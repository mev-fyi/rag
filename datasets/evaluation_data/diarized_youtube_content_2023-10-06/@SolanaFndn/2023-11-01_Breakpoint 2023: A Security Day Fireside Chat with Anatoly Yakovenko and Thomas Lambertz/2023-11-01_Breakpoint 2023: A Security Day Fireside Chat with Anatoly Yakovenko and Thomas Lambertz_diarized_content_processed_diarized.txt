00:00:04.240 - 00:00:11.278, Speaker A: So let's talk about security. What is your favorite thing about security in Solana right now?
00:00:11.366 - 00:00:49.300, Speaker B: Oh, man. Delete all the code, and then you won't have any bugs. I think the rust type system is probably what I think we the strongest aspect of security on Solana. You can write really good rust if you actually put your mind to it. There's very high level tools like traits, and the rich type system can avoid a lot of bugs. But developers do get lazy and under time constraints, ship really bad code sometimes.
00:00:49.492 - 00:00:55.134, Speaker A: Yeah, I mean, we were just at the MeV camp, and they had this amazing t shirt. I'm a fighter, Rust.
00:00:55.174 - 00:00:55.862, Speaker B: Borrow checker.
00:00:55.918 - 00:01:11.274, Speaker A: Damn, Rust got hands. And having just this really amazing meme to just represent the feelings towards Rust, I personally also, Rust is my favorite language, and I think it's really great that Solana is developing in that, for sure.
00:01:13.374 - 00:01:39.242, Speaker B: What I would like to see more, though, is folks try to use tools like Connie or Prousty and try to at least partially verify their smart contracts. I don't think you'll be able to do all of the logic, but I think you should be able to abstract a bunch of the business logic out and have that be verifiable, and then treat the plumbing between the runtime and that part as a separate thing. That would be a lot easier to audit.
00:01:39.418 - 00:02:23.872, Speaker A: Yeah, I think doing verification on whole smart contracts at once is going to be really, really complicated, just because Solana program model is so complicated. But just going with individual parts makes a lot of sense, and that really forces you as well to think about the constraints you have, the individual functions, and just structure it in a way that is easy to verify. What we've been seeing a lot is just stuff with checks all over the place where it's clear they don't have coherent concept of where to put the checks. And I think that would really help. That's the great thing about anchor. It just forces you to put all the checks in the beginning. I think that's actually the biggest win of anchor.
00:02:23.872 - 00:02:29.444, Speaker A: Just like someone forces you to think about every single account and put all the checks at top.
00:02:30.144 - 00:02:51.724, Speaker B: Yeah. Most of the, say, most of the security work in a Solana smart contract is just input validation. And if you kind of have that mindset that I have to validate every bit of input across all the accounts, you're actually pretty far along in writing pretty good code.
00:02:54.224 - 00:03:21.764, Speaker A: Yeah. I've been looking at runtime V two a lot recently, and I think there are some really excellent changes in there. But then again, I'm also a tiny bit scared that the type implementation of inside Solana core is just going to be somewhat off or have some minor bugs. What do you think about that?
00:03:25.504 - 00:04:29.224, Speaker B: The runtime V two is basically using a typed bytecode, which then forces a well defined type for all the accounts and the program as well. And the really cool thing about it is that when you have a transaction and you create the virtual machine for that entire transaction, you can link all the programs together without any runtime checks. You can actually pass all the values because you can validate during that linking time that all the right accounts and everything else are actually being passed by the program code. That's the part that needs to be very secure, and because everyone knows it needs to be very secure, every engineer, every auditor can go look at that code. It can be fuzzed, can have best branch coverage and stuff like that. So I think while you're setting yourself up for a single point of failure, if there's a bug there, it's catastrophic. It is a very small constrained part of the code that everyone can really hyper focus and audit.
00:04:29.884 - 00:04:41.250, Speaker A: Yeah, that's true, that's true. I think even if you get an alternative implementation of fire dancers also doing the type verification, chances of critical bugs there are way, way lower.
00:04:41.362 - 00:05:05.874, Speaker B: Yep, yep. Do you think it's possible to write smart contracts with two implementations? This is something that I've been kind of thinking about. For layer one, it's obvious we have a protocol. Team one writes Solana Labs, team two is fire dancer. Now you have redundancy. You don't have a single point of failure. Can we do that for smart contracts?
00:05:06.774 - 00:05:48.586, Speaker A: I guess we can. Not right now. I think you need a wholly different smart contract language, or at least framework for that to make sense. I don't think it makes sense to write two competing contracts in anchor, because maybe there's some bug in anchor code generation which would then be in both accounts, and anchor forces the same structure in both. I think that's a really interesting idea, to have two programs which you both verify and see the results are the same. That should be possible, and it will force developers to really nail down how the data is structured. And that also might be really helpful for other people also looking at the program, because you no longer have to read the code, but there will have to be some specifications, how the contract works.
00:05:48.586 - 00:05:49.774, Speaker A: I like that.
00:05:50.794 - 00:06:04.054, Speaker B: This is something that the runtime could potentially support. You have in your loader. You define program one and program two literally executes them both, and then make sure that the writable accounts are exactly the same.
00:06:05.154 - 00:06:14.266, Speaker A: I mean you wouldn't even have to do that in the runtime. You could do that right now. You can have via CPI just call both programs and hash the accounts pre and post.
00:06:14.370 - 00:06:20.618, Speaker B: But there's like you have to like deal with ownership, right, of the accounts and stuff like that. It'd be kind of a, you'd have.
00:06:20.626 - 00:06:25.794, Speaker A: To like duplicate state in like both contracts. That's such a cool idea.
00:06:27.574 - 00:06:36.070, Speaker B: Well, if somebody is a security nerd, that would be a fun experiment. To add to the runtime is a second implementation.
00:06:36.262 - 00:07:23.790, Speaker A: Yeah. So I think going into a different topic, token 2022, I think that's also just one of the big topics that's going to change in Solana in the next like probably like half a year or bugs, I don't know, and not even like bugs. I mean, just like the whole concept of having a transfer hook and like having fees associated to transfers and like you're now a pool, how do you deal with that? Like do you just like not allow that? Not allow that in the pool, these tokens? Or like do you allow that? Do you have like special occasions there? I think that's going to be like really interesting for like some smart contract developers and I think we have a lot of work ahead to like create documentation how to use that safely.
00:07:23.942 - 00:08:25.216, Speaker B: Yeah, I agreed. I would be very cautious. If you're building, if you're allowing token 22 in your economic activity pools like markets or whatever, to add the constraint checks to make sure that you're not mixing different assets with real value against user specified token 22 with all the crazy extensions enabled, because I think the surface area there is not well reasoned yet. Be cautious. Some of those attacks you saw in Ethereum because ERC 20 allows you to kind of reimplement, whatever, and then if you have a pool and you're doing like a swap between asset A and asset B, if there's basically an on transfer hook that can take attacks on each one of those swaps, you can probably extract value out of the LP's that way.
00:08:25.360 - 00:09:26.034, Speaker A: Yeah. The thing we've also seen is many contracts that split their implementation up into multiple contracts, they tend to have more bugs because they now need to cross relate ownerships of other contracts and other accounts if they're reading that. And Transahoc basically forces you to have a second contract because you can't recursively call. So that's also going to be something. I think there might be some issues, but overall I think it's going to be an interesting time, but it's going to be secure for sure. What do you think of tiny, denser and all of their ways to improve this RPC security side of things? I mean, there are going to have to be, I think, quite some deep changes in Solana core as well to support all of the features you want there. How do you approach that from an implementation perspective?
00:09:27.014 - 00:10:41.494, Speaker B: You can actually do a lot of this stuff today. If you submit a transaction that has an output account that asserts the state, you can basically check that output account was finalized through like the normal bank cash. And that transaction you imagine is like the thing that asserts like, hey, is my balance x, y or z, or like is my smart contract at this state. So then you can get, you can construct a link of bank cashes to a bunch of votes that show that it was finalized by the quorum, but that gets you to a simple payment verification. But that solves a lot of the attack vectors where you have a corrupt RPC or something like that. What it does if you have a corrupt majority, like the actual quorum is corrupt and they're double signing headers and they're withholding the data that generate the invalid header. This is where you need data availability, sampling and these other tools that have been pioneered by folks like Celestia, and that is a much longer and later problem.
00:10:41.494 - 00:11:16.024, Speaker B: The thing is though, these attacks are possible, but they never happen. There's basically been five years of proof of stake networks with thousands of different networks launched of various amounts of decentralization, literally from 20 nodes to thousands. Like Solana. I can't think of a single quorum attack. And this is because any single honest node can detect a quorum attack. They don't have to be staked. And as soon as that happens, Pagerduty goes off, people's nodes shut down.
00:11:16.024 - 00:12:31.724, Speaker B: It's a very short lived attack that has basically very limited opportunity to extract value and most likely will just cause the network to halt. So there is inherent security in the system that is already preventing that. And when you kind of think of the stack your security surface, when you're signing something, you install the Phantom wallet extension. So you're trusting the Google store, you're trusting Phantom really to implement and store the seed phrase, and you're trusting Phantom to display the transaction correctly before you sign it. At that point, the additional trust of fandom pointing to their RPC node is like very marginal. Even if Phantom used a lite client that talked to the entire network and did all this awesome work, they could just simply just display you junk in their trusted display and you sign something, but it actually drains your whole wallet. So fixing that RPC trust issue doesn't really fix a security vulnerability that's often exploited today.
00:12:31.724 - 00:13:09.024, Speaker B: That's nice to have. I think these things are going to be required when you'll see crypto really start taking over main financial services and be at a much larger scale than it is today. When you are dealing with a very wide variety of services that are global and you kind of don't know who to trust. But we're just really not there yet because everyone kind of operates in some level of trust. You're trusting your wallet, you're trusting infura or whatever, and these things are fairly stable.
00:13:10.204 - 00:14:03.632, Speaker A: Yeah, totally agree on that. Going back to these wallets, something I've been wondering for like quite some time. These wallets, most of them simulate your transaction and basically show you the expected outcome. Why doesn't any wallet really implement that actually with a guard instruction at the end? Wallet could, for example, if you transfer some money, it could just add a guard transaction at the end of the transaction that just checks maybe 10% deviation for some slippage fees. Check. Are all the token balances changed as we expected? Like, that won't catch all bugs, that's not compatible with all the protocols. But I think this is something that wallets could do to really nail down a lot of these attack vectors where you just sign a transaction that says something during simulation and then does something entirely else.
00:14:03.768 - 00:15:17.250, Speaker B: Yeah, this is something that I've talked about before, and that would be really good improvement. But generally this is only a problem if you're talking to an untrusted contract. Yes, and normally users, most contracts are run by some kind of business that's trying to stay open and have revenue or a protocol that's trying to get users, and those things are persistent. So if you use magic Eden today, and Magic Eden is still open tomorrow, they're very, very unlikely to go and update their smart contracts to go fish. All of these things in that window between simulation and execution. So this is really, I think, like a bigger problem during the bull run, when a lot of stuff is launching and people are much more greedy than they're fearful and they like, just click next and everything. I think in that environment, even if you have these guard instructions, I don't even know if people would check that the wallet like, showed him something.
00:15:17.250 - 00:15:22.574, Speaker B: I don't even know if they would register that it showed him that everything's going to drain the human mind.
00:15:24.394 - 00:15:26.442, Speaker A: Make it happen. You have to be fast.
00:15:26.578 - 00:16:00.464, Speaker B: Even if the wallet flashed, don't sign this. This is going to train your whole thing. Confirm again. In that environment, that is, people get greedy and their brain switches off, I guess. I think everyone should have the mental model of always using cold and hot storage, which basically separate your cold wallet. Keep it in the ledger, only use it to do transfers, like simple transfers between the cold wallet and the hot wallet. And then your hot wallet is what you typically would use per project.
00:16:00.464 - 00:16:29.484, Speaker B: A different wallet you should be using to sign things that are less trusted on the Internet. But in general, this is, I think, a human behavior problem more so than a technology problem you kind of see. I think the phantom folks have done a pretty good job adding security features like simulation and then guarding domains and things like that, and using normal web to security to give users that feedback.
00:16:31.424 - 00:16:39.440, Speaker A: Yeah, Guardian domain is probably the more important aspect of that, but you make sure they don't even sign stuff for fake contracts.
00:16:39.592 - 00:17:21.744, Speaker B: Yeah. Nice thing about Solana, it literally does force the transaction to specify what state it's going to read and write. So wallets could simulate transaction and then downgrade all the write locks to read locks if they're actually not being modified, and then display only those changes to the users. You can really increase that. Like, you know, shrink that attack surface. But I'm, I'm very, I don't really believe that that's going to fix those bugs because I'm afraid the users just don't, are not thinking, you know, their, their brains are switched off at that point already.
00:17:22.684 - 00:17:40.464, Speaker A: Yeah, I, I can totally follow there. Like I've done that myself a number of times. It's just like, man, I just want to open this word document. Like stop with these pop ups. Go away. And like cookie banners, just like training everyone to always just click like, go away, go away. Please don't bother me.
00:17:40.464 - 00:18:34.050, Speaker A: I just want to work. Anonymity of the developers of smart contracts. Like I think I'm an auditor and I look at code a lot and I audit the code, but I don't necessarily look at all dependencies because like in rust you have this huge dependency tree and it's really hard to look at it. And I feel like if someone were to want to create a contract that I do not find a bug in, he would probably be able to do that. If somebody was really maliciously targeting me and see how do I make it. This just, even the upgrade, don't find it. And then you also have, because contracts aren't reproducible or like, yeah, they are reproducible if you go for it, but a lot of contracts currently don't go for it with these docker builds.
00:18:34.050 - 00:18:49.934, Speaker A: So I feel like there's a lot of trust required in the developers of the protocol itself. What I've been seeing is there are some protocols which are really just, they are there and there's a lot of money in there. And people trust the protocol because there's money in there.
00:18:50.414 - 00:19:31.082, Speaker B: I mean, there's already a million flexive and bad. These are like the easy red flags that people should be using to filter out which teams are good and which are not. Do they have, are they open source? Do they have a reproducible build? Do they have like, verification would be like the next level. So like, that's very hard and requires a lot of investment, but at least unit testing and fuzzing and all this stuff every developer should be doing. And that's like, you should go through that checklist and be like, okay, this is a good team. This is what I should be using and these are not. But how do you enforce that?
00:19:31.178 - 00:19:52.014, Speaker A: Besides, you talk to people and educate them before you put money in there. Don't look at the TVL, do some basic sanity checks. I don't know. It's a hard problem to solve. I think users just don't want to be doing that kind of work. I mean, you're just like, you want to make money. I mean, there's money to be had.
00:19:52.014 - 00:20:11.166, Speaker A: You don't really necessarily care about these kind of things directly, but I think this is something like we should kind of like talk to users about and like build tools that make it like kind of like easy for them to see that, like some verified flags and like an explorer or like, like stuff like that. But even those are still like imperfect.
00:20:11.230 - 00:20:29.354, Speaker B: So how possible do you think it is to do analysis on the bytecode itself and do fuzzing and simulation to where you can give some machine automated assertions whether this code is safe or not.
00:20:30.214 - 00:21:16.716, Speaker A: We've seen some people do that and we've attempted that ourselves as well. Just like with symbolic execution of smart contract code. Looking at all the inputs, I think that's very possible for these single instructions. Where you have this one instruction is a withdrawal instruction, for example, and then you can verify that it's not possible to get more money out of that than you have currently in your balance or something. These single actions, I think you can verify that. It gets really complicated as soon as you start to have these multi step interactions where first have to create an account which has maybe some settings and then you have another instructions with deposits and there's a third instructions which may be withdraws. And all of this state interacts with each other.
00:21:16.716 - 00:21:49.924, Speaker A: And I think during symbolic execution at least you have this huge state explosion which I'm not sure you can reasonably handle and you could probably fuss that, but even that you'd need to do a lot of custom work for each contract and see how does the initialization work and maybe which fields I want to treat as symbolic. So in general I think that's a too difficult problem to solve all at once. And we should focus on more smaller problems first, if it's even possible at all. What was your favorite bug?
00:21:50.044 - 00:21:51.024, Speaker B: Oh man.
00:21:53.084 - 00:21:57.422, Speaker A: Be it smart contract or like, I don't know, in core or anywhere really.
00:21:57.548 - 00:22:36.788, Speaker B: Oh man, favorite bug. This was during testnet days. I think it was the chorus one guys that discovered it. We booted up. We been doing all this testing on Google Cloud and they have pretty decent network stack and we were using 64 kilobyte frames for the shreds and that was awesome. Performance was great. It was just, we could saturate basically the entire Google network, their internal network, with shreds and TPS.
00:22:36.788 - 00:23:50.754, Speaker B: We had this chart that was showing 250,000 tps and 100 nodes running inside Google Cloud. And when we put it on the open network to get tirade to soul going, none of the 64 kilobyte frames arrived anywhere. Like basically the Internet just dropped them. The problem was that the way that we structured, we really optimized that loop to do verification, signature verification of the frame and then signature verification of all the transactions inside that framework. So when we went through the step of converting that to MTU sized shreds, somewhere along that like refactoring the signature verification for the transactions was dropped. And luckily this developer at chorus one noticed it and created an attack vector that stole all the funds on Testnet before launching. So like, so like stuff like that.
00:23:50.754 - 00:24:02.714, Speaker B: We were just blessed to have like really good folks on testnet actually finding these bugs and yeah, he got a very well deserved bug bounty for that.
00:24:03.054 - 00:24:04.078, Speaker A: That's a great bug.
00:24:04.166 - 00:24:04.834, Speaker B: Yeah.
00:24:06.894 - 00:24:09.134, Speaker A: Thank you anatoly. Thank you, Thomas.
