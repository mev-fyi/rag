00:00:01.520 - 00:00:44.410, Speaker A: I don't know if this font size is large enough for you guys to see, but on my screen I have a copy of the instructions that we sent over for the first project. So we're calling this the Echo program. It's pretty straightforward, but the main idea here is we want to take some data that we set off, chain just some random text, and copy it onto the blockchain. It's a pretty simple operation. There's no complex logic really involved. But I think a big piece of a large pain point in Solana development is figuring out how that first initial interface works. When you have some off chain data or you have some program that you want to interact with, how do you actually get that first transaction working is a huge win.
00:00:44.410 - 00:01:20.824, Speaker A: And what I wanted to do with this program is build an example. That is the easiest way possible to get a transaction working, because that's like the hardest part, I think, to start with. Every other piece of complicated state logic will sort of build on the fact that you're able to send in your first transaction. So that's what the Echo program is. There are five instructions that we're asking to be implemented for the sake of time. Because we're only here for a week, I don't expect that all five of these instructions will be completed by everyone, but I would highly recommend that everyone complete the first three. So that would be the echo instruction.
00:01:20.824 - 00:02:03.424, Speaker A: Initialize, authorize echo, and authorize echo. I'll go over these very briefly in the spec. So, for Echo, this basically just takes whatever string you write and copies it into a buffer on chain. The one requirement is that the buffer, when you call the instruction, should be all zeroed out, so it should have no data inside it whatsoever. And if the data that you pass in, like that string, is longer than the buffer, you only keep the amount of bytes such that you fill up the buffer. Very straightforward for authorize Echo. I want you guys to get started to think about the role of public key cryptography.
00:02:03.424 - 00:02:47.660, Speaker A: I talked in the first lecture about how key pairs allow you to represent ownership. One key benefit of this is that if you can represent ownership, you can restrict access to certain operations to people who own public keys. And that's the idea behind authorized Echo. So when you create an authorized echo buffer, you want to essentially restrict access to people writing to this buffer to only the authority, which is some public key that I called the initialization function. The actual authorize echo call will work very much the same as the initial echo. But the difference here is that the only individual who can call this instruction is the one who owns the key pair with the authority public key. The last two instructions are things.
00:02:47.660 - 00:03:34.694, Speaker A: It's what I called a vending machine echo. This is not a requirement, but it will be really helpful to sort of go over before you start the second project. The idea here is that the access mechanism is changed again. So instead of requiring a person to be the owner of a particular public key, the vending machine echo will require the caller to have access to some tokens that will allow them to access the buffer. So an idea would be like this buffer requires you to have n of some token, maybe like ten USDC. And if you were to actually call the vending machine Echo function, that would require you to burn those tokens. So if you don't have the ten tokens to send to the vending machine, you're unable to call the instruction.
00:03:34.694 - 00:04:07.428, Speaker A: So just another way of controlling access to the echo. These are all pretty contrived exercises, but the idea for all of them is sort of getting you to think about ways in which you can use the different minutiae of Solana programming to build more complicated applications. And we can talk more about this echo project as I walk around the room. But just wanted to give you a sense of the spec. An important thing that I think everyone should read over is the documentation for Borscht. This is the serialization format that we use for this project. All of the docs are in this GitHub page.
00:04:07.428 - 00:04:49.576, Speaker A: Specifically, I want you guys to look at this specification section. This will tell you how these different types are represented in the data itself. Importantly, something that really trips people up is this dynamically sized array object, which is just a vec. I would take very close look at how this spec represents that. So you make sure that when you write that client code that sends data to the program, you're making sure that this representation is valid. And I'm sure there will be questions about this in the discord, but just wanted to point that out because I'm sure this will be a pain point. Ok.
00:04:49.576 - 00:05:39.508, Speaker A: With that being said, I think this lecture will hopefully tie together a lot of the concepts we talked about earlier in the first lecture to sort of really understand how you send data to the blockchain, right? Initially in the first one I talked about this diagram here of how data is transmitted from client to blockchain, and sort of loosely discussed how you build programs and how that data is represented. So mainly I talked about the data, but I didn't really talk about the transactions. Right. These things are important. This is like how you interact with the blockchain. And this is essentially like the program exposes to the user some sort of command line interface that you can provide data to and the program is able to execute against that. This transaction lecture is about how you represent that data.
00:05:39.508 - 00:06:25.584, Speaker A: So how do you invoke an instruction to this complex CLI? So let's talk about transactions. A transaction only has three key pieces. You need the program id, you need the accounts, and then you need the data. The types of these objects are well known. So this is going to be a public key. This is just going to be some list of account metas. And I'll go over this in a second.
00:06:25.584 - 00:07:16.418, Speaker A: This part is really important. And there's also data, and this is just free bytes. So this is just arbitrary length bytes that you pass into the program that you're calling. And this interface is actually what we call an instruction. So all of this stuff here, this is what we refer to as an instruction, just for the sake of writing fewer characters. I'll call transactions TX and I'll call instructions ix. And then you can think of like a full transaction as really just a list of instructions ix.
00:07:16.418 - 00:07:52.984, Speaker A: One ixn. A transaction has the property of being atomic. So when you send one of these transactions to the network, it will go through each of the instructions and run it. But if any of those instructions return an error, the entire transaction will fail. So this is one single atomic block of operations that you're asking the blockchain to perform. And each of those blocks contains this metadata, the metadata that we find here, all of these things. I'll discuss a bit about how this works in terms of what the program sees and what the client sees.
00:07:52.984 - 00:08:28.814, Speaker A: And that really comes down to this whole account meta object, which I'll go into. So what is an account meta? This only contains three fields. This has the key. This is just a public key that represents the account that you're passing in, right? So this is like an address. Every public key will point to an account which may or may not be a data buffer, but this is the address of that potential, that account that the program is going to use to process. There are also two flags that it includes. One of them is called issigner.
00:08:28.814 - 00:09:32.492, Speaker A: This is a boolean, and there's another one called iswritable. What issigner refers to is the public key that is in this key field. If issigner is set to true, that means that this key signature must be found in the transaction. So the transaction object has a number of different things. So the TX object, like I mentioned, it's a list of instructions, but it also has some other pieces of metadata, one of which is going to be the signature. So there's a list of signatures too. So if this is set to true, right? If this is true, right? So if this is true, then this must be found in that list and is writable.
00:09:32.492 - 00:10:28.650, Speaker A: Essentially means whether or not the content of the account that this points to, right? Like this key here is going to point to some account info object. So this is some like actual account. If that account's data changes before and after this transaction, this is writeable. Flag must be set to true, right? If it's set to false, then you would expect that. No, like this, whatever account state was found at the beginning of the transaction has not changed at all whatsoever after the transaction's over. And the transaction will fail if either of these criteria is set to, to the incorrect flag. So if you try to send a transaction that requires you to have a signer, and that signer didn't actually sign for the transaction, like say I didn't actually own this public key and I tried to sign, the transaction will immediately fail because it knows that the signature is missing.
00:10:28.650 - 00:11:21.836, Speaker A: Likewise, if I set is writable to false and I submit an instruction that actually modifies the content of the key, the transaction will also fail. So these booleans essentially tell the runtime and tell the program how these accounts are going to be used. And each of these is going to uniquely represent the arguments or part of the arguments for the instruction of the program. So that's what the account meta is, and that corresponds to this section. So these accounts, and I'll use green to annotate this one, right. The other component that's really, really important is this data. So what that data is, is essentially what the arguments you pass in to this interface to get the program to execute.
00:11:21.836 - 00:12:13.208, Speaker A: So suppose I had a program. So let's call this program a. If program a has a list of like two instructions, right? So let's say the first instruction called foo. The second instruction is called bar, right? If I want to exit, if I want to tell the program to execute foo, or I want to tell the program to execute bar, the program needs to have a way of determining which instruction to use. Like it could have any arbitrary number of instructions, but the program needs to be able to differentiate based on something, like which instruction it wants to execute, right. I know that like both of these will take in some sort of like list of accounts, and you could say like wait, maybe it's a good idea to just like use the account length or something to verify which instruction you can use. Like obviously this is possible.
00:12:13.208 - 00:13:11.520, Speaker A: If all of your instructions take like a different variable length of accounts, then maybe you don't need to specify any data whatsoever to switch between the two or however many instructions you expose. But like functionally, that's probably not a very good interface design. It's nice to have an explicit way to determine what you want your program to execute. And that's where the data comes in. The data, what it represents is it answers two questions. First, one is which instruction? And the second question is what parameters? All of this information is encoded inside here. So when the program receives that buffer of data, it basically knows how to route it to the instruction it's trying to execute.
00:13:11.520 - 00:13:55.448, Speaker A: So if I have a data buffer that's passed in. So I call program a is basically just like some, it's like a CLI. So if I call program a program a and like the input I pass in some data, it knows basically based on the content of the data to either point it at foo or point it at bar. And this is in general true for like all programs. The data is how you determine what action to perform. And the data doesn't include any information about the account buffers that are being written to or accessed, or it doesn't necessarily contain any metadata related to that. It could, there's no restriction on that.
00:13:55.448 - 00:14:42.584, Speaker A: Everything here is just free bytes. So obviously the program id refers to the program that you want to execute. But now we can see that these three different fields is enough information to determine exactly what we want the instruction to do. It tells us I want to run the program that's found at this address, and I want to provide the inputs with this data so it knows what instruction to execute and with what params. And these are the different accounts that it needs to act on. This contains all the information that's needed to do any operation with that particular instruction. The thing that makes Solana programming tricky in many aspects is there are essentially no restraints or constraints on what this stuff can contain.
00:14:42.584 - 00:15:14.074, Speaker A: This is an arbitrary length size data. This is an arbitrary length size account list of counts. There are restrictions on the size of the transaction object itself, but from the perspective of the program, all of this stuff is uncontrolled input. That's dangerous. Like if I take in a list of a bunch of accounts, I don't know what's in this. All I know is that the user passed me this information a user will build a transaction. So it builds a transaction.
00:15:14.074 - 00:16:01.374, Speaker A: It has the program id, it has the accounts, the data. And what does the program do? The program will take this information. So now we have the program here. So it will use the data. So data will point at a particular instruction I zero, right? So it uniquely routes this to a particular instruction, and that instruction at that point. Now it has to process the params, right? So now this instruction I takes in the params from the data and also the accounts. But all of this is uncontrolled.
00:16:01.374 - 00:16:24.044, Speaker A: I don't know what's in here. There's no information that's present at all to the program about what's passed in. The params can be malicious. The accounts can be malicious. You don't know what information is being passed in. And that results in. When you build these programs out for the first time, you need to do a lot of validation, right? You need to validate that these params are valid.
00:16:24.044 - 00:17:07.664, Speaker A: Like, there's nothing malicious in these inputs. The program knows how to deal seamlessly and gracefully with any inputs that are passed in. And it needs to make sure that these accounts are also like what the user claims they are. A very common attack that can be present is just not validating accounts properly and allowing you to do things that are unintentional. And I'll give you a really specific example of something that's pretty straightforward way of how this could go wrong. Suppose I wanted to implement a transfer function, and the transfer function is pretty simple. Suppose it just takes in as data amount.
00:17:07.664 - 00:18:27.158, Speaker A: And then for the accounts we'll pass in two accounts, we'll call it like a source account and the destination account, okay? Pretty simple. So what I'll do, and this lives in some program. So let's call this token tkn. So this is some program that just takes in like amount, source, and destination, right? Imagine I had no checks whatsoever on this, right? And what this will do, like in layman's terms, right, is like source, amount minus equals amount. And then like desk account, amount plus equals amount. So if you were to implement this in a way that didn't consider security whatsoever, this is really, really bad, right? Because what I would do is that I would set this destination account always to something that I own, right? What I would do for ATT and ck, this is me and this is you. And then I'll set this number to something ridiculous, like, I don't know, like 4 billion, I don't know if you have that much, right? But in a system where this was like insecure because all these inputs are not validated, right? And you did something like this.
00:18:27.158 - 00:19:00.830, Speaker A: What you could just do is you could just call arbitrary code on arbitrary input, or, sorry, you would call very specific code on arbitrary input, which is dangerous. And a big challenge of Solana programming is how do you design around these constraints, because all you're being passed is unvalidated input. And so you have to be very careful about this kind of stuff. That's the main idea. Ok, so we talked a bit about these different fields in the transaction. We have it as a list of instructions. Each instruction has these different fields to them.
00:19:00.830 - 00:20:08.026, Speaker A: The account meta object, what we need to do with this is essentially something happens after it's sent to the JSON RPC. So just reiterating on that first diagram I drew, I'll just draw again real quick, client JSON RPC and then program. Okay, so in this stage, right, when we're setting this over here, all of our accounts are in the format of account meta. And here we work with objects that are account info. So something that happens in this like black box here, right? Like what we don't know is this transformation occurs, right? There's some magic that turns this thing into that thing. And once we know that this happens, we don't really need to know much more. If I look into the token program again, I think I have that open in some window or I think I had something open.
00:20:08.026 - 00:20:42.882, Speaker A: Let me go into the processor. Let's go and take a look at the struct again. The source code is large enough. Okay, great. So this accountinfo object has all of these fields, right? Like you can kind of see that. Like these account meta fields that I mentioned before, the key is writable and signer, those have basically just been copy pasted into this object, right? And the rest of it, the things that we actually want to work with are found here, the LAN ports, data and owner. Or really the only things you really care about are like mostly this one, sometimes this one.
00:20:42.882 - 00:21:39.868, Speaker A: But almost everything's found in here, right? So in a sense, the idea behind this account, the account meta object, is a way to take these three fields and index it into some data. And that's what you need to pass in from the client code when you write it. Yeah. So this is how transactions are generated, right? Transactions are just lists of instructions. And the way that you send instructions to the blockchain is through an RPC call called send transaction. What this will do is it will take in a bunch of inputs and then somehow broadcast it over to the program that you're trying to execute. I won't go into explicit detail and how a transaction is formed.
00:21:39.868 - 00:22:14.914, Speaker A: All of this stuff is inside the documentation if you want to take a look at it. It's pretty complex, and there's a lot that I'm glossing over. In a sense, Solana will try to take that transaction and make it as densely patched as possible as a way to save bytes. None of that is super important. Luckily, if you're using any of these client side libraries, all of that will just handle the complex logic of serialization for transactions for you. So this is not really something that you'll have to worry or think too much about. It is important to note that the transactions have a size limitation.
00:22:14.914 - 00:22:45.894, Speaker A: I don't know if it's present in the documentation, but I guess I'll just write it down here. Just so you guys know, a transaction can't really exceed over 1.2 kb. So currently I think there's plans in the works to increase the size, but the size limitation has to be less than 1.2 kb approximately. I think it's a little bit larger than 1.2, but it's important to know that the transaction option is somehow limited in what you can do with it.
00:22:45.894 - 00:23:29.910, Speaker A: With that context. I want to go back a bit to that client program I wrote that interacts with counter because maybe that might provide a little bit more color in what's going on in this particular program. So there are a number of instructions that I wrote here that allows me to actually access that counter object, right? The first one here is the create account. This is the first instruction. So that would correspond to just because the transaction itself is a list of instructions, this is the first thing that gets executed. The second instruction is the one that actually increments the counter. That's the one that I implemented here.
00:23:29.910 - 00:24:05.134, Speaker A: Notice that this keys program id and data. This is just your account meta object. In fact, if you look at the transaction instruction object in JavaScript, they call this an account meta. It's this exact same keys, exact same format. Every instruction you implement and every instruction that you send to the blockchain will somehow follow this format somewhere down the chain. What's nice about some of the pre built libraries is it will do some of that serialization for you. So under the hood, if you look into this create account, it doesn't tell you exactly, it might actually tell you exactly how it works.
00:24:05.134 - 00:24:47.684, Speaker A: Not quite. Somewhere in the actual implementation of the source code, it is just doing this and that's how everything is structured. Right. The last thing I want to show you guys is just how to read and think about logs that you find on the Solana explorer. So I'm going to run this code again. We'll see the count increment from two to three, and then the explorer link that's exposed. I'm going to take a look at that and sort of show you how to process that input and how you can use explorer to debug transactions.
00:24:47.684 - 00:25:16.726, Speaker A: Great. There it is. Perfect. Great. So we can see the different keys that are passed in here. One important thing to note is that this address here is the fee payer. It's not found at all.
00:25:16.726 - 00:25:39.706, Speaker A: This 42 address isn't found in the actual instruction, but is used to pay the transaction fee for the transaction that's been sent. Right. I mentioned in the first lecture that Sol has two purposes. The first one is to allocate account space and pay rent. The second purpose is to, uh, provide transaction fees. Right. Pay for the transaction fees of the, of the instruction that's being executed, um, or the transaction that's being executed.
00:25:39.706 - 00:26:12.474, Speaker A: Um. And that's what this is. Right. It pays a fee of 5000 lamp ports to execute the transaction. And the other public keys that are passed into the instruction, um, correspond to both the program id, which is this one, and a writable buffer, um, which corresponds to the actual counter. And then your program itself can emit logs that can help you debug as well. So one quick thing I want to show you guys before I hop off here, is showing you how you can potentially show some more logs inside your program.
00:26:12.474 - 00:27:09.104, Speaker A: The macro that you want to use is this MSG macro that's part of the Solana program. Everything that you write here will be emitted inside program logs on Explorer. So if I wanted to write what the current count is, so current count, I could just do something like this. Updating count. Okay, so if I deploy this program first I need to recompile it because I updated the source code. It will build out this new binary file. I'm going to call Solana program deploy to upload this to Devnet.
00:27:09.104 - 00:28:03.644, Speaker A: After it's been uploaded, I can run the CLI again. Go to Explorer and we'll see that this log will show up there. So that log that I wrote in the source code updating count to four, is now present in the Explorer logs. So this is a good way to debug programs. Sometimes if you're really stuck, you see that your transaction failed. You want to figure out where in the program, everything started to break. Adding this is basically adding print statements, and you can use Devnet as a way to do this.
00:28:03.644 - 00:28:53.224, Speaker A: Another resource that could be potentially useful instead of running things against Devnet is using your local validator. That's something that you can do fairly easily by just running the command Solana test validator work now. Cool. What this will do is spin up a local instance of a Solana validator, and this will expose the RPC URL of pointing to your local host. And then when you upload your program, you can just change the destination URL that you're uploading to. And now you can test against this local validator. So when you write your client code, instead of pointing at Devnet, you can change the RPC URL to point to your local host.
00:28:53.224 - 00:29:33.502, Speaker A: And that can make a lot of debugging easier, especially if you're getting rate limited. Working with the public Devnet server, I can give some more details about how to do this, maybe write a script and post that in the Discord channel, if that's helpful. But I think that's all I have for this lecture. I'm going to open up the floor for questions regarding any of the content or the project. Yeah, so the question was about rate limiting on Devnet. I think for the most part there shouldn't be a huge issue from interacting with Devnet. However, because there's so many people here and I think we're using the same Wi Fi.
00:29:33.502 - 00:30:35.280, Speaker A: I would recommend that when you develop programs using local validator might be more fruitful in making sure you don't get blocked by sending transactions or making queries. Any other questions? Where should you start? Where should we start for the project echo first instruction? So is the JavaScript code ready to go? Yeah, all of that code, the skeleton code. You don't need to write a client for the first instruction. I implemented that for you guys, so you can just use that and play around with it. But the challenge would be how would you implement the rest of the project? The different access gated instructions. So for the first project, one thing that we built out is an auto gridder system. One thing that we'll be doing is that in the project one discord channel, we'll be posting a link to a Google form survey where you need to fill out information related to the project submission.
00:30:35.280 - 00:31:02.964, Speaker A: Once you do so, we'll be running our autograder on a time interval, maybe once every 30 minutes. It will send you an email with the results of the test cases that ran against the project it's possible that those tests will go to your spam folder. So if you don't see the email, be sure to check that out. Cool. Last chance for questions related to lectures or project. Okay. If not, then good luck.
