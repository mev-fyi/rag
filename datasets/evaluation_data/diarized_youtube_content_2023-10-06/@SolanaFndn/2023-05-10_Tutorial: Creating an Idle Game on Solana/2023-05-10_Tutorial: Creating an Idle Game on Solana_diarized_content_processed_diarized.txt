00:00:00.440 - 00:00:39.614, Speaker A: Hello everybody. I found a cool new tool which is called clockwork. It's an open source tool which lets you trigger certain transactions in the future, depending on certain triggers. But in the use cases, they didn't have gaming, so I thought I'd build a little game around it. It's an idle game which is called Lumberjack, and it will collect wood over time every 10 seconds. So the first thing we're going to do is we initialize our thread and the game data account. And here you can see already that every 10 seconds I will get one vote from this little lumberjack here.
00:00:39.614 - 00:01:21.376, Speaker A: And how this works is that clockwork creates a thread. So basically we create the thread, and then clockwork has this worker network which takes the soil from our thread, where we transfer some soil in, and then it uses this soil to trigger transactions on our program. And we can paste the thread id here into this clockwork tool. And then we can already look what's happening here. So we can see that every 10 seconds this thread is performing some transactions. So let's look at these. And here we can see that this transaction is giving us some votes.
00:01:21.376 - 00:01:50.064, Speaker A: So it's calling the on thread tick instruction on our program. And here on the top, we can see that our thread paid 0.006 soil for this. So this is a little bit more than a normal transaction would cost. And the reason for that is that 0.001 soil are getting paid to the worker network for performing these transactions. And you can actually run your own worker if you want to make some money with it.
00:01:50.064 - 00:02:22.248, Speaker A: So you can like run your own worker. And then your worker would perform these transactions where you need to have a geyser plugin on your validator, but you can do that. And now let's look at this worker and see what else it does. So we can see there's tons of transactions that it does because a bunch of people are using it already. So we can just have a look what these are doing. This one, for example, is the eight vote instruction from our program. This is the seven word from our program.
00:02:22.248 - 00:02:46.244, Speaker A: This is as well. So I think I looked at the wrong one. So let's look at this worker here. So let's just open a few of these transactions and see what they are actually doing. This one, for example, is moving a mega piece. So this also looks like some kind of game. Maybe this one as well, and this one as well.
00:02:46.244 - 00:03:15.554, Speaker A: And this one as well. And this one as well, and this one as well. So there's, but there's like lots of different programs using this already. So let's look at how this works. So in the meantime, we already collected 16 wood. So what I can do now is I can just take ten of these wood and transfer them to convert them to gold. And then I can use this gold later to upgrade a lumberjack.
00:03:15.554 - 00:03:53.338, Speaker A: But first, let's look at the code of how this actually works. So this is an anchor program. And I created the Solana Dapp scaffold again, so you can just write NPX Solana create Dapp, and then your name, for example, idlegame. And this will conveniently create your anchor program. And next JS client so you can use this to easily get you started for building something. And now let's look at this code here. This is written in anchor like I said.
00:03:53.338 - 00:04:21.754, Speaker A: And on the top we have the game data struct. So we have an authority, we have wood, we have the amount of lumberjacks we currently have. Then we have gold, we have the teeth upgrades. Because if you upgrade your teeth, you get better wood and then you get more gold for the wood that you are selling. And then we have have updated ad here. We set it always to the current Unix timestamp to be able in the client to calculate when you would get the next wood. Then we have some error codes here.
00:04:21.754 - 00:04:46.952, Speaker A: You don't have enough wood, you don't have enough gold. And then here we have the balancing. So first we have like wood per cell. So you need ten wood to sell wood basically. And then you have, you get five gold for that and you get another. This is the multiplier, two times the teeth upgrade on top. So if you have a teeth upgrade of five, then you would get 15 gold for ten watt.
00:04:46.952 - 00:05:10.386, Speaker A: And then here we have the cost for the teeth upgrade. We have the cost for buying a new lumberjack. And then we have here the thread tick time in seconds. So we want our three, our tick to tick every 10 seconds. And then we have some seeds here. And now in the initialize function, let's look at how this thread is actually created. So first we set some default values in our game data.
00:05:10.386 - 00:05:37.144, Speaker A: Like we want to have one lumberjack shopping wood. And we have teeth upgrade one. And we set the game data authority to the payer. In this case this would be our backpack wallet. And then we set the updated add time to the current time. Then here we create the instruction that the thread will call on our program. So for that we need to pass in the accounts, in this case is the threat tick accounts.
00:05:37.144 - 00:06:08.892, Speaker A: And we need to pass in the instruction data. So let's first look at the threat tick accounts. This is our game data account. This is derived from the seed game data and our game data authority. So in this case our backpack wallet. Then we have the threat PDA and we have the threat authority. Threat authority is also a PDA which is derived from our game data authority, and the thread is derived from thread id and our thread authority PDA.
00:06:08.892 - 00:06:39.574, Speaker A: So and now let's look at the instruction. So the instruction is here, where is it? On thread tick and onthreadtick. So every 10 seconds this worker network will call this instruction. And all we do is we add some wood to the wood field in our game data. So in this case we always add the amount of lumberjacks. If you have one lumberjack, you get one wood. If you have two lumberjacks, you get two wood.
00:06:39.574 - 00:07:12.340, Speaker A: And then we set the updated time to the current time. So this is everything that the thread actually does on our program. And now let's have a look on when this is triggered. So clockwork provides you a bunch of different triggers. What we did here is we used the cron annotation. So how this works is here you can see the different crunches. The easiest is to just look at the examples, actually, because they're quite complicated to figure out.
00:07:12.340 - 00:07:54.914, Speaker A: So for example, what you can do is you can fire your thread every Wednesday in the month of March at 10:00 p.m. For example. And what you could use this, for example for is you could start certain events in your game. So we could say like every Wednesday for 24 hours, everyone in the game gets double the amount of wood. It's like the super wood event. Or you could also use it for staking, for example, like you take your NFT, you put it in the program, and then you say, every week everyone who staked with this program gets 100 tokens or whatever. So the possibilities are basically endless.
00:07:54.914 - 00:08:36.906, Speaker A: Let's continue in the code here. The next thing we do here is we create the thread. So this is basically a cross program invocation to the clockwork program. And what we put in is we put in the program the clockwork program, and then we put in the thread create accounts. So this would be the payer, the system program to create the thread. Then we put in the threat and the authority, and the signer will be the string threat authority and the payer. So the nice thing here is that the payer is actually the owner of this threat.
00:08:36.906 - 00:09:03.338, Speaker A: So the player could, whenever he wants, he could pause the thread. He couldn't stop the threat and get his soul out of the thread again. But you already see that this might not be the perfect solution for building an idle game, because it of course costs a bunch of sol. Like every transaction every 10 seconds will cost 0.005 sol. Actually six. And 1 million transactions would cost you five sol, usually.
00:09:03.338 - 00:09:49.936, Speaker A: And if you use this worker network, then it actually would cost you six sol because the worker network takes a little fee. But for a game like this, like as an example, it's, yeah, it's just, it's a great tool that you can use. You could also use it, for example, if you have like a big map in your game where people run around off that you could use it to every 30 seconds spawn some random treasuries on the chest, for example, on the board. The next thing we have here is the amount of salt that we transfer into this thread. So this soil is used to pay for the fees, and if the count is empty, then the threads will fail. So you need to fill it up with some soil again. Then afterwards.
00:09:49.936 - 00:10:32.878, Speaker A: Yeah, and this is already the creation of the thread, actually, like we put in the trigger here, the thread id, and all the other functions here are just normal anchor functions that control the game. So for example, I can trade wood for gold. Here is a little check if I have enough wood, if I don't have ten wood to sell, then it would fail. And then afterwards we just subtract the wood that you need to sell from the wood. And we give the player some gold, depending on his teeth upgrade. And then here you can upgrade your teeth if it just costs some gold, and you can buy another lumberjack, this will also cost gold. And then you get here another lumberjack added.
00:10:32.878 - 00:10:50.664, Speaker A: And let's go back to our program. If we already have enough gold, maybe. So we have 53 wood already. So let's trade some more wood for gold. And now we have 14. And I think we need two more. We need 25 gold to upgrade our lumberjack.
00:10:50.664 - 00:11:20.044, Speaker A: So now we have 28. So now if we buy another lumberjack, now we have two little lumberjacks here chopping wood for us. So let's see if in the end maybe have enough gold to upgrade his teeth as well. So in the meantime, we're going to look at the client code. What we do in the client is let's first go to the init instruction. So when we click on init, that was the very first thing that we did. We create a new thread.
00:11:20.044 - 00:11:56.904, Speaker A: So we call initialize on our program, and we put in the thread id. The thread ID is just a string that identifies our thread PDA. And this thread PDA has an authority saved which is our wallet. And this can later be used to close the thread or pause it or so on. Then the rest of the accounts is just the payer or backpack wallet. Then the system program to create the account, the clockwork program, then the threat address, the threat authority, and the game data PDA. And then we just sent the transaction off.
00:11:56.904 - 00:12:27.434, Speaker A: Let's now look at how these are created. So this is an effect which is triggered every time the public key changes. And in this effect, I create the PDA's. So the game data PDA is derived from the game data string, the public key, and the id. Game program id. This is just usual like you saw in the other games as well. Then for the thread id, we just take game data and the public key.
00:12:27.434 - 00:12:47.904, Speaker A: So you might want to go to eight here so you don't have any conflicts. But I think it's per user anyway. So probably it doesn't really matter. Then we set the thread id. The authority is the string authority and the public key. This one is the authority of the thread. So this one will be able to change the thread.
00:12:47.904 - 00:13:10.856, Speaker A: And then we have the thread address. And then we set these. And yeah, all the other things in here are actually only to normally interact with the anchor program. Like the upgrade of the teeth, for example. Maybe let's look at one more. Upgradeteath is just upgradeteath. And here we only need the game data and the signer.
00:13:10.856 - 00:13:42.926, Speaker A: So this is basically here just a game action. All we need is just the game data and the signer. And then maybe what we could still look at is how this timer is calculated. So this is an effect that has an interval which every second calculates the new time. So it just takes the last timestamp from the program. In this case, we need to get the block time. So this is on chain time.
00:13:42.926 - 00:14:07.914, Speaker A: We can't just use datetime now. And then we take this timestamp and we subtract the last lock in time or the last updated time from the thread. And then we just set the next energy here. And on the bottom we then count this counter down. So yeah, now we have enough wood, we can sell some more. But I think you can just try it out yourself. So it's deployed.
00:14:07.914 - 00:14:54.196, Speaker A: The program is open source, so you can try it out. I think the possibilities, what you can build with this are kind of endless for games. So you could, for example, if you have like a strategy game you could trigger an automatic update on the program as soon as the building is finished, or you can spawn random monsters on the map with this and all the clients just need to update themselves. So yeah, I would recommend you to try this out and I will put the comments to the links to the repository and to clockwork in the comments down below. And if you have any questions, let's put them in the comments and I will try to answer them in the next video place. See you guys next time. Bye.
