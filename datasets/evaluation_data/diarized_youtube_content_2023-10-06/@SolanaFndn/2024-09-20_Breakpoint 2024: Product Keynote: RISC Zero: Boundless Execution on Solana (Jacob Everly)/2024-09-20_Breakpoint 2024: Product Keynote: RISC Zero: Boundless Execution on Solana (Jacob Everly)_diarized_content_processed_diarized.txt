00:00:04.520 - 00:00:44.233, Speaker A: Nice to see everyone excited to continue to like expand on the CK stuff going on Solana. The title of the talk is Boundless Execution on Solana. First of all, let's do a little bit of a history recap. In general, blockchains are kind of in this dilemma of security, throughput and decentralization. And everyone kind of make trade offs, right? So you can have like higher hardware requirements, more or less node operators, different sort of execution limits and different sort of block frequencies. In general, when you think of execution on a blockchain, you're constrained by the smallest node. Why? Because that person has to like keep up, continue to execute transactions.
00:00:44.233 - 00:01:18.079, Speaker A: With ck, we get boundless execution. Instead of being restricted by the smallest node, we become a sum of them all. With CK you can have really brief verification that someone's done an execution correctly. So if someone wants to generate and you know has 30K GPUs, they can do 30,000 GPUs worth of verifiable execution. If someone has 100, then you can do 100. So you kind of get this really nice property that you can just do a lot more execution. Let's do a really brief history of ZK in general.
00:01:18.079 - 00:01:50.831, Speaker A: I think ZK has been talked about this like holy grail technology. More on the Ethereum ecosystem side since 2015, 2016. I think it's kind of obvious that there's not many applications live today. Real quick, just mention here, when people mention CK normally, they're normally talking about verifiable compute. That's a syncness re verification factor of it. You can add privacy on top as well. So why are there no ZK applications? Right? Well, ZK is a little bit broken.
00:01:50.831 - 00:02:20.514, Speaker A: Performance has not been there, but there's been a lot of research around it. It's been inaccessible. The example I always give is currently you have to write these ZK circuits. Most of you can probably code the game of chess in a high level language. If I ask you to code the game of chess represented by polynomials, probably less accessible. And then there's also like an ongoing maintenance and security issue. If you ever need to change your ZK program, you normally have to change a large portion of your program.
00:02:20.514 - 00:02:55.944, Speaker A: These circuits also really hard to one audit and make secure in the first place. So RISC0 fixes ZK development. All you need to know about this is we essentially made a ZK circuit that looks like a cpu. We can take Rust code, compile it down to a RISC V binary and generate a proof that this code has been executed correctly. So what does this mean for a developer? Right, it becomes really usable. Okay, so you just write programs in Rust. You can use 70% of the most popular Rust creates inside the ZKVM.
00:02:55.944 - 00:03:16.391, Speaker A: Your development time is 1000 less. You don't have to worry about. You don't have to worry about the security as much and the maintainability. If you want to change your program, you just change the line of rust and you're getting it going. You don't have to get your circuits audited. And then you get this boundless proof part of it. We have this other innovation called continuations.
00:03:16.391 - 00:03:47.753, Speaker A: We can kind of just generate proofs for infinity. So we kind of like stitch them on the back of each other. So let's talk right, like why should a developer care about becoming boundless? I'm going to share some examples that are all being worked on today by partners. First you get like boundless skeuomorphic execution. Today execution in ZK is cheaper than anything on chain. We can verify a Dex swap for a tenth of a cent inside the zkbm. So you know we have like roll ups.
00:03:47.753 - 00:04:24.311, Speaker A: There's some people on Solana looking to do using our ZKM from network extensions coprocessors. Unfortunately this video is not loading. We actually ran the original version of Doom inside the CKVM with rendering. There's the picture. Now next you could do some more like complex trading strategies. We have one partner, not specifically Tokamak, but you could track a moving price average over a month across multiple assets, across multiple chains, doing way more expressive things. And lastly we can start to bring in Web2 infrastructure on chain.
00:04:24.311 - 00:04:49.265, Speaker A: So here's a good example. We can do like sort of like ZK login with the Gmail we generate a proof that you actually own a JWT token. We can also do this with OAuth tokens, Twitter logins. You can find this example on our website. So if you would like to figure out more risk zero, you can find all the ZKVM documentation on the left. And then we're building a protocol. We're calling it the verifiable Compute later.
00:04:49.265 - 00:05:03.215, Speaker A: It lets any chain elastically demand on execution. You can think of it a lot. You know how just how chainlink brought price feeds to every chain. We're going to bring ZK to every ecosystem. Perfect. Thanks guys.
