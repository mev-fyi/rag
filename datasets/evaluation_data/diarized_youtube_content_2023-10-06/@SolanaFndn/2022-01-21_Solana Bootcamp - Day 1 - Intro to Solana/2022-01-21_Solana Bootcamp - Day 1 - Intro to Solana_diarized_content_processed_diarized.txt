00:00:05.080 - 00:00:29.936, Speaker A: So we're going to get started now. As mentioned before, if you don't have your webinar set up, it will be projected on this screen. So you can come up here to take a look at the notes I'm taking. Otherwise, just look at your computer screens, and I'll be okay. I will have to ask that if you're in the room on prem and you're opening the webinar to turn your speakers off so we don't hear the echo. With that being said, let's get started. Welcome to Solana Bootcamp.
00:00:29.936 - 00:01:08.914, Speaker A: My name is Jerry. I work for Solana Labs. Today, for the first lecture, I will just be going over the basic Solana programming model and account structure to sort of give a general overview of how the blockchain works and how to build your first decentralized application. A note to be made about these lectures is that primarily, it's a way for you to gain intuition about how to write Solana programs. It's not going to be a super comprehensive way to write your first decentralized app. Much of that will be on your own through our project based system. Throughout the course of the bootcamp will have two projects that you'll be working on sort of independently, and this is meant to supplement the material that you'll be learning while building those projects.
00:01:08.914 - 00:02:28.133, Speaker A: With that being said, I'll just give a quick overview of what Solana is and how you should be thinking about it conceptually. The first thing I want to talk about is the goal of Solana programming. So, I think of Solana programming a lot like writing a CLI. You have some inputs that you're passing to the network, and the network will process it, right? So really what you do is you take in user input, and you process that to modify on chain state. This probably doesn't make a lot of sense at this moment, but I'll be going over some diagrams to demonstrate how this works. So, the basic architecture of how you interact with Solana is you first have a client program. This is something that's exposed to users through a web application or a CLI.
00:02:28.133 - 00:03:32.984, Speaker A: This will make requests to something called the JSON RPC, and this, in turn, will route the data that you sent it to some program that lives on chain. As mentioned before, the goal of taking in this input is to modify some state that actually lives on chain, and that's what this program will write to. This state is held in objects that we refer to as accounts. So this is the overall interface, and I'll annotate it with a bit of to provide some more color on how this all works. The client code is language agnostic. So this is like language agnostic. This you can write in C, rust, JavaScript, Python.
00:03:32.984 - 00:04:18.798, Speaker A: It doesn't really matter how you write your client. This is just sort of a user facing application that's readily available and usable by someone interacting with the network. The JSON RPC is kind of the middle layer that routes whatever you send from the client eventually to the Solana program. And this is done through objects called transactions. So this is a transaction, and generally I'll abbreviate this with TX. So the client will send a transaction to JSON RPC, and this transaction will get routed to the Solana program, which processes the input from the transaction to modify the state of some account. So that's the write flow when you're writing data.
00:04:18.798 - 00:04:56.814, Speaker A: So this is just like, I'm going to write this as a write operation when you're writing data. This is done through sending transactions to the JSON RPC, routes it to the Solana program, and modifies the state of some account. There's also the opposite direction where once you've written that data to the account state, you can request it back to the user. So this would be like a request. So this is like the data from the account can be flowed back to the client. And this is another interface that's implemented by the JSON RPC. I'll go over that spec with you guys very quickly in a separate screen.
00:04:56.814 - 00:05:53.486, Speaker A: Okay, great. Okay, so in the documentation on the official Solana website, it lists out all of the different RPC APIs. You can think of this as just your traditional rest API. These are just endpoints that you send post requests to, and they'll send data from the RPC host back to your client. And this is how you gain information or get information from the blockchain. So the most useful of these commands is Getaccountinfo. This will just take in some parameters, like the pub key of the object, primarily, that's what you want to query.
00:05:53.486 - 00:06:29.984, Speaker A: I'll go over all of this in a second too. So if this is all confusing at first, this will be covered in more detail. Very briefly, after this section, you pass in this input, and then you'll receive data back on your client side. And this will also be demoed as well if this doesn't make any sense right now. So that operation there corresponds to this read. So this is like a get account info, info. And this is how data flows back from the Solana program into your client.
00:06:29.984 - 00:07:27.734, Speaker A: How I'm going to divide these lectures up roughly is that in the first lecture I'm going to talk about the layer where we do the writing. So, beyond the JSON RPC into the Solana program. This is kind of like where all the blockchain magic happens. All the data that's provided is routed here, and then some process is going to happen. And these are the rust programs you're going to write. So the Solana program is written in rust and compiled down into EBPF, which is just, sorry. Which is just the format in which the data is stored on chain for the programs.
00:07:27.734 - 00:08:13.574, Speaker A: I'm going to talk a bit about how accounts are organized, and I'll come back here very briefly after this. Okay, apologize for my notes. Screen lagging a bit. But everything is an object called an account. And really what this is, you can think of it like a file. Accounts are indexed by a public key, which is just a 32 byte string. Usually this is encoded in a format that we call base 58.
00:08:13.574 - 00:09:07.346, Speaker A: So it might be some random strings with letters and numbers. So I'll just write some letters and numbers down. This is like the address to an account, which is just a data buffer. I think the best analogy here is that this is pretty much equivalent to a file on a normal file system. So normally for your file, your index would be the file name, something like star text. And this points to some file object which contains all the content of the file. So this is how everything's represented.
00:09:07.346 - 00:09:48.304, Speaker A: These addresses are going to point to data buffers, and all addresses are represented as these 32 byte strings. There are some special properties to the string, too. So the solana accounts are represented, or the key pairs, or, sorry. The public keys are represented as half of a key pair. A key pair is a 64 byte object, and it's organized in this way. So you have byte zero here, and you have byte 64 here in the middle. This is the halfway point.
00:09:48.304 - 00:10:51.806, Speaker A: The first 32 bytes of this object are what we refer to as the private key, or the secret key, also known as the private key. I'm going to abbreviate this as SK. The latter 32 bytes is what we call the public key, and I call this PK. So the nice property that this has is that there are a couple things that you can verify with just knowledge of these two, these two keys. It's always true that Sk maps uniquely to a public key. So this is, like, unique. That's one important property.
00:10:51.806 - 00:12:17.450, Speaker A: Let me make this a little bit cleaner. Another important property is that you can verify whether or not a public key has signed for a transaction or like a message using the signature function. So I'm going to write just some notation here. If you have function that's or even output called hash that's equal to the signature on some message with your secret key. There's another function called verify that you can call on this hash with the public key, and this will return true only if the secret key signs. So what's nice about this is that using key pairs and public keys to denote addresses, you have a way to sort of represent ownership, right? So that's the key concept here. I know that if I sign a particular message with my private key, I can verify that, right.
00:12:17.450 - 00:12:57.864, Speaker A: You can take the hash that was outputted by that signature and check it with the public key. And now you're guaranteed to know that this public key was signed for. So the person who signed the message has access to the private key of that key pair. And just to be clear, again, these public keys are used as the addresses. So this is like an address to these account objects, which I described earlier as data buffers. And I'm going to go into that a little bit more now. Right, so we use public keys to access these data buffers.
00:12:57.864 - 00:13:38.884, Speaker A: And then now I'm going to go into the architecture of what this account looks like. There are a couple fields that exist on this. This is just like a struct that you would find. Or when you work with this in like rust, for example, this is just going to be some struct that you use. I think that's going to be on this page. Open up this code. When you write your rust program, one of the most common objects you'll be working with is this account info object, and these will be the fields that you interact with in an account.
00:13:38.884 - 00:14:06.014, Speaker A: There's a key, there's two flags to represent whether it's assign or writeable. We'll go into this. There's the lamp ports, which represents the sole content, the data. This is the most important aspect. This is just the buffer itself, the owner, and whether it's executable. This is not super important. I will go over these fields in a little bit more detail, but this is how the data is represented to you when you actually run the program.
00:14:06.014 - 00:15:02.894, Speaker A: So I'll discuss a bit the contents of all of those elements. Here we have the owner, and this is just going to be a public key. And this represents the program. Wow, this is not working properly. That has write access to this account. You have the data. These are just the raw bytes that the account contains, right? So this is just byte array.
00:15:02.894 - 00:16:01.444, Speaker A: So this will contain all the content of the account. You have the lamports, which is the smallest denomination of Sol. So a LAN port is kind of like the equivalent of a satoshi for bitcoin. And this is going to be represented as like an eight by integer. So this is going to be a U 64. And the conversion factor is that there are 1 billion LAN ports in one soul. Another important field in the account is the executable flag, and this is just a boolean.
00:16:01.444 - 00:17:14.024, Speaker A: So as I mentioned earlier, everything on Solana is represented as account, and that includes programs, right? So programs are just a special type of account where this executable flag is set to true and the actual content of that account contains that executable file that your code is executed against. That's just a special kind of account. And for accounts that contain purely data, the owner of those accounts will be set to the program id. So the public key of the account that contains the program. So there's basically two types of things that you can represent, right? So this determines whether or not, like, is this a program program? Another feature that accounts have, you might ask why accounts will have land ports in the first place. In the Solana model, the data doesn't necessarily come for free. So when you want to allocate more data to an account, there is a fixed lamport cost or a fixed sole cost that's required to create that account in the first place.
00:17:14.024 - 00:18:08.294, Speaker A: So if I were to try to allocate an account that has some fixed size greater than zero and that account has a landport balance of zero, it would be impossible to do anything with this data. So if you want to allocate an account with real size, you need to provide it lan ports. And that's a concept that we call rent. So rent is like paying for space with Sol. And this is sort of like the high level of how these accounts work. I want to go into a bit of an example of how you might actually interact with one of these things and how it lives on chain, because I think that might clarify a lot of things a little bit more. So let me go to an example here.
00:18:08.294 - 00:19:13.674, Speaker A: Here I have some source code in Python where I found an example of a public key that's available on the Solana blockchain. So let me go to explorer. This is a public key that represents a token. So this represents USDC, which is a mint. As soon as this loads, it might take some time. So in this public key, there's some data that represents metadata related to this particular token, and I can show you exactly how that's organized in memory and also decoded from the blockchain by running a series of commands in Python. So what I'm doing here is I'm making a client that connects to this Uri which will allow me to send transactions and requests the JSON RPC notice here I'm calling this Getaccountinfo function, which corresponds to that API call that you see in these documents here.
00:19:13.674 - 00:19:54.580, Speaker A: If I print out the output, we see that we get a bunch of information, like I mentioned before. So we have the data, we have the executable, we have the LAN ports, and we have the owner in my slides here. Apologies for the poor handwriting, but we see that I wrote down these fields as well. You have the owner, which is the public key, the data, which is some byte array. You have the LAN ports which are necessary for storing the data, and you have whether or not this account is executable. So if I print out the data, you just get some raw encoded bytes. These are encoded in base 64, and that's a function of how this get account info works.
00:19:54.580 - 00:20:45.614, Speaker A: It is also displayed to you in the data value, like the return encoding of the data format. This is base 64 here, so I know that it's base 64 encoded, and if I want to decode it, I can just call some helper functions to do so. Now I have some raw bytes. So now the question becomes, how do I interpret this information? I have made a request to the network. It's given me back some information, just telling me what the account contains. But how do I make any sense of this data at all? So the source code that you can look at is all available in all the source code is open source, and you can go to the Solana program library to figure all this stuff out. Let me see if I can find an example of where I use this stuff.
00:20:45.614 - 00:21:15.230, Speaker A: I might just go to the source code. That's the easiest place to look. Yeah. Ok, so I know that this particular object belongs to the token program. Normally when you work with these objects, you'll know what program they belong to, and if it's open source, you should be able to know where the source code of a lot of this stuff is. Most of the time you'll find it in the Solana program library. If you're writing your own programs, you'll actually define the exact schema of these objects.
00:21:15.230 - 00:21:42.044, Speaker A: So I happen to know that this belongs to the token program, and I happen to know that it's a mint object. So that is going to be found in this file here, state rs, and this is the exact encoding format of this. So can everyone see the screen? It might be a little bit small. I'm trying to make this a little bit larger so you can all see this. This is a mint object. These are the fields that it possesses. There's a mint authority, there's a supply, there's decimals, there's isinitialize, and there's a freeze authority.
00:21:42.044 - 00:22:26.014, Speaker A: What this tells me is that given that I've identified this particular data buffer as a mint, I know that all the content of this particular struct is found in those bytes of data, and so I'm gonna go through it piece by piece and try to figure that out. The mint authority is a c option of a pub key. I don't know how large this thing is, but I do know a pub key is 32 bytes. I don't know how large the c option is. The way that I can figure that out is the token program implements a deserialized function here, and I can see that when they're unpacking min authority, this maps to a 36 byte chunk of data. So based on that, I would assume that the first four bytes correspond to this c option parameter. So I'm going to just do that right now and try to unpack this.
00:22:26.014 - 00:23:04.178, Speaker A: An important note is that all of the data that is represented in Solana is in little endian encoding. I'm going to go through the Python struct documentation real quick to sort of go through that a bit. So I'm using Python here. You can use any client side library. Python happens to have a nice way to unpack bytes. The way that you do this is you specify the byte order of the account that you're unpacking or the data you're unpacking, as well as the data type which is specified by some of these keyword characters. Unpacking a four byte integer, which is going to be an unsigned int.
00:23:04.178 - 00:23:56.494, Speaker A: So I know that the encoding schema is going to be I, and I know that it's the first four bytes, so that's going to be data zero to four, and I get a one here. So this is going to be mint authority option, sorry, equals okay, so that's a one. The next 32 bytes is the actual minute authority. So let's find that. So this one, as mentioned before in the notes, is going to be a 32 byte string, right? So if I were to naively just do this. Right. Starts at bytes four, ends at byte 36.
00:23:56.494 - 00:24:32.974, Speaker A: Sorry. Thirty two s. I get back these random jumble bytes, right? This is because public keys are represented and encoded in a format called base 58. So if I want to read this like a string, I would have to use a function to actually encode that string. I wrote a lambda function up here called b five eight e, which just encodes it in a format that's more readable. So I see, I get this stream back. It's just some random letters and numbers.
00:24:32.974 - 00:24:53.024, Speaker A: But if you look in the explorer here, that value the two wm ends in I nine, corresponds exactly to what I decoded here. So the object itself contains this data. And we can go through the rest of this exercise, too. I'll just do a few more. The supply and the decimals, right. U 64 and a U eight. We can do that really quickly.
00:24:53.024 - 00:25:29.444, Speaker A: So supply comes first, and that's a U 64. If we go to the struct module, we see that U 64 is an eight byte unsigned integer. So that's noted by Q. Right. So if we unpack that and we know it starts at byte 36, and then it ends at byte 44, we get this giant number. Right. Let's do the decimals next.
00:25:29.444 - 00:26:14.250, Speaker A: So unpack this again. Get the eight bytes out of it, or get the one byte out of this, right, this is just going to be byte. We see the decimals of six, right. And what you can do with this is, you see this number here is some large value in the decimal. The way that the number is actually encoded is going to be supply times ten to the power of negative decimal. Right. This is how it's actually represented, and that's how the token program represents the data.
00:26:14.250 - 00:26:56.734, Speaker A: So if we look at the Explorer link that we had before, we see that that number actually just matched the current supply. Right. The purpose of this exercise was just to show you that all of the account data that you pull from chain is just normal bytes. And then the way that you deserialize information can just be done by manually unpacking all that information. Let me go back to the Evernote briefly. Right. So at a high level, like what we just discussed, there is that data that we found.
00:26:56.734 - 00:27:59.032, Speaker A: That data going back to this first diagram is found in an object on an account. We fetch that data by going through the JSON RPC, and then we decoded it on the client. There's still some step in between in which we need to figure out how does the program write to that account. We don't really know how this happens yet. We also don't really know how to send data to the program to actually make that right operation. So the first thing I want to discuss right now, and it will be helpful for your first project, is how does the program actually write to that data buffer? And that requires us going into some rust code and talking a bit about how the programming model works. In Solana, I wrote a simple program here that sort of goes over the basics of just like a really simple way to represent data on chain and how a program interacts with it.
00:27:59.032 - 00:28:30.076, Speaker A: And it's called counter. It's not completed yet, but I wanted to go through this to sort of discuss, like, how the structured organization of one of these programs might look. Right. So in this counter, we have a series of five files that we're going to be using. One is called entry point, one is called error, one is called instruction, one is called processor, and one is called state. This entry point is the first place in which the program receives data. The data to the program comes into three pieces.
00:28:30.076 - 00:29:08.064, Speaker A: There is the program id, which is the identifier of the program that's currently running. So for this counter program, this program id would be the address or the public key that points to the data that this program is executing. You have the accounts, and these are all of the buffers that this particular program is going to be operating on. And you have the instruction data. Earlier I mentioned how I think of these programs like clis. This instruction data is the input to your CLI. When you have a number of different features that you want a program to implement, you need to make sure that the program is able to distinguish what operation it is trying to do.
00:29:08.064 - 00:29:51.924, Speaker A: So if I have a program that has three different things, that program needs to know which of the three things it's going to be operating on. All that information is going to be encoded in this instruction data. You can think of this as this is the data that you're writing data to read write, and this is sort of your parameter input. So this is really like a, it's like a CLI type interface, but it's a little bit more complex with the way that Solana organizes things. The traditional way of segmenting your program is to build a number of different files that implement different features. Right. So first you have the instruction.
00:29:51.924 - 00:30:09.556, Speaker A: This is the way in which you identify the different features that a program can do. In this case, the only instruction I implemented is called increment. Right. So all increment is going to do is going to take. Or maybe I should start with state. I'll start with state and describe the program. I should describe this program.
00:30:09.556 - 00:30:35.524, Speaker A: All this program is going to do is it's going to create an object that just keeps track of the number of times it's called. So you have a count. This will be initialized at zero. Every time I call the instruction increment, that count is going to increase and then persist all that data back to the blockchain. And supposedly that data can be accessed back by a client. So that's the high level in processing instruction. I have a scaffold for this thing.
00:30:35.524 - 00:31:31.532, Speaker A: I have increment specified, but I haven't implemented it yet. So what I want to do now is go through the process of actually implementing this increment instruction. The first thing I need to do is to unpack this account, which is a list of accounts that are passed into the program when you execute it. Right? So let's do that real quickly here. That is not right, sorry. Okay, the first one, or I should maybe do a little bit of whiteboarding before going into this in detail. So let me switch back to the screen and talk a little bit about those set of inputs.
00:31:31.532 - 00:33:00.496, Speaker A: Right. So let's talk a bit about those set of inputs. So I talked a bit about how the program takes in these things. You have like a program id. This identifies the program. You have a list of accounts, and these are like the data buffers on what you're acting on, right? So this is like a list of data buffers, but, okay, so I wrote down here kind of like what each of these components are, right. And just to be really clear here, all of these inputs are passed in by the user.
00:33:00.496 - 00:33:23.600, Speaker A: Right. And the account is an arbitrary length. Right? So this can be like any size or a variable size. This information is passed in by the user and used by the program. Right. And once the user specifies all of this information, then the program can actually act on it and do something. That's the overall idea, right.
00:33:23.600 - 00:34:12.984, Speaker A: You start with the client who knows about the program and knows what interfaces it exposes. You set up this instruction in such a way that the program can read it and the program will actually do something with that data. So let's talk about counter, right? I think this will be a really simple program. The only account that you have in here is going to be that counter object that you want to modify. So the first thing I did here was I took the list of accounts and I create an iterator. Next I'm going to actually pull out the account. This next account info is a function that's exposed by the Solana program SDK that you can use to go through an iterator of accounts.
00:34:12.984 - 00:34:47.853, Speaker A: It's doing nothing fancy. So now what I have here, this object, this counter AI, is going to be an account info object, which we discussed earlier. This account info contains all the information and metadata related to that account. It has information about the lan ports data owner executable. Now what I want to do is I want to deserialize the information that this account includes. So to do that, I will use a library called Borscht, which you will be using in the first project as a way, like, to encode data. But I'll use that library to now pull data out of this account object.
00:34:47.853 - 00:35:45.764, Speaker A: Okay, so this is just the function that you use to deserialize. Nothing too fancy here, right? For the most part, if you encounter things like this that you're not familiar with the syntax for, you can just copy and paste it. That's what I would do for the most part. But all you need to know is that this is pulling the data from the raw account info and packing it into an object. Then what you can do is you can just modify the data that you're looking for. The purpose of the counter program is we want to take that counter object and increment it. So if I do counter count plus equals one, now what will have happened is that in that localized copy of the buffer, that count variable will have increased.
00:35:45.764 - 00:36:28.824, Speaker A: One thing to note about this Borscht library is that it will actually copy the contents of the buffer into a new account or into a new object. So the original account data that was found in this counter AI account info, that data still lives in that account buffer. And what we did here is we copied it into a new object. Now we have to write it back at the end. So to write it back we call serialize. Serialize. And this is just syntax for the most part.
00:36:28.824 - 00:37:15.114, Speaker A: And if you have trouble with a syntax in any of your projects, the staff is here to help because a lot of these are just details about how to perform certain actions. But these actions are very straightforward. At the end of the day, you copy data into objects, you modify those objects and you write those data back to the accounts. That's basically it for what we need to do to run this particular program. This counter program, we load in the account, we modify the data of that account, and we serialize that back down into the original input. Right? So if I wanted to now I can just compile this thing. So I'll go back to lecture one and go to the counter.
00:37:15.114 - 00:38:01.238, Speaker A: So I'm running cargo build BPF. This will compile the code into PPF, which you can use in Solana, or you can upload that by code to Solana for your environment setup. You need to make sure that all of these tools are properly installed. Once this compiles, it will tell me that I can upload this program to the Solana network. There are multiple different RPC links that you can use to do the upload, primarily for the purposes of the projects that you guys will be working on. You'll be uploading all of the data to Devnet. You can also do things to a local validator, which you can start with by downloading the Solana package.
00:38:01.238 - 00:39:01.952, Speaker A: And for all applications that you interact with in production, almost all of those will be deployed in Mainnet. But for the purposes of this exercise, once I compile this binary file, I'm going to upload it to Devnet, which after you call this build BPF instruction, it conveniently exposes this command line tool that allows me to just upload. After this is completed, it's going to print out a program id, which is just a normal pub key, and I'm going to show you the contents of that pub key on Devnet after copying this. So if I go to the explorer, I changed my network to Devnet and I paste this address, you'll see that I have just uploaded this program. So this is the program. There's some executable data, and there should, in theory, be some transaction history, too. Yep, there we go.
00:39:01.952 - 00:39:52.434, Speaker A: This is when I uploaded the data. So now I have uploaded a program that I should be able to interact with. For this project, I also implemented a really simple client that I can use. I guess I can just go directly into this lecture. So to build a client, you basically need a way to interact with that JSON RPC. So the way that you do this is you create a connection, and that connection has access to all of those different API calls that were found in that Solana docs page, which I can share with you in the discord. In order to send any transactions, you need Sol in the accounts.
00:39:52.434 - 00:40:53.954, Speaker A: So the two ways that Sol are used, there's basically two functionalities for how Sol is used when working with Solana programs. So Sol has like two utilities. The first one is for paying rent, like I mentioned before. Right, rent cost. You'll use Sol as a way to sort of allocate data into accounts, right, allocating. And the more data you have, the more it's going to cost Solarize. If you look at the command line, the CLI, so I can find that you can get the amount of sole that you need to pay to allocate an account by using the Solana rent function, Solana rental.
00:40:53.954 - 00:41:38.016, Speaker A: And then the third argument, the argument that you pass in is going to be the number of bytes that you want to allocate. So if I wanted to allocate a 100 byte account, I would call Solana rent. It will make a request to the RPC, and it tells me I need to pass in this much sol in order to make it rent exempt. Rent is collected periodically when you deploy these programs. But for the sake of making this not super complicated, the best practice is to always make all of your accounts rent exemption. So when you call out a rent on a particular byte size, it's important to just make sure that when you actually allocate the account, the amount of lamp ports you allocate to that particular object is equal to the rent exemption minimum. So in this case, it's about 0.001
00:41:38.016 - 00:42:06.236, Speaker A: sol. It's a fairly tiny amount to allocate a 100 byte account. If you want to increase that size, that's also going to increase the amount of Sol you need to maintain this. So that's for 1 kb, or I guess approximately 1 kb. When you go into the megabyte territory, it becomes more expensive. If I want to allocate a full megabyte of data, it's approximately seven sol that is required. So there is a cost that is associated with allocating space.
00:42:06.236 - 00:42:48.530, Speaker A: A megabyte is not a lot of information. There's not a lot you can do with it. So it encourages the developer to be really careful with the sizes of the accounts they're using. The maximum account size is going to be ten megabytes, and that's going to be approximately 70 soul that you need to allocate that large of an account. So there's a trade off here in terms of how much space you want to use. Oftentimes when you're representing state, you want to be somewhat conservative with the amount of data you're actually allocating, because it gets more expensive to create more and more of these large accounts, especially for the user. If every user is going in and allocating a ten megabyte account, you can't really expect them to pay 70 sol every single time.
00:42:48.530 - 00:43:28.354, Speaker A: No one's going to use the application. So this is a pretty serious restriction in what you're able to do in programming. So you have to be very cautious about the amount of space you use. The other one is paying for transactions. So right now this is fairly cheap. That's one of the main benefits of using Solana, is that transactions are quite inexpensive. The current cost is like 5000 lan ports per signature.
00:43:28.354 - 00:44:27.798, Speaker A: And remember that signatures are the way that you use to express ownership of particular public keys, right? So if you want to do a single transaction on Solana, you need to have at least one person sign that to pay that transaction fee. In the source code that I'm writing here, that is on to the fee payer. So in this client file, what I'm doing is I'm trying to interact with this counter program that I just wrote, right? I create a fee payer, and because it's devnet, I can airdrop some amount of Sol to it. I can airdrop to sol two e nine to the fee payer of this particular transaction. Then what I'll do is I need to first allocate the account. The account itself is eight bytes large. And then I use this client side function to get the rent exemption.
00:44:27.798 - 00:44:52.854, Speaker A: I could do this using the command line too. I know that it's eight bytes. So the amount of sol that I need to allocate is tiny, right? It's whatever this number amounts to, that will be the amount that I need to allocate towards creating the account. And the account I'm creating is going to be a new key pair. So I create this key pair called counter. I grab the public key of this key pair. Remember, this is 64 bytes.
00:44:52.854 - 00:45:29.434, Speaker A: The public key is the latter 32 bytes. I take that, I create an account and I add it to my transaction. I'll go way more in depth into transactions in the next lecture. Now, I'll actually have to do a bit of implementation here, so I want to sort of figure out how I can make a call to that program, right? The program itself had these number of inputs. It had the accounts that it takes in. It has the instruction data and has the program id. Based on the implementation I have here, it only needs one account total.
00:45:29.434 - 00:46:09.214, Speaker A: So when I actually construct this transaction, I need to make sure that this information is present. We're going to make an instruction called increment instruction. This is currently set to null. It's going to be a transaction instruction object. It has some keys, which is going to be some array of stuff. It has a program id which I pass in as a command line argument. So that's defined here and it also has some data.
00:46:09.214 - 00:46:52.986, Speaker A: So the only data that this instruction is going to take in is going to be this index buffer. If we look at how this instruction is defined, it takes the instruction data here and pulls it in from this counter instruction. That counterinstruction is implemented as an enum, which I serialized with this package called Borscht, which you guys will become familiar with in the first project. The way that Borscht represents enums is that this is a one byte object. So this is just like an unsigned byte. And because it's the first enum in the instruction, it corresponds to enum zero. Right? So when I load in this index, that's going to be enum zero.
00:46:52.986 - 00:47:31.984, Speaker A: The only important part here is what do I pass in for the keys? And the answer is just the account meta. I think I can just do have this code somewhere. Look at the script skeleton code. It's pretty simple. You have the public key, whether it's signer and whether it's writable. I'll go into a lot more detail about all of this stuff in the second lecture. At the end of this, I want to announce the project and sort of open up the floor for questions, because I'm sure there are going to be a lot of them throughout the room.
00:47:31.984 - 00:48:21.734, Speaker A: So public key is going to be corresponding to the counter public key. So the counter key, and that should just be all we need to have inside our instruction. So our transaction is going to now add this increment instruction along with the account creation, and then it will send a transaction to the network and try to get it confirmed. So let me just see if that worked. Lectures. Let's find that public key that we had before. That's not it.
00:48:21.734 - 00:49:09.974, Speaker A: Different page. Nope. I can just deploy the program again, make sure one counter build, that's the one. Okay, so we grab the program id. This is just a number, regular public key. Let's go back to lecture two, and then let's run that code. Okay, great.
00:49:09.974 - 00:50:42.574, Speaker A: That's not good. Where's the filling? There we go. Is that gonna work? Great. Ok, so that actually succeeded. To all of you guys who are actually seeing the webinar, what happened here was I sent a transaction to the network, interacted with that counter program that I wrote, and actually incremented that value. The key that it wrote to was this CIX key here. Right? If I want to run this program again, I can pass that in as a secondary argument, run the same code as before, and we'll see that counter increment from one to two right, so we see that now it's two.
00:50:42.574 - 00:51:27.436, Speaker A: So what we've done in that coding exercise is we've shown how to set up a Solana program by writing rust code that modifies the state of the accounts that are passed in. And then we also wrote some client code in JavaScript. But really the language doesn't matter. That sends an instruction to the network, modifies the content of the data, and then as a user, you query that data and it spits back out the output. And much of what you'll be doing in the first project that we'll assign to you is very much the same thing. It's going to be taking in user input, writing that data to accounts, and then verifying that the data has been written. But in general, the amount of state that can be modified is much more than just a simple counter.
00:51:27.436 - 00:51:58.074, Speaker A: You can imagine that your accounts can store a lot more salient information. Serum, for example, has built an entire order book that lives on chain. All of the amms that you use to do swaps like Uniswap can be built on Solana too. And there's more information that being encoded in there. Nfts have to encode metadata related to the images that those public keys represent. So all of that stuff is additional state that has to be built into these accounts. And the way that you interact with it is just through this interface.
00:51:58.074 - 00:52:51.490, Speaker A: In the second lecture, I'll go a lot more in depth into how to set up these transactions, but I want to go back real quickly to this first diagram I wrote, because I think this is the most important thing to understand here. What you really need to know is that to build Solana programs, you need to write both this client side code, which I just did now in JavaScript, that was a J's client, and you need to write the Solana program, which I wrote in rust. This would be like the counter, and this would be the client that updated the counter. Yeah, I think there's probably a lot of information that still needs to be covered. I haven't talked much about transactions. That will be the second lecture, but I wanted to give you an overall overview. The high level is that all the information that you're going to be working with is represented in two accounts.
00:52:51.490 - 00:53:32.924, Speaker A: These accounts are indexed by 32 byte public keys, which is serve as addresses. If you want to verify that you control an address or own it, you can sign it with a public key or with your private key. And then if you want to access the data of a particular account, you can do so publicly. With a JSON RPC. An important note that I should have mentioned and I should have sort of covered on a little bit more formally, is this owner field? Right. If you note carefully in this JavaScript client that I wrote for this program, for the counter program, I assigned the owner of this counter key to the counter program. Right.
00:53:32.924 - 00:54:21.130, Speaker A: The owner is the only public key that has write access to the data buffer of the account. So in order for that counter to get incremented, the only program that could have done so is that counter program that I wrote. And that's an important feature of how all of this stuff is organized. But yeah, that's basically all I have for the first lecture. Apologies for the technical difficulties. Hopefully that will be sorted out in future ones. Do I have any questions from the audience about clarifying any of the information that was presented here? Yeah, gotcha.
00:54:21.130 - 00:54:54.692, Speaker A: So the question, just to reiterate, for anyone who didn't hear, is whether you have to create the account separately outside of the program, or if you can create the accounts in line inside the program. The answer to the question is that you can do either. So what I did in this particular program was I allocated that counterobject outside of the rust program. I allocated it in JavaScript. But it is possible to also create programs inside the runtime itself in the program you write. The way in which you do this is through a process called a cross program invocation. I will talk about that a lot tomorrow.
00:54:54.692 - 00:55:37.618, Speaker A: This is one of the key benefits of using Solana as the l one blockchain, because when you do cross program invocations, that allows you to achieve composability. The short answer to your question is yes, it's possible. There are limitations to doing things in the program, so sometimes you do want to allocate accounts outside. But both methodologies are the things that Solana supports. A lot of the stuff I would recommend you just kind of use them as black box resources in order to actually build programs in Solana, there isn't that much of a need to understand the core functionality of the network protocol. The main thing is just understanding the interfaces and how things interact with each other. That's what I would recommend, at least.
00:55:37.618 - 00:55:58.634, Speaker A: What I think I'll do is I'll have my staff release the spec for the first project that will just include some skeleton code that you can work off of, as well as the details of the instructions that we want you to implement. I'll give you some time to think about that and read over the spec in the code, and then we'll go over how to build transactions in Solana in the next lecture. Thanks for your time, guys.
