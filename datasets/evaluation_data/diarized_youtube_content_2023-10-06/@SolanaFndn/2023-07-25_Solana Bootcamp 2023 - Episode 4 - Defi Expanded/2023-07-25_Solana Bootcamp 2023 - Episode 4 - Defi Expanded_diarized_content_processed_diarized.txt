00:00:10.040 - 00:00:46.415, Speaker A: Hey guys, welcome back. I'm Joe and I'm going to be continuing our pirate themed boot camp. So if you got this far, this is day four where we're going to be talking about our swap program. So you can see here's the model repo again, I'm sure you've seen it. This is where all of our quests are going to be and we are going to be doing smuggling, bargaining and upgrading your ship. Right? So in this quest here, we're basically going to be learning about how a decentralized exchange works. So if you take a look at the readme in here, you can see that we have, first of all, we have all the stuff that you need that I'm going to go over, right? So setup all the code, everything, right.
00:00:46.415 - 00:01:35.555, Speaker A: So we're going to follow this pretty much exactly. But the first thing I want to do is go over these slides so you can get a link to these in the readme if you need them. And basically we're going to talk a little bit before we get into the code about how a DEX works. Right. So decentralized finance dexes and the constant product algorithm. So first of all, what is decentralized finance or defi? Right? Defi is basically, you know, the, the means by which crypto unlocks a new way of doing peer to peer finance. So traditionally, you know, you've got banks or brokerages or some kind of central intermediary that's going to facilitate trades, it's going to facilitate, buy and sell on market, right? Making markets, things like that.
00:01:35.555 - 00:02:07.757, Speaker A: And the technology behind crypto allows you to be able to sort of make these things permissionless, right? So peer to peer directly through coded protocols that are deployed on a network. So you don't have to trust some party with the authority to essentially revoke whatever it is you're trying to do. And this is a big deal, right? Especially when it comes to being able to autonomously do what you want to do in markets. So here's a look at Defi on Solana. This is from our website, our Solana.com page. This could even be a little bit outdated at the time of recording this.
00:02:07.757 - 00:02:45.341, Speaker A: We might even have some more projects by now, some larger projects, but you can see here is a good snapshot of what that looks like. So Defi is really big on Solana. So as I mentioned how Defi kind of works, there's obviously a lot of disruptive potential with the technology itself. It can challenge traditional finance by offering greater security and also no longer the need for a centralized party. So pretty important stuff. And as you probably heard from recent events, especially around the time of recording this, that is actually extremely important and all the more relevant now. So anywho, here's some key components of Defi.
00:02:45.341 - 00:03:50.229, Speaker A: I'm not going to read all of this here, but basically you have self executing digital contracts. So on Solana, their programs you have digital or virtual tokens which can facilitate these trades on the blockchain network and then platforms that allow users to trade cryptocurrencies without any central intermediary. Right? So those are like the three big deal items when it comes to DeFi. So what about like a decentralized exchange or a Dex? Dex? Well, basically this is like a platform or protocol where you can actually facilitate these Defi trades, right? So think about like if you want to be able to swap two tokens, I want to give you some of this particular token and I want to get some of this token back. And we have to be able to figure out, okay, what's the token you want to give me worth? What's the token I want to give you worth? How much should you get? All these factors considered and that's what Dexes mostly kind of do in an automated fashion. And that's what we're going to take a look at today. So here's a couple of Solana Dexes, you got Orca, Open Book Radium, there's a couple more.
00:03:50.229 - 00:04:49.401, Speaker A: Those are the big ones. And in order to power the technology behind a Dex, there's something called the Constant product algorithm. And that's what we're going to talk about a little bit in detail here in these slides. So I'm going to show some numbers, I'm going to show some formulas, right? And basically the idea here is I want you to really understand how these formulas work and how they facilitate these swaps. Like I kind of just laid up a couple of slides ago and what that actually means. And then when you understand that formula and you see it, we can take that and put it into code and we can build a swap program, we can build a Dex, right? So here's a couple advantages of decentralized exchanges that use the constant product algorithm. I won't cover exactly all of these while I'm talking, but I will just say that it helps with price slippage, it helps with the ability to provide liquidity of certain assets, and it also helps again with that security and no central authority aspect of Defi.
00:04:49.401 - 00:05:28.451, Speaker A: And you'll see a little bit more of what I mean about the price slippage and the liquidity, as you see how this algorithm kind of works. So let's take a look at an example. Right? So in a decentralized exchange, you're going to have a number of accounts that have different, like tokens. Let's just consider everything as a token for this scenario. Since we're working on Solana, we're working on a Solana program, we're going to be building a swap with SPL tokens. Everything in the swap is a token. So we can have any number of these tokens, any different mints, right? And we have some kind of liquidity of each of these tokens.
00:05:28.451 - 00:06:40.815, Speaker A: So for those of you who don't maybe know what liquidity means, it just means that we have some significant quantity of these tokens so that it can be made available to people that are trading on our protocol, right? So if our swap offers liquidity for, let's say USDC Bonk, you know, a couple of other SPL tokens that you might have heard of, that's going to be. That just means that there's a good amount and it's a relative number, but a large amount of this asset is available through our protocol, so that when you go to make changes like swaps, you know that there's enough there to facilitate the trade that you want to do. So considering that, let's take a look at a pool, which is what these things are called, right? Pools of assets. Let's think about a pool that has a number of different assets of varying quantities, right? So we might have X quantity of usdc, Y quantity of Bonk, Z quantity of Sol. And the idea here is we want to ensure a constant value of K. Now, what is K? Well, K is the constant product algorithm. It's the constant product itself is K.
00:06:40.815 - 00:07:48.045, Speaker A: And this is what K kind of looks like. So Q is going to be the total quantity of any asset. You can see I've just got those suffixes there, those subscripts for all the different kinds of assets we might have. So if we just take the quantity of each asset and we multiply them all against each other, we're going to get one large product and that product is going to be K, right? And so whenever trades are being made on a Dex, whenever there's swaps, for example, the pool, and the underlying technology behind the pool, AKA the smart contract or program, is always trying to make sure that that constant value of K stays the same, or at least within a very, very, very tight margin, right? So that's the Whole idea. And this is an algorithm, right? So, like, we want to keep this constant the same, but we want to be able to move assets between two people, okay? And that's exactly what our SMART contract is going to be able to do. So here's just a little bit of information. Q is a nominal quantity, right? So we have to factor in, at least on Solana, the decimal places of these assets, right? And that's going to kind of be something to consider when you're coding this.
00:07:48.045 - 00:08:49.145, Speaker A: And, you know, you can see the example here I've just said, like a token account might have a balance of 10,500 for a mint with three decimal places. So the nominal quantity is 10.5, right? And this will make more sense when you see the algorithm in code. But anyway, let's run through our example, right? So with that in mind, we want to swap some value P, some quantity of P, for another quantity of value of asset, R. Right? And so I'm labeling these P and R, because in the context of my program, what I basically set up is when I come to the pool and say, I want to give you some USDC in exchange, I want to get something back, I'm going to offer to pay USDC and receive something else. USDC in this case would be the pay asset, which I'm dubbing P here. And then whatever I'm requesting in return is going to be R, the receive asset.
00:08:49.145 - 00:09:20.477, Speaker A: Pay receive, if you see P and R. That's why I want to come pay this asset and I want to receive another asset in return. And our smart contract needs to calculate exactly how much of that asset I'm due to receive based on what I'm offering, right? And you might think like, okay, well, it depends on the price of it, et cetera, et cetera. Well, actually, it only depends on the liquidity in the pool. And you'll see why. So here's K again. And now we've included.
00:09:20.477 - 00:10:07.975, Speaker A: You can see the quantity of P and the quantity of R in the pool already as it stands. So right off the bat, we can kind of get rid of. Well, first we can kind of like expand this to. Take a look at this, right? So if we look at the first equation here, QP and QR have just been tacked onto the product. Now, if we want to pay some P and we want to receive some R, that means the pool is going to gain P and lose R. So you can write it like this, right? And inside each of those parentheses is going to be the new quantities of these Assets. And so since K is always, we're always trying to make sure K is the same, these two formula are exactly the same, right? They should be set equal to each other.
00:10:07.975 - 00:11:09.971, Speaker A: And so that's what we have here on the bottom, right? So these should be the same, they should equal the same thing. So whatever value for R, this whole thing should equate to be the same. And we know P because it's what we're offering, right? So that's important. Now let's take a look at it from the top here, right? So we've got this set equals to each other, right? So K equals the first bit that we talked about, which is equal to this new formula with our swap involved. So we can just do a little bit of factoring here, right? And we can say, okay, let's break this down to this, right? And then we can go from here with a little more algebra and we can break that down to this, right? And you can kind of see where we're heading here, right? We're getting a little bit closer to an equation that gives us a value for R. And keep in mind, we know the current quantity of qr, we know the current quantity qp, and we know what P we're offering. So we can get this formula right here.
00:11:09.971 - 00:11:53.649, Speaker A: And then this is our constant product algorithm that our program is going to be built to use, right? And it's really that simple, right? A little bit of algebra up front. You got to make sure you check your math. I used WolframAlpha and it was actually wrong, which is pretty funny. And ChatGPT completely failed, so I'm better at math than AI just putting that out there. Anyways, point is, this is how you can kind of set this thing up. And then we can use this formula to code into our program. And then you can see that since we already know these two quantities, qr, qp, all we have to do is feed a value of P and we will get a value of R, right? And that's how this is going to work every time.
00:11:53.649 - 00:12:47.585, Speaker A: And you might think like, well, how do we know for sure that we know what QP and QR are? Well, these are actually the balances in the pool of tokens. And so if we set our pool up where our pool has any number of associated token accounts, we can just read these token account balances. And so with those accounts, with access to those accounts and given a value of P, our application, our Solana program, can calculate R every time and to a pretty significant degree of accuracy. So one More time. Here's the equation, nice and big and this is basically what we're going to need to know going into building this program. So hopefully that makes sense. Again, the slides are available in the readme and so here's another look at that equation as well in the readme.
00:12:47.585 - 00:13:13.535, Speaker A: You can see we've got just a breakdown here. You'll see that in the comments of the code as well. And then I've got some breakdowns here about how the repository is set up. I will loop back to this pretty soon. But as like a quick tldr, there's a front end, there's a program and there's a series of tests and we're going to drive those tests to set up our swap. Right? So let's just go ahead and work through the swap program and set this thing up. Right.
00:13:13.535 - 00:13:44.651, Speaker A: And I will just flip over to VS code here and show you as we kind of walk through this. Right. So first things first, you can see in my read in my librs here, we've got three instructions of our swap program. We want to be able to create this pool for the first time. So initialize whatever we need to set this thing up. And then we want to be able to fund it with liquidity, which is what fund pool is going to do. And this is kind of like dynamic, right? So like you can add new tokens to the pool, at least the way we wrote it.
00:13:44.651 - 00:14:17.345, Speaker A: You can increase the liquidity of some specific token. You know, there's a couple different options there. And then finally swap is of course exactly what it sounds like. We're going to just offer some asset and we're going to request a swap for another asset. Now you can see we're only passing in the amount to swap. This is P. And that's because the accounts that are involved in processing a swap will actually tell the program which token it Is and the QR, QP values, etc.
00:14:17.345 - 00:15:27.395, Speaker A: And we'll see that later. So right now I'm just scaffolding out the program and if we walk through this readme, you can see the first thing we're going to take a look at is what does our pool look like? Like what's the state of our pool? And so I'm going to use a Solana program derived address and I'm going to set up some state for our pool and we're just going to, we're going to set this up like this. We're going to have one account that's going to hold some data about our pool. And then from that account we're going to generate any number of associated token accounts that will be owned by that account to house the tokens for our swap, right? And so when we have a pool, we're just going to have a PDA and then a number of associated token accounts that will just comprise together our pool, right? So and for those of you who might not know, like you might have learned it in earlier sessions, but associated token accounts, they all correspond to one different mint, right? So if we have like eight associated token accounts, we have eight different assets in our pool. So the way I set this up is I've got the bump being stored in here. This is just like a little config. It's actually a seed that we use to derive the address.
00:15:27.395 - 00:16:36.535, Speaker A: I'm storing it in the account itself just for validation check purposes. And you'll kind of see that a little bit later, but it's otherwise not super important to what we're doing. But this is. Right? So this is going to be just a custom implementation that I put in here to show you guys an example of dynamic Solana data reallocating account size and giving you guys the means to sort of think about how to provide certain checks, right? So to give you an example, maybe you don't want certain tokens in this pool, or maybe you don't want to allow new liquidity unless some kind of config is set to true, right? Or something like that. What we're going to do here is inside this assets vector, we're going to keep a list of public keys, and each public key is going to be the mint that our pool supports. So this gives you two benefits. One, you can set up a bunch of checks like we just talked about, and two, you can just look up one account to serialize it and see all the mints that are offered by the pool without having to instead look up all the token accounts that are owned by this program.
00:16:36.535 - 00:17:11.838, Speaker A: So that might not mean a whole lot to you per se, but when a swap is really big or something like that, this might make more sense. Again, I'm not saying this is how you should build your swap. This is just for example purposes, but that's what this thing is basically designed to do. And that's kind of what I'm talking about right here in this little blurb. And then we're going to move back to state later to talk about some of the like, implemented traits and stuff below. But let's flop over to our first instruction, create pool, right? And you can see it right here in the readme. I'm going to pop it open in VS code again.
00:17:11.838 - 00:17:34.142, Speaker A: Create pool is our first instruction. And that's going to be right here. And you can see this isn't a ton of code. 32 lines, 33 lines, you know, with the brackets. This is just to create that account that we just looked at. Right? So this is our state and this is us just creating that account for the first time. And thus that we can consider as our pool being initialized.
00:17:34.142 - 00:18:05.825, Speaker A: So our account for our pool is created, the program derived address account PDA is there. We can assign it associated token accounts, we can fund it with liquidity. So the pool is active, right? And this is all it takes to do that. We just go ahead and like this is going to be using anchor to do some of the heavy lifting here. So. Right, so anchor right here is going to create this account for the first time. That's what this INIT keyword is going to do for us, which you probably saw a little bit of in the last session.
00:18:05.825 - 00:18:34.021, Speaker A: We've got the constant space, which is just the size of our account when we first kick it off. Right? And the space here is going to be 8 bytes for our discriminator for our data, 4 bytes for a vector, which is going to be empty. So we don't need any other subsequent bytes. And then one byte for that U8 bump. Right. And so then we're going to make sure our payer pays to create this new account. And here's our seeds to derive this address.
00:18:34.021 - 00:18:55.261, Speaker A: You can see something particular here. The only seed we have is the seed prefix constant, which is just a string literal liquidity pool. Right? And the key here is that this seed setup, where it's just one string literal, can't be replicated. Right. Once this account exists, you can't create it again. And that's by design. Right.
00:18:55.261 - 00:19:31.495, Speaker A: You might choose to have multiple pools in your decks, so you might want to change your seed setup. But for this example, I just want one pool and I want to make sure no one can create a new one. So this is how I did mine. So we're going to have somebody sign to create this pool and we're going to need the system program to do it. And then as you can see, our last step here before we, okay, out of this thing is to just set our liquidity pool up with the data. And that data is of course just going to be an empty vector. And then our bump, which is just the bump seed we're pulling Right here from the derivation.
00:19:31.495 - 00:20:02.105, Speaker A: And that's it. So that sets up our pool, right? So now we have this pda, we have this liquidity pool. It exists, we can start to fund it. So that's exactly what we'll move to in the next section. You can see a little bit of talk about our stuff implementations here. So now we're going to talk about funding this pool, right? So funding the pool is going to be where we implement our second instruction. And this is going to be a little bit more complicated, but ultimately you're just transferring and creating accounts.
00:20:02.105 - 00:20:47.315, Speaker A: So let's take a look at funding the pool. And you can see here that again, we've got this anchor set up with some context, right? But you can see it's much bigger. So up here the logic is straightforward. A lot of this I've kind of abstracted into another file which we'll take a look at. But essentially what we're doing is we grab our pool, we build our deposit, and then we run this dot fund, okay? And we pass in the necessary accounts and the deposit. And so literally all that's going to do is say like, here's the tokens that are being funded. Here's this transfer function that's being wrapped by my pool fund, and it's just going to fund this associated token account.
00:20:47.315 - 00:21:20.475, Speaker A: Now I already mentioned how we had to create these things, right? So that's kind of happening down here. So trying to fit all this context in one screen here. But basically you can see here we've got our liquidity pool. Now if we look at Create pool, we saw that we use this INIT keyword. We had some other configs, but now we're using mute because we're expecting it with this instruction to already exist. So it exists already. And since our program owns it, we want this to be mutable and we want to be able to change the data.
00:21:20.475 - 00:21:53.851, Speaker A: And the idea here is when we fund a new mint to our pool, we want to be able to add that mint address to that vector that we talked about. So a couple of things happening behind the scenes we'll get to. So here's the mint that we're funding it with. Here's the associated token account for that mint for the pool. And you can see we're using this anchor additional feature in it if needed, which means kind of what it sounds like. If this account doesn't exist, let's initialize it. So in other words, this instruction will work even if our pool doesn't already have this token account.
00:21:53.851 - 00:22:19.265, Speaker A: If it's creating it for the first time, anchor will go ahead and run that cross program invocation to do it. Which is cool, right? And you can see it corresponds to the mint. Our authority is our pool like we designed. And then here is the payer's token account. This one we are not using. Indent if needed because if you're offering to pay liquidity, that thing should exist, right? So that's not there. And then we've just got the programs that we need to do this and our payer.
00:22:19.265 - 00:23:12.995, Speaker A: So let's start taking a look at what happens when we go ahead and run this pool fund. So and you're probably wondering like okay, why is deposit like this tuple struct like what's going on? Or this tuple object? This is just sort of like a fancy schmancy way of me building the arguments to this dot fund, right? Instead of having to pass four things plus another three and have seven total arguments, I decided to group deposit into a tuple. That's all. But if we look at pool fund, we can pop this open and we can see we are back in our state file. And I've actually set this up to be a little bit interesting for you guys. Anybody who wants to learn a bit more about Rust, this will be nice. I set up this trait and this trait gives us these functions which are going to be associated with our liquidity pool.
00:23:12.995 - 00:24:04.025, Speaker A: And you can see like here's that deposit tuple. We've got another tuple set up for receive and pay, right? It's just like me trying to be clean about this code, right? And that's just all it is. You don't have to do it like this. But ultimately we set this trade up and then we implement this trait on the account of type liquidity pool. And this is an anchor like account object that's generic over some type. We are going to implement this trait whenever we have an account of type liquidity pool. And you can see here that's exactly what this is right here, right? And so this is just me being fancy, but I'm going to add all of these functions via a trait so that when we read the pool in to our business logic, we can then access these functions.
00:24:04.025 - 00:25:17.535, Speaker A: All right, so that's all that is. So going back to the fund function, right, let's take a look at what's happening here. So obviously the goal is to fund the liquidity pool with some tokens, but there's a couple steps we're taking in like the middle, the middleware of this, right? So first of all, I'm gonna turn off my rust analyzer. We go ahead and let them. Oh, maybe I'm gonna turn it back on. Go ahead and let the mint from to amount equal deposit, right? And that's just because I passed it in with this strange formatting. And so once we've got these variables set up, we can go ahead and do add asset and we're gonna add the asset to that vector, right? So to do that, we pass in these few things, you can see just mostly accounts, right? And when we go ahead and run add asset, which is another function associated with this thing, you can see that we're just going to check if this asset exists in that vector and if not, we're going to put it in there, right? So if it doesn't exist, we're going to realloc the account and push the key into the vector.
00:25:17.535 - 00:26:08.791, Speaker A: Now what does realloc mean? Well, on Solana, when you create an account for the first time, you specify the size of that account when you create it, and that's how much rent you pay. And only about a year or so ago they added the feature to be able to reallocate this size. So for example, if we set our account to be of size A plus 4 plus 1, 13 bytes, and all of a sudden we want to add a 32 byte public key to our vector, suddenly we need 45 bytes, right? And if we want to add another one, we're going to need another 32 bytes and so on and so forth. Originally that wasn't possible, but now you can do that. So what we do is what's called realloc and that is something that is available to all accounts on Solana. And you can see right here, that's what we're going to run. So let's just make sure we know where this is getting kicked off.
00:26:08.791 - 00:26:46.995, Speaker A: So when we go to add this asset, right before we push into the vector, we go ahead and reallocate the account and you can see we're giving it 32 more bytes. So I set this thing up space to add payer system program. So why do we need the system program? Well, you can see right here from the highlight, we need to do a transfer. And that's who the payer is for too. So why do we need to do a transfer? Well, your rent that you fund an account with is based on the size. And so if we initialize this thing at 13 bytes and we pay for 13 bytes and then we tell Solana to make it 35 bytes or whatever number. I said 45 bytes.
00:26:46.995 - 00:27:31.755, Speaker A: We need to pay for that, right? So this always goes hand in hand with some deposit of lamp ports of additional money for the rent. With that being said, that's exactly what's happening here. You can see here, we're going to just calculate the new size of the account, which is adding that 32 bytes. We're going to calculate the new required lamports balance and then we're going to fund that additional rent into the new account or into the account we want to change. And then finally reallocated size, right? And this 0 init flag, that means clear the existing data or no. And since we're working with a vector, we don't want to do that because we can just append to it. But if you wanted to change your data schema, you might want a 0 init.
00:27:31.755 - 00:28:08.599, Speaker A: So anyway, that's that, right? So that's all the steps it takes for us to add a new key. And so we finish reallocating, we push the new key to the vector, we serialize it and anchor actually will kind of handle that serializing for us and then we're good to go. So as you can probably tell, okay, that has nothing to do with actually funding the token account. Well, that was step one, right? That was adding an asset to our pool. And this is just for demonstration purposes. Again, you're probably laughing at why I'm going through all the trouble. The second step is of course going to be processing that transfer.
00:28:08.599 - 00:28:42.475, Speaker A: And this I just wrote a helper function for. But all we're going to do is we're going to CPI over to the token program and we're going to run a transfer from our account that's being providing the liquidity to our pools token account. And just for, you know, just for the sake of example, we can see it's going to go from this to this, right? So that's providing liquidity. That's it. Cool. So if we look at our readme, that's kind of what I'm going over here. I'm talking about fund, I'm talking about realic.
00:28:42.475 - 00:29:48.635, Speaker A: We just covered all this stuff, right? And then our next bit here is our third instruction, swap. So flipping back to VS code, you can see here, we're going to take a look at our swap instruction and I'll close these other instructions out too. And basically what our swap instruction is going to do is it's going to set up the constant product algorithm and determine some amount of R to give back now you can set this program up if you want it in the future, you can expand on this and you can allow for the ability to preview how much or whatever. I didn't do all that. So in just the program spec itself, what you're going to do is give me a value P and I'll give you back R, but I will transfer it back in order to kind of estimate how much you'll get. You need to recreate this algorithm outside the program, at least the way I wrote it. So the program is literally just going to take P as an input and transfer R and it's going to do both transfers.
00:29:48.635 - 00:30:33.429, Speaker A: So with that being said, let's walk through, right? So if it's zero, we don't want to be able to run it. So throw an error, right? And then again we're going to load the pool up because I've got my cool implemented functions on here and the last one was process swap, right? So we build our receive and we build our pay. So here's R and here is our Q of R. Here is P, here is our Q of P. And then you can see the payers token accounts are also included here for the transfers. So taking a look at the context again, this one is going to be a little bit larger than the last one, but it's pretty straightforward. Right, again we load the pool in.
00:30:33.429 - 00:31:13.879, Speaker A: Again it needs to be mutable. Technically this might not need to be mutable right now because we're not changing the vector, but nonetheless at least the token accounts will need to be mutable. So you can see here we have a constraint anchor, lets you write these constraints here that they'll run checks at the entry point of the program. So right here we're just making sure that the R asset does not match the P asset, which is good to do. So here's the mint we want to receive. Here is the token account for the pool that has that mint. I'm not using INIT if needed because if that token account doesn't exist, then you can't receive that asset from this pool.
00:31:13.879 - 00:31:51.955, Speaker A: So we want it to throw an error and then the payer might not have this account though like they might not have this token yet. That's okay, we can initialize that too. Here's the mint for P what they're offering to pay. Here's the pool token account. Now this one could be INIT if needed, but for the case, just for the way I set it up, I don't have it as INIT if needed because if you did do init if needed, we would have to implement the add asset and stuff like that. So I didn't really go through the trouble of doing all that. I just basically said if the pool doesn't have P, you can't pay P to get R for now.
00:31:51.955 - 00:32:14.079, Speaker A: So another place that you can kind of expand on this. And then here is the payer's token account for P. Again, we're expecting that to exist because they're offering the asset. Cool. All right, so let's take a look at the process swap. This is the last important bit of our program. And this is where we're of course going to have the constant product algorithm, what we've all been waiting for.
00:32:14.079 - 00:32:43.195, Speaker A: Right. So let's pop this thing open. So you can see here receive and pay, and then our authority, who's going to just be the one that signs for the transfer out from the payer and the token program, which we need. So here's what we're going to do. We're going to come in and we're going to check that the R mint exists in our vector. We're going to check that the P mint exists in our vector. And if both of those hold true, we'll continue through the logic.
00:32:43.195 - 00:33:15.865, Speaker A: And right here determineswapreceive is going to be our constant product algorithm. Now I'm going to go to that last, because the rest of this is pretty straightforward. You can see that if R comes back as zero, we are going to throw an error. And if it doesn't, then finally we're going to process the transfer to the pool and then process the transfer from the pool. And this will happen atomically pretty fast too. And if either of these two things fail, the whole transaction gets rolled back. So it's no big deal.
00:33:15.865 - 00:33:56.513, Speaker A: So anywho, you can see this is pretty straightforward. We're going to transfer the P asset that you're offering to the pool and then we're going to transfer you the R asset from the pool. And then that's going to finish off our instruction. So that's how we set this thing up, this transfer to pool, pretty much the same as transfer from pool. The only difference is we are using the seeds of our liquidity pool to sign this because we're debiting our PDA and the PDA doesn't have a private key. So we're using the seeds to authorize this. Now, that leaves our determineswap receive function.
00:33:56.513 - 00:34:15.647, Speaker A: This is the ultimate piece of our program. This is what we harped on earlier with the algebraic Slides. Right. This is everything we've been waiting for. This is our implementation of that constant product algorithm. And it's not as big as you probably thought it was going to be. Right? It's actually quite simple.
00:34:15.647 - 00:35:49.997, Speaker A: So here again, I wrote this stuff in the comments, but as you can see, we've got R equals F of P, F of P being our determine, swap, receive or constant product algorithm. And so we're going to have big R times little P over big P plus B and the larger numbers, the capital letters, meaning the balances. So you can see here that we pass in the balance of R in the pool, the decimals of R, which I'll talk about in a second. The balance of P in the pool, the decimals of P and the little P value, the amount of asset P that the user has offered to pay. And so just walking through this thing, big R, right? This is going to be the balance and we're going to convert to flow, right? Like I just wrote this little helper function, basically what I'm doing here is you're going to give me a balance, right? Let's say it's like, I don't know, I can't think of a good example, but ultimately what's happening here is convert to float is going to take the value and it's going to divide it by 10 to the whatever exponent number of the decimals. So like I mentioned an example in the slide, but like, if you have 10,500 of an asset with 3 decimals, you really have 10.5, right? And so the program is going to receive 10,500 and we need to normalize this with the decimal places.
00:35:49.997 - 00:36:35.481, Speaker A: So we go ahead and do this and then we get 10.5, and this will give us a much more accurate constant product K. So we do that for both big R and big P, and then we also do it for P, little P, right, because each of these amounts is going to be represented in that U64 large, you know, big int number. So as you can see from our little rust analyzer here, we end up with three floats. And then we can do some arithmetic. So we can go ahead and say big R times P, big P plus P. And then finally, according to our algorithm, we can do big R times P over big P plus P to get R.
00:36:35.481 - 00:37:06.207, Speaker A: And then we finally make sure R is not greater than big R, which would mean the value that we've calculated to give you back is more than our pool has. And we can't do that, obviously. And then finally when we return it, we convert it back to that unnormalized U64 value to give you the value R to have the quantity to be transferred out. And that's it, guys. That's a constant product algorithm right there. So that's how we set everything up. That's how we build this program.
00:37:06.207 - 00:37:51.755, Speaker A: This program works and it works well. And it's hilarious because I'm saying that, and I bet you my tests fail. But either way, you can get all this information from the readme and we talk about all this stuff in detail here. Again, constant product. And that moves us on to the tests, right? So now let's deploy this thing, let's run some tests against it, let's put some assets on it, and let's see what we can do with our swap. Now, before I do that, I want to show off my cool user interface. So in this repository, if you go to the app folder and you install everything with Yarn and then you run Yarn Dev, you will see my neat little user interface.
00:37:51.755 - 00:38:34.685, Speaker A: You will see that we have entered the pirate port. Oh, and this is actually good error to catch, guys. You have to set RPC Endpoint as an environment variable. The easiest way to probably do this is just head into app, create a env and just go ahead and do RPC Endpoint and you can set it to whatever RPC endpoint you want. Let's set it to DevNet. And then basically what I want to do now is go ahead and reboot this thing. And now that should allow us to connect to our RPC endpoint here.
00:38:34.685 - 00:39:03.411, Speaker A: And you should be able to see welcome to the port mate. Right now, these are the assets from a program I've previously deployed. So I'm going to change this up a little bit, but this is what you'll see on the ui. As you can see, we'll be able to pick from all the different assets in the pool. We'll be able to swap between them. And you can see that our wallet will allow us to get a little preview here. But this is probably not going to work just because I'm not sure if this program's deployed or not yet.
00:39:03.411 - 00:39:31.825, Speaker A: Yeah. But anywho, let's go ahead and change this to our program. So to do that, what I want to do is first I want to deploy our program. So I'm going to pop open a new terminal and I'm going to go to. I'm going to just run anchor build and then I'm going to make sure. And I know you guys are probably Freaking out about my positioning of my terminal. So I'll put it back down here.
00:39:31.825 - 00:40:13.465, Speaker A: So that's going to run anchor build on our program and then of course we're going to get this address out and we want to just make sure that our librs matches. It looks like it does. And our anchor TOML matches and then we can run Anchor deploy. And I'm throwing this on to DevNet. So you want to make sure DevNet is in your config and we go ahead and deploy it. And once that's deployed, what you want to do, or even while it's deploying. Well, I think you should probably wait anyway, is if you look at the UI, you can see in Source IDL, we've got the IDL JSON and we've got the TypeScript type bindings.
00:40:13.465 - 00:40:40.775, Speaker A: Right now the type bindings aren't going to change since I last built it, but what is going to change is this address at the bottom of the idl. So I didn't change this program. So all I'm going to do is change this value. Right. And I'm going to just take down my UI until we finish deploying the program. This is probably going to take a while, but once that's done, we'll be able to go ahead and interact with our program from the ui. So while that's running, hopefully it works.
00:40:40.775 - 00:41:09.445, Speaker A: We can actually set up the other tests first. And so this is where the test can be a little bit confusing, but if you want to take a look, we've got a couple things here. So if you look at Anchor Tamil, these are in order. So Update, Upload JSON, Create Assets Test and Master test being of course main. So for the most part you can ignore Master. It's kind of there for the administrator of the Bootcamp to sort of quickly one off, do some scripting. But the other three tests are going to be important.
00:41:09.445 - 00:42:12.027, Speaker A: So the First1, upload JSON, this is stuff that you probably saw earlier in the session. And basically what we're doing is we're going to take all these images up in the Assets folder and those are going to be the Assets folder in the Bootcamp, and we're going to deploy them out to arweave using the Metaplex JS SDK and using Bundler, right? And so all we're going to do is set up a Metaplex instance, we're going to go ahead and log into Bundler, we're going to just set up all of our stuff here, and all we're going to do is upload the metadata. So it's on there and we can access it with the URI field. And so that's pretty straightforward. I have already done this, so I'm not going to run it. But if you do need to do this or you want to change your images or what have you, you can do that. The other test, the next one is going to be create assets, and this one is basically going to give us the ability to create new tokens to serve as our assets, like our cannons and our gold and whatnot.
00:42:12.027 - 00:42:43.829, Speaker A: Right. So first things first. In the repo, I want to make sure I just run a quick yarn, make sure I install all the local dependencies for this, like anchor workspace. And then you can see, just walking through here, we're just doing a loop through all the assets, the assets being in the constant file in util. And you can see right here, these are all the different assets. I've already got my Arweave URLs here, and this is decimals and quantity. And I'm going to be the mint authority of these because that's what the script is set up to do.
00:42:43.829 - 00:43:17.033, Speaker A: So it's going to create each of these with us, or whoever your local key pair is as the mint authority, and then you can go ahead and set up a config file, which is just going to write it to a JSON so we can use it in our other tests. Right. And if you want to take a look at how this thing works, you can pop open mint new tokens. It's literally straightforward. It's just going to set up the different instructions you need to do it. Right. So create account, initialize mint, Create metadata account and create associated token account Mint 2.
00:43:17.033 - 00:43:37.445, Speaker A: Right. So all that stuff, which is pretty cool. And one last piece on this. When you do create assets, there's a flag here for metadata. If you're using local net, you can turn it off. If you don't have the metadata program cloned, I'm going to set it to true since we're on devnet. And that'll mean that our tokens will have images, which means our UI will work, which is great.
00:43:37.445 - 00:44:04.795, Speaker A: So before we head over to the main test, let's take a look and make sure our program deployed. It did, which means we can reboot our UI and we can go ahead and see our new program. And it should probably have no assets yet. Right? It should have nothing. Yep. So account does not exist or has no data, so probably should handle that error. But that means we have no tokens.
00:44:04.795 - 00:44:39.625, Speaker A: Actually, what this is probably barfing about is this is our liquidity pool, which doesn't exist yet because we haven't initialized it. So with that being said, let's go ahead and do this test. So first we're going to create some assets. And so you can do yarn Run or you can do Anchor Run, and I'm going to do Anchor run, create assets. And that is going to create for us those new tokens based on our config file. So we just created all those tokens on DevNet. You can see how fast that was, right? And then we're going to go to our main test and take a look at what we're going to do here.
00:44:39.625 - 00:45:16.515, Speaker A: So first thing we want to do, load the assets in from the JSON file, right? And then before, we want to make sure the pool doesn't exist already, before we run this blah, blah, blah, right? If it does, it already exists. We skip it. Here's where we create the pool. And if we pop this open, you can see we're just running this anchor function, right? So we got our program CreatePool, no arguments. Here's the accounts we wrote and RPC to send the transaction. So that's going to create our pool pda. And then this check is just going to make sure if it exists, we don't run that again because it's going to fail, because that's the way we wrote the seeds.
00:45:16.515 - 00:45:52.881, Speaker A: And then we're going to fund the pool with some more assets, right? And this is just for the sake of making sure that there's enough in there for swapping, especially if something changes. You could run this test and make sure that there's enough assets in there. You can also comment this out if you don't want to do it. And then we can get some information about the pool and finally we can try a swap. And I got this set up to do this a couple of times. So we'll try a couple different swaps, right? You can see it's on a loop here. And I'm basically just saying like log, pre swap, log, postswap.
00:45:52.881 - 00:46:18.579, Speaker A: This is just log statements, These are just print statements. I went through a weird amount of time setting this up and you'll get to see why. But ultimately this swap function is going to be what triggers our program. And you can see swap accounts, et cetera. Here's all the accounts that we have. Here's our token accounts, right? So essentially what we're doing is initializing the pool. If it doesn't exist, funding it with liquidity.
00:46:18.579 - 00:46:42.125, Speaker A: That's our second instruction. And trying a swap, our third. Cool. So since our, you know, liquidity pool doesn't exist yet, let's do anchor run test and let's create this thing. We'll run a couple of swaps and then we'll check out the ui. And I'm going to full screen this so you get to see my beautiful log statements in all their glory. As you can see, I've got some decent ones for the mints.
00:46:42.125 - 00:47:03.125, Speaker A: Let's check them out for this. So here we're going to create that pool right now it's initialized. We're funding it with some mints. We are the mint authority, so we can just mint new ones to ourselves and fund them into the program. And there's the liquidity pool. There's all the assets that it has and its balance. And now here you can see this is the card for pre swap and post swap.
00:47:03.125 - 00:47:54.915, Speaker A: So we wanted to pay muskets, we received telescopes, right? We were offering to pay 19 muskets, and so we started with 79 in our account, and the pool had 60 muskets. And when we were finished, the pool had 79, we had 60. Makes sense. And since the pool started with 20 telescopes and it now has 15.19, you can see that the R value, we offered to pay P19 muskets, and instead we got back our five telescopes. And this makes sense because there's many more muskets inside the pool than there is telescopes, right? So of course we're going to get less telescopes than the number of muskets we're paying. And that's how these pools work, right? Like it's all based on liquidity.
00:47:54.915 - 00:48:24.085, Speaker A: If there's a ton of muskets and not a lot of telescopes, you're going to have to pay a lot of muskets to get some telescopes. Conversely, if you had a lot of telescopes and there wasn't a lot of telescopes in the pool, your telescopes are worth a lot of muskets. Right? And that's how these pools work. That's how DEXs work, at least those that use liquidity pools and the constant product algorithm. So you can see this kind of thing continues, right? We go through a loop, we do a bunch of swaps, and let's take a look at one more. Right? Let's take a look at some gold. We offered to pay 4.
00:48:24.085 - 00:48:54.055, Speaker A: And these are just random numbers, by the way. We offered to pay 4 gold in exchange for muskets. And let's take a look at what the pool has for gold. The pool has a lot of gold, but at this point, it's getting low on muskets. Right, so what are we going to get back for four gold? Well, we get a fraction of a musket, right? A very small fraction. And that makes sense because muskets are now becoming rare in the pool, which is cool. So now this is all done.
00:48:54.055 - 00:49:22.947, Speaker A: Take a look at this, though. If you look at each of these blocks, look at this. I've included our delta K, which is the change in the constant product K. Look at how small that that change is, right? In each of these we've got it down to the thousandths, even the hundred thousandth place of percent change. Except this one. That's strangely high. Right? But you can see that they're very, very tiny, almost negligible.
00:49:22.947 - 00:49:58.315, Speaker A: Sometimes they're flat out zero, at least for the decimal places we're printing. And that, my friends, is why we did the whole normalizing the decimal places and everything. Because this is a true calculation of the change in K, we're just calculating the constant product on the client side and then checking it before and after with these log statements. And this is what we're ending up with. So I would say we have a pretty good working swap program. So feel free to play around with those tests all you want. Let's try refreshing our UI and see if we can load up our assets.
00:49:58.315 - 00:50:23.493, Speaker A: Welcome to the Poet Mate. And there you go. There's our updated assets from our program with our balances there. And just to kind of verify, let's take a quick look at our last test run. And let's just look at gold. Right? There was 647gold after we offered to pay 14 compasses, which were rare. And we received a lot of gold for those compasses.
00:50:23.493 - 00:50:35.292, Speaker A: Right? Looks like 450 gold for those compasses. Those are worth a lot of gold. And then there's our gold right there. 647. Right. And we can see compasses. We finished off with 34 in the pool.
00:50:35.292 - 00:50:48.583, Speaker A: Here's the compass. 34. So we are looking at the proper assets. So cool. Let's go ahead and play around with our swap. Right, Let's. I think I want to get some more money for my compasses.
00:50:48.583 - 00:51:00.719, Speaker A: Right. So let's. Let's do compass for gold. And I want to do. I want to do two. You can see my receive number is calculating this as well from the token account balances. This is something I replicate on the client side.
00:51:00.719 - 00:51:22.551, Speaker A: I'll show you guys in a sec. But I'm going to give five compasses. I just don't know if I have these compasses in my wallet or not. I probably don't see. It's probably not going to work because I don't. Yeah, I'll actually have to put this on to Devnet. It is on Devnet.
00:51:22.551 - 00:51:40.287, Speaker A: Okay. Yeah, I don't think I have compasses in my wallet, but that's okay. We'll just go ahead and try cannons. So I do have some cannons, which is good. So I want to get some cannonballs back. I'm going to send two cannons. I'm going to receive 2.05
00:51:40.287 - 00:52:09.547, Speaker A: cannonballs. Approve and we have a successful transfer. And if we look at our Explorer transaction, you can see here's all the things that were invoked, yada, yada. Ultimately we want to take a look at this. Transfer two cannons and then this is my wallet, right? So this is me transferring to the pool and then transfer 2.05 cannon balls. And then the authority.
00:52:09.547 - 00:52:27.575, Speaker A: We already saw this CYG address earlier. This is the pool, right? So this is going from the pool to me. And that's really it, guys. That's a good working swap program. That's Dex. And we're going to take a quick look at some of the client side code, but I'm not going to go crazy on that. But again, I'm just building a front end from the idl.
00:52:27.575 - 00:53:08.791, Speaker A: We got the wallet adapter, stuff like that. And inside the component you can see here is a swap card. And inside the swap card, we're going to just kind of flop between set, receive amount, et cetera. And then let me see where I put this bad boy. Somewhere in here, I put the calculation for right here. This is pay swap right here. So pretty simple.
00:53:08.791 - 00:53:32.495, Speaker A: Same formula. And yeah, guys, so cool. So thank you very much for taking a look at the pirate swap. Thanks for coming to the port and I hope you guys enjoyed this session on building a decentralized exchange that's powered by the constant product algorithm and thus building a dex or a liquidity pool or whatever you want to call it on Solalo. Thank you guys very much.
