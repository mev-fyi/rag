00:00:01.280 - 00:00:43.184, Speaker A: Hey, guys, it's great to be here. Today I'm speaking about widening the design space of amms with Solana. So the cheap compute on Solana really cracked open the design space for AMm mechanisms, and it really has yet to be fully explored. As we walk down this path of mechanism design exploration, it'll be helpful to have a guiding principle. So the guiding principle here is to create protocols that benefit users. Now, in the context of an amm, you've got a few different user groups. You've got traders who are trying to optimize for swaps, and then you've got liquidity providers who are trying to maximize their long term game.
00:00:43.184 - 00:01:32.180, Speaker A: Now, it may seem that these two user groups are at odds with each other. They may be, but at the intersection you'll find two related ideas, capital efficiency and risk management. So today I'm going to be talking about two mechanisms that you can add to your protocol developer tool belt in that category. The first is market making beyond constant function equations, and the second is interconnected markets. So, first of all, why do people use constant function amms? Well, first off, they're simple to calculate, which is great for lower throughput chains. Secondly, they're price path independent, which can be a good thing. Third, they're really good for bootstrapping new markets.
00:01:32.180 - 00:02:10.874, Speaker A: So what are the downsides? Well, you can suffer from impermanent loss and they're less capital efficient than clobs. All right, so what might a next gen ammo market maker look like? Well, here's one occasion. It, it's a power function. It has this parameter s. And by changing this one parameter, you can affect the concentration of liquidity near the mark price. So you might want to change this parameter depending on the tokens in the pool or the market conditions. So it's, it's pretty versatile.
00:02:10.874 - 00:02:56.654, Speaker A: The only problem is it's complicated to compute. It's non linear and it's not quadratic. So we all remember the quadratic formula, you know, so what's required is an iterative algorithm for finding a solution. Now, that's just basically a guessing game where it makes an educated guess, says, okay, is this close enough? No, let me try again. And it gets close each time. Newton's method is one way of doing that, but depending on your specific market making equations, you can get it much more optimized. Now, with all these iterations, you're going to use up a lot of gas.
00:02:56.654 - 00:03:35.240, Speaker A: So these calculations are actually really expensive. Normally, a single power function, a single logarithmic function takes up 10% of the compute available in a salon transaction. And that would cost about a dollar on ETH mainnet. So we developed the tachyon math library, which reduces compute costs by about ten x for those functions. How does it do that? Well, what you do is you calculate hundreds of thousands of values for these functions. You upload them on chain and then you do interpolation. So it's pretty cool.
00:03:35.240 - 00:04:05.344, Speaker A: It's very accurate. I suggest everybody check it out. It can also be used for things aside from market making. So if you have some expensive algorithms you're trying to run on chain, I'm happy to help anybody get set up with it. It's open source. And also these sort of market making functions might be really helpful in hybrid systems such as drift or root. But this is pretty cool, right? So now we can market make with basically any equation.
00:04:05.344 - 00:04:50.956, Speaker A: We have a library that reduces the compute cost of that. So, you know, it can have a lot of, a lot of different use cases. All right, so that was mechanism number one. The second mechanism is interconnected markets. The risk for any market maker, automated or otherwise, is having stale orders on an order book or an Amm, which no longer reflect the market price. So, well, what does that mean? In other words, you don't want to sell Sol for $10 when it's trading at 20 or 40. Put differently, from a sort of different perspective, you don't want to offer orders which enable another party to create an arbitrage trademark.
00:04:50.956 - 00:05:25.254, Speaker A: So that's bad. That means they're getting money that you could have had, and we want to avoid that if we're market making. In traditional market making, this is a latency game. In amms, this is also referred to as impermanent loss. So, let's walk through a potential situation here. Let's say there's a protocol and there are four pretty similar Solex points. Let's say these are sole stable pools, USDT, USDC, USDX, whatever.
00:05:25.254 - 00:06:13.098, Speaker A: So normally, when the external market price moves, there are arbitrage trades to be made. So the LP's are losing, the arbitrage is gain. And in this diagram, I've represented this by four blue lines. But there's more information that these protocols can use on chain to prevent the extent of this damage. So if you know one, one simple way to do this is to connect the market so that they can see each other's prices. In this new mechanism. As soon as the external price jumps, then, okay, one of the pools gets arbed and its price moves up, and so does the average price.
00:06:13.098 - 00:07:02.834, Speaker A: Now, if the pools are aware of this average price, they can not offer, you know, a better deal than that. And so the next arbitrage trade that happens will actually be reduced. So reducing opportunities for arbitrage, reducing impermanent loss, it's the same thing. And it really depends a little bit on how you implement this. But using on chain information to reduce arbitrage opportunities and impermanent loss is definitely something that should be further explored. And again, this is really only possible in Solana, because scanning a bunch of different prices and creating an average is pretty compute intensive. And if you're storing all these prices in the same account, then you're going to need a zero copy account, because that's a lot of data.
00:07:02.834 - 00:08:06.474, Speaker A: And this last thing is hypothetical. This same concept can be applied to order books. So let's say that each order you submit has one or more conditional checks. And maybe these conditional checks are in reference to another market on the same protocol, so that when somebody's trying to fill an order, the protocol will just check and say, hey, are these conditions met? Is this order still valid, or should I pull it? And this could be really useful in a case where you're market making and the price moves and 400 milliseconds is faster than any blockchain that exists, but it's not super fast in market making terms, traditionally. So this is just a way that that could also be applied, and those are the two mechanisms. So thank you for listening.
