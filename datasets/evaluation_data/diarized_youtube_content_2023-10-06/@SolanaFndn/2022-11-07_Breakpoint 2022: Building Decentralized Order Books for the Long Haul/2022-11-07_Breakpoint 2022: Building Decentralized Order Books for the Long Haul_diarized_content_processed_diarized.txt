00:00:00.600 - 00:00:22.234, Speaker A: Good afternoon, everyone. My name is Jerry Shao. As mentioned, I used to work at Solana Labs. I recently left to do something new during this talk. Near the end, I'll start talking a little bit about what I went off to do. But the purpose of this talk is to talk about building decentralized order books. And the focus will mainly be on the technical design and trade offs of designing such a system on a blockchain.
00:00:22.234 - 00:01:08.668, Speaker A: So first, we need to talk about what an order book is. An order book is simply a mechanism for, uh, some exchange to manage the state of certain orders. And what orders are, are simply, uh, like, basically a way to determine, um, who the buyers and sellers are. In a market, an order has a couple parameters. There's, uh, the side that the order is on, whether it's a buy order or a sell order. Uh, there's a price, the price that the order will get traded at, as well as a size, the amount of asset or widgets that particular order represents. If you took all the buy orders that were in the market and you were to sort them from highest price to lowest price, and by least recent to most recent, you would get the bids.
00:01:08.668 - 00:01:46.890, Speaker A: And for the offers, which is the other side of the book, that would be sorting the sell orders from lowest price to highest price from least recent to most recent. And when we do this, we get a market where the bids and the offers have prices that do not cross each other, meaning that the highest bid is always going to be lower than the lowest offer. And now that we have this order book, we can do a certain number of actions, one of which is to buy. So here we see a limit buy order for four of this asset at $100.01. And we see that the offer at 101 and $0.01 reduced from 4.2 to 0.2.
00:01:46.890 - 00:02:16.634, Speaker A: You can also sell. In this case, it's a market sell. What a market sell means is there's no price associated with the order, and instead, you'll get immediately matched with anything on the bid side of the book. And here we see that 20 orders removed on two levels of the bid. You can also post liquidity by posting limit orders. So here's a limit order to buy 20 at $99.99. What this will do is it will add a new order to the bid now, at the top of the book, and the same thing with limit selling.
00:02:16.634 - 00:02:56.116, Speaker A: Now we see two orders posted on the offer side for $100. And in this case, notice that it does not result in a trade because the price listed is higher than the best bid on the book, the last action you can do is canceling. And in this example, I'll go into how that would look. But to do so, we need to zoom into what a particular price level of this book might look like. So here we're going to zoom into the order or the level at $100.03. Here we see that the size posted is 30.9. And we have four orders on this level, each with a different time posted, and they're sorted by least recent time to most recent time.
00:02:56.116 - 00:03:21.856, Speaker A: We have four users here, Alice, Bob, Charlie and Diana. And if you were to sum the column of size, you would see that it adds exactly to 30.9. Now, let's pay attention to Alice, whose order id is a and has size two. We see that if we were to cancel a, the level at $100.03 gets reduced from 30.9 to 28.9. So, yeah, and once again, when we look at this price level, we see that that order from Alice has been removed.
00:03:21.856 - 00:04:00.944, Speaker A: These are the pretty straightforward operations of an order book. You can buy, you can sell, and you can cancel. So why are order books important and why are they useful? The main thing is that order books are one of the greatest ways that you can have a mechanism for price discovery. They enable the users to post prices, to buy and sell assets. And these prices are going to naturally disagree whenever there is a disagreement in prices. This results in a trade, and by having everyone who wants to post, buy and sell orders, we can match buyers and sellers fairly at the prices that are listed. They also enable some protection against adverse selection.
00:04:00.944 - 00:04:42.718, Speaker A: So adverse selection is not like it is always available, it's always there for any market. But order books are good because they allow you to cancel orders in the case that you're about to be adverselected against. Suppose that the taker knew that the price of an offer was way lower than it needed to be. If the person who posted the offer also knew this fact, they can remove that from the book and avoid being traded against. And these two mechanisms basically allow orderbook to drive hundreds of billions of dollars of daily trading activity in traditional finance. Why should they be decentralized? Well, anyone who's used a blockchain knows that blockchains allow for instantaneous settlement of funds. This is a huge innovation.
00:04:42.718 - 00:05:30.316, Speaker A: If you've ever transferred a token on Solana, you'll see that the process takes maybe a couple seconds to confirm and under half a minute to finalize. This is certainly very different from doing something like an ACA transfer or, or a wire transfer. In traditional finance, these can take order of days to settle. Additionally, all information about trades and orders are 100% public, and this has some trade offs. It certainly changes the game theory of how you might want to provide liquidity on an orderbook. But it does lead to a more open and transparent financial system, which is something that many people are looking for and have criticized about the traditional financial world. Um, the last component that I think is important is that order books and really any kind of, uh, decentralized activity in, uh, the financial space allows for composable liquidity.
00:05:30.316 - 00:06:43.522, Speaker A: What this essentially means is that you can have a number of different protocols or smart contracts call into the liquidity, uh, while performing other actions atomically, uh, meaning that if those other actions are unable to be completed, uh, the whole transaction is going to roll back. So this is a feature that is really unlock, like blockchain, and not really present in any other aspect of any other system that exists in the centralized world. Lastly, I want to talk about why Solana, so Solana is a high throughput blockchain, and by having high throughput blockchains, it really enables the creation of new efficient liquidity primitives. On Ethereum, which is a blockchain that can process ten transactions per second, Uniswap introduces the notion of Xy equals k, which, which is this concept of a constant product automated market maker. While this is incredibly innovative, because it is designed to meet these very narrow constraints, it is purely an approximation of how prices truly move. And when you are opened up with a lot more resources, the design space should enable more complex features. An order book is such an example of a mechanism for allowing liquidity to be present on chain.
00:06:43.522 - 00:07:15.716, Speaker A: And order books in particular require low gas fees, relatively high throughput, and large blocks, all three of which Solana provides today on mainnet. So next I want to talk about some of the design constraints that Solana imposes on you. It's really important when you're building smart contracts to understand the limitations of the system. And Solana certainly has a few things that programmers need to think about when designing these things. The first one is transaction size. When you're sending data to the network, you need to pack everything into exactly 1.2 kb.
00:07:15.716 - 00:07:53.592, Speaker A: This includes all instruction data and account addresses. This is particularly restrictive because account addresses are each 32 bytes, which basically means that you're limited at around order of 30 ish accounts that can be used. These are basically the pieces of state that get modified. Compute units correspond to the actual amount of computation that's used by the chain when it's processing the transaction, you generally want to keep this as small as possible. Account size is another constraint. The maximum size of any account on Solana is ten megabytes, and for every byte additional that you add on top of your account, you have to pay more sole costs as rent. So it is really important to keep it as minimal as possible.
00:07:53.592 - 00:08:26.200, Speaker A: Lastly, composability is very important. You really want to make sure the interface for your program is as easy to work with as possible. For an order book in particular, there are certain properties that you want. You want it to be sorted, you want fast insertion, and you want fast deletion by key, these map to the operations of placing orders, trading and canceling. Placing orders are insertion and canceling and trading. Both correspond to deletion from this order book structure. The natural data structure that you'll learn from your intro computer science class is a treat.
00:08:26.200 - 00:09:05.964, Speaker A: This has order of login operations for both insertion and deletion. However, Solana poses an additional constraint. You really want the tree to fit into a fixed size buffer. If you remember from your intro CS class, these trees are usually defined recursively, which means that the memory locality is quite disjoint, which means that there is a tricky problem of taking this tree structure and fitting it into a fixed size buffer. This is a problem that I worked on a bit when I was at Solana Labs with a library called Sokoban. But for a order book in general, there are many data structures you can use. You can use a crypt bit, which is a binary try, if you know what that is, or some sort of self balancing binary search tree.
00:09:05.964 - 00:09:46.034, Speaker A: Both of these are viable options. I'll talk about some of the trade offs there in the next slide. So on the right hand side of the screen, you see some structures that are present in the serum dex order book source code. Here we have implementation of a binary try or a critbit where you have two objects, an inner node and a leaf node for a crypit. What is important to know is that the important information of the order is only present on the leaf node, while the inner nodes only contain metadata of where to traverse to next. Both of these structs are 72 bytes. If you look on production, the size of the CRM order book for the bid is around 65 kb.
00:09:46.034 - 00:10:28.542, Speaker A: If you divide those two, you get around 910 nodes. But because only the leaf nodes contain valuable data, you only really have 455 nodes per side. And this really plays into the account size limitation where we want to make sure we can pack as much information into the bytes we have as possible. If you have a self balancing binary tree, you actually get to utilize all the nodes. Every single piece of state gets utilized more efficiently. Another thing to note, based off the constraints that we mentioned, is that you want to minimize transaction size and maximize composability. In the implementation found here, the bids and asks occupy different accounts, and in reality they should probably use the same account to represent the data.
00:10:28.542 - 00:10:58.054, Speaker A: And this will reduce the number of addresses you need to pass in by one. And that will in addition make composability more seamless. Here's an example of how I think an order book might be built on Solana. You really want a structure that is zero copy that you can load without copying the data or moving bytes around. And you should really put the bids and ask into the same account. And using a self balancing tree makes the most sense because you get the most usage out of the state. Another hard problem is representing price and size in orderbook.
00:10:58.054 - 00:11:40.654, Speaker A: Usually you want to use U 64s, which are eight byte unsigned integers, uh, because those are compute optimized. In the Solana runtime, there is a default, uh, instruction that allows you to multiply these things efficiently. And this increases a lot more when you, uh, increase the, the granularity of, of that, uh, that object to like a U 128. The problem is that this is on the order of ten to 19, which sounds enormous, but in fact, multiplication can overflow this quite easily if not properly, uh, checked for, which means that you want to have, uh, somewhat not granular sizes on the book, which we call lot sizes. So for every book you have two currencies to trade. There's base currency and quote. Currency base would be like Sol BTC, or ethan quote would be something like USDC.
00:11:40.654 - 00:12:15.224, Speaker A: And you want to have some sort of notion of the minimum units to transact there. Another neat trick that you can do is add some sort of types for these things to avoid any numerical error when you compute stuff. And this should be detected at compile time. I'm going to rush over the slide a little bit. It's a little bit too nuanced. But the idea here is that we have different price levels that we need to represent in the book. You probably want to make these somewhat granular, and the way that you do so is with these things called tick sizes, where instead of making everything in units of single quote lots, you might want to have the minimum price discrepancy in units of multiple quote lots.
00:12:15.224 - 00:12:51.218, Speaker A: Another big problem that comes with designing order books on chain is this idea of cranking. So this is a very interesting one where you might come across situations where someone makes a trade against an order book, uh, but wants to also atomically settle every transaction. Um, I'd argue that in certain cases, this is fundamentally impossible. So let's follow through this example. Suppose Alice were trying to sell ten widgets to Bob's bid, uh, and Bob has a bid posted at $10. And at exactly the same time, Eve will post a new bid at $10.01. And now we have a race condition.
00:12:51.218 - 00:13:37.254, Speaker A: If Alice's transaction hits first, then she and Bob can hypothetically be atomically settled, but Eve is first, then Alex's transaction will fail. The reason for this is that when you structure a Solana transaction, you must pass in every single piece of state that gets modified. In this particular example, because Alice might know that Bob's bid is at ten, she might pass in the state corresponding to Bob's state, but she'll never know about Eve state. And because there's no way to do this, in one transaction, you need to asynchronously settle, which is known as cranking. Again, you can't know who you get matched with a priori, and cranking is a solution to this problem. But cranking also has some issues as well. It is quite operationally expensive.
00:13:37.254 - 00:14:28.008, Speaker A: If you do the math on cranking once per slot per market, at a sole price of $30 per sol, it costs around $12,000 a year to crank a single market. If someone is operating an exchange or someone is trying to support a decentralized exchange, there must be orders of hundreds of thousands or orders of millions of dollars spent towards operationally supporting all of these markets just to pull the crank. Additionally, this is quite centralizing. In order to operate a crank, there must be some sort of server that sits somewhere that keeps turning this and processing trades to make sure that everyone gets settled. Um, if there's no server to run the crank, uh, we'll see that sometimes these markets will, uh, cease to a halt. So cranking is obviously a very big problem. And the way that you can avoid it is if you always know the counterparty.
00:14:28.008 - 00:15:55.404, Speaker A: So there's some trade offs involved here, but I think that is really important when you're designing order books to understand the full state of, uh, what are the things that are allowed and what are what is not allowed and how you can manage that trade off space to build the best possible product. The last point I want to talk about is data indexing and APIs. Whenever you interact with any smart contract, it's very important for the user and also the client application that performs that interaction to know what occurred on the blockchain. So this I think that smart contract should be designed with the ability to pass back responses to the user and they should admit events of all the actions that occurred that get persisted to the ledger. This way what you can do is query the transaction by the signature hash and get back a jSoN of whatever occurred when you interacted with that program. This is also really useful for if you want to build some sort of indexing service or an API service that is able to both track the state of all of the orders and actions that occurred against the order book, as well as provided an interface for users to build SDKs and interact with this program. So as mentioned at the start of the talk, I left Solana Labs a few months ago to start a new company and this company is called Ellipsis Labs.
00:15:55.404 - 00:16:34.040, Speaker A: I wanted to start ellipsis labs because I think that Defi needs better liquidity primitives, order books being one of them. This is the reason why we're building Phoenix, which is a new spot limit. Order book implementation on Solana and Phoenix will have a few key characteristics. One is that the transaction sizes will be minimal, it will be space efficient with respect to how bids and offers are represented in the state. There will be no crank and it's designed with indexing in mind. We really hope to build a liquidity primitive that can last for a very, very long time and is built with a lot of thought. We are also hiring engineers.
00:16:34.040 - 00:17:10.494, Speaker A: We really want people who have experience with Solana and enjoy diving in and understanding really, really complicated systems like order books and markets. Anyone with a high level understanding of market structure also really interested in talking to them because we think that this problem is very nuanced and we want people to think critically about how you can manage the tradeoff space of Solana to build a really sophisticated liquidity primitive people with product engineering experience and quant finance background also a huge bonus. Please reach out to me on Twitter or email founders at ellipsislabs xyz if you're interested. Thank you so much for your time.
