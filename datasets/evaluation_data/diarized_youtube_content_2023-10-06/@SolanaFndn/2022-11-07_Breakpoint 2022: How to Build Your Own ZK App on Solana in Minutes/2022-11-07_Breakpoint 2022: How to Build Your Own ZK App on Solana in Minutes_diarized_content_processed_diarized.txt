00:00:00.680 - 00:00:53.434, Speaker A: All right, so good morning from you again. I'm, as you mentioned, Nico from elusive. And what we're going to be talking about today is how to build your own ZK privacy app on Solana in minutes. And, yeah, as mentioned, it says ZK there, but we're going to focus more on the privacy aspect of it today. And so if we're going to be talking about this, probably a good question to answer first would be, you know, why is privacy even important in the first place? That we're dedicating a whole workshop to it in web3. And the current status quo of how, you know, transactions work on most blockchains at the moment is that you have this sort of pseudonymity, which means that, you know, if you're on a blockchain, people, if they look in the blog explorer, can't see, okay, Niko sent so and so much money, but they can see a certain array of bytes, send so and so much money to a different array of bytes via accounts. And this works pretty well for most cases as long as you're, you know, doing stuff where you're not directly involving your real life identity when interacting with other people.
00:00:53.434 - 00:01:26.466, Speaker A: So, for example, you know, trading in Defi or something like that. But then as soon as you start transferring and trying to connect with the real world, payments is a great example for this. You start running into problems just because, yeah, consider you go to a coffee shop, you pay with, you know, you pay with Solana pay, and suddenly the coffee shop can see, okay, this is Niko's account. He has so and so much money on it. He spends so and so much money. This is his income. Information that most people wouldn't even be comfortable sharing with their close friends or even family is suddenly visible to everyone in the world without the other people even asking if they're allowed to see that information.
00:01:26.466 - 00:02:25.974, Speaker A: So for that reason, privacy is just incredibly important if we want web3 to go mainstream and simply have a more similar UX to web two and get more normal users on board, aside from just general crypto users. And, you know, the first use case, as mentioned, is already simply that most people aren't really comfortable sharing all this information with everyone in the world. But the second use case is, of course, that can actually bring significant dangers with with it if you don't have that privacy built in. You know, again, coming back to the example of the coffee shop, assume you go to a coffee shop in the morning, you buy yourself a coffee for $5 with Solana pay. But some bad actor is scheming outside and, you know, wants to rob someone. And suddenly, if you didn't have this privacy, that bad actor could go in the coffee shop. Before you pay for a coffee, memorize the coffee shop's address, and, you know, just skip team outside the coffee shop, wait for someone with a large enough balance to walk in and buy a coffee and rob that person as they proceed to go out, which is something you want to avoid.
00:02:25.974 - 00:03:14.808, Speaker A: So for that reason, privacy is quite important on that front. The other aspect of that as well is probably defi, it's a very important use case as well. As we saw, with things like three arrows capital in the past, having every single one of your positions, especially leveraged ones, visible to the whole world, is not always a good thing. Just because if you have, you know, if you're running a company and have competitors, or if you just have a lot of enemies for some reason, if everyone can see your leverage positions, then they can see, hey, if Sol falls to so and so price, you get liquidated, they can actively trade against you, which is not ideal. So, yeah, and of course, plenty of other use cases for that as well. So you might then be thinking, okay, so, Nico, if privacy is so important for web3, why isn't it more widespread yet? And for that, we've identified three main reasons. The first one, in the past, has been cost.
00:03:14.808 - 00:04:04.774, Speaker A: So if a normal transaction, especially on Solana, is very cheap, very fast, you know, a fraction of a couple of cents, but then suddenly, to use a private transaction, that's way slower, way more expensive, especially on other chains where transactions are already more expensive as it is, users are not going to be willing to use it again. Buying a five dollar coffee and paying a $20 transaction fee, not ideal. So the way we circumvent that with elusive is, on one hand, we have the silver bullet called Solana, which simply has super cheap, super efficient transactions by default. So through that, we can already get the cost way down. And on top of that, simply by doing a bunch of optimizations to our on chain proof verifier, we're able to get the cost down to, you know, less than a cent, or around a cent. Okay, next. So this is not as cheap as what you conventionally have on Solana, but it's definitely way more acceptable than multiple dollars.
00:04:04.774 - 00:04:37.760, Speaker A: So, next problem. Okay, if we get the cost down, what else is holding people back from using privacy in their daily lives? So, in past systems, the way privacy systems would be set up is that you might even have to switch to a different chain altogether, like Monero or zcash or something like that. Or at the very least have to go to a different website, require people to go to elusive.com, and then on elusive.com you can make a private transfer. Again, this is not ideal. There's a reason why Solana is the most used chain, because it has such great UX, has such great protocols, cheap fees, everything.
00:04:37.760 - 00:05:16.310, Speaker A: If we then tell people, hey, you have to choose between using Solana with its great UX and great apps already built on it, or you have to choose between using that and privacy on a different chain, which isn't as nice to use as Solana is. Most people will probably choose the UX, and this also works on a smaller level. Like if we say, okay, you can stay on Solana, but you have to go to the elusive website. You can't do it from your wallet directly. Most people have their favorite wallet. They love using soulflare, for example. And it has sleek UX, it works well, and they can just do ascend just like that, instead of having to go through the whole extra steps of going to an external site and just for having privacy built in.
00:05:16.310 - 00:06:21.254, Speaker A: So for that reason, we take the approach of just making privacy as composable as possible with standard Solana protocols, meaning we don't have an extra elusive, elusive address or elusive whatever. It can directly interact with other Solana accounts. And beyond that, what we'll be talking about afterwards is we have an elusive SDK with which you can build privacy directly into your existing app, instead of having those two have to be separate features. And finally, this one might not be as sexy as the previous two, but in our opinion, is just as important, if not even more important, especially when talking to other developers. And you guys might be familiar with this as well. The big risk with privacy in the past, especially when you think about things like Tornado Cache, has been that you want to add this cool privacy feature into your app, give that access to that for your users, but then you sort of have those thoughts in the back of your mind, what if someone uses it for bad? What if, because of adding this one feature, again, the huge trouble that I don't want to deal with my protocol? Well, if that's the case, maybe I won't add the privacy at all, just to be on the safe side of it. And for that.
00:06:21.254 - 00:07:09.246, Speaker A: But of course, we don't want to build a system where everything's like, you have to kyc yourself to use it or something else. So we need to find a good middle ground. And what we do for that is in cyber SDK. As I'll show afterwards, we give developers directly the option to choose the level of compliance that they want to have in their specific implementation. So that means for the rogue cipher punks amongst you who wants a full decentralization, nothing at all, you have that option. But for people who prefer to be a little bit more on the safer side, and if you need to do that because of your legislation or whatever, you have that option as well. So yeah, before we get into the coding side of it, I think what might be interesting to think about a little bit as well is just for those of you who might not be as familiar with how these privacy systems work, is just a quick overview of how can we add privacy to a chain that's not private by default.
00:07:09.246 - 00:08:08.254, Speaker A: And the way we do that is with a two step process. Basically you have your normal solana balance, which anyone can see, and you have a private balance that's stored on chain and managed by the elusive program. And the way you answer your private balance is simply you generate a couple of secret values that only you know, that you don't share with the world, and you hash those to a certain cryptographic hash. Then you take that certain cryptographic hash along with the amount of money you want to top up your private balance with, and you send that off to the elusive program saying, ok, I want to top it up with tosoul and I want to have it linked and managed via this specific hash. Cool. So now you have a pride balance on chain, but what does that do for you? Well, most interesting you can do with it is send money to someone else, obviously. And the way you do that is using the zero knowledge proof, which is, just as most of you probably already know, a mathematical argument with which you can prove knowledge of a certain value without actually revealing what that value is.
00:08:08.254 - 00:08:50.364, Speaker A: In this case, obviously the idea would be, is you have these commitment hashes stored on chain, which are hashes of secret values, and you want to prove to someone else, the program in this case, that you know what these secret values are without actually revealing them to the world. And for that you use zero knowledge proof. And then once you've generated that zero knowledge proof, you send that off to the elusive program. It verifies the proof. If it runs smoothly, it says, okay, I now know that those funds belong to you. And because of that, I'll allow you to send two of your ten sol in your private balance to someone else. One thing that might come to mind at first, if you think about this is like, wait, so that means if I go to the block explorer, what you'd see is Niko topped up his private balance.
00:08:50.364 - 00:09:20.544, Speaker A: Niko submit a zero knowledge proof, which led to two sol being sent. In that case, you wouldn't have gained any privacy at all, just because everyone can see I submitted that zero knowledge proof. So for that reason, what we actually have is a little intermediary step, which. Which are relayers, which means when I generate my zero knowledge proof, I submit that zero knowledge proof via HTTPs to a relayer. He encodes it in a Solana transaction and submits it for me. And because of the way zero knowledge proofs work, he can't actually adapt any of the values inside of that proof without making the proof fail. So through that, we've just achieved privacy.
00:09:20.544 - 00:09:49.974, Speaker A: Because in that case, if you were checking the block explorer, you'd see, okay, Nico topped up his private balance with tensoul. And amongst all these transactions, one of those probably came from me, but they all were submitted relayer number two, for example. So through that, we can achieve privacy. So now into the more interesting stuff, which is how you can build privacy into your own app. You can do this with elusive SDK. And this is rather straightforward. Basically, it's a three step process.
00:09:49.974 - 00:10:32.046, Speaker A: And let's walk through what we do if we want to create the most simple app, which is just a little app with which we can manage an on chain private balance and send funds to someone else from our private balance. So the first thing you do is you generate your elusive instance here, which has, you know, the last two parameters I think will be familiar to everyone. The standard connection, user favorite, RPC, and, you know, the key pair that's supposed to be the owner of that. The first part of this, the seed here, is what we actually derive those secret values from. So you can think of this sort of like how on a wallet, you have a little pin or something like this. This is similar to that, just a little cryptographic parameter from which we can derive values that should only be known to the user. Okay, so now we create our elusive instance.
00:10:32.046 - 00:11:02.906, Speaker A: What can we do with it? Well, let's create a private balance with it. So what we do is we call the build top up transaction. We say how much money you want to submit and what token you want to submit it with. We specify what token you want to submit it with, because currently elusive supports three tokens, which are LAN ports, or Sol, rather USDC and USDT. So, yeah, just specify how much you want to top your private balance up with. And how much you want to send and what type of token you want to send. Sorry.
00:11:02.906 - 00:11:29.034, Speaker A: Yeah. Then you sign that transaction and simply call elusive, don't send elusive transaction. And with those four lines of code, suddenly you've just created an on chain private balance from which you can privately interact with the world, which is pretty cool. Yeah. Next, what can you do with your on chain private balance? Well, the most straightforward thing that you can do is send money to someone else. And again, pretty straightforward as well. You have your elusive instance here.
00:11:29.034 - 00:11:51.834, Speaker A: You build a send transaction. You specify how much money you want to send, who you want to send it to, and what token type you want to send it off. You know, between those two steps, it does all the ZK stuff, generates the zero knowledge proof, encodes your data. You know, all that stuff. You get a nice little package out called send data. And again, you call elusive sendillusive transaction. Send it off.
00:11:51.834 - 00:12:28.190, Speaker A: And yeah, you can add some logic afterwards as well to verify a transaction I went through. And if all of that works, you've just created a private transfer with which you just privately send money to someone else. And all of that in five lines of code, which is pretty cool. We also have some other smaller features that might be helpful as well if you're integrating this inside of your app, because your users probably will want to know what their current private balance is. And there's the top up feature with which you can top up your private balance. Maybe someone wants to withdraw from the private balance so you can build it. Withdrawal transaction, same interface as always.
00:12:28.190 - 00:13:13.814, Speaker A: Elusive send, elusive transaction, pretty straightforward stuff. And again, so if you do all this stuff, what you'll basically have built is a simple private sending app. And that would qualify for the two criteria I described at the beginning. This would be low cost, just because it's on Solana and because of the systems running underneath. And it would be quite composable and easy to use just because it's quite easy to implement and implement your own specific app. But it doesn't satisfy the third constraint I specified yet, which is like, you might build this, but then before you deploy it to Mainnet, make it go live, integrate directly in your protocol. You're like, ah, what if someone uses this for bad and end up getting in trouble for this? Or maybe not, but just in case.
00:13:13.814 - 00:14:41.584, Speaker A: And so for that reason, we have compliance systems in place. And you can think of this as sort of a compliance ladder. So to say we have the lowest level, which would be the ground, basically, where you just ignore the rest of this talk and just ignore this part and simply just do. You're happy with the first part, but if you want to have a little bit of compliance, the lowest step, the lowest rank we can provide for you is ownership proofs. And the idea of an ownership proof is, as the name basically describes, is given a certain send transaction that you can see on chain, you can generate a proof if that transaction came from you, obviously, that you're the person who submitted that sent transaction, which under the hood, basically all you're doing is you're generating the proof again, that you own the secret values and that created the commitments that were used for that specific cent transaction. And the interesting thing to notice about this here is you're just proving ownership of a specific transaction, but you're actually not leaking any information about your private balance, or more importantly, of the public key that we use to create this private balance. Which is good, because that means you just prove ownership of a specific transaction, but also has a slight drawback, which is why you might be wondering why there's like some date time stuff in the constructor there, which is since it only proves ownership of the transaction and not much more than that, if I would generate that proof and give it to you, and you would give it to someone else, you could just pretend that you're me, just because the person would be able to verify, okay, you know, this guy, since he generated this proof, he must have been the owner of it.
00:14:41.584 - 00:15:15.524, Speaker A: Yeah. And since we want to prevent these imposter situations, what we actually have in code inside the proof as well is the time at which it was created and a time at which it should expire. So that means when you create this ownership proof, you might say, okay, I want this proof to be valid for one day, or I want this proof to be valid for 1 hour, something like this. And then when the verifier, then, you know, verifies this proof, he has to specify the current time it is by him. And when the proof is then verified, it checks. Okay, is the time that the proof was created with smaller than the current time. And if that's the case, then the proof passes.
00:15:15.524 - 00:15:49.834, Speaker A: Otherwise it says, sorry, expired proof. And yeah, note this, is that something that's encoded inside of the zero notch proof, not inside of our top level SDK, obviously. So that means if someone were to use some other proof verification system, it would still not work. You wouldn't be able to get around it so easily. But let's say second case, your counterparty is a little bit more strict. They don't just want proof that a certain transaction came from you, but they want, you know, they want to know what the public key behind it was, what your private balance at that time was. In that case, we have the second rang of the compliance ladder, which would be the viewing keys.
00:15:49.834 - 00:16:38.564, Speaker A: And the idea of the viewing keys is somewhat similar. It's the idea that you can generate a viewing key, as the name implies, for a certain on chain private transaction, and you can generate that viewing key and pass it to someone else. They can use that viewing key and simply put in the transaction that you told them belongs to you, using that viewing key, they can decrypt your private data to some extent so they can see, okay, this was the person who sent it off. This was their private balance at the time that they sent it off. Yeah. This is of course a much stronger step than the previous one, because if you give someone a viewing key, they will know the actual key behind it and reveal a lot more about your privacy. But as mentioned, we want to build an SDK with which developers have the option to choose how many, whichever level of compliance they feel is appropriate.
00:16:38.564 - 00:17:10.075, Speaker A: And in some cases, this level of compliance is more appropriate or is needed. Yeah. And the final level of compliance, sort of the peak of the ladder, so to say, is what we call trusted third parties. TTP. It's not on the slides here because it doesn't fit like this exact format here. But basically what you might have noticed about these two is that both of these require the user's seed, basically. So that means only the user is able to generate these ownership proofs and these viewing keys if he so chooses yourself.
00:17:10.075 - 00:18:30.028, Speaker A: So that means if you're the owner of the protocol, you can't actually force your user to generate this unless you hold his private keys, obviously, and his seed. Yeah, and in some cases, obviously, in 99% of cases this is good, but in 1% of cases this is bad, which is if someone uses your wallet to make an illegal transfer. And in which case, idea of a trusted third party is at the very beginning, when you instantiate the elusive instance, what you provide beyond the normal parameters is an additional parameter, which is a trusted third party key, and which means from that point on, every single transaction that is privately submitted that is privately encoded also basically has an additional key that can be viewed by the trusted third party, which means you don't only have one person who has access to privacy yourself, but also a trusted third party. Again, and this is probably the largest type of trade off and in most cases might not be fully appropriate. But in some cases where legislation demands this or for whichever other reason, it's optional, you can do that as well. So again, to reiterate, the main idea here is it's not to force any compliance on anyone who needs, who doesn't want that to have, or rather give developers the option to choose the type of compliance that they think is ideal for their specific use case. Yeah.
00:18:30.028 - 00:18:57.078, Speaker A: So, yeah, that's pretty much the main idea of what you can build with elusive. You can easily build private transfers, you can easily build compliance into it. If you want to learn more about it, you can check out elusive privacy on Twitter or on our website. Yeah, right now we're on Devnet. We have a private beta going on right now. So if you want to try out our SDK or if you have some cool idea to build with it, reach out to us. We'd love to give you access to the SDK itself.
00:18:57.078 - 00:19:28.274, Speaker A: And documentation should be very cool in addition to that as well. If you check out our twitter, you'll see we are actually hosting an event later today, I think at 03:00 p.m. Where you'll be able to attend, have a chat with us, have some free drinks, grab some free merch. Should be cool for the remainder for the next five minutes. Also, quick Q and A. Any other questions you might have about elusive or privacy on Solana in general? Yes.
00:19:30.374 - 00:20:17.814, Speaker B: Sorry. Hello. Thank you. That looks amazing. I'd like to ask how much, how much does it take to actually do a transaction? Like you had a wait there, but what is behind that? Like maybe 100 transactions or something like that. And also generating the data for a transaction, is it like, like a hard task? And can this be done on a mobile? Potentially. Thank you.
00:20:17.974 - 00:21:21.554, Speaker A: Okay, if I understood your question correctly, the first part of your question was like, how many transactions does it actually take to do the pride sent? And the second part is, can you do that on mobile? Right, okay. Yeah. So for the first part, how many transactions does it actually take? So for the top up, that takes about five transactions. And for the proof verification, for the actual sending, that takes around 30 to 40 transactions. The reason it's 30 to 40 is because we optimize approving system in a way that depending on the proof parameters it takes, it might take a few transactions more or less. But the cool thing is that the way we have our SDK set up is that through this relayer system, you don't actually have to worry yourself about submitting all those three transactions and making sure all of them actually went through and all that stuff. The idea is really that you leverage the relayers for that, that you send one transaction, your zero notch proof to the relayer, he takes care of submitting the initial transactions to initiate the proof verification and also making sure that the further 30 or 40 transactions actually go through and your proof is actually verified and your private send goes through.
00:21:21.554 - 00:21:45.704, Speaker A: The second part of your question, whether this works on mobile as well. We haven't tested as much on mobile yet. However, we are confident that with the developments in. We're using gross 16 proofs, which has a ton of tooling for it already, which is one of the most popular tooling ZK tooling systems at the moment, which has been optimized a lot for all types of systems, which makes us quite confident that we can get this working on mobile quite well as well.
00:22:03.424 - 00:22:07.604, Speaker C: Hey there, I was wondering, is the code open source and can we go check it out somewhere?
00:22:10.304 - 00:22:12.552, Speaker A: Could you repeat that? I didn't quite understand your question.
00:22:12.648 - 00:22:20.724, Speaker C: Yeah, is the code for the contracts and everything open source, and where can we learn more and sort of look at the code and stuff?
00:22:21.184 - 00:22:37.370, Speaker A: Is the code open source, was the question. Yeah. Okay, sweet. Yeah. So yeah, the code for this is currently not open source because. Yeah, we're closed beta, we're currently on Devnet and we will be launching on Mainnet end of the year. But at the moment when we will be launching on Mainnet, all this code will be open source.
00:22:37.370 - 00:23:01.754, Speaker A: And you'll be able to check it out simply on our GitHub. Yeah, right. Cool. I don't think I see any further questions or am I missing someone?
00:23:04.294 - 00:23:19.474, Speaker B: Let me ask one more then. What is the kind of, can you just dig a bit into what is the kind of zero knowledge math is there like maybe how it does compare with bulletproof? So Zks.
00:23:20.024 - 00:24:28.806, Speaker A: Yeah, for sure, we use DK snarks. And the proving system that we use is graph 16 over VN 254 curve. Yeah, the reason we use dksnarks is simply for the case that ZK snarks have the cool property of having the prover. The proving system is a little bit more intensive, but the verification system runs basically an o of one, which is super cool for multiple reasons. Because if you essentially have a proof that, whose verification steps are pretty much the same no matter what the actual proof encodes, that opens up a lot more opportunity, which is also something that we're working on as well. Because at the moment our main proving system supports, as I showed in the presentation, privately transferring funds. But the cool thing is since we've optimized this proven, we've built this whole infrastructure, since the verification process is pretty much the same, no matter what the proof encodes, whether that be, you know, a proof that encodes a private swap or private lending or even a private NFT trade, we can reuse pretty much all of our infrastructure for that as well, which is something that we'll be shipping earlier next year, where you'll be able to submit just a zero knowledge proof circuit, which in most cases is very short.
00:24:28.806 - 00:24:56.584, Speaker A: For example, in our case for this, the zero notch proof circuit itself is probably like 300 lines of code or something like that, and then just leverage your infrastructure to verify any type of zero knowledge proof that you would like on chain. So, yeah, that's the rationale where we chose ZK snark specifically for that. All right.
00:25:20.264 - 00:25:26.124, Speaker C: So would I be able to use this to build something like dark forest, like the game dark Forest?
00:25:26.464 - 00:26:09.624, Speaker A: Could you use this to build something like the game dark Forest, you said? Yeah, yeah, yeah. For sure. So you would be able to use this again, at the moment, the main process is for basically just privately sending and receiving funds. So you would have to do, like, some extra hacks around it, so to say, to build something like dark forest. But, yeah, as mentioned earlier, at the beginning of next year, we'll be shipping general purpose zero knowledge proof verification vms, which will basically allow you to define what the zero knowledge proof should encode and simply use our infrastructure to verify it. So I think in that case, with that specifically, building dark forest should be very straightforward or not very straightforward, but definitely possible. Yeah.
00:26:20.644 - 00:26:25.586, Speaker B: How do you, or what are your plans for the trusted setup? For the zksnarks?
00:26:25.740 - 00:27:08.594, Speaker A: Yeah, so our plans for the. That's a good question. So our plans for the trusted setup is we actually plan to. Yeah, at the moment for the Devnet, we just have a local. We have a trusted setup where basically you have to trust us to do it correctly because we're not using real funds for that yet. But beyond that, it's simply going to be, again, when we launch on Mainnet, we'll allow anyone who wants to to sign up, participate in the trusted setup and, yeah, be a little piece of elusive history and participate bit, contribute to the trusted setup. All right.
00:27:08.594 - 00:27:14.534, Speaker A: I don't think I see any more questions. Sweet. All right, well, thank you for your time, everyone, then.
