00:00:05.200 - 00:00:09.222, Speaker A: GMGM. I'm Nick from the Solana Foundation Devrel team and today we're going to be.
00:00:09.238 - 00:00:12.062, Speaker B: Talking about transferring compressed nfts as well.
00:00:12.078 - 00:00:15.070, Speaker A: As fetching asset data from the RPC indexers.
00:00:15.182 - 00:00:16.078, Speaker B: Let's get to it.
00:00:16.166 - 00:00:18.134, Speaker A: Now that we've created our compressed nfts.
00:00:18.174 - 00:00:20.334, Speaker B: On the Solana blockchain, we can query.
00:00:20.374 - 00:00:23.326, Speaker A: The blockchain using our indexing providers provided.
00:00:23.350 - 00:00:30.182, Speaker B: By our RPC's to actually retrieve all that information. Here we're using this custom wrapper connection.
00:00:30.238 - 00:00:34.398, Speaker A: Class which is an extension on top of the normal web3 js connection.
00:00:34.446 - 00:00:35.942, Speaker B: Class, which is basically just going to.
00:00:35.958 - 00:00:37.862, Speaker A: Give us a slightly easier way to.
00:00:37.918 - 00:00:42.438, Speaker B: Make all of these post requests to our RPC. In this first example, we're going to.
00:00:42.446 - 00:00:44.110, Speaker A: Get all the assets by the owner.
00:00:44.182 - 00:00:51.254, Speaker B: Of our test wallet address. We're going to send that to the RPC and then we're going to get back that information. We're going to log out different portions.
00:00:51.294 - 00:00:52.782, Speaker A: Of the information to the console so.
00:00:52.798 - 00:00:54.634, Speaker B: We can see it. In this example here.
00:00:54.674 - 00:00:56.994, Speaker A: I'm only interested in the compressed nfts.
00:00:57.114 - 00:01:02.562, Speaker B: For this test wallet. There's only going to be one compressed NFT in it. So in the first example here we're.
00:01:02.578 - 00:01:03.786, Speaker A: Going to get all the assets by.
00:01:03.810 - 00:01:06.474, Speaker B: An owner address, in this case our test wallet.
00:01:06.554 - 00:01:11.642, Speaker A: This is the test wallet address that we minted a single compressed NFT to. We're going to request the metadata information.
00:01:11.778 - 00:01:13.970, Speaker B: From the RPC provider and in this.
00:01:14.002 - 00:01:18.306, Speaker A: Example we're actually only going to log out information that is specifically about compressed.
00:01:18.330 - 00:01:19.946, Speaker B: Nfts and we're going to log out.
00:01:19.970 - 00:01:22.448, Speaker A: Our asset id, ownership and compression information.
00:01:22.626 - 00:01:25.908, Speaker B: Next I'm going to make another request to the RPC to again get all.
00:01:25.916 - 00:01:27.076, Speaker A: The assets by the owner.
00:01:27.180 - 00:01:28.484, Speaker B: And this time we're going to get.
00:01:28.524 - 00:01:30.844, Speaker A: The user address which is the NIC address.
00:01:30.964 - 00:01:33.492, Speaker B: And then we're going to log out the very similar information.
00:01:33.628 - 00:01:38.788, Speaker A: And this time we're going to filter out some of the information to only show the compressed nfts that are from.
00:01:38.916 - 00:01:47.732, Speaker B: The same tree as the original request. So within our console we'll go ahead and run this script. So once our requests go through and.
00:01:47.748 - 00:01:48.932, Speaker A: We get a response back from the.
00:01:48.948 - 00:01:50.890, Speaker B: RPC, we can see that we are.
00:01:50.922 - 00:01:54.242, Speaker A: Getting our test address, which is this c six y.
00:01:54.418 - 00:01:58.090, Speaker B: It owns this asset id of six a nine.
00:01:58.202 - 00:02:03.218, Speaker A: We can see some of the ownership and the compression information from when we actually minted our NFT.
00:02:03.386 - 00:02:04.282, Speaker B: You can see that we have a.
00:02:04.298 - 00:02:09.410, Speaker A: Delegate address of our NIC, which is our user address. And then for the asset that's owned.
00:02:09.442 - 00:02:14.082, Speaker B: By our user address. There's no delegate set because the owner.
00:02:14.138 - 00:02:18.536, Speaker A: And the delegate were set as the same value when we actually minted the compressed NFT.
00:02:18.690 - 00:02:19.972, Speaker B: Now the next thing to understand is.
00:02:19.988 - 00:02:22.300, Speaker A: How to actually transfer compressed nfts.
00:02:22.452 - 00:02:24.468, Speaker B: We've got a lot of the same boilerplate here.
00:02:24.516 - 00:02:26.764, Speaker A: We're making a connection to the cluster.
00:02:26.884 - 00:02:28.724, Speaker B: We'Re loading in our test and payer wallets.
00:02:28.764 - 00:02:30.356, Speaker A: We're logging them out to the console.
00:02:30.460 - 00:02:31.620, Speaker B: Then the other thing I'm getting here.
00:02:31.652 - 00:02:34.580, Speaker A: Is the asset id for the two assets that we just showed in the.
00:02:34.612 - 00:02:39.860, Speaker B: Console that were owned by these two different user accounts. And then we're going to define those.
00:02:39.892 - 00:02:40.852, Speaker A: In a single variable.
00:02:40.948 - 00:02:44.156, Speaker B: In this case, we're going to use our user asset, the one that is.
00:02:44.180 - 00:02:45.626, Speaker A: Owned by our user address.
00:02:45.780 - 00:02:53.054, Speaker B: We're going to get the asset information from the RPC using the getasset method. We're going to log that out to the console and we're going to log.
00:02:53.094 - 00:02:54.462, Speaker A: Out who the current owner is and.
00:02:54.478 - 00:03:03.790, Speaker B: The current delegate for this specific compressed NFT. This is owned by user address with no delegate. And then we're going to get the asset proof information from the RPC as well.
00:03:03.942 - 00:03:08.558, Speaker A: Anytime you're going to transfer a compressed NFT, you'll need to query the RPC.
00:03:08.686 - 00:03:11.046, Speaker B: In order to get the full asset proof list.
00:03:11.190 - 00:03:13.286, Speaker A: Next, we're getting our Merkle tree account.
00:03:13.350 - 00:03:16.600, Speaker B: Information from the Solana blockchain using the.
00:03:16.632 - 00:03:21.008, Speaker A: Concurrent Merkle Tree account class that is within the compression program SDK.
00:03:21.136 - 00:03:24.032, Speaker B: And then for demonstration purposes we're doing.
00:03:24.088 - 00:03:28.280, Speaker A: Some verification to make sure that the proof provided to us by the RPC.
00:03:28.392 - 00:03:31.640, Speaker B: Is in fact valid. Now of note, this proof verification is.
00:03:31.672 - 00:03:33.192, Speaker A: Not required to be done client side.
00:03:33.288 - 00:03:34.368, Speaker B: But if you do it client side.
00:03:34.416 - 00:03:37.520, Speaker A: You can help catching additional errors from RPC data.
00:03:37.712 - 00:03:44.468, Speaker B: All this verification is handled on chain using the compression program to make sure that it is in fact immutable and correct.
00:03:44.636 - 00:03:49.764, Speaker A: Finally, we can actually build our transfer instruction to actually transfer ownership of our compressed NFT.
00:03:49.924 - 00:03:54.420, Speaker B: We're defining our new leaf owner and the current leaf owner and delegate.
00:03:54.492 - 00:04:01.836, Speaker A: We're getting our tree authority and tree depth values from the concurrent Merkle tree class that we discussed earlier. Then we're taking our proof path that's.
00:04:01.860 - 00:04:04.324, Speaker B: Provided from the RPC and we're massaging.
00:04:04.364 - 00:04:15.372, Speaker A: That into a array of account metas because this proof information is just an array of strings provided to us from the RPC. This next portion where I'm doing a slice, we're taking the total length of.
00:04:15.388 - 00:04:17.228, Speaker B: The proof and we're cutting it down.
00:04:17.276 - 00:04:24.524, Speaker A: To remove all the canopy information that's stored on chain. This is actually a very important step when you're creating your proof to send with the transaction.
00:04:24.684 - 00:04:28.820, Speaker B: Because the canopy is already stored on chain, we do not want to send.
00:04:28.852 - 00:04:32.132, Speaker A: The additional accounts that are within the canopy since it's already on chain.
00:04:32.228 - 00:04:36.156, Speaker B: So we can go ahead and chop those out of our proof path and.
00:04:36.180 - 00:04:37.812, Speaker A: Then we send the remaining portion of.
00:04:37.828 - 00:04:46.970, Speaker B: The proof path as our anchor remaining accounts within our transfer instruction. Also within our transfer instruction, we're sending the current root data hash creator hash.
00:04:47.042 - 00:04:49.754, Speaker A: Noncend index that's provided from the RPC.
00:04:49.874 - 00:04:51.554, Speaker B: And for these ones we're just massaging.
00:04:51.594 - 00:04:53.562, Speaker A: Them into a array of numbers.
00:04:53.658 - 00:04:55.370, Speaker B: We can then package up that instruction.
00:04:55.442 - 00:04:56.802, Speaker A: Send it in a transaction to the.
00:04:56.818 - 00:04:59.218, Speaker B: Blockchain with our payer, who is the.
00:04:59.266 - 00:05:02.330, Speaker A: Owner of this NFT. Or this could also be the delegate.
00:05:02.362 - 00:05:07.438, Speaker B: Of the specific leaf. And then finally for this example, we're going to refetch the same asset and.
00:05:07.446 - 00:05:08.926, Speaker A: Then we can log out the new.
00:05:08.990 - 00:05:17.606, Speaker B: And old owner and delegate just for demonstration purposes. So let's go ahead and run this script. Now you can see, we first get.
00:05:17.630 - 00:05:21.030, Speaker A: The current information, we log it out to the console, including our current proof.
00:05:21.062 - 00:05:29.806, Speaker B: Values, and then we actually send the transaction to the cluster. Now that our transaction has completed successfully.
00:05:29.910 - 00:05:31.358, Speaker A: We can see that our old owner.
00:05:31.406 - 00:05:33.006, Speaker B: And our new owner are different.
00:05:33.070 - 00:05:34.694, Speaker A: So we did in fact transfer ownership.
00:05:34.734 - 00:05:37.254, Speaker B: Of our compressed NFT to our test wallet.
