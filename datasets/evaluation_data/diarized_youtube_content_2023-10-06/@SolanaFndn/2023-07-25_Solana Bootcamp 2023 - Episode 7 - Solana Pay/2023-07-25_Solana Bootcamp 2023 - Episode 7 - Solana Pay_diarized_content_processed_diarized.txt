00:00:08.880 - 00:00:51.995, Speaker A: Gm, in this workshop we're going to learn about Solana Pay and its various use cases which aren't limited to just payments. We're going to use transaction requests to interact with the seven Seas game. So let's get started. By the end of the workshop, you would also have a QR code which once scanned with a Solana Pay Connect compatible wallet, would actually send a request to your local development server which will then create an instruction which will interact with the seven Seas game. So I'm just going to scan this with my wallet and take a look at what happens in the seven Seas game. Once I press approve, you will notice that the monster would fire its attack onto the nearest ship. And this is all done with Solano Pay.
00:00:51.995 - 00:01:49.311, Speaker A: So before we dive into the code, let's just do a quick recap or a quick learning on what Solana Pay is and why it's even something that exists. Why Solana for payments? Traditionally, blockchains were built for the payments use case, but we haven't really seen this come to the full fruition just yet. So when we think about Solana, we think about a blockchain that has very low transaction fees, fast settlement and a high throughput. And these are just the kind of attributes that you will need to build an enterprise grade payments infrastructure. So Solana Pay is a payments protocol that was built to facilitate commerce on Chain. So imagine you have like an E commerce store or a point of sale terminal. How do you connect a particular order to a transaction that's happened on Chain? This is like the main or the core problem that Solana Pay protocol was created to solve.
00:01:49.311 - 00:02:52.311, Speaker A: There's like so many other things or so many other benefits that you actually get from using it. So when we think about composability, this is something that the Solana blockchain actually heavily optimizes for and you get to use its full effect on Solana Pay. So like imagine you want to do a cross promotion between your store and, let's say an NFT collection or a DEFI platform, you name it. Because it's composable and because it's built on a permissionless infrastructure, you can actually just go ahead and do just that. You'll kind of get to see a bit more of this when we're working on transaction requests where your server would actually get access to the particular account, or should I say the wallet address that has scanned your QR code. And you'll be able to, for example, look at all of the NFTs that they have, look at the tokens they have. You can even see if they've interacted with a particular protocol on Chain for you to kind of offer some kind of dynamic checkout experience just based on the fact that you have the user's wallet address.
00:02:52.311 - 00:03:40.741, Speaker A: So we get to see like, see that play out more heavily once we start looking at transaction requests. But going beyond that, Solana Pay has been used for lots of things to do with NFTs. We've seen people minting with Solana Pay, dynamic discounts, loyalty programs. There was even a particular event where there was a photo booth and you can go into that photo booth, take a picture and it will actually mint an NFT to your wallet. And that was built with Solana Pay. So there's so many use cases of Solana Pay specifically when we start looking at transaction requests that go beyond payments. And even in our case in the demo that you saw right at the start, we're going to use this in a pirate use case for our Seven Seas game.
00:03:40.741 - 00:04:34.710, Speaker A: So really cool protocol and really extendable, even though it's just called Solana Pay can be used outside of payments. So why Solana Pay? And I think kind of these attributes pretty much just speak to themselves, but the fact that settlement is instant, so the moment somebody pays on your store, you'll actually have the capital instantly at hand. Which can now open up some different use cases for merchants that they can begin to deploy this capital immediately as soon as it's received. Also the notion of zero fees and zero fraud, in the fees case, it's pretty much near zero fees because it's like 0.001 cent. And when we talk about zero fraud, this is just like an inherent benefit that you get from using blockchain technology. So there's the fact that there's no form of chargebacks that people can just claim.
00:04:34.710 - 00:05:35.355, Speaker A: There's no case of somebody, for example, stealing some credit card details and using it on your site. Those kind of things just can't happen. And then when we're talking about the permissionless innovation that's related to the example that I gave that because you have the person's wallet address, you can then offer a dynamic checkout experience just based on what that user has done or what assets that user owns. And you don't need to talk to any team to do something like that because it's all done on Chain also kind of offers an immersive commerce engagement because you have a direct one to one communication channel between you, the merchant and the end user. There are no third parties There are no middlemen. As soon as somebody interacts with your store and you have their wallet address, you have a direct line of communication with them. So you can send them like adverts or again the dynamic or the custom checkout experience.
00:05:35.355 - 00:06:19.755, Speaker A: So the first thing that was done in the V1 of Solana pay was something called transfer requests. And this was just to facilitate a simple transfer. And the way this worked is that there was a particular URL that followed a URL scheme that had all of the required parameters encoded into the URL. So you had things like can actually just check out the spec. So in the transfer request some of these are optional. So for example, you had the recipient which is, this is the address that's going to be receiving the tokens. You had the amount, which is the desired amount that this particular transaction is for.
00:06:19.755 - 00:07:08.815, Speaker A: An SPL token, which is optional because you could also just deal with native soul. In the case of an SPL token, you just put the token mint. I'll skip reference, but you have the label and the message. And again an optional memo which will just create a memo instruction. But the reference is probably the most important thing as part of transfer request because it will act as a UUID and it's just a randomly generated public key that should be used only once, which is to link the transaction that is going to happen on your store or on the point of sale system with a transaction that happens on chain. So that reference or that UUID is what connects the commerce transaction with an on chain transaction. So yeah, that's transfer request.
00:07:08.815 - 00:07:31.365, Speaker A: And again, if this URL is encoded into a QR code and as long as the wallet you're using supports Solana Pay, once that URL. Sorry, once that QR code is scanned, the wallet would know exactly how to decode that URL to get the necessary parameters for the transfer request. And I believe in this page.
00:07:34.185 - 00:07:34.521, Speaker B: There.
00:07:34.553 - 00:08:17.683, Speaker A: Should be a section that tells us what. There we go. The wallets that support Solana Pay currently. So yeah, getting to the more exciting part, Transaction request, this is something that basically is a V2. And now rather than just a simple transfer, you're actually able to construct any transaction. So any transaction that's a valid Solana transaction, you'll be able to use Solana Pay with that. So how it works is that it's still URL based, but this particular URL is pointing to your server and your server needs to be configured to respond to both a get request and a post request.
00:08:17.683 - 00:09:31.599, Speaker A: So now again, once the the wallet that you Use and once you scan the QR code, the wallet will make two requests to that particular URL which will now hit your server with a get and a POST request. The GET request you just need to respond with an icon and a label. And this is just what the wallet would show up in like a pop up UI so that the user at least can get some familiarity with the transaction so that it knows, or at least it can show that yes, you are about to interact with the store that you think you are interacting with with. The post request in the body would be the account, which is the address of the person that has scanned the QR code and your server needs to respond with a valid transaction. So this is pretty much what you saw at the beginning of the workshop where I scanned the QR code and it was able to cause the monster to fire off its attack. That's because again, once my server received the post request, I just created the instruction to interact with the seven SEAS program. So yeah, it's quite expandable in terms of what you can do.
00:09:31.599 - 00:10:18.431, Speaker A: We've seen so many use cases of this in the wild again that extend beyond payments. So in this workshop that's exactly what we going to be doing. We're going to create our own local server that's going to respond to the get and post request and you'll be able to also scan the QR code that you have on your screen that hits your server and you will be able to see the monster fire off its attack in the 70s program. So with that said, let's get started then let's start writing some code. Okay, so to follow along with this workshop, you're going to need a free account on Vercel. This is what we would use for the local development. I guess you could also follow along with Express, but for this workshop we're going to use Vercel because it's just easier setup wise.
00:10:18.431 - 00:10:51.875, Speaker A: You're also going to use, Sorry, need another free account on Grok. This will just allow for you to be able to hit your API server that you have running locally with an external URL. So go ahead and sign up for free accounts on Grok and Vercel so that you can follow along with the code. Oh, you would also need to use a mobile wallet that is compatible with Solana Pay. You can find a list of those wallets in the Solana Pay documentation.
00:10:52.215 - 00:10:55.183, Speaker B: So yeah, let's open up VS code.
00:10:55.359 - 00:11:01.515, Speaker A: So what we're going to do first we're just going to create our projects directories. So I'M just going to open up the terminal.
00:11:03.215 - 00:11:08.355, Speaker B: I'm going to create one called Payments Workshop.
00:11:13.735 - 00:11:46.255, Speaker A: Inside this particular directory I'm just going to do NPM init Y. This is going to initialize a basic project for us and the Y flag is just to say yes to all of the questions that it could have asked us. So yeah, now that we have this directory, we're also going to create a directory called API and within it a file called index js. This is just to follow the convention that Vercel is expecting for a simple API server.
00:11:46.415 - 00:11:49.927, Speaker B: So just going to create that and.
00:11:49.951 - 00:11:54.585, Speaker A: Then create the file index js. I'm just going to now open this.
00:11:54.665 - 00:11:57.385, Speaker B: Up in VS code so we can.
00:11:57.425 - 00:12:05.645, Speaker A: See we have our package JSON and we have the empty index JS file.
00:12:06.985 - 00:12:09.205, Speaker B: Just check that's where we are. Cool.
00:12:10.065 - 00:12:42.155, Speaker A: Then we are going to need to install both Vercel and Grok. I guess optionally you could have this globally installed. But yeah, I just personally like to install dependencies locally because of reasons. So just going to install those. So going to go Vercel and Grok. This will just install those dependencies for us locally. I guess whilst that is downloading we can just go ahead and start to scaffold our server.
00:12:42.155 - 00:13:08.999, Speaker A: So kind of just to go over again, we're going to be creating our own server that's going to be responding to the get and post request from the wallet. So going to go ahead and start that. So again this is just following the convention that Vercel is expecting. So we need to export a default function that is titled handler which takes.
00:13:09.047 - 00:13:12.165, Speaker B: A request and a response response.
00:13:13.825 - 00:13:16.569, Speaker A: And just so that we can see that this is working or just console.
00:13:16.657 - 00:13:26.265, Speaker B: Log that is handling a request and we're going to log out request method.
00:13:26.425 - 00:13:29.665, Speaker A: Just so that we can see that we're both getting a get and a post request.
00:13:29.705 - 00:13:32.485, Speaker B: I'm just going to return a response.
00:13:34.505 - 00:13:35.025, Speaker A: Thank you.
00:13:35.065 - 00:13:42.051, Speaker B: Autocomplete status 200 JSON format we'll just.
00:13:42.083 - 00:14:01.215, Speaker A: Do just a blank response for now. We just want to see that this is working. And yeah, I guess it goes without mention that for this workshop we're going to be using JavaScript. At some point I might be tempted to use JS doc comments just to help with some of the autocomplete features.
00:14:01.715 - 00:14:03.381, Speaker B: So let's just go ahead and now.
00:14:03.413 - 00:14:12.909, Speaker A: See if this is working. So if we do NPX Versailles dev this should now run okay, setup this. I guess all of the default options.
00:14:12.957 - 00:14:23.225, Speaker B: Should just work, no modifications needed. Cool. So now if we Go to localhost.
00:14:24.205 - 00:15:04.085, Speaker A: And I guess we have our code in the API directory. So/API should return the empty JSON. And if we look at our console, we see the handling of request get. With that we have our basic server running and it can handle technically any request and just respond with an empty JSON. So that's great. I'm now going to open another terminal session side by side, and for that one I'm going to run Grok, which again just exposes our local port via an external URL. And we're going to need this when we're testing our Solana Pay endpoint.
00:15:04.085 - 00:15:07.377, Speaker A: So now that I have that running, just going to make this a bit.
00:15:07.401 - 00:15:08.645, Speaker B: Bigger just to see.
00:15:08.945 - 00:15:13.809, Speaker A: You can see that we have a external URL that we can use.
00:15:13.937 - 00:15:20.365, Speaker B: So it's just if I make this so you have the full URL. So if I take this.
00:15:23.475 - 00:16:21.511, Speaker A: And go back and I'll change this to have that external endpoint, this store responds with the empty JSON. You can see another log statement to say hand in a request get. So now we can see that our local server has been forwarded correctly and now we have this external facing URL to hit our local server. So again, this is like extremely necessary for us testing our transaction request endpoint because when we're scanning the QR code from our mobile wallet, it actually needs to hit our server. So with that we should be at the point where we have our local development server up and running. So the next thing that we are going to need to do is just set up the QR code just so that we can have a QR code that points to the local development server that we have. So for this we're actually going to use a library called QR Code Styling, and I guess you're free to use any QR code provider that you want.
00:16:21.511 - 00:17:09.035, Speaker A: This is the one that we actually use in the official Solana Pay repo. So we're just going to use it here. What you'll need to copy is the URL that you get with Ngrok. And also not to forget the API, because our code is written in the API folder and we're just going to need to paste that in where it says data. So now you have. There's other customizing or UI styling options that you have, but I'm just going to leave it empty for now because this works enough for me. This points to our endpoint, but according to the Solana Pay spec, which we can take a look at for transaction requests, the URL that we use in.
00:17:09.075 - 00:17:10.535, Speaker B: The spec.
00:17:12.715 - 00:18:01.055, Speaker A: The URL that we use need to be prefixed with Solana colon. So we need to make sure that for our QR code we also have the Solana colon. And now we now have a valid URL that matches the Solana Pay spec. So if I was to go in whatever mobile wallet that I'm using, I should be able to scan this and it should be able to show me the configuration I have in my particular store. So now we're just going to go ahead and complete our API to conform to the Solana Pay Spec, because right now we just have it returning an empty JSON response, which isn't entirely useful at the moment. So the first thing that we're going to do is going to create our get handler.
00:18:01.595 - 00:18:06.335, Speaker B: So let's just say function handle get.
00:18:06.715 - 00:18:08.443, Speaker A: This is just going to take the.
00:18:08.499 - 00:18:18.575, Speaker B: Response and we're going to return response status 200 JSON.
00:18:21.475 - 00:19:03.095, Speaker A: And we need to return a label, which in this case could be anything, any valid string. I'm just. Because this endpoint is to call the Cthulhu instruction on the Seven Seas game, I'm just going to call it Cthulhu Fire. And then the icon, this will be the. Yeah, the image that you want to show. And again, you can choose any image that's like a png, JPEG or webp, I believe, supported. I'm just going to use this icon that I have prepared already, which is just going to show like a nice little octopus icon.
00:19:03.095 - 00:19:25.825, Speaker A: So now that we have this handle get function that again, this actually conforms to the Solana Pay spec that our get must respond with a label and an icon. So now we're just going to modify this code, we're going to leave the console log just for sanity, and we're going to say if request dot method.
00:19:28.245 - 00:19:31.985, Speaker B: Equals equals get.
00:19:34.845 - 00:19:36.225, Speaker A: We want to return.
00:19:39.005 - 00:19:42.225, Speaker B: Handle get and pass in the response.
00:19:44.335 - 00:19:57.823, Speaker A: Else for now we're just going to return an error because we know in future we have to handle the case for if the request method is a post. But just for now, we're just going.
00:19:57.839 - 00:20:14.765, Speaker B: To return an error and we're just going to say method not allowed and get rid of this.
00:20:18.705 - 00:21:28.105, Speaker A: So now to test this, I guess there's multiple ways. One, you could go back to your browser and hit your endpoint with the/API and you can see that it's actually responding with our label and icon. Alternatively, you could actually scan your QR code with whatever wallet you're using. And on Fantom, especially because we haven't created the post response yet Fantom would actually currently error out. But you actually notice, for example, I'm scanning this on my phone at the moment and you can see it's actually Sorry, our server is getting both a get and a post request. So on Fantom, if you were to scan your QR code, you would be able to see the request coming in on your server, but you wouldn't actually see the UI widget pop up on the mobile wallet itself. But I believe if we were to use Soulflare, for example, in scan, you should be able to see the pop up with the correct label and icon.
00:21:28.105 - 00:21:42.073, Speaker A: So yeah, we've handled the get. Now we need to create our post response. So we're going to follow a similar thing here. So we're going to say function handle post. This one is going to take both.
00:21:42.129 - 00:21:45.245, Speaker B: The request and response.
00:21:50.825 - 00:22:00.283, Speaker A: So according to the Solana pay spec, the wallet is going to send the account in the post body. So actually I just want to log.
00:22:00.339 - 00:22:11.895, Speaker B: That out and we can say account should be request body account.
00:22:12.835 - 00:22:28.409, Speaker A: I guess if you're actually building this out properly, you would have like various checks actually make sure that the account is there. But just for this example, we're not going to do any form of validation and I'm just going to start scaffolding the response.
00:22:28.577 - 00:22:38.473, Speaker B: So response status 200 JSON and we.
00:22:38.489 - 00:23:04.735, Speaker A: Need to respond with a transaction. For now we're just going to leave this as a to do. But that actually needs to be a base 64 encoded transaction and we're going to respond with a message as well. And it's just going to be Kulu fire. Yep. So this is just like the basic function body. But yeah, there's so much things that we need to do in order to actually get the correct transaction.
00:23:04.735 - 00:23:08.775, Speaker A: For now I'm just going to add this, we can say else if.
00:23:10.595 - 00:23:28.275, Speaker B: Request dot method equals equals equals post, that needs to be in all caps, then do something else.
00:23:32.415 - 00:23:39.115, Speaker A: So if we want to do that, we just want to return handle post and it needs the request.
00:23:40.865 - 00:23:44.433, Speaker B: And response there.
00:23:44.609 - 00:24:24.165, Speaker A: So I guess with this actually we never need to go back to the handler function again. It correctly routes our get request to the handle get function, roots our post request to the handle post function, and any other method is currently not allowed. So now we just need to continue to build out this handle post function to get the correct transaction. We can start doing the necessary steps required to get this the correct property for transaction. So what we're going to need, we're going to need the public key. So I Guess in this case it's the player.
00:24:25.185 - 00:24:28.965, Speaker B: The player equals new public key.
00:24:30.425 - 00:24:31.825, Speaker A: And we're going to pass in this.
00:24:31.905 - 00:24:34.965, Speaker B: Request body account.
00:24:37.725 - 00:24:42.905, Speaker A: We'Re going to need to create this K instruction.
00:24:46.045 - 00:24:46.533, Speaker B: Which for.
00:24:46.549 - 00:25:03.003, Speaker A: Now we're just going to scaffold another function called create Cthulhu instruction, which is going to need the player. And we're going to need, as I said, this transaction. And we're just going to scaffold that.
00:25:03.019 - 00:25:09.147, Speaker B: For now as well and just say prepare transaction.
00:25:09.291 - 00:25:55.373, Speaker A: And it's going to need the Cthulhu instruction. And this is going to just return transaction. So I guess with this we're just like creating the scaffold for the handle post function, which we're going to have this player, which is the account that's actually scanned the QR code. We're going to need to create this Cthulhu instruction, and that's going to take in the player. And once we have that instruction, we need to prepare the transaction by just encoding it with base 64. And this will be the final response from our server. So in here, I'm actually just going to do a nice little temporary trick that you can do.
00:25:55.373 - 00:26:38.975, Speaker A: If you're using VS code, you can just have this comment withscheck and it's actually going to almost Type check your JavaScript code for you. So we can see that we're using this public key, this public key class that doesn't exist. And of course I'll create Cthulhu instruction and prepare transaction functions that also don't exist. So we're going to. I'm going to create now another terminal session to install the required dependencies. In this case, we actually need to install Solana Web3JS because that's where we'll get the public key cutlass from.
00:26:39.995 - 00:26:43.215, Speaker B: So I'm going to go ahead and get that installed.
00:26:44.755 - 00:27:30.577, Speaker A: So we can now add the missing import from web3js for the public key. And now we can also begin to create this function. So we have this function create Kuli instruction that takes in the player. So the first thing that we're going to have to do is actually let's. Let's actually comment out what we need. So first thing we need is me to get the player's Gold Token account. And if you don't know what this gold token account is, I guess for the purposes of this particular workshop, you don't need to worry too much about it.
00:27:30.577 - 00:28:05.733, Speaker A: But if you've been following along with our workshop series, you'll know exactly what this, what this Gold Token account is and what it's used for. But we're going to need to play this gold token account. We also need to get all of the accounts needed for the KLU instruction and then we're going to need to return the instruction. So first things first, to get the placegold token account, we're going to use a nice helper function from the Solana SPL token library.
00:28:05.919 - 00:28:22.845, Speaker B: So the cons, the players token account equals, we can use await, get or create associated token account and we pass in.
00:28:24.945 - 00:29:25.455, Speaker A: A connection, which we'll need. We'll need a payer. We'll also need the Gold token mint and then we'll need this plays account. So yeah, we're going to need to import this from the SQL token library and the payer and gold token min are variables that we'll need to define at some point. So let's go ahead and install the SPL token library and we're also going to install the env and the base 58 library and you'll kind of like see why we need the env and the base 58 library. So we're just going to go ahead and install those. Then once that is installed, we can add this missing dependency.
00:29:27.125 - 00:29:45.305, Speaker B: So we're going to go ahead and import from Sportoken and we're going to need the get or create associated token account. You can see that we have a nice typer here.
00:29:47.205 - 00:30:00.099, Speaker A: So now some of the missing variables that we had, we needed a connection. This is something that's going to come from the SPL, the Web3js library.
00:30:00.284 - 00:30:09.455, Speaker B: So connection and that's going to come from Solana Web3js.
00:30:09.835 - 00:30:55.365, Speaker A: And for the purpose of this, we're actually just going to use Devnet because that's where the 70s game is deployed and also that's where our gold is going to be. So now we have the connection, we need the payer. For now, I'm just going to leave this blank. We'll come back to that. And we're also going to need the Gold token mint. And this is one that comes from one of the earlier workshops. But for this particular gold token mint, we're not going to use the Gold Token Mint that you yourself created in the previous workshops, just going to use the standardized ones, the standardized gold token that was created in the deployed 7ses game.
00:30:55.825 - 00:31:03.445, Speaker B: So it's a new public key and I'll just paste this.
00:31:09.265 - 00:31:58.063, Speaker A: That's the go Token mint and this payer and I guess there's like a something that's. Well, I can define Call with the Solana paid transaction request where one you can actually choose to be the fee payer so that anybody that is interacting with, let's say your particular store or point of sale system or in this case in our game, you can pay the fee for them if you wanted to. So that's what we're going to do for anything related to a fee. So for example, if we need to create the associated token account for this particular player and also just for the transaction costs for the Cthulhu instruction, we are going to be the fee payer. So I'm just going to do exactly that. So in this case we're going to.
00:31:58.119 - 00:31:59.915, Speaker B: Get key pair.
00:32:02.135 - 00:32:03.103, Speaker A: Which is from Solana.
00:32:03.159 - 00:32:05.615, Speaker B: Web3js just get the updated.
00:32:05.655 - 00:32:07.263, Speaker A: We're not going to generate it, we're.
00:32:07.279 - 00:32:20.965, Speaker B: Going to do from secret key and I'm just going to use the base 58 decode process env payer.
00:32:21.545 - 00:33:01.913, Speaker A: So there's actually several ways you can go about this. In my case, I'm just going to have the secret key as an environment variable, which of course I'm not going to show here. Yeah, so that it can be loaded in securely. There's multiple ways to actually import from a secret key. Sorry, import from a private key. You can either do it with this method or for example, you can use the unit 8 array, which I guess is actually probably a little bit safer since you don't have to rely on an external library. So let's take a look at the Solana Cookbook.
00:33:01.913 - 00:33:02.565, Speaker A: Actually.
00:33:05.935 - 00:33:12.439, Speaker B: We want to wallet. I think if you look at keepers and wallets.
00:33:12.487 - 00:33:34.665, Speaker A: There we go. How to restore keeper from a secret. So for example, you can have the private key in your environment variable and then load it directly with this. There is, as I said, the base 50 option. But I think. Well, yeah, this is definitely a lot safer because you're not relying on a third party library. So I'm going to go ahead with this method.
00:33:35.565 - 00:33:44.385, Speaker B: Unit 8 array from. So I'm going to get rid of that and say unit 8 array from.
00:33:45.805 - 00:33:47.705, Speaker A: The only thing you'll need to do.
00:33:48.165 - 00:33:51.989, Speaker B: Is just JSON parse that so it.
00:33:51.997 - 00:33:58.105, Speaker A: Actually reads it in as an array and not just a regular string. So yeah, we have that.
00:33:58.965 - 00:34:00.465, Speaker B: Let's get rid of this.
00:34:03.205 - 00:34:34.802, Speaker A: So we have this place token account. We have a token account. So the next thing that we need to do is now get all of the accounts that are needed for the Katuli instruction. And I guess, yeah, when you're following along, this isn't something that you just inherently know you either need to look at the anchor IDL or in my case I just looked at the seven seats program and took a look at all of the accounts that the K2 instruction needs. So I'm just going to copy this.
00:34:34.858 - 00:34:39.854, Speaker B: From something that I prepared earlier.
00:34:40.394 - 00:35:04.447, Speaker A: Okay, so now that we have the required accounts, we need to actually create the instruction. So yeah, because we're not using anchor, we're going to have to construct this manually, which some people may not be used to. And at the end also need not to forget to get the ID for the seven SEAS program. So let's go and start creating this.
00:35:04.471 - 00:35:11.955, Speaker B: So we're going to return new transaction instruction.
00:35:13.535 - 00:35:22.790, Speaker A: And this is something that comes from the Solana Web 3 JS and it's going to need a program ID which.
00:35:22.914 - 00:35:29.785, Speaker B: Is the 7 how do we write it here 70s program.
00:35:31.605 - 00:36:07.155, Speaker A: We're also going to need keys and these are basically the list of accounts that are needed. And we also need to send in the data property as well, which will do in a second. So for the keys, this again the order actually matters. So this is following the order that the Katula instruction on the program is expecting. So the first one is we're going to need the chest vault.
00:36:10.375 - 00:36:20.065, Speaker B: This is writable, is true and is signer is false.
00:36:22.285 - 00:36:25.385, Speaker A: The second account we need is the level.
00:36:25.725 - 00:36:41.225, Speaker B: So pub key is level is writable, is true. And also the is signer is false.
00:36:44.805 - 00:36:47.945, Speaker A: The third account we need is the game actions.
00:36:53.805 - 00:37:01.225, Speaker B: Sign is false. Well, trading commas are. Okay, what next?
00:37:01.685 - 00:37:02.985, Speaker A: Next one is player.
00:37:08.135 - 00:37:12.155, Speaker B: This is writable is true.
00:37:12.535 - 00:37:14.755, Speaker A: And this one does have to be a signer.
00:37:20.055 - 00:37:22.035, Speaker B: Then we have the.
00:37:24.255 - 00:37:25.835, Speaker A: Players token account.
00:37:26.815 - 00:37:27.675, Speaker B: Oops.
00:37:32.265 - 00:37:42.365, Speaker A: You can see that Intellisense and GitHub Copilot are just fighting for attention at the moment. And it's a place token account address is writable.
00:37:45.785 - 00:38:19.379, Speaker B: Oh no, I've missed one here. So after player is actually the system program id. Program ID is writable. Of course it's false. Signer also false. After system program we have the player again. Is writable.
00:38:19.379 - 00:38:26.225, Speaker B: Is false. Is signaling is false.
00:38:31.645 - 00:38:33.665, Speaker A: Now we have the player token account.
00:38:39.685 - 00:38:55.085, Speaker B: Players token account address is writable. Is true, is signer is false.
00:38:59.305 - 00:39:00.921, Speaker A: Couple more counts still needed.
00:39:00.993 - 00:39:13.485, Speaker B: Pub key we have the token vote. Is writable. Is true. Is signer false.
00:39:17.515 - 00:39:20.095, Speaker A: We have the token account owner PDA.
00:39:34.115 - 00:40:28.925, Speaker B: Took an account on the pda. Yeah. So is writable is true, is signer is false. The gold token mint is writable as false is signer. It's also false. We have the token program ID writeable False Sign is also false. This we need to import from SPL token.
00:40:28.925 - 00:40:47.775, Speaker B: We have the associated token program id, which is also from the SPL token library. Is writable. Is false. Is sign us also false.
00:40:49.115 - 00:41:49.415, Speaker A: So now when it comes to the data, this is one to know what instruction in the program you want to call and then pass any particular data related to that instruction. And yeah, because we're using anchor, we need to like figure out what the anchor discriminator is and then pass in the whatever data that function is needed. So there's multiple ways to do this. There is a, like a standardized way on how to get the anchored discriminator, considering that you know the function name that you're trying to call. But just for now I'm just going to use a more rudimentary way and because I actually have what the actual buffer needs to be. But at the end we'll do some refactoring and then you can see how to do this generally with anchor.
00:41:49.715 - 00:41:55.949, Speaker B: So I'm just going to copy from one we prepared earlier and there you have it.
00:41:55.997 - 00:42:08.829, Speaker A: So with that you would have the actual instruction that you need to call the Cthulhu program. Some missing stuff that we need is just this 7C's program ID, which again.
00:42:08.877 - 00:42:28.495, Speaker B: I'm going to copy from what we prepared earlier. So up here we'll just say Const 7 CSP program. That's not it. So now this should be quiet.
00:42:31.355 - 00:43:07.725, Speaker A: So now we're almost there. I think there's only one step that is missing, which is the actual prepare transaction function. Because now we have our Quaker tool instruction that takes in a player, gets all of the necessary accounts and actually constructs the transaction. Sorry, the instruction that we need. So now we can just go ahead and do the last part, the prepared transaction. So this prepared transaction takes in an instruction and all it's going to do is just going to return the desired transaction for us.
00:43:08.145 - 00:43:11.165, Speaker B: So let's see what we need here.
00:43:11.915 - 00:43:13.091, Speaker A: So first thing that we're going to.
00:43:13.123 - 00:43:25.495, Speaker B: Do is we're going to create the transaction equals new transaction. This is from web3. Nope, this is from web3js.
00:43:27.715 - 00:43:28.123, Speaker A: And we're.
00:43:28.139 - 00:43:30.011, Speaker B: Just going to use the add and.
00:43:30.043 - 00:43:42.121, Speaker A: Add that Katula instruction. So we take the kuli instruction, create a new transaction, add that particular instruction. Now we're just going to set some properties on that. So the first one is going to.
00:43:42.153 - 00:43:46.565, Speaker B: Be the recent block hash that we need.
00:43:48.985 - 00:44:02.685, Speaker A: Yes, this is going to have to be an async function because we're going to need to use await. So we're going to await connection get. I think it's get latest block hash.
00:44:05.195 - 00:44:15.095, Speaker B: Get latest block hash and we need the block hash property on that.
00:44:15.875 - 00:44:20.215, Speaker A: And for the fee payer we're just going to set this as the payer.
00:44:20.915 - 00:44:26.415, Speaker B: Because that's the we have opted to pay for the transaction fee.
00:44:27.795 - 00:45:10.511, Speaker A: And because we have set ourselves as the as the fee payer, we're going to need to partially sign this particular transaction because when you're the fee payer, so it's going to get deducted from your account and for any deduction to happen you would actually need to sign to give authorization to do that. So we're going to do partial sign and we're going to sign as the payer. And what we need to do now as mentioned is we just need to serialize and just serialize this transaction and return it as a base 64. So we're going to create a new.
00:45:10.543 - 00:45:16.087, Speaker B: Variable serialize transaction and we're going to.
00:45:16.151 - 00:45:20.015, Speaker A: Serialize it and we're just going to.
00:45:20.055 - 00:45:45.555, Speaker B: Set the verify signatures. We don't need to do that and require all signature is also going to be false. So just going to return serialize transaction to string base 64 and that's it.
00:45:46.015 - 00:46:31.845, Speaker A: So we have our transaction prepared. We create a new transaction, add the Katula instruction set the recent block hash, set the fee payer, partially sign this because we need to sign since we're setting ourselves as a fee payer, serialize the transaction and return it. So this should work. The only thing that you need to do is actually we can just do that quickly. Just need to create your env file and have your payer set to your private key. And of course I'm just not going to show this on screen. I'm just going to do that.
00:46:31.845 - 00:46:50.555, Speaker A: I've gone ahead and add my private key in the environment variable. Now we should actually have all of the building blocks required to scan our QR code and get the Cthulhu monster to fire. So I'm just going to set that up.
00:46:50.595 - 00:46:53.215, Speaker B: Let's go to the seven Seas program.
00:46:55.115 - 00:47:12.435, Speaker A: So that we can actually see this working. So there's a few ships here. So now I'm just going to go to my QR code which is still have my Solana colon, my ngroken API. I'm now going to scan this.
00:47:14.135 - 00:47:14.447, Speaker B: I'm.
00:47:14.471 - 00:47:15.103, Speaker A: Going to open this up.
00:47:15.119 - 00:47:16.271, Speaker B: So we should see this.
00:47:16.423 - 00:47:24.967, Speaker A: So right now, okay, so I got an error and when I got an error from my wallet when I look I can see our server is responding.
00:47:24.991 - 00:47:33.215, Speaker B: With a get And a post. So something must be wrong with the post. So we just take a look again.
00:47:33.255 - 00:47:35.755, Speaker A: See if we can spot anything. So handle post.
00:47:39.845 - 00:47:45.005, Speaker B: Is get. Okay, I can see that. Now this handle post needs to be.
00:47:45.045 - 00:47:50.005, Speaker A: An async function because this is using async await.
00:47:50.045 - 00:47:52.585, Speaker B: So we need to await this.
00:47:54.605 - 00:47:57.625, Speaker A: Prepare transaction. That's also an async function.
00:47:59.405 - 00:48:09.263, Speaker B: So we'll need to await you. And that means also in here we need to await. There we go. Save that.
00:48:09.439 - 00:48:10.607, Speaker A: Now if I go back to the.
00:48:10.631 - 00:48:16.975, Speaker B: QR code styling, I scan that QR code, we should be able to see that.
00:48:17.015 - 00:48:22.487, Speaker A: Yep, got that. Get request when I press allow should now also see a post request come.
00:48:22.511 - 00:48:23.675, Speaker B: In, which we do.
00:48:24.135 - 00:48:31.077, Speaker A: And now I have the option on my wallet UI to confirm the transaction. And when I do that I should see.
00:48:31.181 - 00:48:32.557, Speaker B: Cool it. Fired.
00:48:32.741 - 00:49:00.615, Speaker A: We can see that. That works. That's pretty much it. We can respond to the get on the post request. And in the handle post we have this Cthulhu instruction and that just has the same instruction format as you normally would expect. There isn't anything unique to Solana Pay here specifically. Yeah, so just return that instruction.
00:49:00.615 - 00:49:47.831, Speaker A: Then we have our prepare transaction just to add the recent block hash, add the fee payer, partially sign it, return it base 64 encoded and boom, we have it all done. So there you have it. It was quite simple to set up this Katula instruction and have our server respond with it. And just to kind of reiterate that clearly, as we've seen today, Solanopay can also be used outside of just pure payments. We've used it to create this Katula instruction and use that to interact with the 70s game. Thank you for joining and coding along with this workshop. The final code would be available on GitHub and also a text based walkthrough of this work workshop.
00:49:47.831 - 00:49:51.855, Speaker A: You can find all of that in the description. And then once again, thank you for joining.
