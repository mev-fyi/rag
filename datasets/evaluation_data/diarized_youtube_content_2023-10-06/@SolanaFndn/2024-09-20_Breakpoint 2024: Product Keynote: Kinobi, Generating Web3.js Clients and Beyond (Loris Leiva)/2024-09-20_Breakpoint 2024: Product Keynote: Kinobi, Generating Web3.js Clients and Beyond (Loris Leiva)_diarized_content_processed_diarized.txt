00:00:07.400 - 00:00:42.519, Speaker A: Alright, so today I'm going to talk about a developer tool called Kinobi. The main purpose of Kinobi is to help Solana programs reach their consumers. By consumers, I mean wallets, explorers, decentralized applications, users, and even other programs as program dependencies. Kinovi does that by so we're offering a standard that extracts as much information as possible from Solana programs. We call the standards an interface definition language, or IDL for short. We can then deploy these IDLs on chain, allowing anyone to retrieve them securely. Great.
00:00:42.519 - 00:01:12.097, Speaker A: But I know what you're thinking. How is it different from an anchor idl? Right, well. Sorry? Well, Anchor is an opinionated framework, meaning its idea makes plenty of assumptions. Let me show you an example. This is how strings are described in Enco. Now, if you give me a bunch of bytes and tell me string, I still have plenty of questions. For instance, what is the size of the string and how is it encoded? And the answer to all these questions with anchor is borsch and sometimes bytemark.
00:01:12.097 - 00:01:38.677, Speaker A: But these aren't the only serialization strategies out there. In contrast, let me show you how Kenobi define strings. Kinovi is designed as a tree of node. So in order to define a string type, we need a string type node. It has an encoding attribute telling us how the byte should be interpreted. Now, this node alone has no size constraint. To add one, we wrap it in a size prefix type node.
00:01:38.677 - 00:02:20.845, Speaker A: Now, we know that the size of the string should be encoded before its content, but we still don't know how that size should be encoded. That's why we also provide a number type node to define that size prefix. And just like that, we also define a borstring. However, Kinobi doesn't select serialization strategies. Instead, it provides small puzzle pieces that you can assemble to create any complex type you want. Additionally, Kinobi enables programs to depend on the ideals of other programs, which opens up new possibilities. For instance, consider an instruction that initializes COUNTER accounts and the Create account instruction from the system program that we all know.
00:02:20.845 - 00:03:17.699, Speaker A: Now imagine an instruction bundle node that's like, hey, if you use Create account before we initialize counter, you will end up creating a new counter account. Right? Now we can generate helper functions for these bundles, and Explorers can display more useful information to their users. Okay, cool. So now how do we actually get a Kenobi IDL from my program? Well, for starters, if you have an anchor program, then your anchor IDL can be converted into a Kenobi IDL if you're using Shank macros to get an anchor IDL from your vanilla Solana program, then the same applies to you. And finally, we're currently working on a set of macros that can extract Kenobi idls from any program directly. Right now that we have our Kinovi idl, what can we use it for? Well, Wallets and Explorers can already benefit from this by accessing these ideals on demand. Another utility we get from Kinovi is the ability to generate program clients in various languages and frameworks.
00:03:17.699 - 00:03:57.965, Speaker A: For instance, we have a JS client that's compatible with the brand new Web3JS. Speaking of, the new Web3JS is currently the release candidate, so please give it a try and give us your feedback. We're already generating a Web2JS client for Sana. Core programs, and other teams such as Orca and Tensor are doing the same for their own programs using Kenobi. We also have a JS client for Uni, a Rust client, and even a C client for gaming. But soon you'll be able to generate not just clients, but whole apps, right? For example, CLI tools, documentation, website or React components that you can plug in your dapp. One last cool thing about Kenobi is you can use it at account.
00:03:57.965 - 00:04:30.687, Speaker A: And what I mean by that is imagine I have an app that uses two Solana programs. Now these programs offer Kenobi IDLs, but they don't have JS clients that I could then use for my app. Right? So what do I do? Well, I can create my own custom Kenobi Ideal by merging their idls together and cherry picking the bits that are relevant for my app. Now all I need to do is generate a new client from that custom ida. And now I've got all I need to interact with these programs without any external dependencies. And that's it. That's Kinobi in a nutshell.
00:04:30.687 - 00:04:46.105, Speaker A: Kenobi is community driven. So thank you to all the different people that contributed to the different parts of the machine. And thank you Metaplex foundation for having initiated the project in the first place. My name is Loris. Here is the repo. Thank you.
