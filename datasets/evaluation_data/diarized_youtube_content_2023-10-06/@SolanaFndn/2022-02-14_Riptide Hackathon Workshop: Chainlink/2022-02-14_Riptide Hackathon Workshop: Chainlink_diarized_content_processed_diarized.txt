00:00:04.320 - 00:00:35.124, Speaker A: Awesome. We are live. Welcome, everyone. Thanks for joining. My name is Harry, and today we're going to talk about using chainlink data feeds as part of your Solana hackathon submission. So I'm just going to share my screen here and I might just disable my camera while I talk. Here we go.
00:00:35.124 - 00:01:08.276, Speaker A: So, my name is Harry Papakurischi. I'm a developer advocate for Chainink Labs. And there's my socials if anyone wants to connect. So today we're going to talk about Chainlink as part of the Solana riptide hackathon. Now we're very excited. We love Solana and we're sponsoring a prize as part of the Riptide hackathon. We're sponsoring a 30K USD prize to the best projects that use Chainlink as part of your submission.
00:01:08.276 - 00:01:40.692, Speaker A: So depending on how many projects we get, if there's three or more, the allocation is listed there. If there's less than three, if there's two, we might be 24 and six. If there's one, then they get all the 30. So all you need to do is you just need to build something awesome using our chainlink data feeds. You must use a data feed, or the data feed must be involved in some way to make a state change. And when you submit your project, you just need to tag Chainlink as part of your submission so that we can find it. So that's kind of the formalities out of the way.
00:01:40.692 - 00:02:15.734, Speaker A: Let's start talking about Chainlink and oracles now. So a lot of you probably already know smart contracts have got these awesome benefits, such as really high levels of security, guaranteed execution and trust minimization. But they're kind of also a little bit limited in what they can do. These smart contracts, they cannot reach out to the outside world. They can't reach out chain data events or computation. This is due to the actual design of blockchains. They're deterministic by design and they live in their own little kind of isolated world.
00:02:15.734 - 00:03:49.134, Speaker A: So basically, this problem defined in the context of blockchains is known as the oracle problem. And basically the problem is not being able to connect to external data inputs or events. And it kind of limits the functionality of smart contracts purely to things that can be done on chain, which is cool. But in a lot of scenarios such as DeFi protocols and things like that, you need external data, you need external connectivity, you need to know the price of bitcoin, you need to know the price of Solana, you need to know if a stable coin is pegged to the US dollar or not. So to interact with the outside world, we need what's called an oracle, right? So an oracle is any device that interacts with the off chain world and provides data or connectivity to an on chain smart contract. And the way that the oracle works is that it reports a result of the off chain data or computation on chain, and then that report is used as an input by a program or smart contract as part of its processing logic, right? And by doing so, the blockchain stays deterministic and isn't prone to having its consensus broken because if you had a node reaching out to make an API call, the blockchain loses its determinism. Now having said that, when it comes to using oracles to obtain data such as, you know, price data, etcetera, using a single oracle actually creates a single point of failure for a smart contract.
00:03:49.134 - 00:05:02.168, Speaker A: So, because if you think about it, you've got this highly secure blockchain such as Solana running over 1000 nodes, very hard to hack or gain the deployed programs or modify the state of the accounts. But then if you have a protocol that's relying on some kind of off chain data that's being delivered by an oracle, if that's being delivered by a single oracle, then, and that data is actually used as part of the logic for the program to kind of drive some decision, then if someone's trying to attack the smart contract or program, then they're going to attack the oracle. Basically they're not going to try game or hack the blockchain because it's too hard. So how do we solve this problem of centralized oracles? So the answer to that is a decentralized oracle network. So instead of relying on a single oracle to report price data, we use a network of oracles that all talk to each other. They all pull data from multiple data sources, they all deliver on chain and the results are all aggregated into a final result. And by doing this we extend the trust minimization and decentralization properties of a blockchain.
00:05:02.168 - 00:05:46.340, Speaker A: We take it out to the oracle L2 and out to the data source layer as well, actually. So here's a diagram which basically just shows what I talked about now. So over here you can see we've got a number of Chainlink oracles here reporting price data. They're coming up with a report, basically of a number of, each node comes up with an aggregated value. So each node gets data from multiple data sources and comes up with its final value. Each node's value is put into a report and then one of the nodes is chosen to then deliver that report on chain. Once a few checks are made, and then the final result is then aggregated on chain, everything's transparent.
00:05:46.340 - 00:06:40.844, Speaker A: And then that's the latest price for that asset, or whatever the data feed is for. So by combining your on chain Solana programs and accounts with off chain services such as price fees, you're actually creating what's called a hybrid smart contract. So most people think of a smart contract as on chain code running and in Solana's case, on chain program plus accounts. But when you combine that with services off chain, it's what we call a hybrid smart contract. So DeFi protocols that rely on price feeds, their hybrid smart contracts. So our data feed solution is a direct implementation of the decentralized Oracle network that I just described earlier. We have our data feeds deployed on Solana, offering devs developers access to high quality and reliable price data.
00:06:40.844 - 00:07:10.104, Speaker A: Our price feed design and architecture is the most battle tested and used price feed solution in the blockchain ecosystem today. And we've got a security first mindset with all our solutions. And we kind of strive to ensure that our data feeds are always accurate and reliable. So just a quick overview of data feeds. So we use full market coverage. So we pull data from a mix of premium data providers, aggregators and exchanges. We look at Dexs sexes.
00:07:10.104 - 00:08:01.464, Speaker A: We use a volume based average method of aggregating data. And live on Devnet Mainnet beta is very, very, very close. And we're actually using our new OCR, two aggregators as well in this implementation. So OCR is off chain reporting. Basically, the way it works is each of our nodes actually talk to each other and they all kind of communicate what basically price data they have and they come up with a report and then everyone signs their data and everyone checks to make sure that, that no one's trying to act maliciously. And then one of the nodes is then chosen to deliver that report on chain. But doing it this way, we reduce transaction fees quite significantly.
00:08:01.464 - 00:08:52.744, Speaker A: So right now, these are the feeds currently available on Solana Devnet to use as part of your submission. So you got bitcoin, Ethereum, Chainlink, Solana, as well as two stablecoins there, USDC, USDT, and there's going to be more to come. So that's kind of it. Let's go through a demo of using chain data feeds on Solana Devnet. So what we're going to do now is we're going to deploy a program that uses, that looks up the latest price using a chain data feed and then stores that value in an account somewhere. And then we're going to have a client that actually reads that result off chain. So what I'll do now is I will switch to here.
00:08:52.744 - 00:09:30.092, Speaker A: Actually, I'll switch back to here. So if you go to our GitHub repository at smart contract kit, you'll see pinned to the top of the repository here we have what's called our Solana starter kit. Now, this is a pre packaged repository. It's an anchor based repository. So it uses the anchor framework. So if you're a fan of anchor, then you'll find this familiar. And basically this is a pre packaged repository that contains a program as well as off chain scripts to interact with that program.
00:09:30.092 - 00:10:18.422, Speaker A: And the program basically just does exactly what I described earlier. It looks up the latest price of a price pair using chainlink data feeds, and then it stores a result in an account that's passed into the program. So very simple example, great for getting familiar with using price feeds or even getting familiar with using anchor. And a good starting point to kind of take and look at and use as an inspiration or a starting point for using price feeds as part of your submission. So if you're familiar with running Solana programs and anchor programs, you'll be familiar with these requirements here. They're all pretty standard. So the first thing that I'm going to do is I'm going to clone the repository that should be done.
00:10:18.422 - 00:11:08.524, Speaker A: So what I'll do now is I'm actually going to open it up in a new window and we'll go through it. Hopefully you guys can see that. So the first thing that I'll do while we go through everything is just install some of the libraries that are used listed here in the package JSON file. And while that's running, let's take a look at what we've got here. So we have a program here as well as all the standard anchor things like Anchor Toml. And we have a client script here. And we also have a read data script here.
00:11:08.524 - 00:12:01.108, Speaker A: So what we'll do first is I'll just go through the program. So do I need to make that bigger? Let me see. Hopefully that's not too big. Okay, so first of all, we have our standard anchor library clues here. Now, this is where we're saying we're going to use the Chainlink Solana library. So if you go to the here, sorry, no, not this one. This one here is the dependency there for Chainlink Solana.
00:12:01.108 - 00:12:57.674, Speaker A: And we're using anchor as well, so we're saying we're using chaining Solana here, this is a standard anchor program declaration of our generated program id. Now here is a decimal struct. So this is where the price data is actually going to get stored once we retrieve it. So we're going to store the latest price and how many decimals that price has, because price pairs have a certain precision. In addition to that, there's just a couple functions used purely just for formatting purposes, to format the data so that it's readable. I won't go through it too much detail because it's just basically working with a price which has a bunch of numbers append zeros appended to it and then stripping it to, making it look like a dollar amount. The main part of the program is here, I'm going to collapse that a bit.
00:12:57.674 - 00:13:27.304, Speaker A: So here's our execute function, right? And our execute function takes in a decimal account. This is the account that we're going to be storing the price data in. And then it takes in the user, the chainlink feed. I'll show you the feeds in a minute. So is it the Btc feed, is it the Ethereum feed, et cetera, the Chainlink program account. So on Devnet there is deployed Chainlink program. This is a static value that you don't need to change.
00:13:27.304 - 00:14:11.564, Speaker A: And then the system program, the Solana system program, so it takes those values in and what it does is using the chain library, it basically calls three functions. It calls get latest round data, description and decimals. So latest round data will take in and it will find the latest price for the specified feed. Description will be the description of the feed. Is it solusd, ETH, USD, etcetera. And decimals is how many decimals that that price has, right? So what is the precision required there? So it grabs those values. And all it's really doing once it does that is it gets the decimal account that's passed in.
00:14:11.564 - 00:14:47.030, Speaker A: That's the account that we want to store the data in. And then it says, all right, we want to store the value in the decimal value up here. We want to store the latest answer from the round that was obtained up here. And in the decimals. Decimals we want to store on signing to 32, the decimals value that was obtained. So once we store that data in the account, I think we also just print it out to the screen just for informational purposes. And then the program ends.
00:14:47.030 - 00:15:35.468, Speaker A: So nothing too complicated there. So the next thing that we do is bring up the terminal again and I'm just going to generate a new key key pair to use for our decimal account that we want to store the price data in. And I'm going to airdrop it some Sol tokens. So these instructions have been taken directly from the Solana starter hub repository here. So this is the one that I'm running now. If you might notice that I've actually run the Airdrop command twice. It's because I think the airdrop is limited to two sol now.
00:15:35.468 - 00:16:11.884, Speaker A: So I tend to run it twice just to make sure I have enough to do a few transactions if I need to. So there we go. That's completed. So the next thing we need to do is now build the program using anchor. So this might take a few seconds. In the meantime, I'll check to see if there's any questions. Can you guys hear okay? Someone said the audio quality is not great.
00:16:11.884 - 00:17:00.556, Speaker A: I'll just check. Microphone. Yep, it's on the right microphone. So once that finishes building, we'll eventually get it deployed. While that's going, I will open up our client, which is client JS, and I'll also open up the read data client. So while that's going, let's run through the client and we'll get back to that. It should be finished in a few seconds.
00:17:00.556 - 00:17:55.944, Speaker A: Seems to be running slow, but essentially once that program gets deployed we're going to use a JavaScript client that also uses anchor to interact with the deployed program. So that's what client JSU does. And all it does is it takes in a couple of arguments here. There we go. And it's got your standard kind of anchor initialization things here that we're setting. This is the deployed Chainlink program id on Devnet. This is the static program id that I was talking about earlier that you shouldn't need to change visor so that we can work with precision and decimals there.
00:17:55.944 - 00:18:51.904, Speaker A: Now in this client js, you're meant to pass in a feed value, right? So the feed can be obtained from here. So any of these accounts here. So if you want to see what the latest price of ETH is, then you'd pass this value here. However, if you don't pass in a feed, when you run this script, it'll use the solusd feed as the default value. And all this script is really doing is it's reading in our generated IDL and it's taking another parameter from the command line of program. So what is the deployed program iD? So once our program gets built and deployed, we'll know that and then it just creates a connection to the program. Right.
00:18:51.904 - 00:19:40.014, Speaker A: Using the IDL on the program id. And then once that's done we're creating a new key pair. So this is the account that we want to store the price data in that we're going to look up. And then once that's done it simply calls the execute function which is here that we store on chain and then it passes in all the relevant accounts. So remember we have the decimal account which is the one that's going to be storing the data. Yeah. And then the user, the specified feed, is it the soleusD feed, ETH USD feed and then the chaining program, the static program id and then the system program so they will get passed in and then this execute function gets executed.
00:19:40.014 - 00:20:18.824, Speaker A: Cool. So that's actually built. Now what we'll do next is you need to get the value of the program id now. So anchor has got this funny thing where wants to deploy it wants the program id thats generated but you cant get it until you actually build the program. So im going to update this value here and im going to build that again. Hopefully it shouldn't take as long this time. Cool.
00:20:18.824 - 00:21:12.404, Speaker A: So now we're ready to deploy our program when chaining VRF I just saw on the chat. Yeah soon, hopefully soon. Cool. So now to deploy our program to Devnet I'm going to run anchor deploy and I'm going to specify the Devnet cluster. So we'll give this another minute so to execute. If anyone's got any questions feel free to ask in the chat. Sorry if the audio is a bit funny.
00:21:12.404 - 00:22:43.114, Speaker A: Okay, while that's going I'll talk about the read data client as well. So I'll walk through the normal client and as you guys saw it basically runs the execute function and it stores the latest price of the feed that you pass in into an account and then it reads the value from that account at the end. Did I go through that? I don't think I did. Sorry I forgot to go through that. So once the instruction is executed, basically where once the result is obtained we just basically print out the log messages because we just kind of see this informational kind of output here. But then the important value is actually obtained here at the end where we're looking at the program account struck up here and we're fetching that value for our price feed account public key here and then we're just printing it to the screen. So once you have it here you can do whatever you want with it.
00:22:43.114 - 00:23:24.584, Speaker A: So hopefully we have a program id. There we go, finally. So now that we have a program id, let's try run this client that I just explained. So once again, I'm going to set a couple standard anchor environment variables that are required here. So the first one is the provider URL. I'm just going to set it to the public Devnet endpoint and then my anchor wallet to the one that I generated earlier in this demo id dot JSon. And now we're ready to run the client.
00:23:24.584 - 00:24:01.634, Speaker A: So what I'm running here is I'm running node client JS, the program id I'm getting dynamically using the Solana cli. So Solana address K. Then I'm pointing to my JSON file and then the feed here, I'm actually using the is it the ETH USD feed? Yeah, so I'm specifying the ETH USD feed. Cool. So there we go. You can see some output there. Price is 29 39.
00:24:01.634 - 00:24:49.170, Speaker A: Success done. Oops, what happened? So there we go. We successfully deployed a program on Devnet that looks up the latest price of a chain price feed and then grabs that data and then stores it in an account. And then we interacted with that program using an off chain client in JavaScript and we basically passed in an account that was populated with the latest price data and then we read the data from that account. So as you can see, we literally did it in a few lines here. So I'll just finish up this demo by showing the read only account. Now before I move on, I'll just check.
00:24:49.170 - 00:25:43.364, Speaker A: Questions? Can we create custom data feeds on chainlink? You cannot yet or it's not officially supported. I mean the code's all open and public source, so you can definitely try spin something up yourself and people have on EVM chains in the past, but it's not officially supported just yet. However, you can definitely, like I said, look at the code, look at the node software and try and run it yourself. But hopefully in the future we'll be able to. What about historical price data? Yeah, that's actually an important topic that we were discussing recently actually. So there is going to be a historical price data feature for these new OCR two aggregators. However, I believe that for now it's not going to be enabled.
00:25:43.364 - 00:26:45.034, Speaker A: If you have a need for historical price data and you're on Mainnet or going to mainnet though, definitely reach out to us because we want to hear more about the use cases of historical price data and how they use them, why they use them, what kind of scope of data is needed, etcetera. So definitely reach out. So just in the read data script now I'll just finish off with that. So let's say you have a DAP or something as part of your submission, and you just want to read the value of a price feed. You don't want to generate a transaction and pay Sol and write to an account, etcetera. Maybe you're developing something as part of the Solana pay the payments track and you're taking payments in crypto and you need to use the Chainlink Solana price feed to determine what is the price, how many Sol is required for something that's dollar 100, for example. You might just want to use price feeds as part of your front end.
00:26:45.034 - 00:27:26.486, Speaker A: This is what this read data script essentially is for. And it's very similar to the other one that we just looked at, except that it doesn't generate a transaction. It purely reads the data from the feed itself and then reports it off chain here. So I'll just quickly walk through that and then I'll go through any remaining questions. So the difference here is we're specifically looking at the store using the Chainlink store and OCR, two programs that are deployed on Devnet. Once again, we're taking a feed on the, from the command line as an input. And what we're essentially doing is we're using, we're doing some deserializing using borscht here.
00:27:26.486 - 00:28:15.974, Speaker A: But what we do is we connect to the specified feed, right? And the first thing we're doing is we're calling Getaccountinfo on that feed. The reason we're kind of doing it this method, and not directly through the RPC command is because we're specifying a data slice here. So we're specifying a subsection of the buffer that we want to look at. And I believe that this specifying data slice is not yet supported in get account info. So that's why we have to do it that way. But essentially we want to call getaccount info on the feed. And we want to basically look at the first few bytes, basically to get some header level information, right? So what we do is we pull that information, we deserialize it into a transmission.
00:28:15.974 - 00:29:28.370, Speaker A: And what we basically do is with that header information, we're looking for a live cursor and a live length value, right? And basically those are values that say how many rounds are in that current price feed, right. Because we need to know if there's this big buffer of price feed data. We want the latest price we want to work out how far down the buffer do we need to go to get the latest price so those values are needed. And with that information we generate an offset value that says how far down in the price feed account do we need to go. And then we do another getaccount info on the same feed this time because we know the offset, we know how far down the buffer we need to go to get that latest round at that point in time. So we start there, we get the data, it gets deserialized into a transmission which was specified up here, and the transmission contains just the timestamp and the answer. And once we get that, all we're doing is we're grabbing them from the object in which we deserialize the data into and we're printing them to the screen.
00:29:28.370 - 00:30:20.504, Speaker A: So that's a good way to just get the current price at a particular point in time. However, we also provide a second way of doing this using anchor events. So for those who are familiar with using anchor, you might be familiar with the onlogs function which basically parses logs and looks for specific events that have been omitted. So every time a data feed gets updated we have this new transmission log that's kind of generated and for now it's the only one that's generated, I think. So that's why we're not filtering byte yet, but essentially we're just looking for that log information and we're essentially stripping out those two values from that log. And in the second part of the script it literally just continuously polls a feed to look for those for that log. And then it strips out the information and just prints it to the screen.
00:30:20.504 - 00:31:21.846, Speaker A: So once again, we're not writing any data into an account, we're purely just reading directly from the account and then using that price fee value off chain in some way. So I'm just going to run the second script now. It's very similar to the first one calling read data and we're passing in a feed. Maybe this time we'll call the USDC feed and we'll make sure that it's pegged to the US dollar on definite cool latest price is one. And as you can see this price is one. So there's that new transmission log that I was talking about before. So there we go.
00:31:21.846 - 00:32:10.444, Speaker A: We're not writing anything on chain, we're not writing to any accounts, we're not spending any soul, but purely reading directly from the price feed, from the price feed account and just grabbing that data directly. So once I said, like I said before. Really good. If you're planning on doing something with a payments submission or something and you just want reliable price data, you want data that where you're not relying on an API to be up, where you're not relying on a particular service to be up, and where you want the data to be of the highest quality aggregated across multiple kind of data points. So just to finish up now, I know there's probably one or two more questions. I'll get to that in a minute. I'll go back to the slideshow.
00:32:10.444 - 00:32:46.586, Speaker A: So where can you go to learn more from here? If you have any questions, you can reach out to us in the Solana discord, in the riptide channels or in the developer channels. If you just mentioned Chainlink, we'll see you there and we'll respond. Or you can hit up our discord as well, the Chainlink discord. We've got quite a few technical channels there. We'd love to interact with you there. The starter kit that we just demoed, definitely check that out once again, it's pinned to our repository at smart contract kit. There you go.
00:32:46.586 - 00:33:07.474, Speaker A: The URL is there and we've got a good docs section as well. So docs, chain link, Solana. It will basically walk through everything I explained today as well. So we're very excited to be part of the Solana Riptide hackathon and we can't wait to see what everyone builds. Thank you. So I'll just see if there's any more questions. Now.
00:33:07.474 - 00:34:10.284, Speaker A: What's the fee per call to get prices? Don't you need link? No, you don't need link to get price data. So the fee is in lan ports. Whatever you need to pay to then store whatever state change you make after you obtain the price data. Right? So calling the price data and getting the latest price data does not cost anything. You don't need link. But then once you have that data and then you store it or do something with it and then make some kind of state change in an account or accounts you need to pay the land ports as per any normal solana program. Any more questions? Otherwise we'll end it there.
00:34:10.284 - 00:34:35.844, Speaker A: Cool. I'm not seeing any other questions. So yeah, thanks for coming out and listening. Looking forward to seeing what everyone builds and definitely reach out to us if you have any questions or need help. Thanks everyone. Bye.
