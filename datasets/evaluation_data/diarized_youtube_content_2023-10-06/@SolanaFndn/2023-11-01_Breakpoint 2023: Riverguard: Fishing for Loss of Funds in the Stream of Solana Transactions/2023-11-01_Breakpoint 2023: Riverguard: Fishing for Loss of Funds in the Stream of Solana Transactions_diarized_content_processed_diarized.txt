00:00:03.800 - 00:00:29.134, Speaker A: All right, welcome, everybody. Nice of you to all be here. I'm really excited to talk to you about riverguard fishing for loss of funds in the stream of Solana transactions. I'm Thomas, this is Nico. He will be later introducing a bit of the more technical details. But first, let's talk a bit about security. So, in my mentality, like, every hawk is a bug that is not caught in time.
00:00:29.134 - 00:00:56.094, Speaker A: And I, for myself, security is amazing, and the technical detail is really interesting, and I just want to catch all the bugs. But how can we do that? That's hard. That's really hard. So can we do audits? I mean, yes, of course we do audits, but they take a long time. We can't look at every contract. Can we just review the open source contracts that are out there? I mean, yes, of course we can. But then again, we're currently only six people.
00:00:56.094 - 00:01:27.184, Speaker A: That's hard. We don't have the time to do all of that. So now we make an observation, and we make the observation that some exploits, they're really, really simple. It's just like some minor thing that an attacker does differently and he gets some money out of it. Now, that doesn't mean that the bugs are easy to spot. It just means that the exploit is fairly simple, and probably each one of you would be able to understand it. And these exploits still happen from time to time.
00:01:27.184 - 00:02:00.948, Speaker A: And let's focus on that before we tackle these huge, amazing problems. Where we need fuzzing, where we need formal verification to spot these bugs. Nitty gritty details. We first want to make sure all of these simple bugs, which are simple to exploit, we find them. The way we do that is basically we look at what do the hackers do, and let's do the same, but do it better and do it faster. And our goal here is to protect all of the contracts on Solana, not just some individual ones where we might run the tool. And to do that, we really need to automate.
00:02:00.948 - 00:02:42.302, Speaker A: We can't spend time looking at each contract individually if our goal is to protect all of them. And then maybe we can do some symbolic execution, some fuzzing. But they are great to find unknown and complex bugs. But they usually need source code and manual adjustments. I mean, we had just a talk by Robert today, who talked about fuzzing a bit. And you see there are these details you need to do, which are difficult, and it's just not required. So what we observe is, for the really simple hacks, the pattern we see is usually a user interacts with this protocol, he would just normally do it.
00:02:42.302 - 00:03:20.910, Speaker A: And then he sees something weird. Maybe he tries to enter a negative number or some odd behavior, and he sees, hmm, that works. And then he just starts experimenting around. And then he might turn attacker because there's this opportunity for him to make some money here. And the same kind of things we want to automate. So we want to think like a hacker and basically do black box testing on all of the smart contracts currently out there. The way the hacker would normally do that is like he would interact with a program with via frontend, and then he would look at what the transactions did on chain.
00:03:20.910 - 00:03:49.578, Speaker A: Like, were they successful, were the state changes, what tokens were transferred? Maybe look at the log output. And then he would do some educated guesses to try to exploit that. Maybe the log output is a bit wonky. Maybe we can inject something there. Maybe we can swap with amounts a bit. Steps two and three, we can automate that. We can go through known attack patterns which we observed in the past, and just automatically exploit basically new contracts.
00:03:49.578 - 00:04:26.114, Speaker A: But then that's the problem. Like, how do we simulate this interaction with the frontend? Because that we'd still have to do manually and that still work. So what we figured we'd do is we'd use the river. These are basically like the idea that other users, they use programs all the time. Like a program that is not used. That's boring. So the important programs, this is fun, since users are going to use them, and we can just observe what these other users do and maybe mutate what these do and maybe find some attacks there.
00:04:26.114 - 00:05:08.668, Speaker A: But now we have a problem. We have millions of transactions a day, and most of them are arbitrage bots, which we don't really care about. We care about these user transactions, which maybe use some more niche protocols. And the thing that's even worse here is there are gigabytes of data per second flowing through the validator, the Solana validator. They are pretty much, right now running at the limits of what hardware can reasonably provide for validators. So it's a good technical challenge to how do we do that? If we want to attack these transactions, we have to try multiple times. The first thought is, maybe that's infeasible, but it's not.
00:05:08.668 - 00:05:57.724, Speaker A: So that's where we built Riverguard. And Riverguard is really intended to be this first line of defense for all Solana contracts. It will automatically find the exploitable bugs even in closed source contracts, because we don't even use source at all. We look at this transaction on chain, we mutate them and we find exploitable things, and we can actually even see what's happening in our tooling. We were able to build this completely free for everyone, because we had a Solana foundation grant, which allowed us to spend time investing into the development of the software. And it actually works. So far, we got 19 findings which were actually confirmed bugs which were already fixed.
00:05:57.724 - 00:06:30.272, Speaker A: Yeah. So, like, how is this talk going to work? First, we're going to know about, like, how does it actually work? Like, what does it do? And then we're going to have a really exciting story about Solchenz Eleven, a casino heist on Solana, which was one of the bugs that popped out of this rivergard. And we're going to end with the call to action, how you, all of you, can help us make riverguard even better and make the ecosystem more secure. And with that, I'm handing over to Nico, who's going to talk to you a bit, how riverguard works.
00:06:30.368 - 00:06:51.442, Speaker B: All right, thanks. So, I'm Nico. I've been working for neodymium since the beginning. I'm a co founder. I've now been doing Solana Research, I guess, for almost three years. Right, so, first we're going to look at how Rivergard actually works. To start, just a basic overview of what we do.
00:06:51.442 - 00:07:24.144, Speaker B: So, the river on the left here kind of represents all Solana transactions, and we now take the successful ones. So, from all transactions, we take, let's just say one transaction, one successful transaction, we mutate it in different ways. So we change it. And I'll explain later what that means. And then, in the end, we'll see what the result of this mutation is. So, what changes in the result of the transactions? And from that, we then get findings that we can display in our front end.
00:07:26.164 - 00:07:26.500, Speaker A: Right?
00:07:26.532 - 00:08:17.144, Speaker B: So, I guess, like, the first major hurdle is the transaction ingestion. Solana has a bunch of TPS. If you look at, just, like, how much data actually flows through the validator. So, like, how much input data goes into transactions, it's like gigabytes a second. And so we've patched the validator to send what's called a standalone transaction into a Kafka queue. A standalone transaction, in essence, is a transaction, but not just a transaction itself, but, like, everything that's required to perfectly simulate the transaction and get the same results as when it was executed the first time. So this is stuff like the input accounts, the sysvers, and literally everything you need to execute the transaction again with the same result.
00:08:17.144 - 00:08:53.724, Speaker B: We also have a redis cache. This is for large accounts. If you know a bit about how Solana program works, you usually have multiple megabyte large binary that rarely changes. So that's where the cache comes in. So we kind of don't have to transfer that much data around. It's still gigabits a second that flows through Kafka even with compression. And then this data gets transferred to workers, which then executes the mutations and actually finds the bugs.
00:08:53.724 - 00:09:50.794, Speaker B: So that's what we'll talk about next, the transaction mutations, which in essence is just changing transactions, executing them again, and then seeing what changed. For example, if we change something and the transaction still succeeds, but it shouldn't, then this could indicate that the program might be vulnerable for some attack or the other way around. Even if we change something and the transaction should fail, but it doesn't. Should succeed, but it doesn't, that might also indicate a vulnerability. There's a bunch of different things you can mutate, you can mutate the instruction data, you can mutate the owner of the account, the content of accounts, you can change who signs the interaction. You can completely replace accounts like the sky truly delimitian. Right? So so far, we've implemented seven different mutation rules.
00:09:50.794 - 00:10:24.444, Speaker B: A mutation rule is just like several of the steps I showed in the last slide in sequence. I'll just go over them briefly right now, and then I'll go into details for one of them. So we have three general mutation rules that cover the basics. Most programs already check these things, but we still have findings here. For example, we can catch unchecked account owners. We can catch unchecked signed crossbroker invocations. We can find missing signage, checks automatically.
00:10:24.444 - 00:11:26.594, Speaker B: And then we also have, like, two specific mutation rules, which have been inspired by hacks we found in the past. The first one is unchecked instruction system, and the second one is the unchecked sq verifier program. And I guess in the last two mutation rules, which also have been like the two best ones, I guess the first one is the account creation, denial of service, where sometimes if the, if the program doesn't implement account creation correctly, you can mess with the program and prevent people from withdrawing money, for example. And then the last one is, we call it self transfer, which essentially is just an unchecked vault account. And I go into detail in the last one now. So imagine you have some protocol where the user can deposit money into a vault, and then they get back liquidity tokens. Essentially what we just do is, in the transaction itself, we just replace the vault with the wallet of the user.
00:11:26.594 - 00:12:05.206, Speaker B: So now they pay themselves, but still get the liquidity tokens. And this is almost always lots of funds if this is actually exploitable. And we found a bunch of these findings, which is surprising, but also it's easy to mess up in different ways. Right, so the main issue with mutation rules is obviously the false positive rate. A bunch of these might not be exploitable, for example, with the unchecked owner, if the account is just never used. We actually detect for that. But there's obviously still many more ways in which one of these behaviors can occur without there actually being a bug.
00:12:05.206 - 00:12:32.094, Speaker B: So there's still always manual triage to be done. And we still have a bunch of ideas from imitation rules. So there will be a bunch more. This is just the first set that we have for release. Right, so now story time solutions. Eleven. Right, so this is kind of the story of a bug that we found using Riverguard.
00:12:32.094 - 00:13:22.424, Speaker B: So I'll start it with this finding. This is a screenshot from our front end where we got the message that the program found a self transfer. So we then investigated, took a look at the transaction that was simulated. And then first step you do is you look at what keys occurred, what actually happened, what the mutation will do. And in this case, if you take a look at it, it just replaced the destination of the transfer in the CPI with the source, or a classic self transfer, and the transaction still succeeded. And then of course, the next thing you do is you look at the logs to see if there's any clue about what the program does. In this case, we have this log message here, which just says deposit and a bunch of random stuff at the end.
00:13:22.424 - 00:14:19.110, Speaker B: We then did some sleuthing, because this has usually been the hardest part to actually find the owner of the programs. Right now we maybe have a bug, but we have no clue how to confirm it because we don't know what the program does and we don't know who to contact. So we did some sleuthing and we figured out that this program belonged to a casino on Solana. And then we just interacted with the front end as you would normally would. And we kind of found out how this works is you deposit SPL tokens to a centralized wallet via the deposit instruction. Then you gamble away all your money, and then if you have anything left, you can create a withdrawal request, and then the tokens get transferred back to your wallet via a regular SPL transfer. So now you can already see like if the deposit is vulnerable, we might be able to get credits on the casino and then we can withdraw them.
00:14:19.110 - 00:14:21.194, Speaker B: And in essence we have free money.
00:14:23.054 - 00:14:23.438, Speaker A: Right?
00:14:23.486 - 00:14:58.116, Speaker B: So now we'll just look at, we then looked at the deposit in more details. And the only thing we really could look at was this log message. And it wasn't too hard to figure out. It's usually just a bit of looking around the first part of this message, someone who does a lot of work on Solana can recognize fast. This is just the pub key of the mint of USDC. So this is the token mint that was transferred. The second part was just the amount of USDC that was transferred.
00:14:58.116 - 00:15:26.704, Speaker B: Then the third part was tricky. We just guessed that this is probably some sort of identifier of the accounts that the money was transferred to because the backend needs to know where the money was deposited. And then the last part was the vault that the money was paid into. And our educated guess was the backend passes the logs of all transactions invoking this program and then credits the account id that it finds in the log. And maybe it checks the world key.
00:15:28.724 - 00:15:29.084, Speaker A: Right?
00:15:29.124 - 00:16:37.234, Speaker B: So now we thought like, is this exploitable? And we kind of came to the conclusion that this is only exploitable if the backend credits deposit despite the self transfer. And we obviously couldn't really verify this because like the backend, we don't have access to the backend. So we tried to contact the devs because we also usually don't like to exploit things live on mainnet because then attackers, other attackers might see and replicate the exploit before it gets fixed. But after multiple tries and even getting banned on the discord, we finally got a point of contact. We had an email exchange back and forth where we explained the issue that we'd like to triage this. And then we got back this message, please prove it first, otherwise it's a normal transaction. So we thought, all right, you gave us permission, right? So now we went back to square one and thought like, how could, how could this be broken? We have like this transaction that has this log and we have this backend running in the background that then passes these logs and deposits the tokens.
00:16:37.234 - 00:17:17.290, Speaker B: So obviously, like the first part we already talked about, maybe it doesn't even check the vault that the tokens get deposited to. That would be easy. But unfortunately this turned out to be, they actually did this. So they checked that the vault actually matched with their vault. So just using the self transfer didn't work. So then the second idea we had, which was kind of, I haven't seen around much before, is we call it lock injection. So if we take another look at the instruction data, if you play a lot of ctfs, you might recognize that the last part of this bunch of data is just ASCII.
00:17:17.290 - 00:17:59.458, Speaker B: And it turns out that the instruction format is just like the id of the instruction. Then the amount to be transferred, and then the last whole bit is just like a string, which in this case is the account id. And so let's just be sneaky, just like a classic idea in computer security, just append stuff at the end. In this case, we just try to append the vault at the end of the account id. So now the log output of the program looks like this. So now we have the vaults twice at the end. We just sent this transaction on chain just to check if the log passing would still accept this as a valid log.
00:17:59.458 - 00:18:11.294, Speaker B: And it turns out that this still worked. So their log passing still passed this as like a legit deposit. And the money still got deposited into our account at the casino.
00:18:12.154 - 00:18:12.490, Speaker A: Right?
00:18:12.522 - 00:18:55.278, Speaker B: So the next step was, I think the formatting is a bit messed up here, unfortunately. The next step was then to combine the two things, the self transfer. So we now paid the money to ourselves, which obviously means that the log of the program, the last part, would change to our fake vault, but we then include the actual vault as part of our account id. So the backend would still believe that we paid into the account id. So in this case we didn't actually pay any money, but we still got greater $0.20 in our casino account, which we then could withdraw, which we obviously didn't do. We then reported this to the devs, who then fixed this.
00:18:55.278 - 00:19:51.494, Speaker B: But unfortunately this is not the end of the story. There was actually a second log kind of log injection in there, because it turns out that correctly parsing transaction logs is actually not completely trivial. Like the naive approach that was tried here is you just put a marker at the front of the line and then parse outlines that start with that marker. But unfortunately there can be multiple kind of programs invoked in the same transaction. So what if like another program also outputs like a message in the same format? So we just tried this out, included like our own program in there before and after that had like the same kind of log format. Again self transfer, just to not have to pay anything to them. And so again we didn't transfer any USDC, and again we got the USDC deposited into our account and we're like a dollar richer, I guess.
00:19:51.494 - 00:20:23.370, Speaker B: So. I guess. In summary, we protected over like $1 million from this bug alone. Because that's about how much was in the world. And the devs, even though they gave us a hard time at the beginning, fixed the bug very quickly, and afterwards gave us a bounty. But I think this whole story just shows how the findings in Rivergard are only really a starting point. And you still need to manually triage most of the findings, and the false positives really need to be ruled out.
00:20:23.370 - 00:21:02.994, Speaker B: So a finding in Riverguard doesn't mean it's vulnerable. It's just we have so in like in the last couple of months, I guess, where we like manually triage stuff, we had about a 50% false positive rate. So about every second finding was a bug. Obviously depends on the exact mutation rule and stuff, but it's like a ballpark number. And obviously cooperation makes this way easier for us because we don't have to put so much effort into finding the protocols and getting in contact and everything. And obviously it's also helpful for the protocols because they get their bugs fixed faster. Right now, I think Thomas will wrap things up.
00:21:03.774 - 00:21:34.224, Speaker A: All right, thank you very much. Yeah, so I guess let us help you. So we now have this tool. This tool is running, it's running live on Mainnet right now, and it's producing findings. And we already triaged many of the bugs, but new ones keep popping up. And for each one that pops up, we now have this issue. We want to triage it and we want to get it fixed, or we want to mark it as a false positive and be able to ignore it.
00:21:34.224 - 00:22:16.334, Speaker A: And we have to find the project name, we maybe want to find the source code, we want to find a way to contact the developers to tell them, hey, there's a bug here, maybe we don't know, look at it. Do you want to fix it? And without this information, it's quite difficult to rule out these false positives at this point. Smart contract developers, please implement this security TXT standard, which we have established. It's just a way for your contract on chain to include just some contact details and maybe a name and a website. But really the most important thing is just have an email there or some contact details which we can just use to email you. And Securitytxt is open source, it's really easy to include. If you got a contract, just put it there.
00:22:16.334 - 00:22:58.474, Speaker A: That will not only help us, but everyone who looks at your contract. Now, as to the current status of Riverguard, we recently upgraded it to 100 1617 and it currently runs on Mainnet. We do plan to deploy it also on Testnet and Devnet. Though that's not currently the case, we were working hard on getting it running on 116 before breakpoint. It still finds bugs regularly. Even though this tool is free and we want to be able to offer it to the whole community, we don't feel comfortable with open sourcing it yet. If you have any ideas or improvement ideas or want to collaborate on that, please reach out to us.
00:22:58.474 - 00:23:47.964, Speaker A: But right now it will remain closed source, but registrations are open and you will be able to access findings for your own programs. What's currently still missing the two main points are mail alerts. Before we do that, we have to improve de duplication of findings a bit so we don't send you an email once per hour for every transaction a user does. These are the two main things. But again, if you have any ideas, new fast cases which might be implemented, or if you can do something with the data, just talk to us. You can register for free at Riverguard IO. You can just put in your contact details, you can put in project name, you can put in your website and maybe short description, and then we'll reach out to you to verify that it's actually you requesting access to your own contract.
00:23:47.964 - 00:24:26.824, Speaker A: Because we don't want to hand out any findings to anyone, so we have to do some manual verification there. We still do the triaging, and even if you don't really use the data yourself at all, if you register there, we can more easily contact you because we just have an email attached to a program id then even better, just like your security txt all right, so I think that is already a bit faster than I anticipated. Thank you all for helping us make the ecosystem more secure, and thanks to the Solana foundation for like making this project possible. It wouldn't have happened without them.
