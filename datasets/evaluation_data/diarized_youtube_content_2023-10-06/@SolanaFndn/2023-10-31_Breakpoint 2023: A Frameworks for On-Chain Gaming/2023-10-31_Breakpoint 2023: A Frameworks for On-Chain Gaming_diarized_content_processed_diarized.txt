00:00:02.720 - 00:01:18.564, Speaker A: How are you guys doing? Last talk of the day before your Halloween party, but hopefully this will be an interesting one. I'm Andrea, I'm joined on stage by my co founder Gabriele, and today we are introducing a new framework for on chain games. So I'd love to start by perhaps setting the obvious for some of you, which is why even bothering building fully on chain games and putting the state and the logic on chain, and having to deal with all the intricacy and complexity that comes with it. And the reason is simply to gain properties that we don't have with the traditional gaming infrastructure, permissionless mods. It's one of these properties where essentially all of your players and developers can customize any aspect of your game, from the high level client by introducing plugin or modes, down to the very logic of your game by extending the gameplay with smart contracts. And so essentially it's this new paradigm where every game has become a platform by default, and potentially, no matter how small your team is, you can become a content powerhouse. The second one is persistency.
00:01:18.564 - 00:02:21.354, Speaker A: There's a big buzz around autonomous world, and how these virtual experiences can last forever because they can be shut down, there's no server that can be censored or shut down. And effectively, what these experiences introduce is a whole new level of significance into games. Games become avenues where players play, but also engage, socialize, conduct global commerce, work way more pervasive fashion than what is already happening with traditional gaming platform. And the last one is open economies. So the ability to tap into open global frictionless payment and microtransaction, especially in our ecosystem, and reuse existing primitives on chain like Dexs or NFT marketplaces. The problem with these games is that it is extremely difficult to build these experiences. And so we look at the market and there are frameworks that try to simplify the developer experience.
00:02:21.354 - 00:03:26.296, Speaker A: Some of them are really interesting. They're trying to iterate on provable session where you compute physics off chain and you prove the integrity of the computation on chain, or introduce sticking so loop driven runtime that are more similar to game engine than event driven runtimes of blockchain. But the fundamental trait of that every single one of these framework is doing is they are compromising performance to composability in order to achieve more performance and more tps. Typically you are creating isolation with alt trees, or you are introducing different runtimes with shards. And so we are just not comfortable with these tradeoffs. We ask ourselves, what if there was a framework that has high throughput, that could support us with all the TPS that we needed. We don't demand scaling so that the moment your game becomes successful, potentially up to millions of players, you don't have to compromise their user experience because there's no gas spike.
00:03:26.296 - 00:04:17.614, Speaker A: And you can support this level of demand and a framework that is customizable with no fragmentation. So you can potentially have those probable game sessions or even simulate the passage of time with a free transaction scheduler without having to pay a gas fee. But that introduce no fragmentation with isolated app chain or l three s. And so we're incredibly excited to present Bolt, which is a high performance and composable SVM base on chain framework. Bolt is modular. Bolt is modular and is composable. It works with all of the existing infrastructure on Solana.
00:04:17.614 - 00:05:21.544, Speaker A: It works with our primitives on chain identity, guestless API session kits, and it works with existing frameworks like anchor and all of the existing programs on Solana. Bolt can achieve order of magnitude more scale thanks to ephemera rollups, which are game sessions that opens and closes with users and scale on demand. And third, bold is lighting fast. We can achieve the same level of performance of traditional game engine before these dedicated runtime that can accelerate some operations. As we show you, this is a high level overview of the Bolt framework. It's obviously built for Solana, but it works with NES VM based layers. So potentially also on ASVM based ALT tools and Bolt aim to do two things, to be composable and to bring scale.
00:05:21.544 - 00:06:10.424, Speaker A: So the ECS, the entity component system, is one of the way through which we simplify the usage of on chain components and ephemeral rollups is the technology that I was briefly mentioning. We'll dig deeper into both of these aspects in a moment, and Bolt is integrated into the most commonly used game engine, which becomes the front end of the game, obviously unity, but also other open source and loved game engine like Godot or phaser. And we're even working with newer game clients like Turbo, which is focusing on improving the experience for indie developers and facilitating the creation of quick games and potentially more and more in the future.
00:06:13.884 - 00:06:48.964, Speaker B: And I will take it from here, and I will continue by explaining why we need an entity component system in ECS in the first place. And the answer is simple. It's because it's allowed to be maximally composable, which means that we can build, create and reuse off the shelf components. So as the name suggests, ECS is built by three main elements. We have entities that are essentially just identifier register to award instance. And we have component which defines the data structure. So essentially the raw data associated with entities.
00:06:48.964 - 00:07:57.010, Speaker B: And finally we have systems, which is the logic that operates on components that are attached to the entities. So we have world instances, entities, components and system that operates on those components. Now this architecture has the advantage that all the system and components are reusable. They can be published in a public registry where developer can easily contribute, build, discover and integrate any sort of components, so you don't have to write anymore from scratch your code, but you can reuse all the existing components and eventually contribute to it. We could for example have a data structure for a grid or a movement system, or a zero knowledge primitive for a fog war. And I will now switch to my ide and I will show you an example of a simple war distance using the bolt ecs. So we're going to define a couple of entities, a position component and two systems which operates and change the data of this position component.
00:07:57.010 - 00:09:20.934, Speaker B: So the first entry point is interacting with the word program. The word program is part of the bold framework and expose a couple of extractions which allow you to register a new word distance. You can add the entities to your word distance, and you can register components to the entities that you just find. And components are essentially, each component is defined by a component program where the component program has two instructions. The first one, the initialize, create and allocate the space for storing the raw data that we will use in your component. So in this simple example, we are defining a position component, and if we look up the context of our initialized instruction here, we can see that we have our component data, and the component data is just defining structure which has the XYZ coordinates that can store, for example, a player position. Now the second instruction, which is perhaps the most interesting, is an entry point that allows us to execute any logic and is the one that will receive as inputs our component and an arbitrary system, and through cross programming invocation will execute the logic which is internally defined in the system.
00:09:20.934 - 00:10:16.936, Speaker B: Now here if you look at line 15, we have our CPI call which through CPI will execute a logic internally defined. It perform all the computation the system is defining, and then returning our position which the component program retrieved, and set it back in our data. Now also let's try to look up the context of our apply function. And here we can see that we have essentially just two accounts. So the first one is the account containing our component data, and the second one is the system programs. So the system program is now an interface rather than a single program. So each programs which respect our bolt system interface can be executed through this apply.
00:10:16.936 - 00:11:26.930, Speaker B: And essentially this change the way you design your game logic and reverse the typical flow where if you want to create or encapsulate some logic in a program, you will typically add features and each feature will be instruction in your program. And then eventually at some point your game program will be made immutable. With this paradigm we can instead have a program which is immutable by day one. And then through this proxy mechanism we can inject systems which are built by house or can be built by anyone. So we have a game that runs forever existendable, and anyone can really change the logic of proposed new systems which operate on those components. Now the interface can allow us to do some checks. We can perhaps have game mechanics where all the systems are permissionlessly allowed to modify the component data, or we could have interface that checks if the system is allowed to execute on the component.
00:11:26.930 - 00:12:26.844, Speaker B: For example, you may foresee having a governance system where someone is proposing a new logic. And if the logic is approved, anyone will be able to use that logic in the game. And there could be also forks of the world. So in one word you could have a flying system, while in the other if it not approved, you can have different set of rules and everyone will be able still to contribute to this version of their words. So let's now investigate how we can build a system which modify this component. And a system is essentially just a program on Solana, where this program defines an execute instruction, and the execute instruction is the one we saw being called from the CPI, from the component. And here it just encapsulates a very simple logic where it receives an input direction in computer delta and then change the x and y position of the component.
00:12:26.844 - 00:13:29.464, Speaker B: So let's now see another system which could be potentially be built and deployed by someone else even after we release our games. And here is another example of a system which implements the execute here, increasing the z position by one. So it's someone trying to add a flank system which could be an interface having a different layer on your game. So now the idea is that all these systems, all these components are really composable and all of the, all of the user of your game are not user anymore. But it's become an open, extendable and persistent platform. So we'll now try to execute the unit tests that I have prepared in this example. And I will use the bolt CLI which is built on top of anchor, so you don't have to learn anything new if you're already familiar with Solana and how you build program.
00:13:29.464 - 00:14:12.664, Speaker B: On Solana you can just build your program, test your program. So here I'm running bolt build and bolt tests and here is executing our, deploying our program and then executing the typescript test that I prepared here. So here the tests are sending the transaction for initializing a new word. We are registering a couple of entities, we are attaching a position component to some of those, those entities. And then perhaps the interesting part is here where we execute some of this system. So here we are calling the apply function and then we are using one of the systems. So here is just a default system.
00:14:12.664 - 00:15:21.006, Speaker B: Here we are calling simple movements, and then we have the fly movement here. And now if we look up at the logs of our test, in the first transaction here we're using movement system with an upward direction, it increases the y position by one. In the second transaction we are moving on the right using the same system. And then finally we execute the fly system which is instead increasing our z position by one. So again, this is a simple example, but it gives the idea of really powerful mechanism that allow anyone to build, extend and potentially make your game be interesting forever. So we'll now go back to the slides and I will describe the second interesting aspect of the framework, which is our scalability solution that use what we call ephemeral rollups. So the main intuition is that Solana is already super fast and cheap.
00:15:21.006 - 00:16:25.094, Speaker B: It currently produces blocks with 400 milliseconds you can process thousands of transactions. So it's really already suitable for building full engine games. But there may be cases where for example, if you have all the logic on chain of a multiplayer game, the positions updates will be too slow. So the main idea is that we can have an ephemeral acceleration layer which is fully compatible with the solar runtime is optional and it can serve as really an acceleration on specific operations, while most of the logic is still executed on the base layer. So it relies on the fact that on Solana all the states are stored in accounts. Typically you will have your game program defining the logic and then all the states will be stored in this account. So we can delegate some of those accounts using the bolt error program to this ephemeral layer.
00:16:25.094 - 00:18:05.026, Speaker B: In this example there are two accounts storing the position of a player which are delegated and the provision is actively listening for delegations and provisioning requirements. It will spin up on demand, a new runtime which is fast, it can be customized, it could have gasless transaction or a ticking mechanism and allow us to really have transactions below 50 milliseconds and potentially scale having multiple dedicated runtimes. Now the other interesting part is that all of this complexity can be abstracted from the user. So we have the RPC router which is essentially exposing an interface as a traditional RPC world and client can just interact with the RPC sending transactions, since on Solana all the transactions declare upfront all the writable and readable accounts which are used. This RPC router can essentially routes both transaction and query of the data and retrieval to the correct layer. And then at some point the ephemeral layer, as the name suggests is ephemera will close and all the state will be settled on the Solana based layer which is the responsibility of the sequencer which keeps on track all the accounts. Another view of these mechanics is that we have two layers which execute transaction in parallel.
00:18:05.026 - 00:18:52.278, Speaker B: We have delegated account which can be updated without throughputs and low latency. And then we have other accounts which are not delegated and are executed on the base layer. Now the very interesting thing is that programs, tools, framework, infrastructure are on the base layer. You don't deploy your programs in the roll ups as it's common in many other architecture. Everything is in the same layer, everything is composable. And as we mentioned also this specialized runtime can scale and can really be customized. Now what this allow to unlock is really to have a full new category of games being built on the blockchain.
00:18:52.278 - 00:19:48.524, Speaker B: So you can have low latency high throughput games as you will with a traditional multiplayer game server, but still being able to compose with everything that is available on the layer. One ecosystem, several tools you can access liquidity, you can send messages through a protocol, mint NFT use account abstraction session keys leaderboard one unified ecosystem, everyone enriching a single state machine. Thanks for listening. And that was you can sign up using the QR code to the early access of our framework. And please check out the repository. You can find already some documentation and the white paper describing in details the framework we just presented. Thank you very much.
