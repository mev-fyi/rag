00:00:01.120 - 00:00:11.994, Speaker A: My name is Melvin, I'm from raccoons and we are the team behind Jupiter. So I'm the research engineer and we designed and prototyped the routing algorithm we're going to talk about today.
00:00:13.214 - 00:00:18.794, Speaker B: Yeah, I'm tay. So I'm just help building with the swap API for Jupiter.
00:00:19.774 - 00:01:19.984, Speaker A: And also this is work done with Pierre, who is unable to come today, unfortunately. But some of you may have seen him on discord and it's pretty active there. So Jupiter, as you may have used them before, is actually a swap aggregator platform. So when you put in your trade and you want to buy SOl with 1000 USDC, we compute the optimal route. Right, which is what you see on the right. And what we're talking about today is really how do we do that? How do we determine the best price for the trade you're going to execute? So just here's a number of different dexs that we aggregate across clob's amms and, you know, we've launched sometime end of 2021. So it's been about two years and up till early this month where we did the slides, we did $34 billion in volume, 96 million transactions and 910.
00:01:19.984 - 00:01:59.080, Speaker A: I think Miao's slide is more updated. He said 955,000 wallets more recently. And of course, you know, when we started the project, we began with the drew promise, which is best price, best token selection and the best ux for users. Because we only have 20 minutes today, we're just focusing on the first part, which is the best price. And for that we're going to talk about our routing. But I think routing is a little bit of a dry topic for most of you. You may not be running your own swap aggregator, so we'll largely cover some of the lessons we learned as we developed this upgrade.
00:01:59.080 - 00:02:03.168, Speaker A: Okay, so I'll let tay continue from here.
00:02:03.296 - 00:02:34.178, Speaker B: All right, thanks, Kelvin. So is anyone here, like, delivered in Solana two years ago? Anyone? Two years ago? Yeah, I see a few. So two years ago, before Juveria, there is only like Oca radium. If you want to swap USDC to sold, you need to go through each of the dexs and compare the price. So that's our first problem to solve. We want a place for people to compare direct routes. So this is our first step.
00:02:34.178 - 00:03:32.614, Speaker B: But this is before v one, which is like just compare direct route. Then after that, maybe you have at that time, maybe you want to swap radium to maybe saver so you can't find a direct route between that. So that's why we have the first v one, which is just a simple hop. So maybe it will hop from radium to USDC, then to sabre for example. Then that's how we come up with our v one. So we will include direct swap and a single hopping and yeah, that's how JBRs came out from then after that we get more popular and there's more dexs to integrate. So once we add more dexs, right, we actually found a problem when we built the aggregator, we found more permutation that we need to compute for a single route.
00:03:32.614 - 00:04:44.508, Speaker B: So after that we actually add more heuristic optimization like okay, we only include more liquid token as intermediate route and with that we come up with a v two. And at that time, I think address loopout table also just introduced. That's how it enables us to have more than one hot wicker. Because before that, if we only have one hop, we found that even you want to hop between at that time with serum, now it's open book. So when you want to hop between serum and radium, you actually face a transaction size limit. So thanks for the first thing is the increase in log accounts, 32, 64 and after that the address logout table to help us pack more account in. So with V two we came up with more hope and more token selection, so you can link more tokens together, but after that we get more partners and our API is written in typescript or JavaScript, so we do try to parallelize it, but we face performance issue.
00:04:44.508 - 00:05:24.516, Speaker B: And yeah, that's why we came up with methods which will be talk later on. So if you talk about limitation for Solana, yeah, you can see right now it's 64 account logs, 1.4 million compute unit and 32 kb of heap size. So if you want to be integrated in Jupiter, try to reduce some of this. So you don't use too much compute unit, you use less account. So that's the idea, yeah. So as things grow, if you go into four hops, like a route that has four hops, we eventually have a lot of permutation.
00:05:24.516 - 00:05:34.384, Speaker B: And yeah, our JavaScript effect could not solve this. And yeah, to scale this up, I think Melvin will talk more about it.
00:05:36.044 - 00:06:59.214, Speaker A: Yeah, thanks. So one of the principles I think we try to do on the new design is that let's look at what people have done and can we borrow some clever ideas? In fact, we did this already in our second version, which is the rewrite into rust from typescript. And for that we actually borrowed heavily from Uniswap's open source repository where they have this alpha router. You can find it on GitHub, but largely, it is still based on the notion of checking different permutations, which really, as you've seen, doesn't scale up to beyond three hops because there's just too many different routes available between some of the major pairs, Seoul and USDC. The other area of inspiration could be not just open source projects, but also articles or papers from the literature that could provide solutions that people have designed in the past for a similar problem. And if we look at the limits we have, which is like the most tight limit for now is like the 64 account locks, because one DaX is about 16 locks, so we can do about four or five. And that really limits in terms of how we can find the optimal route, because we can only choose to use four or five routes to satisfy the entire trade.
00:06:59.214 - 00:08:01.194, Speaker A: So if you look a bit deeper in the literature, there's this problem called the constrained shortest path. So in this diagram, I'm trying to explain this problem, right? So many of us, I guess, come from outside Amsterdam, and we took maybe a couple of flights to get here. So imagine every flight you have two numbers, right? One is the cost, the price of the ticket, and the time it takes for that flight. And you have a certain budget, let's say from your company, it says, okay, don't spend more than a couple thousand dollars on the flight. So you have this budget constraint, but you want to find, like the flight, that the sequence of flights that get you to Amsterdam in the least amount of time, right? So this problem is known as the constrained shortest path. And if you think about it, it's actually quite similar to the problem we have on chain, right? Where we have the dollars, the cost of the flight is just like the number of accounts. And we have a budget, which is 64 accounts.
00:08:01.194 - 00:08:29.990, Speaker A: You can't go more than that. It would just not work. And instead of the duration of the time of the flight, we have the output of every hop, because you want to maximize the output at the final token that you want to buy. So there are many papers written about this problem. I would like just to mention one. This is by Lozano and Modaglia. This is published in a computers and Operations research journal in 2013.
00:08:29.990 - 00:09:08.234, Speaker A: So kind of interesting about exactly ten years ago. So they introduced this method called the PALs algorithm, which is a really elegant and simple algorithm. So I really recommend you to look at the paper. And they also talk about number of different pruning rules. So in terms of checking the different routes, we don't have to check all of them, because we can largely just prune them off and eliminate them from the checks. This is what allows us to avoid essentially checking all the possible combinations through this notion of pruning. So for our third lessons, I'll pass it back to Tate.
00:09:08.734 - 00:09:41.632, Speaker B: Yeah. So with all this algorithm, how do we validate our result? I mean, just to run experiments. So what's the most important thing is to reduce variation. How to say. So the first thing we should do is what we do in Jupiter is that we save a snapshot of our account. So we make sure that our account is concerned, because if you keep on fetching from the on chain, it will be wherever the current state of the on chain is. So you will get a different result if you keep on running your same running your test.
00:09:41.632 - 00:10:19.162, Speaker B: So the first thing is that we actually save all the snapshots down locally to our project and we run it against our, our test and go to validate our result. Then after that we keep comparing like train. Is it working better, is it faster, is it doing better? Result. And yeah, in the end, because our new methods is in rust, then we just compare with criterion, if anyone use it. I mean, surely a lot of people have been using this. Yep. So what happened is that with experiment we actually saw improvement in the price discovery.
00:10:19.162 - 00:11:10.624, Speaker B: And so for bottom part is USDC, then the y axis is the price improvement. So we can see that there's huge price improvement against our old v two algo and. Yeah, but actually from our runtime perspective, we actually saw Matis is running a bit slower, but it's using a better price than our v two. But this is the type of compromises that we are willing to take at the moment. So although Uniswap one, because our v two might be a bit more optimized than the uniswap compared to the runtime. So you can see the uniswap taking about 100 milliseconds, where v two taking around less than 60. Well, the mat is averaging around 70.
00:11:10.624 - 00:11:56.584, Speaker B: Yeah. So we do prioritize on the price discovery instead of the runtime. Oh, okay. So to take away from this is that we hope that you all to start using Jupyter API. So you can just go to this, our doc, Jupiter Ag dot docs to check out our swap API. So other than swap, we can, we also provide other things like terminal, like Meow. Just now at the mainstream terminal, we also have exact out for our API, which is not really adopted that much at the moment.
00:11:56.584 - 00:12:03.824, Speaker B: And we do have other initiatives as well. Yeah.
00:12:04.124 - 00:12:41.830, Speaker A: So maybe just to summarize the three lessons from working on this project. So the first one really is we solve the simplest problem first. I think Tolly was saying, do the hard things first, but that takes a long time to get a product out. So for us, we tried to find just one hop, or even just direct routes in the early days. And as the capacity of the network increases, more account logs went from 32 to 64. We could actually start investigating more advanced methods which would give better prices. So that's the first lesson.
00:12:41.830 - 00:13:42.314, Speaker A: The second one I talked about the idea that we should get inspired by other things that people have published, like open source code or papers or literature, and that can give us some useful hints on what might work on the problem. And of course, when we actually implement those things, we have to be careful because often these articles are solving a slightly different problem. It may not work exactly. So we have to run experiments to verify if indeed the ideas that we've implemented improves on what we have done before. And you saw the graphs comparing version two and the Metis algorithm, or v three in terms of the price, that's a trade off we have to make because it's actually slower than our current version two, although it gives a better price. It's slightly slower, but as you saw from our promise, our promise is the best price. So for us it was clear that we had to implement this new one because it gives the users a better price.
00:13:42.314 - 00:14:01.044, Speaker A: So with that, I think we've come to the end, but I think we'll be here in developer stage. We're somewhere at the back, along the black tables near the coffee station. So if you have anything you want to talk to us about, like how do you integrate your decks, or any questions about different products that we have, please feel free to come and talk to us. Thank you.
00:14:01.164 - 00:14:01.524, Speaker B: Thank you.
