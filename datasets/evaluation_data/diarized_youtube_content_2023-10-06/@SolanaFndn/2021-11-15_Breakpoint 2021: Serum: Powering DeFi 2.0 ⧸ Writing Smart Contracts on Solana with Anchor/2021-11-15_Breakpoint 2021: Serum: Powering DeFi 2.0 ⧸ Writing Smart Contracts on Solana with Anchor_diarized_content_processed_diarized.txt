00:00:13.280 - 00:00:27.954, Speaker A: Okay, this is working. Cool. Yes. I'm not talking about serum, I'm talking about anchor. But yeah. So hey everyone, my name is Armani, and today I'm going to introduce writing smart contracts on Solana with Anchor. So here we go.
00:00:27.954 - 00:01:16.338, Speaker A: So if you don't know, you might ask, what is anchor? So in short, it's a programming framework. So in the web two world we have tools like Ruby on Rails, on Ethereum we have solidity web3 js and hardhat. And on Solana we have Anchor. And the thing that all of these tools have in common is that they allow you to ten x developer productivity by abstracting away the complexity of the underlying platform. And we can see this on Solana by taking a look at the projects that are currently using anchor. So if you take a look at seven of the top ten protocols sorted by TVL on Solana, seven of them are using anchor. The mango Ido program is written in anchor.
00:01:16.338 - 00:01:56.928, Speaker A: In fact, it was originally an open source contribution to the repository, the metaplex candy machine anchor. And to me, it's no surprise that for the past two hackathons, the grand prize winners wrote their protocols in anchor. If we take a look at GitHub, we can see we have over 1000 repositories depending on anchor packages. We have over 800 stars and over 95 unique contributors from teams all around the world. So that's a little bit about an introduction. Let's take a look at the tools. So anchor provides a bunch of different things.
00:01:56.928 - 00:02:57.370, Speaker A: So we've got rust smart contracts, we've got a interface definition language. So this is effectively the protocol that the smart contracts and the clients implement so that they can communicate with each other. We have client generators that use the IDL to communicate with the smart contracts, and then we have a CLI to tie everything together, a coherent developer experience. And so all this kind of comes together to create a very productive workflow. So you can write your smart contract, you can build it and parse it into a higher level representation which we call the interface description. And then we can use that interface description to generate clients, which then will talk to the smart contracts and test it. So what we have here is this very productive workflow where anytime you change your smart contract, all the downstream dependencies are automatically updated.
00:02:57.370 - 00:03:44.284, Speaker A: So not only do we have rust smart contracts and rust clients, but in fact we have clients in any programming language that are automatically generated. And so what we're going to do for the rest of the talk is we're going to go through a concrete example of this workflow, we're going to talk about smart contracts, we're going to talk about an IDL, and then we're going to write a typescript test to test the end to end product. So, yeah, let's start with that. So we're going to do the smart contract, but before looking at code, let's paint a picture of the program we're going to write. So what we're going to do is write the simplest program possible. It's going to be a counter program. There's going to be some data stored in the count, starting at zero and associated with this data, we'll have some wallet.
00:03:44.284 - 00:04:17.354, Speaker A: And this wallet is going to be the authority of the data. It's going to be the only thing that is allowed to mutate it, so it will be able to increment the data. And if any other wallet comes along and tries to mutate that data, what we want to do is we want to abort the transaction and not allow that to happen. So that's the program we're going to write. And let's look at some rust code. Yeah, so this is a smart contract. If you've never seen rust or if you've never seen a contract on Solana, it might be complicated, but we'll go through all the sections.
00:04:17.354 - 00:04:42.464, Speaker A: We'll start at a high level. So first line, we have this prelude, import. This is just rust code. And there's nothing anchor specific here, just importing types. Second line, declare id. This line is pretty subtle, and I'll get into why it's important later, but what you need to know for now is we're just embedding a hard coded address into the contract. This is going to be the program id.
00:04:42.464 - 00:05:08.874, Speaker A: And, yeah, it's just a static constant. And we'll come back to this later. The next section is the program module. So this is like the meat and potatoes of the program. This is where all the business logic is defined. And you'll see we have these two functions here, initialize and increment. These would be analogous to the methods in a solidity contract or your rest API on rails, but these are really the entry points into the program.
00:05:08.874 - 00:05:55.174, Speaker A: So you have two options here. You can either initialize a counter or you can increment the counter. And so this is where inside of these methods is where we're going to execute the code to update the counter. So in the next section we have the accounts context. So Solana is a bit unique in the sense that all of the clients provide the data or they specify what accounts they're going to access. And so the accounts context is effectively all of the data that your smart contract can read, all the data your smart contract can write and access it inside of the program. So, you know, we have two structs here, initialize and increment, and each one of them correspond to a method inside of the program module.
00:05:55.174 - 00:06:28.708, Speaker A: So we'll come back to this later. The next section is the account declaration. So this would be known as a model in rails, but it's effectually just the storage layout. So this is the data that we can read, data we can write, the data that's going to be controlled by the program. So those are the sections we have id, we have the program module, we have the account context, and we have the account. What we're going to do now is drill into each of these sections and talk about them in more detail. So here's our accounts.
00:06:28.708 - 00:06:59.894, Speaker A: We have, the first thing you'll notice is this account macro. This is some anchor macro, blackmagic, to effectively just label this struct and say that we can use it for storage. So we're going to have this counter struct, just a regular rust type, and there's going to be two fields in it. It's going to be the authority. The authority is going to be the wallet address that has the ability to update the counter. And then the count is just going to be our data. So it's going to start at zero, incremental one, but this is just the storage laid out for the program.
00:06:59.894 - 00:07:59.074, Speaker A: So we have a single counter that we're defining, and that is our account. Okay, so that's the declaration. Let's move up to the context and drill in. Okay, so as I mentioned before, one thing that's unique on Solana is that like clients provide the accounts, or they provide the set of data that your program can read and the set of data that your program can write. This is great for parallelism because it allows scheduling too. It's easier to schedule parallel transactions, but it's a total nightmare for your program because it means that the client is effectively injecting data that you then have to validate. What we do with anchor is we provide this derive macro with an embedded DSL that allows you to basically specify declarative constraints that will run when you initialize these individual structs.
00:07:59.074 - 00:08:40.464, Speaker A: And so what that allows us to do is on construction, run a bunch of code that basically prove a bunch of properties about our accounts. So when you have one of these accounts contexts, you also have a guarantee or a proof that certain constraints hold. So we'll take a look at this in more detail. So first thing you'll notice is the derive macro. This is how you declare one of these structs. And you'll notice we have two structs, one for initialize, one for increment. Again, they correspond to the instructions in the program.
00:08:40.464 - 00:09:17.724, Speaker A: Let's get started. Inside of initialize. Here we have this account attribute that's inside of this derive, and this account attribute is what allows us to declare constraints within it. And so here we have a bunch of them, right? So we have init stands for initialize. This would be like analogous to Malik and see, so you're basically creating an account, you're going to pay for some rent exemption. So here we're specifying payer is equal to the authority, and that authority is just like another account in the struct. So that's going to be the wallet that pays for the rent exemption tool.
00:09:17.724 - 00:10:06.914, Speaker A: And then lastly we have space. It's going to be 48 bytes. That's just the space for our counter. So what you have here is like this constraint or this macro that will allocate an account, pay for the rent exemption sol, and allocate 48 bytes, and it'll do this all on construction of this struct. And we're going to do it for the field that it is decorating. So here we have the counter, and what you notice here is we have this new account type that we introduce, and the account type is basically just a deserialized account wrapper for the internal type, which is here is the counter which we previously defined in the previous section. What's nice about this is that whenever you have one of these structs, you can guarantee that you have a counter.
00:10:06.914 - 00:10:48.144, Speaker A: It's deserialized, it's a normal rush structure and no other type can be passed into here. So next line we have the authority and we introduce this new signer type. This will effectively just do validation checks on creation. So if the account signs the transaction, we're good. If it doesn't sign the transaction, then it will abort and the transaction will fail. And then the next line here is the system program, and we introduce this new program type, um, which just basically asserts that the account is executable and that the um, address of the program is indeed equal to the address inside. So here it's a system program.
00:10:48.144 - 00:11:55.298, Speaker A: Uh, so you know, all of this comes together to effectively give you this guarantee that if you have one of these structs then you know you have a brand new counter. You know the rent exemption was paid for, uh, by the authority, and you know that authority did indeed sign the transaction. So that's initialize, we move down to increments. And notice we have this new mute keyword right here. The mute keyword stands for mutable, and it basically allows us to persist the state transition whenever we update the struct. So if we modify any of the fields on the counter that is being decorated here, then we'll store that to storage and the state transition will be persisted. Next thing we have here is this has one thing, this is some syntactic sugar, but it basically defines a constraint that basically says if the counters authority property is indeed equal to the given authority, then the struct will successfully be created.
00:11:55.298 - 00:12:48.374, Speaker A: And if it's not, then the struct will fail and the transaction will abort. So all of this comes together such that when you see one of these increment structs, you can prove to yourself that ok, you have a counter, it was previously created and the authority signed the transaction. So then it's probably safe to do something, or it is safe to do something. So yeah, those are the two account context for the program. And what's nice about all of this is that what we've done is we've encapsulated all of the account validation logic in these structs in this declarative fashion, which allows us to separate a lot of validation logic from the business logic in our program. So we'll see that in the next section. So let's go ahead and open up the program module.
00:12:48.374 - 00:13:24.974, Speaker A: Okay, so here's the program module. This is again like where the business logic lies. First thing you'll notice we have the program attribute that basically just labels this module such that all of the functions inside of it will be treated as instructions. So these are your APIs. So you know, we have initialized, we can initialize the counter, we have increments, we can increment the counter. And let's take a look at initialize first. So what you'll notice is like the first parameter here is this context generic over some inner type which is like the initialized structure.
00:13:24.974 - 00:14:17.794, Speaker A: And this is the same initialize struct we previously defined. And so what we know is by just looking at this code, if we ever enter the body of this function, then we can prove to ourselves that we have a new counter, it's zero initialized, and the rent exemption Sol has already been paid for, and the subsequent parameters are just instruction data. So these are just parameters that we pass in from the client. And yeah, let's enter the function body. So the first line here is we have immutable reference to the counter. As I said previously, this accounts context is what gives us access to all the data. So we're going to get a mutable reference and we're going to initialize the data, we're going to set the authority, we're going to set the count, and then we're going to return success.
00:14:17.794 - 00:15:32.024, Speaker A: And that's initialize, and then we can move down to increments, take a look at the context, and prove to ourselves that ok, well we have this increment context, there's some constraints in the increment context, and that means that if we ever enter the body of this function, then we can prove to ourselves that ok, we have a valid counter, and the authority of that counter did indeed sign the transaction. And if either of those things aren't true, then we'll actually never hit the function body. So we take immutable reference to the counter, we update the count, increment it by one, and we return success. And that is the increment method and that is the program module. What you'll notice here is not only do we just not do any account validation logic here, but we're just playing with rust structs. There's no deserialization, there's no serialization, it's just what you want out of your programming model in the sense that yeah, you're mutating some types of memory and you're able to reason about the logic of the program because it's not polluted with a bunch of other checks. That would make it harder to reason about the business logic.
00:15:32.024 - 00:16:14.704, Speaker A: Yeah, so that is the program module. And then lastly we'll talk about this declare id thing. So let's open it up, and what this macro will expand into, it's pretty simple. It's just a static id variable that's created. So we've hard coded it, we have a static id. But the reason why this is so important is because it allows us to bind the program address to all accounts that we declare in our program. So what this means is that, okay, if we ever have one of these counterobjects, then what we also have is a guarantee that that counter is indeed owned by this program.
00:16:14.704 - 00:17:01.022, Speaker A: And so it completely eliminates a class of security vulnerabilities where if you omit an ownership check, something in your program might go wrong. So this is the type of thing that ink provides not just productivity improvements, but also these entire classes of security foot guns that you're exposed to in the vanilla Solana runtime. So yeah, that's the program. What we do then is we have the program, we compile it, parse it, and we get this higher level representation which we call the IDL. This is what it looks like some Json. You'll never really actually open it up. Maybe you will, depending on what you're doing.
00:17:01.022 - 00:17:41.924, Speaker A: But it's worth pointing out that this corresponds one to one to the smart contract. But it's really just the connective tissue that allows you to tie the smart contract to the client so that they can communicate via a well defined protocol. So, you know, we have some fields in here. We have the counter, which is the name of the program, and we have our two instructions, initialized increment. We have the arguments for each instruction. The accounts and the account declaration don't need to follow all this, but you know it exists. You can open it up in your terminal, but worth pointing out.
00:17:41.924 - 00:18:15.090, Speaker A: So yeah, that is the IDL. And next we can see how to tie this all together with a test so we can write some client code. Okay, so here is the test. This is just like a mocha test, and the first chunk of code here is just the imports. Second line, just this describe counter. This is just like a mocha syntax for starting the test. And then the first line inside of the test is pretty important.
00:18:15.090 - 00:19:09.584, Speaker A: So here we have this program variable that's introduced where we have anchor workspace counter. And what's happening here is the anchor package is reading the local workspace, looking up the file system, fetching the IDL, and then using the IDL to generate a client. So this program variable is going to be our typescript representation of our smart contract in a MoCA test. And what we want out of this client is for the API to correspond one to one to the smart contract, so that we can just read the smart contract and know exactly how to use it from the client side. So next line is just like we're creating a counter. This is just generating a key pair. This is going to be the address of the account that holds our data.
00:19:09.584 - 00:19:47.904, Speaker A: And then we got to take a look at the actual test here. So here we're going to create a counter and we are going to invoke the initialize function. So there's a couple things here we have the program, which is the client. We have this RPC thing which is like, we call them namespaces. Inside of the client, there's a couple of them. But the RPC namespace effectively allows you to sign a transaction and send it of the cluster, and on of that namespace you have a bunch of functions that correspond one to one to the instructions inside of your program. So here we have the initialized instruction and we just invoke it like a normal function call.
00:19:47.904 - 00:20:27.136, Speaker A: So we have the data. So this is going to be the start counter and then the context here at the end. So in the context we have the accounts. This is going to be all the data that our program is going to read and write, and we just pass in the pub keys. So we have the counter, the authority, the system program, and this is exactly the initialize account context struct from our rust program. So yeah, those are the accounts. And then lastly we have the signers field, kind of a detail, but in the slanted runtime you have to sign the transaction with all accounts that you create.
00:20:27.136 - 00:20:52.154, Speaker A: So here we're creating a counter account with the system program that's going to be owned by our program. And so, you know, we need to sign the transaction with the counter account. So yeah, that is the first test here. So that is how to initialize the counter. Next we increment the counter. So same thing. We have program RPC increments, just a normal function call.
00:20:52.154 - 00:21:29.602, Speaker A: There's no parameters here, but we still have to pass in the accounts. So here we have the counter, we have the authority, and that is it for incrementing the counter, just a function call. Next we have this new line right here. We have this new account variable that we're defining. This is basically fetching the account from the blockchain, deserializing it, and giving you a typescript type. So we have program account. So instead of RPC we're using this account namespace that gives you access to all of the accounts that are declared inside of your program.
00:21:29.602 - 00:22:03.652, Speaker A: So here we have this counter account, or this corresponds to the rust struct in our contract, and then we fetch it with a pub key, and that will return to you an account. And that's just a typescript object. It's just an object with some fields. So we have the count field, we can assert it's equal to one, and the authority field, which is going to be our wallet. So yeah, that is the typescript test. So what you do is you have this typescript test, you have the smart contract, and then normally you run the test. I'm not going to do this live because I'm not crazy.
00:22:03.652 - 00:22:38.662, Speaker A: But yeah, you would run in your terminal, and what anchor would do is it would spin up the validator, deploy the program, run the test, and then tear down the validator and hopefully return success. And yeah, that is our typescript and that is the entire workflow in one. So if you're interested in more and you want to learn more about anchor, here's some resources. Check out the GitHub. There's tons of examples in there and tests, some tutorials, some API documentation. Probably most importantly is the discord. Definitely join that.
00:22:38.662 - 00:22:48.094, Speaker A: If you're looking to learn, you're looking for help. There's tons of really smart people that just hang out in there all day, every day that like helping out people. So, yeah, that's it. Thanks for listening.
