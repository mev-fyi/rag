00:00:08.440 - 00:00:38.985, Speaker A: Hello everyone. Gm. Gm. I'm Nick from the Solana Foundation Devrel team and welcome to this Solana workshop. Throughout this video, in this workshop we're going to be going over the basics of the Solana blockchain, how it works and how to actually get started with developing on Solana. We're going to talk about things like the Solana programming model as well as how to actually interact using JavaScript and TypeScript, how to interact with the blockchain and perform some of the super common actions that you'll actually be doing when you are developing any applications on Solana. So let's get started.
00:00:38.985 - 00:01:43.527, Speaker A: A brief overview of the agenda. The first thing we're going to talk about is the Solana Network broad high level overview including the technical advantages and a broad just network overview of how Solana actually works. So at a high level the two big technical advantages of Solana is you have really fast confirmation times, especially compared to other blockchains is a Solana transaction can be validated by the entire network in about 400 milliseconds, which is significantly faster than most other blockchains. So with every single transaction you also have these low transaction fees, which a single transaction is usually about 5,000 LAMP ports per transaction signature per signature on a transaction, which we'll go talk about more in depth of what those specific terminologies actually mean throughout the duration of this video. And all of this is actually while maintaining valid consensus through about 25,000 plus voting validators scattered all around the world. So it's a very globally distributed network run by entities and individuals from around the world. So the next thing we'll get into is a broad overview of how the Solana Network actually works.
00:01:43.527 - 00:02:21.059, Speaker A: So at a high level there's a validator leader and this leader is going to receive all the transactions throughout the entire blockchain. It's going to take all these transactions that get created on the front ends and the decentralized applications that you're used to interacting with blockchain blockchains with. And the leader is going to take all these transactions, it's going to pack them into blocks. These blocks are then going to get propagated throughout the entire Solana network. Again those 200 or 2,500 voting validators throughout the entire world using a piece of code called Turbine. And Turbine is just the block propagation portion of the Solana protocol. And these transaction blocks just get sent around the world.
00:02:21.059 - 00:03:02.649, Speaker A: And one of the interesting things about Solana is that all these transactions can actually be executed in a parallel Fashion, because of the way that Solana is designed. A portion of that is because every single transaction on Solana is actually stateless. So a specific transaction doesn't maintain its own state, its own data. It's interacting with accounts that are actually storing those bits of data. Which we'll talk more about the accounts here in a bit. But every single transaction is going to read and write to different accounts on the Solana blockchain. And because all of those reads and writes get processed differently on the blockchain, it allows all of these transactions to be executed very, very fast, which again leads to that really low confirmation time and the really fast block propagation throughout the entire network.
00:03:02.649 - 00:03:47.025, Speaker A: And all of this uses this concept called proof of history, which is one of the innovations that allows Solana to actually be so fast as a blockchain. So just some of the key takeaways is that Solana has really fast confirmation times, low transaction fees, it executes programs in parallel and thus transactions in parallel as well. And it's ideal for high performance applications because of all these features. Next we're going to talk about the general programming model on the Solana blockchain. So the first thing to understand is accounts, and I mentioned accounts earlier, and accounts are one of the key portions of the Solana blockchain. Basically, on Solana, everything is an account. You can kind of think of accounts like files on an operating system, especially if you're used to a Linux based operating system.
00:03:47.025 - 00:04:14.215, Speaker A: Every single program and every single bit of data is a file. Very similar. In Solana, everything's an account. Accounts are unique 256 bit addresses. They all hold some balance of SOL, which is the native token on the Solana blockchain, they can also store arbitrary data just in the form of raw bytes. And the data storage that actual data storage is paid for in what we call rent. And we'll talk more about rent here in a moment.
00:04:14.215 - 00:05:00.017, Speaker A: Now, some of the key things to understand about accounts is that anyone can credit the SOL token to an account and anyone can read data from the account in a permissionless fashion. But on the flip side, only the owners of an account can actually debit SOL or remove a SOL balance from it, or actually modify the underlying data of an account. And that's really what you want because that will inherently make it so you can have security over who actually owns the data and you can have ownership verification. So we can look at the accounts in its raw form and you can see there's a couple of key pieces of data that we have here. We have the key, which is basically the address of the account. You can think of this of your public address that you might be used to seeing. On various blockchains, you have the lamports, which is the actual total balance.
00:05:00.017 - 00:05:36.635, Speaker A: Lamports are the smallest unit of value for the native SOL token. So in a Lamport, or rather one sol is about a billion lamp ports. And accounts actually store the number of LAMP ports that that account has ownership over. And then you have the actual data that's stored within the account. And again, this is just the raw bytes stored in the form of an unsigned integer or a U8 array. And again, those are just the raw bytes that are actually stored on the blockchain itself. And then there's this is executable Boolean flag that every account has.
00:05:36.635 - 00:06:07.417, Speaker A: And basically this just signifies if the specific account that you're interacting with is a program or not. If executable is true, it's a program. If it's false, it's just a data account. And lastly, there is a owner value. Every single account has an owner, and only the program owner of that account actually has the ability to update the data that's in that account. Now that we've mentioned programs, let's go ahead and talk about specifics about them. On other blockchains, programs might be called smart contracts, but on Solana they're called programs.
00:06:07.417 - 00:07:06.925, Speaker A: And basically these are the pieces of code that you can actually deploy to the blockchain in decentralized fashion that are actually going to execute some amount of instructions and some sort of processing on the blockchain itself. And specifically for Solana programs, they're basically a special type of account. Like I mentioned before, they have that executable flag is a true value, which lets the Solana runtime know that it is actually a program. The data that's stored within that specific account is EBPF bytecode, which is the Berkeley packet filter bytecode. And programs are typically written in Rust, whether it's native or one of the Solana Rust frameworks that are out there. You can also write programs in C and C, and there's a couple of helper libraries out there for writing programs in Python and then soon other common programming languages. But for things like Python and JavaScript, any programs that are written in those typically just get transpiled down into their Rust code equivalents.
00:07:06.925 - 00:07:49.181, Speaker A: Some of the key things about programs on Solana is that every program is stateless. They actually can only read and write data to other accounts, so they can never actually write data to their own account. And this is actually one of the things that allows programs to be executed in parallel, which again, leads to the speed improvements that the Solana blockchain has. And like we talked about for general accounts, every single account has an owner value, and only the owner can update the account. So if you're writing a program, you can make any program you write be the owner of any other account, as long as you have the appropriate permissions to do so. And only your program will be able to actually write data to those accounts. All programs execute instructions, which we'll talk more about here in a bit.
00:07:49.181 - 00:08:30.491, Speaker A: And instructions are basically the bits of information that you're trying to ask the Solana runtime or a specific program to actually execute. Programs can all send instructions to each other using something called cross program Invocation or CPI for short. Or you can have instructions be built on a front end, like JavaScript or TypeScript, on a website or a decentralized app that can then get sent to the Solana runtime for execution. So the key takeaways about accounts and program is that everything on Solana is an account. All accounts hold a sole token balance in the form of Lamports. Accounts can store arbitrary data. Accounts can also store executable programs themselves.
00:08:30.491 - 00:09:29.859, Speaker A: And accounts are all passed into programs, allowing for parallel execution. Now, we're going to talk about some of the specifics about Solana program instructions. So you can see the raw form of an instruction here, where you have the program ID of the program that's actually executing the instruction. Then you have a list of an array of keys, and these are all the accounts that are actually involved with executing a particular instruction. And this is one of the things that allows the Solana runtime to be very performant, is that every address or every account that gets touched inside of a transaction or inside of an instruction specifically, is that you have to provide all of those values, all those addresses within the instruction. And this technique actually is one of the things that allows for the Solana blockchain and the Solana runtime to have this parallel execution. And then lastly, you have some amount of data in the form of the raw bytes that are actually being sent over the wire to the program that you're trying to interact with.
00:09:29.859 - 00:10:14.149, Speaker A: That's that program id. And then you take all of these instructions and you can have multiple instructions, and you bundle those together inside of a transaction. And a transaction is the thing that you're actually sending to the RPCS or sending to the validators on the Solana network, which Then get processed through that leader process and the turbine execution or the turbine block propagation throughout the entire network. Here you can see a transaction in its raw form and you have some key pieces of information. Here we have an array of instructions, just the list of instructions that this transaction is trying to execute. You have a recent block hash which is used for deduplication of transactions. And this allows for some of the speed improvements as well as some security features.
00:10:14.149 - 00:11:12.757, Speaker A: You have the fee payer address of whichever account is actually going to be paying the gas fees for your particular transaction. So all those small transaction fees that you get on the network and then you have the actual array of all of the signers. So with every transaction, any time an account is updating data, whether you're updating the actual data itself or if you are debiting Lamports or SOL from an account, that public key is required to actually sign a transaction. And this allows for the cryptographic verification and signature verification on the blockchain. And we just include all of those signatures in the form of the raw bytes inside of every transaction. So the key takeaways on transactions and instructions is that programs invoke instructions, instructions are sent via transaction, and transactions are required to be atomic, and transactions all must be signed. So now we'll kind of tie it all together via the lifecycle of a transaction.
00:11:12.757 - 00:11:57.555, Speaker A: So we'll start from the perspective of a client. So you have a decentralized application and you're building transactions for your users. So the client will actually build the instructions which then get, they get put inside of a transaction. The transaction gets sent to the RPC clients, which then forwards all of the transactions to the voting validators. The validators will actually use the Solana runtime to enable the runtime to actually execute each of the instructions within every transaction. And then each of those instructions will call to a specific program to actually execute whatever that program's code is trying to do. So this program is just say incrementing a counter and it's just going to increment it up by one.
00:11:57.555 - 00:12:37.759, Speaker A: So that's the broad lifecycle of a transaction on the Solana blockchain. So now that we've talked about the basics of the Solana blockchain and how it works, we're going to go through some demos of how to actually use and build Solana transactions. So the first thing is we're going to be going through this example code repo. The link will be available in the description, in the show notes and take a look through the readme. It Kind of describes how this specific section of the repo is laid out and what each of the files are doing. But the first thing to note is that we're connected to the Solana devnet. So you can see here I have the Solana CLI installed on my computer and we're actually connected to this DevNet RPC.
00:12:37.759 - 00:13:23.809, Speaker A: And I also have a local key pair at this file path, which we'll talk more about this in a moment. And you can see that this is the actual address for my key pair. It's this NIC B1D and ends with RexD. And then this particular DevNet account actually has a SOL token balance of about 240 point something actual SOL tokens. So because we're actually going to be executing transactions on the Solana blockchain, specifically the DevNet portion of the blockchain is we're going to actually have to be able to pay for the fees for all of those transactions. So you need to make sure you have some amount of balance in there. So the first script we're going to go through is this script inside of the Scripts folder script number one simple transaction.
00:13:23.809 - 00:14:04.939, Speaker A: And we're going to go through the process of actually creating a very simple transaction just so you can understand the basics of how it actually works with using TypeScript and JavaScript. This entire section of the repo is actually laid out in all TypeScript. So if you're not familiar with TypeScript, don't worry, you can do all the same Things with vanilla JavaScript. It'll all work just the same. So the first thing we're doing here is we're actually doing some pretty standard imports. We're importing some functions and values from the Solana Web 3 JS as well as we're importing some helper functions that are stored locally within this repo. And one of those helper functions or one of these variables that we're importing is this payer address.
00:14:04.939 - 00:14:45.205, Speaker A: And I'm actually taking my local key pair file, this JSON file id JSON. I'm loading that in using JavaScript, so that way I can use this on my JavaScript application front end. And again, that's just using some helper functions within this repo. You don't really need to worry too much about that. That's not really Solana specific. Now the first thing we're doing is we're actually creating an asynchronous function because we are going to do some async await functionality within JavaScript and we're actually just going to log out our payer address key pair to the console just so I can show that that is actually the same address that I just showed. Then we're going to actually do an async await and we're going to get the balance of this key pair.
00:14:45.205 - 00:15:46.179, Speaker A: And again, you should see the same values here that we have for this address and this balance. And then specifically with this example, if this particular balance has or if this particular address has a very low balance, less than one sol, then we're just going to request an airdrop, which is always available on Devnet and Testnet. Next, I'm generating a brand new fresh and random key pair to be used just to demonstrate some of the additional functionality. And we're going to log out the actual address of that key pair and then finally we can actually start building our first transaction and specifically our first instruction for our first transaction. So the first thing we're going to do is we're actually just going to create an account on chain and we're going to take our payer address that we have already funded with our sole balance and then we're going to create that new random key pair. We're going to allocate space on chain so that way we can tell the Solana Devnet blockchain. In this case, we can tell the blockchain that we want this address to exist on chain and we're going to pay that rent.
00:15:46.179 - 00:16:27.911, Speaker A: Now, I briefly mentioned what rent is before, but we'll talk more details about it. Right now, with all the space that is required for accounts to exist on the Solana blockchain, you have to pay rent, this rent. You're required to pay two years of rent upfront to actually store your space on the Solana blockchain. This is what we call rent exempt of paying that large enough balance upfront. Anytime you're going to allocate space on the blockchain, which basically this is the concept of encouraging validators to actually maintain your space and your data on the blockchain. So it's just paying that fee upfront. The Solana Web3JS library has a helper function called get minimum balance for rent exemptions.
00:16:27.911 - 00:16:57.455, Speaker A: And we're going to allocate. We need to tell it how much space we're actually going to allocate. In this case, because we're just going to create a very simple account just to store Lamport balance or Sol token balance. We actually don't need any space to allocate. So this will be the lowest possible amount of rent that you can pay for any given account. So we're going to request the minimum balance for rent exemption of zero bytes. And then we're just going to log that out to the console just to show how many LAMP ports it's actually going to take to allocate this account.
00:16:57.455 - 00:17:54.111, Speaker A: Next, we can actually build our very first instruction. We're going to use the system program and we're going to create an account because like we talked about earlier is every account is owned by a program and for generic normal accounts that are just holding a balance, those are all owned by the system program, which the system program is baked into the Solana runtime every time the validators get updated throughout the validator lifecycle, that the Solana runtime program will get periodic fixes and everything. So it's different to a program that you might try to deploy as a developer. But we're going to create our first account. We're going to provide in all the required data for this particular function. In this case, we're saying the FROM address and this is the payer of our transaction fees. We're going to tell it the new address that we want to allocate on chain and again, we're using this randomly generated key pair and then we're going to tell it how many LAMP ports we want to store in this account.
00:17:54.111 - 00:18:32.095, Speaker A: And we need to make sure that we are storing at least the minimum number of LAMP ports for rent exemption. We need to say how much space we're actually going to allocate. And then the owner of this program, and again, we're just using the system program as the owner. So we put all that into a single variable called CreateAccount instruction IX for short. And now we can actually build our very first transaction for the Solana blockchain. So like I talked about earlier is that every transaction is required to have a recent block hash. So we can actually use the blockchain and just request the recent block hash and we can get that value and we can just put it inside of our transaction right before we send it to the blockchain.
00:18:32.095 - 00:19:28.481, Speaker A: So that's what we're doing here. We're using our connection, we're getting the latest block hash and we're kind of doing a little bit of destructuring and just getting this block hash value and then we're going to include that inside of our transaction. So in this particular example, we're building a version transaction, which is a slightly newer thing on the Solana blockchain, but it is slowly becoming a more and more common standard that is accepted and is actually supported throughout the entire ecosystem. And we're going to build our transaction, we're going to provide our list of instructions in this array. In our case we're just doing one single instruction. We're giving the recent block hash that we just got from the blockchain itself and then we're saying who is paying for the transaction? And then we are actually creating our transaction. We're signing the transaction in every transaction because we are always deducting some amount or debiting some amount of SOL token from at least one account.
00:19:28.481 - 00:20:13.187, Speaker A: There's always required to be at least one signature. So in this case, because we're also allocating space and we're creating an account on chain at an address, that address, that key pair is also required to sign the transaction. So in this case we're going to sign with our payer and our key pair and then we're going to use our connection and we're going to send that transaction to the blockchain and then we're going to do a little bit of logging just for simplicity and for demonstration. So I'll go ahead and clear my console and we'll just go ahead and run this first script. So I'll go ahead and scroll back to the top so you can see all the information that we displayed. And you can see our payer address is that same NIC value that I showed earlier, the NIC B1D and ends with RexD. You can see our total Lamport balance and then the total balance in SOL.
00:20:13.187 - 00:20:47.837, Speaker A: Again it's about 240 point something sold. And then you can see we generated a brand new random address using the web3js. And then we have the actual Lamport cost to allocate that space on chain for the minimum of zero bytes. And then we're actually just logging out our transactions. You can see kind of the data structure that we had mentioned before of how Solana transactions work is we have this array of signatures which is just a byte array. And then we have our message data which has a header, our static account keys. And these are all the account addresses that are touched within our transaction.
00:20:47.837 - 00:21:19.135, Speaker A: You can see the payer address that is actually paying for the transaction. And then you can see the public key of the address that we are allocating on chain. And then this all ones value is the system program. Then we have our recent block hash value again just requested from the blockchain. So it doesn't really matter what that is as long as it is recent enough. And then we have a list of all of our transactions, or rather our instructions that we are actually sending to the blockchain itself. And then you can see our transaction did complete and it completed on Devnet.
00:21:19.135 - 00:21:59.605, Speaker A: So we'll go ahead and open this on the Solana Explorer and I'll also take this opportunity to kind of discuss how the Solana Explorer works and try to how to actually like understand some of the information that's displayed on here. So you can see in the URL here that we're on Cluster DevNet, because our transaction did actually execute on the DevNet. And you can see some common information you might expect on a Blockchain Explorer. And if you're new to blockchain Explorers, it's pretty standard information. You have a timestamp, you have the actual signature value, which is basically just the keyed value for the blockchain to index on. And you have some other sort of information. You have that recent block hash that we sent.
00:21:59.605 - 00:22:23.197, Speaker A: You have the total transaction fee. And you can see this is actually 10k lamports because we had two signatures. You're paying 5k lamports per signature. And then you can see all the accounts that were included within this transaction. We have this NIC value, this at 3, and the system program, that 111 and so on. And you can see our post balances. And who actually had to sign this transaction.
00:22:23.197 - 00:23:08.589, Speaker A: We had two signatures, we had two signers. So our NIC and the AT3 both had to sign this transaction, which is how we got our 10k lamport fee, balance or fee required to be paid. And then you can kind of see the instructions there that were actually executed within this transaction. We had our system program executed the create account instruction, because that was the only instruction that we actually included within our transaction. And you can see the information of what actually happened. We allocated zero bytes on chain and our instruction executed successfully. So now that we have a basic understanding of simple transactions, let's go through a little bit of a more complex transaction and how to actually build those, because it's a very similar process, but there are some slight differences.
00:23:08.589 - 00:23:52.217, Speaker A: You have to do so within the repo, open the script number two of complex transaction and we'll go through this. Now we're doing a very similar thing. We're doing some of our imports at the top. We're going to log out our payer address and a test wallet address, which is in this case we're importing this locally, which is just going to load or generate from our local File system here, kind of just some helper functions just for the demo's sake. But in this case it's just going to randomly generate a new key pair and then save that key pair inside of this local directory, inside the local keys folder, you can see the test wallet's already been generated. And again, just a random address, doesn't really matter what it is. So next we're doing the same thing.
00:23:52.217 - 00:24:44.575, Speaker A: We're going to allocate space on chain for this new random address that we just generated. And in this case we are also setting our space to zero, so we want zero total bytes, so we're going to get the minimum balance for rent exemption there. And then the only difference here is we are setting our test wallet as the address that we want to generate or that we want to allocate on chain. And in fact we're going to store an additional 2 million lamp ports inside of this account. The next thing we're going to do is we're going to actually execute a transfer from our test account, this test wallet account, and we're going to transfer it back to our, or rather we're going to transfer it from our payer account and we're going to send it to the test wallet. So we're going to create our test wallet on chain and then we're going to transfer from our payer to our test wallet. That's going to be the second instruction we're going to execute.
00:24:44.575 - 00:25:31.515, Speaker A: And then we're going to execute a third instruction, which we're just going to transfer to another random address. It doesn't really matter what it is. This is just again to demonstrate how you would build a transaction with multiple instructions. In this case, I'm loading in this static PUB key value, which happens to be this NIC address, which it doesn't have to be, it just happens to be just for demonstration. And we're going to build a transfer instruction, and then once we have our instructions built, we can then get our recent blockhouse just like we did before, and we can build our version transaction just like we did before. Except this time we are putting in four individual instructions. We're creating our test account, we're transferring to our static wallet, we are transferring to the test wallet, and then we're transferring to the static wallet.
00:25:31.515 - 00:26:09.485, Speaker A: Again, just to demonstrate that you can do a lot of these types of things all in one transaction, because every single instruction in a transaction is executed atomically. And what that basically means is that every single instruction is executed in order. And if any of those instructions Fail, the entire transaction will fail. So you get a little bit of data integrity in that way. So then we're going to finally build our transaction. We're going to sign it with our payer and our test wallet, and then we're going to send that transaction to the blockchain and then we're going to log it out for demonstration. So let's go ahead and run this script.
00:26:09.485 - 00:26:30.275, Speaker A: Script number two, complex transaction. And there we go. It completed successfully. Again. We have the exact same payer address. We have this new random test wallet address that we generated and we completed successfully. We logged out our Explorer URL and we can open up the explorer and see what it looks like.
00:26:30.275 - 00:27:02.871, Speaker A: Again, you have a lot of the same information. You have the signature address, the timestamp, the number of the amount of our fees that we actually paid. We have our three account inputs. These are going to change for every instruction you actually execute. And then you can see the list of all the instructions that we're actually executing atomically inside of this transaction. So that's the basic overview of actually building transactions for the Solana blockchain. And we'll go back through the key takeaways is that applications will actually build and send transactions to an rpc.
00:27:02.871 - 00:27:37.427, Speaker A: The RPC is going to actually take all those transactions. They're going to forward them to the rest of the network, to the voting validators. The validators can then execute those those transactions which are going to invoke programs. And each of those programs has the ability to update accounts of accounts that they have the authority or ownership over. So next we'll talk about tokens on the Solana blockchain. So tokens are actually a combination of effectively three different programs. On the Solana blockchain, there's the token program, the associated token program, and the metadata program.
00:27:37.427 - 00:28:21.683, Speaker A: Token program and associated token program, or ATA for short, are programs that are deployed by the Solana Labs organization. And the metadata program, one of the common ones, is deployed by the Metaplex Foundation. So these are three different programs that are built by two different entities that are used by almost everyone on the Solana blockchain. Now, for creating a token, the token program will do what's called create a mint. So a mint is basically just an account that has control over some amount of token balance. You can think of this like a normal government where you have, like, for example, the United States government, they have the Treasury Department, which runs the United States Mint. And the Mint is responsible for actually creating the national currency.
00:28:21.683 - 00:30:00.751, Speaker A: The exact same concept here is we have the token program has control over a mint, which has the ability to mint new tokens. And then once tokens are minted from our mint, they need to be owned by a wallet, by a user, in order to actually interact with the rest of the blockchain. This is actually in the form of this unique ownership relationship via associated token accounts, where a wallet will actually own the associated token account, will have authority and ownership over an associated token account. And that ATA is actually what is storing the SOL tokens, the SPL tokens that you're actually used to interacting with on the blockchain, and then additionally with this, is that tokens can actually have metadata associated with them using something like the Metaplex's metadata program, where you can have things like the name of the token, an image that represents it, to kind of give some sort of visual bit of information for a token. You can have a symbol, and all of that types of information is stored within a metadata account, which is owned by the metadata program, which has a relationship with your token's mint. So if you wanted to do something like create an SPL token, you want to create a random token for whatever your use case is, you can do that by using a Solana transaction. And you're going to create all the instructions that you need in order to perform all these various actions on chain, like creating our new account, initialize that account as a mint, create the associated token account, and then you can actually mint tokens from your Mint into the associated token account.
00:30:00.751 - 00:30:38.911, Speaker A: And all of this can actually be done with a single transaction on the Solana blockchain, which is really cool because this composability that the Solana blockchain has, it means you don't actually need to deploy a new protocol in order to create tokens or SPL tokens. So that's really cool. So let's go ahead and go through that process now. We'll use again our TypeScript code and our scripts. Here we're going to open script number three and this is actually a demonstration of how to create an SPL token, a Solana program library token with metadata on the Solana blockchain. So pretty standard stuff. At the top, we're importing our various needed things.
00:30:38.911 - 00:31:26.555, Speaker A: And of note, we are importing some variables and values and functions from our local repo here, as well as some specific things from Web3js, as well as the Solana SPL token library and these Metaplex foundations, MPL Metaplex libraries, what that stands for, for the token metadata. So we're doing those imports and then again we're going to log out our payer address and our test wallet and we're going to create a. We're going to randomly generate a brand new key pair for use with this use with our SPL token. And then we're going to define a little bit of configuration information of our metadata that we want to have for our actual token itself. So some of this information will probably make sense. You have a name and a symbol. In this case we're going to call this seven SEAS Gold.
00:31:26.555 - 00:32:15.915, Speaker A: For this workshop we're going to have a symbol of gold in all caps and a URI which just points to whatever address you want. And it's just a JSON file which has additional metadata and information in it for your particular token. In this case, we're not actually pointing to a real URL because it doesn't really matter for the demonstration, but if you were trying to create an actual token that you wanted to be live on mainnet or something, then you would need an actual JSON file there. But then there's this other value called decimals. Now every single token has some number of decimals that can be 0 decimals, so you can have only whole numbers and then you can have a bunch of decimals if you wanted. So for our particular case here, we're just setting 2 decimals, just like you're probably used to with a normal fiat currency like euro or US dollar, so on and so forth. We're just going to have two decimal places.
00:32:15.915 - 00:32:58.501, Speaker A: And there's a certain caveat here that we'll talk about in a moment for decimal places. And then we're going to actually start building our instructions similar to when we created our account on chain before. For the simple instruction or the simple transaction is we're going to use our system program CreateAccount and we're going to create an account. This time we're going to allocate a mint size worth of space. Now, this is a constant variable that's pulled in from the Solana spltoken package and it's basically just a helper value which will let us. It'll give us a value of how much space is required just for this particular account. This is a common practice that you'll see when you start interacting with various JavaScript or TypeScript packages.
00:32:58.501 - 00:33:44.487, Speaker A: They'll have helper functions and helper value so you don't have to hard code a bunch of this. It'll be built within their package library. So we're going to allocate that much space, however much space that is, and we're going to get the total balance required, the minimum balance for rent exemption of that same amount of space. And this time our token account, our Mint account, is actually going to be owned by the token program. And again, this value, just like the Mint size, this is a value that's being provided from the Solana SPL token package. And you can see it has this token keg is what it starts with. So the token program will have the authority, have the ownership over our Mint account, which will allow the token program to actually mint additional tokens.
00:33:44.487 - 00:34:32.486, Speaker A: If we tell it to, the next thing we're doing is we're actually going to initialize that Mint account as a Mint. So we're basically going to tell the token program that this account is a Mint. We've allocated space, we're going to tell it that it is a Mint, so it can actually know how to interact with it correctly. And we're just passing in the required values for that are the value of it or the address of it, the total number of decimals and the payer of the transaction, as well as the owner of the authority, the Mint authority, and the freeze authority for it. Whatever address you provide as the Mint authority is the only address that will be able to mint additional tokens. And then freeze authority is very similar. It's a similar concept where you can actually freeze a token so you can prevent additional tokens from being minted unless the freeze authority allows it.
00:34:32.486 - 00:35:50.041, Speaker A: You can also disable additional minting by setting the freeze authority to a null value. So you basically lock it so no one can ever mint additional tokens to your particular mint. Next we're going to get the address that we're going to use for our metadata account to actually store our tokens metadata on chain. Now this is using a concept called a PDA or program derived address. And basically this is a special type of account, special type of address on the Solana blockchain that makes it so a program can actually sign transactions for whatever particular use case you're using. So it basically comes down to the cryptographic curve that Solana uses for its key pairs. And the big thing to note here is that we are this particular metadata account that we are deriving or computing the value of, it's owned by the token metadata program, which starts with meta qbxx and then we are using a hard coded string at the beginnings, we're taking a list of values and we're saying, hey, this is the metadata and then the metadata program as a value, and then the mint key pair that we actually generated earlier.
00:35:50.041 - 00:36:41.275, Speaker A: And we're taking all these together as sort of a key value in a way, and we're using that as a seed to derive our PDA from our metadata program. And we're just going to log that address out to the, to the console for simplicity or for demonstration. And then we're going to actually create our instruction that will create the metadata account on chain. And of note here, we're creating a metadata v3 instruction. So we're just passing in all the required values and addresses that we need to actually create this account. We have the metadata account that we just derive that PDA value, the mint of our key pair, the mint authority, payer update authority, which in this case we're just setting the payer address as the authority for everything, just for simplicity. And then we're going to actually provide the data that we're going to store in our metadata.
00:36:41.275 - 00:37:28.727, Speaker A: In this case, we're storing our name, our symbol and some seller fee basis points, which is like a royalty. We're setting all that to zero, just to set null values for everything, for simplicity. And then now that we've built all three of these instructions, we can bundle those instructions into a single transaction just using this helper function built that's within this repo. And we're going to. It's basically doing the exact same thing that we discussed earlier, is that it's getting that recent block hash, putting it inside a version transaction, and it's allowing us to sign with all the applicable addresses that we need. In this case, we need to sign with our payer because the payer is paying for the fees in our case. And then the mint key pair, because that's that randomly generated key pair that, because we're allocating that account on, on chain, it also needs to sign the transaction.
00:37:28.727 - 00:38:14.591, Speaker A: So we take those three instructions, we put them in a single transaction, we sign them, and then we send them to the blockchain, and then we're going to mint them, and then we're going to log out the information into our console. So let's go ahead and run that script now. So now that the transaction has successfully completed and that script has completed, you can see these various addresses that we logged out. We have the NIC address of our payer, we have our test wallet, that's the same test wallet we used before. We have a new randomly generated mint address, we have the metadata PDA that we derived, and then we have our transaction that was successfully sent to the blockchain. So we can go ahead and open this. On the Solana Explorer, you can see the standard information that we've gone through before.
00:38:14.591 - 00:38:43.829, Speaker A: But now you can see that we have additional accounts that are also included within this transaction. We have our payer, we have this additional signer in this case, this is our mint. We have this additional account here. We have system program, token, program and token metadata. And this account is our metadata account. And then you can look through the various instructions and kind of look at the data that's been passed along. You can see with our token metadata instruction that it has all the accounts passed in.
00:38:43.829 - 00:39:37.913, Speaker A: And then we also have instruction data which you can see the raw bytes that were actually, well, they're hexadecimal encoded bytes, but you can see the bytes that were actually passed within this instruction. So those are all just going to be logged out into the console or into the Explorer because all that data is on chain. And then you can see the program instruction logs as they executed. So now if we go back to our slide here, where we've done the first three steps of our instructions that we're talking about here, but we haven't actually minted tokens to our associated token account or even created our associated token account yet. So that's the next thing we'll go through. And you can, like I said before, you can do all of these things in a single transaction if you want to. But more commonly, you're going to be minting, if you're minting SPL tokens, you're going to be minting them as multiple transactions or they're going to be manipulated in multiple transactions.
00:39:37.913 - 00:40:07.533, Speaker A: So I have it set up in this particular repo for demonstration of doing it as two different transactions. And this will actually make it so we can mint multiple times just by running our mint script. So we'll go ahead and open script number four, mint tokens. And we're doing very similar things here. We're loading in those imports. Again, we're logging out our payer address. In this case, I'm actually loading in some additional keys, just files loaded from a local JSON file.
00:40:07.533 - 00:40:42.651, Speaker A: I can actually open it here. And that's in this case. We're just loading this token mint just to have that value, because you do need the token mint address every time you're going to mint new tokens to a mint. So we're just getting that and typing it to a public key correctly. But now that we have our token mint address, and again, you can do this all in the same script, all in the same instructions. But we need to get or create an associated token account. Like we mentioned before in the slides, the associated token account is actually the account that's going to have ownership over the tokens that you minted.
00:40:42.651 - 00:41:42.643, Speaker A: That then that associated token account, the ATA is then owned by the user, so the user owns the ATA and the ATA references back to your tokens. So we're going to get or create our associate token account. And this is just a helper function that's actually included within the SPLToken SDK. And basically it's going to use a PDA like we talked about earlier. It's going to derive a PDA address and then it's going to check if that account has already been allocated on chain and if it hasn't, it's going to create that account. So it just kind of makes it a little bit more convenient for us so we don't have to write that same boilerplate over and over and over. So that's all we're doing here is we're going to get or create our associate token account from that is we can hover over here that's owned by the payer, or we're going to set the payer for the transaction and the mint of our ATA that we're trying to get and then the actual owner of that transaction or of that associated token account.
00:41:42.643 - 00:42:08.965, Speaker A: So in this case, this is the owner of your tokens. You can think of it like that. And then that can be, but doesn't have to be a different value than the payer. In this case, the payer just happens to be both. But if you as a developer, you wanted to create tokens and airdrop them to people, you can pay for those transactions. You can pay to allocate that space on chain, or you can have the users pay for it, depending on your use case. So that's all we're doing here.
00:42:08.965 - 00:42:55.743, Speaker A: We're getting this public key value of our token account and then we're going to log out that value just for demonstration and then we can actually go through the process to mint tokens from our mint into our associate token account. And this is where the decimals are really going to come in. And you can see here in this script there's some comments here that kind of explain what the decimals are used for. But basically when you are minting tokens under the Spltoken program, the decimals do matter quite a bit. So if you have, if you remember back, we created our token mint with decimals of 2. So we have two decimal places. And if we are going to request to mint some amount of tokens, say 1,000 tokens, well, this also needs to take into account we want to mint enough tokens with two decimal places.
00:42:55.743 - 00:43:26.185, Speaker A: So if you have decimal places of 2 and you're minting 1000, you're going to mint 10.00 tokens or 10 tokens. Same thing is also true. If you're minting 10,000 with decimals of 2, you're going to mint 100 tokens. So just something to note there, something to keep in mind. And now we can actually go through using this helper function that's again provided by the SPL token program SDK, and we can just mint tokens to our associated token account. So we're passing in all the applicable variables.
00:43:26.185 - 00:44:14.955, Speaker A: We need whoever's paying for the transaction, the mint of the tokens, we're going to actually mint the ATA that we're going to send the owner of the transaction and the number of tokens that we're actually going to mint. And then we're just going to log out the signature to an Explorer URL to the console. So let's go ahead and run this script now. So we'll mint some tokens to our associate token account. And you can see here in real time. It did take a little bit of time to actually get our associate token account because we actually just created that on chain. So if we were to run this script again, it would go a little bit faster because you just need to derive it, which is the derivation is actually off chain because it's all the same cryptography under the hood.
00:44:14.955 - 00:44:59.109, Speaker A: But we can go ahead and open our Explore URL here and we can scroll down and see we now have token balances where we just minted 10 tokens to this token. And if you look up here, our tokens mint is this W9HN. And you can see this is the token that we created and then minted tokens to it. You can see here we have our current supply of 10, because we've only minted 10 tokens so far. We have decimals of 2, the Mint Authority and freeze authority, just like we talked about earlier. So now we can go ahead and run the script again, mint an additional 10 tokens because we haven't changed any values. And you can see that getting this PDA address was a lot faster because we didn't need to actually create it.
00:44:59.109 - 00:45:30.233, Speaker A: So now we can open this Explorer URL. It's going to look Very similar to what we saw before. Same thing, same addresses. Because we are minting the same address. We've now minted an additional 10 tokens, but now we have a post balance of 10. So we can open this back up, we can close this other one and you can see now our current supply is 20 tokens, still a decimals of 2 because we haven't changed our decimals and we have an additional transaction that has occurred. So super cool there.
00:45:30.233 - 00:46:06.409, Speaker A: So the next thing I want to talk about is that you can actually update your token metadata. As long as your token's not frozen, your metadata is not frozen, you can actually update the metadata. So you can see here, this particular token we created is named seven SEAS Gold. And if you scroll down on the Explorer, you can go to the metadata tab and you can see the different bits of metadata that's actually stored with this token that we created. So we have seven SEAS Gold, gold is the symbol and this JSON uri. But because our token's not frozen, we can actually go through and we can update all this metadata if we really want to. So we'll go ahead and quickly demonstrate that.
00:46:06.409 - 00:46:36.609, Speaker A: So if you open up script number five, you can see the same stuff as before. We're loading in our token mint and our payer address and then we're actually creating some new token metadata information. So we're going to change the name, the symbol, and I think our URL is going to stay the same. Yeah, this URI is also going to change. You can see it's called new JSON instead of info JSON. So we're going to change all of those values and we'll be able to see that reflected on chain immediately, which is really cool. So we're going to go through the process.
00:46:36.609 - 00:47:19.517, Speaker A: We're going to derive our PDA for our metadata account, just like we did before. We're taking a static value, a static string of metadata, our metadata program address token mint, and it's owned by the metadata program. We're going to log that metadata account address out and we are going to create an update instruction. This is a update metadata v2 instruction. And we're passing in all that information to this instruction builder helper function. And then we're going to take that instruction, we're going to build a transaction, we're going to sign it with the payer in this case, because the payer is going to pay for the transaction fees. But also the payer is the authority of our particular token.
00:47:19.517 - 00:48:00.995, Speaker A: If your authority was a different address, a Different account. That account would also need to sign the transaction, but because they are the same. For this demonstration, I only have a single payer on this. But we're going to build that transaction, we're going to send it to the blockchain, and we're going to do some simple error handling. So let's go ahead and run script number five. So you can see that once the script executes successfully, we can see a transaction Explorer URL. So we can open it up on Explorer and you can see, you know, standard stuff, transaction executed successfully, see the tokens, the accounts that we actually interacted with, our instructions that we executed.
00:48:00.995 - 00:48:32.653, Speaker A: And you can see all these bytes that we have submitted within our instruction. And we can open our token mint because we updated our token mint metadata. We can open this again on the Explorer and we can see now it's been updated. So we can go back to this same address we had here. You can see it in the URL bar, this W9HN W9HN. And we can go to the metadata tab. And you can see that all of our metadata has now been updated.
00:48:32.653 - 00:49:08.421, Speaker A: Well, these specific fields that we actually did update, but we updated the metadata directly on chat chain. Really cool stuff. So now we can go back to our slideshow here and you can see that we've now successfully completed all of these four bullet points here. And we did it as two different transactions. Well, really three different transactions for the demonstration. But you can all do it as one single transaction to create a complete new SPL token, allocate the space on chain for it, initialize that mint, create the associated token account and Mint tokens to that ata. So some key takeaways.
00:49:08.421 - 00:50:00.511, Speaker A: Just to summarize all the bit about SPL tokens is that you do not need to deploy a new program in order to create new tokens on the Solana blockchain, which is really convenient. You can create new tokens using only one single transaction, one single RPC call. And all the related accounts are used to describe those tokens. Like you have your mint, you have your associated token account, you have the metadata account, you have all these different accounts that interact in this composable manner. And that's really one of the strong, powerful points about Solana. So just to summarize again, the overview of minting new SPL tokens on Solana is that you create a new account and you initialize that account as a token mint. Then you can create the metadata account for that mint, which is going to store that random or that specific Metadata like your name, your symbol, your JSON, uri, that sort of thing.
00:50:00.511 - 00:50:45.415, Speaker A: And a wallet will then own an associated token account which then will have some balance of your particular token, which has a direct relationship between the wallet owner, the associated token account owner, and then your mint. And we've already gone through the process of demonstrating the code on how to actually create mint and Mint tokens. So now that we've talked about SPL tokens, let's talk about NFTs. And realistically, NFTs are SPL tokens actually. So on the Solana blockchain, every single NFT is actually an SPL token. They have some specific unique properties that enable them to be NFTs, like non fungible tokens. That's what NFT stands for.
00:50:45.415 - 00:51:13.220, Speaker A: And some of those properties are that the specific decimal places for each mint is zero decimal places. Because you just want one. You want non fungible. And they have exactly a supply of one. And they can actually have highly customizable metadata with them. You can have multiple images, you can have all sorts of attributes and things like that. And you might be used to some of this type of information displayed on your favorite marketplaces of NFTs.
00:51:13.220 - 00:52:00.415, Speaker A: So there's two pieces of information you also have with NFTs is that you have what's called a Master Edition and a collection. And in fact, each of these are basically just accounts that are also stored on chain. But a collection is actually just another nft. So it's an NFT grouping that actually just has a relationship to all the NFTs within a collection. And the Master Edition is just used to. The Master Edition account is just used to store some specific metadata information. We're not going to go super in depth into the Master Edition concept and everything that goes into that, but we'll talk a little bit about collections once we go through the process of actually creating an NFT collection and creating NFTs, which we'll do right now.
00:52:00.415 - 00:52:30.581, Speaker A: So let's go ahead and actually mint some NFTs on the Solana blockchain. So we're going to go ahead and Open Script number six, which is called Create NFTs. I'll clean up my VS code here. So we'll go ahead and open up script number six, create NFTs. And we're doing this very similar things that we've demonstrated all along. You're probably detecting this pattern of you're going to do the exact same thing for a lot of your scripts and a lot of your code. You're going to have all your imports, you're going to get your keys that you need.
00:52:30.581 - 00:53:25.433, Speaker A: Whatever way you're going to get those keys, it's going to change depending on the application that you're building. But for NFTs, we're going to create some metadata, we're going to mint this image here, and we just have a NFT storage link here with basically just a decentralized storage provider using the IPFS network. And we're going to give it a name, a symbol and description. And we can open this image too, just to show what it looks like. It's this cool gradient pirate ship looking image. So we're going to actually mint this particular NFT on the Solana blockchain. Now, in this case, instead of manually building all the instructions that you need in order to handle all of the actions, the instructions and the transaction, you need to mint NFTs, we're actually going to use the Metaplex SDK.
00:53:25.433 - 00:54:40.995, Speaker A: And the Metaplex SDK is an open source SDK provided by the Metaplex foundation and it gives a lot of helper functions that you can use to actually create NFTs and and work with NFTs on the Solana blockchain. So we are going to create a new Metaplex instance, provided our connection, we're going to give it our key pair, which is our payer, since this is going to be the payer address that we're going to use to sign all these transactions. And then because we're also going to use it to upload our metadata to ipfs using the Bundler network and ipfs, we're actually providing some information here and basically because we're on devnet, we have to provide this additional information. If you're on mainnet and you're trying to do this, you don't need any of these configuration values. But the first thing we're going to do is we're going to use the Metaplex SDK. We're going to upload this metadata, which is just a JavaScript object, and it's going to upload this object as JSON to the IPFS network decentralized file storage and we're just going to log out that URI to the console so that way we can see what it looks like. But then we're going to use that URI and our name and our symbol and we're going to mint our first nft.
00:54:40.995 - 00:55:14.927, Speaker A: And again, we're using the Metaplex SDK so it makes it super, super easy to actually mint NFTs. We're going to use the Metaplex NFTs create pretty self explanatory what it's doing there. And we're providing in all of our sort of metadata that we want. We're going to give it our image, our metadata URL which links back to our image. We're going to give it the name and our symbol and we're setting seller fee basis points. And these are basically the royalties that you would see on various marketplaces. Now to note that these are royalties requested.
00:55:14.927 - 00:56:00.585, Speaker A: You can kind of think of it like that. Unless the particular NFT collection is set up in a certain way, it's basically saying you as the creator are requesting in this case 5%, 500 basis points or BIPs for short. You're requesting a 5% royalty on all sales and they'll be paid back to your royalty address that you set up. In our particular nft. We're going to set it as immutable, so that way we can actually mutate and update the metadata for our NFT if we want, which we're not going to cover in this demonstration, but you'll have that functionality. And then we're just going to log out the NFT object that gets returned from the Metaplex SDK and we're going to send or we're going to log out our signature so we can actually view that transaction on the Explorer. So let's go ahead and run this script.
00:56:00.585 - 00:56:46.645, Speaker A: So we'll go ahead and scroll back to the top here and we'll talk about what happened is that we logged out our token mint because we're just using our same mint that we had earlier. We're the same Explorer URL there. And you can see here we have this URL on Arweave because we're actually using. I think I misspoke earlier, we're using Arweave to actually upload using Bundler. That bundler is using Arweave, the Arweave network, which is again a different decentralized file storage. We can actually open this Arweave address and you can see that we have our exact object that we had uploaded. But then we have this large data object here and this is the NFT data object that gets returned from the Metaplex SDK.
00:56:46.645 - 00:57:28.895, Speaker A: And you can see all the various addresses and data that we actually set. When we created our NFT using Metaplex, we have our update authority. In this case it's just the payer that I had set. I didn't specify an update authority, but because it was the payer, that's what it defaults to. You can see all of our JSON that we had uploaded using the Bundler network and uploading to Arweave. And then you can see the other assorted metadata that we have with our nft. We had set a seller fee basis points, and since we had not set a specific creator, it automatically detects that as the payer, and then sets the payer as that creator.
00:57:28.895 - 00:58:07.301, Speaker A: And then you can see some other associated information about our particular nft. You can see the Mint and our Mint Authority, Freeze authority, decimals of zero, just like we talked about earlier. And just the sort of information about our token, the NFT Edition, which we're not going to talk much about here. But if you're Interested more about NFTs, you can go read through the Metaplex docs@docs.metaplex.com and read all about NFT additions and things. But we can go ahead and open our transaction on the Blockchain Explorer and we'll see what it looks like. So once it loads up, you can see we just minted this one.
00:58:07.301 - 00:58:46.275, Speaker A: And you can see this is a far more complex transaction that we than we had previously built up until this point. You can see a list of 12 different accounts that were included within this transaction. You have a couple of different accounts that are all writable, some that have no write or sign or fee pay or anything like that. And that's just because those are read accounts. And you have our program that's actually executing this transaction, in this case token metadata program. And you can see a token balance. We have this token of HZD7 and we changed it by one token because that is the actual NFT that we just minted.
00:58:46.275 - 00:59:17.055, Speaker A: You can see all the metadata that we set within our nft. We have our name, our symbol and our image. And you can also look at the creator. You can see that was the creator address that the Metaplex SDK had set for us. And then if you're interested, you can kind of look through the various instructions that were actually executed. So if you wanted to kind of deconstruct this and maybe handle it yourself manually, you can absolutely do that. Or you can look through the Metaplex SDK and actually look at the source code for the SDK since it is open source, and see how they're doing it that way.
00:59:17.055 - 00:59:41.653, Speaker A: So that's the process of actually creating NFTs on the Solana blockchain. It's pretty straightforward. Super cool. So just to summarize, some key takeaways is that NFTs are SPL tokens under the hood, but they have those unique properties. They have zero decimal places and they have a supply of exactly one. And they all have assorted metadata associated with them. And that metadata is highly customizable.
00:59:41.653 - 01:00:21.527, Speaker A: There's a lot of information that you can put inside of an NFT's metadata. And again, if you're interested, you can read up on those on the Metaplex docs. So that's it for the explicit code walkthroughs. But I'll quickly talk about the account structure and some of the data structures that we had just discussed and just discovered just more explicitly. So if you think back to our SPL tokens, we had our Mint account that we created, and you can see we have some number of decimals, and you can see the math calculation there. You have the isinitialized, the supply mint authority, freeze authority, and those are all the values that we had set on our Mint when we actually created it. And then with NFTs, you have decimals of zero.
01:00:21.527 - 01:01:37.769, Speaker A: And then because they're effectively the same thing under the hood, it's just which particular addresses and specific metadata you are associating with those particular SPL tokens. And then when you think back to your associated token accounts is that we are deriving an associated token account address. That's, that's what that is. It's an, the ATA is a PDA and we're using that program derived address with the seeds of our user's wallet, the token program and the Mint address, and that's all owned by the associated token program. And it basically those are just storing a bit of data which just effectively has a balance, that's all it is. And then once if you think back to our metadata account that we had created for our NFT or for our SPL token in general, very similar thing, we derived a PDA using the static value of metadata, the metadata program and the Mint address, and that's owned by the metadata program. And then within that data structure, you're actually storing some of that specific data on chain, specifically our title symbol and a URI value, which that URI is stored off chains.
01:01:37.769 - 01:02:35.015, Speaker A: You have to then fetch that data and that gets handled and then you have the list of creators as well. So just to summarize those key takeaways is that Mint accounts house data for a Mint for a token mint, and then the associated token account stores a user's balance and metadata can store the assorted metadata information for a particular mint. So lastly, to close out day one of this workshop and of this boot camp. The challenge is to actually create your own NFT collection with a fleet of pirate ships for the seven Seas game that you're going to learn how to build in this workshop. Mint it with, I don't know, like 32 different pirate ships, use different images, try to play around with IPFS and arweave storage and if you look through the code in this repo, there are some example links and document references for more information on those and then create an additional three SPL tokens for gold, rum and cannons. Thanks for watching and I hope you learned a lot in this video.
