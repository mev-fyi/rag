00:00:09.200 - 00:00:52.217, Speaker A: Hello and welcome to our day six of our Pirate Bootcamp tutorial. Today we're going to talk about clockwork threads, randomness and Zero copy. And then in the end we will have a little sea battle on the seven Seas program. So we will start with Turning on the wind on the seven seas. I will show you in a bit what that means. Then we will learn about clockwork threads and how you can trigger transactions automatically from in the distance on certain triggers. Then we're going to dive a bit into randomness on chain, how you can achieve randomness with different values, different functions, and how you can use switchboard Oracle to get more secure randomness as well.
00:00:52.217 - 00:01:34.765, Speaker A: Then we're going to look at big accounts, especially Zero copy with anchor. Yeah, and then we have a little sea battle. Okay, but the first thing we're gonna do is we're gonna turn on the wind on the seven seas. So in the last days you were able to get some to stake your gold and swap your gold for some cannons. So your ship should already be very well equipped now. And now if we deploy our ship here, let's pick an avatar, let's use this one and we deploy our ship. This is not on definite, so let me quickly switch to defnet.
00:01:34.765 - 00:02:16.677, Speaker A: Okay, and now let's try again. So now we have our ship deployed here. And you can also see the little NFT in here. And now what I want to show you is then when we here resume the wind, then magically suddenly all the ships on the map are moving automatically. And this is done by using a clockwork thread, which in the background every two seconds goes through all the ships on the map and moves them by one field forward in their current look direction. And yeah, now I'm gonna show you how this is done. And I can also pause the wind again.
00:02:16.677 - 00:02:59.835, Speaker A: So now all the ships are stopped again. And yeah, how does this work? Clockwork threads. So how clockwork works is you create a thread and this thread will call a certain instruction on your program over and over again, depending on certain triggers. And klocwork does it like this. They have a worker network which listens for these triggers. And whenever the trigger time is due, then it calls the like one of the workers calls your transaction and the fees are taken from the thread. So every instruction actually costs you 1,000 lempards.
00:02:59.835 - 00:03:49.293, Speaker A: And these are the different ways how you can trigger the threads. For example, there is a cron trigger which has this cron notation which for example, fires it every 12am noon every day. So, but I want to Quickly show you all the other triggers. For that we go to the Clockwork development documentation and we can hopefully open this here and here we can now look at the different triggers. We go on threads and then we go on triggers and here we can see the different triggers. So you can trigger an instruction when a certain account changes. You can use a CRON notation.
00:03:49.293 - 00:04:40.431, Speaker A: That's the thing we saw earlier with the. Yeah, the CRON notation. So here you can see, for example, if you do 0, 0, 12, then it does it at 2pm every day, 01510 does it at 10:15 every day. And there's all kinds of these things. And then there's also now, if you want to immediately have a worker which triggers your transaction, then you can have it on a certain slot or on a certain epoch or on a certain timestamp. And you can also now, which is new, use the pith Oracle and then listen, for example, for certain price changes. So you can say as soon as whatever token reaches a certain price, then you want to buy it or something like this.
00:04:40.431 - 00:05:11.489, Speaker A: Or you can also use it for example, for staking. Like you can say, hey, I put my NFT in a contract and then I want automatically to give the staker some token after a certain time automatically, so he doesn't need to do anything and he directly gets them into his wallet. Which is quite nice functionality. Yeah. Then let's see, as I said, epoch, timestamp, pith here, a few of the use cases. Klocwork did a bunch of examples already. So there's the hello, klocwork example.
00:05:11.489 - 00:05:46.825, Speaker A: Then there's the counter example which just counts up a value. Then you can use it for reoccurring payments. For example, for token distribution you can do dollar cost averaging. Like I already said, you can listen to certain prices and then just buy or sell. Then you can have a Serum crank and you can also use it for subscriptions. Like say you have a game and you want to transfer some of his tokens every month to your treasury, then you could also do that. And yeah, they would pay on a recurring schedule.
00:05:46.825 - 00:06:35.709, Speaker A: But I think the easiest way to learn about how this works is that we just build a little example and I prepared a little game. It's an idle game and you can find it here under Solana Developers, Solana Game Starter Kits. And then I would ask you to open the Idle Game folder in Visual Studio. And then you go into the program, you install the NPM packages, you build anchor and you test. So that would be the first test if the anchor program is working and then we would go into CD app, install the packages there as well. I think I use yarn actually usually, but this should also work. So I will now also do this.
00:06:35.709 - 00:07:06.813, Speaker A: Like I opened example the Idle game and yeah, I started it already. But what I do is I just do yarn dev. Then you can click this link and this will open the game. This is some weird wallet adapter error that's currently popping up. You don't need to take to care about that one. Okay, so now we are in the game. Now what we can do, we can do some airdrop since we are on Devnet and we can initialize the game.
00:07:06.813 - 00:07:47.945, Speaker A: So here we pay for the game account, we approve this. And now we can see here that there's already a thread running which gives us one wood every 10 seconds. See now I have one wood. And then there's a few more functions here which is like upgrade teeth, buy a new lumberjack and trade wood for gold. So if we buy another lumberjack then we would get two wood per every 10 seconds. And if we upgrade the teeth, since it's a beaver, of course he makes better teeth. So then the wood that you are selling would give you some more gold.
00:07:47.945 - 00:08:22.597, Speaker A: And we can also stop the threat here. Okay, now we'll go through the code with you and explain you a little bit how this works. So this is the game data account. This is where the whole game lives. Basically for every player we have an authority. We have wood, we have lumberjacks, we have gold, we have the teeth upgrades and we have the last time it was updated. This is important because we want to show in the client the time until the next tick of the thread will be.
00:08:22.597 - 00:08:54.484, Speaker A: So we need to save the time when it was last updated. And then in the client we can just calculate the current time minus the updated time. And then we know exactly how much time we need to show until the next update. Because of course the program doesn't update every second or something, but only every 10 seconds when the tick is called from the thread. Then here we have some error codes. Here we have some constants. The wood that we need to sell and we need at least 10 wood to sell.
00:08:54.484 - 00:09:19.585, Speaker A: The gold that we get per wood is like five. And then the gold we need to upgrade the teeth multiplier and how much it costs to binary lumber deck. And then here we have the thread tick time in seconds. So that's the first part of our thread that we need. So it's just a string. 10 seconds will be part of the cron notation. Then here we have a PDA which is the thread authority and we have the seed for the game data.
00:09:19.585 - 00:09:50.359, Speaker A: So and now here when we initialize, we are creating this thread. So what we do first is we create the game data. This is a normal PDA like you learned on day two, for example, here would be the player position of the little player moving back and forth. So here we just initialize it. We set the authority, the lumberjacks to one and the teeth upgrades to one. And we set the updated at time to the current UNIX timestamp. So that one you can get from clock and then the UNIX timestamp.
00:09:50.359 - 00:10:41.215, Speaker A: And yeah, you need to make sure that in the client you're also always using the Solana blockchain time if you want to calculate times, because you can't just use UDC because the time might be off. Yeah, this is how you import the klocwork SDK and how you import it. And this is how you add the klocwork SDK to your dependencies. So here we are now creating the instruction that the thread should trigger. So what we do is we take the thread tick accounts. This one is just the game data account with the seed, same as in the Tiny Adventure tutorial. Then we have the thread which has a constraint that the threat authority is equal to the threat authority key to this one here.
00:10:41.215 - 00:11:27.477, Speaker A: And the threat authority is just the static seed and the game data authority. So what this means is that every player who plays the game has its own thread and he is also the authority of this thread. So he can stop it started, pause it, whatever he wants. Now back to our initialize function. So here we have the accounts and here we have now the instruction that will be called. So the worker network will do a CPI into our program and we'll call this function here. And in this function on thread tick, which will be called every 10 seconds we get the game data and then we just add to the wood the amount of lumberjacks.
00:11:27.477 - 00:11:52.243, Speaker A: So if you have one, then you get one extra wood. If you have two, you get two extra wood. Then we set the updated at time in the gamedata account and that's already it. So that's the only thing that happens every 10 seconds. And now we have the instruction ready that we want to call. So next thing we're going to do is the trigger. I told you already that it's a bunch of different triggers and this one will be a cron trigger.
00:11:52.243 - 00:12:31.709, Speaker A: So all we do here is like this little asterisk and then we pass in the thread, tick time in seconds at the position where the seconds are, which is here. And then we say it's also skippable, so in case the player wants to stop its thread. Because they are also kind of expensive. Like if you run it every 10 seconds it will cost thousand lamphertz and as you know, like 1 million instruction cost around five solutions. So you need to take care that yeah, it costs a bit of money. That's just something you have to keep in mind. So for an idle game, if it calls every second or every tenth of a second, that's also quite expensive.
00:12:31.709 - 00:13:15.199, Speaker A: So then the next thing is here we call, we do a CPI to the clockwork SDK to the clockwork program to create the thread. And for that we create a new context. We put in the clockwork program the the same as we did for the tokens and for the soil transfer in the tiny adventure. Then here we have the accounts for the thread create. It's the payer, the system program because it needs to create a new account, the thread and the authority. And then here we have the seeds which are the signer, so thread authority seeds and the payer key bytes. And then here we have the amount of lampards that we want to put into the thread.
00:13:15.199 - 00:13:48.635, Speaker A: So in this case we want to put 0.1 SOL we put the thread ID and then we put the instructions, which is this one. So you can also call multiple instructions, but I think you pay 1000 lampards per instruction. So you can't cheat the system by just putting as many instructions in there as possible and trigger. So yeah, that's, yeah, that is already it. It's actually quite, quite straightforward. It's very easier than for example, doing the randomness which we're going to do later.
00:13:48.635 - 00:14:37.265, Speaker A: So yeah, and this offers you a bunch of possibilities. And now we already have 40 wood here. So what we can do now is we can trade some wood for gold. So and if we have 21, 25 gold, then we can buy another lumberjack. And now we have two lumberjacks and now we get two votes every five seconds. So, and now I want to quickly show you how the same thing is done in the seven SEAS program. So for that I'm going to open the seven C's program and here you can see that I should update Visual Studio and that we have a start thread, a pause thread and the resume thread instruction here.
00:14:37.265 - 00:15:00.697, Speaker A: And the starch thread instruction does basically the same as we saw in the idle game. So it creates an instruction Thread tick accounts. It has a cron trigger. This one is a bit different. It's called every two seconds, not every 10 seconds. And then we have the thread authority. Again, just in this case, it's not the player who owns the thread, but it's the program.
00:15:00.697 - 00:15:33.635, Speaker A: So it's actually only a string in this case case. And I put two SOL in here because I don't want the thread to run out that quickly. And then in this instruction, let's go in there. On thread tick we call on the move on the game, we call move in direction by thread. And in this function we find the players on the board. So we find all alive players, put them, push them in a vector, then we go over all alive players. So where the state is player.
00:15:33.635 - 00:16:24.331, Speaker A: And then we find the direction they're currently looking at and then we are checking if the new board state is empty. And then we move the player there and set the other state of the tile where he was before to empty. Yeah. So there is also the possibility to have dynamic threads, which Nick explained in the. In the talk at the bootcamp. I haven't tried that out yet, but there is definitely the possibility to have dynamic threats because what I did here is I did it like this, that as soon as the player reaches another ship or another chest, then he would stop because I don't have the accounts for the token account. If the player would want to collect gold from a chest, then we would need to have his token account.
00:16:24.331 - 00:16:55.275, Speaker A: So we would have to pass dynamic data into the thread. But there is the possibility. So you can research that in the klocwork documentation and also the Clockwork discord or ask on Stack Exchange or so on if you need this functionality. And yeah, so currently it would be nice if the ships like drive around on the map and automatically collect gold whenever a new chest spawns and so on. So if someone wants to take this over, it would be a nice challenge for the afternoon, actually. Like a. A little homework.
00:16:55.275 - 00:17:26.449, Speaker A: Okay, but let's go further to the next topic, I would say. So this was the. This was everything about Clockwork and if there are any questions you can just post them below the video and we will try to answer them later. So now let's talk about randomness. Randomness on Chain is very important, especially for games. Of course, especially for gambling games like for example, if you have a coin flip or you want to build a roulette or poker or any card game where you want to shuffle cards or whatever. So.
00:17:26.449 - 00:18:30.741, Speaker A: But it's also a little bit of a complicated system because everything on chain is public. And yeah, you don't want people to see the data and like create the transactions so that they circumvent the randomness and like trigger it exactly at the slot where the coin flip would win, for example, or the roulette would go to 30. So there are a bunch of ways how you can do this. The first one is Xor Shift. So this is just a mathematical function where you put in a value basically as a seed, like as you know, in normal random functions, and then there's some magic bit shift stuff happening with it, and then you get a new random value out of it and then you can call it again and then you get the next random value. So this is very good, especially for games and on chain programs because it's very cheap. Like you see, there's very little instructions here.
00:18:30.741 - 00:19:14.655, Speaker A: It's very easy to implement. So I'm going to show you later how it's done in Seven Seas. In Seven Seas, it's used for the spawning of a new ship. So it's finding the new ship position and for the damage that the big Cthulhu does when he attacks someone. Yeah, so the problem with this is that it's not fitting to all statistically randomness tests. So you can read about more about this on the Wikipedia article or there's also some papers about it. And this is for example, also used in JavaScript 8 in Chrome it's using the XOR Shift 1024.
00:19:14.655 - 00:19:47.255, Speaker A: And yeah, there are a bunch of different implementations of these. So you can make it a little bit statistically more statistically a little bit better. I will show you later, but first let's look at the usage, how it's done and used in Seven Seas for the Cthulhu damage. So here we are using the. We are creating a new Xor Shift. Then we have the base Cthulhu damage, which is 10. Then we get 30% of the Cthulhu damage, which would be 3 in this case.
00:19:47.255 - 00:20:34.845, Speaker A: Then we take the Cthulhu damage and we add randomness modulo the damage variant plus one. So this would mean like whenever Cthulhu shoots, he does 10 damage plus one to three damage. Yeah, and the nice thing about this is that this is also predictable. So whenever I run my tests and I put in the same seed, then it will always also give exactly the same result. So for games and tests, this is like very convenient. You might also have noticed in the game, like whenever you spawn a ship and there are like two ships on the board, Then the next ship will always spawn in the same position. This is because for the spawning of the ships we are using the amount of items on the board as a seat.
00:20:34.845 - 00:21:31.555, Speaker A: So like this is very predictable. So you can very easily write tests. For example, I spawn a ship, then I move three fails down, spawn the next ship and I can shoot directly at it. So this is a little bit more statistically safe implementation of the XOR shift. What it does is it has a bit of different values and then it multiplies the U64 by U128 and then it cuts off the unnecessary bits again. So this beats a few more of the statistics tests, but also has a little bit more compute and needs a little bit more memory. Then another nice thing that you can do is you can combine the randomness with the current block hash or with the current slot of the blockchain and like this you will have a pretty nice random value which is not related to a fixed value.
00:21:31.555 - 00:22:15.269, Speaker A: So then you basically get the, you just pass in the slot, current slot as the seed for the randomness and then you do the same thing modulo max, the max value that you want. And yeah, you can also do this by instead of the slot, you can use the current block hash and just take the first few bytes, for example, and use them as a seed. That's also already pretty random. Then what you can also do is you can use the hashing function. Hashing functions are very random. So use the slot, then you create a hash from the slot and then you take the first few bytes of it. I think here we're taking the first eight bytes and then you convert them into U64.
00:22:15.269 - 00:23:08.997, Speaker A: And this is also pretty random. But yeah, we will talk a little bit about security now because they are random, but they are not 100% secure. So what this means is a malicious validator could come in and change the block by putting in more like he could like fill up the block in a certain way so that the block hash would have a certain structure. And then like this, he could theoretically attack your randomness value. And while this is very unlikely that this is being exploited, it happened before. So for example, the Trashpanda mint was botted because people exactly sniped all the legendary ones. And there's also the code roulette which was exploited.
00:23:08.997 - 00:23:55.655, Speaker A: I added a few links here that you can look at. So yeah, they predicted which will be the next random value and then they got it. So as soon as there's much of money involved, you should not rely strictly on the block cash or the current slot. But there's also a solution to this, a partial solution, which is using an Oracle. And there is for example, the Oracle from Switchboard, which will be the one that we'll be looking at today. And how it works is that you ask an Oracle for a random value and then the Oracle will give you this random value and then you use it in your program. But as you can already see, this is like a two step process, so it makes it more complicated.
00:23:55.655 - 00:24:37.223, Speaker A: As you can see here, there exists a collusion vector. So this is still not 100% safe, sadly, because if the malicious validator would work together with all the Switchboard Oracle providers, then they could still theoretically break this. But it's way more secure already than only relying on the block hash. And how it works is you request randomness from, in this case Switchboard or any other Oracle. Then they do a CPI into your program. So you need to save the state that you want to interact with in your program. Then you get the CPI from outside, then you consume the randomness.
00:24:37.223 - 00:25:11.953, Speaker A: And using a Switchboard Oracle also costs 0.002 Sol per random value. So there are a few other hacks and workarounds that you can do by just using another Oracle. You could just use the get the current Sol price from Pith, for example, and use that one somehow for your randomness. But you definitely need to research enough. If you have lots of money that is dependent on this random value, then you should be very careful. So, but we gonna today look at the implementation of Switchboard and I added a few resources here.
00:25:11.953 - 00:25:40.395, Speaker A: Here's implementation of Rust program which implements a bunch of different randomness functions that you can just copy, paste or test out. Then we have the coin flip example here. That's the thing we're gonna build in a bit. Then we have XOR Shift explained on Wikipedia. We have an article about Switchboard randomness which is quite interesting. Then we have another playground tutorial that you could just run through. It's called Boss Battles.
00:25:40.395 - 00:26:21.225, Speaker A: It's you're attacking a boss and whenever you do damage, it's a random damage. But today let's look at the Switchboard implementation for this, please. You already checked out the game starter kits, so this time we're gonna open the coin flip example. I again started with yarndev in the app folder, so CD app and then yarndev. Then we have this nice little game here. So there's again this weird Ethereum error from the Wallet Wallet adapter. Right now let's log in.
00:26:21.225 - 00:26:46.295, Speaker A: Should Be connecting but it's not. Now it is. Okay, now we initialize our player and now we can see that there's a vault balance of 12 and a player balance of 07. So now we do tails. Then we have a nice little animation. This is like waiting for the randomness now. And here we can see.
00:26:46.295 - 00:27:12.275, Speaker A: Yeah, we lost. So we got oh wait, I won. But the player balance is still less. So I guess the looks like the text is the wrong way around because the balance in the world went up and the player balance went down. But yeah, we are anyway here not for gambling. We are here to look at, to learn about randomness. So let's look at this code a bit.
00:27:12.275 - 00:27:42.159, Speaker A: We're going to look at the librs file here. We can see how you implement it like you get it from the switchboard SDK in the Kaggle terminal. You can also see switchboard V2. We are currently using the 0.123 version. And now let's look at it. So when we initialize the game, first thing is we start a bump and we start a VRF switchboard key and we save the max result.
00:27:42.159 - 00:28:15.653, Speaker A: In our case it's two. So if you want to have another game which is like goes from 1 to 10, a 10 sided dice roll gambling then you could set this to 10 for example. Or if you have a card game one to 52, pick a card and then you win. Then you would set it to 52. So now we request randomness. The first thing we do here is we transfer 0.1 SOL into a PDA which is this solvault and then we set the state to what the player guessed.
00:28:15.653 - 00:28:48.747, Speaker A: So 1 or 0 or 1 depending of coins or like heads or coins heads or tails. The result we set to zero. And now we do this very big randomness request here. Let's go through the most important accounts. But they are all, they're all described here what they do actually. So we have the Oracle queue, we have the VRF account where the new randomness result will be stored. So they put it into this account.
00:28:48.747 - 00:29:30.519, Speaker A: Then they do an CPI into the program and then in this account you will find the data. Then there is the authority of the VRF account of this one. So like only this account will be able to get the randomness out of this account. Then we have the Oracle queue. This is the queue which provides the random values. And then we have the queue authority. We have the data buffer account, we have the permissions, we have an escrow account which is funded by repsol from the player to pay for the fees.
00:29:30.519 - 00:30:00.401, Speaker A: The 0.002 SOL and we have the player wallet, the player authority and then the standard stuff. Recent blockage. This is the program state from our game and we need the token program because it's interacting with wrapped sol. And as you can already see this is quite complicated. So if you have like a very simple use case for your program, then better use an XOR thing and use the block hash. But if there's money involved then you should probably use something like this.
00:30:00.401 - 00:30:49.315, Speaker A: And I also yesterday I talked with Clockwork and they are also thinking about implementing a little bit easier random function using their worker network. So or if you want to work on something like this, this is something that's like very would be very good to have like a very easy way to get randomness on chain. Yeah. Then here's the player key, these are the seeds. And then we, yeah, we invoke signed this randomness function and then after a bit there will be the CPI from Switchboard which comes back into our program from outside here. Then we have the VF account. Here we find the random value and here we check if it's empty, then there is no randomness result.
00:30:49.315 - 00:31:47.505, Speaker A: I don't know, for example, if Switchbot didn't manage to get a random value, for example, I guess then we have the game state. Here we have the max result and then at some point we will cut off. Now here we will do modulo max result and this means like we have a very huge number u128 but we only need actually a little bit of the last bit. So we cut everything else off and then we check if we won, then we transfer SOL to the player and if we did not win, then we don't do that. Yeah, so this is the coin flip example. And yeah, everything in the program, all the accounts have comments and I explained and you can read more into detail and how it works and just use it in your program if need that. So these are all the randomness functions.
00:31:47.505 - 00:32:35.659, Speaker A: Let's build a coin flip game that we just did. And now it becomes interesting. Now we're going to talk about zero copy and big accounts. So for that we're going to start this Playground tutorial like I uploaded it in Playground for ease of use. You can go here on the left to the tutorials, then back to tutorials and then you can open the zero copy example. And for that we need a local validator. So we write Solana test validator to start a local validator and then In Playground, we can also connect directly to this local validator by using the endpoint local host here.
00:32:35.659 - 00:33:14.263, Speaker A: Yeah, so first we're going to run this thing and look at the tests and then I'm going to explain you what this is and what you need it for. So we just do build, then we do deploy and then we do test. Yeah, how this works, this web platform actually, like it sends your code off to a server, it builds it there and it comes back. So it's a very nice system actually. So now we deploy it. If I can manage to write it correctly, you can see it costs a little bit of soil. I have still 100 SOL left deploying it.
00:33:14.263 - 00:33:48.601, Speaker A: You can already see a little warning here that we're going to need later. It's already giving us a little warning that we might run out of stack size. So we have 4 kilobyte of stack size only. And here in the first test, error is now nicely already showing us this might fail, but you can still run and build it and it would then fail at runtime. Okay, so this is deployed now we run the tests and here you can see what's happening. So the first test is hitting the stack size limit. So let this run in the background.
00:33:48.601 - 00:34:54.440, Speaker A: For some reason it takes a while. So we have certain limits in the Solana runtime. So we have an account limit which is 10 kilobytes or 10 kilibytes actually of the size your accounts can be. Then we have 4 kilobyte stack size and we have a 32 kilobyte heap size. So in this account, this key to 10 kilobyte account limits is actually only there because there is a limit of how much memory you can allocate when you do a cross program invocation. And a cross program invocation in this case is a CPI to the system program to create an account or increase the size of an account. And since the anchor framework creates an account and it does a CPI in the background, like whenever you put init over your account in anchor, what it actually does if you look at the code behind it, is it takes the data from your account and it creates a new account with a system program, then adds the little discriminator at the front and then puts all the data that you want into this account.
00:34:54.440 - 00:35:19.715, Speaker A: The next thing we're going to go beyond the limits. Let's quickly look at this here. Yeah, so it's running. So you can see already that we ran out of. There's some error here exceeding timeouts. So that shouldn't happen of course, since I'm on a local validator. So let's run this test again.
00:35:19.715 - 00:36:02.015, Speaker A: Okay. For some reason it doesn't run currently, but what you would see is that the first test fails because it's running out of stack size that I gonna show you here. We can just open the tests and all we do in the first test is we initialize an account which is too big. So what happens here is this is the initialize hit stack size struct. It's a very fitting name because it's hitting the stack size as soon as you create it. It has 10 kilobyte of data in it or 10 kibibyte kiwibyte are the 24 bytes on top. So it's like a power of two.
00:36:02.015 - 00:37:05.199, Speaker A: And here you can see this is the hit stack size struct. So it's an option of a big struct and the big struct has four public keys and every public key has 32 kilobyte. And if you have 12 of these, then we will hit the stack size because every struct in Rust and in the Solana runtime lives on the stack by default. So to solve this problem, if you ever run into it, if you have too big of an account and you hit the stack size, then you can box your account. So you can box an account by just writing box on it. And what this means is there will only be a pointer left on the stack and it will point to the heap and then the majority of the data will be on the heap where you have much more space. And this you can do like here, where is it? Can I search here Box.
00:37:05.199 - 00:37:44.587, Speaker A: Oh yeah, here. So here you can just comment this out, comment this in and then you will see that the test will pass afterwards. So then the next test, let's see if it ran out this time. No, it's still not running, but hopefully it will run for you or otherwise. I will also put a link into the slides where you have a GitHub repository where you can run the whole thing locally so you can play around a little bit with it. But now I want to show you how you can get bigger accounts. So how you can go beyond the limit.
00:37:44.587 - 00:38:42.753, Speaker A: So you can, you can create a 10kibyte account and then directly afterwards you can call another instruction which increases the account size by another 10 kib. So how you can do this is ank has this very nice function here where you can directly use data that you pass into the instruction and you can use it in the Struct initialization here. So what this means is here we have a realloc and we use the length value that we pass into the instruction data and then we initialize them with zero. That's a bit of a security thing. You should usually use this because otherwise you have some old data in your accounts, then you realloc and the payer will be the signer. Of course, if you realloc an account, it's the same cost as usually. So for 10 kilobyte account you would always say pay around 0.07
00:38:42.753 - 00:39:11.785, Speaker A: SOL or 0.7. So let's quickly check so that I don't say something wrong. You can just say Solana rent and then 10 kilowatts. So it would be 10 0.07 SOL. So yeah, this is how you can make a bigger account. And you can see the code for this here and in the client and the test.
00:39:11.785 - 00:39:41.455, Speaker A: Let's go to the second test. This is how you would then do a realloc. So you call the methods of the program increase account data and you just put in the new size that you want. So if you make it bigger, you need to pay for it, but you can also make it smaller and then you get the soil back. So I haven't tried. If you put it to zero, maybe it just closes the account. So that's also someone could try in the afternoon maybe as a little homework, just put a zero here and see what happens to the account.
00:39:41.455 - 00:40:20.499, Speaker A: I'm not sure if it if you can do this because it wouldn't be rent exempt anymore or if you can't do it because if you can do it and we'll just close the account. So it would be interesting. So someone please try that out and write a comment in the end of the video maybe. So this is how you can get accounts up to 10 megabytes and this should be enough for everyone. And they also way more expensive than already. So but if this still isn't enough, like because if you load this account now and it has more than 10 kilobyte of data, then you would hit the heap slice. But it's only 32 kilobytes.
00:40:20.499 - 00:41:27.111, Speaker A: So if you increase this account three times like we do here in the second Test and we shove more data into it as soon as we go above 32 kilobytes, then we will get a runtime error. I would love to show you this error here. But what you would do now is you run the tests and then you copy the signature from the second test. Where you see the error and paste it into the explorer and then you would see that that the runtime is running out of memory and that you can't completely load an account that is bigger than 32 kilobyte into memory, so the runtime will crash. But what you can do, you can circumvent this by using a zero copy account. And how this works is that instead of loading the whole account into memory, you only have a pointer to a certain amount of memory and you directly interact with this memory by using memcpy operations. So here you can see, you just add this flag here, zero copy unsafe and the rep type.
00:41:27.111 - 00:42:14.435, Speaker A: In this case it's C. But there are also a bunch of different rep types that you can google. There's also packed which makes it a little bit smaller. But then you will have a bunch of problems with options and enums and so on because they are serialized differently. So this is how it's used in the seven Seas program we have a zero copy account, which is the game data account and it has a two dimensional array board of 10 by 10 tiles and an action ID which is used for the animations. And every of these tiles is also zero copy struct and it has the current player, it has the state of the tile, the health, the damage, the range, the collect reward, the avatar pub key which is the nft. So that in the game we can load the little image of the player of the pirate ship and also show it to the players.
00:42:14.435 - 00:43:04.325, Speaker A: Then we have the look direction that we use for the clockwork threats so they know in which direction they need to move the ship. We have the ship level and we have the start health of the player. This one is important because now that you have Rum token which you got yesterday, your ship might start with a different amount of health. And of course the client doesn't know beforehand which start health you have. So that's why we save the start health in this account as well. So in the client we can then directly calculate the health and the start health and we can show a nice little health bar. And yes, so this was zero copy and now we gonna build the seven Cs program.
00:43:04.325 - 00:43:50.175, Speaker A: So for that it's in the same repository you just this time in Visual Studio you open the 7C's program and for this program we have multiple clients. So there's a JavaScript client which doesn't have a lot of functionality yet and then there is the unity client which looks much more beautiful. So let's first start with the JavaScript client. So we go in CD app and we do yarn dev again. And now we have this nice little JavaScript client here. Let's close all the other stuff that we don't need anymore. There's loads of it and there's this error again.
00:43:50.175 - 00:44:47.505, Speaker A: And now we are connecting and here you can already see the first chip and I also going to run the game, maybe just open the WebCL version and then I'm going to show you that actually the same client works for both. Like they interact with the same program. So here I gonna log in now with my phantom wallet or backpack or whatever you like. Just make sure you set it to definitely. Okay, so here we can see now that we have two different representations of the game. One is in JavaScript and one is in Unity WebGL client. And you can see if I move my ship around here, you can actually see the actual representation of the grid on the left.
00:44:47.505 - 00:45:33.757, Speaker A: So you can also see that the ship is a little bit lagging behind to have a nice little animation. And when I shoot I also can't see this in the JavaScript client yet. So there's also something someone could build in the afternoon if you want to do some homework, try to make a nice little animation for the shooting of the ships. So now we're gonna go through all the features and I will quickly show you how they are implemented in the game. So then in the end you would theoretically be able to build this game completely yourself or you just copy it, deploy it yourself, change the graphics, whatever you want to do with it, it's all free for all. So we have the zero copy board account which I showed already. We have this here, the two dimensional array with all these tiles.
00:45:33.757 - 00:46:16.135, Speaker A: So this is one of the features. Then we have the on chain movement which I quickly going to show you. The move player, what move player does, it moves the calls on the game, which is the game that I count the move player and direction. What it does, it finds the player on the board, saves the player position. Then when it finds the player on the board it calculates the new player position which would be if you go up it would be Y minus 1. If you go right it would be X plus 1 and so on for the four directions. Then it checks if the new tile is empty and if the new tile is empty it just moves the player there.
00:46:16.135 - 00:47:01.665, Speaker A: If the player is not empty, if the tile is not empty and it's a chest, then we collect the chest and set the current tile to empty. Then we transfer from the chest vault some soul to the player who collected the chest. And we also transfer some gold token from the gold token PDA token account to the player and then we also save the game action which we'll be looking at at a bit. Yeah, you can gain soul tokens, gold tokens by killing chips that what you just saw. The same thing happens when you shoot. Then it finds the tiles on the side and does attack on tile. And when you kill another ship, then you will also get the soul in that ship and you will also get the gold token in that ship.
00:47:01.665 - 00:47:47.537, Speaker A: The rum and cannons apparently you don't get so because they quickly throw them into the harbor or into the sea or something. The ship account is derived from the mint of the pirate nft. So whenever you spawn your ship, what's actually happening is there's a PDA created which takes the mint of the NFT as a seed for any of these NFTs here. The ship starts at level zero, so there's a PDA which saves the current ship level. And when you use your gold token you can upgrade this ship. So you actually upgrading this NFT pda. So yeah, this is how you can save data on any nft.
00:47:47.537 - 00:48:39.239, Speaker A: Actually just derive PDA from the mint of the NFT and then you interact with that and you upgrade the ship with SBL tokens. You use SBL tokens for damage and health. So this is done like when we spawn a ship, it's in spawn players, we are checking the token accounts of the player and we use these amounts here for cannons and extra health. So the extra health comes from the rum token and the cannons come from the cannon tokens and the cannons in the ship are used to calculate extra damage. So if you have thousand cannons, I think you currently would get 1002 damage. Then the next feature there is, there's an auto approved wallet. I'm gonna go on this on the next slide.
00:48:39.239 - 00:49:11.097, Speaker A: More in detail. Then there's the clockwork weather effects that we talked about earlier. Already we have the NFT avatars. So like you select an NFT and then use this NFT as your character. So you can also see this little NFT here. If I, if I open this and I just deploy this ship, then you can see that the NFT avatar is actually here on the ship. So it's loaded after a while.
00:49:11.097 - 00:49:47.079, Speaker A: Then we have the animations via game action account. So if someone has a better idea for this, I would be very interested in this. But how I did this since like all the client sees is that the state changes right the board changes from one state to another. Like once the player is here, then it's there. So how I managed to get the clients to actually show animations is that I that I create. I have a new account which is a vector of game actions. And whenever an action happens in the game, I create a new game action.
00:49:47.079 - 00:50:22.637, Speaker A: So for example here if we shoot, I create a game action which is the game action shipped shot type and it has the player and the target and so the game shot just shoots in both directions. But then there's another one which is for example, take damage, then ship taken damage. So whenever a cannonball hits a ship, then it's triggering with the ship taken damage type. And then there would be the target and the player in there. Then. Yeah, it also has the damage and there could be any other data in there as well. Oh yeah.
00:50:22.637 - 00:50:56.165, Speaker A: And then we have the surprise Cthulhu attack which you will learn about tomorrow where you will be able to scan a QR code and then the big monster on the side of the map will shoot. We are Solana pay transaction request. So that will be very, very fun. More tomorrow. Yeah. And then a little analytics course on how you can do auto approve wallets. How I did this in the seven SEAS is I have a key pair in the game and whenever you deploy a ship, there's a tiny bit of soil transferred into this in game wallet and then that one is used to pay for the transaction fees.
00:50:56.165 - 00:51:28.595, Speaker A: You can also click here and you can withdraw this amount and you can put some in manually if you want as well. So this is one way it's not 100% secure since the browser isn't really a safe place. So there could be some cross site scripting or malicious extensions. But I think for the game, for this game it's fine. It's just like tiny amounts in there. And I mean it's still a funded key in the browser, so it's a little bit dangerous actually. Then there's some other options, which is the GUM session keys.
00:51:28.595 - 00:52:01.485, Speaker A: I did a video on the GUMP session keys earlier. So it's basically also saving an ephemeral key pair in the browser and transfers a little bit of soul into it. And then in your program you need to adjust your program so that you have an authority which is allowed then to do certain actions in the game. So I will link the video to that in the resources. Then what you can also do is use a burner key pair. This is pretty much what I did in the Seven Seas program. Then SoulFlare wallet has some auto approved functionality.
00:52:01.485 - 00:52:25.105, Speaker A: So you can per app, you can create a new key pair and then you can set auto approve. I mean, this forces you to use Solflayer and it's kind of hard to explain the players. Hey, create an auto approved wallet. And auto approved wallet are also very dangerous. They can use all kinds of things. Yeah. And Clockwork is also working on some solution, maybe where you can facilitate the workers.
00:52:25.105 - 00:53:02.517, Speaker A: But this is not really a solved problem yet. So if some of you guys want to like, work a little bit on this, this would be a very valuable addition to the whole ecosystem, I think. Yeah, I think this is it for day six. Very excited for you tomorrow to tune in again for the big Cthulhu attack. And yeah, now we could do a little, a little sea battle. So if you all log in now, we could fight each other and then we could also like turn on the wind and see how it is with the wind. And then we.
00:53:02.517 - 00:53:13.941, Speaker A: Yeah, here are the resources. I will add the link to the session keys video here as well. And yeah, thank you very much for joining me today and see you everyone tomorrow. Bye.
