00:00:13.760 - 00:00:15.954, Speaker A: Hello. Oh, hi, everyone.
00:00:16.854 - 00:00:17.918, Speaker B: Can you see everything?
00:00:18.046 - 00:00:38.364, Speaker A: Nice. We are Neodymon. This is think like an attacker about us. There we go. Elias. He is Thomas. We're co founders of Neodym, and we've prepared this security incentive because there's a need for Solana security.
00:00:38.364 - 00:01:36.514, Speaker A: We thought about how we could best teach people security, and we think it's not a three hour presentation. So that's why we got this kind of split workshop where we'll have a 20 minutes presentation and then give you two and a half hours of just solving challenges. What's thinking like an attacker? Well, obviously, it's being an attacker, but also for defs, it's how you think about your own code so that you can anticipate vulnerabilities before you even make them. And we think that's important for all the devs to have. But it's also relevant for auditors and security people, for obvious reasons. There are a few ways to get to this mindset, and CTFs are one pretty nice one for those of you who don't know about them. It's basically capture the flag, where you have interactive hacking challenges.
00:01:36.514 - 00:02:17.774, Speaker A: And that's how neodym got formed. And we're all basically CTF people. We like to hack things in our free time. So we thought, why not just bring that format to Solana and get people hacking stuff so that they know how security works? There you go. We could just give you a list of common bugs and actually, we did that. You can find it on our blog. But if you want to have actual security, hands on experience, we'll be giving you guys access to some remote servers and also deaf environments, so you can have a look at some of our challenges and try to solve them.
00:02:17.774 - 00:03:10.210, Speaker A: Is this broken? That's a question we have to ask ourselves many times, every time we audit some contract. And the question is, actually the wrong question. It should be, how do I break this? Because in our experience, you can usually break everything. It's just a matter of dedication and putting in the time and trying to break it. So whenever you look at your own code, it shouldn't be that I put in a vulnerability, it's how far would an attacker go to break my contract? That's something you should always keep in mind and just not. Don't forget that it's always possible to break something. And one big issue, especially with defs, is it's not super easy to get rid of the biases you already have.
00:03:10.210 - 00:03:57.356, Speaker A: When you look at a piece of code, you usually think, well, this is what it does, because I wrote it, and it does that in practice. It usually. Well, it sometimes does something different, and that's something you definitely need to get rid of. So the first thing we would ask you to do is if you. When you're doing the challenges and you feel stuck, maybe grab someone else who has different biases and then try to see if you can maybe come up with some idea or spot where you guys are missing to help each other out. This is one important security concept, basically tracing user input. When we look at a piece of code, we usually don't look at it in terms of, well, this is a function, and it does x, y.
00:03:57.356 - 00:04:40.688, Speaker A: We look at the function and then we think of, okay, this is user input. This is what we control. How can we use this to break the control flow in security? There are a bunch of fancy words for that. There's a concept called syncs and sources, where the idea is that the source is basically any attacker controlled data, and then the sync is any critical thing that could happen. It might be a sensitive function, like invoke signed in the case of Solana, or it might be something like a mem copy and low level c code or something that does, I don't know, some transaction in a web application. The important part is whenever you look at a piece of code, you should think of, I am an attacker. I control this part.
00:04:40.688 - 00:05:10.638, Speaker A: How do I use this part to make it do something that I want it to do? Solana basics for attackers. This won't be a comprehensive Solana guide. We'll just go over the parts that are important for us as attackers. So we're already assuming you know the basics of Solana, like. Yeah, just like the very basics. Solana's main concepts are accounts. That's the main primitive you get.
00:05:10.638 - 00:05:17.638, Speaker A: That's how you interact with stuff. There are accounts and they have stuff. That's an account. It has stuff.
00:05:17.726 - 00:05:18.102, Speaker B: You can see.
00:05:18.118 - 00:05:24.950, Speaker A: We removed some things because they're not as important to us. We can start with the first one.
00:05:25.142 - 00:05:25.774, Speaker B: That's the key.
00:05:25.814 - 00:05:48.412, Speaker A: It's pretty self explanatory. That's just the public key that identifies the account is signer is an interesting one. That's the flag that indicates if an account has signed a transaction, which is obviously a very sensitive thing to do. Lamports. Oh, there we go. Balance. That's basically the balance.
00:05:48.412 - 00:06:24.654, Speaker A: When lamports is like a bill. Yeah, like a billion. No, a billion lamports is one sol. And there are some interesting checks on lamports. For example, we sometimes have situations where you have a contract where you can somehow modify the Lan ports because they do some weird additions where you can maybe overflow stuff, but the runtime actually asserts that the total Lan ports haven't changed. That means even if you have a vulnerability that allows you to add arbitrary amounts to the LAN ports of some account, they have to come from somewhere. The contract can't just magically make LAN ports appear data.
00:06:24.654 - 00:06:47.842, Speaker A: That's also one very important field, especially for program accounts. It has up to ten megabytes of readable storage, can only be written by owner, cannot be resized. That's something they're working on, by the way. And owner, pay attention to this one. If you don't take anything away from this talk, let it be this. Just this. Check the owner.
00:06:47.842 - 00:07:14.664, Speaker A: This is very, very, very important. Check the owner. The owner is the only one who can write data. And if you don't check the owner, you're dealing with data you can't trust. That's something that's super bad. We found so many loss of funds vulnerabilities because people have just not checked the owner. It's something you definitely need to do if you're a deaf.
00:07:14.664 - 00:07:42.284, Speaker A: Check the owner and then executable. That's because the only thing there is in Solana is accounts. So smart contracts are also accounts, and they have that executable bool set to true. They're at that point, they're read only and well have EBPF code in their data transactions. That's you.
00:07:42.404 - 00:08:00.744, Speaker B: All right. That's where I pick off. So we've already learned about accounts. We have a second important concept in Solana that's called the transactions. That's basically how a user will, or an attacker will interact with the contract. Right? But first, short recap of what you've learned so far. Check the owner.
00:08:00.744 - 00:08:33.696, Speaker B: This is like a pretty print of how transaction might look like. There are like a lot of ascii garbage on there. So the garbage you can just ignore just arbitrary keys and signatures. So a transaction pretty much is just like recent block hash, where a recent block hash just ensures the transaction, like only is valid for like a couple of minutes. If it isn't executed by then, the transaction is just invalid and anybody can just delete it. Then we've got the signatures. Signatures are really important.
00:08:33.696 - 00:09:14.158, Speaker B: These are the pieces of information which verify that one of the keys has actually seen the transaction and signed it. The signatures here are the same one as specified in the accounts. But you can obviously have a lot more accounts than signatures in these accounts, the first account always is the fee payer. And all of these accounts, they have rights or like permissions. Like these are printed similar to how you would see on Linux. Like the s means it's a signer, r means account is readable, w is writable, and then you have x for executable. So in this case you have like two signature accounts, the same one we've seen before.
00:09:14.158 - 00:09:53.292, Speaker B: You have like all accounts are always readable. You have a bunch of writable accounts, and then the wallet account is the bottom one, that's an executable account. So these are like in one transaction, you always have like this one set of accounts, and then you have an instruction. One transaction might contain one or multiple instructions. And like these instructions here calls the wallet program and passes the wallet program a subset of the accounts which are contained in the transaction. You don't have to pass all the accounts, you don't have to pass them in the, in the exact same order. So they reordered a bit, but they're in there.
00:09:53.292 - 00:10:39.204, Speaker B: So these are all the accounts the program will be able to access. And then you've also got like this data array. This is just like some untrusted arbitrary data, mostly a serialized struct with, for example, Borsch, which the user just specifies to execute the contract. So, okay, we now have all the basics we need. So this is everything you need to know about Solana for attacking smart contracts, because with this knowledge you can just go into versus code, hit, go to definition, a whole bunch, and every code, every check you will find will basically be there. And now I will show you a bit of how we would approach one of these smart contracts. We've prepared five smart contracts today.
00:10:39.204 - 00:11:04.284, Speaker B: If you get through all of them, very well done. We don't expect that to happen. We will talk about level zero right now. So level zero is like a fairly easy bug. We've also seen quite often in the wild. And I want to show you how we, or I would approach looking at such a contract. So I'm now in versus code.
00:11:04.284 - 00:11:34.486, Speaker B: You see, I have this level zero folder which contains the program kagatoml. As usual, we have a lib and a processor. So first thing we do, ok, we have a smart contract. We don't know anything, we don't know what it does. We haven't gotten some dogs because the developers are like in the time rush, they have to get time to market, no time to document anything. So what do you do? First thing, contracts always have entry points. If I as a user or an attacker interact with the contract.
00:11:34.486 - 00:12:10.156, Speaker B: I execute some instruction and this is the first thing I always go look for. So these are usually as it is over here, defined in the librs where you got some enum that contains all instructions. And luckily for us, we even have some comments here so we can look at, okay, the contract we are currently looking at seems to be like some kind of personal savings wallet. It has an initialize, it has a deposit, it has a withdrawal. We already know all the accounts here. They are named what they should be, but that's arbitrary, that's user controlled. Maybe we can do something interesting.
00:12:10.156 - 00:12:29.908, Speaker B: And also the amounts are fully user controlled. Okay, so contract seems to store money. We want to get at the money. Let's see, what does it actually do? In this function we have get wallet, address, whatever. Some helper functions. We have functions which return instructions. These are just helper functions.
00:12:29.908 - 00:13:03.484, Speaker B: We don't care about all that's helper functions. User is going to use them, but we as attackers don't care. We want to know what the contract is actually doing with the money. So we then start to look at the entry point, because the entry point is the first thing the contract actually calls. And the entry point in here will deserialize all of our instruction data. This is like the extra data field we passed in the instruction. And then it looks at do we want to initialize, deposit or withdraw? And then we have these three functions, and this is basically the whole attack surface of the program.
00:13:03.484 - 00:13:27.470, Speaker B: Everything else has to be called from inside one of these three functions. So for now I can just limit my scope, think about only these functions and look at what they do. We have the initialize function, probably just like initializes our volatile. I guess we can look at. Okay, we have starts with getting accounts. That's just usual how programs look. These are user controls, whatever we can always see.
00:13:27.470 - 00:13:50.308, Speaker B: Okay, program address. Program addresses are always interesting because that's something the program can sign with. So it's always like important to keep track of what they are. Do they use any seats? In this case, the seat is the authority info. Just something to keep in mind. Then we can further take a look and see. Ah, okay, we have some research, maybe later.
00:13:50.308 - 00:14:06.584, Speaker B: Interesting. Invoke signed. Invoke signed is directly. Okay, that might be dangerous, because here we are applying a signature which hasn't existed before. So we have to look carefully at what is it doing. Maybe something wonky. But here we can see it's just system instruction create account.
00:14:06.584 - 00:14:27.696, Speaker B: And this is just like it's instruction for the system account. It can't really do much. The program is all checked inside, so any seeds we apply here, they're not going to be able to be abused. So we can then check off. Okay, invoke sign is fine down here. Invoke signed as well find as well. Then we go to.
00:14:27.696 - 00:15:08.838, Speaker B: Okay, we are now creating the actual wallet, the structure, and now it's important to take a note at. What does the wallet do? The wallet consists of two parts, consists of the authority, and it consists of the vault. So authority, just like guessing, likely something we need to access the vault. And the vault is basically where we store money. Just like guessing from the variable names here. We could go look at everything here, but just like why do that? We can just guess and if the guess turns out wrong, we'll see that later and we are quicker that way. And then we go ahead and serialize the wallet data into the walletinfoaccount.
00:15:08.838 - 00:15:29.606, Speaker B: That's an account we passed at the beginning. Ok, so what we've learned before, we can only write into accounts when we're the owner. So the wallet info has to be owned by the level zero contract we see here. Ok, but that's nothing much happening here. There's no money charged. It's quite boring. Then we see deposit.
00:15:29.606 - 00:15:59.202, Speaker B: Deposit that actually touches money. Same structure as before. We even look at the wallet, we look at some accounts, whatever we see transfer, but in this case it's only an invoke. So only the signatures we already have on the transactions will be passed on. This transfer instructions will not be able to do anything except for what we allow it to do. And as an attacker, we really can't do much with that. Not really that interesting deposit either.
00:15:59.202 - 00:16:39.774, Speaker B: And then we get to withdraw withdrawal. Same structure again, like some accounts, some wallets, we have some thirds, I mean fine, we seem to have like some kind of check that we don't spend too much money. I mean I guess that's fine, probably like some overflow checks. And then we just go ahead and have like vault info and subtract some amount. And from the destination info we add some amount and this is really interesting, right? So this is the point where we would be able to get money. This is like somewhere if we destination info is fully controlled, it just comes directly from the input. So if we were able to reach here, down here with an amount greater than zero, we would just be able to get money.
00:16:39.774 - 00:17:10.904, Speaker B: Now we need to make sure how is this protected? So now I go backwards through the function and just see what checks are there. And then we've already established, ok, amount has to be larger than vaultinfo Lamports. That makes a lot of sense because we won't be able, the runtime won't let us just magically create money. So the vault has to have enough to subtract the amount. Fine, but we are attacking a vault of somebody else. So the vault of somebody else will have money. That's not a problem.
00:17:10.904 - 00:17:35.726, Speaker B: Then we have a bunch of certs. So the first cert authority info is signer. I mean, sure, that's something we expect the authority owner will have to sign. If it wouldn't, this thing would be broken. Then we see, okay, wallet. The wallet is deserialized from the wallet info account, the one we've written before. And it contains two fields, right? It contains the authority and the vault.
00:17:35.726 - 00:18:12.644, Speaker B: And both of them actually checked here. So we are checking that the authority matches the authority we passed, which in turn has to sign, and we're checking that the vault matches. But like, I'm not sure if you remember what we like. Repeatedly a bunch of times a couple of minutes ago, this wallet, it is deserialized from the wallet info. And even though it's called wallet info, there's like no check here. There's nothing that ensures this wallet info is owned by the program. This can be any arbitrary account anybody has created which has a structure that looks similar to vault in authority.
00:18:12.644 - 00:18:48.800, Speaker B: Like, nobody guarantees us that the authority in this account actually belongs to the vault. So this is like the bug we will be exploiting, like in this level one. Let me see. Play. Right? So the exploit, this is like the usual case, the good case, the case that the developer expected. You have a wallet account that's owned by the vault program and it has an authority and a vault. The authority points to the user's public key and the vault points to like another contract, another account.
00:18:48.800 - 00:19:19.564, Speaker B: It's owned by the system program that just contains all of the money. What we as an attacker can do is we can have an attacker program which then creates an account which also has authority and vault. But the vault points to the original to like the Green vault and not the attacker's vault. But now the attacker will be able to sign with the authority because like he sets himself as the authority. So we're pretty sure that's going to work. It's quite a simple bug. If you've seen that a lot.
00:19:19.564 - 00:20:07.640, Speaker B: It's easy to find, but there are a lot more complicated bugs. Sometimes you're just not sure is the thing we are thinking about here. Will it work? Do I have to go hunt for all the checks? It can be really difficult to actually think through if it's going to work, if it's not going to work. And we as auditors, we don't like going to people and saying, hey, you've got a critical bug there, I can steal all your money. And then it turns out that's not the case. So what we did is we developed a proof of concept framework, which helps us to test our theories. So it's a framework designed to deploy a program, to initialize the program, to initialize accounts, to have some money available, unlike your own computer, and then you can interact with a program on your own computer.
00:20:07.640 - 00:21:06.744, Speaker B: You don't need to have a live testnet or a mainnet, because obviously if you're testing exploits, you can't test them on Mainnet, and you can't even test them on any public net because you can't leak what kind of exploits you're doing. So that's what the POC framework is for. And I can also give you a short overview, because you will be using that in just a few minutes, how the POC framework looks like. And all it does is more or less just one rust file, and this one rust file, it's pretty much like a test for your program, and it sets up everything, and then it hacks it, and then it checks if you've successfully exploited the contract. So let's start at the setup function. So these level zero to level four, basically example PoC framework files we will provide to you. So everything you see here will already be set up for you.
00:21:06.744 - 00:22:11.654, Speaker B: You won't need to write all of that yourself, just to like, we only have 3 hours, you can't be expected to learn all of that, just like a custom framework now, but the setup function, what it does is it basically locates the level zero compiled contract. It gets like a rich boy, which is like a person with a lot of money. It initializes a hacker key pair, it initializes some authorities, and then it initializes a local environment, which is basically like a validator, just like in process. And you can add programs to it, you can add account with lampards to it, you can then execute some transactions on it. In this case, we initialize the level zero account, then we deposit as the original user, we deposit some money into it, and we return these two structs. So the challenge struct is something you will be able to access that is like all the information contained in there will be available to an attacker, and then we have this internal thing. This is just stuff which only would be able to be accessible by the user.
00:22:11.654 - 00:23:05.456, Speaker B: So something you could not use in your exploit, because in the real world you would not have this kind of information. And then we have in this framework the hack function, and in this hack function you can then use the local environment and the data you get from the challenge to implement the exploit I just described. So you could figure out how much money do you want to steal, like how much money is in the vault. You could set up this fake wallet which points to the same vault, and then you could use the fake wallet to withdraw funds and basically be richer to make it easy for you to see when you succeeded or in what way you succeeded. We also have implemented a verify function. This verify function always runs after the hack function and tries to basically withdraw all the funds the user originally had. And it tells you if they succeeded or if they didn't succeed.
00:23:05.456 - 00:23:37.614, Speaker B: And it also tells you if the hacker's account has a greater balance than before. And the goal always is make the hacker's account have a larger balance than it had at the beginning. Because in that case you have proven that you've been able to successfully steal some funds out of the contract. Right. All right. I don't think it makes much sense to go into the details of the POC framework right here on stage. It's a lot more sensible for you to like, if you need something here, I mean that's like versus code.
00:23:37.614 - 00:24:10.964, Speaker B: Your instances will have rust analyzer installed, or you can also do it locally. You will have syntax highlighting, you will have auto completion, and there will be docs on the PoC framework. So if you need something, just check the docs or ask us will be around. Yes, that's it about the PoC framework. Yeah, and that's pretty much it for the talk we're giving. Like, the rest of this workshop will be really interactive. So we've prepared our workshop website.
00:24:10.964 - 00:24:38.652, Speaker B: That's workshop dot neodym IO. You could just go there now. I think it's live. And yeah, there will still be some stuff we already talked about in the presentation. It will be repeated there. There will also be like some guides on, if you get stuck, there will be some hints on there, but I kind of recommend you don't use these hints. They're really just like they are if you really get stuck.
00:24:38.652 - 00:25:17.594, Speaker B: And we are like really busy right now. I see a lot of more people have joined, so we'll have to see, but I, I think it should still be possible. Really? Well, we will be providing remote environments, so there's like Google Cloud hosted instances which have already the code on there, which have visual studio on there which have all the extensions installed and you can just use from your web browser. So even if you don't have like a powerful laptop right now, you can just compile and run and do everything you need from the web browser with the more or less usual visual studio code experience. You can also ssh in these instances and just do whatever you want there. Please. Only workshop related though.
00:25:17.594 - 00:25:44.310, Speaker B: And you can also develop locally and the guides on how you will do all that. You can find all of these at workshopeodem IO. All right, we will be providing some papers. He's holding them up right now. These will be the access credentials for the servers. Like, I'm not sure how many servers we have provisioned right now. We can easily provision more if you need.
00:25:44.310 - 00:26:05.658, Speaker B: Shouldn't there be enough? But we'll be going around and every one of you who like wants access to one of these remote instances because he thinks it makes sense to develop remote can just head up one of us. Toby's going around hitting off the papers. That's it for me. I hope you have a lot of fun during this talk and you learn a lot. Cool.
00:26:05.706 - 00:26:19.314, Speaker C: Thank you so much. All right, I'm going to help pass around these papers. I'll do this side, but we're also going to bring some upstairs. And the neodym guys will be coming upstairs as well. So if you need a table, but otherwise, yeah, hack away.
