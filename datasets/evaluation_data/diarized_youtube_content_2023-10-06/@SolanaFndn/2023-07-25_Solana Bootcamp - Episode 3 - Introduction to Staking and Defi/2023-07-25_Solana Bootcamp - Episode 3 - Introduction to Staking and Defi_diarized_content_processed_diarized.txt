00:00:09.040 - 00:00:50.964, Speaker A: Hello, my name is Jacob Creech. I work as developer relations at Solana foundation. Today, we're going to expand on the gold tokens that you earned in the previous day of the boot camp. We're going to do a deep dive, working with tokens in general in Solana, learn PDA's in much more detail, and how to create a staking program for those tokens. Now, what do I mean when I talk about a staking program? The staking program that we will build today will allow you to deposit tokens, earn rewards for the stake that you have in the program. And the longer that you have those tokens staked, the more rewards that you will receive. Now, why would you want to do this? A stake program can have many applications.
00:00:50.964 - 00:01:42.578, Speaker A: Take for example, if you're building a mobile game where you send woodcutters to chop wood in a forest. The longer the woodcutters are in the forest, the more wood they will cut. On the program level, both the woodcutters and the wood can be represented as tokens. If you can send your woodcutter token to chop wood by depositing it within the program, the program would then generate wood tokens for you over time. Let's get to building this staking program. Now, it's good practice before you build any program on Solana to first kind of draw out what accounts that you will be using within the program. We do this early so that you can know what to expect when you're working with the accounts and the account model on Solana.
00:01:42.578 - 00:02:55.484, Speaker A: And it kind of also helps that when you are working later, you don't realize, oh, I needed this account earlier and have to rewrite all the code previously. So, first off, we know that we have these users, so we have a user and they have wallets, right? And for our case, they have specifically a PDA called the Gold Token account. So that, that, that gold token account is directly related to the user and as a PDA. So we know that we have this account and then the user, which is also an account, because remember, everything is an account on Solana. Next, that we know that there is going to be a stake program. Now, for the users to deposit gold tokens into the stake program, they're going to need a specific stake program account on the stake program itself. So we know that that's going to be, we're going to call it right over here.
00:02:55.484 - 00:03:54.774, Speaker A: We're going to call the user stake account. Now, this is going to be a PDA off the stake program, and let's derive it with with the key where the seeds of token, and this would actually be token plus user pubkey. Now the reason why we do both the string literal token plus userpuppy is so that we can directly relate this account to the user by user pubkey. We don't want someone that is a different signer, say another user accessing the user funds of someone else. That would be a security risk. So make sure that you always put in your seeds correctly. And adding a user pub key to your seeds creates a user space in your PDA's on your program.
00:03:54.774 - 00:04:52.064, Speaker A: Secondly, whenever you stake those tokens within the state program, we're going to have to know exactly what time you stake those tokens. So in that we'll have to know some stake info. So let's create a stake info account. This will be another PDA. And this PDA, let's just derive it off of, let's call it stakeinfo plus user pupkey. And so we'll have the string literal of stakeinfo and user Pubkey in order to get the information about their specific stake on the program. This information would be like the slot time so that we know how to generate the rewards.
00:04:52.064 - 00:05:35.044, Speaker A: And speaking of rewards, we're going to need some have to need a place for the rewards to come from on the stake program itself. So let's create a stake, another token account called Gold Token Vault. So this is where all the rewards will be generated from and we will create the seed of vault for those rewards. So there we have it. We have all the accounts that we are required to run the stake program. We have the token account that is owned by the user. We have the token account that is the stake by the staking program.
00:05:35.044 - 00:06:24.334, Speaker A: We have the information about this different token accounts that are staked. And then finally we have the token account that all the rewards come from. Now you might see somewhere in the wild that whenever you have a token account off of a program, you have something that looks like this. People usually sometimes create a PDA that is just for signing. So this would be like a signing PDA that would be derived off of the state program and then the authority of the gold token vault would be the signing PDA. That way the stake program can sign for transfers within the gold token vault. However, this is not required and it's actually not best practice.
00:06:24.334 - 00:07:18.760, Speaker A: So instead what you can do, and this is usually not what you expect at first, is you can take that gold token vault. So we're going to add the seeds back just for completeness sake. Instead you can take that gold token vault and make the authority itself. And given that it's authority itself, you can then use that PDA off of the stake program to sign for the transfers for itself. It kind of removes the need for extra accounts. And usually when you're working on Solana programs, the less accounts the better. The reason being is if you have less accounts, your transactions are smaller, your compute, compute usage is smaller, and the transactions will cost cheaper in the long run if compute ever ends up costing any amount of soul.
00:07:18.760 - 00:07:49.874, Speaker A: So here we go. We have all the accounts that we needed for the state program to run. So let's get to coding. Okay, so first what we're going to do is we're going to initialize a new anchor project. So what you could do is anchor init and we're going to call this staking program. And so what this will do is it will create the program or the anchor project for us to work in to create this stake program. So we can see got initialize and we'll CD into the staking program.
00:07:49.874 - 00:08:16.454, Speaker A: And you can see here that if I open this up, it has an app. That app is for usually where you store the front end. We're not going to have a front end. We're going to write just tests for this program. You have your program, which is a lib RS file. You can see here, it's just a base initialize function as well as base initialize account. And then the test will just run initialize and that is it.
00:08:16.454 - 00:09:07.654, Speaker A: So we're going to check right here and just make sure we're at Anchor 28 for the uses of this tutorial or this bootcamp day. What we're going to do is we're going to be working with the Solana CLi version 116.0. So if you're not on Anchor 28 or Solanacli 116.0, make sure you change these versions because it's no guarantee that this program will work or be backwards compatible if you have a major version change. Finally, we're going to be using the anchor version to also compile anchor 28 as well. All right, so first off, I'm going to make sure that this builds just to make sure that they're not running into any issues. So we're going to do anchor build and we're going to wait for the build.
00:09:07.654 - 00:09:37.114, Speaker A: Perfect. So if you ran anchor build and you just got a few warnings, that's perfect. So if you look at these warnings and you're wondering what do these warnings mean? This is meaning because we're using, we have a context in the parameter here and we're not using it. If we're not using it, it's telling us to put an underscore as a prefix, but we will use in the future. So let's just leave it there. But otherwise it compiled and everything worked. So let's get started.
00:09:37.114 - 00:10:31.276, Speaker A: So looking back at this diagram, we can see that we're going to use these seeds of vault, Stakeinfo and token. So I want to make sure that we do this early and include those three seeds in constants. So first off, up here we're going to create a pub mon constants and we're going to create some constants for us to reference while we are running through this program. So first will be the vault seed, which will be reference u eight, and that will equal the string literal of looking back at it. Just vault this. Then we'll do pub const. Let's see, we have stakeinfo next.
00:10:31.276 - 00:11:28.318, Speaker A: So stakeinfo seed, same type equals string literal and we had it as stake info. Finally, we're going to have the last one, and this one's going to be the token seed. As looking back here we have it as token, that's going to be the same type of string literal token perfect. So we have all the constants that we need and we have the vault, the stake info and the token for seeds. All right, so getting into initialize the way that you usually write programs is you, or at least the way that I like to write them. So I like to scaffold. First, what are the different instructions or functions that I need within my program and then create all the accounts.
00:11:28.318 - 00:12:01.054, Speaker A: So we know that we need an initialize, because if the gold token vault doesn't exist, we need to be able to create it before there's anything else or any other actions happening within the stake program. So going back here we have the initialize function. It's going to have an initialize struct. We'll get to these accounts in just a moment. Secondly, we're going to need a function that allows the user to take the action of staking to the stake account. So here we have yet another one. We're just going to copy and paste this for now.
00:12:01.054 - 00:12:55.350, Speaker A: We're going to call this stake. And if we look at this, we're going to want to be able to stake an amount. So we're going to add the amount as a parameter for the stake function. And finally, whenever we want to get rid of the stake or D stake, we're going to have a destake function that then gives us rewards, resets our stake info and gives us back our balance from the stake account. So that is the final function. So we're just going to paste that back and this one's going to call dstake, right? All right, so we have our three functions or these are each instructions. And now we need to create the accounts with an initialize.
00:12:55.350 - 00:14:00.844, Speaker A: So if we look at this initialize, we have to think, what do I need whenever I initialize this? So first off, we know that we're going to have to need this gold token vault, right? So we're going to have to create an account and this will be account we're going to use something called init if needed. So what if needed is it allows us to initialize the account if it doesn't already exist. So what that means is if I call this instruction of initialize up here, it won't create the account if it already exists. But if it doesn't exist, have it be created. So and then if needed we're going to have the seeds of, if you look up over here, it was vault. So constants was a vault seed because it's going to be a PDA. We always need a bump.
00:14:00.844 - 00:14:27.264, Speaker A: So this is where we need a pair. So the pair will equal the person who is the signer of the transaction. So in moment we'll go add that. But we know that it has to be the signer. So let's go at it right now just so that we know about it. So right here we're going to have another account. It's going to be immutable because we're going to use it as the signer to pay for things.
00:14:27.264 - 00:14:50.520, Speaker A: And that's just going to be the signer. Signer. All right. And just so that it carries throughout, we're going to do the lifetime. Perfect. So we can see here this payer is referencing the account up here of signer. There's two other things.
00:14:50.520 - 00:15:36.964, Speaker A: So we have the token mint and then the token authority. I'll set those up in just a moment, once I finish writing everything. So this account will be the public, this will be a token vault account, and this will be a type of account info token account. Alright. So let's go back for just a moment. So if you remember when I was talking about earlier, is that in order to sign for the transfer of this, you would have to have the authority of itself. So here, up here we have the authority, we're going to have the authority of itself.
00:15:36.964 - 00:16:38.524, Speaker A: Secondly, we have a mint right here. And you might be asking what is the mint? So when you're using tokens within programs, so any type of token account, you're going to need a number of accounts that are always required in order to manage those accounts. So you're going to need the public mint, which is a type account mint. You're going to always need the token program which is of type program token. And then because we're creating account, we will be needing the system program. Otherwise we wouldn't be able to create the token account system. All right, so right now we have all of this information, oh, and we have this token mint equals, we need to make sure that it equals the mint down here.
00:16:38.524 - 00:17:17.654, Speaker A: Alright, so right here we have all the information to initialize the accounts. We have the token vaults account being initialized on startup and that is all we need. So let us anchor build this and we should run into a few errors. The reason being we will run to a few errors because we included all this stuff from token and this is not used and then in it if needed is not available as well by default. So let's just run through those as a practice. So we're going to do anchor build and immediately it's going to run to a few errors. So if we go down, we're going to ah yes, so there we go.
00:17:17.654 - 00:17:32.734, Speaker A: We're going to go to the first error. That was just me accidentally not putting a semicolon. Let's run it again. All right, perfect. We got some more errors. Scroll up to the first error so we can see. All right, it's exactly what I said in and if needed it doesn't exist.
00:17:32.734 - 00:18:16.164, Speaker A: So we need to make sure that we include that feature whenever we start. So right here we'll go to cargo and we'll see here that it says anchor laying equal 00:28 so in order to include new features, you'll have to do the following. So you're going to equal to bracket, this will be version equals same version 0.28.0. However, I'm going to make sure that I include the features of init if needed. Right. So here what I have is, is I have anchor Lang including the vision, the feature in it if needed on version 28. So that should cover this.
00:18:16.164 - 00:18:50.408, Speaker A: So finally we should run into one more error. And that is something about us not including SBL token or anchor SBL into the cargo toml. So let's just wait just for practice. We want to see the error and then use it. All right, so if you look here, we have a bunch of things about missing token, missing mint, missing token account. So let's make sure that we add those and we can actually see right here the rust compiler is very smart in saying hey I couldn't find anchor SBL, you should import this. Great, so let's go import them.
00:18:50.408 - 00:19:29.484, Speaker A: So here in the dependencies for cargo tamil we're going to just type in anchor SPL. We're going to make sure that it's of the latest version of 28 and that is it. And then finally right here at the top we only have use anchor Lang prelude. Right. We have to make sure that we use the other stuff within the crates as well. So we're going to do use anchor SPL and there's a few things that we need. So token, we're going to need token of self mint token token account.
00:19:29.484 - 00:19:53.294, Speaker A: Perfect. So this should be everything that we've used and let's do an anchor build and see if we ran into any issues or forgot anything. Alright, so it looks like I ran into an error still. So let's see what we forgot. You can see that I just said I forgot a semicolon. That's a pretty simple error. Let's go fix that real quick and we can see here it finished successfully released the target.
00:19:53.294 - 00:20:36.194, Speaker A: Some a few warnings about missing contacts and not using amounts just as earlier. That's okay, let's just continue. All right so next up what we're going to do is we're going to go to the test, right? And we're going to take this test and we want to make sure that we test the initialize functionality. If we don't do this first, we might run into issues later and not know what we're doing, right? Okay so if we do anchor test, anchor test will run a local validator on the test. But in order to speed it up we're going to run it ourselves. You can see I'm already running it over here. So let's restart it just for, so you all can understand how it looks.
00:20:36.194 - 00:21:15.686, Speaker A: So I'm going to run slow test validator. That's going to test or run a solid test validator in my background it's currently at slot 200,000, 218,000 alright so let's do anchor test and this one's going to be skip local validator. What this does is it skips the local validator setup. It makes us quite a bit faster. And you saw here that at the beginning it was doing a bunch of transactions and this deployed my program to programid this. Now it failed. And let's explain why.
00:21:15.686 - 00:22:01.894, Speaker A: So we can see here the invadal valid argument of the token vault account was not provided. So let's explain that a little bit. Whenever you make a transaction on Solana, you need to make sure that you're including all the accounts required to make that transaction. So if you look over here, whenever we were doing the initialize instruction, we have it using these set of accounts, namely Tokenvault account is the one that was not included. So let's make sure we include it. So the first thing we're going to have to do is we're going to have to create the accounts that are required and those accounts are the vault. We're going to have to create a mint because the token accounts have to be created off of vault or Alpha Mint.
00:22:01.894 - 00:22:28.242, Speaker A: And let's get started. So first off, we're going to have to create that mint account. We want to make sure that we save it. So in order to create mints, this is using Mocha, we're going to have to include it as yarn add at Solana. I believe it's splash spl token. Right. All right, we already have coral anchor.
00:22:28.242 - 00:22:55.576, Speaker A: We're also, let's see, do we already have, let's check. We also don't have web3 js. So let's make sure we have web3 js so that we can do all the information. Perfect. Let's go back to the test we have is initialize. It's doing the initialize RPC call, but it's not providing any of the accounts that we need. So I am going to now set this information over here.
00:22:55.576 - 00:23:31.184, Speaker A: So just for completeness sake so I can get my pair and do const provider equals anchor provider envelope. So I have all the information. We're going to set this as the provider. I want to make sure that I get the payer out of it. So const payer equals provider wallet as anchor wallet. Perfect. I'm going to need this later.
00:23:31.184 - 00:24:24.556, Speaker A: We're going to have to set up our connection so that we can make RPC calls. So const connection equals new connection. We're going to be working on our local validator. So this will be HTTP one hundred twenty seven zero dot zero dot one at port 8899, which is the default port. We're going to use the state commitment of confirmed so that we make sure that we're always looking for confirmed things. If we look right here, it's saying, hey, I don't know what connection is, we would just want to add it from web3 js and finally let's see, we already have the program so we're good to go. I'm going to create a separate function.
00:24:24.556 - 00:24:53.964, Speaker A: So async function createment token and we're going to create this min token and log it. So this will be cons mint equals await create mint. This is a function from SPL, the SPL token library. So let's go add that in real quick. Add import from SPL token. This is going to require quite a few things. We already have the connection.
00:24:53.964 - 00:25:28.034, Speaker A: We're going to have the pair pair which means it's the actual public key. We're going to have to do the pair payers assigner payer publicy is the actual public key of the pair. Another pair public key. Let's make this token of nine decimals and that is it. So we're going to have the mint. The mint is, let's see what type is the mint. That's a public key.
00:25:28.034 - 00:26:11.604, Speaker A: We want to make sure that we create this off of a key pair though. So let's go up here and we're going to do mint key pair. And this is the reason why we want to do this is we want to have that key pair for use throughout all the tests. We don't have to restart test, have the same key pair being or previous key pair that we no longer have being used in stake program and then not be able to create tokens off of it. So let's create that real quick submit key pair. This will be key pair generate I believe and it's going to say that I don't have it. So let's add it back in perfect.
00:26:11.604 - 00:26:47.346, Speaker A: And just for funsies we're going to console login. Now you don't want to normally log this but because of the test it should be okay. This is so that we can get the secret and we run it. So here what we'll do is we'll add the mint key pair to say hey uses mint kmpair in order to create my mint. So first thing we're going to do is we're going to create that mint. So await create mint token. Alright, so this should log my mint.
00:26:47.346 - 00:27:13.562, Speaker A: So we'll do console dot log mint. And we also have the mint key pair. So let's do anchor test again and see what happens. All right, perfect. So we have the public key which is right here of the mint. And then here's the secret key. So in order to make sure that we're using the mint, the same mint always I'm going to grab the secret key real quick instead of generating a new one every single time.
00:27:13.562 - 00:27:49.724, Speaker A: I'm going to use that secret key that we use previously. So this would be from secret key, this would be new you int eight array and then you just include the secret from earlier. Perfect. So this would create the same mint every single time. We don't need to use this anymore. So we're just going to not use it here because we've already created on our local, but if we do need to create it, we can recreate it there. So we're going to move these console logs because we don't need those anymore.
00:27:49.724 - 00:28:32.164, Speaker A: Alright, so next up, we need to create that vault account for whenever we did the token vault account. Because whenever we run this test, it's going to require that account in order to run that instruction. So let's create it. So because it's a PDA, we're going to have to create it off of this. So this is going to be vault account and we're going to set it equal to basically how you derive a PDA. So that's using a function off of public key dot. They were going to do find program address sync and then it's going to be from the buffer dot fr om.
00:28:32.164 - 00:28:50.712, Speaker A: And if we look over here, it was from vault. So we're going to use vault. And finally we need to always include the program id. Is it program or programid just for. Yeah. Okay, so program id. There we go.
00:28:50.712 - 00:29:23.664, Speaker A: So now we have the vault account and we can use it within our instruction. So over here we're going to have to make sure that we have the accounts and we're going to have to include the accounts that are required in order to run this. So this would have to need the signer. So if you remember, we have to have a signer in order to pay for this. So it'd be payer public key. We're going to need the account or the vault account. So this is token vault account.
00:29:23.664 - 00:29:44.230, Speaker A: Vault account. And then finally we're going to need the mint. And the reason why we need the mint is so that it knows what mint is expected for this token vault account. So this mint is going to be the mint key pair public key. Perfect. So we have the initialize. So initialize will work once.
00:29:44.230 - 00:30:09.156, Speaker A: Let's see how it works. All right, our test passed. We initialized the token vault. It has no tokens to begin with, but we initialize it. And now we can have users staking to the stake program and destaking later. So let's go right at those functions. Alright, so first off we're going to have to create a new set of accounts for this stake.
00:30:09.156 - 00:31:00.004, Speaker A: So first we're going to do the same thing as we did earlier. We're going to do set up a struct for all the accounts so derive accounts. This is going to be a pub struct, let's call it stake so that we know exactly what it's interacting with. And first off, what you do know is that you're always going to need a signer because we're going to have accounts that will need to be created within the stake instruction. It won't always need to be created but sometimes it will so count mutable and this will be public signer. Signer Info. All right, the other one that we'll have to need to create is we're going to have to create the stake info.
00:31:00.004 - 00:32:07.398, Speaker A: So outside of here I'm going to create a different account called steak info just so that we have it and you can easily reference it. So this would be account and pub struct stake info pub we're going to do staked at slot. So what this will do is it'll tell us that whenever that user staked into their stake account we know exactly what slot they staked. Slot is really the source of truth. For time on the cluster there's the ability to use a basically a timestamp but it's not to be relied on because it's kind of like an oracle timestamp versus slots is we know that it's always going to be the correct slot according to the cluster. Finally we're going to create a public key just for error sake of isstaked this or sorry, it's going to be a boolean. This will tell us whether or not the user is already staked and if they are we don't want them to stake more or if they are are not and we're trying to destake later.
00:32:07.398 - 00:33:01.460, Speaker A: We don't want to run into issues. All right, so let us create that stake info for this stake instruction. All right, so here we have, we have account we know that if does the account already if the account does not already exist we want to create it so init if needed. Again the seeds if we looked over here the stake info is stake infoseed in the user public key. So let's make sure we include that. So constants this will be stake infoseed and then signer key dot as underscore ref because it's a pda we always need a bump. We're going to have just as the pair, as a signer, as earlier, one thing to note is this is going to be a token account.
00:33:01.460 - 00:33:41.214, Speaker A: So just as earlier, we're going to need these three accounts always because it is a token account. So let's just add that real quick. And because it's a token account, just like ERT previously, we're going to have to include the mint and then we're going to have to include the authority. So this authority will be itself. So let's name it real quick before we finish that. So public account, public. This will be the stake info account and then this will be an account of type token account.
00:33:41.214 - 00:34:13.270, Speaker A: All right, so the authority is itself. All right, so we have our stake info account. Now we need to make sure that we have the user stake account and actually, yeah, so the user stake account and we're also going to need the gold token account that the user owns. So that's three different accounts that we'll need at this specific time. So let's create that. So first we'll create the one that is their stake account. So just like before, it's another token account.
00:34:13.270 - 00:35:00.322, Speaker A: It'll be in it if needed because we want to create it. If it doesn't already exist, the seeds will be we look here, it's token plus user public key. So constants, token seed signer key as ref because the PDA will have a bump, we're going to have to have a signer in case it needs to be paid for by someone. Just like previously, it's going to be the token mint, equal mint. And then token authority equals itself. So let's call itself so public. This will be the stake account.
00:35:00.322 - 00:35:28.464, Speaker A: So we'll call it stake account. It'll be an account of type info and token account. So just like before, our stake account. There we go. So now we have the stake info account and we have the user stake account. Finally we're going to need that token account that the user already has. So this will be just like before an account.
00:35:28.464 - 00:36:15.936, Speaker A: However, there's a few things that it's not going to be created or not going to be here. So because it's outside the program, this specific account is outside the program. We're not going to do an in if needed because you can do that on the client side. So let's just make sure that we have it's mutable because we're going to move funds or tokens from this account and then it's associated since it's an associated token account. We're going to make sure the mint is the same and then the associated token authority is the signer. So this is because this is being signed by the user, not itself. So this is going to be public.
00:36:15.936 - 00:37:23.824, Speaker A: This is going to be user token account account, info token account. Alright, so if you notice that we use this associated token account and we didn't, we haven't already included that, so we make sure you include it now. And also because we have an associated token account, we're gonna have to need the program here for it as well. So we're gonna have to do pub associated Token pro token program, everything's underscore program info associated token. All right, I have not already imported that so we need to make sure that we import, otherwise we're gonna run two errors. So it's gonna be associated token, associated token. All right, so now we have everything within this struct.
00:37:23.824 - 00:38:00.392, Speaker A: One thing that we need to do is we need to change this and to use stake instead of initialize. Now let's see if it compiles and run it and fix any of the errors that may show up. All right, so compiled everything worked as expected and we're good to go. So we just ran into some warnings just as before. These are things that we have not used. Just for clarity sake, since we are not using the context in the initialize, let's just do that to get rid of that warning. All right, so we have the accounts, now we need to actually implement the staking logic.
00:38:00.392 - 00:38:56.234, Speaker A: Alright, so let's get started that. So first off, whenever I write stake or execute stake, I'm going to have to make sure that I have the stake info. And this is going to be immutable because I'm going to change what the info is provided in there because now we're staking and I want to make sure that I'm grabbing it early. All right, so I have the stake info. Now there's some cases that I want to account for, like for example, if a user stakes but has no tokens, or if the user's trying to stake and already staked. And finally, if you're thinking in the future for like someone that is trying to destake over here, but they've, they're not actually staked, we want to throw an error as well. So let's make sure that we create all these errors or these error codes to be used within the program.
00:38:56.234 - 00:39:37.750, Speaker A: So down here I'm going to create an error code, enumer code, and we're going to create a few errors. So first off, we're going to do message. This message is going to be tokens are already staked. So we don't want to stake if we already have stake tokens. We want to make sure the user de stakes at that point. So we'll call this is staked. Secondly, we'll create the message of tokens are not staked, so they're trying to destake later.
00:39:37.750 - 00:40:21.600, Speaker A: We don't want them to do that if they don't already have tokens. So call not staked. And then finally we're going to have to create them the error message of let's say there's no tokens of stake. So what are you talking, what are you trying to stake for? So no tokens to stake and this will be no tokens. Perfect. So up here what we're going to do is we're going to create those different error responses and then we're going to make sure that we return them if they hit those specific conditions. So first off, if stake info is staked, so we're already staked.
00:40:21.600 - 00:41:02.850, Speaker A: Let's make sure that we return an error error code is staked into, and finally, finally, if the amount, so if they have no tokens or they're trying to stake no tokens, let's not waste compute time. Let's return the error error code, no tokens. All right, now let's get to actual staking logic. I'm going to build this just to make sure. Perfect. So I ran into an issue. This is because it can't find the stake info off of steak.
00:41:02.850 - 00:41:27.816, Speaker A: Let's go down here and realize that. Did I? Oh, it's because it's called steak info account is staked. So it's saying that my stake info does not have is staked. Let's go down here and see what I called. It should be is staked. Let's figure out what went wrong. So what I had here is, is on my stake.
00:41:27.816 - 00:41:49.952, Speaker A: I called this a token account. Instead of stake info, it should be stake info. Let's, and then if I do stake info, it shouldn't need all this other information as well. So let's make sure I remove that are not needed. Right? So we have the stake info seed. It's not a token account. So we make sure I remove everything that's not here.
00:41:49.952 - 00:42:23.630, Speaker A: So this is a problem on my part because it is a custom account. We're going to have to include the space. So space equals eight. Eight, because that's the discriminator that is always required at the beginning of an anchor account, standard mem, size of stake info. Perfect. And so now this should work. Alright, great, look at that.
00:42:23.630 - 00:42:43.754, Speaker A: No errors and we're ready to go. The first thing I want to do is I want to make sure I get the time. And how you get time is you're using a account or a sysvar. That's called the clock. So let's grab that. So use Solana program. Clock.
00:42:43.754 - 00:43:04.614, Speaker A: Clock. Now, because I'm using Solana program, I need to make sure that I include it over here. So program, let's just make sure that is actually Solana program. I believe it's on a dash program. So underscore. And then this would be because I'm using 1.16.0, same exact version.
00:43:04.614 - 00:43:51.274, Speaker A: All right, so now that I have the clock, let us actually grab the time or the slot that at which I am at. So here we go. So over here, I'm going to grab the clock. So let clock equals clock get. I want to make sure that I'm creating the stake info staked at slot. And we want to set that to clock slot, which is U 64. And then stake info dot is staked equals to true.
00:43:51.274 - 00:44:21.454, Speaker A: All right, so I've now set it to the current slot, and I've said that I've already staked. Now let's actually do the stake. So I'm going to do let stake amount equals amount. So this is the amount that I required and we're going to do something special. So because the instruction requires an amount, that's U 64, this is something to consider. Stake slot is unknown field. Let's go figure what I called it, stake at slot.
00:44:21.454 - 00:45:16.074, Speaker A: All right, so that should work. So the amount that say you send from the front end, if it has nine decimal places, which we know from our program, our test, that we created a minke of nine decimal places represented on the program side is actually a one. So one token would equal one with nine zeros afterwards. So we need to actually make sure that we're getting the right amount of tokens instead of the opposite. So say if we just made stake amount equals to amount, we would only have this amount instead. So we need to make sure that we're getting the correct token amount that the front end expects. So we're gonna do a little bit of math here.
00:45:16.074 - 00:46:00.266, Speaker A: So we're gonna do checked multiplication. This is gonna be ten. Use 64 dot power context accounts, mint decimals. So raise it to ten to the power of the amount of decimals so they can get that one with nine zeros instead of 0.00 something something nine or one. So this would be as you 32 unwrap and then we got a transfer. So transfer is a new thing off of the token on SPL.
00:46:00.266 - 00:46:40.758, Speaker A: We're going to make sure that we're including it so that we can actually call it. So transfer, transfer. All right, so let's go back down here and we're going to now call the transfer. So we call Transfer, we'll call CPI context new. So what this is is whenever you're trying to call another instruction off of a different program you need to make sure you use CPI context new. There's also new with signer if I need to sign for it. For this one, we don't need to sign for it because the token account is owned by the signer versus the program itself.
00:46:40.758 - 00:47:51.464, Speaker A: So what we'll do is CPI context new and we will include the accounts. So we're going to do it off of the accounts of the token program to account info. We're going to do the transfer function off of the token program and we're going to do from, so it's from to and then the authority. Alright, so we know that this from is going to be from the token account to the user stake account and the authority is the signer. So what we called it is this is from user token account. So this is actually context accounts, Dot user tokenaccount, dot to account info we're going to do to the stake account counts, stake account to account info. And finally authority is the signer.
00:47:51.464 - 00:48:44.744, Speaker A: And one thing that we are missing from all this is we have the transfer function but what's the amount that I'm actually transferring? So up here we'll do the stake amount and then we should be good. So let's build it and see if it works. All right, so we can see here it built just fine and we're ready to test it. So let's get to testing it. All right, so here we are, we are in the test now and we need to make sure that we create a new integration test for staking. So I'm going to go down here, I'm going to do it, our integration test and do stake. It's going to be a new async function.
00:48:44.744 - 00:49:30.438, Speaker A: Boom. So we're now going to be ready to create a new integration test for staking. If we look back here on the actual implementation, what we're going to have to do is we're going to have to include all these accounts into the instruction used for staking. So we have to make sure that we include all of them just for checking what accounts and seeing what's going on. Let's quickly create the transaction and get all the errors that we're expecting. So we'll do await program methods and this will be just as before. We'll do stake this will be new anchor BN.
00:49:30.438 - 00:49:54.094, Speaker A: We'll just stake one token for now. We'll have to have our signers or I guess for now we don't need that. We're going to just call the RPC just to get it to fail. And then we want to make sure that we log the transaction just so that we can see what's going on. We can do this really quick. Just taking the previous console log. Boom.
00:49:54.094 - 00:50:22.842, Speaker A: All right, so this should fail because we don't have any of the accounts that we had previously. Let's just make sure that it fails as expected. So we go here, anchor test, it'll try to create or initialize it again because it's already initialized. That should be just fine because we do init if needed. Alright, so it failed, the initialized succeeded, but the stake failed. The reason being is we don't have the accounts. That's perfect.
00:50:22.842 - 00:50:52.174, Speaker A: That means it's failing for exactly the reasons that we expected. So let's create all these accounts. So first of all, we're going to create the, let's create the user token account. So user token account equals await. This is how you do it from the SPL token library. Get or create associated token account. What this does is if the token account doesn't already exist, create it.
00:50:52.174 - 00:51:18.834, Speaker A: If it does exist, just get the address. So get the PDA. So that requires a connection. Requires pair, pair requires our mint key pair public key so that it knows what mint to grab from and then the pair pair in case or what, who is the owner? So it's myself. Public key. Perfect. So now we have the user token account.
00:51:18.834 - 00:51:59.706, Speaker A: One thing to note is there's currently no token stored here. So we need to make sure that we mint some tokens so that we have some to actually send over. So let's do await mint two connection pair pair which is the signer mint key pair public key because I need to know which one to mint user token account. So mint to this address. This is the pair pair for the owner. And then we're going to do, we're going to do quite a lot of tokens. So this is just one to the power of, of ten, to the power of eleven.
00:51:59.706 - 00:52:39.234, Speaker A: So quick fix upgrade there we go. So here we are minting some tokens to our token account and now we're ready to create the other accounts. So next up we want to get the stake info count. So let's get the same PDA. So just as before, do public key dot find program address sync. It's going to be buffer dot fr om and it's going to be our specific, our key. So if we go over here, remember previously it was stake underscore info.
00:52:39.234 - 00:53:39.954, Speaker A: So stake info, whoops, steak underscore info. And then it will be also the public key that we had previously or the payers public key, the signer's public key to payer dot public key dot two buffer. And then since it's a PDA, we always have the program id. And there we go, we have the stake info account. Next up we're going to get the, let's get the stake token account or the stake account. So let stake account equals same as before, public key dot find program address sync, the, for the stake account it's token and user public key. So we'll just grab this real quick and replace stake info with token.
00:53:39.954 - 00:54:06.618, Speaker A: Always have the program program id. There we go. So we have, right now we have the user token account, we have the stake info with the stake account. Finally we need the gold token vault. So we're going to go up here, we're just going to copy and paste this vault account. Actually, let's look at the accounts real quick. We have the user account, steak account, stake info, signer.
00:54:06.618 - 00:54:27.034, Speaker A: We've actually done anything else. So we have all the accounts that we need. Let us, let's see what else. Oh, for one thing that we don't have is for this specific address. So this is just getting the address of the stake account. That's a token account, but there's no guarantee that doesn't already exist. So let's, let's create it.
00:54:27.034 - 00:55:03.974, Speaker A: So this be await, get or create associated token account connection. Pair, pair, mint key, pair, pair public key. Let's see. Oh, mint key pair, dot public key. Perfect. So that should be created for there we have the user token count, we have the one off the stake. And then finally now we need to just add them all to the RPC call.
00:55:03.974 - 00:55:50.034, Speaker A: So here we know that the stake of one, we know that it's going to require someone to pay for this transaction. So signers is going to be pair, pair and then we need the accounts. All right, so if you look at here, we can see all the accounts that are required. So we need stake info account, which is stake info. We need the, let's see, we need the stake account which is stake account. We need user token account which is user token account. And then we need, let's see, we already have the mint.
00:55:50.034 - 00:56:10.824, Speaker A: Well we don't have the mint. So mint, that is going to be the mint key pair dot public key. And that is we also need the signer because we don't currently have a signer. Let's see what's wrong with this. Oh, it's not type address. So we just do dot address. Let's make sure that we also include the signer.
00:56:10.824 - 00:56:33.854, Speaker A: So this will be the signer and this is payer dot public key. Okay, so we have all the accounts. Now let's test it. So let's run it. And if we did everything correctly, it should work. If we didn't, let's just debug it and fix all any of the issues. So it's replaying, playing, it's running check and check.
00:56:33.854 - 00:56:54.084, Speaker A: We got two passes. So that means we staked one token to the stake program and everything worked as expected. So that's fantastic. That's actually really exciting that it worked. First try. It's a rare occasion. So finally we need to go do the dstake instruction.
00:56:54.084 - 00:57:39.124, Speaker A: So we go up here, we can see here right now that I'm using initialize as before, we need to create a new set of accounts for the dstake instruction. Otherwise I don't have the right accounts or the context in order to run it. So let's do it. So derive accounts public, struct D stake info. There we go. All right, so we know that we need to have a signer in order to run all this. So we're going to do account mutable just as before.
00:57:39.124 - 00:58:17.976, Speaker A: Pub signer, signer info. And then we need a few other accounts. So we need all the accounts that we have previously. So we need, basically we need all these accounts because we know that we're going to be running with all the accounts. So if you look back here, we're going to be using all these accounts all in this specific instruction. So we're basically just going to copy and paste all the accounts from previous account structs and just make sure we have all of it in the right context. So here we need the user account, we need a stake account, stakeinfo.
00:58:17.976 - 00:58:42.424, Speaker A: We're just going to copy those over. Perfect. And then finally, let's see, we have a stakeinfo, stake account, user token account. We need the vault account. So let's go grab that vault token account up here in stake actually would be an initialize. Here we go, there we go. So we should have everything now.
00:58:42.424 - 00:59:35.524, Speaker A: So four accounts, token vault stake info account, stake account and user token account. Because we're not creating these at this time. We actually don't need all the information every single time. So we can remove all these pairs and signers and just have the seeds and the bump and these will all be mutable because they don't, they already exist at this point. So we don't need init if needed. Alright, so we have all the accounts in our dstake now let's create the actual implementation of dstake here. So if we go up, we're going to go up here, we're going to set the context as d stake and we're going to start writing the logic.
00:59:35.524 - 01:00:18.432, Speaker A: So here what we have is we are going to first, just like in state construction, we're going to do let stake info equals mutable context accounts dot stake info. All right, so now we have the stake info. Actually just for test, we're going to do anchor build just to make sure we did all those accounts correctly. All right, so perfect. That told us something real quick. Is it stakeinfoaccount? I think everything else worked though. Yep, everything else worked.
01:00:18.432 - 01:01:00.552, Speaker A: Alright so stake info, what we want to do is just like in the stake instruction, we want to check if the stake info is staked but we want to make sure that it's not already, it's not unstaked or de staked. So stake info dot is state return error, error code not staked. So we don't want to try, have someone try to de stake if they're not already staked. That would cause issues. It's kind of like a security vulnerability. So let's go here. We're going to grab the clock.
01:01:00.552 - 01:01:48.374, Speaker A: So the clock equals clock get and we want to figure out the amount of slots passed since the original time that we staked. So we'll do let slots underscore past equals clock slot minus stake info. Stake at slot. All right so now we know how many times how many slots has passed. Now we need to also get the current stake amount that we have. So let's stake amount equals contacts dot accounts dot. This is going to be the stake account dot amount.
01:01:48.374 - 01:02:21.406, Speaker A: All right, so we have the amount, we have the slots passed. Now we need to basically calculate the reward. So let's calculate the reward real quick. So let reward equals, so this is kind of like where we need to think about it. I'm going to make something very simple as the reward. I'm going to make the reward, just let's say one token per slot. Most other stake programs, they don't necessarily do this.
01:02:21.406 - 01:03:06.930, Speaker A: They do kind of like a token amount based off of the percentage over the circuiting supply per slot. That way they kind of give a specific curve of amount and they know what the end date. Here, I'm just giving an amount. So anybody that stakes it doesn't matter how much you stake. You could stake one token, you get one per slot, or you can stake 100 tokens, you still get one per slot. So as homework, what I would recommend is mess around with changing this reward parameter. Try to make it based off of the total amount they stake versus just a set constant amount per slot.
01:03:06.930 - 01:03:58.278, Speaker A: All right, just for ease of use, as stated, slots passed as U 64. We're going to just do checked multiplication. So for each slot we're going to do, let's say one use 64 dot, pow. Actually this would be ten, right? Yeah, ten. So for each slot passed, we're just going to do one, one token. So get the correct amount by doc accounts, mint decimals as U 32 and unwrap. All right, now we need to do a few things.
01:03:58.278 - 01:04:31.814, Speaker A: We need to do two different transfers. We need to transfer the rewards that you got to your gold token account. And then finally we need to transfer the current stake back to the token account. So let us do the first one. So let's do the vault one. So if you remember that the vault, it was the authority of itself. So it's a PDA, you need to be able to get the signer in order to sign for the transfer from the account back into the user owned token account.
01:04:31.814 - 01:04:50.634, Speaker A: So that means you need to get the bump. And this is how you get the bump. You do do context bumps. Get this. I'm going to leave that just for a moment. Unwrap. And so this gets the bump based off of the specific account.
01:04:50.634 - 01:05:25.784, Speaker A: So we'll go down here and this will be the stake account or the, sorry, the vault account. So this is token vault account, and I'll be able to get the bump from there. So here we go. Token vault account. Next we're going to get the signer from the bump signer. So this is how the signer looks like within a program. So three of those and then u eight equals we have our seeds, so constants.
01:05:25.784 - 01:06:17.924, Speaker A: This is going to be the vault seed and then the bump. Perfect. So the vault seed in the bump. Now we can actually do the transfer. So this is going to be like a elevated transfer or an elevated CPI call because we're using the program to sign for a specific PDA. So we'll do just as before. Transfer CPI context new with signer this is where things are getting different because we're signing for PDA within the program context accounts token program because we're going to be signing with the token or we're going to be transferring using an instruction within the token program to account info.
01:06:17.924 - 01:06:54.140, Speaker A: Transfer same as before. It's going to be from to authority. All right, so we're going to be transferring from the vault to the token account. So let's do that transfer real quick. So contacts, accounts vault token vault account two, account info two. We're going to do the user account. So user contacts, that accounts, dot token.
01:06:54.140 - 01:07:39.374, Speaker A: I think it's what user token account two account info and then finally the authority will be myself. So we'll just copy and paste it. So token account. All right, since we need to be able to use the signer to sign for this that we just created, we're going to do signer and then finally we need to transfer the specific reward amount. There we go. So this d stake will calculate the reward. It'll get the signer of the token vault account and then transfer from the token vault account the amount of reward to the user token account.
01:07:39.374 - 01:08:19.324, Speaker A: All right, so we have another transfer. In order to do, we need to also transfer from the user stake account to the user's gold token account in their wallet. All right, so let's do let staker. So we know what's the staker is context accounts signer key let bump bring the bump because we're going to be signing for a different account. Again, context bumps. Get this one's going to be, let's see what I called it. Go to de stake down here.
01:08:19.324 - 01:09:09.164, Speaker A: It's going to be the stake account to the token account. So we're going to be signing for the stake account. Perfect. So dot unwrap and then we're going to get the signer. So let signer type equals just as before the seeds. This is going to be staker as well as ref and then finally I believe is the bump. So slice with a bumper.
01:09:09.164 - 01:09:57.004, Speaker A: Perfect. Now just as before, we're going to need to do the same transfer CPI call. So transfer. All right, so CPI context new with signer. This is going to be the context accounts token program. We're using the same token program to do the transfer transfer from to authority. Alright, so our from will be context accounts.
01:09:57.004 - 01:10:48.124, Speaker A: This will be from the, what is it? The user stake account. So stake account account info. The two will be the same two as before, so it'll be to the user token account and then the authorities itself. All right, so we have it as the signer so that we can sign for it. And then finally we have the stake amount so that we know the amount that will be transferring is equal to the current stake amount. Alright. One thing that I want to do real quick is that the stake info, we want to be able to reset it so that we don't have something that might cause some issues later.
01:10:48.124 - 01:11:27.200, Speaker A: So we want to make sure that we're not considered staked anymore because we de staked. And then just for this is not something that you have to do, but I want to make sure that I do it is that I'm going to set it as the current slot so that if there is any issues, the blast radius is smaller because I'll update the slot. All right, let's anchor build it and see if I ran into any errors. All right, looks like I ran into a few errors. That's all right. Let's go up to the first error. You always go up to the first error to see what's going on.
01:11:27.200 - 01:11:42.844, Speaker A: So type ascription cannot be followed by a method call. Let's go see what that is. That's 101. So right here we're at 101. Transfer. Let's see what I did wrong. Oh, so I think what I did wrong is these are parentheses instead of brackets.
01:11:42.844 - 01:11:58.202, Speaker A: Easy fix. Let's just grab that, make it a bracket instead, and run it again. See what other errors pop up. Looks like. I ran to a few more errors. It says that I don't know what stake account is. Let's see where this is.
01:11:58.202 - 01:12:17.910, Speaker A: This is 107. So stake amount. Did I get the amount anywhere? Yeah, I did get the amount up here. So now I need to figure out why it doesn't know what to do there. Oh, it's because I just don't have a comma. See, these are just very simple errors. Let's see, final error.
01:12:17.910 - 01:12:35.246, Speaker A: Let's see. No field token program. This is in line 82. So accounts token program. Ah, so I just did it twice. That's easy. And boom, we're all good.
01:12:35.246 - 01:12:56.516, Speaker A: So this result may be an error should be handled. Let's see what that means. Unused must be used. That is in line 97. So this right here, let's just see. I believe that's what you're supposed to do to get rid of it. Yeah, so that was one of them.
01:12:56.516 - 01:13:19.204, Speaker A: And then I got to do the other one as well. Perfect. The last warning is self is unused. Let's remove that and run it. Boom, look at that. No warnings because we used all the variables and it compiled successfully. So let's go test it out.
01:13:19.204 - 01:14:01.674, Speaker A: So what we're going to do is we're going to create yet another integration test. And this integration test will be for destaking. So integration test, destake equals async function call. Alright, we need to get all the accounts in order to do the dstate call. So first off I'm just going to grab this transaction real quick, paste it and then we're also going to paste the transaction signature line. There we go. And let's just remove these accounts and the signers and we're going to just have the call of dStake.
01:14:01.674 - 01:14:44.490, Speaker A: All right, so we're de staking, we're calling the, the RPC call. Now we know that from previously we need to have the, all the accounts that are required for this instruction and the payer in order to pay for this instruction. So we're gonna do signers, this is gonna be payer dot pair and dot accounts. Alright, so let's go fill these accounts. We need all these different accounts. What's great is previously we got all these accounts already. So it actually makes it really nice for us.
01:14:44.490 - 01:15:21.788, Speaker A: So we can just do this, get all these accounts, put them all here. We don't need them into anymore because it already has some amount in it. So we have the user token account, we have a stake info, we have a stake account, we still need the vault. We don't have the vault. So let's go grab the vault from up here. All right, so we have all the accounts now. So we have the user token account, stake info, account, stake account and the vault account.
01:15:21.788 - 01:16:13.984, Speaker A: So let's fill this out. So stake account will be stake account, stake info, account will be stake info. This will be user token account will be the user token account address because it's not an address, it's called a, let's see, it's called an account. So we have to make sure we get the address. We have the vault account, which is the vault. We have our signer which is pair public key and we have, and finally our mint, which is mintkey pair public key. All right so we have all the accounts, we got all the accounts and we're trying to do the following.
01:16:13.984 - 01:16:49.154, Speaker A: Our instruction should pull tokens from the gold token vault, move them to the gold token account. And then also pull tokens from the user stake account and pull them and destake them into the gold token account. And finally, the stake info should be updated. Now, if we run this, this should run into an error and it believe it should be. If I'm not incorrect, it should be zero x one. So let's get it. Let's see if we hit that error and then we'll explain what it is.
01:16:49.154 - 01:17:05.022, Speaker A: All right, perfect. So we ran to an error. D stake Zero X one. Custom program error zero X one. So let me explain what that is. Okay, so Zero X one, let's think about it. We ran into an error for destaking.
01:17:05.022 - 01:17:52.548, Speaker A: What could that mean? So as mentioned before, we're grabbing the rewards from the token vault, putting them into our token account, grabbing the rewards from their user stake account, and putting into their token account. If we look up the error, so zero x one is coming from token. So we can see zero would be error, not rent exempt. Oh, but zero x one would be insufficient funds for this operation. So transferring from one of these token accounts is telling us that it does not have the funds to transfer from that token account back to our user owned token account. We know that we deposited the funds to the user staking account, so we know that there's already funds there. However, that gold token vault never received funds.
01:17:52.548 - 01:18:20.408, Speaker A: So it's just sitting there with zero funds and we're trying to grab rewards from it. And essentially because we're doing that, it has zero funds, we're running into this insufficient funds error. So let's go fix that. So going back to the test here, we know that this vault account does not have enough rewards. So let's mint a bunch of the tokens to that vault account. So what we do is we do await mint two and it's connection. We need the pair.
01:18:20.408 - 01:18:41.704, Speaker A: So it's once again, pair, pair. We'll need the mint. So mint key pair, public key. We will need to make sure that we're minting to the vault account. The owner is pair, pair, or this is the authority. And finally, we want to just mint a whole bunch. So let's just do 1021.
01:18:41.704 - 01:19:31.550, Speaker A: So what this does is this is making sure that we're minting a bunch of tokens to the vault account to guarantee that we have enough to distribute as rewards afterwards. All right, so let's run the test and see if it works. So if everything worked just fine, then we should have it initialized, it should stake and then destake. So look at that. We have all three passing and we have completed running the test and checking that our staking program worked, both initializing staking and and destaking. To reiterate what we did, we created a stake program that allowed people to deposit their tokens in it and get rewards of the same token. There are a number of things that you can do with this.
01:19:31.550 - 01:19:55.264, Speaker A: Like, for example, the original example given the woodcutters generating wood by depositing those woodcutter tokens and generating the wood token. In our case, we took our gold tokens from seven seas and generated even more gold tokens. So look out for the rest of the boot camp, and thank you for joining us. Bye.
