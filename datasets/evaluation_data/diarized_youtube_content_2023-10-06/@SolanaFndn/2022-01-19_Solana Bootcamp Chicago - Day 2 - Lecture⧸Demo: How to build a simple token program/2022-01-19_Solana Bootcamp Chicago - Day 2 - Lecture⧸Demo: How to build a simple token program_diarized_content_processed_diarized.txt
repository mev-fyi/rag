00:00:04.320 - 00:01:11.566, Speaker A: So, before we start the lecture on the token program, I wanted to cover a few misconceptions about project one that I encountered while kind of talking to different teams. The first thing is I see a lot of people trying to do something like taking some object like an echo buffer, and then doing something like try from slice into the account. This is generally not a terrible idea for most things, but most people have implemented it by having some sort of vector of u eight being the content of this buffer. So something like this. Sorry, the handwriting is a little messy. Let me clean this up a bit. So the problem with this is it's technically correct, but because we're using Borscht to deserialize the way that Borscht represents vectors is not necessarily just spec based on the parameters provided inside that documentation.
00:01:11.566 - 00:02:11.428, Speaker A: So Borscht does something for vectors, where the first four bytes are going to be the size of the vector, and the remaining bytes, that's going to be four to size of size of t times size. This is actually the content of the vector. In reality, what you'll be wanting to do for the echo buffer is just copy things directly into that piece of data in the account. So that's one of the first misconceptions that I encountered while talking to all of you guys today about different things to be doing here. The other one is regarding the create account call in the system program. This is somewhat important. I should have went over this a little bit more in the previous lectures.
00:02:11.428 - 00:03:02.194, Speaker A: But when you create a new account, this is actually breaking up three different steps that are required to allocate some account in Solana. So in Solana, every account has some amount of space. You have some space, you have some land ports, and you have an owner. Each of these has a separate instruction that's used in order to assign the values. Before you can allocate any space, every account needs to have the necessary soul to fund the rent that's required. So the first step is doing a transfer. You need to do a system transfer of Sol such that the account has sufficient land ports to allocate the space.
00:03:02.194 - 00:03:27.134, Speaker A: The second step is going to be an allocate. This will actually give you the space that you requested in that createaccount call. And the last one is assign. This will explicitly change the owner of the account to the public key that's specified here. And just to elaborate, this is a public key. This is some integer. And this is also some integer.
00:03:27.134 - 00:04:09.838, Speaker A: So these are the three steps that you need to do, or that actually happen under the hood, when you call the createaccount instruction, and there's a difference between there's a separation here and there's a reason why this ordering is important too. You need to transfer the soul first before you allocate, because otherwise you don't have the rent exemption necessary. And then the assignment is important. Or you need to allocate before the assignment, because both of these are writable operations. These both write. And that's because in steps one and two, the owner is the system program. In the assign step, that's when the ownership changes.
00:04:09.838 - 00:04:48.064, Speaker A: So at the end of credit account you've transferred the SOL and you've allocated the space. Now, after the assign, the owner becomes the program id, or whatever you specify. This is a parameter into that instruction. If you look at the JavaScript code or the python code, you'll see that the assignment takes in some owner as a parameter. And after these three steps run, the owner will be changed to the program that now has access to write the buffer. So yeah, these were the main misconceptions I wanted to clear up before starting the Luxon token program. Once you know this, I think it should be relatively straightforward how to proceed.
00:04:48.064 - 00:05:47.354, Speaker A: Now you kind of know why that program id is set in the client side. When you call create an account, this owner is explicitly set to the program id of the Echo program. So when you pre allocate that buffer, it does a transfer allocate assign all in one step, and you don't have to worry about that after the fact. But I thought it was important to bring up how this works in practice by breaking up this instruction into the three constituent components. The main focus of this lecture is somewhat to talk about the token program, but also just to talk about general system design and state management in smart contracts. So the token program is the standard in Solana to represent the transfer of different tokenizable assets, and it's really quite simple under the hood. What I wanted to conceptualize for you in this lecture is just how you can think about the token program from a very base level.
00:05:47.354 - 00:06:42.452, Speaker A: There are only two real concepts you need to pay attention to. One of them is called a mint. A mint just refers to a token type. So really how you should be thinking about this is a token type, and this could be a number of different things. This could be like USDC, this could be sold, this could be BTC, it could be any arbitrary token type that you define, and the other object is called a tokenaccount. The term account is incredibly confusing in the solana, like when you're working with Solana, because it can refer to a lot of different types of objects. Generally, I will refer to accounts that represent your token holdings as token accounts, and I will represent system accounts.
00:06:42.452 - 00:07:19.604, Speaker A: If I mention the term account, normally I will be referring to the system account that just represents the raw data buffer. But there's a distinction there. A token account is a user account, or it's a user. I would call it. Maybe user metadata is a better terminology here, but this refers to the amount of a particular token type or mint that a user has access to or owns. And really the number of fields that you need to include in this. And the base most simple version of this protocol is really small for the mint.
00:07:19.604 - 00:08:18.174, Speaker A: All you need to include is an authority. This is a public key. This is the public key of the system account that has access to mint more tokens, right? So this is like who can mint more? And the other is the supply. So this is just the total circulation of that particular token type, or mint like total circulation in a token account. It's pretty similar in the amount of data you need to store in the base case in a very simplified token program. Just to clarify, this is not the actual token program, it's a much simpler version. You only need to store the amount of token you hold.
00:08:18.174 - 00:09:22.840, Speaker A: You need to store who's the owner. So this is just going to be the public key, uh, that has ownership over this particular, this amount of token, um, and that that public key will have to sign for any transactions that change the content of that amount. So public key, um, needs to sign mount changes. And lastly, you need to know the mint that this token account corresponds to. And this guy is just going to point directly at this mint object, right? So now we have some sort of hierarchy that we can pay attention to. There's going to be one mint per token type. And for that mint, there could be a number of different token accounts and users can have multiple, um, there is, uh, uh, there, there is a canonical way to do this in Solana, and I'll cover that in a bit.
00:09:22.840 - 00:10:08.224, Speaker A: But really all this is, is this is a token account, um, that represents the amount of a token that someone holds. Uh, and both of these account types are going to be owned by the token program. Um, and this is just pretty simple, um, like as a conceptual level of how things work, right? Um, and when you work with tokens, there are really only a few operations that you need to support. You need to support a transfer instruction. Oops. This will just transfer some amount between two users a burn instruction. This will take tokens that you own and delete them from the circulation, and a mint instruction.
00:10:08.224 - 00:10:55.384, Speaker A: And there are a few other things, but these are the functional operations that can change the quantity of tokens. These two will change supply, and this will change ownership. So what I want to do now, after kind of discussing the overview of this really simple token program, is just implement this in rust. And when I'm done with the implementation, I will open up the source code for the actual token program and, and just show you how similar the two actually are. Because in reality, this program isn't all that complicated. There's a lot of validation that's required. You can imagine that when you're transferring tokens from place to place, you need to make sure that you can't transfer more than you have.
00:10:55.384 - 00:11:40.210, Speaker A: These quantities cannot go negative. You need to make sure that the signers are the appropriate public keys, given the context of the instruction. But as long as all of these things are accounted for, the actual corelogic is really simple. You're just adding and subtracting numbers. Okay, let's go here. All right, so let's talk about the state first. So for that struct mint, there are only a few things I wanted to add.
00:11:40.210 - 00:12:12.004, Speaker A: I want to know who the authority should be. It should be a public key, and I also want to know what is the current supply. That should just be a U 64. I implemented some helper functions here to sort of like help me load and save the data. I have a load instruction here that will first try to deserialize the mint, but also validate the validation. In this case. Right.
00:12:12.004 - 00:13:09.878, Speaker A: I wanted to add an account tag just to differentiate between the different types of objects I can support. In general, when you're building systems for the first time, it's a good idea to have some sort of distinguishing thing for your different account types. In this case, it doesn't particularly matter, because the mint and the token type have different sizes. The number of bytes they hold are not equivalent. But if it were the case that they did have equivalent sizes, there are potentially malicious things you can do to the program where you pass in a type that does not match the true intended type of the object, and that could be kind of scary. Luckily, in this case, that isn't necessarily something that could happen, but it's something that I would highly recommend that when you design programs on chain, you should account for. Because, again, as I mentioned in a previous lecture, all of these programs are acting on unchecked input because you don't know necessarily what's being passed to you.
00:13:09.878 - 00:13:45.784, Speaker A: It's important to validate as much as you can. So adding this account tag should be a really easy way to distinguish between mint accounts and token accounts. Now I'll do the same thing for the token account and just implement the interface really quickly. So I'll have a tag, I'll just be account tag. I need to have an owner should be public key. I need to have a mint, which should correspond to the mint type that this token account represents and also need to have an amount. So this is the quantity of the token that the owner has of this particular mint.
00:13:45.784 - 00:14:40.664, Speaker A: For both of these structs, I have a couple helper functions that will help me grab like unload the struct from an account info. I have a load, unchecked a load, and I also have a serialize function for the load I want to validate to make sure that this token account or this mint account actually comes from the right source. And that's where I use this tag variable. So I can just check if self tag, it's not equal to account tag of mint. Then I'll return an error. This is fairly equivalent for the token account. Okay, so now the state is basically set up.
00:14:40.664 - 00:15:15.006, Speaker A: It's really simple. We only have a few fields on every account type and then now we can implement the actual logic. So I have a series of just five instructions I wanted to build out here in the real token program, there are more of them. But to just demonstrate really simple functionality, I want to be able to initialize a mint account, initialize a token account and do mint burn and transfer. Should be pretty easy to do. I've already implemented the first two initialize instructions because I felt that, oh, never mind, I guess I haven't. Ok, I guess I'll just do everything then.
00:15:15.006 - 00:15:49.544, Speaker A: So let's start from scratch. If I want to initialize the mint, and I know I'm passed in the Mint account and the Mint authority, it should be fairly easy. I can just set the authority equal to the Mint authority key and I can set the supply equal to zero. Okay. For the token account, it's very much the same. I can first set the token account. Oh, I forgot a step here.
00:15:49.544 - 00:17:05.148, Speaker A: When I initialize it, because the tag needs to be set, the tag should represent a mint account at this point. Account tag, right. So same thing with the token account. When I initialize it, the account tag should be equal to token account, the owner should be the owner that's passed in the mint should be equal to the mint and the amount should be equal to zero. Importantly, we want to make sure that the mint that's passed in is actually a proper mint. And that's what we do here with this mint load step. Because the mint load has a built in validation, it will ensure that this mint type is set properly.
00:17:05.148 - 00:17:42.446, Speaker A: So if we look at that function here, when we load it, we'll make sure that the tag is equal to mint. And the only way that the tag will be set to mint is if initialize mint is called in the first place. So it's important to have these sort of validations in place. So your program is guaranteed to be safe when working on different inputs, because again, everything you have here is unchecked. So you need to make sure that there's no attacks that a user can put in to provide inputs that can cause your program to enter undefined behavior. The mint instruction should be pretty straightforward too. There are only a few things that need to change.
00:17:42.446 - 00:18:46.304, Speaker A: So we've loaded in the token account, the mint account, and these are both checked. So the only way that I can even hit the core logic where we change data is after both of these things have been initialized in the first place. We also make sure that the Mint authority is assigner. Because this is a field that we set on. Because this is a field that we set on the Mint account, we can make sure that not only is the Mint authority signing this transaction, it also matches the Mint authority that's found in the Mint object. So we can do something very similar here where we assert that the authority on the Mint object is the same as the Mint authority key. Now that this is in place, the only thing we need to do is just take that amount that we see here and add it to the token account just to be safe.
00:18:46.304 - 00:19:55.244, Speaker A: So there are two things that we need to change on the Mint account. We need to make sure that the supply gets updated to the proper size. And on the token account we need to make sure that the amount gets updated, and that's really about it. There is a security bug here, and we'll come back to this later. In the burn instruction, everything should be pretty much the same as before, but now the owner is assigner. Like with the previous instruction, we need to verify that after the owner assigns, the owner is also the same owner that we find on the token account object. After we do so, we can just subtract that amount from the target account.
00:19:55.244 - 00:21:36.694, Speaker A: And lastly, for transfer, it's going to be a simple swap between two different token accounts. We first, again, check that the owner is a signer, and the next thing we need to do is we need to guarantee that the owner corresponds to the owner of the source token account, and that's it. So at a very basic level, this is exactly what the token permit is doing. The only additional complexity comes from when you like, add additional features to different operations that can be done. So an example is that the token program supports this delegate operation where you can assign another public key to have custody of some of these tokens. So the amount that is in the token account, you can assign some of it to be accessed by another user. That's a feature that it provides.
00:21:36.694 - 00:22:28.882, Speaker A: It also provides the feature to freeze certain accounts. So a token account state can be in a frozen, it could be frozen, and that could prevent the user from transferring or burning any of the tokens in that particular account. So there are additional features that it provides, but at a base level, the main functionality of the account is just accomplished with these few fields. One thing that you have to be careful of is because you have, again, unvalidated input from the user. If I were to call mint and I had the minthe authority, and I know what this amount is, I can control this however I want. Luckily for this, it's not the most important thing in the world, but it is possible that this amount is passed as an incredibly large number. So you should check for a numerical overflow, because all the numbers you're dealing with here are all u 64s.
00:22:28.882 - 00:23:07.184, Speaker A: So an attack would be like if amount was passed in any of these instructions, like say, amount is equal to U 64 max value. This could cause a lot of stuff to overflow. So the min supply would wrap around and go to zero in like a really small number potentially, and so would the token account amount. So you can be pretty, you need to be careful about like the inputs that are passed in. Likewise here for burning. There's no reason that you should be able to burn any amount that's greater than the total amount. So that should be a fairly easy check to add, right? So you can just fail in the case that the amount that's passed in is larger than the token account amount.
00:23:07.184 - 00:24:40.324, Speaker A: And the same thing is true for transferring. After doing all of these steps, I think this program is fairly complete. It's possible that there are a few other security bugs that I have not caught, but it just shows you that it's necessary to be very diligent about the different things that you need to do. When working with state management on Solana, I forgot to decrement the supply here. Mint supply, yeah, so this is a really simple mutation of the token program. Obviously it doesn't cover everything, but just to sort of demonstrate how close it actually is to the core logic, I'm going to open up the legitimate token program and go over the different things that it actually does. So, Solana token.
00:24:40.324 - 00:25:17.438, Speaker A: So let's just go over like a transfer instruction. So it has a source account, it has an expected mint. That's a bug I forgot to do in my source code. I can change that real quick. I'll go through this and I'll modify that to represent that. This actually needs to be the same thing as well. Um, you have destination account and you have authority.
00:25:17.438 - 00:25:41.554, Speaker A: Uh, and this should be approximately the end of the input that the token program processes. Um, notice how most of the stuff it does here is just validation. Um, it's checking that the account isn't frozen, it's checking that the amount matches the amount. Like the, the amount is of a reasonable size. Um, it checks that the mints are the same. There are a few other things it does. Uh, it checks for delegates.
00:25:41.554 - 00:26:58.324, Speaker A: This is another additional feature of the token program that I didn't implement in the simple version, but all it is is just really additional feature. The core logic of that transfer happens here, where you take the amount and then you subtract it from the source, and then you add a destination, and then it just serializes the object, essentially equivalent to the source code that we just wrote. So I think a lot of times when we're thinking about these programs, it's good to sort of break them down into base principles and also think about what kind of state needs to be represented when we're building out the smart contracts in the first place. So, let's resolve the bug in that code. So, one other additional check that you'll need to do when you perform a token transfer here is you need to check that the mints match between the two different accounts. But once you do that, then I think that covers almost everything. Yep.
00:26:58.324 - 00:27:46.278, Speaker A: So given these changes, I think that's essentially this should give you a glimpse into what designing a slightly more complex system would require. In the Echo program, there really isn't much stuff you need to do to modify state. Most of that just involves copying data to and from different buffers. But when you start working with more complex systems, like you will with the second project, you'll need to sort of understand the types of validations that are required to check the inputs that are passed into your program and also know the different ways, like the different fields that are necessary to encode into the different accounts that you create in the first place. That's really all I have for this lecture. It's pretty straightforward. Just wanted to go through a really simple example to show you that building these smart contracts really isn't rocket science.
00:27:46.278 - 00:28:28.908, Speaker A: Most of it is just thinking about what you need and building it cleverly into the structs that you're allocating and assigning the accounts to the using PDA's. Maybe occasionally, if the accounts require that, yeah. So do I have any questions from the audience? Cool. The only other piece of advice that I would provide here is just that if you're ever in doubt about how something works, you should just always read the source code. There's a lot of it generally, but it's really not all that scary. If you want to figure out how particular CPI interface looks, you should just go into how that instruction is implemented. It will tell you the exact format that you need to pass in, and you just implement that and things should be okay.
00:28:28.908 - 00:28:37.204, Speaker A: If you want to know how the internals of the token program work, you can just read the source code and figure out exactly what it's doing with all the inputs. Yeah, thanks so much.
