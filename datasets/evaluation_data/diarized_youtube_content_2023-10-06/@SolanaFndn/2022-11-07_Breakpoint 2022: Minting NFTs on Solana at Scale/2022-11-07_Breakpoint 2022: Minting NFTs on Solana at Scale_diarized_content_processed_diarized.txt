00:00:04.480 - 00:00:21.846, Speaker A: This is amazing. My mom's never going to believe this. Thanks all for being here so early on a Saturday. Echoing Josh, there's a lot of other places you could have been. We know you went out hard last night. Thanks for coffee and being here. My name is John.
00:00:21.846 - 00:00:31.454, Speaker A: I'm the tech lead on the NFT team here at the Solana foundation. And I'm so happy to be on stage here with Noah and Austin. I'm going to have them introduce themselves.
00:00:32.514 - 00:00:38.174, Speaker B: Hi, I'm Austin. I'm a protocol engineer on the metaplex side. Enjoyed working with these guys.
00:00:39.154 - 00:00:58.334, Speaker C: Yeah. My name is Noah Gendotra. I'm with laps. It's a pleasure to be here. A year ago, actually, I was in the crowd, so it's kind of crazy to be here now on the stage talking about NFTs with Austin and John. So super excited to be here and talk with you guys.
00:00:58.914 - 00:01:46.422, Speaker A: Awesome. And we do want to do a quick shout out to Jerry. I don't know if he's here, the professor, you know, this is a lot of his work that we're presenting up here. So credit to Jerry, I don't see him in the crowd. But at the Solana foundation, you know, we're here to help grow the adoption of the Solana network, obviously by different efforts, like throwing events like Breakpoint, as well as looking into the technology and understanding how this is going to fit for companies and teams of all sizes. And one of those things, excuse me, one of the things that we've been thinking about, too, is like, how is this going to scale? So we spend a lot of time talking to big companies. We spend a lot of time talking to different teams and seeing where their constraints are.
00:01:46.422 - 00:02:17.400, Speaker A: And some of the things that have come up that have been the most obvious places where Solana just doesn't yet scale to are things like games. Games want to be able to issue millions of digital assets as nfTs. They want to be able to do this on behalf of their users. They want to be able to do great experiences for their users. They don't want to have their users have to think about Sol or you, the tokens and things like that. They just want it to work. Enterprises want to be able to do the same thing.
00:02:17.400 - 00:03:19.806, Speaker A: They want to say, hey, I have hundreds of thousands, if not millions of users. They all need an NFT. I want to be able to provide it to them and give them this super slick experience and kind of graduate them into the world of web3. And so when we think about these kinds of things, we really do want to make sure that the tech can actually handle that kind of scale. Now, the other piece, too, is like, as we evolve the idea of nfts, as we understand different things like identity and thinking about how that's going to end up kind of merging as our identities, our sort of personal identities, increasingly become digital, we want to also think about, like, what does it mean for many more people to be on chain, especially on Solana? So we have this grand vision of a billion people with self custody. And when we think about minting nfts at scale, we don't think about one person with a billion nfts. We think about a billion people with one or many nfts.
00:03:19.806 - 00:04:05.112, Speaker A: And so how do we enable that with the technology? And where are the places where this is just not feasible? So the big thing, if you're familiar with nfts metaplex nfts on Solana, is how much they cost. And I think so, you know, there's four accounts. The thing that you're paying for when you're minting an NFT is the account space, right? The rent for these accounts and storing all those bytes on chain. And this is fine at the first 1.012 sol. I'm going to disclaimer, not financial advice, but this is like, you know, 30 or $0.40, right? And this works well for individuals.
00:04:05.112 - 00:04:47.954, Speaker A: But when we think about scale and we think about millions of nfts. 12,000 sol. I don't have 12,000 sol. Like, I don't think anyone has twelve. Sold is a soul, right? So this is just not feasible for a company to be able to say, hey, I want to mince nfts on behalf of my users and let them, you know, represent something, maybe their identity, things like that. I'm so happy to be able to be on stage here to present the technology that we've been working on and just doing for months now, and to be able to really dramatically change this particular slide. So the thing that we're going to be talking about, and we're going to be saying this word a lot today, we're going to be talking about compressed nfts.
00:04:47.954 - 00:05:42.652, Speaker A: And just to really, like, make it clear how freaking awesome this is, with compressed nfts, we can mint a million nfts for five sol, we can mint 100 million nfts for 50 soul. This is a game changer for all of the things that we can now envision when minting nfts is as cheap as a transaction on the Solana network. And this slide is missing a bottom line here, which is we can do a billion nfts for 500 sol. I don't have 500 sol, but someone probably has 500 sol somewhere. And what's really incredible about this cost comparison thing here is twofold. Like one. Again, no one has 12 million sold for this.
00:05:42.652 - 00:06:17.204, Speaker A: This 500 sol is actually predominantly transaction cost, the actual on chain account space needed to store a billion nfts. It's like ten soul. Someone here has ten soul. So this number is something that can change over time as we explore and really mature the technology around compressed nfts. But when we look at this cost savings 24,000 times and we talk to companies, this is magical. This is that moment where they can actually do the things that they've been wanting to do and not have to push this cost to the user. This is really great.
00:06:17.204 - 00:06:43.824, Speaker A: So how does this actually work? Like, what the heck is this? Are we just making things up? Like, you know, what's going on here? So how is this so inexpensive? Compressed nfts, just like any other NFT, get minted through transactions that we get sent to the Solana network. None of that changes. The big thing here is that we're adding a second layer here around indexing. And the indexers really help make sure that we're powering dapps and wallets and that sort of stuff.
00:06:44.724 - 00:06:45.492, Speaker C: Under the hood.
00:06:45.548 - 00:07:26.618, Speaker A: Compressed nfts are structurally identical to the current metaplex nfts that you're already familiar with. And the big thing here is that that per account rent that we were talking about, that 0.012 sol, that part is the part that's being compressed, so the NFT itself is structurally identical. The thing that we're taking out is the actual account space part of it. I talked a little bit about indexers, and the big thing here on indexing compressed nfts is, as I mentioned before, we're minting these nfts and updating them, all that sort of stuff. They still go through the smart contract, they still go onto the ledger, and they still go through the typical consensus mechanisms. That part is not changing at all.
00:07:26.618 - 00:08:23.934, Speaker A: All that is on chain, the big piece here is that that data gets emitted into the ledger, and that information is where the indexers are looking for to provide the information that we're going to need for dapps and things like that. I know that this still feels vague, and that's why I have Noah and Austin here to go through the details. The key piece about this is if we have indexers powering a lot of the flows that we need for these client applications. We have all this off chain data that we need to make sure works with our on chain smart contracts. And this is a really important piece is how do we actually trust that even though we've emitted this into the ledger and this indexer is doing something, that the indexer is actually going to provide the right information that we can validate when we're doing updates, nfts and all that sort of stuff. Stuff. So to go through the actual details here, I'm going to send it over to Noah.
00:08:26.754 - 00:09:10.784, Speaker C: Hello everyone. I'm here to talk about how we solve this at labs. So as you guys know, we're talking about Metaplex compress nfts, which we've been working with, with Austin from Metaplex on for a while. And also, again, a gigantic shout out to Jerry Zhao, who helped us out and architect this and designed this. So without further ado, the two constraints that we had to work with when helping Metaplex come up with compress nfts was that compress nfts depend on indexing. So that indexing has to be one publicly available and operable by anybody in the ecosystem. So it has to be open and available on the ledger.
00:09:10.784 - 00:10:25.364, Speaker C: And the second was that the compressed nfts, when they're served, we have to make sure that the data that's served by the indexer is safe from malicious edits or other corruptions. We solve both of these problems with account compression. Account compression is our way of allowing metaplex to trustlessly index compressed nfts. What this diagram here shows is that when you're minting a compressed NFT, the compressed metadata is logged via the SPL no op program, which is actually executing a CPI. And that CPI data is the compression of t metadata that is being indexed and picked up by the metaplex read API. And so when it's time for you to list or sell or transfer that compressed NFT, the metaplex read API not only serves you your compression of t data, but also a proof that that data was not tampered with in any way. And so what we're showing here on the right is that when it's time for you to execute that transaction, the metaplex compress NFT program cpis into account compression, which verifies the state was not edited since the time that it was logged.
00:10:25.364 - 00:11:22.304, Speaker C: So how does this all work? Well, under the hood, account compression is using merkle trees to guarantee the state of all compressed nfts. What this means is that the compressed nfts are hashed into 32 byte leaves of a merkle tree, which are all hashed together into a 32 byte merkle tree root. When it's time to actually use your NFT, along with the verification proof, those are hashed together to compute a merkle tree root which is verified against the on chain merkle tree root. If both of those 232 by hashes match, then the transaction will continue as normal and you can execute normal NFT operations. If they don't match, the transaction will fail. So that solves our constraints. But now we have a new problem.
00:11:22.304 - 00:11:53.184, Speaker C: Miracle trees can only handle one update per block, as many of you might know. Now, as John brought up, we have high expectations. We expect to have a billion people with one NFT each. One update per block is not going to cut it. We have to have more updates per block. We have to find a way to get around this. So, to talk about how we got around this, I first have to explain what the problem is.
00:11:53.184 - 00:12:50.244, Speaker C: And so what I'm going to show you is the problem inherent to merkle trees, and then talk about how we solve them with account compression. What I'm showing you here is a merkle tree. Merkle trees are used to secure and associate a list of data with a 32 byte hash. So the white boxes here at the bottom is a list of data with arbitrary information in it. That's what the row a, b, C, D, e is, along with some empty items in between. What we do is we hash each leaf into 32 bytes, and then we hash all of those 32 bytes together again and again and again until we get a single root. When we talk about verifying the existence of a particular NFT in this tree, what we're doing is we're hashing the path from that, from the NFT in the tree into its leaf node, up to its parent, up to its parent, and then all the way up to the root of the tree.
00:12:50.244 - 00:13:44.924, Speaker C: When referring to merkle tree proofs, we're talking about the adjacent nodes, which are the minimum amount of information necessary to hash the computed root of the merkle tree when we're talking about when we want to update a compressed NFT. So for example, I want to transfer it, I want to sell it, et cetera. We actually have to perform two operations. The first operation is we have to verify the computed root, which is what we need the proof for. The proof, in addition to the actual compression of t itself, are used to hash all the way up to the root, which gets us the computed merkle tree root. Once that is verified, against the on chain root, we can then update the compress NFT. So here I'm representing that with an updated row at the bottom, which has an updated path all the way up the tree.
00:13:44.924 - 00:14:37.048, Speaker C: So that's it? We're just executing an update against a tree. The issue is that when we imagine a mercury tree processing two updates at the same time, there's a clash. This is a geometry problem specifically. Oh, my apologies, but I can see it doesn't line up perfect. But there's two updates, right? The first update for Merco tree lands within the block perfectly, which is shown in pink. When we process that second proof, which is shown in green here, what's happening is that the proof is now out of date. The top left green node here in the proof is now out of date because that node at the top left has changed.
00:14:37.048 - 00:15:12.184, Speaker C: The miracle tree has been updated. So what this means is that we're not able to compute an accurate on chain root that matches with what we expect it to be. So all of our transactions after the first are going to fail. So that's what we had to design around. And this is what we solved with concurrent merkle trees. Again, this is in large part thanks to Jerry Zhao, with which we express much gratitude. So concurrent merkle trees are designed to handle multiple updates per block, and we do this with an operation that we call fast forwarding.
00:15:12.184 - 00:16:07.174, Speaker C: And what fast forwarding allows us to do is it allows us to take this conflicted node here, which is shown with that collision, and we're actually able to update the proof in green. So that way, rather than having an outdated proof, that proof gets updated and then now becomes a valid, we can compute a valid route from it and then execute an updated change. Concurrent miracle trees are awesome because they allow us to handle up to 2048 updates per block. That allows us to take full advantage of the Solana runtime and update these trees as many times as we want in a block without sacrificing the normal hit that you would expect from using a Merkle tree. So this is not that complicated. There are four steps that are necessary for metaplex to use this. Well, I'll try to break you down.
00:16:07.174 - 00:17:01.554, Speaker C: There's four necessary steps for metaplex to mint you a compressed NFT. You have to create the normal metadata arguments, which is shown here. Then you have to log that using a CPI into the SPL know program, which is picked up by the metaplex read API. The third step is you use the on chain kecat hash function, which which associates the new NFT with a hash. And then you have to CPI into account compression to make sure that the numerical tree updates and that proof, the updated proof and the updated state of the tree is indexed by the Metaplex read API. Now I have great news. Austin here has already done all the hard work for all of us, and this is already done by the Metaplex compress NFT program.
00:17:01.554 - 00:17:50.644, Speaker C: So just before I hand this off to Austin to talk about the metaplex read API, I just wanted to recap that we solved a problem, which is what happens if the indexer is wrong? Well, if the indexer is wrong, your transaction will simply not go through. We talked about that with the Merkel trees. But the second amazing thing which Austin and the Metaplex team have worked on so diligently is creating an open source standard so the metaplex read API can be operated by anyone. So if the data is wrong, you yourself can operate the metaplex read API and reconstruct the information necessary to edit and update your compress nfts. And with that, I'm going to hand it off to Austin to talk about the Metaplex read API and compress nfts.
00:17:52.244 - 00:17:53.356, Speaker A: Yeah, okay.
00:17:53.500 - 00:18:52.094, Speaker B: Hey everyone, thanks for coming. I'll just start off by saying it's been an honor to work with the Giga brains at Solana Labs and Solana foundation. You want to shout out some of the OG compression crew, Larry Wu, Steven Lucher, and everyone in the Chicago hacker house that was listening in and shouting out, no, that's a bug that's not going to work. Yeah, thanks, Noah. So the Metaplex read API, like he said, is not just some service that Metaplex provides. It's open source implementation against the specification for serving NFT data much faster than the current Solana RPC does. Which is a really good thing, because metaplex dapps now typically require some custom indexer or a bunch of caching, or an RPC provider that's extremely forgiving and has their extremely fast nodes like Triton here.
00:18:52.094 - 00:19:56.264, Speaker B: But I'm happy to say that the Metaplex Read API is a disaggregated sort of open source system that's already been implemented by two RPC providers. Triton, who's here? Amazing RPC provider and Genesis go as well. Yeah, yeah, shout out to them. Amazing engineers. This open source code base provides an API not just for compressed nfts, but for regular nfts and for a lot of metaplex open source protocols on chain. Where we really needed the Metaplex read API was to be able to serve the Merkle proofs as Noah mentioned, the Merkle routes are stored on chain and some information about how to cache different changelogs and paths and blah blah blah blah blah, all the super gigabrain stuff. But we needed a way to get the proofs down to the SDKs and the Dapps and the apps so they can transfer, so they can decompress, so they can fuse it and all these other cool things.
00:19:56.264 - 00:20:53.644, Speaker B: So the Metaplex read API follows the ledger and serves proofs accurately. And like he said, if one indexer goes down, or if one of the RPC nodes starts to become malicious, you can switch over to the other one. It's very similar to the Solana RPC in that the data is derived off of the blockchain and served to the user. Our hope here was to create a way for metaplex Dapps or Dapps using metaplex APIs to be much, much faster. Hence we're indexing regular nfts as well. Yeah, we have multiple people running this. We have wallet providers integrating, and now instead of having to do get program accounts and jump around at different byte offsets, you can simply call out to some RPC endpoints and get results back in milliseconds instead of minutes.
00:20:53.644 - 00:21:46.098, Speaker B: We do have some limitations. Currently, three nfts can be edited in one transaction because of the transaction size limitations. But that's actually gonna, that's actually, you know, that limitation is getting loosened because of lookup tables and things like that. Nfts in the same tree are processed serially in the sense that you can still do concurrent updates to that tree, but your updates to that specific NFT need to happen in serial, which I think that makes a lot of sense. Interacting with compressed nfts is now becoming much easier due to SDKs. And like we said, the read API, we have some example code. We already have soulflare integrated it, so that's how easy it is.
00:21:46.098 - 00:22:35.104, Speaker B: Also there are gigabrains as well. Currently you might have some questions about what you can do with compressed nfts. Like the slides say, you can mint them, we have a listing protocol that works with them, you can transfer them, freeze them, but we hope to support all the functionality that current metaplex nfts can do, like fusing, staking, fractionalizing and things like that. So the compression contracts are available on Devnet and Mainnet if you really want to go chew the glass. But we have several RPC providers that have implemented the read API, including Metaplex has an instance, and we'd love for you to come over to our booth and check it out. We can help you get started with that. I'll hand it back over to John.
00:22:35.104 - 00:22:38.268, Speaker B: Great.
00:22:38.356 - 00:22:59.944, Speaker A: So just to kind of pull all that together, the things that we want to take away for compressed nfts, one, they're cheaper, much cheaper. Much, much, much cheaper. Very, very cheap. Very inexpensive nfts for everyone. This is really important. The second part is that you're going to need an indexer. Likely you can use the Metaplex read API.
00:22:59.944 - 00:23:17.762, Speaker A: You can use the metaplex hosted services. You can use Triton, Genesisco, any RPC that has this support. If you feel like it, you could write it yourself. You can take this stuff off the shelf. It's all open source. All the data is on the ledger. You can write this indexer yourself if you want to, and implement the Metaplex read API.
00:23:17.762 - 00:23:49.830, Speaker A: Just make it really, really simple. And the last piece here is that it's all secured by the account compression program itself, which is part of the Solana program library. So we mentioned a little bit about some of the providers and the different places that have this kind of support for the people who are building, now is the time to do it. All these contracts are on Devnet as mentioned, and account compressions on Mainnet as well. We've been working with the gigabrains at Soulflare. Solflare has support for compressed nfts. Go use it.
00:23:49.830 - 00:24:21.222, Speaker A: Thank you so much, solflare. We have service providers also using compressed nfts, Crossmint. If you mint APIs with the Crossmint API, it'll mint compress entities. Awesome. There is a couple more informational panels happening on some of the other stages later, talking a little bit about some of the more business use cases and that sort of stuff. As Austin mentioned, there's a metaplex booth over there. There's devs there to get you set up, get you started, and thinking about how to use compressed nfts.
00:24:21.222 - 00:24:42.060, Speaker A: We're going to go to this next slide and see if it works, which is a video. And someone give me a signal if this is not going to play. I don't know if this actually, I can't interact with this. No, hey, no video. This never happened. So go forth and biddle. Like, use some mint, some compressed nfts.
00:24:42.060 - 00:25:08.262, Speaker A: Thank you so much for listening to us talk. And we have time for questions. So there are some handhelds here. If you guys want to line up next to the mics, go ahead and you can stand up and line up at that mic there and ask the question questions just so everyone can hear and we're happy to answer any questions. Yeah, go ahead.
00:25:08.318 - 00:25:13.174, Speaker C: Yeah, hi, I just wanted to ask.
00:25:13.294 - 00:25:14.286, Speaker B: Is that going to be.
00:25:14.350 - 00:25:19.606, Speaker A: So, for example, a compressed NFT is going to show up in soul scan or in the explorer, a similar way.
00:25:19.630 - 00:25:20.774, Speaker C: That nfts show up now.
00:25:20.814 - 00:25:21.086, Speaker B: And if.
00:25:21.110 - 00:25:25.390, Speaker A: Yes, what would be search for? What would you, what would be put.
00:25:25.422 - 00:25:26.678, Speaker C: Into the, into the query?
00:25:26.726 - 00:25:32.586, Speaker A: For example, like with a regular NFT, we just, just put in the token address. Right. With the compressed NFT, how would it look like?
00:25:32.730 - 00:26:19.220, Speaker B: Yeah. So currently explorers, like, if you copy paste, because no one's ever typed a full mint address by hand into an explorer, you'll just see a transaction. It won't pull the metadata and stuff. We're going to work with all the explorers and if they want to implement it, I think they will. They're extremely fast to implement new stuff, but because there's no data, only the routes are on chain and all that data is bundled up into that root, there's nothing for the explorer to grab onto unless it calls out to the read API. But the id of the compressed NFT, when you decompress it is the mint address. And so we keep that same id for the whole lifecycle of the NFT.
00:26:19.220 - 00:26:25.194, Speaker B: So I do think they'll implement, implement it soon. If you're an explorer here, please do that.
00:26:25.494 - 00:26:59.364, Speaker A: Austin did say the word decompress. We did not put this in the slides yet, but this is actually really important. So we have these compressed nfts that live in these merkle trees. But there are times that you need to use that. With an old contract that only expects NFTs decompression, we can actually take one of these leaves and actually decompress it back into account space into the prototypical metaplex NFT, you know, today. So you could decompress it, use it in a smart contract, and if it's on token 22, you can recompress it back into the tree to do it. So that, that's how the sort of interoperability.
00:26:59.364 - 00:27:07.196, Speaker A: So that address is a mint address. It is a public key, just like you're expecting from any other entity. Thank you, Brent.
00:27:07.380 - 00:27:37.874, Speaker B: Hey, so you talked about this being under open source. I know that Metaplex just changed their open source license for some other projects. Can you talk a little bit about what the licensing is that you moved from AGPL to something else? How does it all work? Yeah, I'm not super up to speed on that. I can't actually remember what the license of the read API is. I believe the license only changed for the contracts. Consult your tax professional. I have no idea how all that works.
00:27:37.874 - 00:28:07.854, Speaker B: The read API stuff is a permissive license. Please don't use it to do evil things. But it's running, it's open. We want people to run a bunch of different implementations under the same spec. We want people to contribute to it, make it better. Shout out to caveman Loverboy from the Genesis Go team for fixing bugs in his fork and not pr'ing them back and making me find them amazing. Dev.
00:28:10.354 - 00:28:11.050, Speaker A: Sebastian.
00:28:11.122 - 00:28:31.174, Speaker D: Hello guys. So I work on the DaO tooling and governance, and my question is, how generic is the technology you've created? Like, can we not only use this to mint cheap nfts, but also create a cheap governance? Because sometimes even right now, Sona is cheap, but still, the entry to vote and participate in governance is still high.
00:28:32.614 - 00:28:59.884, Speaker C: Yeah, thanks for asking. Account compression is generic. It can help with a bunch of different problems where you have a lot of account state and you want to only verify that account state. And yeah, I think it would work for voting. It could work for a lot of different applications. Yeah, we'll be rolling that out hopefully with some integration soon.
00:29:00.224 - 00:29:01.644, Speaker D: Amazing. Thank you guys.
00:29:06.504 - 00:29:24.564, Speaker C: So my first question is, why do you always use such ridiculous names like bubblegum, candy land? It's really confusing. When I first discovered about the compression compressed nfts, I had no idea what it about.
00:29:25.464 - 00:29:51.634, Speaker B: So I'll take that. So we're a company and an ecosystem that helps people put up really good art, but a lot of it is fun, and some of it is just frankly, like, silly. So it's a silly vibe. We don't do it to confuse people. But I don't think I came up with bubblegum. I'm more boring. I forget who came up with bubblegum.
00:29:51.634 - 00:29:52.386, Speaker B: I think it was the lyrics.
00:29:52.450 - 00:29:54.626, Speaker A: It was gummy roll and then gummy.
00:29:54.650 - 00:29:56.850, Speaker B: Roll, bubble gum purple roll, then.
00:29:56.922 - 00:30:19.774, Speaker A: Yeah, that is confusing. But that's, you know, to your point, we did start it off by calling these different names, like Candyland. The program name in the Solana program library is account compression. Like, that's exactly what it does. There's a no op program. That's all it does is literally no opinion. So, yeah, we definitely take that into account when we're thinking about how to productionize it.
00:30:19.774 - 00:30:24.054, Speaker A: But at the very beginning, it's just like, just, you know, slap a funny name on it.
00:30:24.214 - 00:30:25.674, Speaker B: It's Jordan's fault.
00:30:27.534 - 00:30:28.674, Speaker A: This all is.
00:30:29.134 - 00:30:30.214, Speaker C: Thank you very much.
00:30:30.334 - 00:30:36.014, Speaker A: Thank you. Any other questions? Thank you all.
