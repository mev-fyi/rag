00:00:02.600 - 00:00:40.264, Speaker A: Yeah. All right. All right, guys, I'm here to talk about building Sig, a new read optimized validator in Solana. So first I want to talk about who I am. So, I'm Ahmed, the co founder and CEO here at Syndica, and you can follow me on Twitter. So, Syndica is a web3 native cloud. We initially started the company wanting to build web3 infrastructure, and what we realized is that in order to get web two folks into web3, we have to have that kind of glue layer, which is kind of the cloud.
00:00:40.264 - 00:01:40.014, Speaker A: And so what we do at the core is offer RPC infrastructure via our elastic nodes, offering specialized APIs like chainstream, as well as one click app deployments. So you can deploy your app directly on Syndica. But I'm here to talk about a story of decentralization. So, as an RPC provider, we see a lot, and we see a lot of data. Just to give you guys a sense, we process anywhere 100 to 200 terabytes of data every single month, and we noticed a problem. 96% of all calls made to nodes are actually read calls, which in itself is not a big problem, but we are plagued by slot lag. So what you're seeing here on this chart is nine different providers that we tested, RPC providers over 90 day period.
00:01:40.014 - 00:02:22.412, Speaker A: Anywhere you see darker colors is severe slot lag compared to the ethereum ecosystem. We have some work to do. So we talk a lot about transactions per second, which is great. Any fire dancer fans out there, I'm assuming some cool. But we often neglect RP's, which is reads per second. And this is actually really important to the end user, because the end users are often the ones reading the data. So this kind of shows you a little bit of low RPC, high frequency methods.
00:02:22.412 - 00:03:29.076, Speaker A: So one of them is obviously git program account calls for those of you that are developers, one of the calls that is plaguing the ecosystem, and among a few others, like gettokenaccountsbyowner, these are calls that are very low RP's meaning reads per second, but are often called by different dapps. So, really, slana slot lag is often the result of these read heavy calls. And as part of the slana ecosystem, we wanted to do something about it. So that's where Zig, the programming language, enters, as well as SIG, the new validator implementation that we're writing from scratch. So SIG solves the Reed's bottleneck, and that's one of our goals. It'll also improve client diversity and fault tolerance. If you look at this chart here, we actually have only two live clients running in the Solana ecosystem, compared to Ethereum's nine.
00:03:29.076 - 00:03:59.174, Speaker A: So we still have a lot of work to do. Aside from just introducing client diversity and fault tolerance, we also want to offer unprecedented accessibility. And what that means is we want anyone to be able to read the code base and understand what Solana is doing at the protocol layer. So that's been one of our key focuses on this project. So I want to pass it over to Brennan, Mister X 19 himself, to talk about why. Why is IG.
00:04:00.234 - 00:04:47.314, Speaker B: Thanks, Ahmad. Yeah, so I'm Brennan. I'm one of the senior protocol engineers on the SIG team. And so I'm going to be talking a little bit about the technical details about the project. And really what I want to start off with is why Zig is the right programming language to write a new validator in. And so I think it makes sense to start with what is Zig? And so if you look at their website, they say that Zig is a general purpose programming language for maintaining robust, optimal and reusable software. And that's really our goal with this validator, is to create a validator that's robust, that's optimal, and as well, reusable.
00:04:47.314 - 00:05:41.692, Speaker B: And so we'll dive in to what this really means. So what makes Zig zig? And so in Zig, there's no hidden control flow errors are handled explicitly, optional values are handled explicitly. And so it makes it very easy to understand the code and also read the code. On top of this, there's no hidden memory allocations. And so memory allocations are some of the most expensive operations, especially when you're writing a high performance client. And so, since all this is very clear in the code, it makes it very easy to understand where these allocations are happening and how to improve the performance. On top of this, there's no preprocessors, no macros.
00:05:41.692 - 00:06:06.414, Speaker B: It's a very simple language. That's one of its goals is to be very simple. So in a lot of other languages, there's like 50 ways to do one thing. In Zig, there's only one way to do one thing, and that's how it's done. And so it's very, very simple, very easy to read. There's a lot of patterns that keep coming up because there's one way to do it. So it's very easy to pick up, very easy to write, very easy to understand.
00:06:06.414 - 00:06:53.874, Speaker B: On top of that, it has extremely fast compile times so in terms of a developer experience, you can write code, you can then write tests, you can do fuzz testing, benchmarking, it's a very fast iteration cycle. And so you can write some really good code. And so that's a little bit about what Zig is, what's unique to zig. And so in zig, all the memory is managed manually. And so we think that this is required for high performance systems that are read and write heavy. And that's exactly what the validator is. And the best part is that zig allows you to do that in an ergonomic and very readable way.
00:06:53.874 - 00:07:57.670, Speaker B: So basically what this allows you to do is to write really low level code while also maintaining readable code. So to talk a little bit more about this, when you're managing your memory yourself, you get a lot of performance benefits because you get fine gain control over those expensive operations, but it's also kind of dangerous, so it's prone to bugs, memory leaks, seg faults, double freeze, you name it. And so sig, since it's a modern programming language, it basically has a lot of features to help you write safe code as well. And so one cool thing it has is memory leak detection. And so when you're writing tests, basically what happens is at the end of the test, it makes sure that all memory that's been allocated has been freed. And if it hasn't been freed, then you have a memory leak. And so you can see here on the top left, we have some code that allocates memory to the heap, but it's never freed.
00:07:57.670 - 00:08:49.154, Speaker B: And so Zig's really nice because it has really descriptive error messages. And so it tells you there's been a memory leak, and it tells you exactly at what line that memory was allocated that was never freed. So it makes it really easy to write safe code as well as debug and fix that code. And so on top of this to fix that, a very common memory pattern in Zig is to have one line that allocates the memory, followed by a defer statement that deallocates that memory. And so defer statements are basically allows you to run code once the scope ends. And so it's very easy to understand the memory control flow of this is where it's allocated, this is where it's deallocated. And so you understand that you're not having memory leaks and it's very easy to read.
00:08:49.154 - 00:09:38.354, Speaker B: So that's the first statements, which we think are super powerful. And then there's a lot of other cool things that we can talk about. So, Zig, one thing is that it has custom memory allocators, so it makes it really easy to implement, basically custom memory allocation strategies for high performance. And it does this while maintaining readability, which we think is really important. Another really cool reason why we chose Zig is because it makes it very easy to use existing C code. And so you can see just using a cimport statement and pointing to the C header files that you want to import, you can basically use that C code as native zig code. And so you get all the benefits of c, as well as the readability of Zig.
00:09:38.354 - 00:10:28.094, Speaker B: So this is awesome, because there's a lot of battle tested high performance C code bases that we would love to use in our validator, and this makes it very easy to do that while also getting all the benefits of zig. And so speaking of high performance C code bases, we're activate actively collaborating with the fire dancer team to basically know how to write the best validator we can. And so there's a lot of collaboration between the c and the zig teams, which we're super excited about. The team's awesome. So shout out to firedancer. Those guys are killing it as well. Another kind of cool thing that kind of makes it clear that you can write high performance code while also maintaining a lot of readability is SIMD operations.
00:10:28.094 - 00:11:04.364, Speaker B: And so SIMD operations basically stands for single instruction, multiple data. So you're doing one, one instruction across multiple data pieces. And so it's an optimization trick to go really fast. And so you can see the SIMD operations look like just native zig code. You're initializing a and b just like you would an array. You can do addition operations and then array indexing as well. It just feels like native Zig, and it's a very simple way to use a high performance feature like SIMD operations.
00:11:04.364 - 00:12:17.452, Speaker B: And so we talked a lot about high performance readability, and why do we care about readability so much? Why is it like a core priority of the SIG client? And so if you look at the chart, the number of contributors to the validator ecosystem, right now, Ethereum has a lot more than Solana, but we want to change that. We want Solana to surpass Ethereum, to grow the validator ecosystem and make it easy to contribute. And we think the easiest way to do this is to write a validator implementation that's easy to read. And so this will allow any developers that want to learn how the validator works, they can dive directly into the code, read the code very easily, understand what's going on at a fine grain level, and then that'll allow it make it easy to contribute to the code base, to contribute to the validator ecosystem, which will really grow. Just the validator community, which we're really excited about. And so we think when that ecosystem grows, we'll see a lot of cool research, a lot of cool experiments. We'll really get to see what the Solana validator can do when we put all the open source minds on it.
00:12:17.452 - 00:13:03.814, Speaker B: So we're really, really excited about this. And then on top of that, if the code is not enough, we're also releasing technical blog posts which explain the algorithms, the tricks that Solana uses throughout their code base. And so if reading code is not enough, we'll also have these technical blog posts which explain how everything works at a high level, and that'll go along with the code really nicely. Yeah, super exciting. So, on our website at Syndica, we just released the gossip protocol. And so it explains in depth how that works. So you can check that out now.
00:13:03.814 - 00:13:45.862, Speaker B: So that's why we chose Zigg, a perfect balance between high performance as well as readability to grow the validator ecosystem and go really fast. So now I'll talk a little bit about Sig, the roadmap, the progress we've made so far, etcetera. So, in terms of roadmap, the validator is a very big project, so we had to split it up into components that were easy to tackle. And so this is basically the roadmap. We're going to start with the gossip protocol. This is about discovering the other nodes in the network, and it's basically the entry point. Next, we'll work on accountsdb.
00:13:45.862 - 00:14:10.314, Speaker B: This is all about state representation. It's accountsDB is Solana's custom accounts database. And so that'll be the next step. Once we have state represented, we'll work on the state machine, which is the SVM. It's all about processing blocks. And then once we're processing blocks, we'll work on consensus. And so this is processing votes, forks, watching the head of the chain, etcetera.
00:14:10.314 - 00:14:42.454, Speaker B: And once we're following the head of the chain, we'll start to build out the RPC infrastructure, which is all about reading the blockchain data. And so we're optimizing for RP's. So this is the meat and potatoes of it all. And so it's going to be touching data from gossip to accounts DB to consensus, really. We're going to be building this out through all those above steps. And so this is really where we'll finish it off. And then once we finish those steps, we'll have a validator that's able to follow the chain.
00:14:42.454 - 00:15:06.916, Speaker B: So the next step is the leader logic. It's a full scale validator. So this is block production as well as block propagation. So turbine, et cetera. And so, in terms of progress, I mentioned earlier, we finished the implementation of gossip. So we're a very small team. We've been working hard the last couple months, so we're really excited to announce we finished gossip.
00:15:06.916 - 00:15:40.890, Speaker B: So the code's all open source. You can check it out. The zig client is talking to mainnet nodes and communicating efficiently. And we also released the technical blog posts to go along with the open source code, so we're really excited about that. And right now we're working on accountsdb. It's all about representing state efficiently. And so, since we're optimizing for RP's, this is really the important part.
00:15:40.890 - 00:16:12.734, Speaker B: We're doing a lot of research as an infrastructure company that's been operating in Solana over the last couple of years. We have a lot of data that we're analyzing and trying to figure out how we can use those insights into creating an RP's focused validator. And so, going back to the chart, there's really a couple RPC calls that we care a lot about. So get programmer counts. It's very heavy. It's a low RP's high frequency method. So we're doing a lot of exciting research, figuring out how we can optimize it and make it go really fast.
00:16:12.734 - 00:16:18.814, Speaker B: So with that, I'll pass it back to Ahmad.
00:16:21.024 - 00:16:34.884, Speaker A: Everyone. Yeah. Please give a round of applause to Brendan. So, what you see on the screen right now is a QR code. If you scan this QR code, you get airdrop of 1000 soul. No, I'm just joking. I wish.
00:16:34.884 - 00:17:19.044, Speaker A: No, the QR code leads you to our careers page. So Syndica IO careers. We want talented folks to come join the team. If you're excited about building the runtime, if you're excited about building accountsDB or optimizing gossip, whatever it may be, just send in the application. We want talented folks. You don't need to know zig beforehand if as long as you know a modern programming language like C C or rust, it's more than sufficient. And yeah, I think one of the cool important parts about being in the Solana ecosystem is we are building literally the future of the decentralized finance, really, in the whole world.
00:17:19.044 - 00:17:41.844, Speaker A: And to be able to work on a validator. One, it's an honor to be working on this validator, but two, I think it's a huge technical achievement, and anyone that can be a part of it, I think is a pretty awesome thing. So with that, I want to say thank you guys so much for listening in, and we hope you guys enjoy breakpoint. My co founder told me to say this. We are so back.
