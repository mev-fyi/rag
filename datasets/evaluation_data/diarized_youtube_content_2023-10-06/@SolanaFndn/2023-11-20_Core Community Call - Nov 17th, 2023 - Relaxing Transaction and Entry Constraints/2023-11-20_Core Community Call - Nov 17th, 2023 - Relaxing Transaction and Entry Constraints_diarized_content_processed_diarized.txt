00:00:04.160 - 00:00:04.488, Speaker A: Okay.
00:00:04.488 - 00:00:24.434, Speaker B: Welcome everyone, to this month's core community call. This month we have Andrew giving a presentation on two SimD's that he proposed in the past two weeks. It's relaxing transaction constraints and I think entry constraints. So Andrew, you can go ahead and take it away.
00:00:25.564 - 00:00:42.504, Speaker A: Right. I'm going to try and share my screen real quick. Sorry, I'm trying to figure out how to share just the. All right, can you all see that?
00:00:44.084 - 00:00:44.904, Speaker B: Yep.
00:00:45.844 - 00:01:24.764, Speaker A: All right, cool. So yeah, there's two Simd's, 82 and 83, that deal with transaction and entry constraints, uh, relaxation respectively. Uh, mostly I'm going to talk about 82, and if we've got time, I think we can get to 83, which is a lot simpler. I'm going to start off by giving some background and motivation for this work. Um, and then I'll get into like the details of each of the SImD's. Uh, so I started looking at this probably a couple months ago and realized that constraints on transactions aren't documented anywhere except the code. There's no like, document that just says this is what a valid transaction is.
00:01:24.764 - 00:02:04.224, Speaker A: And so that's something I've been working on. It's still not completed yet. But as I was going through that, I realized some of these aren't really necessary. There's a whole host of checks that we do to make sure that transactions can be executed. And these are transactions that could pay fees, and then we drop them very late in the processing pipeline when we could record them and take the fees from them. Except that that breaks consensus right now. So I started going through the process of what if we relax this constraint that transactions have to be executable? Then we could potentially collect more fees if we do see these transactions.
00:02:04.224 - 00:03:22.984, Speaker A: Of course, when I started relaxing constraints, which constraints do we actually need? When I was looking at the other constraints as all of this is going on, we've been having ongoing discussions about asynchronous execution. And so that was noodling in the back of my mind as I was going through this exercise and sort of a background of async execution. There's two questions that we answer on the validator side of things, which is, does this block comply with all the constraints? If it does, then it can go into the history and then the consensus side of things, which is what's the result of this block? And then does the network agree with me? Async execution is just separating these two questions. But right now, because of the way that the constraints are built, they're very much tied together. You can't answer this first question. Does the block comply with all constraints without actually executing the block? Um, so what's stopping us from separating these, at least logically? Right now the synodies are not proposing that we go towards async execution. It's just moving towards separating these two questions logically, but not necessarily making them separated in time.
00:03:22.984 - 00:03:32.184, Speaker A: The only thing that's stopping us is account state on the transaction level. This consists of of mainly four different checks.
00:03:32.684 - 00:03:41.184, Speaker B: Andrew. Oh, so you're. I think you're presenting the keynote, but I don't think it's actually going from each slide to slide just as a heads up.
00:03:43.204 - 00:03:46.984, Speaker A: Okay, let me see how I can fix that.
00:03:47.324 - 00:03:53.064, Speaker B: I don't think it's showing the presentation like the presentation mode when you're sharing just the keynote.
00:03:53.724 - 00:03:54.664, Speaker A: Gotcha.
00:03:56.104 - 00:03:57.724, Speaker B: We can just watch like this.
00:03:58.224 - 00:04:03.120, Speaker A: Okay. Yeah. Can you guys see if I like switch slides here?
00:04:03.272 - 00:04:03.784, Speaker B: Yes.
00:04:03.864 - 00:04:26.468, Speaker A: Yep. Okay. I will not present. I don't know what I'm doing. I guess so, yeah. At the transaction level, this is four checks. Do the alts resolve account lookup tables? If the transaction is a nonce transaction, is the nonce account valid? Can the transaction pay the fees and then can the transaction be executed? The last one's probably like ten different checks rolled into one.
00:04:26.468 - 00:05:10.744, Speaker A: But the summary of it is can we execute this transaction? And SIMD 82 is the relaxation of three of these. So the nonce check, fee paying check, and executable check the SIMD is not a proposal that we remove these checks for execution. All of these have to be met in order for the transaction to be executed. What it is saying is that if a transaction appears in a block, it does not that validate invalidates. That breaks one of these constraints. It doesn't invalidate the entire block. We can either just not execute that transaction and take no fees, or we charge the leader a penalty for including that transaction.
00:05:10.744 - 00:05:59.318, Speaker A: These transactions also will count fully towards the block limits as if they were executed with the maximum number of compute units. That just is there to prevent some denial of service attacks. I had four constraints on the last page and I've only got three here. So I think a natural question is why leave in the alt resolution? That's a temporary thing. It is still making us dependent on account state for the question of is this block valid? But there are higher level constraints at the entry and block level that make removing this true tricky at this time. So I'd like to remove that one at some later point. Additionally, alt resolution is slightly different than the rest of these three constraints.
00:05:59.318 - 00:07:14.064, Speaker A: The rest of these three constraints, the answer can change based on the execution of transactions within the block that you're validating. Whereas the alts are resolved at the beginning of the slot, your view of them is essentially frozen when the slot begins. And so transactions within the block that you're validating can't change the alt resolution. So that makes it so you can validate a block and just answer the question, does this block meet all of the constraints without executing the block, as long as you've executed previous blocks? I kind of already talked about these, and I'm just going to skip a slide and go to the benefits and drawbacks. So like I mentioned, this lets us validate the block. Just say, does this block meet all of the constraints, and can it go into history without actually executing the block? It also simplifies the protocol in some sense, because now there are a lot fewer constraints on what can go into a block. We still have obviously to document like the executable checks, which is the most complicated part, but it separates that from what is a valid, uh, transaction.
00:07:14.064 - 00:08:34.004, Speaker A: It gives a lot more freedom in block packing as well. Um, I'm not suggesting that the labs client do this, but it enables something like a probabilistic fee cash, where if I see some account has 500 sold and they've had 10,000 recent transactions all paying fees, maybe I just assume that they're going to pay their fees correctly and I just record their transactions without doing strict checks, whereas with the strict constraint that all transactions have to pay fees. You can't do something like that in terms of drawbacks, it's consensus breaking. It needs a feature gate. It's not a huge drawback, but just something to note with the nonce check, it introduces the possibility that ancient nonce transactions which are no longer in the status cache could be repeated in the history if the leader isn't doing a good job. Now, we can still check that that nonce account is valid before execution, so the transaction would have no effect on state, but it introduces the possibility that we have duplicate transactions in the history. Depending on how we decide to do punishment for non fee paying transactions, you could have transactions that pay no fees.
00:08:34.004 - 00:09:30.118, Speaker A: And then on the SIMD there have been discussions about potential denial of service attacks. I think the main thing on the SIMD that I missed and did not clarify was the fact that these transactions are still counting towards block limits as if they were executed with all of their compute units, which prevents a lot of the attacks that have been mentioned. The main thing I was hoping for input from you guys on is how should we handle these transactions that can't pay fees. Right now, there have been sort of two competing perspectives on how to handle these. One is that the leader is in running an auction and they are selling. You compute if they fail to collect the fees, the punishment is that they don't get that reward. But there's also this perspective that when transactions pay fees, they are burning half of it.
00:09:30.118 - 00:10:07.494, Speaker A: And that burning implicitly compensates the rest of the network for validating these transactions, which would lead to the idea that if we have these non fee paying transactions, then the leader has to make up for it in some way by either paying those fees or paying some other fee associated with a bad transaction. Yeah, I think we can pause here and maybe open it up for questions and feedback. Is anyone totally opposed to this? What do you guys think about how we should handle these non fee paying transactions? Yeah.
00:10:16.794 - 00:10:18.094, Speaker B: Go for it, Richie.
00:10:19.134 - 00:10:51.494, Speaker C: Yeah, I guess I'll start with. I think this is a great proposal. It puts us further into the direction of bankless leaders. I think the concern of possible Dos by not charging fees at all is a bit of a risk. I don't see that you would want to do this attack, but there is an attack where a block producer could create a maximum size block that is, you know, just contains transactions that always fail. They cannot pay any fees.
00:10:52.514 - 00:11:07.414, Speaker D: So only this is, this would only happen if it's a malicious leader, right? Yeah, because a normal leader is going to filter those. I kind of think that a possible mitigation would be to charge the leader the fees.
00:11:09.414 - 00:11:10.994, Speaker C: Yeah, that's what I'm thinking, too.
00:11:14.014 - 00:11:26.714, Speaker A: I had not written that in the original proposal, but since some discussion has been ongoing there, that is definitely where I'm leaning right now. I haven't changed the proposal because I wanted feedback on this call first.
00:11:29.054 - 00:11:54.634, Speaker D: I don't think we blocked by this attack because if the block limits are enforced, like the compute limits and everything else, it's kind of pretty benign to have a bunch of junk data like, it's okay. Execution should be faster, I hope, right? You like skip, you should be able to fail those quickly in replay, so you're just wasted some of the bandwidth.
00:11:55.494 - 00:12:06.054, Speaker C: It's kind of annoying because it makes the DA layer of Solana, so to say, completely free. Anyone can use turbine to distribute clusterwide junk data and nobody pays for it.
00:12:06.754 - 00:12:11.974, Speaker D: Well, no, you have to have stake to do it. You have to be staked, right?
00:12:12.514 - 00:12:41.224, Speaker C: Oh, yeah, that's a good point. And you don't get any rewards if you don't have identity key balance to vote. So you would lose money if you, you know, if you have zero balance. And, you know, we can't withdraw from the leader as a punishment if it has zero balance, but then the leader would lose out on the stake rewards, thereby punishing it. If we do charge a fee from the leader for these transactions, I mean, it's. That seems like a very simple change to do, right?
00:12:42.284 - 00:12:55.916, Speaker D: Yeah, you'd need to, like, there's a couple dependencies on that. For the leader to be in the leader schedule, their vote account would need to have a certain balance. Right. That would be like, you would add the constraint there so that you wouldn't.
00:12:55.940 - 00:13:03.046, Speaker C: Charge the vote account, you would charge the identity account because. Because this account also gets rewarded with transaction fees.
00:13:03.230 - 00:13:03.994, Speaker D: Yep.
00:13:05.614 - 00:13:44.714, Speaker A: Yeah. I did a quick calculation this morning of basically if the minimum number of slots you can get allocated in the leader schedule is four, if they packed, like, the smallest transactions they could with, like, assuming one signature, it'd be like just under one soul as like, a minimum balance. So I think there's already some ongoing changes to make one sole, the minimum balance. So I don't think we need to make any changes there. And effectively, if they were running an attack like this, it's sort of a self solving problem because they get removed from the next leader schedule.
00:13:47.454 - 00:13:49.074, Speaker C: Why would they get removed?
00:13:50.014 - 00:13:55.854, Speaker A: If we charge, if we take away their stake for punishment on these transactions, we charge them the fees.
00:13:56.634 - 00:14:05.574, Speaker C: Oh, okay. But isn't a mechanism that does this punishment a bit more complicated than just charting the fees or. I might be misunderstood?
00:14:08.234 - 00:14:13.082, Speaker A: I suppose my, what I'm saying is that the punishment is being charged those fees.
00:14:13.218 - 00:14:13.626, Speaker C: Oh, yeah.
00:14:13.650 - 00:14:13.890, Speaker A: Awesome.
00:14:13.922 - 00:14:14.250, Speaker C: Okay.
00:14:14.322 - 00:14:37.044, Speaker A: I think we're saying the same thing. Cool. Another question. I guess if we're leaning towards charging them fees, normally fees are paid 50% to them. Do you guys think that that's reasonable, that they're just like, essentially paying half the fees, or should they be basically burning 100% of the fees at punishment?
00:14:46.084 - 00:14:48.684, Speaker C: Sounds like a bit of an implementation detail.
00:14:48.844 - 00:14:51.544, Speaker D: Yeah, I think that's like, we can figure that out later.
00:14:51.924 - 00:15:07.384, Speaker A: Okay. Yeah, sounds. Sounds good. It sounds like everybody is leaning towards charging the leader fees for. If these transactions don't, or. Sorry. Either validate, invalidate the nonce check or the fee thing check.
00:15:07.384 - 00:15:10.252, Speaker A: Yep. Okay, cool.
00:15:10.388 - 00:15:21.834, Speaker D: It might be easier to charge the vote account. So, like, whatever. Whatever implementation constraints, those would need to be pushed to the, when the leader schedule is generated.
00:15:26.134 - 00:15:27.354, Speaker A: Gotcha. Yeah.
00:15:29.694 - 00:15:40.616, Speaker E: Sorry. If we want to charge the leader all of those fees and they get drained. Let's say they get drained like at the beginning of an epoch, and they still have a lot of leader slots.
00:15:40.790 - 00:15:49.384, Speaker D: That's why they need, they, we will need to have like a, basically a balance check for their, whatever constraint is to be in the leader schedule.
00:15:50.804 - 00:15:54.836, Speaker E: And that would be multiplied by the number of leader slots they have.
00:15:54.940 - 00:15:55.716, Speaker C: Yep.
00:15:55.900 - 00:16:25.164, Speaker A: Okay. Yeah. That, that doesn't strictly prevent them from being drained because there's really, to my knowledge, like, there's no cap. No, like reasonable cap on what fees could be charged. So they could insert a bunch of like max priority transactions, which I don't think we want to enforce that. They can have that many max priority transactions in a block.
00:16:26.544 - 00:16:31.004, Speaker D: What does it matter if they're, what priority they are priority.
00:16:31.824 - 00:16:44.284, Speaker A: It doesn't. For execution. I'm just saying, like, if they insert a max priority transaction that can't pay fees, they have to have that. That introduces the possibility even if we have like a minimum balance, they could still be drained.
00:16:45.424 - 00:16:58.444, Speaker F: Can you just like check before you start executing the block if they have greater than whatever threshold balance, and then you just skip their block. If they do so if they drain it, then they're drained for one block.
00:16:59.304 - 00:17:03.992, Speaker D: You can't, it's really hard to adjust the leader schedule outside of the epoch boundary.
00:17:04.168 - 00:17:04.616, Speaker A: Yeah, yeah.
00:17:04.640 - 00:17:06.524, Speaker F: You would just skip them. You wouldn't adjust.
00:17:07.904 - 00:17:08.400, Speaker D: That's all.
00:17:08.432 - 00:17:09.644, Speaker F: We just be dead.
00:17:10.784 - 00:17:21.044, Speaker D: You can't have, you don't have a guarantee that everyone that's observing the network is in the same state where they decided that that leader should be skipped or not.
00:17:24.544 - 00:17:35.104, Speaker F: Yeah, I guess you would have to make it part of the like, fork choice execution. Like when you start executing the block. Do you think that they have these? Yeah, I don't know. Maybe it's more complicated.
00:17:35.644 - 00:17:50.332, Speaker A: Yeah, I think adding that check would sort of mean that we are adding, adding another constraint that sort of prevents us from async execution because we need to check to be the leader's balance before the block.
00:17:50.468 - 00:17:51.172, Speaker F: Yeah, good point.
00:17:51.228 - 00:17:54.572, Speaker A: Obviously dependent on previous blocks, but this.
00:17:54.628 - 00:18:09.644, Speaker D: Like, the draining doesn't need to cover the fees that you would expect as a network. It just needs to cover the cost, which in this case is just bandwidth. Right. Like, it's just enough of a deterrent that it's pointless to do it as a spam attack.
00:18:11.584 - 00:18:20.604, Speaker C: Yeah, that's a very good point. I would charge them proportional to the size and not charge them the actual fee that this transaction specifies.
00:18:24.524 - 00:18:38.744, Speaker A: Oh, gotcha. You're basically saying don't charge them the fees, but charge them some separate penalty. It's based on the size of the transaction. Yeah. Okay. Yeah, that seems reasonable. Sort of like an implementation detail.
00:18:41.484 - 00:18:43.824, Speaker C: The old Solana fees making a comeback.
00:18:48.584 - 00:19:06.444, Speaker E: So sorry, I want to come back to this, because to me, I think what we should optimize for is still getting people's transactions in, like, liveness number one. Like, if someone can't pay for these extra transactions, but there are still valid transactions in that block, we should probably prioritize getting those executed, right?
00:19:09.064 - 00:19:11.404, Speaker D: I don't follow. Like, what do you mean?
00:19:12.424 - 00:19:22.154, Speaker E: Like, if someone, if someone creates a block, some of the transactions are going to get rejected and they don't have enough to potentially pay for whatever egress fees you want to.
00:19:22.234 - 00:19:46.294, Speaker D: Yeah, those should. The whole block should get executed. There's just, there's just like a cost to the leader to include junk and to make sure that the leader can pay the cost, they need like a minimum sold balance at the start of the epoch in their vote account or whatever account that's hard to withdraw during the epoch. Does that make sense?
00:19:47.394 - 00:19:47.778, Speaker A: Yeah.
00:19:47.826 - 00:19:54.454, Speaker E: Okay. As long as we're optimizing that we can still get transactions in, that to me seems more important.
00:19:58.234 - 00:20:10.394, Speaker D: Well, it's going to be unlikely that somebody has some valid transactions but is also doing a denial of service in the network unless there's a bug in the implementation.
00:20:13.174 - 00:20:26.914, Speaker A: Right? Yeah. I think the main concern with this is that you've got someone who's intentionally putting these transactions in a block rather than, or because of a bug. Like holy mentioned.
00:20:35.514 - 00:20:39.330, Speaker C: Does the SIMD include relaxing the entry.
00:20:39.442 - 00:21:16.270, Speaker A: Constraints or is that separate? So that's what SIMD 83 is. We can move to that. Nobody else have any more comments? All right, yeah, this one's a lot shorter and a lot easier. Right now, entries can't contain conflicting transactions. Um, that's not really too necessary. Uh, I think this is kind of lived on as like a legacy of the old implementation as well as just. It makes it easier to parallelize in the current lab's, uh, code, but it's not strictly necessary.
00:21:16.270 - 00:22:03.014, Speaker A: Um, and this check also depends on us resolving the alts because we can't tell which transactions conflict with each other unless we look at the account lookup tables. So 7383 just removes this constraint entirely and says you can put whatever transactions you want in any entry. This allows for more freedom in the block production. It also allows for more efficient networking. So right now, if I wanted to record like five or ten transactions that conflict with each other, I have to put them in separate entries and those get sent out over turbine individually, whereas now if they're in just a single entry, they can be shredded together and sent out. It's actually one packet. And then.
00:22:03.014 - 00:22:42.974, Speaker A: Yeah, it gets us one step closer to async execution, because now the entry constraints no longer have a dependence on account state. In terms of drawbacks. Pretty minimal on this one. It's basically just that we need a feature gate. And I was talking to Steve yesterday, but I'm not even sure that this is possible right now. The way that the labs client does replay is we receive the entire entry and then we will process it. It might be technically possible where you receive like a partial entry and begin executing.
00:22:42.974 - 00:23:15.274, Speaker A: I'm not 100% sure it is, but if that is possible, this SIMD would make that impossible, because unless you receive the partial entries in the order, you don't know that previous transactions in the entry don't conflict with them. So you sort of have to receive at least in order. Again, I'm not convinced that that's even possible with like the, the way that we deserialize these shreds into entries.
00:23:18.734 - 00:23:23.114, Speaker C: It's a cool idea. I think it's possible knowing the layout.
00:23:24.774 - 00:23:48.494, Speaker A: I mean, transactions aren't fixed size, right? So you have to like scan to find transaction boundary. Yep. Yeah, that was the part I wasn't sure about, is like identifying. If I receive like the 9th shred out of ten, I don't know how to identify where a transaction within that arbitrary slice begins and ends.
00:23:50.754 - 00:24:12.254, Speaker D: Yeah, binning transactions to shreds, that's something that we talked about, but it doesn't really depend on removing this constraint. But I think that would be a totally separate thing. The benefit there is that you could do signature verification of the shred and the transaction totally in a separate pipeline, like as you're receiving shreds.
00:24:12.294 - 00:24:16.950, Speaker C: But it's.
00:24:17.102 - 00:24:21.194, Speaker A: That would be a more complex change. Right.
00:24:24.174 - 00:25:50.144, Speaker C: I'd love to see this constraint go because it kind of keeps the schedulers hands tight behind its back, but there needs to be some upper boundary. Like for example, if like there are two types of clients, you know, I guess like finance and labs or whatever, and one of them consistently has a lower limit on the complexity of a graph that it can execute. It could somewhat split the network. And it's super easy to measure that, because if you have a sequential dependency chain, so, you know, transactions that all write to the same account and they all only load in the same small set of accounts that can completely fit in cache and it's pretty much cpu bulb because it only it's as fast as the VM can execute. If you have a lot of transaction writing to the same account, but all of them also reading a very wide set of accounts, then it becomes data bound because you then have to wait for all of these accounts to arrive every single sequential dependency step. Liam, who can unfortunately join the meeting for Zoom buggy reasons, has also done a lot of research into this scheduling, but I think we might need to come up with some mechanism to have some heuristic how expensive a block is going to be given some arbitrary graph.
00:25:52.424 - 00:25:53.888, Speaker G: Hey, can you guys hear me?
00:25:54.016 - 00:25:54.964, Speaker C: Oh, he's there.
00:25:56.264 - 00:26:27.898, Speaker G: Hey, sorry, excuse the background noise. I'm in an airport right now. I was not able to join for a minute, but I was able to figure it out basically. Yeah, we're working on something to actually like help the network agree on what the actual cost of running a block is in real time. That's outside of the current CU model. We're still working on this and I'm still like passing the idea around and work and kind of workshopping it. But the basic idea is that blocks actually take some amount of time for the network to process as a whole.
00:26:27.898 - 00:27:03.110, Speaker G: It's not just runtime, it's also network distribution time and all these other things. And there could be idiosyncratic reasons why, hey, a block takes a lot longer to send around as well as execute. So we're working on a proposal to address the issue of hey, this block takes a lot longer. Everybody's going to have to wait around and do this XP thing. So leaders should probably have to pay for that a little bit. So yeah, I'm really, I think what you guys are talking about 70, 82 and 83, correct? Yes. I think I'm pretty happy with these proposals.
00:27:03.110 - 00:27:28.144, Speaker G: I think my one big thing is that I'd love to just define what the new constraints, now that we're going to do this thing, what are the now the constraints on transactions. And I know that's a bit of like an exploratory thing to have to do, but, and I'm happy to help figure out what, inspect out what those, actually those, those new constraints now are on like on entries and on and on transactions.
00:27:28.684 - 00:27:49.764, Speaker A: Yep. Yeah. I will work next week on sort of rewriting some sections of the SIMD to be very explicit about what the new constraints are for both inclusion in a block and then for like execution of a transaction. So I'm planning to do that. I just haven't done it quite yet.
00:27:51.064 - 00:27:54.844, Speaker G: That's okay. It's going to take a while to kind of figure this all out.
00:27:55.384 - 00:28:19.634, Speaker A: Yeah. In terms of, like, the cost modeling, I might have misunderstood Richard, what Richard was saying, but I don't think that something new with removing the constraint on entries. Right. Like, feasible, I could just put those in separate entries and still create a block that's very expensive to execute, even if it complies with Cu limits.
00:28:22.934 - 00:28:27.114, Speaker C: I don't know. The constraints on the entry counts, for example, too well.
00:28:30.374 - 00:29:17.364, Speaker G: Another thing to think about, and I brought this up with the call with Andrew and a few others, which is that you have to think about an entry. I may use the term microblock because that's what we call them at fire dancer, but we may call an entry, you will see an entry come over the network, right? And the entry is like one packet coming over the network. And so sometimes they'll come very burst. They'll come very bursty. Or you'll just see one of these, and you want to process, like, it's very easy and efficient to process individual packets, start executing individual packet packets of transactions. And so having this constraint that, like, you can't have multiple rights there slows us down fundamentally, because sometimes it does take. It does like we are doing packet level processing at this point.
00:29:17.364 - 00:29:21.244, Speaker G: So we have to be really careful about how many dependencies introduced.
00:29:37.084 - 00:30:15.304, Speaker B: And just being mindful of time, because we are at time real quick. If anybody wants to continue discussing, well, you're welcome to stay. Keep discussing. For anybody that wants to propose an agenda item for next month, you can propose on the core community call repository here. But, yeah, if anybody has any other questions, go ahead and ask. Otherwise we can continue discussion in the SIMD and on discord. Okay, thank you, Andrew, for presenting, and thank you, everyone for coming for the discussion.
00:30:15.724 - 00:30:17.104, Speaker A: Thanks for giving me the time.
00:30:18.924 - 00:30:21.404, Speaker B: Right. We'll see you all next week, month.
