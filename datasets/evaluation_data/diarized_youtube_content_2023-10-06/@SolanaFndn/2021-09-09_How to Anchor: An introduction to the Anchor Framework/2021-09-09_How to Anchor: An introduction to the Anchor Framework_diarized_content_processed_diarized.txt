00:00:14.720 - 00:00:42.434, Speaker A: Hey, everyone, welcome. Apologies for the delay there on Twitch. I do not know what the error was, but joining us today, we have the man, the myth, the legend himself, Armani, author and creator of Anchor. We also have Chase, who will be joining in and partaking a little bit. My name is Ryan. I help to run the Twitch streams here, and I'm on the product and marketing team. But Armani, this is your stage.
00:00:42.434 - 00:00:52.434, Speaker A: You have some time here. Please ask as many questions as possible in the twitch chat and we'll address them. But, yeah, let's learn how to anchor.
00:00:54.574 - 00:00:58.204, Speaker B: Cool. Yeah. Chase, did you want to maybe start with some questions here?
00:00:58.334 - 00:01:09.964, Speaker C: Yeah, sure. Your mic is down a little bit. Again, you actually let us know beforehand that you historically had issues with Zoom on a regular basis, so not quite surprised.
00:01:10.944 - 00:01:13.592, Speaker B: All right, we will try to try.
00:01:13.608 - 00:01:17.644, Speaker C: To work with what we have here now. Your volume is completely off.
00:01:19.664 - 00:01:21.208, Speaker B: Yeah. How about now?
00:01:21.296 - 00:01:22.216, Speaker C: I'll go ahead and start.
00:01:22.280 - 00:01:22.496, Speaker B: Yeah.
00:01:22.520 - 00:01:59.890, Speaker C: So I'm Chase, developer relations here at Solana Labs, here with Armani. Today's workshop is how to anchor. Historically, the workshops are really just kind of a tutorial, and that's pretty much it. But just considering the guest today who kind of lives behind his Twitter screen and inside of GitHub, nobody really knows. I wanted to just kind of do a little get to know Armani session today. So I'll let you give yourself an introduction really quick about who you are and what you've been up to these past couple of months.
00:02:00.042 - 00:02:23.718, Speaker B: Cool. Yeah, thanks for having me here. So, yeah, so I'm a software developer at Alameda Research, and I spend most of my time these days working on serum and Solana development. So kind of anything related to building tooling or building smart contract related things on the Solana blockchain. Cool.
00:02:23.766 - 00:02:50.974, Speaker C: Yeah, your volume's down again. As we get this worked out, we'll just kind of. It's got some static there, but I think we should be good to go. So I guess one of the biggest questions that I've had personally is, like, how did you really end up working? Like, previously Apple, how did you make it here to serum? Like, how did you make the jump from. From that world to this world?
00:02:51.134 - 00:02:56.750, Speaker B: Yeah, so when I finished college, I started.
00:02:56.822 - 00:02:58.714, Speaker C: Your mic's cutting out again. I'm sorry.
00:02:59.494 - 00:03:18.974, Speaker B: Okay. Yeah, so when I finished my career, when I started my. When I finished college, I started. I started at a, you know, my first job out of college, and my microphone just like, continuously is not working. This is going to work unless I actually solve this problem.
00:03:19.714 - 00:03:21.602, Speaker C: Yeah, it's not working at all right now.
00:03:21.738 - 00:03:33.266, Speaker B: Let me. Yeah, maybe I should maybe log off here and then try to reconnect. I think that might be the course of action here. Sorry, folks. We're good right now.
00:03:33.290 - 00:03:33.922, Speaker C: Let's just go with it.
00:03:33.938 - 00:04:25.536, Speaker B: Okay. Okay. Yeah, yeah. So, you know, I started. My journey is kind of, like, similar to, like, basically like, other people's journeys in the sense that, like, I started my career, and then eventually, during the 2017 2018 crypto boom, I saw what was happening in crypto, learned about ethereum, and then that really caught my attention, and I thought it was really cool technology with a really cool group of people behind it. That just was very obviously the most exciting thing going on in tech at the time, from my perspective. Pretty easy decision for me to just, like, leave Apple and then, like, kind of jump into crypto.
00:04:25.536 - 00:05:25.564, Speaker B: And at the time, I really didn't have an. I didn't have a plan. I didn't have, like, an immediate job or anything. And about, you know, a couple of weeks after I left, my friend Nishad had messaged me and, you know, told me about this new trading company that he was working at called Alameda Research. And that's how I got involved with Alameda from the trading side. I was there for a little bit in 2018 and eventually left to work on Ethereum and other blockchain related things. And then once Alameda started working or getting more interested in doing DeFi related things on the actual blockchain, I came back when they started working on Solana and serum and getting involved with that ecosystem.
00:05:25.564 - 00:05:31.264, Speaker B: So, yeah, that's kind of like my roundabout way of how I got to where I am today.
00:05:31.564 - 00:06:22.610, Speaker C: Yeah, it's cool. It's like, I get a lot of questions daily from developers being like, how did you make that jump? How did you even make the decision to do that? It's really just one of those things you kind of. It's when, you know, you know, sort of thing. Like, for me personally, it's going to be different for everybody, but I think I speak for everyone when I say that thankfully, your friend for introducing you to Almeida, and thankfully, you being here to build what you've built and kind of leading into that, like you've described to me yesterday, in the simplest form, is anchor, as, like, essentially could be considered the ruby on rails for Solana development, and only in the fact that it's a lot simpler than to actually build on Solana native or rust. But what is anchor?
00:06:22.762 - 00:07:26.330, Speaker B: Yeah. So you could kind of attack it from a couple of different directions, but in short, it's like an opinionated framework for developing smart contracts on Solana. And with that there comes a lot of different tooling. There is tooling for writing the smart contracts themselves, which provides a bunch of blackmagic macro code gen for generating a bunch of code from a much simpler API. There's also a well defined interface for these programs. If you're coming from Ethereum, you might be familiar with the notion of the AVI there anchor defines this IDL format, which provides a common format for programs to talk to each other. This is super convenient from the perspective of composability and just from the perspective of productivity, because what you can do if you have this well defined format is you can basically write code that generates more code to streamline and automate the process of communicating with programs.
00:07:26.330 - 00:08:49.224, Speaker B: I could have one smart contract and then generate clients for it in multiple languages. Whether it's typescript, go, rust, c, hash, Java, it doesn't matter. And so there is a big productivity boost to have a tool like this in the ecosystem, because it basically means that I can talk to any program that's exposing this IDL interface without having to worry about rolling my own clients. And so you can start then looking at this from a product perspective. If you're familiar with Ethereum or Etherscan, you can have this pretty magical experience where you can go through a block explorer and see all the contracts and have nice uis for interacting with them, and see all the instructions decoded and look at all the program state that's all available because there's a well defined interface. And so with anchor, with this idL, and with all the tooling around it, the hope is to be able to have a similar type of experience for Solana, but of course targeted at the Solana runtime, which is a very different beast than from the EVM. And so, yeah, that's kind of at a high level, kind of what it's all about.
00:08:49.224 - 00:09:30.624, Speaker B: And basically the reason why it was originally started was actually for security reasons, for productivity reasons, but also for security reasons. When we get to the, to writing the smart contracts themselves and some of the demos later, you'll see more what I mean about this, what I mean by this, but basically it allows you to also not only be more productive, but also, I would say one of the goals is to allow one to be able to reason about the security of one's programs in a much more tractable way, because you can just look at less code and reason about less code, which I think is just easier to reason about.
00:09:31.174 - 00:10:17.148, Speaker C: Yeah, for sure. And like you mentioned, this is an opinionated framework. And like, you're kind of referencing the way that a bunch of different things like structures and deserialization, serialization, and a lot of these, like, it's always a question. It's like there's not a standard way to do things. And like, talking to the engineering team at Solana Labs, it's like that's kind of a feature, not a bug. But the more and more you spend time in Solana discord is, the more you find out is that people want an opinion, they want a direction, and maybe they find out that opinions not what they want, and then they can go learn rust and they can do it on their own. And maybe in the, in the distant future that there's an option on, on anchor to actually select a different type of structure or serialization or serialization method.
00:10:17.148 - 00:11:21.744, Speaker C: So lots of, lots of potential there. So I guess the next question is, you kind of already answered this, who should use it? And what I'm seeing over the course of the past two months is probably less than 50% to close to now, maybe 75 or higher percent of developers going straight for anchor. And I think it's just because of the learning curve is not as steep as learning rust native. And like you said, this is very familiar, a lot more familiar to solidity developers than it is to, than rust or Solana native, which is amazing. So I guess one other question I have. What should people that are using anchor know about it? Is there anything, I guess you kind of covered that already, but is there anything else that people should know about anchor? Maybe like just some kind of, like tldrs before building with anchor? That might be some gotchas, and if not, that's also fine.
00:11:21.864 - 00:12:13.404, Speaker B: Yeah. So in terms of gotchas, I think, yeah, I mean, there's probably a couple of things to point out. So, firstly, I think the goal is that it is eventually a true zero cost abstraction in the sense that there is no performance penalty for using it. But that's definitely not the case right now, although it doesn't really matter unless you're trying to really optimize every compute unit. And for some programs, that's pretty important. For the serum order book, that's pretty important, and I think we'll eventually be in that state pretty soon. But the main things I would consider in terms of gotchas are how does Borscht fit in with your program? If Borsch is inefficient, then maybe you might not want to use anchor because that's a serialization format it uses for instruction data.
00:12:13.404 - 00:13:02.558, Speaker B: That hasn't really been a problem for me in practice, but I've heard from at least one person that that may or may not be a problem. Probably the other one is going to be stack size restrictions. Right now, the Solana stack size, it's, I think, something on the order of like 4 kb or something. I don't remember the exact number, but there is some optimizations that we need to make to the actual smart contract cogen to make better use of the stack. And that is going into details right now that's probably not useful for most of the chat. I would basically say for most people, you're probably okay using anchor. If you are in the situation where you're not okay using anchor, then you probably know you're in that situation.
00:13:02.558 - 00:13:13.194, Speaker B: And it's pretty easy to rip out the code gen and rip out the macros and just do everything from scratch. There's a pretty easy way to eject out of the framework if you really need to. Cool.
00:13:14.254 - 00:13:32.630, Speaker C: One final question before we get into this demo, and it's really, I think, one of the one, maybe it's a two part question and maybe I'm putting you on blast here, but when anchor version 1.00.0, like the official, I'm assuming audited version before you. Yeah, yeah.
00:13:32.662 - 00:14:40.444, Speaker B: So this is super important and it's something that I really want to push forward to like towards like very soon. I think there is probably 1ft gun that I'm, that I'm aware of that we need to eliminate before that. Basically there is like, you know, if you. Again, I'm getting into details here, but there is, there's a footgun that needs to be eliminated that is like, you know, just one, one more thing to check off the list that'll just like make programs more secure. TLDR is that if you have duplicate mutable accounts inside of your program, then you need to ensure that they are unique because otherwise, you know, programs might do unexpected things. But um, there's just some, I'd be comfortable once that feature is out, and then after that, then maybe there should be some ecosystem discussion about serialization format, whether we want to use borscht, what the method identifier format looks like right now. It's a simple version of sigh that Ethereum uses, but without the instruction arguments.
00:14:40.444 - 00:15:01.348, Speaker B: There's some conversation around that type of thing, but I think we're super close, probably maybe a month away from serious conversations about this, so pretty soon. I'm super excited for it. I think it's super important. I would love to get everything audited and push it a little harder after that.
00:15:01.476 - 00:15:09.212, Speaker C: Yeah. Having that first official version that's been audited, that's whenever it gets real. And I think a lot of people are going to be super excited.
00:15:09.348 - 00:15:10.140, Speaker B: Yeah, totally.
00:15:10.252 - 00:15:17.142, Speaker C: That's all I had for you. So I guess now I'm going to go ahead and drop off. You can share your screen and we can get to some code.
00:15:17.308 - 00:15:18.306, Speaker B: Yeah, sounds good.
00:15:18.410 - 00:15:20.186, Speaker C: All right, man, talk to you in a bit.
00:15:20.290 - 00:15:48.274, Speaker B: Cool. Let's see how I can work with twitch chat here. What my plan to do here is to let's share my screen first. Let's see if this works. Cool. All right, can everybody see my screen? Twitch chat? Can you let me know? Great. Okay, cool.
00:15:48.274 - 00:16:15.934, Speaker B: Before getting started, it's probably worth pointing out some materials that everybody can use because you'll inevitably forget everything that I say. Yeah, bump up the font. Sure. Yeah. So here's the GitHub. So just project serum anchor, and there's a couple of things to point out here for when you're developing on your own. So first we have the docs and the tutorials here.
00:16:15.934 - 00:16:52.996, Speaker B: This is pretty bare bones, but it's a good way to get bootstrapped and learn some of the APIs. But the first thing I would do basically is read this. There's some tutorials there. Then furthermore there is API documentation for Rust, we have the rest docs and then for typescript, for the typescript client we have some API docs as well. So in addition to that we also.
00:16:53.020 - 00:16:56.572, Speaker C: Have, they're asking you to bump it a little bit higher. Sorry to interrupt.
00:16:56.708 - 00:16:57.372, Speaker B: Oh, sure.
00:16:57.468 - 00:17:01.744, Speaker C: And you can turn your video off, I think, as well, just to make it even bigger.
00:17:02.884 - 00:17:29.468, Speaker B: Turn my video off? Sure. Stop video. There we go. Cool. Yeah, so we have documentation and then examples. So this test directory here has a bunch of examples you can go through. And so documentation is definitely not up to date with respect to all of the features.
00:17:29.468 - 00:17:58.676, Speaker B: So definitely read through this test directory and then the examples that we'll be going through here. Armani is not comfortable with the Gui. That is correct. I actually am quite bad with software in general, but yeah, the examples we'll be going through here are all in this directory. With that said, those are some resources. Now let's actually start looking at some code. I will not actually, uh, write code from scratch.
00:17:58.676 - 00:18:32.304, Speaker B: We'll just go through the examples. So hopefully this is smooth. Um, and um, I'll try to, you know, I'll try to watch the chat and then answer questions as we go. So um, let's open up the first example, uh, in basic zero. So here basic zero is, this is like the bare minimum, the bare minimum program that um, that you can write in anchor. There's a couple of things to notice here. First thing we have is this program macro.
00:18:32.304 - 00:19:43.364, Speaker B: What this does basically is it defines your set of instruction handlers in the same way that you would for a web server, define your routes or your resources, where each one of these methods is going to be what's called an instruction on Solana. Basically the high level goal here is to be able to communicate with your program in a way that is very natural and intuitive from any programming language. I will go ahead and open up this JavaScript test here. This is just a normal mocha test in JavaScript. If you pay attention to this line right here, then what you'll see here is this invocation of program RPC initialize. Basically what's going on here is that you have an API that corresponds one to one to each method inside of your program. Here on the left you define your instruction handlers and then you can invoke them pretty easily with this API where program is like your client here.
00:19:43.364 - 00:20:20.436, Speaker B: And that's the most basic way of looking at anchor. It's like you have a bunch of tools for easily writing these instruction handlers and then for easily calling them. That's probably step one of getting started here. With that said, are there any questions before we go further? No questions. Great. Okay, let's continue on to the next example. So we'll progressively make things more complicated.
00:20:20.436 - 00:21:19.874, Speaker B: So here we're going to basic one, which is the next tutorial, and we will keep the, we'll stick to the smart contract for now here we have a lot more stuff going on here. The first line here that is new is this, declare id. What this is going to do is statically define your program address and embed it into the program. This is pretty important for security reasons and is a point that maybe we can discuss later. But for now think about this is just declaring your program id. It's embedded into the program, it's hard coded, and all anchor programs should basically start with this line. Now let's maybe look at our instruction handlers a little bit before we have this initialize function and we have this update function.
00:21:19.874 - 00:22:05.464, Speaker B: These two instructions are going to do exactly what you would imagine. It's going to create some data and then it's going to update some data. And there are kind of two components here that if you look at each of these instruction handlers individually. So the first thing is there's going to be the inputs to the function. So here the first parameter to all anchor programs is this context. And this context basically defines all of the accounts that can be passed into one's program. So here we have this initialized struct with accounts, and this is probably one of the more important features of anchor.
00:22:05.464 - 00:23:27.044, Speaker B: We have this derive accounts macro. What this basically does is it allows you to define account validation logic in this struct so that it is completely separated and completely isolated from the business logic in your instruction handler. The reason why this is important is for basically two reasons. Firstly, it allows you to reason about the security of the accounts being passed in one by one, and it also just allows you to isolate your code, the boilerplate for account validation versus the actual business logic. We'll gloss over this for now, but what you need to know is you have this set of accounts and you have a way of validating each of these accounts via this macro here. If we take a look at these constraints individually, the first thing you'll see is this init pair space thing, whatever this means. Basically what's going on here is this macro will create this account paid for by this user, allocating this much space to the account.
00:23:27.044 - 00:24:13.158, Speaker B: If we look at my account, then you'll see a struct. It's decorated with this account attribute and it has some data in it. That's basically how account initialization works. What will happen is when the instruction executes, it'll first initialize the account, and then once you enter into the body of the instruction, you will have the account initialized, ready to go and ready to mutate. So here we take out the account and we update the data given the input to the instruction handler. And that's basically it for initialization. And you can do this type of initialization for any type of account.
00:24:13.158 - 00:25:44.154, Speaker B: So you can do it for token accounts, and you can do it for accounts for really any program. But for now we'll just keep it to this single program to make things a little more straightforward. So with that said, are there any questions with respect to account initialization? Question what if account size is determined by the client? That would be a different way of initializing accounts. In here we have this space macro or the space keyword that will define the exact size of the account. If you want to actually pass in space from the client, then what you would do is you would basically add a space variable, and then you would need to use that inside of your instruction or inside of your accounts context. So in order to pass through variables, you can use this kind of instruction macro, and then once you have that, then you can use that inside of the macro like that. So yeah, that's how you would pass in space from the client to the initialization to the initialization macro.
00:25:44.154 - 00:26:34.794, Speaker B: Question, can we have an arbitrary amount of accounts up to Solana's limit in our initialize, eg, arbitrary number of recipients stored on the escrow PDA? Yeah, you can have as many accounts as you want, as long as it fits within the transaction size limit. That is the only limiting factor. Question, can we look at the rust code that's generated by this? We can. That's actually a pretty good idea. Let's actually do that. Let's go ahead and do this with the previous example rather than this example, because this example might be more complicated. There is a tool called cargo expand, which will expand the macro and allow you to look at all the low level rust.
00:26:34.794 - 00:27:05.434, Speaker B: Now, if you're new to rust, then this is going to be very confusing. I wouldn't worry about it. This is definitely an implementation detail, but if you're interested, you can run this command. It will compile the program and expand the macro into the raw low level rust code that is generated. Can't see the screen. Zoom requires me to switch. Let me try this move up.
00:27:05.434 - 00:27:52.782, Speaker B: Here we go. Cool. If you didn't see this previously, I ran this command, cargo expand. Cargo expand is going to basically get rid of all the macro stuff and expand it into the generated code that is eventually compiled into BPF. And the rust compiler is a bit slow, and so this is a great time to go on Twitter. Still not seeing it. Armani new share cool.
00:27:52.782 - 00:28:37.018, Speaker B: So can you guys see the terminal? You cannot see the terminal. Okay, what about now? Yep. Okay, cool. I'm learning how to use zoom as we go. I apologize for those that are used to regular solana code. Here is the nitty gritty details. If you run cargo expand, you have all of this code that's generated for your program.
00:28:37.018 - 00:30:08.618, Speaker B: Basically, what's important to note here is we can go through maybe some of the code here. This is your standard entry point to your Solana program. This is just the, when you declare the entry point, this is where the execution begins. Basically that calls this function entry, which invokes a big dispatch function that effectively parses out the instruction data, matches a method identifier against the first eight bytes and then invokes the method handler that's defined in your code. If we look at this dispatch function, then you'll see this match statement right here, where what we do is we strip out the first eight bytes and deserialize, or we don't deserialize in here, but we strip out the first eight bytes and then we have this match statement that where this sigh hash is defined by the SHA 256 hash of the method of the rust method name, basically. So basically this match statement will be called, and then it'll call each one of your method handlers, which will then invoke the code that you write yourself. So if you weren't using anchor, you would basically do the exact same thing, but you would be writing this dispatch function yourself.
00:30:08.618 - 00:30:51.026, Speaker B: Basically, what the macro does is it does all this boilerplate for you. If you really wanted to, you could use anchor only for this feature. You could just use it for instruction dispatch and then use the regular Solana APIs for writing the rest of your program. That's cargo expand. I won't go into too much more detail because it's pretty low level and maybe not the best, the best example for people getting started. So I'll go back to the code and just to check, can you guys see my editor now? I see a green outline around my screen, so I assume you can. Cool.
00:30:51.026 - 00:31:22.534, Speaker B: All right, we're learning this as we go, so this is exciting. Okay, so we learned about instruction handlers. We learned about declaring ids. We learned about account initialization via the account context. And now let's talk about this update instruction handler. So this update instruction handler is pretty straightforward. Basically, we pass in some data, and we then update the account that was initialized in the previous function.
00:31:22.534 - 00:32:39.244, Speaker B: The main thing to note here that's new is this account mute macro here. What this will do is it'll mark the account as mutable so that when the instruction exits, it will persist the changes to storage so that the state transition completes. Yeah, that's basically it for initialization, that's it for updating, and that's it for this example. I think we can take some more questions and then move on to the next one. So, question, can you go through each account type at anchor briefly account account info, program account, etcetera? Yeah, that's a great question. So account here is, these are all basically wrapper types for the underlying raw data structure given by the Solana runtime. Account is basically a deserialized wrapper for account info, where the deserialization is this inner account object, what the macro does is it takes the underlying account info that the Solana runtime gives you.
00:32:39.244 - 00:33:48.824, Speaker B: It takes the instructor, it takes the storage data, it deserializes it into this structure and then returns you this wrapped account. The reason why the accounts are wrapped in this way is because you need to always have a handle to this account info object to be able to do cross program invocations, because that's just a part of the Solana runtime API. So that's it for account. And what's nice about account is that when it deserializes any data, it also does ownership checking on the account being deserialized. So what will actually happen is it'll deserialize my account from the raw bytes check that the owner is equal to this declared id. And if it's not, then the program will fail, and it will never actually even hit the instruction handler. If it succeeds, then it'll continue and deserialize the next set of accounts.
00:33:48.824 - 00:34:46.232, Speaker B: Account is basically, you can think of it as a safe deserialized wrapper for account infos, where account infos are kind of the primitive account data structure given to you by the Solana runtime. What's probably worth pointing out here is that these account infos are extremely unsafe to use, in the sense that you should never use them without validating the account. So you need to do things like validate the owner, you need to validate the instruction, or you need to validate the account data. Then only after you do all of that, then can you use these account info accounts. That's it for those account types. The other account types that were mentioned, like program account and CPI account, those were in old versions of anchor. They're still around, but I don't recommend using them.
00:34:46.232 - 00:35:13.734, Speaker B: Account is just a complete replacement for both of those, and it's safer to use. Question is account the new program account? Yes, it is. Cool. I think that's it for this tutorial. I don't think there's any more questions. Let's go on to the next. Actually, before going on to the next one, let's actually take a look at the JavaScript API for this.
00:35:13.734 - 00:36:07.974, Speaker B: There's some important things that maybe point out here. We have two tests here, one for initialize, one for update. The important thing to take a look at is the RPC invocation. The API is exactly like in the previous example, except we have two new things. We have the instruction data, so the parameters that are passed into the function. It's a U 64, so we use this big number type instead of JavaScript number type and we also have this signers array that's passed into the accounts context. The reason why this is needed basically is because when you create a new account, the Solana runtime requires that account to sign the transaction and so we need to generate a key pair and then have it sign the transaction effectively.
00:36:07.974 - 00:36:45.964, Speaker B: So that's it for initializing on the client. Then if you want to fetch the account, then after you have created it you can then fetch it with this account API. Basically you have this program account namespace where all of the accounts live. This is all dynamically generated from the client. Our previous account was named in my account. That's why it's called this. If it was called Foo then you would rename it to Foo.
00:36:45.964 - 00:37:37.454, Speaker B: And what's nice is that you have these clients that are automatically generated and you can access all of the state in your program pretty easily from this API. Taking a look at the chats, can you elaborate on program accounts? Yeah, so program account, I wouldn't worry about it. Just ignore it, pretend it doesn't exist. Don't use program account. Basically what it is is it's a version of account that only validates the currently executing program. Can you talk more about metadata and exploring metadata with anchor? That's a great question. I don't think that's appropriate for this stream just because that's an entirely different rabbit hole to go down.
00:37:37.454 - 00:37:57.444, Speaker B: Maybe we can chat on discord or talk with the metaplex guys about that. I'm going to miss program account and CPI account. Definitely don't miss it. Account is way better and way safer. Yeah, use account, don't use CPI account. Cool. Yeah, that is that.
00:37:57.444 - 00:38:46.814, Speaker B: Maybe it would be nice to actually run this example to get some interactive feedback here. So you actually see what this, what these accounts look like is. So what we're going to do is we're going to initialize the account, we're going to fetch the account and then we're going to print the account and then you'll see exactly what this looks like. So yeah, I think I did not explain what anchor test is, but I will be happy to go into that. Here is our log statement and here is our account data. This is the data field in our account and this is the value so we passed in. This is the big number representation.
00:38:46.814 - 00:39:28.976, Speaker B: But yeah, that's basically it. Let's explain this anchor test example or command a little bit. What anchor test will do is it will compile your program, run a local validator with your program deployed, and then it will run the test suite that you provide. Here you can see the Mocha test suite. That's basically it. It will spin up and tear down the slanted test validator for you, which is pretty convenient for doing integration tests. If you want to write your tests in rust, you could also use the program test tooling, which will also work.
00:39:28.976 - 00:40:12.684, Speaker B: I think the command is cargo test BPF, as you would do with normal slana programs, but that also works as well. And you can use all the rest APIs for that question. Can you show them cs and pdas? Yeah, we can definitely do cs and PDA's. I think that is kind of an advanced topic, so maybe we should go through some other examples first. Um, but yeah, so, so that's integration testing. Um, and that is the basic one example. So we've kind of explored, you know, exactly how to, um, oops.
00:40:12.684 - 00:41:23.114, Speaker B: We've talked about, you know, defining programs, defining instruction handlers, um, defining account initialization. Um, but one thing that we haven't really talked about is how to do account validation and make sure that all the accounts that are passed into your program are safe. One pretty unique thing about the Solana runtime and writing smart contracts on Solana is that you have to declare all of your accounts upfront. The client has to iterate through and specify all of the accounts that the program is going to touch. One effect of this is that clients can inject, or malicious clients can inject the data into your programs that can cause your programs to do unexpected things. One really big part of this rust DSL is providing some APIs for validating. All of the accounts are as expected and airing out if they violate some set of constraints.
00:41:23.114 - 00:42:02.034, Speaker B: Here we have this basic two example. We have these two instructions. Create an increments. This is pretty simple. It defines a counter that can only be incremented by this authority that's given to the creator or that's given to the create instruction. Then once this increment function is called, the count is increased. It's a pretty simple example, but what's pretty useful to focus in on here is these accounts structures here, let's take a look at this first one and go through each of these accounts constraints.
00:42:02.034 - 00:43:17.390, Speaker B: In the last tutorial we focused on this initialization constraint, which will create the account prior to execution. Here we have maybe a new one, which is the signer constraint. What this will do is it'll basically create an if statement that says, if this account did not sign the instruction, then abort when you have your instruction handler being executed, you know that if you're inside this code, then you know that this, that the user has indeed signed the transaction, and that's a pretty like important primitive to understand. And then you have this additional constraint here for the system program which does something similar. But instead of checking that the account has, or that the wallet has signed the transaction, you are checking the address is as given. And so if any account is given here, that's not the system program, then it'll abort and your instruction won't be executed and all is well in the world. You have this.
00:43:17.390 - 00:44:40.630, Speaker B: There's a lot more APIs here, or a lot more keywords to be passing into this count macro. But the basic idea is there is this DSL that is defined to allow you to express these constraints for your accounts. What you can do is then you can reason about all of the accounts that are passed into your program by just checking these constraints and making sure that all of the accounts are as expected. So if we go down to this increment instruction, you'll see an additional one, which is this has one constraint which basically checks the authority field on this counter account is equal to this account that's passed in. We have this set of accounts here that basically will always ensure that this authority not only signed the instruction, but also that the authority is indeed the authority that is allowed to increment the encounter. And yeah, that's probably it for introducing this idea of account validation constraints. So let's take a look at the chat and see what people are asking.
00:44:40.630 - 00:45:52.002, Speaker B: Question, why do we need the system program? Yeah, so we need the system program because whenever you initialize an account in the Solana runtime, it's required for, it's required for the API. Basically it's a leaky abstraction. But the Solana runtime requires you to provide all accounts that you're touching, and in order to initialize an account, you have to invoke the system program via CPI. Now, you don't see any of that because it's all generated by the macro, but you do need to provide the system program whenever you're initializing an account for that reason. Question how did you come up with the name anchor for this framework? So the name anchor is not very creative in hindsight. Maybe it has too many name collisions with other projects, but there's like, maybe a good reason for the name. So firstly, it's a smart contract framework for like Solana sea level runtime, right? And like you have a sea and like with seas there's boats and like, with boats there's anchors.
00:45:52.002 - 00:47:15.094, Speaker B: And so like, you know, you can kind of like, you know, make the stretch there. But you know, if you start thinking about accounts and you think about Solana's runtime as like a sea and you know, and then, you know, you have, and if you think about accounts as like the data, you know, as like flowing through the sea, then you come to this maybe conclusion that accounts need to be anchored down so that your program does not drift away into unexpected areas so that you can guarantee that it executes in this safe way in this safe harbor. So the idea anchor basically was this basically accounts macro is basically originally named Anchor, where you would, where each one of these constraints is a way of anchoring down all of the accounts in your instruction prior to execution. That's the thought process. It's not super creative, but yeah, that was the line of reasoning that led to the name question. How long have you been developing rust? I've been developing rust since probably 2018 is when I first was exposed to the language. Yeah, that's right.
00:47:15.094 - 00:47:37.124, Speaker B: PDA equals voodoo magic. That is correct. Pdas are awesome. I'd be happy to talk about them soon. I think that's it for this tutorial. I don't think there's any more questions. You have these macros for, for defining constraints that is maybe vaguely interesting, but pretty important.
00:47:37.124 - 00:48:39.512, Speaker B: So yeah, let's go to basic three and continue onwards. Basic three is all about CPI, or calling one smart contract from another smart contract. So here I will open up two smart contracts that will communicate with each other. So we have this puppet master and we have the puppet, and as you might expect, the puppet master is going to call the puppet to set some data. So what you will need to pay attention to here is this set data invocation here, which similar to the JavaScript API, will correspond one to one to the instruction handlers in the other program. So basically your programs all generate these CPI clients for calling one instruction from another program. Basically it's really that simple.
00:48:39.512 - 00:49:35.344, Speaker B: You just have this API and you call the API, and that's basically, it's probably worth talking about this. So similar to JavaScript, you have to define the accounts that you're going to be passing in. We're calling the setdata instruction. So we pass in all the set data accounts which correspond to this struct defined in the other smart contract. Then the CPI context is very similar to the context in your instruction handler, except it's used for CPI and it has this additional, this additional parameter, which is the executable account that you are going to be invoking at a very high level. That's how CPI works. It's pretty straightforward, I think.
00:49:35.344 - 00:50:35.490, Speaker B: Are there maybe any questions with respect to CPI? CPI stands for cross program invocation. So in Ethereum it might be called like a cross contract call where you basically are just calling one, one smart contract from another smart contract. Does Solana have an RFC system akin to eips or bips? Yeah, it has a. I don't know how formal the process is, but it has a proposal mechanism or a proposal process that you can see in the main Solana repo. Thank you, Henry, for sharing my LinkedIn. That is not awkward at all. Yeah, so that's cross program invocations.
00:50:35.490 - 00:51:18.344, Speaker B: Let's go on to what is your emac config? You can see my emac config in GitHub. It's on my profile. The EMAc directory is there. That is it for cross program invocations. Let's go to the next example. The next example is all about token accounts, because token accounts are awesome and allow you to do cool things. What this example is going to do is it's going to create token accounts and it's going to create mints within the smart contract itself.
00:51:18.344 - 00:52:08.064, Speaker B: The way you would create a mints is going to be exactly the same way as you would create a regular account. But you have to provide some additional parameters. Here we have our knit macro. We have the payer, which is going to pay for the creation and the rent exemption of the accounts. And then we also have these new additional parameters, mint decimals and mint authority. And these are just going to be the additional parameters given to the account that's being created. That's basically it for creating a mint.
00:52:08.064 - 00:53:10.934, Speaker B: There's this mint account here that you need to use, but it's pretty straightforward. You could just create a mint like this and invoke the instruction. When you enter the instruction handler, the mint will be created, then tokens follow in a similar pattern here where you initialize and then you specify some parameters and then the token will be created. Yeah, so I think maybe, that's probably, maybe a good introduction with respect to the basics, I think we covered most things that people would find interesting at this point. I'd be happy to either, you know, answer any questions, elaborate on anything that people want to know more about, or. Yeah, I'll kind of maybe leave it up to the chat at this point. Let's do Pda's.
00:53:10.934 - 00:53:27.744, Speaker B: All right. Let's do Pda's. Everybody wants to know about PDA's. We are going to talk about pdas. So. Yeah, so PDA's stand for program derived addresses. And this is probably like one of the more advanced but extremely important concepts in the Solana runtime.
00:53:27.744 - 00:55:00.444, Speaker B: And basically there are two different ways of looking at a PDA. The first way of looking at it is that it is an address that is generated deterministically, that can only be used by programs. And what it's basically used for is it's used as a way for programs to generate a signature for cross program invocations. So for example, if you want to have a, if you want to have a program like own a token account, you know, and have that token account, you know, govern, you know, govern those balances based upon the behavior of the smart contract, then what you would want to do is you would want to use a PDA as the owner or as the authority of that token account. And then that program can generate signatures and transfer those tokens back and forth via cross program invocations. That's one way of looking at pdas, which is it's a way for programs to generate signatures. The other way of looking at it is via account data, where you have the ability to generate deterministic addresses for accounts that can then be used for things that you find interesting.
00:55:00.444 - 00:55:28.924, Speaker B: Maybe let's look at some code for this. Let's see. Yeah, so here we have, let's probably maybe look at one of these examples. So PDA init. Let's look at this. This looks simple enough. Yeah.
00:55:28.924 - 00:57:47.184, Speaker B: So what this set of accounts will do is it will generate a PDA account, and that account is going to have data, and that data is going to live at a deterministic address. And this is pretty convenient because it allows you to calculate an account address deterministically without ever, you know, hitting an RPC server, which is great for performance reasons and is something that you should probably leverage in your programs. Here we have all of the same syntax for generating accounts, but we have these two additional fields. Here we have seeds and we have bump. What seeds will do is it will define the kind of the set of bytes that will be used to generate the deterministic address. And basically each one of these byte slices will be used in the preimage of the generated address, which is like, I believe it's hashed to create an output address, which will be where the account data lives. And then we have this bump field here, which is basically used to ensure it's used as an extra seed that is used to ensure that the address that is generated is not like a valid address lying on the ED 25519 curve, which is it's kind of a detail in the Solana runtime, but it basically ensures that no address, nobody can ever have the private key for this address, which is what allows it to be used as a, as a PDA.
00:57:47.184 - 00:58:44.704, Speaker B: So yeah, I think maybe that was probably confusing and probably useful to like look at Twitch chat to see what's going on here, see if there's any questions. Question assume I create deploy a smart contract using anchor and then I like the smart contract to CPI with a smart contract on Metaplex. Could that be achieved with the use of CPI in PDA? Yep, it 100% could. You can CPI to any program via an anchor smart contract question a bit off topic, but how do I get the exact syntax highlighting theme on the anchor docs? It appeared to be using some prism J's version of Tomorrow dark for Rust. Yeah, so that's just using viewpress. I don't think there's anything magical going on there. I would just check the repo for that.
00:58:44.704 - 01:00:01.512, Speaker B: Question what's the current NFT standard on Solana? Metaplex is the standard question if using account info is so unsafe, is it bad that we use them all of the time for CPI calls? Are CPI calls unsafe by design then, or are they safe as long as the program instruction handler we're invoking handles all validation logic correctly? That's a great question. Yeah, so they are not unsafe. Like for CPI, they are unsafe from the perspective of your instruction handler using those accounts. So as long as the instruction handlers are validating all of the account infos that are given to them, then you're good to go. You can use the account infos for CPI, it's just a question of where you do the validation. Like theoretically, if you have a proxy program, for example for the SPL token accounts or SPL token program, and you did nothing but proxy, then you technically wouldn't even have to do account validation because the SPL token program will do it for you. But that's usually a bad idea, and you should just generally validate all your accounts PDA.
01:00:01.512 - 01:01:01.178, Speaker B: Example question to render Metaplex nfts, you have to generate a PDA based on owning address metaplex seeds and its PDA that has metaplex meta. Can you explain why? I don't quite understand the question there. Basically, I don't know. That might be a question for the stream offline or for the metaplex team, but I'd be happy to answer that after the stream. If you're still confused on that, can you go over to the J's side of things one more time please? Yeah, definitely. So let's do that. So are there any specific examples that you wanted to see from the JavaScript side of things? No specific example.
01:01:01.178 - 01:01:35.284, Speaker B: Then let's just go to the last one that we were looking at. So the CPI one would be helpful. Okay, let's see that one. Yes. So this is what the code looks like from the CPI example. So you know, it's basically the same as all the other clients. There's nothing special with respect to the CPI.
01:01:35.284 - 01:02:19.984, Speaker B: You just have to pass in all of your accounts that are defined in your accounts context. Here we have the pull strings function and you have the two accounts and that's about it. Metaplex is not written in an anchor. Yeah, the core contracts are not, but the new candy machine is, which is pretty cool. Question, could the example code be made available for reference after the stream? Yeah, the example code, it's on GitHub currently. So you can go ahead and check them out there, show them the IDL. Yeah, that's a great idea.
01:02:19.984 - 01:03:06.770, Speaker B: Let's go ahead and look at the IDL for the first example. The IDL is basically going to live in this target IDL directory. It's basically just some JSon that can be consumed by clients to be able to communicate with the smart contract. We have this section here called instructions. In there we have this array of instructions. Here we have initialize, which is this initialize function and there's no accounts and no arguments. And that is that this metadata field is an implementation detail used by the CLI.
01:03:06.770 - 01:03:54.454, Speaker B: And I wouldn't really worry about it. It's purposefully not defined. For all intents and purposes, this is the idli. And if we take a look at like a more complicated example, you can kind of see some more interesting, more interesting stuff in IDL. So if you look at the second example or this basic one, you can see a much more complicated IDL where we have our instructions again, but we have the accounts and then all of the metadata about them. Here it's saying what accounts are mutable, which ones have to sign, et cetera. We have the ARG's and the data types on the ARG's.
01:03:54.454 - 01:04:51.618, Speaker B: How the clients work basically is you can create a client like the JavaScript client or go client or whatever that reads this JSon and then generates a bunch of code to basically interpret this and then communicate via, you know, via the, you know, Idl to the smart contract question. So in the j's side of things, we only pass in the pub keys, but in the accounts context struct, we see that takes in accounts, accounts infos, et cetera. What's happening in the middle there. Yeah. So on the client, you only need to pass in the pub keys. What will happen is that will create a transaction. It'll send that transaction over to the Solana RPC node and it'll eventually execute on all the validators when it's executing in the runtime.
01:04:51.618 - 01:05:55.394, Speaker B: Then the runtime will create this account info object for you that is then parsed and unpacked into these structs. And that all happens behind the scenes inside of the macro, so that after deserialization and after constraint checking, these instruction handlers are finally invoked, which will then execute your code. Could you show how to generate the IDL in the terminal? Yeah, definitely. So the IDL is generated in the terminal. There's a couple of different ways of doing it. The most basic way is just by running the build command that will both compile the smart contract, but it'll also generate the IDL in the target directory. Yeah, that is how to generate the IDL.
01:05:55.394 - 01:06:46.778, Speaker B: There's also this parse command that you can use to just generate it. To generate it from source, we just specify a file and then we can specify the input and that'll parse the source and generate an IDL. So those are two ways of generating Idl. I think that's it for the questions. Yeah, there's no questions. I think that's all of the material that I had. Sweet.
01:06:46.906 - 01:07:10.214, Speaker A: Well, thank you so much, Armani. It was a pleasure to have you on the stream. As a reminder, everybody, the stream will be uploaded to YouTube so you can come back here and rewatch it. We'll post the link on Twitter, but after that you can find Armani on Twitter. I'm not going to attempt to pronounce your last name, but you can very easily find him.
01:07:11.684 - 01:07:12.084, Speaker B: Yeah.
01:07:12.124 - 01:07:14.108, Speaker A: Thanks again, Armani. Really appreciate it.
01:07:14.236 - 01:07:39.714, Speaker B: Cool. Thanks, everyone. If you have questions about anchor or about Solana development or anything, really head over to the project serum discord. I usually hang out in there all day, every day, like, to answer questions. There's people like Henry in here that do a much better job at answering questions than me. So, yeah, um, thanks everyone. Thanks for having me.
01:07:39.714 - 01:07:40.814, Speaker B: Thanks. Bye.
