00:00:05.520 - 00:00:42.182, Speaker A: Alright guys, welcome back again. So we've seen how to create an account, right? And we've seen how to do CPI, but what we haven't seen yet is we haven't seen how to actually create our own custom data for accounts. So our own data types, our own fields and that's what we're going to cover today. We're going to dive right into the code. So let's open up lib rs here and our repository structure is going to actually look a little bit differently. You can see we're making use of this instructions and state folder. So if we pop open its processor file here, you can see that we're going to have just one instruction type, so one function and that's going to be to create this address info and that's going to be the name of our account.
00:00:42.182 - 00:01:31.940, Speaker A: We're going to actually have some custom data representing like some address information, right? So if we pop open state and we open this address info file and state you can see here is going to be the struct that represents our custom data. So we got a string, a U eight, a couple more strings and this right here is going to be the major key to actually doing this, right. This is an annotation for bore serialization, deserialize serialize. And what this is going to do is allow us to actually convert from this rust struct into bytes and also be able to do the reciprocal on the typescript end as a client. So that's super important. We're going to go to and from bytes so that we can pass this data onto the Solana runtime and actually save it as account data. And in order to do that you have to add borscht to your cargo toml and add it as an import up here.
00:01:31.940 - 00:02:01.512, Speaker A: And then of course down here we've just implemented address info so we can just like create a new one here. And so now let's pop open the create instruction here. So if we look at create we can see that we're doing nothing out of the ordinary. We've seen this already invoke, we're going to invoke the system program to go and create this account. But this here and this here are going to be the two major keys to this operation. So this one is going to be rent and this one is going to be custom data. So let's jam on these.
00:02:01.512 - 00:02:44.454, Speaker A: So up here I mentioned before in a previous video how, you know, you have to pay rent for the data that you store on an account, right? Which makes sense, you're storing this data on the blockchain. It's not free. You're going to have to allocate space and you're going to have to pay for said space. It's very inexpensive, but you do have to actually manage how much is due and when. So the best way to do this, and now since a couple of changes this year, the only way to do this is to calculate how much rent is due to make your account rent exempt. And that's two years of rent, right? So if you have enough soul or land ports in your account to pay rent for two years, your account is actually considered rent exemption. So this is how you calculate that.
00:02:44.454 - 00:03:18.492, Speaker A: You first calculate the size of that data. So we take that address info struct that's coming in, we convert it to a vector of bytes and then we take the length, and that's going to give us the size of that data. And using that size we can actually calculate what the rent is going to be. And so with that in mind, you can see that we're going to actually set the specific rent here. We're going to set the specific size so no longer just like arbitrary values. And once that's been created, we can finally serialize our data into that account right here with this line. This is all it takes.
00:03:18.492 - 00:04:02.280, Speaker A: So now we basically take what comes in as that object and we just map it to that account data because it's already been allocated to have the proper size for it and that's really all there is to it. So let's take a look at the test because there's a little bit more key components in there. So looking at our test, right, things look pretty typical up top, but right here is where things start to get a little bit different. So right here we're going to have this assignable class and all this thing really does. As you can see, we're just extending it. What this really does is allow for a dynamic mapping of fields. So we're going to pass in an object of different fields and then assignable is really just going to turn those fields into the actual fields of the class, which is going to allow us to then map it with borscht.
00:04:02.280 - 00:04:44.308, Speaker A: And you can see that being done down here. So when we actually create address info, we're extending assignable and then we're adding to buffer and from buffer so we can go to and from bytes. And then finally we add this schema here, address info schema. And this is really just a mapping to it looks like the rust implementation, right? Like this is you can kind of think of it like, okay, this is what it should look like in rust because we're writing typescript, but in actuality this is the boars representation of this object because rust is a low level programming language. There's a lot of similarities here, but I encourage you guys to take a look at the borscht docs to see exactly what these values should be. In this case, they do line up with the rust code. Pretty much exactly.
00:04:44.308 - 00:05:16.488, Speaker A: So then we create a new key pair for our address info account that we're about to create, which we've seen before. And then we set up a new transaction instruction where this time we're adding data to this data field. So everything else we've seen before putting. But right here is where we're going to add that new address info object. And you can see we just got some data in here, right, just some arbitrary data, and that creates a new object. And then we can use that to buffer function to turn that into an array of bytes. And once that's been sent, we can actually pull that account back down and read its data.
00:05:16.488 - 00:05:31.560, Speaker A: And we're going to try to take a look at those fields that we set up. So let's kick it off so you can see our test passed successfully. And there's our custom data right there. And that's all there is to it, guys. That's how you set up custom data. So that was native. Let's quickly take a look at the anchor version.
00:05:31.560 - 00:06:10.372, Speaker A: So our anchor version pretty much looks exactly the same, right? We got the state folder, the instructions folder, and lib rs is just going to have that create address info, and in state it actually looks exactly the same, except we don't need Boris, we just add this guy here and now create. This is where things look a tiny bit differently. So rent is calculated the same way. We're still going to do cross program invocation to create the account. But down here, instead of using that serialization method, we're just going to do this set enter, but it's doing the exact same thing. We're taking the address info object that comes in. This time we're passing in just the params and we're setting up the object on chain.
00:06:10.372 - 00:06:32.768, Speaker A: Same kind of thing though. And then we're just setting the account data to that right there. As you can see, we also tell anchor in the context that address info is going to be the data type of this account. And so it'll go ahead and check to make sure that it is the right space. It's got the right offset, and we're good to go. And that's really it, guys. That is custom data on chain.
00:06:32.768 - 00:06:37.104, Speaker A: That's how you set up accounts, with your own custom data types. Feel free to go nuts.
