00:00:14.280 - 00:01:16.574, Speaker A: So thank you to be here today I'm going to show you how to create a very simple solar explorer and with this we want to learn Webstery T's. So how it started. I wanted to build something on Solana and I wanted to see some real use cases of web3 js. So I discovered this open source that is really great, but we can say that the code is very complete and it's not for beginner. And that's why I create a very simple solace product where today we are going to see how it's built so you can learn something from this project. To give you more context, I built this project with react chakra Ui for the components and typescript. So if you brought here your laptop, you can clone the final project and play around with the code so you can follow better this project.
00:01:16.574 - 00:01:53.504, Speaker A: Now a quick introduction to in deploy. We are going to use fandom wallet. So if you don't have it, I suggest you to install this extension. So a quick introduction to myself. I'm Jovan Furin and I come from Italy and I'm an open source contributor to Muncho Collective and Gitcoin. Right now I'm working on Discovery. Within discovery, we are going to launch our first product, that is Decompass.
00:01:53.504 - 00:02:51.540, Speaker A: Decompass will be a platform to welcome new users to the web3, so we want to guide them and help them to learn Decompass. Recently we passed with 2.5 million GTC on gitping proposal and we are going to launch the Alphabet by December. So if you feel that you align with our mission and want to contribute, it will be a pleasure for me to talk to you more about this project after this talk. Now, the first thing that we want to get to build the Solana Explorer is the to get the price. One of the most popular and best solution out there is to get it from Goingecko. Now I'm going to show you three points why Coingecko is one of the best solution.
00:02:51.540 - 00:03:39.840, Speaker A: The first one is that it's publicly available. That means that you don't need to create an account and then a token to use it. Then it's 100% free. So you don't pay anything to use those API and you have a vast data, more than 1000 coins to get from. So to put the first two points into practice, that means that you just need few seconds to get the data. You declare the Id. In this case we want the price of Solana, then we just fetch the URL and we get the data because we are using react we create the state and we set the response to our state.
00:03:39.840 - 00:04:35.104, Speaker A: How can we know what's the structure of the response body? We can use console log but we also can go directly to Koenigo documentation. It's very easy, you just have to select the API, try out inside the required parameters and run execute the API and you get right here in front on the page of going echo the response where you can choose what data you want to get from. Now this data allows us to create the first session of the final project. So the price now we are going to div into web3. So we are going to get the active stake and the supply. So from web3 we want to import the cluster API URL. So we get the URL, then we use the connection to connect to the URL and we get the data.
00:04:35.104 - 00:05:30.170, Speaker A: Because we are using typescript, we import the type supply and also type both account status from them and what inside those types for supply we have for example total circulating. Those are number that is returned in Lamport that then we need to convert to Sol. If we want to show this to the final user in a more user friendly human readable way then we have both account return and write and that's why we use reduce to get the total amount. So as I said, we need to convert lampo to solve from web3. We can import the constant lampshore data, we can use it to create our function to format. Okay good. And with that we create the second session.
00:05:30.170 - 00:06:23.892, Speaker A: Now let's review what we have learned so far by creating the cluster stats and transaction stats. For cluster stats we import connection and cluster bi URL. We get the URL from the cluster, use the connection to connect, get the data. Then we use the structuring syntax to unpack the values and set the value to our state. And for transactions per second we do the same connection trust API URL, we get the URL, we get the connection with the URL and get the data. So as you can see the most important class within web3 js to get all the data is connection. We can know and check what we can get from connection through the documentation that available on GitHub.
00:06:23.892 - 00:07:19.824, Speaker A: But I think that there is a better place that is directory in the node module. So directly within our editor we don't need to open a browser and go back and forth using the node module. We can be more productive because we don't need to move out. So if you go inside the node module and search for class connection, you can see here are the functions that you can use and they are self explanatory. As you can see everything augmented. Now because we are building icebroller, we need build the search. So we build the search in this way.
00:07:19.824 - 00:08:31.914, Speaker A: Now you can see that we have submit function that will be called when the user input the query and unhit the submit button. We import the base 58 encoding to decode the query. Then we evaluate the length. If this cc two is an address and if this is is 64 it's a signature. Then we show it the component accordingly. Now for the transaction we create those code where for example we can get synodal status and get the block time what's inside the synod status said before we can go inside node modules and we can see that syntax t two returns slot that indicate when the transaction was processed, the confirmation and so on. And then we create account details occurred here we need to import public key that we need to create a class and pass as parameter to get passaccount info.
00:08:31.914 - 00:09:27.278, Speaker A: And we may need to evaluate if it's a token because not all accounts are the same. To make sure that we align with the terminology. Account is a record addressable by a public key and it might be an executable, executable program. And a program is the code that interpret the instructions. So in this chart that doesn't see I think there are several accounts on Solana, the special program like the system program that creates the main account. Then we have a token program which creates the Mint account and also the token account initiated to a main account. So with all those different accounts we can evaluate with stakeholder and show on the UI, depending on the type of token in a different way.
00:09:27.278 - 00:10:17.402, Speaker A: For example, for account we show the Mint and for token account we can show the supply and Mint authority. So till now we built a very basic Solanas program. If we want to go further, we can also allow the user to connect the wallet and see his amount of Solana. And to do that we are going to evaluate if Solana exists within the window. So if they exist, we return it back as a provider and use it to connect to the wallet. Once connected we can get the user public key and use the connection to get the balance. And then we set the balance to our component to show it on the UI.
00:10:17.402 - 00:10:29.034, Speaker A: So if you go to the last part of the final project you can hit the connect fandom and once connected it will show the user balance. That's all. Thank you.
