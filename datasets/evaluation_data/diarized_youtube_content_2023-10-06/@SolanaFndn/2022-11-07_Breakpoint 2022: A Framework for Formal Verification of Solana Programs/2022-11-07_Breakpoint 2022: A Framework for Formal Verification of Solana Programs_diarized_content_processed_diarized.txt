00:00:04.280 - 00:00:35.288, Speaker A: Yeah, so Squaz is the multi seq infrastructure for Solana. We have been on Mainnet for a while and we have over 3000 multiseqs deployed to date. The way we like to talk about squads is we like to separate the standard and the products that we build on top of them. So the standard is really the protocol layer. There's the core multiseq program that's really minimal, really agnostic. Then there's the Squads multiseq program library, which is a collection of programs that expand the functionality for the products that we build. Then there's the work on the ecosystem front.
00:00:35.288 - 00:01:01.946, Speaker A: We have a robust SDK, a lot of technical docs, and encourage people to build products on top of squads. Streamflow, for instance, have completed their integration. So you can stream tokens directly from the squads multisig. Magna is working on one for investor unlocks and we're looking forward to them to come to Solana. And then there's many more. And then there's a lot of the work we're doing on the security side. So squads is open source, it's written on anchor, anchor verified, it's been audited multiple times.
00:01:01.946 - 00:01:35.452, Speaker A: And Auto Stack is our ongoing security partner for all the security rights that we do. It's been peer reviewed before launch, and we have a perpetual bug bounty. So if you find any bugs, please reach out. And then we have the SEC three tool running for any on changes that we do to the code base. On the product side, we have two products live right now. So that's squad's the main product that focusing on treasury management, program management, token management, workflow management, and validator management. So allowing teams, daos, institutions on Solana to manage these core on chain assets via Multisig.
00:01:35.452 - 00:02:07.560, Speaker A: And we just launched our CLI tool, which we're going to announce later today that allows the pro and power users to interact with the Multisig directly with the CLI. And then there's this squads x, something that we're kind of working on right now. Another problem built on top of our standard that's yet to be revealed. And so we'll be sharing more details on that shortly. And then there's SCS. SCS is a collective of teams that rely on the standard that we build, that help us to promote it, or integrate with us, or build products on top. Those are friends and partners and end users.
00:02:07.560 - 00:02:47.406, Speaker A: And we're excited that this list is growing day by day. And so for us, the core objective for squads was always to make it the go to multiseq standard for Solana and security is top of mind. So we kind of did this sort of checklist of everything we want to do to make sure that squads is a secure program. And you saw that in the previous slide. But formal verification has always been this kind of final frontier. And as soon as we completed, like, this sort of initial checklist, we reached out to Robert saying, we want to formally verify squad V three, the main model program. And we figured out that the framework doesn't really exist for Solana, and there's not really any program on Solana that is formally verified.
00:02:47.406 - 00:02:58.146, Speaker A: And so Robert decided to help us out on that. And I'm going to hand over the mic to him so he can share all the amazing work that him and the auto sec team have been doing in the last few weeks and months.
00:02:58.290 - 00:02:58.626, Speaker B: Robert?
00:02:58.650 - 00:03:02.138, Speaker C: Yeah, thank you. Does my mic work? Do I need this?
00:03:02.306 - 00:03:02.826, Speaker B: Hello.
00:03:02.930 - 00:03:20.184, Speaker C: Testing ok? Yeah, thanks. So, auto sec, we do Solana smart contract audits. We read a lot of code. So we work with Solana core directly. We read the validator code. We also look at anchor internals and also a lot of protocols, such as squads.
00:03:20.964 - 00:03:21.324, Speaker B: Yeah.
00:03:21.364 - 00:03:22.504, Speaker C: Quick list of our clients.
00:03:26.124 - 00:03:26.460, Speaker B: Yeah.
00:03:26.492 - 00:04:22.338, Speaker C: Okay, let's get to the actually interesting stuff. So I think formal verification is kind of like this buzzword, right? Like a lot of people say, oh, let's formally verify our programs. But what does that actually mean? So, in a nutshell, formal verification lets you prove that compile time critical properties about your code. And I guess this kind of lends itself to the question, what are critical properties? It's like a very vague concept. For example, if you have a lending protocol, what is critical to the functioning of a lending protocol? And oftentimes that's not really obvious, you might be able to think of some examples. For example, a lending protocol should probably be fully collateralized. But it's kind of unclear if this definition of fully collateralized in and of itself is enough to define the security of a lending protocol or if it's just one of the properties.
00:04:22.338 - 00:04:44.580, Speaker C: I guess another example of this would be, for example, that a multisig threshold is always less than the number of owners. This means that you can't brick the multisig. You're always able to, like, theoretically propose a transaction and sign for it. I guess kind of as a caveat moving into this presentation, one thing that I want to keep in mind is we don't really want to over promise here.
00:04:44.612 - 00:04:44.756, Speaker B: Right.
00:04:44.780 - 00:04:58.164, Speaker C: Like, formal verification, I think, is a really useful tool. But when some people claim that, you know, formal verification solves all your security issues that, you know, it, it makes it, you know, impossible to get hacked. I feel like that's not really true.
00:04:58.204 - 00:04:58.476, Speaker B: Right.
00:04:58.540 - 00:05:44.718, Speaker C: I think it makes it harder to get hacked, and I think it lets you more clearly reason about critical properties about your program. But it's not always that straightforward. Some examples of this would be it's not always clear what you should be even verifying with formal verification, for example, with the multisig squads, maybe it's more straightforward. We have a threshold less than the owners. Whenever we execute a transaction, you need to sign for all of the owners. I think, for example, for a lending protocol, it becomes a lot more opaque. What actually defines critical properties of making a lending protocol secure? And I guess there's also some non trivialities with actually using formal verification modeling the Solana VM is pretty non trivial.
00:05:44.718 - 00:06:11.860, Speaker C: What actually happens during a CPI? It's kind of hard to reason about that. Loops are also pretty painful for formal verification. Yeah, I guess this is kind of like a high level overview. Let's talk about what existing work looks like. So the interesting thing that we were looking into as we started this project for squads is that there's a reasonably mature rust formal verification ecosystem. Already. There's a lot of existing rust verifiers.
00:06:11.860 - 00:06:42.540, Speaker C: They take rust code, and then you're able to assume and assert certain properties. The one that we chose for to build out this proof of concept was Connie. There's also many others. I listed Presley here. I think there's another one, like vipers or something. Yeah, there's a lot of verifiers, and essentially what they do is they let you take assumptions about your code and also assert statements that you think must be true. So for the rust level, this is kind of solved.
00:06:42.540 - 00:07:50.226, Speaker C: I guess one caveat here is that we're doing verification at the rust IR level, so this doesn't go into BPF code, which means that theoretically, if, for example, the BPF compiler messed up, you could verify something with an existing rust framework, but you wouldn't be able to, it would fail in the real world. I think this is kind of a trade off here. We could also write a framework to verify at the BPF level, at the VM level directly. But I think that makes it a lot more difficult to actually prove anything because it's a lot more complex. When you're proving things at a lower level, it's often harder for the prover to terminate. I guess another example is we've, for example, found issues in the Solana VM where the Solana VM doesn't actually respect the rust standard. For example, Solana stack behavior sometimes differs from normal systems, and due to a cork in boundary processing in memory pages at the VM level.
00:07:50.226 - 00:08:35.434, Speaker C: So I guess that's another example of an issue where you could theoretically have an issue at the VM level that doesn't actually get solved or doesn't actually get reasoned about in formal verification. I would say that these are probably very theoretical issues. Like, the boundary issue that we found in the VM was extremely unlikely to trigger. It required very precise stack boundary alignments. So that's kind of why we chose let's just do this at the rust IR level. Let's just use this really mature existing formal verification ecosystem, and we're pretty confident that it's unlikely to actually cause any real issues. I guess the main difficulty here is we have these really nice formal verification, or, like, you know, somewhat nice formal verification tools.
00:08:35.434 - 00:09:13.764, Speaker C: The hard part is, you know, adapting it to the Solana framework. So if you try to naively run Connie on an anchor program, you get this really nice error, which is, like, very obscure. I think this is something to do with, like how? Like, something to do with concurrency in the Solana VM or something. It's like they use probably, like, unsafe code or something that just causes this error and I guess. Yeah, so when we were doing this verification, the approach that we took was to essentially not use any Solana framework code, but to try to write out stubs for all anchor Solana code. And this way we could actually get these tools to run.
00:09:14.224 - 00:09:14.576, Speaker B: Yeah.
00:09:14.600 - 00:09:24.020, Speaker C: So, I guess. Yeah, so these tools work pretty well, except for when they don't. Like, they don't work on Solana code when Mainnet.
00:09:24.052 - 00:09:24.316, Speaker B: Oh, yeah.
00:09:24.340 - 00:09:31.824, Speaker C: So let's actually talk about what we did. So we built this nice proof of concept called otter verify, which is Solana anchor and Connie.
00:09:33.484 - 00:09:33.924, Speaker B: Yeah.
00:09:33.964 - 00:09:43.224, Speaker C: And we actually verified a. I think we verified the threshold property on, on the, on the squads multisig.
00:09:44.684 - 00:09:45.028, Speaker B: Okay.
00:09:45.036 - 00:10:14.676, Speaker C: Yeah, so some, I think there's, like, two kinds of invariants that you can think about with formal verification. So one of them would be function level invariance. So this is squad's create code. And this is like, you might want to reason about, you know, invariants after create runs. For example, after the create function runs, you should always have at least one member. You should have less than U 16 max members. The threshold should be, you know, greater than some number.
00:10:14.676 - 00:10:17.196, Speaker C: Threshold should be less than the size of the members.
00:10:17.260 - 00:10:17.864, Speaker B: Right.
00:10:18.164 - 00:11:03.492, Speaker C: And then if you look at this invariant, you can probably, it's probably relatively straightforward to reason about, you know, maybe this, this is sufficient to define the security of a multi sig, right. It's like these properties are pretty good to verify if this is always true, we can be confident that, for example, you know, modular some issue in the signing that, you know, the multi seg is in a valid state. I think the other kind of invariant is like a structure level invariant. So this is the squads multisig object. It's called Ms. And then it's often useful, for example, to know that at the end of every function's execution, that the threshold is less than or equal to the number of keys. So this is similar to the invariant we described previously.
00:11:03.492 - 00:11:07.144, Speaker C: But this is like for every function.
00:11:09.344 - 00:11:16.232, Speaker B: Yeah, yeah.
00:11:16.288 - 00:12:21.188, Speaker C: So for example, in the remove member, how do we actually verify this invariant? Right. It's like, I think if we look at this code. Yeah, it's like the if statement there. Like if context counts, multisig keys length is less than the threshold, then we just change the threshold to the number of keys. So you know this, by reading this code, we can relatively easily see that this invariant does hold. But what happens if we comment this out? And this is actually kind of interesting, because when we were testing this code, we tried commenting this out, and then we saw that the verification still passed, that we were still able to prove that the threshold is less than the length of the keys, which is kind of surprising, because we see that clearly we removed some supposedly critical code that is supposed to update the threshold when the number of keys has decreased. And I think this example really illustrates the beauty of formal verification, because we have this assumption.
00:12:21.188 - 00:13:04.192, Speaker C: We think that this code looks critical, that it's critical to the function of the multisig, but our framework tells us that it's not. And then if we look into it a little bit deeper, it turns out that actually the squads remove member function. So this is pretty good design practice on their part. There's actually a redundant check when they remove a member. Whenever they remove a member, if the threshold is greater than the number of keys, they automatically reassign that threshold to the number of keys. So it turns out that the previous check was actually extraneous and we didn't actually need it. So if we comment out this check, then we get what we actually expect, which is that the code doesn't actually verify.
00:13:04.192 - 00:13:44.044, Speaker C: And I think this is kind of an example of where formal verification is really cool, because it lets you reason about these state transitions in a non trivial way. You have many places where you could, for example, update these critical fields. But by defining the property once, we only need to say we think that the threshold must always be less than or equal to the number of keys. And then we just run this framework, and then we're able to immediately know that this critical property is true. The caveat is, of course, maybe there's other critical properties that we haven't defined, and maybe that could be the cause of an issue. But for now, this is pretty promising, I think.
00:13:46.154 - 00:13:46.626, Speaker B: Yeah.
00:13:46.690 - 00:14:28.590, Speaker C: I guess as a concrete example for a little bit more on the internals for how we do this. I guess this is a little bit more technical, but Connie has essentially an any structure which lets you define your own structures. So in this case, we have this MS object, and then we fill it in with arbitrary numbers, and then we have like. Yeah, okay, this is a video. I don't know if it will actually play. Can we play the video? Okay, maybe not.
00:14:28.782 - 00:14:29.582, Speaker B: Okay. Oh, wait.
00:14:29.598 - 00:14:30.834, Speaker C: No, it does play. That's great.
00:14:32.334 - 00:14:32.830, Speaker B: Oh, yeah.
00:14:32.862 - 00:14:45.594, Speaker C: So this is running it twice, and then this is what the code actually looks like when we run it. And, yeah, there's a lot of warnings. We should probably filter those out at some point.
00:14:49.134 - 00:14:49.534, Speaker B: Yeah.
00:14:49.574 - 00:15:38.744, Speaker C: And then we can see that when it doesn't work, it prints out that it failed. And I think the other one should be when we actually fix it. So these two are the. I believe this is the threshold changing one. If we could run the other video, that would be nice, too. Yeah, I think for these videos, we probably should have actually shown what code we changed, but, yeah, this was like a very last minute, kind of approve a concept that we recorded, so, yeah, we were kind of rushing this a little bit, rushing this presentation a little bit because we wanted to get it in by breakpoint.
00:15:38.864 - 00:15:39.184, Speaker B: Yeah.
00:15:39.224 - 00:15:59.344, Speaker C: Okay. So, I guess, yeah. Like, the actual code that we updated was like the ones on the previous slides where we updated threshold changing. Yeah, this kind of shows that we can actually verify a property, and hopefully we'll be able to verify, you know, many properties about both squads and moving forward, other programs. Yeah, I think that's it.
00:16:08.844 - 00:16:23.152, Speaker A: We have actually ten minutes for questions, so if anybody wants to ask something, we're here. Or we can just do it after. Whatever works for you guys. Okay. All right.
00:16:23.208 - 00:16:23.648, Speaker B: Yeah.
00:16:23.736 - 00:16:24.604, Speaker A: Thanks, guys.
