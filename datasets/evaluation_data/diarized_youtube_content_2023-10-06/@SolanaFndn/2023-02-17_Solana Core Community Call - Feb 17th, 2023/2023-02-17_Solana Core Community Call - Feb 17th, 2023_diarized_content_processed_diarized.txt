00:00:00.240 - 00:00:34.404, Speaker A: So welcome all to the core community. Call this month. Today we'll have Galactus from Mango team talking about SIMD 16, which is application account, right, fees. And then Zantetsu discussing SIMD 33, which is the timely vote credits keeping in mind time I like to keep or I'd like to cap each discussion about 15 minutes each to give each group their ability to present and discuss with the rest of the core team. But yeah, Galactus, would you like to go ahead and start?
00:00:35.024 - 00:00:37.584, Speaker B: Yeah. Can you guys hear me well?
00:00:37.744 - 00:00:38.312, Speaker A: Yes.
00:00:38.408 - 00:01:01.244, Speaker B: Okay, that's great. Thank you, Jacob. So today I will present to you applications, please. 1 second. I'll just share my screen. Can I share my screen? I share screen. Yeah.
00:01:01.244 - 00:01:52.384, Speaker B: So, yeah. I'm Jim characters from Mango and today I will present to you application fees. So we want to introduce a new kind of fees. It's like fees when you interact with the DAP. And this fees actually will go to the DAP authority, like the account controlled by the DAP, instead of going to the validator itself. And there will be a rebate mechanism where the DAP can actually give back the fees to the user so that the overall transaction of the cluster won't increase. These fees actually will be paid even if the transaction eventually fails.
00:01:52.384 - 00:02:59.082, Speaker B: So why, why do we want to introduce this application fee? So right now, what we see in the cluster is like in Solana transaction scheduler, we put transaction into batches and each batch is executed parallel. So what happens is like a batch will take like locks on, on all of its accounts. So like for example, write locks. And so no other batch can actually use the same account in the same, like at the same time. Uh, so these, these transactions are retried or even forwarded to the next, uh, uh, validator. Uh, so, so usually, actually this actually creates an incentive to span the whole spam, the whole cluster, for example, uh, like, like high frequency, uh, market makers, they will just, uh, create new transactions spamming the network. So actually this will create more and more transactions which will actually touch the same kind of account.
00:02:59.082 - 00:03:59.534, Speaker B: And eventually it will choke the validator with the, like, with these transactions. So we want to have, like discourage this, this kind of behavior of spamming. And even there are like custom programs which will only cpi into the, into the DAP if they can extract profit. So to discourage this kind of behavior and to encourage actually creating proper and valid transactions, we want to introduce this kind of fees. So eventually they will reduce congestion in the Solana network. And actually DApps will also have ability to collect fees, extra fees with this proposal. So these are the resources we have, like the SIMD 16.
00:03:59.534 - 00:04:54.954, Speaker B: We have also created a POC and adapt based on the POC. So we want to introduce a new native Solana program called Application Fees program with this program id. So I will just like talk a little bit about rebates. So the owner of the application fee, like the owner of the account can issue a rebate by CPI into like cpiing into like a special instruction. Like they can issue a partial rebate to the fees. The rebate will be transferred back to the payer in the same at the end of the transaction. But actually if like if the authority issues a rebate, but eventually if the transaction fails, then there will be no rebates.
00:04:54.954 - 00:05:33.654, Speaker B: So we have actually like we have multiple ways to implement this feature. The first thing was storing the application fees on the ledger. This is the implementation done in the parking. But recently, actually there were some complications for like calculating fees because we have to load all the accounts and everything. So we have decided to go to more like setting application fee by instruction. So I will just explain you more about this. So setting.
00:05:33.654 - 00:06:38.234, Speaker B: So we have three instructions. Principally. One is pay application fee, in which pair agrees to pay application fee for a DAP for a certain account. Then the DAP actually can use the second instruction, check application fee, where it can just check for an account if this amount is paid or not. And the third, which is rebate, where DAP can rebate the user, it's applicable like the fees he paid. So, so the pay application fee instructions can take multiple accounts. So you can give a list of accounts and as in accounts and list of fees you want to pay for each account as like as an array of event.
00:06:38.234 - 00:07:46.758, Speaker B: So the instruction must include this, the transaction must include this instruction to interact with dapps, which have implemented application fee feature. Even if the transaction fails, the, the pair will end up paying these, these application fees. Uh, pair could even uh, pay application fee if like he include this instruction, but actually it was not needed or he may overpay uh, the fees. Uh, this, this instruction is used by the runtime, Solana runtime. So you cannot CPI into this instruction from another smart contract and you can actually include multiple accounts belonging to different apps. This won't be an issue. So the second instruction is check application fees instruction where DAP can issue like CPI into to check if they have paid application fees.
00:07:46.758 - 00:08:25.524, Speaker B: So here you take, you have to like one account and one argument like the account where you want to pay, where we expect to have application fee and the expected application fee. So the. So if the application fee is partially paid or not paid, the instruction will give an error written. An error application fee, not paid error. If it's fully or overpaid, it will return. Okay. In case of partial payment, the user will lose the amount he has paid as application fee.
00:08:25.524 - 00:08:33.044, Speaker B: The instruction can be called multiple time across multiple instructions. It won't be an issue.
00:08:34.544 - 00:08:51.044, Speaker A: GM Galactus. Just being mindful of time. We have five minutes. You have to cut. I know that there has been a decent amount of discussion on the SIMD and just would like to open the floor for anybody with questions that have read the SIMD or have so far in the presentation.
00:09:13.804 - 00:09:25.114, Speaker C: Hey, this is Philip from fire dancer. From fire dancer. Yeah, I still wanted to ask you about this. Who exactly can call the rebate?
00:09:25.734 - 00:09:41.154, Speaker B: Yeah, so, actually, like, I understood your question. It was more like, in case of, like, a PDA's, who really calls the rebate, right? That was your question initially, no.
00:09:41.614 - 00:09:43.394, Speaker C: So if it's a PDA.
00:09:43.774 - 00:09:44.342, Speaker B: Yeah.
00:09:44.438 - 00:09:56.256, Speaker C: Well, I guess you. I don't know. I have two different interpretations of what you've been saying. One is, if it's a PDA, then the program that can sign for the PDA can call rebate.
00:09:56.400 - 00:09:57.344, Speaker B: Yeah, exactly.
00:09:57.504 - 00:10:17.574, Speaker C: And other times you've talked about the owner of the account being able to call the rebate. Yeah, those are two different things. And if it's an account which is larger than a PDA, then, yeah. Anyways, I just have two different understandings, and I haven't. So, like, I feel like I don't have full clarity on which one you mean.
00:10:17.914 - 00:10:47.668, Speaker B: Okay, so, actually, like, if you check the. The metadata of an account, like, account metadata, you always have an owner associated to each account. So usually when it's a key pair, like a normal key pair, it's the same owner, even for the PDA. But with assigned instruction, actually, you can transfer the ownership of the account to some. Some. Some other keeper, like, to some other entity. So in that case, they have to sign this transaction.
00:10:47.668 - 00:10:51.624, Speaker B: They have to sign this instruction to initiate the rebate.
00:10:51.964 - 00:11:00.668, Speaker C: The. So, like, if you have a PDA and the PDA is a token account, then the owner of the PDA is the token program.
00:11:00.796 - 00:11:01.460, Speaker B: Yeah, exactly.
00:11:01.532 - 00:11:03.908, Speaker C: Who can sign for it is your program.
00:11:04.076 - 00:11:20.624, Speaker B: No, no, no. It's actually the token program because token program has to invoke. Invoke sign. Like, invoke signed instruction. To sign the PDA, you cannot sign on behalf of token program. The PDA. You see?
00:11:22.724 - 00:11:36.796, Speaker C: Don't think that's right. But maybe I'm mistaken. I think it's the, where you derive the PDA from. That program id is the one that can evoke sign. But I'll double check on this, then get back to you.
00:11:36.900 - 00:11:40.104, Speaker B: Yeah, okay. Yeah, we can discuss it more.
00:11:42.024 - 00:11:58.804, Speaker D: Hey, this is Jerry from ellipsis. Hey, guys. So based on the signing topic, I think Philip is correct, where when you have invoke sign occur, it's a PDA of the calling program, not of whatever program is being invoked.
00:12:07.564 - 00:12:41.396, Speaker B: So, like, okay, let me think. Actually, I think it's like when you create a PDA, you have like a PDA and a bump. So, and then you give it to a program id, this PDA, and then you can just say invoke signed using. Let me get back on this.
00:12:41.420 - 00:13:13.464, Speaker D: Yeah, I can explain how it works. I've explained this a number of times before. The way that it works, just to make sure that we're all on the same semantically, is you have a program and you create a new public key, or you create a new address that is derived from that program id but doesn't live on the ED 25519 curve. And from that program, you are able to call invoke signed into a downstream program with the PDA as a signer.
00:13:13.884 - 00:13:14.744, Speaker B: Okay.
00:13:16.524 - 00:13:17.180, Speaker E: Yeah.
00:13:17.292 - 00:13:23.144, Speaker D: So just wanted to make sure there's no confusion. Confusion around, like, how that, that process works here.
00:13:24.124 - 00:13:37.184, Speaker B: Yeah, but, yeah, but, so we have, we have the owner, right? We have the owner, which is the program which has created this PDA. Right. In the end. So we have a fixed owner of the, of the PDA.
00:13:38.164 - 00:13:54.228, Speaker D: Okay, so the fixed owner of the PDA. So there's, this is, this is, okay, so when you say fixed owner, do you mean like system level owner, or do you mean like owner of, like, this PDA account that has a certain structure tied to it?
00:13:54.276 - 00:13:54.628, Speaker F: Right.
00:13:54.716 - 00:14:10.504, Speaker D: Because, like, when we're talking about the owner of most PDA's, like, if you create a PDA from any, if you have a PDA from any arbitrary program, the system, the owner is always going to start assistant program. There is like, there's never going to be like an owner that's something else unless you explicitly allocate and assign.
00:14:10.924 - 00:14:13.708, Speaker B: Yeah, okay. Yeah, I agree with you. Yeah.
00:14:13.796 - 00:14:14.100, Speaker F: Okay.
00:14:14.132 - 00:14:15.784, Speaker B: The system program is the owner.
00:14:16.244 - 00:14:17.180, Speaker E: Okay.
00:14:17.372 - 00:14:26.988, Speaker D: Um, and so, so what, what are you saying when you say, like, fixed? Um, fixed owner of PDA? Like, I'm not quite following, like, what you're talking about there.
00:14:27.156 - 00:14:37.934, Speaker B: Okay. Uh, I guess, let me, let me look into it more, and I think I will write more about that in the sImd, is it okay?
00:14:38.514 - 00:14:42.058, Speaker D: Sounds good. Would love to see the exact details for this.
00:14:42.106 - 00:14:43.434, Speaker B: Yeah. Okay. Okay.
00:14:43.594 - 00:14:48.306, Speaker A: So I think in being mindful of time, we'll move on to the next person. Thank you.
00:14:48.410 - 00:14:50.290, Speaker B: Thank you very much. Bye bye.
00:14:50.442 - 00:15:11.644, Speaker A: Further discussion on this. Cindy, you can find the link I have posted in the chat. I'll post it again in the chat. It's simd 16. We can both discuss there more, as well as in discord under core technology. Moving on to the next one. Let's go to Zantetsu with simd 33.
00:15:15.144 - 00:15:24.956, Speaker E: Hi. Thanks. I'm gonna share my screen, if that's okay. And can you please tell me, how much time should I expect to have here? Is it another 15 minutes, or is it about more than that?
00:15:24.980 - 00:15:30.572, Speaker A: Or until the calls end? So roughly about 1314 minutes.
00:15:30.708 - 00:16:07.144, Speaker E: Okay, thank you. So I will share my screen. Oh, shoot. Well, I can't share my screen because this is the first time I've used this program on my new computer, and I will have to go to some permission settings to be able to do that. So I hope I can just reference what I'm talking about and people will be able to follow. So I made a proposal quite a while ago for this thing I call timely vote credits. The purpose that I'm speaking about this today is I really just want to make sure that anybody at Solana Labs, or anyone else who's a Solana developer that is unfamiliar with the topic can have some familiarity and can ask me any questions.
00:16:07.144 - 00:17:43.798, Speaker E: In addition, I was hoping that after I make my case for the idea that I maybe can get somebody at Sonarlabs to kind of be a champion of the change to help me get it pushed through the various processes that are required to get it there. I've had a pull request open, and it's kind of achieved attention sometimes, but I don't think very consistently, and I think that it's. I don't know what the existing mechanism is for community contributions to the Solana code base, but I hope that there can be a process by which there's maybe a champion for changes that can act on their behalf from Solana Labs, because from the outside, it's kind of hard to get traction without that. Okay, so speaking about the change specifically for a long time, we've noticed, as the validator set kind of watches this, since a lot of what we do and the profit we want to try to make comes from our vote credit achievements, that there are some validators that appear to be achieving higher vote credits, essentially by delaying their votes and surveying the state of forks before casting. Now, of course, all validators do this to some degree because built into the Solana code base and also built into sort of sane voting practices is the idea of waiting a little bit. If you haven't seen consensus achieved on the fork that you're voting on, so that you don't get too far ahead of consensus and then get locked out for a very long time, should it end up being the case, you're on the wrong fork. So there's some natural amount of that that occurs.
00:17:43.798 - 00:19:20.186, Speaker E: But there's also, you know, within the domain of making that choice, there's also explicitly waiting for a long time to make a vote, to try to make the most accurate vote. And we don't want validators to wait on votes because that will slow down consensus, which will then slow down user perception of transaction completion. So I proposed this idea where vote credits would be calculated based upon the latency of the vote, which is how long it takes from the time that the vote is cast to when it land, or, sorry, the slot that's being voted on, how long it takes for that vote to land on the chain. And I've written that up in SIMD 33, and I've implemented pull requests for that, and I've gotten lots of great feedback from Solana labs over months of time, and I've tried to incorporate all that feedback into the change that I've proposed. The current proposal is that it be done in a staged in several changes, because the change requires updating the actual vote account state for all vote accounts, because extra data needs to be stored in vote accounts to track this latency, and that requires new space in vote accounts. And so that adds complexities because, you know, obviously it has to be done in a very careful manner so that nobody's prevented from voting or vote transactions don't fail for validators because of bugs, and also because expanding the size of vote accounts requires adding lan ports to achieve new ren exempt minimum levels. And there's a consideration there.
00:19:20.186 - 00:20:23.404, Speaker E: All of that is written up in the SIMd, I think. And also, I've sometimes these long running changes have a lot of discussion that can be kind of hard to follow. So I hope that's not the case with the change I have open right now. But I'm more than happy to answer questions about the change and also about the proposal. If I had been able to share my screen, I'd show the chart that I've been creating periodically where I have been looking at the historical vote state over every epoch or many epochs, and then computing the vote credits that were achieved by validators and the vote credits that would be achieved if this proposal were implemented, and having a table showing sort of what the effects are. And from that table, I believe you can see kind of who the laggers are. Cause you can see which validators have, say, the top four or five achieved vote credits every epoch would have significantly reduced credits, each of them, because a significant fraction of their votes are delayed.
00:20:23.404 - 00:21:07.904, Speaker E: And I think that is evidence that this is what's happening. And, in fact, I think that, economically speaking, the ideal voting pattern right now is to vote only on finalized blocks, because you'll get maximum possible credits. And if you're a private validator, since none of your votes will ever be on a fork that ever has a chance of dying, so you'll never get locked out, and you'll always achieve maximum credits. And, in fact, the validator code base and the protocol will accept all those votes, because it accepts votes up to, I think, two or 300 or 400 slots old. So it's very likely that you'll be able to land every vote if you vote in that manner. But, of course, that's a strategy that would halt the cluster if everyone did it. So we don't want people doing that.
00:21:07.904 - 00:22:12.708, Speaker E: And this proposal is a way to ensure that that strategy and strategies that would artificially delay any amount are less profitable or potentially not profitable at all. So, that's my presentation about the topic. I'm sorry I didn't share anything on the screen. Are there any questions, and is there anybody who would be willing to partner up with me on this? This topic has been somewhat beaten to death. I know I've proposed it many times. I've talked about it in discord many times, so maybe everyone's already familiar with it, and if so, great, then I guess the only thing left is, is there anybody that would like to. I don't know how this works with slalom labs, how your organization works with the community, but, you know, and I'm not demanding anything.
00:22:12.708 - 00:22:26.344, Speaker E: It's not like I want to being, you know, like, taking anybody's time from someone labs outside of what the organization thinks is proper for that person. I'm just hoping that there can be some kind of collaboration here.
00:22:26.844 - 00:23:15.094, Speaker A: Yeah, just to touch on that real quick. So, in 71, we kind of outline, like, hey, the best way to get your proposal pushed into, like, the code base is kind of to be able to write it yourself. So that's step one. I know that you've made some prs. That's great. The second step is that there's also, there's a contributor access policy now for the, specifically, the Solana labs repos on the Monorepo, and you could request, like, triage access to start working with other people to get this through. Other than that, I would allow people from Solana Labs to talk about that since you're going, your target is the Solana Labs client for first implementation, but overall, in the long term, it would be multiple client implementations.
00:23:20.394 - 00:23:47.964, Speaker G: Hey, this is Ashwin from slot on labs. Yeah, I mean, the first pull request looks like it's almost done. Yeah, just keep pinging me. I don't know, like, GitHub notifications are pretty hard, so just keep pinging me in chat every time you have an update. I know it takes a while because we move fast to resolve all the merge conflicts, but I think you're doing everything right to get it on track. If we're slow to respond, just keep dming me on discord.
00:23:50.864 - 00:23:55.604, Speaker E: I didn't know that that was an option. I didn't want to pester anybody, but I'm happy to pester.
00:23:56.184 - 00:24:12.224, Speaker G: Yeah, I think you did it a couple times in the past. I've looked at it every time. So, yeah, just keep pinging me if you're not getting a response. And, yeah, I didn't see the SiMD. Maybe we should add some reviewers. I'll add myself and Carl. Hopefully we can get that merge, too.
00:24:14.364 - 00:25:15.400, Speaker E: Great. If there aren't any other obvious questions, there was a question raised by someone at jump last time. I sort of brought this up in a validator meeting, and that question, I think, was about, does this create any kind of perverse voting incentives for validators? Does it disturb the possibility of achieving consensus? Because validators may decide that it's more profitable to vote, to commit more to forks, and then potentially get locked out a lot more. And what does that do? Does it make the blockchain brittle? And that's an interesting discussion to have, and I'm happy to have that. I've thought about it a lot, and I don't think it does, because right now, it can only make things better. Right now, like I said, the best incentive is to simply not contribute to consensus and vote on finalized blocks only. Or if you're not going to do that, if you're not, if you don't have the stomach for something that antisocial, you can choose your point of how far you want to wait before voting when you otherwise could vote.
00:25:15.400 - 00:25:35.204, Speaker E: And that's what the current, what I call laggers are doing. Different ones doing it to different degrees. Some of them are, I think, much better at it, and they. And as a result, they'll be much less affected by this timely vote credits proposal. But all of them will be, to some degree, just on that.
00:25:35.324 - 00:26:44.994, Speaker F: Hey, Richard from finances jump to me, I'm not sure where that concern was specifically raised, but if anything, that was probably more like out of caution, since as far as I know, Solana's consensus protocol has not been formally analyzed, at least until we're having our security auditors look at the current implementation, first of all, and trying to achieve some formal proofs about how the network reaches consensus. But certainly, I think the finance team gave you the commitment in viscode that we will implement your proposal. I guess it's just a question for the way this indeed gets accepted, how this lands on Mainnet, but I think that is mostly out of our control. But for now, we haven't worked on implementing tower BFT for how it currently exists yet, so therefore, it's also a bit tricky to get started on the work now. But as soon as we do work on it, we can commit to also the your proposal, and we really appreciate the work on your side.
00:26:45.654 - 00:27:09.166, Speaker E: Yeah, no problem. I mean, I didn't mean to point a finger or something, it's just. It wasn't a DM after one of the meetings, and they expressed very valid concerns. I'm not even trying to say it was in some way inappropriate, but they were good concerns. And I just think that if someone wants to talk about those, I'm happy to talk about them. That's all, because, I mean, I don't. Like you said, it hasn't been formally, verily formally analyzed.
00:27:09.166 - 00:27:48.160, Speaker E: So I think there's some math you can do to. You know, I'm not that great at math, but there's some math you can do to say, well, given the chance of a fork, if I make this vote, the chance that it's on the wrong fork versus the potential credit I earn by making the vote, I think there's some self referential function or something that decides what the benefit is of making a vote. And of course, we want that to be structured such that it's best for the cluster. I believe that what I'm proposing is. Is closer to that, but, yeah, like you say, until formal analysis is done, I guess I can't prove that. Sorry.
00:27:48.192 - 00:27:58.324, Speaker G: There's also the threshold check, which stops you from voting too far consecutively. So you're still within the bounds of not locking yourself out and being detrimental to the cluster.
00:27:59.344 - 00:27:59.696, Speaker A: Yeah.
00:27:59.720 - 00:28:39.664, Speaker E: And may I point out, and, you know, I'm sure a lot of people know this already, there are some of us validators who, you know, are voting and adding more credits and sort of committing harder to forks and earning more vote credits as a result, of course, with the potential also of getting longer lockouts should there be a fork. And that's the risk we take. And whether that's a better risk for the customer overall, I mean, I guess I can't say. Although thus far in the past year and a half or two years, it hasn't seemed to be a problem. You know, tentatively. But at any rate, that strategy that I just described will be worse after this change. Like, it will mean that, you know, that strategy will.
00:28:39.664 - 00:28:48.064, Speaker E: Well, actually, I guess I'll have to think about it. I believe that it will reduce the benefit of that because. I'm sorry, go ahead.
00:28:49.324 - 00:29:25.452, Speaker F: We see this kind of change direction being implemented in other protocols, most notably ETH two. They have an exponential drop off in rewards on late attestations. So, yeah, I don't see any large reason against implementing time reward credits either. There's a bit more nuance to the way the Solana labs code works, which might in some cases be counterintuitive to how BFT should resolve. Either way, I do hope that we get this proposal through. Maybe.
00:29:25.568 - 00:29:27.464, Speaker E: Yeah, I don't know the timeline.
00:29:28.284 - 00:29:49.344, Speaker A: Okay, so we've reached time. Thank you all for coming today. If we have further discussion, the two SIMD's, I'll post them again in the chat are SiMD 16 and SiMD 33. So Zan's was 33, which is the timely vote credits. And then 16 is what GM Galactus went over with the application. Right. Fees.
00:29:49.344 - 00:29:58.924, Speaker A: We can continue discussion there. Also, if you want to do something more ad hoc, there's the core technology channel in salon and tech discord. But thank you, everyone, for coming today.
