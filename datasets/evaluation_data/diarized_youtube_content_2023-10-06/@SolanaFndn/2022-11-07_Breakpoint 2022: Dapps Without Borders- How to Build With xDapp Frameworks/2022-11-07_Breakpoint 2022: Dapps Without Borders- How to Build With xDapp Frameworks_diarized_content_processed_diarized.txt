00:00:03.920 - 00:01:04.502, Speaker A: Hey everyone, I hope you're having as much fun as I am. My name is Chongurkes and I work at JMP. I'm a core contributor to Wormhole, and today I'm going to be talking about XDAP frameworks, actually. So, yeah, so the first question is, what is an axtaput? So next up is an application composed of smart contracts that live on multiple chains. And this doesn't sound very profound, but actually it has a lot of implications on the way you want to design your smart contracts. Because if you have a Dapp that lives in a single chain, you have a lot of nice properties that are guaranteed by the smart contract runtime on that chain. But the moment you start going cross chain, there's going to be asynchronous communication, all kinds of different synchronization issues.
00:01:04.502 - 00:02:31.748, Speaker A: So what I kind of want to talk about today is what is a good way to architect an XDAP? So before going into XDAP, let's just quickly review some of the properties of traditional smart contracts. So here's a transfer function written in a language that looks a little bit like solidity. And we've all seen programs like this. You know, most smart contracts kind of have these, have these workflows where you have a function that users can call, you know, in a transaction, and the contract does, you know, in this case it's a transfer function. So the contract takes two arguments, the from address to address and some amount, and the contract keeps on chain storage representing the balances of each user. And in the transfer function, you basically subtract the amount transferred from one user and add it to the balance of another user. And so this is a very simple program, but it already kind of shows the usual workflow when you write smart contracts on a blockchain, which is that the balance's data structure is a shared object between all invocations of your smart contract.
00:02:31.748 - 00:03:55.214, Speaker A: So this is a piece of storage that's globally available, and, you know, it's a globally shared resource. So in traditional smart contracts, execution is synchronous, thanks to the log based concurrency model of the underlying blockchain. Now, you know, Ethereum takes a global lock on the whole storage, and that means that transactions are sequenced. A single transaction is executing at any given time, and once that's finished, another transaction can start executing. Solana has a slightly more fine grained concurrency control because the account model of Solana kind of statically exposes the resource acquisition structure of your transactions, which allows the runtime to execute transactions in parallel. But at the end of the day, you still avoid race conditions because Solana is very careful about taking the right looks on your resources. Transactions are also atomic in a traditional smart contract runtime environment, which means when you start execution, the smart contract instructions, if there's an error or if the transaction reverts, then none of the state changes are persisted on chain, so the whole thing rolls back and you can try again later.
00:03:55.214 - 00:05:03.520, Speaker A: And finally, there's a shared state between transactions, which means on chain storage is globally available between any two transactions. So you could say that traditional smart contracts are easy. And of course there's a lot of subtleties to writing smart contracts, but from the perspective of resource management, they're pretty easy to think about, because you don't have to conceptually think about concurrency issues or any kind of race conditions, memory sharing, that kind of stuff. But X Dapps are concurrent, and concurrency is very hard. So why are X Dapps concurrent? An Axdap is basically you have multiple traditional smart contracts operating on different chains from each other. So let's say you have a smart contract on Solana and a smart contract on Ethereum. And the way these smart contracts communicate is you run a smart contract transaction on one of the chains, and then you maybe emit a message that gets picked up by the smart contract on the other chain.
00:05:03.520 - 00:06:33.234, Speaker A: But the moment the transaction finishes on your source chain, all the state changes are, you know, all the partial state changes are committed. But maybe your workflow hasn't completed full because maybe you want to do some sort of cross chain swap and you're locking up funds on the source chain, and then you want to perform some action on the target chain by sending funds through. But, you know, the target chain transaction might not succeed. Or, you know, if, if the transaction succeeds, you might have to think about synchronizing the, the smart contract state back and forth. So it's a very concurrent programming environment that I think currently we don't have a very good mental model for tackling. So yeah, cross chain smart contracts, cross chain communication is fundamentally asynchronous, fundamentally concurrent partial state changes can occur and workflows may be non atomic. So then the question is, are there any frameworks that can help us build safer xdapps or more principled xdapps? And the reality is that up until very recently, with these newer blockchains like Solana and Aptos, avalanche blockchains that have very fast finality.
00:06:33.234 - 00:07:55.784, Speaker A: Up until we had these fast finality blockchains, it didn't really make so much sense. To architect smart contracts in a way where your different components and different chains communicate with each other, because you just had to wait too long for a transaction to finalize on one of these chains, and the user experience there wasn't so great. But now if you're communicating between contracts on these fast finality chains, the user experience can be improved because the latency is much lower. But because it's a very early days of cross chain development, there aren't really any cross chain XDAP frameworks yet. And so what I'd like to present now is not so much of an actual tool that you can use or actual framework that you can use to write safe axstaps, but more of a mental framework for thinking about axdaps and thinking about resources in a cross chain environment that is fundamentally concurrent and such that the concurrency can be handled in a principled and safe way. So here's a mental framework for a cross chain architecture. Contracts on different chains communicate with message passing.
00:07:55.784 - 00:09:38.084, Speaker A: So message passing is a very nice primitive because it's fundamentally you run a transaction on one chain that emits a message, and the actual mechanism for emitting this message will require some cross chain interoperability protocol. So wormhole is an example of a cross chain protocol that supports message passing in a generic way, which means your application can emit a message with some arbitrary payload targeting another chain, and wormhole will then take care of taking that message and delivering it to the destination chain of your choice. So an example of a cross chain message is or an example of an application that uses cross chain messaging is the portal token bridge, which is built on top of wormhole. And the portal token bridge is messages are responsible for essentially describing token transfers that are to be interpreted in a cross chain environment, which means on the source chain you lock up some funds, emit a message, which then gets picked up on a target chain, and then the message will allow you to mint wrapped assets corresponding to the locked up assets on the source chain. So that's a very like clean message passing model. And the benefits of message passing is it's pretty agnostic to the runtime environments of your smart contract. So if you think about concurrency, concurrency control models of more traditional programming languages where you, let's say typescript, in typescript you have async await style concurrency.
00:09:38.084 - 00:11:13.388, Speaker A: But the problem there is that it kind of assumes that you're operating in a sort of homogeneous computation environment where you can execute some action and then wait on the result. In the same computation context, message passing is more agnostic to what's actually happening on the receiver side. And in particular that's very beneficial for cross chain communication because different blockchains might have very, very different calling conventions as far as their smart contract entry points are concerned. Memory models, you know, the whole ecosystems might be very different and so communicate with message passing. A very important thing for a cross chain application is that you carefully design the state machine of your user interactions. So if you have multiple components on multiple chains communicating with each other, let's say in like a ping pong style fashion where you're sending messages back and forth, you have to be really careful about designing the error cases of what happens if you're sending a message through that maybe represents a token transfer to a recipient chain, but maybe the smart contract on the recipient chain has a revert condition in it that doesn't allow the user to unlock the funds. Like what do you do then? You need to handle that error case very carefully.
00:11:13.388 - 00:11:57.426, Speaker A: And when you're going back, provide some mechanism for the user to be able to unlock the funds that they put in. If you don't think about these error cases, then users lose their funds and, and that's going to lead to very, very bad user experiences. So try to keep interactive structure simple. That's another very important thing to keep in mind. And what I mean by this is it might be. So again, going back to a typescript example where you use async await style concurrency management. Usually what ends up happening is your program is going to make a lot of asynchronous requests and block on them all the time.
00:11:57.426 - 00:13:07.084, Speaker A: And the interactive structure there is very much kind of a ping pong, lots of pings and lots of pongs. Style model where the problem in a cross chain environment is that you have to wait for finality on all these chains. You have to think about state changes and all these changes, all these chains. So try to minimize the number of messages that you're sending across chains and try to do as much in a single transaction as you can. A very important next property is managing states locally to a session. So cross chain communication, the way I like to think about it is you have a very well specified protocol that describes the state machine of the different states of your transactions or the different states of the user workflow. And in each step of the way you might want to make some state changes, store some variables, store some local state in the transaction, like the on chain component.
00:13:07.084 - 00:14:42.720, Speaker A: But a clean way to think about this is each interaction that users kick off should be represented by some sort of session identifier that keeps track of the whole cross chain interaction. And when you're storing local variables on any of the connected chains, you want to make sure that the local variables are scoped to that session identifier, and you're not sharing resources between different parallel user interactions. So that way you can avoid race conditions very cleanly. So you want to then once the workflow completes, and that's up to your application, what your workflow looks like. In case of a cross chain swap, the workflow might be you send some funds through, perform a swap, and then maybe send the confirmation back. Once the workflow completes, then you want to commit sort of this local state, local state into the global storage of your application. And so these kind of, this framework that I described is a nice conceptual framework, but it actually corresponds nicely to a principled concurrency framework that's called the actor model.
00:14:42.720 - 00:16:30.244, Speaker A: And the actor model is a nice and principled way to think about concurrent, very inherently concurrent applications, which has clean denotational semantics, which means that it's very well understood and easy to reason about. So your application, a good way to think about structuring across chain application is that the components are structured as actors, which then communicate with message passing. Actors have internal state, internal state that's private to them, and they handle errors gracefully. So a programming language, for example, that has an actor model built in is erlang or elixir. And these programming languages have been, have been, you know, proven to have proven to be very scalable in a highly distributed environment, which is exactly the use case that cross chain application development takes place in. So just to think about the presence of cross chain development, I think that the existing smart contract models are currently inadequate for describing asynchronous interactions. So if you think about solidity, there isn't really any, or like even Solana Rust, there isn't really any nice native way to, to describe a smart contract logic that sends a message to another contract and then cleanly manages local state in a way that doesn't interfere with other sessions.
00:16:30.244 - 00:18:34.190, Speaker A: So right now, you, as a programmer who's building a cross chain application, you kind of have to think about rolling these primitives yourself. So, for example, in a Solana context, maybe you keep track of sessions that are happening between different user interactions, and maybe you localize all your storage interactions to PDA's that are derived from the session id and something like that, just to ensure that there's no overlap between your contract interactions. Because sharing global state between concurrent processes is just, is a recipe for disaster. Like you have race conditions, double spending issues, those kind of problems. And you know, that's the present, the future. Depending on how prevalent cross chain applications XDapps are going to be, I think the future in the future there might be a potential for building out kind of domain specific programming languages that handle this cross chain actor model interaction pattern neatly, potentially with multiparty session types, which is a family of type systems that allow you to reason about reason about the sort of the concurrent control flow of your applications in a way that you can write down what your application is going to do and then what you expect a distributed set of components to do before coming back to your control. So I think there's a lot of potential in building out these domain specific languages in the same way that, for example, move is gaining a lot of traction now, where move, the purpose of move is to provide a principled way of describing assets or just application specific resources in a safe way that guarantees no duplication and no copying.
00:18:34.190 - 00:19:08.194, Speaker A: So similar to how move solves the problem of application specific resource management, I think there's a lot of potential in the future for building a language or maybe extending one of the existing smart contact languages with native concurrency control primitives like actor models or session types. And that's kind of the overall vision of what exdap mental framework looks like, at least in my head. And yeah, thanks very much.
