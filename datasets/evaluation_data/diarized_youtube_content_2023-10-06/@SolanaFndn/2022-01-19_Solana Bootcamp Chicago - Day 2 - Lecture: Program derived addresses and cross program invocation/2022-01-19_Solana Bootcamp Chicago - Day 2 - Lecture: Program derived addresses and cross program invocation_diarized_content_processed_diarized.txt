00:00:03.400 - 00:00:39.522, Speaker A: Hey, good morning, everyone. Hope you guys have made good progress in project one. All the instructors will come around after the lecture and sort of help you guys if you have any questions with that. But for today, the first topic is going to be PDA's and cpis, program derived addresses and cross program invocations. But before going into that, I just wanted to do a really quick recap of the lecture content that we covered yesterday. All of this stuff should be fairly familiar, given that you've been working with the Echo program. Public keys are 32 byte strings that are addresses of accounts.
00:00:39.522 - 00:01:41.386, Speaker A: Accounts are just data buffers that could be only written to by a specific program, and users will interact with these programs by sending transactions to them through the JSON RPC. That's the high level of what we discussed yesterday. And today we'll talk about two topics that sort of give Solana a lot of sort of extendable power, right? A lot of times when people talk about DeFi or like blockchain, they mention the concept of composability. Today we'll sort of discuss like how Solana enables composability. So composability, this is sort of the ability for different programs to call other programs at a very high level. So suppose I had a program a and also a program b. If a can do some action, so a can do some action.
00:01:41.386 - 00:02:56.930, Speaker A: Let's call this foo. It's possible that B would also like to do the same thing that a does, right? You could always just copy the code from program a, deploy yourself, and just execute it. But if program a is a deployed program, it's working functionally, it's possible that you want to execute some action that this instruction does, right? And a big factor of this is that for certain accounts, there's only one program that can write to it. So if program a, like, say this food thing, updates an account, right? Like, what does this do? Like, say, this updates an account updates and account owned by a, and then b also wants to update that account. There's no way in which program b is able to do so without calling program a because of that ownership constraint. And the way that Solana allows program b to make a call to program a is through this concept called a cross program invocation. I don't know if I spelled that correctly.
00:02:56.930 - 00:03:37.136, Speaker A: Cross program invocation. We abbreviate this with CPI. This is essentially a way to allow instructions to call other instructions. So previously, when we discussed transactions, I made it seem like it's just a list of instructions, which is technically still pretty accurate. You can have an instruction zero and instruction one and say this transaction has three instructions. However, it's not necessarily true that these instructions don't call any other programs. Each of them have a source program, but they could make cpis to other programs to do other actions.
00:03:37.136 - 00:04:07.554, Speaker A: So in reality this is kind of, it's not like two, it's not like one dimensional. There's a secondary dimension here where like ix zero could make a CPI call to like say another instruction. Like let's call this ix zero one. And maybe this thing also makes another CPI call to another instruction. So maybe the best way to represent this, I guess you can represent it like a tree. So this is like I zero one one, something like that. I don't know.
00:04:07.554 - 00:04:37.568, Speaker A: The representation of this isn't super great, but the idea is that each of these instructions could potentially call other instructions. It's nested. That's the idea behind these cpIs. There's different layers to it. Maybe a better way of representing it. Say ix zero here, this calls another instruction zero zero. And this thing can call another instruction ix zero zero.
00:04:37.568 - 00:04:59.844, Speaker A: And this call like ix zero one. Right. And then there's like different layers. Yeah, that could be a pretty good representation. So this is like layers, it's like zero one two, right. And then everything will execute sequentially. So this is like order of execution.
00:04:59.844 - 00:06:05.514, Speaker A: Let me erase the first part so this becomes a little bit more clear. So this is the flow of like how these instructions actually end up working. Because most of the time when you're working with these programs, it's not necessarily everything is just one instruction deep. This will allow for zero composability or very minor composability, because the only other way that you can invoke instruction from different programs is by chaining them together in the same instruction. So in this example, everything here is going to be executed from whatever program this instruction comes from. So let's say the blue here, this is like the first program, program, program one. Let's say this green here, this is program two.
00:06:05.514 - 00:07:26.448, Speaker A: Program one in this particular example will have an execution path of many different, potentially many different CPI calls, right? So this here is another program that it makes a call to. This is another program it makes a call to. And this third layer deep is a CPI that's made from this instruction. This sort of just demonstrates that Solana has the capability to allow for, you can essentially reuse a lot of code if there's a program that's out there and deployed with features that are desirable to replicate. You don't have to reinvent the wheel, and oftentimes it does not make sense to do so anyway because the standards are adopted and you don't want to break those standards, you want to stick to them. A really common example to maybe make this more intuitive is the token program. So the way that the token program works is that users have access to some amount of token, right? At a very basic level, I have a token account and this has some amount of token, and say it also has an owner.
00:07:26.448 - 00:09:14.334, Speaker A: Let's make it really, really simple. This is a standard that's deployed by the Token program, which means that the token program is the only program that can modify the content of this token account. No other program would be able to do so. If I created a secondary program that wants to modify the content of a token account, say that this program would like to perform a swap between two parties, or perform an exchange between two parties of tokens, there's no way in which that program can do so. It can't change the content of this count, right? So if I were to create like a swap program, swap program, or like an escrow program, for example, that wants to just sort of swap the amounts of two tokens, and let's just say this swap thing will take in two token accounts, tokenaccount one and token account two, and just, just to perform like a swap of amounts, right? Really, simply all it wants to do is to take Ta amount, ta two amount is equal to ta two amount, ta one amount. If it just wanted to do something as simple as this, there's no way in which you could actually change the value of the data inside this token account unless you are able to directly call this token program. So the idea behind a CPI is that it provides the tools for the developer to perform that operation.
00:09:14.334 - 00:10:27.464, Speaker A: So the example that I'm going to go over is going to sort of extend upon the lecture code I went over yesterday with the counter program. I implemented a program that's called Authorizecounter, sort of similar to the authorized echo that you guys will be working on. And the idea behind this is that this is going to be a counter where only an authority can increment the value. So now when you call increment, you also need to pass in an authenticator, right? And what this does is it takes the count and then plus equals one, but only if auth, if auth signs, otherwise we will fail. And this is like very similar to the previous one, but it's a contrived example. But I wanted to use this to demonstrate composability because what I'm going to do is I'm also going to create a secondary program called tracker. Uh, great, that's really buggy.
00:10:27.464 - 00:11:39.776, Speaker A: Okay, let's try this again. So we have the authorized counter. This is just count plus equals one if Auth signs. And we also have a tracker. So what the tracker is going to do is it's going to take in a user and the user will attempt to increment a counter. Right, user increments counter and it will track the number of times a particular user incremented the counter. The counter is owned by this program.
00:11:39.776 - 00:13:13.694, Speaker A: So counter is owned by let's call this AC and let's call this t. This counter is owned by AC and then the tracker will increment the user counter and this is owned by t. The only way in which this program would be able to do so is if the tracker program makes a CPI call to the auth counter, because there's no other way in which this counter variable can get modified. So this thing here must be CPI, this here must be a cross program invocation. There are a few other things here that potentially might be tricky. One aspect is that the authority must sign in order for the counter to get updated based on the spec of this off counter program. And in this particular example, it's not entirely clear what the authority is going to be because really if you want this program to interact with this other program, you need some way of signing.
00:13:13.694 - 00:13:57.508, Speaker A: Who is the signer going to be like? There's no key pair necessarily that exists that the program would have access to. You also don't really want to store a raw key pair on chain. The blockchain is public. So if you were to query, say an account that had access to a 64 byte key pair, and you try to use that to just sign this auth counter, that would be immediate exploit because we now know exactly what the private key would be that has the authorization to upgrade this particular counter, update the counter. So the way in which you mitigate this is you use a concept called a program derived address. And this is an important concept that's really, really useful for allowing for composability. Really.
00:13:57.508 - 00:15:05.404, Speaker A: This CPI concept and PDA concept are like, they really go hand in hand. This is a PDA. In the first lecture I talked about key pairs as being 64 byte strings that follow a certain property, right? So we talked about key pairs. So the key pairs to refresh the memory is a 64 byte strain where the first 32 bytes or 00:32 64. This is your secret key and this is your public key. And there's a property such that you can derive the public key with secret keys. This property is due to the fact that all key pairs lie on some mathematical curve.
00:15:05.404 - 00:16:07.364, Speaker A: The curve is the ED 25519 curve. This is not important, it's just a statement. You can think of it like a boolean statement. So I'm just going to make a very rudimentary sketch about this concept. Suppose you have some curve doesn't look like this, but there is a property that holds that every key pair, either or like every key pair that has a private and public key will be on this curve, right? So this point just representing that is some pair of private, public key and secret key. And it's true that every key pair that you generate that has both public key and secret key will be on this curve. The way in which programs, it is also possible to have a 32 byte strain public key that does not have a corresponding secret key and that would live off this curve.
00:16:07.364 - 00:16:53.784, Speaker A: And that's what a PDA does. A PDA is a public key that is not on this curve. This has the nice property of not having a corresponding secret key. And if a key pair does not have, or if a public key does not have a corresponding secret key, that means that there is no way to sign for that transaction. So let's go over that. Let's go over that process a little bit. So if you have a point on this curve, really what you want is you want to somehow get a 32 byte string, and that's going to be either your public, that's going to be your public key, right? So this is going to be your public key.
00:16:53.784 - 00:17:55.174, Speaker A: The public key of any address generally is going to be on this curve as a key pair. But if it's off the curve, you can still allocate data to it. It's still like a valid address, but it just won't have the ability to sign using a normal key pair mechanism. What the runtime will do is it will expose or not the runtime. What you can do to get a 32 byte strain off of the curve is you call a function called findprogram address. Findprogram address. Conceptually, what this will do is it will take in a list of seeds, which are just bytes and a program id, and move the key pair from the curve to some 32 byte string that doesn't live on the curve.
00:17:55.174 - 00:18:37.424, Speaker A: So this key pair that I've denoted on this curve, let's call this our program. Let's just say that this guy is our program. If you applied this function, what you would essentially do is you would take this point and somehow map it to a different point that's off the curve. This is our PDA. Notice that because we have the program as one of kind of like a seed for this particular PDA, it's related to the program. So it's one to one that you can derive this PDA. You can figure that out if you know the seeds and the program it came from.
00:18:37.424 - 00:19:38.164, Speaker A: There is a slight catch here, though, because it's not necessarily true that if you gave some arbitrary list of seeds. So let's just say that I had seeds like, I don't know, let's say apple, and then like two say these were my seeds that I were to pass into this function. It's possible that where this public key gets mapped to actually does live on the curve. There's no guarantee here that calling the function that hashes it is going to take this guaranteed off the curve, right. Because like, so find program address doesn't just return like the output of this is going to be some new public key and something that, what we call a bump seed. And I'll go over why we need this bump seed right now. Right.
00:19:38.164 - 00:20:54.284, Speaker A: So if you pass in these seeds, it's not necessarily a guarantee that when you, when you hash the function, the resulting public key, the resulting 30 byte two byte screen will be off this curve. It's possible that it will still be on this curve. So in order to guarantee that the public key that's generated is off the curve is that you need to create a new seed called the bump, which is just going to be a one byte that you use to take this point that landed on the curve and move it off the curve. So that goes here. This line here is going to be find program address with seeds and the program id. And this one is going to be find program address with seeds plus bump, bump and then the program id. The bump seed is basically what guarantees that the resulting hashed 32 byte string is not on this curve.
00:20:54.284 - 00:22:02.814, Speaker A: This concept is very, very, very confusing and probably the thing that trips up the most people about salon development. But the important part of this, what this allows you to do is, I think really two things. There are two main benefits of having this idea of a PDA, right? So PDA's accomplish two things, have two. The first one is that the PDA's allow programs to sign for different instructions. Going back to the previous example when I was talking about the authorized counter or the authorized tracker because we need to increment this counter. And this counter requires an authority to sign for the increment. You need some sort of, you need some sort of public key to serve as that authority.
00:22:02.814 - 00:23:26.264, Speaker A: You can't use a key pair, as we discussed, because there's no way in which you can securely store that information. So you need to have some mechanism to do signing. This PDA sort of allows you to do so. Right? So this is solved by PDA. The other major benefit of using pdas is that pdas sort of provide almost like a hash map interface for indexing accounts. Whatever you use for your seeds sort of function as a way to look up the address of a particular piece of data without having to make any calls to the client. So it's kind of like you have a hashmap with some set of seeds, and this is going to point you at whatever account that you allocate to that address.
00:23:26.264 - 00:24:11.166, Speaker A: And this allows you to sort of represent hierarchical structure too. If you ever have a system where you want to present different layers of tiered information, it makes a lot of sense to use your seeds as sort of like PDA's of other components that could be interesting. Like a really good example is if you want a user based account. So say I want to track user data, user data, and you know what the user's public key is. And then you know user's pubkey. And say, you also know like the group of the user. Say like every user belongs to some group that's like known to you.
00:24:11.166 - 00:24:50.074, Speaker A: So you know the user's pub key. And you also know like the group id, right. You can now do stuff with this information to create hierarchical structures. You can make a PDA of the user's pub key. So you can make like a user metadata. This can be some program address. So let's say that this key is like find program address with seeds being the user's pub key.
00:24:50.074 - 00:26:03.438, Speaker A: And say we also want to include the group id in here. And then maybe we have some group metadata here too. The find program address algorithm is deterministic. So this is going to guarantee give you back the exact same public key every single time. And you also, once a particular account has been allocated, the program has full control over what can be written to it. So once it's used, you kind of know what it's used for, right? It's like the key in the hashmap is you know what's going to be contained there. And so if you have this kind of like switching mechanism by using metadata that's provided to you, you can sort of like organize a lot of your accounts in a way, like kind of like a hash map, right? Like, you know that like this particular class of accounts that use this pair of seeds will have a particular structure.
00:26:03.438 - 00:26:32.704, Speaker A: So this user metadata struct has a particular format. And you know that if you have seeds that have this format, this will be the structure of the output data. Same thing with this group metadata. Obviously, this is just like a somewhat example. I came up on the fly. There are many different examples of how you can manipulate the inputs from the user and the data that a particular instruction has access to to create different PDA structures. But this hierarchical information is fairly useful.
00:26:32.704 - 00:27:15.874, Speaker A: Another thing you can do here, instead of using, you can even chain these together. So in this user metadata, I pass in the user pub key and the group. You can even use this key. So let's call this key just G. G. You can use Gk as a second seed and this will explicitly represent the hierarchy because now this second or this user metadata PDA is a PDA of the user's public key and the public key of the group metadata, which is also a PDA, right. So this allows you to sort of like, again, create these sort of nested structures or nested keys that point to accounts.
00:27:15.874 - 00:28:29.384, Speaker A: So going back to that, right, this is why PDA's kind of function as a hashmap, you figure out what the addresses are deterministically and you can decide what the structure of these accounts are based on the structure of the seeds. Let's talk a bit again about why PDA's allow programs assign. The way in which the signature happens is the runtime will know about the current active program id, right? So that is just like a fact about the system. Runtime knows the program id because the runtime knows the program Id. What it can do is it can run the algorithm that generates this 32 byte public key, given the seeds, and back out what the value of the PDA would have been. And so when you try to sign with the PDA, you need to provide the seeds. Right.
00:28:29.384 - 00:29:55.574, Speaker A: To sign the seeds are the signature. You can imagine that there's a way to sort of verify that the signer that the program is trying to claim is a signer. The public key that the program is attempting to sign with can be verified, is derivable from the seeds that are provided inside the CPI. So this interface is part of the CPI. Okay. So I think that covers most of the high level concepts, but in order to sort of make this more concrete, I'm going to go into an exercise where I actually show you how to implement this in rust, and I have a JavaScript client to sort of demonstrate this authorized counter and tracker program. Okay, okay, so let me go over how this authorized counter works.
00:29:55.574 - 00:30:48.904, Speaker A: Yesterday we had a counter object that only had a single value in it. It had a counter, but in this program I'm adding in an authority as well. This is just for a way for me to keep track of who should be the person who is able to increment this account. If we look at the actual instruction content, the increment looks very much the same as before, except now we pass in not only the counter but also the authority and the instruction is going to fail. In the case of the authority is not a signer, I wrote this little helper function called the cert with message. What this will do is if it passes in a false statement, the program itself would just throw an error. Now it works very much the same as before.
00:30:48.904 - 00:31:39.804, Speaker A: If the counter has not been initialized before, the authority that was the signer that was passed into the program will immediately just be set to the signer or to the authority of the counter. Then we make sure if it doesn't hit the stage, if the count is, say, greater than zero, we make sure that the authority on the counter is equal to the authority that was passed into the program. So this makes it so that you can't do any unauthorized increments. Then, as before, we upgrade the counter and then we serialize. There's another program here I implemented called counttracker. This is the tracker program that I was talking about earlier. This is not fully implemented.
00:31:39.804 - 00:32:22.084, Speaker A: There are some things that I'll be doing here, but I want to go over the general idea about how I was thinking about this particular design. So first we try to initialize a tracker. For every user. They first need to initialize and then they can increment the tracker I created as a PDA. The reason why I created as a PDA is I want the tracker to be unique per user and per counter. The way in which I do this is I grab the user's key and the counter's key. This uniquely identifies a pair of user and counter, and the resulting tracker key is going to be the PDA address that this points to.
00:32:22.084 - 00:33:15.464, Speaker A: As mentioned before, because it's not guaranteed that these seeds result in an address that lies off of the ED 25519 curve. There's also a bump seed that is emitted from this function. We can look into the function, it's not super, it's not super complicated, but there is some stuff that happens. Essentially what it does is it loops through a bunch of bump seeds. Bump seeds are just, this is just that extra byte that puts you off the curve, and it tries to run the standard find algorithm and ensures that the actual key is off the curve. There's another function called createprogram address that doesn't do this check explicitly. It doesn't necessarily guarantee that the resulting public key is off the curve, but it will fail if the resulting public key ends up on the curve.
00:33:15.464 - 00:33:42.664, Speaker A: So find program address is a function that is never expected to panic or fail. It should always return you a valid public key that is not on the curve, and a bump seed that takes your seeds and pushes it off the curve. Guaranteed. This is our first PDA. So pdas are used in rust. In the Solana SDK, there are two functions that allow you to use PDA's. The first one is invoke and the second is invoke signed.
00:33:42.664 - 00:34:29.724, Speaker A: The only difference between the two is that you will want to use invoke signed in the case that you have a PDA that is signing for the transaction and for invoke that's not necessary. Use when no PDA's use when Pdase sign. That is the main difference between these two things. They also take a slightly different set of arguments. Invoke signed will take in three arguments the instruction, the account infos, and signer seeds. These seeds are again for the PDA, whereas invoke will only take in these first two arguments. So this last argument I have here in this function would not be necessary if we were not signing with the PDA.
00:34:29.724 - 00:35:11.854, Speaker A: In this instruction, I'm creating an account for this tracker, which is a PDA. To go into what this is actually doing. This system instruction create account is doing the following like before, as we discussed yesterday, the instructions have keys which are account metas. They have data, and they also have the id of the program that's executing them. These account metas here are declared as writable. So the new here means writeable. I mentioned this in the discord yesterday, but to reiterate here, for everyone, this new indicates writable.
00:35:11.854 - 00:35:52.324, Speaker A: The new readonly function would be, if it's not writable, read only. These are the accounts necessary to create. These are the public keys that the program needs in order to create the account. The from pub key is the pub key that allocates the space and pays the initial soul to fund the rent and the tube pub key is the account that's being created. In this case, both of them are signers. This true flag indicates that both need to sign. So when I'm trying to create the PDA, it's a guarantee.
00:35:52.324 - 00:36:40.084, Speaker A: I need to make sure that this PDA has to sign for that transaction in order to create itself. It would be a bug. For example, if I remove this invoke signed and made this say invoke, this would be a bug. The code should compile. If I did this, assuming I imported that invoke function, this won't yell at me for any reason whatsoever. But you would be unable to allocate this tracker account because the tracker isn't signing for the transaction. And so you're going to get a bug when you actually execute the instruction saying that one of the signers is missing because the PDA needs to sign for its own creation.
00:36:40.084 - 00:37:30.666, Speaker A: So now I do a bunch of validation. I make sure that the keys are equal to the derived addresses based on the seeds that were passed in. If it passes through this invoke signed this is a CPI, right? CPI. It's making a cross program invocation to the system program. If it passes this, then I can finally pull out the tracker and set the initial data. So after initialize has succeeded, I will have allocated an account in which I will store the tracker information, the state of which is defined in this file here. So the tracker is pretty simple.
00:37:30.666 - 00:38:15.234, Speaker A: On this tracker I store the bump seat of the tracker. So this is the bump seat of tracker, the bump seat of the authority, the counter which is not strictly necessary to store, but it's kind of useful to have if you wanted to do any aggregation on the client side. This is probably useful information to have in the tracker object and the count per user. Now the important part is to implement this increment instruction. So the idea here is pretty simple. I already have a tracker that's allocated. I pull that information in.
00:38:15.234 - 00:39:08.494, Speaker A: I also verify that the seeds for both the authority key and the tracker seed match. An important thing to note here is I use create program address as opposed to find program address. This is because from the tracker object I store both bump seeds, so there's no reason for me to recompute those values. Notice in the first instruction here I use find. By using find I determine both the bump seed and the resulting PDA. But if I were to pass in this bump seed, if I knew the value apriori and I pass into the list of seeds and use create as opposed to file, it would result in the same resulting address. So the part that I still need to implement is to actually make the CPI to the authorized counter program.
00:39:08.494 - 00:39:54.054, Speaker A: In order to do so, I first need to implement the interface to allow for the CPI. This is very much the same way as you would do this on the client side in JavaScript or Python. You're just creating an instruction. Instruction just has a list of accounts as data and has the program id, and these are both vectors for the accounts. I know that this counter instruction going back into this processor takes in account info and an authority. The authority is a signer and the counter is writable because we're updating the value here and serializing at the end. And the order is first the counter and then the authority.
00:39:54.054 - 00:40:34.662, Speaker A: First the counter and then the authority. So very simply what we can do is we can create a new account meta. This is writable. So I want to use the new keyword instead of read only. We're going to pass in the counter as the key and we're going to pass in the signer as false because the counter does not sign for this particular instruction. For the authority, the authority will sign, but it's read only for the data. The data corresponds to this instruction enum here for counter instruction.
00:40:34.662 - 00:41:58.494, Speaker A: For increment, this is enum zero, but conveniently borscht allows you to use the try to VEC function that will just do this for you. This is instruction and there we have it. This, after I change this, implements the interface that we'll need to use in order to increment the counter from the tracker program. Now in the tracker program we actually need to make the CPI call to the authorized counter program in order to update the global counter that's found there. So to do so we call invokesigned, we call invoke signed, because the authority that we set is going to be a PDA, the authority public key here that we derived with create program address. The instruction that we're calling here is going to be the one that we just implemented in the authorizecounter program. So this is going to be authorized counter instruction incrementally.
00:41:58.494 - 00:42:33.018, Speaker A: The program id is going to correspond to the counter program. It's important that when we make a CPI to another program that we pass in the account info of the program that we're making the call to. Right, because everything in solon is an account, including programs. The program should be one of the inputs that's passed into the instruction. So this program id here is going to correspond to the counterprogram key. The counter is also passed in. All of the accounts that are used by the downstream program from the CPI also need to be passed into the instruction that you're implementing.
00:42:33.018 - 00:43:48.922, Speaker A: That makes the CPI the authority we also have, and the instruction is counter instruction increment. We need to unpack the results and this first argument is now valid. Next, we need to pass in the actual data buffers that the downstream program will interact with. In this case, it's going to be all of the accounts that are also passed into the public keys. Lastly, because the signer of this is going to be PDA, we need to pass in the PDA seize for the authority. Again, if the authority were a normal key pair, this would not be necessary. But because we're making a signature with this authority PDA from this account tracker program, the seeds become necessary.
00:43:48.922 - 00:44:41.312, Speaker A: So that is just going to be authority seeds. The type of this value can be pretty confusing, so it's important to sort of understand why it has the syntax it does or the format that it does. This is a reference to a list to a reference to a list of a reference of bytes, which is quite a mouthful. But the idea here is that every set of signers is going to be essentially just a list of byte strings. And it's possible that you can have multiple PDA's signing for the same instruction. So you need multiple lists of lists of byte strings. Right.
00:44:41.312 - 00:45:55.194, Speaker A: That's why it's a three layer nested object here. After doing so, after doing this instruction, we'll have updated the global counter that's implemented in this authorized counter program, and then we update the tracker for the user. So that was a lot of code. Let's see if this works. The first, try it. It's my devnet. That is not good.
00:45:55.194 - 00:47:26.554, Speaker A: Hmm. It's possible that I already uploaded this code last night, but it seems like I can't deploy to Devnet right now, which is a little concerning. Sorry, did you sign into the Wi Fi? Yes, I did. I can try to sign out and sign in again. So what I just did was I first started a local validator using Solana test validator, and then in my JavaScript client what I'm doing is I am creating, I create variables to point at the tracker program id and the counter program id, and then I create different instructions that actually update the values. So just going through the flow of the logic here, first I checked to create a counterobject. If it doesn't exist, that counterobject belongs to the authorized counter.
00:47:26.554 - 00:48:39.678, Speaker A: Then based on whether or not I've created the tracker. I may or may not call the initialize instructor in the tracker instruction and then I try to increment the resulting data is what really is interesting. So this is what I print out globally. I try to figure out what the global counter is and then I also look what the user count is, right? So if I were to call this instruction again, like run this code again against the counter that was updated, the authorized counter, what we're going to see as the output is that the global count should update to two and the user count should still be one because the user key will be new. Right? So what's happening is that like the first time I called this particular script, I created an entirely new counter, a global counter that has never been used before. That counter again is owned by the authorized counter program and the authority of that counter is set to a PDA of the tracker program. That's what this thing is.
00:48:39.678 - 00:49:36.674, Speaker A: This is the PDA. The second time I called the program I used an existing counter, the same counter that I allocated the first time, but I created a new user key. That's why the user count here is one. So if I wanted to do something new here, I could also load in the user key from a key pair. Okay, I think this should work. So what I'm doing here is I created a key pair on my file system and I'm loading in that, I'm loading in that key pair to use as the user. So as before, now we'll see that the global count is three and the user count is one.
00:49:36.674 - 00:50:42.910, Speaker A: But the next time I call this we'll see that the global count updates to four and the user count updates to two. Great. So the point of this exercise was just to demonstrate kind of the utility of using PDAs and CPIs. The downstream program, which is the global counter, was a global utility that I was looking to use in that tracker program. The tracker program itself has no ability to authorize any kind of state change to any account that's owned by the counter program because accounts can only be modified by the owner program itself. So the only way in which you're able to do so is by making a CPI. However, because the CPI required an authorized operation, the only way in which you can make this work through a different program is using a PDA to sign.
00:50:42.910 - 00:51:20.924, Speaker A: And that's the idea here. The other thing that I tried to demonstrate with this exercise was to use these specific seeds to index the value of those pdas. That's sort of that hash map functionality I was talking about. Earlier. If you can use seeds that are provided as inputs, you can guarantee the uniqueness of certain keys, and the functionality of those keys is sort of like very, very locked in. Right. So if I use a specific set of seeds for the hash of the PDA and I assign a certain structure to that, I can be fairly confident that this set of seeds can only be used for this purpose.
00:51:20.924 - 00:52:13.432, Speaker A: And that's a really useful feature, and it's very powerful to extend programs using this hierarchical key methodology for indexing accounts and. Yeah, so that's the overall idea about how you want to use, and you can and should use PDA's and your Solana programs. This is a very complex topic. I imagine that it's possible that you guys might have some lingering questions, so I'll leave the remainder of the session just to answer anything that the audience might have regarding this concept. Thanks. So, yeah, any questions to the audience regarding this topic? Yeah, so yesterday when we broke through the echo. So the echo buffer account.
00:52:13.432 - 00:52:49.434, Speaker A: Yeah. So if you looked at that skeleton JavaScript in Python code that was given to you in the create account instruction that was called from the client side, it assigns the value of the. It assigns the owner of the account to the echo program. So the echo chrome actually was the owner of that buffer, which is why it could modify the content. Content. Any other questions? Yeah, over here. Yeah, this is an excellent question.
00:52:49.434 - 00:53:36.010, Speaker A: So the question was, why is the bump seed so important? I think, yeah, this is a very, very confusing topic. In reality, it probably isn't the most important thing in the world, to be honest, because when you call this fine program address, it's possible that you land on this curve and it is a key pair. There is a corresponding private key to the PDA that you derived, but private keys are very, very, very hard to grind out. It's computationally impossible. So in reality, there really isn't much risk in having this bump seed, having this lie on the curve. However, as like an extra perceived level of safety, the bump seed guarantees that every PDA is off the curve. So it allows you to be like a distinguishing factor between any PDA and any key pair.
00:53:36.010 - 00:54:10.824, Speaker A: It guarantees that the PDA is not a key pair if you have the bump seed. That's a great question. Yeah, exactly. So that's a good question as well. When you call find program address, it will return the first bump seed iterating from the largest U eight down. That satisfies the property of being off the curve. It's definitely possible to have other bump seeds that also work but find program address will return the first one that does over here.
00:54:10.824 - 00:54:53.208, Speaker A: The question is if there's ever a use case for using the same like a sorry, could you say that again? Different bup seed? Yeah, a different bump seed for the same set of seeds. I'd say that I cannot think of a good use case to do so. The nice thing about using the same set of seeds is that now you have this hash map style property where you can use those seeds as a key to a particular set of data. I'm sure there could be some reason for using different bump seeds, but I've never encountered one in practice. That makes a lot of sense. If that's all the questions, then I'll let you get working on the project. Remember to don't forget the bump seed.
00:54:53.208 - 00:55:16.584, Speaker A: This is pretty important and it is a problem that I've encountered many times in the past. When you make that CPI call and you sign, you need to make sure that bumpsy is included. If you forget it, then your signature is not going to work. That's the last piece of advice I'll give throughout the lecture, but yeah, best of luck with the rest of the project. The mentors and instructors will be walking around and helping you out if you have questions. Thank you so much.
