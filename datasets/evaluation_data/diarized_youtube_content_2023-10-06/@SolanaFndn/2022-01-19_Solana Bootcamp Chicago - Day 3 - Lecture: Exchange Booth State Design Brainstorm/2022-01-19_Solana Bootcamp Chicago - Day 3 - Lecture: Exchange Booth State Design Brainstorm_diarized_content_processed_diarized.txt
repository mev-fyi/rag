00:00:05.480 - 00:00:23.434, Speaker A: All right. Hey, everyone. I wanted to start an informal discussion on project two. So if you're interested in participating, not mandatory, but I imagine this will be quite insightful. If you're trying to get started on this project, come up here. There's plenty of seats. We're going to do sort of a collaborative design discussion.
00:00:23.434 - 00:00:50.534, Speaker A: The way that I imagine this is going to work is you guys are going to pose most of the ideas. I'm just going to write what you say. Due to the fact that this is being live streamed, I think it would be a good idea to speak up. I'll also try to repeat any suggestions and questions you might ask along the way. So, yeah, I'm just going to wait for everyone to gather up here. Plenty of seats. If you want to keep working on project one, by all means continue.
00:00:50.534 - 00:01:55.922, Speaker A: But, yeah, I think this will be very helpful for anyone who's interested in sort of getting a head start on this design process. Cool. So as we mentioned in the earlier lecture today, what we're designing is essentially like a currency exchange booth, and we want to support a number of operations. There is one operation which we create all of the state necessary for the contract. There's one where we allow an admin to deposit. We want to allow the admin to withdraw, and we also want to allow an exchange. There's another one in the spec where we close the account.
00:01:55.922 - 00:02:18.254, Speaker A: That one, I think, is not super important. So we're going to focus on the ones I have listed on the board and just kind of go over what sort of design decisions we want to make to make this contract work. So let's talk first about contract creation. Does anyone in the audience have an idea of what kind of object you might need to store the necessary information for an exchange booth?
00:02:21.394 - 00:02:22.134, Speaker B: Yeah.
00:02:29.594 - 00:03:01.254, Speaker A: Got it. So what he said is, based on the spec, we'll need to at least have a way to store the admin, the two token accounts and mints, and some way to reference the oracle. So let's write that down here. So this is the struct for the exchange booth. So we have an admin, you have some token account. So let's just call them a and B.
00:03:02.114 - 00:03:02.854, Speaker B: Cool.
00:03:15.054 - 00:04:35.364, Speaker A: Is there anything else that you think we might want to have inside this global exchange booth? Object just on initialization. So you could certainly add those if you wanted to. So the question was whether or not you needed the mint addresses of a and B. The answer to that is that that is sort of a design decision that you, as the developer, would be able to make here, both token accounts, vault a and B, will include the mint addresses. But if you feel so inclined, and if that sort of helps you write the source code, it's definitely possible to include the mints as well. Is there anything else? Yeah, you definitely could do that. So if you wanted to make this sort of like a production application that is released to the public, where every single one of these exchange boosts, like, very, like, publicly verified, it's definitely possible that you would want to include some sort of, like, approval stamp or verification.
00:04:35.364 - 00:04:57.574, Speaker A: I think for the purposes of this exercise, the main goal is to make something very like bare bones and dry. So for the initial implementation, I don't think something like this would be strictly necessary. But for, like, a more sophisticated application that you would release, verification is certainly something really important.
00:04:59.474 - 00:05:03.938, Speaker C: Would it make sense to have, depending on your fee structure, like what kind of fee you want to collect?
00:05:04.026 - 00:06:00.930, Speaker A: Yeah, I think that's an excellent point. So, because the way that we've structured this in the spec, we expect on exchange, that some fee will be provided to the person who is organizing the exchange booth, specifically the admin. So some way to represent the fee structure would be a really important component to include inside the design. The way in which you do so is very arbitrary, and that's sort of up to the discretion of the person building the program. But there are a number of ways that you can do fees. One way would just be like a strict basis points fee that's applied on top of trade volume, and you could also do a flat fee per transaction that is up to the discretion of the person implementing the protocol. Okay, so I think in terms of this information, there should be sufficient state to, in the exchange booth to sort of represent all of the things that you might need to know at any given point in time.
00:06:00.930 - 00:06:41.166, Speaker A: But there are also additional caveats to, like, when these pieces of state change and how you will use them. Also like, who is authorized to do certain actions. All of this stuff becomes kind of important. So let's talk about this create operation a bit. Does anyone want to give a suggestion of. I'll just maybe write a couple things that must be accomplished during create. So what are the things that must happen in the program on creation? Things like who's signing, what accounts are necessary, like this kind of stuff.
00:06:41.190 - 00:06:41.422, Speaker B: Right.
00:06:41.478 - 00:06:46.830, Speaker A: Maybe we can start with accounts that might make things a little bit more, like, explicit as to what you would do.
00:06:46.862 - 00:06:47.198, Speaker B: Right.
00:06:47.286 - 00:07:16.362, Speaker A: Because the way that this actually looks is that the create takes in a list of accounts and also has some data, and it's part of the exchange with program. So all of this information is passed into this instruction. I want to sort of have a discussion on what pieces of information are required by the exchange booth program in order to actually implement this create instruction. So let's talk about accounts, Andy.
00:07:16.418 - 00:07:21.094, Speaker C: They probably need like the admin account. They probably need maybe like the.
00:07:25.034 - 00:07:42.824, Speaker A: Yeah, so from the audience, we heard that you might want to have an admin account. You might want to have the mints a and b. What are some other accounts that might be needed for this?
00:07:45.524 - 00:07:47.276, Speaker B: Maybe the vault b and B. Yeah.
00:07:47.300 - 00:07:58.944, Speaker A: So both the vaults are probably necessary for this. What else? I can guarantee we're missing stuff.
00:08:04.754 - 00:08:05.534, Speaker B: Yeah.
00:08:06.714 - 00:08:09.494, Speaker A: Exchange booth account will also need to be passed in.
00:08:11.154 - 00:08:11.934, Speaker B: Yeah.
00:08:13.194 - 00:08:16.654, Speaker A: Oracle ID running out of space here.
00:08:21.954 - 00:08:24.454, Speaker C: Probably the token and the system.
00:08:25.814 - 00:08:43.554, Speaker A: So the token program and system program. Yeah, that's a great point. So I think both of these should probably be as part of the creation. So token program and then system program. Could you explain why these accounts are necessary?
00:08:45.174 - 00:09:01.014, Speaker C: We probably want the program to own the vaults, so we want to create, like, the token accounts inside the init instruction, which requires both the token program and the system.
00:09:01.554 - 00:09:01.962, Speaker B: Right.
00:09:02.018 - 00:09:56.174, Speaker A: So he was basically explaining how when we create this exchange booth for the first time, it's probably beneficial to have these accounts allocated on the fly, which would require you to use a CPI in order to do so. And in order to use that CPI, you need to pass in the explicit account info for all programs that are CPI to. So that's a really great point. Is that all the things that we need, are we missing anything at all, as far as I can tell? I don't think there's anything here that's explicitly necessary besides these values. But an important thing when you're designing this is also thinking about signers and writability. So I'll just annotate these accounts. Which of these accounts do we think should be signers in this transaction, if any at all? Admin.
00:09:56.174 - 00:10:40.174, Speaker A: Yeah, I think clearly admin is probably the only account that explicitly must be a signer. It's possible in the transaction you're creating that some of these other accounts are also signed if they're created on the fly. We can talk about that in a bit as well, but for sure the admin must be a signer. What about writeability? Which of these accounts should be writable? Yeah, Booth, definitely. Why is that? Yeah, so all of these fields in the booth, the main point of the initialization is that you have this empty buffer with this structure, but it's entirely empty. So you need to actually update every single value inside this booth. So that booth needs to be writable.
00:10:40.174 - 00:10:43.134, Speaker A: What are some other things that potentially need to be writable?
00:10:44.434 - 00:10:45.266, Speaker B: The vaults.
00:10:45.370 - 00:11:20.394, Speaker A: Yeah, because the vaults are things that you're most likely creating on the fly. And we can talk about that in a bit, too, because I think discussion of the vaults is very well warranted. But certainly, if you want to go the route where the vaults are created on the fly, they certainly need to be writable because they start up as empty key pairs with no information. And as you go through the create instruction, the vaults are created for assignment allocated. Okay, so now another kind of more critical question is which of these accounts should be PDA's?
00:11:25.854 - 00:11:27.794, Speaker B: Yeah, the faults.
00:11:28.174 - 00:11:29.194, Speaker A: Why is that?
00:11:30.454 - 00:11:31.954, Speaker C: They're pretty much.
00:11:38.434 - 00:11:39.250, Speaker B: Right.
00:11:39.442 - 00:12:12.186, Speaker A: So, yeah, I guess that was sort of a trick question in the sense that, like, there is no need explicitly for any of these counts to be pdas. Like, none of these accounts have to be PDA's. But there are some nice benefits of doing so. Like, for one thing, for the vaults, if you make them pdas, you're right in that there's exclusive access for this one exchange booth. This one exchange booth will access these very specific set of vaults. And the seeds are very well defined, so they're easy to look up. So certainly possible that these could be PDA's.
00:12:12.290 - 00:12:12.866, Speaker B: Right.
00:12:13.010 - 00:13:01.658, Speaker A: So is there anything else that could be a PDA or might benefit from some of the benefits that PDA's provide? So the vaults are definitely one of them. What's the other account that we're primarily looking to allocate here? Exchange booth. Yeah, exchange booth probably also makes sense in some regard to be PDA. Notice that none of these necessarily need to be PDA's. You can always just allocate them on the side and then populate them while you're writing the program. If you were to do it that way, then the system program wouldn't be strictly necessary. Does that make sense to everyone? Because if you just allocate them, you don't have to allocate them in line with the CPI, so you wouldn't need the system program.
00:13:01.658 - 00:13:12.450, Speaker A: If you're looking to reduce the number of accounts that it's required to be passed into the program, it's possible that these accounts shouldn't be PDA's. But that's ultimately up to you guys.
00:13:12.522 - 00:13:13.174, Speaker B: Yeah.
00:13:15.574 - 00:13:20.150, Speaker C: Because when we do the exchange, the admin can't sign for it.
00:13:20.222 - 00:13:57.614, Speaker A: Yeah, that's a great question. So the reason why they don't have to be PDA's is because the authority that authorizes the vault is not the vault itself. So, on the vault, there's a field called owner, and that owner needs to sign for the transaction. As long as that owner is a PDA, the vault doesn't have to be. So the question was whether or not the vaults have to be PDA's because they need to sign for transactions. And my answer was that because the actual signer of the vault isn't the vault public key itself, but the owner. As long as you make sure that owner's a PDA, you should be totally fine here.
00:13:57.614 - 00:14:24.810, Speaker A: But let's go the route of just sort of discussing that. If we wanted to live in a world where all three of these accounts are PDA's, how do we design the seeds? I think this is an important question to think about, because whenever you have a situation like this, seeds are a fairly important thing to keep into account. Does anyone want to take a stab of at least some of the seeds you might need for these accounts?
00:14:24.842 - 00:14:25.414, Speaker B: Yeah.
00:14:28.274 - 00:15:16.096, Speaker A: Okay, cool. So, for the vault account, I heard it suggested that maybe the seeds for this should be the mint and the admin. So maybe I'll go over here and write. So, this vault seeds here. I guess I'll just annotate this as seeds. Okay, let's discuss pros and cons of using these. What is a con of using these two as the only seeds? Or potential, or maybe not a con, but what is a side effect of making these the only seeds of the vault? Think big picture in terms of, like, say you're an admin and you have multiple exchange booths.
00:15:16.096 - 00:16:03.236, Speaker A: What is the side effect of this being these being the two seeds? Yeah, they would be shared. Yeah, exactly. So let's just say we introduced another mint c, right? So this is an exchange booth between, like, a and b. If we created another mint c, and then we had an exchange booth between a and c. If we use these two seeds for the vault, that indicates that both this exchange booth and the other one will use the same vault for holding mint a. Whether or not that's a good design decision is up to you. If you wanted the vaults to be totally separate, like, if you wanted every exchange booth to be an isolated unit, this set of seeds wouldn't be effective to do so.
00:16:03.236 - 00:16:22.484, Speaker A: But if you wanted these exchange boots to sort of share some global state, then. Or not even global, but just have some shared state, this could be a fairly reasonable interface to adopt. So I think that's a really good point. If you did want to make this unique per exchange booth, what would you add for a seed?
00:16:23.064 - 00:16:25.072, Speaker B: Yeah. Yeah.
00:16:25.088 - 00:16:26.104, Speaker A: You would just add the exchange booth.
00:16:26.144 - 00:16:26.512, Speaker B: Right.
00:16:26.608 - 00:16:36.104, Speaker A: So this optional seed here, if you add an exchange booth, there's an optional seed. And again, this is. We're leaving this design up to you guys.
00:16:36.184 - 00:16:36.520, Speaker B: Right.
00:16:36.592 - 00:17:14.414, Speaker A: Like, whatever you think is, like, more reasonable for the program you're developing, you can decide how to assign that. But if you add an exchange booth as a Unix seed, now we've sort of increased the depth of that hash map, and every exchange booth will have a unique set of vaults. So that is one thing that you can do here. Ok, let's talk about the exchange booth itself then. What are some PDA seeds that you would set there? What would be your rationale behind that? Anyone?
00:17:18.034 - 00:17:19.042, Speaker B: Yeah, I think that would be a.
00:17:19.058 - 00:17:59.954, Speaker A: Great way to sort of uniquely identify an exchange booth. So he said that maybe the seed should be the admin to mints. So if I assign the seeds here as the admin, then mint a and b, that's probably sufficient to uniquely identify a particular exchange booth. You could make the argument that there's another seed that you would add here. What seed would that be? Anyone? Yeah, like, if I have two. If I have two mints, right? A and b and an admin. I'm saying that for this admin, this is the only exchange booth they can use.
00:17:59.954 - 00:18:07.228, Speaker A: But that exchange booth has a fixed oracle. It's possible that if you wanted to use different oracles, that would be another portion of the seed.
00:18:07.276 - 00:18:07.700, Speaker B: Right.
00:18:07.812 - 00:18:43.966, Speaker A: And that's, again, another design decision that is up to you guys. Because if you were to make this a production application, who knows whether or not this oracle should be a seed that is provided here? But essentially, this design here isn't all that complicated. It's really just thinking about how to key your hash maps. And when doing stuff like this, it becomes sort of important to think about this because once you start having conflicts that can get sort of difficult to work through. Okay. The last piece of information that I think is, like, sort of important is talking about. I guess we can talk briefly about deposit.
00:18:43.966 - 00:19:47.710, Speaker A: I think in the spec we mentioned, that deposit isn't strictly necessary to implement in this contract. Does anyone want to add some color as to, like, why you don't strictly have to implement the deposit instruction? Or does anyone have a guess as to why if you were to not implement a deposit, you would still be able to use the exchange booth? Yeah, because conceptually, what happens on a deposit is that the admin is simply going to take some of mint a and deposit it into vault a, or take some of mint commit b and deposit it into vault b. It's not strictly necessary to go through this exchange with program. In reality, all you would need to do is just do a direct token transfer. So it's not strictly necessary to have that deposit instruction, but it's somewhat nice as a way to check your work. I guess it is, however, strictly necessary to have a withdraw function. So I want to talk a bit about that.
00:19:47.710 - 00:20:09.604, Speaker A: But before talking going into depth, adding the accounts necessary for withdrawal, I want to maybe discuss how that withdrawal will actually take place. So to make it sort of explicit, like say I want to withdraw some of mint a from vault a, how is that procedure going to look like what needs to happen? Does someone want to describe that process?
00:20:19.244 - 00:20:21.252, Speaker C: You just mean like the parameters you.
00:20:21.268 - 00:20:45.664, Speaker A: Would need for that. Sorry, I can't quite hear you. You just mean the parameters you would need or the actual. Just describe the process that needs to happen. What are the smart contract calls necessary to allow the admin to withdraw from the vault? Like, what contract is getting invoked? What instructions getting invoked? What is the end state after the withdrawal occurs?
00:20:47.634 - 00:21:00.186, Speaker C: Yeah, so maybe you want to for like any arbitrary user to withdraw, you would want to like first check to see like, you know, do they have enough of this code in the ball? Like will it go under zero? Like how much of it is theirs?
00:21:00.250 - 00:21:00.834, Speaker B: Right.
00:21:00.994 - 00:21:10.934, Speaker C: And then maybe after that you just check. Like you would maybe check that or you would check them. I guess it depends on your.
00:21:13.414 - 00:21:13.726, Speaker B: Right.
00:21:13.750 - 00:21:39.272, Speaker A: So this is probably for exchange. We'll discuss exchange in a bit. Like this is for arbitrary user swapping. But like say I am the admin and I want to pull some of my tokens out of this vault. They're sitting in vault A, and I would like to get all of it back, or some of it back. What is the procedure that needs to occur? Vault A is a PDA token account that's owned by the exchange booth. And I have my own token account.
00:21:39.272 - 00:21:46.360, Speaker A: It has some of mint a. How do I get the mint a from here into my token account?
00:21:46.432 - 00:21:46.856, Speaker B: Right.
00:21:46.960 - 00:22:00.816, Speaker A: So vault A is here and then my token account is here. I want an instruction that allows me to transfer tokens from here to here. How do I do that?
00:22:01.000 - 00:22:01.724, Speaker B: Yeah.
00:22:04.564 - 00:22:07.772, Speaker C: Sign a transaction with the PDA.
00:22:07.868 - 00:22:09.852, Speaker A: Yes, you need to. Yeah, absolutely.
00:22:10.028 - 00:22:10.388, Speaker B: Yeah.
00:22:10.436 - 00:22:44.430, Speaker A: So what he said is that in order to allow this to happen, we need to assign a transaction to transfer the tokens with a PDA. Because this vault is owned by the program. There's no way or we want it to be permissionless, right? There are certain operations where the vault can just transfer money to anyone. In order to do so, it needs to have some valid signer. The way that you can have the program dictate authority is by using a PDA. So somewhere in your program you need to assign an owner for the vault. And I think there are a number of ways to do this.
00:22:44.430 - 00:23:45.454, Speaker A: So this vault. An open question that I will leave up to you guys to discuss is who is the owner? Who owns vaults a and b? Specifically, the specific question, the even more specific question is, what are the seeds? What are the seeds? There is not one correct answer to this question or any of this stuff. This is all designed. It's certainly true. It has to be true that the owner of the vaults will be PDA's. It's up to you to decide what the seeds of that PDA are going to be. And, yeah, I think that essentially determines everything you need to know about the process or the initialization of these token accounts.
00:23:45.454 - 00:24:27.544, Speaker A: By the time you go through this create instruction, you'll have allocated the exchange booth, you'll have allocated the vaults and you'll have assigned an owner for those vaults, and that owner has a PDA. So this is all in an effort to prepare you for when you eventually withdraw or you eventually exchange. I think withdraw is fairly straightforward if you think about it. All you really need to do is you need to do a token transfer from the vault back to the user. The more interesting one, in my eyes, is how you implement an exchange, like the exchange instruction. So that's what I want to go into next. Does everyone have access to this whiteboard? Like, are you all good here? Can I erase? Ok.
00:24:27.544 - 00:25:16.914, Speaker A: All right, this is the interesting one. This is probably the more complex instruction. And I imagine where, besides create, where you'll be spending the bulk of your time. How do you implement exchange? Let's start like we did before. What are the accounts that we need in order to implement exchange? Anyone?
00:25:17.694 - 00:25:19.262, Speaker B: Exchange booth. Yep.
00:25:19.318 - 00:25:25.434, Speaker A: Exchange booth. You can guys just yell them out. It doesn't really matter. Oracle.
00:25:29.214 - 00:25:29.750, Speaker B: Yep.
00:25:29.822 - 00:26:21.254, Speaker A: Faults a and B customer token program. Yes, that's an important one. Customer token account. I think this is all we need. If you guys think of something else, just let me know. Off the top of my head, I think this is all that's necessary. It's possible that something's missing.
00:26:21.254 - 00:27:01.634, Speaker A: Let's go through the exercise again of sort of assigning the signers in writable vault a and vault B. That's a great point, but you actually need the content of this stuff too. You need to get the data of vault a and B, and you want to use the oracle to fetch the price. So you need to pass in those as accounts in order to get that information. That's a great question, though. The question for those of you who didn't hear is why we need to add Oracle vault a and vault B if this information is present on the exchange booth. And my answer was that because you want to get access to the data, you actually need to have those explicit public keys in your instruction.
00:27:01.634 - 00:27:24.540, Speaker A: But, yeah, as far as I know, these are the only accounts that are necessary. Let's talk a bit about writeability and signers. What are the explicit signers here, if any at all? Customer. Yeah, I think the customer is the only signer that's really necessary here. Oh, we are missing one account. We are missing one account. And that's fairly important.
00:27:24.540 - 00:27:35.384, Speaker A: Or I guess this is an optional account in a way, but there's one really important account that we haven't added here that we spent some time talking about in the previous section.
00:27:38.284 - 00:27:41.196, Speaker C: Yeah, it's the owner of the ANP.
00:27:41.260 - 00:27:42.644, Speaker A: Yeah, it's like the PDA signer.
00:27:42.684 - 00:27:43.124, Speaker B: Right.
00:27:43.244 - 00:27:55.184, Speaker A: So this PDA signer is not necessarily something that you need to have. The reason why I say that is because if you wanted to, you could make the owner of the vaults a and B, just the exchange booth, for example.
00:27:55.224 - 00:27:55.712, Speaker B: Right.
00:27:55.848 - 00:28:25.124, Speaker A: Not necessarily the case. This is not necessarily the best way to do things. But there's no restriction in making the exchange with PDA the owner of these two vaults. You can even make the vault the owner of itself. There's no strict ban in doing so. So there are a lot of things that you can do here, but if you wanted to go a possibly cleaner route where different accounts have very strict rules or different accounts have very strict purposes, then you might want to add an explicit PDA signer. Question.
00:28:25.124 - 00:28:43.584, Speaker A: Does this get a signer flag when you pass it in the transaction? Show of hands if you think yes. Okay. Show of hands if you think nobody. Okay. There's more no's than yeses if you answered no. Could one of you explain why?
00:28:46.644 - 00:28:47.424, Speaker B: Yeah.
00:28:54.204 - 00:28:55.104, Speaker A: Exactly.
00:28:55.804 - 00:28:56.276, Speaker B: Yeah.
00:28:56.340 - 00:29:32.512, Speaker A: So, because the PDA. So he said that like, when you pass in an account that needs to sign and a transaction, you'll need to get his private key. Pdas do not have any private keys, so there is no way to explicitly pass it as a signer in the transaction. What actually happens when you make the CPI call to the token program is that this will be implicitly added by the runtime as a signer to that CPI. So there is some magic that occurs in the background that allows you to use this as a signer. But that is an important distinction, and I don't want that to throw anyone off when they implement this program. So this covers, I think, all of the accounts that are necessary.
00:29:32.512 - 00:29:52.804, Speaker A: Let's talk about writability. Which of these accounts are writable? And you can just list them out. All right, so I heard this one. That's true. What else? Okay, that's true. Anything else? Maybe. It depends.
00:29:52.804 - 00:30:40.034, Speaker A: And the reason why I say this depends is based on the struct that we assigned. There's no reason why it should ever have anything that's written to it. It's just static metadata. But if you wanted to include more stats on it, like, say you wanted to include volume stats, maybe you would just update that, right? Who am I to say? So it's possible that you would write to this, but that's completely up to the implementation that you go for here. Okay, now let's talk about the tricky thing that I think everyone will struggle with a bit, and that's decimals. So in the mint account, the amount of mint is represented. And I think this might also be in the token account, but definitely the mint account, there is a parameter called decimals, which is going to be a u eight.
00:30:40.034 - 00:31:38.894, Speaker A: I will abbreviate this as d. And then in the token account, there is a parameter called amount, which is au 64. And I'll abbreviate this as a. The actual value of token that someone hur, that someone owns denominated in the mint decimals is equal to a multiplied by ten to the power of negative d. This is the actual quantity of token that someone owns based on how the mint defines the decimal granularity of that particular token. So the question is, how do you actually implement this exchange? That's going to be tricky. How do you represent the price? How would you represent the price that's found in the oracle?
00:31:40.914 - 00:31:43.326, Speaker B: Yeah, yeah.
00:31:43.350 - 00:32:06.434, Speaker A: You would just do a ratio of two numbers. That seems like a pretty good way to do it. Would you represent that as a decimal? Like, how would you go about doing that? Would you follow the same syntax? I guess you could possibly. Let's just say that we follow the same syntax. So let's do a bit of abbreviation then. Let's start with. Let's talk about the different prices we're working with.
00:32:06.434 - 00:32:09.830, Speaker A: So I'll erase some space over here.
00:32:09.862 - 00:32:10.434, Speaker B: Here.
00:32:11.214 - 00:32:36.314, Speaker A: Okay. Right. There's going to be data for this one, but I think the data here is pretty obvious. This is just the quantity of token, some token that you're passing in. So this corresponds to some mint. The data will just basically be the amount that you want to swap. And to abbreviate this, maybe I'll call this a in.
00:32:36.314 - 00:33:27.250, Speaker A: So the input data here, I imagine I can erase this stuff you're receiving an and the decimals are going to be d in. Oh, also, I just realized that we're missing something because we need the decimals. That also requires us to include mints a and b as accounts in here, because the decimals are found on the mint object and not on the token object. So add that in if you haven't already. And just to sort of reiterate, the things I erased, there's a token program, and there's also the customer token account. Okay. But because the decimals are found in the mint object, it is a requirement that these are also accounts that are passed in.
00:33:27.250 - 00:33:43.722, Speaker A: But your inputs are this, right? You get the amount in and the decimals in. And your target is you want to figure out what is your amount out and the decimals out. Or this, you know, that's known. This is going to be found inside the mint account.
00:33:43.778 - 00:33:43.970, Speaker B: Right.
00:33:44.002 - 00:34:15.670, Speaker A: So this is in the mint account. And so is this. This is a user parameter, and this is calculated. One thing that you'll certainly have is like a conversion factor. So the oracle will define a conversion factor, probably some price. So there's going to be some price and then some decimals related to this price. What you'll have to do is you'll have to use this information.
00:34:15.670 - 00:34:38.350, Speaker A: Oh, I forgot another parameter. You also have the fee, right? That's another thing that's important. That's another input here. At some point, you need to apply some fee as well to all of this information. So you have some fee. However you figure, like, however you like denote, this doesn't really matter. If you use a basis points fee, that's also going to be like somewhat of a decimal mutation, right? Like how you would represent basis points.
00:34:38.350 - 00:35:28.428, Speaker A: Or one way that you can do this is you can make the fee some integer between zero and 10,000. And then when you actually do the fee calculation, you would have decimals of four, essentially, because 10,000 would be decimals of four. So you have all of these inputs that are potentially going in. And really your target is once you calculate this number, you want to do a transfer from whichever mint this corresponds to out of the vault. So I will leave all of this calculation up to you guys. But this is the crux of the problem. Essentially, we discussed mainly about the design of all the objects before, but the tricky state logic is all handling, all being handled in this step where you need to figure out based on the input decimals, the input amount, the price decimals, the price amount, and the fee parameters of the exchange booth.
00:35:28.428 - 00:36:03.434, Speaker A: What are the necessary operations that need to be taken in order to calculate the correct amount out. And a big factor that will definitely block you along the way is both the rounding error and numerical overflow. Because these objects here are u, these objects are u eight s. Not super important. What will likely happen is you'll be doing a lot of multiplication. So if you do like, at some point you might have to do like some an times price. Who knows? This might be a calculation that's required.
00:36:03.434 - 00:36:51.172, Speaker A: If you do something along these lines, it's possible that the u 64 itself will overflow the max value. This is not a guarantee. If you have a very large value for decimals, then the underlying representation of the amount will be very, very large too. So you need to figure out how do you avoid numerical overflow? So I guess I'll list out potential problems here. So here are some gotchas, right? One is like numerical overflow, the other one is rounding. You're not working with clean numbers, so it's not necessarily true that these numbers will easily divide each other. You'll be likely left with some sort of remainder.
00:36:51.172 - 00:37:16.564, Speaker A: Where is that remainder allocated to? That's up to you guys to figure out. So these are just kind of the overall pitfalls I think you'll encounter while implementing this project. Some of you, I imagine, will have some experience doing low level operations like this, so it shouldn't be particularly new. But, yeah, just wanted to go over that and, yeah, let me know if you have any other questions or other things you want to discuss. I'll leave the rest of this time open for that.
00:37:18.264 - 00:37:19.004, Speaker B: Yeah.
00:37:19.704 - 00:37:22.124, Speaker C: What parameters are giving us here?
00:37:22.544 - 00:37:32.694, Speaker A: Oh, right. Are you asking what parameters are being provided? Yeah, so I think the only thing you would need for this exchange operation is the amount of token I want to exchange it.
00:37:34.234 - 00:37:35.454, Speaker C: What is the oracle?
00:37:35.994 - 00:38:13.114, Speaker A: Oh, that's a great question. Yeah. So I think that's up to you design, but I think the oracle should provide you this price information at a very minimum. The oracle should tell you what the price is, and it's possible that one other thing you want to do with the Oracle price is figure out some error tolerance. So if the oracle tells you that the price is at $10, but the confidence interval for this is like $7, maybe you don't trust that. So it really depends on what you use for the oracle and how simple you want to make the implementation. In pith, they will actually tell you a confidence band for all the prices.
00:38:13.114 - 00:38:58.988, Speaker A: If you implement a simple oracle, all you really need to do is have some way of representing this interface. That's a great question. It would be a readable account. I think the original vision for this project is that you can use your echo account to generate an oracle. Because the echo account, the way it looks, is you have just some metadata here, there's some meta, and then you have a free buffer of bytes you can write inside this buffer, a structure that represents the price for this particular exchange booth. There are many different ways to do it if you really want to. It's also possible to pass it in as data input, just as a proof of concept.
00:38:58.988 - 00:39:41.612, Speaker A: But in a realistic system, that's not how you would most likely do it. Most likely you would pass it in an account where you would read that information. Are there any other questions? Swap direction. That's a great question. So the way in which I would determine swap direction is because you have the customer's token account that has the mint address on it. So based on whatever mint included in the token account that determines the direction of the swap, it's a great question. But it's also like, if you want to explicitly specify that, I see no reason why that wouldn't be a possible solution as well.
00:39:41.612 - 00:40:24.986, Speaker A: So if you want to explicitly specify that the swap direction should be from a to b or from b to a, that could be passed in as input data to this instruction. Yeah, so I agree. So in that case, if you provide a swap direction, you would only need to provide one of these vaults. You wouldn't need to provide both of them. Yeah, that's a great point. Are there any other questions? Okay, if not, I'll be around if you want to discuss this or any other portion of the project. I'm happy to just meet with you guys.
00:40:24.986 - 00:40:30.434, Speaker A: I'll be walking around as well, but don't hesitate to approach me or any member of the staff if you're interested. Thanks so much, guys.
