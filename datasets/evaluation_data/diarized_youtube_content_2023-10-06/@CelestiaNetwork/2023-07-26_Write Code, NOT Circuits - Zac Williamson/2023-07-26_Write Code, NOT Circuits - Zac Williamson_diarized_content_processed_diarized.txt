00:00:02.570 - 00:00:18.430, Speaker A: Yes, it works. Wonderful. Hello, everyone. So yeah, I'm Zach. I'm the CEO of Aztec, and I'm here to talk about basically, if I can kind of go back. Does this even work? Never mind. Okay, we're not going backwards.
00:00:18.430 - 00:01:10.690, Speaker A: Yeah. So I'm here to talk about how does one turn code into zksackets, specifically with the angle towards looking at privacy. So privacy is hard if you want to, like. The goal of what we're doing at Aztec is to enable users to write smart contracts where you can have genuinely private state variables inside of them. Where they're encrypted. You can still do logic on them, but only owners of those variables with the decryption keys can actually see what's inside. And so we spent a lot of time over the last few years basically trying to figure out how do you take this key foundational technology of zero and launch proofs and actually present it in a way that gives you the benefits of privacy whilst making it accessible to developers without needing to require cryptographic knowledge.
00:01:10.690 - 00:02:28.330, Speaker A: And basically boiling down all of the complexities to do with ZK two and privacy to a relatively simple set of heuristics. So the goal of this is to create rather composable modular abstraction layers that convert the code of a smart contract and basically the consensus algorithms that you're using to verify its correctness into algebra zeros proofs. So these are the abstraction layers that we've come up with, at least when it comes to how to do this. We're taking a very different approach to Brian and risk zero basically because of the private state model. Once you want to create blockchain transactions where you have private state in the mix, then you can't take an existing architecture like Ethereum and then just wrap it in a ZK proof and call a day. Because even if your state is encrypted, the act of modifying it still basically leaks the transaction graph. So we basically have to build a lot of this from the ground up, starting with what do you need to turn a snark code into snarks? You need a cryptographic backend, basically some kind of proving system that will construct and verify zero proofs.
00:02:28.330 - 00:03:14.438, Speaker A: You then need some low level language that you can use to convert programs into circuits. The idea here is that we have this abstract intermediate representation, Asir, which is our attempt at LLVM for snocs. So it basically describes generic ish constraints that are SNOC friendly. And the idea is you can compose a program out of these. You wouldn't write a program directly in this here. But the goal of a sphere is that you take language front ends, like nor like circum, and those which presents, you know, a nice programming language with clean semantics, and that gets converted into the intermediate representation, a bit like how you take rust. And Rust is a language frontend that compiles down to LLVM.
00:03:14.438 - 00:03:52.502, Speaker A: Noir is a language front end for Zk that compiles down into SIer. The goal of this is to be very modular, so that you can swap out various proving systems, so like Haley two, or aztec stuff, Brettenberg or Arquex, to basically fit your own custom needs. And then on top of that, you actually need tuning for your language. And then you need a program execution environment and a transaction execution environment, basically the entire network and architecture infrastructure around sending transactions to a distributed network. So yeah, let's start at the bottom. Zero knowledge proofs. Yes.
00:03:52.502 - 00:04:27.550, Speaker A: Who wants to do some math? I didn't hear you. Who wants to do some math? Yeah, I know. End of the week, we're all a bit tired, so this is nonsense. Basically. It's not nonsense, but a zero knowledge proof is you have a proverb, you have a verifier and some kind of common state, some statement with some public input, secret inputs. And the goal is to prove that your inputs belong to some defined relation, and the premier file runs some sort of algorithm. This is not a program, this is not a smart contract.
00:04:27.550 - 00:04:53.610, Speaker A: This is weird, messy algebra, and it's a pain. It set asides these three like three fundamental conditions. Completeness, soundness, or knowledge. Completeness is basically if you, an honest prover, can always make a valid proof. The verifier wanted to reject a good proof. Soundless means that a verifier will always reject a bad proof. And zero knowledge means that effectively the verify doesn't extract any useful information out of your proof.
00:04:53.610 - 00:05:25.806, Speaker A: Yes, algebra is like, you can't write complex algorithms in terms of algebraic equations, not practically. It's a bit like trying to write a computer program by flipping bits on a magnetic hard drive with a needle. It's not going to work. And so the basic abstraction layer that we have to move from ZK proving systems to snarks is the concept of an arithmetic circuit. So instead of having an imperative program, you have these concept of arithmetic gates. Gates have wires. They go into the gates, they go out of the gates.
00:05:25.806 - 00:06:04.114, Speaker A: The gates perform basic operations like add and mo. And you can use this to sort of represent a program, as in, if you have an infinite number of gates, you can represent any Turing complete computation. Therefore, you can sort of think of it as being slightly ish Turing complete. And we have very nice weight reductions that convert arithmetic circuits into snark systems. And so this makes abstracts away some of the evil complexities of ZK proofs, but not very much of it, because alphabetic circuits, it's still algebra at the end of the day. So, yeah, basically zero knowledge is annoying. It's hard.
00:06:04.114 - 00:07:02.930, Speaker A: We want people who are working with ZK tech to not have to know anything about ZK or cryptography, because it's an absolute nightmare. Okay, so I've described some of the basic abstraction layers that we can use to construct snark circuits, but how do you turn a program into a snark circuit? Programs are these weird, complicated laviathans of code with lots of conditional branching and predicates, and working on complex data structures. How do you turn that into additions and multiplications? Well, you can do it with noir. So this is a programming language that we're building from the ground up to be ZK friendly and support the kind of complex private state models that you need in private transaction environments. And so we modeled it after rust. So it has variables, it has things like integers and booleans like you'd expect from a regular programming language. And, yeah, so it's a front end, basically.
00:07:02.930 - 00:07:48.020, Speaker A: It doesn't compile circus directly into constraints, it just compiles them into SA. And you can plug in any backend you want that supports SA. The goal is to be a completely open architecture so that other folks can customize it to their needs, plug in whatever cryptography they need to get their job done. So yeah, you have even things like arrays, and you can access the arrays with non constant values, which to a programmer is like obvious to a cryptographer. That's really hard, but we can do it. And basic compound types that you would expect so effectively. Nor is like a programming language from the 1960s, but with modern, modern semantics wrapped around it.
00:07:48.020 - 00:08:07.058, Speaker A: We have even things like a module system and sub modules. Isn't that amazing? It's better than C plus plus. We even have loops. And if statements, which again, as a programmer, of course you have if statements. As a cryptographer, you think if statements, they're hard, but we've got them. And so, blah, blah, blah, noir. Noir.
00:08:07.058 - 00:08:22.074, Speaker A: Noir's li. Amazing. Noir is awesome. You should use noir. So let's move on. Okay, so now you have a programming language that takes your high level pregmuter program and converts it relatively efficiently into a snark circuit. You then have a cryptography backend that turns your snark circuit into a zero proving system.
00:08:22.074 - 00:09:02.554, Speaker A: Do you have a private blockchain? No, you don't. Not whether just that all you have is a programming language. What we need is an execution environment. And so basically some system that doesn't need to be physical or real, but that will execute your program and perform actions as a result of what your program is saying. So node JS basically can be considered an execution environment for JavaScript. The Ethereum network can be considered an execution environment for EVM programs. And so this is where noir with smart contract functionality comes in.
00:09:02.554 - 00:09:39.970, Speaker A: So this is basically what we're building at Aztec. It's a way it's adding the semantics around smart contracts into noir. So you can define contracts, you can define functions that operate on public state, private state, you can define storage slots and storage variables like you do in a regular smart contract language. And then on top of that, is this on the next slide? No, it's not. So, sneak peek of contract syntax. So this is the kind of, the kind of stuff that we are developing internally that will be available externally, hopefully next month that allows. So this is just some random example transfer function, but it has weird keywords like secret and a secret balance.
00:09:39.970 - 00:10:39.906, Speaker A: The goal is basically all the complexity around what the hell that means, all of the encryption, all of the weird stuff you do with merkel trees, nullifier sets and witness encoding inside snarks that's all abstracted away, and you get nice easy storage slots. So yeah, basically taking, it's an abstraction that gets rid of all of the ugly stuff on the right hand side. And then we combine that with a real proper bona fide execution environment. That is the aztec L2. It is a rather large collection of snark circuits that compose a L2 network where effectively the goal of the network is to the user will send snark proofs that represent the function calls to various smart contract functions. And the roll up circuit will. One of the roll up circuits effectively will use a lot of recursive proof composition.
00:10:39.906 - 00:11:33.690, Speaker A: So proofs, verifying proofs verifying proofs to basically emulate a cool stack for the user so that you can basically have a function call stack of private functions and public functions, and you can work your way through the cool stack by recursively generating these snark proofs. And then you have a roll up circuit which will take these snark proofs and validate their correctness, perform all the state updates, validate or correct? Do fee management, do consent like all of the sequencer selection, consensus algorithm checking, and you end up with a proof of a block. But not just any block block, a block which has an encrypted state tree. So yeah, that's the ZK three roll up. It inherits Ethereum's security. We're leaching from Ethereum's consensus like all other L2s. But the critical difference between aztec and the other things is the fact that we support both private and public state, and you can use that to create hybrid applications.
00:11:33.690 - 00:12:35.326, Speaker A: Something I often get asked is, what can I build with privacy? Right? Privacy is like this weird abstract concept, and we don't have it in web3, not really. So how to articulate this? One of my go to examples is Webwolf sign in flows, or specifically things like, let's say you want to sign into a web3 account using Apple ID. Using like FaceTime. No, not FaceTime, Face ID. What will happen on your phone is that your phone is going to use its hardware security module to sign a digital signature according to a message format defined by Apple and according to a public key that is also described by your Apple ID. There's no reason why you can't verify that in a smart contract using account abstraction, and that can then become the default portal to your account. However, without privacy, that means that every time you transact on chain, everyone can link those transactions to your specific Apple ID, which is rather problematic if you're doing anything with any kind of real value associated with it.
00:12:35.326 - 00:13:08.390, Speaker A: Maybe you don't want people to know that you're trading degen board ape nfts with all your life savings. So that's one example. Things like Dow governance, private voting. One of the key problems with Dow governance right now is the massive social pressure to vote according to certain ways. And for better or worse, privacy means that people can vote according to their conscience. Perish the thought. So, yes, maybe in a year or two we will be able see the true dark heart of web3 and what our community really thinks.
00:13:08.390 - 00:13:38.420, Speaker A: Some of the things you can do with privacy, there's the obvious user hiding properties. You can hide your identity and you can then link your cryptocurrency account to a real world identity. I'm actually at the end of my talk because I blitzed through all the last slides and this wasn't supposed to be a 15 minutes talk. I got the timings wrong. So we have a few minutes of questions. Thank you very much.
00:13:42.790 - 00:13:45.140, Speaker B: Does anybody has a question?
00:13:50.070 - 00:14:40.134, Speaker A: So you mentioned public and private applications. Do you have an example of how that would work, or what are the use cases for both of those at the same time? Yeah. So the reason why you'd want composable hybrid applications is because there are a lot of decentralized applications that require global state. And one of the difficulties with an encrypted state database is that in a private world, state is owned by individuals or groups of individuals. It's encrypted against their public key. And so consider a defi app like Uniswap, or any kind of automated market maker, where you have concepts like the total supply in your network, liquidity pools, things like that. That's all global state, and therefore needs to be public.
00:14:40.134 - 00:15:57.946, Speaker A: And so then the question becomes, well, okay, well, how do you get privacy guarantees with a dex? Well, one thing you can do quite easily is you can keep the token values public, but the identities private. So the idea is that you can have token contracts which have basically privacy preserving functions which allow you to hold shielded balances, and then you can directly deposit those. You can basically deposit those value deposit into a Amm like Uniswap, where the value of your tokens is public, but the identity is private, and then you would have the public uniswap algorithm execute the trade in many ways. I suspect this is going to be quite a popular model in the future, because it gives privacy for the user, but it still means that you get transparency for the protocol. So you still know that whatever algorithms are being executed by the protocol have been run correctly. There's no centers of trust. And longer term, you can close the circle and make the entire system private by adding in multiparty computations so that all of the price finding algorithms that an Amm uses are executed in a multiparty way so they can actually be genuinely private.
00:15:57.946 - 00:16:01.680, Speaker A: But that is a future project to be built.
00:16:02.930 - 00:16:25.990, Speaker B: I think we have one more question. Yeah, time for one more question. Hey, so you had a slide there where you sort of described from ZK to snark using a circuit, but then from a snark to a programmable environment, I'm still like, how do you turn then a circuit into a place where you can do all of this? You talked about the language, but where is it?
00:16:26.060 - 00:16:51.370, Speaker A: You're right, I did. Skip that. So, let's go back. So, the first kind of system that kind of did this was the Zexi protocol from 2016. So we have the concept of a kernel snark circuit, where what a kernel circuit does is it verifies the correct execution of a single function call. So let's imagine now you have a smart contract. Your smart contract has public functions and private functions.
00:16:51.370 - 00:17:22.038, Speaker A: Each function is converted into a snark circuit. And so then what a user does is they construct one of these kernel circuit proofs where the kernel circuit takes as an input a function call stack. So at the very start, that function call stack will have one entry in it. It'll be the function that you want to call. And what the kernel circuit will do is it'll pop that function call off the call stack. It will verify a proof that you've provided. Assuming you want everything to succeed, you provided a proof that proves that the function call has been executed correctly.
00:17:22.038 - 00:18:07.314, Speaker A: The kernel circuit will verify that the verification key belongs to a specific smart contract. And then what the kernel circuit is going to do is it's going to grab the public inputs of your inner snark circuit, the one that made the function call, and interpret those inputs according to a defined ABI. And as part of that ABI, that function call may spit out additional function calls to be executed. So if you have, for example, you want to call approve, and then you want to call transfer from on different contracts, for example. And so that's one iteration of the kernel circuit. But the kernel circuit is recursive in that it verifies a previous proof of itself if one exists. And so what you can then do is you can repeatedly construct proofs of the kernel circuit.
00:18:07.314 - 00:18:42.590, Speaker A: So to start with, you have one function in the call stack that gets popped off and verified, but then more functions get pushed onto the call stack as a result of your first function call, and you just repeatedly construct proofs until your function call stack is empty. And then the output of that is, well, you now have a proof of a Kelsey circuit with an empty function call stack. So no one knows what functions you've called. But also spat out of that proof are basically a bunch of encrypted state changes, state updates to perform as a result of those functions being executed. And that's kind of sort of how you can get a quasi execution environment out of a snark circuit.
00:18:44.530 - 00:18:46.242, Speaker B: Okay, day. Thank you, Zach.
00:18:46.386 - 00:18:47.060, Speaker A: Cool, thank you.
