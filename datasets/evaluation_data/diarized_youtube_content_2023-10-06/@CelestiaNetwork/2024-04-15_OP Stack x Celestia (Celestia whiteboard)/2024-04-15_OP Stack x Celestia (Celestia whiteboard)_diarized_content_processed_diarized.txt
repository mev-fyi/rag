00:00:01.560 - 00:00:29.974, Speaker A: Hello. Good afternoon, everyone. Today we'll talk about op stack. But first I want to refresh our memory about l one's in general. Then we will move on to l two s and how op stack l two scales ethereum. So let's talk about l one for a bit. So as we all know, like in a general l one ethereum, the user, let's assume it is Alice.
00:00:29.974 - 00:01:10.550, Speaker A: Alice has like 100 coins in her wallet. She wants to send this to Bob. And current state is Alice has 100, Bob has zero. So Alice wants to use Elmon Ethereum to send 100 coins to Bob. So what does she do? So she creates a transaction using her wallet, maybe like metamask. And this transaction is basically a signature over this data, and it's broadcast to the l one ethereum p two p network, like we all know. So there are geth nodes in the l one ethereum p two p network.
00:01:10.550 - 00:01:46.424, Speaker A: So it's a p two p network. So there are multiple nodes. So this all nodes are part of ethereum l one network. Now, all of them are gossiping, or p two p. So when one of them gets Alice's transaction, they basically gossip that to each other. And one of them will be a validating node, which will produce a block, and the block will include Alice's transaction. So that's how Alice transaction will get confirmed.
00:01:46.424 - 00:02:28.163, Speaker A: Let's assume this is a block producer. It produces a block which has Alice's transaction in it. So let's assume Bob is also on the network, and Bob is waiting for Alice's transaction to Karguru. So Bob connects to the p two p network. So when Bob receives this new block, which has Alice's transaction, Bob's node on the network also receives it, and Bob's balance gets updated. So the new balance is Bob has 100, Alice has zero. And that's how generally l one networks work.
00:02:28.163 - 00:03:50.826, Speaker A: So the main reason why l one's having so successful is because they have these fundamental properties which are behind this successful mechanism for broadcasting and receiving transactions. Two of those properties which are very useful and which we can exploit are consensus and censorship resistance. Let's look at what these properties are and how we can exploit them to create an l two with scales for consensus. All that matters is that if Alice tries to double spend, so if she tries to send 100 to bomb, but also tries to send 100 bags to herself being malicious, then this transaction will get rejected because the p two p network reaches a consensus, not which transaction is valid and which is not. So if the p two p network sees that there is a double sign, then it rejects the transaction, because all p two p nodes are in consensus, that only one transaction should be valid. So that is consensus. What is sensory persistence? So whenever Alice wants to sense a transaction, there is some node on the network that is willing to receive the transaction and accept the transaction into a block.
00:03:50.826 - 00:04:31.500, Speaker A: Because if Alice wanted to send, and nobody was willing to accept that transaction, then there wouldn't be a way for Alice to send this transaction to Bob. So that is sensitive persistence. So we are going to see how we can use consensus and sensory persistence to create an l two network. Let's move on to that next. Yeah, like we saw the major, the main properties that we're interested in exploiting for creating a scalable ed to network, our censorship, resistance and consensus. So now let's imagine Alice wants to send a transaction on l two network. It's going to be the same flow.
00:04:31.500 - 00:05:30.946, Speaker A: Alice is going to send some coins over to Bob, but there are some more complexities involved. For example, how does Alice get those hundred coins in the beginning in the first place? Right, because this is a new network. She had some coins on l one, but how did she get those on l two? And then also, if Bob received those coins, and Bob wants to transfer those coins back to l one, then Bob has to do a different transaction. So there are three different types of l two transactions. There are deposits, there are usual l two transactions, and then there are withdrawals. So we are going to see all of these, but we are going to focus on l two transactors on l two transactions, because majority of the transactions that are happening on l two network are l two transactions. So once user deposits, they do some l two transaction and then withdraws most of them.
00:05:30.946 - 00:06:00.684, Speaker A: Most of the majority of the network transactions are going to be l two transactions. So let's assume for a second that deposits and withdrawals are handled, and let's go through the end to transaction. Then we'll come back to deposits. So we have Alice again here. I'm going to erase this and come back to this. Let's assume Alice already has some coins on l two. So Alice balance is 100, Bob's is zero.
00:06:00.684 - 00:06:45.220, Speaker A: So Alice sends a transaction. Now, this is an l two transaction. It is very similar to an l one transaction, except that it's on a new chain id, and it's spending from Alice's l two wallet. So Alice goes to metamask as usual, but she's on l two network. She creates a transaction. And now this transaction goes to the execution environment. So the execution environment in this case for Opstack is l two geth, which is a fork of get with exactly all the features that are already in l one.
00:06:45.220 - 00:07:47.484, Speaker A: But special handling for deposits and withdrawals, we'll see those later. For now, it's safe to assume that this is basically same as the l two get, is basically same as the get execution and nodes that were here except for some minor changes. So in this case, l two get serves only as the execution environment. There is no p two p network consensus on this, but it simply executes a transaction, forwards it to something called l two node. So Alice sends a transaction to l two get, which forwards the transaction to an l two node. Now, l two nodes are again in a p two p network, so they have the same p two p network and gossiping between them. So whenever any single node receives alices l two transaction, it gets gossiped all over the network and one of them is going to be the block producer.
00:07:47.484 - 00:08:28.694, Speaker A: So it includes alices transaction into an l two block. So now this transaction is part of the l two block that are being caused in the l two nodes. So the important property from last time, which is consensus and sensitive persistence. So we are going to use that to manage this transaction. So generally, like in any blockchain, there is like the data that is involved and the flow that happens is that there is some input. So there is like a previous block that has some state. Let's assume that state is input and this goes to the execution environment that produces some output.
00:08:28.694 - 00:09:10.804, Speaker A: So right now we are here where Alice has a transaction. It went through the execution environment. It created the l two block. So how do we use the previous properties to scale the l two here? So how much of this data, this link, input, execute and output. Do we really want to be able to manage our l two? So outputs can be derived from the input, so we don't need to manage all the output data that is being generated. So like Alice's initial state here, that's part of the input. The final state is Bob will have 100.
00:09:10.804 - 00:10:42.456, Speaker A: As long as we have the execution environment and the input, we don't need to store the output anyway in any way because it's really costly to save the state on a decentralized network and it is easier to manage by having the execution environment and the input anyway. So this kind of a derived data, we don't really need this, but we still need some commitment to it, which makes it easier for withdrawals. So the output states that are being generated on the internetwork we will just use their state routes. The execution environment is part of the network, so it's kind of like we don't really need to worry about it because we will add a consensus rule that only the l two execution engine that we are supporting on the network is the canonical execution environment. So we don't need to worry about the execution environment now, which leaves us with inputs. So all the input data that is being generated, that is the data we want to add to our consensus layer. So if the input data that is being generated, like in all the transaction flow, can be added to the consensus layer, then we can rederive the outputs and we don't have to worry about having the output separately.
00:10:42.456 - 00:11:28.420, Speaker A: So all our majority of our worries basically how to manage the input data that is being generated on our end. So as we saw, our basic worry is to have all the inputs stored somewhere safely so that our l two chain can be really like. So this is the l two network. So one of these l two net nodes will be a sequencer. So we saw here that this node is producing blocks. So this node is also going to write some data to the l one from the previous session. So it's going to write some data that is being generated, the inputs to the l one.
00:11:28.420 - 00:12:14.376, Speaker A: It's going to split that data into batcher and proposer to be managed separately. Like we saw, the output routes that is being, that are being generated will be handled by the proposal, and the input data will be handled by the batcher. Now, batcher is going to compress this input data like it's going to use compression to lower its cost of writing that data to l one. Proposer is only writing state routes, which are 32 bytes. So that's kind of simple. Now, both the proposer and the batcher are going to write data to l one. So this is the previous network that we saw where users were sending transactions, somebody else was receiving them.
00:12:14.376 - 00:12:45.006, Speaker A: But in this case, the batch and the proposal are only writing. So the batchelor is writing something called frames. Frames are derived from the l two blocks that are being generated. We don't need to worry about the terminology too much. It's just easier to assume it has chunks of l two blocks that are being generated. So if you have all the frames, you can regenerate all the l two blocks. And the proposal is writing state roots that were being generated previously.
00:12:45.006 - 00:13:24.406, Speaker A: So all this is being returned to l one. The l one is kind of like it's the consensus layer for this data. So previously we saw that Alice sent a transaction to Bob directly. Now she's sending it through this l two stack. So when Bob wants to receive that transaction, they are going to be listening to this l one to rederive l two blocks from. So as we saw, it has data for recreating l two blocks in the as frames. So there is going to be another l two node here managed by Bob.
00:13:24.406 - 00:13:58.604, Speaker A: So this is all part of the l two stack, and that is kind of the write section. And this part going to the part of the read section. So there are other nodes on the same network. So we saw that the networks are blossoming transactions, creating blocks. When they're writing to l one, they're also reading from the l one. So they're going to read frames that were previously generated and they're going to recreate l two blocks. So the data that was previously here, Alice's transaction, was part of the l two block that this nodes were gossiping, which was returned to the l one.
00:13:58.604 - 00:14:54.104, Speaker A: Now it's rederived into the l two block and it contains the same data, so it has Alice's transaction in it. These l two blocks are read by Bob, who receives their transaction. So we saw how, using the consensus layer of the l one, the data that Alice was initially directly writing to l one, now it's being sequenced by a section of a new l two network, and it's being returned to l one, and it's being written as part of multiple transactions. So it's kind of being batched. So all these l two blocks. So, for example, let's assume these are the l one blocks. So those l two blocks are kind of like bunched up into l one block.
00:14:54.104 - 00:15:57.780, Speaker A: So there can be multiple l two blocks which are aggregated using this network into l one. So it allows for a higher throughput on the l two network. This is the usual l two op stack flow. Now, with celestia underneath, there is a minor modification to this network, which is that when the batcher was writing the frames directly to l one earlier, it is going to write to the da layer, which is celestia in this case, and to the l one, it's going to write only frame pointers. So the height at which the data was included in celestia and the commitment to that data. So only that data is written to l one. And whenever the roll up nodes, other nodes want to recreate blocks, they are going to read the pointers from l one, but they're going to fetch the data from the da layer celestial.
00:15:57.780 - 00:17:22.754, Speaker A: That's just a minor modification which makes this op stack less celestial, which is that the batcher, instead of writing the whole frames to LMN, it only writes a frame pointer, and then it writes the actual frame data to be. And then the same frame data is downloaded from Celestia on a different l two node. So this is the transaction flow for usual l two transactions. Let's talk about the deposits and withdrawals so that we close the loop of here. So when Alice wants to deposit some transaction from l one, she can either create, she can either send a deposit to a special l one contract, smart contract, which is being listened to by the network. So whenever there is a special event emitted on this smart contract, the l two nodes know that some new deposits have arrived and they need to be included in the blocks. The consensus of all those network, all those l two nodes, is that whenever there is a new epoch on the l two network, any epoch is just a fancy way to say start of a block on the l two network.
00:17:22.754 - 00:18:13.284, Speaker A: So whenever there is a new deposit on the l two network, the first block should include transactions which are deposits. So if transactions which are deposits are not included in the first block, the consensus rejects that blocks. So this is a way to force inclusion of transactions from l one to l two. And then when withdrawals. So when Bob has got their updated balance, so now Alice has zero and Bob has 100, and they want to now this stay on l two, right? So they want to withdraw to l one. So they go to a smart contract on l one and they add their withdrawal details. So they first create a withdrawal transaction on the l two network.
00:18:13.284 - 00:19:02.178, Speaker A: And the l two network, as we see, as we saw here, the l two network, whenever it has a new state route, it pushes that state route to l one. So the l one knows the status of pending withdrawals. And when Bob creates this transaction, and they can go to a smart contract for withdrawals on l one, and they can prove that they have a pending. They have a pending withdrawal by proving that they have a commitment to this proposal. Submitted state routes on l one. And now that smart contract can say, okay, you have a pending withdrawal, so you're good to go at. So these are withdrawals work.
00:19:02.178 - 00:19:18.274, Speaker A: So now, now Bob has a balance on l one because of the withdrawal. So yeah, that is how the transaction flow works. Any questions? That's it.
