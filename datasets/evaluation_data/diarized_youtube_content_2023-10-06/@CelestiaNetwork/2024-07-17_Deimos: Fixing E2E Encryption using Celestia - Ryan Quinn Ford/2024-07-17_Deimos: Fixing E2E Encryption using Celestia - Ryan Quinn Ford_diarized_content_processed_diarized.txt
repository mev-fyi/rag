00:00:01.800 - 00:00:56.394, Speaker A: So I'm here to talk about intern encryption on Celestia or how we can fix it. Before I get started, I like to say I'm actually giving this talk on behalf of Sebastian Pusch, who can make it to the conference, but he's been leading this internal effort and has written the vast majority of the code, so you'll all meet him soon. But what am I talking about? So we all use these int and encrypted chat apps like signal and WhatsApp, and we see ads about them all the time, about how secure they are. I mean, WhatsApp imessage is also encrypted. There is signal, but they all have a problem. So these services generally consist of two components, if you simplify them down there is the messaging server, which is actually. There's nothing wrong with this.
00:00:56.394 - 00:01:32.528, Speaker A: So only encrypted messages ever hit the server. They can't read anything. Signal doesn't collect any metadata. That's all fine, but they also consist of a key directory, because if you want to talk to me over signal, you need to ask signal what my public key is. And there's no cryptographic guarantee that the person you're actually talking to then is me, because signal could provide you with a key directory that they don't provide me. So they provide you a merkle proof that they. That you are talking to my key.
00:01:32.528 - 00:02:01.190, Speaker A: But they could also just give me a different, entirely different tree, and I verify the smirkle proof. And it doesn't mean anything. So why would they do this? They can do a machine in the middle attack. This is what the UK government proposed in 2018 with ghost, and it's pretty malicious. How does it work? Well, this is how it works in a trustworthy service. So this is what we kind of expect. If Bob wants to talk to Alice, Bob requests Alice's public key from the key directory.
00:02:01.190 - 00:02:31.436, Speaker A: The key directory returns Alice's public key. You encrypt your message with your public key, and then that gets relayed to the message service. Then the message gets relayed to Alice, and then Alice can decrypt it, of course. And the machine in the middle attack that they can do is really trivial. Instead of returning Alice's public key, they return you one of their own key pairs. And then when they get the message, they can simply decrypt it. And so in the best case, this is just eavesdropping.
00:02:31.436 - 00:03:06.216, Speaker A: They can read all of your messages, they decrypt the message, but they can also modify the message. And so when they get it, they decrypt it, then they just encrypt it again with her public key, with a real public key and she can decrypt it. And if you know a little bit more about the signal protocol, this works pretty much the same with double ratchet. It's left as an exercise to the reader. So yeah, this is a huge problem. But don't worry guys, they fixed it. Everybody knows about these things called security numbers.
00:03:06.216 - 00:03:56.410, Speaker A: I mean, maybe you haven't seen these screens because nobody actually uses them, but you probably have seen when you're using these apps that your security number has changed with a person. So what does this actually mean? You might know. I mean, there are engineers here, but general public does not really understand what it means to. So they fixed it, but they didn't really. I mean, the issue with this is that it doesn't scale. There's a study done in 2017 that only 14% of users were even able to find the security number in the UI. After previous education of what an authentication ceremony is, they were able to find the information after, I think four minutes and then complete the ceremony after another five.
00:03:56.410 - 00:04:30.270, Speaker A: And they still had no understanding of what this even did. I mean, really what you're doing is comparing that the Merkle route they gave you is the one that they gave your conversation partner and you have to do this in real life. You need a third trusted communication channel to do this. And they recommend that this is done in real life. Of course, it's the only true third trusted communication channel. And what if you're on the other side of the world? You can't really verify it with them. I mean, you also can't verify it over signal, of course, because they can just modify the messages, like I said.
00:04:30.270 - 00:05:00.210, Speaker A: So this is a huge problem. And so this means that all current end to end encrypted messaging services are not trust minimized at all. You're needing to trust the service provider to provide you with the correct keys to the service provider. We can look at a few examples here. There's Keybase. Keybase is pretty interesting. They actually write the merkle proof and all the operations to this key directory on the stellar blockchain.
00:05:00.210 - 00:05:33.960, Speaker A: But the issue is that the client does absolutely nothing with this information. And even if it did, Keybase would just be running some RPC to stellar that you're then needing to trust when they serve it to you. So you're not actually getting rid of any trust assumptions. I mean, technically Keybase is then unforkable, whatever that means, but they can still trick single users that they don't expect to check this. They provide a script you can run on your computer to verify against what they post to stellar. But nobody does this. They can still trick you.
00:05:33.960 - 00:06:06.080, Speaker A: WhatsApp is a little better. They spent a lot of money in researching this problem space key transparency and have some custom solutions. They have something called the auditable key directory. They publish audit proofs to Amazon s three bucket, which obviously isn't that much better than. Well, it's obviously not better than stellar, it's a bit worse. But the client also does nothing with this information, so they can still trick individual users. And even worse, WhatsApp is closed source, so you don't even know what they're doing.
00:06:06.080 - 00:06:33.364, Speaker A: And yeah, so not really any better than Keybase. And the protocol that everyone's probably interested in here is signal. What does signal do? Signal is the best in the encrypted messaging app. Right. The issue is that they have absolutely zero solution for key transparency. They don't post it anywhere. You have absolutely no idea what signal is doing, where the merkle routes are, what they're serving you.
00:06:33.364 - 00:07:02.590, Speaker A: At least they're open source. The social consensus is of course that we can trust signal more than WhatsApp. But from a purely technical standpoint, you can actually trust WhatsApp's key transparency more than signal. And this really surprised me, obviously. And imessage is also similar. They have zero key transparency. They offer security numbers, but they're worse than signal on WhatsApp because they don't even show you that your security number with someone has changed.
00:07:02.590 - 00:07:16.610, Speaker A: It's off by default. So yes, very bad. And so, fuck signal. Fuck WhatsApp. All my homies hate unauthenticated Internet encryption. It's really terrible. It's really a problem that needs solving.
00:07:16.610 - 00:08:09.646, Speaker A: So what do we do? I mean, in order to talk to someone over the Internet, you shouldn't need to verify a security number with them in real life, especially if you're not an engineer and have no idea what it's doing. Like, this is terrible UX and everyone uses these apps. Everyone should be able to have the right to talk to someone securely over the Internet without needing to understand some obscure cryptography. Well, it's not obscure, but for them it's obscure. So end to end encryption doesn't cut it. We need authenticated end to end encryption and by default. And so how do we solve this? So the question is more like what does an ideal key directory mean? Well, one of these things is if your client needs to be authenticating or verifying proofs.
00:08:09.646 - 00:08:54.542, Speaker A: Like for example, I said that WhatsApp posts proofs to an s three bucket. You need these proofs to be small, you need low bandwidth to the chat client, the compute overhead needs to be small. This is also a big problem, because WhatsApp, for example, they post tens of thousands of merkle proofs per minute. And obviously your chat client cannot keep up with this, let alone then verify the proofs. And then you also need somewhere to post this. So instead of AWS or stellar, you should probably post it on a DA layer. And while you're doing that, you actually can't trust an RPC, like I said before, because the service provider is probably also running this RPC themselves, and then it doesn't get rid of any chess assumptions.
00:08:54.542 - 00:09:30.302, Speaker A: So you should integrate a node that can communicate directly with this. This key directory should also be wasm compatible with the client at least, well the client, so that you can build it into web apps easily. Everything that needs an identity layer, which is kind of what a key directory is, zoomed out, are mostly web apps. And these chat clients are also all web apps. So needs to be wasm compatible. And most importantly, it needs to be abstracted away completely from the user. Users should not need to care at all about this, they shouldn't need to do any ceremony.
00:09:30.302 - 00:10:07.386, Speaker A: They should just be able to chat with someone and see that their connection is secure, that they're auditing this service provider. Basically just a checkmark or red x if you're not caught up, something like that. So the good news is that it's real. So this is how we solve it every epoch. So this is like a block for us, like a minute or so, you generate a snark over all of the operations that were done in that epoch time. So instead of tens of thousands of Merkel proofs, you have one succinct proof. That's very small.
00:10:07.386 - 00:10:45.374, Speaker A: We don't really care about the ZK property here. I mean you can use it for other things. If you're interested, you can talk to me afterwards. But the main point here is that you have really succinct proof. And then we publish that snark to Celestia, the wasm client that we have just downloads that snark directly from the DA layer, verifies it. And what this means is that just by running a light node in your chat client, you are automatically verifying the service provider and you no longer need to trust them. It's user verify and it's by default.
00:10:45.374 - 00:11:38.402, Speaker A: So this is really nice. So this is kind of how it looks like essentially signal publishes the user's keys to the key directory. Your app talks to Celestia to download the snark, verifies the snark, and then it knows that the keys it gets are real. And so they can trust the messaging server when they send messages that they're not going to be able to decrypt them, that they're not their own key pairs. But you can actually take this one step further. So you could even make a global identity layer out of this, right? You could say that all chat apps use the same key directory because right now they all have their own, they all have their own merkle tree of public keys that is siloed off completely from the rest of the world, can't interact with them. Signal developer like Moxie says, there's no place for this in the modern world.
00:11:38.402 - 00:12:27.510, Speaker A: There's no reason to have a blockchain. But this is obviously bullshit. And their reasoning of course is that their infrastructure costs are very high, they can't allow access from third party clients, but this would allow third party clients to interact. And these are just messaging apps. But there are tons of other uses for such an identity layer and they can share it, which is really nice. So some use cases, obviously in this talk I focused on authenticated and doing encrypted messaging and file sharing, but the whole web actually runs on certificate authority. So for all TL's connections, everything, you have a certificate authority saying this server has the right to advertise themselves as this website.
00:12:27.510 - 00:13:19.582, Speaker A: And certificate transparency, which is what key transparency came from and what this runs on, runs on this assumption that there are some big companies that are running full nodes that are monitoring the certificate authority's behavior in their own trees. But you could technically just integrate the client into the browser and you no longer need to trust the certificate authority. In fact you don't even need to call it a certificate authority anymore because it's no longer an authority. You don't need to trust them, you could automatically be verifying them. You can then also kind of make a crypto native alternative to Keybase. You could link social profiles together and make identity proofs. This is really nice because next time Mustafa writes you on Telegram you can just simply click on his profile and see, ok, this is a scam, he doesn't have his Twitter profile linked.
00:13:19.582 - 00:14:16.298, Speaker A: And this and this and this. This would be obviously very nice. You can make a keystore roll up, which is a big topic right now, has been a topic at this conference quite a bit for cross chain key and identity management to improve UX in our ecosystem. And there are other emerging technologies right now like TL's notary that you can integrate with. This is really cool because then you can make a proof that you have some ownership over a resource on the Internet and only trust a notary. And this is better than even if we just build encrypted messaging on top of it, because you're still needing to trust somebody to do, for example, the phone number registration. It's still a centralized anti civil mechanism without TL's notary.
00:14:16.298 - 00:14:53.510, Speaker A: And you can also use TL's. We can make an instance of TL's notary ourselves, where you can prove selective information about yourself from the server without disclosing everything about your identity. And that's really nice. And then you can also, like I said earlier, use the ZK property of the snarks if you have a second instance of this key directory to do some pretty nice privacy based applications. So how far are we now? We actually have already finished the stage one sequencer improver. The lite client's finished. The wasm client is like a week out from being done.
00:14:53.510 - 00:15:22.950, Speaker A: We're just trying to get some PRS merged. State access is still whitelisted because the API sucks right now and it's really immature, but yeah, and we actually are already live on mocha on Celestia. There was no announcement. We're just engineers. We kind of need some marketing help. But we have a testnet already and so this is really nice. You can already use it, you can already verify our key directory live with our client.
00:15:22.950 - 00:15:50.800, Speaker A: So. Yeah, but this isn't actually enough still. So right now we just post the snark to Celestia, but this creates some attack vectors. It's not very decentralized. It's not really helpful for services like signal because they would still all have to use this API to get the state from one of the servers. So we need to enable full nodes. By doing this, we just post all the operations to a secondary namespace in Celestia.
00:15:50.800 - 00:16:22.394, Speaker A: And this would enable these apps to run their own full nodes that have the state that can serve their own technology stack. It enables future prover decentralization in case prover marketplaces end up not being a meme. And it also provides censorship resistance, of course, some other stuff. So that would be stage two. There's further stages, but that's kind of the idea we have going forward. We also need contributors. We are public good, we have no funding, we cannot pay you.
00:16:22.394 - 00:16:39.450, Speaker A: Please come help us fix things. Anyways, please. This would be nice. Yeah. If you have any questions, you can find me on signal or Twitter. We're on Twitter as well on GitHub. Yeah.
00:16:39.450 - 00:17:10.364, Speaker A: And I will also post some very interesting papers and blog posts if you're interested. Further reading this one specifically, the hey, signal, great encryption, needs great authentication is amazing. Everyone should read that and offers very good insight to even current culture around signal development and why this is a problem. How much of a walled garden it is. Yeah, that's it. Thanks everyone for coming. And yeah, I'd love to answer some questions.
00:17:10.364 - 00:17:11.020, Speaker A: Yeah, thank you, Ryan.
