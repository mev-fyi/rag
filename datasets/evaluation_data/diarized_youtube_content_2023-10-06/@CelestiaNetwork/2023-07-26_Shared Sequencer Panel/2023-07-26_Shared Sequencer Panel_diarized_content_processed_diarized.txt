00:00:00.330 - 00:00:00.880, Speaker A: You.
00:00:01.730 - 00:00:28.200, Speaker B: Hello. All righty. So the whole theory that I have for this panel is that all the talks that we just saw, they're sort of like movies. This is more like the features on the dvd. This is something to go get to know these guys. This is something to sort of. I hope that if we don't answer any of these questions and we just sort of go with the flow, I'm totally okay with that.
00:00:28.200 - 00:00:50.154, Speaker B: This is just to go with the flow, just something interesting. So we already sort of have an intro. So I'll just run through these intros really quick. Right here we have Ben Fish. He's the CEO, co founder of Espresso. He's also an assistant professor at Yale. He has some incredible research that is widely used today.
00:00:50.154 - 00:01:07.342, Speaker B: So proof of replication. I just learned this for filecoin. Literally the most used. I'm supposed to talk on a microphone. Literally the most used ZK proofing system today. No big deal. Also vdfs and even some economics research on mining.
00:01:07.342 - 00:01:20.962, Speaker B: Really great work. We also have Connor. So Connor is just a general purpose gigabrain. I have learned so much from him. Oh, yeah. He's the CEO of Rollkit. Apparently, he's an engineer and a researcher at Rollkit.
00:01:20.962 - 00:01:40.618, Speaker B: Personally, I've learned a ton from Connor about how you actually decentralize roll ups and without using consensus to use something like fork choice rules. It's really, really interesting work. And you've also done work with NPC, and you were a guitar teacher. Yes. So he can riff. Okay. And then we have Josh Bowen.
00:01:40.618 - 00:02:02.082, Speaker B: So, Josh, you are known, I think, for your width and depth of knowledge, which is rare. You've done work again. Also some research at Celestia on execution environments, fraud proofs, optimistic rollups. And before that, you were at edge and node, right? Yes. And then before that, we don't want to talk about that. No. Okay.
00:02:02.082 - 00:02:12.630, Speaker B: As a Google, he worked at. Okay. Okay. So the first question is, what is love? No, I'm just kidding. This is not like the Lex Friedman podcast.
00:02:14.730 - 00:02:17.400, Speaker C: But we could talk about that.
00:02:18.590 - 00:03:14.220, Speaker B: Yeah. Okay. The first topic I really want to get into is not really comparing which is best with consensus and decentralization, but one of the really interesting things with this panel is that we have three shared sequencers or with rollkit, a way to build shared sequencers as a roll up, but they're all in very, very different contexts. So it's like all of these folks and all these projects are incredibly smart, but they made different decisions based on that context. So if we can dive into the why and the how of why we use the consensus algorithms that we used, then I think that gives us a better understanding over the problems that we're trying to solve, which of course shows us what shared sequencers actually do. Because sometimes if you go on Twitter, one of the leading questions is just like WTF is the shared sequencer? So we can just go in order?
00:03:14.910 - 00:04:12.590, Speaker C: Ben sure, yeah. So the way that I view it is if roll ups are built on top of the layer one, then the default shared sequencer should be the layer one. If it's not the layer one, what are you doing? Right, well, you're trying to do something that the layer one doesn't provide. So if you're trying to build roll ups on top of Ethereum, and I'll talk about building roll ups on top of celestia in a second, but if you're trying to build roll ups on top of Ethereum, Ethereum is a dynamically available protocol, meaning it's very available, it's works even if 10% of the network is online, it has very slow 15 minutes finality. So we decided that, well, what does it make sense to build for a shared sequencer that is not the layer one, but sits on top? Well, something that provides a different property and that's fast finality. So that's what hotshot, our consensus protocol does. It optimizes for getting 12,000 validators to be able to reach consensus within a few seconds.
00:04:12.590 - 00:05:04.590, Speaker C: It sacrifices the availability guarantees that Ethereum has, in the sense that if less than 75% of the network goes offline, then it may not make progress. But that is the reason we did that. If you were building a shared sequencer on top of a different l one, like Celestia, which uses tendermint, then it may make sense to use something else, right? Tendermint. We didn't decide to use tendermint because tendermint is not optimistically responsive. That's like a separate discussion. It can have fast finality, but it doesn't necessarily scale to as many nodes if you want to retain those fast finality guarantees. So hotshot is designed to scale to Ethereum's validator set because we want to be as close to the l one as possible, just providing a different property, in this case, fast finality instead of high availability.
00:05:07.170 - 00:06:04.766, Speaker D: Never thought about using rollkit as a shared sequencer? That may be a possibility, but we're more interested in using shared sequencers with Rollkit. Rollkit is meant to support all different kinds of sequencer schemes because we've identified many, and the trade off space between them all is unbelievably complicated. So we like shared sequencers a lot because one of our goals has been to allow people to launch chains without needing to provision a validator set. And when you've promoted that idea and got everyone excited about it, and then they find out they have to have sequencers, then it doesn't seem as cool anymore. So you can do a roll up without sequencers easily. If you do the base roll ups, the no sequencer roll ups, but those inherit the block time of l one, which on Celestia is 15 seconds, 15 2nd finality, 15 2nd blocks. A lot of people want to go faster than that.
00:06:04.766 - 00:06:30.600, Speaker D: When people think about roll ups, they think about arbitram and optimism, which give very quick soft confirmations and provide a very fast ux to the users. And if you lose that when you go to develop a roll up, you're going to be sad. So shared sequencers, let us do this. No validator set, easy to launch, and also have the fast user experience. So shared sequencers are probably one of our highest priorities to integrate into roll kit as soon as possible.
00:06:31.530 - 00:07:37.386, Speaker A: Yeah, so kind of reiterating what the other panelists have, right? Like, I take a much more kind of practical background, I'm not an academic by any means. And so the evolution of Astri as a project came out of my work at Celestial. Broadly, what we were working on was like, how do I deploy a roll up on top of celestial? What are the components necessary to kind of do that, right? So we go look at why are there sequencers in Ethereum roll ups? We've all seen the base roll up design mechanism, right? But the fundamental reality was that users would prefer faster response times than slower response times. I often reference, there's some research from 1991 on, how do users feel about user experiences in web applications, right? And roughly it says users want to click a button and expect it to respond within one to 4 seconds. Shorter is better. There's probably more modern research on mobile uis, right? Everyone's used like an older phone or iPhones are known for having much faster latency and it feels kind of smoother, right? But users like responsive user experiences, to Evan's point, right? With these centralized roll ups, we got these very, very fast responses. And again, I'm kind of cynical, or know, I view it as practical, right? If we want to say, hey, we have these centralized sequencers, we want to decentralize the sequencers.
00:07:37.386 - 00:08:11.906, Speaker A: If you sacrifice the latency benefit, that is the reason they move decentralized sequencers in the first place. Users are going to say, oh, this is just like a degradation of my protocol. No one in a roll up wants to be like the first mover to say, cool, I'm going to use the shittier experience that my users like less than the centralized ones. So it's kind of our job. If we say we think decentralization is important, then we need to provide a user experience that is adequate, that users walk to use the damn decentralized thing. Because I am not optimistic that users are going to be just like altruistic actors who say, no, I use the thing that is the most decentralized. No, they don't.
00:08:11.906 - 00:08:30.638, Speaker A: They use the thing that is convenient for them, that makes their life easy. We need to provide a decentralized solution, and I think shared sequencers are a way to do that while minimizing against it. Should be easy to deploy a roll up, right? We can't have everyone do this problem. Like if we want 1000 roll ups, we can't have every single project need to do this process every single time.
00:08:30.804 - 00:09:24.740, Speaker B: Yeah, going back to the point of taking away the fast responsiveness, have you guys ever taken away ice cream from a child? That's not fun. Okay, so next topic. Another way to think about a shared sequencer is it's a committee, and it can perform some sort of service for roll ups as a committee. And specifically, there's just a lot of different services that you can provide doing that. For example, like with espresso, you can provide DA, and with Astria, as far as I understand, you can do something like IBC and settlement, like with the EVM portion. So I'm curious to dive into what are the other committee based services that we haven't already touched on, or what are some committee based services that you think would be useful for roll ups. So again, we can just go in order.
00:09:25.910 - 00:10:20.354, Speaker C: Yeah, well, it's interesting that you think of it as a committee. If the committee is like 12,000 nodes, or if there's the same set of nodes as the underlying l one, then it's not necessarily a committee, it's the same physical set of nodes. But it's logically playing a different role of offering a modular component of the overall services that a roll up needs, primarily ordering. And then availability can come for free as part of that. But then you bring up a good point, like what other services can you get from an ordering layer? So we've been talking about in our talks how shared ordering layers like espresso like Astria also give you interoperability guarantees. Beyond that, you could think about adding validity checking as well. So what if roll ups could also just settle directly to the shared sequencing layer? Then you might ask, well, what is the layer one doing? Right, well, the layer one is still there.
00:10:20.354 - 00:10:45.260, Speaker C: Perhaps layer one is being used for availability, but the layer one and a half for some reason is better at providing. For example, it may be easier to add a custom opcode to verify ZK proofs at the layer one and a half that is faster. It really depends on what you want to move between the layers because the layer one can provide all these services as well.
00:10:47.470 - 00:10:52.330, Speaker D: I can't think of anything we want besides a fast, dumb, decentralized ordering machine.
00:10:53.710 - 00:12:13.906, Speaker A: Okay, I'll give a more optimistic take. I guess fundamentally I view shared sequencers and this is going to my kind of cloud SaaS enterprise SaaS background, right? And this is a land of middleware, right? When I joined crypto, I think one of the weird things to me was the architecture was like, oh, there's like Ethereum, and then you just slap a UI on top of Ethereum and I'm like, that's not what enterprise architectures look like. There's like 13 layers between an enterprise service bus and some oracle DB from like two decades ago, right? And the mobile app you use to check your insurance, right? Layers exist and middleware is used to kind of intermediate between these and to reduce complexity of interactions with a broader kind of ecosystem of things. So if we think about shared sequencing, again, it's a committee, what can you get from this committee? I think of it as like we've used the term decentralization as a service, but also it's like, what can a roll up get for free by using a shared sequencer? Again, it gets these soft commitments to my talk, right? There's bridging benefits. If you say you still need some kind of bridging guarantee of the canonicity of this chain. This is less useful if you're doing like a settlement to Ethereum thing, right? Where you say, well, okay, is the roll up defined by the bridge? Well, the bridge on Ethereum has control over the ordering of the roll up in some mechanism, then that's fine from a bridging. But if a roll up wants to bridge to some extra domain space, it's going to need to make an attestation of the canonicity of its given fork to that receiving chain.
00:12:13.906 - 00:13:08.034, Speaker A: We could also think about things kind of like farther out. Like, okay, is an oracle is it a roll up of the shared sequencer or whatever? But you could say part of the data stream of this shared sequencer is some set of oracle transactions from off chain. How is that happening? Is the committee of the shared sequencer having an increased amount of state and actually making some claim over the validity of this off chain data? There's various things like that, but I think really the way to think of it is like it's a stream of data. Generally, we assume the roll up is only kind of filtering out the stream of data directly relevant to it. There is potentially data you could push into that stream that gives a shared timestamp of it across all the rollups that they may choose to filter out as well. So again, you could have some JSON format for Oracle data and all the roll ups of the shared sequencer can choose whether or not they want to parse out that oracle data and use that in their state machines. There's a pretty broad design space there, but it's unclear what will be useful.
00:13:08.034 - 00:13:18.970, Speaker A: And I think the research on what are the kind of tradeoffs and security guarantees and whatnot of these things, but I don't think we're solving the Oracle problem here. But there's potential UX benefits as like a role up developer.
00:13:19.950 - 00:14:07.942, Speaker B: Yeah, that's really good. One of the things that I was to lead into the next topic is MEV and PBS specifically. So some of the things that I was trying to hint at is with these community based services is that whenever you use a shared sequencer, and if that shared sequencer is using some sort of MEV infrastructure, that MEV infrastructure is sort of already set in place for you. So to get into the MEV part, monopolies are bad in general. That's usually a safe thing to say amongst crypto people and most folks in general, but we don't always get rid of all of the monopolies. And I think especially from Ben's talk, you had some really, really good answers to this. So I really want to dig into monopolies and basically profitable censorship.
00:14:07.942 - 00:14:38.120, Speaker B: So we still rely. So crypto like, we like to think about getting rid of monopolies, yet each proposer has a monopoly over which block is used for that given slot. So I kind of want to dig into who captures MeV in the system and how can we change that to be more programmatic and no matter which direction we want to go in, how can we change that? So, yeah, we can just, again go in order.
00:14:38.970 - 00:15:10.890, Speaker C: Yeah, I mean, this conversation is relevant even just talking about layer ones, like without roll ups. But the same problem happens with shared sequencing layers for roll ups too. So it's interesting that you said, wait a minute, the proposer in a consensus protocol has a monopoly on a slot. It gets to decide what goes into the slot. So this is, I think, one of the really interesting things about consensus protocols. There's a number of papers on this. Like there's a paper called monopoly without a monopolist.
00:15:10.890 - 00:16:12.318, Speaker C: A blockchain is a monopolist. A proposer has a monopoly over one single slot, right? Does this slot based monopoly behavior achieve monopoly pricing? Meaning, do users pay the price that maximizes the revenue of the blockchain, or do they pay basically the market clearing price where supply equals demand? And so ignoring Mev of ordering and sandwich attacks and all that, if we just look at what's the price to include a transaction. EIP 1559 has solved this problem. Users pay even though the proposer in the consensus protocol has a monopoly, users pay the market clearing price. And the reason is that if the proposer is not willing to process the transaction of a user paying the market clearing price, the next proposer will. So having a monopoly for a short period of time does not give you a monopoly over prices. And this is the key property of blockchains.
00:16:12.318 - 00:16:54.830, Speaker C: That's why they have to be decentralized, right? Because I'm elected once in a blue moon to process a block. If I don't take the transactions as they are paying the market clearing price, there's someone waiting in line who will just do it. So I cannot make a credible threat to users to reject their transactions paying below market clearing price. Now, when it comes to Mev, this isn't the case because the transactions are available to me. I can sandwich attack them. I could even get the help of a bunch of builders and searchers to figure out how do I extract as much value as possible by reordering the transactions in front of me. The willingness of a proposer in a later slot to do it without extracting value doesn't matter.
00:16:54.830 - 00:17:42.926, Speaker C: I can do it now because the transactions are there now. And that's why we need to move towards order flow auction design, where we introduce an ideal functionality that has a privacy element to it, which shields the transactions from the proposer builds a system which is ideal and stable for users, so that all users submit their transactions there. And then we turn the proposer back into a passive entity that can either take the block output of this ideal functionality or have nothing at all. And again, that proposer does not have the ability to make a credible threat to users to not take their transactions. If they send it to the ideal functionality, they just try to take anything that's available to them at the time. And it's very hard to design those ideal functionalities. It involves a lot of cryptography, perhaps trusted execution environments, but that is the direction the industry is going in.
00:17:42.926 - 00:17:51.566, Speaker C: That's what flashbots and suave are working on, and those only work with highly decentralized ording protocols. That's why we're advocating for shared sequencing.
00:17:51.758 - 00:18:11.020, Speaker B: So to respond to that really quickly, in theory, you have multiple different builders, so maybe multiple different swabs or something like that. And the proposer, since they do still have this monopoly for this one block, it's very short and it's very limited, they still can pick the block that gives them the most profit. So this is sort of where I was.
00:18:12.030 - 00:18:47.938, Speaker C: But the block that gives them the most profit may be the one that has all the users. And the one that has all the users is the one that is shielding users from mev. So you can either design something that's stable for the proposers, or you can design something that's stable for the users. If all the users are participating only in the order flow auction that gives them the best execution price, the short lived proposer has no choice but to take from that pool. Otherwise, it doesn't have any transactions to process. It can't make a credible threat to users and say, no, don't submit there, I won't take it because it has a short turn and then it's gone.
00:18:48.104 - 00:19:17.294, Speaker A: Right. I guess I always propose, like the spicy counterpoint, right, of dumb. Flow is dumb, I guess. And what I mean is that generally, when we think about retail flow and users getting sandwiched, it's because they're unsophisticated actors and they're not necessarily doing the labor to find what is the optimal execution for them. Right. And then there's also, we can think about user preferences in financial senses, but also in a product sense. Right? So I spent years at Google, right? What does Google do? Well, Google provides you a lot of free services.
00:19:17.294 - 00:20:12.858, Speaker A: But are those services free? No, Google's monetizing that on the back end with ads. And why are they doing that? Because users don't like friction, and transactions are friction. Crypto talks a lot about transaction friction, because if it's like two and a half dollars, submit transaction, you won't do it. Well, when apps came out, like the App Store and Apple, right, it was like ninety nine cents to buy an app or whatever, that's like no money, right? Like functionally use an app for like ten minutes, you should be willing to pay a dollar for it, right? But people didn't, so they made them all free, and then they monetize on the back end. Users trend towards things that are low friction, and then they monetize on the back end. We see this in financial systems, right, with like robinhood and payment for order flow, right? Users don't think, and they don't read the MBA papers that say like, hey, maybe it's suboptimal for you to actually be submitting transactions that are free, and then you get marginally worse execution, though the actual quality of execution on payment for order flow seems to be like an unanswered open question from analytics and availability of data. But fundamentally, users use the thing that is low friction, not necessarily the thing that gives them optimal execution.
00:20:12.858 - 00:20:54.960, Speaker A: So I think, again, I'm very positive on suave and flashbots, but I think it's going to be a very hard fought battle to say, we are able to convince users that they should only submit transactions to this if that may result in some marginally higher transaction cost for the user. And then someone else comes along and say, I will ruthlessly front run and sandwich you, but you will not pay any upfront transaction fees. The users might say, yeah, I'm fine with that. So I do think there is something from a product perspective that may be trickier to get from user demand, rather than the kind of like, again, the ideologically correct of like, we just need all the user flow to go through one of these kind of like tee environments, and therefore we can't do all the sandwiching attacks when you're like, what if the users just don't care?
00:20:55.570 - 00:21:14.734, Speaker C: I think we're moving the target. Whatever is good for users is good. Like, let's define what's good for users. That's the ideal functionality. Maybe it's not paying for failed transactions, maybe it's not paying monopoly prices, maybe it's both. But if we design something that's stable for users, then that will be stable for a blockchain too. Only if it's decentralized.
00:21:14.734 - 00:21:15.814, Speaker C: And that's the key point.
00:21:15.932 - 00:21:21.878, Speaker A: Yeah, and I agree on that. It's just like defining what is actually a user preference across many parameters is like, hard.
00:21:21.964 - 00:21:22.790, Speaker C: Agreed.
00:21:27.470 - 00:22:34.158, Speaker D: If you use. A lot of people talk about roll ups inheriting liveness and censorship resistance from their base layers, we found that if you build a sovereign roll up on a DA layer which is built such that it inherits censorship resistance and liveness from its base layer. Fundamentally, you leak a form of mev to the validators of the base layer called profitable censorship. And if you don't want to leak that mev because maybe you don't want to create anything like gas wars on the base layer, then you can't inherit liveness and censorship resistance from the base layer. So if you're using a shared sequencer, and your shared sequencer has its own consensus and its own proof of stake and its own token, the cost to create a liveness failure on the shared sequencer is the cost of one third of the stake if it's tendermint style. And that could be very high. That could be high enough that roll up developers don't feel as though they need to build a force transaction inclusion mechanism from L1.
00:22:34.158 - 00:22:44.030, Speaker D: It might be censorship resistant enough on its own, and so the shared sequencers can help remove that MEV from DA layers.
00:22:45.830 - 00:23:09.270, Speaker B: This is really good. Before we finish it up on MeV, do you all envision any way for a roll up to be able to capture its own value just like that? What would be more of like a mechanism design for a roll up programmatically capturing MeV, as opposed to only relying on something like suave or whatever's built into the shared sequencer?
00:23:11.210 - 00:23:51.666, Speaker C: I think that if a roll up is using a shared sequencer, then the shared sequencer becomes part of the roll ups protocol. And so it does need to be programmed into the shared sequencer. You can always view things as roll ups participating in some kind of order flow auction. So if you do design order flow auctions, then maybe there's a way of doing it without programming it into the shared sequencing protocol. But I think that that's the opportunity that we have right now. So one of the ways we didn't really touch on, none of us really touched on this in our talks. But with base roll up, if you use the l one, then there isn't really a way of programming into the base layer like, oh, roll up should get back this portion of MeV.
00:23:51.666 - 00:24:29.058, Speaker C: We designing these decentralized protocols on top of the layer one have that opportunity now. And I think it's important for adoption. It's important for at least the major roll ups out there to be convinced to use Espresso or AStrI or roll kit. Right. An important thing to do is to say here, here's a credible revenue sharing protocol in place that can allow you to get back the value that you're creating for the system, rather than the system taking all the value. And so that is, I think, a very important research problem that I'm trying to get people excited and interested in. We have some thoughts on that.
00:24:29.058 - 00:25:02.160, Speaker C: I shared a little bit in my talk. You can have like alternating blocks where in some of them you run independent auctions, some of them you run joint auctions, independent being one for each roll up joint being auctioning off wholesale blocks for all the roll ups at once. And that allows you to estimate and approximate the marginal contributions of each more directly and then use that to inform some reallocation strategy. But this is a wide open problem that welcome everyone to think about and offer better solutions on.
00:25:04.370 - 00:25:49.960, Speaker D: We think a lot about how you can do meV redistribution and things like that. And we suspect that the way it might work is if whatever layer is doing your transaction ordering has really, really good censorship resistance. Maybe with something like a threshold encryption scheme, or possibly with a multiplicity style scheme that duality proposed, you can use verifiable sequencing rules and maybe something like protocol owned builder to capture that MeV and do interesting things with it. There's also of course all the various epbs, MEV smoothing and mev burn schemes that are coming out of the Ethereum world, and maybe those would have some way of ensuring that it gets captured and redistributed in some equitable way as well.
00:25:50.530 - 00:27:28.650, Speaker A: I guess I'll just throw like a contrary point in here, maybe. So from our view of the idea that deploying a roll up should be as easy as deploying like a smart contract or whatever is a term we use, there is a question to me of who is the roll up? And what I mean by that is not the mechanism design of calculating the counterfactual of a single auction versus a combinatorial auction of what is the value that this roll up deserves. But it's a question of who is the entity that represents this roll up, and how is the shared sequencer aware of that being like a distinct entity? So it's kind of this question of like, and Ben, we've talked about this, where do you pay back the roll up itself? What is the state machine that is actually calculating and receiving these funds and choosing to distribute like to our thing? We think from a UX or developer experience it's important that there's not like a registration phase for a roll up to sign up to the shared sequencer. That's kind of an intentional and why we're like a lazy shared sequencer. So to this degree, it's unclear who would be like the valid entity that is being rebated, the actual funds. Even if we had a magical way to calculate the optimal value that should be returned, it's like, well, who are we actually giving this to? And then the other point I think of is, where do we want this value to be returned to? Should we be thinking about the roll up as some nebulous entity or application developer? Should we be thinking about the users? Right? What if we see some space where I didn't have a tough time in my talk to cover, but what if users are doing something where they have some kind of front end or singular order flow thing, whether it's like suave or some other kind of aggregation mechanism that is actually using multiple distinct state machines and then settling to a single shared sequencer. Well, that user may not have some kind of preference for one of these chains versus the other.
00:27:28.650 - 00:27:59.320, Speaker A: And so should we be thinking more about rebating the MEV to the users? And again, to Ben's point, right, going to order flow auctions of like, well, actually we're trying to get the MEV fairly back to the user. And just right now, in the current MEV design, even on Eth, right, like 90% of that MEV is captured by the proposer. So that's like the entity where you have to get that margin from to give back to the user. But it's unclear if we want like an intermediary hop to give it to the sequencer or the nebulous entity that is the roll up. Really, we just want to be giving it back to the user and giving them like best execution price.
00:28:00.570 - 00:28:39.300, Speaker B: Nice. Okay, so much good alpha. Right now let's focus on base rollups. Based roll ups are a critical part of shared sequencing. You can't really have shared sequencing without some sort of lazy execution. So I'm not really sure on the exact definition of based roll up, but effectively you agree on the transactions beforehand and then you execute them. So this is what I think what Josh was talking about earlier on his talk, where you have sort of like an optimistic relay, where you're submitting a block, you're submitting some sort of transactions, and then you have some sort of arbitrary execution environment on top.
00:28:39.300 - 00:29:12.080, Speaker B: So another thing to do with MeV is, I'm curious, on, with this execution environment itself, on reordering the transactions, or doing something to do with a based roll up capturing. Again, this goes back to programmatically capturing its own MEV is can you have a based roll up that doesn't necessarily respect the ordering of the shared sequencer. And can that be beneficial in any way? Do you see that as like a viable thing? Or, I mean, a very fair answer is no.
00:29:14.130 - 00:30:09.502, Speaker C: No, but no and or is it only yes and can we do a no and okay, no? Anyways, it gets into the definitions of a roll up, can define its own state transition function. And that could be on a block level. For example, you could have an ordering of transactions in a block. But then an application which reads all those transactions like, takes the average and then uses that to determine the state of an amm. So you can define your state transition function to be not just executing transactions in the order that they appear, but it could be some deterministic function of how they appear in blocks. You have to, of course, break it up into some parts. You can't wait forever until you decide what your transition is.
00:30:09.502 - 00:30:37.074, Speaker C: But you could do transitions on a block level as opposed to an individual transaction level. And that does give you some ability to define these reorderings. But the key thing is you can't do it in a dynamic way. You can't do it in an opinionated way. Anyone looking at what the shared sequencer outputs and knowing the state transition function knows what's going to happen. There's no dynamic thing that the roll up can now do. So that's the nuanced perspective.
00:30:37.202 - 00:30:37.494, Speaker B: Yeah.
00:30:37.532 - 00:30:47.290, Speaker A: Doubling down. Right? Like the state transition function, like we argue, is it has to be deterministic. Right. How you order it, you can just say, I read it backwards. Like why? I don't know. Because you choose to. Right.
00:30:47.290 - 00:31:24.262, Speaker A: I think a batch auction is probably like the cleanest thing. If you have like an amm, like a penumbra style batch auction, everyone gets the same price. It doesn't care matter if you're at the front of the block or like the back of the block. Right? But it has to be deterministic. You're not like doing like a random shuffle, because again, then the shared sequencer, again, what is the commitment giving you? If you're like someone's going to randomly shuffle it by some exogenous extra protocol rule, you're like, all right, well, you won't come to consensus on it then what are we doing here? Right? So it does have to be deterministic. Again, how you order it, how you refund it, fine. But also from the shared sequencer perspective, it's just like including the transactions, it doesn't really care what you're doing after the fact.
00:31:24.262 - 00:31:25.320, Speaker A: That's on you.
00:31:26.890 - 00:31:44.538, Speaker D: The name of the concept is verifiable sequencing rules, I believe, and it reduces the problem of fairness to the problem of censorship resistance. If you can get something included, then it will be ordered fairly according to the verifiable sequencing rules. There was a research day, talk about it from Mathias. It's quite good.
00:31:44.704 - 00:32:03.410, Speaker A: I'll just argue I have a general opposition to the concept of fairness being like a thing. There might be some useful economic definition for it, but I think arguing of fairness is where we get spam and whatever, right? Like all of the first come, first serve things of like, oh, is it fair? And, well, is it fair that the guy has faster hardware and a shorter ethernet cable is faster than you?
00:32:03.560 - 00:32:07.810, Speaker D: Well, maybe not fair, but something that you can capture and redistribute, possibly.
00:32:08.870 - 00:32:24.042, Speaker B: Yeah, exactly. So what I was trying to go with that is that you definitely need a deterministic function. But could you design a deterministic function that can direct value capture to somewhere where you want some sort of programmatic mev capture? So something like a batch auction, like what you were saying?
00:32:24.176 - 00:32:40.506, Speaker A: Yes, but I think that can only be the value capture within the state machine of that specific roll up. That cannot be the value capture of, say, an inclusion fee within the shared sequencer. Like you on your roll up cannot deterministically reorder something in such that you extract value from the inclusion fee on the shared sequencer.
00:32:40.698 - 00:33:11.546, Speaker C: I mean, it's also important to note, though, that if you have a deterministic function and you are the protocol or the builder that does have dynamic control over the ordering of transactions that then go into that state transition function, you are the entity that can figure out which order is going to maximize my own profit, or which order is going to maximize some profit. So you don't really have control just by defining the state transition function over where the profit goes. And that's why you still need to get back to this order flow auction design that we were talking about.
00:33:11.568 - 00:33:14.534, Speaker B: Exactly. Because the proposer has monopoly over, not the proposed.
00:33:14.582 - 00:33:59.606, Speaker C: Well, again, it comes back to consensus protocol. The proposer has a monopoly for one slot, right? Which is important because that means that it will take whatever output it's given, if that's the only output from some order flow auction that it can choose from. That's why consensus protocols, that's why blockchains are good, right? Blockchains turn proposers into monopolists from one slot. And that's why centralized systems are bad, because you have a monopoly over all slots. And it's amazing that when going from monopoly over all slots to one slot allows you to achieve non monopolistic behavior in a system that's like the coolest economic thing about blockchains. But you still need to solve this builder side. You need to solve this order flow auction that designs a system which is stable for users.
00:33:59.606 - 00:34:03.820, Speaker C: If you really want to mitigate or minimize mev or control where it goes.
00:34:04.430 - 00:34:11.726, Speaker D: Your verifiable sequencing rules. They don't know if somebody sold on a centralized exchange after they did a swap, for example.
00:34:11.828 - 00:34:12.350, Speaker C: For example.
00:34:12.420 - 00:34:13.040, Speaker B: Great.
00:34:13.970 - 00:34:16.350, Speaker A: Which is how all the mev is extracted.
00:34:18.610 - 00:34:40.162, Speaker B: Nice. Okay, so bear with me. We're going to bike shed on naming just a little bit. Fine. Okay. I think actually the main criticism of shared sequencers is just the name. So do you think that shared sequencing is a good name? Is it justified or would you rather go with something like I've heard shared proposer.
00:34:40.162 - 00:34:47.400, Speaker B: I've heard shared aggregator, is it not shared? Seems reasonable, but maybe not even that. I don't know. What do you guys think?
00:34:48.190 - 00:35:37.670, Speaker C: Are we going in order here? I think that when it comes to names, there's no perfect name for anything. Blockchains aren't a great name. I'll say it, they made a lot of sense for proof of work consensus. But other consensus protocols may not be blockchains, but it's the thing that catches on and it's the thing that resonates with people and it makes sense. And I think that shared sequencing, we've all now been using it and of course once you start using something people are going to point out reasons why it may not be the perfect term. But in the end of the day it's a pretty decent term. And sequencing refers really to finalization of the sequence in which roll ups will execute their transactions.
00:35:37.670 - 00:35:52.330, Speaker C: We could add that to the title. That's a mouthful. And I just don't know if there's another name that's like nice and short and succinct that captures it. But if somebody comes up with one, you're the winner.
00:35:53.150 - 00:35:56.606, Speaker D: I think it's a good name. A lot of people like aggregator. I think that's a good name as.
00:35:56.628 - 00:36:35.050, Speaker A: Well, I guess I'll say, yeah. We made a very intentional decision to use shared sequencer. It was like a marketing term, right? But fundamentally people that use the same shared sequencer have a shared view of the sequence of transactions. Certainly better than settlement layer where everyone's like what the hell is a settlement layer? What are you settling? What is settlement? Right? We're like, no, you use the shared sequencer you and everyone else using it has a shared view of the sequence of transactions. That feels pretty explicit, right? Yeah, we implicitly assume that it's like, in our terminology, like a lazy, decentralized shared sequencer. But again, you just have to pick words and put it in your marketing copy.
00:36:36.030 - 00:36:40.540, Speaker B: Are there any other misconceptions on shared sequencers that you guys would like to address? Now.
00:36:43.950 - 00:37:00.660, Speaker C: Shared sequencing is not one roll up. Shared sequence is not shared execution. It's not shared building per se. It makes some set of shared building easier. I don't know. Shared sequencers are real.
00:37:02.630 - 00:37:29.950, Speaker B: Yeah, that's a great segue into, does anyone know really quick how much time we have left? Oh, wow. Okay, well, okay, that's great. No, there's no need. We don't have time. We were just going to handle if roll ups were real or not. So we'll just leave that for next time. All right, thank you, everybody.
00:37:29.950 - 00:37:33.120, Speaker B: I'm super, I was super excited for shared sequences before.
00:37:36.530 - 00:37:37.520, Speaker C: Take seven.
00:37:41.250 - 00:37:42.000, Speaker D: Okay.
00:37:46.130 - 00:37:52.140, Speaker B: Now I'm extra excited for shared sequencers. Thanks.
