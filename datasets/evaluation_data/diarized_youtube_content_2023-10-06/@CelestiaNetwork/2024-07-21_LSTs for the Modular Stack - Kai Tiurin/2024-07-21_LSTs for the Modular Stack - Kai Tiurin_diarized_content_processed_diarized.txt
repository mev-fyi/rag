00:00:02.480 - 00:00:32.150, Speaker A: Anyway, I think we can start. I think we will make it brief. If anyone has any questions on the go, feel free to answer, feel free to ask. We can discuss. So, yeah, I think I need to. Each time when I try to make a presentation, I always forget about where the presentation mode is enabled.
00:00:35.650 - 00:00:37.890, Speaker B: Slideshow? Yeah, top right.
00:00:37.930 - 00:00:38.290, Speaker A: Top right.
00:00:38.330 - 00:00:38.834, Speaker B: Yeah.
00:00:38.962 - 00:01:18.918, Speaker A: Oh, yeah. Because I always start looking at here, but it's actually here. So, yeah, today we have a workshop that is called lsts for the module of stack, which is. Yeah, technically we will talk a bit about lsts, but they won't be like our maintain topic of discussion today. But actually like on the example of the liquid staking protocol, we will talk a bit more about how to make secure applications in the modular world. So what the state of the problem, the future is modular. We are on the modular summit today.
00:01:18.918 - 00:02:21.880, Speaker A: And what do we mean by that? Is that basically we don't like, see the single chain that fits at all. We see that we have a lot of broaches. Build different applications like blockchain applications based on rollups, cosmos, SDK chains, completely different things. What we see is that probably we are not going to live in the world where we have only a single chain that fits for everything, but probably we're going to live in worlds where there are multiple chains, they interact with each other somehow, with bridges or something. But anyway, so we need to move towards this direction, so to say. And. Yeah, and to live in this modular or interchange or whatever world with a lot of blockchains, we need to build the interchange protocols because liquidity is fragmented.
00:02:21.880 - 00:03:15.364, Speaker A: The user base is distributed across all of those blockchains. We need to build some sort of integrations between them. You're not really interested into limiting yourself in one particular ecosystem. You want to build real cross chain applications and it should not be probably just copy pasting the copy pasting the application that you have on one network to another and have it there to fragment the liquidity even more. You probably want some applications that can interact with other applications on the other chains and such. The illustration here is the example of the map of zones, which is one of the. Yeah, I mean, like, in terms of like, illustrations is one of the, like, good examples.
00:03:15.364 - 00:04:00.930, Speaker A: It shows, like, only the cosmos ecosystem, like. But, but we can imagine that besides the cosmos ecosystems, there are even more applications that, like your application want to interact with. So, yeah, that's, that's what we have. That's what we see as a thing right now. And, yeah, like one of the platforms that is trying to solve this issue is neutron. It's the integrated applications network. So Neutron is a blockchain built on Cosmos SDK that is trying to solve as one of the issues that it tries to solve is that we want to build cross chain applications that want to interact with other chains and such.
00:04:00.930 - 00:04:44.452, Speaker A: Sometimes we can build them as separate up chains. So you can just build your blockchain with Cosmos SDK or whatever else, whatever else SDK you want to use and bake all the logic into your blockchain. I don't know, integrate some oracles and stuff, whatever you want to use for that. But sometimes we don't really want to use to have an up chain because app chain has a huge technical overhead. We need to manage the validator set, we need to care about staking, we need to care about sensors, even if we are taking this stuff from Cosmos SDK. So we use tendermint, etcetera. Anyway.
00:04:44.452 - 00:05:57.064, Speaker A: We should care about it. We should care about all the possible issues including vulnerabilities, upgrades, whatever. The upgrades of cosmos chains, for example, are still pretty, so to say, stressful events. Yeah. And neutron solves this issue through building a platform that allows your smart contracts that are deployed on Neutron to be as powerful as an app chain and to utilize the IBC stuff like intrashin accounts, interesting queries and such, and build the applications with smart contracts instead of building them as an app chains. And one of the examples of such production is drop is actually what we are working on right now is the chain liqueurs taking protocol that is built as a set of smart contracts on Neutron. And this protocol works in a way where we have the head of the protocol deployed on neutron chain, but stake is managed on other chains.
00:05:57.064 - 00:08:11.890, Speaker A: So basically what drop does is you provide your tokens to this protocol on neutron, but your tokens are staked on the other chain and it's done through the interchange accounts from IBC. But what does it mean? It means that we have a little bit of the smart contract development paradigm shift because we got used to from the like where we beginning of creation of smart contracts, we got used to the model where when you develop your smart contract, you have the transactional model of changing the state of blockchain. And if something goes wrong, it works in a way where you just fail the transaction, the state is rewarded and you're pretty safe. So basically it works in a way where you can rely on the transactional model of the blockchain itself and be sure that everything changes consistently and such. But if we develop this smart contract that interacts with something external. As an example of drop, we have a smart contract that wants to stake assets on the remote chain. And to do so, like our smart contract, need to issue the intent to do so and wait for this action to be executed on the remote chain, right? So it's something that definitely doesn't happen in the single block, because at the very least we need to submit the transaction where like smart contract tells that it wants to make this action, the relayer should pick it up, should submit it to the r chain, which is already takes time, and very optimistic scenario, it's at least one block away.
00:08:11.890 - 00:09:26.960, Speaker A: This action should be submitted on the other chain, should be executed there, and then the relayer also should take the result of this action and submit into a neutron chain. So between the smart contracts, intent to do the action and between the actual callback that happening on neutron, there are several blocks at the very minimal, it's a single block. Everything goes blazingly fast. But what does it mean in terms of smart contract development? We don't have any more of this ability to just roll back the state of something went wrong, right? So for example, if this thing would be like one transaction composable, like if anything goes wrong on the remote chain, we could just fail the transaction. If it's like if everything happens in one transaction, right, we could just fail it and systit would be rewarded and we would not care about it at all. But right now, we have at least some time where a smart contract stays in the state of awaiting the remote action to be performed on the remote chain. That means that interchange brings us asynchronicity.
00:09:26.960 - 00:10:21.076, Speaker A: So we have to deal with a synchronous environment in smart contracts, which is just sort of not very the thing that is smart contracts are built for. And yeah, it started looking sort of like an enterprise, classic backend development. So our smart contract actually right now performs some sort of microservice that does some asynchronous works and such, but it's still a smart contract. We still have the limitations that we have from smart contracts. We lose some powers that we got from the smart contracts and the blockchain because we cannot reverse the state this easily and such. And we get some drawbacks that we have from smart contracts. Not the drawbacks, but features that they have.
00:10:21.076 - 00:11:32.940, Speaker A: So, for example, we cannot fix smart contracts shortly, because if we're talking about decentralized applications, they usually performed by daos, or maybe they are completely permissionless and have no ability to upgrade the contracts or something. So it's not the case of production applications from web two where we can just connect to production via SSH, fix something if something goes wrong, roll back the database, I don't know, have snapshots and so on and so forth. It's still smart contracts, we cannot just do it. They still require us like to be much more careful with the development, much more paranoid with the development. We still need to build them in much secure ways. So we see that the complexity of application is getting closer to what we had in web two, but still in this new reality where we have to care about security much more than we used to do it in web two. So let's say.
00:11:32.940 - 00:12:30.424, Speaker A: And. Yeah, like, and so how we can approach that. Okay, like let's, let's, let's build the protocol as a final state machine then because like it's a very, it's very sort of like obvious approach, right? So we have some application, some program that acts asynchronously, right. And we need to somehow manage the complexity of this. So it's not enough to just code it. We need to have some spec that tells us how this protocol should work in the very formal way. And we need to manage this complexity because here is the final state machine of the core smart contract of drop protocol and it's a pretty complex thing and it's because we have to do a lot of, we have a lot of stuff to do on the remote chain.
00:12:30.424 - 00:13:21.984, Speaker A: So what drop does, and it's reflected here on the schema. I won't go very deep into it, it's not the topic of our discussion today, but just to have the understanding. So we have to withdraw funds that are being unstaked on the remote chain so that they could be transferred to user. We need to claim the rewards because we want to stake them again. We need to stake the assets that were deposited to drop protocol on neutron, like on the remote chain, so they would be staked eventually. We want to stake rewards that we claimed before and we want to create new undelegation requests that were made by the users and we gathered the batches of this and such. So there is a lot of stuff that we want to make on the remote chain.
00:13:21.984 - 00:14:10.790, Speaker A: And even while we have interchange queries where we can get information from the remote chain in a very permissionless way, we still need to be very careful with these remote chain operations because it's still a remote chain. We cannot just query its state whenever we want to. The data from that chain need to be submitted to our chain by some external provider. It's completely trustless because of ICQ, but it's still pretty complex task. So we need to be really careful while we are building that. And what we get at the end of the day is think of that complexity. We build our protocol as a final state machine that works in a way where.
00:14:10.790 - 00:15:02.280, Speaker A: So basically on this scheme, circles are the states where smart contracts awaits for execution. Right? So basically, all the transactions for core smart contract, they go from one circle to another circle. It's the actions that are performed during the transaction. Then it goes to this, like, it emits some interchange action it wants to do on the remote chain, and then it's await awaits its execution on the next circle. Once the, like, the action is performed, the result is submitted. We got the new data from the remote chain, then we can call smart contract once again. And from this state, checking if everything is okay, it will go to the next step, performing another interaction action and such.
00:15:02.280 - 00:15:48.982, Speaker A: We build this specification for final state machine, and we implemented everything in rust. So basically, drop protocol is implemented in rust with the cosmosm, but, yeah, but what can we do about it next? So, okay, like, final state machine is a pretty mathematical thing. So it feels like it should be formally verified and. Yeah, like here we can go, like with quint. It's a great tool implemented by the informal team, and we can build a model of this state machine. We can set some invariants we want to check and such. We can run a lot of tests on that state machine.
00:15:48.982 - 00:16:42.030, Speaker A: So, yeah, we can implement this state machine as a quint model. We can prove some properties of this machine. We can also prove some properties of this final state machine, just purely in a math way. We can just build strong mathematical proofs for the state machine. And, yeah, basically, this object, this artifact that we had is a pretty formal thing, so we can work with that in a pretty formal way, and we can prove its correctness and such. So, yeah, it's a pretty good thing that we have it, but at the end of the day, we have these three objects. We have the spec, we have the model that we build with math proofs, quint, or any other tools that we can use.
00:16:42.030 - 00:17:09.974, Speaker A: And the code that we implemented for this spec and the relationships between spec and model, they are pretty straightforward. We can examine it just manually. It should be clear. The model should be built in a way where, you know, like, you can just, like. Yeah, so you can see that the correctness, like, the model is implemented properly just because, you know, like, it's the requirement for this model. In the first place. Right.
00:17:09.974 - 00:18:23.398, Speaker A: It should not have like a lot of boilerplate related to the actual implementation. So it should be like, pretty straightforward for us that, okay, like, let's imagine that, like, yes, spec is completely, completely reflects the model that we implemented, or vice versa. Like, the model reflects the spec, right? So, yeah, that is good. But the next question is, okay, like, but the code that we implemented, does it really correspond to spec? Because, you know, like, this final state machine that we had in theory, like, it's a great thing that we have it, but the question is, does our code actually reflect the state machine that we implemented? Because our code is built with cosmosm, we don't have good libraries to build final state machines there. We have a lot of boilerplate related to the interchange accounts, interchange queries, all the other technicalities that we have here. So the code is pretty complex itself. And building this relation between spec and the code is not that obvious.
00:18:23.398 - 00:19:41.670, Speaker A: So it's not clear for us whether this code actually corresponds to the spec that we meant to implement. And yeah, here we talked only about the spec and the code, but at the end of the day, when we're talking about the protocol correctness, when we want to say that, okay, like, we proved some security features of the protocol, actually, that is what we are interested in, whether, like, model corresponds to the code. And here it's like, it's much less clear, because if we could have at least this relation, we could say, yeah, at least these two things, that they implement the same spec, and that's okay. But since this one is not obvious, this was like, it's not clear whether they have any relations, whether there are any relations between them at all. And ideally, we would love to build this dependency in the first place. That's what we are concerned about, because at the end of the day, the implementation matters. The implementation is the thing that works actually on chain, that faces all the potential issues with liveness and safety and security.
00:19:41.670 - 00:20:32.070, Speaker A: This is the thing that is going to be attacked by hackers or whatever. So implementation is something that we care about. It's not enough for us to just build a good model and to say that, yeah, that's good. We need to actually check whether this code actually corresponds to this model, at least through its relation to the spec. So, ok, and someone could say here, yeah, we have Curry Horvilleur correspondence, we can just build our protocol from scratch with the formal tools, I don't know, prove its correctness with cock language summits like that. But let's be honest, it's the rare case, right. We actually like rarely the protocols encrypt.
00:20:32.070 - 00:21:18.552, Speaker A: They are ready to build their stuff with some really complex tools with the high learning curve. And so basically crypto space has a really fast pace. We need to build fast, we need to prototype things, we need to go to market and. Yeah, like we have no time to, I don't know, like let's re implement everything in scope so that it would be like 100% secure, everything would be formally verified. And even like here we will face a lot of issues related to the fact that our execution environment is not that good yet. And cosmos itself, like, and like, it's not formally verified anyway, so. Yeah, like there is a rabbit hole.
00:21:18.552 - 00:22:16.418, Speaker A: Right. So what we need at the end of the day is some sort of like a simple solutions that would allow us to apply all of those formal fication stuff after the protocol is implemented. Actually, when we already have a prototype, when we already have something working, when we already test the same hypothesis, we already figured out some potential issues and such. So yeah, that's how it works. It's an iterative development anyway. And we should be honest with ourselves that actually when something is already implemented and we already have a prototype and such, and at this point we already want to go to market pretty soon. That's the step where most of the teams, they start to care about security and such and start doing audits and so on and so forth.
00:22:16.418 - 00:23:20.550, Speaker A: So that is why we need something that will help us on this stage without rewriting everything from scratch. Here is basically the main topic for today is the solution that we implemented in our project. To actually try to approach this problem is. Okay, like what do we have? We have the code that implements something and we have a graph of final state machine in the first place. What we did is we formalized the graph because the graph that I showed you before, it was just drone is drawn, draw IO think it's just manual things you can use for building something. You can take a look at it, you can modify it, but it's not something that we can work with from the code. So the first thing that we did is we formalized the graph first.
00:23:20.550 - 00:24:22.030, Speaker A: It looks like that now. Yeah. So we implemented it. We basically described the description of this graph in dot length that allows us to basically build graphs and visualize them. The good thing about it that, yeah, like, so basically from this graph specification written in dot length, first thing that we can do is we can build the visual representation of the graph so we can examine it manually. We still can work with that for our model building proof, the proof of some properties and such. But the most important thing is that we can parse this description, parse this graph specification, and work from that, from the code, and it allows us to build the tools that actually analyze this graph somehow.
00:24:22.030 - 00:24:53.770, Speaker A: And the second thing that we did is we added the code traces. So you can see that. Yeah, I'm going to take a step back. You probably cannot see it, but all of these nodes, they are enumerated. So each node has its own unique id. And we want to preserve this uniqueness with backwards compatibility when we work on the improvements on the protocol. But yeah, each node has its own unique id.
00:24:53.770 - 00:26:30.082, Speaker A: And since our code implements this specific graph in the code, we should see the places where each particular node is implemented. And basically what we are doing is a pretty simple thing. We just put the traces of those nodes into the events of transactions. Basically, whenever we do any action, whenever we go from one state to another, like, basically, like any state transition in terms of like this final state machine leaves a trace in our code that corresponds to this specific action. So we just like pushed like the event with like the keyword not and the unique id of the, of the, of the final state machine node that we mean to implement here. And what does it mean is that like whenever we execute any transaction, for this, any transaction, we have the set of events with this like, keyword and the unique id of the node, and we can match this trace that we got from the transaction with the graph that we have. So we just, like for any transaction that we observe from our protocol, we can take this trace, we can match it to the graph of our final state machine and check whether this trace is actually the correct path in this graph.
00:26:30.082 - 00:28:19.270, Speaker A: Right? Because if it's not, then it means that our protocol, our code, actually does something different. It does not implement the final state machine it meant to be. Right? So, yeah, and that's how we can like prove, it's not like the strong proof, it's a pretty big proof, but it's much better than nothing. That's how we can prove that our protocol, that is, you know, like written in like rust, with all the boilerplate, with all the stuff related to cosmos itself, with all the like workarounds around, I don't know, like interchange accounts and such, with all the asynchronicity, all of this stuff, it still implements the machine, the final state machine that we created for our spec. It's not the strong proof, but first of all, it's the proof we here, like when talking about the correspondence issue, we basically transformed the issue of manual examining all the lines of code to check whether they implement the final state machine manually. Two, just a simple task, you just need to see whether this trace is immediate when the action is performed, when the proper action is performed, and that's what you need. So you basically, you have much easier task to do to prove that your protocol is correct.
00:28:19.270 - 00:29:07.080, Speaker A: So yeah, and when we can check this correspondence, we can check with, check it whenever we can check it during the unit tests. And here you can see the example of unit test. And this is a good part of it as well because like for example in our unit tests we have this like check in each test. And basically it means that for each unit test we actually see which path in the graph this test covers. Right? So like we can see whether like some path is covered, some path is not. Because without that it would be really, really difficult even to explain which specific path you want to cover when you create a task for developer or something. And here you are just saying, hey, this path is not covered in our unit test.
00:29:07.080 - 00:30:13.330, Speaker A: Just write a test that covers it and it just can be done. And you can see that, ok, this thing exists in our codebase right now. We can do it during the integration test. So like whenever we launch the local environment for testing contracts, we can, like for any action that we do, we can check, we just put a checker that for any transaction, actually checks whether these transaction events, they lay in the graph. And we can do it for Testnet and Mainnet environments as well. So whenever we deploy our protocol on Testnet, we implement the monitoring that just indexes all of those transactions and once again checks whether they implement the correct thing. And if we see that something goes wrong, we actually know that, ok, yeah, our protocol started to behave in a weird way and we need to fix that because once again, we never know whether we covered all the potential cases.
00:30:13.330 - 00:30:59.750, Speaker A: Even if we see that all the transactions before they generated proper traces, it doesn't mean that there will be no transaction in the future that will generate some weird trace. So yeah, that is why we need to put it into our monitoring as well. And yeah, that's basically it. You can follow the progress of our project on the drop money website, you can follow our twitter there, you can check the repos. And we are working hard on publishing the docs as well. And yeah, we are going to be launched pretty soon, in a few weeks. So yeah, thanks for listening.
00:30:59.750 - 00:31:06.550, Speaker A: Happy to answer any questions.
00:31:08.410 - 00:31:27.630, Speaker B: Actually, maybe I think I missed this. But like, what's the advantage of implementing FSM in your protocol? And like what, why are people like, what's the alternatives to, like, checking whether the app is running well?
00:31:29.450 - 00:32:20.768, Speaker A: Yeah, thank you for the question. Good one. Yeah. So what the advantage of implementing is FSM because basically we need to manage the complexity of it somehow, right? So that's the question of how we can like create that. And to be honest, like, there are at least like three protocols building on neutron right now. The protocol of protocols of this type that interacts with something on the remote chains through the ICA and search these protocols, drop the covenants by timewave and the AMoled protocol. And yeah, we talked with all of them and we see that all the teams, they come up with the final state machine id.
00:32:20.768 - 00:34:22.260, Speaker A: At the end of the day, the, like, it looks like it's the like best trade off in terms of like managing the complexity of this protocol and like the only way probably to do that because, yeah, like you anyway have very, the states, they, like, they appear in your protocol where like in a very natural way because you have to like, like stop execution somewhere and wait for something to happen on the remote chain and wait for the acknowledged, the result to be submitted. So the states where protocol pauses its execution, they appear very naturally. So final state machine looks like the very natural way to implement these type of protocols. So, yeah, I'm not sure whether there is like any good alternative approach here because as I said, from what I saw, at least from our experience and the experience of teams we talked with, that final state machine approach is the very good one. What could be the alternative solutions for checking the protocol correctness? I mean, like we, like, it's not about the alternative solutions, but you know, like the complementary things that anyway are needed. Like we also, of course, like we write the test, like unit test, intuition tests and such. But if we're talking about the protocol correctness in this specific meaning, right, when we're talking about like final state machine and whether it is like protocol implements this final state machine, I would say that, yeah, first thing that I said, it could be implemented with some special tools for formal verification and such so that the protocol correctness would be just proven by these tools.
00:34:22.260 - 00:35:04.058, Speaker A: But we are not yet there. So yeah, we don't have the necessary tooling and such. As far as I know, at least for crypto, it's not yet implemented. The tool like that would be this advance for cosmos. But yeah, the other potential good solution here would be if we could have any sort of standard framework to build, like, for example, final state machines. So, for example. Yeah, like, I mean, it looks like on our experience that all teams that are start doing like, the protocols of this kind, they are building final state machines at the end of the day.
00:35:04.058 - 00:36:20.942, Speaker A: And it means that probably this approach could be generalized somehow and we could have, like, these, like, SDK either baked like in cosmosm itself or maybe like as a standalone SDK that would allow us to actually, like, structure our code as this final state machine. So, like, in the code, we actually would describe, like, just like states, the actions for transfers between them and all of this sort of stuff. And if we could have the SDK of this type, then it would help us with understanding. It would be much clear. Just with the manual examining of the code that actually implements this state machine, you have one to one correspondence with all the artifacts from your graph in the code, but it's not the case yet, unfortunately. Of course, we thought about implementing something like that maybe later once we will have enough experience with working with that because we need to understand what our actual needs from this framework, from this potential framework, but it's not the case yet. So.
00:36:20.942 - 00:36:26.942, Speaker A: Yeah, but it would be a great solution as well, so that we could just, like, structure our code in a proper way.
00:36:27.046 - 00:36:30.770, Speaker B: And right now, the limitation is the Cosmos SDK.
00:36:31.750 - 00:36:57.616, Speaker A: Cosmos. Yeah, it's not like. Yeah, it's not the limitation. It's just as I said, neutron here brings this new approach to life. Right. Because we didn't have this fisher in cosmos yet. So, yeah, only on neutron, we experiment with this kind of stuff and cosmos.
00:36:57.616 - 00:37:37.940, Speaker A: So it's not like the cosmos limitation. It's just we're experimenting with a new field. So, yeah, we just haven't managed to implement something for that. So, as I said, based on our experience, I think that that's potentially a good thing to collaborate with all the teams that build such protocols to see how we can make it better for other teams to work with that in a more simple manner. Any other questions?
00:37:41.050 - 00:38:28.280, Speaker B: Have you seen anything like that people are building for roll ups that has kind of similarities? I'm not a blockchain developer, so I don't really know what's the other solutions out there. I think makes sense in terms of checking the states. I'm a developer, but more like web developer, but I mean, there is probably, like, other smarter ways of doing, like a proof of the event happening and problem. What I see, FSM is very, very, like, logical. Yeah, but maybe there's other ways of doing it. Yeah, that's okay, that. Can you.
00:38:28.280 - 00:38:30.812, Speaker B: We're also curious, I would say.
00:38:30.996 - 00:39:18.198, Speaker A: Yeah, that's probably the case. So basically, there are definitely other ways to do that. This one is just why I think it's important, because this one is really easy to integrate into your projects. Even on the very late stages. Even if you are already implemented everything you just at this stage, you started thinking about, oh yeah, I need to. Even if your project already live, already deployed on Mainnet, you can add this stuff and even it won't break your logic or something. You can even upgrade your smart contracts to this version with just additional events being emitted.
00:39:18.198 - 00:39:33.640, Speaker A: That won't break anything, like introducing new vulnerabilities and such, and gain additional security. That's also pretty important property of this approach, that it's really easy integrated and.
00:39:33.720 - 00:39:39.980, Speaker B: It always goes back to the idle event happening, or the idle. Idle state.
00:39:41.240 - 00:40:21.670, Speaker A: In our case, yes. In our case, yes. So basically, yeah, we have this idle state here, but it depends on the structure of your protocol. So basically, yeah, for us it's idle because we want to make actions on the regular basis here, and we want to have the gap between those actions. So that's the place where protocol just awaits an idle state until the timeout is reached. So that's just like the specific detail for our protocol. But yeah, it's not a necessary thing, I would say.
00:40:21.670 - 00:40:36.390, Speaker A: Yeah, yeah. Thank you. Okay, if no other question, I think we can wrap it here. Perfect timing.
00:40:37.890 - 00:40:38.990, Speaker B: Thank you guys.
00:40:39.530 - 00:40:42.490, Speaker A: Thank you everyone for coming on this rainy day.
