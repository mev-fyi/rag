00:00:01.760 - 00:00:26.690, Speaker A: So thank you, everyone. Welcome to this panel on the different vms. My name is Rex Kershner. I am a host of the expansion podcast, which is Blockworks latest podcast on the modular ecosystem. And before we jump into vms, let's just do a quick round of introduction. So if everyone can say their name, their project, the VM they're working on, and then let's maybe do one or two sentences on why you think the VM that you're working on is the one to bet on.
00:00:29.030 - 00:00:43.130, Speaker B: Sure. I'm happy to start. Thank you all for coming today. If I were you, I would be in bed. So I'm impressed and honored that you're here. Some of you look like you might still be in bed mentally, even if not physically. I respect that, too.
00:00:43.130 - 00:01:01.310, Speaker B: I work on a project called Onoma, and I have a confession to make, which is that I am greatly underqualified for this panel because I don't know what a virtual machine is. So I'm hoping that maybe we'll figure that out. I'm also not convinced that they should be competing with each other. So, you know, a little. Little. Yeah, maybe. Not sure about the frame of that question.
00:01:01.310 - 00:01:18.930, Speaker B: I mean, the closest to a definition that I've found is that virtual machines are ways of representing functions. And I think it's not really possible to speak about which is the right way to represent functions without speaking about which function do you want to represent? So, perhaps different virtual machines would suit different purposes, but we shall see.
00:01:20.240 - 00:01:45.340, Speaker C: Hello. My name is Mitri. I'm from flip fluent. I totally agree with your point that what the hell are virtual machines? Yesterday I tried to figure out what they did. What's the proper definition of virtual machine, and why we have such huge amount of virtual machines, and let's figure out how it works, why it works, and actually how fluent is trying to solve this problem.
00:01:46.930 - 00:02:09.590, Speaker D: Hi, I'm Eugene. I work at Ellipsis Labs. And I guess I'm the third guy on the panel who doesn't have a formal definition of a virtual machine. But as a company, we are core contributors to Phoenix, which is a limit order book Dex on Solana. We're pretty familiar with the Solana virtual machine and the toolset around it.
00:02:10.820 - 00:02:34.320, Speaker E: Hello, my name is Keone Hahn, co founder of Monad. Monad is a high performance EVM, layer one. And the reason why we built for the EVM is because we feel that the network effects of so many developers, so many libraries, so many existing programs is just really powerful.
00:02:35.900 - 00:03:23.364, Speaker A: Okay, well, I was not expecting to just have debate on the concept of vms, but we'll power through and we'll come to conclusion by the end. But we should start with the EVM. And let's start with the vanilla eVM, the classic eVM. So today, I'll summarize, kind of like the complaints with the EVM in three pieces, right? We have scalability, we have security, and we have developer experience. So can we talk through each of your projects? And except for Keone, who is using the EVM, but kind of in a modified way, can we talk through which of these three pillars do you think is the biggest problem, and how is your project kind of addressing that issue that you've identified? So why don't we go reverse order? Keone, why don't you start us off?
00:03:23.492 - 00:03:25.948, Speaker E: Sure. Would you mind just saying the three different.
00:03:26.084 - 00:03:26.404, Speaker B: Sure.
00:03:26.452 - 00:03:30.680, Speaker A: So, scalability, security, and developer experience?
00:03:31.100 - 00:04:20.070, Speaker E: Oh, sure. So Monad is fully bytecode compatible. So any existing EVM application could just be redeployed on Monad without any changes. All of the changes to the VM that Monad has implemented are just related to making it a lot more performant. For example, introducing a custom state database for storing Ethereum merkle tree data that's completely under the hood. Optimistic parallel execution for executing many more transactions in a unit of time, but also completely under the hood. So just, you know, regards to the scalability aspect, I just think that there are a lot of areas of improvement relative to the current implementations of the EVM, for example, in Geth or Aragon or other clients.
00:04:20.070 - 00:04:34.990, Speaker E: And our team is a team that's really focused on just making some of these fundamental improvements that don't actually change the. Yeah, any compatibility or any, any considerations for developers.
00:04:36.970 - 00:05:50.552, Speaker D: Solana and the SVM are really designed for performance, and that's sort of been the goal for Solana since 2018. And so at the VM layer, there's, you know, some constant factor improvements just in the, really, just in the implementation where we don't use like, u 256 because they don't work super well with computers. Today's computers, let's say Solana, has a couple of other things, like native access lists. Although this is not like a VM detail, necessarily, this is something you could slap on the EVM if you wanted to, and allows you to do a particular type of parallel execution when it comes to which VM is going to win. I mean, I think in the same way that it's relatively unlikely that a single blockchain wins every single use case wins every single user. I think it's pretty unlikely that a single VM or a single execution environment is going to win every single use case. Kind of going to the original question of what are these things useful for anyway? Some applications are going to be really, really performance sensitive.
00:05:50.552 - 00:06:00.780, Speaker D: Some of them are going to really rely on being extremely, extremely censorship resistant. And probably the right tool is going to be different for different types of applications.
00:06:03.880 - 00:07:06.012, Speaker C: You highlighted three main areas, and that's a bit tricky because at the same time you cannot design solution by, for example, ignoring one of these, and you also cannot focus on one specific area. Influent we tries to build a product that combines all these three main aspects, but if someone asked me what's the most important and beneficial, for example, in terms of fluent, I'd say that it's a developer experience. And I have a reason for this because there is a giant problem and maybe I think it's even a giant gap in misunderstanding of what is VM, how it works. And why do we actually need to have these tens of different vms? Because they're all designed for specific needs, for specific tasks. In fluent, we don't want to invent new vms. Actually we do, but we don't expose it to developers. We disallow developers to interact with our VM internally.
00:07:06.012 - 00:07:40.070, Speaker C: Instead we say that you must use only toolset, you know, only tool set that already exists on the market, and you can combine all these tool sets together by translating into our special vm. And this is how we try to enhance developer experience. And at the same time, for example, scalability is extremely important, or projects starting with, let's say fluent TZK based. And it brings scalability opportunities for chain to be semi centralized and be scalable simultaneously.
00:07:41.490 - 00:08:27.290, Speaker B: So I think we've been psyopped maybe by the editor of the virtual machine Wikipedia page. If you go to the virtual machine Wikipedia page, it describes a bunch of these designs from the 1960s. And in the 1960s computers were all mainframe computers. They were in like university laboratories and there were very few computers. They were like big and they consumed a lot of power and they were expensive. And universities, being nice, wanted to allow their staff, many different staff, to use these computers. So they created these kind of timesharing services, particularly timesharing services for computation, where people who wanted to do compute jobs wanted to run them on the mainframe computers, maybe even have those compute jobs interact with each other, would submit job requests, they would send them all to the mainframe, the mainframe would schedule them and execute them in order, because it was trying to share this resource of computation.
00:08:27.290 - 00:09:01.870, Speaker B: And even if you look at something like the EVM or the SVM, they are modeled after the same basic understanding of the problem. And I think that understanding of the problem was perfectly suitable for 1960s mainframe computers when what you wanted to do was share computational resources. I'm not convinced that it's suitable for our problem. I mean, we haven't really defined what our problem is. But to take apart the EVM for a second, to me, the EVM consists of three things. It consists of a state architecture, how state is stored, how changes to state are authenticated. A state architecture, it consists of an instruction set.
00:09:01.870 - 00:09:36.298, Speaker B: This is how computation is represented. So add multiply 256 bit integer types that I would call part of the instruction set. And finally, it consists of a message passing model, which is how programs send data and messages to each other. And in the EVM, this is accomplished by the call opcode and its various variants. And these three things are coupled together in the EVM, but it's not clear to me that they're necessarily coupled together at all. So, one thing we've done with our project, called the resource machine, is split these three aspects apart. The resource machine is a state architecture, but it doesn't fix a particular instruction set or message passing model.
00:09:36.298 - 00:10:00.970, Speaker B: So you could still use the resource machine with the EVM or the SVM, just as an instruction set to represent functions. And you can pass messages, I don't know. However, you need to pass messages on the intent gossip network through solvers to figure out a satisfying solution and just publish that as a transaction. I don't think the resource machine is the only way to split these three components apart. You could do a different architecture. You could do many instruction sets. When you split them apart, they're not tightly coupled.
00:10:00.970 - 00:10:34.854, Speaker B: They're not one to one coupled like they are in the EVM. And you could probably do many different kinds of message passing models. So I would be interested to see a lot of investigation in that direction. I think it's really hard to say what the right vm is without defining a problem. To me, the EVM's problem right now is that it hasn't defined a problem apart from the world computer, which is a meme. It's unclear what the EVM is trying to do. What is the machine that it's aiming to virtualize? Is the machine one blockchain that wants to share, that wants to provide abstract computational and storage resources? That's maybe what it originally was.
00:10:34.854 - 00:11:06.290, Speaker B: But with roll ups, with layer ones being used mostly for proof verification. With a lot of computation happening off chain and with just the very structure of the gossip network, implying that no one other than the person actually proposing the block can really guarantee the results of execution. Absence of more complex models, but still, random nodes in the gossip network can't. I think the EVM has a sort of definition that's like misfit to its actual deployment scenario. And if we want to fix it, we first kind of need to clearly define the bounds of what the machine is that we want to virtualize and to whom.
00:11:07.310 - 00:11:08.890, Speaker A: Keoni, did you want to say something?
00:11:09.550 - 00:12:15.270, Speaker E: Yeah, definitely appreciate that kind of breakdown of the EVM into several components and the effort to try to reimagine what it would look like if we took the burrito apart and made a burrito bowl instead. But I think just to state it very clearly, the way that. And we all know this because we all interact with etherscan, we see a block, and we look into the block, and it has a bunch of transactions. We look at one of the transactions, and it's interacting with a particular smart contract. I would just say that at the end of the day, that's a pretty easy to understand computational model of just transaction based execution, where a transaction is depositing money into your virtual bank account lending protocol or something like that. So it's not like, totally abstract what a VM is. Like, a VM is a sandbox for executing a program using a standardized instruction set, like you said.
00:12:15.270 - 00:12:24.550, Speaker E: And then this gives us building blocks. We can build up more complex an entire Lego castle from these individual bricks.
00:12:25.290 - 00:12:26.706, Speaker A: Yeah, I mean, just here.
00:12:26.778 - 00:12:27.338, Speaker B: Got it.
00:12:27.434 - 00:13:02.756, Speaker A: Got to take that off. Just like, I did not realize the concept of a VM would be controversial for this panel. And look, like I come from the, I don't know, school of vms that, like, I learned what a VM was from parallels. I have a Mac. I wanted to play Windows games. And, like, that's how you did it, right? And so you could say, like, well, what's the point of this virtual machine? And, like, it doesn't have a purpose, and it's just like, general purpose windows. But, like, the point was that I had access to it and that I could start, like, putting my actions and transactions into it.
00:13:02.756 - 00:13:03.380, Speaker A: And so.
00:13:03.500 - 00:13:10.072, Speaker B: And you had applications that you wanted to use, right. That were, like, written for this VM in some sense, since written for Windows, right?
00:13:10.136 - 00:13:10.900, Speaker E: Sure, sure.
00:13:11.200 - 00:13:28.312, Speaker A: Yeah. So, again, what I see at the VM is. And maybe, like, we need to come up with new vocabulary. Like, there's a good space for new vocabulary. But it is just like the environment on which your like smart contract or sorry, your blockchain actions just happen within.
00:13:28.416 - 00:13:28.656, Speaker D: Right.
00:13:28.688 - 00:13:37.356, Speaker A: So in the EVM that is this like well defined space, the SVM has a well defined space that are not exactly the same, but you know, like they're the computing space.
00:13:37.428 - 00:14:44.750, Speaker C: By the way, according to you called it the vocabulary. I think this is the perfect term that can describe the problem we have right now. Because what we know today, we even cannot call EVM a virtual machine because technically it's not a virtual machine. I name it specific context dependent execution environment with specified instruction set. Because from the like, you provided an example of parallels, like it's more about like emulation, it's a hardware emulation problem. And it's quite different because in blockchain we don't have a hardware emulation problem, we have a sandbox execution problem, and the way how we can pack it efficiently into one place and execute. And the question is, why do we all develop on EVM? Is it the best solution? Or we have to do this to support all developers that already persist there in the community, or we have some alternative choices.
00:14:45.570 - 00:15:39.530, Speaker B: Yeah, I mean, I think to your point about parallels, users want to use applications, and if those applications are written for tied to a specific virtual machine, I mean, users will want to use that virtual machine in virtue of allowing them to use those applications. I suspect this is part of why you guys at Monad want to support the EVM and implement it in a more efficient way and make it better, because they're already all of these applications. That totally makes sense to me. But then to me the question is, can we make it easier for some users to make different choices while retaining the ability to interoperate these vms? If we take them, there are many specific choices, let's say specific choices of state architecture instruction set. They have different trade offs that make sense for different applications. Developers are quirky and maybe they will just be attached to particular vms. There are a lot of people who really like this language called knock used by urbit.
00:15:39.530 - 00:16:07.716, Speaker B: It's interesting, it's very quirky. So maybe we should let developers have their diverse preferences, keep them happy. But how can we allow that to happen at the same time that we don't force users into this question of mutual incompatibility. So just like with parallels, well, you had to install this whole separate environment, you had to make a virtual desktop. And I haven't done this in years and years and years. So you're testing my memory here. But to me, this is like a pain in the ass.
00:16:07.716 - 00:16:30.340, Speaker B: Wouldn't it be nice if you could just run the windows applications in Mac? Right? What if the operating system handled this compatibility and interoperability for you? So to me, it seems like we're having a question about virtual machine design, but also, to your point about a sandbox execution environment, I think we're asking more or less about the wrong problem. We're not trying to build a virtual machine. We're trying to build an operating system.
00:16:32.440 - 00:16:49.534, Speaker A: Okay, that blew my mind. I do think this is a good opportunity, and we'll borrow from fluent. And so, Dmitry, I'd love you to speak on this, but can you talk through this new concept of blended execution and just give us a little bit of a definition? And then we'll have some questions for the panelists.
00:16:49.632 - 00:18:08.704, Speaker C: Yeah, the concepts of blended execution is to try to find a way, it's literally a way, how we can represent all vms using only one function, using only one vm. So is it possible to create a vm that can solve and emulate or simulate all these environments in one place? Yes, it's possible. Yes. And we also think that it's possible, because if you try to imagine how your application works, if you try to support EVM, SVM, and all these other vms, all these standards language, your mind is blowing, because you understand you must implement thousands of thousands of different standards. It takes years to implement, and it makes no sense, because during the implementation period, new standards appears, new versions appears, and you cannot support the circuits, you cannot support this code base. It's super complicated. But what if we try to define a new way, how you represent your application through a transition? And if there is a language that can simulate everything, that can run everything, then you can use this language, for example, to simulate itself.
00:18:08.704 - 00:18:43.940, Speaker C: We call this language r wasm. It's an internal tool inside fluent. It works under the hood of the fluent. And it used to simply to formalize how we prove ZK transitions for all languages. And we do so called downcasted ahead of time compilation from all these binary representations into one binary representation. And we use this binary presentation to prove itself and to prove all, and simulate all execution environments in one place. So developers can take any tooling they want, any language they want, any virtual machine.
00:18:43.940 - 00:19:11.880, Speaker C: Actually, we don't care about languages. We care about execution environments. And if you have solidity, VYPR, et cetera, you have some standards. We don't care about standards at all, because we support execution environment. If we have something that is on the lower level than standard, then by implementing this layer you have standards as a default feature. And also of course, all the languages like solidity, Viper, et cetera. It's like a side effect of your product.
00:19:13.300 - 00:19:18.124, Speaker B: Do you handle, or do you try to handle program interoperability, and how do you do that?
00:19:18.172 - 00:20:24.686, Speaker C: If so, this is the giant, I think, question about how this model works, because the most difficult thing is to handle interop between these different execution environments and influent. We don't know what execution environment you use, actually entirely. We have only one language, our wasm, inside. We have only one virtual machine that is absolutely closed for developers, and they cannot use it and they cannot interrupt. It's a side effect of the development process, of the compilation of the translation unit. And we create our own three representation, our own storage layout, and we create special, let's call it loaders for applications according to the execution environment, where we define how they interact with this tree, how they interact with this state transition, and what alone. So they have and what restrictions they have, because we cannot allow these applications to do everything they want because they can, for example, corrupt storage, get access to another execution environment somehow.
00:20:24.686 - 00:21:05.190, Speaker C: And during the compilation process, we inject all these restrictions, all these constraints into the loaders of the execution environments. So let me add one thing. You can build something like you can create application using EVM, using solidity, let's go. You can create application using SVM, and they can share same balances. You can do native interop between these apps. The only thing you need to carry is API encoding. So we don't care about API, of course, because I can explain why, because it's specifically developers problem.
00:21:05.190 - 00:21:50.650, Speaker C: They all think that oh, these chains, these platforms, execution has different API, developers cannot interact. But if you develop an app using solidity language, how do you interact with other apps? On solidity, of course you specify API, you must know the language you use to interact and what language developer of the application use if you want, or for example some specific library you want to interact. And what's the difference if I specify solidity compatible API or some other API, for example borscht compatible API, or some like oosaland compatible API. So there is no difference for developers. The syntax may change a bit, but it doesn't affect the development experience significantly.
00:21:51.790 - 00:22:19.810, Speaker A: Great, so my brain doesn't have very many wrinkles. Let me try to regurgitate back to you what you said. Tell me if this is right, or the effect of what you said, which is as a developer if I want to deploy into fluent, I could write my code in solidity, or I could write it in rust or another language and fluent in the background, takes in all of these binaries and then presents the users that this is one unified computing environment. Correct?
00:22:19.850 - 00:22:20.890, Speaker C: Yes, correct.
00:22:21.010 - 00:23:20.060, Speaker A: And like that. Incredible. Thank you. And like, to me this is like clearly where the industry is moving, right? We just, whoever was here yesterday saw Ed Felton, I believe, from arbitrum. Talk about arbitrum stylists, and this is like the exact direction that they're going, which is to realize that there's not that many solidity developers, there's a ton of rust developers and a ton of C developers and C developers. And so I guess my question for all of you guys is this, for me, this is a clear trend of where the industry is going, but is that how you see it? Do you see that these execution environments are kind of this developer weird thing that we have to deal with now as just growing pains of blockchain computing? Or is this an important paradigm that will exist in ten years and 50 years and we'll understand what the EVM versus the SVM and be having those debates when we're grandparents. So why don't we start up from Keoni?
00:23:21.960 - 00:24:14.008, Speaker E: I'll just mention that JavaScript is still the backbone of most interactive web apps. We have nicer frameworks on top typescript and then frameworks on top of typescript, but everything under the hood is still JavaScript. So I think if you're trying to project five years into the future and say, what does the smart contract landscape look like? Is it just a jumble of all these random solidity things that are floating around in different GitHub repos, all verified underneath their scan? I think that's likely. And we just see a proliferation of more complex applications built on top of the existing ones, similar to how what we see in the Internet landscape with JavaScript.
00:24:14.064 - 00:24:14.860, Speaker A: Yeah, fair.
00:24:15.600 - 00:25:19.280, Speaker D: Yeah, I think this is very path dependent. There are also previous web frameworks, web languages before JavaScript, and I don't think it was clear a priori what was going to reach escape velocity. And there's like a lot of these sort of constant factors that matter here. One of them is the, like the hardware itself, the computers, the browsers now have access to so much more resources than they did before, to the point where like the average shitty JavaScript developer like myself can still build a web application that mostly works, and the tooling is also seem to reach some sort of escape velocity, which is where in my mind, the EVM has the biggest advantage today. I think the total number of developers just doesn't matter whatsoever. If you're bullish at all on crypto, you should expect the number of developers in the future to be at least two orders of magnitude higher than it is today. And then where you're going to get the runaway network effects potentially is going to be on the developer tooling and developer onboarding.
00:25:22.470 - 00:26:31.014, Speaker C: I think one very important statement from my perspective, we cannot fight against developers needs and requirements, no matter what tool set you provide to them. They all the time use what they want and you cannot limit them with a number of vms and say oh, you must use this, this and this for the four of, for your needs because you, you cannot like the number of. So if you can create all these vms, you also can create an app that doesn't fit into one of these VM and you will need new VM. You highlighted the great example of JavaScript. I like to call JavaScript a machine code because in some way of how you think about Chrome, it's an operating system and it has its low level machine code in JavaScript because it's the simplest thing you can develop and use inside your Chrome browser. And Google tried to replace JavaScript for several times. They tried to use Dart as a foundation language for development, but under the hood they literally translate all the time, everything to JavaScript.
00:26:31.014 - 00:27:22.090, Speaker C: And JavaScript is the most weird machine code ever created because, because it's not natural to have JavaScript as a machine code. It makes no sense. But this is what we have. And today if you want to create new solutions, you must always worry and think about developers, about execution environment. You have Google Chrome developers or all browser front end developers, they are locked to use JavaScript and there is no ways how they can get away from this. They're trying to mix it, for example with Webassembly to let developers develop, for example UI using JavaScript and develop highly loaded apps using webassembly. This is very similar, for example, what stylus is trying to achieve.
00:27:22.090 - 00:28:29.450, Speaker C: And you can use EVM, that is, let's say an important legacy to have. And also you can expand functionality using webassembly. But we are trying to think even further, because what if we don't want to limit developers with two languages, with two execution environments? What if we can let them define the execution environment they want? If they want to develop something that is not supported by, for example, stylus, they are limited with functionality because they need to wait stylus to develop this but using our translation approach, we can let developers to create their own execution environments and create apps for these execution environments. If one new vm appears, they just create translators into our level representation, they create simulation tool set and that's it. Developers can start using this and we think it can be the future because we don't want to limit developers, we want to help them to use the same environment, to use the same tooling, and we want all developers persist in the same state, in the same place.
00:28:31.950 - 00:29:23.158, Speaker B: To me the question is, what are we trying to provide here? And in all of the examples that you've given of parallels of the EVM of your kind of blended execution environment, it seems to me like what we're trying to provide is interoperability in two ways. We're trying to provide one, interoperability between applications. Applications need to share some kind of environment, some kind of operating system, especially when they don't always trust each other in order to facilitate interoperability of state messages, et cetera. And two, we're trying to facilitate interoperability with an existing base of programs, developers, the stuff that people have already written in solidity for the EVM, the models that developers already understand, and I think we will continue to want both of those kinds of interoperability. I think this question does not relate to many of the aspects that are often bundled under the term virtual machines. In particular, it doesn't relate to the instruction set. Nobody cares about the instruction set.
00:29:23.158 - 00:30:10.280, Speaker B: What's the instruction set? You said that JavaScript is a kind of machine code, which I think is true and funny, but also Google sank boatloads of money into their just in time JavaScript compiler, and it does random things that I guarantee no one in this room knows. Unless you work for Google on v eight, then I'm impressed and wrong, but probably not come find me after. And the reason that you don't need to know it is that they have abstracted the right thing. Developers can write JavaScript, I mean the web browser APIs are not great, but they're there. At least there is an operating system environment. And Google sank their money, which they have too much of, into a lot of compiler engineers, to at least try and make your JavaScript run kind of fast most of the time, and it works sort of well enough. And I think that is much more likely to be the world that we'll see.
00:30:10.280 - 00:30:29.500, Speaker B: Maybe there will be some low level formats that for whatever reason or another are kind of standard just because it makes things simpler. But developers will not need to even think about them if they need to think about them. And we're on this panel and another 60 years as grandparents still talking about minutiae of virtual machines. Yeah. Then I think we need to re examine our lives.
00:30:30.800 - 00:31:23.358, Speaker A: Okay, well, you kind of cut off my last question to the legs here, but I'll ask it anyway, which is, you know, a buzzword right now in this point of the narrative is abstraction, right? Like chain abstraction, account abstraction. And I guess, like, my question for you guys is like, do you believe that we're inevitably going to reach computational environment abstraction? And to that effect, how important is the VM? And can you build a business with your differentiating factor being your VM, or tweaks to your VM or that kind of thing? Or if we are really going down a computational environment abstraction roadmap, is this stuff really relevant, or is this kind of implementation details that a developer will see on page twelve of the docs? So why don't we go in forward order? Chris, take us up.
00:31:23.534 - 00:31:39.060, Speaker B: Yeah, I mean, I would say, to me at least, computational abstraction was invented by Alan Turing, so I think we're doing ok there. We don't necessarily need to reinvent that one. Perhaps we can build some better compilers. What was the second question? Sorry.
00:31:39.680 - 00:31:49.096, Speaker A: So do you believe in this computational environment abstraction? And is the VM a differentiating factor that you can build a business around?
00:31:49.208 - 00:32:16.226, Speaker B: Right. I mean, whether or not you can build a business around something depends on what kind of world of money and of finance in which you operate. And I think it's likely that that will change. I mean, it always changes through history. So even absent crypto, or even talking about our specific technology, a reasonable assumption is that it will continue to change in the future. To me, compilers are useful. It saves energy to have more efficient compilers.
00:32:16.226 - 00:33:01.630, Speaker B: So I would be very happy if we come up with ways of organizing our financial system that make producing better compilers viable businesses, at least for some people, maybe not everyone. If everyone's producing compilers and no one's producing potatoes, we're in trouble. But we probably want some resources dedicated towards that. I think the business models will need to look different than how they currently look, where people like, in effect, raise the development of compilers and virtual machines and the operation of a specific layer, one blockchain or roll up or something. These are coupled together in the public eye and the eye of capital allocation. And I think this coupling doesn't work very well. One, it doesn't work well as a value capture mechanism because people want to send intents and transactions based on a lot of other factors, mostly not just like the computation, mostly not just the VM.
00:33:01.630 - 00:33:21.030, Speaker B: And two, it doesn't work well in terms of actual capital efficiency because you have a lot of wasted duplicate efforts, and then you try and create gatekeeping effects so people will send transactions to your chain or whatever. So I think in general that's a pretty terrible system of financial coordination, and we should probably seek to replace it in order to get better compilers and more abstraction.
00:33:22.490 - 00:34:13.460, Speaker C: Yeah, I won't say regarding abstraction. I want to also add regarding modularity. And I think these are quite similar concepts, because I extremely love what's happening with crypto industry today. That happens like two, three years. That started to happen two, three years ago, because before everyone tried to build layer one, layer one, layer one, the fully monolithic, almost the same blockchains with one tiny difference. But today, developers, they finally figure out and the entire community that there is no need to create all these fully independent environments. You can do so called, you can delegate responsibility for specific functions to specific areas, you can try to abstract most of things.
00:34:13.460 - 00:35:12.524, Speaker C: You can split your blockchain into sequential execution, data availability, settlement, and et cetera. And you can let different teams to focus specifically on specific themes. This is why VM matters, because VM is a part of execution layer, and let developers create great execution layers and share it across the entire industry and just utilize what we have. I think this is extremely right way because the entire crypto industry is finally on the way to build the giant crypto infrastructure that can be. It's a giant ecosystem that can even compete with web two and to be integrated into web two, because we finally forgot about this extreme decentralization with ASIC mining, where the only thing that is important is to produce your hashes. And this is huge. You have ten kl hashes and amazing omega hashes, terra hashes, it doesn't matter.
00:35:12.524 - 00:35:38.650, Speaker C: But finally we can think about more semi centralized solution, about ownership, responsibility, delegation, and actually thanks to ZK, because ZK really helped to bootstrap this process. Yes, it's not super optimal today. ZK has a lot of things to fix, to improve, to optimize, but community started to think about the problem and now we can expand the ecosystem. Finally.
00:35:41.680 - 00:36:23.850, Speaker D: I'd say the economic interest here, where everyone is always trying to commoditize their complement, means you're pretty much always going to be stuck in the cycle where, like in traditional media today, we see this cycle of bundling and unbundling, bundling and unbundling. See the same thing in enterprise SaaS, and we're going to see the same thing at all these different levels of the crypto stack where I'm always incentivized to try to abstract away or commoditize the layer above me, the layer below me. They're trying to do the same to me. So I think this is really all motivated by business interests. I think it's pretty difficult to fight against the economic incentives. I think that's how it's going to play out.
00:36:26.630 - 00:37:23.794, Speaker E: Yeah, I mean, I think we need to be very pragmatic. I think that there's just an incredible opportunity for the crypto space right now to grow substantially and take more share of the market for decentralized apps to become the prevailing standard. But that's not going to be easy to do. And I do worry that. Well, in any event, I think what's really important is to, like, you know, we have a couple of standards. It's pretty clear that, you know, the, you know, like, there's traction around the EVM, there's traction around the SVM, and we'll make incremental improvements, performance improvements, or feature improvements to those. But really the.
00:37:23.794 - 00:38:05.740, Speaker E: Yeah, just, I think that the growth has to be, obviously in the application space. And I think that to some of the earlier points about just wanting to abstract everything away or give a ton of flexibility, I do think that there's a reason why trains run on tracks. It is because you can go a lot faster when you're on a track. I would just push back a little bit on the. Some of the other comments about how developers might want to run a random language that doesn't exist right now. I don't know. I just think that EVM is here to stay.
00:38:05.740 - 00:38:26.250, Speaker E: Our team is working on trying to make it a lot more performant. I think for the entire Ethereum space. It's just really important for us to get much more scale out of what we have and then go figure out how to make inroads into the rest of the tech and financial space.
00:38:26.910 - 00:38:35.526, Speaker A: Awesome. Well, we're out of time, so, everyone, can we get a hand for our panelists? And thank you, guys. Thank you very much.
00:38:35.598 - 00:38:35.910, Speaker B: Thank you.
