00:00:00.200 - 00:01:32.354, Speaker A: Consensus, but maybe the VM is faster, or if it's a roll up, maybe it has a slightly better fraud proof, or like, you know, maybe they have a better proving system if they are ZK roll up, but they all look fundamentally the same. You have smart contracts that you interact with and it triggers an event, etc, etcetera and that. And like, I think there comes a question of whether or not just switching out the vms are really enough. Or do we need a kind of a novel way of building blockchains to really be able to scale these, these fully on chain games? We decided to think different and ask ourselves, hey, what if we just take a pause from copying whatever already exists? And instead of trying to build a blockchain for everyone, trying to build a blockchain for every single use cases that you can think of, what if you just focus on building the best blockchain for games and games only for those of you who might not be familiar with product design and all of that, this is really one of the key ingredients in building great products is to really understand your user and build solutions to cater to that users in mind. And that's how we embark on this journey in building the world engine. We first started with asking ourselves, how are normal application different than computer games? You see people building web applications using frameworks, let's say Django or Flask or whatsoever, but people don't build computer games with those frameworks. People build computer games with game engines.
00:01:32.354 - 00:02:31.536, Speaker A: Why does web applications have different frameworks and different stacks with computer games? But in blockchain, people just seem to think that you can use the same stack to build this to the very, very different application. What we realize is that with all web applications is most of them are basically event driven in nature. So like for example, a user writes tweets and like, you know, after they write it, they click a button triggering an event. And then after that, buttons click, the tweet is posted onto the Twitter backend server and now the rest of the world can see it. And so this is like what we like to call an event driven runtime. In contrast, games like Minecraft, they don't need user input to trigger like, you know, a state transition or really kind of an update in the game itself. For instance, when you play Minecraft, even if you're just not even on your computer, you can just go to the restroom or just sleep whatsoever.
00:02:31.536 - 00:03:17.944, Speaker A: The game progresses forward. You see wheat grows, you have see Daynet cycles move forward, fire continues to burn, cause damages to players and enemies surrounding it. Waters and physics continue to flow. And so it seems like there's this loop in the background that is continuing to run the game and move it forward. That is not, you know, that is not something that exists in most modern web applications, where it relies on user input to be able to do a certain action. And this fundamentally what we realized was extremely different between these two applications. If you look at traditional blockchains like Ethereum, Solana, and what have you, all of them are designed with this event driven runtime in mind.
00:03:17.944 - 00:04:04.678, Speaker A: Let's say if you have Uniswap, a user wants to trade token a for token b, they submit a transaction and that trade is executed. Again, event driven runtime, there's really no these background loop that progresses the game forward, preventing things like Minecraft from being built fully on chain. And that limits the design space of the game that you can build. And it also impacts performance in ways that you might not expect to. And so we learned that classical blockchains are not compatible to run games. And so this is like how we decided to look more deeply into why loop driven runtime is necessary for a blockchain focus, like roll up or blockchain, like a game. Like a game focus like roll up.
00:04:04.678 - 00:04:42.354, Speaker A: And so this is like where we kind of discovered this idea of ticks, right? In the games, you have this idea of ticks, which are the atomic unit of time, where each game loop is represented by a single ticket. And a higher tick typically implies the game is more responsive, it's more real time, and games are lower. Tick feels more sluggish. It feels like, oh, why is the game so slow? It's not responding to an inputs, et cetera, et cetera. In a classical blockchain, the tick is more somewhat analogous to a block. And a tick in a blog is late. You feel a lack in the game, the client will start acting up.
00:04:42.354 - 00:05:42.390, Speaker A: And so it's really important that you make sure that the tick rate is consistent. Like number of ticks per second remains consistent and is executed at a fixed interval. And we also learned that there are many benefits of adopting this loop driven runtime. It allows us to have this game state transition that is not triggered by external input, like things like gravity or game physics. It allows us to have deterministic transaction ordering, making sure, let's say, like, you know, like attack damages are applied before, like, you know, poison damage, to make sure that, you know, like, you know, let's say a player can heal themselves before, like, you know, they get attacked and make sure that prevents them from dying, et cetera, et cetera. It also allows us to more aggressively paralyze execution, which we do not currently have with like traditional vms. And we also like realized that like we can't really just like try to smock this like, you know, event driven, like loop driven runtime into existing blockchain.
00:05:42.390 - 00:06:25.210, Speaker A: Do you really need to re engineer a new node architecture from scratch to be able to accommodate this efficiently? And so we realized that fast transactions is not enough. Like, there's a lot of people out there trying to build new blockchains with high transaction throughput or high transaction per second. We realized that data alone is not enough. You need these key missing pieces, which is game takes. They're absolutely necessary for building games. There's no game engines out there that doesn't have the concept of ticks. Precisely for this reason, we taught about a L2 roll up solution that basically takes all these boxes for us.
00:06:25.210 - 00:07:12.400, Speaker A: We want to make sure that it has composability. We want to make sure it still has some smart contract, ideally EVM smart contract, to have this unique unlock that games like Dark Forest has. But we also want to make sure it has real time gameplay. Like you are able to make these games where you have a lot of these transactions coming in and you can process them quickly and give them results to the players quickly such that it feels responsive. You want to make sure that you also have an idiomatic runtime. You want to make sure you have this loop driven runtime that we've been talking for the past five minutes, so that we can build more complex games that we previously couldn't build. And last but not least, you want to make sure that the whole experience of playing the game feels like just playing another multiplayer game.
00:07:12.400 - 00:08:15.526, Speaker A: You don't want to have this clunky concepts like wallet addresses, seed phrases and all of that that overwhelms the users because of a lot of these new terms and instead find more analogous way to explain those concepts to players and gamers whatsoever. But with all of that being said, we are still missing one key piece, and that is horizontal scalability. When you're talking about a consumer application like games, you never know how much players you're going to get. Let's say you build a game and it's suddenly become an overnight success. You want to make sure that you are able to support and grow to the scale of your user demand and making sure that you can onboard all those users. And what we have to do with Dark Forest or we had to turn down people et cetera, et cetera. We want to have the ability to make sure that the roll up that we're building are able to grow and accommodate into this influx of users.
00:08:15.526 - 00:09:22.522, Speaker A: This is why we think horizontally scalability is really important for Arolla. And currently, surprisingly, none of the existing roll ups today support native horizontal scalability. And so at the end of the day, a roll up is like runs on a computer, and games in large application games, like multiplayer games, scale using multiple computers, using various architectures like microservices, or all of these different concepts to allow us to scale the user demands. But those concepts currently don't exist, or back then didn't exist. And so that's why we build our own sequencing strategy with a world engine to be able to horizontally scale the game. We also realized that existing roll ups alter. Some people might just say, hey sky, why can't we just spin up another roll up and then route these new games, do this new roll up these new users to this different roll ups? We realized the reason why we don't want that is because it fragments composability.
00:09:22.522 - 00:10:05.150, Speaker A: Recall that the main reason why we're even doing this in the first place is that we want to make sure that we have composability. We want to make sure that all the players are able to interact with this single shared game state. We are having to hop over these different separate roll ups that requires challenge periods, et cetera, and more gas fees with the l one. We want to make sure that all of that happens seamlessly from a single roll up. And things like shared sequence or constructions right now are less than ideal. Some people are talking about how shared sequencers will solve our interoperability problems, but realize most of the shared sequencer designs are very limited in nature. The one that are synchronous have crypto economic security issues.
00:10:05.150 - 00:11:08.694, Speaker A: They have these old DOS factors that impose constraints on execution layer. Now, everyone needs to have the same block time and whatsoever, which is not ideal for a game where let's say you want to have different block times or different pick rates for different parts of the games, or maybe different games altogether, we need a new strategy to sequence roll up transactions. This is when we start looking into the past and we learn about this concept that has existed for many decades, apparently called sharding. Sharding is a scaling architecture for massively multiplayer online game that have been in use since the 1990s. And it allows us to horizontally scale the game to tens of thousands or hundreds of thousands of player. And funnily enough, these are the origins of many of the modern database architecture that people currently use. And so we decided to take a chapter from it and say, think to ourselves whether or not we can use it in the context of a roll up, which we turns out to be able to do.
00:11:08.694 - 00:12:20.952, Speaker A: How does sharding works in games? How you actually sharp a game? Naturally, what we realize here is that there's no one size fits all solution to scaling and sharding a game. Again, it's a tool in the toolbox, not a prescription. One of the most common instruction of sharding that we've seen and that we've applied is a concept called we call location based sharding. Instead of having a single shard or single computer handle all the computation for all the players in the map, imagine you can partition the map, right? So let's say you have these, like, you know, Cartesian diagram, and, like, you split them off into four different regions, and you assign each region to a different shard. And, like, by doing this, you can, like, basically have four times, like, you know, up to four times, like, you know, the amount of players that you can have, because now your players are load balanced into this, like, you know, different, you know, shards within the game worlds. And so this, if you, if you want to move from, like, one chart to another within the game, you can just send a message to your shard, and then your player gets moved to the new shard and leaves the previous chart. And that naturally happens within the same game client.
00:12:20.952 - 00:13:23.404, Speaker A: So you don't need to do this whole, like, oh, I got to withdraw from my chain. You got to log out and lock back in or sign some multiple hop transactions. All happens naturally, as if you're just teleporting from one part of the map to the other. And so this is the first sharding construction. The second sharding construction is, like, what we often see with, like, MMORPG games. And, like, they like to call it a multiverse sharding, right? So each game worlds have multiple instances of, like, you know, basically identical worlds, but, like, the players can join this, like, different shards to make sure that, like, you know, if, like, a server is full, like, you know, there are other options that you can go to such that you're not stuck with this, like, you know, like, you know, stuck, like, you know, be, not being able to enjoy the fun and you're like, you know, just, like, sad and alone, not being able to play the game. But, yeah, so now that we have the loop driven runtime, now that we have horizontal scalability and also in the process solve the kind of composability problems and fragmentation from launching separate roll ups.
00:13:23.404 - 00:14:05.926, Speaker A: We now have all the ingredients to make roll up that is perfectly designed for scaling fully on gene games. And so this is how the world engine was born. The world engine is composed of two main core components. The first one is the EVM base Shard, which is a hybrid execution layer, a hybrid of execution layer and a secure with our custom sharding architecture. And also a game shard, which is a mini blockchain that is acting as a high performance on chain game engine that is specifically designed to run games and nothing else. We didn't think about DeFi or whatsoever, literally only run games. And we optimize that to be able to run games as like efficiently as possible.
00:14:05.926 - 00:15:24.294, Speaker A: And on top of that, build a lot of toolings to make it easier and like allow the game charts to be more powerful and allow people to build more powerful games, such as like our transaction relay that performs transaction batching, real time game state synchronization, a kind of abstraction so that people don't have to worry about wallets and authentication, et cetera, et cetera. Also ZK cloud prover that allows us to use like privately like ZK to have privacy preserving pulley on chain games, as you will see later. And so like, yeah, and so the general architecture for the world engine is like, you know, built on top of these, like, you know, again, sharding architecture where we use the EVM as the base shard. And like, this is like the EVM is where all of the composability of like the game will happen. This is like where people are able to deploy solidity smart contracts where like, for things like marketplaces, so things like Dexs and contracts that compose and communicate with the game shard, et cetera, et cetera. The game Shard itself is a Hyta create many blockchain that allows us to serve a high performance game server, that you're an experience that you're very much familiar with existing traditional modern multiplayer game engines. Again, the game shards are state machine and VM agnostic.
00:15:24.294 - 00:16:27.244, Speaker A: So technically you can customize this chart to your liking or build your own framework, or build your own game shard implementation by implementing a standard set of interfaces that we have provided. We also built a game chart ourselves for people that you can use today and you'll learn how to write use this game sharp framework in the workshop today where you will be writing an nd component system implementations for your game and that allows you to like half the full game logic implemented easily in go. And again, the Cardinal game shares have configured tick rate so you can have sub second block times. Our latest benchmarks allows you to even run up to 30 ticks per second. So these are sub 100 millisecond block times. That is basically comparable to modern game servers that is off chain. And now you don't even have to have distinction of an on chain and off chain game anymore.
00:16:27.244 - 00:17:00.770, Speaker A: There's no more these limitations of if you have an on chain game, it's going to be slow or it's going to be laggy or whatsoever. You no longer have those issues with the Cardinal game Shard. On top of that, you also don't need indexers anymore. Previously, if you're building games like Dark Forest, you need to have large indexers that are caching your data. But with Gameshark you already do this internally such that you don't have to run the separate indexer. That creates more latency and makes your architecture much more complex. And again, all of this is written in go.
00:17:00.770 - 00:17:51.544, Speaker A: So this expands the horizon for like, you know, if you're building a game studio, you can hire people to write go code much more easily than like hiring smart contract developers. And that helps you accelerate your developer productivity, helping you get to like the market and like shipping your game and iterating on your game much faster than ever before. And again, as I previously mentioned, you do have the power to be able to implement and customize your own game charts. You don't have to use cardinal if you don't want to, right? You can use and implement your own. Let's say if you want to write your game logic and solidity, you can write your own solidity game chart. If you want to have a game shard that is dedicated to minting nfts, or maybe you want to have game chart that is dedicated to tracking game identities. You can build that by yourselves and integrate that into the world engine stack seamlessly.
00:17:51.544 - 00:18:59.582, Speaker A: The starting architecture also works with an asynchronous by default assumptions, so you can have seamless composability and trop ability across these charts without having to place locks in the runtime. And all these current shared sequencer construction like that you might see on Twitter, et cetera requires this total ordering and atomic bundles that requires locking mechanism that is non ideal for a game because it blocks the main thread and makes the tick rate unreliable. We completely avoid this problem just by making the composability happens asynchronously. That allows us to preserve this seamless composability without having to give this atomicity guarantees that it's really not that useful unless you're doing defi. That was a trade off that we were able to explicitly make. And because we are so focused in games and we're not trying to cater to 100 different use cases that we might not even know yet, that's the secret sauce of the scaling using the world engine. And on top of that, you also have this interesting shard properties.
00:18:59.582 - 00:19:45.666, Speaker A: Like, you know, each shark can have different da batching strategy. You can geo localize the shards to where your players are to reduce gameplay latency as well. So like, you know, let's say if your players in Southeast Asia, you'd have a server in like a roll up like charts running in Singapore. And that reduces your like latency to your player. In contrast, if you're only running a single, a single roll up sequencer in let's say the US, and you're playing Singapore, it's going to have at least 100, 200 millisecond ping or basically latency. And that's going to make your gameplay experience so much worse. You can avoid this altogether by geolocalizing your charts and distributing players based on locations, et cetera.
00:19:45.666 - 00:20:33.862, Speaker A: On top of that, you have game Shard dev mode that allows you to easily test your games deployment without having to commit to fully deploying with Celestia and paying costs for it. And so you can iterate on your game so much faster as well. And so we've already built like a scene, like really cool games built on top of the world engine. The first one being dark frontier, which is a spiritual successor or a spiritual kind of inspired game of dark forest. It's built on the world engine and was launched in December 2023 in production using Celestia EA. And within that one week of darkfrontier running, it processed 700,000 transactions from all the game moves that are happening on the world engine chain. And on top of that, this game also have full fee abstraction.
00:20:33.862 - 00:21:14.862, Speaker A: So the user, because the cost of the transaction data is so low, because we're using this last year, the users have to pay zero. All of those fees, fees, blockchain fees, those can be covered by the game developers themselves. And that provides a seamless experience for the players as well. And at the same time, because all of these transactions are so cheap due to the high throughput and the cheap celeste, game developers don't have to worry about it. You can just pay it yourself. And now you can give your users a much better experience. And now you can onboard more users and be more competitive against the other, like, you know, crypto or web 2.5
00:21:14.862 - 00:21:51.348, Speaker A: or like fully on chain games. And so again, the code for Dark Frontier is actually now open source. So if you want to play around with it, you want to extend and remix it, you can check out Argus Labs GitHub at like in Argus Labs Dark Frontier, and then you can see how dark frontier ridden how it works. And even you can play around with it locally too, and like play with your friends, et cetera, et cetera. The next game that we've seen built on the world engine that is, I think is really interesting also. It's a very simple game, is like a game called a guard shooter. So a guard shooter is a high throughput real time IO game inspired by a gar IO and vampire survivor.
00:21:51.348 - 00:22:31.046, Speaker A: So if you've played like Agar IO before, you know, like, you're probably just like from the skiing, the screen already knows like how the game works. But a guard shooter is really exciting because it's like one of the most performance intensive games that we thought was, wasn't even possible to build fully on chains. Like, you know, we tried building this on a normal EVM rollup. It wasn't even close to being playable. It was horrible. But now, because we have a real engine, you can have a real time IO game, like a car shooter and make it basically practically indistinguishable from modern IO games, like a gar IO. And again, each player in this game creates 20 transactions per second.
00:22:31.046 - 00:22:57.504, Speaker A: So this is not an aggregate transaction. This is for a single player. And so that is a lot of transactions that we have to be processing when running the game. And the world engine handles that seamlessly. Again, full free abstraction, same as dark frontier. And for this one, it has an even lower block time. It has sub 100 millisecond log time that makes sure that all those real time movements are able to be computed seamlessly.
00:22:57.504 - 00:23:33.672, Speaker A: The guard shooter is going to be relaunching soon, so if you're interested, make sure to keep an eye out and follow us. Follow Argus like Twitter for more announcement than details. But yeah, I've been talking for the past 30 minutes here. We're exactly at the mid time mark. Now I'm going to go switch over to my dev setup so we can go straight ahead and play around with world engine to get things started. What you want to make do is to install the world engine CLI. We have a quick start document if you want to follow along.
00:23:33.672 - 00:24:33.628, Speaker A: What you can do here is to go to our website, world quickstart. And then there you can basically, then there you can basically just see all these transactions, all these setup instructions, and from there you can just start, you just start installing this. There are some dependencies that you need to install, but once that is installed, you can immediately start running these commands and playing around with it. But I already have my local dev set up here. We'll just start from there. After you have all these things installed, what you need to do is to just make sure that you run the command world and then you can see all these commands running. And so the first command that you'll be running is called world create.
00:24:33.628 - 00:25:06.964, Speaker A: And here you can basically start filling in the game shark name and what you can just call your name, let's say startgame two. And then all of that will do to set up code for you so that you're ready to play the game or start building your game. Sorry. And after that you can go to those directories for a game two. And all of your game code will be located in this directory. So now I already have a previous one that I already created. So it's already open with my jetbrains.
00:25:06.964 - 00:25:53.714, Speaker A: So we're going to use this ide called Golan to just really start building the game. So first and foremost, what you want to do is make sure that you have, make sure that you have, sorry, make sure that you have the, sorry, my brain is just on brain dead right now. But yeah, make sure that you're able to run world Cardinal Dev inside the world engine star game directory. And so this will load up all your game using Docker and et cetera. And once you see it kickstarted, you can open up what we call the cardinal editor. So the cardinal editor makes it easier for you to be able to see what's happening on your game. And so I'll move this window quickly here so you can see it.
00:25:53.714 - 00:26:25.824, Speaker A: Let's see. Kind of like, okay, I'm going to try to open this in new window and see if this works. All right. Yeah, there we go. So yeah, now that we have this running, what we want to do here is first create a Persona. So Persona is what it can to be like a gamer account or any play like in Xbox. You have this idea of Gamertag.
00:26:25.824 - 00:27:00.994, Speaker A: So here you can just do something like comage and then it will automatically create a player in the background. And as you can see here, the moment that you create it, you can see all what is the state data that is happening within Cardinal gameshark. So you can see here that you have this Persona attack named Colemich. It has your signer address and so on and so forth. Then you can create a player within the game, which is again following a sample game that we've written here. So you click colemage and then let's say you want to find a different name, let's say a nickname. I was just like, for now, just keep it a school mage.
00:27:00.994 - 00:27:36.940, Speaker A: Now you have these entities that has a health and player component which we'll look into later. I just want to give a quick demonstration here. But once that is there, what you can do here is you can see that the HP, without even me doing anything, you can see that the HP of the player is increasing. So this is kind of like what we like. We have like a regeneration system that gives the player HP at every tick. And these players are basically gaining HP at every second. And we're not making any transactions here, we're just letting the player be and letting the game loops.
00:27:36.940 - 00:28:22.182, Speaker A: The loop run time increments, the player held one by one at each stick. And so that is basically kind of like how the world engine loop runtime in action, as you see. And again, if you want to play around later, here you have the CQL and the player held queries that you can use to get more data from the game that you otherwise you couldn't see from this screen. But yeah, now that we have seen the cardinal netter and we'll kind of be able to play around with it more later, I want to just walk you through in terms of how the code is written. And so the first and foremost here is that you have this cardinal folder. I don't know if you guys can see it. I'll probably try to zoom my screen here a little to make sure that it's big enough.
00:28:22.182 - 00:28:48.192, Speaker A: But yeah, in the sidebar you can see that we have a cardinal folder. There already has four subfolders from component, message, query and system. The most important file here I want to draw yourself, draw your attention to is called the main go file. So this is going to be your entry point for your program. This is all where your components, messages and queries are going to be registered. The components represent your game state data. This is where all of your game data is going to be stored.
00:28:48.192 - 00:29:17.440, Speaker A: So this is one of the most important pieces that you'll be seeing how to implement in just a bit. After that there are messages. Messages represents the user actions really, if you want to. Let's say, allow the player to attack another player in this scenario, or you want to create a player message. I've shown you before, you need to register. You register that as a message and then you'll be able to use that in the car and editor and also from your game engines, et cetera, et cetera, et cetera. Register, query.
00:29:17.440 - 00:30:25.210, Speaker A: Allow you to access game state data and the systems, which again is really kind of where the core logic of your game goes, is a function that gets executed at every tick. And so you can implement any arbitrary functions as you want. As you see in this case, you can have the regen system that regenerates the player's HP at every second, or you can have the player spawner that creates the player when it receives a create player message of transaction. You create an attack system that applies damage to player when the attack player message is created. With that you can get a lot of things done with just this very simple code that otherwise would have been thousands of lines or hundreds, hundreds or tens of thousands of lines of code if you were to build it from scratch. We provide a lot of abstraction and heavy lifting to make it easy for you to implement your game logic. Now that you've seen a brief overview of the structure of the world engine, we can dive right in to each individual pillars of the game engine implementation.
00:30:25.210 - 00:30:55.984, Speaker A: The first one is the components. The components are very simpler. It's really just out of struct definition where you define your data that you want to store using these normal go data types. You give it a name and that's basically it. It took you less than 1 minute to really just write this components. You could write this for component for different players. And let's say in this scenario you have a player have a nickname, as you can see in the editor.
00:30:55.984 - 00:31:27.994, Speaker A: Before, after define those components, you can define the messages. Again, messages, all of these are very simple. It's all just normal structs. You pass it like this is the message, the inputs, what are the parameters or the body or the content of the message that you want the player to submit. And then this basically provides the receipts or the result of the messages. Same thing goes here for player. All just struct definitions for the query.
00:31:27.994 - 00:32:37.164, Speaker A: It's similar to the system functions. It's really defined as this function that takes in a request and returns a response, and within it you are able to execute search queries within the garden game State and return a result accordingly. In this scenario, we are searching for the player health data. We can call cardinal new search and then filter based on player components, player components and health components, and then for each of those player and health component, it adds iterates to them. And if the nickname target of the player health request is defined here, matches the current player health, the current player entities nickname or player component nickname, you return those informations and you terminate the loop. And now if player doesn't exist, it will simply terminate and return with an error. All of these functions is basically just writing your normal go code.
00:32:37.164 - 00:33:28.164, Speaker A: You can just treat this search almost like an SQL query where we do the heavy lifting of querying those data in the background using the kernel framework, and you're simply just needing to filter it based on components and your custom filtering logic or iteration logic using the kernel framework. The same goes with the system. Again, the systems, as you've seen before, has the abilities to iterate through messages. There are systems like attack system that depends on, let's say a certain user input. This is somewhat akin to the event driven runtime I've talked to you before. You can iterate and in this scenario apply damages. If you have an attack player message, you get the target player information and apply damage to it and updates the data using component.
00:33:28.164 - 00:34:04.584, Speaker A: And then yeah, that's pretty much it for tax system. And then there are really interesting systems I mentioned before that doesn't depend on these user transactions. Even without user inputs, you want to have this ticking in the background. So we've seen people implement things like a gravity system or physics system as a system within cardinal that happens and continues to take in a background. And, and this simple example, we're incrementing the health of the player, just kind of regenerating them like healing essentially. Right. And again get component, subcontract component and that's it.
00:34:04.584 - 00:34:52.324, Speaker A: That's pretty much as straightforward as it gets. Again, also using the new search method that we've seen here and yeah, that's pretty much it. And again here you can see you have your utils and just these are helper functions really just kind of like syntactic sugar to make the code more clean. But that's really all there is to this. And you can see how the entire game is implemented under 1000 lines of code. Adding all of this are definitely less than 500 lines of code and took me less than 30 minutes to write. There are really interesting things that you're able to do with the cardinal framework and it, it's going to take me many, many hours to really go through it all by one by one.
00:34:52.324 - 00:35:39.546, Speaker A: Really give you a good idea of where to look, I'll pull up the dock site again. Let's see. Make sure I can switch to the screen. Now if you're in the doc site, you can just really go to this introduction section again. The quick start is here if you want to find the installation guide and whatsoever. Once you're there, you can check out in the Cardinal gameshark tab about all the information that you want to find about the world Engine Gameshark implementation. You can learn about how you can write and register your components here, understand what the component is and how it works, how to implement systems, how to create a remove entities, how to get instead of remove components.
00:35:39.546 - 00:36:37.644, Speaker A: All of these are documented in our documentation such that you can play around with it directly and just copy and paste the code so you don't have to guess around. And again, things, event and messages, queries and so on and so forth. Another cool thing that I want to highlight is we have something called the Cardinal query language. I know we didn't get the chance to really cover this, but Cardinal query language allows you to query the game state data in kernel using a query that is somewhat similar to SQL. So if you're familiar with SQL then you can use CQL as well to basically get arbitrary component data. It supports all these logical operators so you can access those informations easily. After there, you can learn more about how you can interoperate and build smart contracts that interoperate between the EVM and the game shard.
00:36:37.644 - 00:37:21.006, Speaker A: So we have these lists of supported types. So as long as your messages and queries support the supported types, then it will be able to work and compose with UEM. And we're continuing to extend the number of support types, but this generally covers the majority of use cases that you need for the Persona. As I mentioned before, it's really kind of how we represent game accounts. Notice that we want to make sure that we have a seamless user experience, so we use the Persona system to really provide a way and are easier to understand concept of a wallet or account in the blockchain. Instead of having these weird long addresses that are zero x addresses. Few Persona tags are human readable, so it's normal username.
00:37:21.006 - 00:38:28.334, Speaker A: And then on top of that we have a native account abstraction system that allows you to authorize multiple Ethereum accounts to control the same Persona. This allows you to share your game accounts to your friends or buddies or brother what have you, without having to give them your private keys, which currently you're not able to do seamlessly. If you're just using a regular EVM roll up again. Also have rest API documents here if you want to play around with it directly. But for most people, if you want to integrate, let's say, your game implementation, the world engine game implementation with a game engine of your choice, we have SDKs build out to make all that easy for you. So in general, if you want to, let's say, use things like unity, Unreal, godo and whatsoever you can use, our Nacama SDK and Nakama SDK allows you to integrate with all of the major game engines. This is how we are able to build dark frontier on Unity instead of JavaScript and all of that by using our Nacama SDK and communicating through that SDK client.
00:38:28.334 - 00:39:31.090, Speaker A: And so yeah, and then you have all these documentations that you can check out if you want to install your kind of client libraries and then you can find all these client libraries documentation for unity, Unreal, do JavaScript and so on and so forth in kind of like the Nacama official documentation. So if you click this, you'll kind of like find different like support for many different game engines that you can try out. But like, yeah, that's like pretty much it. Like, that covers the entire gamut of the world engine stack. I know, like we were not able to really get into super nitty gritty. So if you have any specific questions or if you're interested in building on top of the world engine and you're still not sure about how to get started or you're facing some challenges with any part of the development lifecycle, feel free to reach out. To me, my Twitter is SM scenario and yeah, I'm super excited to be able to working with all of you guys and, and like, yeah, I'll be staying around in the Discord channel for next few hours as well.
00:39:31.090 - 00:39:49.814, Speaker A: So if you have any kind of like, you know, like last minute questions that you want to ask me or you would just want to hop on a quick call to kind of jam on the kind of like your hackathon ideas, I'm happy to be off like a service and like, yeah, I think that's pretty much it. And like, I'm happy to kind of like wrap up here. Maybe if you have some time for questions, I'm happy to answer live questions as well.
00:39:50.794 - 00:40:17.054, Speaker B: Yeah, we actually do have a question, a few questions. Thank you again, Scott, for giving us all the information about world engine and Argus. I think. Yeah, we'll just, I'm going to read it from the YouTube stream. We have a question. Taking the example of runescape. How would you think about building private worlds? Only members who have access should be able to view the world, the members and all activities.
00:40:17.514 - 00:41:07.390, Speaker A: Yeah. So I think it depends on like how you want, how private you want it to be, right. So if you only want to, let's say private in the sense that, oh, only certain player can go to that and like access those worlds, you can easily implement that as a part of the system, right. So you can check whether or not a person is an officer in Persona tag. And if you're not like that, like, you know, their Persona attack is not from this list of kind of like, you know, people, then you're not going to be able to access those kind of like access those worlds. Right. However, if you are trying to have it to be very, very secure, that is, it has full privacy and people are not able to even read the chain data of what is inside those worlds and who are authorized to even go to those roles, then what you can do is use ZK to have these hidden information states.
00:41:07.390 - 00:41:34.894, Speaker A: You're going to use things like te or whatever, privacy preserving primitives to build games that have these hidden states while being on chain. But yeah, I think that's a great question. I'm happy to jam on it more. But yeah, in general, you can have these permission access control for different parts of the game by checking the username Persona tag of the player and just granting access based on that.
00:41:36.714 - 00:41:51.452, Speaker B: Thank you. Then another one that is specific to your demo that you were doing. The question is, I have no idea how all this works, but why do you have to go through every player each time? What if there were a lot of players? How do you do it?
00:41:51.508 - 00:42:27.034, Speaker A: Justin. So that's a great question too. One of the things that like, one of the optimizations that you're able to do is through caching so, or like, sorry, not caching so indexing. So you can create a map of like, you know, the list of players. So if you have a lot of players, then you can basically just like, hey, like, you know, like, you know, I like, you know, here is the user string, or like say like their nickname or their Persona tag. Here is their corresponding entity id for the player. And then based on that you can do o one lookup of our constant time lookup on these player entity ids.
00:42:27.034 - 00:43:14.474, Speaker A: But for those example, we're trying to demonstrate how you can iterate to a list of players using a search. And so that's why we're iterating to the forlorn. But one thing to also highlight here the reason why we're able to get away from that, like get away from writing inefficient code is because cardinal and go extremely fast. So even if your code is unoptimized, you will still have amazing performances. You still will be able to have all of those basically high pick rate, et cetera, by the virtue of the perform and execution. But of course, as your game grows more complex and you're starting to think more about optimization, you're able to use features like indexing or these mappings to make sure that you have faster lookups on your players. But yeah, that's a great, great question.
00:43:14.474 - 00:44:08.654, Speaker A: And then I think it just comes down to really how optimized you want to write your game code. If you were just trying to prototype and quickly and just have a clean code, you don't really have to worry about all of that. But yeah, the most simple example is to just iterate through the list. And that's because the data oriented, data oriented data locality design that we have with the cardinal implementation, iterating through these for loops that are extremely fast because it's just iterating from an array basically, instead of having to have multiple reads. But that is very technical implementation details if you're interested on that, how we have a separate conversation. But yeah, DLR. If you want to have better performance optimization, you can use indexing to be able to have faster lookups for player Persona to id mapping.
00:44:08.654 - 00:44:09.514, Speaker A: Essentially.
00:44:09.894 - 00:44:14.686, Speaker B: Awesome. Thank you. And then one. On a lighter note, what is your favorite game?
00:44:14.870 - 00:44:49.724, Speaker A: What is my favorite game? That's a hard one, I would say. I play a lot of strategy games, so I really like games like Stellaris and civilization. So that's really when designing games and building games, I do take a lot of inspiration from that. But yeah, again, if you are working in games like me, it's really impossible. Really kind of stick and play with only one game. You really have to play a lot of games so that you can draw inspiration from many different places. So I've been playing a lot with a lot of mobile games recently because I think that's kind of like a category of games that I just haven't spent as much time on.
00:44:49.724 - 00:45:06.324, Speaker A: But yeah, I think in general, if I have to choose one game that I have to play the rest of my life, it's probably going to be something like Solaris or like, or like, you know, or like civilization and like, and like there are multiplayer like version of these games as well that I think is really cool. And like, I really enjoy playing as well.
00:45:08.464 - 00:45:24.864, Speaker B: Yeah, I had some questions I wrote down while you were going through that. And I'm curious, on the front of, like, traditional gaming and maybe like web, two games, how many events per second or like, transactions per second, do a lot of those have coming in?
00:45:25.364 - 00:46:23.210, Speaker A: Yeah, so that's a very good question. And I think the answer here is really depends on a game, right? So, like, games like, let's say, like Hearthstone, like, our, like, turn based card game is going to have a much lower events or like, messages per second in contrast to, let's say, a game like Counter strike, right, where it's like literally every single bullet that you fire is like a message on a game server. And so, like, you know, those are going to be very sharply different from each game for, from one another. So it's really hard to kind of really give you, like, a one answer for this, but it's really easy to kind of, like, do the math for it, right. So what you want to do is, like, first and foremost, like, you know, like what we did for a guard shooter is to understand, like, how many actions at the maximum that a player could be making or how many messages per second could a player be making. And so, like, for a guard shooter, that was number was like around like, basically 20 messages per second. That is the upper limit of how many messages you're going to make.
00:46:23.210 - 00:47:13.244, Speaker A: Or that's basically around the average of how many messages you're going to be able to make per second in the game. And so you can multiply that number by your estimate of the user count for that game. And that's how you're able to get the current, basically, message per second or transaction per second off that game. For major games, let's say, let's say Hearthstone. I'll give you an example. Um, turn based games are typically, like, really, really slow, right? They're like, um, like, you know, again, like, I don't know, I would say, like maybe like one, like one transaction per second at the maximum for each player. And then you have, like, you know, like, basically, let's say, like, Hearthstone has like 100,000 or like, you know, like 500,000, like, you know, like, you know, daily active user and et cetera, or concurrent user.
00:47:13.244 - 00:48:00.362, Speaker A: That's going to be 100,000 to 500,000 of, like, you know, transaction per second, right. Even for a very small game like a Hearthstone, that is a lot of transaction per second. So it's impossible that you're going to be able to do this with a single roll up, you're never going to be able to do that. If you want to achieve that scale, horizontal scalability is the only way that you're going to be able to really achieve that. Even with parallelization of the AVM and whatsoever, you're really never going to reach 500,000 transactions per second. Those are really the areas where you just need like, you know, like these like horizontally scaling strategies. And that's like more of a problem for consumer applications because again, with Defi, people are not making a lot of like, you know, like, like, you know, like one transaction per second with like when you're using Dexs, right.
00:48:00.362 - 00:48:45.574, Speaker A: But where they're playing a game, like, they don't even realize that they're interacting with the server a lot. And that's like what we need to make sure that like, you know, we are able to process like seamlessly and like, yeah, so, like, if Heartstone, which is a very small, like in a game, is 100,000 to 500,000 transactions per second with like those numbers of players, just imagine how many messages or transactions per second counter strike is. Or like how many transactions per second, like Valorant is right. And so that's like why horizontal scaling is important because like fundamentally, if you're building consumer applications, real time consumer applications at those scale, you will not be able to like kind of scale using a single machine. And so that's why we focus on the world engine horizontal scaling a lot.
00:48:47.434 - 00:48:49.074, Speaker B: Thank you again for the answers.
00:48:49.234 - 00:48:49.974, Speaker A: Cool.
00:48:50.394 - 00:49:14.424, Speaker B: That's all I had. Now it looks like we don't have any other ones in the chat. So yeah, I'll give it another last call for questions for Scott. And I guess there's a kind of question coming off of the last discussion. So the game devs host the servers.
00:49:16.244 - 00:49:59.746, Speaker A: So, yeah, so that's a very great question. So for rollups, like for the roll ups, you can host it yourself, but we also have partners that allows you to host their roll ups for you. So these are rasp providers who might have seen the other workshops or talks. These are the people that will help you run and operate your roll ups, including your game shards. So if you are interested in that, feel free to reach out to me. I'm happy to make introductions to companies and teams or even give you support to host it yourselves in your own cloud servers and just basically start from there. But again, the easiest solution if you don't want to manage your own roll ups is to use a roll up service provider.
00:49:59.746 - 00:50:01.974, Speaker A: And we're happy to make introductions there too.
00:50:02.364 - 00:50:16.748, Speaker B: Awesome. Yeah. And as you mentioned, I think the best way to reach out is either on Twitter or directly on discord. So. Yeah. If you have any questions for Scott, please reach out. And thank you again, Scott, for teaching us about world engine.
00:50:16.748 - 00:50:17.244, Speaker B: Awesome.
00:50:17.284 - 00:50:19.024, Speaker A: Cool. All right, thank you. See ya.
00:50:19.604 - 00:50:20.764, Speaker B: See everybody. Bye.
