00:00:01.360 - 00:00:07.334, Speaker A: I'm here with Karel Kubat, founder and CEO of Union. Welcome to Sovereign Radio.
00:00:07.462 - 00:00:09.278, Speaker B: Yeah, thank you so much for having me.
00:00:09.454 - 00:00:14.130, Speaker A: I want to start us off with understanding the problem that you're trying to solve with union.
00:00:14.430 - 00:00:48.770, Speaker B: Yeah. So really what we observed as builders in union is that any engineer wants to build their own l one or their own roll up, because it provides you much better control of your product, just a much more cohesive experience for the end user. And overall, it gives you an edge over your competitors. The problem that we observed is it's an insanely high barrier to entry, to doing so, really. Only hyper liquid DyDX managed to do so. And the reason for that is that it's actually really hard to get access to interoperability. Moving away from Solana or Ethereum to your own state machine is actually a very hard transition.
00:00:48.850 - 00:01:04.532, Speaker A: What would you say, though, if you're imagining all of these different folks running their, their own roll ups or running these l one s? Do you actually imagine then tokens and actually messages constantly being passed between them?
00:01:04.716 - 00:01:20.012, Speaker B: Yeah, almost like a mesh of microservices communicating like that to each other. And this is a world where block times are sub second for each of these roll ups, where these messages are passed within a second as well. So almost like web two trad five, which users are used to as well.
00:01:20.076 - 00:01:27.758, Speaker A: So, I mean, there are, I guess, should we place union in the bridging category? Is that what you call what you do?
00:01:27.854 - 00:01:31.430, Speaker B: I would say so, but more focused on the message passing and the security.
00:01:31.510 - 00:01:32.766, Speaker A: Side of it, not tokens.
00:01:32.878 - 00:01:38.422, Speaker B: So we do tokens as well because we support the IBC protocol, but the team score focus really is message passing.
00:01:38.486 - 00:01:47.310, Speaker A: What would that actually mean for a user? So if your messages are going between them, if you're less focused on tokens, what is actually happening?
00:01:47.430 - 00:02:08.810, Speaker B: So basically, any interaction a user has right now with the blockchain is a message submitting a transaction to a mempool is a message submitting a transaction to a mempool to then do a bridge operation to buy tokens on a chain and send them back is two messages. So actually, most of the traffic that we observe right now on chains are messages being sent around. Tokens are just a specialization of that, to be honest.
00:02:08.890 - 00:02:19.712, Speaker A: But when it comes to a cross chain ecosystem, then is it like your application could actually be interacting with all of these different chains at the same time? You wouldn't even notice as a user.
00:02:19.906 - 00:02:33.040, Speaker B: That's the end objective, right? You interact with a certain app, and that app might depend on other apps, right. Uses some type of DAX for settlements, share security with some other chains, but in the end, you want the end users just to know the app that they're using.
00:02:33.460 - 00:02:37.840, Speaker A: But do you think, like you sort of said, that's the end game, but where are we today?
00:02:38.220 - 00:03:13.422, Speaker B: So for us, the way we wanted to solve this issue is basically start with completely removing the barrier to entry to get access to interoper. If you want to solve that, that means that getting bridge support can't be a web two bd game where you need to have enough traction to then get support by one of the major players, but where you basically, in one or 2 hours can do the integration yourself the same way you're integrating uniswap pool. And if you're doing that, then you have to rethink the security model because if you allow other teams to integrate themselves, you can no longer rely on them being honest participants. So you have to solve some very fundamental issues to build such a system.
00:03:13.566 - 00:03:17.926, Speaker A: Where does union actually live? Is it a standalone l one of its own?
00:03:17.998 - 00:03:25.822, Speaker B: Yeah. So it's a standalone l one that we use as the bridgehub, as the IBC routing hub, and then we connect that over IBC to many different chains.
00:03:25.926 - 00:03:42.446, Speaker A: Okay, so, I mean, this makes me really want to know what the difference is between this and some other bridging projects or like, yeah, message passing projects. Like, I mean, this makes me think if you're an l one, like, are you like Axelar or are you anything like hyperlane? When you talk about all these different.
00:03:42.478 - 00:04:19.674, Speaker B: Ecosystems, I would almost say that's the best of both worlds. So, a fundamental issue with XLR is for each new network they support, their validators need to run full nodes for that network. So you can kind of do the math. Right now I think there are 75 validators and about 80 networks supported. So this system costs a lot of physical infra quite quickly on, and that makes it not really scalable to thousands of roll ups. In Hyperlane's case, it's almost like an open source SDK that you can use to build your own bridge. And so you can connect to one other chain if you want to do that, and you can do that fully permissionlessly, but you don't then inherit all the connections that that chain then has going forward.
00:04:19.674 - 00:04:24.866, Speaker B: So you don't have an ultra wide bridging network. You open individual connections over and over.
00:04:24.978 - 00:04:31.730, Speaker A: So, okay, so each, would this be like an application doing that? Would an application decide which routes or who's doing that?
00:04:31.810 - 00:05:02.246, Speaker B: It's normally the developers that do this, so they use hyperlinks SDKs to basically create their own bridge. They can then use transport layer wormhole, for example, or run their own multisig based bridge and then set up their own bridging network that is very permissionless. So it works well with scaling. But to us that seems super optimal because it ends in a world where a lot of teams are going to run their own multisig bridges. And we saw this happening kind of in the previous wool market at the start when everyone did an old l one, ran their own bridge, and that's just very prone to hacks.
00:05:02.318 - 00:05:08.966, Speaker A: I want to kind of revisit the what you are doing that's different because now that you've explained sort of how their systems work, I want to compare that.
00:05:09.118 - 00:05:57.842, Speaker B: In the case of union, it is a chain, but to open a connection to union, the union validators do not need to run any extra full nodes whatsoever. Instead, a lite client smart contract is deployed union scales much better with the number of chains connected because in this case, all you need to do is have one party generate a ZKP to forward the state of this lite clients. This scales to thousands, even tens of thousands of bridge connections. The other bonus for this is that the union chain acts as checks and balances. So a developer can actually spin up a roll up on their laptop and connect to a union testnet right now, open a connection, receive funds without actually ever needing to talk with our team and be able to take that roll up down as well later on. So there's no like social consensus going on whatsoever. It's all programmatic.
00:05:57.946 - 00:06:09.286, Speaker A: You just mentioned lite clients and like, I'm not clear on where the lite client is. Is it on your side? Are you deploying on union, a lite client of the other chain? Or do they have have to deploy a, like, client of yours?
00:06:09.318 - 00:06:15.406, Speaker B: It's always on both sides. So the chain connected to union checks union and union checks the chain connected to it.
00:06:15.518 - 00:06:33.902, Speaker A: How then are like, if there's these like connections to this l one, like where are things going inside? How do things actually happen within the system? How do you move? You know, you're talking about one chain where they do kind of this like client swap, and then there's another chain with a lite client swap. Are you then a routing l one? Is that where you are?
00:06:33.966 - 00:06:58.002, Speaker B: Almost the best way to envision this is that union is like this big heartbeat that resonates every 3 seconds. Many proofs from different chains go in there and then one single proof from union goes out everywhere else. And so for each chain that's connected to union, they contain the union block header, but through the union block header, also the block header of each connected chain. And that's really that security backbone, the basis for them building message passing and token transfers.
00:06:58.066 - 00:07:13.430, Speaker A: Isn't that then a lot like you're getting every single and you're saying it's very open. So like anyone who creates one of these, there could be thousands of them happening. Doesn't that make the block header then like just basically whatever the information it's passing on doesn't make it too big.
00:07:13.510 - 00:07:35.170, Speaker B: So that's actually where you apply some zero knowledge cryptography techniques. In our case, it doesn't matter if we connect to a chain with ten validators or 1000 validators. And the same goes for that block header. It isn't crow in size. Instead what you use for the message passing is storage proofs. You just need that single block header with a single storage root hash and then you can build out everything else from there.
00:07:35.630 - 00:07:40.210, Speaker A: I think you just mentioned 1000 validators, but I'm talking more about 1000 connections.
00:07:40.590 - 00:07:58.374, Speaker B: That's all the same tooling. In the end, each CKP that we verify I think takes the network maybe like sub milliseconds. Basically within the three second span you have a lot of time to verify many different ckps. So you can handle up to a couple of thousand connections this way without needing significant infrastructure.
00:07:58.462 - 00:08:19.840, Speaker A: I still don't get it though. If you're trying to pass a message, you've rolled it all. I understand you've batched up all of the information into a ZKP I guess. But then there's another like client, like remember you're trying to get to that other chain. How did they actually decipher where it comes from? Like which.
00:08:19.920 - 00:08:54.404, Speaker B: Yeah, yeah, no, exactly. So on that other chain there is a contract that has the union live clients and the most recent blockader. And that contract is able to parse storage proofs that anyone can provide. And these storage proofs through the liteline code, through all of these block headers, point to this other chain, to data that is stored over there. So when someone wants to send a message from sepolia, they basically store that message. In a smart contract this whole updating process happens. And on bearer chain someone provides a storage proof stating on sepolia this message is stored in this contract.
00:08:54.404 - 00:09:05.804, Speaker B: And that can be someone has locked up ten ERC 20 tokens and wants to send it to Baruchain. And in this case, the barachain contact will then mint tokens, or it can be some other type of message that has a destination.
00:09:05.972 - 00:09:08.620, Speaker A: Where are the storage proofs? Are they on your chain?
00:09:08.780 - 00:09:36.432, Speaker B: No. So the storage proofs, they actually provided on the destination chains. So the destination chain needs to have the consensus proof for the security portion of it. But the consensus proof, that's what updates the lite client is basically very lightweight. It just tells the chain sepolia had block Hash XYZ on height one and ABC on height two. And that's all that the consensus proved us. Now for this new block, there might be 100 users wanting to submit transactions.
00:09:36.432 - 00:09:44.912, Speaker B: So a relayer that observes this off chain starts generating these storage proofs and providing them to barrel chain to trigger each of these transfers one by one.
00:09:45.016 - 00:10:02.280, Speaker A: Personally, I don't fully understand that yet. I have to be honest. To me, I still don't understand how on Barachain, like in your example of sepolia to Barachain, how Barachain is getting a message, how does the message be uncovered? I'm assuming it's a specific message.
00:10:02.440 - 00:10:03.140, Speaker B: Yeah.
00:10:03.800 - 00:10:06.220, Speaker A: How does it know what that message actually is?
00:10:06.720 - 00:10:41.710, Speaker B: For that, you do need a specific contract. On version. Someone will store a message on Sopolia, which just bytes, and with that, it'll store the destination contract and the destination chain. So it'll say contract one on bearer chain will be able to know what to do with these bytes. And then the whole union system takes care of getting that message over there, and then calls the contract to get those bytes. And those bytes can be a payload that does a transfer or something that does a swap, can be anything that that contract is able to interpret. And that's kind of what we actually expect our like third party developers to interact most with to write these types of contracts.
00:10:41.790 - 00:10:51.586, Speaker A: I'm assuming like, because you're not creating this in the first place, like some other app developer is building that connection between those two things. Right? Like you're saying, like they're deploying a light client.
00:10:51.698 - 00:10:55.466, Speaker B: No, no, no. So we actually deploy live clients from almost all major ecosystems.
00:10:55.498 - 00:11:16.362, Speaker A: Oh, you do do that first step. Okay, but then let's go to what the app developer is actually doing. So the app developer is interacting on sepulia through smart contract has some special codes in what they're writing, I guess to interface with union. Like that's included in the like client. And then are they writing like, yeah, maybe you can walk me through developer.
00:11:16.386 - 00:11:41.798, Speaker B: To be honest, it looks like a very, like gateway contract, very similar to what you do. If you were interacting with hyperlink or layer zero, you basically register your contracts to receive messages or tokens and to be called for that. Specify how much gas you're willing to spend for certain operations. And that's really it. So from the outside, if you're just using union, it's very similar to other bridges. The security model under the hood is completely different. So very much like an EV and a vanilla car, and then you're still going to be driving around with them.
00:11:41.798 - 00:11:52.750, Speaker B: It's just the engine that's very different now for developers as well. If they're building their own chain or their own stack in Foo, then they deploy the lifetime themselves and they use one of our SDKs to pre deploy this.
00:11:53.410 - 00:12:09.386, Speaker A: Is it similar? I know that in reading up on this, there's a strong connection to IBC. Is this IBC? Have you incorporated IBC then into other networks that weren't IBC enabled? Or is it similar? How do you connect with that?
00:12:09.418 - 00:12:35.926, Speaker B: Yeah, basically our approach was to be a really good way to do these consensus proofs and storage proofs, and then we had to decide, are we going to do our own protocol on top of this and have a new competing standard, or are we going to go with a protocol that we think is very well designed and could perhaps be that open source, native common good protocol? We decided to be fully IBC compatible, which means that SCIP protocol or any cosmos change is natively compatible with union as well.
00:12:36.118 - 00:12:47.386, Speaker A: I'm assuming then if you're IBC compatible, you're compatible with all of the chains that are IBC native. But are you using IBC elsewhere? Like, are you actually bringing it to other ecosystems?
00:12:47.418 - 00:12:57.746, Speaker B: Yeah, yeah, yeah. So with our contract sets on Ethereum, for example, Ethereum is fully IBC compatible. So someone could use that as well to basically just do their own direct connection to Ethereum if they wanted to.
00:12:57.818 - 00:13:08.968, Speaker A: Huh. There is another bridging system that we haven't mentioned yet, which is like across. Do you put yourselves more in that category? Or, you know, we kind of already covered how they compare to hyperlane and to xlrtaine.
00:13:09.014 - 00:13:54.656, Speaker B: Yeah. So there's two mainstreams in bridging infrastructure, and one is that you try to get as much security and correctness on chain and the other one is basically that you don't do any of that at all and you just trust market makers off chain to fill users orders across is the second type of solution where you take on a brief risk as an end user, but at scale, this is relatively secure and an upside is that the system is quite easy to implement and can be very fast. The downside is these types of systems, they're not really that decentralized. It's almost as if you're routing through a centralized exchange to do your bridging. And they require a lot of liquidity. They require market makers to have stock on every single chain available. And to be honest, for me, foremost of all, they don't really allow general message passing to work.
00:13:54.656 - 00:14:05.440, Speaker B: And so union is more on the trustless category here. But you can actually do intent based bridging on top of union and using union to pay back market makers and liquidity providers.
00:14:05.520 - 00:14:16.192, Speaker A: So intents is something that we hear a lot about in the ecosystem, but I think it makes sense to define it here. And, yeah, like when, like how would an intent flow across union?
00:14:16.336 - 00:15:14.684, Speaker B: So for me, this definition of intent is basically a user just stating I want to end up at this location with these assets. I don't care if someone forms a swap or just gives it to me as long as I end up in this final state. Now, how most protocols do this is they allow any market maker to get the user to this end state and then they use an oracle to verify that the user really did receive the first. The downside is you both rely on market makers and on Oracle, and especially the Oracle case can be quite slow while you're waiting for that response. How union can play in on this is that you can actually use union to verify that the user received their funds and quite fast at the same time that it would take union to do these live plans updates. So you then kind of get the best of both worlds where you can get a user their funds really quickly on destination site, basically within a second, and you can actually repay the market maker within 30 seconds. And that way you get a system where even for market makers, you don't need to wait a week or more to get their funds back.
00:15:14.684 - 00:15:17.636, Speaker B: And for users it really seems like it's instantaneous.
00:15:17.748 - 00:15:25.480, Speaker A: How is it unlocking? Is it because something's locked on each one of these chains? Is the market maker pool? Like putting funds into a pool or something?
00:15:25.900 - 00:15:42.924, Speaker B: Yeah, the market maker happens to have funds on one of these chains. The user locks their funds on the origin chain. Market maker gives the funds on the destination. But now you have this communication problem. When are you going to release the funds on the origin chain back to the market maker? Right. And for that you kind of need a secure communication channel.
00:15:43.092 - 00:15:50.720, Speaker A: The team that's often known for intents is like anoma the Anoma team, are you in any way in the similar space to what they're doing?
00:15:51.860 - 00:16:14.842, Speaker B: Not really. The gnome, I would say, is a different interpretation of intents, where it's more like a single chain, where instead of submitting transactions that specify what the transaction does, you just submit what you want to happen. And then the nomadchain starts computing what to do to reach that end destination. For us, it's really more about the order flow and the flow of transactions across chains.
00:16:15.036 - 00:16:27.110, Speaker A: So it's not like hops, it's not like the intents that you're describing. It's not like there's multiple different trades happening, and then you end up with what you need. In this case, it's like, I want this on one chain, unlock on the other.
00:16:27.230 - 00:16:35.390, Speaker B: Yeah. Because especially for an end user, you normally wouldn't really care about this intermediate trade. You just want to end up in your final destination with $500.
00:16:35.470 - 00:16:45.728, Speaker A: Okay, what ecosystem do you put union in? Is this a Cosmos project? Is this a interchain project? Is this a modular stack project? What is it?
00:16:45.784 - 00:17:12.094, Speaker B: Yeah, I would say more modular stack projects. We do use the Cosmos SDK and a lot of the kind of philosophy from Cosmos, because I think, in the end, modular and horizontal scalability is, of course, invented almost by the cosmos ecosystem. For us right now, actually, our main focus is EVM ecosystem and EVM rollups. So right now we support Barachain, Ethereum, arbiter, and with base and linear coming.
00:17:12.142 - 00:17:24.606, Speaker A: Online very soon, what's the future of the project then? These are sort of the different networks that you're already interfacing with. But will you also go, like, off the EVM type things? Will you start looking at, I don't know, other vms?
00:17:24.798 - 00:17:30.518, Speaker B: Yeah, I think our next big objective is going to be the move language and supporting movement. Labs launch.
00:17:30.614 - 00:17:32.930, Speaker A: I thought you were going to say Solana, but okay.
00:17:33.910 - 00:17:46.020, Speaker B: I mean, everyone has to acknowledge Solana and do it at some point, but Solana, from a consensus perspective, is actually very hard to operate with. I see they've tried to get as much TPS as they could, and they kind of dropped security a little bit because of that.
00:17:46.140 - 00:17:48.572, Speaker A: Can IBC go to Solana, do you think?
00:17:48.756 - 00:17:57.964, Speaker B: Right now, there's some kind of test implementations for this out there, but they rely on using a multisig bridge to facilitate the security. So, to me, that's not really IBC if you're doing that.
00:17:58.052 - 00:18:06.582, Speaker A: Got it. I don't know how DA actually even plays into your system, but are you in any way using like Celestia itself, the chain.
00:18:06.686 - 00:18:26.894, Speaker B: So union doesn't use DA specifically, but union bridges chains that do use dA. And because in the module stack, the chain kind of splits up its core responsibilities across many other chains. We need to recombine all of that to construct those lifetime proofs. So in the end we monitor Celestia, we monitor avail and basically construct those proofs together from that data.
00:18:27.062 - 00:18:46.044, Speaker A: Cool. I have one last question before we sign off, which is all of this talk about light clients. And you were saying you actually are deploying these like clients. I'm guessing you're building these like clients. Are they based on anything existing? Like I know that a few years ago the team succinct was doing like client work. Is it based at all on their design or is it totally.
00:18:46.092 - 00:19:09.510, Speaker B: No. So we've written ours completely from scratch. I think if you look at our code base, maybe at the start we use some of the verifying contracts which basically verify the CKP's, but our stack is very different. Succinct. Did I think Stark to snark from the very start? We generate snarks immediately, which as so happens for our workloads is a lot more efficient. So right now, for example, to generate the union ZK piece, that takes about 6 seconds.
00:19:09.970 - 00:19:12.850, Speaker A: Cool. Well, thank you so much for this interview.
00:19:12.930 - 00:19:13.714, Speaker B: Thank you so much.
00:19:13.802 - 00:19:18.050, Speaker A: And thank you for watching this episode of Sovereign Radio and we hope to see you in the next one.
