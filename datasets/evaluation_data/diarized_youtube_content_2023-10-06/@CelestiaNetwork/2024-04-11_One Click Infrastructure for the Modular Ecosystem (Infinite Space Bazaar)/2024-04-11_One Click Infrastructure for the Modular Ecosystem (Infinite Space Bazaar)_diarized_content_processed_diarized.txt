00:00:00.200 - 00:00:01.120, Speaker A: To doing that.
00:00:01.302 - 00:00:26.474, Speaker B: Yeah, GM again, everybody, and welcome to another workshop for the infinite space Bazaar. Today we have Teddy from kurtosis teaching about, teaching us about one click infrastructure for the modular ecosystem. Teddy, I'm looking forward to it. To learn more about kurtosis and see what you can kind of take out of the developers hands in this case so they can focus on their applications.
00:00:27.504 - 00:00:57.294, Speaker A: Yeah, 100%. Thank you, Josh. GM GM everybody. It's a pleasure to be here. A little bit about me, I'm a software engineer at Kurtosis. I've been here a while and have also kind of just recently been working in the module ecosystem with some of our work with hyperlin and now getting to Celestia as well. So I'm excited to show you all a little bit about what we think kurtosis can offer and how we think we can play a role and hopefully benefit you guys.
00:00:57.414 - 00:01:00.354, Speaker B: So yeah, awesome, looking forward to it.
00:01:01.214 - 00:01:42.924, Speaker A: Cool. We'll just get into it. So first things first, if you want to actually follow along, now's the time to actually install kurtosis. So if you've got brew installed and you're on a Mac, do a quick brew install for installing the Kurtosis cly. And then just to make sure everything is ready and working, run the second command to actually run the Ethereum package, and then to open up our UI. Run that third command, Kurdosis web, to actually open up a UI that will allow you to visualize your environments. Just if you want to follow along as we go through some of the later parts of the walkthroughs, hopefully we can just set all this stuff up now.
00:01:42.924 - 00:02:21.072, Speaker A: But yeah, a little bit of an agenda for what I'll go over today. I'll do some context setting and do some background about what info looks like in the modular ecosystem today. Some of it we already know, and a lot of it has been covered in the prior workshops, but we'll kind of contextualize that. Then I'll talk a little bit about kertosis, our product, and where we fit into this ecosystem. I'll do some walkthroughs and then hopefully some discussion about prizes and how you guys can get started. Cool. So, as we may know, modular devs need easy access to a lot of infra to actually start developing testing.
00:02:21.072 - 00:03:12.584, Speaker A: Now, this is the same for protocol devs, but also app chain devs. In order for app chain devs to get started, they need to get their roll up deployed and working, and they need this roll up setup to come out of the box with an underlying l two, depending on what their stack is. They need bridges, they need block explorers, sometimes they need indexers and oracles. So there's a lot of different components in infrastructure that Appchain devs actually need out of the box to get started. And right now, and I'm pulling a slide from Josh's or from Josh's slide deck on actually how to deploy an op stack roll up. There are three options for appchain devs to get started to actually do this. The first thing is you could deploy from source on your own, as Josh mentioned, but that does require some DevOps experience.
00:03:12.584 - 00:03:53.552, Speaker A: You could deploy using a role as a service provider. So caldera, conduit, gelato, or you could use an existing op stack testnet. Let's dive a little bit deeper into what some of these options look like for an app chain dev. If you're actually deploying from source on your own, where you'll usually get started is in some or many onboarding guides that usually come with a lot of prerequisite steps to actually get your environment set up. Sometimes, and this depends on the roll up that you're actually deploying with. But sometimes there's a UI for you to get started with. Other times you kind of install a binary onto your machine and do some setup to get that started.
00:03:53.552 - 00:04:56.734, Speaker A: Maybe it's a GitHub repo, maybe it's setting some environment variables, but you've actually got to do some steps to set up the environment and then run the different commands to actually get the different components of the infra that you need up and running. Now this is just the onboarding experience, but when you're actually trying to then take this and maybe deploy it to a more, maybe a Devnet setup that maybe you and other developers can set up, this is where you'll actually start to really require some more DevOps knowledge. So that's an option. Option number two and three looks like using some of the existing ras providers that have great uxs that abstract all of that away from you where you just say, hey, these are the roll ups that I want. Point and click and actually spin up that roll up, deploy it. You can choose which roll up kind of configuration you want, choose a settlement layer, data availability layer, et cetera, and then maybe configure some bridging as well as some other tools that you get out of the box. This is a good experience as well.
00:04:56.734 - 00:06:01.514, Speaker A: Usually these ROS providers will offer a much cheaper price to get that up and running for a testnet and then a different price for mainnet but this is an option that an app chain dev has if they actually want to get started as well. Now, where kurtosis kind of fits in is almost as a 1.5 in between that option number one and option number two. What we found is that a lot of times you'll have the protocol developers from the l one's and the l two s who actually are building this infrastructure. Also on the Oracle teams and the indexer teams, et cetera, we're actually building this infrastructure. And they have some, they're the ones who are writing those guides that require that you actually follow to get that infrastructure up and running. But again, sometimes that takes some DevOps experience and also requires a lot of steps to configuring your environment and getting things up, which can be frictionful and actually be painful for users who are just trying to get spun up very quickly.
00:06:01.514 - 00:07:01.384, Speaker A: What we found is that where we sit in that 1.5 is we offer protocol devs, the ability to package those steps to get everything up and running and then make it an easier experience for users to get that infra locally or in the cloud. So let me dive in a little deeper about what this actually looks like. So with kurtosis, what we've got is we've got a few different things. First off is we've got this kind of environment definition language called Starlark. This is where usually some protocol dev or some dev or infra dev will package up the actual steps that are required to configure that environment. Spin this up, spin up the Genesis, get the artfasks working, mount it onto another container, but packages up into Starlark and then they'll pass it in through the kurtosis engine to actually get that info running over a docker or over some container orchestration engine, docker or Kubernetes.
00:07:01.384 - 00:07:47.064, Speaker A: Then we've built some experiences that make this process a little bit easier where you can actually go through our UI. And if you're going through kertosis cloud, you actually don't need to have Docker installed on your machine. You can actually just run that package in some cloud infra that we manage and get it out of the box very easily. We have this package marketplace where the protocol devs who actually package up that infra can publish their package so that other people can click on that package and easily run it. Some packages that we've got that we'll explore later, the Ethereum package. We've also got some basic kind of postgres package, redis package, and basic infrastructure that are common for people to use. And then we've also got an enclave builder that allows you to visually put these packages together.
00:07:47.064 - 00:08:45.314, Speaker A: Let me get a little bit. So what I'll do now is I'll actually go through some of the packages that are commonly used, and then we'll actually go through the walkthrough portion where you can actually see how this experience actually looks like. So probably the biggest and most used package that we've got is the Ethereum package. This package was developed in joint effort between us and the Ethereum foundations and Barnabas. But this has been very useful for not only the Ethereum foundation and helping them get easy devnets locally that they can iterate on and develop and test, but then also publishing the Ethereum package for other users and client teams in the space to use. So for example, Flashbots has used the Ethereum package and built on top the Ethereum package and added mvv infrastructure to actually do mev testing with it. Nethermind has actually done blockbuilder testing building on top of the Ethereum package.
00:08:45.314 - 00:10:19.314, Speaker A: So the Ethereum foundation kind of packaged up the Ethereum devnet and published it to make it easy for other people to use and get that infrastructure easily so that they can do their own workflows. Another great example of how we kind of accomplished this was we collaborated very closely with the guys over at Hyperlane, shout out to Nam and Yorkie and Avi and everyone there. But we collaborated with them to make the experience of deploying their relayers and validators to set up a hyperlink bridge between chains a lot easier. We worked with them to create the hyperlane package where they encapsulated that logic to actually spin up the infrastructure and then offer this form fill experience where the person who is actually onboarding can just say, hey, I just need to pass in my origin chain, name router key, some other config, and then I'll get that infrastructure either locally on my machine or in a cloud environment. And so again, this just makes the onboard experience a lot easier. Most recently, actually, the team over at Polygon shout out to John and Leo has done some great work in creating a package that actually spins up the full Polygon CDK environment with some extra tools on top of it. Once again, we're seeing a story where our protocol dev can encapsulate that DevOps infer logic and then offer this nice form fill experience where you can just get that package running wherever you need it and then start iterating on it and playing with it.
00:10:19.314 - 00:11:14.584, Speaker A: The cool thing about the Polygon CDK package as well, is that they're actually leveraging the Ethereum package under the hood to actually build, to actually get that l one network going, which shows another cool feature of kurtosis, which is that in the way that the Starlark environment definition language allows you to create packages, they become very composable. And that's a lot of what we actually want to see from builders in this hackathon building composable packages that work together so that if the Polygon team has created a polygon l two rollup people can build packages on top of that, that leverage the l two under the hood. And we'll get a little bit into that later as well, but. Cool. Now I'm actually going to show and walk through this experience a little bit, so I can't see any of the comments. Cool.
00:11:14.744 - 00:11:18.016, Speaker B: Okay, I just wanted to have a question so far.
00:11:18.200 - 00:11:59.896, Speaker A: Hey, GM's, see you guys. Cool. So what I'll do now is I'll kind of share my screen, and I'll walk through our cloud experience, and then I will also walk through some of our UI experience. So let me just share my screen. Cool. Can everybody see my terminal up in here?
00:12:00.080 - 00:12:00.616, Speaker B: Yeah.
00:12:00.720 - 00:12:00.960, Speaker A: Awesome.
00:12:00.992 - 00:12:02.164, Speaker B: Nice and clear too.
00:12:02.504 - 00:12:28.534, Speaker A: Awesome. Cool. What I'll do now is I'll just use the kurtosis cli. Hopefully you've gotten the kurtosis cli installed. Then what we'll do is actually run a simple package with it. What I'll do first is I'll actually run, let's say the postgres package. So this package will just spin up a simple postgres database.
00:12:28.534 - 00:13:09.734, Speaker A: Great. And now we've got this postgres database running on this expose on this port. And what I'll actually also do is I'll start up the Ethereum package in the background, and then I'll show you how you can actually interact with the environments that have been spun up by the Kurtosis engine through the web UI. So while that spins up, I'm going to open up the local UI and I'll change my screen share here.
00:13:13.754 - 00:13:18.994, Speaker B: And this is all running locally on your machine, not on Kurtosis cloud, right?
00:13:19.114 - 00:13:50.700, Speaker A: Correct, correct. This is currently running locally, but I'll also show you the cloud version as well. Cool. Here what we've got is we've got the Kurtosis UI. You can see that you can interact with the different environments that we just spun up. So we just spun up that database. And you can check out the logs.
00:13:50.700 - 00:14:25.820, Speaker A: You can also get some basic information about the services there. And each of these environments that are spun up by the kurtosis engine are in their own isolated enclaves where they have their own networks and they interact with the services all completely in an isolated and separate fashion, which is nice when you want to just spin up multiple things and then also easily tear them down. So I can easily blow away that postgres database. And I believe we've got our Ethereum network up and running. So cool. We've got this Ethereum network up and running. We can interact with the nodes.
00:14:25.820 - 00:15:25.784, Speaker A: We've also got Prometheus and Grafana set up, so we can also check those out. I'll show that a little bit later, but we can click on the exposed ports to actually see the Prometheus and Grafana dashboards, check out logs of these services. This experience I all just ran completely locally, but that actually does require you to have Docker installed, Docker or kubernetes installed. You can run this infrastructure over Docker Kubernetes, but let's say that you want maybe an even smoother experience and you don't want to quite, or maybe you don't have Docker installed yet. You can also use the user cloud version where if you just go to cloud dot, kurtosis.com will give you a quick environment where you can also run packages. I'm going to move over and share a different screen where I'm actually now in my cloud environment and we'll deploy a quick hyperlink deployment.
00:15:25.784 - 00:16:13.774, Speaker A: Now I'm actually in my cloud environment and what I've just done is I've entered a link that automatically pre fills some information about the hyperlink package backing up. And Yorkie demoed some of this flow in his workshop as well. But the hyperlinkly outputs this link to cloud doctor.com that actually puts in this information completely pre filled. Then you can click run and that will get a relayer and a validator set up for you in a cloud environment. So again, a really clean, easy way to just get up and running with your environments. Then I'll show one more example of this.
00:16:13.774 - 00:17:03.324, Speaker A: Now we've got our relayer and our validator architecture working. We can check out the logs to make sure that, okay, cool, so didn't have enough funds in my account, but then we can go ahead and debug from there, check out their layer logs as well. And then I'll show one more example before we actually go ahead. And I'm going to show you a little bit about the behind the scenes where that is actually being produced. But we'll show one more example. So here I've actually got the polygon package where you can see a very similar experience. Deploy l one.
00:17:03.324 - 00:17:19.954, Speaker A: They've kind of isolated it and broken up into steps where you can deploy the l one. True. Yep. I want to do that. Deploy the ZKVM contracts, get the database, get the bridge infrastructure, let's get the central environment as well. Let's also get the node. And then I also want to deploy observability.
00:17:19.954 - 00:18:03.318, Speaker A: And then you can also configure a host of other things, but they're optional, and they've got, you can also configure it to be optional and have preset values for those that will actually get the environment to work. And I'll run that. I've actually pointed this to a fork version that I created, just because the polygon package takes a decent amount of time to run. But once that's all said and done, you should get all the infrastructure. Again, I've commented that for the purpose of the demo, but if I hadn't done that, that would have spun up all of the polygon infrastructure. Cool. Now, going back to the presentation, how was that experience made possible? Cool.
00:18:03.318 - 00:18:14.404, Speaker A: Let's actually get into what the experience of writing your own package would look like that entire experience. Cool. I'm hearing, how's the sound? I hear it's breaking in and out.
00:18:14.524 - 00:18:15.692, Speaker B: Your sound's good.
00:18:15.828 - 00:18:16.868, Speaker A: Sounds good. Cool.
00:18:16.956 - 00:18:17.624, Speaker B: Yeah.
00:18:18.284 - 00:19:27.194, Speaker A: So how is that experience kind of made possible? Cool. Well, let's jump into the hyperlink package, for example. Let me get that set up. So here's hyplane package. Once again, this was a package that we co authored with the Hyperlane team, where they were able to actually encode that infralogic and actually provide that experience that you just saw that I showed in the UI. So a little bit about the behind the scenes of how this works. So the team created a package called the hyperlink package, and what we do is we actually parse this information that they actually say, hey, this is the stuff that we want to be configurable.
00:19:27.194 - 00:19:54.908, Speaker A: We want the origin chain name to be configurable, the validator key. These are the types that we want on it, and we parse that. And then that's what allows us to offer that form fill experience of getting onboarded. And then the rest of that is saying, okay, based on that information they give us, let's encode some logic that will control how that environment is actually set up. And that is done through this environment definition language that I mentioned earlier. Called Starlark. It's pretty, pretty much just a subset of Python.
00:19:54.908 - 00:20:51.196, Speaker A: So if you know a little bit of python and you can kind of follow our instructions to be able to do that. And so they've encapsulated the logic to actually spin up the relayer, which is, as you can see, setting a handful of variables, getting the proper images in place, running a command, and then setting up the files. And the nice thing once again is that they kind of say, this is the information that we need to know. Once the user of the experience gets it, gives us that information, we'll actually encapsulate the logic of running it. And so I'll show another example of this with the Ethereum and the polygon packages. Actually, let's go to the polygon package because they actually have a good example of composability. So here is another example with the polygon package actually leveraging that.
00:20:51.196 - 00:21:40.172, Speaker A: So they've created this kurtosis package, they've got this main star, and so here they actually encode the logic of cool. We're going to deploy the l one. And you can see under the hood, they're just importing the Ethereum package that was created by the Ethereum foundation. And they're then running the Ethereum package just like importing, let's say a Python library, or literally just like a python library. And then they're passing in the orgs that they said were important to the underlying Ethereum package. And they didn't have to rewrite any of the logic to actually spin up the ethereum l one network, they're leveraging that already packaged Ethereum package that the Ethereum foundation created. So a great example of just being able to plug and play and compose different parts of infrastructure together to get it up and running.
00:21:40.172 - 00:22:47.534, Speaker A: And then the polygon folks were then able to encapsulate the polygon specific infrastructure. So spinning up the contracts, getting the databases, getting the genesis file working. And they kind of also did a great job of making or separating out these different environments so that again, people can choose the different ways in which they want that environment to be configured in that form. Filter experience. So I'm going to go back to cool. When should you actually consider checking out kurtosis, taking all that information and now synthesizing a little bit? If you're a protocol dev and you're looking to simplify the onboarding experience for users, just like we were able to accomplish with the hyperlink team and now with the work that Polygon is doing, if you want to simplify that onboarding experience offer less steps, give them an easy way to do it in the cloud. That would be a great option to use kurtosis for.
00:22:47.534 - 00:23:53.096, Speaker A: And then as an app chain dev, when would you actually want to use that? Let's say that you don't want to actually go through those long onboarding steps and getting all that infra set up and configured. Likely we'll be running into some friction with maybe different versions or packages or libraries not being set up and dependencies not being set up and then having to go to the discord to clarify those things. But then you also don't want to go to a Ras solution just yet. Maybe you don't want to pay for it, or you know, kind of, you want a little bit more configurability and you don't want to go to a Ras just yet. That also be a great opportunity to use kurtosis and also kind of with all of this kind of in order to actually enable the modular composability of all this infrastructure working together, just like the polygon l two was able to build on top of the ethereum l one, we actually need people to be writing these packages that can actually fit together. So that's a huge part of why we wanted to take part in this, the infinite space bazaar hackathon. Literally the whole point of this package or the hackathon is to have people exchange modules and work with each other.
00:23:53.096 - 00:25:12.104, Speaker A: And so we want to incentivize people as well to create those modular infer packages that can work together. So if you're a dev with a little bit of docker experience and you know how to write python, and you're also looking to make some money, we are really looking for people to write modular packages that package up the different components of infrastructure in the modular ecosystem and have them work together. So on that note, how can you get started with kurtosis? So we are giving out prizes to people who are actually taking new pieces of infrastructure that are required in the module infrastructure and packaging them up. So maybe it's a faucet that can be used with the Ethereum package, or an oracle or an indexer. Pick a piece of infrastructure to actually package up and then write a Kurtosa Starlark package for it. We've got docs on the actual instructions that are kind of that outline the instructions that you'll use to work with the Starlark environment and then publish it, make it into a package, give it a GitHub repo, add a nice doc string to it so that you can get that form fill experience and the local or the cloud UI, and then a bonus if you could actually plug it into another package. So if you can leverage, let's say even polygon package or the Ethereum package under the hood, or maybe even the hyperlink package so that we can start building these modular pieces that can work together.
00:25:12.104 - 00:26:19.456, Speaker A: Some ideas that I'm looking forward to seeing are if you can take a deploy your own roll up guide and actually make it into a package. Rolekit's got a guide that I think would be a great opportunity to actually, in a similar fashion to the hyperlink guide, encapsulate that stuff into a kurtosis package and then offer a nice form fill experience. Or again, like I already said, package up a piece of infrastructure and have it plug into another package. So, yeah, what infra are you going to package and make modular so that we can enable devs to build a little bit easier with an ecosystem. Looking forward to everybody's ideas and kind of to get us started, here's some links to actually getting started with writing a package, and then as well as our quick start guide and then invitation to our discord. Very excited to see what people want to build and also very open to working with people, even if you're a little bit new and you just want to experiment with what Docker and containers look like and spinning them up. Very happy to chat, educate, and collaborate.
00:26:19.456 - 00:26:30.784, Speaker A: So that's it for me. Happy to go anywhere from here. Can demo a little bit about how writing a package works, maybe running a few other packages or exploring the UI a little bit. Yep.
00:26:33.004 - 00:26:48.974, Speaker B: Thank you again, Teddy. If anyone has questions, please drop them in the chat. One of my questions was how I could get started using kurtosis for a roll up on Celestia. But it sounds like that's still kind of a work in progress and also a bounty, right?
00:26:49.054 - 00:26:50.342, Speaker A: Yeah. Yep.
00:26:50.518 - 00:27:11.674, Speaker B: So I'm curious if you've played around at all. At the beginning, I think you touched on the complexity of combining all of these pieces, whether or not it's like a modular stack, or whether it's just using, like, the Ethereum package. I'm curious what the most difficult part has been interacting with, like, the modular stack specifically.
00:27:13.354 - 00:28:01.474, Speaker A: That's a great question. I think the most difficult part for us, and I just think the ecosystem general is, again, there's so much infra that people are building, and the nice thing is that people are building it out in the open web, three is very open source. So you've got all this open source code being written in different stacks using different tools, but then you have all this infrastructure actually needing to depend on each other. For us, it's been actually looking at other people's infrastructure and helping them package it with working with different stacks and actually getting that package into kerdosis. But it's also a great opportunity to create a standard for the ecosystem where you can add these interfaces that allow things to plug and play together regardless of the different stacks and infrastructure that people are using.
00:28:01.974 - 00:28:06.554, Speaker B: Nice. Are there any existing packages that use Cosmos SDK?
00:28:07.704 - 00:28:13.164, Speaker A: No, not currently, but would love to see that become a reality if somebody's up for it.
00:28:13.904 - 00:28:31.924, Speaker B: Yeah, it sounds like it could be useful for, I guess, on the roll kit side of things. I don't have any, I guess, burning questions right now, but I'm curious to know if there are any other bounties or examples or packages I guess, that you'd like to see built.
00:28:33.152 - 00:29:29.580, Speaker A: Yeah, in honestly, you know, one, one that I'm really looking to, you know, I've been taking, I've been considering taking a shot at this for myself, but I would love to see the. I would love to see this guide kind of packaged up into a kurtosis package. So this is the, the GM world guide for the rolled Kip, the Rolekit SDK. And again, it goes through the steps of people need to install dependencies. Golang, wget actually the image for a slow cnlite node and decent amount of steps here. Would love to see this be patched up into a nice experience where somebody can just come and give the information that they want and then get all this infrastructure up and running and then also hopefully compose that on top of, on top of an l one as well. So I've taken a shot at this.
00:29:29.580 - 00:29:40.104, Speaker A: I know I've talked to Manav as well about taking a shot at this, but haven't been able to get there yet. So would love to see if somebody could take a shot at that. And I'm happy to work with them to do that as well.
00:29:40.524 - 00:29:53.064, Speaker B: Awesome. We have some time, so I guess if there's anything you mentioned, a few things you might walk through, I guess, on the UI or other packages, are there any ones that you'd like to highlight?
00:29:53.444 - 00:30:19.164, Speaker A: Cool. One thing that I can do is I did forget to actually show the Prometheus dashboard that was spun up by the Ethereum package, so I will go ahead and do that it.
00:30:44.564 - 00:30:54.708, Speaker B: And then in the chat we do have a question about the best way to contact you directly. I'd imagine Discord is probably the best way to generally reach out to the team, right?
00:30:54.876 - 00:31:05.624, Speaker A: Yep, yep. Discord. I did. I put that link at the very end of the slide. No, that, that's not super accessible. But if you go to kurtos.com, comma, we've got our discord link up there as well.
00:31:05.624 - 00:31:35.424, Speaker A: And then, you know, I'm everywhere. I'm in the, I'm in the ISP discord. So reach out there as well. So cool. I'll show off the. So here's the Grafana dashboard that was actually collected, that was actually spun up by the Ethereum package and then exposed. So let me take a step back and go to the UI to show how I got there.
00:31:38.544 - 00:31:47.124, Speaker B: And I guess usually you just have some things running in Docker, but you don't have as much visibility on it without Prometheus and Grafana.
00:31:47.544 - 00:32:28.694, Speaker A: Yeah, exactly. Exactly. Prometheus and Grafana add that observability where again, the protocol dev or the info person has added the dashboards that they want and expose the metrics endpoints that they want. And then I just clicked on that Grafana dashboard, and then that will take us back to. I clicked on the HTTP port that was exposed by that Grafana service that was in the kurosis UI. And then I got that nice Grafana dashboard that you were just seeing. Now, again, the cool part is that this was actually composed off on top of the Prometheus and Grafana packages that we wrote at kurtosis.
00:32:30.174 - 00:32:49.594, Speaker B: Oh, I'm going to hang around until we get him back, I guess. Definitely. If there's any questions, now is a great time and we'll get to them.
00:32:50.894 - 00:33:38.380, Speaker A: Accidentally, accidentally clicked. Accidentally clicked out there. But to get back to what I was saying. So the cool thing is that the Grafana package and the Prometheus package that was being used in the ethereum network were actually using under the hood, the Prometheus and Grafana packages that we at Kurtosis wrote. So at Kurtosis, we've invested a lot of time in actually building packages for basic pieces of infrastructure that any architecture is going to use. So postgres redis Nginx proxies Prometheus confined dashboard so that you don't have to actually create or rewrite the starlark or Kurtosis starlark to get that in for yourself. You can just plug it into an existing kurtosis package as if you were importing a library and then get that for free.
00:33:38.380 - 00:34:35.294, Speaker A: So I'll show a little bit of the, I'll show an example of the Prometheus package there. So here's the Prometheus package. Super simple. So if you, let's say that you are trying to, in whatever package you're writing, were trying to set up observability using Prometheus Grafana, you would just come here and then follow the instructions on these example of things that you need to pass into the Prometheus package, just like the parameters of a function. And then we've even got some starlark snippets to get you started with actually just importing the package. And actually, another thing that I'll show off is that if you need a place to go and figure out what are the packages that exist and what are the packages that you can leverage and what you're writing, you can head to the Kurtosis package catalog that will actually show off all the packages that currently exist and are published. So you can see the hyperlink package there.
00:34:35.294 - 00:35:18.534, Speaker A: You can see the Ethereum package. We've got dive packages from Hugo Byte, and then again, some of those basic infrastructure packages, etCD package, Flink, Grafana, MongoDB, and yeah, and then there was mine that I was showing you guys earlier and again. And then the nice thing about the package catalog is it'll actually, if you click this run, it'll take you straight to the kurtosis cloud dashboard where you can then just run that package. So again, if you need an easy way to just figure out what packages exist, try them out and experiment, go to the catalog, dot catalog dot kurtos.com to check those out.
00:35:20.914 - 00:35:21.774, Speaker B: Sweet.
00:35:22.514 - 00:35:23.226, Speaker A: Cool.
00:35:23.370 - 00:35:29.974, Speaker B: I'm out of questions myself. Thank you for showing us around kurtosis.
00:35:31.194 - 00:35:54.914, Speaker A: Sure thing. Yeah, just, just want to reiterate, looking forward to seeing what people are able to build again. In order to enable kind of those smooth, clean experiences for onboarding, we want people to be writing modular info packages. So, yeah, if you've got some DevOps, got a little bit of docker experience and python experience, I think. I think you should take a, take a shot, and I'm happy to work with you to make that happen.
00:35:57.214 - 00:36:13.714, Speaker B: I actually do have more questions. Have you worked with. I know the Ethereum package is like consumed by the Polygon CDK package. Would it be useful to have also op stack and arbitrum nitro as packages there?
00:36:14.294 - 00:36:28.278, Speaker A: Yep. Yep. No, definitely. Yeah, definitely. Those are options. Polygon team has done some great work in investing, actually creating that package. I believe they're using it for internal configuration testing.
00:36:28.278 - 00:36:43.914, Speaker A: There's a lot of people who need to get the polygon environment spun up to do whatever the workflow is, whether it's internal devs, but also Appchain devs as well. So, yeah, no reason that that same experience can't be replicated across the different roll ups and l two options.
00:36:44.734 - 00:36:56.870, Speaker B: I hadn't actually really thought of it being used as, like, an internal testing tool, but I guess it could really cut out a lot of time for people instead of spinning everything up manually or with existing scripts.
00:36:57.022 - 00:37:19.534, Speaker A: Yeah, and that's kind of where we've also seen it be very viable for the Ethereum foundation as well, where they're working with a ton of different client teams who are all need the clients to interop with each other. And so the Ethereum package offers a standard for just getting an Ethereum Devnet locally on your computer and then running it against a configuration that can reproduce a bug or just test a specific workflow and such.
00:37:19.874 - 00:37:20.614, Speaker B: Nice.
00:37:23.994 - 00:37:24.370, Speaker A: Yeah.
00:37:24.402 - 00:37:28.654, Speaker B: So thank you again, I guess. Is there anything else we want to go through?
00:37:29.444 - 00:37:39.140, Speaker A: That's it for me. Really excited to see what people are able to create and very happy to work with everybody. Honored to be here. Thanks for having us, Andraj.
00:37:39.332 - 00:37:42.764, Speaker B: Yeah, thank you. Have a good day, everybody. Thank you again. Teddy.
