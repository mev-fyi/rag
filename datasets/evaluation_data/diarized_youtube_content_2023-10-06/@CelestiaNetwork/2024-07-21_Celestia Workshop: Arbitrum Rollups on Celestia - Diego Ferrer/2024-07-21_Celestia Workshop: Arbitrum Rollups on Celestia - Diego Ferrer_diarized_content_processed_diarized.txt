00:00:02.840 - 00:00:40.088, Speaker A: Well, hello, everyone. My name is Diego Ferrer. I'm a solutions engineer at Celestial Labs. The agenda had a very generic title. It was arbitrum rollups on Celestia. But you can assume that title was just a last minute thing, and it's nothing entirely correct or a good reflection of what we're going to talk about today. What I want to talk about today is, sorry, arbitrum nitro roll ups with Celestia da.
00:00:40.088 - 00:01:26.220, Speaker A: But more specifically, I want to talk about combining best in class DA with best in class execution. And then at the end, I'm going to try and showcase how you can, for example, run your own arbitrum orbit roll up with Celestia da while still leveraging new things in the arbitrum nitro tech stack, such as stylus. I admittedly, I'm doing this for the first time. I tried building some of the code stuff in my hotel, but my hotel Wi Fi sucks, and that didn't build. So right now, I'm depending on my coworkers. Josh's phone shout out, Josh. So, yeah, it's a quick, nice logo.
00:01:26.220 - 00:02:04.678, Speaker A: So, if you've been in the modular ecosystem, you may or may not have seen this image before. It's basically a very nice, sort of, like, marketing diagram that showcases the different configurations that you can have for, like, a roll up in general. Right. Obviously, this is more specifically for Celestia. That's why you see the name Celestia all over the place. But you can essentially switch celestia for, say, like, ethereum da or something else, right. Today, specifically, we're going to look at what it's like to build a celestium.
00:02:04.678 - 00:03:26.920, Speaker A: In this case, the celestium in question, being an optimum. These are all kind of meaningless words that people have come up with throughout the years, in my opinion. I don't know if there's a formal definition of what an optimum is, but you can go talk with the l two beat folks, or you can read some articles by Luca Dono on his personal website from the l two B team, where he better describes what an optimium is. But the idea of an optimum is essentially, you have a roll up or an l two that has its own execution. So where it says celestium, that's where your arbitrage nitro rollup would have or would essentially be the execution part. And you have settlement and consensus from Ethereum because you're deriving, ultimately, the order of your batches, which determines the order of the transactions in your roll up from the order in which they were posted on Ethereum, right? So if you post batch one, batch two, and batch three, and there's no reorgs, that would be the canonical order of your chain. But if batch two gets reorged, say, to the later part of the batches, then your order would be determined by Ethereum, not by Celestia, because your batching order would be one, three, two, and ultimately you are using celestia for data availability.
00:03:26.920 - 00:04:30.820, Speaker A: So let's look at a little bit more how all this stuff works, right? So first we have the famous simple diagram from the arbitrum nitro whitepaper. Essentially, the arbitrum nitro system first, like tries to, or the arbitrum nitro whitepaper first tries to explain in a more generalized concept, like what a roll up is, or more specifically, what this system is like from first principles. So the system has a sequencer that takes transactions from the user. The sequencer generates a soft guarantee. That's what nowadays is sort of like the hot talk in the town, right? Like soft confirmation slash pre confirmation. I'm not going to debate anyone on this room or on Twitter on that topic. But basically, sequencer gives you a soft guarantee that your transaction will be included on the batch that gets posted on Ethereum.
00:04:30.820 - 00:05:48.580, Speaker A: And the sequencer's job is to take all those transactions to create an order list of inputs which get passed onto the state transition function, which then applies each of these transactions one by one. So it has state zero, it applies one transaction, and then it checks that it's valid. Then it moves on to state one, so on and so forth, until it reaches the last transaction in the batch. And that's what generates a valid roll up block, or l two block, which is settled to the l one, meaning this batch is posted to Ethereum, or in the case of an l three chain, that would be settling to the l two. Additionally, in order to check that these blocks are valid, people need to have that data, aka the data needs to be available for validators and for people that are running nodes to check that the inputs, when given to the state transition function, match the expected outputs. And that's essentially how an arbitrum nitro rollup works. The main difference on the how this would work with Celestiada is not that complex.
00:05:48.580 - 00:07:11.178, Speaker A: That's it. The difference here, there's an arrow missing. Technically, the l two block is still settling on Ethereum, meaning you are posting a very small batch of data to the l one chain to essentially check the ordering of the batches. But the only difference between the previous, more high quality image of what an arbitra nitro roll up looks like. And this system that we built, this integration that we built with celestial Va, is that instead of batching and compressing the data of the transactions that go into a batch and posting that on ethereum, you're posting that on Celestia, and then you're posting this data pointer, which is like a couple of bytes that essentially allow people to uniquely identify a roll up batch number to some data that lives on Celestia at a specific block height for a specific commitment and so on and so forth. And it also includes the necessary information that you would need to run a arbitrum nitro fraud prover validator for this roll up. And lastly, there's that fallback part, which essentially is sort of like a security mechanism.
00:07:11.178 - 00:08:39.880, Speaker A: Like if you are running one of these arbitrum nitro witsilessia da l two s or l three s, then in the case in which, for example, your node goes down, your Internet connection goes down, something happens, right? Like for some reason, the system wasn't able to post the batch to Celestia, it will fall back to ethereum l one or the arbitrum nitro l two. And more recently, we also experimented with the folks at conduit to enable fallback to a different DA provider. The problem that that solves is that basically Ethereum can only take so much data for a batch, and the amount of data that you can publish on, say, celestia is greater than that. So if you're trying to post a batch that's like two megabytes to Ethereum, that will never happen. So your entire batch of user transactions would get completely discarded in the case, there's an issue with your celestial connection. But enabling a fallback to say something like any trust is sort of like a good fallback guarantee that your data will still be made available somewhere else and you won't have to revert this massive batch of user transactions. Another thing to note that it's not well depicted on the diagram is that this is technically the first integration to ever use blobstream.
00:08:39.880 - 00:09:46.860, Speaker A: If you've been around the ecosystem, or if you checked out on Twitter, you probably heard this word many times. But blobstream is basically the way in which we get on chain verification to the attestation of some data being included on celestia, right? This fact can be leveraged in the nitro like smart contracts for the settlement to see if the batch data was posted to celestia or not. So the way this basically works is that in the case there is fraud, right? And two people are having a dispute in the arbitrum protocol. While running Celestia Daevdev, you would check against blobstream whether this batch of data even exists or not on celestia, and if it doesn't exist then you would discard it. If it does exist, then it's a valid batch and the rest of the arbitrum nitro fraud proof operations would continue as per usual. This is a better diagram that explains exactly what blobstream does. In case you've never seen it before.
00:09:46.860 - 00:11:06.540, Speaker A: It's sort of like a more conceptual thing than an actual implementation thing, given that this is just a generalized concept. This is the same concept that Blobstream x by succinct uses to essentially leverage Ck to make some of these attestations more efficient to post. The same thing can be said about the newer or the rift zero version of the implementation, blobstream zero. They both achieve the same thing, which is to relay attestations from the celestial chain to some other EVM chain or even non evm chain for the purpose of giving roll ups a form of verifiable attestations for data inclusion. This is a diagram that sort of explains the workflow between a celestia or arbitrum nitro with celestia roll up and the blobstream x system improvers and whatnot. Ultimately, your settlement contract for arbitrum nitro would wrap around or leverage the blobstream x contract as of the current implementation. There's also nothing stopping people from using the RiSC zero implementation if they wish to do so.
00:11:06.540 - 00:12:33.810, Speaker A: And now for what I believe is sort of like the more interesting part, like why are we even talking about arbitrum nitro with celestial da, right? What is the difference between, say, choosing something like op stack and something like choosing arbitram nitro? And in my opinion, other than the fact that today running an arbitrum nitro rollout means that you have fraud groups from day one. While it is true that the Op stack or the Op Labs team developed fraud proofs for the op mainnet and other chains, to this day, a lot of op stack chains don't have fraud proof support because of Altva and other issues. But with Arbitrum Nitro, you do get that feature of fraud proofs from day one. But how do you differentiate from one EVM with fraud proofs to another EVM with fraud proofs? My opinion is sort of like the features that that enables that these, like, stacks enable. And the most important one, or one that's, like, really cool to highlight, in my opinion, is Stylus. In case you haven't heard about it before, Stylus is essentially this upgrade to the arbitrum nitro stack that will enable people to write smart contracts in any language that compiles to WaSm, right? So you can think about it. That's like writing smart contracts in Rust C C.
00:12:33.810 - 00:13:18.246, Speaker A: It's a natural realization to the fact that if you read the arbitrary for white paper, it specifies that the system proofs transactions by compiling source code into WASM. So instead of just, like, limiting itself to taking the EVM, compiling that to WASM and proving that, then it expands upon it to allow people to also prove other programming languages, other contracts, if you will. And the cool thing about this is that you don't lose the EVM. So you can still have the EVM in your roll up, but you can also leverage this new system, Stylus. In a nutshell, they call it EVM. I'm an engineer. I'm not a marketing person.
00:13:18.246 - 00:13:53.530, Speaker A: I'm not going to make any opinions about that name. People have talked about it on Twitter. That's not my issue. But it's EVM because stylus is added it to the Evm, like I mentioned. That means choosing to use arbitrum nitro. And choosing to use Stylus doesn't mean that you're losing support for the things that you already, for some reason, loved about solidity and the EVM landscape. But it means that you keep what you already have, while also now enabling this new paradigm of writing smart contracts on essentially languages that the rest of the world actually uses.
00:13:53.530 - 00:15:15.050, Speaker A: That means you have rich language support that already exists for rust. You can use the stylus SDK and ClI to start building things today on Testnet. It will soon be enabled for Arbitrum one mainnet, assuming the DaO votes yes to it or for it, and it will be enabled in arbitrum orbit roll ups with celestial DA soon after. Additionally, you have interoperability between these two things. Having this co located EVM machine with this co located system for Rust and C and C doesn't mean that you have people siloed into different ecosystems inside of your roll up. It actually means that these two things can coexist and interoperate. For Arbitrum one, it means that people, for example, that are now building a stylus can code old contracts that existed on the EVM for people that are building orbit roll ups or sorry, orbit chains with Celestia da, it means that you don't have to worry about having to separate the developer Persona into those who want to live under the old ways of the EVM, in my opinion, and those that want to try this new thing out, you can actually have both instead of boring you with more words and bullet points and whatnot.
00:15:15.050 - 00:16:11.028, Speaker A: I took my freedom to just screenshot ed talks from yesterday. So other than just enabling new languages, which is cool, some people might say, well, but you can already do that if you go to Solana. Or I can change my vm and write in rust, et cetera. And while that is true, I think something important to highlight is that the stylus system is actually very efficient when it comes to computation. So here you can see how DBM today is like, slow and expensive, right? Ed talked more about it during his modular summit three talk. But essentially you can achieve more with less. And this actually enables a lot of cool stuff, right? You have faster runtime, you have better compilers, like the compilers for Rust, C, C, etcetera are.
00:16:11.028 - 00:17:14.419, Speaker A: You know, I don't want to say, obviously, because I don't want to, like, hurt anybody that works on solidity. But, you know, the rust compiler, the C compiler, et cetera, these are things that have been used for years and things that are being worked on by basically the rest of the world. And also with things like stylus, you have, for example, faster operations such as catch, Hackley. Your memory can be 100 to 500 times cheaper than when you use the EVM. And this enables new use cases such as advanced cryptography. Some of the stuff I discussed or heard from the off chain labs team while talking with them some couple months ago was this idea of, well, now that you can enable these new cryptographic use cases on stylists at a cheap cost, it makes it very viable to, for example, build new forms of user authentication. You can think about it as new ways of doing account abstraction on these systems.
00:17:14.419 - 00:18:00.080, Speaker A: So imagine, for example, being able to sign transactions with face id on iPhone. You could probably build such a system on the EVM, but it would probably be very expensive. Stylus would allow you to do this in a way cheaper manner without having to enshrine something as a precompile. And obviously cheaper computation is good for things like AI. You can also now do precompiles in stylus, which would be very useful for people that are trying to build these cool things as their own orbit roll ups and, yeah, heavy computation. And additionally, you have really good resource pricing for this. To learn more why resource pricing matters so much, go rewatch John's talk.
00:18:00.080 - 00:19:41.160, Speaker A: So what does this all mean, right? Like, why am I even talking about stylists? Why haven't I, like, started, like, I don't know, like, doing the workshop and coding and whatnot? I think it's because I really want to convey the idea that, like, again, this is not just like, oh, come and watch me talk about, like, arbitrum, nitro, and Celestia da, right? Like, I've done that before. It's more so that now I can actually talk about this idea of having best in class DA and best in class execution. So you're combining Celestia, which is the only DA network currently live, that has data availability sampling, which also now has the blockstream data to station bridge live, allowing you to build these systems in a matter of a couple of commands, or in the case of, like, you preferring to use a RAS provider, five minutes, a couple clicks, and, like, a credit card, I guess. But also things like Celestia da enable way cheaper Da costs than Ethereum, even after AIP 48, 44. And with stylus, as I mentioned before, now that you have more efficient and cheaper computation, you're essentially combining the both best worlds, right? So now you have cheap da, but you also have, like, cheap computation. So again, best class da plus best class execution subsidy is cheap. But that's just like, you know, that's not necessarily the property that you should be looking for.
00:19:41.160 - 00:20:22.808, Speaker A: That's what I tell people whenever I talk with folks or debate around the topic of Da and Da layers. If you want cheap, I can give you an API for my Amazon s three bucket right now. That's very simple. That's very cheap. But what matters here is that you have permissionlessness and verifiable da, right? That means you can go and deploy one of these systems today. You can just start paying for DA at a very, very cheap cost, and nobody's stopping you. Like, I am not going to ask you to, I don't know, Dox your IP address or sign up on a Google form or KYc yourself.
00:20:22.808 - 00:21:21.010, Speaker A: There's no such requirements with this kind of thing. Again, Silas contracts are over an order magnitude faster, with significantly lower gas fees due to superior efficiency of Watson programs. Memory is way cheaper, and you get fraud proof support from day one, right? So you're really getting, I think, in my opinion, one of the best stack combinations that are currently possible in the sort of roll up landscape. And, yeah, that's basically it for my, I guess, talk part of the workshop. Now I am going to hope that my docker image finished building and if not, then we'll see what we can do about that. So. Okay, so I do have a couple of stuff.
00:21:21.010 - 00:21:57.432, Speaker A: This is going to be a challenge. Let me see how I can make this bigger. Okay. All right, cool. Let's do that. So the first thing to sort of start testing any of these systems locally, in my opinion, is to have a local devnet. Otherwise you start running into certain issues.
00:21:57.432 - 00:23:23.602, Speaker A: Right. As someone who spends perhaps a, as someone who spends a significant amount of his life working on rollups, perhaps way too much, it is kind of problematic when you want to try to iterate rapidly around building these systems, modularism, not maximilism, but when you are building software modularity, sort of the microservice landscape of web two, it's great and it does allow specialization, but you still need to find a way to sort of connect all these components. Back in the day when I started building the arbitrum nitro integration, we didn't have this. I'll explain what this is in a second. But I had to build more docker images. So my coworker is going to test to the fact that it was really annoying to try to spin a local devnet and then test it with any system and then make sure that it was compatible also then with a testnet and so on and so forth. And the reason as to why I recommend doing local devnets instead of testing or, sorry, testnets, is that while it is very simple to run a celestial light node, you might have to get, or not might you have to get mocha tokens or arabica tokens for which you have to go to a faucet and whatnot.
00:23:23.602 - 00:24:22.478, Speaker A: And while there are plenty of tokens available on Testnet for the faucet, it is kind of annoying, in my opinion, to have to request tokens, receive them, and then you're testing, you're, I don't know, in the zone going hard coding and then you run out of funds and then you have to go request them again. It's sort of annoying. You might as well deploy a local devnet where you are like a whale. It's a nice stream to have the fruition. But yeah, I essentially, what I have here is this thing called Apollo. Apollo is basically sort of like local deployment system that was built by somebody at celestial Labs. Calum, what Apollo allows you to do is to run a single command and essentially without having to use Docker, which is great, you have yourself a local validator full node, a bridge node, you also have a light node.
00:24:22.478 - 00:25:49.150, Speaker A: Of course, one of the things to highlight about Apollo is that other than just giving you the minimal necessary components to run a local devnet environment, it also comes with some really cool utility, in my opinion. One of them, for example, is that you can, it comes with this front end that allows you to check out, allows you to check out the current running services, the endpoints for each one of these. Sometimes if you're just starting out and you're just building a roll up, or you're just trying to check out arbitrum, nitro or Opstack, you might only care about the light node RPC endpoint. That's all you need to submit blobs and retrieve them. But perhaps as you start going deeper into the stacks and whatnot, or testing, et cetera, you might want to look at other RPCs. So this is actually very useful because it gives you the endpoints for Comet and whatnot. But even cooler, in my opinion, is that, as I mentioned before, one of the biggest pain points of sort of like developing or testing anything locally, when, for example, using a light node for mocha or arabica is having to request funds from the discord server and whatnot.
00:25:49.150 - 00:27:00.758, Speaker A: And even with a local devnet, like a docker compose setup, sometimes maybe you change keys and you forgot. The other day I was helping someone during a hackathon who for some reason was trying to use an old docker image for a local devnet, and he couldn't figure out which address had tokens, which that's not really fun. So with Apollo, you actually have a faucet, right? I don't have an address copied on the slides, but assuming I did, you could enter this address into the faucet. We might try that now if time allows. But basically you enter your address, you request fonts, you get set address, sorry, you get set testing tokens that would allow you to post the blob to this local devnet that allows you to run this local devnet in the first place. The other component that's important to highlight is this Celestia da server. This is a recent addition that I did to, to the arbitrum nitro integration.
00:27:00.758 - 00:28:26.780, Speaker A: The reason behind that is, how do I explain this? The life of people that work at ras companies and the life of solutions engineers such as myself has been essentially burdened by dependencies and go mod replace and cargo crates and whatnot. And obviously Celeste is not the only da layer, right? So there's like this sort of issue where modularism, not maximalism, but like from the point of view of any of these roll up stacks, who wants to all of a sudden upstream a bunch of new dependencies, a bunch of new code changes, etcetera. So the solution to that actually kind of comes from what Josh Bowen once told me is the good old pattern of things at Google, which is you build a proxy to the proxy. So the DA server is not really like a full on server. It's just like a little shim that connects to the celestial lite client that's currently running on Apollo. And what this does is that it has the right interface to allow the arbitrum nitro rope system to communicate with it and then relay the request to the light node to submit blobs, fetch data, et cetera. And then if I can find.
00:28:26.780 - 00:29:18.950, Speaker A: Yep, and then we have actually our roll up, which it built. But now I have an issue. So let me see if I can make this bigger and we can see what the issue might be. Again, I built this today for the recording. If you're watching this anytime in the future on YouTube, this is probably already fixed. But for now, for this workshop, let's see if we can try to figure out what the issue might be. So it's having an issue estimating the gas it might be because like I mentioned, these systems tend to change very frequently, and sometimes the arbitrum, the option labs folks, change stuff, and then I have to make sure that my stuff is now compatible again with their stuff.
00:29:18.950 - 00:30:03.500, Speaker A: It's, trust me, not really fun. But overall, I guess the entire point of this presentation is to showcase that running a roll up is not as complicated as people think it is. Obviously, RaSp providers are a nice way of interacting with a Uihe and with the person and not having to deal with any of these things. But there's also other solutions and tools out there. One that I've heard frequently mentioned is kurtosis. So you can use something like that to orchestrate all these different things. And you don't have to be a maniac like myself with four terminals, open a website and a bunch of other stuff.
00:30:03.500 - 00:30:50.290, Speaker A: And additionally, if this is running, I can maybe use this last couple minutes to sort of highlight the fact that now you can build with stylus and select CDA together, which again, in my opinion, it's a really powerful and cool combination. And let me see, in the meantime, as I try to maybe fix this quickly, does anyone have any questions that they might want to ask? I'll give it to the crowd if anyone has any questions if not, I will. Yeah.
00:30:52.110 - 00:31:02.010, Speaker B: I kind of forgot, like, where, like, the integrations with, like, the various crafts providers are. Those are kind of all automated, and now this is, like, ready to ship on.
00:31:04.810 - 00:31:41.298, Speaker A: Yeah, great question. So the question is where the integrations sort of, like, stand and have they been audited and are they ready to be used with different RAS providers? The answer is yes, with an asterisk. So what I am showing right now today, like the is version three 0.0, which uses stylus. I can't promise this is mainnet ready because arbitrum one itself has not upgraded to stylus. Once that happens, I would say, yes, it's safe to use this. We are audited.
00:31:41.298 - 00:32:37.958, Speaker A: So the changes made to three 0.0 are the same changes that were audited in two 3.3. So that means today you can go to someone like conduit, you can go to someone like Caldera, and you can deploy one of these arbitrum nitro rollups with Celestia da. You won't be getting stylus until that upgrade is enabled by the RAS providers. But again, the changes to support a Da layer are, once they're done, there's no changing them unless the underlying system changes itself significantly. What I mean by that is that obviously there's this simple change of post my data to Celestia instead of Ethereum, and then retrieve it from Celestia. That's pretty simple auditing.
00:32:37.958 - 00:33:28.710, Speaker A: That was probably the easiest task of the auditor. The challenge comes with trying to integrate, for example, with the fraud proving system and making sure that that one stays sound like the original fraud proof system, and two, that there's no bugs. But again, that was audited by Ottersec. The audit is completed, and basically everything that's two 3.3 for nitro and above is like mainnet ready. With the caveat that anything that hasn't been enabled, let's say, like arbitrum one, probably still needs some time to go on to, like, maintenance. But, yeah, let me see.
00:33:28.710 - 00:34:04.340, Speaker A: This is honestly just giving me errors. And I. I don't think I can fix it in four minutes. But if you are watching this workshop on YouTube, probably by the time you're watching it, this is already fixed. Again, apologize. There's nothing I can do. Also, about my Wi Fi at my hotel, I've been working on this this entire week, but to no fruition.
00:34:04.340 - 00:34:28.890, Speaker A: Because, yeah, I mean, sometimes for some reason, Docker doesn't build with hotel Wi Fi, but it does with my coworkers, like hotspot. So, yeah, if there are no other questions. I am probably gonna end it here. And yeah, have a good rest of your day everyone, and hope you enjoy the rest of modular summer.
