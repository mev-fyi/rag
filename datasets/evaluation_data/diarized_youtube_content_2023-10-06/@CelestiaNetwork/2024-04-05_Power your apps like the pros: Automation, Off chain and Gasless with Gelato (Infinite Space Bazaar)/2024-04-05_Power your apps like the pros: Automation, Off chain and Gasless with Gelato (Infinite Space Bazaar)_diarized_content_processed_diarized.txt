00:00:02.880 - 00:00:40.294, Speaker A: Awesome. And we're live again. I'm going to have some fun with these effects once more. Welcome everyone and GM, GN or GE, we're glad to have you here. Thank you for tuning in for this workshop for the infinite Space Bazaar. We're going to be learning about automation off chain data and gasless with Gelato. So I'm joined by joined by Javier from Gelato, and I'll let him do a quick intro and then take the floor.
00:00:41.554 - 00:01:37.588, Speaker B: Yeah, thanks, Jos, thank you for having me here. So, I'm Javier Donoso. I'm the head of developer relations at Gelato, and I'm helping the customer integrations, our customers to integrate all of our products. I'm very excited to be here and share with you some insights so you can build on this hackathon, and specifically because we have a testnet built with Celestia that we can test afterwards. So first of all, I would like to give us a short intro that I'm used always to talk with our customers. So imagine when you come to web three, that you have to create an app. So at the beginning, when you start to participate in hackathons, as you are doing right now, then you think that you're going to have a front end built in react and some smart contracts and then you are good to go.
00:01:37.588 - 00:02:48.274, Speaker B: But as it happens, like it happened to me when I started building on hackathons, then at the end of the day, you need much more things. You need indexing, you need job scheduler, you need off chain data, you need somehow to relate transactions if you want to offer gasless transactions to your users, you need notification, maybe you have somewhere above to keep your private keys. And now if we think that since one year more or less the app change, the ability to have your own chain is very high, then you will also need to spin your chain. So all of this is actually very complicated. And you as a developer, you should be focusing on building your protocol, building your custom logic, building your awesome application for your users, not building the infrastructure around it. Because imagine if you have the chance and your protocol scale, you have to scale and maintain different server resources. You will need to manage multiple RPC connections for higher reliability, and you will need to pay different service providers.
00:02:48.274 - 00:03:52.566, Speaker B: You will need to have some support other chains if you want cross chain compatibility. And you will need to store somehow the key. So at the end of the day, you are wasting some time in developing things that you should not, that someone else can develop for you. And you are only the single point of failure because you are concentrated on building infrastructure and infrastructure should not be the limit in your development, your custom logic should be the limit. So that's why we actually created gelato. Sometimes when I remember back in the days when someone asked me why your customers need gelato, and I always say that actually we try to solve the job the customer has to do. And in this case, the job of the customer is to have their protocol with the best infrastructure and on the best blockchain possible.
00:03:52.566 - 00:04:52.810, Speaker B: So that's why we launched last year the gelato roll up as a service where we have different tech stacks like optimism, Polygon, arbitrum. We have also different data availability like Celestia. Then we have overset of services among we will see later in detail. But we have automation, off chain data randomness or account abstractions, and all of the things that are required to build on your blockchain, like block explorers, KYC wallets, off and on ramp, everything that actually are in the normal classical evm chains. And you will also need to know on your roll up. So when we think about the services, and probably gelato is already well known for all of these services because we started in 2021. So these are what we call our middleware services.
00:04:52.810 - 00:05:30.638, Speaker B: Our middleware services are first web functions. Here we have a way to very easily automate, get off chain data and then publish transactions depending in your custom logic on chain. And here we have different use cases and customers like the ones that are shown in the slide. We also offer relay. Relay is the ability to send transactions on chain where you can sponsor the cash for your users. It means that for your user is cashless. This is one of the features that most required to have broader adoption.
00:05:30.638 - 00:06:31.004, Speaker B: And we offer also the possibility that to pay this on chain with a transaction while the transaction is executing, or with an off chain mechanism that we will see also afterwards we also offer randomness. We work with the different network and we get the random numbers, we verify the signature and we push them on chain. We also have chain incompatibility mode for protocols that have already their contract audited and they want to go to another chain, but they don't want to change their contract. So we offer the ability to use this chain link compatibility mode so they don't have to change anything on the contract. And we also have account abstraction. We are integrated with the Safeco SDK and we have our bandle CRC 437 compatible and we have a partnership with Zerodev. Actually for the builders in the hackathon, for the audience, this is the most important part of this presentation.
00:06:31.004 - 00:07:39.740, Speaker B: Here you can start to perceive the kind of services, the kind of features, the kind of cool project that you can build. We will see later on some ways how we can create a very simple perpetual protocol where we will have setting the order and getting the price from the BIF network oracle where how we can relate transactions and how we can execute transactions, depending whether a position has to be liquidated or not. And we will do all of this hands on. So web three functions and that will be our main part of of the presentation. So we write our code on typescript. It can also be solidity in solidity, but the examples that I prefer are on typescript. Once we have our code tested and ready to go, we upload our code to ipfs and we receive the CID, the IPFS hash.
00:07:39.740 - 00:08:48.918, Speaker B: So our network of executors are running this code upon the triggers that you decide. They can be every second, every second, every 2 seconds, every block. They can run upon certain events that happen on chain or they can run as a schedule like a cron job. So once this run, when this run is happening, then the code says whether it has to publish some transactions on chain or not. We can also query some off chain data for any HTTP API endpoint that we want and then we send the payload to be executed on chain. So the gelato protocol forwards the transaction to the target contract and the target contract is executed. So as a summary, we have a typescript code uploaded to ipfs that is pickup by the gelato nodes and then is run.
00:08:48.918 - 00:09:54.174, Speaker B: And in case a transaction has to be executed, is published on chain. So this is more or less the way how our web three functions work. We can see here the different protocols that more than 500 that they have already integrated some of our services, you see here almost all of the big names in the space. Pancakeswap, Quentas, Synthetix, Bjorn, Abracadabra Ave maker, the office most of the big names in this space. So specifically for the hackathon we have $5,500 in Yale. This is the binti the bounty and it has to be the most important premise is that it has to be deployed on our testnet. Raspberry Raspberry, as I said at the beginning, is an ops stack blockchain with Celestia beta availability that we have deployed in production quality mode.
00:09:54.174 - 00:10:48.050, Speaker B: And we have also all of the different services on this network. We have functions, we have relay, we have BRF and a lot of partners, as we can see we will see afterwards, are already deployed there. So a lot of interesting stuff to build some bounty to encourage more to build. And let's see how easy can we do this. So in this purpose use case we will see first the low latency oracle. So the low latency oracle, we have a user that it wants to set an order in the perpetual contract. The web three function is listening to this set order event in the perpetual contract then runs the code that we have prepared in advance.
00:10:48.050 - 00:11:40.804, Speaker B: It queries the price from the oracle. In this case we are using the pist network, we get the price and then we settle the order. So with this flow we can ensure that the price that we are getting for this order is verified on chain. Because when we are sending the transaction on chain, this transaction is doing in our smart contract two things. First, verifying updating the price in the bit network contract on chain, getting the price and do the custom logic in this case setting the order. So let's have a look in first of all our repo, if you want we can provide this repo, this open source with the different examples. So here we have our contract.
00:11:40.804 - 00:12:42.094, Speaker B: This is, I think it would be better that we go afterwards to the, to the contract. Let me, let me also explain something about the testnet so that you understand where we have, where we can start. So here we have the three public testnets that we have already prepared. The one that we will work in today is the celestial raspberry which the OPI celestia raspberry. And when we go there, here we can the URL for this public testnet, I will provide it afterwards but it's very easy. Ras network public testnet so we are here in the op celestia raspberry we have, it's a testnet. The settlement layer is a polya.
00:12:42.094 - 00:13:24.734, Speaker B: We have the chenid, we have the block explorer is this one is the classical block scout explorer. So we also have the ability to breach assets. If we click here on, we will have to breach sepolia. It takes around three minutes. So in this case it asked me to switch to Zeppolia. So now in three minutes I will have more. Sorry, I have to choose, I'm going to choose 0.5.
00:13:24.734 - 00:14:16.884, Speaker B: And now bridging the funds. I should have the funds in my network, in the op celestial raspberry in around three minutes we can see the transaction in the l one or we can see the balance in the l two that we will see increase in some, in some minutes. So this is the bridge. We have also a transaction debugger and we have, which is important for us is the RPC that we will use for our hard hat project that we're going to see in a moment. Actually, I jump faster than I should before. So now let's go to our hardhats project, our repo, and let's have a look into our contract. So we have some state with orders.
00:14:16.884 - 00:15:00.164, Speaker B: That is not really important, but it's not worth mentioning right now. We instantiate the so called ERC 2771 context that we will see later on why we need this when we want to relay. And this is what we're going to focus on. In the first example we have here the set order and it emits the setorderevent. So first of all, we're going to deploy this contract. So in order to deploy and verify the contract, we will go to our hard hat config here. I have some parameters I need for the both three functions to execute and to query the price.
00:15:00.164 - 00:15:49.144, Speaker B: What is important to notice is that the web three function has a plugin that we instantiate like this. So we are able to test everything locally. And you cannot imagine helping customers how often when they discover that they have the ability to do end to end testing with a fork network, mocking the web three function and receiving the results of the calls. Actually it is like a three x speed developing compared to before, so we will see it later. So one thing is we have to create this object so the hardware plugin can work. We have here the different networks and in our case is the raspberry network. This is the RPC that we saw before.
00:15:49.144 - 00:17:14.044, Speaker B: This is normal stuff for every project that we know and we have developed what it is specifically for the custom chains and that are not yet established, is that in order to verify them programmatically, we have to pass this object where we define the API key here is not important what we put, but we have to define in the custom change array one object with this information, the same name as appeared here with the chain id and the block explorer API, which is the same for the blockage cloud explorer. One other thing that we have to do to be able to use this configuration is to import the hardhat etherscan. So we installed the nomic labs hardhat and Etherscan. We create the BRF object, we include the network definition of raspberry and we paste the custom change to configuration so we are able to verify. So let's do this. And first we start the live demo. Yam deploy network raspberry so it looks like it's deploying perfect.
00:17:14.044 - 00:17:50.954, Speaker B: We are using this, we are using here this deploy script. So now the contract is deployed, we're going to see it in here. Okay, the contract is created. We have here the bytecode. Perfect. So let me do a little bit so I don't need to. Okay, perfect.
00:17:50.954 - 00:18:58.244, Speaker B: So now what we have to do, we go ahead and verify the contract and we will do it passing the contract plus the params that we need as constructor arguments, which are first the gelato messenger. We will come to this later. For now bear with me, I will only copy it. We have here the gelato messenger. The second is the peace contract, which also I've defined it here. Sorry. And the third one is the trusted forwarder that we will see what is the use for where we see relay.
00:18:58.244 - 00:19:31.764, Speaker B: So perfect. Now if. All right, blueberry, sorry. Actually as I've, I did wrong, it's not blueberry is raspberry. As we are having different networks, sometimes it's easy to get it wrong. Okay, raspberry, perfect. So it should.
00:19:31.764 - 00:20:22.736, Speaker B: So we're gonna wait for the verification, but we can see later that it works. It's taking some time. Fair enough. Now let's have a look how we create this Webtree function that will do all of the heavy lifting for getting the price from the network and verify and sending the price on chain. So in this folder we have the folder web three functions. Here is where we have our different web three functions and we will start with the Oracle keeper. This one is the one that we saw in our chart in our presentation before.
00:20:22.736 - 00:21:18.664, Speaker B: That is listening to the set order event. And once this set order event is happening, then it will get the price from the pit network and it will publish on chain. So let's see how it works. We have here this method, this on run method, and here we have our different context that we pass with the web three function and we have all of this information available while the function is running. In this case we have some arguments that it will be over contract and our price feed, then the storage that we are not using. Then we have a multi chain provider. The multi chain provider allows you to, you can instantiate the multi chain provider with the default network where the web three function is targeting, but you could also create another provider like say chain id 137.
00:21:18.664 - 00:22:25.984, Speaker B: So in this case you would have a provider already available for polygon where you can do any RPC calls. You cannot execute, but you can do any RPC calls. So here we get the arguments and here we start querying the pit network for the price. So we have here the establish the connection we get the price, we create the price object and then we instantiate our contract that we have just deployed. And we, as this web three function is going to, is going to be triggered upon an event, we also want to get the parse the event. So we have the relative information, the information there. So we get the current price from this price id and then we simply encode the function data for this update, update price orders that when we go to our contract we have seen that this is the set order that triggers the event.
00:22:25.984 - 00:23:31.760, Speaker B: And once the web three function is going to, is going to run the update price order. And we can see here the only gelato messenger, that is one of the parameters that we have passed in the constructor. Every time you create a web three function, we create a proxy contract that is managed by you and it's an additional security layer so you can actually gauge the executions of this method. Then this method can only be executed by the gelato web three function. So going back to our index here we have the, we have prepared the data to be executed and then we return Canexec equal true and an array of transactions to be executed. In this case we only have one. And in the case that we decide nothing, that nothing should be executed, then we will return, can execute to equal the files and a message that we will see later on.
00:23:31.760 - 00:24:07.544, Speaker B: So now let's have a look on the, on the testing. Okay, the verification is hanging. I don't know why. Let's, let's have a look again. Okay, let's, let's have a look whether it's already verified. Yeah, apparently it did verify properly, but it didn't send back to hat the message that it was already verified. Good.
00:24:07.544 - 00:25:11.024, Speaker B: So now if we have a look in our tests, we will first run only the one for the Oracle keeper. So, so let's see if we are ready to go John test. So perfect. It is a passing. So I'm able to, to deploy, so I have already prepared the deploy script. This deploy script is deploying the IPFS code, sorry, the code, the typescript code to IPFs and it will return a CID, that is the IPFs hash. So we do this here.
00:25:11.024 - 00:25:50.624, Speaker B: Perfect. We have already the CID, which is important for later. So now we have already our code on ipfs and now we have to create a task that will run when the event is fired. So we go again. Now we go to our gelato app. Here in our gelato app we can see our functions, the relay, the VRF over services. So we go ahead and create a task in this case it's an on chant event in raspberry.
00:25:50.624 - 00:26:20.830, Speaker B: Perfect. We go to Raspberry. So we go to our contract address. I'm sorry, that was a test. We have here our contract address address. Perfect. So we go here and we input our address here.
00:26:20.830 - 00:26:55.854, Speaker B: We have the ABI decoded so we can click the event and we say that we want the typescript function. And I'm going to go ahead and copy the CID that we just deployed to ipfs. Perfect. And then it's asking me to, sorry, this is not the correct, the correct one. Let me see. Actually it was not this one to deploy. It's not the trigger order, it's the oracle.
00:26:55.854 - 00:27:29.274, Speaker B: So we should, this should be the one. So, perfect. So this is the CID for this example. So let's go ahead and input the CID. I see that. Let me refresh because maybe with all of this hiccup is not working properly. Create task on chain event.
00:27:29.274 - 00:28:10.124, Speaker B: I go here, I copy the contract. I take the set order event typescript function. Then I go ahead and copy the CID. And then I have to pass the contract again as an argument and I will also pass the price id that we are querying. But this, I can have it from my object here. This is definition here. So I'm gonna go ahead and copy this.
00:28:10.124 - 00:28:50.638, Speaker B: Perfect. And we're gonna call it set order infinite Bazaar, or maybe we call it the other run. So we'll have three altogether, infinite space. Perfect. So let's go ahead and create our task. It should work so nice. Let me wrap again the contract because we will need it just later.
00:28:50.638 - 00:29:28.094, Speaker B: So we're gonna go and we have prepared a small react app where we have the contract. Not contract. I think it, I think it was called like this. No. Okay, so this over there is here get permanent. That's why. So we have here our contract.
00:29:28.094 - 00:30:01.530, Speaker B: We will then Yamo start in between. Let's have a look if our, let's have a look if our transaction did perfect. The function is active. We don't have any executions. We don't have any logs here we can see the code, the code. And in this case we don't need storage or secrets, which are secrets. You can save some specific API keys that no one should see.
00:30:01.530 - 00:30:46.066, Speaker B: You have the ability to do this. So now is the moment of the truth. Let's go ahead and, okay, we have here, let's see. The inspection is going to be a lot of errors because it's a very, what is happening is happening something because normally it should. What is happening here the is not working. The the bit network API. Actually it should here now.
00:30:46.066 - 00:30:59.934, Speaker B: Okay. Okay. It start to show some prices. It's actually querying every 2 seconds, 3 seconds the price. And then we say that we want to create an order. So let's create an order. We confirm the order.
00:30:59.934 - 00:31:40.780, Speaker B: We wait a moment that the order has been finished. Actually if we go to the contract probably we will see that the contract. You can see how fast is this network because already transaction has been executed. Actually here we are waiting for the feedback from the contract, from the event. Sometimes depending on the RPC gets some. It needs some time. Okay, if we now go to the gelato app we see here there is an error.
00:31:40.780 - 00:32:10.832, Speaker B: Okay, that should not be. There is an error. I pass correctly the address. I pass correctly the QM normally we should see here the executions. I don't know, I don't know. Let's move forward normally here we should see that what we just did execute properly. I had prepared one other task this morning that is the same.
00:32:10.832 - 00:32:41.702, Speaker B: And I want to show you so you can see what are the expected results. That was the so called celestia order. And here you can see that the is triggering every time there is an order to settle. And when there is an order to settle then execute the transaction. And here we can see the different transactions I tested. So this is normally what we should have received in this live demo. Sorry for that.
00:32:41.702 - 00:33:35.034, Speaker B: If we have some time afterwards we will do it again. So the second point which is interesting, I'm going to stop the overreact app. And the second point that is interesting is now what we have seen is that we have sent transactions to our contract. But what if we would like to sponsor the gas for our users? What if we would like to offer guestless experience for our users? Then we will need to use relay. So I prepared some schematic presentation about the relay concepts. This is what we just did. Our user is sending a transaction to a smart contract.
00:33:35.034 - 00:34:28.644, Speaker B: And the contract can read the message of sender which is the user and the message value. So what happens when we want to relay a transaction? When we are using our relayer, it means that someone is sending the transactions on chain. It means our gelato relay. So the user sends the HTTP request to the gelato relay contract. Then the gelato relay contract which is on chain for sure forwards the transaction to the smart contract. And here, as you see there are different things that have to be kept in mind. One, the message sender is not more the user.
00:34:28.644 - 00:34:58.542, Speaker B: The message sender is the gelato icon. And this brings sometimes some confusion. So the second one is that there is no possibility to send value. There's no way to attach value because the value should be attached from this user that is sending the transaction. So and here we are sending an HTTP request. We are not sending any value in any transaction that we can transfer value. So the message value is not possible to be transferred with a relay transaction.
00:34:58.542 - 00:36:18.344, Speaker B: So what we see in some of our customers is using the permit function on ERC 20 tokens to be able to send transactions to transfer tokens that within the transaction has encoded the signature for the permit method. So then how these transactions are paid, because at the end of the day you are sending here, the user is sending a normal HTTP request to our gelato relay backend and we, gelato are pushing the transaction on chain. So it means that in this case we are paying for the, for the gas cost, for the gas fees. So what options do the user have? Does the user have to pay back the gas fees? So we have two options. One is the off chain, one balance we have on polygon where you can deposit USDC, and then this USDC on Polygon will pay for all of the chains where we are for raspberry. Also in the case of Testnet, we should deposit some sepolia is on Sepolia. Moving forward we will also accept USDC payment in other networks.
00:36:18.344 - 00:37:18.234, Speaker B: But for, for the time being, we have one gas tank with USDC on Polygon and all of the transactions for mainnets that our users are doing through all of the networks are paid with this one balance. And the second way of paying, of paying the transactions is using the so called syncfi methods. The syncfe methods are, are some helper methods that you include in your contract. And while the transaction is executed, you query the fee details and you transfer while executing the fee to Gelato. It's also possible we have some customers using it. It's a little bit less efficient because as here, all of the accounting in one balance is on chain and only we push after several hours. American route on chain is much more efficient because all of the heavy lifting of the accounting is happening off chain.
00:37:18.234 - 00:38:24.902, Speaker B: So the one balance is also important because it's also how we pay the web. Three functions, executions as we saw before. So another thing which is very important is we saw that the message sender is not the user sending the request is the gelato Lake contract. But what if I need the information about the user, how I can be sure that in the transaction, if you want to append the user that actually this user is sending this transaction. Then in order to do this, we have the ERC 27 71 methodology. And the way how it works is that the user sync the HTTP request off chain. Then before when we send the transaction, our metamask pop up, so we can sync the transaction and pay and confirm the transaction.
00:38:24.902 - 00:39:33.318, Speaker B: Here it will pop up so we can sign the transaction, but we don't have to pay anything. So this signature is append with the payload to the request it sent to the gelato relay, and we decode the signature to check whether the user sending this transaction is the one that signed the payload. We will do this with EIP 712. So once we do that, we append the address of the user to the call data. So in the smart contract implementing the ERC 27 context, we can slice the 20 last bytes of the call data. And this is actually our address, the user sending the transaction here. It's very important that we only accept this when the contract sending this transaction is over trusted for Wardour.
00:39:33.318 - 00:40:54.234, Speaker B: That's why when we saw before in our contract that we passed the trusted for wardour is to ensure that no one can send any payload with any appended address at the end of the call data. So ensuring that only we accept to the code the address when the trusted forward that is later a contract. Then we can do the step three and decode the original user. It's always when we talk with our customers, we reinforce this message that is very, very sensitive because once you have the code, your user in your contract, and you can act as the one sending the transaction is your user. So you have to be sure that the one that is telling you that this user is legit is our gelato relay contract. So if we go ahead to, if we go ahead to our UI and here we will see the set order sign. Let's go ahead and look for the method.
00:40:54.234 - 00:41:35.774, Speaker B: Set orders, set conditional, order, set execute margin, order, set order, gashless. Here we're going to see how the implementation looks like normally in what we saw before. We will only have the prep mark contract, which is our contract that we have deployed, and simply set order and passing the value and it will execute. Here we prepare the data by populating the transaction. It means that here we have the payload that we're going to send. We pass the chain id. In this case, it's raspberry.
00:41:35.774 - 00:42:36.224, Speaker B: Here we have the target contract. Is the target receiving our payload. Here we have the data and the signer address, the one that is going to sign the transaction. Then we do a very simple sponsored this is our SDK and here we have our sponsored call, which is the method that we are going to call passing the request the provider a gelato relay API key that we use so that it will be decreased from your one balance and we will receive the URL where we can see the status of the call. So let's go ahead and do it again. Perfect. We are here, this is working.
00:42:36.224 - 00:43:41.778, Speaker B: So I'm going to click gaslit. Now when I'm doing setting an order, we should receive the metamask that is going to pop up and asking us to sign, not to confirm the transaction. Now we are relaying the transaction and now very shortly we will see the hash, the transaction that we can see now that already have already succeeded. And actually we have mimicked the transaction that we have seen at the beginning. But here with relay, let's have a look if our function in this case has picked up properly the let's see if we have the error. Yeah, normally if we don't change anything, it should be the same error. So I think I could show better, more than debugging, probably something that is I forgot to update or to change.
00:43:41.778 - 00:44:24.920, Speaker B: I think it's better that we see the different use cases that we also have in our report. So let's go ahead and see the next use case. The next use case is actually a little bit different. We have orders, but we don't have orders that have to automatically be settled. In this case we have a conditional order. Imagine you have your price at $3,000 if, and you say I want to execute this conditional order when the price is 5000 or when the price goes down to 1500. So we create, we send the transaction to our contract.
00:44:24.920 - 00:45:30.454, Speaker B: We will see the method here. This web three function is not reacting, is not only triggering, when the event is happening is constantly like in a 5 seconds interval or 2 seconds interval, querying the events from this perpetual contract. And in the case that it found some events that matches the conditional order method, it will then store in the web three function storage that before we saw that we didn't use it. Now we're going to use the storage and then every 5 seconds is going to check all of these orders. We will create an array and every time it checks whether we receive a price from from the pit network and whether the price it makes that the conditional order executes, executes or not. So let's go ahead and see the code. This is the second use case, the conditional order.
00:45:30.454 - 00:46:48.394, Speaker B: Here we call it trigger or what? So we have here our, we don't have log as we have before because now we are not only listening to a log, actually we are storing in our storage the last process log that we analyze and we also store and get the array of orders that we want to execute, that we want to check by every run. So we instantiate the contract, we do the connection as we did before with PiS. We get the price, we prepare the price object. And here we are going to read the events directly from the contract and we are going to read between different block numbers and it's a kind of loop. So, and here what is important to retain is that we push the orders to an array and then we check whether the price is above or below depending on the logic. And then we prepare the orders ready to be published. And I restore the new last process block and the new orders to fulfill without the ones that are going to be executed.
00:46:48.394 - 00:47:33.244, Speaker B: And in this case if we have some orders to execute, we return the payload as before. And if not then we can select the remaining orders and we say not orders to settle. So if we have a look into the contract like before, we're going to see set conditional order. This is the events that we're going to use to query the logs from the contract. Not, we are not listening to this event. We are triggering the function every 5 seconds. And this is the function that it will get executed by the web three function as we see the Onigelato message sender.
00:47:33.244 - 00:48:35.054, Speaker B: So let's go ahead and deploy this one. Maybe in this last minute that we have is going to work. I don't know if I'm doing something deploy order. We could run the test. I run it before they were working and maybe from the test is very interesting to notice what I said before about the end to end, the end to end testing. Okay, here, let me see. Probably in the next, we won't have time to go over the next example, but it's maybe worth have a look here at this.
00:48:35.054 - 00:49:14.964, Speaker B: Exactly. Here we see in our test that we get the web three function code and we will run this web three function locally. This web three function, remember what we saw in the code. Return a call data and target address so we can execute this locally. So this is about testing. We don't have more time to look at this in detail but let's have a look. And we're going to deploy to the functions, we're going to create one more function.
00:49:14.964 - 00:50:23.554, Speaker B: So in this case we're going to execute every 5 seconds, we have our typescript function, in this case, it's asking me about the contract. Ah, I know, I know, sorry. Actually we have to pass always a small fee to p's when we execute, when we update the price, and this contract has zero balance, so let me go ahead and. Yeah, CCC, so we are in here, this is the contract of the address, and I want to, it's only one way that actually the contract transfer. So the list the last five minutes, at least we're going to see that it works. Okay, we have already 0.1, so now let's go again and set one more order.
00:50:23.554 - 00:51:39.302, Speaker B: We will do it with relay again, why not? You want to see the transaction? It executes, perfect. And now the only thing that we are waiting is that our all settled order task, which is the infinite space bazaar exec pending, perfect, Bravo is working. So now we will have the execution, the next seconds, it will execute it. Perfect, it has executed. And now if we refresh, we can see that actually we have the published time from this order. In this case, we can see that it took 8 seconds to do all of the journey from relaying the multifunction, waiting for the events, running the code, getting the price from P, and then publish the transaction on check. And we are on a testnet, so our backend is not so performant as in on production.
00:51:39.302 - 00:52:19.634, Speaker B: So I think we could have a look, we could deploy the next web three function, but I think that the process is actually the same. So I think that is better that we allow the users to have some questions, the viewers, if they have a specific interest in some of the parts that we have discussed. I'm happy that at least at the end we could see that the web three function was working. So without anything more to say, then I think here is where my presentation finished. Happy to take any questions that are, that are asked.
00:52:22.934 - 00:52:43.514, Speaker A: Awesome, thank you, Javier. I think the first, I don't think we have any questions in the chat. Yeah, at least not on YouTube. But I am curious, you showed us using hard hat, I was wondering if developers can use foundry as well.
00:52:44.974 - 00:53:12.534, Speaker B: Yeah, you can use foundry for doing all of the tests, but for the plugin to do the testing, like the end to end, you cannot use it. You will need to call the web three function normally, get the call data and pass it to the contract, but easily you will have to do some more steps. It's not so simple as this. That is only one line that it says, get web three function, run web three function, get called data.
00:53:13.394 - 00:53:22.734, Speaker A: Thank you. Yeah, it's always, always fun to do live demos, but it's always funny to see what you run into. I'm glad you figured it out at the end there.
00:53:23.234 - 00:53:42.614, Speaker B: Yeah, and the thing is that I tried twice today and it worked and then I didn't change anything. Then you were thinking why it doesn't work now you don't have any. But then it was still true that we have to fund the contract.
00:53:44.674 - 00:53:54.574, Speaker A: Yeah, I guess I'm curious if you have any suggestions for the hackers on what they could build with Gelato other than what you showed us today.
00:53:55.434 - 00:55:23.656, Speaker B: Yeah, I think that any project that tries to provide some user experience that is beyond what we see, we have shown, for instance, the guideless experience. But still you have to sign every time. Probably you could have a proxy contract somewhere, create some session keys locally, and then with this session key validated in this proxy contract, probably if you know how to do it, you could have a signless experience where you only sign once, and then you can send all of the trades without any, without any signature more. This is something that maybe is interesting when you want to showcase your project. So anything that is related to off chain data lottery with BRF and any games. We have seen an explosion on blast of VRF customers and customers playing like math. And so randomness, a game that you can do signless, maybe a game where you can also buy some weapons or lend some weapons, because you can with automate, with web three functions, you can ensure that the user is going to need give you back your weapon.
00:55:23.656 - 00:55:59.360, Speaker B: So all of these kind of things that you can, all of these features that can make your application stand out like a normal web two game, for instance, or logd or anything. Actually we have seen so many things today. I was in a meeting with, with Cedram that actually they are using us for breeding the horses and for landing the horses. Cedran is a horse race, a digital horse race. They are using us for this. We also have very, very interesting projects. Like we have one.
00:55:59.360 - 00:56:49.328, Speaker B: I don't know if you are aware about superfluity. Superfluid is like a streaming money protocol. And then we have one customer that has one protocol that it has a vault and it pays the fees to the protocol in stream depending on the total volume that is locked in the vault. So every day with gelato it calculate, it does all of the math for calculating how much should be the newest stream and then update the stream and then without nothing, without nothing to do. So now we have a lot of intensive protocols that they are testing like ostium and arbitram. That is going to be a perplex. That is like they're going to do everything with us.
00:56:49.328 - 00:57:10.276, Speaker B: So it's actually very interesting. We have these two categories, the middleware. That is what I'm more like helping developers customers. And then we have the ras, our chains, like the raspberry where we implemented Celestia, and we are very happy with. But this is more or less our different types of services. Awesome.
00:57:10.380 - 00:57:20.996, Speaker A: Yeah. Thank you again for the summary there. If I were a developer who had questions about gelato, where is the best place to reach out during the infinite space bazaar?
00:57:21.180 - 00:57:45.704, Speaker B: Yeah. I only know one person which is faster than me, and it's Aniruth and one of my team members. And he's probably already in discord. He's in India, so maybe late in the. For late times in America, he's not going to be there, but then I'm going to be there if he not there. So this course and tagging me, Donoso is. Or tagging Annie Ruth McCanna, who is actually already there.
00:57:46.484 - 00:58:07.720, Speaker A: Great. I'm going to do a last call for questions in the chat. I don't see any, but also, yeah, if you're tuning in now, we'll have another workshop in an hour. And on the note of gaming, we'll be going over the world engineering with Scott from Argus Labs.
00:58:07.912 - 00:58:09.664, Speaker B: Nice. Nice. Really cool.
00:58:09.824 - 00:58:12.784, Speaker A: It's a good segue into. You're talking about gaming.
00:58:12.944 - 00:58:14.244, Speaker B: Yeah, indeed.
00:58:15.184 - 00:58:16.244, Speaker A: Hi, Aniru.
00:58:17.464 - 00:58:22.600, Speaker B: We have to see your effects for saying goodbye, like at the beginning.
00:58:22.752 - 00:58:24.992, Speaker A: Oh, yeah, yeah. Thank you again, Javier.
00:58:25.048 - 00:58:25.800, Speaker B: I don't know if it'll work.
00:58:25.832 - 00:58:27.832, Speaker A: I put a like, green screen now.
00:58:27.888 - 00:58:30.216, Speaker B: No, but before it was nice. Doesn't know what's going on.
00:58:30.280 - 00:58:42.714, Speaker A: There we go. It's going to blur it out, though. Thank you again for teaching us about Gelato. And we look forward to working with Gelato for the rest of the ISP and beyond.
00:58:43.454 - 00:58:45.710, Speaker B: Thank you very much for having me here. I appreciate it.
00:58:45.822 - 00:58:48.094, Speaker A: Yeah, have a good one.
