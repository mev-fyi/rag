00:00:02.330 - 00:00:17.578, Speaker A: PB Espresso. This is not my idea. This is Quintus's idea. I stole it from him. He has all the creative ideas. So I'll be talking about PBS for shared sequencing and responsive consensus protocols. These are sort of two unrelated topics.
00:00:17.578 - 00:01:01.402, Speaker A: Well, maybe not completely unrelated because responsive consensus is Espresso's consensus protocol for shared sequencing. But the talk will be split into these two different subjects on PBS. So first, just to quickly introduce what is shared sequencing? So roll ups are horizontally scaling the application layer of Ethereum. The idea is that when you add new applications, then you can have those applications add new servers that execute. Some of those applications are roll ups that support other applications. But I view roll ups as basically applications that support other applications. And the layer one is now not doing any execution.
00:01:01.402 - 00:01:22.262, Speaker A: They are just verifying fraud or ZK proofs. It's also leveraging this heterogeneity. So you can have powerful servers on the application layer. You can keep the servers on the layer one very weak. They just verify proofs. They don't need to do any extreme execution. The problem is roll ups control a lot.
00:01:22.262 - 00:02:18.810, Speaker A: And that leads to the need to either decentralize the roll ups themselves and add some kind of decentralized process for each roll up to decide on the ordering of its own transactions or it moves us towards a different model where they share the L One. So the other problem which remains if each roll up just runs its own consensus protocol for its own transactions, is that they remain very isolated from each other. And so currently, even though we're sharding the application space of Ethereum, we're sort of ruining this amazing property that Ethereum has, which is the interoperability of contracts. One contract that you deploy can easily make function calls to another contract and they share liquidity with each other. So roll ups don't scale Ethereum without changing its fundamental properties. And that's not really scaling. That's scaling and changing the target.
00:02:18.810 - 00:03:22.698, Speaker A: So how can we regain the functionality of Ethereum as it is today while still scaling Ethereum? So one idea that has come out is for roll ups to share a consensus protocol for ordering transactions. So this is this idea of separating ordering from execution where the L One doesn't build or execute, right? The roll ups do that. But the L One can provide finality on transaction ordering, availability of data, verification of state proofs and transactions, submit directly to the L One and the roll ups just read from the L One and execute. So there's the question of does this give us interoperability? It's also good to note that this layer that's shared by the roll ups for ordering doesn't need to be Ethereum itself. It could be some layer 1.5 that sits in between. And the main reason for that is protocol modularity.
00:03:22.698 - 00:04:21.790, Speaker A: Perhaps we would introduce a new protocol that has the ability to provide faster pre confirmations than Ethereum does. Ethereum has slow confirmations time. So this is a reason to design shared sequencing layers that are not Ethereum itself, but some other protocol that sits on top, whose sole purpose is to provide a different property to roll ups, like higher throughput and faster finality. The concept is, though, the same users are submitting their transactions to the consensus protocol that is independent from the rollups. Roll ups read from this consensus protocol and only execute and report state results. So does sharing an ordering layer help interoperability if the ordering layer is not doing execution? That is the main question of the first part of this talk today. So I'll say there are three advantages, but I'll focus on one that has to do with PBS proposer builder separation.
00:04:21.790 - 00:05:18.530, Speaker A: There are also advantages such as simplifying cross roll up bridging mitigating systemic security risks for bridges. We've written about this in blogs from Espresso systems, but I will focus on this topic today of supporting cross roll up building with economic bonding. And what is this? So, first you've been hearing about proposer builder separation all day, but maybe everyone has a slightly different way of describing it. So I'll just do a quick review and present sort of my view. So, the proposer is a fundamental part of the consensus protocol because all consensus protocols today are based basically on leader election. If we use consensus protocols that are not based on leader election, then we might end up with something different. But consensus protocols like Ethereum and like the consensus protocol used in Espresso or Tendermint or any of these systems have a leader that is elected to propose transactions that then get ratified or signed by others.
00:05:18.530 - 00:06:04.130, Speaker A: So there's always a proposer. If someone says that we can remove the proposer, what it really means is that you can just use the layer one proposer and you don't need to introduce new proposers in the L2. But there's always a proposer from the system that finalizes the ordering of transactions. So builders today can compete and then produce a block. The proposer doesn't need to build a block. It can play this passive role of accepting a block from builders. And if we leave it up to proposer to do this and don't design anything into this building layer, then what ends up happening is a first price auction where the proposer will just accept the most valuable block that comes out of the builder network.
00:06:04.130 - 00:07:12.994, Speaker A: And so that's a reason to take a different design approach where either we might do this in terms of implementing some smart contract that introduces some rules that we hope proposers will follow, or it can be some kind of other ideal functionality similar to what Suave is designing that implements some kind of order flow auction among users and searchers. If we can design something that is not just maximizing the profit for the Proposer, but is stable and better for users and users are only submitting their transactions to this ideal functionality. Whether it's a smart contract or a protocol like Suave, then the Proposer will have no choice but to accept the block of transactions from this ideal functionality. Because there's no transactions going anywhere else. And this only works because the consensus protocol is decentralized. If the consensus protocol was not decentralized, then a proposer could say, I'm going to ignore this smart contract, this isn't good for me, I'm going to ignore this ideal functionality. I want people to submit to me the most valuable block.
00:07:12.994 - 00:07:50.770, Speaker A: I want to extract all the mev because I'm a monopoly, right? The decentralization of blockchains breaks this monopoly so that a proposer is a monopoly for only one slot. And that is why if we design an ideal functionality stable for users, the proposer cannot influence what happens. The proposer can either take it or leave it. If it leaves it, the next proposer will pick it up. The most it can do is delay. So that's why extreme decentralization is so important from an economic perspective. This is one of the most fundamental properties of blockchains from an economic perspective.
00:07:50.770 - 00:09:06.714, Speaker A: So proposer builder separation over shared sequencers looks the same as over Ethereum today because Ethereum is a shared sequencing layer. So if we introduce a layer 1.5, it's just introducing a new modular layer on top of Ethereum, which runs an order finalization protocol, but still has some proposer as part of the consensus protocol that will accept blocks from a builder network. And we can design that builder network to be smart and do things in a way that's good for users like Suave or some kind of smart contract design. So one of the things that I'm not going to really focus on mev as much as this problem of regaining interoperability and atomicity among roll ups that are sharing an ordering layer, is that through PBS, builders can actually make promises to users about atomicity and they can be slashed if they violate those promises. So a very simple example is the following. A builder can say, I will process your trade on optimism and your trade on ZKsync, which may be taking advantage of some arbitrage opportunity to two AMMS on the different roll ups, and I promise that I will only include them.
00:09:06.714 - 00:09:53.402, Speaker A: I'm building a super block for both roll ups and I will only include these transactions together if they both succeed. If one of them fails, I won't include either. And this statement can be cryptographically signed so it can be used as evidence against the builder if it violates this promise. So it can be slashed, it can build up a very large collateral that gives the user confidence it will respect its promise. And the builder then provides this to the proposer of a consensus protocol that's not executing at all, but is basically auctioning off wholesale a super block that produces a subblock for every roll up simultaneously to the builder network. Okay, very simple. Without a shared sequencer, this would not work.
00:09:53.402 - 00:10:43.770, Speaker A: At least it would not work as well. The builder would have extremely high risk that if it tries to make this promise to the user, it's possible that the independent sequencer or consensus protocol for ZKsync will accept the transaction, but the independent sequencer or proposer consensus protocol for optimism will reject it. Right. There is now two independent auctions and it doesn't have a guarantee it will win both. Whereas with a shared sequencer and a single proposer that is elected, there's one auction for both together. So the builder could be slashed and lose its high collateral, even if it doesn't do anything wrong. So that's why sharing a sequencer reduces the risk of builders, allows for more builders who can make these atomicity guarantees.
00:10:43.770 - 00:11:26.440, Speaker A: So the builders sit on this layer on top of the shared consensus. This is how it looks in espresso. A slightly more complicated example would be a flash loan. So let's say a user wants to get a loan from Ave on one roll up of 1 million USDC deposited into an AMM trading USDC against Dai. So now it can't immediately bridge its funds over and just deposit it directly into this Curve contract on roll up B. So we'll introduce a bank contract, and the bank contract is going to have a branch on both roll ups. Okay, so there's a branch on roll up A, there's a branch on roll up B.
00:11:26.440 - 00:12:01.614, Speaker A: We'll explain how the builder can ensure this atomicity of these two events. But basically, the user will send Dai to the bank contract on roll up A and it will get Dai from the bank contract on roll up B. Then it will deposit into Curve, get back its USDC and do the reverse. Right? Deposit into the bank contract on roll up B, get it on roll up A. I haven't explained how we ensure that those can happen atomically. I will in a moment and then return the USDC to Ave on roll up A and keep the profit. All of this needs to happen in a single transaction.
00:12:01.614 - 00:12:38.954, Speaker A: That's a flash loan. So how does a builder enable this? Well, the builder who's building the block for both roll ups simultaneously could provide a signature, again backed by some collateral. And that just gives an instruction to this bank contract on roll up B that says this action happened on roll up A. So you can release the funds on roll up B and the builder creates a super block. The bank contract on roll up B just trusts the collateralized builder signature. If the builder lies it's accountable and loses the collateral. And roll up B is not absorbing the risk.
00:12:38.954 - 00:13:21.534, Speaker A: All the risk is absorbed into the bank contract. So it can become a business to design these contracts and specify your requirements for what builders need to put up in terms of collateral and other possible conditions. And it's assuming some risk, but it can also be taking a fee. So this is an example of something that's enabled by shared sequencing, which would not work without shared sequencing, right? Of course, it's not exactly the same as what you can do on a shared execution environment, but it opens up a wide design space. And really, this is just a straw man simple construction. I encourage people to come up with more creative ideas. The builder signature would do the same for roll up a bank contract as well.
00:13:21.534 - 00:13:59.310, Speaker A: It's symmetric. There are some concerns that having builders execute for all roll ups may lead to builder centralization. The reality is that executing for all smart contracts sorry, for all roll ups is not actually that high a barrier to entry. Right? In fact, compared with ZK Proving, it's not that high a barrier of entry. ZK Proving is extremely expensive. It can be like 10,000 times or more expensive than executing. And the requirements of the builder market don't need to be the same exact requirements in terms of decentralization as the consensus protocol.
00:13:59.310 - 00:14:50.934, Speaker A: We need many, many nodes participating in consensus so that proposers act passively and don't monopolize. We don't necessarily need 12,000 competing builders to have a competitive market that takes care of monopolistic forces. So it can just be sufficiently permissive and open and free entry and have low enough barriers to entry such that it's sufficiently competitive. In fact, the barrier to entry for builders is much higher without shared consensus because builders take on more risk. As I illustrated a slide earlier, builders would require more capital to win simultaneous auctions. They would absorb more risk that can't promise user atomicity without the risk of being slashed. So where there's a will, there's a way it's better to have shared sequencing.
00:14:50.934 - 00:15:37.922, Speaker A: We will lower the barrier of entry for builders rather than increase. So now for something completely different. I will talk a little bit about PBS for responsive consensus protocols. So, Ethereum's consensus protocol is not responsive, meaning it has a fixed block time if that is 12 seconds, ethereum's finality is not actually 12 seconds. It's much longer than that because the transaction needs to be several blocks deep to be confirmed. So it takes about 15 minutes to finalize. In Ethereum, a responsive protocol does not maintain the extreme availability that Ethereum has.
00:15:37.922 - 00:16:24.790, Speaker A: These two properties are incompatible. But what a responsive protocol can do is it can give finality as fast as the network will allow. Fundamentally, it will stall if the network is not doing so well, whereas ethereum can continue even if only 10% of the network is live. So, due to the Cat theorem, these two properties are essentially incompatible. But optimistic responsiveness is the property that can get you as close as possible to the performance of a centralized sequencer in a decentralized way. The nice thing is you can compose them together because you could run optimistic responsiveness on top of a dynamically available protocol. So consensus protocols that can return an answer immediately under optimistic network conditions are called responsive.
00:16:24.790 - 00:17:15.398, Speaker A: There's no block time in responsive protocols. So how does this affect PBS? So, let's look a little bit at the round structure of Hotshot, which is based on PBFT and is a responsive protocol. In the first round, the leader proposes a block, collects back signatures, then it will aggregate these signatures, form something called a quorum certificate. It will broadcast it again, aggregate them and collect signatures on that. So again, this can happen if the network is very well connected, or maybe there's even a content delivery network that assists this to proceed at very high rates. Then, as soon as these signatures are collected, the protocol doesn't need to wait. It can just move on.
00:17:15.398 - 00:18:10.090, Speaker A: Finality has been achieved. So under optimistic conditions, we can finalize blocks as fast as the network will allow. The problem is, with PBS, if a leader has only one proposal before the next leader comes up, then it's incentivized to delay, because in order to run an auction, it could, for example, run the auction for longer and obtain a more valuable block from builders. So one solution is not to rotate leaders based on blocks, but rather to rotate leaders based on some time window. Okay? So we can allow the leader to propose and obtain finality on as many blocks as it wants, consecutively until this time window expires. I'm not going to go into the details of how you do that in the consensus protocol, but that's the main idea. It doesn't completely get rid of all incentives to delay, but it goes very far to mitigating this primary concern.
00:18:10.090 - 00:19:05.510, Speaker A: When is it safe for a builder to release data? So, in PBS, for Ethereum today, the builder releases data after receiving a block hash, and then it races with the proposer to relay that block hash in order to get that block accepted. And at this time, it releases the data because Ethereum nodes won't accept and vote for the block without receiving the data. Now, if the proposer proposes a conflicting block hash, it could get slashed. But sometimes that slashing amount is low compared to the amount of profit it could make from stealing the mev from the builder. So they really do engage in this race, and it's even possible for the next proposer to fork the block and steal the mev. So the protection for builders today on Ethereum is not actually that high. And I'll argue that it becomes a little bit better when we were looking at a responsive protocol.
00:19:05.510 - 00:19:56.218, Speaker A: With a responsive protocol, once a builder has received a signed proposal, it can ensure the network reaches strong finality within a certain time window and under good network conditions. Of course it's possible for the network to experience a fault. But it can gain confidence given its observation of the network, and again, a much higher confidence that it will be able to succeed in getting this finalized and not allowing the proposer to steal the mev and do something else for even stronger protection. The builder may only release the data after seeing the first quorum certificate on the original proposal. Remember, there's two rounds. This just brings it closer to the finalization gate and it doesn't really need to release the data until the second part. There are some caveats of that.
00:19:56.218 - 00:20:40.086, Speaker A: Now we only have one round to broadcast the data instead of two. That's easily solved by broadcasting an encryption of the data starting at round one and then releasing only the decryption key starting at round two. The decryption key is small and can be broadcasted faster, so that solves that problem. It's harder to pipeline proposals, though, with this idea. So one of the nice things about protocols like Hotshot is it allows for overlapping rounds. But if we hold onto the data and we're already proposing a new block in the second round, then this gives the builder of the previous block an advantage for building the next block, since it's the only one who really knows that information ahead of time. This might be addressed by order flow auctions, right? These ideal functionalities might be able to take care of that.
00:20:40.086 - 00:21:02.970, Speaker A: They essentially create one builder abstractly, that is the ideal functionality and have all the real builders just participating in it as a multiparty computation. So, thank you very much. That's what I had to tell you about today. And next up, we have Evan Forbes, who is going to tell us something exciting about ending the proposer monopoly.
