00:00:02.080 - 00:00:06.050, Speaker A: Welcome to the fireside chat. I'm Connor from Celestia.
00:00:06.790 - 00:00:12.250, Speaker B: I'm Henry from Penumbra. And we are here to shill privacy.
00:00:13.550 - 00:00:36.430, Speaker A: Yep, we're gonna relentlessly shill privacy, and we're gonna talk about shielded pools and things of that sort. So let's see, Penumbra is on Mainnet now. How many days has it been?
00:00:37.610 - 00:01:33.830, Speaker B: I think this is day seven. So at the moment. So there's a proposed phased mainnet for penumbra, and right now we're in phase zero. So there's an initial proposed network, there's validators, there's blocks are being produced, but that network has a lot of the core features that would actually make penumbra useful, disabled, and those can be enabled through on chain governance votes. But basically this allows there to be a period where there's a bit of a shakeout. So one of the key things that is a little bit different about the penumbra launch, we have this kind of joke internally of like penumbra is built different. And you know, there's the funny sense of that, but there's also a very literal sense.
00:01:33.830 - 00:03:04.310, Speaker B: None of the infrastructure for the network is being run by any of the entities that developed the software. And that means that there's this kind of like chaos period of seeing how that decentralization happens. A lot of other chains they'll launch and there will be some like, here's the official RPC, here's the official front end, whatever. And by creating some official service, you're basically kind of cutting off the opportunity for any of those things to emerge organically through the community. So right now there's kind of this like messy period of people deciding to host rpcs and posting those on the forum, and people chasing down URL's and manually typing them in. And as that period kind of comes to a close, we'll be able to see, okay, here are the resources that have come out of the community, and we'll be able to kind of streamline that process, direct users to it. So once that happens, we're anticipating that there will be a governance vote to enable IBC and to enable the DeX, and at that point, the battle station will be fully operational.
00:03:06.850 - 00:03:31.866, Speaker A: Cool. So I tried out the Penumbra Cli and one thing that I noticed is that, well, there's a few things that I noticed right away. The most obvious first impression of it is that fire emoji warning message that gets printed every time you run it, that says, this is dangerous, you're about to lose money. Which is, I thought that was pretty.
00:03:31.898 - 00:03:34.338, Speaker B: Cool because that was for testnets.
00:03:34.474 - 00:03:36.866, Speaker A: Oh, that was just for testnets. Okay, so on mainnet you're not about.
00:03:36.898 - 00:04:47.270, Speaker B: To lose probably it's the same software, right. But when we put that in, like, so part of the penumbra backstory is that I really wanted to lean into this ethos of like build in public, build in view of the community. I think there's a lot of projects where like they go off, they build the thing, they just like spend all the time in some slack and then all of the like tacit knowledge of why all the technical decisions were made is just like locked in some like corporate slack instance that gets data retented and there's this kind of like, oh, well, we'll make a thing and then we'll throw it over the wall and then maybe people will run it. And for penumbra, we took a very different approach. Basically, as soon as we had like one end to end transaction flow that kind of worked, we just like yeeted it out and called it a testnet that was like testnet one. And then every time there was some catastrophic failure of the testnet, we would like blow the whole thing away and start over. We went through 75, 78 testnets, I think, and people would make fun of us on Twitter being like, oh, just one more penumbra testnet, bro.
00:04:47.270 - 00:05:05.230, Speaker B: But it was a really good forcing function for can this software actually be deployed? In the very early days it was like so sketch. Like the software was so bad that we wanted to put in a warning of like, we actually do mean it.
00:05:05.730 - 00:05:30.840, Speaker A: Well, I just thought it was like a warning that was saying that you're using cryptocurrency. I thought it was like a very basic warning that was saying like, you're using cryptocurrency. There's an option to reset your directory in here and you may delete your private key, which is fair. Kind of like how all the web wallets, they all force you to copy your seed phrase and then they quiz you on your seed phrase because they assume that you're an idiot, which they should because so many people are.
00:05:33.660 - 00:06:49.698, Speaker B: Well, maybe we'll leave the warning in. But yeah, I mean, I think a thing that's pretty cool about it is that. So one thing that I'll talk about unprompt it is another design decision that we made very early on for penumbra was to not put any keys whatsoever in the full node software. So one problem that happens with privacy chains especially, is you have to have some way for each user to manage the state of like, what is the stuff in my wallet? If you imagine you have a private chain, you can't just go and query an RPC to say what's my account balance? Because by design that's supposed to be private. And so there's some process that your wallet has to have to synchronize and learn about the state that's relevant to it. And in Zcash, which I previously worked on, this was done by embedding that wallet into the full node. But once that was done, that became kind of the, it's like that became the sort of default thing, and it removed a lot of the pressure or the forcing function to really make that work well.
00:06:49.698 - 00:07:53.690, Speaker B: And so the zcash mobile wallet story or anything other than using a full node was kind of several years delayed because there was this thing that kind of worked for the sort of some of the use cases. And one of the things that we did when developing penumbra was starting from the very beginning of thinking of, there's going to be a client device and that should be separate from the node. And maybe a user is like querying their own full node because they're running their own node. That's great, good for them. But we want to design a client sync protocol that will actually work without knowledge of all the data that's in a full node. And we ended up co designing that with the protocol that is on chain. And effectively, every time we added a new protocol feature, we would also have some explicit modeling of like, okay, and how does this reach all the way out to the client device and then back.
00:07:53.690 - 00:08:18.300, Speaker B: We can't just assume like, oh, someone will build an indexer that will fill in all the information after the fact and kind of paper over our protocol design flaws, we really have to have this kind of end to end conception of protocol design where like, there's a user device that doesn't have access to a full node, what information does that need to have? How does that get synchronized, and how do we make that efficient?
00:08:22.480 - 00:08:57.064, Speaker A: So there are not that many actions that you can take with the CLI. So if you ever use the osmosis CLI, and you go to the transaction sub command, and you look at all the kinds of transactions you can send, there's like 100. And even though penumbra does a bunch of things, multi asset shielded pool Dex governance, it seems like there's not that many different kinds of transaction types. Is that because each you had to intentionally minimize the actions and keep it simple, because each action is a circuitous no.
00:08:57.112 - 00:09:50.172, Speaker B: So that's actually, that is more of an artifact of the CLI. So the way that penumbra transactions work is each transaction is a bundle of actions that are going to all be applied together or not at all. And you can stack together those actions to accomplish whatever functionality you want. So, for example, suppose I want to send you funds. I'm going to make a transaction that will have some spend actions, that spend notes that I have, release the value into the transaction, and I'll have an output action to send a note to you, and I'll have an output action for whatever change I have. And so you could classify that as like a send transaction, but that's not really an inherent property of the transaction. That just happens to be, like one way that you could assemble the actions of.
00:09:50.172 - 00:10:53.860, Speaker B: And so the reason that we have sort of relatively fewer things in the CLI is actually just because when we built the CLI, we tried to orient it around, like, specific things that you might want to do. But there's a bunch of interesting emergent behaviors that you could have, if you, like, manually compose different actions together, they're just not exposed. And one really cool example of that is something you can do with the dexdenness. So, Penumbra has a Dex. The model for the Dex is that all of the liquidity positions and the trades that are made against the Dex are public, but you can't see who is doing them, because it's just funds come out of the shielded pool, interact with this thing, and then return. And the Dex operates on a batched execution model, so there's not any kind of ordering games for the Penumbra Dex. That part of MeV is just gone, and instead, everything gets executed in a batch in phases.
00:10:53.860 - 00:11:59.562, Speaker B: And one kind of interesting emergent behavior that you can get by customizing action stacking is, it's actually possible. We didn't explicitly design for this, but it turned out to be the case. You can actually do block scoped JIt liquidity on penumbra. And the way that you would do that is you create a transaction where in the same transaction, you have an open position action, and then you have a close position action that will close the same position that you just opened. And because those two actions are actually going to get queued for execution at the end of the block, the effect of that is that you can create a position that has some fixed price liquidity, and that will be live for exactly that blocks Dex execution and then close. So if you want to do, say like arbitrage against a centralized exchange. You can wait up until however long you think it's going to take you to make all the proofs.
00:11:59.562 - 00:12:57.910, Speaker B: That'll be a few hundred milliseconds. You can get a quote from whatever centralized exchange you want, and then you can create a transaction that says like, I'm going to offer exactly this much liquidity at some spread around that price, and it will auto close at the end of the block. And so I don't have to worry about like, is there some MeV game of like can I cancel my order fast enough? And I think it's a really interesting example, because this behavior was not something that we ever explicitly designed for, but rather it was the kind of composition of a bunch of independent features that we made. Like you can compose arbitrary actions and you have a batched execution model. For the DeX, it just kind of worked out. So I think that what we're going to see post launch, and as there's more and more activity on the chain, is more creative ways to build and structure transactions.
00:12:59.450 - 00:13:30.090, Speaker A: This Dex is super interesting. The fact that it is ordering agnostic is like, this is like something that Ethereum people talk about like it's Sci-Fi and it's on mainnet about to be enabled. I wonder, is this, so this twelve second batch auctions, that seems like something that the really fast market makers wouldn't want, but it seems like something maybe the more passive LP's would very much want. What do you think about that?
00:13:30.210 - 00:13:54.102, Speaker B: So for penumbra, the block time is actually 5 seconds. So you can locally in your browser prove a penumbra transaction, submit it to the network, and get absolute finality of its inclusion in less time than it would take to get a single Ethereum block. Cool. They should make Ethereum faster, in my opinion.
00:13:54.166 - 00:13:56.854, Speaker A: Well, okay, but like, it's still the five second resolution.
00:13:56.982 - 00:15:17.710, Speaker B: No, I'll get there. I'm just, I'm just trying to back you up on your campaign to make Ethereum faster. Okay, to the question about like, is that batch time too slow? Although the, I think I, although the Dex execution is only happening every 5 seconds, there's not necessarily a limit on how soon someone, or how long someone has to wait in order to interact with it. So if we consider that like arbitraging or providing liquidity based on prices from a centralized exchange, the relevant latency, there isn't the 5 seconds between the blocks, but it's however long it takes that market maker to prepare a transaction that they can submit just in time for the next block to occur, because they don't have to, when that first auction finishes, they don't have to immediately make their quote for 5 seconds into the future. They can wait until, let's say, like 500 milliseconds into the future and then submit as long as they have some kind of fast path to a proposer.
00:15:18.250 - 00:15:31.794, Speaker A: Okay. Okay, cool. Nice. And there is, at one point, there was something about flow encryption. You wanted to hide the order flow from the proposers. Is that still on the roadmap?
00:15:31.962 - 00:16:55.558, Speaker B: So it's on our roadmap. But we did cut that scope out of v one, both because the feature that is required to make that work, which is vote extensions for tendermint, was quite delayed in shipping, but also because we realized that Penumbra is already three projects worth of scope already. And so maybe we should just try and ship one thing and then keep iterating on it. But our thought is that being able to do trading strategies without allowing people to inspect the entire history is already a huge leap forward. And definitely it's something that I'd be interested in exploring for a v two, but I would say that at this point, Penumbra is on Mainnet. It's going to be live, and we'll be able to see what actually is useful. So at that point, the protocol design decision making isn't just up to me personally or other people on the Penumbra labs team or whatever, but a kind of community driven process to form consensus around features.
00:16:55.558 - 00:17:01.610, Speaker B: And so we'll kind of see, okay, what do people actually want to want to have?
00:17:03.550 - 00:17:09.250, Speaker A: What kinds of actions can governance do? What kind of proposals can get executed by governance?
00:17:10.390 - 00:18:10.550, Speaker B: Yeah. So the governance design for Penumbra is basically modeled off of that of the Cosmos SDK. So we didn't really want to innovate too much because there's already a lot of work for the project, but it is a little bit different. So we have the same basic structure of, there's a delegated voting system, so validators can vote, their delegators can override their votes. The main type of proposal is signaling proposals, where you can sort of iteratively build shelling points around particular ideas by having signaling on text. Another type of signaling proposal is for helping coordinate chain upgrades. So if the community wants to sort of change the consensus rules, there's a way to coordinate.
00:18:10.550 - 00:19:10.254, Speaker B: If we were going to do this change, this is when we would do it, and we can agree about what code we might or might not want to run. Importantly, though that upgrade process is not directly enacted by the governance. It just allows the software to coordinate a halt, and then validators can choose to do an upgrade or not. So that's kind of the main thrust of governance. There is also a community pool, which is similar to the way that a community pool works on a cosmos SDK chain. But that pool is initially frozen, and there would need to be a governance proposal, sort of like a meta proposal, to do a chain parameter change to enable it. Oh, yeah, there's a parameter change mechanism.
00:19:10.254 - 00:19:19.880, Speaker B: So there's an explicit list of like, certain parameters for the chain that can be enabled by governance and that allows, you know, like turning on and off various features.
00:19:22.180 - 00:19:26.612, Speaker A: What the heck is going on with the liquid delegation staking stuff?
00:19:26.756 - 00:20:01.718, Speaker B: Oh, this is super cool. So, yeah, we had to invent a new kind of proof of stake along the site. The way that's kind of like I was saying about the, like, we've already got like three projects worth of stuff. We should chill at least. So one of the, one of the very early decisions for Penumbra, which is kind of like tying ourselves to the mast moment, was we decided that Penumbra is only going to have shielded accounts. There's not going to be any transparent accounts on Penumbra. There's no transparent addresses.
00:20:01.718 - 00:21:16.030, Speaker B: We're not going to do this optional privacy thing. We're going to build shielded transactions, and that's going to force us to actually make all the shielded stuff work, which was correct, but it turned out to be kind of brutal. But one of the problems that comes up is like, okay, it's a proof of stake chain. How are you going to build a private staking system? And if you don't know who all of the delegators are, how can you pay out staking rewards? So what we, so what we built to get around that was an alternate version of proof of stake that doesn't actually have staking rewards. Instead, each validator has their own validator specific liquid staking token, which we call a delegation token. And this represents basically fractions of that validators delegation pool. And when someone does a, a delegation to stake funds, rather than saying like, oh, they have these tokens, and now we're going to attach this extra state to these specific tokens and say they're bonded.
00:21:16.030 - 00:22:26.244, Speaker B: We say when someone delegates, they're going to do a protocol native exchange of the native unencumbered staking token to this validator specific delegation tokenization. And the exchange rate between those two tokens, prices in all of the cumulative staking rewards that have occurred since genesis. And the effect of that is that now when you delegate, basically you're pre debiting yourself for all of the staking rewards you didn't earn because you haven't been staking. But now your delegation is on the exact same footing as every other member of the delegation pool. And so when you unstake at some later point, the difference in those exchange rates is actually going to be the auto compounded effect of what would have been a staking reward exactly over the time interval that you held that token. But the chain never needs to track that on an individualized basis. So you can economically replicate the effect of a staking reward.
00:22:26.244 - 00:23:19.150, Speaker B: But it's much, much simpler for the chain because it doesn't actually have to keep track of which delegations are where and how long they've been. It's all just bundled into this single token state. And it also makes it substantially easier and safer for a third party later to build some kind of pooled liquid staking token. So for example, if Stride wanted to make like a stum token, then all they would have to do is just implement a pooling mechanism that is going to pool these native lsts across different validators. They don't have to build some kind of multisig, and it really dramatically reduces the amount of risk to the chain that's imposed by somebody building a pooled liquid staking design.
00:23:20.540 - 00:23:39.052, Speaker A: Okay, because that's what I was going to ask next. I was going to say, are we about to see people take these delegation tokens and IBC, bridge them to Mars protocol and then start trying to borrow against them? But you answered that would be cool. That would be cool. But you said they might get abstracted into like a stride STM or something like that.
00:23:39.196 - 00:24:46.610, Speaker B: Yeah, I think it basically, it depends on how efficient the rest of the ecosystem is at managing liquidity between these different things. So if you have 100 validators, and then there's 100 of these different delegation tokens, those will all have totally known exchange rates relative to each other. And unless you're really specifically pricing slashing risk between different validators, you would be able to auto relate between them. But it might be simpler for the rest of the ecosystem to coalesce around like one pooled representation, or maybe there's others. But a cool thing is that unlike a system where the liquid staking has to be kind of bolted on, if people don't like the choices of whatever contract is deciding how to pool different validator stake, they can just exit and that's a really cool benefit.
00:24:54.430 - 00:24:56.770, Speaker A: There's a web prover. How's that going?
00:24:58.230 - 00:25:49.984, Speaker B: It's gone really well. So another design decision that we made upfront was we want to try to build like a web first user experience and try and make that work. And it was really interesting. We were able to feed a lot of lessons from how awful is it to try to build a web interface back into the core protocol design and iterate that way. But right now for the web prover, we have the rust code that does the ZK proving. It's compiled to WASM, and we use webworkers to parallelize the proving across each action in the transaction. This is unfortunately still like about 20 times slower than the native rest code.
00:25:49.984 - 00:27:03.430, Speaker B: But since our native rest code was really fast to start with, it kind of evens out. And the other thing that we did at a kind of high level of the cryptographic design was we made it so that when you sign a penumbra transaction, you don't actually sign over the proofs, you only sign over the effects that those proofs are going to have. And what that does is it lets us start optimistically creating all of the proofs in advance of the user actually clicking confirm. So if a user is using a penumbra front end, I want to do send x to y, I hit submit and this pops up the approval dialog. That approval dialog can be showing the user, ok, here's exactly what the transaction is going to do, and you can double check it in this trusted way. And while they're looking at it, it can already be starting to do the proving. And what that means is as long as the proving time is faster than the time that it takes for a user to review the approval dialog, it is effectively infinitely fast.
00:27:06.010 - 00:27:19.570, Speaker A: It is really amazing how all the little details like that have been thought through and how much like an Apple product the whole UX Washington thought through, all the way down to the lowest level protocol decisions.
00:27:21.150 - 00:28:05.410, Speaker B: Thanks. We do our best. Another kind of subtle example of that is the way that we made the Penumbra addresses work. We ended up refining this, that it would work seamlessly with IBC. One of the goals that we had in the design of penumbra washing as much as possible, we should align the privacy boundary of the system with the chain boundary. Right. And the thinking is, when you're building a blockchain or a crypto product, in some sense, in some fundamental and inescapable sense, the cryptography is the product.
00:28:05.410 - 00:29:14.480, Speaker B: And if the actual cryptographic properties of the system don't match what the user is expecting. This is going to lead to disaster. And that doesn't mean that every user has to be expected to understand all of the cryptography, but it does mean that you need to make sure that whatever you build is actually aligned with what an intuitive understanding of the properties of the system could be. In the same way that, for instance, with signal, as a user, you don't actually have to understand, hey, here's how this triple ratchet thing works, but you just, it works. And in order to make this kind of alignment of where's the privacy boundary for penumbra with IBC transfers? Because that's the kind of explicit action that a user is going to take, I have funds over here, I'm going to send them to Penumbra. And we want that to be the place that the privacy happens. We needed a way to make penumbra shielded pool work really seamlessly with the way that IBC transfers work.
00:29:14.480 - 00:30:37.670, Speaker B: So an ICS 20 transfer for IBC, the data of that transfer is an amount, a denomination, a source address, and a destination address. And the reason that you need to put a source address on the sending chain in addition to the destination address for the receiving chain, is that it's possible that that transfer could timeout. And for a normal transparent transfer on a cosmos chain, right, handling a timeout is very easy. You just like send the funds back to the account that sent them. But from a privacy perspective, it would really suck if every time you had to do a withdrawal from Penumbra, you have to specify, here's the long term linkable account that I'm sending the funds to, or I have to, like, I can get better privacy, but like, expose myself to loss of fund, like, this would suck. So instead, what we did was we made it so that every Penumbra address actually includes some encrypted metadata about what the internal meaning of that address is. And you can have many, many penumbra addresses that are all part of the same wallet and grouped into logical accounts.
00:30:37.670 - 00:31:32.090, Speaker B: And using this embedded encrypted metadata tag, we can actually encode into the address in a secret way so that only the user can see. This address is actually some randomized IBC deposit address for some numbered account that the user has. And that means that when someone is creating a withdrawal or deposit IBC withdrawal transaction, their software can auto fill a freshly generated new penumbra address into the sender or receiver field, and their wallet software will later be able to look at that address and inspect and understand which account it was being sent to, even though that's not publicly revealed to anyone.
00:31:33.670 - 00:31:40.250, Speaker A: So how was the experience of trying to get IBC to work with a different kind of merkle tree than the SDK?
00:31:42.950 - 00:31:54.800, Speaker B: There's a meme that we made of the Vietnam dog Chihuahua, and we overlaid our Merkel proof format onto it. Cause that was our. It was a negative experience, let me say.
00:31:54.880 - 00:32:04.344, Speaker A: See, I had a really hard time just trying to get Rolekit to work with IBC. And Rolekit uses the SDK, or I was using the SDK to try to make it work.
00:32:04.512 - 00:32:55.270, Speaker B: Yeah, I think so. There's kind of an interesting thing here, which is there's, like, IBC, the protocol, like, as designed, and then there's IBC, the protocol as implemented and as designed. It's a super, super flexible and generic general purpose system. As implemented. It's mostly that, but also there's a bunch of implicitly specified behavior that really, you have to do some spelunking through the IBC go implementation to figure out. And I remember having a pretty. There's one conversation that I had two or three years ago with Zucky where I'd gotten Covid, and we were stuck in this quagmire of, it wasn't working.
00:32:55.270 - 00:33:28.890, Speaker B: And I'm doing the phone call to get the moral support or founder therapy or whatever. I'm like, yeah, this just feels like a total quagmire. And I don't know how we can make the IBC stuff work. And da da da. And Zaki's response was like, yeah, that's what I've heard from basically every team that has tried to work with this stuff, but you're pretty good at figuring out all that cursed bullshit. So my hope was that you could go and fix it and then tell everybody else, here's how to do it properly. And that was a moment where one part of my soul just died and left my body.
00:33:28.890 - 00:33:35.070, Speaker B: And then we've had others since then, but now it's main net, so I can. Hopefully there's some left.
00:33:36.850 - 00:33:42.350, Speaker A: Yeah, man, you hate to be told that you're humanity's last hope to do something.
00:33:43.520 - 00:34:46.620, Speaker B: Yeah, but we did. I mean, the thing that sucks is, like, he was right and like, we did actually end up fixing it and, like, built a whole IBC stack, so it worked out. But, yeah, we'll see how it goes. But it's been really helpful for us to have done this process of, like, building everything in public, having running code basically all the time. One thing that we know works because we've exercised it on testnets, is if you have a penumbra testnet somewhere and you're doing relaying, you can just go to faucet circle.com and get your testnet USDC and then immediately deposit it into penumbra and transact with it just like any other shielded asset and just like works. And I think that's a thing that's kind of underappreciated about IBC is as a networking protocol.
00:34:46.620 - 00:35:14.950, Speaker B: There's a lot of spooky emergent behaviors that you only really see when you try to do stuff for real. So if anybody is building stuff that is supposed to integrate with IBC, my recommendation would be as much as possible. Just like if you can get a test deployment and just actually start exercising it, because there's no substitute for just seeing what the code works.
00:35:17.410 - 00:36:06.140, Speaker A: Yeah, we're starting to run out of time, but it is absolutely amazing the ridiculous amount of work that has gone into this thing over the last three years and the culmination of it hitting mainnet. It's also worth talking about how this thing has not just attracted hype, but it has attracted a real community of enthusiasts. The infra that's being spun up in these early days is mostly just by fans of the project. The discord is real people. There's, of course, a whole bunch of bots and farmers like everything, but there's actual real humans talking about this thing in the chat, which feels very organic and refreshing. So I highly recommend everybody try out penumbra. This thing is, it came from the future.
00:36:09.760 - 00:36:10.500, Speaker B: Soon.
00:36:13.520 - 00:36:19.180, Speaker A: Can we answer questions? Should I.
00:36:22.680 - 00:36:23.464, Speaker B: Thank you.
00:36:23.592 - 00:36:26.312, Speaker A: Did you rewrite the IBC stack yourself, or did you?
00:36:26.376 - 00:36:53.230, Speaker B: Yeah, we rewrote the whole IBC stack in rust. And then you didn't use IBC rust. We ended up. Unfortunately, the state model for penumbra is a little bit different from what that library was aimed at. And so we had to kind of have our own originally as like a fork, and then we rewrote most of it. But we now have our own IBC implementation. We actually share it with Astria.
00:36:53.230 - 00:37:11.210, Speaker B: So the Astria stack is actually just like the Penumbra stack, which is great, but there's a common IBC implementation between those two projects, but it's separate from the informal IBCRs effort.
