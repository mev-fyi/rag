00:00:00.090 - 00:00:44.182, Speaker A: You. Hey, everybody. Thank you for coming. Yeah, my talk was originally called the economics of modular blockchains, but I realized that that was a very broad topic and it has to cover a lot of breadth and not go very deep on any specific issue. So I thought I'd kind of apply some of the principles I was thinking about in that original topic towards answering a very practical question that I think that the industry needs. And what I want to answer is, if somebody is an app developer, meaning they're building software for users that serves a purpose, why should they consider to include modular blockchains in their tech stack choice? And before I answer that and go into this, I do want to introduce myself. I'm lzrs.
00:00:44.182 - 00:01:27.154, Speaker A: I'm the founder of Modular Cloud. We have a cloud infrastructure for modular blockchains. And I am on a panel in about an hour from now. And I encourage you all to attend. And we're going to talk more about the specifics of those services that we provide more in depth in that presentation. Okay, now on to why should people use modular blockchains for their apps? So here's the common narrative of why somebody would want to use how a blockchain works. Essentially, there's a user, and this user creates a transaction, and they securely send this transaction to some sort of decentralized network.
00:01:27.154 - 00:02:21.146, Speaker A: And once this transaction is off into the Internet on this decentralized network, there's this group of nodes that come to consensus and they verify that this transaction is valid and update the state, and it's broadcast and finalized and sent out to everyone in the world. I think that this is like a common explanation, but I don't think that there's some parts of this type of common conception that I don't like. And the one I want to highlight right now is that I don't like that when people skip when they say, okay, the user uses the blockchain. Because I think that really takes out a really important point and part of the equation. And in doing so, it kind of makes people that are building apps not really understand where they fit into the picture. Because the reality of the situation is that the user is not using the blockchain. They're using a device like a phone or a computer.
00:02:21.146 - 00:03:12.406, Speaker A: And on that is some code that's run, that's written by some sort of third party, some sort of project, which that is the app and the developers that are building that app are integrating with the APIs and sdks provided by the blockchain. So the app developer, in a sense, is the true consumer of the blockchain. And I think as we go on, over time, we're going to transition more from everything being where we tell people, like, okay, this is a crypto app, this is a blockchain app. And a lot of stuff will be going on behind the scenes once developers realize the power that blockchains can provide them, just as a technology in their technology stack. Okay, so imagine you're an alien and you're coming to earth. You have no context about this. And you look at these two apps, these are undeniably apps.
00:03:12.406 - 00:03:36.194, Speaker A: They're both on the Android Play Store. So you can install these apps on your phone. These are apps, these are not blockchains, they're not decentralized networks. Right? There's a Venmo app and the mycelium bitcoin wallet. Now I would ask, what's the difference? I mean, you can say there's a different UI, different name, stuff like that. But by the way, sorry, I thought the time was frozen, but it was actually moving. Never mind.
00:03:36.194 - 00:04:19.306, Speaker A: Anyway, so I'm trying to be mindful of my time. Anyway, so if you compare these apps, they both connect to the Internet. One of them, you could say, connects to the bitcoin network. The other one connects to Venmo's servers. But that in and of itself is not a particularly meaningful distinction. What I would say is the difference between these two is that the bitcoin wallet is actually not only retrieving some data from the network, but it's also doing some sort of verification on that data. The way that it does this is, it connects to this very powerful API that you can call the bitcoin node RPC.
00:04:19.306 - 00:04:46.840, Speaker A: And what I want to do is I want to, in this talk, propose an abstraction that we can use when we think about talking to rpcs. And this is going to apply to all blockchains, not just bitcoin. I'm starting with bitcoin because it's a very simple case. It's basically an app chain for payments. And over time we've modularized these and expanded the scope of what these protocols can do. But this is going to be an easier case to explain. So I have this abstraction that I'm going to present to you called a cost function.
00:04:46.840 - 00:05:33.302, Speaker A: And this is how I think that app developers should be conceptualizing blockchains. Like they shouldn't be thinking about the internals of the peer to peer networking and cryptography. I mean, it's important context, you need to be aware of that. But it's not the fundamental thing that you should think about when you're considering how, or if you should integrate a blockchain into your app. So what is a cost function? A cost function is essentially if you given a statement, it's the cost that the person making that statement would incur if they were to commit fraud. So in the case of bitcoin, this has a very narrow capability. So if someone says, I sent you five bitcoin, and I'm going to be very much abstracting this process, I'm not talking about actually how this works.
00:05:33.302 - 00:06:20.026, Speaker A: This is a very high level description of this process. But if someone says, I sent you five bitcoin, you wouldn't want to necessarily trust that that's true and do something irreversible like sell your kidney, just trusting that it's true, they could be committing fraud. And the difference between something like venmo and bitcoin, both are hard to commit fraud on. But if you use Venmo, you don't actually have the information for how much it would cost to commit that fraud. So probably, you'd probably be fine with Venmo, but there are situations where having that additional information would be good. So in this case, this person claims to have sent five bitcoin to this person in exchange for some service or goods. And this person realizes that the cost to commit fraud in this scenario is lower than the value of the transaction.
00:06:20.026 - 00:07:05.166, Speaker A: And now they can make a risk assessment, and they can model the risk based on their use case, on how confident they are and how they want to interpret that data between the two. But I think that they're actually connected. At the last modular summit, I gave a talk on the subject. I encourage you to check it out if you're interested in learning more about that. But I'm not going to talk about that here. Okay. How does the cost function work? Essentially, you start off by having this assumption that you have access to the open Internet, and through accessing a peer to peer network, you're able to scan and get all the possible chains, or maybe not all the possible chains, but among the chains that you can find when you scan the Internet is the one that you are looking for, which would be called the canonical chain.
00:07:05.166 - 00:07:45.290, Speaker A: It would be like, for example, the longest bitcoin chain with the highest difficulty. That would be the canonical bitcoin chain. And what happens is you retrieve data from the network and then you apply a rule set to actually determine which of these potential canonical chains is the canonical chain. Because you can't, of course, trust anything you hear on the Internet, just because someone says this is bitcoin doesn't mean that it's true. So the way that this works is you can break this down into two pieces. First is validity, and the second is the fork choice. So if you think of all these things as just raw bytes, like just blobs, binary data, you will parse that and you'll check if the structure of that data follows the rules of the protocol.
00:07:45.290 - 00:08:46.770, Speaker A: That would be checking the validity. And then even if you have ten chains, maybe there's eight of them are valid and two of them are invalid. You still have to decide which one is the canonical chain. So a fork choice rule will take two potential chains, a and b, and it will return either chain a or chain b, depending on which one it prefers. And if you go through all possible chains that are presented to you from the network with this connectivity assumption, assuming that you're connected to the Internet, you should have, by the end of it, the preferred chain out of the whole list will be the canonical chain. And so how this plays into the cost function is that there's this thing, I don't really know what we should call it, but maybe we can call it like security units. Once you have this data and you know what the canonical chain is, now you can actually statically analyze that binary, and you can determine what would be the security units that it would take.
00:08:46.770 - 00:09:30.722, Speaker A: If someone had these security units in an abstract sense, could they commit fraud into the system? So let's go through a concrete example of this. So what we're talking about bitcoin, it's proof of work. So there's a certain hash rate. A hash rate would be a unit, perhaps. And if you had enough hash rate, you could do a 51% attack. And now, in and of itself, that's not actually that useful, because how do you know how hard it is to do that hash rate? Maybe you can use your laptop or something and commit fraud. So there's another assumption that goes along with this assumption that you have access to the open Internet, and that's access to market data.
00:09:30.722 - 00:10:12.830, Speaker A: And this is not built into the protocol, so it can be kind of counterintuitive, but this is actually really key to properly utilizing blockchains. And so with this market data, basically what you want is the cost of the hash power. So in this case, essentially, I don't actually know how people really calculate this, but I assume it's basically like the electricity costs and maybe something to do with hardware. But there is a way that you can model the cost of getting the hash rate that you need to commit fraud. And from that this is what you would have as the cost function. And you can now say, based on this statement that I'm verifying, how expensive would it be to commit fraud in this case. And then now I can determine based on the circumstances for my application how I want to interpret what is on the blockchain.
00:10:12.830 - 00:10:52.106, Speaker A: And then of course, who uses proof of work anymore, I guess. Right? Proof of stake is exactly the same thing. You have tokens that can be slashed and there's a price of a token, you have access to the market data, you can do the same exact thing, it works the same way. And so I'm not going to go into this connectivity assumptions, but I do think that this is one area that really does trip people up, because there is an assumption when you're using blockchains that you have access to the open Internet. And if you don't actually a lot of things break down. I think when a lot of people think about it, they just look internally into how the protocol works and sometimes not all the answers are there. And so that might be a disconnect why some people don't understand the value prop of crypto.
00:10:52.106 - 00:11:37.990, Speaker A: But I'm not going to go into this because we just don't have time. But I do want to talk a little bit more about selecting the canonical chain, just to be a little bit more clear about how this works. Essentially you're getting all the chains, this is the pseudocode, you're filtering out the valid one. So now you have a list of valid chains, and now you're just literally running a reduce of the fork choice rule on all the valid chains. But what's interesting is you can actually collapse this down and you can combine validity into the fork choice rule itself. And it would look something along these lines where instead of a function that takes a and b as an input and returns either a or b, depending on which one is preferred, you also can return like a nil value if both chains are not valid. So you're just basically checking the validity at the same time as determining what is your preferred fork.
00:11:37.990 - 00:13:10.646, Speaker A: And so this is actually, I would argue, the most concise abstraction for how blockchain. What is a blockchain? All this other stuff is implementation details like are you using proof of work or proof of stake? Do you have merkel trees? A lot of these things are like just to achieve this, but this is the actual conceptual, the essence of what we're actually working with here. But the thing is though, is again, I want to reiterate that the fork choice rule by itself is not really useful because you say, okay, this is the valid chain, but what's the implication of that? Right? You need to have what I call this broader thing, which is this cost function to understand what does it mean when you find data in this chain? What kind of guarantees can you expect from, and how expensive would it be? How much can you trust this data, essentially? So I want to now build up from bitcoin to modular blockchain so we can see how this all ties together. Okay, so bitcoin had two problems, and I want to focus mostly on this first one. And essentially the problem with bitcoin is that it's hard to engage in commerce with bitcoin. And one reason for that is, of course, you have to get a bunch of people to get bitcoin wallets. You have to get businesses to put their payroll or their point of sale system on bitcoin.
00:13:10.646 - 00:14:01.370, Speaker A: That's all very hard, and we've made very little progress on doing that. But there's also kind of a more fundamental reason why it's hard, and that's because it's really hard to bridge on chain and off chain events and people working in real world assets and dealing with oracles and stuff. They face this all the time. And I won't go into, because we just don't have time, I won't go into the theoretical reasons why, but I think there are some interesting things for why this is true. But I'll give you an example to make this more concrete. So this was the example we went, so someone was going to sell their kidney or something, and this person claimed to send them five bitcoin, but really did not. And they were able to not trust that because they could calculate that it was likely that they could be profiting by committing fraud in this scenario.
00:14:01.370 - 00:14:42.994, Speaker A: Now, this works in this narrowly defined scope of saying, I sent you five bitcoin, because essentially that's what the bitcoin app does. It's a payments. So the cost function can let you verify the cost of how much it takes to commit fraud in this case, but it can't do other things. Like, for example, if they claim to have provided the service, you wouldn't be able to verify that actually happened. You'd have to introduce some sort of oracle. And then that introduces additional risk into the system. And all this kind of risk, the more risk that you introduce into the system, the more you have to have a margin of error on anything that you're calculating.
00:14:42.994 - 00:15:26.130, Speaker A: And eventually, if you have enough error, that's going to all compound and it's going to be a useless value. So you want to constrain any of those things. You want to have as much to be directly verifiable by the cost function as possible. And so there is a way that bitcoin could have addressed this and expanded the functionality if they wanted to. And I'm not saying that they should have, I'm just saying they could have. And the way to do this would be to hard fork and add more opcodes and increase the power of their scripting to do other things that people want to do. And the more things that you'd want to do, the more different types of statements you'd be able to verify with this cost function and understand the context around how expensive it would be to commit fraud in these scenarios.
00:15:26.130 - 00:16:03.166, Speaker A: But they didn't do this. And why did they not do this? I think this is a really important point. I actually think it's exactly what you would expect. So there's this thing called Brooks law, and it talks about how you add engineers to a project, and it makes it harder to actually complete the project, because essentially, as you add more people, the lines of communication increase combinatorially. So what this means is, as you add more people to a group, the communication overhead gets way more and more and more difficult. The implication of this is, at a global scale, you really can't coordinate. It's not possible.
00:16:03.166 - 00:16:44.142, Speaker A: It's prohibited. And that's why these permissionless networks are really great, because you actually don't have to coordinate. And I'm not going to go into this, but I do want to say this idea that blockchains allow people to reach consensus, I think is not a good way of all of looking at it. I think blockchains allow people to verify things and calculate the probability of fraud, but they actually work because you can't come to consensus. Like, for example, a 51% attack or a 66% attack. These would require consensus among the participants of the network. And the fact that those don't happen, because that's very hard and very expensive, is the reason that this works.
00:16:44.142 - 00:17:38.154, Speaker A: So we're actually playing off the fact that you can't reach consensus. It's maybe not important, but I just thought it was worth mentioning. And so essentially, it makes sense that bitcoin wouldn't be able to upgrade because everyone's verifying their own thing independently for their own purpose. And you'd have to get the people sending it to upgrade, and the people receiving it to upgrade because you want to be sending what someone's trying to receive and receiving what someone's trying to send, and it's very hard to do. Ethereum actually fixed this problem, though, because what they did is they modularized the application logic of bitcoin. And so if you remember, I'm not going to go back a bunch of slides, but I had this diagram where it showed that the cost function, or where the canonical chain is determined by the validity rules and the fork choice rule. Well, essentially what Ethereum did is they modularized the validity rules.
00:17:38.154 - 00:18:45.730, Speaker A: And so you're able to essentially do something like this, which is where you can make a statement like I did X according to module Y. And that module Y would be a modular validity rule set that can be loaded all onto the same blockchain. But the thing is, since this is modular, you don't actually have to fork the network and breach consensus with the entire developer community and all the users that are verifying the chain. So this allows people to build this stuff and use it in a modular context without the coordination overhead. So allowing you to not just have a modular validity rules, but also a modular fork choice rule so you're able to define. So if you think about a roll up on Celestia, for example, essentially that roll up has its own fork choice rule with its own validity rules and its own fork choice, but it also uses Celestia's fork choice rule as an input. So it's not just a function that takes a or b, it's a higher order function that takes a b and another function, which is a fork choice rule.
00:18:45.730 - 00:19:40.054, Speaker A: And so in this kind of way, you're able to import the verification capabilities of other chains into your chain. And that's what a roll up essentially is in its essence. And so this allows you to express a greater number of things that can be verified and you can understand the cost of fraud in these systems. And so I'll just kind of go through this little three dimensional diagram. Initially, we had like an app chain, which was bitcoin, and you could just basically have different wallets, and they're just verifying these very narrowly useful statements such as, I sent you this many bitcoins. Then we had ethereum that would allow for dapps, and this had so many more use cases like NFTs and Defi and stuff like this. And there's a lot you can do with this.
00:19:40.054 - 00:20:22.030, Speaker A: But now what we're going to have is with modular blockchains, we just kind of added this other dimension here. Since you can customize the full fork choice rule, you're actually able to even do more interesting types of things. Like for example, you can decrease the level of security and so you can increase performance as a result. And you can verify things. You have more customizability in actually setting the parameters for detecting fraud in the use case that you are actually building for as an app developer. And so, yeah, I think that's my time. So this is like a great place.
00:20:22.030 - 00:20:29.490, Speaker A: The conclusion slide was here. So thank you, everybody be, I appreciate you coming. Thank you, Liam.
