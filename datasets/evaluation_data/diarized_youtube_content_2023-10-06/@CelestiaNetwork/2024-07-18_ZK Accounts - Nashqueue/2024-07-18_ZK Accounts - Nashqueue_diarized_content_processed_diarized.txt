00:00:01.840 - 00:00:42.712, Speaker A: Hi, my name is nazku, I'm a protocol research engineer at Celestia and today I'll be talking about ZK accounts. I'll start off with this diagram. I believe we can define blockchains in these constructions. So you find most of them either on the top side and some of them on the left. Let's take Solana for example. It does everything next to whole thing and you can maybe see some conversion to move to the right part. We have ZK compression.
00:00:42.712 - 00:01:49.022, Speaker A: Maybe we will have roll ups on top of Solana and only verify. Then of course you have Ethereum, right? And Ethereum's roadmap is really the L2 rope map where we're moving further and further into the direction and putting computation off chain. And you can have something like bitcoin. And I would say bitcoin is more on the left. You have scripts, some expressivity, but there's current proposals, there's the bit VM. There's also maybe potential other ways to move to the right, like Opcat, where you add enough expressivity to create roll ups. And if you want to think about Celestia, you have to extend the graph, right? We are really on the far left because you can't do much on Celestia.
00:01:49.022 - 00:02:39.850, Speaker A: You can transfer tokens, you can read and write blobs and you can stake. That's really what there is to do. And what ZK accounts really enables is to have that left curve mindset, but really push towards the right and how it makes it. It. Basically what will happen is that Celestia can teleport to the endgame. We have now the holy grail, at least on that dimension that people would strive for to some background. This was proposed a year ago by Mustafa to have the Zksnark as the verification key.
00:02:39.850 - 00:04:19.700, Speaker A: You have an account and the verification key is the Zksnark. And we got a spec from succinct and have been working in the working group on creating, working more on the spec, thinking about interoperability and all the other questions that concern the ZK account. And it can get political or questions arise, right? As if we do not have an execution environment, a virtual machine. The option is to enshrine a proof system. Now, which one do we do? And this is of course a topic of conversation that you can be a part of as the community. And we have to remind ourselves of the core values that we bring into here, and especially these three, where one, the user is a first class citizen, which means that what we get by adding ZK accounts is increasing that trust minimization because you do not have to trust intermediaries, let's say, for bridging. Another thing is we have to keep in mind credible neutrality to the execution environment, which says that any application we should be able to deploy without enshrining any specific execution environment.
00:04:19.700 - 00:05:39.340, Speaker A: I think the most critical part is to keep the state load minimal and not add any overhead to the state machine. So what is a ZK account? Right? You can think of it as just another account. Currently we have our account and we can transact with it using our private key. We have a user and mapped to that is a public key and we can verify a transaction that we sign over with the private key using a signature against the public key. Very simple. And to be, you know, have a metaphor. You can think of ZK accounts as being another account where the user of the private key would be a program and the public key would be the verification key against that program, right? If I want to prove or verify some stateroom function, I would do that against the verification key and I would do that with the Zksnark.
00:05:39.340 - 00:06:31.690, Speaker A: And now we can look at the code and options and how to build that. But I am sorry, this is not the talk for this. I will instead give you all the things that you can build with CK accounts. Okay, so three things that we can do transfers, we can do transfers. I can send TIA from an account to Ezekia account. And if you think about it, transferring TIA back from Ezekia account to an account is trust minimized bridging. You verify that something was true and against that key you are allowed to, in other terms, withdraw from the Ziki account.
00:06:31.690 - 00:07:54.380, Speaker A: So one thing that you can do is put in any state machine into a ZK account and you have a roll up, right? This is trust. Minimize bridging between an account and a roll up. Currently this is not great. If you want to have TIA on a roll up, you would have to use IBC, which is enabled at Celestia, go through a command BFT chain and then to a roll up and you add a path dependency for one and a intermediary. And if the chain is not trust minimized, the common BFT chain doesn't allow end user verification. You are basically not following the core values. And one thing that could be interesting, that as a food of forethought, which is we have to discuss, but if you are connected to IBC, is there a way to transfer those tokens through Celestia to the ZK account? And can we do that in a way without, for example, let's say, removing the token filter or.
00:07:54.380 - 00:08:52.794, Speaker A: Well, that's basically the point of discussion. Okay, what are other things, right. We can do staking in a delegated proof of stake system. What you will see is no matter if you want it or not, you will get liquid staking. And this is how staking would look like from a point of perspective of a ZK account to a validator. But how would you do liquid staking today is you would have to bridge out using IBC, then bridge back in into a multisig, which is the most expressive thing. That is like in the future, there will be also interchange accounts and then stake using that multisig.
00:08:52.794 - 00:09:42.972, Speaker A: Of course, now you have two trust assumptions that come with BFT chain and the multisig. And you will basically get minted the t on the account. And how you can change that is putting just let's say, liquid staking module into the ZK account. And now what you have is trust, minimize liquid staking. And you know, we can go to the final boss and look at restaking. And the flow is just similar, right? You put into your rest taking module that communicates with the liquid staking, it stakes, it goes back the receipts flow. And in the end, you would get the staked, staked Tia, some representation of the LRT.
00:09:42.972 - 00:11:19.180, Speaker A: And you can loop that how many times CTA allows you to do, and I'm not saying that you should do this, but you can do it at least in a trust minimized way. And what we were talking about right now is all server side proving, you have your transactions, you have your state, you give it to the server and it creates a proof of that, proof you can do things like deposits and withdrawals. But what if you actually care about the client side? What if you want to use the ZK part of the ZK snark? And one interesting thing that I talked before, what if we, let's say at Zkmail, I have some private data, and only when I got the email, I can actually send Tia to another account or use a presentation before. And if I am allowed to open a website, this gives me the proof that I have some, let's say proof of ownership. But you can go a step further and think of it like, oh wait, ZK account is an abstraction over an account. So ZK accounts are also account abstraction. And one example could be a Keystone roll up.
00:11:19.180 - 00:12:52.736, Speaker A: You can add all kinds of things that you would want in a keystore roll up, right? Key rotation, social recovery spending policies, or you can prove that you're OFAC compliant. And that is, I think, very powerful in the context of L2 fragmentation. You have so many roll ups, and on each of them you have your own account, and they're all maybe using a different account, different private key, or the same one. But if you can rotate the keys on a ZK account, why not let that ZK account talk to the roll ups? And if you rotate the keys on one account, you can rotate the keys in the whole ecosystem. And I think this is very powerful and could unlock really frictionless communication where the user doesn't really see it as multiple chains. Okay. The third thing that you can do is posting blobs, right? And I was doing the presentation and I was, you know, starting to come up with more and more things that you could validate over the blob.
00:12:52.736 - 00:13:56.280, Speaker A: And I think it's still very unexplored. But one very obvious thing that you should do is maybe, let's say a shared sequencer is posting blobs to Celestia. Currently, they have a problem of who is actually paying for the blobs. Like there's some relayer, but who owns the keys of the relayer? You can all abstract that away and just say, hey, if that tendermidlite client says the consensus was valid, then you can spend blobs that they were specified or have some blob faucet where you fund it. And anyone can post blobs using that account when they certify some rule or ordering rules. There are many ideas, and you can think of it as solving the woods attack, an attack where you basically spam your namespace and add additional prover cost to the prover. And this fully circumvents that.
00:13:56.280 - 00:15:20.296, Speaker A: And the last thing that I wanted to add is, okay, we went from server side proving, we went to client side proving, and let's just expand. I think you've seen this diagram many times onto different flavors, but it is, I have many proofs and I aggregate it, and then I post one proof. And this is just one thing, right? This could be proof or aggregation. This could be intent matching, solving any type of aggregation that really lets the developer be lazy and don't have to think about how they should communicate with that because they. With other roll ups, because they just plug in and communicate. So as Mustafa said yesterday, you know, lazy bridging is a lifestyle. And this is where I want to, you know, revamp and take a step back where we as a community and in the working group like we were proposing this ZK account primitive.
00:15:20.296 - 00:16:04.930, Speaker A: And it is a very small primitive, right? This is a small change. It does not increase state bloat. It increases the trust minimization of the end user. And it really unlocks so many things because you can now with a small primitive have profound value in having all of those additional functions. And yeah, with that I want to thank you. This is my talk. And yeah, if you have any questions, please ask them.
