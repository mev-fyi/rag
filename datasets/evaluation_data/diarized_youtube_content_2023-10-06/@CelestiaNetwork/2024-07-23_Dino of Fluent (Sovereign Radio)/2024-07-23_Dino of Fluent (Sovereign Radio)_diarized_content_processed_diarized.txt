00:00:00.760 - 00:00:14.190, Speaker A: Welcome to the second annual sovereign radio. I'm your host, Chango Unchained, and I'm here with Dino from fluent, and we're going to talk about blended vms. Welcome to the show.
00:00:14.310 - 00:00:27.118, Speaker B: Great to be here. Excited to chat and thank you for you guys hosting this, like, amazing event. Probably my favorite event. It was definitely my favorite event last year, and I'm no doubt that it'll probably be my favorite event this year.
00:00:27.174 - 00:01:05.054, Speaker A: I agree. I can't take credit for organizing this event at all. This is a Yaz and Natalie production from Celestial Labs, and I'm just an interviewer here. Yeah. So we're here at Modular Summit, and you gave a talk about fluent and the problem space of having multiple vms and not really having some kind of coordinated platform for people to pick and choose what they want to use. So right now, there's been a Camryn explosion of different vms. There's moviem, SVM, the EVM.
00:01:05.054 - 00:01:17.130, Speaker A: Obviously in Cosmos, we have no vm, so there's just too many to choose from. But fluent, interestingly enough, is doing something called blended vms, and we want to hear about that.
00:01:17.430 - 00:01:52.038, Speaker B: Yeah, happy to talk about it. So, yes, as you said, there's a cambrian explosion of, like, l two s chains, Vmsheende. And right now, I think our view in the problem space is right now, you really have to make some pretty stark trade offs, like just a very coarse grain, let's just say the EVM type world. And even to some degree, the SVM has some go to market benefits. People shit on the EVM, and for valid technical reasons. But from a go to market perspective, if you're a dev bringing something into the market, there are reasons to use it. You can actually iterate more quickly, the tooling, the knowledge base.
00:01:52.038 - 00:02:33.890, Speaker B: You could type something into Chachi BT and get an answer if you have a problem. So I'll call those go to market reasons. But then, at the same time, there's a lot of, as you said, next gen vms popping up, whether it be at MovM, be it a number of other vms that have kind of technical benefits, whether it's like formal verification or parallelization, whatever. And so, like, right now, people have to. I mean, previously, people had made like, a very stark decision whether it's like, okay, do I care more about the ecosystem go to market benefits or the technical benefits? And, like, the reality is, you know, it's kind of a hard choice because, like, the technical benefits are very. Have been very sexy over the past couple of years. Or the past year mostly.
00:02:33.890 - 00:03:17.142, Speaker B: But, like, you're kind of placing a pretty extreme bet on an ecosystem to, like, be able to bootstrap something new. And so what we're doing is we said, okay, well, can we actually give people the best of both these worlds? And what we, as we say it, like, blend. Like create a new type of blended vm that actually lets people come. And depending on which VM support, like the person supports, obviously fluent is like one. Ideally, the end state is fluent is kind of like the first blended execution network, but just one blended execution network. We focus on EVM, Wasm and SVM apps. So the idea is a dev can come that you can copy paste evm stuff in there, copy paste svm stuff in there, build wasm stuff.
00:03:17.142 - 00:03:56.750, Speaker B: So what that means is any of the languages that compile, I mean, obviously that includes cosmosm, so not cosmos and at least not right now, but any kind of languages that compile down to Webassembly. Like right now, we're just starting by supporting rust, but we'll add, like, typescript and many others over time. But I guess just, like, more broadly, we will end up supporting different VM environments. And I think we can get into this later if you want. But the design to which we built the system makes it pretty trivially extensible to other environments. So we could add fuel, we could have moved, we could add whatever else. So we could add cosmosm.
00:03:56.750 - 00:04:17.482, Speaker B: It's a little bit more tricky because that's obviously go, and so we would need to do it in, like, tiny go and whatever. There's some, like, implementation stuff there. But, like. But, yeah, it's a pretty cool design. It gives developers, like, just a ton of expressivity on what they want to build. Right. I mentioned the simple base case of, like, easily porting over things from SVM, EVM, and, like, building wasm stuff.
00:04:17.482 - 00:04:35.808, Speaker B: But I think the more interesting thing to do is build what we're calling, like, blended apps, which you can think of it as imagine somebody building just a solidity app that leverages some rust libraries. Very simple, but you can actually get exposure to just many, many more tools and building blocks than you otherwise would in an EVM only chain or an.
00:04:35.824 - 00:05:34.474, Speaker A: SVM only chain as a developer. Because at least in the cosmos space, the problem with us is that we're not compatible whatsoever with the EVM. And in order to do so well, there have been Cosmos SDK app chains that have been built that have EVM in it. So we have geth as a module, and so that's been the way that we've been kind of speaking the EVM language in Cosmos. But then, at the same time, the UX is such that it's almost like two separate chains in one. And in order to transact in that one app chain, there's almost like some kind of bridging involved. And so if you have a blended vm in one execution environment effectively, how would that work? Would it be, like, many different little vms, like little evms and, like, Cosmos and VM and move vm and then bridging between each other in that sense? Or what would the UX actually be like for an average user?
00:05:34.562 - 00:06:07.822, Speaker B: It's a good question. So, like, what we've seen over the past year is a bunch of different, like, attempts at solving this problem. And, like, for the MO and a lot of them, they play out exactly how you described, where, like, you would actually take multiple different vms and run them. Sometimes it's by, like, a third party team that comes in and say, hey, how do we get, like, EVM on salon or EVM on this or even on that? And. But, like, fundamentally, they're just like a VM kind of like running or force fit onto another VM. And that ends up, like, from our experience being like, pretty clunky. And so we didn't want to take that approach.
00:06:07.822 - 00:06:52.626, Speaker B: You also see other approaches that just have multiple different vms. I'll say, like, more on like the same plane. And like, the interop experience is, like, better, but we still don't find it to be like, that efficient or scalable. And so what we did is we basically just solved it using pre compiles. And that ends up being much more efficient and actually makes it not only more efficient to ZK prove the current vms that we support, or vm targets that we support, since, again, we're not actually running those vms, we're simulating them, but also makes it pretty trivially extensible to new VM targets. If we wanted to add, I think one of the first external vms that we're going to add is fuel VM. We've been talking to them, and we could add move, and we could add some other.
00:06:52.626 - 00:07:15.758, Speaker B: And there are other implementation challenges to doing so. And that doesn't necessarily mean want to support all of those vms on our l two instance. But as far as the vm and framework called fluent base that we're building on the side, of course we want to integrate more vm targets so other people can spin up chains with different types of combinations or different blends of.
00:07:15.774 - 00:07:43.250, Speaker A: Vms help me understand your architecture a little bit better. It sounds like you're a roll up, and your roll up that runs these precompiles of different vms. But as a DAp developer who's using this, let's say you want to pick up the fuel VM or something, but use your precompile. Where are they actually executing their Dapp? Where is the Dapp actually being hosted?
00:07:43.710 - 00:08:26.050, Speaker B: Yeah, so I want to distinguish, actually, between, let's just say, fluent l two and fluent base. So fluent l two is a roll up on ethereum? That's correct. And there, for the foreseeable future, we'll only be supporting EVM Wasm SVM apps. So in that specific. You mentioned fuel. But in that specific scenario, if you have some type of app that you otherwise could have deployed on Solana or something, or on another EVM chain, you can pretty much just copy and paste it, change your PC, everything works, it's 100% compatible with each of those environments. And then the wasm environment is more of our own thing, where currently we have a rust SDK, but we're going to be building, or the community could build additional SDKs for that.
00:08:26.050 - 00:08:38.734, Speaker B: Now, that's fluent. Let's just say for fluent l two, and then for fluent base, we can add support for more and more VM targets. And I think that what is fluent based?
00:08:38.782 - 00:08:41.102, Speaker A: First of all, is it an app chain or is it a roll up?
00:08:41.166 - 00:08:58.922, Speaker B: Yeah, sorry. That's like a roll up framework. So you can think of it. You can ultimately think of fluent l two, more akin to an op main net, and then fluent base is more of an op stack kind of thing. So it's the l two and then a framework for people to build of, customize their own l two s with a similar core.
00:08:59.026 - 00:09:01.594, Speaker A: Okay, so in Celestia speak, kind of like rogue kit.
00:09:01.682 - 00:09:02.586, Speaker B: Yeah, yeah, exactly.
00:09:02.658 - 00:09:07.346, Speaker A: Okay, gotcha. All right, so how does that work for developers?
00:09:07.458 - 00:09:17.266, Speaker B: Well, developers building, like the. Like a chain with fluent base, or developers who are deploying on, like, a chain, like on a blended, like, roll up, basically. I could probably talk to the louder.
00:09:17.338 - 00:09:25.348, Speaker A: What do you. What part of this entire thing do you see actual traction in? So, like, who's your target?
00:09:25.514 - 00:10:05.540, Speaker B: Yeah, good question. So, like, we're. I mentioned those two things. We're completely focused right now on the first one, which is just like rl two. Getting that off the ground is obviously just like a difficult enough, like, you know, challenge and building momentum around that. And so our, like, target audience would just be like, devs who really want to just like, push the boundaries of, I guess, what was previously possible with like the EVM or any of these individual, like, these individual execution environments. Right? So, like, we're seeing some excitement around people taking, forking stuff in solidity, but differentiating it, it could be a Dex, it could be whatever, differentiating it in rust, for example, that happens to be the first thing that we're supporting.
00:10:05.540 - 00:10:26.806, Speaker B: But you can envision a lot of different combinations like that where you can basically add either more efficient components to your app that wouldn't have really been feasible in solidity or just make things more performant using, right now, rust, but ultimately c libraries or things like that.
00:10:26.968 - 00:10:36.546, Speaker A: Gotcha. Right. So speaking of the blended VM, how do you see people actually using it in practice?
00:10:36.738 - 00:11:32.798, Speaker B: So, one thing to note, like, we actually just released our Devnet maybe like a few weeks ago, and so it's early days for us, but we are seeing a lot of interesting, like, we're kind of seeing two different things. Like, for the most part, it's been very easy for people to port over just like solidity apps. So people who are just like, excited about the future of like, kind of blended vms and like, what's possible there. So it's kind of like more like go to market side, but like, at the same time, we are kind of like exploring the design space with, with devs, trying to build kind of like new things. So we're seeing some interest from like, like the gaming community. You know, you have a lot of those folks who like, are, you know, they appreciate the properties of, like, rust and like, they also understand, like, the value in basically, like, design. They're like, they're like, they're world builders, right? Like, they understand the value of just kind of using kind of like the best component, the best tool for each part to really make sure you design the best experience.
00:11:32.798 - 00:12:04.326, Speaker B: So the idea of using solidity where it makes sense and using rust where it makes sense really resonates well. And so I think we're pretty well suited for some stuff in kind of gamefi. We're also seeing a lot of those types of builders start to become more interested in social fi consumer stuff. I think that's just based on the state of things today where a lot of excitement is going. So, yeah, we'd be happy to foster those types of environments, but at the end of the day, obviously permissionless system and build whatever.
00:12:04.438 - 00:12:15.198, Speaker A: Yeah, that's really interesting. Do you see this scaling to billions of users in the future? Or is this more of a proof.
00:12:15.214 - 00:12:20.742, Speaker B: Of concept right now, the l two scaling to billions of users, or. What do you mean?
00:12:20.846 - 00:12:46.492, Speaker A: Well, for example, if someone were to build a gamefly application or social fi application that has, you know, potentially hundreds of millions of users early days, then I would imagine it needs to scale, right? So this architecture is really novel, let's say. So I'm wondering how that's going to scale for any one of these applications that you gave an example of.
00:12:46.556 - 00:13:02.532, Speaker B: You know, we'll probably run into similar. At some point, like, run into similar challenges as any other roll up or chain, right? This is definitely nothing. Trying to. Oh, yeah. There's one thing I want to make clear. Like, this is definitely not us saying, like, hey, we have this blended VM. You could put everything in it.
00:13:02.532 - 00:13:34.546, Speaker B: So, like, let's just, you know, sorry, everybody go home. Like, this should be, like, the one place where all the apps go. Definitely not like, what our main point is somewhat technically, like, obviously there are limitations. Like, you know, we will. I think this will be a very, like, scalable design because we can actually, like, paralyze the blended VM and then actually get some of those parallelization benefits for kind of the supporting VM targets that we offer. But, like, just completely putting, you know, completely putting that aside. Like, no, we don't think this will scale to the, you know, billions of people in the world.
00:13:34.546 - 00:13:59.894, Speaker B: And our idea is not like, hey, this should just be one big, fat roll up. Instead, we do see, you know, if there's going to be a million, you know, single execution networks, as we, as we call them, like, EVM only or whatever, we would love to see a million, like, blended execution networks. And we just think it's like, you know, it broadens the design space for any of these individual sandboxes. So we just think it's, like, a better way to build execution environments.
00:13:59.942 - 00:14:07.650, Speaker A: Okay, interesting. Would you almost call this blended execution environment a hybrid of sorts?
00:14:08.030 - 00:14:11.410, Speaker B: Yeah, I guess you can call it that kind of. Yeah, you could.
00:14:11.750 - 00:14:16.222, Speaker A: I'm just thinking about dog breeds right now. Just, like, putting all of them together.
00:14:16.326 - 00:15:07.166, Speaker B: Yeah, well, the thing is, like, I don't think we, like, we don't want to put necessarily, like, all of them together. There's definitely, like, some, like, technical, like, challenges. If you were just gonna, like, keep adding more and more and more, that would get really hard. So we're focusing on these three strategically, I think, obviously, EVM and SVM. SVM is interesting technically and ecosystem wise. EVM is interesting ecosystem wise, and then we think web assembly is awesome, and we think that enabling people to use millions of more libraries and dozens of more programming languages in tandem with what's already established in web3 just ends up being a net better experience for developers, especially if you can actually crack the code and make that like a seamless developer environment. But we don't necessarily even see any individual blended execution network just supporting everything.
00:15:07.166 - 00:15:37.642, Speaker B: Ideally, let's just say we support those three, maybe add a couple of more if they're interesting in our l two. But as we actually get this framework off the ground as an act two, I guess, and people start building other blended execution networks, you know, maybe they make different trade offs, right? Like maybe somebody wants to just focus on like, move and SVM great. And make it like super compatible with, like, move things. Like great, do it. So I really think that's why I'm saying, like, I think that it's just a better way to design execution environments, no matter what types of trade offs you want to make.
00:15:37.706 - 00:15:56.252, Speaker A: Yeah, fair enough. All right, well, if you've been nerd sniped by Dino here, please follow more about fluent in the future and tune into his talk at modular summit, which will be in the same series, I believe so, yeah. Thanks for tuning in.
00:15:56.356 - 00:15:57.180, Speaker B: See you. Thanks.
