00:00:04.650 - 00:00:13.950, Speaker A: Hello. Can you guys hear me? So why don't we start with a brief round of introductions? Marco?
00:00:14.690 - 00:00:24.346, Speaker B: Yeah, I'm Marco. I work at Interchain Gambaha, and I'm the current product owner of the Cosmos SDK. I've worked from Tendermint all the way to the Cosmos SDK.
00:00:24.378 - 00:00:37.510, Speaker C: So just having done with it, I'm James Prestwich. I'm currently CTO at Nomad, which is a modular bridge focusing on smart contract chains and arbitrary message passing.
00:00:38.250 - 00:00:45.770, Speaker D: Hi, I'm Beau. I'm co founder at Polymer Labs, and we're working on a universal IBC interoperability hub.
00:00:46.510 - 00:00:53.790, Speaker E: Hi, I'm Alex. I'm an engineer at Protocol Labs. I've spent the last three years or so working on filecoin as a software and protocol engineer.
00:00:54.290 - 00:01:51.354, Speaker A: Thank you. So Mustafa made this very clear distinction this morning, what a modular blockchain is and what modular software is and where the distinction? You drew a clear line. So let's also briefly summarize what modular design in general is. Modular design means that you basically break up a system into smaller parts, so called modules that can be used in other contexts that can be changed. Or basically, you can plug them into other systems as well. And in modular software or like modular programming, you basically subdivide your program in modules where the modules only execute. The part that you care about modular blockchains is when you basically outsource core functionality of a blockchain.
00:01:51.354 - 00:02:09.206, Speaker A: I think that was made very clear throughout the day. So I wanted to ask the panelists, where do you see modularity emerging basically in the fields that you work on in the Cosmos SDK? I think Zaki took most of it away in his talk, but maybe you.
00:02:09.228 - 00:03:00.440, Speaker B: Have more for us. Yeah, unfortunately, I didn't see Zaki's talk, so I don't know if I'm going to say something wrong now, but the Cosmos SDK was always built, or the Cosmos ecosystem was always built with the mantra of there will be many chains in the ecosystem, kind of this interchange world with IBC. And so the idea of modularity in a framework to rebuild, to build new blockchains and make it faster to scale has always been at the core of Cosmos. And so with the Cosmos SDK, it's evolved over the last it's been around for like, six, seven years now. And now at the most latest, I think it's the most advanced, and it's truly modular. Now we're seeing chains pop up in the Cosmos ecosystem that go from like, Inception, and then one month later, they have main net, and we really haven't seen that. And building a modular software stack allows people to accelerate their products.
00:03:01.530 - 00:03:02.440, Speaker A: Thank you.
00:03:03.370 - 00:03:54.040, Speaker C: Right now in bridges, we're seeing a lot of modularity in the separation between communication channels and the applications that they run, between how you actually pass data between chains and between what's done with that data, like token bridges, NFT bridges, governance systems. One of the things we built at Nomad that we're very excited about is a strict interface for how a communication channel connects to an application. And this should let applications like Bridges swap out IBC for nomad channels for anything else they want. In general, we think of modularity as finding the right place to separate a concept into two smaller pieces and finding the right interface for that, finding the right interface for that separation and defining the contract around it, how people use it, and what they can rely on.
00:03:57.530 - 00:04:43.320, Speaker D: We see IBC as defining those interfaces, like James said, in a really nice way, kind of separating the transport authentication ordering layer from some of the application semantics. You can kind of see it in the interchange standards. There's clear distinction between the two layers. They have a number of specifications that they review by the community and across different organizations. And one more thing I would like to say about what Mark was talking about in terms of the Cosmos SDK is that I think the Cosmos SDK does a really good job of making the components so modular. You can replace certain components, like with what Celestia was able to do, come and replace Tendermint core with optimate and basically do what they do and be able to innovate. And that's a really important thing that I see here, is that it allows different organizations to come together, build together and innovate very quickly.
00:04:45.290 - 00:05:39.020, Speaker E: Yeah, I mean, modularity of software is very core to how Protocol Labs tries to build things. IPFS, for example, has a sort of strong brand as a thing. But really IPFS is a collection of protocols and components that are put together, a data model in IPLD, some network transports from Lib PDP, a few different ways of exchanging information. And so really we don't think of there being a protocol as IPFS, but a node can participate in an IPFS network if it uses a similar network protocol and if it adopts one of the transport protocols, one of the data exchange protocols that one of our IPFS nodes will use. And then similarly, those pieces can be taken by other projects. And so other projects will use Lib PDP for their networking. That automatically puts them a step closer to interoperating with other projects that do the same thing.
00:05:39.020 - 00:05:46.780, Speaker E: And the IPLD data model, again, is not specific to IPFS and is a foundation for other applications data.
00:05:50.430 - 00:06:04.450, Speaker A: In the so the Cosmos SDK was mentioned several times in the Cosmos SDK and particularly in Tendermint. Do you see anything that is currently more monolithic, that should be more modular? Marco.
00:06:06.550 - 00:06:18.280, Speaker B: Thankfully, no one here who works on Tendermint Core very opinionated on this. Tendermint was always built as a library. So kind of when Jquan and Ethan Buckman wrote it, the idea was.
00:06:20.810 - 00:06:21.126, Speaker A: You.
00:06:21.148 - 00:07:06.130, Speaker B: Have consensus, you have P to P and all these things. But it's like if someone wants to switch out consensus from tendermint consensus to hot stuff, it should be easy enough to do it. It was always meant as like a consensus framework, a consensus library. And over the years, building modularity is very difficult, especially at a low level, because you're kind of making assumptions of how the application developers will use it. How the clients will use it is somewhat easier. But application developers, the deeper they go, the more freedom they need in developing their software. And so at the lower level, tendermint has kind of shifted more, less from being super modular to being a bit more opinionated, because if you make too many opinions or you don't make that many opinions, then it becomes really hard to build software.
00:07:06.130 - 00:07:16.470, Speaker B: But in tendermint in general, I just wanted to be more modular. I wanted to switch out P to P with a click of a button instead of having to fork the code and rewrite some stuff.
00:07:16.620 - 00:07:32.750, Speaker A: Yeah, that's what we do at Celeste. So one aspect that was also mentioned several times is like, also, would you also describe it as modular, or is it something specific to the Cosmos ecosystem only maybe? James.
00:07:34.930 - 00:07:49.700, Speaker C: I really enjoy working with IBC. It is modular in a sense that it can be applied to other ecosystems. I think that the amount of effort it takes to reach other non tendermint ecosystems right now is very.
00:07:51.910 - 00:07:56.898, Speaker B: Actually, it's actually a lot easier than we first thought.
00:07:57.064 - 00:09:07.050, Speaker C: Okay, I'll talk to you after the know. It took a number of years to develop IBC for tendermint. In the first place, it's going to take a little while longer to productionize it outside of the tendermint ecosystem in the E Two model, where they have a proof of stake system that admits some reorgs. We have a lot more work to do to parameterize IBC and make it work for the Casper based consensus system, which is why we focus on not just the IBC connection, but what applications can we build today that can be eventually connected by IBC once it's ready? And what channels can we build that can be used today that can be swapped out for something more secure or faster once it's ready? This is one of the great parts of modular design, is it allows us to go build scout modules that go fast, break things, colonize new ecosystems. Not colonize, but explore. Explore. That's a good word, Tracer.
00:09:07.050 - 00:09:29.620, Speaker C: Wander around new ecosystems, find what works, and then we can bring in these heavier and better things like IBC in the long run, once we have figured out what an application developer wants in a specific chain ecosystem, modularity allows progressive development and upgrades over time.
00:09:33.510 - 00:09:46.790, Speaker A: Let's talk a bit more about Bridging and IBC in that sense. So modular blockchains, does it make your life much harder as a Bridging provider or like as someone building bridges? Thinking about bridges?
00:09:48.650 - 00:10:13.310, Speaker D: I think so. Sorry, you can go. I think so. I think there's more considerations to make. For example, like when you separate consensus or perhaps execution from the data availability and consensus layers. Now you have to say like, well, on this end we have data availability headers, on this other end we have state proof headers. We have to somehow combine these things when we want to perhaps produce a fraud proof.
00:10:13.310 - 00:10:23.106, Speaker D: But yeah, I think there are more considerations to make and how all the pieces fit together, it's not fully clear yet, but I think we're going to be able to figure those things out.
00:10:23.208 - 00:11:00.366, Speaker C: Yeah, one of the interesting challenges is that the bridges like IBC, which are kind of the ideal, most secure model you can get, they mix the execution and consensus layers, they have to cross that boundary, they can't be confined to one or the others. The bridges that we work on, and that can be iterated fast, they stick in the execution layer, they don't really touch the consensus systems. So modularity might make this more challenging to reach the long term goal of having these consensus layer bridges everywhere because there will be more consensus modules that.
00:11:00.388 - 00:11:26.946, Speaker A: We have to account, more execution modules as well, which will also play into these kind of bridges. Yeah, let's take a step back and talk more about modular software aspect. So first of all, do you see any downsides of building your software more modular, maybe Alex or Marco?
00:11:27.058 - 00:12:29.510, Speaker E: Sure, yes. There's always a trade off, I think, to building something more modular. To build a module to be reused by others is in a sense to take on an obligation to serve others needs and you don't know who they are when you start building and they don't know who they are when you start building. But eventually in order to serve some needs well, you'll have to optimize towards those and necessarily be less good for some other use cases. And so at some point someone else coming along with a new novel application, wanting to plug it together out of modular pieces, will find that they can't get the performance or the features that they need. And so at the other end of the stack is sort of vertical integration and there is a great place in the world for vertically integrated software and vertically integrated systems. Car manufacturing is probably a timely example now where for a long time car manufacturers were outsourcing and modularizing and buying and putting together components from other lower level manufacturers.
00:12:29.510 - 00:13:09.218, Speaker E: And there was this old joke in the auto industry that you could see the chart of the car company from the layout of the dashboard and you could see like there was a climate control team and a radio team and a navigation team and so on, but then Tesla came along with entirely new needs. And so they are a vertically integrated car company and they make almost all of their own components and they use their own manufacturing processes and can produce a different thing at a price and performance that could not be met by stitching together the modules that existed beforehand. And so I wouldn't be at all surprised if we see a continual sort of back and forth between modularity and vertical integration. In five years time, maybe we'll be at the vertical integration summit about all.
00:13:09.244 - 00:13:48.674, Speaker B: These special purpose blockchains to kind of add on to that. It's like when you're building modular software, you're also providing a guarantee of security and kind of the assumptions you made when building the software. But especially you can't predict what a developer will do when they use your software. And so you providing a guarantee for this software and then maybe them taking it and changing a few variables kind of breaks that guarantee. But for them it's like if they say we are using the Cosmos SDK and we got hacked, it's like, no, you guys are using a fork of the Cosmos SDK that you guys rewrote a bunch of stuff. This shouldn't really fall on us because Cosmos SDK, we provide a security guarantee of the software that's in the code base.
00:13:48.872 - 00:14:07.386, Speaker C: Yeah. You kind of have to teach developers not just about the system that you built, the module itself, but about the interfaces and the boundaries of that module and what they have to do to keep the module working with other modules correctly. So there's a lot more developer mental overhead for these things.
00:14:07.568 - 00:14:34.658, Speaker B: Yeah. And you end up talking with a bunch of users like, how are you going to use the software? And I think in the current blockchain space in the past year or something, we've kind of run into this cycle of like we're kind of rinse and repeating many similar products. And then so it's like you build your modularity to serve these products then you all of a sudden get a team that does something out of the box and you're like, okay, wow, this is where we want to be going. Because this is pushing the boundaries. This is something that's next, this is the place that we're comfortable in right now.
00:14:34.744 - 00:14:56.614, Speaker C: Yeah, I think that brings up an interesting point that I want to connect to. Alex over here is we always start off building bundled projects, everything's integrated in Ethereum. And it's because we just didn't know how to do any better at the like. We built Ethereum the way we did because we had no idea what modularity was or what the right boundaries between different parts were or where the consensus.
00:14:56.662 - 00:15:00.278, Speaker A: Coin is even more extreme to that. Like it's more monolithic, like more integrated.
00:15:00.374 - 00:15:20.478, Speaker C: Yeah, we built it monolithic because we didn't know what the right module boundaries were. Now that we know we can build modular systems and then eventually, once we have modular systems everywhere, people are going to want to go back to monolithic to eke out those little gains they can get by eliminating the edges between modules.
00:15:20.574 - 00:15:22.500, Speaker B: Yeah, that's the typical problem.
00:15:23.990 - 00:15:35.110, Speaker C: Yeah, exactly. In web development we've seen it go from monolithic services to microservices and back to monolithic because people get frustrated with whatever the current model is.
00:15:35.260 - 00:15:39.650, Speaker A: That's basically what Alex also said previously. There will be a constant back and forth.
00:15:39.730 - 00:16:05.806, Speaker E: Yeah, we're in a great space now where it's all about the pace of innovation and modularity is fantastic for you can quickly plug together a few things and maybe you take some trade offs, but you can learn really fast. But once we really know what we're doing james is right. We didn't know what we were doing to start with. IPFS is just the same. Lib PDP didn't birth as an independent project. It was extracted from IPFS and so were some of the other protocols over time. And then we realized what we're doing and what we want to plug together.
00:16:05.806 - 00:16:14.018, Speaker E: And then when someone really knows what they want to do, they're going to go and do it from scratch in a vertically integrated way again, when they're going to sacrifice the ability to change it later.
00:16:14.104 - 00:16:17.990, Speaker C: Yeah, and we had to do it that way because we didn't know any better.
00:16:18.060 - 00:16:18.482, Speaker E: Totally.
00:16:18.546 - 00:16:24.150, Speaker C: We had to experiment with it first as a monolithic thing to figure out the right way to build modularity.
00:16:25.130 - 00:18:14.300, Speaker A: So some theme kept popping on. Recurring theme that was mentioned on the panel is like the interaction with users and people using your modules potentially different in different ways that you didn't anticipate, maybe. So one thing that I wanted to ask, and I don't have an answer to it at all myself, but how do you basically maintain these modules from a governance point of view? Potentially you have tenement, maybe you have the Cosmos SDK and its modules and you have something like Lippy to P, which is widely adopted across the blockchain space or other non crypto projects as well. How do you make sure that this is somewhat like is it like in any other open source project where you basically maintain it and you discuss things on GitHub and this is like you submit RFCs and you discuss and you discuss and eventually you come to an agreement and you implement this or that feature or this and that addition to the protocol. Is it exactly like this? Or are we in a space where I feel there's all these projects that are kind of like collaborating using the same software, using the same open source software and they are at the same time collaborating, but at the same time somehow also competing? It's like do we need other means of governance and do we need to align incentives here or is that something that is unnecessary? I know it's like a tough question. I could probably do a whole summit about this topic, but I just want off the top of your head, what are your thoughts on this, particularly Marco and Alex? Maybe.
00:18:18.510 - 00:18:19.930, Speaker B: I'm going to have to think for a second.
00:18:20.000 - 00:19:03.290, Speaker E: Yeah, sure. I can start as far as I don't have anything that says it's different to other open source software yet maybe it will be, maybe we'll learn about something or perhaps some better way of doing things. But I think it basically comes down to open source software development. And most of my ideas here, I'm like shamelessly parroting things from Nadia Egbal and her book Working in Public, which I think really sets the stage for the discussion here. Software, the code itself, once it's produced, is a public good. It can be taken and used by as many people as possible with no marginal cost. But software development and the software development resources, the people and the time and the attention is a scarce resource that is competitive.
00:19:03.290 - 00:19:59.926, Speaker E: It sort of comes down to a discussion about at what level do you want to be open and decentralized and permissionless. It doesn't scale for a team building a critical software component to accept contributions from everywhere, to answer every question, to allow anyone to have their say on how the software should be written, the team will immediately grind to a halt and be unable to make any progress on the things that are important. But we can sort of add the robustness, add the antifragility back at a higher level by agreeing perhaps on a protocol and then having multiple implementations of it. So there are multiple implementations of Lib PDP, and they agree at the protocol level, but then are free to make all of their implementation decisions independently. And so it's robust in the sense that individual software libraries can fail. Most open source software libraries go nowhere. They're pet projects, they don't gain traction, they don't go anywhere.
00:19:59.926 - 00:20:16.560, Speaker E: And that's fine. And that makes the ecosystem of open source software incredibly robust, because individual projects can fail on the way to us discovering and supporting the best, most useful projects and then one day forking them when we need different needs from them.
00:20:17.090 - 00:21:17.778, Speaker B: So at least in the cosmo space, we're starting to get to the point where we have to put a lot of parameters that are kind of like feature flags inside modules for things that are changing to replicate the similar behavior. In the early days when the Cosmos Hub first launched, and there's maybe a couple of other chains, it was easy to coordinate, like, we go talk to these three chains. Do they want this change? Some of them put it to governance, some of them don't, some of them say it's fine, and then we go forward with it. Right now there's roughly 35 chains. And if we introduce like a consensus breaking change that they may not read the change log for and all of a sudden have this irregular behavior that they weren't expecting, causes a huge, huge problem. And so feature flags are kind of like the worst thing you can do in software and just adding a bunch of them just because you end up having to maintain so much extra software that you don't know how. Many people are using but in an environment that you don't know how many people are using your software because they may be rebranding it as their own or they may be forking it and saying something else, then it's kind of hard to be like, okay, we're making this consensus breaking change.
00:21:17.778 - 00:21:25.560, Speaker B: If you don't like it, you have to go do it on your own. Because we want to also avoid people just forking the repo just to do little changes.
00:21:26.410 - 00:21:35.434, Speaker C: This is a little embarrassing for me because I have an unmaintained Cosmos SDK module that needs to be updated for the breaking changes.
00:21:35.632 - 00:21:36.860, Speaker B: Yeah, exactly.
00:21:38.670 - 00:21:40.620, Speaker C: I'm feeling a little called out here.
00:21:42.030 - 00:22:05.060, Speaker A: But none of you think that there needs to be basically some dow structure or something like that to maintain because in this space, there's always these incentives, right? Like, you have stakeholders, you have maybe even competing projects that use your stack, right? Yeah.
00:22:06.150 - 00:22:49.170, Speaker B: It's a super hard question to answer. And in terms of governance and the Cosmos SDK land and Tendermint, it's unfortunate to say, but there's like a finite amount of people who actually understand the protocol, and there's a lot of people who use it. And so if you end up involving all these people who just use the software and maybe they write applications with the Cosmos SDK, they never have dove into tendermint. And all of a sudden you have to involve them in tendermint discussions on like, oh, are we changing to lib P to P or are we changing to this? Are we changing to this? Then the process gets dragged out. Like Alex said, you end up hitting a wall and then the spec keeps moving and the developers kind of get burnt out because it's just kind of like you're trying to implement a moving spec and then it just becomes an infinite loop.
00:22:50.310 - 00:22:59.830, Speaker A: It's like you don't like democracy, basically. But yeah, I got the point and it makes sense, but it's a recurring thing. And you talk about governance.
00:23:00.970 - 00:23:33.040, Speaker D: I think we're talking about interfaces and layers and also governance and consensus over those interfaces and layers. And Alex made a really good point about if you define certain interfaces, for example, within the Cosmos SDK, you have the ABCI. It's evolving to the ABCI plus plus there were some interface changes at the two client level to support the development of different light clients. I think the idea is that you want to have some sort of consensus over these layers and how they're defined and then be able to have protocols come in and innovate and make trade offs beneath between the interfaces themselves.
00:23:34.210 - 00:23:56.144, Speaker A: Makes sense. Do we still have time for a few questions maybe from the audience as well, if there are any? I always asked a few questions before, and I was like, Keep them for later, but not sure if people asked it here. Are there any questions? Don't be shy. One over there. Where? Up there.
00:23:56.342 - 00:23:57.410, Speaker B: There we go.
00:23:58.260 - 00:24:03.350, Speaker A: People are running away. Can introduce yourself?
00:24:03.880 - 00:24:16.760, Speaker F: Hi, I'm Max. Can you comment on maybe there'll be an overlap in the future where the communication mechanism, the bridges overtake the actual chain.
00:24:18.700 - 00:24:22.500, Speaker C: A future where the communication layer in the bridges overtake the chain.
00:24:22.580 - 00:24:38.080, Speaker F: So where we're looking at modularity, especially like with Celestia, where it sort of enables cross chain applications, would you see that the bridging technologies become more dominant than, say, on chain activity colonization?
00:24:40.660 - 00:25:29.500, Speaker C: That's an interesting question. Typically, the Bridging technologies can't provide what users want out of a chain. Users want to store their assets, to trade them, to lend them, borrow against them, all of these things that bridges are poorly suited for. The way we look at this future is that bridges are going to be asynchronous communication channels between applications that are homed on individual chains. And I don't see that changing in the near future. I do think that there will be some Bridging standards that are just on every chain, implement the same standard in solana rust and near rust and polkadot rust and solidity and everything else. But I wouldn't say that they would dominate the chains.
00:25:29.500 - 00:25:32.480, Speaker C: They might just be widely deployed on chains.
00:25:36.980 - 00:25:40.710, Speaker A: More questions? There's another one over there.
00:25:50.530 - 00:25:51.326, Speaker B: Hi.
00:25:51.508 - 00:26:21.080, Speaker G: My question is more to the interoperability rather than modularity of parts. We're seeing now a lot of the crosschain protocols are trying to build essentially similar cross chain messaging protocols as IBC is or XCM is for the substrate. Do you see these becoming they're becoming like a standard to allow them to interoperate, or it's more of which ecosystem wins out?
00:26:21.870 - 00:26:23.260, Speaker B: IBC is the standard.
00:26:24.590 - 00:26:26.314, Speaker C: IBC is a standard.
00:26:26.512 - 00:26:28.460, Speaker G: Tell this to the XCM people.
00:26:30.350 - 00:27:05.160, Speaker B: We've talked with the web3 folks and the polka dot folks about IBC. We're working with a couple of teams implementing IBC on substrates via grandpa like clients and mountain. There's some new consensus that they're doing. And so we're working with people who are implementing both. And the idea behind cosmos and IBC and everything is just kind of like interoperates with everyone because it's like a connected ecosystem of blockchain, not of a specific smaller ecosystem. Just makes everyone better. And so, in a way, we lift everyone up.
00:27:06.730 - 00:27:57.474, Speaker C: IBC includes a lot of different parts of this bridge stack as well. So when we talk about IBC, we have to distinguish between which ICSS we're talking about, which touch different parts of the modular, like chain stack and bridge stack. So some ICSS will be the standard, and some of them won't make sense in specific chain environments. So thinking about this a little more, to answer Max's question, I think a little more in depth. You could look at IBC as an example of the communication standard dominating the chain in that cosmos chains are designed the way they are in order to support the current set of ICSS. Cosmos zones are designed to participate in IBC. And that is one of the defining, most important elements of Cosmos.
00:27:57.522 - 00:28:06.458, Speaker A: Yeah, so you can use it off the shelf without adding another IBC client. That makes sense. There is, I think, another question over there. Last question. Yeah.
00:28:06.624 - 00:28:07.660, Speaker C: Hi, friends.
00:28:08.270 - 00:28:19.360, Speaker B: Basically, I think, say all this modular stuff plays out two years from now. What are your thoughts on what this post modular world looks like? What things are we going to focus on? Is this more like application layer stuff?
00:28:20.050 - 00:28:21.662, Speaker A: Yeah, that's a great question.
00:28:21.716 - 00:29:35.410, Speaker E: To end the panel, may I start to step back and look at why we're here? We're trying to build the reason that blockchains and execution layers and so on are interesting is because we're providing a platform for applications to be built, software for people to use to achieve things, and in our case, ideally, things that are cooperative or collaborative in some way. And so there are a lot of modules to be built out in this platform. With a nod to Mustafa's attempt to claim the definition of modularity earlier today in a development, platform needs the execution layer, the CPU in the computer, and it needs some Ram, which is the state. And it needs an I O bus, which is the data availability layer. And it also needs storage, which is filecoin, and it also needs networking, talking to other computers, which is bridges. And there are lots of pieces here that need to all come together into a platform. And I think we will start to see some standard ways, some standard groupings of these modules in much the same way as, like, the IBM PC defined a standard platform much to IBM's detriment, but which then provided the greenfield for application developers to go nuts on this platform that was well understood and widely implemented.
00:29:35.410 - 00:29:43.260, Speaker E: And so, hopefully, in two years time from now, that kind of platform is understood and we're talking much more at the application level.
00:29:43.790 - 00:29:46.922, Speaker A: Thank you. Okay, that was it. Thanks.
00:29:46.976 - 00:29:48.060, Speaker C: That's a good way.
