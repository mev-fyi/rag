00:00:00.330 - 00:00:32.978, Speaker A: You. Hello everyone and thanks for coming today to kind of like moderate summit. And today I want to talk about a little bit of something that we've spent the past almost three quarter of a year working on. But the story, as you will see, is much longer than it currently has, seems like. So yeah, cool. All right, so quick introduction about myself. Before I started Argus, I was one of the co creators of Dark Force.
00:00:32.978 - 00:01:53.594, Speaker A: Dark Force, for those of you who might not have known, is the first fully on chain game on Ethereum built using ZG Snarks. That started with a simple question of like what if we create a game where every single game action is an onchain transaction? Back then in 2020, this was an absurd thesis. A lot of people was wondering why would you make fully on chain games and how is this even possible with blockchain being as slow as it is? But regardless, driven by our curiosity driven our just like our kind of culture just fucking around and finding out, we decided to build Dark Force. And so this is like what Dark Force looks like back in 2019, 2020. And yeah, it's basically a space exploration game where thousands of players were fighting on chain to expand their empire. And within the first week of launch we had more than 10,000 players or wallets and trillions of gas spent in the Ethereum testnets, attracting a large number of players. And eventually we had to move on from testnets because other developers who want to test their applications were not able to and eventually move to a side chain.
00:01:53.594 - 00:03:19.734, Speaker A: And even in a side chain it is supposed to be more scalable. It turns out that it is not as scalable as we think it is. We quickly filled up the entire block space, driving up gas costs and practically making side chains unusable with only a single application. And so now begs the question, right, so with all of that limitations, why are people still so excited about onchain games after Dark Forest? We've seen many people, investors, founders, builders, hackers alike building on top of the legacy of Dark Forest with things like Lattice, building Mud, a library and framework to build on chain games easier and also content companies like primordium building a fully on chain games and also things in auto ecosystem beyond the EVM like Dojo on StarkNet. The key thing here is that we realize that the limitations that we have with existing blockchain comes down to the fact that we are sharing a chain with everyone else. We are sharing this very small room where there's not a lot of space with other applications that also want to use that. And so if you see on the chart there, you can quickly realize that if there's another game like Dark Forest living on that same chain, then there could not possibly be a functioning chain.
00:03:19.734 - 00:04:04.598, Speaker A: And so the question is like, what now, right? Do we just give up? Do we just kind of just throw away the concept of onchain games? And so we decided that no, we want to actually explore how we can build better on chain games. And we want to make sure that the game that we're going to build next is going to be scalable. And so we embark on a journey that starting with a one big key realization that we currently took blockchain architecture for granted. We have all these L ones and L two S, and yet they all look the same. They all will tell you very, very similar things. They'll tell you that our consensus is better, we have better trade offs than the other blockchain. They'll tell you that their VM is faster.
00:04:04.598 - 00:04:46.482, Speaker A: They'll tell you their VM is like paralyzable. Or they'll tell you that maybe if they're an L Two, their fraud prover is better. Or how their other competitors fraud prover doesn't exist, or their other roll up is fake news. Some people will claim that their approving system is better, like our ZK approvers are faster, although we never see the benchmark. But all this war to an end to create yet another Dex that you can deploy on any other chain, like, doesn't matter what VM it is, it all just looks the same. Or to mint yet another NFT that again, you can deploy on any other chain. We decided to take a step back and think differently.
00:04:46.482 - 00:05:24.610, Speaker A: Think how we can actually see blockchain architecture from a different lens. We asked the question of like, what if we escaped the classical blockchain architecture? Every blockchain that we've seen until now, it all looks similar to Bitcoin, all looks similar to Ethereum, behaves the same way. You have the concept of Gas, you have the concept of transactions. Like people send transactions, they submit it to the blockchain and that causes a state transition. It all looks identical to each other. And another key thing that we realized is that other people and other blockchains let it be L One or L two. They're all trying to build a blockchain for everyone.
00:05:24.610 - 00:06:19.238, Speaker A: And I'm not saying this from a wholesome way. It's more of the fact that they don't really take into consideration a specific kind of use case or a specific kind of user persona. And instead they just try to build something that everyone will just assume is compatible with their product in mind. We took a different direction. We choose to build the best blockchain for a very, very specific user in mind, in our case being players and game developers. And so again, we asked this question and it comes down to really understanding how games are vastly different than your typical applications. So for example, application that you might use a lot is things like social media, like Twitter, and the other kind of things would be games like Minecraft, on the other hand.
00:06:19.238 - 00:07:11.206, Speaker A: And so here we can see that with Twitter. Twitter acts in this very straightforward way where if you write a tweet and then you click a button, then you will have your tweet posted. One thing to note here is that every time you click a button there is a user input event and this is what triggers the state transition. This is like what I typically like to refer to as an event driven runtime. As you can see, this is very much similar to how your typical blockchain would look like a user would want to trigger an event and they would click send a transaction and that transaction would inflict it. But if you see games, on the other hand, games doesn't behave the same way as like a web application. Even without user input, even if you're AFK, if you're just like going away with your brother, state transition still happens.
00:07:11.206 - 00:07:55.278, Speaker A: Like fire will continue to cause damage, water will continue to flow, wheat will continue to grow and day and nighttime will continue to move. And this is like what we like to call the loop driven runtime. Key thing here is that no user input is needed to cause a state transition. And so drawing an example back, you will notice that the web app is again very similar to like smart contracts. Let's say in uniswap a user wants to trade token A and token B, you would submit a transaction and that trade is executed. Again, event driven Runtime we realized very quickly this event driven runtime nature of classical blockchains are just not compatible to run a game state machine. And so we kind of explore deeper the loop driven runtime that game has.
00:07:55.278 - 00:08:45.938, Speaker A: And again, all game engine is specifically built to support this loop driven runtime. The key thing with the loop driven runtimes is game progressions and how times are organized within the games is referred to as ticks or the atomic unit of time. Each game loop is going to be executed in a single tick. And the higher tick rate that a game has, the more that the game feels more responsive. If you played game like Counterstrike or Valoran, you'll notice that these games have 20 tick rates or 60 tick rates for the modern game servers. While games that are more old, they'll typically have lower tick rates and often you feel sluggish, doesn't feel responsive, right? In blockchain you can treat these ticks to something that's analogous to a block. It's basically a single unit of time where state transition happens.
00:08:45.938 - 00:09:31.230, Speaker A: If a tick or a block feels late, you visually and feel lack in the game. And if you've built games before or even you've played game, you know how suck it feel when your game move lack and you die and you get killed and they would rage onto the enemy or the game developers. It's not a pleasant experience. And so at the end of the day, we believe that games are loop driven in nature and because a lot of game state transitions are not triggered by external input. For example, a gravity doesn't rely on the user pressing the W button to move forward. Gravity will continue to exist regardless of user input. There's also a case for deterministic transaction ordering.
00:09:31.230 - 00:10:52.074, Speaker A: Let's say if you want to inflict a damage to your user, should the game heal apply regeneration to the HP of the user first? Or should it inflict damage first with a traditional ordering of just like this random builders of typical execution layer, let's say the AVM, you can't predict or you can't deterministically control which state transitions are getting applied first and as a result you have this deterministic transaction ordering problem that causes reliability issue in the game loop itself. On top of that, you can also allow for more aggressive realization by using data oriented system design in these loop driven runtimes. Last but not least is that while some people might talk about it retrofitting event driven runtimes like the VM into a loop driven runtime, we've seen that this leads to a lot of issues because of the nature of how you do gas mirroring, how do you do accounts. That is not as simple as just calling a loop or calling a single smart contract function again and again at every block. And so if you have a layer two roll up with a loop driven blockchain for games, what unlocks do we get? The first thing is of course we want to maintain the composability. Making the blockchain from event driven to loop driven doesn't mean you have to sacrifice composability. And that's actually the reason why we want to use blockchain as a runtime for these games in the first place.
00:10:52.074 - 00:11:55.210, Speaker A: On top of that, with a loop driven game runtime you can have real time gameplay where you can now start to blur the line between a blockchain and a traditional game server and eliminating the concerns of building a game on top of these roll ups. With the Adiomatic runtime loop driven runtime, you can also build more complex games than you can before in a blockchain. There is a reason why most quote unquote games that you see on the blockchains are mostly just people minting NFTs because that's really what the easiest you can do when you can only have event driven runtimes. And last but not least, the more that you can emulate a traditional game engine runtime, the more that you can just treat the user experience much like playing another game. But with all those good things in mind, we still are missing one key ingredient to build a scalable game server blockchain. And the key thing there is the fact that we also need horizontal scalability. When you're playing a game, you are not only playing it on a single server if you play MMOs are comprised of many, many servers.
00:11:55.210 - 00:12:48.190, Speaker A: If you're playing Counterstrike, these Counterscribe games are spread out across different sessions that is run across different computers. But if you realize at the end of the day a roll up runs on like a computer and so they are bound to the physical limitation of computation itself and say games and like most large scale applications scales using multiple computers. But if that is the case, then why don't we just spin another roll up? Then if we do the naive approach of just spinning up another roll up we can lead to composability fragmentation. Smart contracts would stop talking to each other. And while there are kind of different construction of shared sequencers, a lot of these constructions are less than ideal for gaming use cases. For instance, you might rely have to depend on crypto economic security to prevent things like locks, Dos, vector and doing like atomic. Shared sequencer construction can also lead to constraints on execution layer.
00:12:48.190 - 00:13:37.426, Speaker A: As a result, we need a new strategy to sequence roll up transaction. And in the search for that, we had a gift from the past. Again, we'll look into how traditional game servers, especially those with intensive performance, exitation like massively multiple online game like World of Warcraft, RuneScape, Ultimate Online and whatsoever through the concept of sharding with shorting. Some of you might have known this concept from databases like MongoDB. But the reality here is there's this concept, the concept sharding itself comes from game servers first instead of the database first. And so how does sharding work in game? The key thing here is that there's no one size fits all problem. Again, at the end of the day, shards are just tool in a toolbox, not a prescription of how you should build your game.
00:13:37.426 - 00:14:34.142, Speaker A: So for example, in the first sharding construction you can use location based sharding where you can split, let's say, cartesian coordinate into four diagrams. And like when a player want to cross from one shard to another, you simply send a message to other shard and then the player would be teleported to the other shard. The second construction is by using something that we call multiplayer sharding. If you've played MMO games before, you might have seen that when you log in you have multiple servers that you can choose. This is the same construction that you can do where you can have distinct states or distinct game worlds that the players can decide to join. So now we have all the ingredients here, right? We have the loop driven runtime, we have the horizontal scalability and we also want awesome composability. All of this sounds great, but how do we achieve this in a roll up? Right? This looks like things that on the server seemingly looks like beyond the reality of like we couldn't get from a blockchain.
00:14:34.142 - 00:15:11.722, Speaker A: But this is like why we created Roll Engine. We realized that we can't just use a normal roll up and expect that it will run the way that we want it. We took it to our own hands to actually build the solution that we need. The same way that back in the 1990s, when you want to build a treaty game, there's no treaty game engines available out there, you have to build them by yourselves. And so the world engine is again divided into two key parts. The first one being the core which is comprised of two key elements which is the EVM base shard which is a hybrid execution layer and sequencer with sharding support. And the second part is the game shard which is a high performance game engine plus execution layer.
00:15:11.722 - 00:16:09.506, Speaker A: And on top of that you have peripheral components like transaction relay and netcode to do the client server communication. And also things like ZK Cloud prover for you to have ZK games like Dark Forest. And so the role engine core really comes down to our very specific design of our sequencer. While other sequence like shared sequencer construction would optimize for having atomic composability, we decide that atomic composability are extremely overrated, especially when you're operating on the context of games. And that's why we went full asynchronous and so we don't have to put locks on the runtime. In EVM base shard we have a global EVM chain where players can deploy smart contracts to compose with games, create marketplaces DEXs. We built this on top of Polaris which is Cosmos SDK compatible EVM module that allows us to customize the EVM to much greater extent than what we could buy, let's say just like naively forking get.
00:16:09.506 - 00:17:00.718, Speaker A: On top of that we have the Gameshart which is running on top of the EVM base shard sequencers which is a high tick rate mini blockchain designed to serve as a high performance game server. The gameshart is also designed to be state machine and VM agnostic. We built an abstraction layer much similar to Cosmos SDK EBCI so that you can customize a shard to your liking or build your own by implementing a standard set of interface. We have also built the first game shard implementation to provide an example. And we use an entity component system that is commonly used by game engines and with construction that prioritize entity component system as a first class citizen. So every single objects or every know primitive on the state machine itself is treated like an entity. So things like accounts are a part of ECS.
00:17:00.718 - 00:17:43.162, Speaker A: Transaction is a part of ECS system. It also has configurable tick rate. So you can customize your game to be as fast ticking as possible or you want to slow it down to prioritize more number of entities. And the best part of this is that you don't need to rely on indexers. You can have fast reads on a blockchain without having to have this lack of eventual consistency indexers like what we currently have with Mud, Dojo and whatsoever. And my favorite part of all is that you can write your code and go so you don't have to wrestle with smart contract languages that can be very limiting sometimes. And so the key thing again, as I mentioned, Shards are agnostic in nature to our abstraction layer.
00:17:43.162 - 00:18:39.220, Speaker A: So you can build other Shards construction like a Solid game shard to complement your cardinal game shard. You can also build NFT Minting shard that have custom rules by, let's say, custom mempool and ordering construction to solve the basic Minting noisy neighbor problem. You can also create a Game identity shard to use NFT to present your game identity and allow you to trade your game identity as well. And again, we don't use Slux and as a result we don't have to block the main thread and making the game shard runtime as reliable as possible and not causing any lags. And we don't have to rely on crypto economics construction anymore. On top of that, we also have many interesting shard properties like how each shard can have different DA batching compression strategy and you can also geolocly shards to reduce gameplay latency. And last but not least, you can also run game Shards as an independent game server onto its own, so you don't have to worry about roll up deployments on day zero.
00:18:39.220 - 00:19:21.790, Speaker A: And so we've built many various games on top of the gamesharts, we've built like a fully on chain agario which have traditionally not been possible using our full World engine sequencer stack gameshart, Nakama and so on and so forth. We've also worked with a hybrid model where you would use existing game engine frameworks on Solidity and combining that with a world engine and the future is for you to decide. You're going to use our cardinal stack, you can do hybrid, you can build your own gameshart. It's basically Kubernetes for on chain games, it's mix and match Lego for your games. And so now you're able to try out the world engine. It's now open source on our GitHub. We are welcoming you contributors for people who are interested.
00:19:21.790 - 00:19:49.954, Speaker A: Feel free to reach out afterwards. And if you're interested in building your first World engine game, we are having a workshop later today at 11:30 a.m. At the Kaji Stage. And then tomorrow we're also going to be hosting the gaming track. We have a panel and we also have a talk about onchain games at the four year stage. And last but not least, the key takeaway from my talk would be that let's build cooler roll ups. We are right now at a roll up renaissance and what we already know is that of course roll ups allow you to scale a blockchain.
00:19:49.954 - 00:20:11.710, Speaker A: Of course roll ups will allow you to tap into the security of the underlying L one. But right now we are still living on this very EVM centric conception of roll up architecture. This the starting line and not the end. What we want to go towards is a user and application centric roll of construction where people can build. Cool shit. And, yeah, that wraps my talk. And thank you for listening.
