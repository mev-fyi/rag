00:00:08.110 - 00:00:31.046, Speaker A: Alrighty, welcome everyone to another Celestia community call. This is community call number two. I'm Yaz. I'll be your facilitator for this community call. And we have a lot of exciting updates that I'm really excited to share with you along with the rest of the Celestia team. So yeah, let's get started. So on the agenda we have status update on the Mamaki testnet.
00:00:31.046 - 00:00:50.320, Speaker A: I'll be covered by ismail. We also have an overview and demo of the data availability API that been launched on Mamaki Testnet. And finally we're going to do an overview of the new Golang rest client for Celestia node to kick it off. Ismail will take over right now.
00:00:51.410 - 00:01:50.114, Speaker B: Everyone. Thanks Yaz. Yeah, just a brief update from the Mamaki testnet. So in the beginning, shortly after we published the testnet, in the sense that people started joining, we realized that the tenement release that we used, the latest one tenement 35, was kind of unstable on the peer to peer layer and we spent quite some time trying to debug this and use the legacy flag there without going into much detail. I think besides those hiccups in the beginning, because of our validators being creative, we kind of managed to stabilize the network. It's still kind of not optimal, but it works. And we're working closely with the tenement team.
00:01:50.114 - 00:02:48.994, Speaker B: I think a big shout out to Evan, who's not on this call unfortunately, but he worked very closely with the tenement team to fix some bugs on the tenement peer to peer stack. Yeah, we also found some bugs on our end and celestial app, which is very good. That's why we launching a testnet and we're fixing these bugs basically as we speak and working on those both in apps on node. Yeah, again, big thank you to our validators for being so patient with the launch and with the hiccups that happened on the way, but it seems to work very fairly well. And maybe as a heads up we will eventually follow whatever decision. Actually, it's not entirely clear. We will make a decision depending on how the Cosmos SDK decides.
00:02:48.994 - 00:03:32.930, Speaker B: The Cosmos SDK team decides which tenement version to use in their next release, like, which is 46. But depending on that we'll decide how to move forward with the testnet. But there will be an upgrade fairly soon either way. But not this week, most likely next, or the following week or weeks. Yeah, we've seen a few block explorers. I think one worth mentioning is by Lazarus, who is also trying to parse the pay for data transactions yeah, I think that's it. From the testnet, a quick update on the QGB.
00:03:32.930 - 00:04:08.480, Speaker B: The team there has found a bug on the relayer and is working on fixing it. A proposed solution is called like a universal non. I can link the issues for those that are interested to follow along in the chat here. Think it makes more sense? Yeah. And for the Ethermind optimum updates, I'd rather give it to Tomas. Thank you.
00:04:13.010 - 00:05:21.650, Speaker C: Okay, regarding optimist and ethermin, we were facing some slight issues with stabilizing block production on Mamakai Testnet right now. We fixed most of the most important bugs, and because of the initial problems with block production on the Testnet itself, block submission from Optimid was pretty problematic. We had some issues with too small timeouts and with failed operations. But right now we're preparing a terminal based chain to run on Mamakai Testnet, and we're also preparing tutorial to run how to run optimist based so ABCI based, Cosmos based roll up on top of malachi testnet.
00:05:26.090 - 00:05:33.050, Speaker A: Thank you. Have we covered any QGB updates?
00:05:34.430 - 00:06:01.480, Speaker B: Oh, I mentioned those. I mean, the team is working on fixing the bug in the relayer. If John has anything to add to that, I'm happy to let him speak, but I think it's too detailed to, it would take too much time to explain the issue at hand. Even so, I think we should go over to demo the data availability API, which is more hands on and more interesting, and an overview by Tomas of the rest.
00:06:06.730 - 00:06:21.420, Speaker A: Sounds good. All right, so now we're going to go over the overview and demo of data availability API and to demo it. Renee is going to demo it, so I'm going to stop sharing my screen. And Renee, whenever you're ready.
00:06:22.350 - 00:06:24.286, Speaker D: Hey, can everybody hear me?
00:06:24.308 - 00:06:25.486, Speaker A: Fine? Yeah.
00:06:25.588 - 00:06:26.334, Speaker B: Yes.
00:06:26.532 - 00:06:45.826, Speaker D: Okay, cool. I'm Renee. I work on the data availability node at Celestia. It's a goaling implementation of the data availability node. Maybe we'll have some other kind of implementation later on in the future. But for now it's go. I am going to walk through our data availability API right now.
00:06:45.826 - 00:07:03.658, Speaker D: It's very new, very fresh. So I'll just start sharing my screen. I'm also going to go off video so it's easier for me. Is it working fine?
00:07:03.824 - 00:07:04.540, Speaker A: Yes.
00:07:04.990 - 00:08:04.490, Speaker D: Okay, cool. So I'm going to go over two of the endpoints that we have for now. They're basically the only two endpoints that really matter. It will kind of take you through the flow of a pay for data transaction in the Celestia network and if you don't know what a pay for data transaction is, a PFD transaction. It's kind of like the core transaction type that the Celestia data availability network will deal with, because it's just a way for you to post messages to the network and then pay for that. So the celestial node exposes an endpoint called submit underscore PFD, where you can actually submit data under a given namespace. The namespace has to be eight bytes hex encoded, and you can submit any arbitrary data and pay for that, as long as you can pay for it, essentially.
00:08:04.490 - 00:09:01.562, Speaker D: So in the left side of my screen you can see that I have a node running, this is a light node, and as you can see there are like a bunch of logs that say sampled path header. The primary function of a celestia data availability node is to perform sampling over the network. And there are different types of sampling, and the light node performs like light sampling. So it's only sampling for a certain amount of shares to guarantee it with a high probability that the block data does exist on the network. And there are also other node types like a full node for example, that will perform full reconstruction on block data. But that's kind of outside the scope of this demo. So for now, I'm just going to demo basically submitting a message to the network, getting hopefully a successful transaction response with a block height at which block was this message included.
00:09:01.562 - 00:09:50.080, Speaker D: And then using that block height, I will attempt to retrieve the data that I submitted from the celestia data availability network. So my node is already running for the purpose of the demo. I have a node running so that it's synced up to the network head so that we can actually work with this node. And I will go ahead and do a post request with a payload that will comprise the pay for data transaction. By the way, all celestial nodes expose their RPC by default on port 26658. So just so you know, then we have the data, the payload here.
00:09:54.290 - 00:09:54.606, Speaker A: And.
00:09:54.628 - 00:10:45.790, Speaker D: Then the endpoint is submit PFD. And so there's also this neat little playground thing that will allow you to generate some arbitrary namespace id with a hex encoded message. And so I'm just going to use that to generate a random namespace Id. So in the payload of the post request you have namespace underscore id field that takes a hex encoded namespace Id. Then you have the data, this is your payload, whatever data you actually want to submit to the network. And that is going to be just hex encoded bytes of whatever length. And then you have the gas limit field, which you can set yourself.
00:10:45.790 - 00:11:38.770, Speaker D: I'm going to do 60,000. And then you can submit this to the celestial light node. And sometimes it takes a while because what's actually happening under the hood right now is that the celestial light node will proxy this transaction into the consensus network. Because there are two separate PDP networks that are operating with Celestia. One is the consensus network that is responsible for ordering the transactions and basically producing the blocks, and then the data availability network, which is responsible for essentially doing sampling and data availability for the celestial network. And so it kind of takes a while because the celestial light node is like proxying this transaction to its core connection. We call it, it's just a connection to a consensus node, like a celestial core node.
00:11:38.770 - 00:11:41.554, Speaker D: So it might take a little bit of time.
00:11:41.752 - 00:12:04.010, Speaker C: Another reason for the time is that the transaction is submitted in synchronous way. So the post will return when the block is finalized. So it also depends on the block time. So you may give like additional, even 30 seconds.
00:12:05.310 - 00:12:39.774, Speaker D: Yeah, exactly. So it is a synchronous call. So basically we are waiting for a proper transaction response, which can take a little bit of time. But in the meantime we'll post links to the docs of how to do submit, pay for data. And then hopefully you guys can follow along even right now, or play around with the API afterwards. Give us feedback. There are many ways that you can give us feedback.
00:12:39.774 - 00:13:20.130, Speaker D: You can open an issue on the Celestia node repository, you can tweet at us@celestia.org you can contact me on Discord, you can contact any of us on Discord. Contact me on Twitter. Yeah, just follow along with the docs and then play with the API a little bit and let us know if we're missing something or if there's something that you'd like to see or if something's not working for you. Something's confusing because this is still in development and it is definitely rough around the edges, especially the thing like the way that the namespace data is returned back. It's like base 64 encoded. I'll talk about that later.
00:13:20.130 - 00:14:00.160, Speaker D: We just need to iron out some of the rough edges, I guess, of the API. So yeah, it's definitely still in development and we'll definitely expand it and make sure that it's, I guess, getting better and improving constantly. It's taking a bit of time to submit this transaction. Sorry, guys, love live demos. Yeah.
00:14:01.250 - 00:14:21.640, Speaker A: So while we wait for it to submit a transaction, maybe we can share the tutorial itself, the node tutorial. I'm going to add it to the chat. To the zoom chat, maybe if you want to share that screen.
00:14:27.520 - 00:14:28.904, Speaker D: Oh, the zoom chat.
00:14:28.952 - 00:14:32.510, Speaker A: Yeah, it's the last one.
00:14:33.300 - 00:14:38.350, Speaker D: Yeah. Okay.
00:14:39.440 - 00:14:52.210, Speaker A: So that way anyone who's following along there's like a tutorial and guide on how to get started, submitting pfds and requesting the data back to follow along with what Renee is doing.
00:14:52.740 - 00:15:43.516, Speaker D: Yeah, so basically what we're supposed to be getting back is something that looks like this, and it will take a while, unfortunately. But yeah, you get a TX response that looks like this. If it was successful, it gives you the height at which the transaction was included. And then what you can do is use that height in order to do a get namespace data request. So we have two endpoints basically to get the data given back to you, and one of which is a little bit more technical. It's like the get namespace share. So it basically returns to all of the chunks of the message that you've submitted to the network in a not very nice format.
00:15:43.516 - 00:16:10.090, Speaker D: And then there is a much nicer endpoint called namespace underscore data, which is also a get request that Tomash actually implemented for us very nicely. That will give you back just like the message as a whole. So we'll be using that for the tutorial or like for the demo. Sorry. Yeah, it's taking a really long time. I'm sorry. I don't really know why it's hanging so long.
00:16:14.460 - 00:16:23.660, Speaker A: It could be because Jacques just said that a new block just went. So probably like the mamakitas and taking a while to produce a new block.
00:16:26.560 - 00:16:39.810, Speaker D: Yeah, sorry. Should we do some sort of Q a in the meantime or not Q A, but maybe go into depth on one of the.
00:16:45.160 - 00:17:13.116, Speaker A: Yeah, we can definitely do in Q A. Like our amazing community organizers can relay any kind of questions back to us, but if there's no questions so far, maybe we can just proceed to Tomas while we wait on the transaction to come through and then we'll dedicate the final time for Q A. Yeah, that sounds good.
00:17:13.138 - 00:17:14.510, Speaker D: I'll stop sharing now.
00:17:17.520 - 00:17:35.250, Speaker A: All right, so the next up, let me share my screen. We have an overview from Tamas on the new goal line gras client for celestial node. So I'm going to stop sharing the floor for.
00:17:39.700 - 00:17:45.640, Speaker C: Sharing to find proper window.
00:18:09.790 - 00:19:05.850, Speaker B: Actually, there was a question, I'm just going to read it out. So someone asked how much of celestia is on AWS? Yeah, that's a tough one. More question for our validators, I guess. But I would say that even on a testnet on celestial, like on Mamaki, it's not representative for the actual mainnet launch, even if validators might use a different setup for testnets than for Mainnet. So I can't really answer the question. I would think it looks kind of similar to on the hub or on similar chains though where I don't know how much it is, but I would assume it's like roughly like 20% or 10% maybe of nodes, but that's just like a guess. Okay, sorry to interrupt.
00:19:07.390 - 00:20:18.450, Speaker C: Okay, what I wanted to show today is go CNC so go client for Celestia node rest interface we created this repository. It was extracted from the code used in optimint to access celestial node and we would like to invite anyone from the community to contribute to this project. Right now we already have some prs and some issues you can choose from. All of them are good first issues or help wanted issues. This help wanted issue is a bit more complicated, so it's not the best first issue, but we have some first issues. It's both coding and documentation, so I think that everyone can jump in and start contributing. As I said, we have some community contributions, some even are already merged.
00:20:18.450 - 00:21:48.574, Speaker C: This is repository the main idea in this repository is to create a go client that will wrap entire rest and HTTP handling logic inside libraries. You can use it programmatically. We're mapping endpoints of celestial node one to one. So we have methods like header, balance, submit, submit, PFD which is implemented because we already need it, and namespace shares and namespace data because we also already need this. One cool part is that we have integration test suite that is using Docker to set up temporary network using both single celestia node and single celestia app instance and we can run tests without accessing actual test net. So the test is very simple. We spin up the docker in the setup phase of the integration test suite, we're creating a client and this also shows how you can use client in your application.
00:21:48.574 - 00:22:49.090, Speaker C: So we have some random data, some randomly hard coded namespace. You can submit the data, submit the PFD and use namespace data to get the response. As mentioned earlier, we're using the hide from TX response. Yeah, all the issues we create and we probably will create more issues inside this repository. We try to have it user friendly. So we have the link to the spec of the method, documentation on spec of the method. We even have a link to code in celestial node where it's actually implemented so you can pick up all the details.
00:22:49.090 - 00:23:25.520, Speaker C: This is basically it. I can also show how it's used in optimint. So in optimint we have a pluggable data layer architecture. So one of the data layers is Celestia. And in Celestia go, we're implementing methods like submit block, which is pretty simple. It marshals the block. Submit PFD to the configured namespace, checks the result.
00:23:25.520 - 00:24:20.960, Speaker C: This is one thing that we may want to move into go CNC. So we're also checking application level errors because it may be the case that we're timeouting or something like that. So then submit PFD will return an error. And another thing is that everything will go fine, but on the application layer there will be some issue. For example, we're submitting duplicated transaction which will be also reported. So we need to handle this right now we're handling this in optimin, but we may want to return an error from submit PFD. I guess I will create an issue in OCNC soon for someone to implement this.
00:24:20.960 - 00:25:04.560, Speaker C: And we also have retrieve blocks method, which is using links with data. It retrieves the data and then tries to serialize, and if it's deserialized, we're basically done. And this is all I wanted to show about GoCNC. And once again I wanted to invite everyone to contribute and to create new issues, to create some more tests, implement some missing methods, and create documentation samples and so on.
00:25:06.450 - 00:25:55.390, Speaker A: Amazing. Yeah. So everyone check out the links in the YouTube chat for the GitHub repository. And this is a great way to get started with contributing to a Golang rest client for node and to get started with development on top of celestial with a community maintained SDK. Finally, we want to share that we're hiring. So if there's anyone out there interested in joining the Celestia team, you should definitely apply on our link job. Lever co Celestia currently the things you're going to be working on is Golang, Cosmos SDK tendermint and lip P to P.
00:25:55.390 - 00:26:32.182, Speaker A: The vote that we're looking for is Cosmos SDK engineer in Go. A DevOps engineer, networking engineer, and a senior database engineer. Yeah, so please check out the link apply and we'd love to chat with you. Finally, we're going to leave this time for Q and A. Currently we have a few open questions. Let's start. So where can I get the hardware requirements? So for the hardware requirements I'm going to share with you here.
00:26:32.182 - 00:27:01.490, Speaker A: It depends on the kind of node that you want to run. Right. So if you want to run a validator node at the top of the section, I'm going to share it. Hopefully somebody would be able to share on the YouTube live. Yeah, over here. The first section is always going to be a hardware requirement. Whether you're running a validator node, a consensus full node, or from the data availability side bridge nodes, there's always going to be a hardware requirement section for each node.
00:27:01.490 - 00:28:08.886, Speaker A: Yeah. Now we can go to the other question. When will we see an example of an execution layer on Celestia? So with ethermint optimate, with the Ethermint optimist work being done, we'll have documentation on a settlement layer that is EVM compatible and that will help allow developers to get started building on top of Ethermint optimum. And we're hoping that we can start demoing or having documentation ready within the next two weeks to a month. So the team is working on that and we would be able to share more in the coming few weeks. Another question is when is the incentivized testnet being launched? We haven't announced a launch date yet, but hopefully this year is what we're anticipating. If there's no more questions, we can go back to Renee.
00:28:08.886 - 00:28:16.620, Speaker A: Renee, you want to share? All right, let me stop sharing and show Renee's. Go for it.
00:28:19.310 - 00:29:18.858, Speaker D: Okay. All cool. So, okay, so this took a while, sorry. Okay, so we did, just to refresh everyone, we were doing a submit paper data transaction, and we were submitting this arbitrary data under this namespace. And so we got a transaction response and it was successfully included. And we have a block height at which it was included, which is important because then we are actually going to use that for our namespace data query. So all that we need in order to query the node for the namespace data is we'll hit the namespace data endpoint, we need our namespace id under which we submitted the data, and then we need the height at which the message was included.
00:29:18.858 - 00:30:20.562, Speaker D: And then we will get our data back as base 64 encoded, which is kind of annoying, but we will decode it back into hex and. I've done something wrong, I haven't copied it properly. Oh, we've got two messages here. 1 second. I guess it was included twice. Okay, so yeah, then we have our message data back. I know it's not really cool to see, but the path of the transaction itself was really interesting, and the fact that the light node can retrieve the message back, that the fact that the data availability network is syncing blocks from the consensus network, extending them and then making the shares of those blocks available to the network is pretty cool.
00:30:20.562 - 00:30:49.420, Speaker D: I know it's not really much of a demo, but it's where we're at right now and we obviously want to improve the API later. So definitely give us some feedback. And if you have any questions about any of the endpoints right now or how things work, please shoot them in the YouTube comments or however that works. But yeah, now it's finished, so we can go back to Q A.
00:30:51.650 - 00:31:24.180, Speaker A: All right, sweet. I'm going to go back to sharing the final slide. Let me see. All right. Yeah, so again, check out the link we're hiring. If you have any more questions, we can hang out here and do a quick round of Q a for any more questions from the YouTube live stream. Otherwise, otherwise we can end the call early.
00:31:24.180 - 00:32:01.010, Speaker A: Oh yeah, so there's a question. So one question is, could it be possible to offer this proposal of consensus solution for chain outside of the IBC ecosystem? Okay, offer this proposal consensus solution, I'm guessing for tendermint. So I guess the question is, can tendermint work outside of the IBC ecosystem? I'm not sure. Ismael, you want to take that?
00:32:01.380 - 00:33:09.380, Speaker B: I mean, I interpret Joel's question as does optimum. And these roll apps, can they work outside of the IBC ecosystem? Yes, they mean IBC can also work outside of tendermint. There's like a misconception that IBC, the spec only works with tenement, which is not correct, but it's generally enough that you could have a single node or like a proof of authority thing or some committee. And definitely IBC is generally enough to capture roll ups as well. But there's no implementation. So that definitely needs a separate IBC client for mean Selastia main chain will be connected through IBC to a bunch of other chains, but the roll ups, it's up to them to decide how to bridge to other rollups. There might be canonical easier solutions where if they use a common settlement layer, bridging might become easier.
00:33:09.380 - 00:33:30.140, Speaker B: If it's a Cosmos SDK based roll up, IBC is probably the most natural thing, but as I said, that needs to be a new client implementation, I guess if that answers the question that's asked Joel on YouTube.
00:33:33.200 - 00:34:31.408, Speaker A: Hopefully answered the question. Otherwise, Joel is free to come up with any follow up questions. Before we go to the next question, we can also expand more on one previous question. Will we see an example of execution layer on Celestia? We already covered ethermint optimum as one kind of execution environment at EVM base, but the plan is at least long term to have all different example documentation tutorial on how developers can integrate their execution environment of choice with selective data availability layer and that is definitely the plan. And if any of you have any kind of execution environment that you'd like to see being deployed on top of celestia, feel free to reach out to us and we can talk more about this. And yeah, hopefully that answered a previous question like expanded upon more. All right, there's another question.
00:34:31.408 - 00:34:47.332, Speaker A: If I use optim, should I spin a light node or a full node to test my pet project deployed on mama key? What node type is easier for developer user experience traumas? You want to take that one?
00:34:47.386 - 00:35:47.050, Speaker C: Yes of course. Light Note is enough currently for development on Mawaki I configured my own Celestia app, but it's only a full node, it's not a validator, it's a full node and I configured pruning so I'm not keeping historical data. So it's light on my disk and I don't need much space for it. And I'm using celestia light node and it works fine. So I would say it's easier and it requires less resources. So yeah, I'm running this on my very small home server and I would say it doesn't require any significant hardware to run.
00:35:49.020 - 00:35:49.432, Speaker A: Great.
00:35:49.486 - 00:36:08.750, Speaker C: Definitely full node of celestia app or you can use public endpoints and light node for celestial node. This is enough for testing optimist on the market.
00:36:10.020 - 00:36:44.890, Speaker A: Amazing. Let's see if we have any more questions and hopefully this answered one of the viewers question. All right, so far no more questions. Maybe we give it another minute or two before we can wrap up. Maybe in the time that we wait for more questions to come, we can do a little icebreaker with the team talking about what is your favorite color? I'll go first. Black. Anyone else?
00:36:47.440 - 00:36:48.590, Speaker C: Same here.
00:36:50.800 - 00:36:54.750, Speaker D: I wear all black but my favorite color is red.
00:36:55.360 - 00:36:56.204, Speaker A: Red?
00:36:56.402 - 00:36:59.010, Speaker D: Yeah, like super bright red.
00:37:00.660 - 00:37:05.970, Speaker B: I also mostly wear black, but obviously the Celestia purple is my favorite color.
00:37:10.200 - 00:37:12.100, Speaker E: I also am a fan of purple.
00:37:12.760 - 00:37:21.700, Speaker A: Purple. Do we have a name for the specific purple color using celestial.
00:37:25.500 - 00:37:38.030, Speaker B: Probably has a name. It definitely has some hex code. I do remember I was half joking because there was a long discussion about the color to use and if it's the exact color, long time ago.
00:37:44.960 - 00:38:08.870, Speaker A: There's another question that what is the profile of the new strategic partners that Celestia plans to implement in the future? So I guess it's a question on, I guess, the category of strategic partners Celestia is planning to work with as it goes closer to launch. Aditi, do you want to answer that one?
00:38:10.120 - 00:38:20.010, Speaker E: Sure. I think I need clarity on that guess from a product perspective or what is the question?
00:38:21.420 - 00:38:23.610, Speaker A: I'm just going to paste the actual question.
00:38:25.920 - 00:38:44.130, Speaker E: Kind of vague. I think we're interested in any project that wants to try building modular and leveraging our roll ups. And so we're open to chatting with anyone and yeah, anyone who's interested in our ecosystem or orbit should definitely get in touch.
00:38:45.060 - 00:39:09.422, Speaker A: Great. All right. Okay. It seems there's not any more questions. Let me double check again. Yeah, seemed there's no more questions. I think we can wrap it up.
00:39:09.422 - 00:39:11.680, Speaker A: Like we can stop sharing the screen.
00:39:13.490 - 00:39:18.510, Speaker E: I think there's one more where? In the chat.
00:39:26.810 - 00:39:47.050, Speaker A: All right, yeah, I think the last one or the one about the profile of the strategic partners. All right. I think that. Oh, it's called Tarot Purple, Aditi. Like the actual name of the purple color that is used by the logo.
00:39:48.990 - 00:39:55.070, Speaker E: That was just what I wanted to name it. I think that was all the questions. I thought there was one more, but that seems to be it.
00:39:55.220 - 00:40:33.222, Speaker A: All right, great. So thank you everyone for joining another community call. If you have any kind of feedback on the structure of the call. We're just like at the moment, experimenting with what worked, what doesn't work, and certainly for the next call, we'll make it more inclusive so people can ask more questions in an interactive way. Also, again, thank you to all the validators validating on Mamaki. And you guys are the real ogs. Thank you so much for all the support in helping spin up Mamaki testnet.
00:40:33.222 - 00:41:03.140, Speaker A: And to all the developers out there, get started with the data availability API that Renee went over and start contributing code to go CNC, which is like the Golang rest wrapper for the node, celestial node that Thomas went over. And if you have any more questions, shoot us a DM on Twitter or come hang out in our discord. And yeah, thank you all for coming. We appreciate your time and take care.
