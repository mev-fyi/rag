00:00:01.920 - 00:01:00.310, Speaker A: All right, so I kind of lied a little bit to the organizers and told them this was a talk about client diversity, which is a common ethereum concept. So first off, let's introduce me. I'm James. I work on Ethereum things for the last, I don't know, like close to ten years or something. I worked on bitcoin stuff before Ethereum was around, and now I spend most of my time doing roll ups, bridges, cross chain things, and mechanism design writing and being really annoying on Twitter. So why do I care about this? There's been this idea since the beginning of Ethereum that you should have a lot of clients. You should have Aleth and parity client, and maybe the, like, whatever Gavin was working on back in the day, and Geth and Reth and Nethermind and Aragon and Akula and client diversity.
00:01:00.310 - 00:01:32.196, Speaker A: So this is from yesterday. Client diversity is a measurement of how many pieces of software did we build to do the exact same thing and how many people run each individual piece. And what are the philosophical implications of me forgetting to finish the slide? I don't know. So you might notice a few things about this. It makes you feel a little anxious, a little scared, little irresponsible. Like, it's got this. Wait, do I have a laser pointer here? Don't think so.
00:01:32.196 - 00:02:07.532, Speaker A: Damn. It's got this uh oh emoji, and it's got like this big red bar here. And it does like this weird thing where it just assumes everything is what you don't want, which is a very normal statistical methodology. Just assume the bad case and oops, there we go. The same page has this big danger warning, like, we're above 50%, we're in danger. And then I clicked on this link here, view staking pool diversity, because I was interested in that. I want to know who's got money and what the money's doing and who's in charge of it.
00:02:07.532 - 00:02:48.178, Speaker A: And yeah, that's an ad. It just goes to someone's website. They're trying to sell you data analytics, and they fucking got me. So the way I found this was just googling client diversity, because I have no idea what I'm saying up here. This is the Google results for client diversity. You may notice something like, this is the official Ethereum website, and this is some random guy's ad, and one of them shows up on top when you search client diversity. So I don't know why they have the same logo or what's going on here, but the important part is that client diversity, scary.
00:02:48.178 - 00:03:29.570, Speaker A: Like, it's a political goal, that there should be more Ethereum nodes, that people should write Geth and Reth and whatever. And it's also the assertion that you, as the user running software, should make a different choice based on what's politically good for the network. And I think that's a bit weird that they're telling you that you should just stop running Geth because there's too many geth nodes and that's your fault. But this isn't to talk about client diversity. Like I said, I lied to the organizers, so this is a talk about client monogamy. You gotta just settle down and marry one. And I'm James Prestwich, and I've been working on Ethereum stuff for close to ten years now.
00:03:29.570 - 00:03:55.790, Speaker A: Before that I worked on bitcoin stuff for a bit. And why do I care about this? I have to ship code. I worked on this thing called Alloy. Alloy gets used by foundry and by rethemeral, and by a bunch of other people. I worked on a bunch of different bridges. I've shipped a lot of code over the years, and all of the code does one thing. Like it does what an app does.
00:03:55.790 - 00:04:50.240, Speaker A: It talks to the node like this is what an app does. The client sends requests to the node, the node sends responses back. The general format is the app is going to wait for a block, do something with the block, and then repeat that forever and never stop. If your app stops, that means something's gone very wrong and you're very unhappy, and you have to do a bunch of ops things, and no one likes that. So the problem is that while the client's, while the app is talking to the node, the node is talking to the network and things are happening. And the client talking to the node is this nice, consistent JSON RPC that usually works, but some sometimes doesn't. But the node talking to the network is an absolute mess, and the node talking to the network is going to get new blocks, and maybe it's going to get a new block, like right here between these two client requests, and then something different is going to happen.
00:04:50.240 - 00:05:37.854, Speaker A: And the client doesn't know the node got a new block unless it specifically asks if it got a new block. So because these are separated by time, if you ask about the block over there, and then you get it back over here, you got a different block and you don't know. So here's an app. Like when you try to actually make one, you're going to ask the node what the block is. You're going to see if you have missing blocks. Like if the node knows of blocks you don't, you might go, oh, fuck, and have to try to get all of those missing blocks, and then you want to process them, and then, wait, sorry, the node has a new block now, and you have to undo all of the stuff you just did and go back to the beginning and repeat this forever. It's not a good pattern to like, right? This is what every weird JavaScript UI does behind the scenes.
00:05:37.854 - 00:06:18.412, Speaker A: It's asking Metamask what blocks it's got. It's trying to keep consistent, it's trying to see what the chain is doing, it's trying to process stuff, and it's just failing, and it's all a mess. So the problem, like I said earlier, is that anything can change on the node at any time. So when you're writing your app, your app has to account for the idea that the node has reorged 20 blocks while your app was running, which means your app has to then internally reorg 20 blocks, and that kind of sucks. That's incredibly complicated code to write. Any hands for people who've written reorg logic in chat. Yes.
00:06:18.412 - 00:07:08.788, Speaker A: Sup, dude? Nobody likes it, nobody does it. And as a result, apps are very unreliable, and the root cause is the JSON RPC. So the third time you make an app, you're gonna make something like this. You're going to have two separate tasks. One of which is polling for new blocks, is making an organized model of the chain locally in your app, and then is externalizing blocks, and then another task, that's your working loop, that's waiting for work from the polling task, and does the work, sees if it's still valid, and then commits it. And both of those tasks are going to repeat forever. And if they crash, something's wrong, and you're having a bad day, so why not use the notifications? I know some of you have written stuff with Infuria, and you know about the streaming API.
00:07:08.788 - 00:08:00.218, Speaker A: Well, I have bad news. You expect them to work kind of like this, where you're learning about transactions or blocks from the network, and the client receives them right after the node does, but they actually work kind of like this, where sometimes blocks will just disappear somewhere between the network, the node, and the client. No client reliably notifies you of all information you subscribe to. Any subscription may be missing. Random events from the middle nodes just don't work sometimes, especially over JSON RPC. And we discovered this with a lot of trauma. So, like I said earlier, I maintained this thing called alloy, Alloy came out of ethers rs, and in ethers rs, we had this pending transaction system.
00:08:00.218 - 00:08:51.160, Speaker A: The idea was you should be able to broadcast a transaction, and you should be able to wait till it confirms it's really simple, right? Well, you think it's really simple until you actually try to do it. And then you find out that none of the nodes work, and infurer will take your transaction, but then tell you it doesn't have it, and everything's just kind of terrible all the time. And so, as the pending transaction loop got bigger and bigger, we eventually decided to just not fix it and do a complete rewrite of ethers from the ground up. And the new one's somewhat better, but it still uses JSON RPC, and it still has to account for the idea that sometimes the node just lies to you, and different nodes lie in different ways. So, for example, Aragon has had a longstanding bug where it just returns incorrect results on some RPC calls for no reason. You ask for a receipt, you might get a different receipt. That's great.
00:08:51.160 - 00:09:43.018, Speaker A: So the 15th time you make an app, you just fork geth. You just fork it. You build your app into geth. But why? So, a node is a piece of software that is specifically written to wait for blocks and then do something with the block and to repeat that forever, which is the exact same loop that you want your app to do. And the node has people who have specialized in writing this reorg logic for you because it has to, because it's a full node, it has to track the chain, so it has to handle reorgs. And so why don't you just make your app into a component of a node? The node is doing the hard parts, the complicated stuff. Your app should not have to track reorgs.
00:09:43.018 - 00:10:14.870, Speaker A: There is a piece of software dedicated to doing that. So, eventually, as you get better or bigger or more professional, you start forking nodes in order to write your applications. It is the only way to get reliable infrastructure. You cannot make something reliable over JSON RPC. It just doesn't work. The nodes themselves, the JSON RPC servers, aren't reliable. And you have all of these timing issues we talked about earlier.
00:10:14.870 - 00:10:49.540, Speaker A: So the only way to go for high reliability is to build into the node. You see this from Etherscan, from essentially every significant block explorer. You see this from things like inferior alchemy. They modify their node software. Inferior and alchemy go steps further and add balancing layers and other infrastructure things around the node software. They don't try to use the JSON RPC. It's not good, it's not reliable.
00:10:49.540 - 00:11:31.050, Speaker A: So apps are just better when they're running as a component of the node. At this point, it's unavoidable. It's a well established fact. Once you get professional enough, you fork geth or you fork breath, or nether bind, or whatever other flavor you like. And then there's no inconsistent state, ever, because there's never a time lag between when the node learns about something and when the app learns about it. You avoid this entire class of problems. You never have to reorg, because the node is reorging for you, and the node gives you a nice little piece of memory that says, hey, we reorged, and you can just handle it.
00:11:31.050 - 00:12:01.730, Speaker A: You don't have to ask the node if it is reorged. You don't have to backfill any blocks. The node just gives you that. So when you're writing your app, you can just cut out the whole pulling loop, all of the chain state tracking, all of the Reorg monitoring, and just go to workers. You can put all of your engineers on working on your app instead of half of them, because you no longer have to maintain half a full node in JavaScript. And that's pretty great. So this brings us to client monogamy.
00:12:01.730 - 00:12:39.802, Speaker A: I'm James Prestwiche. I've worked on Ethereum for a few years now, and unfortunately, I have to run a company. Sometimes I have to pay people. Some of the people write software, I write software, I have to pay me. Sometimes software engineers need to eat and need health insurance if you're in the US. So that's kind of expensive, too. And I can't spend my money rebuilding my app to be part of Geth and then, wait, the network's not diverse enough.
00:12:39.802 - 00:13:16.050, Speaker A: I can't just spend the same amount of money again. Fire all my go engineers, hire a bunch of rust engineers, and rebuild it to work with rhetoric. Because the network's not diverse enough. Client diversity is only for end users. It's only for the hobbyists at home. Real businesses cannot support client diversity because we have to pay people, we have to build our application, we have to marry a node. So if an app is a node component, you'd have to rewrite that app for each node if you want to be able to switch.
00:13:16.050 - 00:14:07.608, Speaker A: So, like, things I will not be doing is rewriting my entire app to switch nodes. Once I have built an application, once I've built the validator service, once I've built the roll up, I will not be spending the same amount of money again to rewrite it for a new node. I am now married to the node that I chose, and diversity doesn't even come into it. Even if I want client diversity, I no longer have that option as a business. Every significant business in the space chooses a node and sticks with it. Client diversity is for people who are not being paid to work on this. So 95% of companies are not going to rewrite their entire app, they are married to their node.
00:14:07.608 - 00:14:48.360, Speaker A: And if you want to professionalize your company, if you want to professionalize your application, if you want high uptime and high availability, you have to do this too. You have to settle down, marry a node. So these systems exist. There are interfaces in both Geth and Reth for modular extensions. I helped design the Reth one and did a little bit of implementation on it, but there aren't any takeaways here. You have tension between the network's goals to be diverse and your goals as an individual who has to spend time and money building something.
00:14:49.020 - 00:15:10.940, Speaker B: Thank you very much, James. Once again, big round of applause. And our next speaker is Mark Tanue, the co founder of Optimism. He'll tell you a bit more about the super chain and Opstack interoperability. Big round of applause.
