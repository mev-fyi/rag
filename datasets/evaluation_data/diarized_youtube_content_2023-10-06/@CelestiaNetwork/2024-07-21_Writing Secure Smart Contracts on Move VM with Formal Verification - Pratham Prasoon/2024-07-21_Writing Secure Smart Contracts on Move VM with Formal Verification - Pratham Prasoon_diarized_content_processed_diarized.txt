00:00:02.120 - 00:00:15.770, Speaker A: We get started. Okay. Hey, everyone. Glad to be here. GM. GM. And yeah, it's been an exciting day at modular summit, and I can't wait to tell you all about secure smart contracts on the move VM.
00:00:15.770 - 00:00:42.650, Speaker A: And yeah, let's just get right into it. So, hi, I'm Pratham. I do developer relations at movement Labs, and I've been here for about. Been here for about a month. In 2022. I worked with Celestia as a part of their modular fellows cohort, and since then I've just been working full time in the modular blockchain space. So today we'll go over mainly three things.
00:00:42.650 - 00:01:29.760, Speaker A: So the first thing is, what is the movement network? And then we'll talk about the main topic that we're here for, formal verification. What is it, why does it exist and how does it work? And we'll also look at a live demo of how formal verification works so that you can write secure smart contracts with the move VM on movement. So let's get started with what is the movement network? So let's take a step back. So the movement network uses something called the move VM. The move VM is this technology that was built by the Libra and the DM team at Facebook in 2019. And later off it was spun off into AtOs and SuI. And it's this virtual machine that has really great technology for processing transactions on the blockchain.
00:01:29.760 - 00:01:53.882, Speaker A: So, like things like block STM, it's really fast, it's paralyzed. And yeah, that is a bit about the move VM. And for some context, solidity is the most common language that we have right now with the EVM, with the get client that you use. However, it is very much prone to, uh, attacks like Defi. So. And like just other sort of attacks in the smart contract space. So you've seen over $7.6
00:01:53.882 - 00:02:28.652, Speaker A: billion worth of assets being stolen because of, uh, problems in the sort utility language. And that is why you have a lot of auditors who audit, uh, solidity smart contracts, uh, at a professional level. And we can see this pie chart over here, just the different kind of attacks that you have on the EVM side of things. So you have signature exploits, proof verify bugs, private keys being compromised, lots of other things. And this is by Defi Lama posted this year in February of on the 20th. So we want to avoid attacks. We want to write safer and better smart contracts.
00:02:28.652 - 00:03:00.800, Speaker A: Now, how do we do that? Well, that is where the moviem comes into play. So move is this language that was built for the move virtual machine that was part of like, Libra and DM at Facebook. And it's this very secure and safe programming language that you can use to write smart contracts. And it's also more developer friendly than solidity. So it was introduced back in 2019, and it uses a new paradigm of resource oriented programming, and it's currently used in Aptos and Sui. So Aptos and Sui have their own variants of move. One is RTO's move and sui move.
00:03:00.800 - 00:03:51.912, Speaker A: And what is resource oriented programming? Well, it means managing resources such as memory, in a way that it is explicit and controlled. And these resources can be digital assets like nfts or tokens, or like identities, or like name sources or anything that you can imagine. And the ownership and transfer rules are very explicit. So, like, resources are moved, rather than being copied from one state to another explicitly, which is, which helps with security and other notable features of the movement network. Block STM, very popular parallel execution engine that, that has inspired a lot of other protocols, and it allows for like, multiple transactions being processed simultaneously. So as a developer, you can write smart contracts. And as transactions come through, Block STM will allow you to automatically paralyze those transactions and make sure it's executed efficiently.
00:03:51.912 - 00:04:43.210, Speaker A: And we are an integrated l two. So we use Ethereum for settlement. So we post commitments to Ethereum and we use Salesforce for DA. We're also building a decentralized sequencer that will be used with the movement network. We also have support for interop solutions like Hyperlink or IBC. If you are in the cosmos ecosystem and coming over to security, which is one of the big aspects of move, we prevent double spending, strict ownership like explicit state changes and resources are moved, not transferred, and also resource duplication, re entrancy attacks, and also, most importantly, formal verification with the move proverb. So we bring to Ethereum a move based roll up, the great tech that was built at Facebook, then at Aptos and Sui, and now it's on ethereum.
00:04:43.210 - 00:05:19.022, Speaker A: So that's all about the movement network. Now the movement testnet is being cooked as we speak, and it'll be out soon. We have a devnet already that you can try out, and it uses AppDosmove. And now let's talk all about formal verification. That's what we're here for. So what is formula verification? So formal verification is a mathematical concept where you can prove the validity of a certain system in mathematical terms, whether it will behave the way that you intend it to or not. So there was this paper written by the Appcost team about formal verification.
00:05:19.022 - 00:06:07.504, Speaker A: And in the context of smart contracts, it means that when you write certain functions in the smart contract, it behaves exactly way that you intended to like, there are no hacks or bugs that are inside of it. And there's also something called static analysis that allows you to analyze the security of a smart contract without even running it. And this is only possible on the move vm with the move language. And the process of formal verification is into four steps, but I would mostly classify it into this being the first two steps being one chunk and this the other two being the next chunk. So let's just go through them. So the very first thing you do is you write out what your smart contract wants to do, the specification. You specify what properties and what behaviors you want inside of the smart contract.
00:06:07.504 - 00:06:47.324, Speaker A: So that's the first thing you come up with. And then you model the smart contract, which is you write out the business logic and whatever you want the smart contract to do. And then in the second step, this is where the form of verification happens. You generate proofs that check if the smart contract that you modeled meets the specification that you go for. And this is done using the move prover. This is a piece of software that allows you to just verify smart contracts mathematically. And then at the end, once the proof is generated, you see using formal mathematical methods to check whether the proof generation meets the specification and the modeling that you've done.
00:06:47.324 - 00:07:30.754, Speaker A: So all in all, this helps you verify whether a smart contract works the way you intended to or not. And why do you do this? Well, this tightens the feedback loop for security of smart contracts. So you're able to detect vulnerabilities where human auditors might miss a thing or two. You can instantly find errors, like right after writing the smart contract before it is deployed. And you can prevent like costly fixes, because as you've seen, security can be costly. In web3, you've seen lots of hacks on sorority, just small things here and there that you miss, and then your entire protocol is exploited. So the only caveat is you need to know how to properly write specifications for these for formal verification.
00:07:30.754 - 00:08:08.552, Speaker A: So think the way. The analogy that I like best to explain formal verification in practice is that it's more like a test that you write after each function that just allows you to see the function is okay or not, that there's no hidden bug or something which we will look at in a demo. And how do you do this? Well, let's look at a live example. So I'll just go ahead and go into the code right here. So I have some move code over here. And so the first example is very simple. It's a basic example of just like a hello world contract.
00:08:08.552 - 00:08:40.056, Speaker A: So we have, I'll zoom into this a little bit. And so in move, you write smart contracts with something called the module. So this is the syntax for how it works. You start off with defining the address. So in this case it's zero expo two, and the name of the module is hello prover. So we're just doing a basic example of how we can do formal verification here. So I have this function at here which says add.
00:08:40.056 - 00:09:24.668, Speaker A: And if you see the syntax, it's kind of similar to rust with you defining the type of the variables that you're passing into the function. So we're putting unsigned 64 bit integers. So x is, we have x, we have y, and then we also specify what the output is going to be, which is also an unsigned 64 bit integer. And all it does is it simply adds x and y. Now to check whether this function works, whether it adds the two things properly, you can simply add something called, you can add the spec keyword, and then you can specify, you can have the same function name and specify. You can ensure that the result is equal to what you want it to be. So this is like a test case that's been added here.
00:09:24.668 - 00:09:49.884, Speaker A: That's how I like to think about it. And then you have a similar function for subtract. You can also multiply numbers. You can also divide numbers when you're dividing. You want to make sure that you're not dividing by zero, because that's not allowed, because then you'll just run into infinity. You have the max function, so you have a bunch of functions right here. So you write the function, and then you write the specification, and you ensure that it's correct or not.
00:09:49.884 - 00:10:16.620, Speaker A: That's how the syntax works here. And we have done this for a bunch of other bunch of other functions, is odd, is even, blah blah blah. You get the point. And then I can simply run the move prover from aptos. So it start checking the specifications that we have right here. And you can see it's a success because these are very simple functions. We're just checking if it does what it says it does.
00:10:16.620 - 00:10:52.528, Speaker A: So cool. Let's look at a more complex example. So I'll just comment this out, and then we will move over to example two. So this is an example of a more complex smart contract. And what we do here is basically just comment on this code, otherwise it will cause issues. Yeah. So this is the coin module.
00:10:52.528 - 00:11:19.052, Speaker A: It's, you can think of it as a bank sort of application where you can deposit coins into this storage area and then you can transfer it, you can take it out and there's a maximum amount of coins that you can put into it. So again, we define a module. That's how you start smart contracts on aptos. So this is the address that we put right here. Zero, x, four, two. Same thing as before. It's called coin, and we use the signer function.
00:11:19.052 - 00:11:50.386, Speaker A: So this is to make sure that you can sign the smart contracts, whether it be the user or when you want to deposit or take money out of it. So that is why we import the, again, very similar to rust if you have written smart contracts in Solana. Cool. And then the very first thing we do is we define a constant and some module level specifications. So we have this module right here, pragmats, if it is strict. So we want very strict verification here. So that's what we're defining right here.
00:11:50.386 - 00:12:18.646, Speaker A: Then we also define the max balance. So we want only 1000 coins that can be deposited inside of it. And the next step, we define a struct. So this is the account, and it keeps track of the balance inside of the account. And the account is, it's a type of a key because it's a user account and the user account is controlled by a public key. So that's what we're defining here. And then you move down, we start defining some specifications.
00:12:18.646 - 00:12:58.778, Speaker A: So these are for functions that sign some of the things that for other functions that we have below. So you can create accounts, you can transfer money, withdraw money out of the smart contract, deposit, etcetera. So for that we're just defining the signers over here. And this is also like, we're using a specification right here. So, yeah, and then we move over to like some other functions of the smart contract. So we're creating an account that, and then we write the corresponding specification for it. Again, we abort if the account already exists.
00:12:58.778 - 00:13:38.088, Speaker A: And we have the ensure statement set here, so that you ensure that address actually exists and then the balance is at least equal to one. And then you also have a withdrawal function. So the withdrawal function just takes out the subtracts the amount of money that you want to take out from the balance that you have. And again, you write a specification for it. The, so the sort of sequences, you write a function, you write its corresponding specification. Similarly, you do that for the deposit function. Again, you write the specification, you write the function and then you have the transfer.
00:13:38.088 - 00:14:13.042, Speaker A: So you can transfer to other accounts or you can deposit into the smart contract. And again, you write the same specifications. And the last thing is pretty important, this is something called invariant. So generally you want to check these, like the accounts that you're transferring to. You want to check for all possible accounts that there are and not just one particular case. So it does not vary, it's invariant. So you check for all possible use cases where accounts can deposit or take in money.
00:14:13.042 - 00:15:00.608, Speaker A: So that's why you have this invariant line over here. And you're just checking to see if the balance is less than the max balance. So again, similar to writing tests for smart contracts, but yeah, now we can also run the move pro right here. So the command is aptos move prove and then the directory that we're in so we can see it's a success because everything works as intended. So if you, as you can see, just by writing these simple tests, you can very easily tighten feedback loop for just seeing if you have vulnerabilities in the smart contract or not. And that is how formal verification works. So I think we've come towards the end of the presentation.
00:15:00.608 - 00:15:17.020, Speaker A: Thank you so much. And I'm Rasoon Pratham. If you want to follow me on Twitter or other social media and you can even find me on Telegram, love to chat about all things move. And I had a blast doing this presentation, so thank you so much.
