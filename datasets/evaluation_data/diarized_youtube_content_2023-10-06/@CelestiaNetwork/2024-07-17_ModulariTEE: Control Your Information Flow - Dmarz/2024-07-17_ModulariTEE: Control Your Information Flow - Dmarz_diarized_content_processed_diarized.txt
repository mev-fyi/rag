00:00:01.800 - 00:00:31.620, Speaker A: Okay, I'm gonna get started. What's up? I'm dmars. I'm gonna be showcasing not only my ability to make puns, but also how you can control your information flow using Tes. I'm gonna give you a little bit of a story for why applications need to control their information flow. I'll briefly mention how you can use Tes, but the rest will be left to your imagination. Yeah. So first, I'll sort of motivate why Mev should be part of the modular stack.
00:00:31.620 - 00:01:06.060, Speaker A: I'll then go through a story of two ofas, which stands for order flow auctions. And then lastly, I'll talk about what do so Mev in the modular stack. So why did we invent the modular stack? We as in the community and celestia. But it doesn't align with the ethos of the space to have everything be monolithic and controlled by one person. That one's pretty obvious. Um, cars aren't monolithic. Uh, you know, high performance machinery does not all get controlled by one person and have interfaces that aren't able to be swapped in or swapped out by other people's, um, products.
00:01:06.060 - 00:01:37.580, Speaker A: And then lastly, division of labor. If we specialize between different teams, then, you know, someone working on DA or someone working on consensus or settlement or execution are all able to benefit from each other. So how's it going? Um, I would say largely it's going great. This is a screenshot from conduits rollup as a service UI. There's a bunch of other roll up service providers as well, and it's pretty awesome. You have four options already or three. You can pick between two different stacks.
00:01:37.580 - 00:02:24.780, Speaker A: You can choose multiple different settlement layers and execution layers as well as data availability layers. If you were to be building a blockchain about four or five years ago, what you probably would have done is went to to go Ethereum and forked it, or you would have used the Cosmos SDK, which is also a bit more modular than forking. Go Ethereum. So although it's going great, pressure is definitely growing in certain parts of the stack. So on March 14, this is an example of a high transaction revert rate on base on this date. I don't know what it was, some type of NFT drop or something, but over 20% of the transactions landed on chain were reverting. We dug into this a little bit and we discovered that a large portion of these transactions were on chain searching.
00:02:24.780 - 00:02:43.866, Speaker A: On chain searching can basically be described as well. We can compare it to l one. So on l one. When you're trying to execute an arbitrage, you send a transaction to a block builder. That transaction basically either succeeds or reverts. All. All modern blockbuilders will just remove your reverting transaction.
00:02:43.866 - 00:03:21.196, Speaker A: If it reverts. This allows you to basically compute a bunch of prices off chain, do some execution, and then let the blockbuilder take care of it. We don't have this though on l two s or honestly most of the modular stack. So what's happening is searchers are basically encoding their arbitrage functionality into their smart contract, and they're just pressing that button like a shit ton. They just keep hitting it all day, you can think. So what they do in the contract is essentially they will check between multiple different pools. They will see if there's an arbitrage.
00:03:21.196 - 00:04:05.910, Speaker A: If there's not, they revert. That revert then lands on chain. These chains are quite scalable at this point though. So we're seeing about two cent for revert on a bunch of roll ups, base op and many others, which if you think about it, just to make a dollar profit, you can essentially try 50 different times to press this button. What happens then? If transaction fees go even lower, can you try a million times just to make a dollar? So yeah, this leads us to the conclusion that if you don't have an efficient auction off chain, then your auction moves on chain. And this basically is the motivation for why we think this meme should have an MEV layer inside of it. Cool.
00:04:05.910 - 00:04:56.762, Speaker A: So before you want to just slap another layer on this diagram and say, we'll just take whatever ofa the market decides, whatever mempool, whatever block builder, I'd like to take you through a little story of why this ad hoc composition doesn't work as well as you'd think. Yeah, and so, disclaimer, I am not commenting on the security model of these components or their implementation. My lens is purely compositional. Okay, so let's start with the user, Alice. She wants to trade on some type of chain, we'll call it explode. She's looking to trade long tail assets, as the kids call them. So yeah, she just sends a transaction in profits, right? Well, no, there's like a bunch more complexity, especially for chains with a lot of on chain volume.
00:04:56.762 - 00:05:42.410, Speaker A: But I'm not here to mansplain you the transaction supply chain all over again, but I'll walk you through some options. First, you might go through a telegram bot somehow that ends up at a block builder. You don't really know, you just type some words in a keyboard and suddenly your trade maybe or maybe isn't on chain. The rules there aren't very transparent. The other option is an in wallet swap, maybe where you hold your private key gives you a little pop up that's like, hey, we trade better for you. You again, don't really know how that gets to the block builder, nor do many other people know how that flow gets routed. The other really popular option, order flow auctions, there's actually multiple in production.
00:05:42.410 - 00:06:25.850, Speaker A: What essentially happens here is the user sends a transaction to one of these ofas they're typically behind an RPC in your wallet. The OFA will then send your information about your transaction to searchers. Searchers will then construct a back run, send it back. The OFA will say, oh, okay, you gave all the value back to the user, or maybe 90%. They'll then pass it onto the blockbuilder. The rules there are a little bit more transparent because there's like actual open source code and public rules, but they're mostly socially enforced at this moment. So yeah, one lesson here is that like increased complexity of modular components in this mev layer creates the need for aggregation.
00:06:25.850 - 00:06:57.218, Speaker A: So because of all this complexity, there's been a bunch of people that have tried to make this simpler. So one example is an OfA multiplexer that exists. It makes a ton of sense. If you want your user to get the best refund, you might send it to multiple venues. But let's dive into this. There's a hypothetical one called mevreducer. It has this rule, wherever I send my transaction through, and it reveals this information to the searcher.
00:06:57.218 - 00:07:25.460, Speaker A: But you don't want the searcher to front run you, right? If they have the entire transaction, they could just grab it, front run it, send it to a builder. Now the user is actually worse off. So what they do is they send fake transactions so that the searcher doesn't actually know which one is real. Searchers try to background all of these. Only the ones that are real end up on chain. There's another one, MeV distributor, another hypothetical one. It only reveals partial transaction information.
00:07:25.460 - 00:07:53.266, Speaker A: So potentially Alice is swapping some token pair and the size, but it doesn't tell you which direction. So now the searcher has to send a background for the one direction and the other direction. So that's really great. But this multiplexer will then send it to both of these. And if you're a smart searcher, what you can do is you can just watch both of them. You see a fake transaction. In the first case, you then query the API on MeV distributor to see if it's there.
00:07:53.266 - 00:08:21.150, Speaker A: Oh, it's not there, that's the fake one. You grab the full one, you then search it here. Boom. You see that? That's the real one because it's also in the other Ofa. You can also do this reverse in the reverse way too. But the point here is that both of the security models of these end up weakened because of the fact that we're trying to compose these two mechanisms off chain. So yeah, composing order flow auctions resolves to the worst security for both of these order flow auctions.
00:08:21.150 - 00:09:03.289, Speaker A: Here's my tumblr esque take of this. Yeah. Do not stack mechanisms into the modular stack, but rage, rage against ad hoc composition. Okay, so what do we do about this? So option one, we could say, oh, this is like the status quo and permissionless auctions, and we should accept it. I think that's actually a valid take that if the base layer wants to be maximally decentralized, we totally should advocate for max competition on these things. But I don't think we should stop there, especially if we're trying to bring in the next hundred trillion users. That includes bots.
00:09:03.289 - 00:09:50.580, Speaker A: So option two, build integrated applications. This is a meme from Neutron. The idea is you can essentially, if you have a roll up, you can own the entire stack. You know which RPC the user is going to go to. You then make your sequencer such that it only accepts transactions from that RPC, and then you have very tight control of where the information enters and exits the system. You then can do any, you can basically pick and choose any one of your ofas that you desire, and that totally feels modular. So those are basically the two main options I think of, but there's probably some type of spectrum that exists here between permissionless auctions and integrated applications.
00:09:50.580 - 00:10:46.874, Speaker A: And I think one of our, so one of the key observations from this tale of two fas that I just shared was that information leakage is the issue. So my contention is something in the middle is probably able to control information in a permissioned or semi permissionless setting. So yeah, what if we could control the flow of information across the stack, then maybe it might look something like this. We just have more boxes like cool. And I didn't draw a box around the settlement layer because I'm still a bit confused what the settlement layer is. So, yeah, so what technology do we have to put inside? What technology can we use to wrap these boxes up with another box? The first thing you might grab in your toolkit is ZK. If you have been around for any of the presentations today, you might see how that's an issue.
00:10:46.874 - 00:11:14.766, Speaker A: Though this doesn't work well for multiparty compute or private global state, which is exactly what we're doing. There's multiple different parties involved. Maybe if this is. Yeah, I mean, it's hard to even imagine what like a Dex is without multiple parties. The next thing you might reach for is MPC, and I think that's like a totally valid option. The problem is, it's not speed wise. It's not really here yet.
00:11:14.766 - 00:11:58.564, Speaker A: Today we've actually done a bunch of research where we did like an MPC back running bot at our flashbots research, and I think it was like 20 seconds or something to compute a background which is quite slow and definitely not suited for l two s at the moment. And then as well, you have this k of n trust assumption, which was talked about earlier, and then, oh. Misformatting. So shill alert. I think someone said, we haven't been saying the word shill enough, so I'm trying to help identify where I'm shilling at. Flashbots, we think tes are the answer, obviously. So we think that if you could put these different components in the te, then you're actually able to control the information flow between them.
00:11:58.564 - 00:12:44.820, Speaker A: And this gives us a bunch of the properties we want. It's fast, it's private, it's cheap. Some cool ideas you could think of doing with this new technology. You could do encrypted mempools and order flow auctions, and then you can enforce the boundaries between the two. So basically, your encrypted mempool could ensure that it only sends information to an order flow auction that it trusts or has permission to be able to use it. And I think that's super cool, because as we saw with that other order flow auction scenario, with the tail of the two ofas, there's no way for us to control the information between those two. Not that we need to in all cases, but it's perfectly probably what you need to do if you want best execution for the user.
00:12:44.820 - 00:13:02.660, Speaker A: Execution layer. Privacy is another example. Like block builders and other people who are doing the actual execution are able to work on top of encrypted data. Something like shielded. Da. I haven't really thought about that much, but I think that would be a really cool idea if someone could think of that. And then as well, t multiprovers.
00:13:02.660 - 00:13:20.270, Speaker A: Oh, what's that? Did someone hear something new applications also could emerge if they exist on this layer. That's interesting. I wonder what they are, but cool. That's the end of my presentation. Thanks to.
