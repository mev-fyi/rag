00:00:00.490 - 00:00:56.046, Speaker A: Okay, so what we're trying to do is, yeah, we want to provide customizable roll ups. And what that means is we want people to be able to customize one the base layer or the DA layer. So whether it's like Celestia, we support other ones, which, I'm sorry, I'm embarrassed to say that during a Celestia lightning talk, support like polygon avail eigenda, we'll support some others, we'll support other virtual machines. So right now we support Solana VM and EVM, and then we do some additional customizations based on what the app is, the game. Maybe it wants like Verifiable randomness, maybe you're like a ZK protocol and you need custom elliptic curves or something like that. So this is what we wanted to build. And then the question is, how do we build it? So historically, when Eclipse was first started, let's say you want to just like the most obvious solution to building your own customizable roll up is we'd build it kind of like Arbitrum or something, and we'd just start with EVM and we'd implement settlement on all these different L1s.
00:00:56.046 - 00:01:18.082, Speaker A: Then maybe we want to support SVM and naively. Now you'd have to implement an SVM like interactive fraud proofer or worse, if it's like a ZK VM. Now you have to have ZK circuits for the Salana VM and all this stuff. Maybe we want to add like move in the future. Then we have to redo this whole process. So there's nothing really gained by there's not much infrastructure that can be reused. There's like orchestration infrastructure and stuff like that.
00:01:18.082 - 00:02:05.326, Speaker A: But all this settlement logic would be highly bespoke to each bytecode. So what are some other solutions? Here one, you could do something similar to what ZKsync does. ZKsync has some kind of shared intermediate representation where they take, let's say you're writing in Solidity, they compile it to some LLVM intermediate representation, convert that to their own circuit, or it's compatible with their own ZK sync circuits. But what's bad about that approach is now I'm trying to remember when this was, they had this big announcement that they had finally added support for Yule. It's like language specific support, because they have to re implement this bespoke compiler for their ZK sync machinery for every single language. And the reality is not that many people are using Yule compared to Solidity or all these other languages. So that's a very tedious, again, one at a time type approach.
00:02:05.326 - 00:02:30.182, Speaker A: And then the last approach, which is what we opted for, was just pick a then. So we picked the Solana VM for reasons that we can go into. And let's say we want to support EVM. We have a smart contract that lives on the Solana VM and it basically acts as an EVM bytecode interpreter. And then of course, you want to support EVM wallets. So you need some proxies. So your EVM wallet connects the proxy and that wraps it in a Solana transaction, sends it to your Solana VM.
00:02:30.182 - 00:03:08.658, Speaker A: And in some ways this feels kind of forced, right? Because maybe there's like transaction size limits or gas limits that are more strict in Solana, especially when you have the overhead of this interpreter and there's ways that you can kind of improve that. But that's the downside of this approach. But by doing this, we just have to implement these bytecode loaders in the Solana VM. We have to have these proxy nodes, but we can reuse all of the logic, especially given that for our ZK Solana VM we're using risk zero. So we basically take BPF programs and then we have this JIT compiler that outputs risk five by code. Then we have to make the memory accesses work correctly. So then it works in the risk zero item.
00:03:08.658 - 00:03:30.080, Speaker A: For context. For people who don't know, risk zero is a ZK risk five VM, so it can run any risk five program. And that's what we'reusing for our ZK settlement anyway. So that's how we support multiple VMs. On the DA part, we want to support multiple DA layers. So probably want to do some kind of sovereign settlement. So that's the motivation behind why Eclipse is architecture this.
00:03:30.080 - 00:04:18.206, Speaker A: Okay, so what are the downsides here? Well, one thing, settlement. So the Solana VM and even the EVM to some degree, it's not really built to be used as a roll up, especially for the Solana VM because the state for Solana is not stored in a merkel tree. And that's important, especially for an optimistic roll up because let's say I'm going to assume everyone knows how an optimistic rollup works. So let's say you want to dispute some state route you're like, this is the last state route I agree with. Here are the inputs and you have to be able to re execute that on the settlement layer. So that part of committing to the inputs and saying these were the inputs that belonged to the state tree at that time requires a state route. So without a state route, you can't do that kind of input commitment and then re executing through some settlement layer that's a little bit easier to do.
00:04:18.206 - 00:04:45.058, Speaker A: So in order to do that, we have to stake a sparse merkel tree within the Solana VM. And you obviously want to benefit from the parallelism that's inherent in the Solana VM. That's part of why we picked it to begin with. So you have to have a sparse merkle tree that's able to be updated in such a way that it's consistent with allowing this highly parallel execution layer. So that's one difficulty. Another is that we want to do mev redistribution with things like Skip. That's tough because Solana completely removed the mempool.
00:04:45.058 - 00:05:15.908, Speaker A: So we have to add a mempool back in and that has challenges of its own in terms of now we have to make decisions in terms mean it's something we have to explore further with the Skip team. But ideally it probably wouldn't impact throughput very much. But it's definitely something that Solana, again, was not really designed for. So these are like examples of the downsides of starting with the Solana VM. Okay, this is like more high level stuff. These are like use cases. So this is all like gaming specific stuff.
00:05:15.908 - 00:06:00.144, Speaker A: But the thinking maybe to take a step even further back behind Eclipse, we want to let you spin up your own customizable roll ups. The question is, why would you want to do that? And the answer is there's a bunch of use cases such as games or maybe physical infrastructure networks or enterprise chains that maybe need to be OFAC compliant or have additional privacy layers on top or something. Maybe they need custom opcodes. This is a roll up thesis, so maybe everyone's already bought into this, but this is why people would want to spin up their own chain. And these are examples of specific features that having your own chain could give to a game. Some of these features are not actually specific to roll ups, but this is just like maybe we're talking to Zynga or something. Someone who's not even Zynga actually has a crypto team, but someone who's not super familiar with crypto.
00:06:00.144 - 00:06:27.340, Speaker A: Then the question is, why would they want to be in crypto at all? So we have to motivate that for them as well. So that's what this is, basically. That's basically it. I don't think the rest of these slides are really super relevant, but maybe it makes sense to open it up to Q A or if there's anything that I glossed over. Happy to dive deeper into that. Yes. How are you going to incorporate Verifiable vendors? Yeah, so that one's tough.
00:06:27.340 - 00:06:49.590, Speaker A: The simple answer is you just have an Oracle that's just like, automatically built into all of that. Maybe there's like a system program and you automatically deploy this to every chain that's spun up, if it's a gaming chain, and then the way that Oracle gets its data is through some separate set of nodes that are doing some verifiably random scheme, and then you can always compare against the two or something. Or you could dispute. So that's one way.
00:06:51.000 - 00:07:05.800, Speaker B: So when the website for Eclipse says that you can because I read the docs recently when it says that you can deploy an EVM roll up, you're not really deploying an EVM roll up. You're deploying a C level VM with the EVM inside.
00:07:05.870 - 00:07:07.850, Speaker A: Yeah, don't tell anyone. Yeah, that's right.
00:07:08.220 - 00:07:15.496, Speaker B: All right, got it. Are you guys redoing that or are you guys taking the work from Neon?
00:07:15.688 - 00:07:19.630, Speaker A: Yeah, we work with the Neon team. Yeah. So, like, half of our chains are EVM, actually.
00:07:20.080 - 00:07:25.748, Speaker B: What part of a value role of a roll up that launches on Eclipse?
00:07:25.784 - 00:07:57.240, Speaker A: Just like Eclipse play? A part of it would be the settlement process. So we have this honest minority settlement layer. It's like if you took a sovereign roll up and just did no execution on it, then that's what Eclipse is providing. It's kind of unclear what would be the right revenue model for something like that. You could do like a simple SaaS model where we just don't take any cut, we just charge a flat fiat, I don't know, 100 grand a year or something. Another option is you take a slice of transaction volume. Seems like a little bit more crypto native, but then the risk you run is when a chain gets big enough, it's running like millions of transactions a day or something.
00:07:57.240 - 00:08:20.610, Speaker A: There's some break even point where they're like, we should just be our own layer one, which maybe is like the future of how these roll ups will progress. You start as a roll up and then you establish some critical massive transaction volume and then you branch off as your totally sovereign L1. Another option is you just have some kind of staking mechanism. So basically, that's all to say we haven't finalized our tokenomics. We don't know what the revenue model would look like.
00:08:21.620 - 00:08:28.144, Speaker C: So you brushed on this, but you skipped it over. What was the motivation for using a salona Vmsb foundational layer?
00:08:28.192 - 00:09:03.148, Speaker A: Yeah, well, we wanted a fast VM, so I think of the idea of trying to implement or reimplement settlement for every bytecode was just like out of the question. So we didn't want to do that compiling to an intermediate representation. We explored that a little bit. There's some tooling like Solang, and there is stuff where many languages can compile it to some common bytecode, but ultimately they're not super sustainable. We'd want to compile it to a bytecode that's good for the CK circuitry that we're putting together. So it's better that we just have one highly optimized CK circuit for one bytecode. So we didn't want to reuse anyone else's tooling for that.
00:09:03.148 - 00:09:41.644, Speaker A: So that was part of it. And the Phonobm is really fast. It's parallelized has local fee markets which every roll up is going to need at some point, because I think that one point totally tweets all kinds of crazy things. But one thing that is definitely true is what causes high fees is not really about on ethereum it is, but in a lot of cases it's not about block space contention, it's about state contention. When many people are accessing the same piece of state, that's what causes high fees. And therefore you don't want, if I'm a guy trying to just be a normal guy using a DeFi protocol, if there's a big NFT mint going on, that should not impact me. And that's something that Solana identified and built this fee market to address.
00:09:41.644 - 00:09:59.792, Speaker A: And maybe they identified it because they're one of the highest throughput chains that exist right now. They're the only ones that reached that critical mass. Like they learned through experience. They're like NFTs ended up being a big use case. They started seeing this is taking down the whole chain. Let's address that directly. And probably all these other high throughput chains will end up hitting something similar.
00:09:59.926 - 00:10:10.272, Speaker C: Say cliff settlement layer. What kind of features does it have to make it especially good at settlement? Or do you also plan to have asset issuance or other things on the settlement layer?
00:10:10.336 - 00:10:16.648, Speaker A: Yeah, we do bridging from there too, but yeah, we haven't thought too much about asset issuance or anything. Maybe it's something that we should chat about.
00:10:16.734 - 00:10:22.740, Speaker B: I'm curious, when you're talking to your customers, you allow them to basically pick their DA layer.
00:10:22.820 - 00:10:23.256, Speaker A: Yeah.
00:10:23.358 - 00:10:26.008, Speaker B: How are you seeing preferences around that?
00:10:26.094 - 00:10:34.590, Speaker A: By default, we go to Celestia. Like if they have no preference, we always use Celestia and most people don't popular thing to say in this room.
00:10:35.200 - 00:10:36.664, Speaker C: Most people don't have a preference.
00:10:36.712 - 00:11:04.890, Speaker A: Yeah, most people don't really seem to know or care. The reality is, I think it'll end up being like where do they fall in terms of decentralization versus the costs they're willing to pay? Something like that. I guess you could use it. I don't see the advantage of using Ethereum versus Celestia, but maybe there's someone like Zynga. What they ended up doing is they're just deploying their apps directly to the Ethereum layer one. So these guys just don't know what's going on. So that's kind of how some of these people think.
00:11:08.860 - 00:11:11.880, Speaker C: Is it watching all the different VA networks at the same time?
00:11:11.950 - 00:11:27.070, Speaker A: Yeah. So for the Verifiers, we actually group that with the execution layer. So if someone spins up an Eclipse chain, we're like, oh, it's also on you to run a Verifier because it wouldn't be feasible for us to try to verify for all these chains with all their different maybe they have different block times or something.
00:11:27.600 - 00:11:34.828, Speaker B: I'm curious about your gaming strategy. Like you mentioned about, that's the focus for now in terms of private market fitness.
00:11:34.914 - 00:12:10.264, Speaker A: Yeah. So I guess part of the reason why we picked gaming is just like there's a lot of interesting areas for appchain, so we just flipped a client, we're like, let's pick one of these. And the situation with gaming is that a lot of crypto games, the extent that they incorporate crypto is pretty limited. So those kinds of use cases are not as interesting for us. But we try to push people to incorporate more crypto native game mechanics. We would love to see more stuff like streaming micro payments or, I don't know, some kind of create to earn schemes or things that could only exist on chain. And we have these docs of a bunch of different game mechanics that we think would be interesting to see.
00:12:10.264 - 00:12:28.160, Speaker A: And we want to be design partners for these games. Especially given that a lot of the time if someone is in that category of games that are receptive to being really avant garde, they might not have the crypto knowledge to know what's the right way or right mechanics that they can incorporate. So we have to kind of act as that partner and give that expertise.
00:12:29.140 - 00:12:43.190, Speaker B: Yeah. I wanted to kind of follow up from what Barry asked about people having preferences for DA layers. Execution. Do you get people that are like, oh, I need solidity in my life or I want to e class?
00:12:43.800 - 00:13:02.760, Speaker A: Oh, there are definitely people who have strong preferences on VMs. And even though I have strong preferences on the DA layer, what will happen is polygon will give someone like a million dollar grant. So it's like you have to deploy to polygon avail. So then there's not much wiggle room. They have to use that that's.
