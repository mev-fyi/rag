00:00:01.840 - 00:01:07.770, Speaker A: Hey everyone, I'm Andrea, I'm the CEO and co founder of Magiblok. And today I'm going to be talking about how we're using ephemeral roll ups to build real time games entirely deployed on Solana. So fully on chain games on Solana. So I'd love to give you a bit of the backstory of Got excited about fully on chain games and how we got started. When it comes to building games entirely on chain, I think it boils down to fundamentally these three key properties. If you have state and logic on chain, your game is a permissionless platform, which means that anybody can build smart contracts that extend the functionality of that game, introduce new behavior for your players, and at the same time the same goes for new business model. Developers are able to potentially monetize content in new either with royalties or with direct to consumer sales, but they're able to do that without asking for your consent as a studio.
00:01:07.770 - 00:02:07.936, Speaker A: And this game in the middle is Pirate nation, built by proof of play. They are the same team that used to work on Farmville, if you remember. Oops, how can I go back? Okay, sorry. This team used to build Fireville, and if you remember what happened with Farm, they were basically building on top of Facebook. And Facebook at some point decided to unilaterally change their relationship with Fireville and basically rock them. And so the second property that is interesting about fully on chain games is that they basically represent these unstoppable world, unstoppable digital realities that no matter what happens, will persist forever and lowers the trust barrier for developers to build on top of your own platform. And the last property is verifiable compute, which is obviously a great fit for any sort of poker or casino games, but not necessarily only those type of games.
00:02:07.936 - 00:02:53.796, Speaker A: Any PvP with some value at stake, think esport, for example, is a great fit. And you also have the ability to create prediction market that doesn't require external oracles to resolve. So if you can run the video right now, we basically start building a fully launching game on Solana. We chose Solana because we wanted to preserve the composability of the state. And this was essentially a PvP arena game where you could put down some soul, invite your friends or compete with strangers, and roam around an arena where you have to kill your opponent. You see there's a spinner in the top left corner and that is a Solana transaction. So we were basically running this game entirely on chain.
00:02:53.796 - 00:03:49.700, Speaker A: And you can see that now I'm trying to kill the other player by blowing myself up and to basically kill the opponent. And you notice that there is a significant amount of lag between these games, these two players, which make that experience basically unplayable. There's no chance that this game could become a mainstream consumer application. And so the we were considering whether we should build our own sovereign chain or roll up, but at the same time, we kind of were stuck in this trade off between composability and performance. We didn't really want to build on rollup in order to preserve the property of composability. Rollups tend to fragment the ecosystem to the point where even if you're sending a simple native USDC payment, it can become this overly convoluted and complicated process. But at the same time, Solana was clearly not enough for us.
00:03:49.700 - 00:04:38.659, Speaker A: We only had this general purpose runtime and we couldn't customize our own block time. We couldn't have sovereign block space to reduce the fees, for example. And we didn't have enough TPS for the moment where we needed to onboard new players. And therefore we went back to the design board and we created what we call ephemeral rollups. We published this paper and here's how it looks. Could you please run the second video? So this is a fully onchain game that is entirely deployed on Solana and is accelerated with ephemeral rollups. You see the transaction being processed super fast, and at the same time we managed to reduce all the lag within these two clients, playing together side by side.
00:04:38.659 - 00:05:22.280, Speaker A: And not only the game is hyper performat, but is also composable with Solana L1, because by minting this gem, we're sending a transaction that mint the token on Solana Mainnet. This is based on the player position in the ephemeral roll up. So we are looking at the coordinate in the ephemeral roll up and we're minting that token. And this is fundamentally what magic block is about. Magic block is a decentralized high performance network that extend Solana capability and accelerate state transition without breaking the composability of the underlying base layer. We give developers the ability to run real time transaction. The latency, the end to end latency is less than 50 milliseconds.
00:05:22.280 - 00:06:12.050, Speaker A: But at the same time, we're composable with the underlying base layer because the smart contracts are deployed directly on Solana and not on a different ecosystem at the same time. This system is scalable. We can give them more TPs on demand whenever they might need it. And it's modular, which means that we can give them sovereign block space and the ability to customize the runtime to introduce loops, or to have custom fee policies. So, to understand how this system works, just keep these two very simple concept in mind about how the Solana virtual machine works. Solana Works has this notion of accounts where state and logic is natively separated. You have executable and non executable account, and so you have the logic that is natively detached from the state.
00:06:12.050 - 00:07:05.106, Speaker A: And at the same time, we have PDA's program derived addresses. Basically every account has a program owner, and program derived addresses are these deterministically derived addresses that program can leverage in order to sign without a private key. So with these two ideas, we can go through an ephemeral roll up lifecycle. Developers deploy smart contract directly on Solana and they can delegate account the PDA into a delegation program, effectively moving the ownership of that PDA through the delegation program and an SVM operator. So a fast Solana validator that we wrote from scratch to optimize for performance. Spin up an ephemeral roll up session. The overhead on the validator is between four and ten milliseconds, because it's not bound by consensus.
00:07:05.106 - 00:08:05.864, Speaker A: We don't have voting, we don't have voting, we don't have gossip, and that's why the state can change so quickly. This is the state of the position of the player that you saw in the video before. And whenever we need that information back on chain, we can post a commitment. The active node operator will post a commitment on the base layer and a network of challenger, verify the integrity of that computation. So this is fundamentally a fraud proof system where you have these parties that active challenger, and can sign off that state commitment before it gets finalized on Solana. And when that happens, we have the position, state gets updated, the authority of the pdas get transferred back to the original program, and we can have conditional operations such as a token mint, as you just saw in the video. The interesting idea behind this design is that we can shard the state of games or application into multiple execution environments and run them in parallel.
00:08:05.864 - 00:09:25.454, Speaker A: Because on Solana you always declare upfront the state that you're accessing in the transaction. You can decide to maintain on the base layer an NFT mint or USDC payment, and only move the state position of character, for example, in one or multiple ephemeral roll ups, or you can do vice versa. It's completely up to you as a developer to decide which account you want to run in the ephemeral roll up and which account you want to keep on Solana, and at the same time with an RPC router, we can abstract all of this complexity away from a user perspective. So with a single RPC, they're interacting with all of these different environments that are executing state transition function for your game or application. So when it comes to the trust assumption, this is my mental framework on how you can basically prove that some off chain computation is correct. You have validity proof that rely on cryptography security, and you have fraud proof that basically rely on the assumption that someone, some honest party, will raise a challenge if they detect some fraud in the session, where that probability basically depends on the length of the challenge period. We assume that the longer the challenge period, the easier it is for someone as party to raise the challenge, and it depends also on some sort of bond.
00:09:25.454 - 00:10:44.230, Speaker A: So what is the economic incentive for some party to raise that challenge? And at the same time, you need a sufficiently high enough number of parties to act as challenger, because if nobody is watching that session and nobody will raise the challenge, and the more active participants, the more stakeholders are acting as challenger, the higher the probability that at least an honest party will raise that challenge. And so the way our system works is that the ephemeral roll up are posting a state commitment, and then there's a challenge period which the developer can specify. They can decide to customize this challenge period, but well, obviously, if that challenge is raised, we have to enter into a dispute game and that challenge period is extended. And then we have to resolve either with a section game or with a ZK proof what the state was. But if the challenge is not raised, then by default the challenge window is extended, unless we have this prespecified number of nodes that sign off that state commitment. And this is basically to ensure that there is at least some party that watch that ephemeral roll up session. And this number is also customizable by the developers, so they can basically trade off some time for money.
00:10:44.230 - 00:11:50.350, Speaker A: They can pay these parties to sign off that state commitment, and they can be more aggressive on the security window because they want to settle back the state faster. And there's also optimization that we can do in terms of not having full node, recomputing one by one and replaying all of the transaction, but having lite clients or sampling nodes that basically just sample portion of the ephemeral roll up. So this is our oldest scenarios, and when the challenge period is not elapsed, obviously we want to wait for that period to come to conclusion. But even if the window ends and we don't have enough signature, we don't have enough parties acting as challenger. There is the probability that there is potential fraud, right? Because there's not enough challenger basically. And this could happen especially with very, very aggressive fraud pro window. At the same time, if the part is the signature threshold is reached.
00:11:50.350 - 00:12:40.584, Speaker A: But we are not yet done with the challenge period. We want to wait for the challenge period to terminate. So only in the case where both are true, where the challenge period is elapsed and the signal to traction has been reached, we can finalize the state back on the base layer. So to sum up why ephemeral rollups is an interesting solution. Ephemeral rollups operate at the account level, so they only accelerate particular state that you want to delegate into these sessions. And any account can natively be delegated into a blazing fast Solana validator that operates at faster speed because it's not bound by consensus. Ultimately there will be multiple parties running these nodes, and these nodes can be spun up just in time and co located close to the user.
00:12:40.584 - 00:13:31.720, Speaker A: So everything is deployed on the edge to reduce farther than network latency. And this gives them the ability to basically access sovereign block space because they can customize the runtime the way they want, they can specify their own gas policies, they can introduce randomness at the node level. This is something that we have been asked where they can decide to extract meve if they want. And this only takes an extraction call on Solana, so they don't need to redeploy into a different system. They can just call an existing, the delegation program and from there they can operate in the ephemeral roll up session. So the validator will automatically clone all the programs that are needed to execute that state transition function into the ephemeral rollups. Obviously we are focused on gaming.
00:13:31.720 - 00:14:31.768, Speaker A: We have a whole variety of tooling that we have developed for facilitating the creation of fully on chain games. We have Bolt, which is an entity component system to basically allow this smart contract to be easily extendable. We have session keys which allow users to sign transaction automatically and not having to approve every single operation or interaction that they're making in the game. We are unity verified solution. So we have huge amount of SDKs for not only Unity, but Unreal Godot phaser that game developers can use to build their games. But this system is fundamentally a system can be used for many other use cases. All of the use cases that you see here are either use cases that we are actively exploring and project that we're working with, or we have project that reach out to us to explore ephemeral rollups as a way to scale, accelerate, and customize their own runtime.
00:14:31.768 - 00:14:45.250, Speaker A: So if you're interested in understanding more about ephemeral rollups or to get in touch with us, feel free to reach out on my telegram or follow us on x. Our handle is magicblog. Thank you.
