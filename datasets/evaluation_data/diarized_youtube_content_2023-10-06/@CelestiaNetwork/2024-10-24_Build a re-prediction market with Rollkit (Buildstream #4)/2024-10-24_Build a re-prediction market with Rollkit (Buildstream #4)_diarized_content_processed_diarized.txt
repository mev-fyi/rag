00:00:36.515 - 00:01:21.665, Speaker A: Welcome everyone to Build Stream, where we explore projects from the Celestia ecosystem and learn about their whatever in terms of what they're building. In build stream number four, we're going to be learning about how to build a reproduction market using RollKit with Celestia underneath. My name is Josh, I'm from Celestial Labs and I'm excited to welcome Jarek and Manav from Rollkit. Today they'll be guiding us through building that reproduction market and helping us learn about what it's doing and how you could build something like this of your own. So a few notes, feel free to ask questions in the chat. We'll get to them during the stream. All the source code will be linked on GitHub in the video description.
00:01:21.665 - 00:01:39.745, Speaker A: So yeah, let's get started with some introductions and start understanding what this project's going to be. So first, rollkit. Rollkit is a way to build unstoppable apps. Manov can you introduce yourself and then briefly describe what Rolekit does?
00:01:41.805 - 00:03:27.225, Speaker B: Hey everyone. Yeah, Manu from the Rokit team. Rollkit, like as Josh mentioned, we call it the installable stack. So it's kind of the way the framework for you to build go from like you can define the whole pipeline from how you go from blobs on Celestia to any random sort of state that you would like to go to. It has a bunch of these components to customize all of these things on how you go from blobs to a set of transactions to how you interpret those transactions in a state machine and then to come to a new state, it role creates the stack too for you to define the entire thing and what makes an unstoppable kind of the angle is since these apps are directly on DLL like Celestia, right? And that is that since the liveness properties of that this app is directly related to the liveness properties of what's the liveness of Celestia are since people can just directly post transactions on Celestia so you can kind of capture the full spectrum of how like what build whatever really means. So it's you can think of as like the toolkit to build whatever.
00:03:28.405 - 00:03:55.195, Speaker A: Yep, awesome. And I definitely fumbled the intro a little bit. We're going to explore projects from teams building whatever and we're going to learn about what that whatever is. So yeah, thank you for getting to that. And then specifically we're going to build an unstoppable app today, but we're going to be building a reproduction market. I feel like prediction markets are pretty hot, but I've never heard of a reproduction market. Yark, what are we doing today?
00:03:56.335 - 00:04:19.987, Speaker C: Hi, everyone. Yeah, I work on RollKit as well. Reproduction market is a simple app. It's more like an example app which could be built using hotel rollkit. Settle on Celestia. The app itself allows you to place bets on the odds of the elections. And when the election is done, you can claim your winnings.
00:04:19.987 - 00:04:23.375, Speaker C: Basically, it's pretty simple, pretty straightforward, I would say.
00:04:25.035 - 00:04:33.955, Speaker B: So you're kind of predicting what where the prediction market would go to. That's why it's called like a reproduction meta production market.
00:04:34.075 - 00:04:40.455, Speaker A: Nice. So on that note, I think we're ready to get started, right?
00:04:42.355 - 00:04:43.215, Speaker C: Yeah.
00:04:44.515 - 00:04:45.115, Speaker A: Nice.
00:04:45.235 - 00:04:51.815, Speaker C: Okay, let me share my screen then and I'll walk us through this. Okay.
00:04:54.795 - 00:05:05.645, Speaker A: And a reminder to anyone watching, if you want to drop questions in the chat, feel free to do so and we'll get to them, you know, as it makes sense. Whoa.
00:05:07.185 - 00:05:08.321, Speaker C: Can you see my screen?
00:05:08.433 - 00:05:09.325, Speaker A: Yes, sir.
00:05:10.465 - 00:05:37.615, Speaker C: Okay, so there are a few components we need to take care. First, we want to start the celestial light node, which would allow us to perform data availability sampling. And we're going to do this on the Mocha testnet. This is the docselesta. Org. This is the tutorial for how to set up Celestial. You got to have it installed, built.
00:05:37.615 - 00:05:59.821, Speaker C: I did it already. So I can just run some commands, e.g. init and then I have my own key with the faucet funds with the funds received from the faucet and the way I start the the node itself. So let's do. So let's delete Init Mocha.
00:05:59.893 - 00:06:06.717, Speaker A: Okay, now I guess for people who aren't clear, Mocha is a testnet, right?
00:06:06.861 - 00:06:08.149, Speaker C: Yeah, Mocha is a testnet.
00:06:08.237 - 00:06:08.865, Speaker A: Nice.
00:06:10.165 - 00:06:35.165, Speaker C: Now I have a key which is. Which is not my slasky, but I guess it's called yback or why betas? I don't remember why. B test. I guess let's try. Okay. Okay. Seems like we have it running.
00:06:35.165 - 00:07:20.559, Speaker C: No issues, no warnings, no errors. Let's move on. Okay, some warnings, yeah, but no errors warnings. That's okay. Now let's get to how do we connect it to our app? So the app itself would be running on the rtella rolekit repository. So it's a rolekit with git as execution client, which will have a rollkit as a consensus and will send the blocks, post the blocks to the da.
00:07:20.727 - 00:07:24.975, Speaker A: So can I interrupt you real quick? Could you zoom in on this, please?
00:07:25.095 - 00:07:26.567, Speaker C: Okay. Yeah, yeah.
00:07:26.631 - 00:07:27.875, Speaker A: Nice. Perfect.
00:07:28.255 - 00:07:47.161, Speaker C: Yeah. For that we're gonna take this repository, our tel network, our telerolkit, the main branch. We're gonna clone it. I have it already. And we will spin it up. And to do that we also need some setup for connecting it to the da. And here we have.
00:07:47.161 - 00:08:00.845, Speaker C: Let me zoom in again. Here we have at Rolekit Dev we have a tutorial for how to deploy a roll up or an app to Celestia.
00:08:01.545 - 00:08:04.665, Speaker A: In this case the roll up and the app are the same thing, right?
00:08:04.825 - 00:08:34.569, Speaker C: Yeah, basically. And TLDR would be that we need to have. We need to provide these four flags to the binary to the start command. We need to get the auth token, namespace, block height and DA address and also rocket aggregator for the signature. So let's do it. Let's follow this tutorial. So we have light not running.
00:08:34.569 - 00:09:02.255, Speaker C: Okay, let's try to get DA block height, auth token. But this one is for Arabica. So we want to change it to mocha and let's print it. Okay. There is a key token. The DA namespace is the default one. Let's just export it.
00:09:02.255 - 00:09:28.625, Speaker C: The DA address is the default one as well. Now we have it. Let me copy all these flags. I'll copy start as well. I'm going to first build it. Let me go to Teller. So I cloned the repository.
00:09:28.625 - 00:09:59.127, Speaker C: Here I have everything and there is a init script. So init script allows you to set up the like app state, app genesis and all the config for the. For the app. I'm gonna leave this as it is right now, but I could have few keys. I could have rename it. So what's happening here? We have. We create the key we added to the Genesis.
00:09:59.127 - 00:10:24.415, Speaker C: We allocate Genesis accounts. Yeah. And sign the transaction. And the rest is some validator stuff and some configs for the Genesis. This may be refactored later, but. Okay, so first I'm going to build the binary itself using Ignite. Using Ignite chain build.
00:10:29.595 - 00:10:33.475, Speaker A: And this is the same way you'd build any Cosmos SDK chain, right?
00:10:33.635 - 00:10:34.375, Speaker C: Yeah.
00:10:34.995 - 00:10:50.325, Speaker B: Yep. So Role Kit is like an EVM on top of Cosmos dk. And Role Kit right now works with the Cosmos dk. With this interface called abci.
00:10:51.865 - 00:10:58.005, Speaker A: You can scaffold a rollkit app from Cosmos SDK now. Right. Or from Ignite rather.
00:10:58.305 - 00:10:58.849, Speaker B: Yes.
00:10:58.937 - 00:10:59.605, Speaker A: Yeah.
00:11:02.785 - 00:11:15.575, Speaker C: Okay, now let me try to start it like this. Did I miss anything? Yeah, probably worth mentioning.
00:11:17.715 - 00:11:20.095, Speaker A: What did you set the namespace?
00:11:21.875 - 00:11:32.115, Speaker C: I think I did. Let's change. Check it. Yes, I did.
00:11:32.235 - 00:11:33.067, Speaker A: Okay.
00:11:33.251 - 00:11:35.415, Speaker C: The default home would be.
00:11:38.675 - 00:11:41.735, Speaker A: That was all set up with the init script. I see.
00:11:42.515 - 00:12:04.053, Speaker C: Yeah. The default home for the app would be my home and our troll directory. I'm going to run the init script right now and it will create the config for me at my current directory which I will copy to the home. Okay. File it is valid. Genesis. Cool.
00:12:04.053 - 00:12:44.109, Speaker C: Now I'm going to remove my previous from home and copy to home. Let's see if it's there. Control Genesis. Okay, it's there. So we have one key. So if I do so there is a command under the artillery which is a cosmos command. It says I have a keyring test and I have the name of the key and I'm going to get the address and the private key.
00:12:44.237 - 00:12:44.765, Speaker A: Nice.
00:12:44.885 - 00:12:56.235, Speaker C: With the signing algo for eth. So what I want to do right now is starting using start. So.
00:12:58.335 - 00:13:00.475, Speaker A: And why do you need that key to start it?
00:13:01.055 - 00:13:13.271, Speaker C: No, no, I just printed it for myself to use it from the contract. So when I, when I do the deployment of contracts on Gith, I will use as a deployer this key basically.
00:13:13.303 - 00:13:13.735, Speaker B: Yep.
00:13:13.815 - 00:13:14.615, Speaker A: Makes sense.
00:13:14.775 - 00:13:40.385, Speaker C: Okay, let's try to start it. Okay, what we see here is logs for blocks. And now we also see over here that the git module has started at Port 8545. And now I also want to see the blocks being posted to the DA actually finalized.
00:13:41.805 - 00:13:45.185, Speaker A: So now we're making EVM blocks on a roll up.
00:13:46.405 - 00:13:50.765, Speaker B: Yep, this just starts a EVM roll up. Nice.
00:13:52.105 - 00:14:00.561, Speaker A: It's basically like blank slate to do whatever you want with to basically tailor out for your app. Nice.
00:14:00.753 - 00:14:27.857, Speaker C: Yes. I don't see any issues with the light node and I see the logs for submitting blocks to the DNA later. I'm going to leave it. We have it running. We have the port 8545 open for the RPC. And now let's, let's work on the production market itself. So I'm gonna go to market.
00:14:27.857 - 00:15:02.347, Speaker C: Yes. Okay, so we don't have UI right now, but we only have the CLI interface. So first I want to walk us through the code real quick through the contract itself. So Election Prediction Market is the name of it. So we have. Okay, this is, I think this is, this should be 23, I guess 59. 59.
00:15:02.347 - 00:15:07.083, Speaker C: I'm not sure if the date is correct actually, but pretend it is.
00:15:07.139 - 00:15:08.295, Speaker A: It's all good. Yeah.
00:15:09.525 - 00:15:34.541, Speaker C: So the market, the name of election, the pool size, whether it's result or not, who was the winner and the. The bats pools basically. So votes for Democrats Votes for Republicans which is Republican which is just the difference of 100. Yeah so we we assume that there are no other and date for the last update the bed itself party which.
00:15:34.573 - 00:15:56.335, Speaker B: You just to reiterate what's going on here. I think it's like I don't know if we stated it is like users can kind of are predicting where the odds of prediction would go of the I think the market which is the election market right now. Right.
00:16:02.365 - 00:17:06.627, Speaker C: The amount whether it's claimed or not and the list of user bets Then we have few events deconstructor. So this is basically a simple solidity smart contract which could be done by anyone. So I'm just going to walk through it. So we have a bad token so we're going to deploy some ERC20 token for the beddings just for using it as the source of funds basically election name odds. Yeah, as I said and that's it. Okay so this is the function for the oracle which will update the odds. So this will be done every minute I guess every minute we will get from the get the Democrat odds get the calculate the Republican odds timestamp and that's it.
00:17:06.627 - 00:17:10.179, Speaker C: So the function for placing by itself.
00:17:10.307 - 00:17:13.651, Speaker A: Where are we going to get those odds? I feel like we haven't covered that.
00:17:13.803 - 00:18:18.889, Speaker C: Yeah, yeah, yeah we're going to get it from the public API I guess call API. I'll get to it in a minute. Let's get through the placing bets. I'm going to make it a little smaller placing bets so we check if market is resolved full sizes and then we push the user bet in mid event as well Resolution of the market where we specify the winner and the claim winning where the winning is calculated over here. Over here. So basically the winning is calculated by taking the same percentage as person batted for the winner party taking the same percentage from the losing party editing to the what he like bat and this would be the total winning basically okay get market info is just to view so get the odds and the bets. GetUser Bets is the view to get user bets and pretty much it.
00:18:18.889 - 00:19:05.167, Speaker C: So as you said we gonna have an oracle and take the data from the Internet. So for that I created a small bash script called this. So this is just a loop which every 60 seconds takes the result from here. Okay but this has to be maybe if I make it smaller it will fit just to jump on it. Okay so let's see. Okay, wait a second. No.
00:19:05.167 - 00:19:39.365, Speaker C: Okay yeah so this is taken from the apicalashes.com the markets this is the ticker name for Kamala Harris. And there is a last price value. So last price is the odds, basically 45%. And so if we have 45% here, we know that 55% for the Republicans. So if I go to kalashu.com. yeah, this is it.
00:19:39.365 - 00:20:15.715, Speaker C: So 55% for Republicans and 45 for Kamala Harris. Okay, let's get back to this, to the script. We also have here a helper script market ch, which I'm going to get through in a minute. And here we just get that last price I mentioned for the Democrats. So first let's deploy the contract, the bed token. This is just ERC20 token. Okay.
00:20:15.715 - 00:20:40.645, Speaker C: Deploy. I think I have a forge script for that. Create. Okay. It's really hard to see anything. Okay, so and we also want to make sure the private key is the same. Private key.
00:20:40.645 - 00:20:58.989, Speaker C: Okay, so we have the amp here which has the private key. So using the key info command, we want to take. Okay, something's really with my. With my terminal. Let's try it again.
00:20:59.157 - 00:21:00.989, Speaker A: Yeah, yeah.
00:21:01.117 - 00:21:43.175, Speaker C: So I want to take these two and put them for the owner to the address of the dot M over here. Is it the same? Actually, no, it's not the same. So and owner address, I guess. Yeah. We will also update the values for the token and for the market. Okay, now let's try to create it again. Okay, we specify that we have 100 million tokens minted.
00:21:43.175 - 00:22:08.705, Speaker C: Specify the RPC and the private key. Private key is because I did not export it, I guess. Let's try again. Okay, so we see that the contract was deployed to this address. So let's update that N like this.
00:22:09.085 - 00:22:11.705, Speaker A: I've never seen someone hop around vim so quickly.
00:22:13.005 - 00:22:13.605, Speaker C: What?
00:22:13.725 - 00:22:16.785, Speaker A: I've never seen someone hop around vim so quickly. Nice.
00:22:19.485 - 00:23:02.077, Speaker C: Okay, shall we check if it's deployed? Just want to check the code. Okay, so the token is there. Now let's get through. We have a script for deploying the market. Deploying prediction market. What it does, basically it gets the instance of the token from the address and it creates the election prediction market with a 50% quads initial. And its name is 2024 US presidential election.
00:23:02.077 - 00:23:06.493, Speaker C: So let's try to deploy. I think I have the deployment script for that. Yeah.
00:23:06.509 - 00:23:11.509, Speaker A: So why does it start at 50? Is that just to set it?
00:23:11.677 - 00:23:30.167, Speaker C: Yeah, yeah. It will be updated the first cycle of the Oracle. Okay. We just need to start from something. Okay, here we have the script for deployment deploy prediction market. Let's try to run it, see if it works. Okay.
00:23:30.167 - 00:23:57.635, Speaker C: It seems like it worked. It worked. And this is the address I want to put to the market. Address the source. Okay. Okay, so we have the token deployed. We have the market deployed.
00:23:57.635 - 00:24:34.921, Speaker C: Now let's try to get any view. So I'll get through this helper script I have, which is a small bash script. What it does basically let me get through the end. Yeah, so it has a few commands like updating odds for the Oracle. Yeah, the resolution of the market, the bet, like placing bet and some views. Okay, so let's, let's try to get the view. Actually market info.
00:24:34.921 - 00:25:19.755, Speaker C: Is it info? Yeah, market info. Okay, so this is invalid and time. So nothing, none of that in the pool. Now let's start the Oracle. That will update the odds. Okay, seems like it did. What if I'm gonna get to another terminal and and I want to check the info if it was updated.
00:25:19.755 - 00:25:32.335, Speaker C: Okay, seems like it was updated. Now market info. Okay, so the odds are updated right now.
00:25:32.495 - 00:25:33.127, Speaker A: Nice.
00:25:33.271 - 00:25:36.111, Speaker C: Let's check if it's valid. Still the same.
00:25:36.303 - 00:25:37.955, Speaker A: Looks like what it is on there.
00:25:38.545 - 00:26:01.769, Speaker C: Yeah, yeah, it's still the same. Okay. Okay, now I'm gonna try placing my bet. So for that I'm gonna use market. Get user bets. I guess get user bets really is a view and it gets me nothing. So I don't have any bets.
00:26:01.769 - 00:26:18.827, Speaker C: I'm gonna bet. But okay, I need to specify the party would be zero for Democrats and how much I want to bet. Let's say 100 bucks. $100. Let's try.
00:26:18.891 - 00:26:22.091, Speaker A: Okay, 100 big bet tokens I think, right?
00:26:22.203 - 00:26:42.027, Speaker C: Yeah, 100 tokens. Not a dollars but not a stables. But just bet tokens. You're right. So I have one and I'm going to place another one for, for Republicans for example, $100 as well. 100 bad tokens as well. Yeah.
00:26:42.027 - 00:27:01.177, Speaker C: Okay, let's get user bets. Okay, so we have bets and let's get the market info. Okay. First I want to also check if everything's fine here. Okay. What is this? Ah, this is what's the wrong key I used. So this is not an issue anymore.
00:27:01.177 - 00:27:25.485, Speaker C: And Celestia light node is up and running. Okay, so blocks are being posted, I guess. Yeah, creating revolution blocks. Okay, everything's fine. And here we have already three cycles of the updating odds. So Oracle is working. We place bets now we can try to resolve the market.
00:27:25.485 - 00:27:30.305, Speaker C: Market. What's the command?
00:27:32.805 - 00:27:33.745, Speaker A: Resolve.
00:27:34.685 - 00:27:53.049, Speaker C: Yeah, resolve. Right. Okay. Expected one. Ah, yeah, I think I forgot to provide the for resolve. What are the result? Let's say, let's say zero For Democrats election not ended. Okay, so we can resolve it.
00:27:53.049 - 00:27:54.465, Speaker C: Yeah, I think this is it.
00:27:54.545 - 00:27:56.325, Speaker A: So yeah, makes sense.
00:27:58.505 - 00:28:27.655, Speaker C: This is just a demo. So in real life we could have done pretty good, pretty good logic in there, put into the contract, etc, etc. The point is to demonstrate that the way we build the smart contract, the old way is the same as you can spin up your own chain, your own app, using RTL, EVM and RollKit and Celestia as a DA. So that's it pretty much. I guess.
00:28:29.035 - 00:28:44.825, Speaker A: Yeah. So I guess like some notes that I know that you were planning on building this to be a little bit more integrated into the roll up. Yeah. Can you briefly just talk about how that was meant to be done?
00:28:45.325 - 00:29:55.635, Speaker C: Yeah, yeah. So this is a very native approach with this Oracle as a bash strip. It is a possible but this is a possibility to do this the way it should be done through the integration of the Oracle sidecar process and plus the modules Cosmos SDK modules like for the Oracle and for the market map for example, Skips Connect. I tried to do it actually, but then I realized that it would take too long and I wanted to shoot for something simpler. But if I wanted to do it I would just go through the connect, I guess skip. Over here, for example, we have the integration, we have a good guide which allows you to set it up and to spin up the connect sidecar itself. Connect Sidecar plus integration of these modules, Oracle and Market map into your app and plus you need to set up the ABCI method where you want to the pre block where you want to update the market.
00:29:55.635 - 00:30:35.895, Speaker C: Basically fetch the odds from different APIs like for example Polymarket API in this case and have updated the contract from the SDK. So you would want to build generate the EBIS from the solidity and include it into the go code before building use it into the deploy contracts there as well. So you can deploy them in the uni chainer and then in a pre block or just call the methods from this API that you have.
00:30:37.315 - 00:31:35.795, Speaker B: What's going on here? The difference is basically right now the Oracle is in order to update the Oracle you are putting the transactions just periodically, you're just submitting normal transactions. What this Skip connect would allow you to do is it inserts during the block building process itself. You will insert transactions top of the block. So even if there's a lot of activity and there's congestion on the chain, your Oracle price updates never really get. They always top the block. So they are always there and they never not make it into the block so they don't get affected by the congestion. So that's like the main I guess, thing you get from this, from this more sophisticated approach.
00:31:36.215 - 00:32:22.175, Speaker A: Nice. And maybe I guess in the next one we can play around with it on some other market because I think the election will be over by then hopefully. So I guess I noticed that you're using Kalshi and that was actually like surprising to me because I've never heard of Kalshi. I've heard of Poly Market, I've heard of some other ones that exist out there. So I'm kind of like curious from someone watching who's, who's wondering themselves like why would you want to build something like this? And the follow up question there is could you build something like an aggregator for like a bunch of different prediction markets or something like that?
00:32:23.515 - 00:32:58.159, Speaker C: There actually there are many markets here in Koshi Selection. No. Well, first of all, why did I choose Kosher? So I was looking for something public and something that doesn't require any API keys. So I just went to the network and I realized that they have some feed being this data being taken from events. I guess it's over here now. Yeah, basically. And took it.
00:32:58.159 - 00:33:09.435, Speaker C: So as it was something pretty easy could be done differently. Yeah. And the next question you had was whether it's possible to build an aggregator.
00:33:12.215 - 00:33:24.995, Speaker A: I mean, I guess surely it's possible, right? Yeah, maybe more of like a question for Manov about who would be building this and why would they want to do it as an unstoppable app.
00:33:26.855 - 00:34:20.571, Speaker B: Yeah. So why would you build this? So this is more of like a kind of instead of it's a second order derivative of a production market, I guess. Right. So kind of think of it as in can you can do more of like a. This was more of like a basic product but you can kind of do an option where if you wanted to, instead of like you just be buying yes or no on the market, you can buy a call option that like okay, you are, you have the right to buy this like at 55%. If it's a call option, you're buying the right to buy at 55% regardless of where the price goes. So it's just kind of more of a second order derivative.
00:34:20.571 - 00:35:02.283, Speaker B: So I thought that would be an interesting thing since the first order derivative is very popular. That's a natural thing to it. And then you can kind of. It's more of instead of a discrete thing where or where you're getting the whole range of a market where 5556 like you're kind of you would be betting on in this case if you are doing a prediction market, you bet like okay, yes, I want to buy Donald Trump at 55%. I think the chances going to go. It is going to go higher. Instead of buying that, you're just betting that it's okay.
00:35:02.283 - 00:35:29.455, Speaker B: It is going to go up at some point. You're just betting on up, down or flat. That's kind of what like I guess option different strategies allow. Allow you to do so that was kind of the inspiration for why you want to. Yeah, may. But maybe for like markets that are very liquid like the election one a second order derivative would be something people would want.
00:35:29.995 - 00:35:56.865, Speaker A: Yes. I'm like I have like less of a defi brain than I guess I'd like to admit. So yeah, thank you for going through that. So on that note, that was really dope. It was actually like a little quicker than I was expecting. So if you're watching and have questions in the chat, please remember to do that. But in the meantime we're going to talk about what you could build next.
00:35:56.865 - 00:36:06.285, Speaker A: So Manav, what do you think you'd like to see built with Rolekit? It could be prediction market, it could be completely unrelated. I'm curious what you're thinking of these days.
00:36:06.985 - 00:36:40.555, Speaker B: Yeah, for sure. So you can build this architecture like what we demonstrated. It was more of a traditional. This is an app on Celestia. So it's what do you call a roll up. Right. So this is more built in the more traditional sense where you have a centralized sequencer which is like the in charge of publishing blocks all the time and anyone can verify the chain by just looking at the DA layer.
00:36:40.555 - 00:37:05.881, Speaker B: Right. And then the state machine in this case which is the evm. Right. So this is more of like a basic form right now. So you could build whatever you can right now build with like on an EVM in this case. But like what how I see it evolving and what I want to see people build like this. Like what we're unlocking is like the entire more of the design space.
00:37:05.881 - 00:37:46.165, Speaker B: So instead of just a centralized sequencer, you can do more things. Like you can build more application specific chains where you can control the entire block building flow. Like how your transactions make it to your chain. What determines the canonical set of transactions. That right now is being done by a centralized sequencer. But that is a very primitive basic way on how things are done right now. But you can do more interesting things.
00:37:46.165 - 00:38:54.495, Speaker B: Like for example, currently all these transactions are just like this endless sequence is just bashing all the transactions that are coming in. It could do something cooler where instead of a centralized sequencer, you are directly submitting a transactions to Celestia. And the chains like canonical set of transactions now would be determined. Like how the ordering of those transactions happens would be determined whoever's the most active. For example in the, in the, in this application instead of like, oh, or you can also allow like sponsoring transactions where some transactions are free, you will only include a subset of people and the state machine like considers the transactions free. So there's like this whole design space that right now we recently are sort of unlocking with something introduced called Sequencing API.
00:38:55.355 - 00:39:00.507, Speaker A: So that's entirely programming Sequencing API for Rolekit.
00:39:00.691 - 00:39:50.105, Speaker B: Yeah, it's a sequence API for RollKit. So how transactions make in to the state machine, we kind of just made that entirely programmable. So we just made an interface for that as a very minimal one. So if you wanted to do a centralized sequencer, let's say for speed, you could still do that. You could also plug into a shared sequencer if you like. Could do a more primitive, what people call a base roll up, which is just, okay, just take whatever transactions are on Solestia and those are your transactions. But you can do something more which is you can unlock, you can apply some arbitrary ordering rule or how you pick those set of transactions.
00:39:50.105 - 00:40:13.245, Speaker B: So let's say, let's say you, you could allow like only a certain set of NFT owners to come and come and bills like send transactions to your chain. Interesting, right? Or you could redistribute the revenue of your chain to the people who fit some certain condition.
00:40:13.985 - 00:40:14.889, Speaker A: Interesting.
00:40:15.057 - 00:41:18.059, Speaker B: Yeah. And then Oracles as well. You could like what Yarek showed, right? Oracles. Right now with Skip Connect it was like okay, you can insert Oracle's prices top of the block with the centralized sequencer doing that. But then instead if you're just having a party or like a bunch of people posting Oracle prices on some namespace on Celestia, your chain, like how you construct your chain, it would just be like putting Oracle prices from that namespace on top of the blockchain. So you can kind of compose different chains together as well. But so I want to see that design space be like explored more and then have more applications, specific chains that like would tap into that instead of like just general purpose ones.
00:41:18.059 - 00:41:24.843, Speaker B: I feel like we have like a, we have like a plethora of general purpose VM chains.
00:41:24.899 - 00:41:25.611, Speaker A: Yeah.
00:41:25.803 - 00:41:37.455, Speaker B: So I want to see more of those and some ideas are, I Want to see more? Like, there's recently web proofs that are. That people have been.
00:41:37.575 - 00:41:38.927, Speaker A: What's a web proof?
00:41:39.111 - 00:42:18.549, Speaker B: A web is like a way to. To take an information or like prove a piece of information that you have off chain using let's say an app. You use like Spotify, right? Let's say, interesting, I am a top 1% listener of some artists. And then it uses something called ZK tls. So there's been a lot of people kind of building ZK TLS stuff recently. So you can kind of prove that you were actually a top 1% listener of some artist on chain. So you have that primitive unlock, right? So you can.
00:42:18.549 - 00:43:06.429, Speaker B: Now I want to see people using web proof. So to be building applications on chain with this. So you can kind of do this on the state machine where, okay, you. You can make a chain where, okay, all the people who satisfy this criteria. Where, okay, let's say the top 1% of an artist and the artist wants to give all these top 1% people the ability to claim some merchandise. Right? You can make a chain where there's no need for gas. It's just like whoever fits this criteria, only they can submit a transaction and that gas is completely free for them.
00:43:06.429 - 00:44:03.345, Speaker B: Gas primarily exists as a concept just to prevent spam. But then if this list is small anyway, like the list of people who can verify that there's some condition, then you don't really need a notion of gas. So that's like something cool you can do where an artist can come and just enable these people to claim some merchandise or drop an exclusive album cover. Let's say things like that. Those are some more things I want to see more of the intersection of web proofs and these different ways to build chains. That's very underexplored. I want to see also some more like applications that don't necessarily need.
00:44:05.325 - 00:44:05.661, Speaker C: Like.
00:44:05.693 - 00:44:10.877, Speaker B: Necessarily need more bridge independent apps. So something.
00:44:11.061 - 00:44:12.105, Speaker A: Does that mean?
00:44:13.495 - 00:45:35.839, Speaker B: What does that mean? It's like where most of the value is like in is on this chain natively. So for example, like the. For example, there is this chain that's building a role called lazy chain, which is like this NFT community on Stargaze right now. So it's like this chain is like just acts as a platform for them to coordinate and do things together. Right now how they would do is they would go on more traditional like web two platforms to coordinate. So this and the whole unstoppable aspect of kind of makes them like once this chain is like there on Celestia, like You can, you cannot really stop it as long as someone's running a full node off the chain. So I want to see more of those things where of like different communities come and use Rolekit to, to more like build a chain to sort of coordinate between themselves and do things together.
00:45:35.839 - 00:46:38.519, Speaker B: So like the artist example is like a way just for top 1% listeners of some artists to come and do things together. Right. So I kind of want to see more of those things. Yeah. And there's like a bunch of things that you would like that it would be interesting to do on chain. Another one that I want to see is like people to bring their high scores for certain games onto on chain using also something like a web proof and then let new games that are popping in or coming up tap into this community of people who are like already like they have proved that they're like top players of some game, some category. And if wants to bootstrap their initial set of users, they can kind of tap into this community.
00:46:38.519 - 00:46:40.675, Speaker B: That's another thing I want to see.
00:46:41.295 - 00:47:02.565, Speaker A: I actually realized. Yeah, no, thank you. You were mentioning earlier, certain holders of an nft, for example, could be the only ones that can use the other chain. Like the roll up. Is that something like you mentioned, lazy chain? Is that something that like a sloth could basically interact on this lazy chain if they had the sloth?
00:47:03.265 - 00:47:10.681, Speaker B: Yeah. So that's something you could do. Like you could. You can make it free for people who are sloth owners.
00:47:10.833 - 00:47:11.377, Speaker A: Yeah.
00:47:11.481 - 00:47:40.361, Speaker B: You know, and the slot ownership can be. Is kind of off chain in from this chain's perspective, it's on another chain. Right. So you can kind of give certain privileges to sloth owners here and you can even order the transactions so that like slot owners get priority. So. Yeah.
00:47:40.513 - 00:48:07.085, Speaker A: Nice. We actually had a question from Ryan in the chat. You already answered it. I wanted to confirm if that was the answer, I guess. Can you name one concrete example of something you'd like to see with zktls and what bringing the web proof into rolekit looks like? I'm curious on the second half of the question. I think you already described the Spotify example.
00:48:07.395 - 00:48:08.203, Speaker B: Yeah.
00:48:08.379 - 00:48:14.491, Speaker A: As like the start. But what does that look like bringing it into WorldKit, bringing into RollKit, you.
00:48:14.523 - 00:49:03.469, Speaker B: Can either let web proofs just be like normal transactions. People just submit that as the content of the transaction and that allows you to do something new on the chain in the state machine. That's one thing you can do. Another thing which is like more underexplored is like what I emphasized initially is instead of the state machine, you can kind of bring it into consensus as well. So only people who can verify a certain web proof, maybe that's like a sybil resistant thing, right? Maybe it's like your only people with a real passport can come in. There's ZK Passport for example. That's like also ZK tls.
00:49:03.469 - 00:50:00.915, Speaker B: That's an example of it. Only people with a real passport can come in and actually build blocks or they can come in and that is like, it's like proof of how there's proof of work, proof of stake, proof of whatever kind of things. This would be like a passport, right? So you would only people who have a passport can come in and do things or you can also do it based on certain privileges. Only people. Let's say your chain is very specific towards a particular country. You're building for a market in Southeast Asia, let's say for devcon. So you can allow only people in Southeast Asia to come in and be a block builder or give them priority in how your like your transactions get ordered.
00:50:00.915 - 00:50:22.805, Speaker B: And only like those set of people can be like you can grant certain privileges to them on how the chain is determined. Basically. Yeah. So yeah, even more data machine. Yeah.
00:50:23.865 - 00:50:45.465, Speaker A: So yeah, thank you for those examples. I guess the last question I have is I noticed that you mentioned the sequencing API for Rolekit. I'm curious if there's anything else that you are working on right now that you can share anything about that's coming in the near future.
00:50:46.125 - 00:51:21.607, Speaker B: Yeah. So the sequencing API is something we kind of have been working with the last couple of months, but we're going to make a new. We're going to make a release with the sequencing API and have an implementation for it which would be the sequencer for now. But we're kind of going to invite. We invite people to contribute other implementations like you could do base mode or you can do more complicated things that I described. That's you could do. Or also the shared sequencers now like ASTRIA is live so they have a repo for that.
00:51:21.607 - 00:52:27.161, Speaker B: So you can describe your rule and other things we're working on right now. The two main focuses we have are something which called the Execution API. So Rolekit historically only worked with this interface called the abci. And the most popular ABCI interface that exists is ABCI State machine that exists is the Cosmos SDK. There's also a Rust state machine by Penumbra called Synodarium, so you could also use that. But right now your state machine needs to follow this interface called abci, so that we felt like that was something that was restricting us. So we wanted to just redefine our own interface which is more generic, that can still be used for the SDK, Cosmic SDK if people want to use that, but also unlock other VMs from the EVM to all other VMs that exist out there.
00:52:27.161 - 00:53:19.917, Speaker B: So EVM SVM movie and whatever. So this unlock role kit to work directly with directly with React, or directly with like a Move execution client or directly with the SVM execution client. So that's kind of what we're. Yeah, so we're working on that right now to unlock that. And then another thing is adding ZK ibc, which is like this IBC client which verifies execution proofs. So ZK proofs, instead of needing a validator, set signatures. So we're working with the Celestia protocol team, the core protocol team, to have a trust minimized bridge from a roll kit chain, which is right now Rollkit plus ret.
00:53:19.917 - 00:53:38.523, Speaker B: So rollkit EVM chain to Celestia. So that's another focus. So you can have a trustworthy bridge for assets. But those two, those two are the main focuses. And then we'll go back to adding maybe more implementations of these. The new design space, can I mention.
00:53:38.699 - 00:54:05.715, Speaker A: Cool. Well, thank you both for your time today and for teaching us about RollKit and about how to build an unstoppable app with RollKit. I want to just leave some space for final comments or like final thoughts from either one of you and then open the floor one last time for questions. But yeah, thank you everyone for coming today and thank you Manav and Yark for teaching us.
00:54:07.695 - 00:54:09.195, Speaker B: Thank you for having us.
00:54:09.495 - 00:54:23.185, Speaker A: Yeah, you're welcome. I don't see any questions. I think we're good to go ahead and close this down. If you do have any questions about Rokit, I think the telegram is the right place to go.
00:54:25.445 - 00:54:39.065, Speaker C: What we would like to see is people saying what we should build next. And I think Mana pretty much covered all the details, so nothing to add from me.
00:54:40.205 - 00:54:44.725, Speaker A: Awesome. Thank you both for your time again and wishing everyone.
