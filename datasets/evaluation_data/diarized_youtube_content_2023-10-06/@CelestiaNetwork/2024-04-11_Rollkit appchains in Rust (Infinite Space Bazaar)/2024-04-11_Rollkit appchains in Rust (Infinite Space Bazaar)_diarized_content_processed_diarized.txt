00:00:02.520 - 00:00:22.234, Speaker A: Welcome, everyone, to another workshop of the Infinite Space Bazaar. My name is Josh. I'll be hosting today, and I'm excited to invite Connor, aka Cnode, to talk about Rolekit app chains in rust today. Connor, you want to give us an intro?
00:00:25.174 - 00:01:12.634, Speaker B: Yeah, sure. My name is Connor. I'm a solutions engineer at Celestia, and today's talk is about how to make app chains using rust. You might be familiar with the Cosmos SDK Plus Rolekit stack, and the purpose of this talk is to go over how you can use things besides Cosmos SDK with Rolekit. If that's your cup of tea, maybe you like rust more than go. Maybe you are ambitious and you want to get your hands dirtier and do some cool infrastructure stuff. This talk will help, hopefully help you get started with doing things like that.
00:01:13.774 - 00:01:19.634, Speaker A: Nice. I'm going to go ahead and put your slides up. What's the difference in an app chain and a roll up?
00:01:20.704 - 00:02:04.484, Speaker B: Oh, well, I'm sort of using the term interchangeably here. Generally, people use the term app chain to refer to a blockchain that serves a application specific purpose, and a roll up is a blockchain that's hosted on another chain. Basically. For example, to make a freestanding app chain, you might use tendermint, which is a proof of stake consensus software code base. And if you want your app chain to run as a roll up instead, for all the various reasons that Manav already explained in his talk earlier today, you would simply replace tendermint with Rolekit, which was built to be a drop in replacement for the former.
00:02:05.064 - 00:02:05.844, Speaker C: Cool.
00:02:06.184 - 00:02:09.004, Speaker A: And with that, I'll let you get started.
00:02:10.384 - 00:03:15.384, Speaker B: Sure. So I won't bore you all too much with the slides. This stream is mostly just going to be live coding. But like I said before, you have this lower thing right here, which is tendermint, which is a modular consensus engine, and it talks to arbitrary application logic, which might be built with Cosmos SDK. And it uses a really generic interface called ABCI to go between the consensus engine and the application state machine. And once you finish building your state machine using Cosmos SDK or rust or whatever, if you want to turn your chain into a roll up, or maybe you're just building a roll up, you can replace tendermint with rollkit and put Celestia underneath for all the many benefits for scaling and decentralization and security and ease of launch that my colleague mentioned in his talk earlier. And anyway, let's get into it.
00:03:15.384 - 00:04:05.482, Speaker B: This talk is about not using Cosmos SDK and instead going over the various options that you have if you want to write your app using rust. So there's a few nice code bases that exist. The first one that I'll talk about is Tower ABCI, which was built by the Penumbra team. And Tower ABCI just gives you a really thin wrapper around ABCI that lets you just basically write your blockchain using rust. It gives you access to the ABCI methods. Then there's a slightly higher level framework, also made by Penumbra called senatorium. I just ran out about this recently, but it is a little bit more batteries included than just using Tower ABCI.
00:04:05.482 - 00:04:57.354, Speaker B: It gives you a Merkle tree and a data store, and Astria is using this for their blockchain. So I put a link to the code where Astra uses snidarium. And then the third thing that I'm going to mention is one of my random side projects called Minnow, which is just my attempt to create an ABCI friendly state machine that's prover friendly using tower ABCi. And it's written in rust as well. I created this before I knew what Sndarium was. So it's a little bit, maybe reinvents the wheel too much. But anyway, I decided that probably the most interesting thing I could do for the rest of this talk is to just live code minnow.
00:04:57.354 - 00:05:17.434, Speaker B: Because like I said, I don't know enough about Snowdarium to actually teach anyone watching this how to make an app, how to use it to make app chain. So if everybody's cool with this, I think I'll just load up versus code, and I'll just start working on minnow, and I'll explain what I'm doing as I work on it.
00:05:17.934 - 00:05:34.054, Speaker A: Sounds good to me. And if you are curious about anything during the workshop here, please drop it in the chat and we'll get to it.
00:05:35.074 - 00:06:25.854, Speaker B: Yep, this is. This is interactive where please ask questions. I'm going to be live coding some esoteric, obscure code. So first, let me just get a fresh clone of it. I'll share my screen. So, I haven't worked on this in a while, but we will blow the dust off of it together. Okay, we cloned.
00:06:25.854 - 00:06:52.998, Speaker B: Now we shall open it. How does it look? Is it readable? Looks like it is, yeah.
00:06:53.046 - 00:06:59.594, Speaker A: I think maybe a little bit, like, zoom in on the whole. Yeah, maybe even one more.
00:07:02.354 - 00:08:11.824, Speaker B: Okay, so, Minnow is this ABci state machine that I started working on, if you're familiar with rust. One thing I like to do whenever I open up a rust code base is I just go straight to the cargo toml file, and I go under dependencies to see what is this thing importing. So, so far I've implement, I've imported a signature library tower and a merkle tree, mono tree, which is a sparse merkle tree. I've also imported the celestia types because this, this specific project is celestia specific. Minnow in its current form is seeking to implement. Well, I mean, it seeks to be a fraud provable state machine. And one of the ways that it tries to be fraud provable is it uses its own serialization scheme that I came up with, rather than doing protobufs or borscht or something like that.
00:08:11.824 - 00:09:16.766, Speaker B: Because the way that Celestia works is it breaks blobs up into shares, and then it has the blob commitment. And in the header to your block of your roll up blockchain, you want to have the commitment to the blob for the block body, and then fraud proofs. You want your fraud proofs to be in the form of like, share inclusion proofs. So you want to prove a Merkle path to some share that has fraud in it. And so Minnow includes share aware serialization, which I just kind of rolled it from the ground up to be this very, this very like simple serialization scheme, which I will show you right now. So, in the transaction file, the transaction file defines a very simple transaction struct, which has the 32 byte sender pub key, the 32 byte recipient pub key, and then an amount, which is like an amount of coins. I don't have fees in minnow right now.
00:09:16.766 - 00:10:13.754, Speaker B: So at the moment, Minnow does not have any way of collecting fees from users. And then there's the signed transaction struct, which has a signature, and then a serialized transaction. So if we go to how the serialization works for a transaction, you'll see that it literally just creates a 72 byte buffer, and then it just copies the 32 bytes from the sender pub key into the buffer, and then it copies the recipient pub key, and then it copies the amount. So this is just the most minimal serialization scheme you could possibly think of. And we're rolling our own shareaware serialization. A share is 512 bytes. So this is just 72 bytes for one transaction.
00:10:13.754 - 00:10:21.654, Speaker B: So we know that at least, like, several of these could fit in. Could it fit into one share?
00:10:23.754 - 00:10:25.494, Speaker A: What does share aware mean?
00:10:25.994 - 00:11:21.182, Speaker B: Oh, so basically we just have to think about all the data structures, because we want this to be fraud provable. We want like one share. We don't ever want, like a transaction to span across multiple shares of the blob because we want like a single share proof to be usable as a fraud proof. So we don't want to use Protobuf because Protobuf is not shareaware. Protobuf is this general purpose thing. Yeah, so I have tests somewhere. Yeah.
00:11:21.182 - 00:12:15.956, Speaker B: So anyway, that's transaction, the sign transaction, like you can call the sign method on a TX to sign it. It also just serializes it for you. In the block abstraction, we have incoming blocks, and then we have the notion of transaction ISR pairs, because this is fraud provable. It gives you the state route after the results of executing each transaction. There is code for ABCI somewhere. I guess I can. Oh yeah.
00:12:15.956 - 00:13:15.904, Speaker B: So here's the ABCI stuff. We import the tendermint crate, and the tendermint crate has the ABCI module. And you can think of your app chain state machine as like a server that takes ABCI requests and it returns ABCI responses. So we have the init chain requests, the prepare proposal, process proposal, and finalize block. So rolekit gives us a request to initialize a new chain. For each block it requests, like transactions to go into the block. And for process proposal, it validates a block that it received and then finalized block is where it actually executes the block and rights to the state machines, state store.
00:13:15.904 - 00:14:05.314, Speaker B: So we have, in the state, we have these account balance pairs where it just maps a pub key to the pub keys balance. Yep, yep. We have serialization code for these. The state of the, of the minnow state machine. It keeps track of, you know, the chain id. It has the merkle tree, the state root, which is just a hash, the current block height. And this is the stuff that I haven't worked on in a while, and I need to blow the dust off of it.
00:14:05.314 - 00:15:16.154, Speaker B: It keeps track of state diffs, it keeps track of the non committed state route, and like the current pending block. All right, so then there's this call function, state call. And here is where we have all the different ABCI methods. And then like, when it receives and ABCI request from rolekit, it will call some function in minnow. So, like, here's what we can go look at with the init chain so we can look at this type. I think that might be good to look out. Oh, no definition found.
00:15:16.154 - 00:16:03.274, Speaker B: Rust analyzer. Oh, maybe because my tree is not, does not exist. My tree does exist, but that path is probably wrong. Oh, maybe my poseidon hash does not exist.
00:16:09.294 - 00:16:12.754, Speaker A: What's the TLdr on the Poseidon hash?
00:16:13.364 - 00:16:37.784, Speaker B: Oh, yeah, this code base is a little bit of a mess because at one point, I thought I was going to pivot it into being a Zk roll up, and so I made the merkle tree use poseidon hash. Got it. I could probably just switch it to the upstream. The upstream version of the tree.
00:16:38.864 - 00:16:39.604, Speaker C: It.
00:17:05.004 - 00:17:41.004, Speaker B: Okay, let's do that. So you don't do this one. We will do this. Just because rust analyzer, for all its faults, we do love it. And also, for a demo, we really want to be able to look up definitions. All right, so let's see if I can go to this now, maybe. No, not quite.
00:17:41.004 - 00:18:44.004, Speaker B: Yeah, it looks like I got to these three abci methods. Init chain, prepare proposal, process proposal. She's done. Requesting a chain, maybe not. My laptop sounds like a jet engine right now. So, in a niche chain, we. We look at the request chain id, and we first, we check the.
00:18:44.004 - 00:18:56.464, Speaker B: That the chain id matches the chain id of the one we're looking at, and we throw an error if it doesn't. And we also force the initial height to be equal to one.
00:19:15.784 - 00:19:17.284, Speaker A: Why is it equal to one?
00:19:18.424 - 00:20:08.924, Speaker B: Because this is the first. The first block height should be one. Got it. I don't remember why I forged tendermint. Why did I. For tendermints? Well, I can just add it to my workspace. Where's tenderprint? Here is.
00:20:11.864 - 00:20:15.724, Speaker A: Eric was wondering what the link to the repo is.
00:20:17.984 - 00:20:19.564, Speaker B: What link to what? Repo.
00:20:21.304 - 00:20:22.644, Speaker A: I guess, to minnow.
00:20:23.744 - 00:20:26.804, Speaker B: Oh, sure. I can share that.
00:20:30.844 - 00:20:31.584, Speaker C: Thanks.
00:20:32.044 - 00:20:34.064, Speaker A: Drop it in chat. Cool.
00:20:42.204 - 00:21:06.284, Speaker B: So, tendermint Rs has the AbCI module, and then. But maybe it's not in there. It might be in a weirder, a stranger place. Yeah, it's in like this. So there's the tendermint Rs.
00:21:11.344 - 00:21:14.684, Speaker A: Is that just implementation of tendermint?
00:21:15.384 - 00:21:25.360, Speaker B: Yeah, I don't know if it's an implementation because I don't know if it actually can, like, be a validator, but it has all the types. If you want to work with tendermint types in rust.
00:21:25.552 - 00:21:26.444, Speaker A: Got it.
00:21:27.904 - 00:22:01.910, Speaker B: So it has the enum for the requests, and there's, like, you know, init chain, begin block, deliver TX. End block, prepare proposal, process proposal, begin block and end block and deliver TX. I think they're all gone. These are, like, obsolete with ABCI. ABCI Plus. Plus is the newer version of Abci, which. Oh, it has, like, better abstractions, but then you should be able to go look at what it is.
00:22:01.910 - 00:22:29.938, Speaker B: Okay, finally, here it is. The request init chain is the one that I was currently looking at. So, like initiative, Rolekit sends this to minnow or to Cosmos SDK. But today we're looking at minnow, and it says, like the Genesis time, the chain id. And then there's this thing called the app state bytes. And this is where it gets fun. That's kind of like the Genesis state.
00:22:29.938 - 00:23:50.950, Speaker B: So that's like everybody who gets the token when the chain launches. So let's look at how I validate the initial state. So what it does is it reads. Reads the app state bytes, 40 bytes at a time. And then for each, for each 40 byte chunk, it deserializes it into an account balance pair, and then it writes the first 24 bytes into a 32 byte buffer, and then it inserts into the merkle tree the key value pair. Oh, yeah, right. This buffer thing is very ugly.
00:23:50.950 - 00:24:46.664, Speaker B: It's because the merkle tree requires the key value pairs to be 32 bytes. And so even though it's only a, like a U 64, we have to write it into this, like 32, this like 256 bit buffer. Oh, and then it sets the root. One thing I did not do is I did not write an actual store. So this, kid, is why you should not use minnow, you should just use synodarium.
00:24:49.884 - 00:25:03.674, Speaker A: But this is, I guess this is how you would use rolekit and ABCI outside of the context of, like, cosmos. Other examples, same deal.
00:25:04.494 - 00:26:34.584, Speaker B: But this is a, I'm showing you all a very crude, very crude piece of software, which is missing a lot of the important things that you want in a state machine, which is like a store, database, telemetry, stuff like that. And then once it computes the state root and it loads all those user balances into the tree, we return a response, an init chain response, and we can look at that. The init chain response is here in the tendermint crate. So it gives you the initial app hash for the chain after it executes the genesis block, as well as these consensus params and validator list. And depending on, like, how your rollup is sequenced, you may or may not do anything for that. In my example here, I just leave it completely empty, but I do return the app hash. So then we can look at prepare proposal.
00:26:34.584 - 00:27:43.158, Speaker B: So let's quickly go remind ourselves what the prepare proposal request looks like. So the request prepare proposal, it gives you this max tx bytes, this, which is the juicy part, the txt transactions, which is a vector of bytes, a vector of byte arrays. And this is totally arbitrary. This can be like, you can structure this however you want. So in mine, what I did is I interpreted each transaction in that vector as a 136 byte buffer. And we start by just, oh yeah. And then we cast the whole thing into incoming block, which is a minnow type.
00:27:43.158 - 00:28:02.604, Speaker B: So incoming block is just a vector of 136 byte values. Do I have any code for if it receives, if one of them isn't 136 bytes? I'm not sure, but there should be.
00:28:10.584 - 00:28:11.524, Speaker A: Not yet.
00:28:12.744 - 00:28:52.196, Speaker B: Not yet. I'll make it to do. So. Then we call. We want to get an outgoing block. And to get an outgoing block from an incoming block, we call process. And process takes a mutable reference to the state.
00:28:52.196 - 00:30:06.614, Speaker B: And remember, the state is this type that contains the merkle tree. So process does a lot of stuff. First, it creates the outgoing block with the current stateroot as the header, and then it initializes this pairs vector. And then for each of the signed transactions in the incoming block, it deserializes it into a signed transaction, and then it calls verify and run transaction. And oh yeah, what it does is if any of them are invalid, it just ignores them. And, but if they are valid, it creates a signed transaction ISR pair. So that's just a, it's an ordered pair.
00:30:06.614 - 00:30:11.994, Speaker B: On the left is your serialized signed transaction. On the right is your estate route after executing it.
00:30:14.234 - 00:30:15.534, Speaker A: What's ISR?
00:30:16.434 - 00:31:18.774, Speaker B: ISR is an intermediate state route. So after you execute a transaction and you have the state root obtained from the result of executing it, you include it. And this is how a fraud proof works. You show that the intermediate state route was computed incorrectly, and minnow seeks to make that very feasible by using shareaware serialization. So if one of these pairs is part of the blob and it's not valid, you can just show the share that contains the invalid one, and then that would work as a frapp group. So process returns the outgoing block. And remember, that is just the header and the VEC of these signed transaction ISR pairs.
00:31:18.774 - 00:32:21.764, Speaker B: And the response to prepare proposal. Yeah, the prepare proposal response is very simple. All it is, is a list of transactions which go into the block. So request prepare proposal has raw, unprocessed transactions, and then the response is only, is a list of the ones that are just the valid ones. So it basically filters out all the ones that are invalid. But also, like the hacky thing that minnow does, is even though this is supposed to be transactions, we return pairs. So ABCI expects you to use it in one way, but we do it slightly different because it was not meant for fraud proofs.
00:32:21.764 - 00:33:28.924, Speaker B: All right, so that is how Minnow does prepare proposal for process proposal. We, of course, we take the request process proposal, and this is like a completed block. So rolekit or tendermint sees the completed block and we call that the proposal. The block is the proposal. And this gives you a bunch of stuff. So like, one of them is the transactions, one of them is the proposer address. There is a hash, a height and misbehavior, which maybe we could repurpose that into fraud proofs, but I'm not totally sure.
00:33:28.924 - 00:34:16.864, Speaker B: So let's take a look at the minnow one. All it does is it only looks at the transactions field. And again, we interpret these transactions as pairs. So all it does is it tries to deserialize it into a pair and it succeeds. Unless there's a serialization issue, Minnow's process proposal doesn't actually validate them. Although maybe this is where we would put that code.
00:34:39.504 - 00:34:45.884, Speaker A: Can you briefly cover what prepare proposal and what process proposal are?
00:34:46.544 - 00:35:34.644, Speaker B: Yeah, so prepare proposal is when you're, when Rolekit gives you a list of transactions from users, when it gives your app chain a bunch of raw transactions from users to execute and create to put into a block. And process proposal is when Rolekit has a valid block and it wants your app to validate it, execute the other one that there's also finalized block. And then finalized block is after process proposal. So, like, process proposal is you execute and verify the block. Finalize is you actually save the block to your database.
00:35:34.944 - 00:35:35.872, Speaker C: Got it.
00:35:36.048 - 00:35:36.964, Speaker A: Thank you.
00:35:39.584 - 00:36:06.830, Speaker B: Yeah, you can kind of think of your, one way to think about AbCI is rolekit is a remote and your app is a VCR. So like, your, like, rolekit controls the app with buttons on the VCR, and it's like prepare proposal is the fast forward button, etcetera. Maybe that makes no sense.
00:36:07.022 - 00:36:12.314, Speaker A: No, that's a good analogy, I guess, if you know what a VCR is.
00:36:13.174 - 00:36:36.494, Speaker B: Oh, true. I was going to say DVD player, but I guess kids don't know what that is either. I don't know. It's like a Xbox. The consensus engine is the player and the state machine is the console. What is that?
00:36:39.634 - 00:36:44.494, Speaker A: I was going to ask about the transaction flow, but I want to let you continue on the state.
00:36:45.434 - 00:37:21.674, Speaker B: Sure. Well, I mean, I was just going to like, try to figure out what tests I already had written and see if they're good. Where did I put my tests? Maybe here. Okay, so in versus code, if you write a rust test and you put this test above it, it lets you have a button to just run it.
00:37:22.334 - 00:37:23.074, Speaker A: Nice.
00:37:24.854 - 00:38:06.364, Speaker B: So here is the test, serialized transaction test, where we create a transaction where the sender pub key is eleven one one, and the recipient pub key is two two two. And he's sending 3000 tokens. Oh no, tendermint didn't build. Well, that's super. Not my fault, but I don't know why it's happening. It used to work.
00:38:13.464 - 00:38:15.324, Speaker A: Just built with an older version.
00:38:15.824 - 00:38:55.944, Speaker B: Probably something. Definitely something like that. Okay, well, let's fix rust. Can you see my terminal?
00:38:56.264 - 00:38:58.564, Speaker A: Yep, we got your whole screen.
00:39:07.784 - 00:39:12.164, Speaker B: This is real, real world knowledge that we're demonstrating right here.
00:39:12.824 - 00:39:14.604, Speaker A: This true life coding.
00:39:15.104 - 00:40:44.574, Speaker B: Yep, true life coding. So the time crate is throwing and yeah, it's just the time crate, which is throwing. So first thing I want to try when you get that is figure out what's going on with the versions of things. This is definitely not the newest Lumina. So what if I just upgrade lumina it? Everything else looks like it's pretty much the right. Maybe tenderprint is wrong. Okay, well, we can go and figure out, because Lumina probably uses tendermint, so we can just use whatever version they use.
00:40:44.574 - 00:42:18.994, Speaker B: Oh, they use this one, the celestia tendermint. So I'm just going to go ahead and this is going to break some stuff, accelerate even more problems. Oh, I think I forked tendermint and I added a bunch of like, default traits.
00:42:25.194 - 00:42:28.854, Speaker A: Oh, so that's why normal tendermint wasn't working. Or the types at least.
00:42:30.914 - 00:42:59.424, Speaker B: Very likely. Yes, I think I had to. I should have upstreamed those changes, but I guess I could do that on this stream. Why not? Is anything else weird in here? This tower is locked on a specific version, but that seems fine. This is fine. This is fun. I think it's just the tendermint.
00:42:59.424 - 00:44:30.254, Speaker B: I think I had some stuff in here for the celestia blob commitment in the header. Maybe, or maybe not. I kind of want to rewrite this whole thing, but not today. So we have one issue with the time crate where they're trying to call derived defaults on a type. We have unstable issue with this. We also have unstable, unstable, unstable on unknown feature. Oh, and this is from the curve Dalek four 1.1.
00:44:30.254 - 00:47:02.920, Speaker B: Oh, but I was using version two, 1.0. So let's upgrade that, see if that solves anything. Oh wait, 2.1.1. Okay, hold on. All right, most of the errors are still there, but did that one get fixed? Maybe we can add this create attribute to enable the feature, but I don't know what is what is even because I don't import curved dialoc. I import ed 25519 Dalek. There is some way you can look at dependencies I don't see.
00:47:02.920 - 00:47:32.664, Speaker B: Okay, maybe. Hold on, we'll grep for it. But that doesn't show me what crate imports it. Okay, never mind. Back to the drawing board.
00:47:36.144 - 00:47:36.884, Speaker C: It.
00:48:13.924 - 00:48:22.464, Speaker B: Let's try adding this line to the root, the crate root. Maybe that'll fix some errors.
00:48:23.124 - 00:48:25.024, Speaker A: Looks like it's appearing in a few.
00:48:27.384 - 00:48:28.124, Speaker C: It.
00:48:38.904 - 00:48:39.964, Speaker B: Didn'T do it.
00:48:53.004 - 00:48:53.744, Speaker C: It.
00:50:03.564 - 00:50:05.264, Speaker B: Try updating rust. I guess.
00:50:09.864 - 00:50:35.716, Speaker C: It'S.
00:50:35.800 - 00:50:37.504, Speaker B: Does that do anything? Maybe.
00:51:01.544 - 00:51:11.604, Speaker A: I guess. In the meantime, if anyone is curious about where they should go for this, I think the GitHub repo is the best place. Right.
00:51:13.984 - 00:51:14.884, Speaker B: For what?
00:51:15.504 - 00:51:19.444, Speaker A: For checking out minnow and learning more about minnow.
00:51:19.944 - 00:51:39.384, Speaker B: Sure. Yeah. I would say if you're curious about this weird code base I made, then, yeah, check out. Check out minnow on GitHub. The link is in the stream, but if you want something that's more, more batteries included, you should check out sndarium.
00:51:42.244 - 00:51:43.892, Speaker A: You mind dropping a link to that?
00:51:43.988 - 00:51:45.104, Speaker B: Yeah. Yes.
00:51:46.164 - 00:51:46.944, Speaker C: Nice.
00:52:04.104 - 00:52:20.144, Speaker B: Here's the link to the upstream code, and then I'll put the link to the usage in Astria as well. Okay. I think this actually might be kind of working. Oh, no. Okay, less errors now.
00:52:20.764 - 00:52:48.204, Speaker A: Nice. We did lose your screen share, though.
00:52:49.184 - 00:53:35.126, Speaker B: Yeah, I'll put it back in a sec. Here's the astro code that uses snowdriam. All right, back to doing this. Okay, so now the errors are actually from my code, which is great. So need to fix the import of tendermint.
00:53:35.220 - 00:53:35.854, Speaker C: It.
00:54:19.894 - 00:54:55.084, Speaker B: Looks like it's pretty much the same structure. So I can just go replace tendermint with celestia tendermint. Okay. Five errors. Now we're down to three. There is no, .0.38 which is weird.
00:54:55.084 - 00:55:16.704, Speaker B: I guess we have to do 37. Okay, now we're back up to six errors. That's fine. You know how it is with rust. Oh, shit. What happened to 38? Okay. It actually is missing the finalized block types.
00:55:16.704 - 00:56:52.494, Speaker B: One cool thing we could do is just remove it. Haven't got to that part of implementing Abci anyway, but let's see if it exists. GitHub Iger, where on earth is Celestia tendermint Rs? Yep, Iger owns it. There's the, there's the tendermint folder, and there's three, four, and 3.7. Let's see if there is 38 on the informal systems branch. Yes. Okay, so informal has three, eight.
00:56:52.494 - 00:57:46.384, Speaker B: Iger does not. So that means we need to somehow we need to update it if we care about finalized block, which maybe we don't, because maybe Celestia doesn't have finalized block, but regardless. Also maybe roll kit doesn't want celestia tendermint. Hmm. Oh, we have another minute, so maybe. So it's possible that rolekit communicates over a different a newer version of AbCI than celestia supports.
00:57:47.964 - 00:57:49.824, Speaker A: Sounds like it can make sense.
00:57:53.004 - 00:58:06.524, Speaker B: Because Rokit is not quite the same thing as Celestia. So let's use a layer one blockchain for data availability. Rolekit is a framework for building chains on top of da layers.
00:58:17.544 - 00:58:35.664, Speaker A: So keeping the kind of people, I guess, hacking in mind. Uh, are there any things that you'd like to see built during the hackathon, or any ideas you have for people who are curious about using rust? Uh, and roll kit?
00:58:37.804 - 00:59:35.924, Speaker B: Um, yeah, I mean, this is, this whole area is certainly for builders who want to get their hands dirty, who are like most interested in doing some doing some trailblazing on the frontier. Because, you know, snowdarium tower, ABci and Minnow are not as beginner friendly as Cosmos SDK. So if you are interested to use rolekit app chains with rust, you're going to need to do a bit of trailblazing. But they're starting to be a big community around it, so you'll certainly be able to get people to reply to you on Telegram if you decide to go down this trail. Otherwise, if you want something that has lots of tutorials and way more examples and you don't mind writing, go. Cosmos SDK is great.
00:59:40.024 - 00:59:49.828, Speaker A: And do you have any last things to share for people? Maybe they have places to contact you or last sure.
00:59:49.876 - 01:00:03.904, Speaker B: Yeah. I respond to all DM's on Twitter and I respond to telegram as well. Twitter is colluding node. Telegram is my name.
01:00:10.024 - 01:00:10.844, Speaker C: Cool.
01:00:12.304 - 01:00:50.404, Speaker A: Awesome. There aren't any questions in the chat. I've exhausted my list, but I had a great time learning and want to thank you again for joining to teach us. Thanks for watching app chains and rust. I'm sure all the rust heads will like it. So yeah, if you're watching the stream after the fact, I would say that discord is also a good place to chat about this, whether no matter what team you're on in ISP. But yeah, thank you again and thank you everyone for joining and wishing everyone a good rest of your day.
