00:00:01.800 - 00:00:13.686, Speaker A: All right, thank you, everyone, for staying here. 04:00 p.m. on a Saturday. And thanks for the celestial, you guys, for organizing. All right, I'm Terry. I work at Eclipse, head of strategy talk. Title is called you only need run roll up.
00:00:13.686 - 00:01:12.246, Speaker A: But I'll be talking more about why infra take rate is actually going to zero over time. The trend in the past three days at Moderator summit, and I think infrastructure in general has been that apps want to own the value that they created. Imagine the scenario where pump fund could own all the MEV and execution fees that they generated, right? They made 59 million over the past couple of months, but presumably 1 million a day in judo bundle tips would have resulted in hundreds of millions of excess revenue. So from a perspective of an application that wants to internalize the MEV and the execution fees that I generate, I have a couple options that are available to me today. I can become a cosmos app chain and integrate skills, which allows me to internalize the fees as an application, plus execution fees, plus mev times, say the foundation stake divided by total stake minus some validator epsilon. In exchange, I give up synchronous composability. I have all these third party infrastructure costs.
00:01:12.246 - 00:01:37.688, Speaker A: These are things like rpcs, indexers, liquidity, third party bridges. And these are not negligible costs. If any of you guys have built an l two or an l one, quite significant. Plus some validator setup costs. You know, if you're using replicated security, never mind. You can become an ad specific roll up through something like a RaS project, conduit caldera, in which case you get the fees as an application. Now, I won't stop talking about that, because that's kind of generalized across all these options.
00:01:37.688 - 00:02:10.716, Speaker A: You get mev, you get fees, but you have to pay taxes to your DA and settlement layer, you lose synchronous composability. You also have to pay third party infrastructure costs. Now, there's these new kind of applications, I think Sorella, vertex, cowswap. They're kind of titular here, that are self sequenced apps, right? They have sovereign sequencing, and in the process they take an internalized MEV, then they redistribute this in a way that is favorable to their users. So in the case of Sorella, they distribute it to passive LP's. And here you get fees. You don't necessarily get execution fees.
00:02:10.716 - 00:02:46.768, Speaker A: TBD, you get Mev internalized, but you also have to pay settlement execution. So, for example, in the example in cowswap, when you settle the batch auction, make sure that the batch auction is optimal on chain plus pay for execution. In the l one, you also lose synchronous composability. There are no third party infrastructure costs. So take that out. Now, the final option that's quite recent is you can have an app chain and you can opt into a shared sequencer here. Everything you get as an app specific roll up, plus you pay a shared sequencer fee.
00:02:46.768 - 00:03:21.206, Speaker A: You always have to pay a shared sequencer fee because they also maintain their own infrastructure. They also maintain their own consensus set and some type of shared sequence or surplus question mark. We kind of don't know what that looks like yet. In designs that might be a pro rata distribution of cross domain mvv surplus, but we don't know that yet. In exchange, you pay for uncertainty in devex, third party infrastructure costs, and generally design uncertainty and uncertainty as to when these will ship. But you'll realize that all four of these options compare that to what you get as an app on a general purpose execution environment. You get basically nothing.
00:03:21.206 - 00:04:07.070, Speaker A: So why would people move towards app change? This is the reason why. But the problem with a lot of infrastructure today has been that people have taken this chart as a given. They're like, okay, everyone will move to an app chain because this is the profit structure of applications today. But we want to ask, what if there's a way that we can kind of build for this part and change this equation instead of taking this as a given and making sure we build a strong shared sequencer? So let's further examine the shared sequencer and the profit kind of motivation behind building one. Say I'm an application, so I'm an application, and I'm thinking about, do I want to go towards an app chain that's standalone, or do I want to go towards an app chain that operates into a shared sequencer? Right. Go towards just an app chain. Then I internalize all these fees right here.
00:04:07.070 - 00:04:53.938, Speaker A: But if I go into an app chain with a shared sequencer, then I get these benefits at this cost. So what is the cost of synchronous composability while opting into a shared sequencer? Well, we have devx uncertainty. We have uncertainty in terms of revenue share design, and we have third party integration costs, which are also present if you're a normal app chain. So ultimately, the equation that boils down to is the shared sequencer surplus question mark larger than the shared sequencer fee plus devex degradation. And to this day, we don't quite yet know. But, okay, now, from the perspective of an app chain or a general purpose l two. Let's examine the matrix of do I opt into someone else's shared sequencer, or do I launch my own shared sequencer? Right? So if I opt into someone else's shared sequencer, I have to pair the shared sequencer fee.
00:04:53.938 - 00:05:42.920, Speaker A: But TBD, I might get some pro rata portion of the cross domain surplus times rollup divided by n minus the shared sequence of feet. Now that might be positive, that might be negative, that might be zero. We don't know just yet. Now, if I launch my own shared sequence of network, say I'm arbitrum or optimism orbit, and I have an established ecosystem, I have a lot of users, I have a lot of liquidity, a lot of dapps, then I can charge the margin on the cross domain surplus, which TBD exists or not, which is always strictly greater than what I get if I opt into someone else's shared sequencer, which means between domains that we want to interoperate on. I won't use arbitrum, I use optimism. So I want to interoperate between optimism and arbitrum. But they will never have the incentive or the coordination to be able to interoperate with each other by opting into the same share sequencer network.
00:05:42.920 - 00:06:17.730, Speaker A: So interop is a social problem. Like Justin Drake said this on a podcast with Toli, shared sequencing is not a technical issue, it's a social issue. And that is why it's easy. But I want to say that is why it's incredibly difficult. It's a massive coordination game. Before, we had these groups of sovereign domains, and they were not interoperable, and they housed their own applications that were interesting and we loved transacting on them. Now, each of these are going to have their subdomains, which are interoperable with each other, but at the end of the day, they won't be cross interoperable through a shared sequencer mechanism.
00:06:17.730 - 00:07:32.150, Speaker A: And so, yeah, it's a massive coordination problem. But it is important to note that all of these aforementioned options, even though with these coordination games, with these incentive issues, all still significantly better than staying on a general purpose l one and l two. So then how can we justify the existence of any general purpose l one and l two? Why would not every single app move towards sovereign sequencing and app chains then want to interoperate between a shared sequencing layer? Well, how can we change the equation? So how can we make it so that the value of being on a general purpose l two is larger than the value of being on an app chain? For one you come down and you kind of like, list out the profit and the cost of each. You realize, okay, fees on the app are common to both. Let's cancel them out. Then you realize down here that the right side of the equation, which is being on an app chain, you always get to internalize your own mev plus execution fees. And because those are positive, and the other side, the left side, only has a negative, which is congestion, you need to, by definition, in order to change the equation, move that also to the left side of the equation, which means as an l two or general purpose l one, you need to redistribute your execution fees and your mev to the Dapps so they have a reason to stay on your chain.
00:07:32.150 - 00:08:28.572, Speaker A: Now, I put Epsilon over there because there will always be some sort of value loss because of composability in a general purpose environment. Then on top of that, you now cancel out mev and fees. You have congestion minus epsilon, negative congestion minus epsilon on one side. And on the other side, you know, this is kind of the value you get from being in a shared sequencer network. You have to solve congestion, and then finally you can make this significantly positive if you can actually help Dapps make more money. So, yeah, I call this doing the easy thing hard, because we can take it as a given that the profit matrix on the fourth slide is correct and build towards synchronous composability through shared sequencer networks and significantly complicated additional tech. Or we can change the equation and say, why don't we change the equation on a general purpose l two, and change it so that applications want to stay on my general purpose layer, and it is incentive compatible and actually profit maximizing to do so.
00:08:28.572 - 00:09:00.660, Speaker A: So how do we get there? Number one, as we went through the equation, solve for congestion. So Dapps never lose revenue from fee spikes, never lose users to noisy neighbors. That's number one. Number two is decrease the customer acquisition cost for Dapps and help them increase their revenue. So that looks like increasing attention in distribution funnels. A lot of people have talked about these, having a community, et cetera. Number three, help them tap into existing infrastructure, liquidity providers, etcetera, and finally, redistribute your profits back to Dapps that originated it.
00:09:00.660 - 00:09:34.314, Speaker A: They are first party citizens on your chain, on your execution layer. They deserve the value that they create. Give it all back. The question is, can we get a synchronous execution layer that retains the dapp that build on it? So what's the end game? What does this result in today? The protocol layer is capturing most of the value. PBS means that execution proposers, specifically validators, are capturing a lot of the value created by the DApps that live on execution layers. And this is why people have been talking about the fat protocol thesis. People have predominantly invested in tokens of l one l two tokens.
00:09:34.314 - 00:11:04.610, Speaker A: We think competition in the infrastructure space has become so intense, app chains have accelerated this demand that in the future, general purpose execution environments will have to compete on giving back all the value they create to applications, and they will compete on becoming a thick protocol layer that actually has value of being synchronously composable and large. So what can blockchains do today? They have to compete on scale, get fast, fast, give back as much value to DApps as possible and focus explicitly on how you lower customer acquisition value for Dapps. And so this is kind of like a allusion to Evan's talk which said, your margin is my opportunity. So what is the infrastructure end state take rate? It's such that the portion of the margin that you charge on MeV plus execution fees plus some abstract value assignment to universal synchronous composability plus liquidity, plus users minus congestion, which should ideally be zero, is larger or equal to than what you get out of being a sovereign app change. So mev plus fees minus da minus settlement, plus some abstract value of sovereignty. So the more value you can raise here, as you mentioned, as you can see, the more value you can get out of universal synchronous composability, the more you can lower customer acquisition cost for dapps, the more you can actually capture value as a base layer. So there are two directions that I think a lot of execution environments, general purpose execution environments can go today.
00:11:04.610 - 00:11:46.050, Speaker A: You can become one big roll up, give back all your MEV to Dapps, which is itself a hard problem. We don't yet know how to do MEV attribution with composability. We don't know how to do it. Yeah, there's like complicated fast bundle auction design, which is very interrelated to MEV attribution and composability. There's fast VSR verifiable sequencing rules, which we don't yet know how to do either, and a 400 millisecond latency, or you can go towards the shared sequencing route, which also we still don't know, I think, how to solve. Exactly either. We have Devx problems, coordination games, as we explained in slide three and four, cross domain surplus, attribution and redistribution, which none of the teams have correctly figured out either.
00:11:46.050 - 00:11:47.910, Speaker A: Thank you.
