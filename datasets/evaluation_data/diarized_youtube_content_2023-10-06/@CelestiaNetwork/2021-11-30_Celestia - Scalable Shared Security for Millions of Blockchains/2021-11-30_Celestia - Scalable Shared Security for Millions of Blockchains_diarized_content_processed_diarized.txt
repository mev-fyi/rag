00:00:05.050 - 00:00:41.078, Speaker A: All right, another round of applause for our Lido finance friends, Vasili and Andre. So I think in January I was like researching crypto and Cosmos, and I would always talk to my girlfriend about it. And then she sat me down one day and she's like, I don't care. You need to find friends to talk to about it. So I made a Twitter account called Coney Daddy and things have gone really, really well. Look at all my new friends I get to talk to. And you guys actually understand it all more so than I do.
00:00:41.078 - 00:00:49.910, Speaker A: Fantastic. Well, a new friend that I made this week, he's the co founder of Celestia Ismail. Coffee.
00:01:04.630 - 00:01:29.690, Speaker B: Hello. First of all, I want to thank the conference organizers again for this awesome event. So nice to meet all of you in person. Again, I'm Ismail. I'm going to talk about Celestia and how it brings scalable shared security to millions, potentially millions of blockchains. First, a few words about me. I'm the CTO and co founder, as Coney Daddy already said.
00:01:29.690 - 00:02:37.230, Speaker B: And I used to be also like a tenement core engineer. Before that I was a research engineer at EPFL, where I think it was like blockchain scaling, privacy enhancing technologies and consensus and all distributed systems. You can find me on GitHub and on Twitter Liamzi, Croitz and Queer. So let's dive in with what is Celestia? It's a modular, scalable security layer, or like a blockchain stack. And why should you care? Because it makes it easier for you to deploy your application specific blockchain. The thing that it removes is the requirement that's currently there that you have to deploy your own consensus network. So if you want to deploy application specific chain currently, you of course have to bootstrap a proof of stake network, right? And we remove this and you can, more frictionless, deploy your own decentralized blockchain.
00:02:37.230 - 00:03:24.766, Speaker B: So let's start with something that most of you probably know, or like many in the audience are familiar with the abstraction layers in tenement. Tenement already does something really nice. It separates consensus from execution. So the execution you could think of like a transaction that modifies account balances. And how this is achieved in tenement is there's a thin layer called AVCi, and the state machine is a separate software layer. It could also run in a separate process, but it's still on the same blockchain. Right.
00:03:24.766 - 00:04:01.720, Speaker B: What we do at Celestia essentially is we take this monolithic blockchain architecture where everything runs on one chain, like consensus. And the execution of the transactions to a more modular stack. So in our case, the base layer, Celestia, just does consensus and provides security. And you can put the data on there. And on top of that, you can plug your application specific chains. Don't have to run your own consensus. You could even have something that runs smart contracts on top of that.
00:04:01.720 - 00:05:18.798, Speaker B: Yeah, in the traditional world, this would be all in one chain, as I said. So this is comparable to, you can draw an analogy to the evolution of the web here, because if you look at the early web, the only way you could deploy your web application or your website was you have to host your own physical server, essentially. And then the next step, the next iteration was basically you have websites that you can deploy using shared hosting providers, but these shared hosting providers would choose the programming languages, you can use the interfaces and everything. So you would be kind of stuck with the choices that the service provider did for you. In the current web, websites run on virtual machines, so you have your complete freedom on how you host your website. And similarly, we believe that the blockchain space will evolve, or already is evolving. Actually, if you look at the first cryptocurrencies, they were one application essentially, and each blockchain, like bitcoin, litecoin, and all of this had their own blockchain and their own consensus.
00:05:18.798 - 00:06:21.170, Speaker B: The next iteration was like Ethereum, where you could deploy your smart contracts on one execution layer, essentially. And we believe the next iteration of that is a modern crypto ecosystem. That's actually to a great extent already a reality, thanks to Cosmos, essentially, where applications run on their own app specific chains. But what's missing is like a shared security layer, and we believe that's the next iteration. So how do blockchains actually work? Current blockchains usually couple consensus with state execution, as I said. So for a full node to validate if a block is valid, what you make sure is a block has consensus, and then you actually also verify each transaction and execute those. So you check if the block has consensus and you check if the transactions are valid.
00:06:21.170 - 00:07:04.770, Speaker B: Right. This is like a bottleneck because every full node has to execute every transaction. Yeah. And Celestia changes this to the design of celestia, basically is the answer to what if you can post arbitrary blobs to the chain and they do not modify the state? So you can even dump invalid transactions onto the chain without having any impact. These would just be ignored. Right. And how does execution work? Nodes and clients can actually download these transactions and execute them locally.
00:07:04.770 - 00:08:06.280, Speaker B: That's the basic idea, right? It's actually an interesting historic fact about this is that in the very early days of Cosmos, Jay and Bucky had a very similar idea which was called supertanker, where you basically would dump the other chains transactions on the hub that had several problems. I'll explain a bit more of this later. So that's what, like because of these problems, the hub is what it is today instead of this. And Celestia has some answers on how to do this properly in a decentralized way. So what Celestia does is also it asks the block does it have consensus? Right, like as before. But instead of checking if the transactions are valid, you just make sure that they are available so that we are published to the network and they are available for full nodes to execute. Yeah, that's basically it.
00:08:06.280 - 00:09:24.990, Speaker B: How do you make sure that a block is available? I mentioned before that if you dump many transactions of your millions of blockchains essentially on the base layer, the block can become potentially very large. And if you think of the bitcoin scaling days, for instance, there was a big debate about small blocks, big blocks, and how big blocks create centralization. And in celestia we fix this. Or like there's a solution to this in celestia, which is called data availability sampling. It's a technique that enables you to make sure that the full block with all the data and all the transactions was actually published to the network without having to download the block. Sure, if you download the block it's easy, it's trivial to make sure it's available because you downloaded it and you can verify the block. But what if you just could download a tiny portion of the block instead and get very high probabilistic guarantees that the full block is available and that's what data availability sampling enables.
00:09:24.990 - 00:10:42.570, Speaker B: How it roughly works, I won't go into details, but how it roughly works is how you lay out the block in shares and then you erasure code these shares. And erasure coding is a very simple technique known since like I think the erasure coding and this block layout essentially enables what I said before, that you can download really just a tiny portion of the block and have almost 100% certainty that the full block is available. Why is this interesting? The cool thing about this is the more nodes you have in a network, the more data you can basically host securely, right? So you get similar scalability guarantees as in Bittorrent. And Bittorrent is like the most scalable decentralized protocol that was deployed so far. So this is very interesting. We trying to bring that scalability of BitTorrent to the blockchain world. Essentially, just to summarize again, the execution model is that applications use Celestia just to store the data.
00:10:42.570 - 00:10:47.782, Speaker B: And the full nodes of celestia, the main chain, do not process these transactions.
00:10:47.846 - 00:10:48.554, Speaker A: Right.
00:10:48.752 - 00:11:25.320, Speaker B: The data is then processed locally, as I said. Well, that could raise the question, what if you have like light clients, for instance, or like nodes that cannot process all these transactions, right. Like if you have a light client, you don't want to download even your application specific transactions. And the answer to this is you can solve this with light clients and a roll up. What is a roll up? A roll up. They're quite hyped in the ethereum ecosystem and they're not very much made it into the cosmos ecosystem. And we will change this.
00:11:25.320 - 00:11:31.890, Speaker B: So a roll up is essentially a blockchain that posts its blocks onto another blockchain.
00:11:31.970 - 00:11:32.358, Speaker A: Right.
00:11:32.444 - 00:12:11.954, Speaker B: It's basically what I said before. Instead of the transactions now, you post the block including a state route, and that makes your application specific chain a roll up. Essentially there's two kinds of rollups. There's ZK rollups and optimistic rollups. We're currently focusing on the optimistic case, but something like Celestia is necessary in both scenarios. Essentially, yeah. In optimistic rollups you need something for light clients to make sure that the block is actually valid, because you only receive a header.
00:12:11.954 - 00:12:44.190, Speaker B: And the block proposal, the block producer could essentially also be just a centralized sequencer, which is currently in all Ethereum roll ups is mostly the case that there's just centralized sequences. How do you make sure that they do not just post invalid blocks? How do you ensure that? By state fraud proofs, essentially, like in ZK rollups, it's not necessary because in ZK roll ups you have a cryptographic guarantee that the state is actually valid.
00:12:44.270 - 00:12:44.898, Speaker A: Right?
00:12:45.064 - 00:13:06.278, Speaker B: That's the only difference. People confuse this often. That's why I'm mentioning this. Another technique we're using. So like I said, all the applications, right, they post the data onto the celestia main chain. How do you ensure that the application specific chains only need to care about their application specific data?
00:13:06.364 - 00:13:07.000, Speaker A: Right.
00:13:08.490 - 00:14:14.122, Speaker B: The technique we use is a namespaced mercury. You could think of like a mercury, a binary mercury that is like domain separated by namespaces, or they're sorted by namespaces and that enables clients to download their specific application specific chunk of data. You could think of it from a tenement perspective, to think of it as like a multitenant tenement, essentially. Okay, I don't know if I confused you so far or not, but how do we actually get to millions of blockchains? Right. What Celestia does, it reduces the barrier of entry, and you don't have to deploy your own proof of stake network, but I think you have to lower the barrier on all levels, as in we need better tooling and we need better documentation. That's, I think, key to achieve this goal. Independent of the scalability technique like Celestia, that would enable millions of blockchains and theory and practice.
00:14:14.122 - 00:14:49.798, Speaker B: We need better tooling for this and better developer usability. I think we can learn a lot as the cosmos ecosystem. We can learn a lot from Ethereum here because the tooling there is great and the documentation as well. And we improved a lot, but there's still a lot to learn, I think. So what are the challenges we are facing specific to Celestia and where we could need some community input and some interesting challenges if you want to work on those. One thing I mentioned briefly are state fraud proofs. Right.
00:14:49.798 - 00:16:12.878, Speaker B: We need those for rollups, these application specific chains. If you connect them, for instance, to each other or just for light clients, you need these state fraud proofs. Originally, we wanted to focus on like Cosmos SDK based application specific chains. We realized that it's actually quite difficult to have state fraud proofs in the Cosmos SDK, essentially, because the Cosmos SDK itself is very unconstrained and not very, very well specified, and it's also constantly changing. So this is one challenge we are looking at, and I think here we could use a lot of help in very clearly defining the SDK and its modules and defining a set of constraints how to make the Cosmos SDK state fraud provable efficiently. So this plays into the next step, like where I mentioned also you need state fraud proofs for roll ups, right. And for rollaps, it's even more tricky because if you think of you have two chains, they're connected via IBC, and imagine there's an invalid state on one chain and you are connected to that one chain.
00:16:12.878 - 00:16:18.034, Speaker B: You need a way to execute the transactions of the other application specific chain.
00:16:18.082 - 00:16:18.438, Speaker A: Right.
00:16:18.524 - 00:17:02.610, Speaker B: So you need additionally to the efficient state fraud provability. Essentially what you need is a default execution environment where can easily take another application state machine and run part of it. So that's easy in smart contracts, but very challenging for the Cosmos SDK as well, because it's basically go code. You can do whatever you want, right? Yeah, that's a very interesting challenge. And we're looking into the EVM as a potential solution to that, we're also talking to Fader and EVMos. We're looking into making the EVM essentially more state fraud provable. And like many other teams, we basically need ABCI.
00:17:02.610 - 00:18:01.062, Speaker B: We're very hyped about this, actually. We had an implementation of the first phase of ABCI long before it was actually fully specified. In fact, I don't want to take any credit of this, in fact, but I told Dave that, why not? It's actually odd that you only have ABCI callbacks to the state machine in the last phase of the consensus. Why not have them in all phases? And that's what basically ABCI is. So we needed to modify the block before we're proposing it to separate the state relevant portions from the blobs. Essentially that I mentioned before, we're looking, we're eyeballing with immediate execution instead of the deferred execution model that tenement currently has, where the state route in block n represents the transactions of the previous block n minus one. Essentially another challenge we face.
00:18:01.062 - 00:19:16.190, Speaker B: So I mentioned data availability sampling is quite, it has much more requirements and much more challenging requirements to the peer to peer layer. So we are looking internally pushing to move to lip p two p. So our stack is based on the p two p and parts of like ipfs. And we also trying to push for tenement itself to move to lip p two p. We are potentially collaborating on this with protocol labs and interchange gmbh and informal. And if you are interested in p two p work, please come talk to us later as well. And another thing that we faced is that tenement is, although it's like an awesome piece of software, it's not as easy as it could be to swap out certain components in tenement without having to maintain a fork, right? So it's like we mercury the block differently, we do the erasure coding and yeah, again, it would be nice if the peer to peer layer was easily, it was easier to swap out the peer to peer layer because this is currently quite intertwined in tenement.
00:19:16.190 - 00:20:16.894, Speaker B: So that brings me to the end of my talk. So to summarize again, we are building the first really scalable, modular, universal consensus and data layer that brings shared security. And it will enable people to developers to develop, to deploy their own application specific chain without having to deploy your proof of stake network. And we envision long term that this will enable global communities that can self organize using decentralized networks and tools without being burdened by existing power structures. You can learn more on our homepage and I don't know if I still have time on questions or not. Yeah. There's 1 minute left if you have questions, but also we have a booth and Nick, a colleague of mine and me, we're there.
00:20:16.894 - 00:20:24.400, Speaker B: Please ask us all questions that you have and come talk to us as well. Thank you.
00:20:35.950 - 00:20:37.962, Speaker A: Thank you so much, man. Well done.
00:20:38.016 - 00:20:39.110, Speaker B: Well done. All right. Peace.
