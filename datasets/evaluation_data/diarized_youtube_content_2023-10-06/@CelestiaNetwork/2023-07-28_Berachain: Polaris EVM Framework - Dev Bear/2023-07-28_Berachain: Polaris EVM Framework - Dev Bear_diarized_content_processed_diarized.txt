00:00:00.330 - 00:00:45.980, Speaker A: You. So today I'm going to be talking about player CBM framework and kind of give a high level overview of bear chain as well. So a little context on myself, Dev Bear, CTO of Bear chain and Bear Chain is an EVM compatible l one built on the Cosmos SDK. And what we did is we replaced the traditional proof of stake system with what we call proof of liquidity, which allows for reutilizing staked assets to provide liquidity and making validators. Validators, sorry, validator, stake weight associated with how much liquidity they're providing. So before we get started, just want to give a little intro of our team. Our team comes from a wide variety of team, comes from a wide variety of backgrounds, including web two, web3 all over the place and wouldn't be able to build anything without them.
00:00:45.980 - 00:01:37.846, Speaker A: Yeah. So why EVM? This being a cosmos adjacent conference, a lot of people ask us like why EVM? And the simple answer is the developer tooling and just the access to utilizing the technology is so much simpler. There's millions and millions of JavaScript developers and we see the EVM as kind of the javascript of blockchain. And we think that by utilizing these type of technologies and making it really easy for people to build applications, that we can onboard more users into blockchain in general. And the next question is why Polaris? And when we sought out to build barachain, we had a lot of complicated logic that we had to add to the base layer. And we saw that just like simply forking geth or taking another EVM framework made it extremely, extremely difficult to do this. We looked into kind of some other app chain frameworks and we realized that the commonality between them was that a lot of the time that they would get to something that was EVM ish.
00:01:37.846 - 00:02:45.322, Speaker A: And the problem with EVM ish is that it's different than what developers assume, it's different than what people assume. And you end up with compatibility issues like we've seen with like Zksync and some of the other l ones where it's just not close enough and it can lead to problems and just poor developer experience. And the idea here is that we want to introduce an easy way for app chains to create an EVM equivalent EVM that allows for them to just plug it in, drop it in and create easy and a nice environment for extensions, et cetera. And the idea of this is that we wanted it to be modular, so we wanted a way to completely break apart all of the different aspects of the stack very similarly to the concept taken from the Cosmos SDK being built on Cosmos. We have the networking layer, the consensus layer, and then the cosmos layer as our traditional application layer. And we propose adding a new runtime layer on top of it, which allows for the VM to be completely separated from the Cosmos runtime, which allows for it to be running a fully native standard EVM, like you would see on Ethereum Mainnet. And how we accomplish this right now, given the limitations of comed and the SDK, is we actually are able to build EVM blocks from the data that's provided from comed.
00:02:45.322 - 00:03:38.920, Speaker A: So we take things like just the block header in general, block height, block timestamp, et cetera, aggregate all the transactions out of it, and are able to construct an EVM block that is equivalent to how you would see on Mainnet. Then what we do is we apply all the EVM state transitions, and then we essentially post that block back up to the comet chain or the cosmos chain and store its stateroute in the IVL tree. So how do we do this? When we went to setup to build an EVM that's interactable with Cosmos and AbcI in general, we wanted to come up with what is the simplest, easiest way to build a blockchain. And at the end of the day, we see it as pretty much three main processes. So the first is that you need a way to build the block and assemble the block. So you're taking effectively a list of transactions, ordering them in some way, you need to. Then once you have that list of transactions, you need a way to process them, apply the VM state transition, store the data, et cetera.
00:03:38.920 - 00:04:43.528, Speaker A: And then lastly, you need a way to actually commit the block and make that part of the canonical chain. So in ABCI, this is prepare, proposal, process, proposal, and finalize block. And in geth, this is your geth miner, your geth state processor, and then your store is your statedb or your blockchain. So we realized that a lot of common blockchain frameworks, other than just geth and cosmos kind of follow the same general pattern. So we realized that in Polaris, what we could do is we can go and actually generalize this into basically three main interfaces or three main kind of constructs, a block builder, a block processor, and then a storage provider. So what we do in Polaris is we essentially bifurcate the actual block building and processing and storage from the execution itself. So in order to maintain that perfect kind of JSON RPC compatibility with EVM, mempool, blockbuilding et cetera, is we actually run all of the kind of block building and storage on the Cosmo side and effectively just use message passing to allow the EVM execution client to do all the things that it needs to do.
00:04:43.528 - 00:05:23.510, Speaker A: So for instance, here, we have an example here. If I would just submit a transaction for executing an EVM, I would actually do that directly to the Ethereum side, JSON RPC, and that would get inserted into mempool. From there, that gets passed over basically a message system which allows for ABCI to pick it up. So then the builder is able to pick it up, and then that's how the proposal is made. So all of that is done on the Cosmos side, but the actual user was interacting with the EVM side. Secondly, from there we process that proposal that basically, again, is taking that list of transactions that was built, processing it through the system, that's talking to storage, that's talking to the actual EVM interpreter, et cetera. And it's all done through this message passing channel.
00:05:23.510 - 00:05:59.408, Speaker A: And then lastly, we need a way to store what we did. So simply, in finalize block, we're able to go and just write it to disk and say this, now block is in the chain. This also kind of allows us for queries as well. So we not only do we able to support native EVM transactions, but also full JSON RPC compatibility for queries, et cetera. And we do it through a similar model. The message dispatcher is able to get the request from the RPC, talk to the Cosmos storage, and handle it that way. This also works for transaction simulation for if you were running a searcher that's trying to build a block, you could do it this way.
00:05:59.408 - 00:06:41.070, Speaker A: So the EF call goes to JSON RPC, goes to the dispatcher, and is able to touch not only the storage, but can touch the processor which touches the EVM interpreter, et cetera, et cetera. What this also allows us to do is it allows us to make all these components really, really pluggable. So in the traditional kind of, you were to compile it all together, you'd have to kind of choose an EVM, and you're stuck with what you kind of choose with. But what we're working on is making it so that you can plug in kind of different components from different clients and make it so you can really increase the client diversity. So in this example here, you could take the transaction pool from ref or the mempool from rest. You could use Aragon's RPC, which is notably very well done. And then if you just wanted to use like the standard geth vm, you could totally do that.
00:06:41.070 - 00:07:32.440, Speaker A: At the same time, you could just choose to use all of them, which know, if you really like rust, for instance, you could do it this way. Lastly, we also engineered something that we call the precompile development kit, which allows people to write these extensions to the EVM or these pre compiles in a way that's really, really friendly. Traditionally, if you look at this precompile example from Geth, you have to write these really convoluted, simple kind of structs that are really kind of hard to use. You take input bytes, the return type is bytes. And overall, it's just a very kind of raw experience, which makes it really difficult for developers to add functionality to their app chain or to their layer one or two. But what we did is we made it so that you are trying to get towards the concept of writing a pre compile should be as familiar as possible to someone who is solidity or viper native. So if you look on the left here, this is for the cosmos staking module.
00:07:32.440 - 00:08:32.928, Speaker A: We have like a staking soul, which is effectively getting your validators delegating, et cetera, et cetera. And we're actually able to map those types directly to ghost trucks using reflection, et cetera. So if you look here, comma address is the address which adheres to kind of what we see in solidity, return types being big int is like a un 256, et cetera, et cetera. And then what we do is we utilize that same concept of the message passing. So when we kind of see a pre compile and we call it, we're able to use the message dispatcher to pass that over to the precompile manager, which can call the corresponding Cosmos module, which is really nice from that developer user experience perspective. So at the end of the day, we can have all this cool tech, but what do the advancements actually enable? So the first thing that I think is really cool is it allows for in the first time in cosmos to have genuine client diversity. On Barachain, for instance, we route all of our transactions to the EVM, and by proxy, all of them will be utilizing different clients depending on what execution client that validator or node is running.
00:08:32.928 - 00:09:14.000, Speaker A: This is really good for exploits. It's just generally good practice to have. And overall, it is the first time in cosmos that we've seen this, which we think is a really, really exciting addition. Lastly, it allows for some really interesting things to happen at the base layer. You've created a nice way to not only write application logic, but also introduce that application logic into the base layer and create really cool things. It allowed us to write some of our defi logic that we use in our proof of liquidity system on bare chain and tie that into Abci in a really native way. And it allowed us to kind of start building some of these interesting products like Flashbarra, Slinky, which is the oracle that I mentioned during the panel, and then things like integrating rollkit into Polaris, IBC into Polaris, et cetera.
00:09:14.000 - 00:10:16.050, Speaker A: So earlier today, I did a workshop with Diego and Josh from Celestia that was basically showing some of the modularity of Polaris and really showcasing how truly EVM equivalent it is. So we had the Celestia da devnet running that's being used for data availability and consensus. Then we had a Polaris SDK chain that was integrated with rollget that was rolling up to the DA. And then lastly, to really show off that EVM compatibility, we were able to deploy an op stack chain that's utilizing that Polaris chain for its settlement, which really goes to show how we truly have, like, an EVM equivalent chain, not only from an execution perspective, but rpcs and everything all the way down as the op stack deployment stuff is notoriously a little finicky and is a really good test to see where we are. And that's everything I have. Thank you guys for coming. Cool question.
00:10:17.480 - 00:10:21.476, Speaker B: Enabling client diversity for each. Right.
00:10:21.658 - 00:10:35.316, Speaker A: So it would be for any Polaris chain. So it would be enabling like, a chain that is running in Polaris that has 100 validators to create client diversity within their chain themselves. So it would allow for the EVM. Yeah, for the EVM.
00:10:35.348 - 00:10:35.544, Speaker B: Right.
00:10:35.582 - 00:10:36.170, Speaker A: Okay.
00:10:38.060 - 00:10:46.040, Speaker B: Is Polaris like a consensus middle layer?
00:10:46.200 - 00:10:58.576, Speaker A: So the way you think about it is it allows for any cosmos chain to integrate to EVM really easily. So because it's completely separated, all you have to do is kind of import this module and it allows it to.
00:10:58.598 - 00:10:59.932, Speaker B: Talk to the module.
00:11:00.076 - 00:11:02.560, Speaker A: Yeah. Allows it to talk to an execution client.
00:11:03.380 - 00:11:10.592, Speaker B: So if an existing app chain that does not have it yet, they could plug in and upgrade.
00:11:10.656 - 00:11:11.828, Speaker A: Yes, 100%.
00:11:11.914 - 00:11:18.648, Speaker B: Oh, cool. That's useful. Thanks.
00:11:18.734 - 00:11:19.610, Speaker A: Thank you.
00:11:21.660 - 00:11:35.372, Speaker C: Hey, is the idea behind something like a flashberra to essentially have, like, proposer builder separation for Polaris chains, or is it more like the current version of MEB boost kind of thing?
00:11:35.426 - 00:12:08.200, Speaker A: Yeah. So right now, the current implementation of flashbearer is built on top of Skip's Pob. So it's basically taking skips Pob all of their very cosmo specific logic and adaptering it over to integrate into flashbots. So it'll be not flashbots as in what we see on Mainnet, but the flashbots interfaces. And what that allows us to do is it allows for searchers that are running their bots on Mainnet, or allows them to integrate their existing code into a Polaris chain. Again with the concept of reducing friction for bringing Ethereum ecosystem devs into cosmos because they don't have to go rewrite all their tooling, et cetera.
00:12:08.860 - 00:12:10.170, Speaker C: Nice. Thank you.
00:12:18.080 - 00:12:22.010, Speaker A: Sweet. Awesome. Thank you.
