00:00:01.800 - 00:00:21.490, Speaker A: Good morning, everyone. Appreciate everyone coming out Saturday morning here. I know it's been a long, long week, mostly for everyone. I'm Yuri from Signature Ventures. And guys, we have with me the fabulous five guys. You could just introduce yourself quickly and also your company.
00:00:22.750 - 00:00:39.200, Speaker B: Hi, my name is Stan, I'm from initiative. I'm currently one of the co founders. And what we're trying to do at initiative is trying to re envision the roll up world and how multiple applications on each roll up interact with each other in the general user experience. Yeah, I guess we'll keep that simple.
00:00:39.620 - 00:01:20.740, Speaker C: Hi, I'm Rishabh. I'm one of the founders of Socket. We're the first chain abstraction protocol. What we're really building is as this fragmentation emerges in the stack with so many chains and applications and tokens spread across chains, instead of a user carrying about 500 different variables like rpcs and gas tokens and whatnot, you want to provide this way for users to interact with all of these chains in like, a global block space point of view, where they just care about two or three things that they care about the most, like speed or cost, and everything else is abstracted away from them. And we use like, this mechanism called Mofa to achieve that.
00:01:21.480 - 00:01:38.360, Speaker D: Hi, everyone, I'm Marko. I've been running marketing for Lifi for two and a half years now. Running jumper on the B two C side. In short, Leafi has been doing chain abstraction since three years ago by aggregating all of liquidity in Defi. And super happy to now move to the next step with socket.
00:01:40.180 - 00:01:53.400, Speaker E: Good morning, everyone. I'm Karel, founder of union. We do zero knowledge interoperability. Our testnet recently went live. We passed about 90,000 users and almost 400,000 transfers on our public testnet.
00:01:54.700 - 00:02:08.270, Speaker F: Wow. Good morning. Thank you for coming. If it were me, I would be sleeping if I were you. So I'm very impressed. You have more fortitude than I do. As you can tell by the hairstyle, I'm very underqualified for this panel because I don't have a modular mullet.
00:02:08.270 - 00:02:19.470, Speaker F: Also, I feel like to be modular, they have to be multicolored. So I'm not really buying this yet, but we'll see. Yeah. Did I say, my name is Christopher and I work on anoma?
00:02:20.810 - 00:02:40.396, Speaker A: Perfect. Maybe take a minute or so to define a little bit what chain abstraction actually is. Because if you take it literally, if you abstract away the chains for the users to be everything more easy, any centralized exchange can be a chain abstraction. So from your point of view, what is basically chain abstraction for you, especially from the point of view of your company? Potentially, sure.
00:02:40.428 - 00:03:18.294, Speaker B: So I think there's two things to really consider when you're looking at chain abstraction. One is, I guess like the end users, the actual users who use the application itself that you're trying to build, the people you're trying to try the application. And the second is the users or like the developers who actually make those applications. Right. So what are their experiences like? How difficult is it for them to attract liquidity? How difficult it is to actually build on the chain or whatever infrastructure that you have made? And so when you're looking at chain abstraction, I think there's two categories to consider. The first is the user experience, and that kind of can be split furthermore into two categories. It's like the infrastructure itself.
00:03:18.294 - 00:03:59.150, Speaker B: How interoperable is the infrastructure, how easy it is to be able to allow different application developers to build on top of that. And then the second is the UI Ux. Like, how do you envision a multi chain world or a very modular world? I think when you look at a modular world, everything is split into different parts and you kind of optimize along each vertical or each horizontal in the stack itself. And so that makes everything, let's say, 100 times more complicated, more difficult. And so how do you kind of retie those pieces together and make it really easy to use? And I think chain abstraction is one of those things that is very complicated and kind of wide, but really just touches the end user experience, whether it's the developer or the user itself.
00:04:00.130 - 00:04:11.990, Speaker C: Yeah, I think going back to my intro point, I think today there's too many variables that a user needs to care about. The user almost needs to be a scientist to be able to interact on chain.
00:04:12.030 - 00:04:12.230, Speaker A: Right?
00:04:12.270 - 00:04:46.826, Speaker C: Like if just a small example, right? A user who needs to swap from one chain to other to another, they need to care about two gas tokens, two rpcs. The cost is gas cost of like one chain, and then the bridging cost and then the gas cost on another chain, and then the swapping cost. These are like, and then, and then like, latency also is finality of one chain, finality of the other chain bridging, and so on and so forth. Right? So the number of variables basically are exponentially increasing, or the number of variables that users needs to care about are exponentially increasing as the number of chains increase.
00:04:46.898 - 00:04:47.154, Speaker B: Right?
00:04:47.202 - 00:05:14.590, Speaker C: So chain abstraction is not about, it's still about having all of these fundamental rights for the users to interact with on chain, but without having to care about so many variables. They should just care about what are the one or two or three most important things to them, which might be different for different users, but they don't have to interact with on chain, interact on chain directly and see these variables in action and just care about what, what's really important to them.
00:05:15.650 - 00:05:53.200, Speaker D: Yeah, I mean, I think in short term everything is UX based. I think one of the best examples from what we need to do is just move what we're doing into web two level of usability. When you use Internet, whatever, you don't need to know that there's satellites and cables and how should works in the backend or in behind. And our industry needs to get there. And chain abstraction allows that to happen. I think just in short term it's going to be purely ux fixing, not like bridging chains. Everything's going to happen in the back end still, we're not going to abstract that part away.
00:05:53.200 - 00:06:04.520, Speaker D: But fixing the UX for users to actually make it simple for a boomer to come in and use an app, not a chain, is the chain abstraction.
00:06:06.700 - 00:06:31.992, Speaker E: So I feel at least that just delegating chain abstraction to being good ux is kind of the most lame answer. Just because I feel like in the UX side you can already do a lot of stuff and we've been doing that for the last five years. Right. Like we can try to hide away a lot for our users. The problem is when you hide away a lot for the end user, they lose a certain competitive edge compared to others. And obviously they start having worse trade execution, et cetera. Right.
00:06:31.992 - 00:06:50.954, Speaker E: So actually if we give them all of the knobs to see what fees they're paying, what protocols they're using, that's what gets them good prices as well. Or early access to icos, or early access to pools. And so I think with chain abstraction, like, if you just focus on making it simple for your grandfather to use, do you really build a good defi product?
00:06:51.122 - 00:07:00.270, Speaker D: Not really sure there should be both, because with the fees, with the issues, that's what puts people away.
00:07:02.050 - 00:07:38.904, Speaker E: We've had those uis before already. They've existed. There has never been an issue where we couldn't write a new front end in react, where we just compress all of those numbers into ones or do some simple calculations for the end user. I think the real issue at some point with all of this chain abstraction is that actually for developers building all of these uis, it turns out that it becomes very hard to port them across different chains. And that those semantics are completely different. Even though every single chain exports approximately the same functionality at a very high level. We look at what apps were building, it's always swaps, it's always lending, it's always taking.
00:07:38.904 - 00:08:10.860, Speaker E: The core functionalities are the same, but then for move based chains, for SVM based stuff, it's then completely different and semantically very strange to operate with. So for me at least, chain abstraction starts actually at the back end itself, and realizing that perhaps we want to indeed only export those core functionalities to the end user and give them all of the knobs necessary to interact with the core functionalities without needing to know necessarily about the underlying backend chain. But that's still perhaps a complex ux, because in the end, finance is complex.
00:08:11.280 - 00:08:32.000, Speaker C: Yeah, like just adding on to this point, right. The true reality is that fragmentation on chain, like, the on chain fragmentation will always exist, right? Like there will always be hundred chains. It will always be complex to kind of like, navigate this. But like, how do you kind of like, give these users these knobs in like, such a way that is, like, understandable to them?
00:08:32.040 - 00:08:32.240, Speaker A: Right?
00:08:32.280 - 00:08:50.364, Speaker C: So it starts with the backend, but it also kind of like, is an, at an intersection of, like the front end and back end in some sense, where these knobs basically, like the front end sort of things. And then, like, at the back end, there are these actors that really kind of, like, are, let's say, performing all these actions in a complicated way.
00:08:50.492 - 00:09:17.846, Speaker E: Yeah. And I think one thing is, in crypto, if you actually look at a lot of the depths on Ethereum and Solana, most are forked. Some react starter templates by uniswap rights. And so actually, the power of having some sort of default across the industry is like very strong, because in the end, like the early standard that you set then happens to be used by everyone. Right? Every single swap page looks exactly the same. It also has little rounded corners, it has the same buttons, same inputs. And that's because everyone forks the Uniswap UI.
00:09:17.846 - 00:09:25.650, Speaker E: And so I think for chain abstraction itself, that's why you have to start at the backend and kind of add the root foundation, because then it propagates everywhere else later on.
00:09:27.590 - 00:09:28.370, Speaker A: Chris?
00:09:28.830 - 00:10:12.784, Speaker F: Well, as I said, I was underqualified for this panel, so I have a confession to make. I don't know what chain abstraction is exactly. I mean, interpreting it literally. Blockchain's a data structure, a linked list of blocks, and that's already an abstract data structure. So it seems like chain abstraction is kind of a tautology in social practice, it seems like what people mean is something like these blockchains, like these actual instances of things that exist in the world and produce blocks and store data, there are too many of them and users don't care and they want to do something with their application. So maybe we should abstract that in some way. Now to me, a central question when you're trying to abstract something is what are you trying to abstract? And what are the essential properties that you want to capture in the abstraction as opposed to like the properties you don't care about.
00:10:12.784 - 00:10:40.880, Speaker F: Now, as we see them today, blockchains typically couple two services. They couple the service of ordering transactions and they couple the service of storing data. And sometimes they store that data forever, at least by default. If you write to ethereum storage, that's the assumption. Sometimes they store that data only for a little while, so called data availability. If you write to blob storage or you write to Celestia, that's the assumption. Right? So to me, it seems like there's sort of two distinct services here that we could potentially abstract, and users might want them in different ways for different purposes.
00:10:40.880 - 00:11:41.120, Speaker F: The other question, which comes to mind, to your point on, well, just good ux is not enough, is that I think we might want to think about what it is that users want to do and how to ensure that some of what they want, maybe their intent, is somehow translated through this network of like peer to peer nonsense, and that whatever ultimately happens, they have some way to measure it, create some feedback process where if some solver or some place they're sending, they're like very abstract intent, or kind of less specific specification of preferences. Even if it's not formally an intent, users need some way to measure. Is the system ultimately satisfying this in a way that they are happy with or not? So I think those two aspects, separating out what kinds of promises for different services are being offered and figuring out how to create feedback mechanisms so that users can interact with the systems in a way that is in their best interest in the long run, are the aspects that are interesting to me.
00:11:41.740 - 00:12:19.970, Speaker A: Cool. I think everybody mentioned at least users once. And if we take visually this cake framework, if you don't know what the cake framework is, just google it from frontier research. And there are all these elements on these three layers, and on top of all that is applications. So if we take this for granted, those things are all built now. All these layers are built now. How would an application look like in this framework? Is it just a front end with a prompt or is it always a financial application then? How would you imagine the application to be? How would you imagine the user to want, actually? So for when you're building something.
00:12:23.990 - 00:12:58.336, Speaker F: How would I imagine an application to be right? That's a good question. I think, to touch upon my previous answer a little bit, what you want to capture in abstraction, you want to capture the right things. You don't want to abstract everything. Like if it's just send my transaction to a blockchain, send it to one of them. This is about as specific as like send to my packet to a computer, like one of them. You know, we don't use the Internet like that. When we use the Internet, we specify, say, the IP address to which we want to package to go.
00:12:58.336 - 00:13:24.688, Speaker F: What we don't specify is exactly how to get the packet there. The Internet doesn't do pre routing. It does like just in time or on demand routing. When we're talking about blockchains. Again, there are kind of two services which I think we need to differentiate here, ordering and storage and ordering really has. These two services are different in part because the user will care about different things. When you care about ordering, you care about mostly that these validators aren't going to double sign.
00:13:24.688 - 00:14:11.578, Speaker F: Maybe you care that they have enough economic security. You also care a lot about what other intents or transactions are also also being ordered in the same block. Because maybe you want some kind of composability, even atomic composability with other intents and other assets, whereas when you're talking about storage, you care about. It depends a little bit, maybe with optimistic roll ups or something. There are different models, but typically you care about data being retrievable in the future and data being retrievable efficiently in the future. You don't want to store it in a super expensive place if you only need to retrieve it every so often. So it seems to me like from the perspective of an application, we should build abstractions that allow application developers to reason about who they need to trust to do the ordering and what assumptions they're making and what kind of storage services they're buying, but not to reason about any of the internal implementation details of those things.
00:14:11.578 - 00:14:28.670, Speaker F: Developers should be able to reason about what promises are being made, and you know a little bit about kind of how those promises would be enforced, but not needing to know. For example, maybe the internal details of how, I don't know, validators are sending data around to each other on the network. That's not irrelevant criteria.
00:14:31.050 - 00:15:10.448, Speaker E: I'm going to put my deaf brain on with this question. I think if you look at a lot of the UIS right now, especially on the Ethereum side, then the UI will almost exactly resemble the smart contract. And for like every button that you are clicking, there's usually a one on one function that's being called. And the downside of this is that usually there's not actually a good mental model for how you should model the financial application itself, like the smart contract. And this leads to pretty high gas utilization because you cannot really batch user transactions together. Usually users need to submit multiple interactions with the protocol. For example, you do separate approve and then the actual interaction.
00:15:10.448 - 00:16:02.188, Speaker E: And so overall, we lose a lot of money on gas by modeling our applications this way. And we have a very one on one connection between the UI and the smart contract, which means that it becomes harder to kind of aggregate them. And this is where I think actually originally kind of the chain abstraction, intense stream came from this idea of how about we have sort of a layer in between here that's maybe a bit more machine friendly, more backend oriented, where we think more about batching gas optimization, where we realize, hey, these apps are all the same. And then the frontends actually go against this shared interface. And that way at least like we have a lot more straightforward forward applications for the backend developers. And overall, that's also this move for Ethereum to become more of a settlement layer. And you really get this separation of, hey, smart contracts really are not intended for end users to interact with directly.
00:16:02.188 - 00:16:08.760, Speaker E: And apps themselves really provides like a 360 experience for the user with this platonic, abstract world.
00:16:09.540 - 00:16:15.560, Speaker F: I realized also in our answers that maybe we should answer a more basic question, which is, what is an application?
00:16:16.390 - 00:16:39.246, Speaker E: So for me, an application is always like kind of a single smart contract with state that might manage some funds or users or whatever, and that can have like a UI associated with it. But since we're all in blockchain web3, for me an application has to kind of live on a chain or be its own chain, like its own state machine. I think for you it could be much bigger or smaller as well.
00:16:39.358 - 00:16:46.614, Speaker F: So if I have a Uniswap contract on Ethereum and a Uniswap contract on Austin optimism, would you consider those the same application or different ones?
00:16:46.782 - 00:16:53.450, Speaker E: I would say that's quite hard right now, because if they could independently work, then we'll consider them just two separate applications that interact with each other.
00:16:53.790 - 00:16:54.530, Speaker F: Fair.
00:16:55.750 - 00:17:45.802, Speaker D: I mean, Ux might be a weak answer, but the problem is we're building a lot of cool infra and not inviting new users into the market. So we're basically circle jerking each other with super cool infra being built. And so you asked about the financial stuff. So this is one of the first things that's actually going to invite people. Do people want to make money? People want to know about finance, but it's really actually hard to get into it properly and make money in it, right. And so with intents, with chain abstraction and especially AI agents later on, like shared keys and stuff like that, we're going to be able to have applications that learn based on your behavior, give you recommendations, execute for you, basically, and make it super simple for you to interact with stuff without you knowing basically what you're interacting with. You want to see a product and you want to see how much money you're going to make and you want to see how much money you're going to save, maybe by something.
00:17:45.802 - 00:18:26.988, Speaker D: So from a financial perspective, there's a lot of verticals where that could be super helpful. From suggestions perspective, we're just actually executing on your money. But this is something that can invite new people, building more dev tools, building more, I don't know, intent based protocols, whatever, we're there. We have good tech that we can join together and create good dapps that we don't have good dapps. And second thing, maybe a hot take, but at least from my circle of people, Coinbase wallet is maybe a good example of a first chain abstracted wallet, or at least a balance abstracted wallet. You try, you're like, oh, this is cool. And you go back to rob your metamask.
00:18:26.988 - 00:18:38.450, Speaker D: Because for us that are in the industry, it's simple. Crypto UX doesn't suck, right? And so we need to invite new people in it because we're not going to use like these new models that easy.
00:18:39.030 - 00:18:52.382, Speaker A: So do we assume that at least financially educated users in the first place. Sorry, do we assume that all the users will be, or at least the first users will be financially educated people because they want to make money, they know at least some sort of, well.
00:18:52.486 - 00:18:55.850, Speaker D: Maybe not financially educated, but want to be, right.
00:18:57.170 - 00:19:19.698, Speaker C: I think right now we have financially educated users. Right. I think, like, no one can be more educated in some sense than what we have today. And now we only need to kind of decrease the bar of education needed to kind of like interact with things on chain. Right. And I really agree with like what Chris mentioned where like, we need to think about what is the right kind of or what right level of abstractions.
00:19:19.754 - 00:19:19.970, Speaker B: Right.
00:19:20.010 - 00:19:26.606, Speaker C: There are like, I said there are 500 variables that users need to care about. What are the two or three most important variables?
00:19:26.638 - 00:19:26.830, Speaker E: Right.
00:19:26.870 - 00:20:12.558, Speaker C: And these variables might be different. The important variables might be different for different users, right. Some, I might not care about security as much as, you know, like you do, right. And I might care more about cost, but someone else might care more about the speed, for example. Right. So at an application level, like whoever is building a protocol application, they kind of like need to think about what are the things that I really want to optimize for the most and really have that on chain. And going back to the Coinbase smart wallet, I think the smart wallet right now, especially with magic spend, is one very good example of this, where they just allow you to interact on chain with base applications, with your balance on Coinbase exchange.
00:20:12.558 - 00:20:34.160, Speaker C: In some world, you can consider your first question that as a chain, but users don't really need to know about base or anything, they just need to know. Yeah, I can own a higher yield on something called AavE, so let me just use my Coinbase exchange balance to earn yield. And that's all they should care about from Coinbase point of view.
00:20:35.700 - 00:21:46.870, Speaker B: Yeah, I guess specifically, I think when we're talking about financial applications, all the users, or whichever these imaginary users are, have different levels of knowledge of finance or whatever. Domain specific knowledge, right? Like I come from a trading background. I don't expect somebody who doesn't know how to markets work or that has no experience to trade to know how to deal with these complex products, right? But I think the interesting thing about web3 is that you are exposed to these things, right? There's like volatility products, different types of swaps, different types of very interesting stuff that are made by people who are presumably, hopefully familiar with what they're doing. But that doesn't mean like the end user actually understands what they're touching, right? A lot of times you just see a really high APR API, you're just like, okay, let's put somebody in and let's see how it goes. And so I think you shouldn't expect all users to be the same and to have the same level of knowledge. And so, as Chris kind of mentioned, we were trying to abstract different things, like what are really their needs, right? Like who are you really trying to target? Maybe it's institutions, maybe it's like the end user in some of these lending markets. As an example, like do you really want the like average retail user to be lending in something that's potentially risky? And maybe that is something you want, maybe that's not something you want, but those are things you kind of have to consider when you kind of look into chain abstraction.
00:21:46.870 - 00:22:25.790, Speaker B: I guess on the developer side of things, same thing as well, different levels of developers front end, backend, whatever developers you want to have different types of tooling, whether it's SDKs, APIs, things like that, to really fit your solution to their needs. Maybe your front end developer doesn't really need to understand the underlying smart contracting language, or maybe they are a smart contract engineer, but they don't understand a different language. Maybe you're familiar with solidity or whatever versus move. When you're building these applications and doing this so called chain abstraction, there's a need for segregation of the type of user that you're targeting.
00:22:27.970 - 00:22:53.958, Speaker A: At least to me. It feels like we do assume some sort of finance in the application so far right now. Does that mean that there is still works to be done? We're not now abstracting infrastructure level stuff away. There is still a need in the future to abstract the financial part of way. Maybe at the application level, or is our intents, for example, might take care of that because they just can interpret human language and then transform it into financial language and then move it all down.
00:22:54.054 - 00:23:27.530, Speaker B: Yes. I actually disagree that most of this is finance. I think a lot of it will be finance and I think the majority will be finance because like just in general, the frameworks really fit well for these types of products. But that doesn't necessarily mean like, you know, most of this will be financed in the future. Like if like a simple example is like you have a game, right? I don't know, maybe you play maplestory or runescape or like whatever other game and you want to pay somebody or have like an intent for somebody to do something every 6 hours, right? Like that's not necessarily financially related. I mean, you could pay for a service, but I wouldn't argue. That's like, you know, like traditional finance in any sense.
00:23:27.530 - 00:23:48.850, Speaker B: And so like some of this stuff I do think can be solved with intents, right? Like you kind of say like I want somebody to chop my tree every 6 hours or farm my plants every 6 hours or something like that. And that's like something that I do think if you have an on chain game or like some game that can be connected on chain is something that can be solved with some of this new type of infrastructure that was originally meant for, you know, finance.
00:23:49.590 - 00:24:41.276, Speaker F: Chris, you want to say something intense for runescape grinding. I love it. I, I mean, you asked about intents and natural language and kind of how users will give inputs to these systems. And I think we can find a lot of inspiration by just looking at what exists in the world today, even in sort of web two. Or in a typical example of an application where you haven't clear intent, is something like uber or bolt, booking a car where you want to get from a to b, that's a constraint. You have some preferences about getting a car quickly and perhaps at the lowest price as possible, given enough trust in the driver or something like this. And I think that the interface offered there is not natural language.
00:24:41.276 - 00:25:14.368, Speaker F: It could be Uber could offer you a bot that you chat with to book your car. They don't because it helps to have a visual map. So I don't think that ever. I don't think that everything will switch. I think some things, you know, to me it's important to segment like, it's one thing to try and train a large language model or something like this to convert natural language descriptions into precise, you know, data structures, mathematical descriptions of an intent. That seems to me like something that's very useful. You can display a visual confirmation to the user of exactly what's going to go on.
00:25:14.368 - 00:26:05.376, Speaker F: Expressing an intent in natural language that you actually send to the distributed system and try to match using natural language. This is a very different and very interesting, but like, that's a research problem, I would say, because verifying that that intent was matched correctly turns into a problem not of syntax but of semantics. It actually turns into something like the oracle problem, like, do we agree on the state of the world? I think that's an interesting research direction, but probably not something to be productized anytime super soon. You know, I think I'm not, I don't come from a financial background. To me, part of the interesting effect of crypto has been to maybe at least catalyze some reinvestigation into the question of what is finance. To me, the boundaries are a little unclear. Is Uber a financial application, for example? Well, there are financial transactions going on.
00:26:05.376 - 00:26:52.004, Speaker F: They ended up also giving out loans. Maybe that's just weird, like capital market structure stuff. So I think it's a little bit tricky to draw the boundary. Also, certain communities probably will want to limit the degree of financial interoperability in their systems. An example of this is Runescape. If everyone in Runescape just uses farmers, somehow it kind of loses, like the game loses its purpose, you know, I mean, it may be dull and boring and kind of terrible to spend 6 hours clicking your axe and clicking the tree, but at least when I played the game, somehow this created a certain kind of camaraderie, like, you know, shared sacrifice, shared hazing. By the dumb rules of runescape, tree farming was part of what made the game like a place that people wanted to hang out.
00:26:52.004 - 00:27:06.160, Speaker F: And if all of that just becomes financially interoperable and you can buy it, then it's not like it loses its separation as a space. I think now it's just someone with a lot of money can buy a runescape account and I don't know if people would want to play anymore. So I think there's some interesting questions about that.
00:27:06.820 - 00:27:35.870, Speaker A: I actually like this game as an example here too, because if you chop trees every 6 hours, for example, you don't do it for because you love to chop trees, you do it because you might be exchanging for something else, another resource to build something more. Right? So in the end there is a marketing behind that and there's again, finance. So might it be that this application layer in social abstraction is just a translation layer from normal people doing something and it translates to financial means and then so it goes down basically to blockchain. Is that a way to think about applications?
00:27:37.370 - 00:28:22.208, Speaker B: I think in a lot of these cases that is true. Maybe you want to sell these logs that you chop to someplace called the grand exchange maybe, or something like that. But in other cases maybe you just want somebody to move your assets somewhere or maybe move your NFT somewhere, or maybe as some of these panelists mentioned already, I have an NFT on one chain or one application and then there's another application, but I'm not really sure how to like move this asset myself. Right. So maybe you just specify like I want it to be moved to this stage, to a different place, or like this application in the cheapest way possible, or like maybe the fastest place possible, or like some combination of those two, and you just submit that intent. So I don't think they necessarily has to be financial. You could say like, you know, NFTs have some sort of value, you're moving a financial asset.
00:28:22.208 - 00:28:32.180, Speaker B: But I think like that probably is like a little bit too pedantic in some sense. And I think the average user is like, I just want to move it to this application to do something with it.
00:28:33.400 - 00:29:46.128, Speaker E: Any application that has in app purchases or to be honest, any transfers of assets internally is a financial application in the end. And if we look at applications, a lot of them do trading coupons, for example, you might think that's something cute that your mom does, but then raise.com I think makes 500 million a year of multiple billion dollar market of people trading coupons on the app internally. And then the question becomes, do you believe that these apps become better if they're open financial markets or if they're close financial markets? Obviously they have some type of internal order flow going on. Coupons are being traded back and forth. Do they give that order flow to Citadel and the Citadel start r being coupons and make hundreds of millions of that? Or is this something that you settle on chain allow anyone to have access too? And that's why I think overall, especially Gamefi too, is if you look at a lot of games, they are indeed financial applications. There's so much trading going on, so much order flow, so much potential value, that the question is, do we have the game companies keep that themselves or do we open that up to everyone out there? I don't think in the end, the end users interested with actually interacting with this, they actually don't want to really know that they're gambling on a financial app.
00:29:46.128 - 00:29:56.920, Speaker E: But does the app become cheaper for them if it's opened up to any trader out there? And that, at least for me as a libertarian, I do believe that if you make it an open market, it becomes more efficient for the end user.
00:29:57.860 - 00:30:49.170, Speaker B: I think open markets very interesting. I think in general, having higher competition is good for the end user itself. I just question whether, for example, large, somebody who makes something that's worth something or has an ip, for example, let's say Starbucks, they had a partnership with a chain. And so, for example, every time you buy a drink, you get an NFT or some sort of thing on chain. I think that is leaking a lot of value from the perspective of Starbucks. And that's why I think these partnerships don't work out is because you have all this data about these users and do you really want to make this publicly available to all your other potential competitors? For example, if I start issuing instead of those frequencies that you collect on Starbucks and you start making them on chain, you can get civil, right? Or you can get, sorry, not civil. You can get vampire attacks, because I could be another franchise or another coffee chain or whatever.
00:30:49.170 - 00:31:11.776, Speaker B: Be like, if you have one of these nfts, you get a free drink from me, and that's probably something you don't want. I think there are certain applications where you don't want to share that as the person who develops the application, as the end user is very good, you get a free drink. But I think those are just some application choices, like the teams that make these applications have to make at a high level.
00:31:11.808 - 00:31:50.314, Speaker C: Like there are like two types of, like, just to summarize, maybe, right, like, there are two types of use cases, right? Like financial is like everything quantifiable, I would say. Right? Like money or like funds are quantifiable. So whenever there's like something quantifiable, you have like parameters which are quantifiable, like cost, for example. Right. Like, becomes a very direct component. And, and then on the other hand, games, or let's say farcaster, it's again, another example of a very nice chain, abstracted sort of an application for me where, okay, yeah, we have to set up a wallet and everything to onboard. But once you have that, there's no difference to use farcaster versus Twitter.
00:31:50.314 - 00:32:15.260, Speaker C: And then you can then start embedding these financial primitives or these financial interactions on top of it, which is where things will become more interesting on, like what, what does that look like? But it still starts with like this non financial, completely abstracted sort of an experience where users do not even need to know that there's some chains exist under the hood, but they still can farm our airdrops.
00:32:17.160 - 00:32:47.510, Speaker A: Sounds good. So if we just switch a little bit to how much in application developer, how might a tech stack look like? So you already see for solvers, for example, we have a tendency to centralization because only a few solvers are basically taking most of the order flow. Do we expect that on the, let's say the permission and also the settlement layer and at some point having just like a standard vertical tech stack and that's it. And that's what the app developer uses then? Or do we actually have some modularity kept there and can keep it more modular? Right? In that sense.
00:32:50.500 - 00:33:32.520, Speaker C: Yeah, no, I think, I think when we talk about solvers, I think while centralization is one thing that people have started talking about, I think the real reason why solvers or any off chain entities are introduced in this transaction lifecycle is for efficiency gains. So the right parameter to kind of talk about these off chain agents, in my view, is like efficiency gains while ensuring that they don't have this capability or mitigating this capability for them to kind of like misuse any kind of like potential, let's say monopolistic centralized powers or whatever.
00:33:32.560 - 00:33:32.736, Speaker A: Right?
00:33:32.768 - 00:34:08.752, Speaker C: So for example, the most simplest way, and this is something that we will talk about a lot, is while you're kind of like firing, let's say, a swap transaction, you can say, I want at least, least XYZ amount of stuff and then the worst case execution that you will get is this. So in some way, you can kind of, like cap or in some way, you can basically always be ensured that these entities can't kind of, like, misuse, even if, like, they're like the. Even if there's, like, some amount of centralization in there. But I'm very curious to hear, Marco, Chris, like, what are you guys thinking?
00:34:08.926 - 00:34:36.080, Speaker D: I mean, the centralization comes from not having a standard. And you have players like one inch fusion. You need your unicorn power. You have another place. It's a different system how you compete to solve, in a way. And so there's a high barrier of entry. Basically, it's either infrastructure cost or actual capital cost, or you need a lot of money in different chains to actually relay if you're doing bridges.
00:34:36.080 - 00:35:03.840, Speaker D: And so I think across the zip, for example. Super great move to solve that, Kalani. Super great move to solve that. So once the barrier of entry becomes way, way, way smaller, the centralization problems will start going away bit by bit. Hopefully, if we don't stay in the north american regulatory framework with all the solvers, we will be solved. Yeah.
00:35:06.350 - 00:35:29.290, Speaker E: Keep it short, because you know more about this than I do. But I think at least as a solver, from an off chain perspective, you always want to combine as many competitive advantages as you have. So I don't understand why, as a solver, you would modularize and only focus on one component. Because ideally, you have as many edges and you go as vertical as you can to get the highest yield that you can do. And that seems to be what happens in tradfi as well.
00:35:29.710 - 00:35:37.456, Speaker D: But isn't that actually more centralization? Because if, if one just gets better, better, they just eat all of the order flow in the end. Right?
00:35:37.528 - 00:35:43.300, Speaker E: That's what we observe in tradfi as well, right? That seems to be the natural gravitation of solving off chain agents.
00:35:43.920 - 00:35:47.472, Speaker D: How do we fix that? Like, what's your, you know, what do we do to fix that?
00:35:47.496 - 00:35:56.272, Speaker C: It's about efficiency, right? Like, if efficiency is there, like, you should just think about mitigating it. But if you get efficiency, it's great.
00:35:56.416 - 00:36:32.216, Speaker B: I don't, I don't actually think, like, a lot of this is like, that big of a problem, personally. I think if you have open access that anybody is able to access this order flow and compete in this environment. Sure. But obviously, the person who provides the most efficiency and the best price is the one who's going to take most of the order flow. I think that's natural. The best person wins, especially in a market that has perfect competition, that naturally in some sense leads to centralization, as you guys mentioned. But I think that is less of a problem, and I think it's more of a problem that anybody is able to access this market itself.
00:36:32.216 - 00:36:36.620, Speaker B: The barriers to entry should be low, not necessarily winning should be easy.
00:36:38.280 - 00:37:11.310, Speaker F: I think there are different sources of super linear returns to scale, which is what we're talking about here. One source is barriers to entry caused by protocol incompatibility. So standards help with this because they just reduce the switching cost. Then anyone can start a new solver, start a new chain, whatever, and if it uses the same standard, no one has to rewrite their applications for it, which makes it much easier to switch. There are other sources of super linear returns to scale, though. One of them can just be currently owning liquidity. Like if there is one big solver matchmaker, they have most of the liquidity.
00:37:11.310 - 00:37:57.860, Speaker F: Absent some coordination amongst the users, they will probably just continue to have most of the liquidity, because users, because the users are going to send their intents where the liquidity is already. So to me, the other part of this question is actually like a dynamic systems question. It's not just a can we design this architecture? Question. And that latter part of the question is how do users share information amongst themselves to determine whether or not some big central operator is screwing them or not? And if they're not screwing them, like, okay, whatever, I mean a kind of altruistic, or at least like minimally extracting monopolist is a pretty efficient configuration of the system. But in order to bound them to minimal extraction, you need a credible threat that if they start not to minimally extracting, you can leave and switch. And I think that's an interesting question.
00:37:58.640 - 00:38:21.040, Speaker A: Nice. I think it's a good note to end on, because the clock is ticking down to now. Zero we have any questions from the audience. Also, I can't see all that well because of the lights, so if you just shout a little bit. Okay, no question. Okay, so then thank you all guys. You've been beautiful.
00:38:22.620 - 00:38:23.228, Speaker D: Thank you.
00:38:23.284 - 00:38:23.948, Speaker F: Thank you.
00:38:24.084 - 00:38:24.460, Speaker A: Thanks everyone.
