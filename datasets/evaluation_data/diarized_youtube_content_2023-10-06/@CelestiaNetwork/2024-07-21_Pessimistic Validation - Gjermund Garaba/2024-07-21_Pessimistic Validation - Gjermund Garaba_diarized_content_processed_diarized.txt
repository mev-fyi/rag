00:00:01.480 - 00:01:35.550, Speaker A: Yeah, so going to be talking about pessimistic validation, which is with the goal of enabling IBC for optimistic roll ups. And as we will get to beyond that as well. So my name is Yermun Garaba. I've been in the cosmos ecosystem for a few years and been working with blockchain and software for quite a few years now. Currently working at ICF in the IBC team implementing the IBZ Go and working on IBZ protocol. Yeah, this project, it came about during the Celestia Infinite Space Bazaar as a hackathon project and yeah, won a first prize there and since been working on it to bring it to full production value. So the problem that I wanted to sort of tackle with this was mostly around optimistic roll ups and sort of the UX issue of bridging tokens or messages in general, where you have this seven day, typically seven day period, wherever, where you have to wait for this to settle because you need to have, need to wait for any potential fraud proofs, which is fairly close to unusable in my opinion.
00:01:35.550 - 00:02:18.650, Speaker A: And until ZK is available for all kinds of chains, for all kinds of purposes, its optimistic roll ups are probably going to be quite prevalent for a while. So yeah, nobody has time to wait for that. So yeah, before I get into sort of the solution that I went with here, there's a couple of properties of proof stake chains that I wanted to and roll up. So I wanted to just go through. So basically, proof of stake chains are trusted committees. They're trusted committees in that they have like the stake that's, that is assigned to them. And basically whenever you do bridging or.
00:02:18.650 - 00:03:29.966, Speaker A: Yeah, whenever you use IBC, you're basically relying on this trusted committee of the chain to have signed off on the state. And of course you validate that it's correct. But that is actually the canonical one that was finalized. You rely on the trusted committees and for rollups, a property that's kind of important is that the risk of these actual frauds are very low if you run a full node, because then you can actually verify that the state changes are correct because you're running all the transactions and you're going through the entire state and making sure that it's correct. Given that if you do see something that's off, that you would submit a fraud proof. If you wouldn't, then nobody gets any benefit from that. So the solution is based on some of these properties, basically leveraging existing economic security that exists on proof of stake chains, particularly for this implementation, is for cosmos chains.
00:03:29.966 - 00:04:26.500, Speaker A: So like Cosmos hub or osmosis or whatever. And how it works is that the validators on the receiving chain, so the non roll up chain, they basically run, or some of them run full nodes of the roll up itself. So they're running all the transactions and making sure that the state is correct. And they just post that information to a lite client so that you can actually just do normal IBC without any changes to the protocol, without any changes to the roll up itself. You just need to have a light client that can actually do this. So you could today, for instance, with a rollkit roll up, you could use the tenement lite client that exists. But the problem is that the committee that you would be trusting is typically one sequencer.
00:04:26.500 - 00:05:24.830, Speaker A: So there's, you just have a 101, which is not good. But in this case, we take it back to the receiving chain and use the existing validators and existing security that is already there. So you can trust that the lite client is updated correctly and that there has been no fraud. Yeah, and that's sort of the general idea, sort of the way to make this a bit more functional, because if you have, for instance, the cosmos hub or some other big chain run full nodes on all the roll ups, then you would basically have. Yeah, it wouldn't make a lot of sense from either a cost perspective. And you basically just have a full chain again. So the idea here is to have some sort of partial set security where you can have basically configure how much security you actually need for a roll up.
00:05:24.830 - 00:07:03.546, Speaker A: Typically for, I guess, many roll ups, they're not going to have a ton of TVL on them or any high incentives to actually attack or try to trick it. So you can use a smaller subset, which makes the cost of actually doing this not too bad. Yeah, and also doing this, this way we can also hook into the existing slashing mechanisms that exist in Cosmos SDK and you can control incentives and how you reward these validators. I'll get back to that a little bit later on a bit more technical note, sort of how this is implemented both in the proof of like the one I did in the hackathon, but also sort of how I'm doing it in the more production ready version is that I have a sidecar process that basically that the validators run together on the node and they basically query the full nodes that they set up. The sidecar connects to the chain itself through using ABC I from common PFT and injects this information using vault extensions. And yeah, these vault extensions, they get tallied up. And if it's correct and everyone agrees, then the lite clients get gets updated.
00:07:03.546 - 00:08:46.180, Speaker A: So the lite client verifies that the required security has been reached and that everything is okay. And then you just have a lite client that has all the information you need, and you can just do IBC using existing tooling and nothing really changes for the user beneath here. So that was one of the core things that I wanted to do with this, was to leverage everything that already exists in the cosmos ecosystem as far as tooling and relaying and all this. And what is actually interesting about this is that the way that this pessimistic lite client is set up is that it's not necessarily, it doesn't need to actually run the same type of, type of proofs on the Merkle tree and all this that currently the tendermint lite clients required today, because we can actually just have all these packets that the validators see, they can commit them to the light client. And as long as you have some sort of relayer that is able to post or to send these packets, you can do it with any chain that implements IBC. And that means, for instance, that you can do IBC directly to an EVM chain, actually to Ethereum as well, with no real change to how this is set up. The main thing you would need is of course IBC implemented on the EVM side, which there are already some pretty interesting proof of concepts using sp one.
00:08:46.180 - 00:10:20.800, Speaker A: So you can have a live client on that side that solves packets that way. But packets from the EVM side would basically work out of the box with this. And the only real difference in this system to enable that is just so in the sidecar, it has implementations for different types of full nodes basically to query and what the assumptions that it needs to accept new changes and how it looks for them. So for Cosmos, it's pretty simple stuff, and there exists a bunch of different tools to do this also with ethereum chains, and then you can just make sure that the chain has reached finality before you actually submit the packets back to the lite client. I'm also mentioning IBC lite here. That name will not stay, but there is some work happening within the IBC team with a more, how can I put it, more simpler version of IBC that requires a lot less implementation details, but keeps the same security assumptions, which would make bridging to Ethereum even simpler. And yeah, you can actually go on the GitHub and look up the current work that's happening there, and there is more information coming out very soon as well, so keep your eyes peeled for that.
00:10:20.800 - 00:11:27.252, Speaker A: And yeah, I just wanted to go a little bit back to what I was talking about earlier. This is kind of deep in the like IBC protocol or implementation, but basically before you can send a packet, the lite client needs to be updated. And that's done through what's called update client. And the main thing that it does to verify the state changes is through this verified client message. And basically what the pessimistic lite client would do is it would get a bunch of IBZ packets, probably some state routes, some different stuff that it would need to verify, and then it will just verify that all the validators have signed off on this using basic cryptographic stuff. And then you can save that to the consensus state. And when you receive a message, you just make sure that the IBC packet in question, which is basically a hash using a different bunch of different parameters, that it exists.
00:11:27.252 - 00:12:51.210, Speaker A: And if it exists, then you can trust that this packet has, has actually been committed and exists on the counterparty chain. So it's relatively simple stuff and it's quite generic, which is why this also would work with Ethereum. And I haven't really looked deeply into it, but I don't see any reason why an IBC lite implementation on Solana wouldn't work or whatever chain, basically, as long as it can implement the IBC standard and the IBC packets, which will be even easier in newer versions of IBC where you don't need all the proto stuff and all this. This will basically work anywhere where you can't just have a normal lite client that we use today. In terms of security, it's basically the exact same security assumptions that any other IBC connection today uses. It relies on trusted committees on both sides to have signed off on the states, and that you can verify that the state changes are valid. But that will basically be the same because it also relies on the trusted committees to commit that.
00:12:51.210 - 00:13:58.480, Speaker A: And basically what would happen if the sequencer started posting data that is not valid. So basically a fraud, the full nodes would not accept those changes and would just stop committing new stuff and can also just immediately shut down the lite client as well, which would halt the entire, the entire connection. In addition to that, what I'm planning to do is to add, like if there is a fraud proof that gets submitted, and it's provable that you can slash the validators that actually accepted changes that they should not have. So that makes it easier for them to, it makes them incentivized to actually run this, to run full nodes and to actually verify them. If they relied on anyone else, then they're, well, they're putting their funds at risk. In terms of economic model, it's bits. I'm still designing this.
00:13:58.480 - 00:15:36.066, Speaker A: I'm actually thinking that for incentives, there's a lot of IBC fee middleware and things that's been worked on in that that can actually be reused here, especially since the validators that update the live client, they have full control over what they can accept according to whatever the protocol implements and a protocol could implement that. It requires that these IBC packets have a fee packet alongside it. So that's all the messages that actually come across have been incentivized and that's kind of needed because why else would these validators actually take the cost of running these full nodes? Yeah, in terms of slashing, non participators should at some point be slashed or something. And of course, what I talked about earlier with fraud proofs, another actually, just before I go forward, one more thing that's kind of interesting about this is that since these validators are basically, they're running fully on this chain already, they're running full nodes of the other chain, and they're connecting this information into the chain through these vault extensions and stuff. What they can actually do at the same time, which I'm planning to get in there as well, is that they can actually do relaying at the same time. So they can. You actually, in this setup, wouldn't necessarily need to have external relayers.
00:15:36.066 - 00:16:44.088, Speaker A: You could have all the packets and everything committed and applied on both sides very easily because you basically have sort of an overlap of the validator set in a way. So it's also way it would also speed up things. And of course, you wouldn't rely on validators who would need to fill up their balances and all that. Relayers, I mean, but that's more of a side note to make this even more interesting in terms of how this could be set up, just using Cosmos hub as an example, because it's like if they want to be sort of a liquidity hub for the modular ecosystem, they could, if they implemented this and had all these different roll ups connected to it, they could very easily have all these funds routed through the hub. And especially with the new version of the transfer, or ICS, V two. Ics 20, I should say there V two, which now has multi hop transactions embedded in protocol. You don't need middleware anymore for that.
00:16:44.088 - 00:17:49.104, Speaker A: And you can automatically rewind it. So if you have a roll up and you want to send it to osmosis, it would be one transaction, and if you want it back, it's also just one transaction and it gets automatically routed through the hub. In this scenario, it could also be implemented as a consumer chain. AV's on the hub as well. The other example, which is a bit closer to some other stuff I'm working on, is that, for instance, Stargaze could very easily implement this as well and have all these different NFT roll ups, some of which are definitely coming seal academ. There will be a panel on that later today. And they have the same problem in terms of how to get these packets routed securely because like in the laser chain example, the slots will bridge to this roll up.
00:17:49.104 - 00:18:39.612, Speaker A: And to be able to bridge it back, you need to have the security there. Yeah. And again, also for stargates, it kind of makes sense to have an ethereum connection to get all the things that are already there. I'm not really going to go through this now, but it's, if you are familiar with how gravity bridge works, it's actually very similar. They also run some sort of sidecar process that's with Ethereum node. And the main difference there is that they have this special gravity module where they keep the attestations and they have a special smart contract that deals with this and can only do token transfers. In this version you have sort of the same thing in a lot of ways.
00:18:39.612 - 00:19:26.926, Speaker A: The main difference is that it's actually just normal IBC instead. So it looks like the same picture, but it's really not because, you know, IBC. So that's, I think that also is true for a lot of other bridging solutions that exist today that rely on all kinds of unproven, and I'm not going to say shady, but different kind of security assumptions that IBC can do a lot better. So I think being able to do this brings a lot of benefits in terms of security and tooling. So, yeah, in conclusion, optimistic roll ups dispute. Windows can be solved using this. Any chain that can implement IBC in some way, it can be smart contracts.
00:19:26.926 - 00:19:52.350, Speaker A: It doesn't have to be IBC. Go can connect with this. And it's actual true IBC without extra intermediaries. A lot of the, I'm going to say, so called IBC connections today are actually relying on a lot of intermediary stuff that makes me a little uneasy. So. Yeah, and that's it. Thank you all for coming.
