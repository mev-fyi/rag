00:00:01.760 - 00:00:36.346, Speaker A: I thought I made the title a little bit more fun, thinking the original title is a little bit boring. But the future of Gmove, I think it spin this thing over like three times a day, four times a day, and now time to be going a little tackle a bit. A walk through a quick agenda. Just glossary, context, problem solution architecture, and kind of where we're headed. Starting with Glossary, I think we'll start off with a sequencer. I know we've been chatting with Astria Espresso, a few of these other sequencers. No, we're not a shared sequencer business, but I think we're entering this era where a lot of these L2s are coming out with their own shared sequencers.
00:00:36.346 - 00:01:04.042, Speaker A: You have optimism. Super chain. You have Zksync working on a super chain. Agular itself is working with a few shared sequencers. So for move Ins network, we envision a network of high throughput rollups that all want to share state and sync across. The biggest issue with this, when you have thousands of rollups, especially those are different vms, is how do you sync state across rollups? Specifically, state finale guarantees, which I'll get more into later. We have m one, which is our decentralized ecosystem network.
00:01:04.042 - 00:01:31.720, Speaker A: We have the movement l two itself, which is kind of the main bread and butter VM as a virtual machine. I don't think I need to explain this, but it is the execution layer where folks deploy apps. If you're using uniswap curve aave any of these things, you're probably on the EVM. And then with this modularity thesis, we've seen a cambrian explosion of different vms. We have the Solana VM, the movevm. We have VAWSM based vms and future vms coming to market. And we're all here for experimentation.
00:01:31.720 - 00:02:04.624, Speaker A: The moon SDK is a software kit to execute smart contracts on the L2 itself. The moviem itself is. I'll get more into the kind of history and where that comes from. Fractal is the EVM interpreter. So I think the one thing that we specialize in, I'll go into architecture as well, is we recognize the new tech is pretty cool, but it has to have backwards compatibility. Majority of developers today are solidity. So the question is, how do you onboard new developers and new apps? I think two of the layer ones, apparition Sui tried bringing move to market, but it's a slow process, teaching people languages.
00:02:04.624 - 00:02:33.120, Speaker A: Solana took four years to kind of kick off and took some time. The first Solana wallet, if you guys remember, it was pretty poor and then it took like two or three years until infrastructure got there. And move is still in that early nascent stage where infrastructure is still developing, teams are still developing. So it's important to also have even compatibility, which is where fractal will get into da lair. I don't think I need to explain this to you guys. I think Nick White can explain it better than I can. So context solidity is the most commonly used smart contract language.
00:02:33.120 - 00:02:49.610, Speaker A: Most people who've written it probably hate it. There's over $7.6 billion lost so far. Increases the barriers to entry. But more importantly, this chart. This chart is a loom groom in why none of your parents, family, or anyone can trust crypto. There's over four and a half this year in billions lost.
00:02:49.610 - 00:03:22.826, Speaker A: Billions lost in hacker attacks this year. Some of notable exploits or private key compromises, risky attacks, flash loans, math mistakes. Like, 2% of all attacks in crypto are just because you added the wrong number. So it's like if you did 256, if the 256 bit limit, and you did 257, congratulations. You lost $50 million in traditional tech. If you get hacked, like when Facebook and Mark Zuckerberg started Facebook, you just lose a few files and it's not the end of the world. You get hacked in crypto, you lose your entire user base and most importantly, trust overnight.
00:03:22.826 - 00:04:05.350, Speaker A: Because crypto is so reputation based, it's extremely important to have security, especially at runtime. So part of the work we're doing at movement is to really bring the security landscape to the forefront, where users, developers, can trust the system that we're building, and modularity itself can bring security to the forefront of discussions. So context for those that aren't familiar, there's a DM program around six years ago, Facebook essentially put a billion dollars in the blockchain. I was like, we're going to have a Facebook blockchain, essentially USDC or their equivalent, floating from New York to Thailand to the speed of light. So you didn't need to send WhatsApp, you didn't need to send PayPal out of Venmo. You could do it within Facebook itself. And all these partnerships and all this work laid out, SEC is like, nah, you can't do that.
00:04:05.350 - 00:04:42.070, Speaker A: Thanks, Gensler. But the language was still really powerful, right? It was a new paradigm of resource oriented programming. You have form verification built into runtime, and most importantly, you also have block STM. A lot of the parallelization engines that you know and love today, like Monad APta, Sui, et cetera, are all variants of this original research done by Facebook, which was this optimistic parallelization engine known as Block STM. So Mov does is brings the security and speed in one vm, and our mission is to bring it to Ethereum. So can we enable safer, smart contracts within Ethereum? Can we bring move to Ethereum? I think so. And our solution is a moot based roll up on Ethereum.
00:04:42.070 - 00:05:06.542, Speaker A: I won't get too into rollups because I think we've kind of nagged on a lot. But there's two main categories of rollups. You have optimistic rollups, which have prop roofs and challenge periods. And you have ZK rollups, which are validity proofs. Fast but computationally expensive. I think most of the roll ups coming to market in the early stages, like arbitrum, optimism with optimistic proofs, optimistic rollups. And then you had ZK saying scroll bringing ZK roll ups to the market.
00:05:06.542 - 00:05:33.070, Speaker A: And we're kind of in this weird stance because now we have these next gen roll ups coming market. So you have optimistic ZK and next gen rollups. The question is, what's the right architecture? Is it optimistic and ZK? I would still say we're pretty early on where it's still very competition expensive to do a ZK movie or ZKsVM. If you had to write custom circuits, it's probably a three year project. It's a whole different company. Honestly, we barely even solved it for the EVM. So doing it for next gen vm is rather difficult.
00:05:33.070 - 00:06:02.980, Speaker A: I think a good middle ground that we reached is ZK for all proofs, which kind of blends the mix here, where it's still an optimistic role technically, but you can use validity proofs in ZK when you're doing challenge periods, so you only use ZK when you need it. And that's kind of where we're getting into and kind of blending it. So for starting, we're going to have optimistic roll up. But the 6710 year endgame is a fully end to end ZK Rollup. And I think a lot of the ZK researchers agree that the endgame is ZKdev. We believe in validity proofs. It's a little difficult to get there, but I think we're getting there.
00:06:02.980 - 00:06:30.400, Speaker A: And that's also ending up for movement. So the final architecture is move based ZK Rollup. We say ZK fraud proofs to start off with and then migrating to a validity proof network eventually. M two makes the most sense because, a, you have all the benefits of safe execution environments like move with the high throughput paralyzed environment. With Ethereum, it's kind of the best of both worlds. Wherever. If you built on aptos and suite, you might have been pushed off by a lack of liquidity, maybe the vibes.
00:06:30.400 - 00:06:56.830, Speaker A: But the two main issues for building apps and these new layer ones is a acquiring liquidity and b acquiring mind sharing user base. For context, I built the first Dex in Aptos. This was August 2022, and it was pretty awful. There's apt and testnet Dex token, which meant that Dex was kind of useless. No one wants to trade one and a half assets and doesn't really get anywhere. So same Dex can deploy on top of movement. You still get all the benefits of move.
00:06:56.830 - 00:07:28.980, Speaker A: We have native ETH directly from Ethereum. You have low fees because of celestia and alternative das. So you're able to bring essentially different parts of stacks in one combined environment. So you have all the benefits of Aptos and Sui while living on Ethereum with liquidity and security while still having low fees. So this endgame is when we can finally have these L2s challenge the throughput and security and speed of layer ones. And we have a few folks do for the SVM, MovevM, paralyzed VM and the next gen is the future for sure. A little bit in architecture.
00:07:28.980 - 00:07:55.306, Speaker A: I'll kind of walk through everything. I know I have ten minutes, but the movement SDK is where the main block building happens. Proof of marketplace is kind of on more on how we generate fraud proofs and validity proofs eventually on and how we settle on l one. So the even compatibility is kind of the bread and butter because a lot of you guys are like, okay, move is dead. There's like five move developers and argue that's true. It's very difficult to build a new language. Solana was barely able to do it and they pulled it off.
00:07:55.306 - 00:08:23.494, Speaker A: Most other alt programming languages can die off. I think there's a cause of two issues. A, there's no backwards compatibility if you're a solely developer right now. For most L1 s, even if you want to try the ecosystem, it's pretty difficult to do so because you need to learn new language. You need to learn new kind of SDKs. There's so many programming languages, so why would you do that? And secondly, the kind of go to market strategy is relatively difficult because you can't give people the taste of ecosystem. You're pretty much isolating yourself so that you yourself and your five devs.
00:08:23.494 - 00:08:43.568, Speaker A: So that's why some of the L1 s have issues with movement. We have full end to end EVM compatibility at the bytecode level. We support slitty smart contracts as well as move smart contracts. Compile them to one byte code and settle them on the moviem. Here's a little bit how that translation process happens. I won't get too into it. You can ask questions if you're interested.
00:08:43.568 - 00:09:10.664, Speaker A: But essentially you take the slowly script, parse it down to ast, which is abstract syntax tree. It goes to intermediate language called Yule, which is more similar to assembly. You map those UL op codes so you have 142 slurry opcodes. You map those to the 54 move opcodes and you deploy them on top of VM itself. It's similar to soling on Solana, but actually useful. And then I think similar to Neon. I don't really know what's up there, but it's completely end to end compiled SDK level.
00:09:10.664 - 00:09:27.856, Speaker A: So it's not a bridge at all. I think Neon is more of a bridge from Solana to EVM. Not too sure this works at runtime. There's no latency issues. So I would say 60% of the ecosystem right now is EVM, which is fine. We acknowledge that there's very few move developers right now. We're going to work our asses off to get more moved.
00:09:27.856 - 00:09:49.546, Speaker A: Monitor. The goal is 10% by end of the year. But even if you don't like move, you can still be in movement. Go through this. So decentralized sequencer is pretty hot topic. Some people say centralization sequencers are the end game and we want to prioritize UX. And some people say decentralized sequencers or share sequencers the future because you want Interop.
00:09:49.546 - 00:10:11.676, Speaker A: I would say the correct answer is both. If you're gaming a role prioritizing high throughput rollups or high throughput capacities, you should choose a centralized sequencer. Today, if you use a decentralized sequencer there'd be latencies and trade offs and you don't necessarily need a decent shared sequencer. If you're building a fully on chain MMO. You don't need to have composability with a yield aggregator. It doesn't make sense. You're focused on user experience.
00:10:11.676 - 00:10:26.152, Speaker A: You don't need to take the latency. I think. Secondly, what's really interesting is there are use cases that need shared sequencing. For example, if you yield aggregator roll up. Imagine if urine launched a roll up. They want people composed with other assets. Maybe it's the Gamefi assets they want to roll in.
00:10:26.152 - 00:10:55.190, Speaker A: Maybe it's or book assets they want to roll in. And for that, shared sequencers are really important. Commonly the issue is if you have a bridge, you have to read like clients from each different roll up, which kind of low, slow, clunky and bad ux for the first time. If you have shared sequences, you can restate directly from the shared sequencer itself. So for us, we have a stack, which is execution layer stack. You can use whatever role framework, use our DA, and then use the MovM and connect to the shared sequencer. That way you have one unified execution layer and one sequencer to connect.
00:10:55.190 - 00:11:21.312, Speaker A: If you don't want to use the shared sequencer, that's fine. We'll still love and embrace you, and you can still be part of the community. But we believe that there's a lot of use cases that demand shared sequencers. So the end game is kind of this both economy where you can choose whatever you want, build whatever, but there's some use cases, and I would say most use cases actually would prefer shared sequencers. And most importantly, we're getting into token economics here. Most L two tokens are meme coins. They're just governance tokens that have no actual value accrual.
00:11:21.312 - 00:12:01.902, Speaker A: What's really interesting is when you decentralize a sequencer now you have mev, you have robustness, you have censorship, resistance, you have all these principles that we work so hard for, that's not just one AWs node that's running billions and billions of dollars. So I think Stark had just announced today that there's enabling staking. All the roll ups will eventually decentralize. Yes, arbitrage is making billions off the sequencer, but the end game is decentralized sequencers and finally giving value accrual back to tokens. So m one, as it stands right now, is a common BFD ten mn consensus. No, it's just not another consensus Cosmos chain we slapped on. What's really interesting is a lot of the shared sequencers are working transaction finality.
00:12:01.902 - 00:12:38.252, Speaker A: But that's not the main bottom line for shared sequencers. It's state finality guarantees. If you're arbitrum trying to bridge to optimism, how do you ensure that the state is synchronous across different roll ups? Right now, there's no real solution to that. There's two main proposal solutions. It was either ZK state proofs, which what Lagrange is working on, or you need economic guarantees to back up the state between rollups. So what gets really interesting here is you can actually make the shared sequencer fundamentally get a staking hub where if you have four different roll ups, all joining one shared sequencer, they can all delegate x amount of stake. So if I'm arbitrum, I can delegate a million dollars worth of arbitrum to this shared sequencing poll.
00:12:38.252 - 00:13:07.226, Speaker A: Optimism can delegate op a million dollars worth and then you have to be honest about your state finality, otherwise you will get slashed. So that state finale guarantees introduces a new paradigm. It's very, very R and D. I will preface this. It hasn't really been implemented, but it's something that our research team, our head of research, worked in mental and designed their shared sequencer implementation. But it's something that we're thinking to, because if we're ever going to get this endgame where people actually care about shared sequencers, transaction finality is not the main issue. It's state finality guarantees.
00:13:07.226 - 00:13:48.518, Speaker A: So how do we get there is the main question for us. So yeah, proof of stake again, native staking token is what gets me up and going. How do we make l two tokens actually great again? And staking is the way you enable this. You have, if I'm a validator, I stake the move token or alternative tokens to receive emissions, and then I get transaction fees from multiple roll ups, and then I can use that tokens to run more and more nodes. So you actually have l one principles that can be applied to L2 solutions, which solves a lot of the paradigms we're seeing, where L2 tokens don't really scale and don't really compete with layer one tokens. But now I think we're entering this mechanism where we can have creativity, we can have mev, we can have deep, deep mev research. Imagine Gito for arbitrum.
00:13:48.518 - 00:14:21.028, Speaker A: That'd be pretty cool, right? So yeah, multistoking, multi taking, stoking native da tokens, et cetera. I know I have three minutes, so let me go into the ZK side again. Another research article or research part that we're looking into, ZK next gen is pretty difficult to do. I think we benchmarked, there's still costs around four to $0.05 for a transaction using mysterious latest benchmarks, which for us is pretty expensive considering our transaction fees are a cent to $0.02. We're trying to get there. So right now, I don't think ZK is there for Zkmove or ZKsVM, even though teams have implemented it.
00:14:21.028 - 00:14:47.458, Speaker A: There's a team that did it for Halo two and it was pretty expensive. But I think Succinct is working on making it more accessible. So we're looking to percentage research with them where provers can generate proof. Right now we can use planky three for moviem. Right now planky two is the past example, but with SuCync you should be able to do ponki three with field encoding, custom gates and optimizations. The main thing is having recursive proof generation. But until we get there, ZK for all proofs are pretty good.
00:14:47.458 - 00:15:38.610, Speaker A: Again, most users don't care ability proofs or how decentralized the proof generation is, they just want great user experience. So ZK for all proves and optimistic rollups are good enough for the time period. And then once we get the point where ZK proof generation is cheap, and most importantly, proof verification is cheap, we can get to a point where Camzie can move and ZK next gen vms. Yeah, other components obviously selling on Ethereum you have a validating Bridgemark contract and full nodes. Let's see what else. So yeah, where we are today and what we're launching Tesla in two weeks public testnet. We had private Testnet go live a week ago, have our core teams building on intermediate goal is movement as optimistic roll up ZK fraud proofs execution movement SDK sequencing with our m one network data available at Celestia and then ZK proof generation with rist zero right now.
00:15:38.610 - 00:16:08.446, Speaker A: And we're next. Having our SDK go live, having the ZK roll up go live. Hopefully we can get to a point where proof generation verification is down so we can have fast high throughput roll ups with Zkhdem and they shared sequencer and finally use cases for Infra. I think yesterday we announced the first or the movement phone. I don't know if it's the first move in Avone, but I think mobile is really where we're getting at, where there's final use cases for apps. We have high throughput chains, high throughput environments. We have a team based in Kyoto that sold 10,000 phones already.
00:16:08.446 - 00:16:23.140, Speaker A: It's cloud network. HQ should check it out, but they can have a fully on chain decentralized deep end product. Going to pick up a lot of steam in Japan. But yeah, use cases for infra enabled by high through infra and yeah, getting right there. Thank you.
