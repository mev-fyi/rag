00:00:02.520 - 00:00:20.650, Speaker A: Okay. Hi everyone and thanks for coming. We want to talk about the rolekit. This talk was supposed to be given by our team lead, Mano, but he couldn't make it. So he is here with me on the phone. Mano, say hi.
00:00:21.750 - 00:00:24.270, Speaker B: Hey everyone, I'm here.
00:00:24.390 - 00:01:12.186, Speaker A: Yeah, we do answer any questions. Okay, so let's talk about Rolekit. So first, I think everyone knows what Sovereign roll up is at this point, but I just want to emphasize one more time, the point of first of all, the whole modular paradigm is to decouple the execution from the consensus. And usually we separate like four different levels. Execution, settlement, consensus, da, data availability and sovereign roll up. Not like the roll up which settles on some l one. Sovereign roll up takes care of its whole sentiment.
00:01:12.186 - 00:01:48.400, Speaker A: So it decides what is canonical chain. It resolves disputes and have its own governance. So that's the key point. And yeah, the most important thing that makes it sovereign is the ability to hard fork. And no, they don't have to, they are not forced to hard fork. Actually they can choose if they want to upgrade to the new software version and if not they can just stay and have a fork. Yeah.
00:01:48.400 - 00:03:05.760, Speaker A: So here Rolekit comes into play. So what is Rolekit? This is the webpage we have on the website, the main page of our website. And the point of Rolekit is to empower devs to be able to launch sovereign customizable blockchain as easily as smart contract. So it allows, it's a module, it's in a module stack and it gives the speed and ease of doing this because you don't have to take care of many things such as spinning up validators, taking care of consensus and stuff. Yeah, it's open source, by the way, so everyone can go to the GitHub and see what's going on there. What are we working on? There is a project which shows what we're doing right now and a bunch of issues. And our goal is basically, as I said, to allow devs to create new classes of rollups very quickly, not in weeks or months, but in days or even hours.
00:03:05.760 - 00:03:38.842, Speaker A: Okay, so what is Rolekit briefly? First of all, it exposes ABC I client. So it's basically a common VFT replacement. So you can, first of all on the website, I'll get back on the website. You see we have three main points. Build with the best, optimize for your needs, take control. So the point is that people got to know, get used to the Cosmos SDK ecosystem. Cosmos ecosystem.
00:03:38.842 - 00:04:32.230, Speaker A: They use Cosmos SDK. It's proven to be reliable and good. And Rollkit is a replacement for the common BFT, which means that you can actually migrate your existing blockchain project to rolekit to become a sovereign roll up. And also it's a modular software in terms of, not modularity in terms of blockchain, but software. So it means that it has a bunch of interfaces and it's very customizable. It gives you freedom basically to substitute the data availability layer, for example avail or Celestia, or another interface which is sequencing. So right now we support centralized sequencer, but we're working on shared sequencing.
00:04:32.230 - 00:05:35.590, Speaker A: Also IBC client, also state machine. So everything that is ABCI that implements ABCI can be a roll up, for example custom bus or like some EVM or I just Cosmos SDK app. And it could be done in different languages as it's protocol buffers, so it's agnostic from the stack. And why do you use Rolekit? Basically, as I said, it has the interchange stack, Cosmos SDK, IBC, ABC, I unlocks block SDK and connect built by SCIP, which lets you implement stuff which was not possible with pure ABCI. And yeah, it's a common BFT RPC equivalent, meaning that you can replace it back and forth if you want. So if you want to just give it a try, you can do it. Yeah.
00:05:35.590 - 00:06:46.500, Speaker A: Also it's very customizable and it allows you to do things like change the speed of block reduction or let the roll up work on the so called lazy mode, which means that the block are produced only when there is something like, or once a minute, for example, D layer could be chosen. And yeah, we're working on sequencing, delegating sequencing. Yeah. Fast time to market and the sovereignty, which is the most important. So let's talk a little bit more about these interfaces that we have. So as I said, DEA, it's an interface for the underlying blockchain, which is the data which serves as data availability, not just storage, bridging IBC client sequencing. Right now we support centralized, working on shared and based sequencing as well, and different execution environments such as EVM WASM or different other kinds of VM.
00:06:46.500 - 00:06:58.440, Speaker A: And we also work on the state validity mode. Right now it's pessimistic, but we work on two others, like optimistic and ZK Mana, do you want to add something?
00:07:01.510 - 00:08:04.748, Speaker B: I would add that. So currently the state machine, anything that Cosmos SDK, anything that uses Cosmos SDK can use Rolekit. Like right now, mostly Cosmos SDK is used with common BFT, but RoleKit acts, as you think of it, as a kind of drop in replacement to comet VFT which turns your application to a roll up. So it's a different consensus engine and we're sort of modifying it to add different, all these module components that you see on the slide. We're modifying it so that it can support all these things. So you can pick and choose your modular component as different teams compete in their own category. Just want to add.
00:08:04.924 - 00:08:45.184, Speaker A: Yeah. So the point is that you can switch and experiment so it gives you flexibility. Okay. Also you don't need to have upgrade keys when you so avoid l two s cancel multi seq on the bridge, contract on the l one supplement layer. So it's a centralization risk. Yeah. So with sovereign roll up you can choose basically if you want to participate in grade or not like in l one because you're not settling on other protocol.
00:08:45.184 - 00:09:28.160, Speaker A: So you don't need upgrade keys for bridging on trick ability to hard fork. Yeah, as I said, ability to hard fork and no extra settlement cost. That's right, because sovereign rollup, they have its own settlement. And rollkit by the way has a full node which does the execution. So that's why it's our own as well. Okay, I want to walk briefly through the transaction flow that we have in rollkit and explain what's going on. So first of all we have few types of nodes.
00:09:28.160 - 00:10:10.690, Speaker A: As I said, aggregator or sequencer, blocker user is the same. Aggregator node is responsible for building blocks. It also does the execution. But it's the node that is responsible for producing blocks, for ordering transactions. So user submits transaction to any kind of node, it's being gossiped and gets to the aggregator node, to the mempool. Aggregator node rips the data from mempool and creates data headers and packages them into the blocks. And it gossips back to two different nodes like full node right now.
00:10:10.690 - 00:10:57.044, Speaker A: Yeah, light node is still work in progress but it's on the diagram. Yeah. So after that sequencer or aggregator node publishes the block and the header to the, to the DA. Yeah. During that time or even before that the nodes already received this block and they can actually do the verification. They can either verify header or verify header, verify block data and PFB commitment. This is something we call soft confirmation.
00:10:57.044 - 00:11:51.036, Speaker A: So if everything is fine and the state transition is valid, we say that it's soft confirmed but it's still not included into the DA block yet. So after that, after that, those nodes that already process this block, they can fetch, they can retrieve data from the DA layer and if it's there, it means that it was included, and it's the point when we can say that it's hard confirmed. So it's basically like finality for this block. It's final for this block. So it takes time. First of all, the finality, the default finality for the block is 1 second. But for example, for Celeste it's 12 seconds.
00:11:51.036 - 00:12:33.930, Speaker A: Means that it starts confirming. It could be soft confirming after 1 second, and in the worst case, 12 seconds for hard confirm. Okay, let's move on. Let's dig deeper a little bit into the interface. So we use Goda and it exposes seven methods. It's an abstract interface that allows to have a drop in replacement for De, like celestia. Right now we use two methods, which is get and submit, and what get does for the nodes.
00:12:33.930 - 00:12:49.650, Speaker A: It allows you to basically get the blocks like list of blocks by ids and by specifying namespace id and submit submits blocks, basically. So it's pretty simple. Yeah. Mano, you want to add something or did I miss anything?
00:12:51.110 - 00:13:36.970, Speaker B: Yeah, so just to mention any DA layer. So rolekit just interacts with the DA interface. So anyone can have an implementation for this DA interface and they can use that layer as a DA layer. So currently we support, we have a local version for testing and we support Celestia. We have implementations for avail, Celestia and bitcoin, but anyone can theoretically add that implementation to this d interface and rolekit. Just work out of the box with that. Yeah, that's another.
00:13:38.300 - 00:14:27.412, Speaker A: Yeah, that would just require basically to implementing the interface. Okay, let's move on. Yeah. Open source contributions are welcome. As I said, you can go see what we do right now at the project tab, and you can see the issues which are marked. Okay, now what I want to do actually is a small demo. So first of all, we want to showcase the modularity aspect, when you can substitute and swap different components, for example, the ones that are implemented by interfaces like state machine or DA.
00:14:27.412 - 00:15:12.020, Speaker A: And the plan is to first go through our website, do the tutorial, and show how we do the no op state machine, just with the wine liner. Then I suggest we try to spin up the custom blossom as a state machine, like a custom blossom roll up. And later I want to show how it's done, how we can swap the local DA, which is like a mock implementation of the DA, to the celestia for Cosmos SDK. Okay. And after that we may have questions and maybe do something more if we have time. I think we do gonna have time as it's just 16 minutes. Okay, so let me actually make the full screen.
00:15:12.020 - 00:15:43.890, Speaker A: So here on the website we have a quick start and it's pretty simple so you can try it easily. First you need to actually refresh here. So the version is the latest. What you need to do, you need to just run the script to install the rollkit. It's already installed for me. Let me actually check that. Let me make it a little bigger.
00:15:43.890 - 00:16:02.300, Speaker A: So rollkit version is 13.6. So how would I run this is just by doing role kitstart. That's simple. So if I do roll kitstart. Ok wait, no pierce. Ok let me try it again. Yeah, so let's stop.
00:16:02.300 - 00:16:34.620, Speaker A: So what it does it just first of all let's see. Service start. Yeah, and it starts, it has no seed nodes, working in a creator mode, default mode, and it starts creating and publishing blocks. So we run it before. So that's why we have height 384. Okay, pretty simple, everyone can do it. Now let's try to do a little bit more complicated with custom awesome.
00:16:34.620 - 00:17:27.148, Speaker A: So on the editorial section we have section for the execution and we have a custom buffering roll up. So what is cosmosm? It's basically a webassembly engine that allows you to have a virtual machine which is cosmos SDK compatible. And we will try to integrate this with the local g. So before that, maybe a few weeks ago we had a little bit bigger tutorial which was covering all the steps. Right now we switched to kurtosis. So first of all, what is gryptosis? It's a tool for packaging and launching environments of containerized services where you want them, how you want them, and using just simple command. So, and yeah, and we released, we made it a package.
00:17:27.148 - 00:18:37.442, Speaker A: So if you go to this website for example to this repository, custom awesome. Roll kit, custom awesome over here. Yeah, here it is like a small repo with the two files, kurtosis YAML which specifies what is this package, and main star which actually explains what should be done under the hood. So if we didn't use kurtosis, we would need to spin up the local DA, manually building it and running it, and same for the wasm D. And here you can see this is the python script where we start the DA which is imported from another repository by the way, local DA, let's look at this as well. Yeah, so make, build and build local DA which would spin up the DA on 7980 and custom was some ports and the start command bosom D start. So it's Roku aggregator mode da address.
00:18:37.442 - 00:19:07.420, Speaker A: This is the way we specify how to connect to the local DA using this flag, RPC, GRPC, PtP. Okay. And if we wanted to run, for example, real da like available Celestia, we would need to specify a few different flags. But we'll get to that later. And that's it. Let's try to do it. I think I had it somewhere over here.
00:19:07.420 - 00:19:47.396, Speaker A: Slide client. Okay, let's just follow tutorial and see how it goes. Not here. Over here. Okay, let's do kurtosis run. So it created an enclave, dry chassm, just random name started the engine. Now it spins up the local DA and the custom box roll up itself, which is like prepared for that.
00:19:47.396 - 00:20:11.440, Speaker A: So let's do Docker P's. So it uses Docker under the hood. And as you can see, we have a custom. Awesome. Which is this container running on port, exposing some mapping, some ports. Yeah. And I.
00:20:11.440 - 00:20:56.684, Speaker A: The port for the local DA as well is mapped 7980 and some more stuff, core stuff. Okay, now let's do this. First of all, yes, I did Docker P's. Let's try to write the variable, the name of this container. And yeah, we may do actually later on we may just try to deploy and do some interaction with the contract actually in that right now, I just want to do docker logs to see the logs of the running. Okay, this is the Roku logs of the running. Custom asmrlab.
00:20:56.684 - 00:21:38.056, Speaker A: As you can see, it does block execution. Okay. Okay. Now if you want, we may come back to this later and to play with the contract a little bit. Now I want to show how we swap the DA component, Da layer. So for that, I suggest the easiest would be to just follow the tutorial as well. So if we go to the RoleKit wordload app here, there is a big tutorial which uses ignite CLI.
00:21:38.056 - 00:22:08.370, Speaker A: It allows you to scaffold with ignite the chain. Then we do some. Yeah. By the way, we have ignite app, it's called Rolekit. And you can just add it to the scaffolded app, Cosmos SDK app, and it will be included. And basically before that we need to replace in a go mode the common BFT. But right now you can just do this and it will do the same.
00:22:08.370 - 00:22:28.484, Speaker A: It will replace the engine. Okay, so I did all that. Right now this tutorial is pretty interesting. It does some changes to the keepers, to the logic. Basically the Cli warnal game. Yeah. And over here we need to run the local DA.
00:22:28.484 - 00:22:57.988, Speaker A: I think we already have the local da running. Yeah, it's already running from the previous from the previous roll up, which is still up. I might actually kill it. Let me. No, I'm not going to kill it, I'll use it. And this is the command, how would I build it? So I need to ignite chain build. This would just build my binary and initialize the chain config using ignite rolekit init.
00:22:57.988 - 00:23:28.530, Speaker A: And I specify the flag local day because of locald. So let's try to do it first. I have wordle over here. Ok, this is the wordle. Let's try to do like this. Okay, so it installed word d binary and it added chain config over here. Okay.
00:23:28.530 - 00:24:31.048, Speaker A: And here's the genesis by the way. Okay, now what I want to do using the roll kit cli itself, I want to create some configs. I think it's already there but yeah, I'm going to remove it for now, let me make it a little bigger and I'm going to do rope. It only needs, okay, so what it does, it just specifies the entry point and the directory where the configuration is. So we can maybe move it or we can run this, the rolekit sub command from any other subtree like any other place in the subtree, and it will resolve the correct binary, the correct roll up and the correct genfig. Okay, now how would I run this roll up? What I need to do is rocket start, which under the hood would spin up this world d binary basically. But now it's called entry point over here.
00:24:31.048 - 00:24:57.018, Speaker A: Yeah. And we specify the DA address which means that we specify where to connect. Let's try to do it. Okay. Okay, this is it. And the rest of the tutorial is for, we could spin up, open another terminal and try to do some transaction submission and stuff like that. It's very interesting, anyone can follow it.
00:24:57.018 - 00:25:43.932, Speaker A: Now I want to try to switch from the local DA. Let me get that. Yeah, from the local DA as I specified here, to the celestia for example. So for that I need to spin up the celestial node, celestialite client, which is, I pre installed it actually let me go here and show a little bit. So this is another tutorial which tells you how to run, which points you were to get information, how to run celestial light node, we have different networks and yeah, it requires you to pass the previous tutorial which is GM world. We skip that, we just go over here. Yeah.
00:25:43.932 - 00:26:09.860, Speaker A: So how would I connect to da layer instead of local da? I would just need to remove the previous flag for the local Da address and put these three local rollkit da hideous. Both token and namespace. Okay. And this is the command, how would I do this? Let me do this. So first I'll just get the block height. I first start this one. Okay.
00:26:09.860 - 00:26:35.040, Speaker A: Now block height, auth token and the default namespace. Okay. And now I would do rocket start. Okay. Okay, it works. Okay, this is it. Let's go back to the presentation.
00:26:35.040 - 00:26:48.782, Speaker A: Now. I'd like to hear from you. Do you have any questions? And maybe what would you like me to play with? Or maybe actually mano has anything to say? You want to add some?
00:26:48.846 - 00:26:49.206, Speaker B: Not really.
00:26:49.238 - 00:26:57.934, Speaker A: That's great. Let's go to questions. Okay. Okay, do you have any questions?
00:26:58.102 - 00:27:02.030, Speaker C: Yeah. How does a state machine talk to rollkit?
00:27:02.110 - 00:27:04.570, Speaker D: And is it like weird to look at interface?
00:27:05.270 - 00:27:32.752, Speaker A: Yeah, so as I said, rollkit is a common VFT replacement. The question is, how does state machine work? Talk to rolekit through the ABCi interface. So basically it's initiated by the rolekit. So you know what AbCi is, right? Yeah. So it has to implement that basically. But under the hood it could be like any kind of state machine. You know, I can rewrite my own custom state machine that would just implement this interface.
00:27:32.752 - 00:27:43.830, Speaker A: And that's why you can replace it easily. You can just. Yeah, if I wanted to. Okay, go on.
00:27:45.570 - 00:28:27.212, Speaker B: We're working on something called generalizing this. So it's not just ABCI, it can be an execution interface. So like different vms, like the EVM uses something called the engine API. The SVM developers just released an interface called Anza API. Shop up to them. So you can have an interface where ABCI, engine API and ANSA are just implementations. And so a rolekit node can just talk to any of these state machines directly.
00:28:27.212 - 00:28:34.120, Speaker B: So rolekit is agnostic of the state machine. It's just think of it as just like the glue for all these monitor components.
00:28:34.920 - 00:29:00.180, Speaker A: Yeah. And I also, I saw Connor from Celestia have a repository which implements, which makes a rust implementation for this. So it allows you to like. Wait, wait wait. What was the name of this repository? I don't remember, I don't remember.
00:29:01.120 - 00:29:08.340, Speaker B: It's called cynoderium is the penumbra one. And then the one Connor had is called minnow.
00:29:08.880 - 00:30:06.800, Speaker A: Minow, yeah, minow, yeah. So, yeah, so it could be not just rust, it could be any language, basically just protobufs. Basically. Okay, any other questions? Yeah, as you can see, it's pretty simple, pretty easy to use. It gives you the flexibility. For example, can you repeat the questions? There are no questions anymore. I just say that rolekit gives you the flexibility and ease to ship faster, basically that you can just build the Cosmos SDK app, for example.
00:30:08.820 - 00:30:20.070, Speaker B: You can go to market really fast with a roll up and while having all the capabilities that you might be used to with a full fledged blockchain. So a roll up is a blockchain.
00:30:20.490 - 00:31:24.750, Speaker A: We discussed yesterday with now the scenario when you want to prototype and maybe settle on Rolekit for a while, and then you might want to switch to be the chain with a set of validators, its own consensus. And we decided, we came up to conclusion that it does make sense. It doesn't make sense to switch back from rollup, especially considering the final state of the roll kit. I mean, so right now we have many stuff in progress, but if we have sequencing API done, if we have proof schemes done, validity proofs, not just pessimistic ones, flight clients. So it's all in progress. And when it was done, it does make sense to switch back to the, like, to the l one. Okay, what should we do now, Mana? We have still some time.
00:31:24.750 - 00:31:27.590, Speaker A: We still have.
00:31:29.810 - 00:31:31.962, Speaker B: We can end early. That's fine.
00:31:32.106 - 00:31:32.546, Speaker A: Okay.
00:31:32.578 - 00:31:36.380, Speaker B: It's good. We have like minutes for many, not a big deal.
00:31:36.500 - 00:31:39.240, Speaker A: Was it clear regarding the transaction flow, by the way?
00:31:44.100 - 00:31:47.080, Speaker B: Yeah, I mean, it's pretty good.
00:31:48.820 - 00:32:11.300, Speaker A: Okay. Okay. Okay. I was asking guys in a room, what was your question? My question was, was it clear regarding the transaction law? Because I think I was a little too fast and, you know. Yeah, pretty simple. Okay. Yeah.
00:32:11.300 - 00:32:23.152, Speaker A: Okay. And thanks for coming and thanks, Mana, for assisting and helping. I think this is it.
00:32:23.176 - 00:32:25.020, Speaker B: Of course. Thanks. Nothing.
00:32:30.640 - 00:32:46.916, Speaker C: Sorry I came late. I was at a manual from Beijped from wherever. Yeah, you guys are so I don't want to like, disrupt your flow because it's also recorded as well.
00:32:46.988 - 00:32:48.280, Speaker A: No, it's all.
00:32:50.700 - 00:32:51.440, Speaker D: Right.
00:32:52.180 - 00:33:07.920, Speaker C: So essentially you're just making it like, easier for you guys to deploy sovereign blockchain and like, create your own, I guess, like, for everybody to like, create their own blockchain on their own. Dm.
00:33:08.540 - 00:33:36.126, Speaker A: Yeah. The point of this framework is, as I said, to empower developers to create rollups faster because, like. Yeah, you're welcome. Because it's actually easy to build a blockchain on the Cosmos SDK, you know, but still, it requires some operational stuff and the costs incurred. Costs and like infrastructure and. Yeah. And a common BFG.
00:33:36.126 - 00:34:09.540, Speaker A: You're right. Yeah. So with rollkit, you can. It's like, it's really a small engine, which is very modular and very, like, obstructed in terms of interfaces. It's read and go and you can basically customize it as you want. You can even actually in theory, like if you're not satisfied you can fork and dig into it and maybe change something. But overall, like any component can be substituted, for example, as mana mentioned.
00:34:09.540 - 00:34:14.248, Speaker A: Yeah, go on, go on the slide.
00:34:14.304 - 00:34:20.260, Speaker D: With all the components. It's a good one to show.
00:34:21.720 - 00:34:42.854, Speaker A: Yeah, you can, you see there is a bitcoin dealer. So what it means that bitcoin which is the like separate blockchain with its own like script and you know, like it could be done as a D layer. So it's pretty cool. Like pretty cool that you can.
00:34:42.942 - 00:34:51.846, Speaker C: So you guys are trying to like combine everything in this case because I can tell me like explain like what?
00:34:52.038 - 00:35:41.950, Speaker A: Yeah, we're not trying to combine. We try to make it modular and make it replaceable and make it easy to do it. So it's basically decoupling. Any good software is built using the primitives, like how it's called abstraction and generics stuff. And here we have interfaces which could be implemented. So for example D layer, as I said, just like six methods, but we really use two methods which is submit and get. So bridging IBC client, for example we use by default it's tendermint zero zero seven.
00:35:41.950 - 00:36:23.864, Speaker A: Could be anything else like sequencing. Right now we have a centralized sequencer. That could be the main argument that it's a centralized, but in reality, in reality there are many bonuses coming with that. For example, it's fast, it doesn't how it's called. It's fast lightweight, and there is no governance. What's the benefits of centralized sequencer again, manoeh, what are the, what, the benefits of centralized sequencer at this point?
00:36:23.952 - 00:36:50.316, Speaker D: Oh benefits. It's just like a fast, fast go to market. You don't have to boost up a bunch of validators, right. And then you can also have super fast block time check. It's only like one round trip global Internet latency. So like that's like 115 milliseconds, 200 milliseconds. So you're block time really fast and it's really like kind of really dependent on the state machine on how safe.
00:36:50.368 - 00:36:53.372, Speaker B: Commitments and execution works.
00:36:53.516 - 00:37:14.164, Speaker D: Right. So that's an advantage. But like we're adding, working on the sequencing API, which is basically going to allow you to delegate sequencing to another layer. So there's shared sequencers coming to market like ASEA Espresso, so you can use them as well.
00:37:14.292 - 00:37:14.748, Speaker C: Right.
00:37:14.844 - 00:37:44.432, Speaker D: But in that case the rolekit node will just be a header producer, it'll just be pulling blocks from there. You can also have base mode so you can use the DA layer as like the DLA blocks as your roller blocks as well. So you can kind of like pick and choose between these different modular components and like basically build whatever you want.
00:37:44.536 - 00:37:44.800, Speaker A: Right.
00:37:44.840 - 00:37:48.980, Speaker D: That's kind of it. Got it.
00:37:50.680 - 00:37:51.128, Speaker B: Yeah.
00:37:51.184 - 00:37:52.020, Speaker C: Cool stuff.
00:37:52.600 - 00:37:55.380, Speaker A: What can you say on the Cilia mode?
00:37:58.400 - 00:38:53.600, Speaker D: Oh, for state mobility mode right now, like you can run a full node, you want to verify the chain just like any other blockchain. Right. So like there is. And then what we're going to add like what we have in the most immediate format is we are going to look at all these CK vms that are in market and going to integrate them so that starting with the EVM. So there's a bunch of work being done on Revs just came to production. The risk zero CKBM just came to production. So we want to integrate them and have an option so that you can run an EVM roll up easily with, you know with a CKBM.
00:38:53.600 - 00:39:12.920, Speaker D: And then we're going to add optimistic mode which is you will only generate CK proofs when there's a. You will only generate a z given database here in that case.
00:39:13.080 - 00:39:13.940, Speaker A: Okay.
00:39:15.160 - 00:39:32.388, Speaker D: But yeah, you can kind of pick and choose between these modes on how the roll up talks are different other chains and how it has bridges. Yeah. You can theoretically support any of these things. So.
00:39:32.524 - 00:39:42.040, Speaker C: Yeah, that's what I got it. Interesting. Yeah. All in one kind of toolkit in that sense.
00:39:43.100 - 00:39:50.204, Speaker A: Yeah, I think, I think it's natural, you know, if all kid wouldn't appear someone else would do it basically.
00:39:50.292 - 00:40:02.910, Speaker C: Yeah, yeah. But then like what's the, what's like driving you guys to continue like developing and like being better? Like what's the incentive?
00:40:05.130 - 00:40:13.498, Speaker D: It is rolekit is an open source like public good. So it is a team that's supported by celestial apps.
00:40:13.594 - 00:40:14.230, Speaker C: Right.
00:40:15.050 - 00:40:24.106, Speaker D: It is like in the incentive is really like to make it really easy for anyone to experiment use all these components.
00:40:24.258 - 00:40:36.398, Speaker C: Is there any like issues with like the underlying technology changes with one of like the Da layers, bridging and sequencer? Like what's the, what's the impact on you guys?
00:40:36.534 - 00:40:40.030, Speaker A: What do you mean? What do you mean changes?
00:40:40.190 - 00:41:06.080, Speaker C: Like in terms of like the implementation? Like maybe one of the, one of the, I mean because you're attracting all the functionalities of the different sequences, Da layers, bridging and like wouldn't there be like a delay in terms of like being able to support that functionality?
00:41:07.180 - 00:41:34.380, Speaker D: Yeah, that's good. So I think like what, like the goal is that like for example, like the DLA, right. Since rogue has achieved, if the avail implementation changes, then there's a team, their team actually maintain that implementation.
00:41:34.720 - 00:41:37.568, Speaker C: Yeah, it's a client stuff.
00:41:37.744 - 00:41:39.340, Speaker A: So if they change.
00:41:43.040 - 00:41:43.936, Speaker C: Together with them.
00:41:43.968 - 00:41:55.780, Speaker A: To like it's more like they, they know the interface and they can just go and update the client for them. That's it. So that's what you mean like if they change their underlying like API or something?
00:41:56.200 - 00:41:57.120, Speaker D: Yeah, yeah.
00:41:57.160 - 00:42:01.420, Speaker A: So we cannot do this. So they can do it like is it just.
00:42:02.560 - 00:42:11.920, Speaker D: We don't need to own it. We can have teams of different components. Right. They have an incentive to go and support that and change it.
00:42:12.000 - 00:42:12.660, Speaker C: Yeah.
00:42:13.520 - 00:42:52.932, Speaker D: So that's kind of like how we want to take it. We don't want to like support on all these different components and maintain all of them. That's not sustainable. So having these teams own it, like if there's users for these, then there's a natural incentive for them to do it. Right. And it creates like an alignment sort of around all of these different components on how for them to contribute to roll kit. So for example, the avail team which contributed the implementation for their thing to roll kit, they've been also working on generally roll the issues.
00:42:52.932 - 00:43:02.810, Speaker D: So we can expect that to happen more and more with shared sequencers, with execution. So that's kind of like the vision for it.
00:43:02.890 - 00:43:03.550, Speaker C: Yeah.
00:43:04.490 - 00:43:14.430, Speaker A: Okay. Just want to add that for example, the tool I used, cortosis, is also contributing to rocket. So they created the packages for us.
00:43:25.960 - 00:43:40.760, Speaker C: Cool thing. Sounds good, sounds good, yeah. And don't be obliged to like stay here or anything. Yeah, yeah, yeah. Thank you for your presentation.
00:43:40.920 - 00:43:42.080, Speaker A: Yeah, thanks for coming.
