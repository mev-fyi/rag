00:00:01.880 - 00:00:41.332, Speaker A: Okay, I'm Mariano, I'm the head of engineering of claps. I'm probably going to try to fast forward the first few slides because I wanted to talk more on the technical part. So last year on etcetera, we actually announced that we wanted to go to solo L2. It took us actually a while to figure out how because we had an initial idea. Then we start basically having to analyze all different frameworks. But almost recently, a week ago, we launched our first testnet. I guess the merits of this testnet to me mostly revolves about migration.
00:00:41.332 - 00:01:20.380, Speaker A: It's actually one thing to launch a L2 on your own. Like, you start from scratch, you don't have any state, but a very different thing is to launch using an existing chain. And Dango in particular is actually a fork of one of our oldest testnets, Alpha Horace, which has been there for four years. So it's basically four years of history that we are migrating. And so in a way like, yes, you get the best of silo, now it's available on a testnet. And I guess we see how Ethereum is going like this sediment layer for web3. It's like that's the whole idea of actually Ethereum roadmap.
00:01:20.380 - 00:02:06.628, Speaker A: And you see how all these are L2s and roll ups are appearing and trying to use Ethereum as a settlement. And I guess we hope that cello was one of the first, if not the first ones that basically migrated into l two can basically pave the way for others to follow. So what I want to talk here is about like, how to do that. I guess what I'm trying to say here is that, yes, this is actually quite a hard, hard, hard fork. What I mean by that is basically you need to imagine. Imagine you are a user, you have your wallet or you have adap, and you go to adapt. The moment a solo transitions to an altru is going to be just another block.
00:02:06.628 - 00:02:34.020, Speaker A: So you're not going to notice that. You are going to see that, ok, there's all one blocks and then the next blocks happens to be no two blocks and nothing really happens. It's like any other hard fork. So whenever you had a hard fork, yeah, there's protocol changes, maybe there's a new transaction type, there's AIP 1559 or things like that. But in general it's the same thing. And here it's going to be the same thing. Of course, for node operators, they need to do something.
00:02:34.020 - 00:03:33.180, Speaker A: So, five tips on how to migrate to l two. So first tip is like, use an existing stack again, if we see this whole idea that we are going to have several choose going 201 and we see all these kind of, we are getting to this fragmentation problem, we're going to have a lot of l choose. And actually it's best if we start trying to standardize things. I guess the whole idea of being modular, having these things, it's okay, you need to reuse these things and don't go solo. In our sense. We basically chose op and Eigen, I guess, for op. I guess the tweet stocks by itself you can see around 74% of all two throughput is actually powered by Op.
00:03:33.180 - 00:04:24.712, Speaker A: And why I guess that's not just luck. What has happened here is I think Op was created to be a stack, so has been created to be a stack. And that actually matters because when you see the whole design, the whole code, you see that it's actually very well structured, modular, and separate into parts. So it's actually very easy to extend. It's also, that's why I guess because all you have all these projects, you have a very big open source community, which at the same time means that you're going to have probably different options if you want to use the a. Well, definitely you can probably go to find example of NDA, or you're going to find example of Celestia or Aveo. If you want to choose whatever you want to choose, you're probably going to find examples of that.
00:04:24.712 - 00:05:01.110, Speaker A: And I think another nice thing to say that I guess maybe you don't find that very often. It's actually very well spec. So if you want to learn how it works, you can actually go there and actually going to see a step by step detail of actually how things are being created there. Again, I guess for us, basically what most important thing is we want this kind of off chain data availability for solo and solo users having very cheap fees. It's actually very important. And I guess on that, I think there's many options that are all very good options. Something I guess we like also was this idea of power restaking.
00:05:01.110 - 00:05:28.334, Speaker A: So eigenlayer has rest taking. And to us, I guess to me that's actually quite nice. I guess there's some economic reasoning about how it's taking, how it's taking. It works. I think there's some kind of social part of, okay, you have the same actual entities running the same things for you. And I guess that's probably not capturing the protocol and the economics, but I think actually has some social value. So tip number two, I guess I'm going too fast.
00:05:28.334 - 00:05:56.246, Speaker A: But I distill your protocol into a patch queue on top of your stack. So two parts here fur distil. No. So yes, you probably, I guess Celo has like more than four years of history. We created some features and the moment you are going to, I guess it's actually a perfect moment to try to distill your product, basically to try to see, ok, let's keep all those things that are really, really important and leave the other things. Apartheid. No.
00:05:56.246 - 00:06:28.074, Speaker A: So do that process. Second thing is like patch queue, I guess also if you've been solo working for more than four years, you probably know that or any other blockchain company. And if you depend on op stack or geth or whatever, well, you have a huge engineering problem. It's like you need to do upstream merges. Basically you need to bring the code from geth every now and then to keep up to date. That's actually quite challenging, quite aero prone and quite a problem. In that sense.
00:06:28.074 - 00:07:20.490, Speaker A: I think the best thing for you to do is to try to have your features be layered on top of the stack of your chosen as a patch queue. If you know about git as a patch queue, even better if you can get your features integrated into a stack, because that will, first you're going to contribute to a stack back, which is a very nice thing to do. And second you're going to have less of problem doing upstream merge. So for us, a few features that kind of demo this thing. So Cello has fee abstraction. The idea is like you can pay gas fees with rc twenties and currently, for example, you can pay with USDT, with USDC and with like celo natives. And this is very powerful for us, I guess, for our users, because what we want here is like imagine you want to go and do payments, you want to do things like that.
00:07:20.490 - 00:07:56.880, Speaker A: Well, it's kind of hard to explain that you need to do that with some other token that is not your familiar token, like Celo ETh or whatever, a kind of traction is going there. But I think it's not that simple yet. So for us, how you do this, so we do this with envelope transactions. I know if you know EIP 1559, the idea is that you have this idea of, well, it's a number of transactions, there's another ip that creates this idea of where you can have transaction types. These are called embryo transactions. And to me, actually the perfect way for you to extend that protocol. Again, if you want to extend Ethereum, try to do it in a way where it's going to be isolated.
00:07:56.880 - 00:08:30.432, Speaker A: And I guess emerald transactions are very good to do that. So in our case we basically add a field where you say okay, what's the address of the RC 21 you use? And then the state transition function is going to handle that for you. Another big thing is like one block fanatic here is not much of a change. It's more of a realization that I guess not many people do. So people like to see. I guess l two has one block finality, sorry, have 1 second block and say ok, yeah, this is very fast. It's not really that way.
00:08:30.432 - 00:09:38.290, Speaker A: The problem you have is for example op, when you are, when you have a block that happens every 2 seconds, that block first doesn't go to Ethereum, it goes a couple of seconds later or minutes. But also it's using information from Ethereum blocks. So when they basically do deposits or what they call forced transactions, they're basically using information that it's in Ethereum blocks. Now Ethereum blocks are not final until 15 minutes after. So if you use things that happens before those 15 minutes, then in the chance that Ethereum can reorg, and actually Ethereum basically doesn't reorg after 15 minutes, but there is a chance that it do like the moment there's a proposal or testers, well your whole chain will need to reorb. So actually if you want to have one block finality, what you need to do is like, well you need to rely on ethereum finalized blocks. That's actually for p likely it's more of like a configuration thing.
00:09:38.290 - 00:10:05.254, Speaker A: And that's one thing you need to do. I guess you're going to have slower deposits, it's going to take 15 minutes. Okay, but what you're providing is one block finality. You are not going to have reworks. The other thing you want to do is like try to add slashing for a queue occasion. So sequencers are going to say hey, there's a block every 2 seconds. But how we know that actually is going to happen? Well I guess right now maybe it's reputation, they're not going to do things that they are against themselves and their brand.
00:10:05.254 - 00:10:43.450, Speaker A: But maybe you can also add like a slashing or have a testers another feature that solo has that also shows something. That extension is like token duality. So Celo, it's a native token of our sello network, but at the same time it's an RC 20, it's dual. Now that seems like a dream. Like we offer like a wrap f and all those kind of things. So this is interesting to be done. And it's actually easy, but has like a unique as very simple hack, which is you need to be able to implement the transfer from of an RC 20 interface.
00:10:43.450 - 00:11:25.188, Speaker A: And that means you need to be able to transfer on behalf of someone else. And for that actually you need a precompile. So we have a simple precompile that only that contract can call and that can solve the problem. Again, precompiles is probably another thing that you can actually do and extend, and it's fairly straightforward. Okay, tip number three, migrate your chain versus porting your code. So if you have a chain that has been there for four years, and you probably have a few hard folks, a few protocol changes, maybe those changes are on the block format, on the block header, on the type of transactions. So when you are going to l two, you are basically creating this new client.
00:11:25.188 - 00:12:11.464, Speaker A: Do you want to port all that code? You probably don't. And so what you could try to do is be able to migrate the history. And what I mean by that is actually when I run an l two node for solo, this node has in their database all the blocks from celos since Genesis four years ago. And it needs to be able to read them, it needs to be able to interpret them, it needs to be able to validate them, and for that it needs to know how they are actually spec. So what we actually did was basically migrated those blocks while keeping the block hashes and all the information of them. And that gives you the best of what works. We still need to port some code.
00:12:11.464 - 00:12:31.840, Speaker A: So for example, we had envelope transactions that we don't use anymore. We still have them. We also have what we call a seronated transaction. We was a transaction before EIP 1559 that had this feature of fee abstraction. We also had to port that. It's just to be able to read those blocks. But that's one thing.
00:12:31.840 - 00:13:07.968, Speaker A: The other thing you need to do is handle archive notes. So yes, you have a full node, but archive nodes has this ability to be able to query historic state. You can go and query the smart contract state somewhere two years ago, and that's an archive node. Now the problem is that you do that well, your l two node won't have that feature. And of course, because if not, you would need to migrate everything and it will be a big pain. But what I can do is actually proxy that. So it's not ideal in the sense of infrastructure runners, but it actually works pretty well.
00:13:07.968 - 00:13:43.626, Speaker A: What you do is you have your l two archive node, which is able to respond all state queries for the l two state or l two history. And then whenever it receives a tracing call, an Eth call for a very old block, well, you defer that. You proxy that to l one archive node. No. And that way you can solve it. Ok, tip number four is like, so rethink where your token lives. So Celo, it's a native token of this l one going to an l two.
00:13:43.626 - 00:14:37.046, Speaker A: Now the moment you be an old two, you have this question. Do you want Celo to be a native versus 20 of Ethereum? Or do you want it to be like still then only exists on the old two and only bridge solo back to Ethereum whenever you need, because we chose the first idea why. I guess having an rc 20 on Ethereum will have better security, but that kind of creates a problem because you already have all these token supply already on the l two. How you make that? And so it's also straightforward. What you can do is basically you just mint all the cell on the l one. You lock that on the native bridge and then that means that everyone can withdraw their cellular native on the Altru back to Ethereum. And that will just work.
00:14:37.046 - 00:15:20.786, Speaker A: We have a small or not small caveat, which is what happens with minting and burning. No. Okay, five minutes. What happened to minting and burning? So for minting and burning, what you need to do probably, I guess minting and burning actually happens on the seller network, right? Right now, for example, you have epoch rewards, things like that. And so I guess what we found so far is that, okay, we can mint the whole total supply that we know it's capped to 1 million, we put on the bridge and then we replace minting by releasing. So we have a contract that basically locks all the setup that is to be minted and it's going to release it using the same minting schedule. But now it's going to be a reschedule.
00:15:20.786 - 00:16:00.272, Speaker A: Like if you think economically, it's basically the same thing. Okay, tip number five, and I'm finishing with this, do multiple upgrades. This is more of like an engineering practice, but I guess it's pretty obvious, right? If you have these very, very complex things to do and if you know from infra, you have this idea of continuous delivery. Basically you want to always be shipping things and always be basically doing things. So try to do this exercise multiple times. In our case, what we are thinking is, so this is dango right now. So we had three do net testnet, Alpha, Horace, baklava and one mainnet.
00:16:00.272 - 00:16:40.204, Speaker A: All these are like public testnets testnets or chains. So our first experiment, real experiment, was like okay, we're going to fork Alpha Horace. We're going to basically use the same state history of Alpha Horace and we're going to create a new chain that's dangle. That happened like Friday later we're going to basically upgrade Alpha Horace. What it means is like you have like I know you're infuria or Fortno or whatever RPC URL you have for Alpha Horace, it's still going to be the same. It's just going to be replaced to an all to node and you will notice a difference. Then we're going to do with baklava.
00:16:40.204 - 00:17:09.624, Speaker A: So Alpha Horace will run entirely but Backlaba is actually run by a whole validator set. So it's going to be much more of an orchestration project where we need everyone to do the upgrade themselves. And finally we're going to do main. The idea again is to exercise this muscle of doing the migration as many times as you can. Ok, that's all for me. And I guess I finish almost in time. Great question.
00:17:09.624 - 00:17:53.282, Speaker A: I'm just wondering what was the biggest motivation to move from an l one to an l two? Yeah, great question. I guess I have my personal view on the subject which is like to me right now, if you are a chain, you might be an EVM chain or an EVM chain. And I think Ethereum has demonstrated that they are the biggest chain out there on EVM. And if you are an EVM chain, you are basically trying to be almost like them. So you have two choices. One choice is to be truly, truly different. And then that means follow the path of Aptos, Solana Suinganheze, have a very different model.
00:17:53.282 - 00:18:55.830, Speaker A: Maybe try to capture a different side of the market by having other use cases. Or you should basically join the community in a sense and be part of the grander Ethereum community. If not, you are kind of in the middle. And so to me that's from more of a strategy perspective, from a technical perspective, you also going to be able to Ethereum security, you're going to have faster or better connection to Ethereum. So there's like definitely benefits there. But again, if you think from more of like a rational strategy perspective, I think it kind of makes sense to be closer to what you actually, and actually a lot of what we say when this style and everything is also going to try to move closer. Something that we find out also the hard way is like every time you try to innovate and try to do something different to Ethereum or faster.
00:18:55.830 - 00:19:31.120, Speaker A: We implemented EAP 1559 before it was actually implemented in Ethereum. Well, it later happened that they implemented that in a slightly different way. And so now you have an incompatibility problem. And so it's kind of an interesting thing to say how you make those bets of, like, if you want to do something different, you're going to, let's say, now you want to do native account abstraction. That's great. But probably by the moment, Ethereum has that for EOS, it's going to be slightly different, and then you're going to have a problem. So it's a nice trade off to think that's clear.
00:19:31.120 - 00:19:31.920, Speaker A: Thank you. Thank you very much.
