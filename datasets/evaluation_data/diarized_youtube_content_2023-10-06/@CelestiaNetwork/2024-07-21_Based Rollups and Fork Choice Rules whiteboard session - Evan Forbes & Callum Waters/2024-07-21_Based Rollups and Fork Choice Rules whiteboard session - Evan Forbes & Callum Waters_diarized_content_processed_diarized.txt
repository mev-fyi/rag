00:00:00.840 - 00:00:01.208, Speaker A: Dope.
00:00:01.214 - 00:00:03.070, Speaker B: Okay, should we start with introductions?
00:00:03.190 - 00:00:03.742, Speaker A: Yes.
00:00:03.846 - 00:00:08.410, Speaker B: All right, this is Evan Forbes, and he works at Celestia as the protocol lead.
00:00:08.990 - 00:00:12.254, Speaker A: This is Colm. Colm's a core dev. We work on the same team.
00:00:12.302 - 00:00:13.370, Speaker B: We're working on the same team.
00:00:15.910 - 00:01:00.600, Speaker A: And today we're going to talk about base roll ups, four choice rules, and, like, really dive into them. And I think the first good place to start is actually talking about the problems that there's solving. And there's two sort of distinct problems that sometimes they solve both at the same time, sometimes they don't, and that can maybe lead to some issues. And then after we talk about the problems that they're trying to solve, then Colin can talk about the transaction flow of and the different roles involved, and then we can talk about Mev and for choice and stuff. Okay, so the problems that we're trying to solve are two fold. The first is the simplest is a yemenite, a decentralized sequencer set for a validator or for a rollup. For a rollup, you don't want to have a centralized sequencer.
00:01:00.600 - 00:01:30.196, Speaker A: That's bad, because now you have a centralized sequencer simultaneously. You're a roll up. You don't want to have your own sequencer set either, because that defeats the purpose of using a roll up. I would rather just spin up a cosmos chain. That's easier. So if I want something that actually gets the benefits of these things, you can use something called a base rollup. Now, base Twiller has, in my opinion, one distinct property, and that is that it simply executes transactions after you reach consensus.
00:01:30.196 - 00:02:09.038, Speaker A: So first you have some sort of ordering of the transactions. So if this is Celestia, this is the Celestia square, we're going to stick some transactions in here for my namespace. That's my base roll up. We're going to pull this down. And after we reach consensus on it, after we timestamp it, after we publish it, now we have the transactions, and now we execute them. So now we have, however you execute your transactions, and this can be entirely arbitrary to your chain, you execute and then you're a roll up. So now you're doing some proving as well.
00:02:09.038 - 00:02:40.830, Speaker A: But we'll actually talk about proving later. That is the sole purpose of a base rollup. The only thing that you need, and the thing here is that since you're executing your transactions after the fact, you can actually share the sequencing across many different nodes because they don't need to know anything about you. They literally just order the data and stick it in one place. And as we know, that's actually scalable because it's separate. They are not paying attention to anything to do with your state machine. They don't care.
00:02:40.830 - 00:03:14.632, Speaker A: They don't care about your ordering, they don't care about anything. And because of that, it's actually scalable. The second problem that we're trying to solve is mev. So the classic cases with the liquidation, someone has a loan and it gets liquidated. So they have collateral up for that loan, and someone needs to bid for that collateral. So they have, the original loan is worth 100, I'm just going to call it t for tokens. So you have 100 of these tokens.
00:03:14.632 - 00:03:57.950, Speaker A: That was the original collateral for the loan. Now, whatever the value in this liquidation, now they deem that you're underwater or getting close to being underwater, which means that the value here, the collateral, is not enough to back up your loan. So we're going to liquidate you. We're going to sell your collateral while it's still worth enough to cover your loan payment so that we can actually keep the system maintained that the system is good. So to do that, we're going to have a discount. So we're going to sell your 100 tokens, we're going to list it at. If this is denominated in some other currency, let's just call the other currency a.
00:03:57.950 - 00:04:23.598, Speaker A: We're going to assume that originally it was one to one, but now the price of your collateral went down. So the price of t went down. Now you have 70 a. Anyone that pays 70 a is going to get you our 100 t. Okay, so that's there. But now we actually want something better than that. That kind of sucks because the price is somewhere between 70 and something else.
00:04:23.598 - 00:04:46.986, Speaker A: But when we actually liquidate your collateral, usually we have a bidding system. We want whoever is willing to bid to find the correct price. This is the entire purpose of auctions, right? We try to find a correct price when we do this. In theory. It sounds nice. I have an auction I'm going to bid up here to whatever the actual price is. Let's say the actual price is here.
00:04:46.986 - 00:05:42.480, Speaker A: And as a user, it sucks. I get liquidated, I lose this amount, but really I'm getting like 90 out of my hundred. It's not that bad of a cut. But when you add Mev in here, now the, it assumes that the auction is actually credible. It assumes that the auction can actually make these comparisons in a reliable way, but it can't because the proposer is the one who gets to determine what is the input into that auction, the proposer determines. The proposer has a monopoly over what goes in. So what does the proposer do? The proposer says, oh, I'm going to have people bid, I'm still going to have an auction, but it's an auction to pay who pays me the most for this bid? So they end up, what happens, this happens is that this money right here, all of this extra behind this discount that goes to the proposer, it doesn't go back to the user.
00:05:42.480 - 00:05:51.620, Speaker A: The proposer captures all that value. For doing what? Just simply having a monopoly, not actually having, producing any value, not actually doing anything. Yeah.
00:05:51.700 - 00:05:54.988, Speaker C: So you're saying that like proposers are doing this right now, like this is.
00:05:55.004 - 00:06:33.846, Speaker A: In their software, like this. This happens like every 12 seconds on Ethereum right now? Yeah. So this is really bad. We want to find something like this to either direct this value back to the user, so to have a credible auction, or we want to find a way to capture the profits of the system in a more programmatic way. So we're going to choose the winners. We're going to choose, instead of going to the proposer, we're going to go to someone else. So that was a bit of an elaborate illustration or ramble, but those are the two problems that we're trying to solve here.
00:06:33.918 - 00:06:47.610, Speaker B: Like, you're essentially talking about value capture. Can the app do that, or will that be taken by external parties? Yeah, that's one of them. And the second thing is going back to the whole, like, where do you get your inclusion and ordering guarantees from?
00:06:48.110 - 00:07:20.788, Speaker A: Yeah, yeah. Okay, so the decentralized sequencing set, the sequencer is publishing and timestamping your transactions. And because they do that, now, you're able to have a decentralized sequencer set while not having to get your own sequencer set. Right? So that's what base rollups are solving. They solve this ability to have a decentralized sequencer set in a permissionless way. I don't have to ask anyone, I just write some transaction, I write my state machine, and then users just start using it, and that's it.
00:07:20.844 - 00:07:55.054, Speaker B: Because if we were to rewind or unwind a little bit, the whole goal of this as a whole was verifiable execution. That's what Ethereum tried to do. Ethereum didn't scale, so we tried to find an alternative solution to scale. Here came Celestia. Then how Celestia winner is doing is instead of having 100 nodes doing however big the sort of network is, instead of having all of them do both consensus and execution. We're going to have the $100, just the consensus, because the execution is the computationally intense part, and have each individual application, maybe it's only a couple of nodes, do the execution itself. So we're trying to outsource the execution.
00:07:55.054 - 00:08:29.290, Speaker B: And then these have now been named rollups. So this is kind of straightforward. But just to get there now, what do we see in our current roll ups? We see that they're often these centralized sequences. So now you've got these problems about censorship, resistance. Like, now you're posting your data to celestia, but you're using some sort of sequencer, and they have control of the order. And so we're trying, like, I think what you're trying to get around here is how do we, like, avoid these things? Because then now you're relying on that sequencer for some censorship resistance. And now, yeah, now that sequencer can also extract Mev.
00:08:29.290 - 00:08:35.390, Speaker B: And so base is what you're presenting as, like, the solution to this, where, like, it avoids these.
00:08:35.470 - 00:08:37.250, Speaker A: Yeah, we get two birds stoned at once.
00:08:39.470 - 00:08:40.890, Speaker B: All right, continue.
00:08:42.179 - 00:08:49.099, Speaker A: So now we can go through the transaction flow. What does this actually look like in real life, and what are the roles of the things?
00:08:49.219 - 00:09:39.808, Speaker B: Yeah, so I think one of the confusing parts, if we're going with this modular thesis, which is kind of very similar to the microservices architecture, web two, like a decade ago, what do these different categories look like? And I think there's a lot of debate about where they lie, and I think we're still trying to fine tune what they look like. I guess one of them we have is this da layer, and it kind of depends how you use it. So, for example, with Celestia, there's three things that celestia is providing. It's providing inclusion. So proof of sufficient inclusion, you can call this order. So what is the order of these things? And this is done by consensus anyway. So you're like Cosmos SDK chain for widow Earth does these things.
00:09:39.808 - 00:10:08.580, Speaker B: The thing that solicitor does on top is a way of sampling this stuff. So this is how you have your data available guarantees. This is the whole scaling solution. Well, instead of downloading all that data that has been included, you can have a more efficient way of doing this. Now, that's the sort of da layer side of these things. We have this emergency sequencing layer. So the like of Astria.
00:10:08.580 - 00:10:33.406, Speaker B: And Astria has to be decentralized because you're trusting Astria to do order for you. Right. So now, instead of relying on Celestia for ordering. You're using Astria, and Astria can do this a lot faster. So it means you get your ordering a bit sooner. So you now, if you wanted to, as your roll up, start using the. So you'd be publishing transactions to Astria.
00:10:33.406 - 00:11:12.900, Speaker B: That'd be sort of almost like a DA, batching them together. And then you can know ahead of time what's in those transactions, and then they eventually go into Celestia. But the problem with something like Astria is that now they dictate order. So you're now dependent on them for sort of like either censoring you or sort of like sandwiching you. Like, now they can extract that mev. And so the whole pine of, like, the base layer is like, let's not rely on both of these two things. So now you're relying on the validator set of the sequencing layer and the validator set of the DA layer.
00:11:12.900 - 00:11:24.656, Speaker B: The DA layer is already doing ordering for you. You kind of get that. So why are you paying extra for the sequencing itself? Can we just have some system where you post stuff directly to the DA layer? Do you want to jump in?
00:11:24.728 - 00:11:52.608, Speaker A: One important note is that, like, base roll ups, bass roll ups can be used with either. And what Colin's saying is that you don't have to use a sequencing layer. You could use the DA layer for the sequencing layer. At the same time. The problem with base roll ups is that you inherit that sequencing from the base layer. So if your base layer has slow sequencing, well, now you have slow sequencing as well. So the reason for having a separate sequencing layer is still a base roll up.
00:11:52.608 - 00:12:09.270, Speaker A: Either way, in my opinion. Like a base roll up doesn't like the whole, it's only champagne if it's from some region of France. Right thing. Yeah. Thank you. Thank you. It's like a base roll up is not just a base roll because it's on an l one.
00:12:09.270 - 00:12:45.708, Speaker A: A base roll up is a base roll up because it has deferred execution and can share a sequencer set. Yeah. So the thing that you're getting here from the sequencing layer is you're getting these short term commitments. I think one of the fun things, I don't know, I don't want to go on too big of a tangent, but the four things that Sriram always mentions for the security of a chain, it's like you have da, you have censorship resistance, you have reorg resistance. I'm not even going to write this out. And then there's one more. What is it? I need to go look at the tweet.
00:12:45.708 - 00:13:06.780, Speaker A: But anyway, you can get all three of these. Or in this case, if the sequencing layer is posting its blocks to the DA layer, eventually you get all three of these from the DA layer. But the sequencing layer, its sole purpose in this case is to give you these things for 12 seconds.
00:13:09.280 - 00:13:39.106, Speaker B: Yeah. And if you saw the talk about, yeah, on fast block, slow squares, the idea is that if the DA layer can do this faster, so at a, like, per second time, then actually you don't really need a sequencing layer. You don't actually need that added, like, level of security. What you can have is maybe an aggregation layer. So something, I actually don't use the word aggregation layer because it has already some sort of context, but some sort of batching. Right. So you can always post directly to Celestia.
00:13:39.106 - 00:14:07.440, Speaker B: That way. You're relying on Celestia for censorship resistance. You're not relying on them. They're not permissionless. But if you want to get things cheaper so you don't have to pay for the entire signature stuff on Celestia, you can sort of batch them through some sort of batch provider. And this is like some sort of permissionless system, you might imagine there might be three or four competing to have the lowest price batching it there. And if, for example, this guy is trying to censor your transaction, you just submit it directly to the DA layer.
00:14:07.440 - 00:14:13.844, Speaker B: Okay, so that was like, the first part of it. And then should we talk about, like, execution approving now?
00:14:13.972 - 00:14:14.588, Speaker A: Yeah.
00:14:14.724 - 00:14:57.172, Speaker B: Okay, so this is like the one aspect. So it's just getting this data on chain. Now, the second part is like, how do we work around execution improving? And so, like, one of the things that works quite well with solicitor is like a proven network. So you would just have the flow is once the sort of transactions are on Celestia, there'd be some way where you, like, a prover would realize there's enough of, like, we're not really gonna get into payments, but sort of like incentive for them to now produce a proof. So there'd be enough transactions there. They would then execute, find out the new state route, and then create a proof for that. And then that proof would then go into the DA layer.
00:14:57.172 - 00:15:18.380, Speaker B: And so then you, as your lite client for this base roll up. The way that you're working is you're reading Celestia for proof that your data is included, proof that the block is published in terms of the sampling. And then also now the proof from the execution itself. Do you want to add something to that?
00:15:19.000 - 00:15:19.740, Speaker A: No.
00:15:20.120 - 00:15:23.644, Speaker B: Ok, so how do we explain to this to you in a very simpler way?
00:15:23.792 - 00:15:28.812, Speaker A: Maybe like pretend I'm a user. Yeah, I'm going to sign something.
00:15:28.956 - 00:15:30.452, Speaker B: And who are the other agents? Right.
00:15:30.516 - 00:15:31.772, Speaker A: Yeah, let's follow it.
00:15:31.836 - 00:15:37.680, Speaker B: So there's like one flow where you can submit to this person who batches things together. Wait, wait, wait.
00:15:38.500 - 00:15:44.600, Speaker A: Let's draw it out. Let's get it. All right. I signed a transaction. Here you go.
00:15:46.020 - 00:15:47.040, Speaker B: Who am I?
00:15:47.420 - 00:15:51.050, Speaker A: We'll follow it. So transaction, it's signed.
00:15:51.390 - 00:15:57.486, Speaker B: The batching thing is optional. You kind of don't need it here. And so I think maybe for a simpler method, you could just say you submit it to the DA layer.
00:15:57.518 - 00:15:57.990, Speaker A: Good idea.
00:15:58.070 - 00:16:21.480, Speaker B: So you submit it to the DA layer and then you basically have people from all over the network submitting their transactions. Then you'll have some sort of like roll up node. And the whole idea is like instead of having this like network, it's permissioned. So you can have multiple roll up nodes. You join the square.
00:16:21.820 - 00:16:22.600, Speaker A: Yeah.
00:16:25.460 - 00:17:04.140, Speaker B: So you'll have someone who's incentivized to run a roll. No, because they get the rewards for producing proofs. And so they will read off the transactions and the transactions will say some sort of fee towards their prover. Once there's a certain amount, they will then execute those transactions belonging to that namespace and then produce the proof and then submit the proof back into the DA layer. And so then you as the user, you submit your transaction, you sample the square that it's available and that your transaction is included. And then you sample the, then you sort of like retrieve the proof, you verify the proof of the state. Now you know the new updated state that your transaction went through.
00:17:04.140 - 00:17:10.504, Speaker B: Does that make sense? Do we have any questions just to like stop it here? Yeah, maybe.
00:17:10.552 - 00:17:19.022, Speaker D: Is there a concise way to say what exactly is the difference between a base roll up and a non base roll up? What's the unique feature that a base.
00:17:19.046 - 00:17:20.086, Speaker A: Roller has to have?
00:17:20.238 - 00:17:25.118, Speaker B: In my view, it's debated. I think the base term is all over the place. But I will let you take the.
00:17:25.214 - 00:17:55.060, Speaker A: I think the sole technical thing that you need is deferred execution. So I execute the transactions only after they have consensus. So that's it. And anything that has that could be a base roll up because now the consensus is external. Right. I'm like drawing a line in the sand and saying I'm only handling things on this side, therefore everything on that side can be arbitrary, can be a different chain even. Right.
00:17:55.060 - 00:17:55.888, Speaker A: Okay.
00:17:55.904 - 00:18:00.584, Speaker D: So deferred execution. We're saying that it might be a base rollout. So what?
00:18:00.672 - 00:18:04.700, Speaker A: No, no, that's my definition of a base roll up and I'm quite opinionated on that.
00:18:06.680 - 00:18:07.648, Speaker B: Yeah, that's why I said that.
00:18:07.664 - 00:18:22.660, Speaker A: It's like, yeah, I know some people say base roll ups are only base rollups if they're on like the l one. So like ethereum doesn't refer to base roll ups if it uses a shared sequencer. It's not a base roll up. It's only a base roll up if it's only l one. I think that's a silly definition. It's not useful.
00:18:23.520 - 00:19:18.810, Speaker B: Yeah, I'm not sort of worried about the nomenclature. I just, I think the important part for me is saying that like the layer gives you a lot more than what people are going to be using it for. A lot of people don't have. Okay, so you've seen this rise of sequencing layers and so my pushback about this is like do we actually really like okay, great, we've got this modular thesis, but are we adding modules just for the sake of it or are we adding different layers for the sake of it? What are they actually inherently providing? And I think if you actually dig a little bit deeper, all they're doing is making. Now instead of relying just on the security of the validator set of, of the DA layer, now you're relying on the validator set of the, or like the censorship resistance of the sequencing layer. So you're increasing the amount of things that you're relying on. And so if you can kind of reduce that and like if you're a roll up, you're always going to have to be, if it's ethereum or solis or anything like that, you're always going to have to be reliant on that validator set so you can't eliminate it beyond that.
00:19:18.810 - 00:19:48.644, Speaker B: But I think instead of just adding like modules just for the sake of it, I think we should be really critical about what is that additional change to the security. Ok. And so I think in many cases you don't need decentralized systems. You kind of need to create open market systems. So where people, and so I made this use case about aggregators. So they're like competing with one another to make the cheapest price for batching it in for you. That's their service they're providing.
00:19:48.644 - 00:20:14.890, Speaker B: It's permissionless, you don't have to use them. You can always go direct to Celestia. The same for proven networks, the provers are all competing each other for who can do the proof the cheapest. The one that does and gets in is the one that gets the reward for it. So now you're creating, just in simple economic terms, open markets that people can compete about it rather than having a decentralized system. And the only security that you really are then dependent on is the DA layer.
00:20:16.430 - 00:20:20.650, Speaker C: So I guess I'm not 100% convinced that you're not going to have me being.
00:20:21.350 - 00:20:24.530, Speaker A: Oh, you are at the moment. Yeah, you totally are.
00:20:29.310 - 00:20:31.210, Speaker C: Executing transactions themselves.
00:20:32.390 - 00:20:32.726, Speaker A: Yeah.
00:20:32.758 - 00:20:37.022, Speaker B: So this first part was about security from like, I guess, like a censorship perspective, right?
00:20:37.126 - 00:20:37.502, Speaker A: Yeah.
00:20:37.566 - 00:21:30.340, Speaker B: Then there is a security from like, well, who's going to be trying, like, who extracts the value, who gets rewards? And we kind of want to build systems where the app at least gets to choose this, whether the app wants to choose batches to get rewards in the way that they order the transactions, batches maybe similar to builders in the PBS sense, or whether they want to give it to provers in some way. We want to make sure at least that the application has some control with that. And I think a lot of this comes down to how that fork choice rule works. So when you're submitting the transactions on the DA layer, the order with which the transactions are on the DL layer does not have to be the order with which you execute across. So the application itself can define some way so that even if you have a batch which is trying to, like, sandwich or do something that, like the protocol the application doesn't want, the application can come up with some deterministic way with which it doesn't actually execute it in that same order.
00:21:30.420 - 00:22:05.340, Speaker A: I think this is a great time to go into that. So we kind of glossed over this execution portion, but this execution portion includes this for choice rule and some of these things. So, um, I think that was a great point on, um, we can start with enshrined PBS, so. Or not enshrined, sorry. We can start with how PBS works, and we can show you that even without having order agnostic applications, you can still have very ordered applications like what we're used to now, like on Ethereum, with.
00:22:05.460 - 00:22:32.702, Speaker B: Maybe we should just, like, explain this. So there's like, we kind of talked about two different categories of applications. Order agnostic are like, split wise, where there's not someone who can really extract value. It's just like, okay, you have a debt to me, you have a debt to me, blah, blah, blah. It's like Ticketmaster, like a decentralized Ticketmaster. The control of order flow is not something where the person who has control of that can extract some sort of value. Shaking his head.
00:22:32.846 - 00:22:34.918, Speaker A: No, there definitely is ways to extract value.
00:22:34.974 - 00:22:42.110, Speaker D: There's no point of ticket master that someone can come in, buy all the tickets and then, and then they have monopoly on actually sign tickets on the secondary market.
00:22:42.150 - 00:22:46.726, Speaker B: So there's volume, sensory, that's different. Yeah, okay, I see what you mean.
00:22:46.838 - 00:23:36.736, Speaker A: There's, in all of these systems, there's always ways to capture value. And split wise, yes, because if there's split wise, maybe not because it's predefined. Like I have some number of people, I divide the cost across four or something, but with something that's a, like with cycles money or with enoma, where I'm trying to find loops, I can totally insert myself in those loops to connect the dots. And I take all of the excess that people insert. Because with MeV, most of the time, it is like I think other people said this, this is not me. But most of the time in these systems, we define things like slippage, or we define things like this. Maximum cost I'm willing to pay, but with MeV, I can make you pay that maximum cost, I can make you pay the maximum slippage, and that's where the MEV is.
00:23:36.736 - 00:23:57.368, Speaker A: Yeah, yeah. So we want systems. Ideally, it would be nice if I could just say maximum cost. And most of the time it never gets hit. Yeah. So anyway, we have these order agnostic applications and we have these ordered applications, and these systems can actually handle both ordered applications. Now rely on something that's like PBS.
00:23:57.368 - 00:24:34.876, Speaker A: So proposer builder separation. So I'm going to cover that, really not use a red, I'll use blue to cover PBS really quickly. And then I'll show us how. If we have a censorship resistant sequencing layer and base roll ups, we can enshrine that in protocol and we can control where the value goes. So here we have proposer builder separation. It normally works by, we have a proposer here. So the proposer, in this sense, the traditional name for the proposer, even though I disagree with the naming, is the person who's choosing the next block of the l one.
00:24:34.876 - 00:25:10.854, Speaker A: So we have this block of the l one. We're going past here, this proposer's choosing this one. They have a monopoly on this at the moment. They choose the proposer. And now we have our builders, our builders over here, they're the ones who are getting really clever with transactions. We're going to have transaction three, two, one. And we're going to instead of ordering here, we're going to order them as three, two, one.
00:25:10.854 - 00:25:47.346, Speaker A: Because that gives this builder a better chance to capture Mev. So you have many of these builders. They're organizing these transactions, they're actually building the block, they're executing these transactions, they're finding the way that they can capture the most value. And then now they're all competing to actually get this slot. And this is what proverb builder or proposer builder separation, how it works is that you have some centralized relay at the moment, like flashbots or something to do with that. And these builders submit bids. They say, I want given a set of transactions, I will pay this much.
00:25:47.346 - 00:26:03.160, Speaker A: And these bids are these tips. And the proposer doesn't even have to touch transactions yet. They don't even have to run a mempool at the moment. All they do is they just, they wait there. They wait for their turn. The builders will submit a bid. They submit a bid.
00:26:03.160 - 00:26:25.806, Speaker A: The proposer says, okay, I'm just going to take the highest bid. I haven't seen the transactions yet. The transactions are still private. I haven't seen them. I'm going to sign this block, though, because you gave me the highest bid. So I'm going to sign it, sign this proposal, and then after I give you the signature. Now here's the thing.
00:26:25.806 - 00:26:45.820, Speaker A: I can't equivocate. I can't sign two things. I can only sign one thing. So it works out, because now the builder says, ok, now I have your signature. I know that this is going to be the next block because you're the proposer. And guess what? Now I'm going to gossip. These transactions that previously were private, there's my own order flow and my own thing.
00:26:45.820 - 00:27:18.116, Speaker A: And now this is where the things that we were talking about before, where who captures the value here? The proposer does, because the builders that are organizing these blocks are being really competitive, but they're submitting bids to the proposer. And because they have to be so competitive, the proposer is the one who, they still capture some value, but they don't capture nearly the amount that the proposers do. So we don't like that. The proposal's capturing value here so we can improve upon the system in a way that I think is kind of neat.
00:27:18.268 - 00:27:24.960, Speaker B: But like this is for a consensus kind of chain, you're transferring this to a roll up where you don't actually have a proposal.
00:27:26.980 - 00:28:11.230, Speaker A: Like you're saying the proposal here, you do have a proposal, technically, because the l one proposer is always your proposer, even for a roll up. So what we want to do is, um, we have to, to fix this. It requires one thing, and it requires that instead of having one proposer, like a column is saying, I have many proposers, or you have to have some mechanism of censorship resistance. So you have to have a mechanism on the sequencing layer, wherever your sequencing layer is, you have to have some mechanism where this is no longer, uh, a single proposer. It's multiple proposers. So let's make the assumption of censorship resistance. We have to make the assumption of censorship resistant blocks.
00:28:11.230 - 00:28:46.146, Speaker A: Each block is censorship resistant. Now, this can be a little bit confusing, because traditionally, when we talk about censorship resistance, we're like, oh, you could be censored for one block, it's okay, just get it, and then on the next block. But, no, that's not good enough here. We need censorship resistance per each block in order for this to work. So this is where you have multiple proposers. Instead of one proposer dictating, having a monopoly over everything that goes in that block, we're going to have many proposers include. So now proposers are, and you have no benefits of, you don't get the decision of what goes in.
00:28:46.146 - 00:29:11.372, Speaker A: So because of that, now we have our same system that we have here. We have builders. We have builders building these roll up blocks like they did before. They come up with the best version, that makes them the most money, and then they bid. They're still bidding. But here's the thing. Where does the money go from the bid? That's where the application comes in.
00:29:11.372 - 00:29:23.240, Speaker A: The application can choose that now because of the censorship resistant block. So it's still the exact same system that we had before, except for the money's not going to the proposal. The money's going wherever we want to in a programmatic way.
00:29:24.580 - 00:29:26.040, Speaker B: Do you want to go through that flow?
00:29:26.380 - 00:30:17.240, Speaker A: Yeah, it's the same flow as before, where we have these l one blocks. But now I'm going to say that, let's say we have three proposers here, p one, p two, p three, and we're going to do that again. And so this right here, and this entire set of three different l one proposers, they're the ones who are building this next block. But they all three would have to, let's, let's just say that for now, for simplicity's sake, they all three would have to collude to censor a builder. So now we have the competitive builder, but the builder in their bid, they're not giving the money to the proposer. It's not a tip, it still is a bid. The money's going somewhere.
00:30:17.240 - 00:30:54.010, Speaker A: But that's dependent upon the application, because now the builder transactions, they build a header, and in it, normally it has a tip, and this tip would normally go to the proposer. But now our fork choice rule for a base roll up. So in our da block, we have a bunch of. So, in this block. So I'm taking like a subset of this block. There's three sections here that are contributions from the proposers. Now I'm going to have, let's say we have two builders, builder a, B, A and B.
00:30:54.010 - 00:31:35.200, Speaker A: And so this is a roll up block from BA, and this is a roll up block from builder B. This roll up had a tip to the application, not to the proposer of ten, and this one had a tip of nine. So guess what our fork choice rule is. Our fork choice rule is whoever pays us the most. So now that value, that value, all the money that comes from the excess. So, like in these restrictions for users, it's like I specify the max that I'm willing to pay all that excess we have control over now. So there's still better things that you can do, but I'll get to that in a second.
00:31:35.200 - 00:32:10.846, Speaker A: At the moment, you can take the existing system that works. Now, if you have censorship resistant blocks, you can have these based roll ups that use these fork choice rules and the proposers of the sequence of the l one to have really good sequencing. They inherit the sequencing of the l one, they inherit the DA, the publishing, all the other security elements they're inheriting from the l one. They're using their fork choice rule, though, to capture their own value, because we have censorship resistant blocks. So that's already like the first system, but there's actually cooler systems. Yep.
00:32:10.998 - 00:32:19.958, Speaker D: So what exactly does censorship resistance blocks mean here? Because you said something about it's not even okay to be censored for one clock. So what exactly do you need for this to work?
00:32:20.134 - 00:32:56.060, Speaker A: So, normally, if we only had one proposer. So this is like the status quo. This is what happens on ethereum. Now. There's a single proposer, they have a monopoly, so they're going to pick the one with a tip that goes to them, where if there's multiple proposers here, we have to collude in order to pay the tip to us, instead of the tip going to wherever the fork choice rule is. So the problem is that you can still have, let's not call it a tip, let's call it a. I don't know, this is a roll up tip and this is a proposer tip.
00:32:56.060 - 00:33:31.430, Speaker A: You can still have both of these things in both systems. It's just the fact that you can't exploit it. So with the proposer tip, they're going to pick the p tip that's best for them, and the roll up tip. Now, they simply, even though this roll up block is worse, it's tipped worse, but they're not going to pick this one. They're just going to completely leave it out of the block. And then you need censorship resistance per block because, well, oh, but I can include this block later maybe, but it might be too late.
00:33:31.810 - 00:33:42.082, Speaker D: So the assumption is that there is like one honest proposer that will take the block that has the highest roll up tip, and he's not going to care about, you might try to bribe people, but you assume that one of.
00:33:42.106 - 00:33:49.802, Speaker A: The proposals will have that block. Now you have to collude in order to have that monopoly.
00:33:49.946 - 00:33:53.106, Speaker D: So it's enough to have one honest proposal that, like, does.
00:33:53.218 - 00:34:01.842, Speaker A: It's a little bit more complex with there. It's like one third of the voting power still. You can always censor if you have one third, but you, now you can also force inclusion if you have one third.
00:34:01.946 - 00:34:10.578, Speaker B: But if there's multiple proposals in one block, aren't all the proposers going to choose the block that's built with them, with the highest tip to them, so they have the same one?
00:34:10.674 - 00:34:22.787, Speaker A: They can still definitely pick the transactions that are tipping them the best. But you're also incentivized to pick the transactions that cause the application needs to.
00:34:22.803 - 00:34:35.347, Speaker B: See the one that's best for the roll up and not best for them. But if it's always, if the roll ups are gonna. If the proposals are always greedy, even if there's like ten of them, they're all gonna pick the same block, right? One that has the highest proposal to.
00:34:35.363 - 00:34:49.410, Speaker A: It, but not, let's say that in ten here, the ten, not a single one of them. Of the ten that actually get included in the signatures of the block, that not all ten of them can't include even one of these.
00:34:51.470 - 00:34:52.766, Speaker D: You are making an assumption that there.
00:34:52.798 - 00:35:13.126, Speaker A: Are some people that are altruistic, in a sense, right? Not altruistic. It's. Yeah, honest. You have to assume that there's at least one third of the validators, one third of the voting power that's not censoring in order to have censorship resistant blocks. Yeah. Does that make sense?
00:35:13.278 - 00:35:34.600, Speaker C: So here, when you decide which transaction are going to be included before we know the content of this transaction. So that way I can buy, let's say, a transaction slot in the next block, that gateway on plan, and then once this can be reversed, it's finalized, I actually post the content of my transaction. It's another build that can because we already know the order.
00:35:37.420 - 00:35:49.360, Speaker A: I think I get it. I'm not sure, but we are going to cover order agnostic where we switch this up. You don't have to use this. I actually think this is way more boring. Yeah.
00:35:50.020 - 00:36:03.710, Speaker C: Very stupid, naive question, but for me, intuitively it feels almost backwards in the sense the main problems are the open censorship and like prior orders to builders. How does this kind of change that dynamic?
00:36:04.770 - 00:36:13.590, Speaker A: Builder censorship. So yeah, this solves the, so the censorship resistance here is key for solving builder censorship.
00:36:14.010 - 00:36:19.590, Speaker B: Censorship isn't the fact that there's multiple builders competing to multiple.
00:36:20.570 - 00:36:24.918, Speaker A: The censorship comes from multiple proposers for each block.
00:36:25.074 - 00:36:40.450, Speaker C: If you have a situation where like, you have a power law with the builders, right, same as Ethereum, and you have like most blocks being created by a couple of builders that then have like private order flow, like, does it, like, how does having multiple proposals help you?
00:36:41.270 - 00:37:03.212, Speaker A: Multiple proposers helps because if we now you can include like in here for the roll up, I can include headers that are built by these. Let's say, even if we only have three headers, three builders, I can include the headers from all three. And then I use a fork choice. So I'm sort of, I'm taking what exists on Ethereum now and I'm putting it in protocol.
00:37:03.396 - 00:37:04.760, Speaker C: So each proposal.
00:37:06.380 - 00:37:17.240, Speaker A: Yeah, yeah, yeah, it's, yeah, exactly. You should also consider like, there are multiple ways of making sensory resistance laws and multiple proposals.
00:37:21.030 - 00:37:25.450, Speaker B: So could you just have a single proposal and that proposer includes all bids?
00:37:27.670 - 00:37:29.662, Speaker A: What's forcing them to include all bids?
00:37:29.806 - 00:37:31.010, Speaker B: They get the most money.
00:37:35.710 - 00:37:41.294, Speaker A: I think they would. Does that make the assumption that the tip here is smaller than the combined.
00:37:41.342 - 00:37:57.800, Speaker B: Tips or what are you, because my initial thing is like, okay, so every single proposal, no matter how many proposals you have, will always choose the block that's built with them, with the highest tip to them. So in a homogeneous, like, network, if everyone receives the same blocks, they're all going to pick the same one, right?
00:38:01.300 - 00:38:04.524, Speaker A: As long as they include more than one. Yeah.
00:38:04.652 - 00:38:08.356, Speaker B: So like, in this case, what's to stop all proposers, including bb?
00:38:08.468 - 00:38:13.844, Speaker A: Well, there's nothing stopping from more than like one third from censoring, ever. So if you have one third, it's.
00:38:13.852 - 00:38:19.002, Speaker B: Not censoring, it's just like, that's the one that, that's the greediest algorithm.
00:38:19.106 - 00:38:25.150, Speaker A: Well, if you don't censor, now you have two. If you do censor, you have one. And now you can't use a four choice rule.
00:38:26.610 - 00:38:30.626, Speaker B: So you want to incentivize the proposer to include both bits.
00:38:30.698 - 00:38:44.788, Speaker A: Yeah. So if they include multiple transactions here, now, this tip still exists, it's just not the majority of the MeV, it's a very small portion. And now all these proposers who included transactions here, they share these tips, presumably.
00:38:44.924 - 00:38:49.068, Speaker B: Okay. But so they want to get as many of them as possible. They want a tip from BA.
00:38:49.164 - 00:38:53.980, Speaker A: If anyone's willing to submit a roll up block, it's advantageous for the proposers to include it because they get those fees.
00:38:54.060 - 00:39:15.190, Speaker B: And then that header goes into a DA block, and then the following block, the builder then submits the transactions that follow. Right. And so all builders can see the transactions that are being committed by the DA layer. So they'll see that which one wonde, which one had the highest roll up tip, and so then they'll know not to submit their transaction. Right.
00:39:15.230 - 00:39:25.118, Speaker A: Yeah. There's probably some games in there you might need, some proving systems. I'm going to wave my hands. Okay. Do you have any more questions before we move on? Yeah.
00:39:25.294 - 00:39:27.582, Speaker B: Do people understand that? I was just learning that as well.
00:39:27.686 - 00:39:49.092, Speaker A: Okay, so collecting the transactions and then like they execution afterwards as well, the proof, there's a sort of wide design space as a prover, as a builder, if you had fast enough proving, I could just include the proof with my header. We don't have that yet, though, so. Yeah.
00:39:49.156 - 00:39:49.572, Speaker C: What matters?
00:39:49.596 - 00:39:50.180, Speaker A: How many chances?
00:39:50.260 - 00:39:52.148, Speaker C: But, yeah, good point.
00:39:52.244 - 00:39:52.740, Speaker A: Yeah.
00:39:52.860 - 00:40:01.686, Speaker D: So this assumes that proposal tips are part of the box. Right, because the proposals get the tip. If this block is included then, or.
00:40:01.758 - 00:40:02.238, Speaker A: Yeah.
00:40:02.334 - 00:40:14.502, Speaker D: So what stops me from setting up system where I'm like, I will pay you a tip, but only if my block actually is the fork choice that wins. So you do the tip out of band, you're like, if you include something that will make my block, not the.
00:40:14.526 - 00:40:31.050, Speaker B: Block, I will not take, but you have to bribe all the proposers to not include the competitive block, which eventually there is probably some price, and then the idea is that hopefully that price isn't sufficient enough to encourage that. Yeah, the price of censorship. Right. Like how much? I'm just trying to understand.
00:40:31.090 - 00:40:33.322, Speaker A: Always thinking about out of band payments is always important.
00:40:33.466 - 00:40:41.770, Speaker D: Yeah, I'm just trying to understand because this seems like you're just sort of trying to make the bribe. Let's call it part of the system.
00:40:41.890 - 00:40:45.274, Speaker A: Oh, 100%. That is exactly what we're doing. Right.
00:40:45.362 - 00:40:47.338, Speaker D: What if we just take it out.
00:40:47.354 - 00:40:49.002, Speaker A: Of the system again and just fine.
00:40:49.026 - 00:40:49.778, Speaker D: We can always do that.
00:40:49.834 - 00:40:59.434, Speaker A: Yeah. Still there. You need the ability to censor. So you still have to convince the validators in either way to censor in order for this not to work.
00:40:59.562 - 00:41:00.066, Speaker D: Right?
00:41:00.178 - 00:41:15.970, Speaker A: Yeah. So as long as you don't have that ability, which is, I don't know which chains actually have that right now. But you can do it in multiple ways. You don't need multiple proposers. You can use like Cosmos right now has vote extensions. You can use vote extensions. People do that right now.
00:41:15.970 - 00:41:44.710, Speaker A: They sell at the top of the block. Yeah. Okay. We don't have much time on, I want to cover the cool thing more. This is the boring thing. This is good because we can still capture value, but it's also still really lame because it's not captured. The value is going to the application and maybe we want the value to go to the user and that might be a bit more complex.
00:41:44.710 - 00:42:26.458, Speaker A: And we have more tools there though. We have more tools if we use something that is more order agnostic. So the order agnostic way of doing this is you actually post your transactions first. So instead of having a builder here that has this private order flow that I get things, we're going to do the original thing that Colin was talking about. We're going to take our transactions, we're going to submit them directly to the DA layer or a sequencing layer, however you want to call it. So now we have these two transactions here. And now these two transactions are, these are timestamped, they're published and they must be included in the next block in some way.
00:42:26.458 - 00:43:00.394, Speaker A: That doesn't mean that they get executed, it just means that they're part of protocol now. Right. So now I have these two transactions here. We're going to go to our execution and we are going to, in this order agnostic way I can have, well actually I take it back, it doesn't have to be order agnostic. The ordering of these transactions doesn't necessarily have to be order agnostic. But you can publish things first. And now I can have headers, I can have a block builder submit headers.
00:43:00.394 - 00:43:12.312, Speaker A: So we still have the same form before. So we publish all the transactions. And now we have builders. They're going to build these blocks. So I'm going to just these roll up blocks.
00:43:12.496 - 00:43:13.960, Speaker B: Your squares are getting worse.
00:43:14.120 - 00:43:43.584, Speaker A: That one's a house, that one's a square. So we're going to take these transactions that are directly submitted first, and then now these builders, they have to build the block in the way that fulfills some optimization function in the best way. So whatever that is now here, I think you can get a lot more creative than just using the traditional proverb, builder separation and stick it in protocol. Sure you can do that. It's a little bit boring. This is more fun.
00:43:43.712 - 00:44:05.880, Speaker B: So what you're just saying to like repeat the point here is the proposal. Like the DA proposer, no matter which way they order the transactions, that can be overridden by how the builder proposes how those transactions should be ordered. Exactly. So it's, even if you can't bribe the proposal of celestial or any other DA layer, because that isn't actually what might be the way it's expected.
00:44:05.920 - 00:44:41.300, Speaker A: That's why I like to say time stampede, because it's sort of, it's the same thing as saying ordered, but it's saying that like these transactions have a timestamp if you need it, but in reality it's more just inclusion. So they, these transactions get included. These builders, they're going to build headers that are fulfill some function with amms. Like a fun one is like you use some convex function to optimize the amm. Let's say you want to optimize for LP's. I want my block. Whoever can organize these transactions in the best way to give LP's the most money.
00:44:41.300 - 00:45:05.080, Speaker A: And let's say this person does it. Now this is the block, that's the canonical block for the roll up. And the roll up will just rebuild on that block. And I think that's this way of first posting transactions and then getting clever with how you actually order them, or even ordering them deterministically in some cases is way more fun.
00:45:06.180 - 00:45:12.524, Speaker B: In that case, would they also do the execution and the proof of execution if the data is already done?
00:45:12.572 - 00:45:38.310, Speaker A: Yeah, you could do it here. And the fun thing here is why I think this is more fun is because if we go back to that liquidation example, and when you have proof of builder separation, you're extracting the maximum amount that you can. And at least it's not going to the proposal now, but it's still abstracted. And now you have to find a way to give that back to users. And most of the times, token holders and users are not the same thing. Screw token holders anyway. Yes.
00:45:38.310 - 00:46:09.260, Speaker A: Thank you. So we don't really care about token holders, we care about users. So in the case of having an order agnostic in here, you can have an order agnostic application. When the order doesn't actually matter. The application, instead of picking it, holds the auction in protocol still. So we're still holding these auctions in protocol, but now the auction is directly based on the transaction that refunds the user the most. That's the transaction that we pick because that's what we care about.
00:46:09.260 - 00:46:13.660, Speaker A: There. Mev. Solved. It's that simple.
00:46:15.720 - 00:46:17.808, Speaker D: Are there any disadvantages of this approach?
00:46:17.944 - 00:46:18.592, Speaker A: No disadvantage.
00:46:18.616 - 00:46:18.752, Speaker B: No.
00:46:18.776 - 00:46:19.500, Speaker A: Just kidding.
00:46:22.760 - 00:46:30.376, Speaker D: You lose something because transactions are private before they're executed. I assume you might be two faster chains in a sense.
00:46:30.408 - 00:46:30.552, Speaker A: Right.
00:46:30.576 - 00:46:34.980, Speaker D: They might see a transaction that were posted to you and then they might do something based on them.
00:46:35.560 - 00:46:46.552, Speaker A: There could be something there. Yeah, there's. I guarantee that there are. I don't know them. Yeah. Yeah. So that's for someone else.
00:46:46.552 - 00:47:06.720, Speaker A: No, I'm kidding. I'm kidding. But like, sometimes there's just so many different possibilities that can occur that I think you just have to get the system live and we're just going to have to. It's going to be a few years. We're going to demo it. We're going to see that actually totally is bonked. This doesn't work or something like that, and we just have to figure it out anyway.
00:47:06.720 - 00:47:07.900, Speaker A: I think we're out of time.
00:47:09.120 - 00:47:12.000, Speaker B: Yeah, I think we have a ten minute break right before the next people come on.
