00:00:01.720 - 00:00:36.544, Speaker A: Gblend. Gblend. Yep. I'm Dino, one of the co founders of fluent. And I'm going to be mostly talking about applications, actually, not necessarily blended execution, definitely not like the underlying tech and stuff. So try to keep it high level, try to keep it interesting and title your favorite apps are blended. All right, so a few kind of main topics we're going to be talking about learning from how the cloud scaled.
00:00:36.544 - 00:01:17.724, Speaker A: There's some lessons in there we're going to talk about. We're going to assess the current state of execution environments and we are going to outline a better path forward for execution environments. So the first thing is we spend a ton of time in crypto talking about the next billion users and the next million developers. And the reality is we don't even have like a million users yet. So it's like we probably should be spending a little bit more time talking about some of the lessons we can learn from the spaces that actually have a million devs and a million users. Billions of users, actually. You could see here like your typical social app, multiple billions of users and many millions of devs actually.
00:01:17.724 - 00:01:53.218, Speaker A: So maybe we can learn a thing from them. And so what they got right, in my opinion, is taking these individual functions of an application. So this is supposed to be like an Amazon type thing. So take a search function, a payments function, a ratings function, and breaking that up into loosely coupled services. And they're like, hey, over 20 years they realize like, hey, it scales way better this way. And we can update things, like different teams can iterate really quickly, work on different parts of the app, can update things, scale them better. And the reason we're all here is because we obviously learned a thing or two from that.
00:01:53.218 - 00:03:01.980, Speaker A: We said, hey, the big fat piece of code doesn't really scale well. So let's like chop things up and modularize. And so the main point here, which I think that they learned in the cloud, is that if you give developers like the best tool for each task or the best kind of tool for each function or module or whatever you want to call it, a in modular land, this is kind of applicable to the core architecture, you end up with better products. And so the question is, what can we learn from, what else can we learn from how other computing paradigms have been successful today? And we can just zoom in to the modular side of that last diagram and unpack the actual modules themselves within a given execution environment. Most likely, since it probably won't be that interesting to talk about like search, we're going to go to a hopefully much more relevant or familiar example. And we're going to talk about the front end of Figma. Most of you probably are aware of Figma, but in case you're not, it's a collaborative design tool that's built for the browser.
00:03:01.980 - 00:03:42.042, Speaker A: And they basically managed to find a way in this very constrained computing environment of the browser that isn't very flexible. They found a way to actually, you know, offer a unique application that wasn't possible before and clearly a ten x application to disrupt the design industry. So it's like, what can we learn from like some of those design principles? And the way I break it down, like this is the figment interface, in case you're not familiar. But there's kind of, I'll break it down into like two core parts. There's like the middle area, which is like this main panel that's, that's highlighted, and it's the meaty part of it. And this is where you'd have like all of your, all the files, there could be hundreds or thousands of files. And basically that is kind of hard to do.
00:03:42.042 - 00:04:19.170, Speaker A: Typically in a browser environment, it has to be really performant. And in their case, their design goal is 60 frames per second, so there's not any lag. A very different design goal is on the layers and properties panel, and so this is less performance sensitive. But the main design goal there is to make it as easy to like, easy for developers to quickly iterate on. So it's important to have a ton of libraries that are sitting there waiting as building blocks for developers to iterate on quickly. But it's not that heavy compute. So these are very, very different goals.
00:04:19.170 - 00:05:05.694, Speaker A: So what do, how built? And what they ended up concluding is that it's best to handle the different design goals with two very, very different languages. So in their case, C and typescript. So the layers and properties panels on the right and left side, they're basically, they're written in typescript. For the most part, figures are written in typescript, but then what they do is they use c for the core rendering engine because it has to be very performant. And so what's kind of the net takeaway there? In my opinion, it's that the best tool for each job kind of can create the better products. In their case, a $20 billion product that disrupted the whole industry. Let's actually use another example that's, I mean, not everybody's a designer, and maybe you're not super familiar with Figma.
00:05:05.694 - 00:06:04.510, Speaker A: Let's actually use one that probably hits closer to home, which is telegram. I'm sure everyone here spends way too much time on Telegram, but it's the same basic idea. So, like most of Telegram, at least the web version of Telegram is written in typescript. But there's a few core things that they actually use, whether it's c, four, or just some other, in their case, wasm based language libraries for different specific actions, whether it's because those parts of the app need to be highly performant and to make more sense in circumental, or maybe some other language has some interesting building blocks, these pre built libraries that they just want to plug in. So one example here, I don't know how this is going to come up, because it's supposed to be a gif, but I think it has to be a video. If you've ever used the animations or stickers or anything in Telegram, you'll notice that you're interacting with c, which you don't really think about because you're using a web app. But it's really the case behind the scenes.
00:06:04.510 - 00:06:43.602, Speaker A: I guess it was a time video. Okay. And so those are not the two only applications. I mean, so many of the applications, your favorite apps that you might use on a daily basis, whether you interact with them directly or whether they're sitting behind the scenes like a cloudflare, like they still exist, and they're built using these types of principles of, like, using the best tool for the job. Okay, let's contrast that with crypto execution environments today. So just like blockchain execution, what does that look like? And what we see is a very different level of expressivity for developers. It's very siloed if you're somebody.
00:06:43.602 - 00:07:17.930, Speaker A: And by the way, this is not making a case against a bunch of rollups. We actually see that vision, too. That's not going to be the point of the rest of this talk, but just a quick clarifier. But if you're somebody who is trying to build within a given sandbox, if you're trying to build the best Dex or the best whatever possible, and that particular application, you're confined. You can't use the best tools for each part of that application at all. Even just the notion of being an EVM developer, an SVM developer, is kind of silly. That's why, of course, you got more ECC side events than actual web3 apps.
00:07:17.930 - 00:07:56.556, Speaker A: And so I'll actually go as far as making the statement that we will never get mass market applications with these really constrained computing environments. So what do. Oh, what was that? So what we're proposing is a new type of vm called a blended vm. And the main idea here is you kind of have this one state machine that can support applications from all different types of environments that are atomically composable in real time. They're sitting there, it feels like one. It really just feels like it's one VM at the end of the day. And it really feels like that.
00:07:56.556 - 00:08:39.784, Speaker A: For a developer, there are like a lot of, from what we found doing research, there's other types of implementations where it might seem like it's multiple different vms together, and maybe that's how they implement it. But either way, we haven't really found it done in a very elegant way. And this just feels like one unified environment for a developer. And just to make that a little bit more concrete, what do you get? I'm not going to talk about the inner workings of it. We could save that for another talk. But what do you get? Dozens of programming languages, millions of software libraries, all in one place. And just to point out a specific application, get a little bit more concrete, even this is an example chess game.
00:08:39.784 - 00:09:19.550, Speaker A: I guess you can't. I don't know how that actually renders, but there's one part of it that's in solid. We built it, there's one part of it that's in solidity for the most part. The thing is in solidity, but it's using rust for the core game engines, using a rust library. And the cool thing about it is to a user, the user doesn't feel that the user doesn't interface with that to them, just using their EVM wallet. The only way they experience that application is either being an application that's now possible all of a sudden, or just a faster one, or something like that, or just with better features, using libraries that somebody took. So that's just a really simple example just to ground it, because I know sometimes you can get abstract without that, but we envision a lot more things.
00:09:19.550 - 00:09:59.982, Speaker A: Here's just a snippet from Twitter, from someone in the gaming community, and we already start to see kind of like the juices flowing around what can be done in this type of blended vm. And we're really excited to see what people build around Devnet right now. One thing I want to point out is fluent specifically is focused on, as you probably saw on the other slide, EVM WASM SVM apps. But we think this is just a better way to build execution environments like this type of design. And we would hope that other people maybe prioritize different types of vms to blend together. And we envision not if there's going to be a million, we'll call them single execution networks. We would love to see a million blended execution networks.
00:09:59.982 - 00:10:33.610, Speaker A: So, yeah, excited to see what people build with this, we're starting to hear some really awesome ideas. And just to reemphasize, I mean, that's basically the end of my talk. Just want to reemphasize the main point here that I think for us to actually build these ten x applications that anybody gives a shit about, we have to start giving developers the flexibility to easily use the best tool for each job. And I think that's when you get the best products. And then, and here's a spaceman meme. All right, thank you. Yeah, that's it.
