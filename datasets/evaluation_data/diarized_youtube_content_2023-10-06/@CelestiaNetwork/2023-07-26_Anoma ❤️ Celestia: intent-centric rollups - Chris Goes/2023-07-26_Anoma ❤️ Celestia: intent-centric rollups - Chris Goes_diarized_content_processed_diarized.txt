00:00:01.450 - 00:00:27.910, Speaker A: Let's see if I can answer any of those questions. All right, so if you read the schedule, I think I started with initially a slightly different title, which was something like privacy preserving Runtime Rollups for Efficient DA Sampling. But I've been sometimes told that I use too many words, so I tried to simplify it and now it's just intent centric roll ups. I'm Christopher. Thanks for coming. Wow, this is a beautiful venue. You may know me as the co founder of the Noma Project.
00:00:27.910 - 00:01:04.318, Speaker A: I also worked on IBC before, but really I'm just an armchair philosopher in denial. So this talk started by a little bit of a meditation of mine on what exactly is a roll up and as know, maybe adjacent to, but not always part of the modular ecosystem. This has not been entirely clear to me. So on Monday I went to the Celestia.org Glossary, which seemed like a good canonical place to look this up and found this definition quote a roll up is a type of blockchain that offloads some work to a layer one. Like Celestia good marketing rollups host applications and process user transactions. Once those transactions get processed, they are then published to layer one.
00:01:04.318 - 00:01:47.754, Speaker A: It's layer one's job to order those transactions and check that they are available at minimum. It's a good definition, but there are three words here that I think we might come back to later in this talk and those three words are type of blockchain. So I ask you now just to meditate, what exactly is a type of blockchain? But for now, let's move on to a term that is even more criminally underdefined, which is intent. So what is an intent? Anoma has been using this word for a while. We've been perhaps criminally vague about what exactly it means. We wrote it down in some ways, but it recently became popular. Honestly, I think it has very little to do with us because a lot of people are using it in a lot of ways that are not perhaps exactly the ways that we went, but they seem to be sort of correlated.
00:01:47.754 - 00:02:29.546, Speaker A: So here are a few takes on intents. There's uma, from Succinct talking about intents for cross chain bridging UX very important at Research Day in New York. Here's Penumbra talking about intents for user basically user wallets intents for users thinking about how to declare what they want a transaction to do or not do. Then of course we have the radical takes tux intents, turn your front upside down, get your kids to call you back. Intense are a girl's best friend. Okay, so maybe back off a little bit. And if we language is like OG decentralized coordination scheme, right? And we don't really get to pick individually what exactly terms mean to me.
00:02:29.546 - 00:03:44.638, Speaker A: The interesting question is when you zoom out and look at how people are using words, there's some commonality here, right? There's a reason the word intent became popular so quickly, so fast, and that people can use it with each other. And they all seem to understand like, roughly what they mean. And I think what they mean is that an intent is, if you put it in kind of slightly more mathematical terms, an intent is a commitment to a preference function over the state space of a given system, right? So as opposed to a transaction which specifies a specific imperative execution path, do A, then B, then c, an intent says, I want an execution path that satisfies these constraints, right? I have these preferences over what gets executed in the state space of a given system. This is what varies, right? So when Uma is talking about cross chain bridging, the system is like the chains that you're interested in bridging between when anoma is talking about who knows what. As we'll get into a little bit later, the system is like the information flow, right? So the bounds of what the system is that the intent refers to can change. But in all cases, intents are these sort of like commitments, credible commitments to preference functions. So I want to zoom out a little bit and kind of just analyze like, okay, so here on one side for the modular ecosystem, there's this concept of roll ups, and everything is kind of organized around roll ups.
00:03:44.638 - 00:04:10.090, Speaker A: And from our land, we come from the concept of intents, and everything is organized around intents. And I think these are two interesting concepts because they come at the problem from different directions. To me, roll ups are kind of bottom up. Like, you start with this modular thesis. You start with data availability as the base layer, and then you sort of build roll ups on top of that. And then we see a kind of proliferation of different execution environments, different approaches to sharding, as was covered in the last talk, stuff like this. So roll ups come at things bottom up.
00:04:10.090 - 00:04:55.926, Speaker A: To me at least, intents come at things, quote, unquote, top down, or like users down. Like, users have intents, right? They're always going to start with intents, and the system had better figure out how to do something reasonable. In some senses, as system architects, we actually don't get to choose. Users are going to have their intentions, their intents when using the system, and we just have to try to build something that can satisfy those as credibly and fairly as possible. So in particular, I want to ask the question of can intents sort of help out the modular ecosystem? So Mustafa, in his talk earlier brought up a bunch of challenges at the end and kind of open problems. And I have a slightly different list, but I think it shares several components. So three challenges for modular, as I see it at the moment, just kind of an architectural paradigm.
00:04:55.926 - 00:05:46.330, Speaker A: Are these inefficient sharding, application lock in and user facing complexity and by challenges? I don't mean like flaws, I want to be clear. I just mean as the ecosystem is sort of moving at the moment, if we try and foresee what might happen and try and avoid some potential problems while we still have a chance to steer things, here are a few things I think we should just sort of be cognizant of. And I bring them up here because maybe I think intents can help, but let's just go over what they are first. So challenge number one is inefficient Sharding, the most expensive thing in the world of distributed systems is atomicity. Because atomicity requires that you send messages to one place and you order them there. And that always implies at least some kind of N squared consensus communication. And it just means that you have to be processing things in like one location, right? It's the typical problem of sequential behavior in concurrent systems.
00:05:46.330 - 00:06:42.454, Speaker A: Users of course, want everything. In particular, they seem to want cross roll up transactions, applications, interactions, token transfers, stuff like this. So users are not going to be thinking about like, oh, I should put all my state on roll up once that it's most efficient. No users are going to say I have asset here, I want asset there, do something, make it work. And it's our job to try and make it work. And one, in making it work, we want to kind of give as much freedom as possible when it's properly constrained to the operators of the system to make it more efficient. So in particular, if we envision a world of roll ups and all of the roll ups have different applications, right, and the applications are like bound to specific roll ups and users want to do lots of cross application interactions, then we've added this weird constraint where it's like there's a sort of demand for atomicity, right? Like users want to interact with application A on roll up one and application B on roll up two and they want that interaction to happen atomically.
00:06:42.454 - 00:07:15.478, Speaker A: Or there's a bunch of shared state. And if we tie applications to roll ups and kind of have separate sequencers, then we get this sort of static sharding system where we can't change the topology of which different roll ups are settled atomically, right? It's static. And if we view kind of the demand for atomicity as varying over time, perhaps dynamically, this seems to me like it's inefficient. We've sort of out of this constraint. So that's challenge number one. Challenge number two is application lock in. One of the great things about the modular stack is that you can build heterogeneous execution layers very cheaply because it doesn't require deploying a whole layer one.
00:07:15.478 - 00:08:09.190, Speaker A: But one challenge with heterogeneous sort of heterogeneous protocol execution layers is that they make applications less portable. So the EVM, for example, is interesting VM, of course it changes quite slowly. One thing that I would like very selfishly often is for the EVM to add new pre compiles for new curves so we can do more efficient cryptography. And it would be easy to launch a rollup that forks the EVM and adds a new pre compile for a curve. Right? But one disadvantage if you sort of look at this from the application sort of whole ecosystem perspective is that then if other roll ups don't also adopt this new opcode, the app is kind of locked in. Like if the sequencer of that roll up starts charging higher fees, if users can't easily switch, if there's a bunch of application state that gets tied to this very specific different execution system, the application can get kind of locked in. And this means that apps may be paying really for more and more kind of atomicity than strictly speaking, necessary.
00:08:09.190 - 00:09:15.770, Speaker A: And the third challenge I see is user facing complexity. So one modular component selection and certainly modular component construction adds a lot of clarity to the design process of blockchains and allows different teams to work on different parts, which I think is very helpful from a coordination perspective. But especially if these different parts are operated by different sequencers, different validator sets, it tends to entail some complex security assumptions. So if we think about this from the perspective of a user and what the user has to reason about in order to know whether their interaction is safe, right? Something like this, if there are different parties for solving execution, data availability, all of these components of the modular stack, that's a lot for the user to think about, right? Different interactions require different safety levels. The user is not going to, every time they send an intent, send a transaction, the user is not going to reason through all of the sort of crypto economic calculus of is this thing in fact safe? Right, given all of these specifics. So I think user facing complexity can be a challenge, sort of one that requires that we come up with good standards for describing what these security assumptions are. And also we want to always maintain the know, as Mustafa mentioned, kind of sovereignty.
00:09:15.770 - 00:10:10.906, Speaker A: To me, sovereignty also includes the ability for users to easily switch if something goes wrong, right? Communities like own the system, they give it value by bringing their applications, bringing their intents to the blockchain, and they should have the ability to switch away and in particular to kind of credibly threaten to switch so that they don't have to actually do it because it's cheaper. Right? So I'm going to postulate a kind of thought experiment here and see if it might help with some of these challenges. And that thought experiment is what if at the moment, applications, as I understand, and I could be slightly wrong, but as I understand, applications are kind of defined on top of roll ups in the modular stack right there's, data availability layer, some execution, there are particular roll ups. Those roll ups have state formats. They have instruction sets. They have VMs, stuff like this. Then applications are defined on top of the roll ups, right? And I propose a different way of defining applications, which is to define applications as intents.
00:10:10.906 - 00:11:06.046, Speaker A: So in anoma an intent is kind of opinionated about some things and unappeniented about other things. So, in particular, intents specify which parts of state they must modify atomically, right? If we think about the whole system as having a sharded state where the state is sharded by concurrency domains and different security domains, intents specify sort of in an explicitly include fashion, which parts of state they must modify. The state can be held on different domains. If you require atomic settlement between two completely different validator sets, that's not possible, right? But you can specify in the intents which things you need to be atomic and the kind of custodians or the validator sequencers in charge of that state must sign. Right? And I think one way of kind of understanding the relation of this to roll ups. So we have a concept we call partial solving. And partial solving is like, if you have some intents, let's just describe the intents abstract claims.
00:11:06.046 - 00:11:22.994, Speaker A: Let's say one intent. This is the one on the top left here is Alice. And Alice wants to trade star for dolphin, right? We have another intent that's Bob. Bob wants to trade dolphin for tree. Then we have the third intent, Charlie. Charlie wants to trade tree for star. Right? Okay, we have something we call solving.
00:11:22.994 - 00:11:44.250, Speaker A: Solving basically means matching intents. And solving can be done fully. When you take a bunch of intents, you match them completely. You get a fully balanced transaction, or it can be done partially. This particular diagram gives an example of partial solving. So in this example, we take Alice's intent and Bob's intent. And Bob already has something Alice wants, right? Bob already has a dolphin.
00:11:44.250 - 00:12:41.706, Speaker A: So we take Bob's dolphin and we send it to Alice. And then we craft a new intent that now requires that we get a tree and give a star, right? So we can do this kind of partial solving by combining two intents, doing some kind of simplification, and creating a new intent that we then self send elsewhere to do some more solving later. So if you think about it abstractly, if we have, like, an A for B intent, a B for C intent, partial solving just takes those two intents, combines them, and makes an A for C intent, right? Then in this particular example, in the second stage of solving, we have this partially solved intent, and we match it then with Charlie's intent. And then we get a fully balanced transaction where everyone's assets get swapped. Just a three party barter. So what is partial solving? I postulate that partial solving is a roll up. So if we think about type of blockchain, what does type of blockchain mean? I mean, I think there's some hash linking involved.
00:12:41.706 - 00:13:03.510, Speaker A: There's like some history. We need to be able to verify this later. Partial solving satisfies all of those properties. It's just kind of on demand. Right? We look at the intents, we do some kind of partial state change sending in this case Alice's no, sorry, sending Bob's Dolphin to Alice. We have some state changes that we still need to do. We commit to those.
00:13:03.510 - 00:13:34.314, Speaker A: We can perhaps in Anoma's case, we can make them private. We can even roll them up in a ZK proof so we have zero knowledge and computational compression. So that's like a ZK roll up and then we send it onwards. Right? Now, what is not fixed in this particular design is that we don't fix what has to happen afterwards. Right? So we just take these two intents, we see that we can do some simplification, we make a roll up. This is what sometimes we've been calling runtime roll ups or on demand roll up. And then we can send that partially solved, partially rolled up intent onwards.
00:13:34.314 - 00:14:08.214, Speaker A: We can do some more rolling up. And then as soon as it's fully balanced, it's like a transaction and can be settled somewhere. Right? So in a kind of intent centric view of roll ups, partial solving and roll up creation are just the same thing. So maybe the difference with some of the current modular stack is just that roll ups are created on demand. Right? And I think that this has some advantages. It allows for this kind of global compositionality in determining the actual topology of sharding at runtime. Right? Just like when you're processing intents around the network, it preserves local liveness.
00:14:08.214 - 00:14:54.090, Speaker A: It does require standardizing on a state format. This is perhaps controversial, but I think that we can do this in a way that doesn't really constrain choices. One nice thing about the way intents work is that intents specify verification conditions, not the execution method, which means that you could have different instruction sets. So you could preserve basically heterogeneity of execution systems as long as you have the ability to verify. Right? So think about it like if everything is a ZK roll up, then intents specify conditions for verifying, like the other guy's ZK rollup. If the other guy uses some other opcodes internally, you don't care as long as the condition is eventually satisfied. So in some sense it's a standard which allows you to agree on as little as possible, which is always good in distributed systems.
00:14:54.090 - 00:15:21.970, Speaker A: Right? So intense sender roll ups enable dynamic sharding. Choosing shards at Runtime, intents can specify which consensus providers they're okay with. They can specify more options. So you don't need to fix, like sending your transaction to one specific roll up. You can say, okay, I want the cheapest settlement subject to these conditions, and here are the security assumptions I'm okay with. This enables the network to dynamically sort into independent atomic bundles. So it should end up being cheaper for users.
00:15:21.970 - 00:15:58.686, Speaker A: Defining applications by intent formats, if done well in kind of standardized, should help a lot with application portability, because applications then are not they're not tied to a specific roll up. They can sort of move freely across roll ups. And maybe heterogeneous instruction sets become more like specialized solving algorithms for different domains. The same application can shard its state according to what users want. Right. So you can move code and data across chain, and application portability in particular gives you as a community or as an application user, a credible threat to fork out extractive operators. Right, because it's easy to move your application code and logic somewhere else.
00:15:58.686 - 00:16:38.042, Speaker A: Everything is kind of standardized to a sufficient degree. Then if someone is charging if they're, like, extracting a lot of mev, if they're charging high fees to withdraw your assets over bridges or something like this, then you have a credible threat that you can just leave. And I think you need this in order to constrain the kind of operator extraction and these systems. Then specifically in Enoma. We've been spending a lot of time trying to craft a good framework for describing, declaratively what information flow users want to allow in intents. So this looks basically like declarative constraints. Intents can say that in conjunction with this atomic settlement, this value X must be revealed to A and B.
00:16:38.042 - 00:17:20.642, Speaker A: So X could be a note, could be a key. It could say, this value Y must be revealed to some other party C at block one, two, three in the future. And these kind of declarative information flow constraints enable things like cross roll up, private bridging, new auction designs, privacy preserving governments, programmatic disclosure of aggregate data. Yeah, a lot. Information flow control, if done properly, I think can be quite general. So what is a blockchain? I'm back to this question, and personally, I think a blockchain is a data structure. Like, if you take a piece of data and you hash another piece of data and you include it, you've just gotten a kind of partial ordering relation, and this is the essential thing.
00:17:20.642 - 00:17:46.142, Speaker A: And everything else perhaps can be separated with intent. Centric roll ups, we just create blockchains on demand. They live very ephemeral lives. A blockchain exists for a second when two intents are matched, and then it's kind of rolled up, and then you can verify it later, but you need to store the data somewhere. There's still data availability. But the blockchains are really quite ephemeral. And whether something is an L one, an L two, or L three is just an observer dependent finality choice.
00:17:46.142 - 00:18:08.054, Speaker A: So shout out to John Charb from DBA. This is kind of my meme summary of this talk. Roll ups are l. Two S roll ups are just L ones. Roll ups aren't real. Blockchains are real. Okay, so finally, a few kind of grab bag slides of just interesting points that I think come up when you look at things in this way.
00:18:08.054 - 00:19:18.718, Speaker A: So if we conceive of a world of like, what do the economics of these different systems look like in a world that's modular with intents? And shout out to Zaki who I think had a Tweet that says something roughly like this I see kind of two classes of maybe value capture or like two classes of things people will want in an intense sensor modular world. And the first class and this is like maybe this will be controversial to call it a dow but the first class I'm going to call service provider Dows. And the reason I call them dows is because there's like a group of validators or operators who are working together and are providing services as a collective and they're like coordinating to provide that service efficiently and reliably. But users or sort of applications see it as a service provided as a whole, right? So I would say that one kind of Dao you can have in an intent centric modular world is a data availability Dao which provides data availability and ordering. And there's some slight differences here but at the moment Celestia and Ethereum and the kind of roll up centric roadmap data availability, host layer model are providing this kind of service, right? Then you could have some kind of execution DAOs. Maybe current rollups are like this. You could have solver know, Suave, as I understand it, is like this.
00:19:18.718 - 00:20:01.606, Speaker A: And these service provider DAOs are competing on the basis of liquidity and sort of role specific optimizations, right? They're like providing really efficient data availability sampling. They're providing more private solvers. In the case of Suave using SGX, they're providing some specific service that they think people want, right? Then they're just assets. People want people still want Bitcoin, they want ETH somehow they still want the almighty American Empire bucks on the blockchain. And those assets are competing independently of protocols, right? They're competing on the basis of distributions and how good they are at public goods funding. So three concluding thoughts here. One I think intense and modular are like a match made in heaven.
00:20:01.606 - 00:20:20.606, Speaker A: They come at the problem from opposite directions. They can kind of help solve each other's problems. An intent centric architecture. I didn't have time to go over all of it in this talk. But one challenge we've had building anoma is simply that we don't have specialized primitives, right? Like we don't have efficient DA sampling. We don't have these individually optimized things. So I think there's a very nice synergy.
00:20:20.606 - 00:21:17.640, Speaker A: There. One thing I also really like about the modular blockchain world and kind of some of the conversations we're having here is that it seems like it's sort of a fusion of ethereum and cosmos of the polycentric or self sovereign political ideology with the kind of clear architectural thinking of the Ethereum ecosystem. This also maps like Celestia, anoma many of these teams in the modular world came from Cosmos or worked on Cosmos, and we're now kind of converging with ethereum. And finally, I have a kind of shout out similar to something Mustafa mentioned, which is that let's please, please not remake the mistake of building a lot of transparent blockchains that are not going to work. Like, if you're trying to launch a transparent roll up and it's not for some cute game, maybe this is okay. But if you're trying to launch a transparent roll up for financial settlement and you are going to spend years on this, and you're going to spend a marketing budget, and you're going to spend go to market effort and you're going to convince a lot of people to use it, make it private, don't make it public. It's not going to work.
00:21:17.640 - 00:21:19.940, Speaker A: That's it. Thank you.
