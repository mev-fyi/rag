00:00:16.040 - 00:00:40.634, Speaker A: Hello, everyone. Welcome and GM. My name is Josh. I am from celestial Labs, and today I'm excited to welcome Mads, uh, also known as rain and coffee, from Maven Eleven. Today we're going to be having another infinite space bazaar workshop, and we'll be learning about customization and specialization, building apps with modular infrastructure. Mads, it's great to have you here.
00:00:40.974 - 00:00:44.074, Speaker B: Thanks for having me, and good to see you again.
00:00:44.374 - 00:00:50.834, Speaker A: Likewise. So, I know you work for Maven Eleven. What do you do there?
00:00:51.794 - 00:01:25.564, Speaker B: I do what we call research. And some people might refer to this as, like, lowercase research. So I'm not a professor, I'm not an engineer, but I have spent the last decade in crypto. So I spent a lot of time reading, gaining knowledge. And what I do there, essentially is I'm responsible for a lot of our technical DD. So when we look at projects, like I said, Asia, although the actual investment admin eleven was a little bit earlier than when I joined, which was two and a half years ago. But I also do a lot of portfolio help.
00:01:25.564 - 00:01:53.234, Speaker B: So as I'm looking at a lot of stuff that we look at, I generally have a pretty good view of what's going on. I might have specific knowledge on topics that the port code in question might not have, so I help out there as well. And then, of course, sit on the investment committee at Maven eleven. And I also spent a lot of time writing, so you might have seen some of that on Twitter, which is specifically where we release our articles. And I'm generally the writer for all of this.
00:01:54.654 - 00:02:04.714, Speaker A: Awesome. I'm happy to learn more from you. I'm sure everyone else is as well. And without further ado, I'll let you get to it.
00:02:05.854 - 00:02:40.984, Speaker B: Perfect. Sounds good. Yeah. So, as Jess pointed out, I'll be talking about specifically why I think you should be building apps with modular infrastructure. So generally, most of the apps that we've seen built in crypto and web3 are generally built with or on a generalizable smart contract chain. So that could be an ethereum, it could be even a roll up, like an arbitrary monoptimism that also just generalizable that you gain from doing this. And these are, I put them in sort of three perspectives, which is customization, curation, and specialization.
00:02:40.984 - 00:03:13.754, Speaker B: And let's dive into it. So we'll sort of go over first just some specifics so you sort of know where I'm coming from. This is to set the lay of the land. Why model infrast different from monolithic infra, and how this differs from things like modular software. And then we'll get into like why I think these apps actually start to become infrastructure, the powers that it provides them with. And there's several ways of doing this, and we'll get into some of those. And why I think specifically most of them don't make a lot of sense for most applications.
00:03:13.754 - 00:04:06.654, Speaker B: And why, particularly building on a DA layer only as a sovereign roll up, for example, or even on unshare sequence on a sovereign rollout makes a lot more sense. And the whys are sort of, as pointed out, particularly around the customization and specialization within these you have specifically ordering. So we'll spend quite some time ordering as this relates a lot to monetization, specifically for Defi applications. And we'll also look at things like customization and complementation. When I say complementation, I refer to the fact that you can lower the cost of running most of your infrastructure, that in the current day and age are probably quite expensive in a lot of places. And these customization things could be related to building completely new types of applications. Maybe they're dependent on some specific type of CK setup that you might not have on an existing chain.
00:04:06.654 - 00:04:38.864, Speaker B: And then we'll touch a little bit on curation. And this ties into the word intents and a lot of the words that we've seen there and how you can outsource. Love that as well. So the methodology I'm using is, and the danger of coming up with too many new words, I just say monolithic appchain. So a monolithic app chain should be a chain like osmosis. So it's an app chain that does everything by itself. So it's integrated ta, consensus, execution, settlement, whatever you want to call it, a modeler app chain.
00:04:38.864 - 00:05:27.694, Speaker B: I generally also call a application specific roll up. So this is an app chain. It could be a DeFi application, it could be a shellshield application that only handles some aspect of what a blockchain does. So they might have outsourced the developability consensus to Celestia, and they're settling onto some other chain that could be a place like a dimension or in ITIA or Astria, and then maybe they handle execution themselves. And what we all see is this rise of modular software. So with things like the customer SDK, with sovereign SDK, we're seeing a lot of easier access to actually building new types of applications, specifically as roll ups. And what a model that protocol is, is just a chain doing one specific thing.
00:05:27.694 - 00:06:16.234, Speaker B: So CSS, data availability and modeler software is more what you can use to build these specific types of modular protocols. And a merger of that is sort of happening with these things. So I could build a roll up on solar Celestia using I think like op stack, Rolekit, sovereign SDK, or even the custom SDK. And now we sort of get into the reason for why you'd actually want to become an infrastructure as an application. And I put it into two buckets. So you have the economic reasonings which are probably most prevalent for EFI applications. So on Ethereum application might create a lot of MEV, but none of that MEV actually gets recaptured back to the application that is quote unquote trading it.
00:06:16.234 - 00:07:00.012, Speaker B: And we'll get into how we can start to fix that and solve some of these issues further down. We also get resource pricing efficiency. So I'm not sharing the entire research compute of a specific chain with other apps. So on Ethereum, obviously sharing Ethereum block space with a ton of other applications, and that goes for most other existing chains in question at this point. And you also just get the result of having warehouse of block space here. So you have your own specific sort of warehouse where your block space is your block space, and you can decide what it costs, what it does, and how much it costs to run it. While that is not the case on a generalizable chain, and then we have the second bucket, which is the customization reasons here.
00:07:00.012 - 00:07:56.398, Speaker B: This is specifically relevant for applications that are trying to do things they can't do on a geolidable chain. So there could be an opcode that they want, but because of the way social consensus works, and having a massive decentralized network, getting that included on Ethereum could take years. And you might be dependent on this. So it might make more sense for you to build a roll up where you can have that specific opcode or precompile or specific curbs of board. So that's also what we're seeing with this sort of new wave of CK verification layers that are trying to support more expressive CK schemes or even cheaper ways to verify this. And as with that, we all see a rise of customizable and alternative vms. So while obviously the EVM is still king in terms of developer community, there's a lot more newer applications coming in here as well, and newer vms.
00:07:56.398 - 00:08:46.474, Speaker B: So we've seen obviously the cloud VMware Lana, we're seeing move, we're up to Siri movement, and we're also seeing even things like cosmosm in the customer ecosystem also see a lot of usage. And these things can also be customizable, and it sort of ties into that opcode reasoning as well. And so the last reason is you can scale as you need. So if I am getting a lot more users, I can increase the amount of hardware requirements that my sequences of other data might have as a chain. And if you're using a scalable DA layer as well, then that also makes that a lot more easy. And you're not constrained by various reasons or other applications using that specific layer. Now, what we see happen generally is this first wave of monolithic app chains.
00:08:46.474 - 00:09:44.384, Speaker B: So this is sort of what we call the cosmos ecosystem. And here we are seeing obviously newer ones like DyDX, but older ones like osmosis, obviously the Cosmos Hub and a bunch of other chains as well. And while these type of chains make a lot of sense in terms of the powers that they provide to a developer, they're also very expensive to run, but they do allow you to internalize and control more if you're fine with paying for that cost or doing all that orchestration between infrared, which is quite a lot of work, and you also don't get any dependencies. So if you're like, I want to have complete control, I don't want to depend on anything. You could sort of go with a complete monolithic app chain and handle everything yourself. But it is quite a cost and quite a bit of hard work to actually make this work. And I think most applications simply cannot pay for this.
00:09:44.384 - 00:10:37.744, Speaker B: But we generally do see this funnel, and we've seen this a lot lately, specifically with things like professional exchanges for protocols that start as a smart contract, see the constraints that that puts on them, and then go to an app specific roll up. And then you have rare edge cases like a Dyx that goes to a complete app chain, but those are for very, very large applications that can sort of handle that network. So what do you do if you want the powers of an app chain, but you simply cannot create a security budget of one? Well, the solution is relatively simple. You could inherit some element of security. However, there's different ways you could obviously inherit this and different costs associated with this. The first one, and the one, I think the most relevant one for today is obviously data availability. So data availability.
00:10:37.744 - 00:11:13.948, Speaker B: You can use a DA layer like Celestia. You could push your transaction data to Celestia and get very quick and very efficient proofs of that data being available. And that input transaction data is sort of the last bastion of truth for everything that happens in that warlord. So if I have proofs of this data being available, I can obviously calculate and compute the outputs that that specific chain of application should have. And we'll get into why I think this is probably the best solution a little bit. What you can also do is you can inherit settlement. So this is specifically for centers and persistence on dispute resolution.
00:11:13.948 - 00:12:10.764, Speaker B: So CK verification for CK roll up, fraud proof verification for an optimistic roll up. And this also make a lot of sense in a lot of cases if you're specifically looking for shared liquidity with other applications or other roll ups that might exist, and then you have the third, which is consensus. And this is also the most contentious one of the three and one that we'll get into a little bit of why I think makes the least sense and why it is the most expensive. We've seen this live in production with customers, hubs, interchange security, and also what we've seen with newer shared security models like a polkadot or ligand layer, for example. Now, these three methods actually look like this. So the first one is utilizing some DA layer. The second one is a roll up between some settlement layer and probably also a DA layer, depending on what kind of chain you're settling to.
00:12:10.764 - 00:13:05.408, Speaker B: And the third one is sort of this shared security where you probably are sharing some crypto economic security from a main hub. And that main hub operators are likely running and are opinionated about the specific thing you're doing on that chain, which obviously has some added costs associated with it. So I generally don't see consensus as being that efficient to inherit. So in my view, it's not really the third time, it's the charm. I generally look at it as because of the extra cost associated with those operators being opinionated, you have to pay a lot more in incentives. So that also ties into the fact that the amount of security that you might inherit might be too high for the added value that you can provide to those operators. So those operators obviously, yes, they are opinionated.
00:13:05.408 - 00:13:53.694, Speaker B: They need to be running the runtime or state machine of your specific application or roll up. And because they're opinionated, because they're putting a stake in crypto economic security that they could lose if that specific chain or them act maliciously, which is obviously quite troublesome. And generally you're also opting in provide some degree of security. This could be for a year or two or three. But if the thing you're providing security to is no longer being profitable for you, whether that's from token incentives or whether that is from a fee sharing mechanisms that you might have. We saw that with neutron, with the customer sub they were giving away 25% of fees. If there's not enough activity on that chain, those fees don't amount to much.
00:13:53.694 - 00:14:31.274, Speaker B: So you could be forced in while losing money. And then there's the point earlier where there's only a few specific applications in my opinion, that can do this. It's all the orchestration. So you'll likely need to have relationships with 2040 different infrastructure providers, if not more, depending on how big of a validator set you might want. And these need to orchestrate between themselves, which is obviously quite a lot of work as well. And because of the fact that you opinionated, you're taking on these actual slashing conditions. And if these things are not built in protocol, let's say you're inheriting some security from a chain could be Ethereum.
00:14:31.274 - 00:15:19.074, Speaker B: That slashing condition might not be able to actually be proven on chain in protocol, and you have to resort to social slashing. But it's obviously not a deal. You'll have a set of people that decide whether or not a specific operator or validator gets slashed. So I guess the question you ask yourself is the goal alignment with something here, or do you actually want shared security? So that's also a choice that you have to make. The cost and architecture we tied into a little bit earlier, Coruscant does some great research on this. So generally you do have quite some costs associated with the hardware, but also the fact that you need DevOps. This goes for all of the info providers that you might be using for an app chain.
00:15:19.074 - 00:16:17.264, Speaker B: So let's say you go for 100 validators times they might cost to run the hardware and the DevOps associated with the engineers that you hired to do this, this could get quite expensive. While let's say you're inheriting some data availability consensus security, those validators in that chain you're inheriting from are unopinionated. So a celestial validator or celestial liner do not care about the data that I post. They will prove that it's been put in a block and they will sample it, but they're not necessarily opinionated about what kind of data it is. So they're not running a validator on my specific roller. So there's not that class associated with it either. And with inheriting DA consensus, for example, you could preferably, you want to run more than one sequencer, let's say that is four or five, maybe ten, or maybe you tap into something like a shared sequence as you get that decentralized sequencer from the get go.
00:16:17.264 - 00:17:09.214, Speaker B: And that ties into complement as bit as well as you can. Just then just pay a fee for that sequencing as well. As you pay a fee for DA, for example, you're not forced to give away token incentives like you might be for a shared security setup. Now we sort of get to sort of what is very relatable to celestial here is that it's these modular app chains also application specific roll ups, and they essentially inherit what I think is the most important part of anything that you want to inherit, and that is data availability because it is the last passion of truth. So you can compute any outcome from this, provided that it is correctly provided. And while you're devouring that security, you also gain complete control. So you get specialization and customization and you also get way lower security budget payments.
00:17:09.214 - 00:17:45.040, Speaker B: So that's what we just went into. The fact that the cost of running a monolithic app chain or inheriting some consensus security is likely going to be a lot more expensive. So instead you're just paying some DA fee. And then if you're not using a decentralized chat sequence to begin with, you probably have some execution costs associated with running a sequencer, but it could also be relatively low cost depending on the amount of users that you might have. And there's probably also some RPC costs associated with it as well. And then you just store state. Obviously Celestia is likely to be pruning data after a certain amount of time.
00:17:45.040 - 00:18:37.764, Speaker B: So you do want to store this outcome state somewhere, but that is a one of n sort of honest guarantee. So the amount of place you want to store this is not necessarily going to be that expensive, depending on how hard of a security guarantee you want on this. And so what you also gain is this retaining of ordering powers, which I think is quite important. And we'll get into this here in a little bit, specifically around fees and Mev and how you can use these ordering powers to build applications that are better for your end users. So we'll get into it in a little bit. And as I've alluded to over the presentation so far, is that you get this ability to commoditize your complements. So that is the things that you are utilizing or the things that are used to funnel into your specific application or infrastructure.
00:18:37.764 - 00:19:43.678, Speaker B: So generally there's an idea that if you decrease the cost of the things that you utilize to make your application a product, I think the demand for that product will increase as well. Obviously, I think at this point in crypto, with how early we still are as industry, that is sort of less important, even though we might have commodity prices for various things you might want because of the rise of competitors that are offering a very similar price. And then you're sort of depending on quality of that specific complement. At this point, crypto is still quite beady and attention driven, so you might see alignment or partnerships mattering more. But I do think as we mature, having the abilities are very low. Cost in terms of complements is extremely important and also just opens up the ability to do a lot more for end users in terms of what kind of applications you're actually building. So the things that you can commoditize obviously, or that you can outsource to others are things like da right? So perfect sample.
00:19:43.678 - 00:20:17.110, Speaker B: Celestia. It could also be blockbuilding. So you could utilize a thing like a suave because you want map of where transactions and auctions to happen in sort of a trustless quote unquote environment. It could also be historical state state rent. So maybe you want to outsource the state rent because you don't want to be running a large node that keeps all this state stored. It could also be things like running all active state on disk for state that you're executing. We're also seeing this with ckvms.
00:20:17.110 - 00:20:59.938, Speaker B: So they're using these open source ckvms as funnels into things that they can monetize that could be proving or verification or even roll up as a service, essentially also being able to utilize shared sequences. So you can also look at shared sequences as a roll up and service provider. That is also a way to look at this. And the cost of utilizing those things are quite low. And what this sort of, I think highlights a bit is that the way that a lot of web two and so traditional development happens is generally through APIs. And I think what we're seeing slowly but surely. So this API economy sliding in over to crypto as well.
00:20:59.938 - 00:21:49.474, Speaker B: And I think this is particularly something we're seeing in the modern spectrum. And this is sort of how it could look. Obviously this looks quite complex, but for an end user, all this is abducted away and these could just be looked at as API calls that you're making. So in terms of developer experience, this is not as complex as you might assume, and you're outsourcing all of this to very reputable and strong projects. So that could be an FPC provider. There's various types of decentralized RPC providers that are providing FPC services. And then if you have specifically MEF aware transactions, you could outsource this to something like a suave that might run private auctions on these specific MEF transactions that you might have within your blocks.
00:21:49.474 - 00:22:50.788, Speaker B: And then you can obviously outsource a sequencing thing or posting to a shared sequencer. And within that you might also have different types of block software development kits. That also means you could do the things that you might not be able to do so before, and then you obviously might have a deal layer that you also might be tapped into. Now, one thing I think is particularly important if you're building a diva application is ordering. And generally, for the most part, applications have not at any point really have control over this unless they want to give up on security. So on Ethereum, if I want to specify where a set of transactions originating from applications should be ordered in an Ethereum block, I have to pay and fight against other searchers and other people trying to extract some meV. So ordering is important because this is where sort of transactions get ordered.
00:22:50.788 - 00:23:48.794, Speaker B: And if you're doing any front running, back running arbitrage, it's all related to what transactions are ordered in the block. And generally we have some specialized actor that is building these blocks and proposing these blocks that we've seen with proposal separation in Ethereum, with Mapboost, and generally have some auction related to this. Now if you hold the power over ordering, which as a roll up, you do. So here you're running the proposer sequencer, and the sequencer controls where a transaction are put into a block. And if you do that, you do hold the power to extract or be paid to extract MEV, most setups now alias and robots are just sort of fifo. So first in, first out, and not a lot of MEV is extracted here. It's more sort of the way we see MeV in Treadfi that is based on latency.
00:23:48.794 - 00:24:50.634, Speaker B: So while you could introduce things like a priority fee and then a searcher that is trying to extract me from applications on your roll up could obviously pay this priority fee, and that sequencer or community can then extract that fee. But I think there's cooler ways of actually utilizing these ordering powers too, specifically to not extract from users, but rather write them with arguably a fairer outcome. And these are some of the things that we see here at the bottom. So verifiable sequencing rules could be things like we can base auctions where you have a uniform clearing price. You could even do things like swap splitting between different pools or between different blocks if you have very large transactions. And you can all start to see this with intent centric applications. So some of the things that I think are extremely interesting specifically for an application, if you're looking to build with modern infrastructure, are sort of this notion of providing either fair ordering or highways for specific purposes.
00:24:50.634 - 00:25:18.368, Speaker B: So let's take an example where you have a block. So this is the top right picture here. You have two lanes within this block. So you have a priority lane and you have a chronicled normal lane. So in this priority lane, you would generally have things that are meth aware. So this could be things like arbitrage, it could be liquidations. And generally the people that are in this lane are likely to be specialized actors.
00:25:18.368 - 00:26:12.034, Speaker B: So this could be whitelisted searchers, or it could be the protocol itself. So generally what you can then do when you can control how a block looks like, is that you could say if you are in this priority lane, you should be paying a higher fee to the ones that you're trading or extracting value from. So let's say we have an LP pool in an amm here. The people extracting value from those amms, if they're doing so, and if they're the top of block or back running, for example, they are probably extracting value, then they should pay a higher fee. So you can say, if you exist in this pro lane, okay, instead of paying 0.25% in fees, maybe you pay 0.5% or you pay 1%, and that then you can redistribute those fees back to the people that you're expecting from, or the protocol itself.
00:26:12.034 - 00:27:02.324, Speaker B: And this is particularly important for a defi application. And we're sort of seeing some of this happen already, and I think we're going to see a lot more of these sort of ordering power start to happen as well. So within this sort of normal lane, you just have to channel normal transactions. And the parallel lane, you have these map aware transactions that because they're extracting value, you should pay a higher fee. So generally you'd want these to be whitelisted. What you can also do is this idea of constrain the ordering rules of your roll up to a specific set of rules. So let's say you want to provide fair ordering for your end users, your traders, and you don't want any trades to be set up in a way that is providing a better price for somebody else.
00:27:02.324 - 00:27:56.884, Speaker B: You could do a thing like you only have buy, sell, buy, buy, sell, buy, sell. And the only time you could have a buy buy or sell sell is if you have a better price at that point than at the beginning of the block or if there are no other trades in the opposite direction. So obviously in this case, if you're long tail, you're probably not going to get the best execution. But if you have a pretty fair buy to sell volume, you could get pretty fair execution on most trades here. And these are sort of ways you can start to sort of play around with ordering to benefit the end users of your specific application. Now this MEV is obviously a result of inefficiencies. So this could come from block times on the roll up, and that has some liquidity pool, but these inefficiencies are likely always going to be there.
00:27:56.884 - 00:29:24.462, Speaker B: That's just the result of our financial system. So extracting some of this value specifically to give back to the protocol or back to the users that you're extracting it from, I think is a pretty valuable thing because these actors are obviously also extracting some value and as such should be paying some fee to actually extract this value. So the way you can look at this, that sequencers and sequencer have an upward roll up, one application are not just existent to take some transaction fee that all might be paying to cover the cost of compute and stage show as covered earlier. But you can also start to utilize MEV as a way to pay back to your application users and even the ones providing liquidity, for example. So this is something to keep in mind is that when you're building an application in defi utilizing model infrastructure, there is this entire MIPS supply chain that I think is very relevant for you to look at and keep in mind as you're thinking of way to monetize or provide fair value to your end users. I think the best example of this is the Uniswap debacle. Hayden Adams in this tweet puts it into perspective that Uniswap LP providers on Ethereum are paying a pretty hefty fee.
00:29:24.462 - 00:30:53.114, Speaker B: They're providing liquidity, but they're also being extracted from, and they are creating a ton of mev. So a lot of MeV Epson flows throughout Uniswap as a protocol, and a lot of searches are going through arping, front running, back running, sandwich tacking, and are extracting value from these LP's and these users and that actual profit are either ending up in the pockets of the searchers or it's going to the Ethereum validators, the proposals of the Ethereum blockchain that are not necessarily Uniswap LP's nor token holders or part of the foundation of protocol. So this is something to keep in mind here, that all these efficiencies get exploited by actively looking to extract MeV. But none of it actually goes back to the liquidity providers, which is pretty unfortunate for Uniswap as a protocol and the LP's in the protocol. So while a lot of this MV EPs and flows through, none of it actually gets captured by Uniswap. Now, if Uniswap was a modular app chain, an application specific roll up, and had control over ordering, that means they would be able to take a priority fee paid by the searches that are extracting value. Instead of going to the Ethereum validators that are not a part of the Uniswap protocol, it would go straight to the Uniswap protocol and its token holders and its community, and then you can think about how you want to redistribute that.
00:30:53.114 - 00:32:04.454, Speaker B: But that's obviously up to you as submitted as a developer. So in a world where Uniswap or any Dex or AMM has ordering control, they can start actually monetizing these inefficiencies which are currently not available to because of how the MEV supply chain works on a generalizable blockchain. So I think this is one of probably one of the best examples for why MEV is important and how it can actually be used to provide a better experience both to the users of the protocol, but also the ones providing things like liquidity as well. Now, some of the other powerful aspects I also think comes with building an application that's model infrastructure are things that you can start to play around with, particularly on an execution environment level. These could be things like curves and precompile support for things like a CK verification chain. So we've seen quite a few of these come out lately just because of how inefficient it is to actually verify CK proofs on a lot of different blockchains. And they might not have specific curve support or specific security guarantees on these things either.
00:32:04.454 - 00:33:05.084, Speaker B: Even the celestia community is actually also exploring the use of being able to utilize and verify CK accounts on celestia itself. So you might actually be able to start doing some very cool things as a CK roll up, or even as a different application on Celestia as well, by verifying specific proofs on Celestia as well. And what also ties into this a bit in terms of the verifiable sequencing rules that you could have optimized rules for central limit order book for example, as well. And you could also have specific opcodes that any theory might not support. I think good examples here are things like a counter abstraction and a bunch of these other eips and opcodes that might not be existent, but that you might be able to integrate and utilize as an application on a roller. Other things that are important here is also, as we pointed out earlier, scale as you need. So this could be specific gas limits that you have set.
00:33:05.084 - 00:34:25.770, Speaker B: So if you're just a single application, you don't have a thousand different applications. The amount of active global state that you might have is probably not going to be that large. So you might be able to actually keep this in memory on disk and increase these gas limits to very large levels and obviously scale that way, which I think can be quite interesting. You could also lower or lengthen block times depending on your specific use case here. And another thing that ties into MV we touched on earlier is that you could have oracles run by the protocol as well, that if they're utilized in a liquidation, could pay back some of those fees to the protocol in question or to the ones that are getting liquidated. And what say here is that doing this on any sort of generalizable chain at this point is not impossible, because the cost of doing this, if it's related to ordering, is simply impossible or you're not in control of the community that is implementing these different rules or upgrades that you might be dependent on. So this is something to keep in mind if you're building an application that it might be more worth it for you to actually utilize an infrastructure piece like a roll up than building just a pure smart contract and specialization.
00:34:25.770 - 00:35:18.314, Speaker B: So we trust a little bit on this in terms of keeping things on disk in memory specifically for execution state. You could make things like hardware changes. So you might want to do specific database things that you might want to do, or you might want to crank up the hardware as high as possible and do extremely low block times while you're using some DA layer. These are all the things you could do maybe you want to build in phone verification. This could be by utilizing a vm that's more friendly towards that. And since you also control ordering and what gets put on the roll up, you can also start to look at things like monitoring, so exploits that might be happening on your roll up and how to respond, respond to that. So if you know this transaction is an exploit, well you could sort of look at this as good censorship.
00:35:18.314 - 00:36:09.416, Speaker B: And I don't think we need to get into discussion around this now, but it is a discussion to be had. Is there some censorship that is good if it is related to an exploit. And if you have an exploit, do you actually want to censor that before it gets put into a block and finalized? Obviously you could argue that these things should be permissionless and there should be no censorship at all. But if you're building application that you want the best for your end users, and if 99% of those people do not want this export to happen, then maybe it's something worth looking at. Now what we also talked about a bit earlier is intense and how that might fit into sort of modular infrastructure. So one idea I've been tying with is this thing called curation. So basically you can have these all encompassing front ends.
00:36:09.416 - 00:37:06.444, Speaker B: We're seeing wallets, I think particularly bolts here. We also have things like search on Dora, which also allows you to customize and do different things on a front end level. And these things might tie into some servo network that might do a specific action for you. And what we see is this proliferation of front ends. And so the backend can be quite customizable and able to be specialized to your specific needs. Now, when I said earlier that you should probably inherit some degree of security, and while you could do ordering off chain as a smart contract, you might not inherit any security on this, and it is quite risky for the users of that protocol. One thing you could do is obviously things like CK, and you could run a VM extension off chain and not have any state there specifically, but just prove some type of computation.
00:37:06.444 - 00:38:10.026, Speaker B: The issue with this obviously is the fact that in high optimizable and very efficient setups, CK is still not quite there yet, and there's quite some costs associated with the compute, but also the verification as well, and things like proof times and how long it takes to actually generate this. So while you might get that at some point where you might be able to do some of these things without necessarily needing a stateful roll up, and then obviously if we have CK curve support on Celestia, you might also be able to do some cool things here. So this is not to say a lot of things I have said you can't do the studios already. You could do them, but at the loss of security, which is why I'm referring to that you can inherit some degree of security, and that DA is likely the best way to do this. So what I'm kind of going to say here is towards gend, and I have some more examples later if you want to look at this. But essentially it's that the world today is obviously changed quite a bit. We have a ton of different types of roll ups, we have a ton of different types of SDKs, we have all of our services, we have shared sequences, we have bridges and so on.
00:38:10.026 - 00:38:58.894, Speaker B: So a lot of this API economy sort of coming to to play, and the choices that you have here are quite extensive. And the amount of customization ordering that you specialization that you actually can do are quite wide and broad. So I would definitely look into how you can actually utilize infrastructure as an application to build fairer and better applications for your end users that can actually make things like monetization a lot more easy to do as well. So I'm very excited to start to see applications moves from just smart contracts on generalizable blockchains to becoming application specific roles and taking advantage of these powers that it does provide to you. And yeah, that's it. I do have some more examples if we want to go into that, Josh, but do let me know.
00:39:06.774 - 00:39:37.774, Speaker A: I'm definitely curious to learn about some more examples there. I guess the first question I have, there aren't any in the chat is kind of on those examples. And what type of applications. I guess the question is what type of applications do you think would be both like cool to build, but also what would you think would be useful to build with this type of modular infrastructure?
00:39:38.194 - 00:40:28.704, Speaker B: Yeah, I think particularly on a sort of a Dex setup. So we've seen some setups on this, particularly with frequent batch options. I think generally now there is in most Dex mm designs and most blockchains now a lot of the actual execution and whether that's fair or not comes down to sort of the mvv playground and that black box. And that's just because of the way priority fees work and that you're paying to get input in quicker. But if you're not paying the highest, then you're likely to get a worse pricing. Things that I think would be very cool to see is an application specific roll up utilizing frequent batch auctions on a sequence level. So it's built into the ordering of that specific block setup you might have.
00:40:28.704 - 00:41:40.110, Speaker B: So what you can do is that you could set some time period that could be half a second, it could be a second. And here you accumulate orders that are coming in, and then you essentially have this uniform settlement price, which is the quantity of crossing orders, where is the highest, and then you sort of settle on this price, which means you can get very fair pricing to an end user that you wouldn't be able to do if it's based on latency and you sort of eliminate a lot of the front running or back running that you would otherwise get in a setup that does not have frequent batch auction. And this can also things like coincidence of once. So if you have within this block, you have a ton of traders that are trading ETH to USDC or TIA to dimension. If there are willing buyers and sells on both sides, you can match them peer to peer. And by doing that you can also provide wayfair pricing. You don't have to route to a pool and you don't have to maybe pay gas fees or whatever it might be that you are pushing with smart contract, but you might just be able to do that P two P and you can even mix this in and do things.
00:41:40.110 - 00:42:21.744, Speaker B: If you're using an LP pool, an automated market maker, you could have an option sort of rebalance this pool because it's obviously been put out of, let's say we have some off chain price fees that we're using. The likelihood of this after a block being inefficient or out of order, well, you can then have an option to rebalance this pool in the right way. And a searcher would be willing to do this. That's what they do now. And most asms, they're doing sextext arbitrage and part of the surplus. You can even give back back to the LP's at the end of the day, which would always also provide a better experience for both LP's but also traders.
00:42:24.124 - 00:42:58.154, Speaker A: And kind of going to the. You mentioned the Uniswap example, and it made me wonder if, I guess if you think that a lot of existing applications that do the type of volume that Uniswap does, as an example, do you think that they, as time goes on and as the modular ecosystem kind of grows, do you think there's going to be more incentive for them to decide to operate as an app chain instead of just an application on an earlier one.
00:42:58.694 - 00:43:34.794, Speaker B: I definitely think so. I think the community will probably be the loudest about this because they are the ones missing out on whether that's monetizable ways to monetize or whatever it might be. I think we're seeing a lot of this. Actually, with perpetual exchanges, this is obviously a lot easier, but their liquidity is not needed to be on Ethereum, for example. So Uniswap is obviously dependent on ethereum liquidity. While a perp exchange could operate as a specific roll up, and maybe they have a smart contract on various different chains where the liquidity just lays there. It could just be in USDC or USDt.
00:43:34.794 - 00:44:13.594, Speaker B: And for those types of questions, it's a lot easier. There's still a lot of issues around liquidity fragmentation. If you are an AMM Dex going to that specific roll up, because you need that liquidity to follow with you. Unless we do various types of Univ. Four hooks or single sound crunch, and maybe we can get around this, I don't think that's clear yet. So I think for petrol exchange it's a lot clearer. And we're seeing that with things like Ava, or even, which obviously is a part of the mono ecosystem and hyper liquid as well, that are sort of taking these powers because of the fact that they're not as reliant on liquidity, and that liquidity can be more stagnant.
00:44:13.594 - 00:44:39.794, Speaker B: So I think this is just the first wave of it. I think there's still some quinks to work out in terms of how liquidity operates in the modern ecosystem before we really start to see these amm, larger indexes start to move. But I do think there will be calls for it within the community that would prefer, you know, either fair execution for the end users, or better, non saciable ways of providing value to the LP's.
00:44:43.214 - 00:45:01.294, Speaker A: Are there other, I guess like DeFi is pretty much the biggest thing that we've talked about. I'm curious if there's other, I guess, like sectors or categories that you would think like modular app chains really make a lot of sense for.
00:45:02.234 - 00:45:52.694, Speaker B: I think one clear example could be things like gaming. So in gaming you obviously have pretty wild requirements for scalability, and not sharing block space with other applications is probably quite important. You might also have within that specific rules that you want to exist. Maybe because you have an on chain marketplace. So like a grand exchange where you could reorder when orders comes in will obviously be pretty bad for the traders on a grand exchange, for example, a lot of times I go by Runescape here. I think gaming makes a lot of sense, both for ordering reasons, but also for scalability reasons. And I think there's quite some interesting things you could do on a VM level.
00:45:52.694 - 00:46:38.954, Speaker B: So whether that's using game specific vms. And I think we're seeing quite a bit of work on this for people like Argus and others as well. Or maybe you even want to run Linux, or maybe you want to run doom or whatever as a VM and they have rules around these things. I think that is one thing we might see. And then I also think specifically around the growth of CK. I think there is a lot of room to make verification more efficient and I think optimizing a roll up, for example, to be very efficient at verifying specific types of CK proofs and schemes is also something that could be quite interesting and fun to look at.
00:46:41.954 - 00:46:56.014, Speaker A: And jumping back to precompiles and opcodes, do you have any, I guess, good examples that you know of that would be good to learn from?
00:46:57.234 - 00:47:50.250, Speaker B: Yeah, so this could be, let's take an example of like a perpetual exchange. Let's say you have an opcode that calls to update an order that you have put in. Having this order be or the specific opcode cost, like a large amount of gas is obviously pretty efficient. So you could code this opcode, for example, to cause a very minuscule amount of gas because it's so vital and it's going to be used all the time. I think that is something that is possibly interesting in terms of pre compiles. There's quite a lot of CK proofs, for example, that you might type with schemes or setups that you might actually want to verify on ethereum, but you're not able to because of precompile support. So I think that is one thing that's particularly relevant for CK, but it could also extend to a bunch of other things.
00:47:50.250 - 00:48:26.744, Speaker B: I'm not necessarily CK, but might just be led to some computation you've done off chain. But I think looking at the history of Ethereum, there's a lot of opcodes or eips as well that applications developers have been yearning for for a long time. But the actual implementation of this can take years. So, you know, waiting a year or building your own app specific roll up, it might make more sense to do, to do the latter and actually make these specific things that you've been learning for a while.
00:48:29.724 - 00:48:37.064, Speaker A: I guess it's a good way to front run whatever you're waiting on that's stuck in an EIP or something like that.
00:48:38.284 - 00:49:17.234, Speaker B: Yeah, I mean, we've seen that happen with roll ups already. So account on Ethereum is still not quite there. And even things like EOA is controlling smart contract accounts like EIP 3074. These things have been implemented on rollups on top of Ethereum already just because of the fact that you had obviously cheaper computation, so it made more sense to do it there and you had application developers asking for it and sort of implementing that without making pain breaking changes is a lot easier when you have sort of a siloed execution environment that you can play around with.
00:49:19.794 - 00:49:21.706, Speaker A: What do you see as the risks.
00:49:21.770 - 00:49:28.346, Speaker B: There in terms of changing vms and things like this?
00:49:28.490 - 00:49:51.744, Speaker A: Yeah, I guess if I were to have my own custom roll up and using like basically things that aren't in production on Ethereum mainnet, are there any angles there where myself is like a roll up developer am opening up the door for something bad to happen? I guess.
00:49:52.724 - 00:50:35.236, Speaker B: I think that is definitely a valid concern. I think that is something that should be kept in mind. But I think thats also a thing with smart contract development on any generalizable blockchain is that you will have risk associated with doing new things and having audits is going to be important. I think generally if you're not like an expert in changing customizing vms or changing out opcodes, maybe that's not the thing you should be going down. But always being audited, having gone through formal verification and things like this is very important. I do think so. But you're definitely opening up risks.
00:50:35.236 - 00:51:29.794, Speaker B: But I think that comes with doing anything that is new and haven't been done before. I do feel like what we've seen is that the fact that you can control, as we talked a little about the good censorship, if you have a single sequencer for example, you can, if needed, vote in the community. Okay, we should be rolling this back because something bad happened. And obviously you could even have hard forks on Volt and table Celestia while still keeping data availability on Celestia as well. That's one of the things that it does a lot for, is these hard forks that are a lot easier than doing it on a generalizable chain. Because if you want to hard fork a smart contract state on Ethereum, well, you'd have to get the entire Ethereum blockchain to hard fork as well, which is quite unlucky.
00:51:32.814 - 00:51:50.474, Speaker A: Makes sense. And I do want to actually call, I guess, for the audience if anyone has questions, to please drop those in the chat. Mads, I'm curious. I know you do a lot of research. What's been the most interesting thing for you recently?
00:51:51.494 - 00:53:00.874, Speaker B: I think recently sort of thinking about how when we have different roll ups on top of a thing like a celestia, how we can start to do sort of atomic composability between them. So a lot of this ties into having shared state. But what if you don't have shared state, at least not immediately? What kind of actors do we need to implement here? I think Astra is doing some very cool work on the composers, which is sort of a role or an actor that simulates specifically cross domain transactions. I think there's a lot of open questions here still, but I think it's a very interesting design environment, especially if we want DeFi applications like a uniswap, for example, to actually move to an application specific roll up. Well, they're likely going to want to be able to do atomic calls to other applications. And if those applications don't live on the same roll up, this obviously becomes quite difficult. So we might need some settlement layers or shared sequencers that have sort of global shared state, or are using something like a simulator that can simulate transactions between the two.
00:53:00.874 - 00:53:37.054, Speaker B: But a lot of defi today is built on sort of being able to atomically call other smart contracts on that chain. So there's, I think, a lot of open questions about how do we actually get DeFi protocols to move over and build their own siloed execution environments while still being atomically composable between them. That is something I've looked quite a bit at. I've also looked at a lot of intents and how that might provide a better user experience, whether that's better execution or ease of use. It's also something I think I find quite interesting as well.
00:53:38.214 - 00:53:44.434, Speaker A: Can you give the like quick, what's the quickest way that you would describe intents to someone who's not familiar?
00:53:44.934 - 00:54:37.090, Speaker B: So on. I think the best way to explain this, let's say that I'm going to, I want to trade each USDC. Most people will just go to the uniswap front end trade it, and that's sort of, sort of it. But if you're trying to optimize for, for an outcome that either provides you with some surplus or give you a better execution price, or you have to either go to something like an aggregator that might scan more pools than just a single pool and that could possibly provide better value. But you're still doing all that yourself and you're specifying the specific route that you're going to take with an intent. We essentially, we specify a desired outcome, but we don't specify how to get to that outcome. So it's like a partial transaction.
00:54:37.090 - 00:55:58.294, Speaker B: I haven't specified how to actually get to the outcome, but if you can get to the outcome or even better, provide me a surplus, I'd be thankful for that. And generally with most intent protocols, now we have the specialized actor called a solver that you outsource this hard work of finding the best route to a specific liquidity pool. Or if there are other people also trading within this protocol that have the asset that I want, and I have the asset that they want, we can also match them peer to peer and likely get a much better price, and also not have to run through like a smart contract for a specific pool, which on Ethereum is quite expensive. It could be $35 just to touch a smart contract pool. So that's, I think it's the best way to explain it. And there's generally some auction between these solvers, which means that instead of like a searcher computing sort of extract value from you, a solver is generally computing to satisfy you the best, because that means that when they win an auction and probably get some identification in token, or they get to take some of the surplus they have provided for you. So it's a way of sort of utilizing the searchers to provide value instead of extracting from you, which I do think is quite interesting in terms of just getting a better user experience.
00:55:58.294 - 00:56:48.794, Speaker B: There's still a lot of things that are open in the questions in terms of how trusted are these parties, how do we verify that their intents have been done correctly? So there's a lot of CK magic down the line, probably in some future. And there's also questions about should they have a stake or a bond or some cryptocurrency security as well. But I do think they're quite interesting in terms of just abstracting away and building very cool front ends. So this could be on a wallet that you just have some solve API that does some very specific action that you might ask it to. And I think that ties a little bit to that sort of idea of doing curation front ends that can be specified specifically to you as a user without having to be written by an app developer that goes down one specific imperative route.
00:56:49.894 - 00:57:05.274, Speaker A: That's interesting. I personally don't know enough about intents, so that was a great way to help me understand it. And I'm actually curious to jump back to. I think it was the conductor from Astria.
00:57:05.894 - 00:57:06.558, Speaker B: Composer.
00:57:06.606 - 00:57:15.128, Speaker A: Yeah, you're the composer, I guess, at a high level. Can you cover how the composer works.
00:57:15.296 - 00:58:01.014, Speaker B: And how that helps? Yeah, yeah. So with Ashtria, you obviously have this shared sequencer chain, and these sequences are proposing these large blocks for five or ten different roll ups. But in terms of once you do this efficiently, if we had these sequences hold state and store state and execute for all of the different roll ups, we're not scaling at all. We're just building a singular chain. So what we do is that we have these lazy sequencers that are just proposing and executing, but they're not storing or holding the state, because that would be humongous nodes. And we would not be scaling, we would just be doing what we've done with shared consensus, as I talked about earlier. So we want.
00:58:01.014 - 00:59:01.504, Speaker B: It's not that now, if we want to atomically, either atomically or non atomically, bridge between these different roll ups, we always need to prove that the state has been stored and executed on these roll ups, and we also need to prove it between them. What a composer essentially does is it simulates transactions and executes transactions between these two rollups that want to interact with each other. And they also sort of compose these blocks down to the sequences as well. And in Astra, you also have a second wall, which is the conductor, as you said, which sort of retrieves the data from the data availability layer in celestia. But essentially a composer is sort of to provide and help us get atomic composability between infrastructure that is kind of siloed. And we do that by simulating the transactions that they have. And we do this because we don't want double spending of state.
00:59:01.504 - 00:59:59.944, Speaker B: So if I'm purely trusting roll up b while I'm roll up a, that they have executed this and they haven't, well, I mean, they could be double spending state and full, coming to quite a bit of an issue. So the composers exist, compose and ensure that all the follow ups have executed things correctly, and that we're not getting double spendings of state, which should obviously be pretty bad. One other thing you could do is you could have consensus lanes between these roll ups, but that's not atomic unless they're both running full nodes on each other. And then we get into that entire scalability issue again. But you could do that, but then you wouldn't have sort of atomic compulsibility, and you would also still be sort of trusting the ordering that these guys come to. So maybe you have a more powerful than the other. Well, then who's the guide actually deciding on this? But that's sort of a highway, like a high level way to look at it.
01:00:01.804 - 01:00:15.924, Speaker A: Yeah. Thank you. And on topic of research, are you writing anything now or released anything recently that folks should check out or get excited about?
01:00:16.504 - 01:01:02.844, Speaker B: Yeah, so we have both a substack paragraph and I think a mirror as well, where we upload our posts, and also on our website, mavenlevin.com dot. I've recently written, and it's tied into this presentation as well. I wrote about specifically ordering for an application and how you could utilize that to your advantage. So we've written about that. I've also written a post about commoditizing your complements, where I also go into the idea of using open source software to funnel developers into your ecosystem. We also touch on specifically the role of DA and how I think it's the only scalable way of inheriting security, and how consensus shared security is not.
01:01:02.844 - 01:01:45.004, Speaker B: If you're interested in that, I would definitely take a look at that and it's very related to what we talked about in the presentation as well. I'm working on some on an article specifically around this composer role, an actor, and how simulations can sort of fit into this, as well as the importance of having some global state between applications. Specifically if you want to do the the very cool atomic stuff that we can do on generalizable blockchains at the moment. So we look out for that. I'll probably also put out an article on sense. This is something I've spent quite a lot of time looking at and I've also done presentations and further.
01:01:47.024 - 01:02:07.314, Speaker A: Awesome. I'm looking forward to reading some of those, if not all of them. And there aren't any questions in the chat and I notice that we're a little bit over time, so I do want to be conscious of that. Are there any last things that you'd like to share with us before we sign off?
01:02:08.134 - 01:02:43.330, Speaker B: Yeah, if you are also looking at these specific things I like to research, feel free to reach out to me on Twitter. I'm always happy to just jam on blockchains and crypto and modular infrastructure in general. And if you're building applications that take advantage of model infrastructure specifically to either provide fair execution or an outcome for your end user or even for LP's or whatever it might be, feel free to reach out to you. We'd love to talk to you and see how we can help you. If you're looking to fundraise or just talk about your product, I'm happy to just jam. Awesome.
01:02:43.442 - 01:02:48.906, Speaker A: And just to make sure your Twitter is zero x raining coffee, right?
01:02:49.090 - 01:02:50.974, Speaker B: That is it, yeah, zero x ray.
01:02:51.304 - 01:02:58.884, Speaker A: Nice. And I guess is there a good place to reach out to the team?
01:03:00.744 - 01:03:18.396, Speaker B: If you've reached out to me on Twitter, I will read it and if you want to get into contact with anybody else on my team, I can also help facilitate that. But generally I'm very open on Twitter and my DM's are open and I check it relatively often. I will definitely get back to you.
01:03:18.560 - 01:03:34.704, Speaker A: Cool. Thank you so much. Thank you again, Mads, for teaching us about modular infrastructure and what you can do with it today. I'm excited to see what people build and looking forward to having another conversation like this in the future.
01:03:35.084 - 01:03:37.064, Speaker B: Thanks for having me, Josh. And thanks.
01:03:38.684 - 01:03:40.284, Speaker A: Yep, you're welcome. Have a good one, everyone.
