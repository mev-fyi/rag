00:00:02.250 - 00:00:23.360, Speaker A: Okay, modular IBC patterns. Since we're here at the modular summit, everything's modular. Just a quick introduction. Hi, my name is Jack Samplin. I'm the co founder and CEO of Strangelove. You might know me from the Cosmos hub, the Cosmos SDK, IBC, Akash sommelier and or Noble. I've been working deeply within the cosmos ecosystem for many years.
00:00:23.360 - 00:01:02.266, Speaker A: Strangelove is dedicated to building IBC and supporting its growth, and that's what I've spent most of the last few years doing, and that's what my company does. So, just a quick refresher on IBC for folks. I think this particular audience probably doesn't need it, but I think the broader modular audience, there's a lot of people unfamiliar with IBC, especially the core underlying primitives. So I do think it's important to kind of dig through these. So IBC is a general message passing framework for blockchains. It's modular by design, and there's some key primitives that are really important to think about. The first one is clients.
00:01:02.266 - 00:01:58.178, Speaker A: So clients contain all the authentication logic. Which chain am I talking to? What are its validators? How do I know that the state transitions it's providing are valid connections, and channels make up the middle layer, which is the transport layer. And this is the sort of like, how do you connect one smart contract to another? And it's the on chain pieces that help define that. And then there's packets. So from a developer's perspective, that middle layer, which we call the tau transport, ordering and authentication, you don't really need to care about. It's kind of the key part of the protocol, and it helps you build everything on top. As a developer, if you're a chain developer, you might want to care about clients because maybe you have some unique consensus, or you're an optimistic roll up, or you're a ZK roll up, and you've got some different cryptographic properties that your chain needs to authenticate it, and you would encode that into a client, and that runs on all of the chains that you want to connect to.
00:01:58.178 - 00:02:39.358, Speaker A: And then on top of all of this infrastructure, we build the packets, and this is the application data formats that you send data back and forth with. So, roll ups, we've got ZK roll ups, we've got optimistic roll ups and some other stuff based roll ups, modular, pilled roll ups. I don't know. People are coming up with all kinds of stuff, but I think for practical purposes, there's really two. We've got ZK rollups which are kind of the future, and optimistic rollups, which are the today technology. And I think that bringing IBC to each of those, there's some unique challenges to each of these different architectures. So I'm going to dig into optimistic roll ups a little bit.
00:02:39.358 - 00:03:16.954, Speaker A: The dimension team was just up here, and they showed you guys the right way to do optimistic IBC. And I think that the escrow thing that you guys presented was really cool. And being able to optimistically accept that is one way to get around the dispute, period. This is the hard way, this is not the easy way. And the dispute, period, does lead to some bad ux, but you guys had a really elegant way of getting around that. This is similar to what UMA protocol is doing on Ethereum, and it is definitely one way forward. That's kind of tough ux for users in a lot of ways, and I think it can end up being hard to reason about.
00:03:16.954 - 00:04:06.060, Speaker A: Then there's the easier way. And basically this comes down to a committee, whether it's a multisig, a validator set, or some sort of combination of those, there's a committee of keys that provides that authentication logic and helps validate the data coming into your chain. This tends to lead to much better UX and is a lot easier for users to reason about, even though it introduces additional trust assumptions. So the right and the hard way. I've talked to a lot of folks about it. It's been hard to get people behind building that out and building on top of that for a variety of reasons. So I've been thinking a lot about committees, and I came up with kind of a fun little committee design that seeing if anyone's interested in.
00:04:06.060 - 00:05:11.454, Speaker A: So let me talk about this stamper idea. You'd have a tendermint chain where essentially validators attest to the optimistic roll up header. So what does this mean? Each of the validators would be running a full node for the optimistic roll up and then submitting the app hashes to the chain via vote extensions or some other mechanism. Once you reach consensus on those headers, you can write them to state, and then clients would be able to detrust those. And the on chain lite client of this is basically a tendermint like client, which is a huge benefit. But instead of checking the stamper chains state for packet inclusion, you go check the state of the roll up for packet inclusion. So one of the benefits of this design is the minimal change to the set of underlying primitives and libraries that are maintained by the core teams that would enable us to offer the developer experience that we want, which is that the roll up connects directly to any other chain in IBC and is able to bridge seamlessly that way.
00:05:11.454 - 00:05:48.300, Speaker A: And from a developer perspective, you just send a packet directly from your roll up to any chain in IBC that connects to that network. And this is a cool design, but I think the biggest problem with this is it's a committee like any other. It's kind of fundamentally the same trust assumption as hyperlane or axilar or wormhole or any of these other committee based interoperability solutions. So I probably not going to build this. Maybe somebody does. If you're interested, please hit me up. But what I'm more excited about I think is ZK rollups, where the hard way and the easy way is the same.
00:05:48.300 - 00:06:55.418, Speaker A: You use a Celestia light node to check for data availability and then you add the ZK proof to the sovereign rollup and suddenly you're able to connect directly from that ZK roll up to anywhere else in the IBC network. This is what users want bring in. It's all chains and bridges at the end of the day. And this kind of eliminates this idea of the settlement layer in a lot of ways, which is I think is why it's tough from a mental model for a lot of folks. So on that side of things, we're going to be working with duality labs, sovereign labs and informal systems to help bring the first IBC ZK lite client to market and try to drive some value directly to the hub. So from an architecture perspective, what does this look like? We've got Celestia, where the ZK rollup is writing all of its state to for the data availability layer. And then duality, which is an ICS chain, would be running this light client for the ZK sovereign roll up and helping enable communication with the rest of the IBC ecosystem.
00:06:55.418 - 00:07:32.234, Speaker A: That light client could run on any other chain, but I think initially we'll probably just run it on duality. And I think that this project is going to be a good blueprint for future ZK roll up integrations because there's a lot of different ZK technologies out there. We're not going to have to do this once. We're going to have to do this like ten to 15 times as these cryptographic standards change, as the proofs get faster and faster and help improve in performance. So yeah, I guess that's kind of what I had prepared. It's just kind of a brief overview, but happy to answer any questions that folks have. Yes sir.
00:07:32.352 - 00:07:34.700, Speaker B: Can you elaborate on the test problem?
00:07:57.450 - 00:08:37.730, Speaker A: Yeah, for sure. So the roll up would incentivize the tendermint chain in some way. I think the easiest way is to have it. A roll up operator would deposit IBC into this, would deposit USDC into this tendermint chain and say, hey validators, I want you to finalize my roll up headers. Basically the validators would then spin up full nodes for each of the roll ups. And because they're listening directly to the state transitions on the network, on that p to p network, they're going to see the latest block headers as they come in. Each validator will have an independent view of that state and then every time they see a new header, they write it to the tendermint chain.
00:08:37.730 - 00:08:58.742, Speaker A: And then you're checking every block. Once two thirds of validators have seen the same header, we commit that header into state. You can then prove that header using the light client on a counterparty chain so that you can prove that that header is included in the stamper state. And then you can check it for packet inclusion on the roll up side. Does that make sense?
00:08:58.796 - 00:09:02.214, Speaker B: Yeah. So basically it's really cutting short the optimistic time.
00:09:02.332 - 00:09:03.800, Speaker A: Yeah, exactly.
00:09:05.210 - 00:09:10.278, Speaker B: So there is ZK, which is directly this, and this is like sort of invalidating you, so no need to worry.
00:09:10.374 - 00:09:55.722, Speaker A: Yes. And I think the key idea here is one thing that I don't like about committees, and I think a lot of other folks don't like about committees, is you end up having these multi hop transactions and it kind of forces this really suboptimal developer user experience and adds a lot of latency in many cases. And with this committee, the latency issue is still potentially there. But I think that there's a lot of ways to shave that down. And also from an app developer's perspective, it offers that point to point IBC experience that most developers are familiar with. And I think practically roll ups are going to want to connect to five to ten key chains to help bring in liquidity and provide other markets and potentially provide services via IBC. And having to do that over multi hop, it's a complicated developer user experience.
00:09:55.722 - 00:09:58.780, Speaker A: So that was kind of the motivation behind the design.
00:09:59.390 - 00:10:21.618, Speaker B: Cool. I think just one thing maybe I would say my only concern with this is that there is some bootstrapping cost in terms of making validators actually do it for your roll up. Initially, way back then, like one and a half years ago, we also had this notion in mind, but we really wanted to make it super easy. And to bootstrap, basically roll up.
00:10:21.704 - 00:11:11.666, Speaker A: Yeah, I think this is the complex part and the devils in the detail of all these designs. I think for that, there's a lot of restaking designs that you could potentially do where you're locking up tokens with the validator and they're getting paid in yield. Most of those are in kind. It's not really compelling for validators. I think in order to make this system work, you'd have to literally just pay the validators money in order to cover it. One of the cool and fun aspects of that design is that the stamper chain could easily degrade service for the roll ups. In the event that user doesn't pay, they just start maybe finalizing only one every ten headers, and then if payment doesn't continue, maybe one every hundred, and then finally dropping service after a predefined period of time.
00:11:11.666 - 00:11:30.274, Speaker A: And you can easily offer different service tiers for different roll ups and different payment methods. And I think that there's a lot of room and flexibility to innovate on that side of things. But, yeah, it's like, again, the market needs to be there a little bit in order for the solution to really be. Yeah. Cool.
00:11:30.332 - 00:11:30.842, Speaker B: Thank you.
00:11:30.896 - 00:11:38.300, Speaker A: Yeah, absolutely. Anyone else have any questions? Susanna, I saw you had one. Did I answer it already?
00:11:41.250 - 00:11:54.106, Speaker C: Thank you. With the stamper idea, this would be, like, linked to the conditional clients idea that you were wanting so that you link the two clients.
00:11:54.218 - 00:12:32.270, Speaker A: I think conditional clients is like a nice to have. It's not necessarily a must have. We've got that wasm client in go now that accepts sort of like arbitrary wasm code. And I think this is going to go a long way to helping users only have to write their client once in rust and then kind of deploy everywhere. So that's one key piece of this. But one of the things we did when building that wasm client is we took the tendermint lite client from IBCRs and wrapped it in a smart contract. And a lot of the testing we did was against that tendermint client to ensure that it has the same properties as the tendermint client in go, and we could easily fork that contract.
00:12:32.270 - 00:13:10.934, Speaker A: And then in the functions where we're checking for packet inclusion within IBC, you just substitute the roll up header instead of the stamper header. So it's a really light fork of that client. It would be an extremely minimal change set. Conditional clients would make this nice and easy and be a lot more ergonomic and space saving, but order to ship it sooner, you could easily do it the other way. But I think that this is one of many use cases for conditional like clients. But it's not a dependency. Any other questions for folks? Awesome.
00:13:10.934 - 00:13:18.050, Speaker A: That sounds great. Thank you guys very much for your time. Really appreciate it today. You guys have a great one. Bye.
