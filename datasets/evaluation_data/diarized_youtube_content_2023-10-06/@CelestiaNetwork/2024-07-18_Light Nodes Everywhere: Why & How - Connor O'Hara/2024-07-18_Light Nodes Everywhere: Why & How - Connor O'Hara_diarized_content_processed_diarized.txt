00:00:01.840 - 00:00:56.940, Speaker A: Good afternoon, everyone. My name is Connor, and I'm a solutions engineer at Celestial Labs. Most of what my job entails is trying to fill the block space by building integrations with rollups. But also sometimes I get to work on research prototypes in my downtime. And today's talk is eventually going to get to one of those research prototypes that I am working on. But first we got to talk a little bit about the light node. The light node has been run all over the world, many different countries, many cities, probably most of the continents, maybe not Antarctica, but all the other ones are pretty believable that they've been run there and on a bunch of weird embedded devices, like the winner of the light node contest, who ran this on some weird Android device.
00:00:56.940 - 00:01:45.960, Speaker A: I'm not familiar with the odroid, but it looks cool. It's been run on the Solana phone, and it's been run at Chili's, which is a restaurant that the Europeans in this room would not be able to comprehend. We teach workshops on how to run the light node. Here's Josh showing people how to run the light node at modular summit. But I have some bad news. The excitement has to die out if we want to win. It's sad that we have to move on from this early stage of us taking all these pictures and celebrating it so much and showing it everywhere.
00:01:45.960 - 00:02:27.178, Speaker A: Once it becomes a boring and ubiquitous thing is when we know we've won, people don't celebrate the calculator app. They don't celebrate the notes app. And that's where we need to go. We need to get to the point where it's something we don't think about. We don't need to celebrate because it's just everywhere. Like the padlock symbol on the web browser, it'll just become a reassuring thing that protects people from attacks they don't know about, using cryptography. They don't understand, and everyone will take it for granted, which is good.
00:02:27.178 - 00:03:38.296, Speaker A: We will have won when we start to take it for granted. Okay, to change the subject a little bit, this is a question that I constantly get asked. Like, everywhere I go online, at conferences, there's always people who are like, what's the incentive to run a light node? You guys need people to run light nodes for the chain. What's the incentive? What do I get for doing this? And I think the misconception comes from all the content we have out there that says the network scales with the number of light nodes, which is pretty true, but people get the idea that it's like, oh, Solana scales by making the nodes bigger, and Celestia scales with the number of light nodes. No, Celestia also scales by making the nodes bigger, but we need more light nodes to do that securely. Anyway, I think that's where the misconception comes from, but I want to talk about why this question drives me so crazy. So when I first started using crypto, the way that everyone used to use it was with this application here.
00:03:38.296 - 00:04:19.570, Speaker A: This is bitcoin core for windows, and it's a wallet and a full node. When you want to look at your balance or send and receive bitcoins, you have to wait for this thing to synchronize. And you can see down on the bottom, it shows you the sync status of the node that's running in the application. And this was by far the main way that everybody used bitcoin at the time. And so you had everybody running nodes. Not running a node was not really even an option when this was the primary way to use crypto. This app is from 2011.
00:04:19.570 - 00:05:22.690, Speaker A: This is a bitcoin wallet for Android. And we talk about users running light nodes like it's some kind of science fiction, but this is 13 years old. The first ever front end to Ethereum was this thing called Mist, and it's like a web browser thing, and it also ran a full node, and you had to wait for it to synchronize before you could click buttons and interact with Ethereum. One of the first Dapps was called Augur, and it didn't have a hosted front end because when the auger client side app came out, the idea of a hosted front end was ridiculous. People would laugh if you suggested that. They would say, oh, isn't that centralized? Of course the app needs to be a full node because it's a Dap. Then a little bit later, web wallets came out and they shipped with remote rpcs.
00:05:22.690 - 00:06:30.620, Speaker A: And what's really funny is now people ask me, what's the incentive to run a node? But if you're on the Ethereum subreddit, when Metamask came out, there were a lot of commenters who were saying, what is this? Where's my node? What happened to the node? Didn't mist and augur have full nodes running? What is this? Are we just trusting Joe Lubin? But nodes in end user software has not completely died out. Privacy focused apps require them. It's actually not possible to make a wallet for a shielded blockchain without doing this, without syncing the blocks and syncing nullifiers out of the block or notes out of the blocks and trying to decrypt them. This is a screenshot of ywallethe, one of the Zcash mobile wallets. This is the Penumbra wallet. It also does the same thing. You can see at the top it has a worker that syncs blocks in parallel and it displays this to the user and there's just no way to do it without it being some sort of node.
00:06:30.620 - 00:07:37.906, Speaker A: Additionally, Kepler, which is the main web wallet for Cosmos, it has this place in the settings where you can put in a link to the lcd the letclient daemon, and nobody uses this. The devs haven't really spent much time trying to improve the UX of this, because again, what's the incentive? But alas, this guy kind of has a point. The question may drive me crazy, but it still deserves an answer. People aren't going to do something if the benefit of doing it is less than the cost of doing it. If you want anyone to do anything, and I want people to get the full security of blockchains, the benefit of doing it has to exceed the cost of doing it. So we think about, we ask, what's the incentive? Maybe we should instead think about it the other way. Maybe the cost is just too high.
00:07:37.906 - 00:08:24.184, Speaker A: Maybe the benefit is small, but the cost is too high. If the benefit is small and the cost is zero, you'll do it. You wouldn't walk up a ten mile hill for a piece of candy. But if I put a piece of candy in your hand, you'd probably accept it. So imagine you have two plumbuses, and they both are really fast, and they both have really low fees and have the same apps and the same liquidity, and otherwise they're completely the same. But one of them has a trust minimized like client. At least it's something I started to spend some time thinking about.
00:08:24.184 - 00:09:07.510, Speaker A: How do we make the node lighter? How do we make it so, so incredibly light that you just, everybody will take it? And it's just so easy that it doesn't slow anything down, it doesn't waste your bandwidth, it doesn't make your hardware lag, and it's just like this nice little free piece of candy that gives you more security. Lumina RS is awesome. This is the demo that is at modular summit and everybody's trying it out and you can check it out and get an NFT. It's really, really dope, but it still takes some time to sync. You still have to actually decide to do it. It's not so light that you don't even have to think about it. So it's great that we have this wasm like client that runs in the browser now.
00:09:07.510 - 00:10:15.810, Speaker A: Big improvement over modular summit last year where we didn't have a cool demo like this, but I still want it to be lighter, I still want it to sync instantly, and I want it to be just completely effortless, as if I was just putting a piece of candy in your hand. So I started to think about how, what's the state of the art for really, really, really light, really really fast thinking light clients. There's this idea that's a few years old now where you can use recursive ZK proofs to sync the chain. I believe the first place this came up was plumo by Celo, which where every time there's a new block header, they create a recursive proof of all the previous headers and you can just verify one proof to sync the whole chain. And then Mina took it even further where they also wrapped up the execution into that as well. So it's not just a consensus like client, it's also recursively verifying the whole consensus and execution history of the chain. And so I built a prototype of that for Celestia on my GitHub.
00:10:15.810 - 00:11:04.932, Speaker A: Right now you can find the celestial recursive sync repo, and this uses SP one to just verify tendermint and produce a proof, and then also verify the proof from the last header. And if you're in the SP one chat, you probably saw me begging for the recursion feature for a month so I could do this as soon as they did, I put it together. But that is not all. You need to have a trust minimized light client. The plumo and the Mina ZK recursion powered light clients don't da sample. So if you are validating consensus and the state transition function, there still is a way that your light node could get fooled in a way that a full node wouldn't be able to be fooled, which is data withholding. And we want to make these things good.
00:11:04.932 - 00:12:16.532, Speaker A: We want these things to be properly trust minimized. If you download a Celestia header like this, they're about 61. If you want to sample the last two weeks, you need to have two weeks worth of these headers, which is pretty big. That's 879 megabytes, which is 30 to 40 minutes of TikTok usage, and that's not even counting the samples and the sample merkel proofs. So 30 to 40 minutes of TikTok usage on bandwidth equivalent on your device that seems a little bit like not enough, like I'm handing you the piece of candy. That sounds like we're getting to the territory of this is a little bit too clunky to be everywhere, but there's tricks you can do to lower that, and we're going to get into that. So once you can trust a recent header, for example, maybe you're using the recursive ZK proof that I am building, you can sync the rest of the headers backwards.
00:12:16.532 - 00:12:53.456, Speaker A: So instead of checking all the signatures, you can just look at the hash of the previous and the hash of the previous and so on. The cometbft already does this, and it's also an initiative from the node team, the celestial node team. This is what a header looks like. It has a bunch of fields in it, quite a few. You have the consensus hash next validators, hash stateroot, and so on. It's pretty big. These are the things that are.
00:12:53.456 - 00:13:45.000, Speaker A: Well, along with the signature data, these are the things that are 60 kb ish. But if you're doing backwards sync, you don't need all that data. You can just look at the hash of the header, the last block id, which is the hash of the previous, the data route, because you need that to authenticate the samples as well as verify proofs about rollups. And the tendermint block hash is actually a merkle proof of the fields in the header. So you just provide merkle proofs to the two fields that we care about, and you can reduce the size by 99%, which is great. So it's not going to be 800 megabytes, which is 30 to 40 minutes of TikTok usage. It's going to be.
00:13:45.000 - 00:15:14.190, Speaker A: You can cut that down by 99%. You still have the samples and the sample merkle proofs, so it's not going to be quite 99%. But we're probably, if you, especially if you combine it with something like Gzip or some other compression algorithm, you can probably get this a lot lower than 30 to 40 minutes of TikTok usage, probably in the single digit minutes, like maybe less than ten minutes of TikTok usage, which is much closer to this being completely effortless. Going back to how the recursive sync lite client would work. Right now, the proving time that I benchmarked on my laptop is 25 minutes, which is a lot slower than the Celestia block time, which is 12 seconds. So you would worry that the, that the proofs would not be able to keep up with the blocks, which is a concern. This is currently solved in the repo by leveraging comment BFT skipping verification so just like how the IBC on chain tendermint like clients allow you to relay headers and skip some of the ones in between by using this heuristic where as long they say that as long as the validator set doesn't change by one third of stake, you can safely assume that it's legit.
00:15:14.190 - 00:16:44.582, Speaker A: Although it does have a few different attacks if you're using skipping verification than a regular one, which you can read about in this article by Anton called different types of evidence and tendermint, where he outlines the different attack vectors against skipping verification versus going one by one. So ideally we wouldn't have to do that optimization to let the proofs keep up with the blocks. At the moment, that's what I've built, but theoretically there's a cool way that you can keep up with the chain even though the proof time is slower, which is this, you can use a folding scheme, so the proof time might be slower than one block, but if you're using some sort of proof system that supports folding, you can accumulate a witness of the tendermint circuit every time there's a new block and then prove as fast as the proving time without the actual witness that you're proving falling behind with the chain. And there's actually like a pretty good stack which is pretty mature and ready for this exact thing to be built today. The proto Galaxy folding scheme is the state of the art. It's implemented in Bretonberg and then noir language exists as a front end for that. So this is a cool thing someone could build if you are in need of a hackathon project, and that's about it.
00:16:44.582 - 00:16:45.270, Speaker A: That's all for my talk.
