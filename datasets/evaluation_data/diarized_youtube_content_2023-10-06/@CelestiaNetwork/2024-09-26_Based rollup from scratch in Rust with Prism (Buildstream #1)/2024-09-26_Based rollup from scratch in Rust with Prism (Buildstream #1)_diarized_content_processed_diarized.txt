00:00:01.680 - 00:00:02.220, Speaker A: Nice.
00:00:03.185 - 00:00:03.937, Speaker B: We live.
00:00:04.041 - 00:00:39.925, Speaker A: Yeah, we're definitely live. Welcome everyone to the first stream of a series to be titled where we meet with developers who are building in the Celestia ecosystem and talk about what they're building. Today I'm excited to welcome Distracted Mind, AKA Ryan. And we're going to be talking about based roll ups, building a based roll up in scratch from scratch in Rust. Ryan, I'm going to let you do a little intro and then we'll get to the next slides.
00:00:40.585 - 00:01:53.295, Speaker B: So I'm Ryan. I was a protocol engineer at Celestia for about the past two years, working on the Node team in a little bit with Devrel. And I am now founding Prism, which is a verifiable authentication standard for the Internet, which is kind of word solid, but it lets us build Web3 applications on Web2 rails without compromising on decentralization or privacy and security and actually improves these things of these metrics in quite a massive way compared to for example, Ethereum, thanks to Celestia. And it operates as a base rollup on Celestia. And I was really excited to talk to Josh about how we can show the world how easy it is to actually make a based roll up and what it is. So that's what we'll be going through today, making a quick little chat app, not using Prism. We won't actually be talking about Prism much, just about based roll ups and.
00:01:53.295 - 00:01:54.775, Speaker B: Yeah, yeah.
00:01:54.855 - 00:02:35.611, Speaker A: And I guess like more context there. I think like a lot of you, if you're, if you've watched like other things that we've done, there's been a lot of like SDKs and things where you have to use a bunch of different things together. But Ryan's going to show us how easy it is to actually just build an application directly on top of Celestia. So yeah, I'm looking forward. And on that note, we're going to just go through some introduction real quick. I'm going to try to do this as quickly as possible so as to not lose people so quickly. We're going to go over Celestia, the different types of roll ups and then we'll get to a demo first.
00:02:35.611 - 00:03:48.695, Speaker A: What is Celestia? If you're not familiar, Celestia is a modular data availability network that makes it easy for anyone to securely launch their own blockchain and that's what we'll be doing today. We can think of it more like an application though. What is data availability? Data availability is in the blockchain sense, the ability to ensure that every transaction included in every block is accessible to every node in the network. So basically this means that everyone as an independent individual can access the all of the information that they need to and then also verify that all those transactions are there. And then what is data availability sampling? Data availability sampling is the magic that makes Celestia work. So basically we're able to sample using a novel mechanism and this enables trust minimized light clients. So by downloading a small portion of the data, what we're able to do is verify that all the data is there.
00:03:48.695 - 00:03:57.335, Speaker A: So this lets us run these light nodes on phones in our browser actually even in like Chrome extensions and wallets and things like that.
00:03:58.155 - 00:04:42.579, Speaker B: And I'd like to butt in here actually. Yeah, please say like before we get into, you know, this next part, that this is the real innovation behind Celestia. It's not abundant black space or whatever, it's trust minimized light clients. It is exactly what the space has been screaming, crying for, for over a decade now. It was the original dream of Ethereum that you can have applications that talk directly to the blockchain. It didn't end up working on Ethereum because they don't have trust minimize light clients. You have to trust some node running elsewhere to give you the correct data.
00:04:42.579 - 00:05:10.345, Speaker B: And with Celestia you can run trust minimize light clients, which means you can have like a little package running in your own application that talks directly to the Celestia blockchain without relying on intermediate parties. And not only that, but actually provide security back into the network and letting us make even bigger blocks. So that's what's really exciting and that's what this slide is about.
00:05:11.085 - 00:06:05.655, Speaker A: Yeah, and I guess that's also what makes the like north star of 1 gigabyte really exciting because we're at 2 megabytes right now, so there's a long way to go. But by the way that Celestia is designed, this is something that is actually possible. See where we're at. So yeah, I guess like something that I find really cool is that light nodes make the Internet verifiable by all I mentioned, like you can run them in browsers, you can run them in your phone. Eventually we want to be able to verify like everything we're doing with something like this. So I guess like at the core with Celestia underneath, developers can deploy high throughput unstoppable applications with full stack customizability. And what this looks like, I guess we're going to go into like what a roll up is now.
00:06:05.655 - 00:06:42.905, Speaker A: So I also, I guess if you're in the chat, drop an L for lazy ledger. We're glad to have you here. And if you have any questions, drop them in the chat as well. So, yeah, what's a roll up? A rollup is a type of blockchain that publishes its transactions to another blockchain. I think this is like the easiest way to describe it at a high level. I think there's definitely some nuance there if you want to get into semantic debates. But basically a rollup is a blockchain that uses another blockchain for something.
00:06:42.905 - 00:07:30.325, Speaker A: And what this looks like in practice, you basically in like the most, I guess, standard way, you take your transactions, you bundle them up into a proof, and then you post that proof to something like Celestia and also. Ryan, feel free to interrupt me. Yeah, yeah. But the most common type of roll up that we're seeing on Celestia is a smart contract roll up. And a smart contract roll up is a type of blockchain that publishes its finalized blocks to the settlement layer, which then verifies the transactions using its execution environment. So there's a lot of infrastructure to be ran here and it relies a lot on the settlement layer. What's up, Brian?
00:07:30.625 - 00:08:12.475, Speaker B: Yeah, so something particular to pay attention to here because it's the nuance that we'll talk about in regards to other types of roll ups is that it publishes its finalized blocks. So it creates its blocks outside of this blockchain, like people are submitting transactions to some sequencer and then it sequences the transactions, makes a block, and then publishes that block to whatever the base layer, which then also verifies like proof of correct execution in some cases that this block is correct and allows the roll up to continue.
00:08:13.695 - 00:08:54.605, Speaker A: And I feel like I should have skipped to these a little bit sooner. So this first one is what it looks like in terms of like the modular blockchain design. And then Ryan was describing here the way that it verifies those proofs and transactions. I want to try and skip through this so we can get to the actual demo. So what is a sovereign roll up? You've probably heard of this and maybe don't understand the difference. A sovereign roll up has its own settlement layer, has its own execution, and then it uses something like Celestia for consensus and da.
00:08:55.715 - 00:09:32.855, Speaker B: So something I guess important to note here is that in a smart contract roll up you are posting your proof of correct execution to the L1. And the L1, in this case mostly Ethereum, has an execution environment that verifies this proof so you are paying Ethereum for this like computation and in a sovereign rollup you don't offload that, you do it yourself and you are completely in control.
00:09:34.635 - 00:09:52.813, Speaker A: So yeah, so yeah, I guess like the beautiful part about sovereign rollups at a high level is that you can have control about pretty much everything that you're doing with the roll up. But I'm going to let you take this actually.
00:09:52.869 - 00:10:04.745, Speaker B: Oh, sorry. All base roll ups are sovereign. Yeah, but not all sovereign rollups are based. So based rollups are like a subset of sovereign rollups that have some unique properties that make them pretty cool.
00:10:06.125 - 00:10:14.345, Speaker A: So yeah. What, what is a base roll up? I feel like this is one that's kind of like less defined than most of the ones we've already talked about.
00:10:14.925 - 00:11:47.065, Speaker B: Right? This, this kind of got defined like I think last year for the first time by the Ethereum and Celestia community, Dankrad posted like the first, I think it was Dinkrad first explanation of what it is but from my understanding or our understanding and a simpler explanation is just a roll up where the next block in the rollup is defined by the transactions that were posted in the previous O1 block. This, this is different to smart contract rollups in the sense that the transaction, the transactions don't go through a sequencer and then get finalized into a block and that block gets posted. But anybody can post their transactions directly to the base layer, for example Celestia and then they will get permissionlessly included in the next roll up block if they're valid. So instead of posting your blocks to Celestia, Celestia already has the transaction data and you use that to make your next roll of block. And that of course has a nice property that you can post your transactions to the base layer. Like I said, typically you can do this with smart contract roll ups as well, but it works kind of differently. Like you post it to the smart contract and then the sequencer will be forced to include it in the next block.
00:11:47.065 - 00:12:06.263, Speaker B: But that's more of like a side effect or like a escape mechanism, security mechanism rather than a baked in feature to the architecture. So we have some scribbles here where we were.
00:12:06.399 - 00:12:10.623, Speaker A: Yeah, I was actually trying to scribble on it and it's just not working. So I'm glad we use this.
00:12:10.759 - 00:12:11.335, Speaker B: Yeah, it's fine.
00:12:11.375 - 00:12:19.231, Speaker A: Yeah, base rollups are so based they don't even have like a diagram yet. So yeah, yeah, figure that out once we, once we go through this whole thing.
00:12:19.263 - 00:13:07.127, Speaker B: So a big like architecture difference with base rollups is that they don't have a sequencer really. I mean they have a bachelor. So people can either post transactions to the batcher and maybe you get a discount for doing so, or maybe the bachelor subsidizes their transactions. Or they can just post directly to the L1 and then the roll up network can decide or not can decide derives the next roll up block based on the transactions that were in that previous one block. So instead of making a block and posting it to the L1, L1 makes a block and you make your roll up block based from the data that's in there. Yes.
00:13:07.271 - 00:13:12.695, Speaker A: Nice. So on that note, I drew something and it's not showing up. So we're going to get.
00:13:12.775 - 00:13:47.883, Speaker B: We did get a. We did get some questions here. So one of them, what makes a smart contract a type of blockchain? I thought they were more like apps or is it a SM contract rollup different than a solidity smart contract in context of Ethereum. So rollups can sometimes be defined like by a smart contract. It doesn't mean that all smart contracts are rollups. Most smart contracts are just apps on top of Ethereum. But it is the most common way to deploy rollups.
00:13:47.883 - 00:14:23.867, Speaker B: And some also common base rollups are roll ups that share a sequencer with the base L1. Not that they don't have. Yeah, I mean this is semantics, this is like nuance. So in reality you are sending your transactions directly to the L1, meaning that L1 has a sequencer that decides to include your transaction permissionlessly or not. But the point there is that the roll up architecture itself does not require running a centralized sequencer that you maintain. So. Yeah, I mean that's correct.
00:14:23.971 - 00:14:33.455, Speaker A: Yeah. Thank you. I wanted to jump back to this because I feel like the like thing to be clarified here, like most roll ups that you know of are smart contract roll ups.
00:14:34.275 - 00:14:34.819, Speaker B: Yeah.
00:14:34.907 - 00:14:52.037, Speaker A: So like yeah, pretty much everything. I think we're ready to start demoing. All right, that last slide is just time to demo. Let's build. So I'm going to let you kick it off and we're going to follow along.
00:14:52.181 - 00:15:13.355, Speaker B: So if I need to make my font bigger, people can say in the chat. But we're just going to get started. So we're really raw dogging this in rust. We're not going to use any frameworks or anything. So first thing that we need to do is create a new project going to call it GRG Chat. Why is that?
00:15:13.695 - 00:15:15.435, Speaker A: I feel like we need some context.
00:15:15.855 - 00:16:09.265, Speaker B: So our, our base roll up that we're going to make today is literally just a stupid simple chat application without authentication. Authentication is an exercise left to the reader. It's super easy to add, but for like minimizing the scope here, it doesn't include it. And it will, we will go through making the transaction types the component that handles the state and then the component the like node of the roll up that actually can submit batches and derive blocks from L1 and all of that fun stuff. So it'll become more clear as we jump into it. Cool. So I have created the project with cargo and now I'm just going to open it here.
00:16:09.265 - 00:17:10.575, Speaker B: That's not the right one, this is the right one. And we are going to start out by creating our transaction types. So this is actually super simple. First we need to make a librs that includes the transaction types and then we can already get started actually because we're not using SDK, we can just define them as the enum. So what are our transaction types? We have, we want to do two types. So sending a message and then a registration registry. And so the way that these will end up looking is if you want to send a message to a chat, or maybe we should start with register.
00:17:10.575 - 00:17:51.741, Speaker B: So if we, if we want to register to send a message, we are going to have a username which is just a string and then public key, which is a public key. Now this does not actually end up getting used in this demo. What we're going to do is provide that as an exercise to the reader that that gets verified. And the reason that we like have this transaction type then I mean it's a little superfluous, but super flawless or superfluous, I don't know.
00:17:51.773 - 00:17:57.725, Speaker A: That's all good, I guess. Like the authentication is not really like the point here, right?
00:17:57.765 - 00:17:59.869, Speaker B: Yeah, it's not the point, but if.
00:17:59.877 - 00:18:03.749, Speaker A: You want to add it and you're watching this like this is definitely a good exercise.
00:18:03.797 - 00:18:53.393, Speaker B: Yeah, we actually don't even have a public key type because we're not importing any. So it will just be a vector of bytes, that's all we need. So the point of the register transaction type is that you don't want to have everybody's name in the chat be some big long unrecognizable string of public public key. So we're going to let users send a public key and a username and then when they chat their username will be shown. Now, because we don't have authentication, theoretically you could send a message for any user, but like Josh said that's not included here. So that's our register. That's already a registered transaction type.
00:18:53.393 - 00:19:36.595, Speaker B: It's just a strict. And then we also have our send message which will have a public key as a user it will have a like contents of course what the message is made up of and then also the channel that we send it in. So we're going to have like multiple channels. Like if you think of Slack or Discord or something, you have like a target for where your message goes. All right. And so that's actually also it. Of course this is also missing the signature but you're low key like building.
00:19:36.675 - 00:19:40.361, Speaker A: Discord on a base roll up if you think about it. Nice.
00:19:40.473 - 00:20:09.531, Speaker B: A little bit. Yeah. And so then of course we need to include these here so that they get like. So then the transaction is made up of these types. So the, there's like the variant of the enum and then this is the contents of the actual transaction. So there we have, we already have our transaction types. I'm going to have to come back in here and derive some traits.
00:20:09.531 - 00:20:14.655, Speaker B: But that's already it. I mean it's 20 lines of rest.
00:20:14.955 - 00:20:15.499, Speaker A: Nice.
00:20:15.587 - 00:20:53.409, Speaker B: And then now we can, can have a base role for the Greg Chat. Base role? Yeah, like adding a role for a user. Right. So you could actually theoretically have then grant role that maybe only the like creator of the roll up. So you, you'd register a public key and only that public key is allowed to grant roles and then it gets attached to the user. You could do that pretty easily. So next step is we need somewhere to handle the state.
00:20:53.409 - 00:21:43.553, Speaker B: We need somewhere to when a transaction gets processed to actually like update the state of the roll up. So that's our next step. And if we think about it, we're not going to use like a Merkle tree or anything. It should if you eventually want to make proofs over anything. But for sake of simplicity we are just going to raw dog it with hash maps so that we have a state struct and this is what our nodes will contain. And then what it's made up of is a. I guess this doesn't need to be public hash map made up of public keys to strings.
00:21:43.553 - 00:21:47.761, Speaker B: Right. Because when you register, you register with the public key and then that gets mapped to a string.
00:21:47.913 - 00:21:48.603, Speaker A: Nice.
00:21:48.769 - 00:21:50.303, Speaker B: And then we also.
00:21:50.479 - 00:21:54.487, Speaker A: Otherwise you'd have like public keys showing for people names.
00:21:54.551 - 00:22:23.285, Speaker B: Yeah, exactly. And then we also have a hash map of what is the channel identifier. It's also a string to a vector of messages. Now message as a struct does not actually exist yet. So I'm going to make it here. All it is is a user id, which is a string. Note that it's not a public key here, because when we display it to the applications end users, we again don't want to show the public key.
00:22:23.285 - 00:22:46.915, Speaker B: And then we also have the contents of the message. Just another string. All right. I don't know what it's complaining about here. Expected comma. Oh, yeah. So the first thing we need to do when we think about state is of course.
00:22:46.915 - 00:22:57.295, Speaker B: Oh, whoa. That was AI. Sorry about that. Okay, we don't want to do that. We need to have this like new. New state.
00:22:57.415 - 00:22:58.715, Speaker A: You're not just coming up.
00:23:01.095 - 00:23:40.703, Speaker B: I mean like using AI, you could make it even quicker because it's that simple. But anyways, what you want to be able to do is validate a transaction, right? So if we have. It's going to take the state and it's also going to take a new transaction and then it's going to output. Hold on. We need to add some dependencies. One of these is anyhow, which is good for error handling. Is it going to show here? I think that's it.
00:23:40.703 - 00:24:15.195, Speaker B: Is that it? Yeah. And so that just tells us if something has errored or succeeded. So when you call validate tx, you just want it to give you a response. Is it an error or did it pass? And that's what result is good for. And then we need to actually validate. So what does it mean for a transaction to be valid? We can think about that. So for a registered transaction, we're using pattern matching here.
00:24:15.195 - 00:24:41.445, Speaker B: When is it valid? It's valid when a user that the user that they're trying to register does not already exist. So is this already correct? If the users already exists, then to error?
00:24:43.625 - 00:24:44.365, Speaker A: No.
00:24:46.905 - 00:25:22.323, Speaker B: I think that's correct. I don't want to do that. I want to import this macro here so that our code looks less ugly. But I was actually thinking of the inverse case. Like if the user doesn't already exist. All right, no, sorry. Like the user not already existing is for send message.
00:25:22.323 - 00:25:52.857, Speaker B: So this is already correct for register. So if you are trying to register, the only way you're able to register is if that public key that you're trying to register isn't already in the state. Technically, like it needs more. Technically you should have unique strings as well. So instead of just checking if the public key exists, you should also check if that username has already been registered. But we're not going to care about that here because you could do different.
00:25:52.921 - 00:25:54.905, Speaker A: Public key with same username.
00:25:55.065 - 00:26:32.755, Speaker B: Yeah, exactly. You could pose somebody else, I guess, and nobody would be able to tell the difference. And then sending a message is just exactly the opposite. So you can only send a message if you've already registered. And then at the end of this we just want to say that everything is okay. So why is this network? Because we need to derive some traits on here, which would be. So this is just a way of.
00:26:32.755 - 00:27:23.555, Speaker B: In case you don't know rest, it has these macros that lets you have your structs fulfill properties without you adding any extra code. So what we need here is clone. It needs to be able to be serialized so that we can post it onto the data availability layer. And then the same applies for the public key, but we also need to be able to hash it and be able to test for quality. And these are things for the hashmap. And then for our other transaction types, we also just need this. Serialize and deserialized don't exist yet because I need to cargo add serta.
00:27:23.555 - 00:27:29.035, Speaker B: And then in here we're going to say.
00:27:32.895 - 00:27:33.439, Speaker A: Derive.
00:27:33.487 - 00:27:49.335, Speaker B: And this will like unlock those macros that I was just talking about. So now this should theoretically compile once I add them. All Right, Coolio.
00:27:50.315 - 00:27:51.295, Speaker A: That's like.
00:27:51.715 - 00:27:56.499, Speaker B: That's already validating a transaction thing, huh? What did you want to say?
00:27:56.587 - 00:28:01.375, Speaker A: I'm saying. Yeah, I was just going to ask like that. That looks like the full transaction type.
00:28:01.875 - 00:28:21.273, Speaker B: Yeah, I mean it is. So this is now like we won't have to change anything in here and still 20 lines of rest. And that's like. Oh wait, no it's not, it's like 30. Yeah. So we can validate a transaction, but we also need to process one. Right.
00:28:21.273 - 00:28:53.261, Speaker B: So if a transaction is coming in, we need to be able to actually execute it. And the way that that works is only a tiny bit more complicated. So we're going to take a mutable reference to ourselves because we need to change the state. We're also going to take the incoming transaction. First thing we want to do, of course, is well, wait, let me. Let's have that also return a result. So we want to validate that.
00:28:53.261 - 00:29:44.895, Speaker B: We want to use the method we just made to make sure that it's valid. And then once we know that it's valid, we can execute it. So we're gonna have another match statement. And then if you're registering what that looks like is that we just insert the user. What would that be? Contents, User contents id. And then if you have A send message transaction. What that does is.
00:29:44.895 - 00:30:11.943, Speaker B: Whoa, whoa, whoa, whoa. The AI is kind of tripping me out. I need to turn that off. But first we need to get all that. So let's look at the state. What we have is a hash map that points from a channel to a list of messages. So what we want, if somebody is sending a message, is to get that list of messages and add the new message.
00:30:11.943 - 00:30:57.535, Speaker B: Yep. So that means that the first thing that you do is get the channel. Get that vec at contents channel. So then this is a. Like, it could be messages, but it could also be empty in case it doesn't exist yet. And then we also have the user, which comes from here. So we get the user identifier for the user's public key, because in the send message transaction, it doesn't have their username and only as a public key.
00:30:57.535 - 00:31:35.469, Speaker B: And then now we have to construct our new message, which is literally just user id, user clone. And then the contents are the contents of the contents. Contents of the transaction type. All right, now we have to handle two cases. Because this is an option, it means it could already be empty, meaning this is the first message in the channel. Is that correct? I think so. Yeah, this is already correct.
00:31:35.469 - 00:32:10.367, Speaker B: So in case the messages don't exist yet, we need to like create a. Initialize it in the hash map. Otherwise we can just add on to it. And that's what this case is. So if there's already some messages, we just added it. Otherwise we need to create a whole, whole new entry. Why is this failing? Because we should just be returning first.
00:32:10.391 - 00:32:12.155, Speaker A: Of all, msgs.
00:32:16.535 - 00:32:30.165, Speaker B: Where. No, I think we just need to say okay at the end. And that's just.
00:32:34.785 - 00:32:42.825, Speaker A: Do we need something to process a register, like a registration of a user?
00:32:42.985 - 00:32:57.695, Speaker B: Oh, no, I know what's wrong. I think it's just this. Oh, I'm one layer too far out. What is wrong about the register?
00:32:58.835 - 00:33:04.095, Speaker A: You have to have handle the case where you're registering a user to.
00:33:06.595 - 00:33:10.215, Speaker B: What do you mean a user? To.
00:33:12.275 - 00:33:17.875, Speaker A: Land. No, to make sure like you're processing the send message. Right. Oh, I see it. Sorry.
00:33:17.995 - 00:33:26.535, Speaker B: Yeah. So in the register you're just inserting it. I think this is the problem.
00:33:27.115 - 00:33:30.135, Speaker A: Do you need to handle the case where the user exists already?
00:33:31.715 - 00:34:28.035, Speaker B: Oh, well, no, we already do that here. Right. Okay, so if the user already exists, then we're going to throw an error anyways. I'll come back to this, but this is already our like right now. Now this is really bugging me because I don't know what's wrong. Self user expected. One of them takes that public key and like I mixed them up.
00:34:28.035 - 00:34:55.883, Speaker B: Right. And then this just needs to be like that. Okay, we're good now. Now we have no errors. All right. So that processes our transaction. And so with that we actually already have the.
00:34:55.883 - 00:35:13.973, Speaker B: This is our execution environment. So we have an execution environment and 70 lines of rest instead of some, like, bullshit, I don't know, thousands of lines of code backing it. You can just have something over here. Yeah.
00:35:14.069 - 00:35:15.225, Speaker A: That you don't understand.
00:35:16.005 - 00:35:18.309, Speaker B: This is all you need for an app like this, right?
00:35:18.357 - 00:35:18.985, Speaker A: Yeah.
00:35:19.965 - 00:35:51.881, Speaker B: Okay, so what is next? Now we actually have to write the roll up node, which is the more complicated part. But it will also. I'm not going to do the whole thing on stream. So now I will add full node and pull up my reference here. So let's get started. What is a full node? I mean, I'm calling it full node, but it's light enough that it could be its own. Like.
00:35:52.033 - 00:35:58.127, Speaker A: Yeah, like the application is so light, right? Like it's not going to make our computers break when we run it.
00:35:58.231 - 00:36:37.575, Speaker B: No, no. The reason I'm calling it full node is because in the context of rollups, full node is a node that processes all the transactions individually. And a light node is typically one that just verifies proofs. But this node is so light that it could run in your browser, for example. First, before I do that, we need to add a few more dependencies that would be Celestia types and then Celestia or PC.
00:36:39.635 - 00:36:41.651, Speaker A: All right, and what is the.
00:36:41.683 - 00:36:42.499, Speaker B: What are those for?
00:36:42.587 - 00:36:43.899, Speaker A: Like, like high level.
00:36:43.987 - 00:37:01.161, Speaker B: So we need Celestia types because the Celestia types has, for example, a blob. And a blob is what we're going to submit to the Celestia blockchain. And it's also what we're going to retrieve from the Celestia blockchain. Then we need the RPC create to let us communicate with Celestia. Cool.
00:37:01.193 - 00:37:05.217, Speaker A: And we're going to just use that to talk to our light node. Like normal light node.
00:37:05.281 - 00:37:24.965, Speaker B: Yeah, exactly. Cool. So one thing that you need is your state. So that's what we made in the other file. Right. Because you need to be able to progress your state based on transactions that are coming in. You're also going old ones too.
00:37:24.965 - 00:37:46.781, Speaker B: Yeah, yeah, exactly. And so that's actually all you need for that. And then we also have like the client that actually talks to Celestia. So I'm just going to take it from CELESTIA RPC client and then we have a namespace. Maybe you want to talk about what a namespace is?
00:37:46.893 - 00:38:03.745, Speaker A: Yeah, I guess like the easiest way to think about a namespace is like a channel on Celestia that you would post to. Right. Permissionless. Anyone can post to any names. Well like with a few exceptions anyone can post to any namespace. But yeah, the best way it's just like a channel on Discord.
00:38:04.685 - 00:38:58.985, Speaker B: So what that means is our roll up posts to a channel and then when we request all of our transactions, we only get transactions from that channel, which is really nice. And then we also need a start height because if you didn't have a start height, what would happen is your roll up would try to search for transactions from the first block on Celestia and we start way ahead. What are we on like block 2 million or something on Mocha. So we start later so that you don't need to sync as much history like you know when your roll up started. Doesn't make sense to try to find transactions before that point in time. So we have a start height, we have the namespace, we have the DA client and then that's all we need for now. And we can get started with like the actual methods.
00:38:58.985 - 00:38:59.765, Speaker B: So.
00:39:02.425 - 00:39:12.745, Speaker A: I guess the start height, like you, you don't really technically need it, but it's just a way to reduce the load on your application or whatever you're doing.
00:39:13.645 - 00:39:14.325, Speaker B: Yeah.
00:39:14.445 - 00:39:15.197, Speaker A: What's Tokio?
00:39:15.261 - 00:39:34.669, Speaker B: One thing we do need is Tokio which lets us do some async rust for example. I'll show in a second. Wait, not there. I think we need to add some features. So version features. It's like, I think it's. Yeah.
00:39:34.669 - 00:40:52.487, Speaker B: Full and so let's think about what a full no needs to do. First thing is it needs to sync old roll up or sync old celestial blocks so that it knows it finds transactions that were already posted and also needs to keep up with incoming celestial blocks as they get produced. So we can start maybe not with the like incoming blocks, but it makes sense to start with like historical sync. So what that is is it's a synchronous function and it takes an arc. An arc is if you don't know rust, it's an atomic reference counter. It's so that you can like keep track of how many copies of a struct you have somewhere and send them around threads. And the way that Genesis sync works is first we need to know.
00:40:52.487 - 00:41:04.355, Speaker B: We already know where we are going to start syncing. Right. That's what start height is. But we need to know like the final height of the network that we need to sync to get caught up fully.
00:41:05.415 - 00:41:08.355, Speaker A: Just like the latest header.
00:41:09.655 - 00:41:28.961, Speaker B: Yeah, just the latest header. So we say header network head and then we pass in the self DA client. That's how that works. And then we call await and then do you think I can reduce the font size a little bit?
00:41:29.073 - 00:41:33.605, Speaker A: Yeah, I think so. Otherwise yeah, you'd have to wrap it.
00:41:35.985 - 00:42:48.399, Speaker B: And then let's just get rid of the errors by doing that. So our final height is going to be this network headers height. And then what we're going to need to do of course is say for every height and from the start height all the way to the network height value. I don't really know why there's the dot value method on it. I guess height is its own type and celestial types. We need to sync a block. So the way we do that is by asking the blob client self height and then it takes a list of namespaces in case you have like some rollups need multiple namespaces.
00:42:48.399 - 00:43:47.925, Speaker B: We only have one and that is self namespace and we have to await that as well DA client and then that gives us maybe a vector of blobs. So if there are some blobs, if there are none, we don't care, we just throw away the height. If some blobs is response then that lets us do something called process 01 block. OK, problem. This doesn't exist yet so we can make that really quickly. It's also really simple. What it is is I'm trying to ignore the AI as it comes in.
00:43:47.925 - 00:44:56.637, Speaker B: It also takes reference counter to itself and then it takes a vector of celestial blobs and it's just going to give us oh no, it doesn't even need to give us a result. So what this is going to do is try to parse every single blob that we get. Because if you think about what a celestial block is, there's a ton of namespaces. In every namespace there's a certain amount of blobs. Right now for us, these blobs could be one of three things. They could be junk, an invalid transaction or somebody spamming us, we want to throw those away. It could be a single transaction if somebody just posted a single transaction or it could be a list of transactions in the case that you're using like batcher.
00:44:56.637 - 00:46:11.143, Speaker B: Okay so the way that we're going to process them is by saying blobs.intoiter. flat map. I'll explain this in a second. Oh, we need one thing, and that is our batch type, which is just a, like an alias basically for a vector of transactions. All right, so we want to try to turn every blob into a batch. That means try. We need to actually match this case, hopefully.
00:46:11.143 - 00:47:03.165, Speaker B: Why isn't that? So in case the trying to parse it from a batch is successful, then we'll take batch zero. And what that means in Rust is it'll take the vector of transactions, otherwise it should actually just give us zero transactions. So if it errors, like if it's junk or something, the way that we will process it is a list of empty transactions. All right? And then we do a flat map, which means that every iteration of this little closure is going to give us a list of transactions. And at the end of it all, we want to have a single list of transactions.
00:47:08.595 - 00:47:17.015, Speaker A: It sounds like this is something that just reduces the size of like, state here. Was that.
00:47:18.915 - 00:47:19.939, Speaker B: What do you mean?
00:47:20.107 - 00:47:24.187, Speaker A: I guess, like, what is the flat map helping with? Besides the.
00:47:24.291 - 00:47:41.075, Speaker B: Oh, the. The flat map something is. There we go. Um, so we have to implement this in a second. But the flat map takes. If you have like a list of lists of blobs, it turns into a list of blobs. Right.
00:47:41.075 - 00:47:49.179, Speaker B: Okay, so we. Our. Our little thing here turns one blob into a list of transactions.
00:47:49.347 - 00:47:50.147, Speaker A: Got it.
00:47:50.291 - 00:48:01.435, Speaker B: And if you didn't, if you just use map, then it would be a list of a list of transactions. And we just want a basic list of trend. Like it just like deletes those borders. Cool.
00:48:01.595 - 00:48:02.295, Speaker A: Nice.
00:48:03.355 - 00:48:38.915, Speaker B: All right, so once you have those transactions. Oh, I forgot to do something. And that is that we need to wrap this as well, because we're sending out cross threads in our commutex only one thread at a time should I have access to. And we need to keep track of how many copies we have. That's why we have the arc. So. And then the reason I thought of that now is because we need to lock the state so nobody can touch it while we're processing things.
00:48:38.915 - 00:49:16.241, Speaker B: And then we can do transactions that like, iterate over the transactions. And then for every single transaction we'll do, we have to. Is that correct already? Yeah. So for every transaction, we want to call state, process transaction. If it's okay, we don't need to do anything. I'm actually going to replace this with a little like, notification that we process the transaction. Otherwise it's just going to spit out an error and throw it away.
00:49:16.241 - 00:49:57.555, Speaker B: That's why I don't want to return a result here because we don't care if this errors. If it errors, it means it was junk and it wasn't valid. Right. And here we do the validation and then we have to implement this now. So what is this? This means that there is currently no implementation that lets us convert from a celestial blob into a batch. We're going to do that real quick. All that is there's a trait in REST called Try from and once you implement this trait, you can call that method.
00:49:57.555 - 00:50:33.467, Speaker B: We want to turn a blob into a batch. The type of error we're going to return is anyhow error. And the does that work? I need to first install cargo bin code is a way to serialize data. So you could use JSON, you could use bin code. I'm using bin code. JSON would work just as well. But like when you post it to the DA layer, it needs to be in bytes.
00:50:33.467 - 00:50:58.395, Speaker B: So you can't just like send a naked REST direct there. You have to convert it to bytes somehow. And that's what we're using bin code for. Later on, when we're posting to the DA layer, I'll show that we're actually using bin code serialize. But this implementation is actually not even correct. What we want to do is there are two cases here.
00:51:02.095 - 00:51:08.035, Speaker A: And I mean, it looks like when you're retrieving it, you need to deserialize it, obviously, right?
00:51:08.655 - 00:51:43.059, Speaker B: Yeah. So basically blob data, again, there are two cases here. Now one of them is that the transaction actually is a list of transactions. So in that case it is already a batch, which is a vector of transactions. So we don't need to do anything. So we'll return. Ok.
00:51:43.059 - 00:52:21.165, Speaker B: Ok, batch. And then if there's an error, we need to try to see if it's a single transaction. Because if it's not a list of transactions, it could be a single one. So then we just say let transaction. Then we try to deserialize again blob data from the blob data. And then if that. Does that work? Yeah.
00:52:21.165 - 00:52:33.935, Speaker B: So what I'm doing here. One more time. Sure, yeah.
00:52:42.315 - 00:52:43.403, Speaker A: And value data.
00:52:43.459 - 00:52:45.507, Speaker B: We need to add derive here.
00:52:45.651 - 00:52:52.859, Speaker A: Are you using blob derive? That should work.
00:52:52.947 - 00:53:25.825, Speaker B: All right, so again, one more time. What I'm doing here is we want to be able to convert from a celestial blob into a vector of transactions. First we try to see is it a vector of transactions. If it's successful, then we just return the vector of transactions. If it's unsuccessful. We try to deserialize it into a single transaction and then return a list, a batch containing a single transaction. And then this here makes a little more sense because we say, okay, well for every single blob, try to convert it into a batch.
00:53:25.825 - 00:54:05.835, Speaker B: If there's an error, then there's no transactions. But if there's at least one, then we get the vector of transactions and then flat map it into a simple list of transactions. And then we lock the state so nobody else can access it from another thread and then run process transaction on every single TX that comes in. Okay, cool. So this works. Except we don't need this. And then now we have Genesis syncing.
00:54:05.835 - 00:54:48.315, Speaker B: We have processing incoming celestial block. And here you see the base roll up part, which is your rollup state, gets derived from the L1 block. We receive the L1 block, which happens here. Right. Get all blobs from the L1 block. And then we process every single transaction. Now in the traditional roll up, since this maybe can't be seen as a roll up because there is no context or no analogy to a block, here you are just like, what is it called? Processing transactions as they come in from.
00:54:48.315 - 00:55:00.515, Speaker B: From Celestia. But you don't like, create a block every time that will be maybe in like the next iteration in the series. But anyways. Yeah, now we have something from Genesis.
00:55:01.775 - 00:55:06.095, Speaker A: Yep. What's next? No, I was gonna. I want to let you keep cooking.
00:55:06.795 - 00:55:54.135, Speaker B: Okay. There's one more thing. And then the rest of the code I will just copy and paste and explain because after this next step, we're actually done really, like, with all of the actually interesting parts of it. So sync incoming blocks. What this does is it's going to take another arc to yourself and then it's going to also return a result. But the error is a special type of area error from Tokyo called join error. All right, so what does this need to do? We already have sync from Genesis.
00:55:54.135 - 00:56:20.205, Speaker B: Now we need to subscribe to new celestial blocks. The way that we do that is by. Sorry, I'm thinking. I'm looking at my reference. We're going to have to modify this method in a minute to like.
00:56:22.745 - 00:56:27.655, Speaker A: Internet slowed down, it seems. Or mine did. Nope, that's on me.
00:56:28.755 - 00:56:29.695, Speaker B: We good?
00:56:30.915 - 00:56:31.387, Speaker A: Wow.
00:56:31.451 - 00:56:39.411, Speaker B: Wow. Are you. Are you there? You there?
00:56:39.563 - 00:56:41.907, Speaker A: Yeah, I'm here. I don't. I don't actually know where it is.
00:56:41.931 - 00:56:42.627, Speaker B: Okay.
00:56:42.811 - 00:56:43.895, Speaker A: Yeah, we're good.
00:56:44.915 - 00:57:00.917, Speaker B: Okay, so there's a cool method in the Celestia API called Blob Subscribe. And what it takes is namespace is a namespace and that's it. What are you complaining about? What can you.
00:57:00.981 - 00:57:06.357, Speaker A: Does that help you avoid concerning yourself with like all the other namespaces that have things on them?
00:57:06.421 - 00:57:36.865, Speaker B: Yeah, exactly. So anytime that there's a new celestial block, if there's data in your namespace, you're going to get it. And then we need to call await on it. And then this gives us a subscription to a struct called blobs height. And if I go here, it'll. It'll show what it is, is there's maybe some blobs, but you'll get for every height a response. And then if there are blobs in your namespace, they will be inside there.
00:57:36.865 - 00:58:20.695, Speaker B: So once we have blob sub, we just need a loop. That could be it. Hold on. I think it's that next. Yeah, it is. We first need to the. Oh, I see the problem.
00:58:20.695 - 00:59:28.629, Speaker B: This is like more like a result. So then we need to do pattern matching on the result where we say if the response from the server was ok, it gives us a blob response object which is that blobs and height structure just showed you. And then that's where we can do blob response, blobs dot unwrap. And then if there's an error, all we'll do is we'll like print an error to the console saying that we error. And so that's technically everything. Like this is your full roll up, but we are going to change a few things in here. The issue here is that these have to run next to each other.
00:59:28.629 - 01:00:09.395, Speaker B: Like this needs to start and then while this is running, you already need to start listening for incoming blocks. But the issue with that is that you don't want to process the blocks out of order, so you need some synchronization between them. So I'm just going to copy and paste, paste that code. So I'm going to open like the full, the full Greg chat and we can take a look now at what that looks like. But anyways, that's it. You did it. We made a roll up.
01:00:09.395 - 01:00:24.179, Speaker B: That's what, 200 lines of code. You have your chat application now. The parts that I'll be pasting in it will come to a total of 500 lines of code. It's not working for me.
01:00:24.267 - 01:00:27.235, Speaker A: What's the part that's missing? I guess you were kind of going into it.
01:00:27.355 - 01:00:47.501, Speaker B: Yeah, I'll show it, I'll show it. So basically everything's the same here. Like now I'm navigating through the full project. Yeah, so transactions are the same. State is also the same, except we have two other utility methods where I just like. It lets you read a channel and list the channels that exist.
01:00:47.653 - 01:00:50.645, Speaker A: Seems pretty one liners. Yeah. Yeah.
01:00:50.765 - 01:01:29.685, Speaker B: And then in full node, the difference is that inside of. Hold on, it looks like a lot more, but it's really not a lot of. It's the web server, I think from Genesis. Yeah, a lot of it's a web server, which I'll also go through. So I add to the full nudge direct two things. One of them is an atomic boolean, which is just saying, okay, is Genesis sync complete? And then there's also like a notification channel for syncing. I also added a list of pending transactions so that like batches will get posted.
01:01:29.685 - 01:02:07.485, Speaker B: So when I was talking about base routes at the beginning, I said that there are batchers that batch transactions. What that looks like is that when somebody queues a transaction, you just push it to the list. And then every now and again, you submit the batch as a blob to Celestia. I make a blob based off of the pending transactions I put into a batch. I serialize it with bin code, put it into a celestial blob, I submit that blob and then we get a log in the console that the batch is posted.
01:02:07.645 - 01:02:09.385, Speaker A: How often does that happen?
01:02:10.085 - 01:02:15.301, Speaker B: That happens every. I can find that for you right now.
01:02:15.493 - 01:02:16.309, Speaker A: I'm just curious.
01:02:16.397 - 01:02:53.175, Speaker B: Every batch interval second, which is every three seconds I have here. Every three seconds, if there is any transactions, I try to post it nice. And then it just calls this post pinning batch. So what I did end up changing is in sync from Genesis. You need to say when the Genesis sync is complete. That's why I store true in Genesis incomplete. And then you notify everybody that's waiting for the Genesis sync to be complete.
01:02:53.175 - 01:03:37.655, Speaker B: Then what happens down here is I like start a buffer for pending blocks because as I said before, you actually need to be processing incoming blocks while you're doing the Genesis sync. And that means that you need to store them to be applied right after the Genesis sync is complete. So I use this buffer to. When I get an incoming block, I store it in the buffer. And this buffer basically only gets emptied after Genesis sync is complete. But I start writing to it right away. So we subscribe just the same way as before.
01:03:37.655 - 01:04:05.281, Speaker B: We get the response same way as before. Except instead of calling process L1 block, I put it into this buffer. Then this gets started in the background. That's what the spawn is for. Minimize that. We wait for genesis sync to be done and then once it's done, we can process the blocks that are in the buffer. So that's what this loop is for.
01:04:05.281 - 01:04:59.553, Speaker B: It's saying while there are still like blobs in the buffer, keep processing them. And then starting sync is just a matter of like starting a thread that does the genesis sync, starting a thread that does the incoming sync, and then like waiting for them to finish. And then start does the like sync handle, which calls this the batch posting, which is the thing that happens every three seconds. And there's also the web server that runs in the background. So there's like three threads that are running in the background that are handling these different tasks. And that's what happens when you start the node. The web server I generated with AI it's super simple.
01:04:59.553 - 01:05:26.961, Speaker B: All it is is like we have a few methods. You can list channels, you can read channels listing channels, just calls list channels on the state. Reading channels does the same. And as you saw, those are one liners registering a user queues a transaction which could post it in that batch. Sending a message does the exact same thing. And then we have a main method. So this is like how you interact with the app.
01:05:26.961 - 01:05:28.769, Speaker B: There's a few commands, I guess like.
01:05:28.857 - 01:05:35.365, Speaker A: The web server basically just made it easier for us to interact with. Using the things you wrote on the stream. Yeah, nice.
01:05:36.545 - 01:05:41.803, Speaker B: It's not actually roll up code, but in total this is more like making.
01:05:41.979 - 01:05:46.015, Speaker A: This usable code rather than adding rollups.
01:05:47.195 - 01:06:30.481, Speaker B: Not only do we have a full base roll up and a few hundred lines of code, but we have a full base rollup and a web server to interact with it and the actual user interface to interact with the base roll up. The way that looks is that you can list the channels, you can read the channels, you can register a user, you can send a message, you can start a full node. Starting a full node just means it takes a start height like I defined before. You know that your roll up starts at a certain height. And then it also takes like hex, which can be your Celestia namespace. So where on Celestia you're posting it. And then there's also a method to print the usage.
01:06:30.481 - 01:06:54.745, Speaker B: Then the methods are really just like list all the channels, read all the channels, register user, which sends it to the web server that's running in the background. I think we're ready for the demo. I know that that was rushing through those final parts of it, but all the code is on my GitHub. We'll link it. Josh, that's on you.
01:06:55.605 - 01:06:58.089, Speaker A: If you want to check this out, you can do that.
01:06:58.217 - 01:07:14.169, Speaker B: QR code. Yeah, you can check it out there. If you have any questions, you can always write me. I have the same username on Telegram, on GitHub, on Twitter, but I think we can dive into doing that. Did you send me tokens so that I can run my.
01:07:14.337 - 01:07:20.605, Speaker A: Yeah, I did, I guess. Okay, we can go ahead and get started. What are we going to do to get started, though?
01:07:23.115 - 01:07:24.175, Speaker B: What do you mean?
01:07:24.515 - 01:07:27.419, Speaker A: Oh, I don't know. What's the first thing we need to do? Start a node.
01:07:27.547 - 01:07:35.539, Speaker B: All right. We just need to, like, start our full nodes. So the way that I will do that is like, I have a celestial node running in the background.
01:07:35.627 - 01:07:49.785, Speaker A: Cool. I'm going to start that as well. And then I guess if you manage to, like, follow along before we, like. As we get this going, you're going to want to run your light node with rpc. Skip dash off.
01:07:50.445 - 01:08:07.397, Speaker B: Yeah, I'll show the commands that I'm running the light node with. Celeste. Yeah. So I don't know. Can I paste this somewhere? Yeah, I can paste it to you in the private chat.
01:08:07.581 - 01:08:13.585, Speaker A: I'll just send mine in the chat, actually, because I don't need that header command anyway. If you're following along. Yeah.
01:08:15.895 - 01:08:22.595, Speaker B: Anyways, that's the command I'm using. We need to know what our start height is. So I'm going to do header.
01:08:25.895 - 01:08:26.955, Speaker A: Network head.
01:08:28.015 - 01:08:58.151, Speaker B: Yeah, I'm being lazy. Hold on. So this tells us what the latest head is. And then using that, I can start my grug full node. So what namespace are we doing it on?
01:08:58.303 - 01:09:00.235, Speaker A: Let's do the GRG chat namespace.
01:09:01.375 - 01:09:03.835, Speaker B: Which one is that? Is that 477?
01:09:04.335 - 01:09:06.195, Speaker A: Yeah, it's just a little bit different.
01:09:06.545 - 01:09:08.945, Speaker B: Ending in 1 74. Yeah.
01:09:08.985 - 01:09:12.885, Speaker A: And then we're using a start height of 90, ending in 90.
01:09:13.825 - 01:09:23.745, Speaker B: Yep, sounds good. All right, I'm going to start my full node and then I'm going to start sending transactions.
01:09:23.785 - 01:09:28.161, Speaker A: That's good news, right? It just says server listening. That means it's running. It's working nice.
01:09:28.233 - 01:09:48.468, Speaker B: It means it's running. So I'm going to register a user again. The public key is not really a public key. It's just like random hex bytes. So I can put whatever I want in here. I just did ABAB42 and my username is Ryan. The user registration request, since successfully.
01:09:48.468 - 01:10:19.335, Speaker B: So now I'm pointing out my screen, but you can't see that Sorry, I just sent one. Yeah. On the left hand of the screen you'll see that a batch got posted with transaction. We should also see that the transaction gets processed when the next block comes in. If it's working correctly. Yeah, sure. Oh, if mocha is working correctly.
01:10:19.335 - 01:10:22.547, Speaker B: Did you. You got them?
01:10:22.651 - 01:10:34.235, Speaker A: Yeah. So I'm getting. I'm seeing it was processed with one transaction. That's from my batch. And then I think we're processing both Ryan's registration and my registration.
01:10:34.615 - 01:10:38.195, Speaker B: Yeah. And then I'm going to send a message into general.
01:10:42.695 - 01:10:51.275, Speaker A: And then I guess while we're here, the different methods that you can play around with will list channels first.
01:10:53.145 - 01:10:54.465, Speaker B: Well, I haven't sent one yet.
01:10:54.545 - 01:10:57.565, Speaker A: We don't have any yet. So that's why there's nothing showing.
01:10:58.505 - 01:11:03.033, Speaker B: But I just sent a message, so hopefully you'll see. Can you go back to your.
01:11:03.169 - 01:11:11.245, Speaker A: Yeah. So right now there's a channel that should be there after. Okay. We process that new transaction. So we have channels now.
01:11:11.665 - 01:11:20.751, Speaker B: And this is on Josh's computer, of course. So we are interacting with each other via Greg Chat without actually, this is.
01:11:20.783 - 01:11:25.703, Speaker A: Copied from GregBrain.dev if you're curious and you want to learn more about how.
01:11:25.719 - 01:11:28.875, Speaker B: To design software, how to. Actually right.
01:11:31.975 - 01:11:39.275, Speaker A: Now we need to read channel and we're going to see our messages show up.
01:11:39.575 - 01:11:41.631, Speaker B: Hell yeah. So that's it.
01:11:41.783 - 01:11:42.515, Speaker A: Dang.
01:11:45.985 - 01:12:15.827, Speaker B: So, and this is really easily extensible. Like one thing that you can do is add authentication. That's really easy because all you have to do is add the signature to the transaction types and then inside validate transaction, make sure that the public key matches the signature. There are also like tons of other great ideas for making some base roll ups. Like I think Josh and I are going to hack on a Celestia listening room hopefully soon.
01:12:16.011 - 01:12:17.575, Speaker A: Yeah. What's the point?
01:12:18.995 - 01:12:29.043, Speaker B: Well, you like, you can post songs in there and then everybody has to listen to whatever you put on. It's like a radio room.
01:12:29.099 - 01:12:31.731, Speaker A: Oh, so we're making a jukebox. I didn't even think we got.
01:12:31.763 - 01:12:33.075, Speaker B: Yeah. And it's going on main net.
01:12:33.155 - 01:12:34.415, Speaker A: All right, let's get it.
01:12:34.715 - 01:13:07.039, Speaker B: It's a main Net jukebox. Celestia Jukebox. And yeah, I don't see. My thing is, I don't know why I should use a roll up framework. It seems like the apps that I want to build require like minimal boilerplate. And the thing is when it's this minimal, you're in complete control over the full stack. Like you're not Relying on thousands of lines of code from somebody else to go wrong and for them to handle the bugs.
01:13:07.039 - 01:13:25.243, Speaker B: But you have everything and it's not a lot of code. Not much can go wrong. So I like to keep it as simple as possible. Base rollups allow you to do that, allow you to do it in a trust minimized way on top of Celestia. And that's why they're so exciting to me and why we made Prism as a base roll up.
01:13:25.419 - 01:13:48.447, Speaker A: Really cool. I wish we could have, I guess for people watching, Ryan and I practiced this already and I think my excitement might have shown a little bit more then. But I just want to say I think this is really cool. Really. Thank you for showing us how easy it is to build something that doesn't rely on tens of thousands of lines of code.
01:13:48.631 - 01:14:18.531, Speaker B: Yeah, I mean, if you share my screen again, we can look at the full list of dependencies are horrendous. What do we have here? We have a web server. We have something to serialize to bytes. We have Celestia stuff, serialization again, something for Async Rust, some error stuff, another web server stuff, more serialization, More serialization. Like there's nothing here. What can go wrong?
01:14:18.643 - 01:14:34.257, Speaker A: This seemed like very standard. Well, yeah, like, knock on wood. But this seemed like really standard. Like standard things that you would kind of like use in many Rust projects. It's not like, yeah, I don't know, the weirder dependencies that you find in a lot of rollup SDK case.
01:14:34.441 - 01:14:57.377, Speaker B: Right, right, right. Like, nice. I pretty much all Rust projects I see have these steps, to be honest. So maybe minus the Celestia stuff and the web server stuff, but the rest are pretty much like, get added to all projects anyways. But yeah, thanks for tuning in. If. If you're still around, I don't know how many people are still on.
01:14:57.377 - 01:14:58.641, Speaker B: It could be one person, could be.
01:14:58.673 - 01:15:05.975, Speaker A: Two, you know, but actually wild, it says there's like 2400 people that are watching on X basically.
01:15:06.055 - 01:15:06.675, Speaker B: Really?
01:15:07.415 - 01:15:27.675, Speaker A: So I don't know how real those numbers are, but it's pretty cool that. Thank you for tuning in. If you're watching, I wanted to let you, like, save some time, I guess. I know we're already over, but if you have any closing, like thoughts like, what do you think people should take away from this? What do you want to see built?
01:15:32.025 - 01:16:07.889, Speaker B: I think what people should take away from this is that it's finally time in our ecosystem. And by ecosystem, I don't mean Celestia. I mean like what we're actually working towards with crypto to make applications that people use. And this is by far the easiest way to ship decentralized applications. And it's super easy to do. It's never been easier. You can make whatever you're dreaming of.
01:16:07.889 - 01:16:39.147, Speaker B: And you know, Celestia has this tagline of build whatever, which to me is a little too like, nonchalant. Yeah. But what it enables is like finally what we've been waiting for for over a decade. And on the surface what we just built is a chat app, right?
01:16:39.251 - 01:16:39.515, Speaker A: Yeah.
01:16:39.555 - 01:17:07.665, Speaker B: But in reality, like what it actually means is that you and I are able to interact with each other via whatever. Right. Without relying on some server. We're running our own Celestia node. Soon that will happen in the browser. Like you'll go to a website and your browser will be interacting with the Celestia blockchain.
01:17:09.645 - 01:17:13.555, Speaker A: So that's one piece. But I'm running on my own. No one else is controlling me.
01:17:13.635 - 01:17:37.095, Speaker B: Doing. Yeah. And then that's why I was so like, why I fell in love with Ethereum and Ethereum wasn't able to meet those demands. It has other trade offs that are very important. I still love Ethereum, same big Ethereum fan. But this is the next like paradigm shift and please build something.
01:17:37.835 - 01:18:11.737, Speaker A: And yeah, I guess like the, the only other thing you're doing is running the grgchat full node, which is also something that you're choosing to run. No one can change that. But like, yeah, I guess if you were to like package this up into something with like, I don't know, privacy and stuff like that, it seems like this could be a like truly unstoppable application that could. Yeah, I mean, like, okay, I'm trying to like, you know, it sounds like you could add Prism to this, right?
01:18:11.851 - 01:18:21.509, Speaker B: No, what I want to, what I want to say is that you can make a private roll up out of this really easily. All you have to do is make the messages encrypted. Right?
01:18:21.557 - 01:18:21.989, Speaker A: That's it.
01:18:22.037 - 01:18:36.157, Speaker B: Yeah, easy. And then you need a way to authenticate other users public keys than use Prism. But like you can make private roll ups, private base roll ups on Celestia super easily. Minimal overhead. Go do it.
01:18:36.301 - 01:18:36.725, Speaker A: Nice.
01:18:36.805 - 01:18:37.981, Speaker B: I wish I had more time.
01:18:38.093 - 01:18:57.665, Speaker A: That's what. Yeah, that's what I was looking for. Looking forward to see what you build. I want to thank everyone again for coming. Thank you, Ryan, for joining. I had a great time learning from you and look forward to doing something a little bit more. I don't know, I'm looking forward to seeing what the next evolution is of this, because I didn't realize that was going to be so simple.
01:18:57.665 - 01:18:59.981, Speaker A: But yeah, on that note.
01:19:00.053 - 01:19:01.885, Speaker B: Well, it'll be for the next podcast.
01:19:02.045 - 01:19:14.315, Speaker A: Yeah, we'll go ahead and sign off here, but have a good rest of your day. Good evening and thank you again for joining Lazy Day. Yes, stay lazy. Drop an L for Lazy Ledger as we close the chat.
