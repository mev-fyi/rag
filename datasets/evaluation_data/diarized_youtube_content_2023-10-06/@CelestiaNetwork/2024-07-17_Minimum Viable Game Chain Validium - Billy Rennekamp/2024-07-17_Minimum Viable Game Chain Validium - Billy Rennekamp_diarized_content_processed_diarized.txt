00:00:01.880 - 00:00:20.998, Speaker A: So my name is Billy. My talk is minimum viable game chain validium. Basically, it's about making games fast. I think we've had a few talks today about the problems in blockchains. I will reiterate some of those problems and talk about another way to solve it. Quickly, though first, a little about myself. I'm the founder of a new company called Trifolabs.
00:00:20.998 - 00:01:03.486, Speaker A: Recently I was an entrepreneur in resident at one KX spun triflabs out of there. Prior to that, I was helping run the Cosmos network at the interchain foundation. In parallel, I've had a NFT gallery called Folia app for on chain nfts. And I got into the space back in 2017 with an on chain game called Clover's Network early NFT and AMM project. So the first sort of thing I want to begin with is why on chain? Why on chain at all? We've heard that there's problems with it. We know it's hard, but what's the point of going through all these efforts? I like to think that all of the reasons sort of are based on this idea of persistence. We all know the origin story of Ethereum.
00:01:03.486 - 00:01:40.400, Speaker A: Blizzard nerfed one of the settings on an item, and Vitalik was so upset he cried himself to sleep and decided that he would never play a game that didn't have persistent game state, something that he could rely on that wouldn't be rugged away from him. And so he invented Ethereum. Here we are today. But this idea of persistence is really all over in blockchain. And I think we can all agree that there's like various degrees of how believably persistent something is. I think what's really important, though, is that as long as there's a credible threat of persistence, you're able to sort of hang your hat on. Then you're able to build with the idea that persistence is there and build things that actually expect persistence.
00:01:40.400 - 00:02:10.728, Speaker A: Once you have that, you're able to get a lot of other really interesting features. First one is community ownership. So of course we have the freedom of speech, painting by Noram Rockwell, and the idea that the people who care most about this game should be involved in the decisions about what happens to this game. They are the ones who are most invested in it. And of course, having things on chain built in a persistent way allows all sorts of avenues for community ownership to occur. Of course, this can be a double edged sword. You know, you have the tyranny of the masses.
00:02:10.728 - 00:02:53.040, Speaker A: You don't want to prematurely decentralize give away the most important decisions to people who are not yet fully integrated into a system, or maybe not fully qualified to make those decisions. And so this is always going to be a balancing act. The next one is composability. We all know the phrase of money blocks, building blocks, legos. Basically, it's the idea that if you assume the system underlying is persistent, you can rely on it to build your own business, build your own applications, build your own products, whatever it is on top of it, you can interface with it in a reliable way. And that's what's really necessary for composability. Someone may build a game, but there might be a metagame which can take place on top because they can rely on that underlying game persisting.
00:02:53.040 - 00:03:34.672, Speaker A: Of course, composability really does also open up some other attack vectors. Here I have pictures from Robot Wars, a popular tv show in which people build robots to kill each other. Really what you're doing is making your game fully accessible to what are possibly your worst users, the people who build bots or the bots themselves. Unless you fully go in that direction and you make a game which is meant for bots like bot wars, you're at risk of having the actual thing that people are there to do, to have fun and compete at sort of an even playing level disrupted. And so composability is a double edged sword too. The final one, I like to point out, is value as a primitive. And I think that this applies to all blockchain applications in general.
00:03:34.672 - 00:04:25.956, Speaker A: It's basically just an improvement in the efficiency in the programming language. We've had money represented in software for a long time, but only with blockchains, where the money itself is a primitive in the programming language, are we able to sort of collapse that distinction. You know, never before were you able to have basically a flash loan, because in the meat space you're never sure if that sort of instant loan will be enforced. At the end of the day, you know, we rely on a lot of meat space institutions to make sure that software representing money is treated like money. But if you can remove that, there's a lot of really interesting new things which become possible. Of course, value as a primitive, what kind of applications really benefit from that? It's mostly gambling games, and I'd like to say that porn is to the Internet as gambling is to blockchains. It is maybe some sort of a necessary evil.
00:04:25.956 - 00:05:07.550, Speaker A: It is good, it is bad. It is here to stay in various capacities. But I would also like to point out that gambling is one of the only truly equitable ways to allow players and bots to coexist inside of a game. Here's an example of backgammon, long ancient standing game, well loved all over the world, that has an element of chance involved. You roll dice inside of it. Because of that, the world's worst backgammon player still has a chance of beating the world's best backgammon player. As you can see here, this superbot still could be beat because there's always this chance element and that destabilizes things in a way which is actually really equitable.
00:05:07.550 - 00:06:00.660, Speaker A: Of course, this can be scaled to full randomness, which is fully equitable and is basically a random number generator slot machine, which maybe you lose out on other elements of fun somewhere in the middle backgammon and somewhere on the far right would be fully skill based, in which if you go toe to toe with a bot, you're dead. Also worth mentioning quickly, this term, autonomous worlds, I think it's used a lot. I think the ideas in autonomous world have actually been around for a long time. They have a new sort of branding, which I really like, autonomous worlds, but it's basically just this idea that's really exciting. When you build something that has the possibility of being bigger than yourself, it can live on beyond you or any individual or any company. It can occupy a space that persists, possibly forever. Something that's large enough, interesting enough that others might want to occupy it, live inside, build other things that it can sort of extend and grow.
00:06:00.660 - 00:06:44.990, Speaker A: It's a really vibrant idea, but it's of course been around since the beginning. I think what autonomous world's really about is just a flag to get under, which is a recommitment to stop making bad games. We've had games since the very beginning of the day's blockchain. But if you look around, we can sort of admit they're almost all bad. And I think for various reasons, we do have very legitimate reasons that they're still bad. UX is hard managing private keys, gas on ramps and off ramps, but I think there's even a worse reason, which is that we've encouraged the creation of bad users. There's this idea that players and farmers exist as the same thing, but really farmer speculators are not necessarily players.
00:06:44.990 - 00:07:30.884, Speaker A: The core definition of a player is attached to the definition of play, which I think really points to intrinsic value in the experience rather than extrinsic value. As soon as you have the possibility of incentives, extrinsic value becomes the motivator and you're no longer really playing the game to have a good time, to have intrinsic value. You're playing it to make money, which there's a lot of really interesting applications that look very similar to games, or I would even still call them games that reward extrinsic value. And I think that's great. It's just you kind of leave behind the possibility of the game also being fun. And I think that we don't really need to give that up. The other problem is that the core loop is always coming soon, because we've sort of compromised the purpose of these games.
00:07:30.884 - 00:08:27.742, Speaker A: Often you need to make something that looks and smells like a game, so you can justify the money that you raise for it, so you can justify to the users who play it in order to validate the game, because they now are invested in it. You create this whole sort of zombie cycle of people who are walking and acting like they're playing games as part of a company, but really all they're doing is trying to produce games that continue to signal the fact that they're games to justify the infinite speculative loop. But again, we do have very real reasons that games are not great. And there's plenty of people who actually are nothing succumbing to these bad user pitfalls they are building to make games that are fun, but they're still restricted by very real problems, mostly around limited computation, expressivity, and limitations on speed. So let's talk about speed and complexity. The people who are still trying to make fun games are basically restricted to grid based movement games. All the games you'll see today are essentially digital representations of board games.
00:08:27.742 - 00:09:02.250, Speaker A: Things that don't really need more than one update state function per 5 seconds, 1 minute, whatever it is. And there's a lot of really fun games out there. I mean, love board games, don't get me wrong. Love retro games. You know, it's just insane that we have to be restricted to this extremely small subset of games inside of an industry that's trying to push the envelope forward. So I'm arguing for even just the smallest phase chain to the right of the screen, which is Super Mario. Also a quite simplistic game when you look at the sort of progression of technology in games, but a huge phase shift in expressivity from a completely grid based game.
00:09:02.250 - 00:09:35.858, Speaker A: So two of the ways that I think people are coming about it can be categorized with one of the solutions and one of those categories, which is mud by lattice. It's a solidity framework. They're basically saying, let's just increase the complexity that's possible to build with solidity, gas be damned. It's going to keep running down. Anything that you need, you can just build it in solidity. Eventually you'll be able to execute it, but they're still limited by block time. So l two s, you know, they still have two second block production times that we see now.
00:09:35.858 - 00:10:20.112, Speaker A: And I think it's going to be really difficult to get around that. If you saw the Argus talk, too, there's just so many steps in the process that add more and more latency, and it's really difficult to make a fun game that has that much delayed. So the category that I'd like to argue for today are called validium games. And there's kind of two ways of going about it. One is using zkvms, and zkvms are great because it means that you can write your game in logic that actually looks and acts like code, or maybe like actual code in a language you're already familiar with. But the problem is that when you do this, you are actually proving that the code is executed correctly at the virtual machine level. You're making a proof that the virtual machine executes it, and that has way more instructions and way more circuits.
00:10:20.112 - 00:11:09.766, Speaker A: The proof size is way larger, and it takes way longer to generate it, and so it's a very slow user experience if you're trying to create a proof for a game that was played. The other route is when you do handwritten circuits. And I've chosen Sircom as the kind of favorite solution for writing handwritten circuits. It's hard, but it's fair because it leaves you with a very minimalist circuit that you can actually prove in the browser in under a minute or less, so that you can preserve a user's expectations on latency. So all of this sort of goes to this motto of play first and verify after. These are validium games or Zkrollup games, and if you're not familiar with what Zksnark generally looks like, here's the flow. ZK synarcs have public inputs, and they have private inputs as denoted.
00:11:09.766 - 00:11:34.828, Speaker A: Public ones are public, private ones are private. In this game scenario, the public input would most likely be the initial game state. So that comes in and everyone can see, yes, I'm starting the game the same way everybody starts it. This is fair. The private inputs, I like to refer to them sort of as key loggers. It's basically all of the keystrokes, all of the button presses, anything that a user would do in the duration of playing. That game are made into private inputs.
00:11:34.828 - 00:12:21.114, Speaker A: These are run through the snark, which actually contains all of the game logic you need put into a loop, whatever sort of necessary logic is there. What's really nice about making the private the user inputs private is that it means whenever you play a game, you don't necessarily leak your secret sauce the way that you beat the game. Other players can't copy it that way. I'd like to give an example of this artwork by Radical Software group from the two thousands. They hooked a keylogger up to Nintendo Entertainment System controller and they beat the entire game of Super Mario Bros. They recorded every single keystroke that went into the duration of playing and beating this entire game and saved it. And then they printed it to a hardcover book in the form of guitar tabulature.
00:12:21.114 - 00:13:11.120, Speaker A: Theoretically, you could reproduce every single keystroke at home while reading this book without looking at the screen. And at the end of the game, you will have completely beat Super Mario Bros. Because that game is deterministic. So as long as the game that you're writing is deterministic and completely modeled in your circuit, it can be modeled again in any game engine that you want. You can allow your players to play it where they would expect, with whatever features they would expect in that environment. As long as the user keystrokes or button presses can be replayed later inside of a snark. Then afterwards you have a public output that's of course saying the level is cleared, the boss is beat, the score is high, the time is fast, and a fraud proof which says there's no other way this person could have gotten these numbers unless they actually played this game and beat it with this score.
00:13:11.120 - 00:14:05.962, Speaker A: Those get submitted on chain and you're able to sort of claim, yes, this is my score. I beat the game. The game has a state up chain function on chain, just to mention quickly circum as my go to language for the solution. I think it's the right balance between the math that actually represents what's going on inside of a circuit, which are polynomial expressions and things that look and act like code that allow you to build these things efficiently. It's also the most sort of widely supported and used in production project that is targeting evms, so it makes it faster and cheaper than zkvms. And of course blockchain devs love to suffer. So why not create an entirely new new weird abstract way of thinking about writing code? But you might ask yourself, don't all of these only lead to single player games? And aren't single player games.
00:14:05.962 - 00:14:35.748, Speaker A: Super lonely and sad. Well, we all know the experience of being alone together, and it's really not that bad. In fact, World of Warcraft, which you might think of as one of the most popular PvP games out there, is not actually PvP. Sure it literally is. But the majority of the players who play this massively multiplayer online game are playing in single player mode. Apparently 90% of them are just playing as a single player. But you still have community, you still have high scores, you still have a great game.
00:14:35.748 - 00:15:08.846, Speaker A: One player games can be multiplayer in a lot of different ways. Just as an aside, there is some interesting techniques that could make this whole thing multiplayer. Eventually, when you start signing everybody else's gameplay, you look something like a state channel. Some of the other talks today are some of the solutions for this. But if you want to chat about this possibility afterwards, come and find me speedruns. All of these single player games can be made multiplayer simply by making them into speedruns. And as we've seen, the popularity of speedrun culture has exploded over the last years.
00:15:08.846 - 00:15:55.022, Speaker A: Mostly you think of video game speedruns, but of course you can do a speedrun on anything. This is somebody, I think, young kid who has the first person to build the entire crankdat song inside of audio software in under 17 seconds. If you want to listen to crankdat over and over again and be exhilarated, please search crankdat speedruns. The other really nice feature about this whole system is that speedruns have a problem that this solves. Regardless of the fact that these are on blockchains, speedruns always have this problem of verifying whether the speedrun is actually authentic. If you've ever seen the movie king of Fistful of quarters, it's one of the most exciting sports narrative movies I've ever seen. But it's a documentary on people who play retro gamings competitively.
00:15:55.022 - 00:16:26.020, Speaker A: It focuses on Donkey Kong, and it has one of the most villainous villains who's maybe cheating to take out the really sweet guy who's trying to break the record after years and years and years swear he's cheating. And the whole movie, you're just like, blood is boiling. So these are pictures from recently. Somebody broke an important speedrun in Minecraft, and then they were found out to being cheats. So these were all the sort of memes I was able to collect of people just freaking out. Of course it's legit, of course it's real. But if you have your entire game modeled in a ZK snark.
00:16:26.020 - 00:17:20.336, Speaker A: There's no way that you can deny that this play is valid. You have cryptographic proof that this is a real playthrough of the game. So that's what we're working on now at Trifle. This is a new game company that I'm just starting. We're taking our first game, modeled after the history of games, with something like an extension of asteroid. We began thinking about the three body problem as an interesting problem when it came to putting physics on chain. Could we put the gravitational calculations of bodies interacting in space, that chaotic problem that the tv show and the book is named after, on chain? So the first circuit came with requirements that would make sure this is playable and easy by players, and that was to not be beholden to any other blockchain, to not be beholden to any other framework, to not be beholden to any other prover network.
00:17:20.336 - 00:17:51.916, Speaker A: We wanted to make sure that the users in their own browsers could generate their own proofs and submit them to an EVM chain. And that meant that we had to keep the number of constraints under 1 million. It also means that the prover file had to be under a gigabyte so that browsers could load it. And we wanted people to be able to do it in under a minute of proving. With those restrictions, we were able to run the simulation for 20 seconds at 25 frames per second. Then we realized that actually, these things, if you put targets on them, they become really fun to shoot at. And so we added the extra complications of shooting at them.
00:17:51.916 - 00:18:29.020, Speaker A: Of course, we could only run it at 26 seconds, at 25 frames per second at that point. And then we took it all the way to. Anybody problem? Anybody problem is now a daily game where there's five levels a day. It's a little bit like wordle. Every day, you progressively shoot more and more of these baddies out of the sky so that your hero body doesn't die and it runs at 25 frames per second. The visuals are actually at 50 frames per second, but that means that there's a maximum of 1500 steps per level, which means that while you're in the browser, you can make your proofs between 10 seconds and 1 minute, depending on how fast you beat the game. And all of these are batched into a single transaction.
00:18:29.020 - 00:18:42.968, Speaker A: We're still in stealth mode, but we're coming soon to an EVM near you. In August, it's trifle labs again. Trifle life. Trifolife is my Twitter handle. Shameless shills. I'm Billy Renekamp. If you're interested in a playtest, dm me on Twitter.
00:18:42.968 - 00:18:43.720, Speaker A: Thanks very much.
