00:00:01.880 - 00:00:43.998, Speaker A: All right, so this is an impromptu talk. I found out that I was going to do this very recently, so please bear with me. The idea is to talk a little bit about the user journey user, in this case meaning developer, and specifically when choosing the execution layer that's going to host their dapp. So I'm going to explore a little bit about the design trade offs on execution layers. So the point of this talk is to convince you of two things. First one is that execution layers have a very big design space, and that is a shame to explore app change, for instance, without also exploring the design space of execution environments. And the second thing is that execution environments are very context dependent.
00:00:43.998 - 00:01:12.202, Speaker A: So it depends on what kind of app you want to build, what kind of application, what kind of user experience, and so on. A little bit about myself. I'm this guy, I'm a co founder, and I led the first roll ups implementation at Cartesi. I'm brazilian, but I'm very bad at soccer, and I'm also very bad at designing slideshows. I'm always down to chat. I like to talk a lot, so please reach out. I have a forecaster and an x account, and there's a link to the Cartesi development community.
00:01:12.202 - 00:01:31.402, Speaker A: It's kind of fun because we do every development and research in public, so you can see all the conversations live. Quite interesting. There's a lot to learn there. So let's start. So this is the modular summit. So I guess I'll skip a little bit of slide. But that's the common accepted view of the modular stack.
00:01:31.402 - 00:02:16.286, Speaker A: So have execution, settlement, consensus, data availability, and also a meme layer down there. That's very important. The definitions change. Often there's a bunch of new modular layers being added basically every day, added and subtracted. So at first sight, the execution layer looks very simple, right? It's just got an input, you execute on it and have an output, right? Usually you have the state, you add an input and you get a new state, and the outputs can be embedded on that state. So it's quite simple. The problem that you have is that the execution layer has interplay with a lot of other layers, right? So this is a good example to show the interplay between computation, computational capacity, and data availability capacity is what we call the cone of innovation.
00:02:16.286 - 00:03:31.860, Speaker A: And it's just an intuition. It's not to be taken as gospel, but it's the idea that as the computational capacity grows and the data availability capacity grows, you have an extended design space for applications, right? So if you take like, let's say Ethereum L1, which you have limited without EIP 4844, you have limited data and you have limited computation. So there's only so much that you can do as an application developer. Once you start to go to, say, EVM rollups, you start to increase the computational capacity and you start to be able to do way more than just in a sense, gentrified DeFi, and then have app chain roll ups, which is a trade off between interoperability and computational capacity. And then you start to be able to do much more fun things as well. Here we have areas without any application, and that's to show the intuition that it doesn't really matter if you expand one of the axes a lot without touching on the other one, right? In other words, if you have 10gb of data availability, but you have the computational capacity of one calculator, then there's not really much you can do with that. So that's why you have some errors without applications.
00:03:31.860 - 00:04:29.992, Speaker A: All right, so what should you consider about your execution environment when you are thinking about developing an app? And just as a quick reminder, the Dapp lives in the execution environment. So in a sense, the developer's final experience is the execution environment. So that's why it's very important to choose it well. So the first thing is a little bit obvious. It's the kind of dapp that you want to build. So what kind of dapp are you optimizing for? Are you trying to do defi? Are you doing games, social fi governance and so on? How intense, how much computation will your Dapp need? Is it a super simple dapp, or are you trying to build something complex with a lot of computation? Right. So what's the preferred programming language? Are you okay with coding solid chiral? Do you want to use python, rust, or any other language? You see, there's a long list of things that you need to consider before locking yourself into an execution environment.
00:04:29.992 - 00:05:34.750, Speaker A: So for instance, you have developer resources. What resources will you want to use when coding your dapps? Do you need a file system, or are you ok with just storage and code data? Do you have latency tolerance? Do you need instant composability, instant interoperability? Or are you ok with having latency outside your dapp domain? So if you're say, interacting with uniswap, you probably need instant composability. If you're ERC 20, you need instant composability. If you are an order book exchange, then very likely you don't really need instant composability. You can deal with asynchronicity a little bit more. Is your app shared or isolated? Is your execution environment supporting a single dapp, or is it supporting multiple dapps at the same time? So if you think about Ethereum, Ethereum and AVM was built to support multiple dapps at the same time, and it takes the trade offs necessary for that to happen. That's why when we talk about vms, there's some people that criticize EVM a lot, and I'm not on that camp because I do believe that EVM is quite useful for a lot of things.
00:05:34.750 - 00:06:32.610, Speaker A: All right? So please don't get bored. There's a proving system. Are all the choices that you made regarding your execution environment, are they going to catch up to you when you try to prove it to the base layer? Right, because it's very easy to promise a very incredible execution environment, and then you'll find out that it's very hard to prove. Right? What's the financial model? For instance, if you have a shared layer like an EVM roll up, then your application doesn't need necessarily to sustain itself because you can just launch it and it's going to live on that layer forever. You don't need to constantly pay the upkeep price of the infrastructure. And app change, on the other hand, has to justify itself financially, because if you have a launch an app chain and no one is using that, then who is running the nodes? Who is paying to run the nodes? How important is privacy? They need privacy for inputs or just for state. So it's a last one, but it ends in an infinite list.
00:06:32.610 - 00:07:36.998, Speaker A: So what kind of inputs is your application expecting? What kind of outputs will you bring? Like what kind of messages are you going to send to the other applications? And so on, so on and so on. So you can see it's a lot of, it's a massive design space for execution layers and a lot of decisions that the dev developer need to make before logging into one. I think a very good way to split the design space in the first look is to think about shared roll ups and app chain roll ups, right? So have this idea of shared roll ups which have machines, extreme environments that were planned to support shared rollups. So the AVM is an example of that, the Solana VM as well as Socknet and so on. And these are execution environments that are planned to host many dapps at the same time. And if you want to do that, then you have to be very careful of things, right? Because first of all, if anyone can deploy a DApP, then someone can deploy malicious DApP to attack your execution environment, right? To attack other dapps. So memory safety is a problem.
00:07:36.998 - 00:08:22.868, Speaker A: Metering, adversarial metering is a problem, right? And you see that in Ethereum all the time. They have to be very conservative of gas costs, because anyone can launch an application that takes advantage of some mispriced gas to attack the entire layer. On the other hand, you have app chain roll ups, which are way less composable than shared roll ups. They have a worse interoperability. But. But they do have the advantage of being a safer environment for your application, because your application is not really attackable by other applications, at least not directly. So you can take more design trade offs regarding metering gas and even decentralization, computational scalability and so on.
00:08:22.868 - 00:09:17.374, Speaker A: So, cart, as you are at this side of the spectrum, you have like Solana, this is not a complete graph course, but yeah, and you have some projects in the middle who are trying to cater for both shared roll ups and appchain roll ups. But this separation usually is very good at defining the kind of trade offs that you're going to get. So, just going over real quick about the design choices that we made at Cartesi, just to give an example of what I'm talking about. Cartesi is an execution environment with a risc fiber architecture as a Linux runtime, and it's optimized for app change. It would be insane to run this as a shared layer, simply because the computational scalability wouldn't be there. It's too expensive for you to host multiple applications at the same time. So we optimized for computational power, which means that we had to sacrifice instant interoperability.
00:09:17.374 - 00:10:01.050, Speaker A: For instance, we optimized for fairly complex applications, and therefore we need an extreme environment that can support complex tooling, because you can only build complex applications if you have complex tooling, at least safely. And you. Oh, these slides are a bit outdated. But one the trickiest parts of building Cartesi is building the fraud proof system. As you can see, you have to prove a very big computational power application that has complex tooling on a semi complex machine, which is Rix five, which is not really complex, but it is complex compared to the EVM. So that's it. Thank you guys.
00:10:01.050 - 00:10:02.470, Speaker A: And any questions? I'm around.
