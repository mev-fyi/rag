00:00:01.520 - 00:00:43.282, Speaker A: Hi everyone, I'm Nitya. I'm going to talk about on and off chain approaches to chain abstraction. So I'll start with a little bit about myself. So my name is Nitya. I'm the founder of a company called Capsule. We build cross app embedded wallet infrastructure, basically make it easy to onboard users, and then have them continue to interoperably interact with many different apps across the crypto ecosystem. And so my background, I started my career in fintech as an engineer, then worked on layer one, Celo, and then was really focused on stablecoin payments and mass adoption, like stablecoin based banking.
00:00:43.282 - 00:01:37.370, Speaker A: And that was really what brought me to this space where with Celo or with capsule, what we are really focused on is thinking about how can you give applications control over the user experience and the parts of the user experience around crypto, giving them the maximum control. Maybe there's an application that doesn't want users to know that there is crypto that even exists. Back to the previous talk in HTTPs, that maybe crypto is just a different place to store certain data. There might be other applications that are all the way on the other side of it. Crypto is front and center, and maybe tokens are the core kind of action. Like trading tokens is something that people spend most of their engagement in the application doing. So we think a lot about this spectrum of you might have fully crypto forward, let's put it, as well as crypto in the background.
00:01:37.370 - 00:02:14.410, Speaker A: So chain of traction has definitely been a hot topic. I think we're here for a number of reasons. I think the first one that's worth maybe congratulating is that we no longer have $50 l one transactions that all of us have to suffer through. We no longer have rabid chain congestion just because a popular NFT project decided to have a mint available. We more or less allow chains to be in charge of their own destiny and applications as a result, to be in charge of their own destiny. We've removed the noisy neighbor problem, but there's no free lunch. We've introduced some other problems instead.
00:02:14.410 - 00:02:53.990, Speaker A: Um, namely, uh, bridging is a big one. Uh, it's really easy to interact on a chain, but how do you get there? Um, we also have the challenge of if you now had an asset on one chain, that asset could exist on n chains, where n is the number of, of overall chains that exist. And I think this week we probably saw half a dozen neol two s, um, get announced. So this is certainly not, not going away. Uh, the, the computer scientist in me, um, will call this an o of n problem. Uh, and every time we have a new, new chain, there's another place that our stuff could be, and therefore another pair of chains that we might need to transact between. So this is a big problem.
00:02:53.990 - 00:04:07.894, Speaker A: What we've basically seen is that as the surface area increases, it makes it more difficult to put certain things on chain. For example, I'll talk a little bit about smart contract accounts and trade offs there, but one of the great powers we have is programmability in crypto. But we have this paradox now that anything we put on chain has to be on every chain, and that has cost implications, ux implications, bridging implications, and more. And so now we think about off chain as a way to be this agnostic, neutral place where we can kind of manage something uniformly across multiple different chains. I think the term off chain has historically had a really bad rap. It's been kind of conflated with custodial systems, trusted systems, generally speaking, systems where there could be bad actors. And I think that's been a challenge for the space, because especially now that we're seeing this expanded surface area, we're going to have to rely more and more on systems that are not native to any given chain, but rather agnostic.
00:04:07.894 - 00:04:48.760, Speaker A: And I'll talk about how we think about this. So I'll start with the off chain transaction life cycle. So there's a lot of talk here around what happens once a transaction hits a mempool, hits a chain, gets their sequencing confirmation. All these things I'm going to talk about what happens above. So, applications have historically been tasked with actually obtaining some kind of user intention. That could be an intention to mint an NFT, to swap a token, to stake something, and that typically materializes into some kind of transaction on chain. And apps have been responsible for proposing what that transaction should be.
00:04:48.760 - 00:05:53.800, Speaker A: Wallets have historically been this separate space where the whole point is that it's a different application that a user uses to determine whether a transaction should be signed or not. And what's been historically special about wallets is that they have the private key held within them, and that provides this separation of concerns. And so why am I talking about wallets? This talk is supposed to be a chain abstraction. So what we've seen is that as there are more and more chains, the responsibilities of wallets have increased. Where wallets are now, the place where you not only are looking at what action the user is taking, but it might take now three or four actions to get the right asset to the right chain. So maybe I have USDC on optimism, but I need to get that same USDC to noble. How am I going to do that? The wallet is now a place where three or four different individual transactions might need to happen to make the thing I want a reality.
00:05:53.800 - 00:06:42.732, Speaker A: And so there's more and more that's been shifted up at the wallet layer. Apps similarly have had an increased scope as a result of this. So applications now have to think about, ok, well, what's the right way to route my assets to the chain I want to be on? And generally speaking, it's led to this condensing of the wallet and app separation of concerns that was initially mentioned. So what? Wallets used to be this neutral, trusted, almost kernel, where a wallet could be anything from a user could completely choose this. It could be a piece of paper with your private key written on it. It could be a ledger, it could be a mobile wallet, it could really be anything. And apps as a result didn't have to think about this notion of managing keys securely or anything like that.
00:06:42.732 - 00:07:25.370, Speaker A: It was all about once the user has a wallet, propose a transaction to the wallet and leave it up to the user to accept or deny. And that interface was always very explicit. And again, when you're transacting on a single chain, explicit approval, let's say transfer ETH from me to everyone here, that was a lot easier to navigate in terms of an explicit approval where you can look at a transfer. It still wasn't great. The highlight of no one's day was looking at that JSON and inspecting it, but at least it was manageable. But now what we've seen is that that turns into 4345 transactions, and the user burden has just become a lot higher. So now, as a result, we've seen these layers combine.
00:07:25.370 - 00:08:08.640, Speaker A: It's become even more important that these layers are able to be combined so that we don't have this back and forth switching friction of going from app to wallet to app to wallet. So there's a few different ways to approach this. The first is explicit approvals, which is what we've all kind of come to know and love and hate. So this is the nice confirmation dialogs that we see. So we see that if I'm transferring an asset from one person to another, there is an explicit confirmation. I am responsible for inspecting that, parsing it, making sure my wallet is not going to get drained, and then going ahead and approving it. And of course, the wallet is just responsible for accurately doing this.
00:08:08.640 - 00:09:02.920, Speaker A: The problem though, is that user friction is really high. And it's only getting higher because as I mentioned, instead of one of these confirmation dialogs standing in the way of me and that NFT I really wanted, it's now going to be. So what's option b? We started to see more and more applications take on background approvals or using things like embedded wallets. I have a screenshot of Warpcast here as one of the notable examples of this, where we're fully abstracting away the notion of a chain. I would imagine that many people on Warpcast don't actually know what chain they're transacting on the. But yeah, this gives us the ability to kind of interact with an application in a first party context without this back and forth switching. The user, however, needs to trust a lot more.
00:09:02.920 - 00:09:50.936, Speaker A: We need to trust the application to both be proposing the right transaction as well as confirming it onto the chain. And the result of this is just that it breaks a couple of the paradigms that we had before. So this app plus wallet paradigm was really neat because you could have a wallet and connect that to many different apps that had a variety of levels of trust. However, with background approvals as a user, that wallet is now fully trusting any application that it's connected to. And as a result of this, what we've seen is that most of these background approval type of type of initiatives have to have app specific wallets. And app specific wallets create some challenges. We already talked about liquidity fragmentation.
00:09:50.936 - 00:10:31.678, Speaker A: Now we have another problem, wallet fragmentation. So instead of now having the right asset in the right wallet, but on the wrong chain, I might now have the right asset in the wrong wallet on the wrong chain. And so I have to get it into the right wallet, I have to bridge it to the right place. Again, this gets more expensive, more confirmation dialogues, more problems. And the core problem here is really that when you have these more integrated experiences, you're scaling the amount of trust and therefore the amount of risk that needs to happen with every incremental app that you connect to. So there's a third option. Shocker.
00:10:31.678 - 00:11:30.398, Speaker A: That's what I'm here to talk about, which is a more nuanced approach. So we can condense these app and wallet interfaces, we can abstract a notion of what chain people are interacting on. However, as mentioned before, it's really important that we keep that trust explicit, and so how might we do that? So I'm proposing basically a way that we've approached it at capsule, but it's really a tale as old as time in terms of going from something that is integrated and one to one to trust interfaces that are explicit. This is something we do quite a bit of in the crypto space already. So in the paradigm I'm about to introduce, wallets are more of a permission management layer. And then new apps are still default untrusted, but apps can gain the trust of a user progressively. And so in that warpcast example, I can connect that wallet somewhere else, but that somewhere else is default untrusted.
00:11:30.398 - 00:12:01.338, Speaker A: And over time, as a user, I can grant more and more and more trust to that application. So this is really the holy grail. Oops, sorry, I skipped a couple slides ahead. But this is really the holy grail because it gives us the best of both worlds. It gives us this clean, abstracted, beautiful web two like experience where crypto is exactly as in the background as we want it to be, and it gives us explicit, verifiable trust. Um, and so account abstraction is really the. Am I not able to go back here? Oh yeah, beautiful.
00:12:01.338 - 00:12:59.310, Speaker A: Um, so account abstraction is something people talk a lot about, um, in this regard. Uh, and it's great because you can have this idea of a session key that programs privileges, you can revoke the session key. However, in a chain abstracted paradigm, you end up with n session keys. If we want to change the permissions in one of these session keys, we have to change that end times across all the end chains that we're on. And we therefore just start to see some challenges in what logic is worth the monetary investment of putting something in a session key in different times. And so what we do with capsule is we basically try to take a lot of those value props and bring them off chain so that they can work across a variety of different chains without requiring this on chain surface area, which as we mentioned, is expensive. So we build embedded wallets that are interoperable across web3 apps as well as chains.
00:12:59.310 - 00:13:51.280, Speaker A: So what we do in terms of this gradual permissioning or gradual trust problem is we actually think of this as very similar to OAuth and how OAuth scopes work. The first time I connect my google account to calendly, maybe I don't want to share all my contacts and maybe I just want to share my calendar access and that's required. But the next time maybe I am not enjoying typing in the names of all the emails of people who are already associated with my Gmail. So maybe I grant that privilege the next time. And so what we do is we think about MPC key shares and MPC resharing as a way to grant scoped access to the different apps. And this allows us to do this in a revocable fashion as well. So I'm not sure if this video will play, but basically this walks through and I can talk to anyone afterwards signing up for red.com
00:13:51.280 - 00:14:08.986, Speaker A: comma, going to blue.com later on, and then granting blue.com some progressive privileges. So minting just an NFT. And then later on you could grant blue.com the ability to transfer eth out of a wallet maybe once that trust is built up. And so, yeah, that's it.
00:14:08.986 - 00:14:13.270, Speaker A: Thanks everyone and happy to chat through.
00:14:14.050 - 00:14:16.722, Speaker B: What's the business model of devsil?
00:14:16.906 - 00:14:23.710, Speaker A: Oh yeah. So we work directly with apps, so what we do is we charge a subscription based fee.
00:14:24.370 - 00:14:40.862, Speaker B: I have a question on the MTC. Obviously there are advantages, obviously for safety, but there are some disadvantages related to maybe speed and stuff like that. Like how can you just describe what the user experience would be in terms of the negative sides of the MPC?
00:14:40.926 - 00:15:10.182, Speaker A: Just NPC is another victim of this end nodes scaling type of challenge. So the approach that we have taken is to have a pretty opinionated two of two MPC setup. And so that trust assumption is fairly explicit. There is one share that's held by capsule and another share that is held by the user on their client. The user receives a backup of the capsule share when they onboard. So there is full censorship resistance in the system from the beginning. However.
00:15:10.182 - 00:15:17.934, Speaker A: Yeah, it is an opinionated two of two setup, but latency wise this two of two gets us pretty fast. So under a second for most operations.
00:15:17.982 - 00:15:26.410, Speaker B: Yeah, just for user experience, this would be okay. And can a user choose to have more than two NPC's? Is there an option?
00:15:26.800 - 00:15:39.008, Speaker A: There are resharing schemes that exist in MPC where you can go from a two of two quorum to a resharing that say, has a three of five. It's not a workload that we support, but the cryptography does allow for it.
00:15:39.104 - 00:15:40.880, Speaker B: All right, awesome. Thank you so much. Thank you.
