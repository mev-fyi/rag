00:00:00.250 - 00:00:54.014, Speaker A: So first off, what is eclipse? So eclipse is, eclipse is building scalable, modular application specific roll ups using the salon VM. So what this means is that currently, for most l one chains, all application devs share the same chain. And so in times where there's like a lot of demand for the chain, if you get really contested, gas fees can get really high. In the case of Solana, sometimes people spam thousands or tens of thousands of transactions a second, which really ballnecks the network. So what we're doing in eclipse is essentially building roll ups for every specific app. So every app will have its own dedicated app chain that all settles to a single eclipse settlement chain. And app chains can choose what data availability providers to actually store their blocks in.
00:00:54.014 - 00:01:51.886, Speaker A: And Celestia is one of the main data availability providers that we are supporting in our initial devnet releases that are targeting early next year. So what is IBC? So IBC stands for the inner blockchain protocol, and it's essentially a protocol for very, basically sending messages across chains. Why might you want to do this? Well, the easiest example is if you want to bridge assets across chains or do trades across chains, you can take your value from one chain, move it to another chain. We need some sort of secure way to make sure that those messages are sent across correctly, that people aren't doing things like double spend transactions. And so IBC provides a framework to enable this to happen. So here are some of the key components of IBC. So when you talk about IBC, typically we're talking about two chains that are communicating with each other.
00:01:51.886 - 00:02:37.562, Speaker A: And so both of the chains need to have some things built on top of them. They need the core protocol of IBC, which I will talk about in the upcoming slides. This is the actual language of the messages that need to be sent across chain so that both chains and the relayers in the middle will be able to understand the messages. Both chains need a client for the other chain. Talk about this a little bit more. Basically, what this means is that every chain should be able to read the state from the other chain and verify that that state that it received is actually correct. The third part is for apps that are building on each chain, they need to integrate into what they're called modules.
00:02:37.562 - 00:03:38.930, Speaker A: These modules sort of plug into the core IBC logic and are able to make IBC messages. And essentially, when we talk about sending messages through IBC, what we're really talking about are apps that write modules, and these modules talk to each other. And finally, there's a relayer that needs to sit in between these two chains. This is like an off chain program that listens to messages on both chains and then ferries messages across to the opposite chain whenever it sees, like, a message on a sending chain. So I'm going to walk through the IBC core protocol to give you a sense of what this looks like. So, ICs two, as I mentioned, ICS is the series of official IBC standards that designate how the protocol works. So, ics two talks about clients, and usually these are light clients, because it's sort of infeasible to run like an actual full client on chain, typically.
00:03:38.930 - 00:04:42.440, Speaker A: So this client must do two main things. The first thing is actually being able to parse the other chains data. So, given, like, this blob of binary data, the client must be able to deserialize this based on whatever format it's sorted. And then the other thing is that it must be able to verify that this state has consensus. So all Cosmos SDK chains use tendermint as the built in consensus mechanism. So, since IBC was designed with Cosmos in mind, it has built in support for tendermint. If you are going to connect to a chain that doesn't use tendermint, say ethereum, then you would need to write logic that understands the signatures of the validators, maybe like the structure of the Merkel tree that the data is stored in, and be able to sort of verify that all those signatures were signed correctly, that they were, as you expected, and that the data is actually present in this creative on big state.
00:04:42.440 - 00:05:34.102, Speaker A: So now that we have light clients, we can now be able to start creating connections between two different chains. So connection just represents an open link between two chains. So every connection needs to use a specific client so that the connection is able to understand what the other chain is saying and be able to establish this handshake to start a connection. Of course, the same client can be used with multiple connections. So if we are connecting to multiple cosmos SDK chains, well, the protocols that they speak are exactly the same, so we can reuse the same cosmos SDK tenuremint client to talk to both of the chains. So, here is a diagram of what starting a connection looks like. So, as you can see here, there's two chains, and they want to communicate across each other.
00:05:34.102 - 00:06:10.978, Speaker A: So a connection is initiated when something on chain a. Chain a, I'm just referring to as, like, the starting chain. Something on chain a sends a continent message to the IBC core module. It just says, like, okay, I want to start a connection with this other chain using this client, if that condonent is successful, then in the middle here, what it isn't labeled is like this whole section is what the relayer is doing. So the relayer is listening to messages. On chain a. It sees a continent that was successful and then says, okay, chain a wants to talk to chain b.
00:06:10.978 - 00:06:54.238, Speaker A: I'm going to send a con open try message on behalf of chain a to chain b. If that is successful, it'll read the chain b state, and it's like, okay, chain b accepted that connection. I'm going to tell chain a con open act. We're going to act the fact that chain b opened the connection. And once that's successful, send the con open confirm. So if you're familiar with TCP, for instance, this looks pretty similar to a syn synac act handshake and effectively serves the same purpose. It's just telling both chains, making sure they both have the correct state of both chains in mind, and making sure that both chains are aware that this connection is open next.
00:06:54.238 - 00:07:21.690, Speaker A: So if you've been paying attention, I actually skipped from ics three to ics five. I think this is just because the way they're organized is a little bit weird. So ics five talks about ports in IBC. As I mentioned, there are modules which represent apps. Modules end up talking to each other. These could be things like smart contracts or cost modules. And modules bind to a port to identify themselves.
00:07:21.690 - 00:08:02.962, Speaker A: IBC. And this works like sort of similar to ports on your local machine. A module can actually bind to multiple ports, but for our purposes, it's super important. And so once a module is bound to a port, it can establish channels of communication between a port on their chain and then a port on a remote chain that they've already connected to. So channels have a few different properties. They can be unidirectional versus bi directional. That just means messages are going one way or messages can go both ways, and then they can be ordered versus unordered.
00:08:02.962 - 00:08:32.462, Speaker A: This just means packets must arrive in order versus packets can arrive out of order, but then something has to sort of wait until all the packets arrive in order afterwards. So here's a diagram of channel establishment. If you saw the last diagram, this is basically exactly the same thing. It's just like one level up. So instead of establishing a channel, we're just establishing a connection. Otherwise the messages roughly work the same way. So I'm not going to go into this too much again.
00:08:32.462 - 00:09:05.100, Speaker A: And then channels can be torn down. This is pretty straightforward. One side says, I want to toast the channel. And then it just gets relayed to the other chain using a relayer as well. So once channels are established, channels let you deliver packets back and forth. These packets, again are very inspired by TCP. They contain a source port and channel, a destination port and channel, a sequence number saying which packet number it is, and then the actual binary blob of data that they have.
00:09:05.100 - 00:09:45.314, Speaker A: So packet delivery is pretty straightforward. This is sort of the core of what the relayers do. So after connection is established and a channel established, a relayer's main job is to sort of ferry these packets over. So whenever it sees a send packet on any chain, it needs to take that and then send a corresponding receive packet onto the chain that it needs to be delivered to. And this is the primary way that data actually gets across between different chains. There's some timeout mechanisms on the packet itself. So if the packet doesn't get delivered for ten or 20 block types, this is like configurable.
00:09:45.314 - 00:10:28.578, Speaker A: When you send the packet, chain a can choose to time out that packet, and then that timeout also needs to be delivered over to the other. So these are the basic building blocks that you need to send messages across IBC. There's a few other specs that I did not mention, but these are the main components. So with these sort of layers of building blocks, you're now able to send packets across. One thing I do want to point out is that the relayers in the middle here are untrusted. So IBC security does not rely on the relayer here being trustworthy. The relayers can send whatever messages across between chains.
00:10:28.578 - 00:11:50.282, Speaker A: So going back to the very beginning of this presentation, both chains have a light client for the other chain, and it is within these light clients that the validation of all the messages happen. So the security of IBC depends on the light client implementations of both chain b on chain a and chain A on chain b, like being correct, because if the relayer is being malicious, the light client can just reject the message that the relayer tried to send across because it wasn't actually on chain a. So that's what the security of IBC kind of depends on, is the security of these messages on chain. So what are some applications that you can use IBC for? So these apps are actually sort of like apps defined within other spec numbers. So there are two categories that IBC is currently focusing on, cross chain activity and transfers. So for cross chain activity, there's this idea of interchange accounts. So you have an account on one host chain, and then you can sort of maybe use the same private key or use the same account address and use that same account on other chains, except instead of having local accounts on those chains, what you do is you just send IBC messages and then that lets you interact on behalf of that account on the other chain.
00:11:50.282 - 00:12:18.934, Speaker A: Cross chain data queries is the idea of being able to query information about the different chains. Say you're on Salana and you want to query eclipse, but not eclipse, sorry, ethereum price data in a very cheap way. You can use ICS 31 to sort of establish that and then cross chain transfer. So these are mostly named after the ERC number. So ICS 20 is like the fungible token transfer. ICS 721 is NFC transferred across chain. Cool.
00:12:18.934 - 00:13:01.000, Speaker A: So I want to jump a little bit into IBC and eclipse and some of its unique challenges there. So eclipse, as I mentioned at the beginning, is a Solana VM, not a Cosmos SDK chain. So unfortunately, because we're not built on the Cosmos SDK, we don't get the IBC module for free. We can't really use the module because it's designed with Cosmos SDK in mind. So a lot of the initial work is just re implementing the core protocol on Solana, which is written in rut and building that up. So that was like one of the first things that I was working on. And the second thing we need to do is build light client support.
00:13:01.000 - 00:13:43.362, Speaker A: So for eclipse, on any cosmos chain that we're trying to connect to, and for Cosmos chains on eclipse, the latter mostly exists already. Cosmos chains on eclipse because there's an implementation in rust. So the main big hassle is supporting eclipses as a light client. So this means both understanding the data format of this Solana VM as well as verifying our sort of unique consensus mechanism. So we have sort of a unique settlement system, given that we are a roll up. So that's been a larger bit of work. And also an interesting point is that relayers also kind of need, like, client support.
00:13:43.362 - 00:14:56.374, Speaker A: So the reason why relayers need this is that if it's trying to receive messages from both chains, it needs to be able to look through the stream of messages, be able to filter out which ones are IBC messages, probably check that the messages are correct, because sometimes the relayer needs to deliver messages to another chain. And if that message was actually invalid, the relayer could be wasting gas sending a message to a different chain when a real IBC message didn't actually get sent. So the relayer does want to validate that the message is correct. So that's what I've been working on right now. And then another challenge is that eclipse is an optimistic roll up. So I don't want to dive too deep into this, but an optimistic roll up essentially assumes that the transactions that are produced by the execution nodes is correct. But if there is a problem, if someone realizes, oh, one of the transactions is incorrect, it can submit what's called a fault proof, and the protocol has a built in way to deal with fault proofs.
00:14:56.374 - 00:16:06.820, Speaker A: And if the fault proof is correct, the chain will be rolled back to a previous known correct state. So some other optimistic rollouts include names like, and this is a challenge for eclipse as well, because IBC kind of assumes that if the message got delivered across chain that it was just successful. So there's not an easy way inside IBC to say like, okay, this message was delivered, but now it's incorrect. Now, so can you drop it from the state? So we have to work around this a little bit. One way is actually to just work with IDC to add this into their spec as a part of their core protocol. That's one thing we're investigating. Another way might be this challenge period could be like a, so like one simple way is we allow people to start sending messages, but the messages don't get delivered to the receiving chain until that entire one week period has passed, because after that one week, we know for sure that those transactions are final.
00:16:06.820 - 00:16:55.380, Speaker A: This is straightforward to do, but Ux wise might not be the best for users because they have to wait this whole challenge period. A third way might be to deliver messages using a bridge instead of using IBC. So a bridge that we're working on integrating is hyperlane. So the way hyperlane could work is that it actually runs a full node of eclipse so that it can know for sure that the messages on eclipse are correct. And so it doesn't actually need to wait the entire two weeks or one week before the message gets sent over. So that's another way. Maybe something like this could also be built into IBC if we work with updating the spec for this.
00:16:55.380 - 00:17:35.950, Speaker A: And then there's some interesting challenges around, like paying fees for relayers, because relayers have to pay gas to actually deliver these messages back and forth. So ICS 29 is working on this. There's no chain right now that actually has support for this. But that's something that is interesting for eclipse as well, given that we have these app specific chains that might all have their own tokens. So this might be uniquely challenging for some relayers cool. So that's mostly what we have in terms of eclipse. So we're aiming for a definite launch early next year, sometime around January or February.
00:17:35.950 - 00:17:47.538, Speaker A: So. Yeah, keep an eye out for that. And that's basically it. Yeah. I want to leave some time for questions if anyone has anything. Yeah. Awesome.
00:17:47.538 - 00:18:01.240, Speaker A: Thank you, Kevin. If anyone has questions, feel free to ask. Yeah, you can also feel free to just send messages in the chat if you.
00:18:04.810 - 00:18:30.960, Speaker B: Kevin, I thought that was a great rundown and summary of IBC. In terms of the specific challenges for eclipse, is it true that there aren't really light clients in Solana and there isn't like a state route for. Do you, how do you get around that? Because doesn't IBC kind of assume both of those things?
00:18:33.810 - 00:19:35.522, Speaker A: Right. I believe that Solana has some unique challenges. Like you're mentioning. One design that we are pursuing for eclipse is having this modular chain where the data availability is separate from the execution part of Solana. And so since we are settling to, say, Celestia, we have some flexibility over how we represent the state. So we do plan on having a Merkel tree to represent both the on chain state as well as some off chain IBC related message like logs that we don't actually want to store on chain permanently because they're expensive. We're still working out the exact details of what the actual data format on Celestial will look like, but we have some flexibility over adjusting this.
00:19:35.522 - 00:20:11.920, Speaker A: And then within the light clients that we build for the cosmos chains as well as the relayer, we can have it know about the specific eclipse data structure so that it can actually parse these trees. But, yeah, Solana doesn't give us some of this stuff for free. Another challenge that Solana has is that it doesn't actually store all of its history in states similar to Ethereum, where you can sort of retrieve anything from any time in the past. Salon doesn't have that as well. So that's also something that we have to work with, too, because IBC might want to request messages maybe like five or ten blocks in the past.
00:20:14.690 - 00:20:32.070, Speaker B: Got it. So the fact that you guys are kind of ripping out the salona virtual machine that you can rewrite a lot of this is not dependent on the actual Solana layer one implementation, because you guys are kind of going to adapt things to your own implementation.
00:20:33.130 - 00:21:49.790, Speaker A: Yeah. So I think some of the on chain smart contract work can be reused with the salana L one, but we're not actually depending on the Salana L one. We do plan on using Salana as one data availability source if apps prefer that, but they're definitely not locked into using like. So you said they need to implement like four proofs to IBC. How far are you along with it? What's your thinking there? I'm still sort of working on a draft of what changes we could make to the protocol. I think we're going to start with the simpler wait the entire challenge period before delivering messages, because that helps us get an MVP ready, but I think that isn't ideal. So still trying to draft the exact details of how that could look within the protocol.
00:21:49.790 - 00:22:31.162, Speaker A: Maybe we maybe tag all the messages with some bit saying we're delivering the message, but it's not yet settled. And then we deliver another bit further down the line where we say this message has actually passed the entire challenge period. Something like that. Still trying to work out the exact details of that right now. Okay, modular Joe. Modular Joe is asking. So you're planning to commit to the SVM state every block by using a Merkel tree? Yep, that's correct.
00:22:31.162 - 00:23:13.540, Speaker A: And actually IBC has some built like a built in spec for these things called vector proofs. So what they're essentially doing is you can commit to sort of the Merkel root and then a specific member of this Merkel tree with a much more sparse representation of all the nodes. I believe it's like the entire path of nodes from the Merkel route bound to the specific node that you care about. So it typically only requires log of n space. So yeah, we are planning to do that. I think it's pretty standard for other chains as well. So, yeah.
