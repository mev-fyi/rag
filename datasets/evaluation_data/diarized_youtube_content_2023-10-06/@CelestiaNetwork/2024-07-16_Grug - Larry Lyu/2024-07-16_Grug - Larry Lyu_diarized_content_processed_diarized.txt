00:00:01.840 - 00:00:47.430, Speaker A: Hey, my name is Larry. I founded a company called Left Curve Software and we are building an execution layer for blockchains called Grag. So before we jump into grag, I want to just give a bit of general thoughts on what it's like to building an execution layer in today's market. So there are, you see, there are three fact, well, aspects you can look at when evaluating an execution environment. There is bead, meaning just how many TPS you can do. There is security, meaning how many security pitfalls your developers can potentially fall into. And there's features, meaning how big of a toolkit you're providing to your developers for them to build their apps.
00:00:47.430 - 00:01:31.336, Speaker A: Now you can choose to spread your efforts evenly across these three aspects, and in the end, you might get a new execution that is, let's say 1.2 x better than the EVM. That's a good thing, that's cool. But I think that's just not going to have a very good of appeal in today's market. So the approach that we take for Grok is we want to pick only one of these aspects and really focus on that. And the objective is we are going to be ten x in that one aspect than any other alternative. Now you see, if there aren't some apps that really, really need that one aspect to be good, well, that is our natural customer.
00:01:31.336 - 00:02:16.612, Speaker A: So that's how we carve up a niche in the market and grow from there. So that one aspect we picked is the features side. So our objective is that by providing a rich set of features, some applications that are difficult or just straight out impossible to build in other vms are going to be easy to build in grag. So for the rest of this talk, I will just walk you through some of my top favorite features that grag uniquely offers. Feature number one is our smart account system. Now, Ethereum has EIP 3074, which I think is the right direction. However, our smart account system, I think is more elegant and more powerful.
00:02:16.612 - 00:03:11.984, Speaker A: And it's just really simple. Let me talk you through about it. On the right hand side, it's the flowchart on how a transaction is handled in grag. So when a blockchain receives a transaction, usually the first thing it does is to authenticate the transaction, meaning to make sure the transaction comes from the rightful owner of its sender account. Typically this is done by including a cryptographic signature in the transaction, and the blockchain will verify that signature. The drawback of doing that is the blockchain needs to kind of enshrine a signature scheme in the chain's logic, and that is not flexible, meaning the account cannot choose which scheme it uses. So if at one point there's a new scheme emerges that's better in Ux, better in security, well, it's not very flexible.
00:03:11.984 - 00:04:06.180, Speaker A: We take a very different approach. Instead of a cryptographic signature, you see in bottom left, our transaction includes a field called credential, which is just a generic JSON value. The blockchain does not attempt to interpret this value, nor does attempt to do anything with it. Instead, each account in grag is a smart contract, and that smart contract must expose a special function called before transaction. So on the top right, the first step of handling a transaction is to call the before transaction method. In this method, the contract is provided with the details of transaction, including what are the messages, function calls are in there and what is the credential. And it is up to the contract to interpret that credential and do anything about it.
00:04:06.180 - 00:04:49.570, Speaker A: So this is the most flexible authentication scheme ever, because the contract can literally do anything it is programmed to do. So it can be a cryptographic signature, it can be a one time password, it can be a hardware key, it can be a combination of the above. So anything you can imagine is totally up to the contract programmer. So after that step, we move on to execute that transaction. And after that, it is our second major innovation in this account system is we call back into the account contract again another special method called aftertransaction, and the account can do whatever is programmed to do. So this opens a lot of possibilities. I'll just tell you two of them.
00:04:49.570 - 00:05:25.472, Speaker A: One is that you can set a daily outflow limit in your account. In the before transaction function, you calculate the total value of your account, and in the after transaction function you calculate that again. And if that decreases too fast, well, you can reject the transaction. Now, if you implement this correctly, that can pretty much prevent majority of the hacks. If it just your account literally doesn't allow its own value to drop too fast, that just prevents hacks. Right. And the second use case is a financial use case called credit account.
00:05:25.472 - 00:06:11.780, Speaker A: So this is a new Defi primitive where your account is allowed to take uncollateralized loans. And this is only possible because of two things. One, in the after transaction hook, we can compute the account's house factor. And if that transaction causes your house factor to drop too much, we reject that transaction. And the second fact is, because our account, each account is a contract, we can build in liquidation mechanism into that account. So these two things combined make, is it possible to allow the account to take uncollateralized loans? So this is a defi primitive, uniquely enabled by Grok. Now, it would be dishonest for me to not mention Mars protocol, which I worked for prior to working on Grok.
00:06:11.780 - 00:06:55.346, Speaker A: Mars implemented credit account cosmosm. So it's not saying it is impossible to do that in other execution environments other than Grok, but it's just really, really, really difficult. In fact, we estimate that if the credit count had used Grok, the size of the code base can be reduced by 70% easily. So that is just how easy Grok makes to write this kind of complex financial applications. Okay. Second feature is flexible fees. You might notice that there's one last step in the transaction flow chart I didn't mention, and that is where we handle the transactions.
00:06:55.346 - 00:07:47.996, Speaker A: Gas fee. So different from every other blockchain in existence, gas fee in Grok is handled by a smart contract that is appointed by the chain's governance. So inside that contract needs to expose a special function called handle gas, which is called after each transaction in that function, the contract, which we call taxman taxman, is provided with the details of the transaction's gas consumption, and it can be programmed to do whatever the developer wants it to do. So I'll just give you a few examples of what you can do about this. Maybe you don't like the floating gas fee in ERP 1559, so you can implement a flat gas fee. Or maybe you don't like burning your fee. You want to distribute that to stakers.
00:07:47.996 - 00:08:13.238, Speaker A: You can just program that in your tax min contract. Or maybe you can allow the account users to pay gas fee in any asset. If that is not an asset you want, you can just swap that in your dex. Maybe you say, oh, we want to give holders of a certain nft a discount in gas fee. You can do that. Maybe you want to give some new users some free transactions. You can do that.
00:08:13.238 - 00:08:43.028, Speaker A: Maybe you're running an order book. You say, oh, if you put a limit order that doesn't eventually get filled, maybe we can give them a refund. You can do that. So this may or may not be a good idea. I'm just showing all the possibilities, right? And if at any time you don't like your current gas fee mechanism, you want to change one, you don't have to fork your chain, you just upgrade that one contract. That's all you need to do. So makes it super simple.
00:08:43.028 - 00:09:27.688, Speaker A: Feature three is crown jobs. Crown jobs means tasks that need to be executed at regular time intervals. For example, an order book exchange needs to find matching orders and execute them. Like every block, a perpetual futures exchange will needs to update the founding rates of their markets based on the open interests, long and shorts every once in a while. So these are crown jobs. Now, in traditional blockchains, these actions needs to be triggered by transactions. If you're using Opstack or EVM or solana VM, you have to run bots to send transactions to the chain to have these things done at regular time intervals.
00:09:27.688 - 00:10:26.504, Speaker A: But in grag, this is baked into the blockchain. So how do we do that? Well, we borrowed this concept from Cosmos that, well, this is our flowchart for handling the entire block, right? When we receive the block, there is a list of contracts called begin blockers that is appointed by the change governance. It will just be called a special function called before block, one by one. So if you are running an order book or a perps exchange, you can do that things in your begin before block and then it goes to go on to process the transactions one by one. And after that there's another queue of contracts called afterblock will also be called one by one. So that is where you can do some of other tasks. So apparently before and after blockers needs to be appointed by governance because these function costs are unlimited in gas.
00:10:26.504 - 00:11:03.986, Speaker A: So we don't want somebody to put in like an infinite loop in them. But you can imagine programming a contract that has some sort of limited gas, gas stealing and use some sort of auction methods to select permissionlessly select these contracts. So that's something we can do. The fourth feature is our token standard. Everybody hates ERC 20, I'm pretty sure. But exactly why are ERC 20 bad? I can think of six reasons. One, every ERC 20 is a separate contract that has its own state.
00:11:03.986 - 00:11:46.910, Speaker A: And it just happens. Also that ethereum transaction, each transaction can only call one contract natively. So that means each transaction you can only send one token, right? Now imagine you have 30 tokens in your account, you want to migrate them to another. Well that's 30 transactions for you. So that's the first drawback. Second drawback, you cannot send a token to another contract and immediately call a method on that contract. So that is why when you swap on uniswap, it asks you to approve a spending limit and then withdraws that in a second transaction, it withdraws that spending limit from your account.
00:11:46.910 - 00:12:27.462, Speaker A: Now there are some newer standards like ERC 677 that adds a new method called transfer and call. But still you can only transfer and call with one token per transaction. So if you are providing liquidity to uniswap, that requires two assets, well, you still can't do that. The third thing, the recipients cannot reject a transaction. So that we've seen a lot of instances where people sending assets to a contract and that results in permanent loss that cannot be prevented. And the next two things are related to queries. Given an account, I want you to list all the assets held by this account.
00:12:27.462 - 00:12:44.782, Speaker A: Impossible. Because each token is a separate contract that needs to be queried separately. If there are 1000 tokens out there, I need to make 1000 queries. That's just ridiculous. Given a token, I want you to list all its holders. Impossible. And that is for a different reason.
00:12:44.782 - 00:13:20.692, Speaker A: That's due to the Merkel Patricia tree that Ethereum uses. It hashes all the keys and values. So because those values are hashed, you cannot iterate them. So this is a fundamental flaw in the Ethereum design that is just too late to fix. Finally, not a drawback in of itself, but fungible and non fungible tokens are two standards. Wouldn't it be better if we can manage them under one roof? Right, so grag solves all of these problems. So, um, let's start with the queries on the right.
00:13:20.692 - 00:13:57.774, Speaker A: This is an example of what happens if you query an account's token balances. You just say, hey, this is the account address, tell me all the token balances and the query, just give you a list of results, as simple as that. And also NFT. Each NFT is just a one supply fungible token, right? So we can manage nfts and fungible tokens under one single standard. So in the example here, you see I have badkids. If badkids was using grag, this is what you can do. Recipients can reject token transfer.
00:13:57.774 - 00:14:37.818, Speaker A: Each account must implement a special method called receive. So each account can examine all which assets were sent to me, who sent it to me. If I don't like it, I can reject it. And finally, when you call a contract, you can attach any number of fungible or non fungible tokens as a payload, and the contract can just then do whatever it is programmed to do. So I hope it convinces you it's a much better token standard. Cosmos IBC is natively enshrined as a native bridging solution. So that allows you to onboard users seamlessly from every ecosystem.
00:14:37.818 - 00:15:00.730, Speaker A: I'm listing some possibilities here, not endorsing any of these protocols. Just give you an example of what can be done. And this is for the nerds. We have a lot of quality of life improvements for you. Our transactions are natively multical. If you have a mapping data type, you can iterate them. We have null types in solidity.
00:15:00.730 - 00:15:34.290, Speaker A: If you have a number, that number is zero. It's not possible for you to tell whether that number is simply uninitialized or it's actually a zero. Right? We have null type. Contrast can be upgradable. No need for proxy patterns, no need to worry about you mess up the state call data are human readable and reentrancy attacks are simply impossible in grok. So that's some of the top features. Our roadmap we are thinking about tagging a release candidate in Q one of next year.
00:15:34.290 - 00:16:12.940, Speaker A: As that we are not really focusing on performance, we are focusing on features. However, I think even without any serious efforts into optimization, we can still do 1000 TPS, which is, I think enough for a lot of the applications. We are going to launch a chain, we are going to have a token, and we are going to ship the first few consumer apps ourselves. So post launch we are going to do a few more things. There will be a solution to state bloating, which is believed to be the biggest hurdle in Ethereum scaling. We're going to have a solution to that. We're going to think about parallel processing with block STM.
00:16:12.940 - 00:16:36.510, Speaker A: And finally, we want to also dk proof our execution. So that's all. Oh right. One last thing is we build grag by standing on the shoulders of giants. And specifically this giant is cosmosmouse. We are inspired by cosmosm. It would be literally not possible, it would literally not exist if cosmosm didn't exist.
00:16:36.510 - 00:16:47.910, Speaker A: So thank you to cosmosm creators and developers. And finally, this is our discord channel. If you would like to chat, please scan the QR code, take a picture post on Twitter, and thank you.
