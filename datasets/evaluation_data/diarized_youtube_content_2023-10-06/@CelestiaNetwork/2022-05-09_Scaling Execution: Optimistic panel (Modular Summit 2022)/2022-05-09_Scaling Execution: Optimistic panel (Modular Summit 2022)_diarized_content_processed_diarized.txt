00:00:04.090 - 00:00:33.670, Speaker A: All right, so why don't we start with a brief intro of ourselves, and I'd like to also hear a short elevator pitch of what you're working on your project. I'm sure many are familiar, but it would be nice to have your own definition of it. So I'll start with myself. I'm John from Delphi Digital. We provide cutting edge crypto research, and we are strong supporters of this modular paradigm.
00:00:34.170 - 00:01:04.254, Speaker B: Hello, I'm Proto Lamta. I work at Optimism as a researcher with Optimism. We're working on a new upgrade called Bedrock, and this simplifies the protocol by modularizing, by taking apart the roll up logic from the exclusion logic that we know as GAF. And as part of this, we also have this new faultproof tech that will basically secure the withdrawals from the roll up to the layer one.
00:01:04.452 - 00:01:32.040, Speaker C: All right. Hi, I'm Josh. I'm an engineer at Celestia Labs, where I lead the Sevmos team. So I'm not participating on the L1 data layer of Celestia. I'm working on, if you recall, back to Mustafa's slides or Eric's slides, the Sevmos section, which is a sovereign roll up focused for settlement, so for roll ups to actually settle onto. And as part of that, we're using fraud proofs to actually kind of guarantee the security of that sovereign roll up.
00:01:33.150 - 00:01:51.600, Speaker D: I'm Emily. I work at Fuel Labs, and we're building Fuel, which is the fastest modular execution layer. And we're building that using three different principles that's UTXO based parallel transaction execution, the Fuel virtual machine, and then a really superior software development experience.
00:01:52.790 - 00:02:45.086, Speaker A: Thank you, guys. Emily, I think now that we're in the roll of paradigm, the differences between fraud proof and validity proofs, those are kind of overplayed and well known by a lot of people. But I think what's under discussed is how dispute resolution mechanisms, fraud proofs, and particular implementations of those differ from each other. So I'd like to start with that and have your opinions on what are some design choices you've made when building these dispute resolutions mechanisms. And if any, can you point out to some unique aspects of your implementations of dispute resolution?
00:02:45.278 - 00:03:17.126, Speaker B: Right, so if you think of the early roll up design, everyone approached it, starting with the fraud proof, and then later looking at what can we fit in into the execution. I think this really hurts. UX. Over time, we have learned that users want some like they want on ethereum. At least they want ethereum features. So they're looking for an EVM or they're looking for some specific execution environment without workarounds. So to get rid of these workarounds, you have to approach it differently.
00:03:17.126 - 00:03:30.270, Speaker B: You approach it with this type of VM that can run arbitrary code. Maybe it can run something else than optimism and then do a fraud proof over this more generic binary of instructions.
00:03:31.250 - 00:04:01.686, Speaker C: Yeah. So I kind of view fraud proof as a relatively more limited design space, I think, even than, like, ZK roll ups because you really have two ways of doing a fraud proof. You're either going to have re executing a transaction or you're going to have this bisection interactive verification game. For us, we're just using re execution of a transaction. And that's our kind of first attempt here. And that's for purely practical reasons, we're building fraud proofs into the Cosmos SDK. The modular software architecture that Cosmos SDK provides is you can have consensus on one layer and then you have your state machine on another layer.
00:04:01.686 - 00:04:24.450, Speaker C: And so it's a relatively clean software design to just add that execution layer, that state machine Cosmos SDK layer, and say, okay, now Light clients just have to have the ability to take your fraud proof, set up the state. The pre state that you give them right from your state witnesses and then actually re execute the transaction just as any other Cosmos SDK based execution layer would do it. So from it's just an engineering practicality question.
00:04:24.520 - 00:05:14.290, Speaker D: Here at Fuel, we use a hybrid approach. So on one hand, we use UTXO based fraud proofs, and then on the other hand, we also use interactive verification game fraud proofs that are at the VM level. And we combine both of these to produce an outcome that works for our execution model. And we feel that this offers benefits because it means that we only need to necessarily rely on, say, a specification. And other designs might rely on different technologies, like interpreting to WASM and then doing fraud proofs with WASM. And those technologies would then rely on the limitations of what the WASM team wants to implement for the language. And at Fuel, because we take this hybrid approach, we're just relying on the specification and that gives us some freedom.
00:05:14.950 - 00:05:53.482, Speaker A: Interesting, I didn't know that about Fuel. So, just to move on that, how far do you think, as an industry, we are in fraud proof design space? Do you think in near future, do you think many of the problems are figured out and these implementations are going to converge on one design, get more commoditized? Or do you think we will see more and more some different implementations getting divergent, like some different flavors of solutions here?
00:05:53.616 - 00:06:33.026, Speaker B: So in terms of research, I think we're getting there. But in terms of products, there can be so much more. So when you think about all this new tech that enables fraud proof over some arbitrary execution, you could do a lot more than just an EVM or just some specific type of smart contract VM. And so think of indexing services or other types of things that take layer one data and do these very expensive, like huge computations and then just prove that the execution is correct. This can be very meaningful to, say, adding an indexer to a chain that wouldn't otherwise be possible with a smart contract.
00:06:33.218 - 00:07:04.098, Speaker C: Yeah, from my view, I think we're pretty far along in research and like what I mentioned before. Right. We have these two modes, and you can kind of figure out how to implement those modes from an actual implementation perspective. I think it's a wider range because if you want to re execute transactions, right, and you just pick that mode of fraud proof, then it's completely dependent on what execution environment you are using here. Right. If you're going to use an EVM execution environment, you're going to have to have the ability to re execute EVM transactions. Same for CosmWasm, same for, I'm assuming, right, where you're boxed in by what your execution environment is.
00:07:04.098 - 00:07:33.360, Speaker C: And so in that space, we're actually pretty narrow in what we've researched because, quite frankly, blockchain right now we have a pretty minimal number of general purpose execution environments. I mean, look, we have like Solana, we have Cosm WASM, we have Fuel, we have EVM, right. Those are kind of the big four that cover most of these things. And then we have but, you know, even Team Right is working on an EVM transpiler. So we're very small number of execution environments, and that's going to actually drive what kind of fraud proofs you need to be able to generate, right?
00:07:34.050 - 00:07:52.098, Speaker D: Yeah, I think we're going to see some general theoretical ideas shake out and become more standardized. But then in terms of the actual implementations, I feel like those will be specialized to the particular technology. Stack got it. Yeah.
00:07:52.184 - 00:08:30.240, Speaker A: So we basically cannot consider fraud proofs in isolation from the execution models. I think everyone would agree with this. So I'd like to hear your experiences and get more familiar on what kind of constraints each pose on each other. So your fraud proof posing on your choice of execution model and vice versa, what are some constraints that you witnessed if you could share your experiences here?
00:08:31.490 - 00:09:22.598, Speaker B: Right, so we started with the wrong approach with a lot of constraints. Over time, we kind of freed ourselves going for more and more generic fraud proof. So we're not doing really a fraud proof over the EPM, but rather we're doing a fraud proof over MIPS execution. You can target a Go program to different instruction sets. Most commonly that's x 86 But MIPS is this simple instruction set that you can do a fraud proof over. And using this approach, you can compile the EVM implementation from GAF to this type of binary, but it doesn't mean that you cannot compile another type of Golang program to a binary to do a fraud proof over. So over time, I really do think that we'll start thinking outside of the box, something that's not a regular smart contract.
00:09:22.598 - 00:09:25.860, Speaker B: VM and do fraud proofs are for more interesting things.
00:09:26.310 - 00:09:29.460, Speaker A: Would you think MIPS could become a standard?
00:09:31.430 - 00:09:52.970, Speaker B: So, unfortunately, at the time of development, we didn't have the ability to target risk phi with Go. But by now, in recent updates in Go, this risk phi instruction set is now supported. So there is this more elegant instruction set that we could support. And the differences are not that large. It's the same kind of family of instruction sets.
00:09:54.430 - 00:09:56.346, Speaker A: Very interesting. Yeah.
00:09:56.368 - 00:10:13.886, Speaker C: So in that vein, right. I mentioned we're limited by the execution environment. We have to re implement the execution environment and the kind of elegant solution that the optimism team has gone with. And as I understand, the nitro VM is somewhat similar. That where they essentially take the EVM, which is a somewhat hard to understand virtual machine. It's somewhat complex. Right.
00:10:13.886 - 00:10:51.814, Speaker C: And they compile it to this reduced instruction set computer, which is MIPS, and then RISC Five would obviously be like, the ideal, more modern one, but it's just not quite kind of ready yet from, like, an infrastructure perspective. Right. And that simplifies our problem. We still need to be able to have the ability to kind of deterministically execute this thing. But then you're reduced to kind of a simpler problem because really what you're trying to figure out with a fraud proof right. Is how do I execute the minimal amount of state transitions and give essentially the smallest amount of state to, I'll say, my Light client, right. And then allow them to do the smallest amount of work to prove that I gave them an input and an output, and they did an execution on that input, and they got a different output.
00:10:51.862 - 00:10:52.410, Speaker B: Right.
00:10:52.560 - 00:11:22.998, Speaker C: And I think we'll see this general purpose fraud proving hopefully kind of become the standard. And then what we have to see is this kind of software architecture on Light clients being able to execute these general purpose things, right. Where right now you have to run a Light client for your optimistic roll up that has to be able to run this MIPS VM right. And it has to tie into that execution for us. Light clients in a Cosmos chain normally don't have any execution part in them. They don't have a state machine. We have to attach a state machine to them and have an ability to start up this state.
00:11:22.998 - 00:11:36.198, Speaker C: So I think we'll see it at this engineering level of how can you easily tie into these optimistic roll up chains to actually do more general purpose execution of a Risk Five or a MIPS based fraud proof?
00:11:36.294 - 00:11:37.180, Speaker A: I see.
00:11:37.950 - 00:12:05.818, Speaker D: Yeah. So I touched on this a little bit earlier, but because at Fuel, we have this hybrid approach, it allows us to be based on specifications instead of being based on running fraud proofs based on, say, WASM or something like that. So I feel like, in general, the fraud proof schemes that we'll see are going to be tied to execution.
00:12:05.934 - 00:12:06.262, Speaker A: Right.
00:12:06.316 - 00:12:06.822, Speaker D: Yeah.
00:12:06.956 - 00:12:25.306, Speaker A: So in your hybrid model, would you say that it relates to your data model, like the UTXO model? Would that be relate, like, your choice of a hybrid fraud proof? Would that be related to your choice of UTXO model or those irrespective of.
00:12:25.408 - 00:12:32.170, Speaker D: Themselves I would say that our choice of doing a UTXO model is what helped us choose to do the hybrid approach.
00:12:32.250 - 00:13:37.330, Speaker A: Okay, yeah, I see a lot of focus on the roll up space, and rightfully so, is focused on reducing this L One footprint. Right. When we move from single round fraud proof to a Bisection game, we try to simplify basically the problem to a single instruction set that should go on chain. So this reduces the l one footprint. But when we think about scaling as a holistic thing, really the L One footprint is a part of it. Arguably, it won't be the biggest part of it in the future with solutions like Dank Sharding, like with Celestia, a part of scaling is obviously the data model and execution model. So I'd like to know what are some optimizations that you do in this respect in your particular implementations?
00:13:38.150 - 00:14:29.518, Speaker B: Right, so I do think optimistic roll ups are in favor here of seeker roll ups, where if data does get very cheap, then we reduce our cost by basically 100%. This is our primary cost. Execution only happens during the fault proof in the unhappy case. So in the happy case, you'll get very, very cheap transactions. And in the best world, you would combine Zike rollups and optimistic roll ups. If we had a Zika proof for arbitrary computation like we can do with fraud proofs, they can lag behind the optimistic roll up and reduce the dispute period by showing a validity proof to basically confirm the execution. Short term, I think the optimistic roll ups are more powerful here with better arbitrary execution.
00:14:29.518 - 00:14:33.602, Speaker B: And so I'll have to deal with the dispute period for yes.
00:14:33.656 - 00:15:32.486, Speaker C: I think answering your specific question of, like, what are we doing to kind of specifically optimize our thing outside of the data? You know, a project inside of Celestia, we're not really focused on that right now. We're taking a somewhat naive approach to these roll ups, to these optimistic rollups in the fraud proof, where we're just trying to generate a fraud proof. And we're assuming that the size will come in at such that we can post it on our data availability layer, and we're assuming our data availability layer gives us cheap enough data that we're not too worried about that. I think one of the interesting things is as data becomes cheaper, right, as Proto mentioned, optimistic roll ups start becoming more favorable because they have a higher cost of a quantity of data that needs to be posted on the L One as an optimistic roll up. And when that kind of problem becomes better, the actual cost of generating a fraud proof also, or the complexity of that, can become simpler because in this generic execution, the Nitro VM is somewhat complicated. To understand the Bisection game, it's much easier to explain to someone, oh, I'm just going to give you a pre state. You're going to do an execution, you're going to get a post state.
00:15:32.486 - 00:15:50.986, Speaker C: The reason you might want this interactive verification game is because you can get a smaller fraud proof. And if your data is expensive, you could touch a lot of state in this fraudulent transaction. You could have with a very, very large fraud proof, theoretically too large to even post in one block. Right. And that's kind of an unacceptable situation. That's what the arbitrary people were talking about.
00:15:51.008 - 00:15:51.146, Speaker A: Right.
00:15:51.168 - 00:16:21.560, Speaker C: They can cover fraud proof for transactions that are essentially larger than the total block space of Ethereum. But if we start having larger blocks on a data layer or really, really cheap data, you can kind of remove some of the optimizations actually in the fraud proofs because the assumption is you're not frequently posting fraud proofs. If we're posting fraud proofs, like once a day, once a week, once a year, something is kind of wrong with the economic incentive system here. Right. So we can actually get simpler things and less optimized systems that are then easier to understand, easier to audit and verify if we get cheaper data, right?
00:16:23.050 - 00:17:02.980, Speaker D: Yeah. So in terms of optimizations, there's really two things that come to mind for fuel and that's one, we have the UTXO based model that allows us to eliminate the need for a global state merkel tree. And this allows us to scale quite generously. And the second thing is, in the actual implementation, every contract has a corresponding address. And then to refer to these contracts, you refer to them using an address. And this allows us to take advantage of some of the properties that having a global state merkel tree would allow you while still maining the UTXO based system where we don't actually need it.
00:17:05.370 - 00:17:33.600, Speaker A: Thanks for these. Yeah. I'll have one final question and then I'll open the panel to audience questions. So oftentimes in these crypto projects there's like misconceptions. So can you think of a common misconception related to your project or optimistic execution in general, if you have any? If you don't, feel free to pass this one.
00:17:35.170 - 00:18:32.720, Speaker B: This is a spicy question. Everyone thinks different things about roll ups. I think in general you could say there is a misconception that non interactive or interactive roll ups one is better for some weird reason. In the end, I do think it really depends on the dispute period. If you have this kind of dispute period, then you will see differences, or if you don't have this dispute period, you'll see differences. So like in the sovereign rollup model or things closer to Celestia, it will actually matter to be able to do a non interactive fraud proof. Whereas on Ethereum Mainet, you always have a limited EVM and having interaction is actually a good thing because if you have a week anyway to do this anti censorship fraud proof, if you take the time, then you might as well use that to reduce the cost on layer one.
00:18:33.170 - 00:18:40.386, Speaker A: So in the case where the fraud proof is distributed over the P to P layer am I getting if you.
00:18:40.408 - 00:18:50.162, Speaker B: Want to be off chain, you definitely want to be non interactive or something close to that. Whereas if you want to do this on chain, interactive is actually more optimal.
00:18:50.306 - 00:18:51.190, Speaker A: Makes sense.
00:18:51.340 - 00:19:35.282, Speaker C: Yeah. So for the celestial model, if we go into the L1 two three right, we're deploying that settlement layer which is itself a sovereign roll up. So in this way we're boxed into using this non interactive fraud proof because we don't have a place where a smart contract can live that would essentially mediate this interactive game. But to answer your question on misconceptions, I think there's a little bit of this assumption that like a 14 day latency window or whatever to the verification or the trust of the roll up transactions. Some people don't know. I think that that's like a completely arbitrary number that was picked. There's not good backing research on this is what happens if you extend it to 21 days.
00:19:35.282 - 00:20:01.894, Speaker C: This is what happens if you shorten it to seven days. People just picked like 14 days and good enough. That seems fine. Right. But we haven't seen a live network generating large quantities of fraud proof. To see is 14 days actually long enough? And if you think about the amount of transactions going through these networks, right, if we look at Starkware, we're in tens to hundreds of billions of dollars of transactions. The reality is you just need one honest full node in the network to be re executing all transactions.
00:20:01.894 - 00:20:52.574, Speaker C: They should be able to find an invalid transaction. This latency window doesn't really need to be that long for you to have a pretty large set of people that are economically incentivized to check these transactions. You could probably be order of days or even hours because these liveness failures you'd have to have the assumption of there is no honest watcher in your network executing the transactions, but you're still producing transactions. It's just not a real world situation in the modern world of how trivial it is to spin up software. If the thing that can generate a fraud proof is open source software, if all of them are down on the network and you have a 24 hours window, there's like ten cloud services you can go to at any hour of the night, buy a VM, download the software and execute it against the chain in that period. I just don't see liveness issues being something where we need 14 days to resolve this.
00:20:52.692 - 00:21:12.686, Speaker B: Right, so I think the 14 days number or seven days for some it really depends on the censorship ability against the fraud proof. So if you have fraud proof of chain you have a very different model than if, say if you have a fraud proof that depends on miners, including the challenges.
00:21:12.878 - 00:21:36.620, Speaker C: Yeah, and I guess so we're biased in this sovereign roll up environment, right, where we have a relatively easy workaround to the censorship resistance because you can pass it to the data layer. And the assumption is that the data layer is not necessarily incentivized to censor transactions for your roll up above it. Obviously that's still an area where you can have censorship if there's sufficient money to be gained by censoring. Right?
00:21:38.030 - 00:21:44.800, Speaker A: Yeah, but good color. I like the angle that you put on this. Emily, do you have any?
00:21:45.170 - 00:22:27.580, Speaker D: Yeah, so speaking particularly about Fuel, I feel like there's this misconception that Fuel is an optimistic roll up first, when in reality it's a modular execution layer first. But I don't think that this is a problem that's specific to Fuel. I think because modular layers and the modular blockchain is this new exciting thing that's becoming more prevalent in the space that we are knowing and working with. I think there may be misconceptions about what the definitions mean and I think that's why days like today are very important, so that we can get excited about it and bring everyone together with the community.
00:22:30.370 - 00:22:48.310, Speaker A: So if anyone have any questions, now's the time. Questions? Don't be shy. No one.
00:22:49.640 - 00:22:53.160, Speaker C: This shows that fraud proofs are already answered. We've already solved all the problems.
00:22:53.230 - 00:22:56.810, Speaker A: All the problems. I think there's one. Oh, here we go.
00:23:00.720 - 00:23:41.096, Speaker E: Thank you for the panel. I have a question here. I was asking few labs folks on the background, but still question for you. Let's say I have a Celestial like client on a phone. It's just a deliverability layer, okay? And there is a Dex deployed on a full node, basically uniswap. And I want with my phone to take like to plug any execution layer and talk to that Dex. Do you think it is viable in this year or a year after or is it just like a realm after five or six years?
00:23:41.198 - 00:23:42.104, Speaker B: Thank you.
00:23:42.302 - 00:24:24.772, Speaker C: So I guess when you say a phone here, it's a relatively nebulous thing because I don't think hardware limitations of phones right now are going to be a limiting factor. I mean, what the hell does like an iPhone 13 have from a processing power perspective that's insufficient to do validation or execution of transaction. I think your actual problem is going to be kind of from a software perspective, like can I get my software onto iOS? Probably not. Can you get your software onto Android? Probably if you route the phone, yeah. Then you can probably jam it into Linux somehow. But then actually an interesting problem is something that I don't think we talk about that much is like cross architecture things. You can just transpile it to like Arm, but you do get layers of different architectures in here.
00:24:24.772 - 00:24:44.780, Speaker C: But I don't see any technical limitations for that. I think we're into the limitations of Apple and Google control, what, 98, 99% of all phones and they're relatively restrictive on the kind of software you can deploy. I don't know if anyone's gotten blockchain execution nodes onto a phone. I don't know where that falls into an app store category.
00:24:46.160 - 00:25:28.040, Speaker B: Well, so if you have a phone, obviously you might want to run a full node. But this is what light clients are for to reduce the resources. So if you want to submit a transaction to a Dex from your phone and if you want it to be confirmed on the data layer, then there will probably be some software roll up that will try and specialize. In giving you, like, a soft confirmation very quickly for the dex to have a good UX and then to show you a proof that the data has been confirmed. And I think this is really just should be a software problem. And I think this is like a question for maybe a software and roll up panel or basically like the execution layer more so than the execution fraud proof tag.
00:25:30.540 - 00:25:32.276, Speaker A: We have time for one more question.
00:25:32.398 - 00:25:33.804, Speaker C: We got one over there.
00:25:34.002 - 00:25:36.184, Speaker A: Someone over here. Yellow.
00:25:36.312 - 00:25:37.550, Speaker C: Oh, there you go.
00:25:43.280 - 00:26:06.820, Speaker F: Oh, they did work nice. So I often think about app specific chains as not really being like whole chains, but just like a roll up that's built on top of, like, a celestium or something like that, and each application will just run their own roll up and et cetera. I wonder how much you guys have thought about that. I think especially with the people that are building more general purpose solutions.
00:26:07.960 - 00:26:08.324, Speaker A: Yeah.
00:26:08.362 - 00:26:45.914, Speaker C: So that's pretty easy for us to answer as trying to do fraud proof in the Cosmos SDK. Right. It's just a Cosmos transaction, and as long as we can generate a fraud proof based off of the state tree that we'll get in the Cosmos SDK, then it should be fine. For app specific chains, I think that should go for kind of all of these. It's just as long as you have the ability to re execute a transaction for that app specific chain, which really just involves a light client being able to load the state and execute whatever software makes up the app specific chain, it shouldn't be more difficult than that. All right, let's call it there.
00:26:45.952 - 00:26:50.060, Speaker A: So, thank you guys. That was an awesome panel. Thank you.
