00:00:01.800 - 00:00:54.434, Speaker A: I'm Hart from across protocol. I'm here to talk about intents. People in this audience might understand intents well, but I think a lot of people don't. And at this conference, there's a few people that have come up to me and been like, hey, I'm finally beginning to get this intense thing. And I'm specifically going to focus on cross chain intents, what that means, what that looks like. And my goal, or thrust here is to try to pill you on why this architecture is important for interop and why I think it's the best, quote unquote, best architecture for most use cases of what we need to do to connect blockchains. Okay, so what we want, and I think everyone generally agrees with this, is we want cheap, fast and secure interop.
00:00:54.434 - 00:01:12.726, Speaker A: That is so seamless. You don't know you're dealing with blockchains. The you don't know you're dealing with blockchains part is called chain abstraction. People like talking about chain abstraction right now. I think that's great. But the general point is we want to connect this modular ecosystem. We're here at modular summit.
00:01:12.726 - 00:01:45.718, Speaker A: How do we connect the modular ecosystem so that it feels like one unified platform? Users just click buttons and do things. That is the goal. I think the problem here is most people think interoperability looks something like TCP IP. You have a bunch of servers and you want to connect them with pipes and send messages between them. And this is how the Internet works. So it makes sense that this is how we'd connect blockchains. And I actually think this is a misnomer.
00:01:45.718 - 00:02:08.750, Speaker A: This is what gets us in trouble if you think about this kind of naive version. Let's see if I can use the pointer thing. Yeah, blockchain B. I want to send value or send money, send an asset, send one eth between a and b. Let's just send a message. Right? That seems easy. Makes sense.
00:02:08.750 - 00:02:40.560, Speaker A: But there's some problems with this. Problem is blockchain has some sense of finality on blockchain a. So I can't really send this message until I achieve some sense of finality on blockchain, a yemenite, and then sending a message between blockchains. Well, being secure is hard. I have to be fast, cheap and secure all at the same time. That's an extremely difficult thing to do. There's a lot of three way pyramid things.
00:02:40.560 - 00:03:23.900, Speaker A: But why that's hard to make happen. So, yeah, this is a hard thing to do. And basically, if we go back here, we got time for finality time to send message. That's slow and it's probably expensive and it might be insecure. So the solution here is very simply, let's just stop sending messages, at least not in real time. And this is where the intense concept, the cross chain intense concept really comes in. The core observation that I think we've made is in the Internet, in TCIP, you're moving bytes, you're moving messages, you're moving data.
00:03:23.900 - 00:04:04.002, Speaker A: But for 98% of blockchain use cases today, when we are connecting between blockchains, what we really care about is moving value. And I say mostly because there are use cases where I need to move messages. We can maybe talk about that later, but most of the time I'm just moving value. I'm bridging, I'm swapping, and maybe I'm calling. So on the destination chain, maybe I'm doing some action. And that further extends to this concept that, okay, value is fungible. If I'm a user, I don't care which dollars got to the destination blockchain, I just want dollars.
00:04:04.002 - 00:04:41.982, Speaker A: They're the same. And I think this is like the core insight that unlocks in this cross chain intense concept. I don't care how the money got there, I don't care which money it is, I just care about it being there. And I think this is our mental model for why we think cross chain intents works so well. So we'll redo this bridging concept where I want to move value from blockchain a to blockchain b, but we're going to not send messages, so no message sentence. Instead we introduce a third party. We're going to call them solvers in across, we call them relayers or fillers, some people call them market makers.
00:04:41.982 - 00:05:28.342, Speaker A: All the same concept. It's a third party that is going to observe the user's deposit transaction on blockchain a and then going to fill them with their own capital on blockchain b. And the core trade off here is with their own capital, which we'll go into. So the solver fills them with blockchain b and they can fill them extremely quickly. If this solver trusts, say, a preconfirmation from a centralized sequencer or decentralized sequencer, whatever it might be, if they trust what blockchain a is telling them, these solvers can take risk with their own capital to fill the user near instantly. And the fun thing I could do, if we had a computer, I could do demos, I could give you guys a demo of this. Our median fill time, l two to l two on across is about 4 seconds.
00:05:28.342 - 00:06:08.810, Speaker A: Right now, when we're going from arbitrum to base or optimism, it's about a one or two second fill time. It's extremely quick because we have a solver network that is trusting the arbitrum sequencer here, but they're trusting it with their own risk capital. It's not the user's money that's at risk here. And they're giving an extremely fast fill, which we'll get into more. Okay, so idea here with cross chain intents, solvers are using their own capital. I'm repeating myself here. Solvers are using their own capital to quickly and cheaply fill users, and then they get repaid later.
00:06:08.810 - 00:06:42.402, Speaker A: So, okay, we'll zoom out a second here. This is what the across view of what cross chain intents looks like. This view is shared by a lot of other people in our ecosystem. The frontier research guys. The cake framework looks like this. What socket's doing with their mofo framework looks like this, too. A bunch of people are kind of independently coming to a similar looking architecture where we have three layers.
00:06:42.402 - 00:07:34.480, Speaker A: We have the intent layer, where what the user wants to do is created. This you can think of as the application user says, I want to move a to b, or maybe it's move a to b and do a deposit function or buy an NFT or execute some bit of code. We have the solver layer that is competing to fill that intent, and we have the settlement layer. The settlement layer here is going to escrow user funds on the destination chain and not release them to the solver until we verify the intent was repaid. So the general order flow here, intent gets created, user funds get escrowed. Solver fills user extremely quickly with their own capital. Then wait, delay, verify the intent was filled, release user funds from escrow back to solver.
00:07:34.480 - 00:08:13.982, Speaker A: Okay, so I want to walk through just sort of why I think this architecture works well and what the trade offs are. So intents, I said before, they can be really, really fast. This is data from our own internal systems where we're looking at l one to l two, bridge times l two to l one, and l two to l two, and across. We really do have a median fill time about 4 seconds. The 90th percentile fill times under 10 seconds now. And we're pushing hard to get this down. What's cool about this is we don't really do anything.
00:08:13.982 - 00:08:57.960, Speaker A: We just incentivize solver competition, and the solvers themselves are the ones that are competing to fill users faster. As some of you may know, I sometimes war with Stargate on Twitter. This is our data, not Stargate's data, but this is our data that you can verify yourselves. On Stargate V two. They're a lot slower because their general framework is this, let's send a message from a to b, and they have to wait for a sense of finality. It's a different architecture, it has some trade offs, but it's certainly not as fast. And for comparison here, I also included circle CCTP protocol, which I think is very cool, very useful, and is actually integrated with a cross under the surface.
00:08:57.960 - 00:10:17.360, Speaker A: But the way circle works is if they're going to burn and mint USDC, they need absolute certainty around finality guarantees. So Circle will wait for full finality of the l two checkpoint to be finalized by Ethereum means it's going to take them about 20 minutes to bridge transactions. And that's something that they're not going to change because that finality guarantee matters so much to them. Okay, so too much text on this slide. But the high level context here is, I think intents can be extremely secure. And the observation here is that we are separating the urgent part, that the user wants a fast fill from the complex part, which is how do we verify that fill did happen? How do we send messages between blockchains? And by separating these two things, the complex part we can take our time on, which buys us more advantages for how we would actually verify or send messages between blockchains. And we have the in this intense framework, it's not wed to any one messaging technique for how we would verify intents.
00:10:17.360 - 00:11:06.174, Speaker A: We can do what we want here, and different architectures are going to use different mechanisms. You could imagine verifying fills using canonical bridges. This is somewhat how a cross works today. We kind of use a combination of an optimistic system to verify a batch of solver fills, and then we use canonical bridges to move that message from Ethereum mainnet to the different chains that we support. But you can also imagine that we use ZK proofs to do this. You can imagine we use native interop. So when you see the optimism, super chain building native interop, could we use the native interop? That optimism has to verify intents and repay solvers more quickly and more securely.
00:11:06.174 - 00:11:32.498, Speaker A: Yes, definitely. Polygon ag layer, all the above. We can use these systems, kind of abstract them into this intense framework to enable more secure relayer repayment. And intents can be really cheap. And this one takes a little more nuance to think through. How this happens. But I.
00:11:32.498 - 00:12:40.760, Speaker A: The reasons why we can be really cheap with this architecture involve batching and using messaging techniques that are extremely secure but cheap. So, basically, in the trade off spectrum of sending messages that are cheap, secure, and fast, we can give up on fast and focus on cheap and secure. This is data, again, from our own internal systems. We're not always the cheapest. To be fair to my friends at Stargate, sometimes some of their bus stuff can be extremely cheap, but it takes about three minutes versus 4 seconds. And so there are trade offs here in our architecture, and we are gunning towards this idea of speed matters more than very, very marginal price improvements. So why can intents be cheap? I'll keep this as like a high level kind of conceptual example, but let's imagine we're bridging $50 million in volume over 50,000 transactions.
00:12:40.760 - 00:13:50.558, Speaker A: Let's assume that both bridges, both the kind of messaging architecture and the intense architecture, have the same gas costs for deposit and fill transactions, which is, like, approximately true. What's the difference between doing this batched verification of intents versus sending a message for each bridge fill? And the trade off here on the intents architecture is that solvers are making loans with their own capital. There is a cost of capital for a solver to fill a user with their own capital and get repaid later. And as an example, if I'm loaning 50. Oops, sorry, if I'm loaning $50 million for an hour at a 10% interest rate, that's $500 for an hour. And if I can batch together my hours worth of solver repayments, I can then verify these 50,000 intents for like, ten messages. I'm putting a hypothetical cost here of a dollar, but it's some fixed cost that's low.
00:13:50.558 - 00:14:33.740, Speaker A: And so your main cost is the cost of this loan. But you compare this to, if I'm going to send 50,000 messages, I'm actually saying these messages are super cheap, I'm putting them at message. But sending 50,000 messages is extremely expensive relative to sending far fewer. And I think this is the other insight that, I don't know, people have totally groked yet. I look at this intense architecture as a compression of messaging. So in this example, 50,000 cross chain actions are compressed into ten messages to verify those 50,000 actions versus 50,000 cross chain actions. 50,000 messages.
00:14:33.740 - 00:15:14.752, Speaker A: And in my view, this compression gives us extreme cost and security advantages. We can then send fewer messages. They could be more expensive, but still, in aggregate, cheaper. And they can be much more secure. So I think this is the, an underlooked aspect of why this cross chain intense architecture can work so well. Okay, so there's, here's a concept, or just a slide of ingest jumper. Lefi's jumper across can actually be significantly faster and even cheaper than circle CCTP, which is circle's native bridge.
00:15:14.752 - 00:16:07.240, Speaker A: And like, how's that possible? This isn't possible at huge values. If you're bridging a million dollars of USDC, you should use CCTP if you want to minimize costs. But for small sizes, we're actually so gas efficient, this architecture can be so gas efficient on its deposits and fills that we can actually be cheaper than what circle costs for bridging modest amounts of USDC. And we can of course do this far faster given that solvers are fronting this capital and filling users quickly. So what's the TLDR here we look at cross as this settlement layer for cross chain and intents. I believe this architecture can scale to transfer billions of dollars a day of value while sending very few messages. This is this message compression idea.
00:16:07.240 - 00:17:18.381, Speaker A: Non intent based designs, designs that are sort of messaging centric need to send a lot of messages if they're going to send a lot of value between blockchains. And my observations, just intuitively that feels exciting. That feels like something that's going to cost a lot. Okay, so our vision at the intent layer, we want to cross and we increasingly, I'm going to go into a second in the standard for cross chain intents that we've been developing, but we want a cross to promote this intent centric architecture where we help aggregators, dapps wallets, protocols like scip create and root intents through our solver network. We want to help develop a solver network that is not specific to a cross. We think this solver network needs to be generic. I don't want to say a public good, but it needs to be accessible to many applications that can all benefit from a positive sum, like a not zero sum advantage of increased liquidity at the solver layer.
00:17:18.381 - 00:18:14.520, Speaker A: And so we're working to help establish a standard for cross chain intents that I'm going to get into. And lastly, there's this settlement layer where across. What we are trying to do here is define a best in class settlement layer that will escrow user funds and release them to the solver after we've verify the intent was built. Okay, so yep, we've sort of, in the course of this year, we've relaunched across V three as a settlement system for cross chain intents. And we've been working hard with Uniswap and Uniswap X's cross chain design in many ways mirrors or has many similarities to what we're doing. We've worked with Uniswap to develop a standard for cross chain intents. It's been assigned the ERC number 7683.
00:18:14.520 - 00:18:48.510, Speaker A: And you guys should go check out ERC 7683. Dot, dot. We are actively looking for feedback on this standard. This is still being developed, but we want this to be an open standard that has no concept of vendor lock in. We want this to be a standard that helps define a common layer of abstraction for how intents can work. And actually, I'll go back here for a second. There's a slide that I didn't quite have time to make before I had to send these in.
00:18:48.510 - 00:19:39.670, Speaker A: And it goes to sort of think through how we create a unified ethereum in a world where we have more and more types of ecosystem interop. So I wish I had a visual for this, but you can kind of imagine we have the optimism super chain that is working on their version of native interop to connect super chain chains. We have Polygon Aglayer that's working on their version of native interop to connect egg layer chains. We have Zksync doing the same thing with elastic chain arbitrum orbit. A little bit less clear what they're going to do here. Now they've got some cool stuff coming out, but they're going to connect their own chains, too. And so you kind of have, if you zoom out, you've got four ecosystems that are building their own versions of interop that might work pretty well.
00:19:39.670 - 00:20:23.540, Speaker A: They might not still be that fast. I actually think most of these technologies are not going to be two second fill times, which is what we're aiming for. But there's now this kind of fragmentation around how ecosystems in Ethereum might communicate. And I'm not even including Cosmos and Solana and all this other Alt L1 s. And now from just Ethereum's perspective, there's something very cool about fostering this experimentation and this innovation within these different ecosystems. But now you have this splintered and fragmented world, and I don't think that's very good. We want, like a unified ethereum experience.
00:20:23.540 - 00:21:27.356, Speaker A: And I think this standard thinking of an intent, a cross chain intent, as a very thin, very lightweight layer of abstraction that specifies how a user can move assets from a to b and maybe execute some code on chain b. It becomes a unifying layer that helps connect these native interop ecosystems with a common standard. And if your intent happened to be, let's say, for example, between two optimism super chains, well, then it would just be better. It would just be cheaper. It would be just as fast, but it would be cheaper because the intent protocol would be able to repay the solver more quickly, more cheaply, using the native interop that the super chain offers. Okay, so I'm going to run out of time here, but we're bringing intents to some new chains. We are also at this concept of a cross plus, where it's just using the same ERC 76 intents standard, but allows you to execute code on the destination chain.
00:21:27.356 - 00:22:10.870, Speaker A: So you could bridge and buy an NFT or bridge and deposit into. Into aave or morpho. And the only other thing that I wanted to show you guys, because I think this is super cool, Den Koon has changed the game. Den kun lowered costs by so much that what we actually saw is the median size of an l two to l two bridge transaction was like $500 before on, like, literally before March 15 when Den kun came out. And it's dropped by a full order of magnitude. So the median l two to l two bridge size is now $50. We actually have consumer applications, people using l two s to do real things, which I think is super cool.
00:22:10.870 - 00:22:16.250, Speaker A: Okay, that's me, Hal 2001 on Twitter. Thank you guys very much. Appreciate it.
