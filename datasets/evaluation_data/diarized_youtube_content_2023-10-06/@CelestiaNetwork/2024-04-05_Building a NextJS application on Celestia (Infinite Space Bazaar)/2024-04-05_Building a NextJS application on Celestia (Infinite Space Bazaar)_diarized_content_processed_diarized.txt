00:00:01.840 - 00:00:21.274, Speaker A: Awesome. We're live again. Welcome everyone to the infinite Space Bazaar workshop with lzrs. Today we're going to be learning about building a nextjs application on Celestia lzrs. You want to do a quick introduction?
00:00:21.654 - 00:00:26.388, Speaker B: Yeah, sure. Thanks so much for having me, Josh. I'm very excited to be participating in this hackathon.
00:00:26.526 - 00:00:29.448, Speaker C: It's very, very cool, all the prizes.
00:00:29.536 - 00:01:16.164, Speaker B: I mean, this is just such an opportunity for a developer who wants to get involved in the modular ecosystem, or just blockchains in general, to build great projects, get great mentorship and learn a lot, and maybe earn some money. And so I'm, my name is Lz Rs. I was a very early builder coming into the Celestia ecosystem and I ended up, I ended up finding, I end up founding a company called Modular Cloud. And our goal is to build infrastructure that helps people build this next generation of modular blockchain. So we're trying to rethink everything from the first principles that you get when you're in the modular blockchain space. So that's my quick intro. Should I jump into the presentation or anything else?
00:01:16.244 - 00:01:21.344, Speaker A: That's all. Thanks for joining us. I'm going to go ahead and give you the floor and put your screen up on there.
00:01:22.334 - 00:01:23.154, Speaker C: Oh yeah.
00:01:23.694 - 00:02:20.090, Speaker B: Okay, cool. So today, what I want to show you is a really cool initiative we've been working on, which is to build a roll up that is actually basically just next JS. So the goal here is going to be that if you are an app developer, you can build a roll up that has full security in the same exact way that you would build a regular application. And since next JS is considered to be, and believe me, it has its problems, but it is typically considered to be the gold standard for how you should build a web two app, we decided to use next JS as a framework. Although this could actually be, the concepts that I'm going to teach here today could be translated into to any number of frameworks. And also just if you have a custom built project, another title for this.
00:02:20.122 - 00:02:22.114, Speaker C: Talk could actually be how to build.
00:02:22.234 - 00:02:34.098, Speaker B: A roll up framework from scratch. So this is essentially what we did. I noticed the screen has got a little small in my face. Got big. I don't know if whoever's in control. Perfect. Yeah, this is great.
00:02:34.098 - 00:02:52.724, Speaker B: Okay, so I want to start off with a demo, and just in all transparency, we put this demo together in the past 24 hours. So if it there are some glitches, it has nothing to do with the blockchain part, it's just the fact that we built an entire app in 24 hours.
00:02:52.884 - 00:02:53.584, Speaker C: So.
00:02:55.964 - 00:03:04.544, Speaker B: Shout out to the front end team at modular cloud for putting this together. So I'm just going to type the URL here so it's nice and big for you to see it.
00:03:05.164 - 00:03:06.664, Speaker C: There's two URL's.
00:03:07.014 - 00:03:56.304, Speaker B: One is play modular cloud. Unfortunately, I realized just before going live that verse cell, there's some issue where it's not connecting to our sequencer. So this is the easy URL to type in, but this is actually not going to go on chain. So if you want to use the version that's going to go on chain, I will also share this URL with you. So I'm just going to just enter that even though it's not a command, just so it's there on the screen. So this, you can type in this ip and this port. So I just like last minute spun up a local instance of the server not running in Vercel, although typically this would be intended to be run on Vercel.
00:03:56.304 - 00:04:34.530, Speaker B: Yeah, I'm just going to give people some time and I'm going to pull up my version here so you can see it. So what we made was a little Twitter clone. And so, for example, and by the way, the first moment that it loads, it might take a little bit longer. And that's because it's generating a key for you. And so you don't have to sign in or anything. You can just start using the app and I'll walk through all these details, but I just want people to get a sense for how this works and try it out. Hopefully it doesn't break, you know, what they say about demos.
00:04:34.530 - 00:04:58.418, Speaker B: So I'm just going to do it. I'm just going to post an example here. I'm just going to say example and I post this. Okay, so it says example. And so it seems like somebody else came in here and said, gm, good morning to you too. You can actually go in here and reply. This is like just kind of silly little features that we implemented.
00:04:58.418 - 00:05:27.318, Speaker B: It's glitchy. So I'm going to say reply here, I'm going to submit that. And now. Okay, so what happened was this was Josh. Josh got this, he got this address when he visited the website initially. Now he just set his name to Josh and now it is updated here. Now, unfortunately, we were implementing this front end fast, so we actually just pull the root name here and put it as everyone's name in the reply.
00:05:27.318 - 00:06:04.134, Speaker B: So for now you can't see what the name of the person who replied is, but actually we can really easily fix that. And I just want to emphasize, has nothing to do with the blockchain. That's just literally like the front end code where it's sourcing the data and how it's rendering. So this is a cool little fun demo application, and I'll give you guys a little time to play with it. But basically, I'm going to walk through how this works. So first of all, what you'll notice is that you didn't have to sink a wallet, you didn't have to do anything. You didn't even have to sign in or create an account.
00:06:04.134 - 00:06:49.938, Speaker B: We were actually able to do this for you. So this is a really nice user experience. And what's cool is when I walk through actually how this app is built and how this data is on Celestia, you're going to see that this made little to no difference in the development experience. And yeah, I'm just really excited to show you. So, okay, so what's happening? So the way that the authentication works is that we decided to use an MPC embedded wallet. So we went with a company called capsule. Their website is usecapsule.
00:06:49.938 - 00:07:20.080, Speaker B: Usecapsule.com. We worked with them. And what we do is we, when you make a request, we see that you don't have an active session. And when that request comes in, we generate a new key. And this is now added to a cookie, so it's tied to your session. So if you come back with this browser or refresh the page, you're going to still be logged in. Now, this way of building apps is actually compatible with any wallet.
00:07:20.080 - 00:08:07.832, Speaker B: You could use metamask, you could use mobile wallets, you can use all kinds of things. We would need to build out some additional tooling, but we wanted to have a demo that was as like seamless and magical as possible, and then you can kind of work out how you want to handle the authentication from there. And so the cool thing about this though is that we don't actually have the key. This is a secure MPC wallet where we only have one share that you're authorizing us to use. And you can actually, through capsule's platform, set constraints on this wallet, and you can revoke are privileges to use this wallet. You can claim this wallet, export it, and use it in other instances as well. And so this is a really cool feature.
00:08:07.832 - 00:08:39.168, Speaker B: And I think for an app like this, I really strongly recommend that people consider using this type of wallet. So as it stands right now, when you visit the page and you get your own address down here. The thing is, we do have full control on using that key when we generate it is you visit the website, maybe you do some sort of low value interaction, you don't have any money locked up in this, and maybe you.
00:08:39.176 - 00:08:40.736, Speaker C: Don'T really care as much about the.
00:08:40.760 - 00:09:20.354, Speaker B: Security, but then maybe as you get your account to have more points or you become more valuable, you have a reputation you want to, then you can then go and export and secure that key. And so that's the design choice that we decided. And I'm going to walk you through how, how that's implemented in a second. But essentially what happens. So I want to explain the flow of what happens when you actually take an action. So when I'm writing a post and submitting it, what's happening is. So now I'm already authenticated, I have a session.
00:09:20.354 - 00:09:39.950, Speaker B: This is a server action in next js. This method is fully compatible with server actions and API calls. And when you submit it, I'm going to walk you through the code of what nice. More messages. I'm going to walk you through the.
00:09:39.982 - 00:09:43.434, Speaker C: Code of exactly how this works.
00:09:44.974 - 00:10:14.254, Speaker B: So here's the original repo. If you want to look at the commit history, you can see that legitimately. We just did this 19 hours ago and so we have a great front end Dev who put this together yesterday. And all I had to do, I'm going to show you the commit that I had to make to that this. So I didn't tell him how this system worked. I said, just build this app. Here's the Figma files.
00:10:14.254 - 00:10:47.546, Speaker B: Build this app. And so he did all these, all these commits, you can go and look at it. And I think he actually streamed his work too. If you follow him on Twitter, you can probably go and look at his stream history. But he built this app just like a normal app, and this is all that I did. In order to enable this syncing with Celestia, I had to add a lot for debugging why I wasn't working a few hours ago or 30 minutes ago. But so here's the sequencing.
00:10:47.546 - 00:11:30.344, Speaker B: First I just, I had a few extra commits just setting it up on my, on my computer. But this was the commit, this is all that I did. And this could be actually a package. There's no reason that this has to be me putting these files in this project. I think it would make sense for us to publish a package, but for this version, all I did was I didn't edit any code except for in one place. And I just added a middleware that executes on every request. I installed a few dependencies and I added an authentication library that handles our authentication.
00:11:30.344 - 00:12:27.424, Speaker B: I added some utilities for interacting with the sequencer, which is a standalone server, which we're also going to release open source, probably today or tomorrow. And I just edited this one file because I told him don't do an authentication system because I'm going to bring an authentication system for you to use. And it's going to be a very simple one. And I'll walk you through this. Just to be clear what we're looking at. This is a normal web two next JS react developer building an app and the way he would normally do it, using the state of the art next js with server actions and app router react server components, everything in the gold standard. And we just did this many edits, deleted this many lines, and added this many lines and imported a package essentially, which is what adding these files are.
00:12:27.424 - 00:13:43.684, Speaker B: Now this is a verifiable replayable roll up where the data is put onto Celestia and it can be verified and replayed. So how does it work? So first, so you remember I made a request here, and what it does is when you take a server action or you make an API call index JS, what happens is you, every single request goes through middleware. Now I will say there's one caveat, that one restriction. When you do this on Vercel specifically, if you want to use middleware, you and I'll make this bigger just so that we can, just so you guys can see how to make it bigger. Okay? When you use middleware. Okay, so the one requirement I was going to say is that this has to be running on edge because Vercel doesn't, for some reason, doesn't run middleware on the node JS runtime. So you have to use the edge runtime.
00:13:43.684 - 00:13:47.060, Speaker B: Just, it's just one caveat. Hopefully you're using the edge runtime anyway.
00:13:47.092 - 00:13:48.020, Speaker C: Because it's way better.
00:13:48.132 - 00:13:51.860, Speaker B: But sometimes you have to use the node JS runtime. Just something to keep in mind.
00:13:51.972 - 00:13:53.484, Speaker C: With that said, there is a workaround.
00:13:53.524 - 00:14:31.424, Speaker B: That'S possible to implement very easily to use node JS. However, we just didn't do that because that wasn't what we were doing in this demo. And there are, we can talk about that if people have questions about using the node JS runtime. There are some other drawbacks, but we can talk about that at the end if you're interested. So let's just start over. So you take some action in the app like you're posting something, and when you do that, it creates a request. This request now comes through the middleware as this request object.
00:14:31.424 - 00:15:02.564, Speaker B: Now let's just say you load the homepage. That would be a get request. A get request typically is not something that's going to alter the state. So I'm making the assumption here that if you're doing a get request, you're not writing any data. So this does not affect the data that goes on the blockchain. You're actually reading data from the blockchain in that case. So that is not something that needs to be sequenced and put onto Celestia now.
00:15:02.564 - 00:16:28.438, Speaker B: So now assuming that this is a standard request that's writing some data, what we do is we get the session, meaning we see are they logged in? Do they already have an account? And I won't go into this too much, but essentially what we do is if they have a session, we get the address associated with their session. And if they don't have a session, we create a wallet using this wallet API that we developed based off of capsules MPC. And so then what we do is we get all the details from the incoming request. And here is where we talk to the sequencer. So right now you can think of this as something that finds all the write requests, records, the requests that were made, and is now preparing them in a way that can be replayed later. So what the sequencer does is the sequencer is a server, and I will show you the source of this. But what the sequencer does is it's listening for requests and it takes them in a first in, first out basis and it actually ensures that they run in a specific serializable order.
00:16:28.438 - 00:17:23.824, Speaker B: So we're actually waiting for the sequencer to process this request in the queue. So the one other downside of this approach is that the way that we built this particularly, it would have a performance bottleneck if there was a lot of requests coming in at once. But to be clear, under normal usage that's pretty unlikely to make a noticeable difference for users. But it's just something to keep in mind. So what we're doing is we're getting the method of the request, we're getting the path of the request, we're getting some important headers that will help. So in the case of react server, sorry, server actions, you need to have these types of headers to understand how to parse the action. And we're also taking the body of the request, which would be usually the data that you're trying to input into on chain.
00:17:23.824 - 00:17:59.896, Speaker B: We're taking all of this data and we're packaging it up and we're sending it to the sequencer. So what I'm going to do is now I'm going to switch over to an ide and show you some of the sequencer code. Let me just. Sorry. Just let me load this up for a second. I put in a few changes just because I was trying to debug what was wrong with it, but I decided here to use bun for this. And so this is listening for a request coming in.
00:17:59.896 - 00:18:30.034, Speaker B: So this is the enqueue request. So when you do sequencer enqueue, what it's doing is it's calling this function here where you're taking data and you are posting it to the sequencer. It's really simple. You're just passing it along to the enqueue method of the sequencer. Now let me go back here. So I'll just close this so we have view more. Let me make this a little bit bigger so you guys can see.
00:18:30.034 - 00:19:42.472, Speaker B: So when, you know, when an enqueue request comes in, meaning a new request has been made to the backend, and now that has been relayed to the sequencer, it goes to this enqueue function. Essentially what this does is it takes the data that was sent to it, it serializes it into a string, and then I won't go into this logic. This is just some stuff with Redis to basically block new requests if the old request hasn't finished, because we want to be able to replay things in the exact same order and have no data races, so that we can always determine the same state when we replay the data from Celestia. So I won't go through and explain all this logic, but essentially what it does is it ensures that one request is processed at a time. It'll unblock one, and then when that's finished, it'll unblock the next one, and then when that's finished, it'll unlock the next one, and then it also, if.
00:19:42.488 - 00:19:44.964, Speaker C: It times out, which is important because.
00:19:45.304 - 00:20:31.388, Speaker B: The edge functions have a 302nd timeout, if it times out after 200 seconds, will clean up the job from the queue and basically cancel and say this failed, and just throw an error to the client trying to make the request going back to the middleware. What's happening is we have the request, we're sending it to the sequencer now. This is blocking development. Sorry, not blocking, it's blocking the other requests coming in until it's finished. And once it is the turn of this request and the sequencer gives it the go ahead, then the middleware is simply replicating the request, except this time bypassing the middleware.
00:20:31.436 - 00:20:33.684, Speaker C: So this is where it actually does.
00:20:33.804 - 00:21:15.990, Speaker B: What the user originally intended to do. So you can kind of think about this as the middleware blocks the execution of the API or server action and then it instantly replays it. And that's what is actually writing to, or that's what's actually writing to the database. So when you're on this website, this is functioning just like a normal, a normal next JS website, because what you're doing is you're here, you're querying a database, you're getting the current state of this application, and you're able to just.
00:21:16.062 - 00:21:16.958, Speaker C: Write a SQL query.
00:21:17.006 - 00:22:02.612, Speaker B: We use postgres, you could use any database, you can use MongoDB, you can use dynamo, anything you like. It really makes no difference which database you use because essentially once we have serialized the request and sent it to the sequencer, then we're just actually running that on the database and getting the intended state so that it can be read by the read requests. Now going back to the code. So once we've actually executed the request here, then we tell the sequencer this job that was queued up, that is now done. So let's go on to the next one. And this will now unblock the next request. If there is another request that's waiting.
00:22:02.612 - 00:23:08.534, Speaker B: If there's no request waiting, then it, it just finishes. And last but not least, we're just setting the cookies. So when we create the wallet, we just start making sure that they are now logged in. So that's all that this does. And I think I can talk a little bit about what this next thing does in the sequencer too, just to explain things a little bit more. So once it's in queued, then the next function essentially goes, it takes the next pending job and it moves it into the active column and it will also take, or, sorry, I guess I'm not going to actually go in and explain all this because it's a little bit tricky the way that I implemented it. But essentially what it does is it takes the next pending job, moves it into a staging list, and then it moves the last active job into what's called the committed list.
00:23:08.534 - 00:23:12.574, Speaker B: And what we do is we have.
00:23:12.914 - 00:23:14.922, Speaker C: This list of, after all these requests.
00:23:14.938 - 00:24:11.258, Speaker B: Are done, now they're stored as committed in redis. And so another thing that's going on simultaneously is when you're running the sequencer, there's just a simple interval here. And this runs every, what is this every minute? And it says batching transactions. And so batching transactions, what it does is it goes, and it runs this build block function. So the build block function, what it does is it, it gets a batch of transactions. And the way that we did this batching was we just very simply just grabbed the last or the ten items on the queue. It just does ten at a time.
00:24:11.258 - 00:24:12.530, Speaker B: I think that there could be a.
00:24:12.562 - 00:24:13.730, Speaker C: Much more optimized method.
00:24:13.762 - 00:24:32.024, Speaker B: I just didn't want to accidentally get blocks of blobs that are too big just in some off chance. And I didn't expect to have that many transactions where this would cause like a huge backlog or anything. But basically every minute it pulls the last ten requests that came in.
00:24:33.724 - 00:24:34.060, Speaker C: To.
00:24:34.092 - 00:24:59.514, Speaker B: The API and it zips them up, it signs them and it encodes it into a string. So this, so build block essentially just produces a string that has all of the serialized transactions. Then all we have to do is post the block. So it'll take the block that was built and it will post it. And the way that we do that.
00:25:00.334 - 00:25:05.574, Speaker C: Is we just do a fetch request.
00:25:05.654 - 00:25:13.822, Speaker B: And this can go to a celestial light node. So if you just run a light node, you can easily do this. But what we're using is actually we.
00:25:13.838 - 00:25:15.846, Speaker C: Have a blob API that we're going.
00:25:15.870 - 00:25:52.838, Speaker B: To be launching today. And so we'll release the documentation later today about this. But basically it's just like a light node. You can plug it in just like a light node, except you don't need to worry about managing the wallet. So we also use the similar MPC style wallets to give you a dedicated address that will sign the paper blob transaction on your behalf and it will submit it. So the Celestia team generously provided a lot of testnet tokens. So you can currently use our API for the Mocha testnet and we can just send these out, you don't have.
00:25:52.846 - 00:25:54.194, Speaker C: To go through the faucet.
00:25:55.334 - 00:26:01.182, Speaker B: But of course for Mainnet we're going to have a method that you can simply put in your credit card and.
00:26:01.238 - 00:26:03.382, Speaker C: We will just allow you to post.
00:26:03.438 - 00:26:34.186, Speaker B: Blobs to mainnet without having to actually buy the tokens, manage the wallet or anything like that. You just use our API with the API key. So yeah, I mean, it's really just that simple. This is how you post the blobs to Celestia. So now let's kind of look a little bit more behind the scenes on how this data is actually going on to Celestia. So let's see. I think I have a tab up here.
00:26:34.186 - 00:26:52.778, Speaker B: So this is the namespace that we are using. Okay, well that is a little concerning. Oh, there we go. Okay. Okay. I thought it wasn't posting the blobs, but it is. So these are just different transactions of batches from the sequencer.
00:26:52.778 - 00:27:43.034, Speaker B: So this was the most recent one. We're going to put in some parsing features in the Explorer and so in the future you'll be able to actually see what data was posted from next and you can actually see more details about the request in the Explorer. But since we just put this together, we didn't have time to add any interpretation in the Explorer for this type of data. But I should note that our explorer, we do parse different types of data and embed it in the Explorer. So that's a really cool feature that we do support in general. And yeah, so I mean this is the data on, on Celestia. And I will also show you just kind of a little bit more about how this works behind the scenes.
00:27:43.034 - 00:28:43.264, Speaker B: So here's the sequencer, here are the logs of the sequencer. So here's it's batching transactions. It's running every minute. So you can see, I just put a log to indicate that this is always running and this is what happens when it gets hit. So when you like, I'll just, I'll just do this again just for, to make this example more clear. Actually let me go on this version of it. So I'm going to say hi, it's posting and now this has done enqueue and since there is nothing blocking it, it then called next and then that was added to active and then it started batching transactions again because it had been a minute and then now it's posting the block and here it is and this is the height.
00:28:43.264 - 00:28:55.612, Speaker B: So that's how it works. I could show you, I could show you what's going on inside of browns.
00:28:55.628 - 00:29:28.776, Speaker C: But I honestly think that that's a little bit confusing. So yeah, I think that's basically an overview of how this works. I'd love to answer anybody's questions. If anyone has specific questions about how to apply this to the use case of any applications that you're working on or anything. And we're going to be releasing all of this open source, we're going to be releasing a guide and we're also.
00:29:28.800 - 00:29:30.256, Speaker B: Going to be releasing APIs that will.
00:29:30.280 - 00:29:42.304, Speaker C: Help you with every piece of this including hosting the front end, hosting the blobs, managing user sessions with MPC signing, and also the sequencing of all the.
00:29:42.344 - 00:29:43.216, Speaker B: APIs that we'll provide.
00:29:43.280 - 00:29:56.884, Speaker C: So in theory, you can just sign up for an account with us, use your API key, we'll handle all of that stuff in the background, and you can just build your next js application or using another framework as you'd like.
00:29:59.194 - 00:30:15.814, Speaker A: Thank you for giving us the walkthrough there. I don't actually see any questions in the chat. I was curious, I guess, though, if I were wanting to play around with modular cloud, where should I get started?
00:30:17.714 - 00:31:02.724, Speaker C: Yeah, so, well, we can go on our docs. So our docs are here. And so we have information about our hackathon prize. I will say that we're doing a $10,000 prize, and so anyone that's using this, I'll make this a little bit bigger. Anyone who is doing something like this would be eligible for this prize. We want people to really make apps that are verifiable, that use Celestia, but that are also really useful and cool. And one joke that I like to make is, what's the difference between a web two app and a web3 app is a web two app is useful.
00:31:02.724 - 00:31:44.976, Speaker C: That's not to be disparaging to web3. Web three apps are great, but the thing is that web two apps only have usefulness. That's the only thing they have going for them. There's no point of making it if it's not going to be useful. A lot of the technologies that people have developed have been built for making really useful apps. We're excited to enable people to do that and make web two style apps that are verifiable on Celestia. So anyway, the documentation has some information about a hackathon and it also has some of our APIs here.
00:31:44.976 - 00:31:55.224, Speaker C: So you can access data on various move and EVM blockchains that we integrate with. And we're going to add our blob API here later today, so you'll be able to learn more about how to access that.
00:31:56.164 - 00:31:56.944, Speaker A: Awesome.
00:31:59.124 - 00:32:48.106, Speaker C: I think a few more things I did want to touch on is that, of course we can talk a little bit more about the security assumptions behind this. So, like, this is something that's not using ZK proofs. For example, this is something where it's kind of a traditional lazy ledger style application where data is posted onto Celestia and then it's replayed, and that is how you can verify the app for yourself. Now, this, it is actually totally possible to take a system like this and prove the execution of the API. That's something that someone should build. I think it's a really interesting project and I think like there's a lot of people working on solutions for proving JavaScript applications. And so I'm very interested in seeing.
00:32:48.130 - 00:32:49.882, Speaker B: What those teams can do to extend.
00:32:49.938 - 00:33:09.998, Speaker C: This to basically give the same developer experience with what people might consider to be like better security assumptions. But I do think this is actually pretty good in my opinion, because this is something that, it's on Celestia, you can replay it and you can easily.
00:33:10.046 - 00:33:12.246, Speaker B: Verify it, especially if you can run.
00:33:12.270 - 00:33:17.654, Speaker C: A version of the app that has the canonical truth from Celestia.
00:33:18.274 - 00:33:20.202, Speaker B: You can easily just check the, you.
00:33:20.218 - 00:33:37.854, Speaker C: Know, the status of a given webpage on that version to make sure that that state matches up with what you're expecting. And in some ways that's like an even better way for like a normal person to verify that something is actually true. So I think, I think this is.
00:33:38.194 - 00:33:40.186, Speaker B: There'S definitely security trade offs, especially with.
00:33:40.250 - 00:33:50.614, Speaker C: Hosted front end, but I think this is a very legitimate way to build a web3 application and with better tooling and it can only improve from here.
00:33:52.474 - 00:34:29.922, Speaker A: Awesome, thank you. I guess like we do have a good bit of time left. I was going to say definitely, if anyone has questions, please drop them in the chat. But I'm curious to take a step back to the demo app that you were showing us. If you can give us, give me like the high level of when I go and enter a post, like where does that, where exactly does that go? And at what point does it touch like Celestia and get basically written to the chain.
00:34:30.098 - 00:34:32.094, Speaker B: Yeah, sure. So.
00:34:34.323 - 00:34:42.627, Speaker C: Like let's just pretend that Celestia wasn't in the picture here. So let me try, I'll bring up.
00:34:42.675 - 00:34:52.703, Speaker B: This, I'll bring up this ide with the code in it.
00:34:55.523 - 00:35:08.864, Speaker C: So okay, let's pretend like yes, Celestia is not in the picture. And so what would happen is there's these actions. So this is called server actions. This is something that's built into react and next. And.
00:35:11.644 - 00:35:13.700, Speaker B: Essentially what it does is you.
00:35:13.732 - 00:35:39.670, Speaker C: Call, you pass in form data and it gets parsed and then it's added to a database. And this reads from the cookie. This is just how you would normally build a next JS application. So this runs on the database. However, I mean, sorry, this runs like, this runs on the server with your database. So this executes in a completely standard.
00:35:39.702 - 00:35:42.954, Speaker B: Way like you would otherwise do.
00:35:43.334 - 00:35:55.806, Speaker C: There's no difference between this and any other app. The only difference is that we do three things. One, we log every request coming in through the middleware.
00:35:55.910 - 00:35:56.670, Speaker B: Actually four things.
00:35:56.742 - 00:36:55.804, Speaker C: We log every request coming in, so we know the type of the request and we know the content of the request. Two, we authenticate the user based off of their address and key. Three, we make sure that each request is serialized in a specific order so that you don't ever have any data races, and you will always replicate the same order when you try to replay it from Celestia. So we don't let two things run in parallel, we instead put them one after another. And there are ways you could make you could optimize this to actually run things in parallel, but you'd have to deal with locking and stuff. And I for this demo, that was just not a goal. And four, we also have to ensure that there are no non deterministic functions that are executed inside of any API calls or server actions that you make.
00:36:55.804 - 00:37:29.244, Speaker C: For example, when you are writing to the database, if you want a timestamp, you can't just say date now and get the current time on the server at the time of execution. Instead, we actually have a solution for this, which is, I can pull this up, let's see. It's just a really simple function called oracleize, so it essentially just can turn any data that's non deterministic into something.
00:37:29.324 - 00:37:32.364, Speaker B: That could be basically attested to by the sequencer.
00:37:32.444 - 00:37:50.406, Speaker C: And I'd be very interested in having like a more decentralized, more trustworthy version of this where you could, for example, let's say you did a fetch request to a URL that is something that's potentially non deterministic. It's true. You might get the same result when you request data from a web page two times in a row.
00:37:50.470 - 00:37:50.950, Speaker B: You might.
00:37:51.022 - 00:38:06.614, Speaker C: But also the data could change. So if you, for example, call some sort of third party API, get some data, you put that request on Celestia, and then someone pulls the data from Celestia and tries to replay it, they might get different data.
00:38:06.734 - 00:38:07.638, Speaker B: So what you can do is you.
00:38:07.646 - 00:38:09.614, Speaker C: Can use this oracle ize function and.
00:38:09.654 - 00:38:11.254, Speaker B: All it will do is it'll just.
00:38:11.414 - 00:38:23.024, Speaker C: Record what you got at the time of execution and then the sequencer will sign that this is what they got and attest to it. That's not a great security guarantee.
00:38:23.364 - 00:38:23.908, Speaker B: In general.
00:38:23.956 - 00:38:45.084, Speaker C: I just don't recommend if you are trying to build a web3 app, I just don't recommend doing something like a fetch request. It's just not really what you should be doing. But if that is what you need for some reason, and it's not something that all your security depends on, then this is a really good solution. And again, I also think that you could build a more decentralized version of that as well.
00:38:46.304 - 00:38:59.524, Speaker A: Awesome. I think that's actually a good segue into a question from the audience. Can you share some ideas for hackers in the ISP? And what would you like to see people build?
00:39:00.944 - 00:39:38.254, Speaker C: I want to see people build things that are. That you wouldn't expect to be on chain. This is kind of like what we're trying to get at. For example, I built a to do list that uses celestia. This is something that isn't immediately. It's not immediately, like, obvious why you'd want to do that, but it's cool because, I mean, let's say you wanted to verify that somebody did different tasks at a different time. You could then, you know, you can kind of start building up an ecosystem.
00:39:38.294 - 00:39:40.230, Speaker B: The more different interesting apps that people.
00:39:40.302 - 00:39:53.862, Speaker C: Use that are on chain, the more that you can build on top of that and actually verify that things happen across different apps and create really cool things across an entire ecosystem. So I think we just need to start like. Like, I think that, like, this is.
00:39:53.878 - 00:39:54.406, Speaker B: The way to go.
00:39:54.430 - 00:40:09.142, Speaker C: If you want to build an app, just think about the opportunity here. You can just build an app like you normally would and you can put it on chain. You can get the crypto ecosystem into it. You can, you know, we like, you.
00:40:09.158 - 00:40:11.982, Speaker B: Can get, like, you can build bridging.
00:40:12.038 - 00:40:17.246, Speaker C: And get people to put money into your app and basically get like an alternative revenue stream to what you would.
00:40:17.270 - 00:40:18.270, Speaker B: As just a web two app.
00:40:18.302 - 00:40:32.954, Speaker C: And you can get an audience. Plus, if you build something for a hackathon like this, you can also win some prize money. So I think it's a really great opportunity for people to actually build consumer apps that people use in like on chain.
00:40:33.814 - 00:40:53.734, Speaker A: Awesome. Thank you. I don't think we have any more questions. Go ahead and check one more time and make a last call. And I guess on that note, if I'm building with modular cloud and I have questions, where's the best place to reach out?
00:40:54.514 - 00:40:55.754, Speaker C: You can go on our docs.
00:40:55.794 - 00:40:56.494, Speaker B: There's.
00:40:58.474 - 00:41:06.554, Speaker C: A little thing here you can click on. You can just talk to us directly.
00:41:06.674 - 00:41:08.734, Speaker B: I tested this out. It does work.
00:41:09.354 - 00:41:27.334, Speaker C: And you can also follow us on Twitter, DM us, and all of our socials are on here. So you can also come to office hours every day. So I'm available to talk and I'd love to talk to you about what you're building.
00:41:27.974 - 00:41:33.294, Speaker A: Awesome. And I guess a follow up question to that. Is the discord a good place to reach you as well?
00:41:33.414 - 00:41:38.714, Speaker C: Yeah, absolutely. We're going to be in the modular cloud discord inside of the hackathon.
00:41:41.254 - 00:41:49.354, Speaker A: Yeah. Unless you have anything else to share. I just want to thank everyone for coming and thank you for teaching us about what you can do with modular cloud.
00:41:49.774 - 00:41:50.554, Speaker B: Thanks.
00:41:51.414 - 00:41:52.294, Speaker A: Have a good one, everybody.
