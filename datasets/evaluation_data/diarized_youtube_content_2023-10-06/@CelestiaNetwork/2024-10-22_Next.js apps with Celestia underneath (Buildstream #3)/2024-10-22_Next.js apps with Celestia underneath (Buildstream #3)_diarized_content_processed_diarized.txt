00:01:08.205 - 00:01:39.825, Speaker A: Welcome to Build Stream, everyone. And welcome to Build stream number three, where we're going to be meeting with one of the builders in the Celestia Ecosystem and learning about what he's building. Today I'm excited to introduce LZRS from Shop and Framework and Modular Cloud. My name is Josh from the Celestial Labs team and we're all excited to have you here today. Thanks for having me. Yeah, you're welcome. Today we'll be learning how to build Next JS apps with Celestia underneath.
00:01:39.825 - 00:02:07.895, Speaker A: If you have any questions during the chat or during the stream, please drop them into the chat and we'll get to them during the stream. All of the source will be available afterwards on GitHub and we'll link that in the stream description after. So, without further ado, I'd like to introduce LZRS from Chopan Framework and Modular Cloud lzrs. What is Chopin Framework and what are we going to build with it today?
00:02:09.155 - 00:02:45.165, Speaker B: Yeah, thank you for having me. Chopin Framework is a web framework that allows you to make a web2style app. And this app can be built in the exact same way as a normal Web2 app. You can use Next JS or other web frameworks. Right now we're focused on Next JS and you can present that app to your users in the same way that you would as a Web2 app. And so the users will have a Web2 user experience, the developers will have a Web2 developer experience, but it's going to have the security of a blockchain application. So it's going to be.
00:02:45.165 - 00:03:01.493, Speaker B: The architecture under the hood is going to be just like a roll up. And in that sense it can inherit the security of the blockchain that it's built on top of and it can have interoperability with the rest of the crypto ecosystem. So it's a super powerful new way to build apps.
00:03:01.629 - 00:03:08.885, Speaker A: Nice. So it sounds like we're kind of swapping out a traditional backend and using the DA layer in this case instead.
00:03:09.585 - 00:03:22.925, Speaker B: More or less. That's a really good way of thinking about it. Should I dive into. Yeah, yeah. So if you don't mind, I'm going to share my screen right now. Yep.
00:03:25.025 - 00:03:35.295, Speaker A: Not at all. And if you're watching and you want to get started with the chat, drop an L in the chat for Lazy ledger. Then we're going to get that going.
00:03:38.475 - 00:03:41.015, Speaker B: Let me know if I should start.
00:03:41.315 - 00:03:42.651, Speaker A: Yeah, you're good to go.
00:03:42.843 - 00:04:14.123, Speaker B: Cool. In the first part of this, I broke this into two parts. The first part I want to talk about the big picture. What is the vision for what we're building towards with Chopin Framework? What I really want, since this is put on by Celestia and they've been such a huge supporter, I want to also showcase what I view as the grand vision for Celestia and how this is going to build a fully verifiable Internet. I'm seeing that my screen is not shared. Oh, there you go. Okay, so let's just jump right in.
00:04:14.123 - 00:04:58.431, Speaker B: So, okay, the biggest problem with the Internet is that it's not secure. And I want to change this. So let's just think about, let's just conceptualize the Internet from. In a very, very simple terms, there's a user and a server. This is a very common way of thinking about things. So the problem with this is that the server or whoever runs the server can manipulate any data in the database, they can censor people on the platform, they can change the rules, they can change how the web application works. On any website that you visit, for example, you could even spoof the activity of a user and make them say something that they didn't say.
00:04:58.431 - 00:05:31.397, Speaker B: Like, for example, the President. Oh, wait, okay, well, Trump actually did post this. This is real. But you could, if the President of the United States used a centralized platform, you could launch a, as the administrator of that platform, you could launch a token in their name, which is not good. So as you can see, like, centralized servers are very vulnerable. And this is a huge problem. And the really, the sad thing is that the user has absolutely no recourse whatsoever to any of these attacks.
00:05:31.397 - 00:06:10.079, Speaker B: You cannot detect them, you cannot combat them, you cannot disprove them, you cannot bypass them. There's nothing as a user on the Internet. As great as the Internet is, there's nothing that you can do about it. And this has a lot of downstream implications which I would love to get into deeper at another time, but like, just really quickly. I mean, this means that users can't trust what they're reading. Business owners can't rely on these platforms, so they can't build content businesses or they can't be developers that are building third party plugins that are on top of a tech platform. And you can't integrate, you can't trust other sites that you integrate.
00:06:10.079 - 00:07:01.695, Speaker B: This really limits the amount of that different companies can collaborate with each other. And I think the most important thing is that it forces centralized ownership over tech companies since there's this centralized point of control, which whoever controls this server is able to manipulate data and basically control all the rules of the entire platform. That is a centralizing force that requires centralized companies to operate software that we use on the Internet. And that is a huge vulnerability. And when we are able to solve these problems, we can then unlock a whole new way of building software. We can unlock new forms of permissionless collaboration, we can have daos build software and we can finance software development with DeFi. There's a lot of really amazing things that are going to open up if we solve these problems.
00:07:01.695 - 00:07:42.325, Speaker B: How would we do this? Well, one way to solve these problems is that we could rewrite the entire Internet from scratch. Like everything on the Internet. We can use these new, whatever the latest cool developer tool in the web 3World is, a few people have used it, they think it's kind of good, but largely invalidated. And all these people who choose different technologies for all their different web applications, we can say you're wrong, you shouldn't choose that technology. Instead you should use this library that this 19 year old made and went viral on X. Like, that's obviously not. This is a horrible plan.
00:07:42.325 - 00:08:05.959, Speaker B: This is not the plan. We cannot really, I mean, you know, like, yeah, we can't do it. Exactly. This is not the way to do it. We should enable people to use the tools that they want. Now there is going to be a lot of new tools that emerge that are going to be great. But if we want to get the entire Internet to be verified, then we're going to need to come up with a better idea.
00:08:05.959 - 00:08:52.401, Speaker B: So, okay, what about ZK tls? Some people might think of this, like ZK TLS is something that has been known as a way to take web true data and bring it into web 3 and make it verifiable. ZK TLS is really, really cool and these teams are awesome that are working on it. But this doesn't solve the problems that I mentioned. It doesn't add security to the underlying apps that the data that's being accessed. What it does is it improves the chain of custody. So if you use ZKTLS and you talk to GitHub to get someone's username and you bring that on chain, what that's doing is it's making sure that the people taking the data from GitHub server and putting it on chain did not modify that data. And they're being honest.
00:08:52.401 - 00:09:33.275, Speaker B: And it also does some really cool stuff to preserve the privacy of the user who authenticated to prove that they own that username. It's a very cool technology. It's something that we will utilize, but it is not going to solve the actual problem of GitHub and Microsoft, the company that owns GitHub. It doesn't solve the problem of them updating the database to change someone's username or to ban a user, or to change the rules of how ownership of repositories works. For that, we need to actually verify the software that's running on GitHub's servers. Now, if you're still thinking about what is the solution, how do we make the Internet verifiable?
00:09:34.095 - 00:09:35.087, Speaker A: One of the.
00:09:35.271 - 00:09:36.287, Speaker B: Yeah, go ahead.
00:09:36.471 - 00:09:42.635, Speaker A: Ask for people who aren't familiar about what ZK TLS is like, what's the TLDR on what that does?
00:09:43.895 - 00:10:50.671, Speaker B: Yeah, kind of like what I was saying is that ZK TLS is something that will authenticate that you talked to a server with the appropriate certificate. So that it shows that when you present that data on chain, you also have a proof that you actually retrieve that data from the centralized server that you expect to. So after it leaves the server, that data is secure. It's unaltered, like a proof that that was what was presented. But there's no guarantee about the underlying Data from the Web2style app that was presented that can be completely manipulated and you can just have a proof that that's really what they sent you. But that doesn't enforce that any of these problems that we were talking about, any of these problems manipulating the database, it doesn't prevent any of that. The GitHub can still do whatever they want and including they could potentially use that as an attack vector against on chain applications using ZK TLS by saying one thing for zktls and then changing it later and then messing it up.
00:10:50.671 - 00:10:58.937, Speaker B: And you need to have mechanisms for that. Which I'm not saying zktls is bad. I'm saying ZK TLS doesn't solve this problem.
00:10:59.081 - 00:11:06.673, Speaker A: It sounds like there's still a lot of centralized trust that you have to place. Like you have to trust a lot of centralized authorities for this.
00:11:06.729 - 00:11:25.205, Speaker B: Yeah, exactly. This problem is completely unsolved up until now. A centralized server, like for example, if people are watching this on X.com, x can put any data. They can post anything from our account. They can. They can update our follower list, they can ban us, they can change the rules of the algorithm.
00:11:25.205 - 00:11:36.357, Speaker B: They can do everything. There's nothing. They own it, it's centralized and there's nothing that we can do about it at all. We can't detect it, we can't prevent it, we can't bypass it. Does that make sense?
00:11:36.461 - 00:11:37.581, Speaker A: Yeah. Thank you.
00:11:37.773 - 00:11:50.709, Speaker B: Yeah. Cool. So, okay, so we can't. So to solve this problem, we can't rewrite everything from scratch. That's just not realistic. We cannot. I mean, ZK TLS is great, we should use it.
00:11:50.709 - 00:12:30.455, Speaker B: But this does not solve that problem. It solves a different problem, which is a good problem. So what if we used ZK proofs or other types of proofs on the server? What if we actually prove the computation running on the server? This is a good idea. So let's look into how this might work. So the user makes a request to the server, and then the server runs a ZK vm and the ZK VM will. Inside the ZK vm, it'll run two pieces. One would be the request handler, which would be just a function of code that executes when that request comes in.
00:12:30.455 - 00:13:08.239, Speaker B: And then the other thing would be the database. So you can think about the database as like, let's say I post something new on x.com I post some update. The database did not have that post in the database before I made that request, but I send that request to post that new data, and then it adds it to the database. And now the database has been updated. So before the request there was what you can call the initial state, and after the request there is what you can call like the final state or the next state. This is what's called a state transition function.
00:13:08.239 - 00:14:03.187, Speaker B: You have a function that, given the previous state of the database and the new data coming in from the new request, you have the new state, which is the new state of the database. I know that might be a little bit technical and a little bit dense, but this is essentially how roll ups work. We can use this exact same architecture on the server. Just to be clear, you send the request in, it runs this request handler, it accesses the original data from the and then updates the database, and then it can send a response to your browser or to your application with the proof that the response is correctly generated by the request that you sent. And it can update the next state for the next request that comes in so that you can use that state when you're handling that next request. And this is a really great pattern and this will work. But there is a problem with this.
00:14:03.187 - 00:14:44.131, Speaker B: The problem is that we don't know what the. What the previous state must be, because, I mean, it's a little bit. We don't need to go into all the details, but basically we don't have consensus over what's in the database. If we just use ZK proofs on the server. We don't know what the old state of the database is. So when we have that incoming request, we can't, we can prove that there was some state in the database that we used against the incoming request, but we can't prove that that was the canonical official prior state when generating the new state. So how do we solve this? Data availability layers, that's what solves this.
00:14:44.131 - 00:15:28.919, Speaker B: So we are going to focus on Celestia for the rest of this presentation. So how does data availability fix this? Well, the truth is a bit of an oversimplification. So I want to kind of go a little bit more in detail just to give you. I want to show you the exact place of the infrastructure where the DA layer actually adds verification. So the way I like to think about the Internet a little bit more in depth is that there's a user and the user is connected to an Internet service provider. So in the United states, there's Verizon, ATT, Comcast, etc. These are Internet service providers and they bring Internet to your home.
00:15:28.919 - 00:16:50.665, Speaker B: And so what happens is you connect to your Internet service provider and then there's many different Internet service providers and all of these connect at what's called an Internet exchange point. And so this kind of aggregates a bunch of networks and this is where something like AWS would connect to. So when you are. So this is in a sense how an end user is connected to a data center with a server in it. So now also keep in mind there's many people with home Internet connections, so there's going to be a lot of individual users with slow connections, maybe 100Mbps or honestly much less than that sometimes. And these are all going to be connected to an Internet service provider which is going to aggregate all of these connections and it's going to go to like local nodes and they're going to have this backbone and essentially it's going to come from all these different homes and it's going to all go at some point into a single wire, more or less, or fiber optic cable going into an Internet exchange point. And then this Internet exchange point is going to have really like, I mean, I'm kind of simplifying, but basically a single wireless that's going into the data center, or at least you can say for sure the server is just going to have a single fiber optic cable going into it.
00:16:51.725 - 00:16:53.677, Speaker A: Wild way to think about it, honestly.
00:16:53.861 - 00:17:22.776, Speaker B: Yeah, it is. It's actually really interesting to learn about this stuff. Let's say you want to upload a picture of the Mona Lisa. How is this going to happen? What it doesn't do is it doesn't just send it all at once. Because if you can only send, technically, although it's very fast, you can only send one bit at a time. There's a little bit of nuance to that, but let's just pretend like that's true. You can only really send one bit at a time.
00:17:22.776 - 00:18:21.083, Speaker B: You can only read one bit at a time out of into your computer from a fiber optic cable. So what it does is you have all these people that are using the Internet at the same time, and yet when they all connect to the data center, they're essentially it's all going through like a few cables. So how does that happen? Well, what it does is it breaks the data into packets, so it'll break up this picture into smaller chunks and then it's going to route these packets across this infrastructure and the order can get mixed up. There's no guarantee that it gets delivered. Sometimes packets get dropped and there's all these types of unreliability that you have. But what happens though is that at some point these packets go directly into the server and there's just like this fiber optic cable going into the server and that server is reading one bit at a time. And it's just really quickly doing it because it's a very fast connection.
00:18:21.083 - 00:18:59.475, Speaker B: But then it gets this packet and then it gets this packet and then it eventually gets the whole picture. And so there is, at this end point, there's this sequential, canonical, single lane highway of data. There's a specific order of when that data came in, and that is kind of like at the tail end of this flow. And that's not to say this whole thing is like a first in, first out queue. This is not a reliable system. But there is a canonical order of bits that came into the server that's running the software. That's just how it works.
00:18:59.475 - 00:19:33.829, Speaker B: And so, and like that is essentially the ultimate bottleneck for the application is the connection going into it. And there are other bottlenecks. And for the user, the bottleneck would be how much data they can bring into their home. Usually that's much less than what the server has, although it could be more. And so like this right here is essentially what DA layer is making verifiable. It's saying like, it's running on top of the Internet. It's not part of the Internet infrastructure.
00:19:33.829 - 00:20:55.001, Speaker B: But you should think about this as a bandwidth Verification tool, something that says this is the order that the bits came through and as we send them to the server for computation, if we go back to our problem where we were saying, well, we don't know what the previous state should be, how do we know what the data should be in the database? How can we trust the proof if we don't know that that previous database's data is correct? Well, the answer is if we can use Celestia to very efficiently understand what was the, all the data that was sent through what was the correct list, then we can use the proof to prove that the database state that we were using for our state transition function was actually the correct database state. And in so doing we are, by verifying Celestia, we can use that in conjunction with a proof to prove that the entire thing is accurate. And this is how roll ups work. But this also works just in general. And notice I didn't talk about any libraries or frameworks or anything like that. This is just in general how you can verify software on the Internet. And I'll stop there for a second.
00:20:55.001 - 00:20:56.521, Speaker B: Do you have any questions?
00:20:56.593 - 00:21:02.073, Speaker A: Yeah, I don't have any questions right now. There aren't any in the chat, so I'm going to let you roll with it.
00:21:02.209 - 00:21:42.075, Speaker B: Awesome. So, okay, so now let's put all this together. When you put all this together, we have, this is everything that we need for a fully verifiable Internet. Like we have the DA layer checking all the incoming traffic, verifying all the incoming traffic and putting it in order. And then we have proofs that once the traffic comes in, we are proving that this was handled properly. And when you combine this with several other problems or solutions that are already solved, like digital signatures and bridging and ZK tls, which is also a very useful thing. If you wanted to have a verifiable application, talk to a non verifiable application.
00:21:42.075 - 00:22:22.985, Speaker B: That's the best bet that you have. So if you combine all these things, you can imagine basically having an entirely verifiable Internet. You can imagine having a data center that's world class, that can host. I mean, you don't think that you're going to exhaust the resources of aws. You just go and you host your app. You're not going to exhaust the resources of aws. So you can imagine for the people that demand verifiable applications that they would be able to do it affordably and have viable businesses and basically make software that is verifiable and affordable and works and is interoperable with crypto.
00:22:22.985 - 00:23:07.085, Speaker B: So this is what I think we should have for the entire Internet. Just like as we adopted HTTPs, where you're validating the certificate of the server that you're talking to, we can take that a step further. And if we have a very good developer experience, we make this easy, we build this into the infrastructure, at least as an option, we can have a whole bunch of adoption on this. So now. But is that realistic? Is it realistic to verify a giant portion of the Internet? Is that something that we can actually do? Yes, I think it's really. Let's do it. Yeah.
00:23:07.085 - 00:23:36.313, Speaker B: We do not back down from a challenge. Exactly. So, okay, like, let's, like, let's, let's think about this. Okay, so ZK proofs are currently 100,000 times more expensive than normal computation. Last time I checked, that's really expensive that we obviously can't just do everything that we normally do as a ZK proof. That's not going to, we're not there yet. Now there are other techniques of proving that are not ZK proofs.
00:23:36.313 - 00:24:27.503, Speaker B: Like we can use fraud proofs, we can use actively validated services, we can use Comment, bft, all these types of things. There's a lot of techniques that will add either a lot of security or just some security, depending on your needs, that can replace ZK proofs, which are still more expensive than normal computation. But they're much, they're in the same order of magnitude, roughly, or maybe just a little bit more expensive. But ZK proofs are by far way too expensive to be used at scale right now. But they are the holy grail because they are very efficient and they are very secure. But let's think about these numbers for a sec. So first of all, people already operate high margin software businesses.
00:24:27.503 - 00:25:13.765, Speaker B: So like, easily, easily. I mean, COMPUTE is honestly less than 10% of total expenses. But let's just conservatively say compute is 10% of your total expenses as a software business. That means you actually have a decent margin that even if compute was 10 times more expensive, your business could still be viable potentially. And then like people have 10% have, you know, 90% margins on serverless platforms, and these serverless platforms are like 10x more expensive than bare metal. So if you kind of look at this, you can kind of see how the there is like this giant software margin that is there that could be there. Like, I think a lot of stuff would still be viable even if the underlying cost was 100 times more expensive.
00:25:13.765 - 00:25:45.965, Speaker B: The other thing, which I think this is like a Much less good assumption. But I just put it in there because these other ones I think are actually conservative. Like not everything needs to be proven. Mostly it's just state updates. And it's hard to what the ratio of state updates to reading data is. But you could optimistically think you can get another 10x just from not proving everything, just proving the things that you need, need to. So if we're already doing, we're already doing the computation that we're doing.
00:25:45.965 - 00:26:31.851, Speaker B: But there's already. And we need to, right now we don't want to pay 100,000 times more than we currently are to do what we do, but we do kind of have this 1000x margin to work with. So maybe if it was, if we could just do things 100 times more efficiently that might actually be viable to bring most, to prove most computations. And so what? So I think like, so within one decade, like Moore's law will deliver us those types of scaling results. But I also think we have such good teams working on this succinct risk zero. I mean so many other like proverb networks and ZKVM teams and engineers work. I mean there's hardware, there's teams doing hardware acceleration for ZK proofs.
00:26:31.851 - 00:26:48.103, Speaker B: I mean I couldn't be more bullish. I think we're going to get massive amounts of scaling just from the engineering side. And yeah, so I'm very bullish on being able to do this in the foreseeable future to be able to do ZK proofs on anything that you want to at a good cost.
00:26:48.279 - 00:26:50.311, Speaker A: I like the way you broke that down a lot.
00:26:50.503 - 00:26:50.887, Speaker B: Thank you.
00:26:50.911 - 00:26:51.595, Speaker A: Thank you.
00:26:52.175 - 00:27:33.711, Speaker B: So okay, now what about Celestia? Celestia has a little bit bigger of a challenge than Z because Celestia needs to scale 1 million times to match a modern data center. And so like, so celestia has about 1Mbps of bandwidth. It might be a little higher now. And then data centers have at least 1 terabit per second. Like a big one will have 50 terabits per second or something, maybe at most 100, but a small one would have 1 terabit per second. And I think it's safe to say, like, if we could have like, I'm talking about a small, like a real legit data center. If we could have a whole data center that's verifiable.
00:27:33.711 - 00:28:10.701, Speaker B: Like you don't think you're going to go on like some, you don't think you're going to exhaust the resources of fly IO or something? Right. You're not going to like. There's plenty of. There's plenty of bandwidth there to be had. So I think 1 TB is a really good target for what we should try to scale to. And so, okay, so can Celestia scale a million times? I mean, I feel ridiculous saying that they could, but actually, let's look at this. So first of all, Celestia has already delivered a 1000x improvement to Manta.
00:28:10.701 - 00:28:36.833, Speaker B: Manta was the first roll up to launch on Celestia, and they've already delivered a 1000x improvement over Ethereum. Now, that cost calculation is a little bit more complicated. It has to do with computer compute cost, not just bandwidth, et cetera. But it's already happened. 1000x is not a crazy. Is not an impossible thing to deliver. The next thing I'll say is that Celestia's current roadmap is a thousand.
00:28:36.833 - 00:29:05.865, Speaker B: It has a 1000x increase. So we can get from a megabit per second speed to a gigabit per second speed. And that's just on the. That's just the current plan. And maybe you can correct me if I'm wrong, Josh, but I mean, talking to people in the Celestia team, I think this can go above A. Above 1 gigabyte blocks every 2 seconds, which is what I believe is the current target for the roadmap. That's kind of an arbitrary stopping place.
00:29:05.865 - 00:29:44.533, Speaker B: So I think that even with the current techniques, the current plans, I think it could go higher than that. But it's certainly true that as you approach 1 terabit per second, it gets a little ridiculous. A gigabit per second is. I've been thinking about the engineering of this and a terabit per second is really hard. So I'm not saying that that's an easily solvable problem, but I think that over time we can get there. And with good engineering, as we've been doing, I think that this is possible. And the only other thing I will say on this is that we only need to verify the writes, not the reads.
00:29:44.533 - 00:30:34.261, Speaker B: So a lot of the bandwidth is for reading, not writing. And so again, like, I think 1 TB goes a lot further than you think, and 1 gigabit per second goes a lot further than you think for this type of architecture. So, okay, so like, and last, in this section, I just want to kind of mention this quote that someone posted on X and I forgot who posted it. I would give them credit, but this reminded me of this quote by Alan Kay says people who are really serious about software should make their own hardware. And I really kind of am starting to think of Celestia as almost a deep in network. And Celestia is not building hardware. It's not like, yeah, no, they're not building hardware.
00:30:34.261 - 00:31:08.005, Speaker B: They're not actually doing deepen. But the logical conclusion is that people would, if we were to follow this architecture, to make a verifiable Internet and verifiable data centers, the logical conclusion is that we would. It would be very difficult to run a full node, a block producer, and that would be a highly professionalized thing which would actually have physical infrastructure that would need to be spun up in order to support this. And of course it can be verified at home with light notes, which is the great part. So I think that's a really interesting perspective.
00:31:09.145 - 00:31:22.205, Speaker A: And so I would say in that case you're going to kind of put all of the nodes are going to be on the user end, like on the client side, so you can just verify things yourself.
00:31:22.625 - 00:31:24.641, Speaker B: Yeah, yeah, right.
00:31:24.673 - 00:31:37.485, Speaker A: It's very important. Like a terabyte is definitely not out of the question because with light node optimizations, like engineering optimizations for how blocks are made and things like that, I think it's definitely possible one day.
00:31:37.565 - 00:32:02.885, Speaker B: Yeah, yeah, yeah. And I think it's really important to hit that point. It's a great point. People will be running light nodes so they don't have to trust the people that are producing the blocks. There are going to be big companies that can process a lot of bandwidth with specialized compute hardware that are going to be running this next gen data center. They might also be running provers alongside celestial nodes. I mean, who knows the kind of stuff they'll be up to.
00:32:02.885 - 00:32:23.125, Speaker B: But the thing is these will be professionals, will be very expensive, very, very expensive and it will be great service for people. But at home, users will be able to verify this with a light node. So they could do it on their phone, they can check what these big companies are doing on their little small device, which is really awesome.
00:32:23.555 - 00:33:00.475, Speaker A: I was actually, I want to toss into this like random fun fact. I was going through old notes that I came across this weekend and I had something from one of Mustafa's talks about how it's more like more likely that you have a photon hit your RAM and flip a bit than it is for you to get the wrong result from sampling 100 times. And I don't have the math like on hand to back that up, but I think that's something that blew my mind Then and just shows the power of the math here with data availability sampling.
00:33:01.095 - 00:33:26.557, Speaker B: Yeah, I mean if I recall correctly, like every time you sample that the odds of get of not finding the missing data are in half. They're cut in half. And so when you double things. So like basically your security doubles with every sample. That's one way of looking at it. Although maybe that's a bad way of looking at it. So yeah, when you, when you like double, double, double a hundred times, I mean like I think like 17 samples is like 99.999%.
00:33:26.557 - 00:33:33.501, Speaker B: If you keep doubling up to 100 times, you're going to get to an astronomically high amount of security. It's kind of ridiculous actually.
00:33:33.613 - 00:33:43.505, Speaker A: And then like we can wrap that up, I guess, but like it only would take 1, 2, 3, like around like 10 doublings to get from 2 megabyte blocks up to 1 gigabyte.
00:33:44.285 - 00:34:01.869, Speaker B: That's right, yeah. So it's very doable. I mean it's going to be really hard. It's going to be hard. It's going to be really hard. But it's doable and it's so worth doing. We're talking about providing the security that Ethereum and Bitcoin and these very secure established networks provide.
00:34:01.869 - 00:34:33.925, Speaker B: We're taking all the benefits of those systems, the reason we call those cryptocurrencies, taking that and giving that to all software on the Internet. And this also helps with interoperability and we can talk more about that later. But this is very worth doing. It's very worth doing. This is the end game. This, this is how I see things playing out. So I think over the next decade, because with, with Moore's law and Nielsen's law and all the engineering breakthroughs, I think we can maybe not have this all set up, but we can be well on our way to having built this over the next decade.
00:34:33.925 - 00:34:54.917, Speaker B: But, but you don't need to wait for the, for the whole Internet to be able to go on this type of an architecture and build software in this way to do it now. You can actually still build this stuff right now. So like this is an amazing vision. Will be great when everyone does it, but you can do it right now. So how.
00:34:55.021 - 00:34:55.573, Speaker A: Let's do it.
00:34:55.629 - 00:35:31.471, Speaker B: Well, Chopin framework, that's, this is what Showpan framework essentially does. In the previous explanation, I was talking more on this conceptual level, talking about TCP, IP as a level of abstraction for thinking about it. I don't know exactly how Celestia is going to turn out when it's scaled. I think a lot of smarter engineers than me are going to figure out the best ways of doing that. So I was just putting forth a potential vision for that. But with Chopin Framework, this is on a different level of abstraction. It's above that layer of tcpip, it's on the HTTP layer.
00:35:31.471 - 00:36:25.613, Speaker B: But essentially it takes that architecture that I just talked about and implements it on the HTTP layer, which is the layer that the web browser uses. And it's also the layer that like a mobile app would use when they do rest APIs in their backend and stuff like that. So this can power any sort of mobile app, this can power any sort of website. And what it does is it gives developers, first of all the same developer experience that they would have when they're building Web2 apps, as I've already mentioned earlier. And since it works natively in the browser, the user can just go on the website and start using it. We've used embedded wallets and other techniques to give the same user experience as well. You don't have to build your software any differently than you otherwise would when you are using Shopping Framework.
00:36:25.613 - 00:36:56.195, Speaker B: You just build a normal app, a normal web2 app with your favorite tools, whatever tool you like to use. And we're going to focus on next JS today. But you could use Ruby on Rails, you could use whatever you like. And security is the same as a blockchain. And we'll talk more about that and get into the details. Of course there are ways that you can have more or less secure versions of this, but this is a roll up architecture and this has full blockchain security. Now.
00:36:56.235 - 00:37:00.485, Speaker A: You don't even need to think about it like a roll up though, right? I think that's the really cool part for me.
00:37:00.595 - 00:37:25.217, Speaker B: Yes, yes. And this, this could be, you could run this as an L1. The architecture works as an L1. But the cool thing about having this be a roll up is that you get to inherit the security of a super secure blockchain like Celestia. So that's a huge, a huge bonus. And yeah, and a super scalable one too. So, okay, so, so okay, let's just walk through how this works.
00:37:25.217 - 00:37:42.813, Speaker B: So like a user is on the web browser. You're on a web browser right, right now watching this or mobile app. But let's say you're on a web browser and you go to example.com and so example.com is using Chopin framework. And so as we discussed, there's a server. So you're connecting to the server and you're doing a GET request.
00:37:42.813 - 00:38:03.035, Speaker B: This is a type of HTCP request. This is what happens whenever you visit example.com in your browser. It does, under the hood, there's an HTTP request that does a GET request. That's how it works. That GET request returns you the webpage that you just loaded. That's how it works when we do this.
00:38:03.035 - 00:38:40.335, Speaker B: From the perspective of Chopin frameworks, this is almost like querying the state of an application. If you're doing an RPC call and you're trying to get your balance, that's querying the state. That's similar to doing a GET request to an HTTP server. You're querying the state. If there's a list of of posts on there, on that page, it's going to be pulling from the state of the application, which has a database of posts, and it's going to be returning that on the page. And so that's what you do when you do a GET request. But let's imagine for a second that this is the first time that you've visited example.com
00:38:40.335 - 00:39:17.717, Speaker B: so in this case, what it's going to do is it's not only going to return you the web page, it's also going to return you a script that runs what's called a service worker. And a service worker is built into the browser. It's a feature that's in the web standard. So it's built into every single browser. And there's a script that's going to run inside of the service worker. And what this does is it bootstraps a wallet. What a service worker does is you should think about it as like a guard that stands on the edge of your browser between you and the server.
00:39:17.717 - 00:39:40.109, Speaker B: And every time before you send a request to the server, the guard says stop. And the guard can do whatever you want. The guard isn't charged. And so the guard can say, go on. You can go and talk to the server, or they can say, stop. You have to return with this message instead of what the server said, the guard is in control. So we injected the service worker into the browser.
00:39:40.109 - 00:40:32.433, Speaker B: And what this does is it catches the outgoing request. And if it's a post request or you're trying, or a request that mutates the state of the database, it serializes it and it signs it and it attaches the signature to the header. So I have this here. So you make a post request, it's intercepted by the service worker, it's signed, and then it's sent to the service. So every request coming to your server now has a signature. And now as from that basis, you can now authenticate your users with private key cryptography or public key cryptography. So you can kind of think of like the user's address as their user id.
00:40:32.433 - 00:41:05.143, Speaker B: And you have a signature on every single thing that they do, verifying cryptographically that they didn't. So that's kind of the, that's the basis of how people interact with these. And you can also, for example, use the API by just creating your own signature and putting it in a header and using the REST API. You don't have to go through the browser, but this will work in the browser and give users the exact same user experience that they would otherwise enjoy. So, but that's not all. This is actually again, an oversimplification of what's actually happening really. There's another layer and this is the sequencer and it's middleware.
00:41:05.143 - 00:42:14.079, Speaker B: So this sits in the cloud, this sits before you get to the server, there's this middleware that intercepts the traffic. It's in another guard, except the guard is out instead of outside of your browser, the guard is outside of the server. What this does is it just makes sure that you don't send in multiple requests at the same time. You execute each request in a sequence and this ensures that the result can be replicated every time because you're not going to have data races and there are optimizations where we could have it, where you don't do it this way, it's just going to take more engineering. This does have a slight scalability trade off, but we won't get into that for now. Basically, this collects all the incoming requests, runs one at a time, and it connects to Celestia and puts the signed requests on the blockchain. And so this, so you have now an ordered list of every single request coming into the web server stored on Celestia.
00:42:14.079 - 00:42:49.373, Speaker B: And so now think about it this way. So like if you had a list of every single request that came into your website ever, and you then executed each of those requests in the exact same order in the exact same way that you originally got it, you would then have the exact same data in your database. Now, there are some caveats. There's something called non determinism. Let's just like there are solutions for that. Let's just not talk about that for the state of this. The point is though, is that you of course, you deterministically resolve it.
00:42:49.373 - 00:43:22.937, Speaker B: You ideally have a proof that that's a correct resolution and you include that as context alongside the request. But if you hit. The point though is by putting this on Celestia, you're inherently making it verifiable. So someone can now run another version of your server and they can read from Celestia all the incoming data. And with that incoming data, they can then have a full node that fully verified everything that happened on that website. Just like you can run a Bitcoin full node and replay all the transactions, fully verify all the transactions in Bitcoin. It's the same concept.
00:43:22.937 - 00:43:36.325, Speaker B: This is called a pessimistic roll up. So I want to now do a live demo to show you what I'm talking about. Okay. I'm gonna switch screens really quick.
00:43:37.665 - 00:43:58.659, Speaker A: In the meantime, if you have questions and you're in the chat, please drop them there. If you're watching and you want to have some fun, drop in another L in the chat for Lazy Ledger. I'm getting your screen up right now. I see that. Nice. Here we are.
00:43:58.827 - 00:44:14.145, Speaker B: Okay, so I'm going to just show you. This is something that we have on our. On our website demo. Oh, wait, hold on, let me refresh the page. There's a tracker on it. So right now this is live. Yeah, this is live.
00:44:14.145 - 00:44:48.165, Speaker B: I'm going to go through a coding example, but what happened is right now it's getting signed. The embedded wall in the browser is signing it. What it first did was it optimistically updated the ui for some reason it sent it twice, but it optimistically updated the UI and it signed the request and then it took that request and it sent it to the server. That's the soft sequencer confirmation. Then that request is going to be sent to the DA layer by the sequence. Let's go and let's make our own version of this.
00:44:51.945 - 00:44:59.085, Speaker A: Once the da. Quick question. Once the DA layer confirms that, then it's finalized because it's been posted.
00:44:59.625 - 00:45:25.335, Speaker B: Exactly. Yes, exactly. That is a common pattern with rollups is you first get a soft confirmation from the sequencer, but then eventually that settles onto a blockchain and then you can have more security. But at least in the meantime, you can use the app as if everything was continuing on as normal. Unless the highly security sensitive situation. You want to wait. So you have that optionality here.
00:45:25.335 - 00:45:37.275, Speaker B: But I just wanted to point out, like in that demo, maybe I can go back to it for a sec. Like this, I just went on this website and I click send. That was.
00:45:37.315 - 00:45:38.971, Speaker A: You didn't have to log in or anything.
00:45:39.083 - 00:45:40.059, Speaker B: I didn't have to log in.
00:45:40.107 - 00:45:42.695, Speaker A: You don't have to download without knowing it, right?
00:45:42.995 - 00:46:10.985, Speaker B: Yes, exactly. It automatically generated this address. For me, this was all something I just had this experience and yeah, it was just like any web2app. I didn't have to install metamask or anything like that. So you can just have. In a sense, this is a really great authentication system because you automatically assign user IDs to users. It's almost easier than having to create an account.
00:46:10.985 - 00:46:29.705, Speaker B: Let me go back to. Let's build this. There's this repo. It's GitHub.com modular cloud,/chat demo. Chat slash demo. Yeah, you got it there.
00:46:29.705 - 00:46:46.365, Speaker B: Good. The main branch is used on the website, but there's this branch demo. I prepared this branch. The demo branch is. I took out Chopin Framework from this.
00:46:47.905 - 00:46:49.085, Speaker A: It's just like an.
00:46:51.145 - 00:47:05.257, Speaker B: Normal Next JS app. Just really quick. I'll just walk you around it. Oh, wait, no, not that. I'll just walk you around it really quick. There's a layout. It has jsx.
00:47:05.257 - 00:47:24.081, Speaker B: This is using React and you have a page. We're doing SQL queries to the database. It's loading a React child component. I'm going to. I'm not going to go too deep into this at this time. I'm just kind of showing you there's a few.
00:47:24.233 - 00:47:33.129, Speaker A: Start this up. It's basically just like a Next JS site. There's no embedded wallet or anything like that that you just went over.
00:47:33.177 - 00:47:46.625, Speaker B: Right, exactly. That's my point. My point is this is using SQL. This is hosted on Vercel. This is doing having. This is a normal Next JS app. Like if you follow the instructions and the docs for building a Next JS app, this is what you would have.
00:47:46.625 - 00:48:07.339, Speaker B: I have told people, build the Next JS app now, integrate Chopin Framework. And they built it. They didn't know what Chopin Framework was. They didn't know anything about blockchains. And then they used Chopin framework to add in the blockchain security. So I just want to be clear that this is the starting point. So we're not going to build this UI together because that's something that you can learn on your own time.
00:48:07.339 - 00:48:23.595, Speaker B: But if you know how to make apps in next year, or web apps in general, you'll be able to use Ship Hand framework. So. Okay, so now without further ado. Let me. Let me. Okay, what I wanted to do, let me do this. I'm going to fork this.
00:48:23.595 - 00:48:25.695, Speaker B: I think that's the easiest way to do this.
00:48:26.315 - 00:48:28.091, Speaker A: You maybe zoom in just a bit.
00:48:28.123 - 00:48:33.787, Speaker B: On a fork exists that's annoying. A fork exists already? Yeah. You want me to zoom in?
00:48:33.891 - 00:48:38.603, Speaker A: Same org? Yeah. Just like control command plus on the GitHub. Yeah.
00:48:38.699 - 00:48:40.387, Speaker B: Okay. Is that better? Can you read this?
00:48:40.451 - 00:48:41.215, Speaker A: Way better.
00:48:41.865 - 00:49:03.285, Speaker B: I can make this a little bigger here. I already have a fork, which is unfortunate. I will just make this fork on the ship and Framework. Org. Then I will say chat demo live. Now I'm going to uncheck this. Copy the main branch only because we want to use the demo branch.
00:49:03.285 - 00:49:38.417, Speaker B: Want to call that out? You could do just the main branch if you want, but that's not what we're doing here. It's forking now. I'm going to clone this locally. I'm going to copy this. I'm assuming you got to have a GitHub account for this, but I'm assuming that people do. I'm loading up a terminal. I'm just going to make like this bigger file exists.
00:49:38.417 - 00:49:41.565, Speaker B: Demo 2, how do I make this bigger?
00:49:41.985 - 00:49:43.497, Speaker A: Same command plus probably.
00:49:43.601 - 00:50:08.055, Speaker B: Yeah, okay. I'm just making a demo. I'm just making a directory to put this in and then I'm going to clone and you can use the GitHub however you like to prefer to clone GitHub. You can do it. This is how I do it. Okay, I'm cloning this. I'm going to now open this in cursor.
00:50:08.055 - 00:50:30.201, Speaker B: Let's see. Open a folder and then. I should have had this loaded up better. Demo 2 opening this. Cool. Here is this now. Terminal.
00:50:30.201 - 00:50:49.761, Speaker B: Open the terminal. So this requires all the dependencies of next JS to be installed. I think it's really just Node JS that's required to do that. But I also. If you have Nix package manager, you can just say nix shell here. Because I have. I'm using PNPM as a package manager.
00:50:49.761 - 00:51:38.187, Speaker B: You can use whatever you'd like, but I'm using PNPM as package manager. Node JS we're going to run this in a second, but let me first, let's get this set up on Vercel because I want to show you guys how to deploy this into production. I'm going to make a new site, new project. Then I'm going to do Chopin Framework chat demo live import. This is going to be hosting the sequencer, or rather it's actually a little bit complicated, but it's going to be hosting the server and the server will have a sequencer as the middleware. I'll show you how that works. For now, what I'm going to do is I'm Going to click deploy now.
00:51:38.187 - 00:51:59.915, Speaker B: I'm expecting an error here. The reason why I'm expecting an error is because this needs to have a database attached to it. And so without the database, it's not going to be able to store the messages in the chat. So we will just kind of have to. We will. Yeah. We're going to have to wait for this.
00:51:59.915 - 00:52:00.259, Speaker B: Just.
00:52:00.307 - 00:52:02.779, Speaker A: Did you just say chap, by the way? I like that.
00:52:02.827 - 00:52:03.723, Speaker B: Did I say chap?
00:52:03.819 - 00:52:06.707, Speaker A: I don't know. Chopin app or like, chat app.
00:52:06.731 - 00:52:19.247, Speaker B: I couldn't. Oh, that would be cool. No, I was saying chat. But that is a good. That's a really good one. Yeah. I'm trying to think if there's anything I can do to push this forward.
00:52:19.247 - 00:52:25.695, Speaker B: While we're waiting, do you have any questions this far into the process?
00:52:25.855 - 00:52:37.235, Speaker A: I guess you were a second ago. You're describing that when we're putting this up on Vercel, it is kind of like. It is a server and it's also the middleware.
00:52:37.855 - 00:52:39.151, Speaker B: Yeah, exactly.
00:52:39.263 - 00:52:43.435, Speaker A: I was going to ask about the middleware, but. Yeah, I'll let you keep going forward.
00:52:43.735 - 00:52:45.875, Speaker B: Yeah, exactly. There's middleware.
00:52:46.495 - 00:52:51.715, Speaker A: Middleware. Basically what we're adding to the app.
00:52:52.015 - 00:53:14.835, Speaker B: Yes, that's part of the process. Exactly. I'm going to walk you through that in just a second. As you see, there's an error here. This is expected. You could have input the environment variables beforehand, but I think it's easier to just do it after, actually, because there's two steps that are needed. First of all, you have to notice when you've deployed a Vercel, it's on the main branch.
00:53:14.835 - 00:53:44.211, Speaker B: We want to use the demo branch. I'm going to go into settings here, go to Git, and I'm going to say we're going to use the demo branch. That's one of the reasons why there's an error. Now, the other reason there's an error is because there's no environment variables. But actually, what I want to do is I want to go to storage. So this is. I wanted this to be built in a way, the easiest way possible.
00:53:44.211 - 00:53:54.535, Speaker B: I want to just use Vercel's built in postgres and have this work and be a verifiable web application that inherits security from Celestia.
00:53:56.245 - 00:54:06.525, Speaker A: Also Command plus, this site, too. We're doing more on here than I thought. Hopefully Vercel has a responsive. Yeah, there we go. Nice.
00:54:06.565 - 00:54:16.225, Speaker B: Yeah, perfect. Nice. Yeah, they're good. Okay, so postgres. So continue. I don't think this will Leak any private keys. But if it does, I'll shut it down.
00:54:16.225 - 00:54:26.559, Speaker B: Okay, so it's called. I'm just going to create it. This is very easy. Now I'm going to connect it. It's going to connect to this project that we just started.
00:54:26.687 - 00:54:27.367, Speaker A: Sweet.
00:54:27.511 - 00:54:56.131, Speaker B: Connect. Ok, so now it is connected. Now what I want to do is I also want to put this in the local environment. So I'm first going to do this command for cell link and it tells you this. So it's very straightforward. And the reason is because I want to bring these environment variables so our local version can also write the database. So what I'm going to do is.
00:54:56.131 - 00:55:18.295, Speaker B: Because I already have. I don't have Vercel installed because I just don't want to. I'm going to. You can do NPX if you use npm, but I'm going to say NPM DLX for Cell link. Or you could install developer dependency here. I guess what it means is. It just means that.
00:55:18.295 - 00:55:33.305, Speaker B: Sorry, I'm just filling this out. I selected it, found the thing that I've already set up the project and now it's linking it. So now it's pulling in the environment variables. I'm not going to open this file, but.
00:55:34.365 - 00:55:35.585, Speaker A: Yeah, you're good.
00:55:35.965 - 00:55:51.785, Speaker B: It's weird. Oh no. I have to pull it in the next step, but. Sorry. Anyway, DLX will download and execute without installing it. So if you have a command line tool, you don't need to actually install it. Same with npx.
00:55:51.785 - 00:56:08.245, Speaker B: Now I'm going to do this and I'm going to pull the environment variable. Ok, I'm not going. I'm hopefully not going to accidentally open this file. Oh no. Oh yeah. Ok. Dlx.
00:56:13.075 - 00:56:16.055, Speaker A: That helps me understand this command a lot more too. Thank you.
00:56:16.475 - 00:56:17.295, Speaker B: Yeah.
00:56:19.195 - 00:56:21.855, Speaker A: So the first thing you did was just link it to Vercel.
00:56:22.595 - 00:56:32.255, Speaker B: It's doing as it is now. Are you there? I think it lost connection.
00:56:32.715 - 00:56:41.065, Speaker A: Yeah, I got you. Your screen's still showing, but a little blurry. And I also don't know if it's me.
00:56:42.005 - 00:56:43.429, Speaker B: Can you hear me? Can you hear me now?
00:56:43.437 - 00:56:45.105, Speaker A: Yeah, I can hear you fine. Yeah.
00:56:46.885 - 00:56:48.705, Speaker B: Oh, interesting. Is it frozen?
00:56:49.525 - 00:56:55.165, Speaker A: It's just a little blurry. It's still moving. Yeah, we're coming back.
00:56:55.285 - 00:57:10.955, Speaker B: I don't now. Maybe my Internet somehow went out. Let me try this one more time. I think it's going to work this time. There we go. Created this file. This will have your environment variables in it.
00:57:10.955 - 00:57:23.755, Speaker B: Now we can just run this. Actually, let me go back to Vercel. For a sec. I want to run on Vercel because now we have everything set up.
00:57:24.495 - 00:57:26.195, Speaker A: It shouldn't fail on Vercel.
00:57:27.295 - 00:57:42.435, Speaker B: It should work for whatever reason. If I'm wrong about that, we can just do a go here on deployments. Create deployment. You can select the demo branch. Create deployment.
00:57:50.215 - 00:57:54.995, Speaker A: Shout out Vercel for making it so easy to launch websites databases.
00:57:56.995 - 00:58:05.051, Speaker B: I think though I haven't used Caldera and Conduit and stuff, but it seems like that's even easier if you think about it. They have just one page.
00:58:05.163 - 00:58:06.055, Speaker A: That's wild.
00:58:06.675 - 00:58:34.535, Speaker B: Yeah, props to them. Very cool teams doing roll ups as a service. While this is loading, we can actually just start working on the local version. Local version. What I'm going to do is I'm just going to run this. I didn't do anything. Install.
00:58:34.535 - 00:58:37.935, Speaker B: Got to install the dependencies.
00:58:38.435 - 00:58:39.335, Speaker A: Those are easy.
00:58:40.155 - 00:59:07.301, Speaker B: Yeah, they are. Now let's try it. Okay. I did a little bit of a hack here to get this ready for the integration. What I did is I hard coded the address. I'm also in the wrong. One sec, hold on.
00:59:07.301 - 00:59:33.099, Speaker B: I'm in the wrong branch. I didn't have to check out demo. Yeah, you didn't check out demo. I'm going to reinstall just in case. Now there's no Chopin framework in there. Now I'm going to run this. Now what I did was I hard coded this address.
00:59:33.099 - 00:59:56.239, Speaker B: This is Vitalik's address on the program. You're going to be posting as Vitalik in this demo. So let's just go on the. Let's go on the. Let's see if we can go on this production version. Let's visit. Okay.
00:59:56.239 - 01:00:14.671, Speaker B: So there's no chat messages yet. Now this is your address. It says it right here. Okay. It says hi. Now hopefully this works, but let's just try it. Okay.
01:00:14.671 - 01:00:40.565, Speaker B: Let's go to local host 3000. Okay. Hi. It's already there. Okay, this is cool. And if I were to post, since we don't have authentication implemented, it's going to post from the same address. But I'm just going to do.
01:00:40.565 - 01:00:52.429, Speaker B: Anyway, bye bye. This works. Now let me go switch back to. I hope it works. But again, live demos, you never know if it works.
01:00:52.477 - 01:00:55.505, Speaker A: But we'll hit a problem at some point. That's ok.
01:00:58.165 - 01:01:22.339, Speaker B: Did it not refresh some for some reason? For some reason. There we go. Okay, so there's like a thing that automatically pulls from your messages. I don't know. That's not necessarily working at this moment. Maybe it will start working later. But the point is it works.
01:01:22.339 - 01:02:04.021, Speaker B: We put the messages, we see the messages, they're in the database, they're pulled in here. Now what we want to do is this is a normal, this is a completely normal next JS application. What I want to do is I want to make this a Chapan Framework application. How I'm going to do this is I'm going to go on Chipan's website and I'm going to scroll down to here and I'm going to copy this instruction. Ok. So I'm going to just close this for now. We don't need to run it locally.
01:02:04.021 - 01:02:37.515, Speaker B: I'm going to use PNPM instead. I'm going to install these dependencies. Ok, they are installed. So now I'm going back to Shapan Framework's website. Now we need to create a middleware file. I'm going to copy this and I'm going to go here and I'm going to create a new file. Now I'm forgetting if middleware goes in the root directory, I think it goes in the root directory.
01:02:37.515 - 01:03:26.235, Speaker B: Okay. Okay, so now we've included the next JS middleware. Now this is what we were talking about in the presentation earlier about the sequencer that intercepts the requests, make sure that they execute in order and puts them on chain. So that's what this is when we import that. And then lastly we need to include this provider in the layout. The reason is that this is going to inject that service worker for the wallet and it's also going to provide a hook so that people are able to access what is the current logged in user's address.
01:03:28.375 - 01:03:34.235, Speaker A: Looks like pretty much every package I've used from NPM on a site like that.
01:03:34.695 - 01:04:19.991, Speaker B: Yes, I did things in even the weird, weird less optimal ways just to kind of try to make it very user friendly. Showcan provider. Ok, so I now have added the provider. Now ok, we have the, the basics. But since we actually are authenticating users and people are posting messages and we need to get their address associated with the message. Like in the database we're saying this person with this address posted this message. That's how the database is structured.
01:04:19.991 - 01:04:22.035, Speaker B: If you want to look at it, it's like.
01:04:24.415 - 01:04:26.235, Speaker A: You maybe make that wider.
01:04:26.655 - 01:04:28.035, Speaker B: Yeah. How do I do this?
01:04:28.535 - 01:04:35.131, Speaker A: Double click. The top bar would do it for the whole screen. Oh, usually. Never mind.
01:04:35.203 - 01:05:01.221, Speaker B: Oh, there we go. Yeah, there we go. So, yeah, so you're inserting into messages, you're saying the text and the timestamp and the address and you're posting that into the database. So now, right now the address is hard coded as Vitalik's address. Now this is obviously not what we want. So what we want is Cursor knows what we want. Get address.
01:05:01.221 - 01:05:14.825, Speaker B: Let's see. Right. It did it. Right. Okay. So we want to get the address of the current user and insert that into the database as the person who owns, you know, owns that message. Okay.
01:05:14.825 - 01:05:51.253, Speaker B: And also it's worth noting like you could for example have like a points in the database or tokens in the database. You can have any sort of value. It doesn't have to be messages. Messages is just a fun demo and then that would be like a verifiable state that could eventually be bridged into another application. It could be a token that's traded. So all you'd have to do is basically create a token table in the database and that would be how you can create your token. And so now, okay, so we have this action that will insert messages.
01:05:51.253 - 01:06:15.065, Speaker B: And now I want to go to the page because we also need to read the list of messages. Sorry, not the page, but this component, tsx. So in this there is also. Yeah, hard coded address. So we're claiming that we're Vitalik in here. So that's not going to fly. I'm going to say.
01:06:15.065 - 01:06:51.259, Speaker B: I think it's use address. Use address. I don't know why it's not auto completing but I'm just going to anyway I'm going to react. Cursor could do better. I believe if I recall this is everything that I needed in order to get this to work. I'm going to try it, but I don't guarantee that it works. Let's see, let's see.
01:06:51.387 - 01:06:52.899, Speaker A: Only one way to find out now.
01:06:53.027 - 01:07:16.551, Speaker B: Yeah, no error. So far so good. Now let's switch over to local hosts. I don't even remember which one is local host. This is local host. Ok that's funny. Ok so now it's saying oh you're not Vitalik.
01:07:16.551 - 01:07:28.875, Speaker B: It's not matching this with our. So it knows this is not our address. This is a good sign. Let's go over here. This is our address. 3A, blah blah blah. So let's see if it works.
01:07:28.875 - 01:07:56.255, Speaker B: No it's not. Okay. No it's not Vitalik. Okay, so far so good. So right now what it's done is it's signed it and I don't know when the signing is done. I don't have the live tracker on here to say when it has moved on to the next step. But it should have been signing or is currently signing in the background, this request and then it is sent to the.
01:07:56.255 - 01:08:16.221, Speaker B: The middleware and then there shouldn't be a lot of. Yes, it is. That's funny. There's a bit of a lag sometimes being signed. So that's why for the chat application, the way that I have it, I don't have the hyper. The. I have a slower way of signing, which there is a faster way.
01:08:16.221 - 01:08:36.897, Speaker B: I'm just doing the slower way for the demo. Okay, but no, yeah, of course, yeah, but yeah. So anyway, I sent this message. So it's gone to the middleware and now it's gone and executed the function handler and it has updated the database. I hope it's going to refresh just to double check. Yeah, okay. So it's definitely there.
01:08:36.897 - 01:08:49.138, Speaker B: But as you saw, that was an instantly responsive UI because we use optimistic updates and then we were able to handle everything in the background. And you saw this. I just spun up this website.
01:08:49.256 - 01:08:49.954, Speaker A: Yeah.
01:08:50.374 - 01:09:26.276, Speaker B: And it's. I didn't have to install anything, I don't have any extensions, I'm not using any extensions or anything. So it just works. But what you could do is you could hook it up to MetaMask or other wallets if you want that level of security which users deserve to be able to choose. So just to finish up this demo. Let me see. I want to go back to Vercel for a second and I just want to say that right now you need to get an API key in order to use the sequencer.
01:09:26.276 - 01:10:21.287, Speaker B: So the local host version, if you use this in local host, it will work because it doesn't need it. For local host, we do a different thing where we route the request locally and it doesn't put the data on chain on the local host. But in production, when you actually have a domain that is running on a website like the this is our website, in this case, it's not going to work unless you have an API key. I'm going to release this publicly available in the next week or two. But in the meantime, if you want to do this in production, not locally in production, you need to just get in contact with me and I'll send you an API key. I can tell you where to do that later, but I'm just going to do this as an example. I'm just going to link shared environment, variable sequencer, sequencer, secret set link, and then I won't.
01:10:21.287 - 01:10:33.959, Speaker B: Just for the sake of time, I'm not going to actually wait for this to deploy and show it live, but basically you just redeploy it with the new secret and that is what it takes to.
01:10:34.007 - 01:10:35.075, Speaker A: Did you press it?
01:10:35.905 - 01:10:42.513, Speaker B: I didn't need to. I just needed to update the environment variable. I linked it so that I wouldn't expose what it is.
01:10:42.569 - 01:10:43.325, Speaker A: Makes sense.
01:10:44.145 - 01:11:07.375, Speaker B: Just get in contact with me. I'll provide that details at the end. If you want to run this in production right now, but otherwise very soon you'll be able to easily do it without getting in contact with me. That was the demo. Now I want to go back to the presentation just to kind of like summarize what we've seen and do some final thoughts.
01:11:08.595 - 01:11:31.745, Speaker A: I'm going to ask what's the next thing that you'd like to see built with this? I guess you just pushed an update to the chat demo. So if I go on, once it's been built and I go try that out, it's going to go. It's going to actually give me a new address for the browser that I'm on. Right. And it'll send a message. Obviously not as Vitalik. It'll send it as my new address.
01:11:31.745 - 01:11:33.785, Speaker A: And you'll see that on your end too.
01:11:35.125 - 01:11:56.965, Speaker B: Yes, but it won't if, if you don't have it set up with the same database. Unless you're running a validating node, which I did not show you how to do. Yeah, you're not going to. If you create a new database, you're not running a validating node that's like connecting Celestium, replaying the transactions, then you're not going to. Then if you do your version with your Vercel database, that's going to be a separate instance.
01:11:57.075 - 01:11:57.801, Speaker A: Yeah.
01:11:57.993 - 01:11:59.441, Speaker B: So. But yes, you can.
01:11:59.473 - 01:12:04.825, Speaker A: Oh no, I was just asking. I found your. The Vercel site while you were doing it. Oh yeah, that one will be updated.
01:12:04.905 - 01:12:08.553, Speaker B: Yeah. Cool. Yes, that should. That should work probably by now. It probably works.
01:12:08.649 - 01:12:09.841, Speaker A: Nice. That's awesome.
01:12:09.873 - 01:12:23.573, Speaker B: But yeah, I mean. Yeah, and you saw it local too. So. Okay, so yeah, go ahead and mess around with that. So, okay. Does this replace smart contracts? I think this is one thing that a lot of people wonder. I say actually yes, in a lot of cases it does.
01:12:23.573 - 01:13:09.525, Speaker B: I say this is a better way of building consumer facing applications. Anything with a ui, it's better than a smart contract. And the reason is I like to relate solidity to C. It used to be that people would use these low level languages like C to build software and when they did this, they directly wrote to the memory of the computer that they were running on. And it ended up being that this was a very buggy way, a very dangerous way. You could, even the best programmers messed this up and they would cause security vulnerabilities in their software or they would just make it crash unnecessarily. And it was just also an unneeded, it just made it less accessible to build apps.
01:13:09.525 - 01:13:48.115, Speaker B: And that's how people used to build consumer applications. And I like to think of solidity in the same way, except instead of writing to memory, it's writing to Global State. Ethereum is an incredible big global, highly secure, highly decentralized state machine. And the state that it stores, if you can write a solidity smart contract and you can write directly to that global state, it's actually amazing. But with great power comes great responsibility. And as you see this is how software has evolved. People do less low level programming now.
01:13:48.115 - 01:14:24.925, Speaker B: And when you're building an application you're doing stuff in JavaScript as the VM. And I mean that, I mean like you know there's a runtime that that's embedded in. I mean I don't like people could have like a VM in Rust and they're not directly doing memory management or whatever but at some level somebody is, at some level somebody's writing low level code and they're directly writing to memory. But that's just not the level at which people build consumer facing applications. And so I say you should not be directly writing to Global State unless you know what you're doing. Unless you're building blockchain infrastructure, you should not. That's not what an app developer should do.
01:14:24.925 - 01:14:50.463, Speaker B: Someone making a consumer facing application. You're much better off using our software that is built to connect to the blockchain than rolling out your own. Don't roll your own unless you know what you're doing, then go ahead. But like that should not be the default. So solidity is not going away. Solidity is extremely important, more important than ever. It's going to play such a huge role, Ethereum is going to play such a huge role in the future.
01:14:50.463 - 01:15:22.525, Speaker B: But for consumer facing applications, it's not the way that you should build them is not to just go and use solidity. That's what I would say about that. And also I just wanted to say like some people think, oh, chopin framework converts web2apps to web3apps. It's such a gimmick, it's fun, it's just a joke. It's haha. No, I mean this is, I would argue this is the optimal way to build applications because you can use the tools that have already been vetted in the tech industry as the best ones for using consumer applications. And then we're just applying the blockchain cryptography to it to give it the security.
01:15:22.525 - 01:16:02.225, Speaker B: So, okay, but now what are the downsides? Because I've been talking a big game. What are the downsides? First of all, if you're trying to migrate your next JS app or other web app to this, the authentication might become a problem. Not a big problem, but a small problem because you're going to have to potentially refactor the application to use our get address function. You probably have a password, username and password system. If you're building from scratch, what we offer is great. But if you already have username and password, you're going to have to rip that out because you don't want to send passwords on chain. And it's not going to even work if you do.
01:16:02.225 - 01:16:23.759, Speaker B: You need to use private key. You need to use private keys to sign transactions. So that's going to require a little bit of work. It's not flawless and it's not seamless. The other thing is that we don't have privacy figured out yet. I mean, we're working on it. I do believe we're going to be able to have private applications using this, but there's some engineering that needs to be done on that front.
01:16:23.759 - 01:16:55.765, Speaker B: And just like keep in mind, like private messages in such an app, unless you're using client side encryption, which would work by the way, if you want to roll that yourself, they're not going to be private like this. Everything posted is public information. Just keep that in mind. Don't get your users to have a private diary web app on chain that everyone can read. Just be mindful. You might need to re architect things and rethink things. The other thing is, for now, until we have done more engineering, this is going to affect your app's scalability.
01:16:55.765 - 01:17:31.215, Speaker B: But what I would say is I really welcome people to make an app in this way, make it a huge success and then try to scale it and collaborate on actually building out the infrastructure and tools needed to scale this. I will absolutely work with you if you run into this problem. And I think lots of people would be excited too as well. So it's honestly an opportunity. There's so much space here. I mean, I can't build all this myself, so there's so much space for someone to actually come up with a scaling solution and offer that as a protocol or a product. Or a service.
01:17:31.215 - 01:18:27.031, Speaker B: So you might even be discovering a new business model by just pushing this to the boundaries. I mean, not being able to scale is a good problem to have. That means you have users and this allows you to get started quickly, build apps, iterate fast and it is scalable. It's just there is a scaling impact that this has compared to not other blockchains per se, but compared to hosting it on Vercel without any sort of verification or blockchain requirements. The last thing I'll say is that we talk about all the amazing security that you inherit and there's an asterisk that we need to add to that. You do inherit it if you run a full node and that is very annoying and nobody wants to do that. So there's a thing called light client verification which uses Celestia light nodes and proofs and all this stuff.
01:18:27.031 - 01:18:53.261, Speaker B: And we are still working on that right now. It's not like you have this effortless, everything's verifiable, everything's 100% secure. This is early. We're early on this idea. I'm just talking about architecture here and a basic release of a proof of concept. So there's no light client verification and as a result the bridging is still in progress too. So there will be interoperability with broader crypto.
01:18:53.261 - 01:19:10.375, Speaker B: You will be able to transfer your tokens in the database out to some defi protocol. You can do that in the future. It's technically possible. I know how to do it. It's not built and it goes hand in hand a lot with light client verification too. These things are in progress. It's early.
01:19:10.375 - 01:19:47.979, Speaker B: I just wanted to let you guys know that I think it's exciting. I won't go into the full roadmap. This is some high level points, but I do want to say very soon we're going to release the open source sequencer. There's the Oracle module, we're going to release that which is important for doing fetch requests and stuff like that very soon. We are going to also support non Next JS apps. Right now if we go on the website, you're going to have to see the packages and the instructions for Next JS only, which is a very popular option. But if you want to use anything else, you're going to have to figure it out yourself.
01:19:47.979 - 01:20:22.949, Speaker B: And I wouldn't recommend trying to do that, I would just recommend waiting because we're going to have a great solution and it's going to be easier than what I just showed you. It's going to be very, very slick. And yeah, so there's all this other cool stuff and what I'll say is like if any of these things excite you like on an infrastructure level, like a provable SQL database, something we're working on and like get involved. I don't want to even build this. Like there's just way too much to build. There's so much to build on this roadmap and like Celestia, I think they're going to be tapped out getting to terabit per second. Like they're, they're just like working hard on that vision.
01:20:22.949 - 01:20:49.265, Speaker B: I'm working hard, hard on what the pieces I think are obvious to work on next but there's so much other stuff to do. And so like I will like support anybody who wants to come in and build infrastructure for apps like this and like I like please, please like get in touch if you don't want to build an app, you want to build infrastructure, I'm not going to be competitive with you at all, I promise. That's a good way to.
01:20:51.885 - 01:20:54.265, Speaker A: I was going to ask what's a good way to get in touch with you.
01:20:57.725 - 01:22:09.185, Speaker B: I would recommend just following OPAN framework on X and you can go to our website Chopin Sh. But in Chopin framework I also put a link to our Discord. You can go and join the Discord and get in touch with me that way you can also send a DM to modular cloud or Shapan framework and yeah, that's what I recommend And I will help anyone get started and support you guys building apps in the Discord. And there is also another option if you want to be a supporter of this project. There is a paid option on the Shopan website where you can get more personalized attention and more prior ties time from me and I would host a bunch of stuff for you and all of that and make it really easy. But either way I honestly just want to foster people building and I will be supporting the community in that way and I also am going to be. I will announce here that I'm going to be launching a series where I'm building a social network on Celestia using Chopin framework.
01:22:09.185 - 01:22:18.925, Speaker B: And so I will also be sharing that on. If you just follow the Chopin framework on X, you're going to see all the episodes of that.
01:22:19.785 - 01:22:21.605, Speaker A: Awesome. That's exciting.
01:22:22.265 - 01:22:23.085, Speaker B: Yeah.
01:22:23.985 - 01:22:27.057, Speaker A: Do you know what app you're going to build or is that secret?
01:22:27.241 - 01:22:29.017, Speaker B: Yeah, I will reveal it later.
01:22:29.121 - 01:22:34.645, Speaker A: Nice. Sweet. Did you have anything else for viewers?
01:22:36.295 - 01:22:41.275, Speaker B: No, I. Yeah. Thanks for letting me share this and. Yeah, absolutely.
01:22:43.375 - 01:23:03.135, Speaker A: On that note, I wanted to thank you again for joining today and thank everyone for watching. And I'm looking forward to a Part 2 of Chopin framework whenever we think it's ready. But I learned a lot from watching you today, so thank you again.
01:23:03.755 - 01:23:04.491, Speaker B: Thank you, Josh.
01:23:04.563 - 01:23:11.051, Speaker A: And if you have any last words, now is the good time. Nah.
01:23:11.123 - 01:23:17.187, Speaker B: Yeah, yeah, yeah. No, all good. Yeah. I'm like, you're doing this.
01:23:17.211 - 01:23:25.915, Speaker A: Thank you. Awesome. Yeah. See you in the next Build stream. And thank you again for joining. And thanks again for hopping on lzrs. We'll see.
