00:00:01.920 - 00:00:43.542, Speaker A: Hey, everybody, thanks for coming. I want to talk about Stylus. There's a lot of attention to all of the areas of building an l two or l three chain. Thank you. Whether it is sequencing or data availability or proving, at least at this event, I haven't heard as much attention to execution, but the execution layer is actually quite important. And I want to talk about stylus in the multivm, which I think is the biggest breakthrough in blockchain execution I've seen in a long time. And I want to emphasize that everything I'm telling you about today exists and is available to you on Testnet.
00:00:43.542 - 00:01:29.796, Speaker A: And assuming that the arbitrum dao votes for it will be on Arbitrum one and Nova Mainnet, and if you have an orbit chain, can be on your chain. Okay, so let's start with the EVM. Arbitrum has supported, you know, like most of the Ethereum stack has supported EVM from the beginning. The EVM was designed for good reason, a design that made sense at the time and still does make sense for a lot of use cases. It was meant to be small, and it was meant to be easy to price. This was one of the, I think the really amazing pieces of foresight in the design of EVM was to think about pricing as an inherent part of the mechanism. And so, right, Ethereum code, or EVM code, is written in solidity, kind of like this.
00:01:29.796 - 00:01:55.220, Speaker A: It compiles down to this binary code. The code is translated into EVM bytecode. All right. But most developers on Ethereum, of course, tend to write in solidity. Some write in viper. But essentially, if you're learning to program in the Ethereum stack, you're probably learning solidity programming. And unfortunately, bugs are reasonably common in code that's written in these languages.
00:01:55.220 - 00:02:55.192, Speaker A: And it's partly because I think in the early days and when these things were first designed, there wasn't enough experience to understand what kinds of bugs might arise from it. Also, frankly, just the scale of the developer community meant that the amount of resource devoted to building really high quality tooling, not only for things like compilation, but also testing and so on, was not there and still is not there compared to other programming paradigms and languages. So we saw early on a lot of bugs. The community has gotten a lot better. Experienced solidity programmers have a giant checklist in their head of things not to do, but obviously, it's better if it's not the programmer's constant attention and experience that prevents bugs, but something else. Okay, so how did we get here? Well, solidity was designed to be easy. It's been compared to JavaScript in the sense that it's relatively easy to get onboard, at least to some extent.
00:02:55.192 - 00:03:38.644, Speaker A: And like JavaScript, ease of onboarding can be a pro or a con. But easy isn't always simple if you're writing mission critical code, if you need to avoid bugs. And smart contract programming is really all about avoiding bugs. It's important to have languages and tools and systems that are as bug resistant that make it as easy as possible for a competent programmer to avoid shooting themselves in the foot. Okay, so one approach that some projects have taken is to say, well, let's not do the EVM, let's not do solidity, let's use a different virtual machine. Then we can perhaps write our programs in a different programming language. And you see some success here, things like Solana, obviously.
00:03:38.644 - 00:04:38.660, Speaker A: But in the Ethereum space, we have this huge and vibrant community of programmers. We have a big installed base of applications that already exist. And so that's kind of the dilemma that you might see us as being in. You're either in the EvM world, some pros and cons, or you're in the non EvM world and some pros and cons there. And so one of the drawbacks of being in the EVM solidity world is that it's a much smaller developer community. So this bar graph shows the number of active developers in each of these programming languages, systems, C and C being huge, rust being pretty big, EVM solidity being smaller. Now, this means fewer programmers available, it means less existing code available, and it means tooling that is less secure and less robust.
00:04:38.660 - 00:05:37.374, Speaker A: So we asked ourselves, well, do we have to choose? Why not have both? Why not build a single system that lets you write your code in EVM in solidity in EVM, or write it in the language of your choice and run it all together on one big happy chain. So it's time to do that. Let's give ethereum developers that power. So that's what arbitrum stylus is all about. It's the next generation programming environment for arbitrum chains, lets you write smart contracts in Rust, C, C, zig, and other languages, and it's fully EVM interoperable. So to give you an example of what it looks like for code, here's a rust function that computes the catch act hash of something, and it does that by calling the standard library, astandard library in rust to do that. And the program has just decorated it with this decorator at the top hash arbitrum, and this will cause installis.
00:05:37.374 - 00:06:32.860, Speaker A: This will cause the compiler to compile this function so that it can run on an arbitrum chain. And so porting this to arbitrum is as easy as just writing that at the top. Ok. One of the disadvantages of EVM as it stands is that it's relatively slow and expensive. So, for example, in the time that the EVM does seven ad instructions, you can do one hash round of catch act in a state of the art virtual machine. So, alternative virtual machines such as Wasmer, which is arguably the most popular wasm virtual machine, is able to run much faster, and for two reasons. One is WaSm was very carefully designed for security, for performance in a way that EVM was not.
00:06:32.860 - 00:07:14.650, Speaker A: The virtual machine has much more engineering effort into it, but also EVM, in some respects, is unable to run quickly. So, for example, the fact that the basic data structure is a 256 bit integer rather than a 64 bit integer like you see in rust, has a real impact on performance. These things really add up. All right. Okay. So arbitrum, it turns out, already proves the results of computation by doing fraud, proving over WASM execution. That's a decision that we made back in 2021, and we made it because we anticipated that we wanted to do this stylus move later.
00:07:14.650 - 00:08:06.196, Speaker A: So arbitrum stake gets settled to ethereum using fraud proofs over WASM already. And so the idea is that. So currently in the legacy arbitrum, the fraud proofs are over WASM code that's compiled from the arbitrum state transition function. So the idea is, well, why not extend this to user provided WASM code? So what you need to do then, is to have the ability to take in untrusted user code and to load it into that same execution environment that you're going to prove over. And, of course, do that in a way that is safe. So WASm is a big deal, and I want to give a little bit of a sales pitch for WASM webassembly. Here we have the founder of Docker saying, well, if this stuff had existed in 2008, we would never have needed Docker.
00:08:06.196 - 00:09:12.590, Speaker A: WASm is designed for the purpose of securely running untrusted code fast in an Internet environment. It's used, for example, in browsers. It is designed based on a lot of really careful computer science work to design and improve and assure the semantics of the language. And also, there are very heavily engineered and battle tested WASM virtual machines available. Okay, so that's what the multivm is. The multivm is this idea of having one chain, multiple languages, and fully composable, and this is a big deal, right? So what we're not doing is creating a silo for EVM code and a separate silo on the same chain for this WaSM rust code. What we are creating is something where any program, any contract, can call any other contract, regardless of which language it's written in, regardless of how it was compiled.
00:09:12.590 - 00:10:11.790, Speaker A: And users can interact with applications without knowing or needing to know in what language that application's contracts were written. In fact, it's even possible, if you're using a proxy upgrade pattern, to upgrade a legacy EVM contract into a rust stylus contract without breaking anything or even changing your data representation. So this is not a new l. Two, this is designed to run on existing chains. Existing arbitrum chains can upgrade into it, and indeed, the main arbitrum testnet is already upgraded into stylus. Okay, so underneath the covers, the way this works from an engineering standpoint is the two composable virtual machines are built. Basically, we took an EVM implementation and a WASM implementation, wasmer, which is the most popular and mature waSM VM, and integrated them together to give a single state transition.
00:10:11.790 - 00:10:48.910, Speaker A: There's a single state try, which is exactly in the ethereum format, which you're using regardless of which language you're in one database. There's really nothing else like it in the ecosystem. And this has a bunch of really big advantages. First, faster runtime. Why faster runtime? Well, you have a faster vm. You also have better, more mature compilers. And if you write in a language like rust, which is very good at telling the compiler what's going on so that the compiler can optimize more aggressively, you get a big performance advantage.
00:10:48.910 - 00:11:39.210, Speaker A: So to give an example of one benchmark, if you're running catch act hashing by using the native rust library versus writing that code in solidity, that is, not using a precompiler something, then stylus is 73 x faster. So for compute intensive workloads, you can get a lot more computation for the same gas. In fact, stylus doesn't use gas to charge you for instructions. It uses milligas called ink. So even memory access can be a lot cheaper because memory representation can be more efficient. So this allows a lot of new use cases. It allows more advanced cryptography, because you can do more computation, and you can import legacy rust libraries for cryptography or C or C libraries.
00:11:39.210 - 00:12:32.842, Speaker A: It allows some AI related applications to happen, because not only when you go faster, not only does it take less wall clock time, but also you can do a lot more within the same gas limit it allows you to do. L1 precompile research. That is, if you want to try out a precompile on, say, either in a testing environment or on your own chain, you can write that precompile, you can write that code in rust, import it in stylus, and get performance comparable to what you would get if it was a precompile that was handwritten to go with an existing chain. So you can try out prospective precompiles by actually implementing them and running them at about the speed they would run. Also, you can do heavy computation of many different kinds. And so, for example, in finance, you could do a black Scholes computation quite feasibly. And one of our developers has done that.
00:12:32.842 - 00:13:14.520, Speaker A: Okay, you can use tools you're comfortable with, right? You're not using a weird domain specific language. It's not kind of sort of like rust, it's not inspired by C. You use the real compiler, and there's a really simple system call like API to do the things that you would do in solidity with, with sort of the magic things like block number. And so you just have a library like this block number, just call that. So all of the affordances that EVM programs have to see change state to see the time, all of those things, those are all supported in simple rust style libraries. That's all part of the SDK. Most importantly, of course, the EVM compatible, fully interoperable.
00:13:14.520 - 00:13:57.946, Speaker A: There is automated support in the SDK for the EVM binary calling convention. That means if you want to call some EVM code, you can just simply write an interface in. You can simply declare a function signature and then just put a decorator above it saying to generate stub functions for calling it. So that means you can interact with call and be called by EVM contracts that are written in solidity and Viper in a really natural way. So here's an example. Here's a solidity program. We've got this contract Foo, and it's calling some contract that satisfies this interface counter.
00:13:57.946 - 00:14:38.092, Speaker A: This is what you would write if you were in entirely EVM world and you wanted to have this counter contract. Now, if in stylus, if this counter contract were implemented in rust, you wouldn't have to change anything. This code doesn't need to know what language the thing it's calling is written in, and it works the other way as well. If you're calling from rust, you don't need to know the end user doesn't need to worry. The user experience is just the same, except stuff is faster and cheaper. It just works. So one of the lessons here is that EVM compatibility is not the floor for performance.
00:14:38.092 - 00:14:52.800, Speaker A: It's the ceiling. That is. Oh, I'm sorry, it is the floor, not the ceiling. That is. EVM compatibility is table stakes, but we can do much more without taking away EVM compatibility. It's not an either or. You can really have both.
00:14:52.800 - 00:15:21.018, Speaker A: The testnet's available. There's a lot of documentation and examples. You can go and look at it and try it out. A lot of people have. The SDKs actually are kind of amazing. I want to give a few examples to give you a flavor of how easy this is. So here we have, this is rust code, and we import some stylus stuff, including some stuff from alloy, a really great package that stylus uses heavily.
00:15:21.018 - 00:16:25.396, Speaker A: Kudos to the alloy team. Here's an example where we're declaring a data structure that we can access in rust, but we want it to use the same representation as solidity. And so we use this solstorage macro. We write inside the data structure in solidity, and then this will automatically generate the equivalent data structure in Rust, which you can access in your code, and it will ensure that it's represented in storage exactly as solidity would represent it. So that means, for example, that you can upgrade from a solidity implementation into a rust implementation by just writing the data structures of the solidity code that live in storage, like this, wrapping this sole storage macro around it, and then just using the data naturally in rust. So down here we can say, we have a counter, we can say self number, get. That is, we can just access this from rust as if it were a rust variable of equivalent type, and the macro does all of that stuff.
00:16:25.396 - 00:17:13.824, Speaker A: I also took this implementation of the counter type and decorated with this external tag. And this tells the compiler that I want this thing, this counter implementation, to be callable as a contract from outside. And so this will get compiled into a contract which can be deployed, and it's really that simple. I simply write the code of this thing, I put the external decorator on it, and now it will be compiled as a deployable contract. It's EVM ABI equivalent. For example, here's an implementation of an ERC 20 token. We have this solstorage declaration here which declares the data structure.
00:17:13.824 - 00:18:03.916, Speaker A: This is the data structure that you'd expect for an ERC 20. You have implementations of the code down here, by the way, down here we've declared in solidity syntax, some events, and error codes, and those also get automatically translated into rust, so they're directly callable or invocable from the rust code, just as you would want. I have to say, having used this, this is one of those really rare programming tools where everything works at least as well as you hope it does. One other programming languages, it's easy to add it. One of our most languages that don't have without a runtime that compiled to WASM can be used with stylus. One of our team members, Raul Jordan, one day got interested on a lark in getting zig to run in stylus, and it took 16 lines of code to do. So.
00:18:03.916 - 00:18:32.950, Speaker A: Pretty easy to do. It's just a question of how you of getting it to compile to wasm in a natural way. So you can do that if you like. You need something low level. Well, if you want to have really low level code, you can write like this. You can write user main and take call data in and give back a result, which is either the return value or the error value. So, very simple, you can just work with the bytes if you want, of call data.
00:18:32.950 - 00:19:02.660, Speaker A: So again, if you want to do precompile like stuff, if you don't want to have to. If you don't want to have to pay for the automatic marshaling and unmarshaling into the Ethereum Abi, you don't have to, all right. Lots of people have used it. They think it's awesome. Here's an example of verifying messages signed with Ethereum validator BLS keys. Again, just a little bit of code to do, lots of examples here. I won't run through all of them.
00:19:02.660 - 00:19:22.790, Speaker A: If you want to try this out, and I encourage you to, if you're a developer, arbitrum IO stylus, this is, it's available today on Testnet. It is available for orbit chains that do want it, and if the arbitrum dao votes to adopt it, then it will be on arbitrum mainnet very soon. Thanks very much.
