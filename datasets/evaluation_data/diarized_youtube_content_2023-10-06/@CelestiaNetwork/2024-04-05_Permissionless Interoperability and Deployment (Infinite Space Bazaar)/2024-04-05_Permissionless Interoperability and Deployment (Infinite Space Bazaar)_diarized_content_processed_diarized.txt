00:00:01.240 - 00:00:20.874, Speaker A: Awesome. And we're live again. Welcome everyone to the infinite space Bazaar. We're going to have another workshop today from hyperlane. I'm joined by York. Yeah, so we're going to be learning about permissionless interoperability and deployment from York. York, you want to introduce yourself?
00:00:21.734 - 00:01:19.884, Speaker B: Yeah, everyone, my name is York, I'm one of the engineers over on the hyperlane team. Been working on Hyperlin for around two years now, and the Celestia ecosystem emergence has been super exciting for us. Basically, this new roll up ecosystem has kind of some unique interoperability demands, and we've designed a lot of our protocol around servicing that ecosystem. So I'm going to be talking about basically an overview of the hyperlane interoperability framework. And later on we'll talk about how to basically work on a hyperlane related project in the hackathon and some bounties that we've outlined to get some inspiration going, but we're pretty flexible on that end.
00:01:21.614 - 00:01:22.334, Speaker C: Definitely.
00:01:22.454 - 00:01:29.030, Speaker B: If you're interested in building on top, please reach out, either in our discord or just to me personally.
00:01:29.062 - 00:01:33.954, Speaker C: I'll have some contact info later, but yeah, hop into.
00:01:34.494 - 00:01:36.142, Speaker A: Yeah, thank you again.
00:01:36.198 - 00:01:36.794, Speaker C: Cool.
00:01:37.294 - 00:02:56.210, Speaker B: So yeah, like I said, hyperlane is an interoperability framework. But before I kind of describe the details of that, I'm going to give us some background context, the problem that we're solving. So if we look at the evolution of crypto in the past decade or so, there has been an increasing divergence in the types of infrastructure that decentralized applications are using. So bitcoin was the kind of first example of a blockchain, and it had this novel proof of work mechanism. They used this Utxo execution model, and that was a payments application. As people started to attempt to build an ecosystem on top of that infrastructure layer, they realized that there were a bunch of constraints with that Utxo execution model that prevented them from building more sophisticated financial instruments on top. And this led to the creation of a bunch of smart contract blockchains.
00:02:56.210 - 00:04:32.962, Speaker B: So that includes ethereum, which probably almost everyone here is familiar with, as well as near Solana move. All of these chains are meant to basically function as a smart contract infrastructure layer, so such that people can permissionlessly compose many decentralized applications on the same network. So we saw the emergence of DeFi on some of these networks, and the ability of a lending protocol to compose with a stablecoin protocol or a payments protocol, these sorts of things. So we had kind of a faster pace of innovation, but there were a few problems. So one is in order to enable that type of generalized computing environment like a smart contract vm, it's very costly, basically for the network's consensus, for everyone in the network to come to consensus on every single applications execution. There's also a more recent concern, which is this concept of state bloat, or state growth, which is basically that every application in these chain's history, any kind of data storage that they've ever done in the past ten years, must be stored in perpetuity. None of them have implemented any sort of kind of state expiry.
00:04:32.962 - 00:06:28.212, Speaker B: And so in order to run one of these chains, you kind of have, are starting to see basically some throughput and storage bottlenecks, which is kind of centralizing. It prevents new applications from being as appealing to users when they get to market, because it's just so expensive to, to use these chains. And so I think the third phase, I guess, of evolution of this infrastructure is what I call the app chain phase, I guess, which kind of, some of the cosmos and Polkadot ecosystems were pioneering, which was the idea of building applications, or rather building, building a chain and an application with a very tight coupling that allows an individual application to overcome some of these scaling bottlenecks that some of the smart contracts chains were starting to see, while maintaining composability across these different chains. So Cosmos and Polkadot both kind of had their own intra ecosystem protocols for maintaining composability between these chains. And they kind of have these frameworks for defining what the state transition function is of each chain. Slightly less generalized. More recently, with the emergence of celestia and ethereum, transitioning more to DA for a roll up centric roadmap, we've seen an even further kind of modularization of some of these previous iterations.
00:06:28.212 - 00:07:52.644, Speaker B: So, you know, arbitrum and optimism. Not only are do they have their own roll ups, but they're also providing frameworks for people to build application specific roll ups, which is kind of a hybrid design of these generalized smart contract computing environments and like the application specific chains. And we've now separated the data availability of these roll ups from the execution. Hopefully everyone here is familiar with celestia and the problem that they're solving and data availability, but that's kind of the mental model. Rollups and DA's are kind of just a decoupling of smart contracts, execution and storage layers. In future, we'll have even further innovation, and people are working on plasma and sharding, and maybe Celestia will add some of this ZK account, proving so that roll ups can actually settle to Celestia, these sorts of things. But basically, long story short, there's no shortage of diversity in these different approaches to building or choosing infrastructure for a decentralized application.
00:07:52.644 - 00:09:05.824, Speaker B: And I think this is like a natural trend. Basically, we'll continue to see more diversity, and what's cool is not only is this happening at a theoretical level, but actually Dapps are actually adopting these new infrastructure layers. L two beats a great website that illustrates kind of some of the statistics on the level of adoption. I think Celestia's ecosystem page also has some good data there. But there's a problem that comes with these new infrastructure layers, and that is that the composability story between these roll up environments has become quite fragmented. And depending on the pairwise set of rollups or chains that a user or an application may want to move between or compose between, there are entirely different interfaces for doing so. And not only are the interfaces different, but the trust assumptions and.
00:09:07.564 - 00:09:08.020, Speaker C: Kind of.
00:09:08.052 - 00:10:06.868, Speaker B: Security model security posture is different for each set of pairwise chains. Like moving between two roll ups is different between moving between a roll up and celestia, or moving between a roll up and ethereum. It's created this matrix of complexity that's quite hard to reason about, especially as a dapp developer, when deciding how to go to market. So we've been thinking about this problem pretty hard for a while now at hyperlin, and are trying to basically address some of this complexity in a novel interoperability framework that attempts to unify some of these interfaces, as well as create some standardization around defining what the trust module models are between each pairwise set of chains.
00:10:06.916 - 00:10:07.504, Speaker C: So.
00:10:09.564 - 00:10:31.054, Speaker B: What we've done is we've created a modular interoperability protocol that separates basically the transport layer and the application layer. In case these concepts aren't familiar to you. These are borrowed from the traditional networking stack, but the basic concept is.
00:10:33.154 - 00:10:33.658, Speaker C: The.
00:10:33.746 - 00:11:43.904, Speaker B: Application or the DAP interface, basically for moving funds or information between two sets of pairwise chains can be consistent and kind of agnostic to the specific transport layer that is being used at the infrastructure layer underneath the hood. And so we have this nice kind of consistent API between every set of pairwise chains, and we can basically have different backends or different target backends on the transport layer that this, this application layer interface abstracts over. And so that includes roll up native bridges that includes basically third party validator attestation systems, that includes ZK lite clients. Basically the transport layer can target many different backends and the application layer will still be consistent. And so this has led to.
00:11:45.724 - 00:11:46.544, Speaker C: Basically.
00:11:47.804 - 00:13:42.778, Speaker B: A shift in, or we believe, I guess this leads to a shift in the kind of interoperability landscape in the sense that people can start to specialize and focus on what they're good at. And so the ZK teams who have spent years kind of researching these performance gains for improving like, you know, their snarks or whatever, can just simply build a transport layer backend of a ZK lite client. And they don't have to build everything that comes on top of that to get their technology to market. So they don't have to build all of the interoperability protocol just to leverage their ZK lite client. And instead they can now basically expose an interface to hyperlink and get their ZK lite client basically available to every Dapp developer that's already using the hyperlink interface. Dapp developers can basically independently configure for each set of pairwise chains their security preferences, basically what they want the target back end to be. We have our own prescription of a set of defaults between many of these pairwise chains, but the idea is we want to, going back to this point, we want to embrace the modularity of these application specific roll ups, and we want applications to actually be able to express application specific preferences, because security is a spectrum and different applications almost certainly have different preferences.
00:13:42.778 - 00:13:51.334, Speaker B: So just as an example, a stablecoin payments application probably wants to prioritize.
00:13:54.084 - 00:13:54.572, Speaker C: Basically.
00:13:54.628 - 00:14:24.032, Speaker B: Liveness for small amounts of transfers over safety. So I think in a point of sale experience, usually the way these things work in traditional finances, you have a credit system, but the credit system isn't actually settling to the banking system for some time. So there's different levels of finality. We're just kind of rebuilding some of those systems in a more transparent and.
00:14:24.128 - 00:14:25.456, Speaker C: Trustless way with blockchains.
00:14:25.520 - 00:15:21.244, Speaker B: But the beauty of this kind of modularization of interoperability is now, as new research comes out of new ZK technologies or new consensus mechanisms, the application layer can be consistent. So people don't every time some new. The most recent one this week was Andreessen announcing the launch of their ZKVM, which can be used to verify arbitrary programs and basically function as one of these security backends on the transport layer. Every time one of those new technologies comes out, the Dapp developer doesn't need to re architect their entire system, which has kind of been the status quo of the past few years, which I think we believe has led to.
00:15:23.384 - 00:15:23.896, Speaker C: Basically.
00:15:23.960 - 00:15:35.904, Speaker B: A lot of this stagnation and this fragmentation, basically, it's unreasonable to ask every application to keep re architecting to accommodate.
00:15:35.944 - 00:15:39.184, Speaker C: These new, these new layers.
00:15:41.284 - 00:16:36.114, Speaker B: So just to give some context on the state of hyperlink, we're in production in a bunch of ecosystems. We have implementations of this consistent application layer interface across a bunch of different smart contract vms. So we're on the EVM, we have a c level VM implementation. There's a move VM implementation, there's a cosmosm implementation for Cosmos chains. And the application interface, basically that hyperlink exposes across all of these different smart contract environments is consistent. So it's this simple messaging API of basically being able to dispatch some information to another chain where you're just specifying the target address and domain. And basically a body is just a simple message passing interface.
00:16:36.114 - 00:16:54.234, Speaker B: And behind the scenes, on each pairwise set of chains, we have a different transport layer. And this actually allows us to get better trust assumptions than some other interoperability protocols, which maybe make more universal.
00:16:57.234 - 00:16:57.722, Speaker C: Basically.
00:16:57.778 - 00:17:50.634, Speaker B: Assumptions about the transport layer. And so, you know, between osmosis, which is a, you know, a tendermint cosmos chain, and Ethereum, we can use a tendermint backend. We call them interchange security modules, but we can basically get like client proofs now that we're working with succinct on this backend. But the message passing interface between these chains looks no different from ethereum going to Solana or to Aptos. And the backends might look different, but the application interface is consistent. So that's the important part. Yeah, this is just a nice summary of what we just talked about.
00:17:50.634 - 00:19:05.964, Speaker B: Another thing that we've prioritized in the design of our protocol is what we call permissionless interoperability. So we like to think of Hyperlane as the most accessible interoperability protocol, because instead of having to kind of come and do business development with our team, you can actually deploy Hyperlink to new chains. And this is part of the beauty of Hyperlink being implemented in smart contracts. It's very easy for an application developer to deploy hyperlane to a new chain or roll up without the lobbying of the core team to get involved in that process and operate the infrastructure themselves. We're fully open source, so if there's something which isn't supported that you'd like to see, you can make a feature request or file a bug report. We have guides in our docs for how to do this, and we think this is really a kind of best in class experience. And we love to continue to get more feedback on this.
00:19:05.964 - 00:20:44.454, Speaker B: But yeah, long story short, during this hackathon you actually should be able to, to connect up some new chain, some, maybe a new celestial roll up to the rest of the hyperlane network without any involvement from our team. Obviously we're happy to support developers in our discord and definitely reach out, but yeah, you should never be blocked. And yeah, this process should basically take only around ten minutes. We think this is kind of like a huge unlock for the ability for these kind of application specific roll up ecosystems to explode in growth because right now they've been really limited by the interoperability story. Basically like if someone launches a new roll up, they have to, you know, they have to figure out how to get users to their chain. And in the past that's often involved interacting with a centralized exchange. More recently it's involved maybe lobbying one of these other bridge providers to do a more like white glove deployment to your chain, which might come with some high fees, it might come at a high cost, which basically is prohibitive for a lean startup who's maybe trying to take some risks.
00:20:44.454 - 00:21:31.574, Speaker B: So yeah, we'd love to see people try this out during the hackathon. We've built a few applications on top of this protocol. So this protocol is just very simple. It's a message passing interface. The most kind of the simplest application to understand that can be built on top of the message passing interface is what we call warp routes. This is basically a way for you to bridge tokens between chains. We call them warp routes because you can have basically security or transport layer configurations which are specific to a route.
00:21:31.574 - 00:21:39.334, Speaker B: And so it's kind of somewhat different from a traditional token bridge in the sense that all of the collateral.
00:21:41.194 - 00:21:41.530, Speaker C: Is.
00:21:41.562 - 00:22:23.744, Speaker B: Not necessarily taking on the same trust assumptions, which in the past has functioned as a very large honeypot for, for attackers to see a bridge. And they basically see if maybe one of these tokens, collaterals in one of these bridges is only 100k worth in us dollars. But in aggregate, cumulatively across all of the tokens which are sitting in this bridge which have the same attack surface area, this maybe is like 10 million or $100 million. I don't think I'll have to.
00:22:25.924 - 00:22:26.252, Speaker C: Prove.
00:22:26.268 - 00:23:35.438, Speaker B: To you guys that the existing token bridge paradigm has been exploited a lot. And so this is kind of a slightly new way to think about things. We have support for a bunch of different types of asset parameterizations. So you can, we have templates basically for NFT warp routes for native assets, or for just entirely synthetic assets. We're doing this for a bunch of roll ups. Now we have a recent feature we added to this was what we call yield bearing warp routes, which is the ability for basically the underlying collateral to be productive, which supports the ERC 4626 vault standard. If any of you guys are familiar with that basic idea being, you know, if you want to have the Ethereum or some asset on your roll up earning yield for your users, you can have the collateral on the l one be deployed into some yield vault.
00:23:35.438 - 00:24:55.790, Speaker B: Basically something that looks like a, a staked ETH yield bearing vault. Basically. We also have what we call interchange accounts and queries, which are developer primitives on top of this messaging API that make it easier for developers to build applications. So you can think of these almost as like kind of library like standard lib type functionality for hyperlink that allows you to do two things. So interchain accounts, the basic concept was motivated by the ability for a smart contract on one chain to interact with a smart contract on another chain without the smart contract on the destination chain being aware of hyperlane at all. And this basically has a bunch of nice backwards compatibility benefits where now your new roll up, let's say your new celestial roll up, can interact with compound or dai on Ethereum. Those contracts don't have to be built to understand hyperlink because we've built this interchain accounts API.
00:24:55.790 - 00:25:50.488, Speaker B: And the idea is you want a local representation of your smart contract on the destination chain, in this case, let's say Ethereum in our DAI example, so that the target contract can use its normal access control. The DaI smart contract has a set of balance holders which are all just local addresses on this chain. We need a unique representation of some smart contracts from, let's say your new celestial roll up on Ethereum. And we do this by creating basically this proxy account that can only basically authenticate calls to be made by receiving a message from the owner account or like the hub account, we like to.
00:25:50.536 - 00:25:51.524, Speaker C: Describe it as.
00:25:53.434 - 00:27:03.314, Speaker B: This is like an abstraction over the messaging API that allows you to basically make interchange calls that are authenticated in the sense that the target contract has a unique representation of the sender, despite not knowing anything about this interchain account API. Similarly for queries, basically in order to get a response back to the origin chain, we have another API that allows you to perform a view call basically on another chain, get back the response. So in this case we're actually doing two message hops on the underlying messaging API, but we'll get back the response from whatever view call we did on the other chain. And this is just a much simpler API for a lot of developers. We'd also love for people to try these out in a hackathon and give us feedback. These are in production on a bunch of chains. So just to walk through basically how we're lowering the barrier to interoperability.
00:27:03.314 - 00:27:45.314, Speaker B: You guys may be familiar with Rollup as a service providers like Caldera, who allow you to select between these different roll up frameworks and to choose a data availability layer. What you can do in this hackathon is basically go through their guide and spin up maybe a testnet roll up with celestias. Da. And you could use hyperlane to get your new roll up connected to a bunch of existing networks. So you can connect your new roll up to Solana, Ethereum, some cosmos chains, some move chains. We're on a bunch of roll ups. This is non exhaustive list, but just illustrating the modular security paradigm.
00:27:45.314 - 00:28:42.934, Speaker B: But, yeah, we think this is basically the missing piece in the modular stack for Dapp developers. So, yeah, we're just making another lego for people to plug into. We work closely with a bunch of these roll up as a service providers to make it as easy as possible to get hyperlink hooked up. And, yeah, that's basically the overview. We have a few bounties available for people who are participating. So, like I already alluded to, you can launch one of these celestia roll ups and connect it to the broader ecosystem of hyperlink chains. And we'd love to see someone do this in the hackathon.
00:28:42.934 - 00:29:08.594, Speaker B: This was just announcing this workshop, but I'm basically happy to take any questions about anything I talked about so far. I guess we have to the hour. Actually, maybe Josh can correct me if we have to the hour or not. But if it's useful, take some questions, we could hop into a demo of the cli. Really? Really, anything's possible.
00:29:10.294 - 00:29:13.634, Speaker C: Let me look at the chat real quick for questions.
00:29:15.854 - 00:29:43.110, Speaker A: Sorry, I was muted. Yeah, we do have till the hour. I think a demo would be awesome. Personally, there are two questions there. Well, one question in the chat that I'm going to put up on the screen here, and I think, yeah, does hyperlink support evm based l one to l two or l two to l two? Message passing. Yeah. Is BSc to arbitrum and custom? L two to custom l two, yes.
00:29:43.222 - 00:30:16.314, Speaker B: So we do support this, both. All of the paths, basically, and we're already in production between BSc and arbitrum. And, yeah, if you wanted to launch a new l two during the hackathon, yeah, that's part that's a big part of our value prop is that you can deploy hyperlane yourself to that new l two and get it connected to arbitram or BSc or any of the existing deployments. Question your part one?
00:30:16.974 - 00:30:31.934, Speaker A: Yeah, we'll go ahead and go pop up. Yeah, question your part one. Game between two users with previous deposits. Users would be more comfortable making. I don't. Is this a question?
00:30:33.954 - 00:30:51.070, Speaker B: User would be more comfortable making deposits on their favorite chains and stable coins. After the game ends, the winner receives a winning night. Chain protocol retains a small commission on the contract. Yeah. So, basically, like a lottery kind of thing, I think, pool together. Maybe at some point, had a. A game like this.
00:30:51.070 - 00:31:28.786, Speaker B: Yeah, totally possible. You could build basically an interchange version of pull together style application. Generally, there's a lot of applications that people are probably familiar with, or, like application categories or verticals that people are familiar with on some of the existing smart contract chains that can be augmented slightly with hyperlink to reach a broader audience and basically, like a broader market, basically by just exposing an interface on.
00:31:28.810 - 00:31:29.754, Speaker C: A bunch of different chains.
00:31:29.834 - 00:31:33.258, Speaker B: So that's a. That's kind of a perfect example of.
00:31:33.306 - 00:31:34.774, Speaker C: The type of thing you could do.
00:31:35.394 - 00:31:58.972, Speaker A: It's like a perfect use case. Yeah. And I guess on the note of deploying, they're using hyper lane between two different roll ups. I wanted to confirm my understanding that you could do this between, let's say, a Cosmos SDK roll kit roll up and an EVM roll up. As long as they both have hyperlane, you can pass messages between them. Right?
00:31:59.148 - 00:32:19.360, Speaker B: That's exactly right. Yeah. So the other advantage of our protocol is not only are we modular at the kind of, like, transport layer of being able to use different security models between chains, but we also expose a interface to a bunch of different execution.
00:32:19.392 - 00:32:21.264, Speaker C: Environments and smart contract chains.
00:32:21.304 - 00:33:01.310, Speaker B: So we have a Cosmwasm smart contract implementation, an EVM implementation, sea level implementation. There's varying degrees of support in the CLI for being able to deploy those things just because we haven't been able to reach feature parity. But the CLI has a great experience for deploying the EVM version of our protocol. And basically, if you want to deploy the sea level or cosmosm version, there's, like, some slightly. There's basically a longer guide for how to do that in our docs. It's not as streamlined as the Cli.
00:33:01.342 - 00:33:03.794, Speaker C: Experience right now, but we're working on that.
00:33:05.154 - 00:33:07.974, Speaker A: On the note of the Cli, do you want to show us around?
00:33:08.554 - 00:33:09.818, Speaker B: Yeah, let's do it.
00:33:09.986 - 00:33:18.654, Speaker C: Let me pull that up. I guess I'll need to share a different window here going.
00:33:18.954 - 00:33:25.494, Speaker A: And then if anyone does still have questions, please drop them in the chat. Also, if you're on Twitter, we can see those as well. So.
00:33:31.774 - 00:34:09.654, Speaker C: Okay, just making like a sandbox window here so I don't accidentally do something. Okay, cool. All right. Share screen window. All right. Should be in my terminal. Everyone can see that.
00:34:10.634 - 00:34:20.614, Speaker B: Awesome. All right, cool. So I'm going to just install the latest version of the Hyperlane ClI.
00:34:23.213 - 00:34:25.073, Speaker C: And all the fresh features.
00:34:29.933 - 00:34:31.469, Speaker B: Maybe it would be useful actually to.
00:34:31.501 - 00:34:47.194, Speaker C: Pull up our docs alongside this, just so that we both have a reference point. So let me do my entire screen. Cool.
00:34:47.234 - 00:35:32.350, Speaker B: So there's a super simple, basically, like getting started guide for if you want to deploy hyperlin. And the first step is basically installing the CLI. We can quickly look at the list of chains that are available to access in the CLI. So someone was asking about arbitrum and bsc. Those are all exposed nicely in the CLI. There's actually a much longer list of chains that hyperlane is in production on, but just haven't been basically made available within the CLI. But I think for the purposes of.
00:35:32.382 - 00:35:37.354, Speaker C: The hackathon, this should be pretty sufficient.
00:35:39.334 - 00:36:08.388, Speaker B: But the first step in deploying hyperlane is basically choosing a configuration. So we have a kind of nice interactive experience for setting that up. I'm going to maybe, let's call our new chain celestiarollup. And I'm going to come up with.
00:36:08.436 - 00:36:09.424, Speaker C: A new.
00:36:12.054 - 00:36:30.114, Speaker B: Chain id. Going to need to have a URL. So in this case, I'm just going to launch a local anvil note and pass that here. I'm going to maybe skip this.
00:36:32.574 - 00:36:39.884, Speaker C: Let's see what happened there. Invalid URL. Okay, I think I was just missing the.
00:36:44.024 - 00:36:45.928, Speaker B: I was just missing the HTTP.
00:36:45.976 - 00:37:01.764, Speaker C: I can't pass the 127. So let's just go through that really quickly. Again going here. All right, sorry, bear with me real quick. So let's do a roll up.
00:37:02.724 - 00:37:05.584, Speaker B: This I think I need to do.
00:37:08.684 - 00:37:22.544, Speaker C: Basically localhost. Hopefully that works. I guess it told me enter HTTP. I wasn't paying attention.
00:37:23.124 - 00:37:46.576, Speaker B: All right, we did it. Cool. So we have now this yaml config. This is what we just put in. This represents all you need, basically to have the CLI ready to deploy. So let's just go through the next.
00:37:46.600 - 00:37:47.964, Speaker C: Step in the guide here.
00:37:49.424 - 00:37:57.836, Speaker B: Another step we need to do is basically do the, the ISM configuration. So if you guys remember from my.
00:37:57.940 - 00:38:01.784, Speaker C: Presentation, the isms are the.
00:38:04.244 - 00:38:20.108, Speaker B: Basically the transport layer configuration. So this is how we actually verify the authenticity of a message between chains we call again, isms are interchange security modules. You can read more about those on.
00:38:20.156 - 00:38:48.614, Speaker C: Our docs in the, the reference section. I guess there's also an example config that maybe I can just grab from here. See, this might be a little old, but I think this might work. Let's just try it out. So I'm going to. Yeah, just go in here. Oops.
00:38:48.614 - 00:38:56.058, Speaker C: All right.
00:38:56.146 - 00:39:47.304, Speaker B: I think we can call this celestial rollup. We're going to need to have a list of validators, basically. So this is the kind of simplest ism that we have available. We basically have a very simple multisig that allows you to spin up validators and have a kind of attested model where you just kind of defer to some binary. You're running to attest to the legitimacy of messages. If you want something more sophisticated, there's a few off the shelf modules available for other types of security. So we can also wrap the native roll up bridges.
00:39:47.304 - 00:39:58.300, Speaker B: We have some ZK like clients available as well. Depending on the origin chain that you're verifying. Those are a bit more involved to.
00:39:58.332 - 00:40:00.664, Speaker C: Get up and running. But.
00:40:02.884 - 00:40:18.184, Speaker B: Again, just check out our docs if you want to learn more about that. But I'll kind of proceed with the simplest possible setup. Honestly, it might be the easiest if I have basically just two local chains.
00:40:18.224 - 00:40:22.884, Speaker C: So I don't have to worry about fauceting or anything. So let me just.
00:40:26.104 - 00:40:27.684, Speaker A: Stream out on your right side.
00:40:28.664 - 00:40:31.924, Speaker C: Oh, I'm sorry. Hopefully that's okay.
00:40:32.824 - 00:40:34.244, Speaker A: You're just getting a mirror.
00:40:35.024 - 00:40:38.964, Speaker C: I see. Okay. I think I just need to do a different port.
00:40:41.904 - 00:40:48.484, Speaker B: Cool. So I have two anvil chains running here. I'm going to quickly just.
00:40:50.464 - 00:41:21.324, Speaker C: Basically, that's not what I was looking for. I'm going to quickly just dupe this and make this 8546. Cool. All right.
00:41:35.794 - 00:41:38.378, Speaker B: All right. I guess I'll need to make a.
00:41:38.426 - 00:41:39.014, Speaker C: New.
00:41:41.674 - 00:41:43.014, Speaker B: Wallet for.
00:41:45.034 - 00:42:32.324, Speaker C: Getting a validator set up. Let me just do that real quick. Okay. I think I need to do RPC URL. Do that on both chains. Sorry.
00:42:32.364 - 00:42:52.594, Speaker B: There's just like, you know, some, some setup here. If, if you're doing this for real, obviously you wouldn't want to, you know, just use a plain text private key. We have a guide in our docs if you want to productionize to basically setting up a validator with a more sophisticated key setup.
00:42:52.634 - 00:43:02.254, Speaker C: So you can use a key management service that has basically a more secure.
00:43:03.554 - 00:43:07.094, Speaker B: Setup where you're never restoring your private key in plain text.
00:43:07.754 - 00:43:09.870, Speaker C: This is just for the purposes of.
00:43:10.062 - 00:43:11.994, Speaker B: Showcasing something for the hackathon.
00:43:14.294 - 00:43:14.958, Speaker C: So let's.
00:43:15.006 - 00:43:16.034, Speaker B: Let's keep going.
00:43:22.534 - 00:43:44.534, Speaker C: All right, just open that up here.
00:43:55.714 - 00:44:13.774, Speaker B: All right, so I'm just going to configure isms for these two local chains. But like I, like I mentioned earlier, it's totally possible for you to connect your new chain to all of the existing hyperlink chains. It's the advantage of our modular security setup.
00:44:14.954 - 00:44:15.694, Speaker C: The.
00:44:16.034 - 00:44:28.734, Speaker B: Like I said, the CLI has access to all the chains shown here. If you want to connect or learn more about some of the other chains which may not be available in the CLI. Definitely, definitely reach out in our discord.
00:44:29.904 - 00:44:32.644, Speaker C: But I'm just going to proceed with those.
00:44:33.504 - 00:44:38.564, Speaker B: I'm just going to do one signer. We're going to grab the.
00:44:41.304 - 00:44:52.912, Speaker C: Address I made earlier as the signer, and we're going to do the same for the other chain. Cool.
00:44:53.008 - 00:44:56.804, Speaker B: Now we have a super simple ism configuration.
00:44:58.804 - 00:45:02.944, Speaker C: Let's just look at that, I guess. Sweet.
00:45:06.124 - 00:45:15.864, Speaker B: All right, so now the next step is to basically run the deployment.
00:45:18.204 - 00:45:18.492, Speaker C: So.
00:45:18.508 - 00:45:24.354, Speaker B: We can quickly talk through what the different values are here.
00:45:26.334 - 00:45:31.194, Speaker C: Probably just going to remove the optional stuff.
00:45:37.814 - 00:45:40.874, Speaker B: So our ism config that we just created is at the.
00:45:41.814 - 00:45:58.104, Speaker C: That I just output it right there. The chain config is what we created before in this file we're deploying to Celestiaroloff one and Celeste rollup two.
00:45:58.964 - 00:46:01.404, Speaker B: Obviously, these are not real chains.
00:46:01.444 - 00:46:04.148, Speaker C: These are just the local anvils I.
00:46:04.156 - 00:46:05.060, Speaker B: Have running on my machine.
00:46:05.132 - 00:46:09.864, Speaker C: But the same process would apply. Oops.
00:46:15.464 - 00:46:17.184, Speaker B: And I'm just going to use any.
00:46:17.224 - 00:46:22.404, Speaker C: Old key that's on the anvil note.
00:46:25.424 - 00:46:27.784, Speaker B: So do we want to use some existing contract addresses?
00:46:27.824 - 00:46:42.544, Speaker C: No. Going to deploy to these two roll ups. Signer will be that anvil account. I think that's right. Yep. I think that's correct. Going to proceed.
00:46:42.544 - 00:47:00.264, Speaker C: Getting a call. One sec. Just mute that. Okay. Let's see what happens. Can you guys still hear me? I'm getting some weird.
00:47:01.924 - 00:47:03.084, Speaker A: Yeah, we got you.
00:47:03.244 - 00:47:23.494, Speaker C: Okay, cool. All right. What happened here? Invalid chain id for Signer. I don't know what this just dumped out at me. Let's see. Did I mess it up? Providers failed sign transaction.
00:47:33.994 - 00:47:39.374, Speaker B: Classic live demo stuff. Let's see if I can figure this out. Invalid chain id for Signer.
00:47:41.854 - 00:48:01.230, Speaker C: What did I do wrong? Maybe I have to use the chain id that was in here. That's probably what it is. Let's see that fixes it. Ah.
00:48:01.302 - 00:48:01.742, Speaker B: Okay.
00:48:01.798 - 00:48:24.018, Speaker C: Now they're just colliding okay, progress. Um, I guess I'll have to launch each one of these slightly differently. So this one that. This one, I think I can just do three. One. How can I not do that? Oh, just there. Right.
00:48:24.018 - 00:48:54.782, Speaker C: I think I need to do this one more time. Oops. Okay, looks good. Let's try again. Oh, did I adjust that? This one has eight now, right? Yep. Okay, looks right.
00:48:54.878 - 00:48:59.166, Speaker B: Okay, we did it. We're in the mirror again.
00:48:59.310 - 00:49:00.234, Speaker C: My fault.
00:49:01.134 - 00:49:02.394, Speaker A: I didn't want to interrupt.
00:49:03.134 - 00:49:06.794, Speaker B: All right, so we should have basically.
00:49:08.294 - 00:49:10.262, Speaker C: Just look at the output there.
00:49:10.438 - 00:49:18.314, Speaker B: So we have some addresses now in our artifacts folder. So let's just take a look at that artifacts folder.
00:49:22.034 - 00:49:29.586, Speaker C: Looks like I've actually done some deployments previously here. It's kind of funny, but yeah.
00:49:29.610 - 00:49:32.894, Speaker B: The one that's relevant to us is this most recent one here.
00:49:35.394 - 00:49:36.690, Speaker C: Let's take a look at that.
00:49:36.802 - 00:50:18.986, Speaker B: So here's all the different contract addresses that we just deployed. You'll see that within each chain we deployed basically a multisig ism that reflected the validator setup we did together, as well as basically the mailbox. There's a few other things that are defaults that we have for spinning up validators. So the Merkle tree hook is basically like a state commitment that the validators use to attest to. I think we are getting close to time, so let's see if I can.
00:50:19.010 - 00:50:51.874, Speaker C: Get the agents set up here as quickly as possible. Wondering if it will be faster for me to do kurtosis or just a local binary I have built. Let's see if I have that ready. This might be a bit painful. Okay. That's going to take a while.
00:50:53.614 - 00:51:06.954, Speaker B: Yeah. So we have basically a few different guides depending on how you want to run the validators. We have a local setup, which is what I'm doing. So let me just.
00:51:08.974 - 00:51:10.114, Speaker C: Go to.
00:51:12.294 - 00:51:12.726, Speaker B: That.
00:51:12.790 - 00:51:21.822, Speaker C: Section of the docs. Yeah, so I guess I was attempting to do building from source.
00:51:21.878 - 00:51:22.714, Speaker B: Let's see.
00:51:24.494 - 00:51:25.718, Speaker C: That might take a while.
00:51:25.846 - 00:52:05.614, Speaker B: Obviously, it's like a little complicated rust binary, but we also have some published docker images, and we also have this guide with kurtosis, which is basically an infrastructure partner we have who will do a basically hosted version of this for you. So you don't even have to figure out any of your own infrastructure. So there's basically like a single click validator and relayer deployment to get your new chain up and running. And we have this like one month trial agreement with them. We can try to do this together.
00:52:05.774 - 00:52:29.334, Speaker C: Let's see if it works. So I want both of these chains select the origin chain. Okay. Select chains to relay between, I guess just this one.
00:52:30.634 - 00:52:32.042, Speaker B: Please select at least two chains.
00:52:32.138 - 00:52:32.934, Speaker C: Okay.
00:52:35.474 - 00:52:39.254, Speaker B: I haven't done this in a while, but I'm glad that it's walking me through it.
00:52:40.754 - 00:52:42.454, Speaker C: Let's see if this works.
00:52:57.694 - 00:53:24.894, Speaker B: All right, look at that. So, yeah, like I said, we really invested a lot into this experience, and it should be as like self explanatory as possible. And I think this Kurtosis guide is probably the easiest for the hackathon. The private key of the validator we have it is right up here.
00:53:26.594 - 00:54:15.374, Speaker C: Where is it? Cast wallet, new or no, what was it that we did cast something. There it is. Okay, let's see if I can get this RPC URL thing to work locally. Optional, optional, optional. Yada yada. Okay, origin chain name zero.
00:54:16.914 - 00:54:19.014, Speaker B: All right, let's just click run and see what happens.
00:54:19.794 - 00:54:21.334, Speaker C: We got a few minutes here.
00:54:22.354 - 00:54:23.774, Speaker A: Early live demo.
00:54:32.994 - 00:54:43.894, Speaker C: Not sure if the local host URL's will work out for us, but we'll try it. Okay, so we have news. Go ahead.
00:54:44.474 - 00:54:49.254, Speaker A: Helps take out the DevOps side of things. So you can think about your application.
00:54:49.874 - 00:54:54.174, Speaker B: Yeah, exactly. So this is just a nice easy way to get up and running quickly.
00:54:55.514 - 00:54:58.042, Speaker C: So you can just iterate on the.
00:54:58.098 - 00:55:29.104, Speaker B: Application side eventually if you wanted to productionize, have a kind of hosted agreement with a few of our partners where we'll operate some of this infrastructure for you. But yeah, this is like a pretty nice experience. Okay, so let's see. Yeah, so I think the, I think.
00:55:29.404 - 00:55:38.084, Speaker C: It'S not going to allow me to do this localhost setup. I would need to somehow expose a.
00:55:38.244 - 00:55:58.524, Speaker B: Port forward, basically to give the validators and relayers a real URL that they can hit. Because my machine is obviously not exposing that right now. But yeah, if we were to have that real URL, we would basically be able to do yarn. Sorry, hyperlane message.
00:55:59.344 - 00:56:46.874, Speaker C: Maybe it's hyperlink message sent. I guess it's just sent message and the private key. No, we could do it from one of these chains that we just deployed. Not sure. So I need to do this because I need to pass in one of these guys. And the sky. And the sky.
00:56:47.614 - 00:56:57.504, Speaker B: Okay, what this is doing is we just dispatched a message from this chain. So you'll see the transaction here to this chain.
00:56:59.804 - 00:57:01.148, Speaker C: Never got the binary built.
00:57:01.196 - 00:57:49.304, Speaker B: But now what this is doing is the CLI is waiting for. It's basically polling to see has the message been delivered to the destination chain because of the validator setup that I configured and the failure we saw here. This will continue to pull basically until we got that validator spun up. But that's the basic workflow. I know we didn't get all the way through it in time, but hopefully that was pretty self explanatory. Does the validator running hyperlane node are incentivized to run? That's a great question. Right now we have some off chain agreements with a few of our operators who, who perform this validation service, but we're working on bringing those incentives on chain.
00:57:49.304 - 00:58:11.728, Speaker B: We're also launching a eigenlayer AV's that people can participate in, which will allow people to secure a bunch of different networks. But yeah, if you're interested in operating a validator, you can basically reach out.
00:58:11.736 - 00:58:20.688, Speaker C: In our discord and we're happy to chat. Awesome, cool.
00:58:20.736 - 00:58:23.844, Speaker B: Thanks so much everyone, for the time.
00:58:24.504 - 00:58:27.424, Speaker C: I know we ran a little over, but it's okay.
00:58:27.544 - 00:58:41.384, Speaker A: I was going to ask if there's any last things you want to share with people who are hacking or any ideas that you would like to see built during a hackathon. I'm curious to know what. Yeah, coming from someone at Hyperlane, like what you'd like to see?
00:58:42.804 - 00:58:43.716, Speaker B: Yeah, definitely.
00:58:43.820 - 00:58:48.544, Speaker C: Let me just pull up my screen real quick again.
00:58:53.324 - 00:59:29.254, Speaker B: So we have a few different, just like example projects here. So you could build a an market for testnet tokens. So this has been like kind of controversial in the past, but sometimes it's hard to get faucets to work. And this is like a more market driven way to solve the testnet funds problem. You could do a key funder. So basically like managing balances across a bunch of different chains.
00:59:31.774 - 00:59:32.870, Speaker C: Can do some.
00:59:32.902 - 00:59:55.966, Speaker B: Sort of like cross chain limit order style exchange where you can have a decentralized exchange with assets, or basically pairs of assets that don't necessarily live on the same chain. These are just a few ideas. There's also a list of bounties on our website.
00:59:56.110 - 01:00:01.294, Speaker C: I know, I just did the mirror thing again. Sorry about that.
01:00:01.454 - 01:00:02.834, Speaker A: Keep people on their clothes.
01:00:04.774 - 01:00:16.754, Speaker B: There's a bounty thing on our website. Definitely check those out as well. Yeah, reach out in our discord. And like I said, we're pretty flexible, so if you're thinking about an idea, we're happy to give feedback.
01:00:18.414 - 01:00:20.446, Speaker C: Yeah, sweet.
01:00:20.510 - 01:00:28.654, Speaker A: Sounds good. Thank you again, York, and thank you everyone for tuning in, and we look forward to seeing what you build with hyperlink.
01:00:29.874 - 01:00:31.454, Speaker B: Awesome. Thanks so much guys.
01:00:31.914 - 01:00:32.354, Speaker C: See ya.
