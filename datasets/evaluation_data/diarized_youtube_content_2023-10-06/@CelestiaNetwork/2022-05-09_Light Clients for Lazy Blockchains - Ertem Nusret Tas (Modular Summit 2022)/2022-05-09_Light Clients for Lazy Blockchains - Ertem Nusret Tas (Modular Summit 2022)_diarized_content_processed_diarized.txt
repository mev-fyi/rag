00:00:03.610 - 00:00:21.306, Speaker A: Hello everyone. Oh, okay. I should be okay, medium range. Hello everyone. I am Artham Nusrettaj, and I'm a PhD student at Stanford. Third year. I did an internship at Celestia last summer.
00:00:21.306 - 00:01:08.210, Speaker A: It was a great experience. And today I'll be talking about a recent work we have now put onto Eprint. It's light clients for Lazy Blockchains. And this is joint work with my colleagues Dionysus Zindros, Lei Young, and my advisor David Che. Okay, to understand Light clients on lazy blockchains, we should first understand the Light clients on what I will call eager blockchains, which are the traditional blockchains. So these traditional blockchains combine transaction verification and execution with the consensus protocol. So this coupling ensures that only valid transactions are included in the canonical or the finalized chain.
00:01:08.210 - 00:01:44.858, Speaker A: Typical examples can be thought of as bitcoin and ethereum. And now let's see a run of these consensus protocols and observe this coupling in action. So this is the genesis block. In these protocols, new proposals come on top of the canonical chain. That could either be the finalized chain or the longest chain, depending on the type of the protocol. And transactions are included within blocks. These protocols are maintained by validators, and these validators have actually two roles within the protocol.
00:01:44.858 - 00:02:20.874, Speaker A: They are responsible for the execution of the consensus protocol by proposing blocks or voting on the blocks. But they are also executing the transactions within blocks. And the reason they do this is because these validators, they want to vote on or extend only blocks that contain valid transactions. So in this case, transaction one is valid. I think colors are not showing very well, but I'm just going to point them out. Transaction one is valid, so they vote on it, and then this block becomes finalized. And so that the same happens for transaction two.
00:02:20.874 - 00:03:08.680, Speaker A: But now you can see transaction three is invalid. So there is a proposal with an invalid block. There is a proposal with the invalid transaction. So these validators who are also full execution nodes, they execute this transaction. They notice that this transaction is invalid while attempting to execute it, and then they will not vote for this block and this block will not be built upon and it will not become finalized. So what they do instead is that they perhaps vote on proposals that are forking out this block with the invalid transaction from the canonical chain. So a beautiful feature of these protocols is that you can just look at the chain and then see what the ledger of valid transactions is.
00:03:08.680 - 00:04:21.470, Speaker A: So we see that if we just look at the chain of finalized blocks, we will immediately see that the ledger of valid transactions is just TX one, TX two, skipping TX three, TX four, and TX five. Okay, so how do the laser blockchain protocols differ in this regard? So these protocols separate execution from consensus. As a result, there can indeed be invalid transactions within finalized blocks. Or that lie in the canonical chain. The biggest example as everyone here might know is Celestia and there are also like more academic, there are other protocol examples from the academic world. So I will again quickly run go through protocol execution that exemplifies a lazy blockchain protocol. So in these protocols, the validators are only the consensus nodes, they do not execute the transactions so they think of themselves as responsible for the ordering and perhaps the availability of these transactions but not maintaining a state or verifying their validity.
00:04:21.470 - 00:05:00.842, Speaker A: So as a result, now what will happen is that our block with the invalid transaction tree will indeed get finalized and it will enter the ledger. Okay? The validators are not executing the transactions but someone is surely doing that right because someone is maintaining the state. So this someone are the full nodes that are different from the consensus nodes that are executing the consensus protocol. And these full nodes, they look at this ledger sorry, excuse me. They look at this sequence of blocks that are finalized. They extract out the transactions within these blocks. Here is the transaction list.
00:05:00.842 - 00:05:45.062, Speaker A: And they start executing these transactions one by one by perhaps applying them on top of the latest state. They notice that transaction three is invalid. So they basically sanitize this list of transactions and then obtain the ledger. But this is done externally by the full nodes and this is not done by the validators who are maintaining the chain. That's why the chain could indeed include the invalid transaction. Okay? Now light clients on eager blockchains or traditional blockchains as prominent example is the simple payment verification on Bitcoin or Ethereum. So I don't want to say it's easy, but I would say it's easier than a lazy blockchain protocol to design a light client on an eager blockchain.
00:05:45.062 - 00:07:02.094, Speaker A: And the reason is when you look at the sequence of blocks that are finalized you know that the transactions included in them are valid transactions given some honesty assumptions on the validator set. So now let's consider a client, this client is a car dealer. So this client has a buyer, this buyer is claiming that it has paid this car dealer some amount on the and then this car dealer basically wants to verify whether this transaction that is paying it for the car it's selling is included in the chain and then only afterwards it will send the car to the buyer. Now this light client, it's a light client because it does not have the capacity to execute all of the transactions in this chain or verify download all the transactions from all of the blocks. So it asks around and then it asks a full node is this transaction to valid and it's part of the ledger. So the only thing the full node has to do in this case is to point at this transaction within the canonical or the final chain because we know that in an eager blockchain. Every transaction in the canonical finalized chain is valid so it can just be pointed at in this manner.
00:07:02.094 - 00:07:44.660, Speaker A: And then now our dealer is happy, it can send the car. The question is answered. Now suppose this buyer who is buying the car is a malicious buyer and then it sends a double spend to another car dealer. Now we don't want this other car dealer to be sending the car over to this malicious buyer. So we don't want this car dealer to think that this transaction three is a valid transaction and it's part of the ledger. We want it to reject us. And fair enough, the full nodes will not be able to show any block on this canonical chain or the finalized chain that contains transaction three because the only block that contains it has already been forked out.
00:07:44.660 - 00:08:31.150, Speaker A: So this is basically how simple payment verification on a very high level works. So can we use the same logic on a laser blockchain? Because I'm asking this question, the answer should be no. The reason why we cannot use it is as follows in the case of this client, it's indeed the same. A full node can point at a transaction two within the finalized chain. But now we have a problem. A malicious full node can point at transaction three within the finalized chain because in a lazy blockchain the validators who are executing the consensus protocol did not check for the validity of the transactions. So the invalid transactions are also included in this sequence.
00:08:31.150 - 00:09:11.850, Speaker A: So now we have a double spend issue. So it looks like the simple payment verification that we have just gone over does not work in this case. Okay? So this is now a problem and the rest of the talk will be trying to solve this problem. And the solution is the title which is a light client for laser blockchains. So the solution starts with again a light client. So to simplify things a little bit, let's forget about the account model or the states. Let's think of our states as just like a set of UTXOs and the transactions are transactions that are spending UTXOs.
00:09:11.850 - 00:10:11.550, Speaker A: And then this light client, basically the queries it has is it has a UTXO, it thinks it has a UTXO and it's asking is my UTXO in the latest set in the latest state of the world? Now this light client has a couple of peers that are full nodes and then these full nodes will send answers back to this light client. Suppose one of his peers sends the answer yes indeed, your UTXO is in the latest state, it's included within the latest set of UTXOs. Here is the commitment to this like maybe latest set of UTXOs and here is a proof of inclusion for your UTXO. And then, now the light client could be perhaps happy. Well, the light client, if the light client hears the same response from all of its peers. And then here we will be assuming that there is at least one honest peer that the light client connects to. It's not like all of his peers are malicious, because if all of his peers are malicious then this light client is at this point doomed.
00:10:11.550 - 00:10:43.340, Speaker A: So we will assume at least one of them is honest and if all of them returns the same response, then the light client is happy. It knows that the return response is the same as the one that was returned by the honest one, so it should be correct. But the problem starts when one of the peers returns a different response. Because the issue here is that Light client does not know which of its peers is honest. It knows that at least one of them is honest. Because if it knew which one was honest, it would have just asked that one. It wouldn't have even bothered to connect other ones.
00:10:43.340 - 00:11:52.778, Speaker A: It does not know which one is honest. And then now the light client will try to figure out which of my peers are honest and which of the answers are correct. So that's the question the light client is asking and I would like to just formalize things a little bit before I go forward, even though theorem says it's informal. So the lazy light client solution we provide has the following guarantees for this light client who is asking which of my peers is honest and which one of them is like lying or telling the truth. So suppose our light client connects to at least one honest full known, the identity of which is unknown to the light client and the network is synchronous and let L denote the length of the ledger which is like 10 million transactions on ethereum perhaps today. Then our light client solution ensures that the light client can find the correct answer to its query. It can find which of them is lying and which of them is honest amongst its peers in logarithmic number of rounds in the size of the ledger with logarithmic communication complex.
00:11:52.778 - 00:13:14.086, Speaker A: So the statement is what justifies our solution as a solution for light clients? Because a light client needs to do this either in constant time or logarithmic time, it needs to be succinct, it does not have the resources to download things that are linear in the ledger side and then the site benefit is that the responsibility, this impulses on the full nodes are also linear in the ledger size. So it's not blowing up their responsibility beyond just downloading the transactions as they usually do as full nodes. And finally, so I have been vague here and I've just talked about a single example of a light client asking whether it's UTXO is in the latest state or not. There is a formalized definition of what it means for the state route obtained by the light client to be secure. So if you are more theoretically inclined, please check out the paper. Okay, so how does the light client figure out which of these full noses telling the truth or lying? To do that, it runs a challenge protocol. Sorry? So in the challenge protocol, the full nodes are obliged to give some more information to the light client to be able to convince that the other party is lying or to be able to convince the light client that they are the honest party.
00:13:14.086 - 00:14:10.298, Speaker A: And what is this extra information? And this extra information is what I will call a dirty tree. So these honest full nodes that are peers of our light client construct this dirty tree. To construct this dirty tree, these full nodes that are the peers of my light client, they look at the sequence of finalized blocks, the canonical sequence of blocks, and I will call this canonical sequence the dirty ledger because it indeed looks like a ledger of transactions, right? But it contains invalid transactions in them, so it's kind of dirty. So these full nodes, they are capable of executing this dirty sequence of transactions and that's indeed what they do. They apply the transaction they see on top of the latest state. So they might start with a genesis state, apply transaction one on top of that. Then they obtain state route one, then they obtain state two, they obtain state three.
00:14:10.298 - 00:15:08.506, Speaker A: So here they are trying to apply an invalid transaction on top of the state. So if this transaction is not applicable, we can define like a rule which would say that this state will be the same as the previous one because the transaction was, we were not able to apply that invalid transaction. Okay, so they keep doing this and then this way they obtain an augmented 30 ledger. So in this 30 ledger, we again have the invalid transactions, but at least each transaction is now augmented with the state that is obtained after applying this transaction. So now the state could be very large because here we are talking about full nodes that are trying to obtain a dirty tree. So in this example, you can think of this st five, st six, st seven as the root of the state, which is succinct. Okay? So as the name indicates, they will of course construct a merkel tree out of this augmented dirty ledger.
00:15:08.506 - 00:15:29.320, Speaker A: So in our merkel tree, the entries of the augmented dirty ledger will be the leaves and then they construct this merkel tree and that is what we call the dirty tree. Okay, so are there any questions so far about how the dirty tree is constructed? Because that is a crucial part of the architecture. Yeah.
00:15:38.730 - 00:15:42.760, Speaker B: Each full node does a construction and then provides the data.
00:15:43.850 - 00:16:41.754, Speaker A: Yeah, they individually construct this. Suppose as a litecoin, I contact like eight peers and they return me some responses. I tell them, justify your responses. Then as part of this justification step, they need to give me some extra information and this extra information is a dirty tree which they construct individually. So basically to construct the tree, you look at the whole ledger, which is the 10 million transactions here. This sounds a bit unpractical, but what happens in reality is that you can construct a tree on a rolling basis, right? And whenever there is one transaction added, the amount of work you need to do to update your tree that you currently hold for future queries is just logarithmic so you can have it constructed on an ongoing basis. But for simplicity here I was just talking about a light client, sorry, a full node that constructs it on the fly when the light client asks it.
00:16:41.754 - 00:17:44.006, Speaker A: But in practice it can be constructed. Yes, well, there might not be any invalid transaction there, but we only need to assume the worst case for security and then we will assume in the worst case there might be invalid transactions in this dirty ledger. And as a result, this is an augmented dirty tree ledger and a dirty tree. Okay, so what information does our full nodes send to the light client so that they of course cannot send the whole dirty tree because it's huge, it's constructed with all of the transactions in the dirty ledger so far. So these full nodes, the peers, they send to the light client, first, the root of the dirty tree which is just one hash function. Second, they sent the merkel proof of the last entry, which is this one. Okay, so this is the setting.
00:17:44.006 - 00:18:48.826, Speaker A: Now, so our light client, which I will hereafter call a verifier because trying to verify whose response is correct or not. And then the full nodes are hereafter called the provers because they're trying to prove to the light client that their response is correct and the other guy's response is incorrect. And then now the provers has so far supplied to the Verifier that the state route SD seven, the proof of inclusion, we can forget it for now. And then the dirty tree route and the dirty tree proof. So this dirty tree proof is basically from the latest state root to the root of the dirty tree. So if I go back one slide, so it's from here to the root and now the verifier has this information and it sees that okay, so can the dirty tree roots be the same? Now? The response is no, the dirty tree roots cannot be the same because this last entries claimed by these provers are different as a result. Now the question in the eye of the verifier has been reduced.
00:18:48.826 - 00:19:34.302, Speaker A: Now it does not worry about the latest UTXO state route anymore. The question has been reduced to talking. Oh, sorry. The question has been reduced to finding out whose dirty tree route is the correct one or who constructed a dirty tree that is correctly constructed. That's the question the verifier is asking to figure out who's adversary. Okay, are there any questions? So now I will show something called a Bisection game which the Verifier can use to figure out whose dirty tree is constructed correctly. So this Bisection game has been explored in previous lines of work.
00:19:34.302 - 00:20:20.694, Speaker A: So there is this really nice paper referred the Allegation of Computation. That is where it first appeared. So in this Bisection game, one of the provers act as a challenger and the other prover acts as a responder. The goal of the challenger is to find the first point of disagreement in the responder's dirty tree with respect to its own dirty tree and then using this first point of disagreement to convince the Verifier in a very succinct manner that the responder should have been lying all along. So during the Bisection game, challenger sends queries to the responder and responder replies to these queries. So it's like a communication rounds happening over time. And these queries go through the Verifier.
00:20:20.694 - 00:20:50.194, Speaker A: So Verifier looks at each query. So challenger can send a query to the responder. It reaches Verifier, then Verifier forwards it and then responder replies back and the Verifier replies back to the challenger. This is how the structure of the game proceeds. So now I will go into the Bisection game in the next slide. So in that slide I will just focus on challenger and the responder their queries. But you should be keeping in mind while looking at that slide, that every round of communication goes through the Verifier.
00:20:50.194 - 00:21:43.078, Speaker A: So Verifier is inspecting all of these messages all along. Okay, so as I said, the goal of the challenger is to find the first point of disagreement on the responder's directory with respect to its own derivative. So before anything, let's first look at where is the first point of disagreement. So the first point of disagreement is the first three entries look good, but the fourth entry is different because this responder has TX three prime and then it has SD three prime, whereas challenger has just TX three and SD three. So we will count ourselves as successful if the challenger indeed identifies that point. Okay, to identify so far the challenger also only knows the responder's directory route because that's what the responder sent so far. So the challenger knows that the responder's directory route is different.
00:21:43.078 - 00:22:13.454, Speaker A: So it's going to tell the responder, hey, reveal the two children in your tree of this route. Then the responder reveals these two children and sends them back to the challenger. Now the challenger and the light client check. If we hash these two children, does it equal to this original route? If not, then it's obviously that the responder is lying. It's like sending wrong information. Then we immediately identify it as malicious and the game is over. But now responder could be smart.
00:22:13.454 - 00:22:41.050, Speaker A: It will maybe send correct children. Now this hash to the root. Everything is so far good. Now the challenger checks. Do these two children of the root, whether are they the same as mine or not. So now, in our example, suppose they are both different. This tells to the challenger that the first point of disagreement on the responder's tree with history should lie on the left hand side of the dirt tree of the responder.
00:22:41.050 - 00:23:17.622, Speaker A: Now then the responder queries the different child on the left hand side. Sorry, the challenger queries it and the responder again reveals these two children. And then now suppose the left hand side actually matches the left hand side on the challenger side, and the right hand side is different as a result. Now, the challenger knows that the first point of disagreement lies to the right of this part. It should lie on this part. So it's now going to query the two children of this node. The two children are queried and it turns out these are the same.
00:23:17.622 - 00:24:06.482, Speaker A: And this is the difference as a result. Now, challenger has identified TX three prime, s T three prime as the first point of disagreement between its dirty tree and the dirty tree of the responder. And it has also identified this one, TX two S T two, as the last point of agreement. Well, the last point of continuous agreement. Okay, so these informations are also witnessed by the Verifier, who is witnessing all of this communication. Now let's go back to the Verifier. So, Verifier has been told by the challenger that the first point of disagreement between the challenger and the responder is TX two to TX three prime and SD two to SD three prime.
00:24:06.482 - 00:25:04.070, Speaker A: This transaction sequence and this state transition, that's the first point of disagreement. And it seems like the responder is also agreeing with this assessment because the replies of the responder seem to indicate that this is indeed the first point of disagreement between them. So now the task of the Verifier has suddenly become very simple. The only thing it has to do is to check if this transaction, TX three prime indeed follows TX two and if SD three prime indeed follows SD two. So if both of these transitions are correct, then it means that the responder should have been the truthful party, because the challenger should have been must have been challenging the responder for no reason. But if there is actually a mismatch here, then it means that the responder has constructed this dirty tree incorrectly. So now in this example, as indicated by the color red, the responder is the malicious party.
00:25:04.070 - 00:25:43.810, Speaker A: And then TX two is followed by TX three instead of TX three prime. And as a result, the Verifier understands that the responder is lying. And then the correct order tree root is H as given by the challenger, and challenger is telling the truth. So the correct answer is yes. So this is basically how the protocol works. So we have also implemented the protocol on like 17 provers that are globally distributed on some AWS instances. And then we assumed a ledger sequence of 10 million transactions.
00:25:43.810 - 00:26:15.274, Speaker A: So M equals 300 is a degree of R 33. It's not two, it's 300. I will come quickly. Why it's such a large degree? And then there are four rounds of interaction per game because the height of the tree is approximately I guess it will be something like four. And then each Light client runs 16 games. Why is it not only one game? Because you don't contact one or two peers. You contact like eight peers or like more peers.
00:26:15.274 - 00:26:48.062, Speaker A: So that's why it runs 16 games. We have a tournament that determines how many games it should run. And then this Verifier, we just assumed a college laptop with some college internet connection. So it's 300 megabits per second downlink and ten megabits per second uplink. And it turns out these 16 games run in 18 seconds. And then this could of course be improved. So we have some improvement ideas on how this latency can be further decreased for this Light client.
00:26:48.062 - 00:27:32.520, Speaker A: But many blockchain protocols also confirm things in like tens of seconds. And then this is the latency as the ledger size grows. So it's not linear, it's like a logarithmic because the scale is logarithmic on the x axis. Okay, so why the 300 degree? It sounds like a ridiculously weird tree. The reason is we made some calculations and it turned out like the minimum expected latency for the given bandwidth and given tree sizes is as shown here. And then we also made some measurements and it seemed like the latency is minimized when we set the tree size to the degree of the tree. The number of children per node, 300.
00:27:32.520 - 00:28:11.220, Speaker A: And yeah, so this is one of the first Light Client constructions for lazy blockchains. So this is a table of summary. So as you can see, the full node needs to download all of the headers and download all of the transactions, execute them. Whereas now we can only download the headers and we don't need to download L transactions. We can have logarithmic communication complex for a Light client. The C can also be further reduced to log C using interesting idea called Super Light Client. And for details, please check out the paper.
00:28:11.220 - 00:28:25.990, Speaker A: Any questions? I'll be happy to yes.
00:28:26.520 - 00:28:30.040, Speaker B: Can I just ask the complexities or average?
00:28:30.780 - 00:28:32.330, Speaker A: These are worst case.
00:28:36.780 - 00:28:51.580, Speaker B: Awesome. By the way, I just wanted to ask is this accessible to getting? Can you just spam this with a bunch of because it's on the P to P layer. You don't have an arbitration contract.
00:28:52.400 - 00:29:35.492, Speaker A: Yeah, this is susceptible to dos. We discussed this in the paper. Well, our naive solution is like what everyone else uses, which is maybe the Light client can blacklist the provers that are like dosing it. That is one solution. And then many optimistic solutions are this is like if you think about it's like an optimistic solution because we have an existential honesty assumption one honest peer assumption plus the synchronous assumption for the network. So, like other optimistic solutions, this is susceptible to Dosing and could perhaps be improved by research on how to avoid Dosing in these systems. To completely avoid it, you can go all the way to ZK.
00:29:35.492 - 00:29:58.700, Speaker A: So one potential solution for the same light client approach is using recursive of Snarks or recursive Snarks. I don't know if they exist, but yeah. Cool. I guess there are no more questions. Thank you.
