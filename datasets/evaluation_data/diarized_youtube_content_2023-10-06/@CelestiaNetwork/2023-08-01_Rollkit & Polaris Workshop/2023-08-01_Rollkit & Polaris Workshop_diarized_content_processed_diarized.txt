00:00:00.330 - 00:00:50.602, Speaker A: Thank you, everyone, for coming today. Today we're going to be doing a little demonstration and workshop regarding Polaris, which is the EVM framework that we've created in order to get all the EVM goodness on bear chain for a little bit of context. Bear chain is the EVM compatible, all one built using the Cosmos SDK. We replaced kind of the traditional proof of stake model with something we call proof of liquidity, which incentivizes validators and node operators to provide liquidity as part of securing the network. And as part of this, we felt that EVM compatibility was something that was really important to us. The background of kind of my co founders and a large part of the core team was from the EVM ecosystem. And despite, like in Cosmos, we love Cosmos, but we really wanted to make sure that our friends and builders in that ecosystem were able to participate in our chain and felt that we wanted to provide them an EVM experience that was equivalent and made sense.
00:00:50.602 - 00:01:20.550, Speaker A: So that's how we ended up where we are today. Along that journey, we became really good friends with the guys over at Celestia. Huge fan again. Appreciate them for running this conference and everything they do for us. Diego and I spent a lot of time getting not only Polaris working, but Polaris working with Rollkit and some other EVM frameworks as well. So that's what we're going to be demoing today, is showing how you can build your own Polaris chain, which is, again, Cosmos fully EVM equivalent, but have it post data to Celestia's DA.
00:01:20.970 - 00:01:52.190, Speaker B: Yep. Everyone. Hi, I'm Diego. I work at Celestialabs. I do a lot of stuff with bullkit, but also with other frameworks. And like he mentioned, we work together well multiple times on integrating Polaris, which is a Cosmos SDK like EVM library, and Rollkit, which is a drop in replacement for tendermint that allows us to take their software and combine it with ours to make EVM roll ups on top of Celestia.
00:01:53.570 - 00:02:44.318, Speaker A: So, to give a little overview of kind of the architecture of what we're going to be doing today, or part of the architecture of what we're going to be doing today, is that as part of kind of the test of ensuring that Polaris was a fully EVM equivalent chain, the RPC was working correctly. All the opcodes and everything were working correctly. We thought that if we can deploy an op stack roll up that settles on a player's chain, that's a really good kind of real world test to make sure that are all the rpcs responding correctly? Is everything working? Can contracts deploy? Can hard hat deploy work? Can foundry deploy work? All these things. So we were fortunately able to do that. And not only were we able to do that on a Polaris chain that's operating as an all one, but in addition, one that's actually settling on Celestia as well, utilizing roll kit. So if we go over to. Where's Chrome here? Oh, it's here.
00:02:44.404 - 00:02:44.798, Speaker B: Perfect.
00:02:44.884 - 00:03:24.522, Speaker A: So if you guys want to go over to GitHub.com parachain slash players, you'll see this is our core repo. So it contains a wide variety of packages regarding, or a wide variety of modules, I should say, that are used in order to make up kind of the core players framework. One of the core distinctions that we made as part of this was we really wanted to bifurcate all of the things that are happening in the Cosmos runtime versus things that are happening in the EVM runtime. So what we did is we have an actual full kind of ETh module that has all of our common ethereum logic. So this is kind of what's interacting with the state machine. This is handling all of kind of the rpcs, just all of the state processing, et cetera.
00:03:24.522 - 00:04:05.190, Speaker A: And then our actual cosmos side of things really just is a communication layer that allows the cosmos client to communicate with the ETH client. And that's a big part of what allowed us to get that true raw EVM compatibility is we weren't reinventing the wheel. We weren't trying to take tendermint rpcs or take something about Cosmos and make it look like Ethereum. We were like, okay, how do we take Ethereum and make it so that cosmos can communicate with it? So secondly, if you go to here, so go to bear chain modular. So it's modular summit workshop 2023 with all the dashes and stuff. So this is basically what we're going to be doing today. So the first thing we're going to do is we're going to spin up a local Celestia Devnet.
00:04:05.190 - 00:04:43.110, Speaker A: Then from there, we're going to configure the Polaris repo to be able to post to that Devnet that we're running. And then basically, we can go from there. We can make sure we have foundry installed in order to deploy contracts, do the setup, et cetera, and then we can start the chain and start to interact with it like any other EVM chain. So if we look over here, basically we have Polaris repo here. What you want to do is you want to check out this specific role kit branch. If you go on Twitter and see any memes or know Scott Sinardo, you'll know that Diego works tirelessly and effortlessly every night putting together new roll kit branches.
00:04:44.250 - 00:04:46.674, Speaker B: Yeah, chief branch officer.
00:04:46.722 - 00:05:22.420, Speaker A: Branch officer. Fortunately though, due to some creativity, we'll say setting up a Polaris chain to utilize roll kit over in lieu of command or tendermint. It's pretty simple right now. All you have to do is just, you'd have to do a simple replace statement of the SDK just to get the roll kit compatibility. And then this protobuff replace that. If you've been in cosmos for a very long time, you will know how much we love this replace here. One day we'll get rid of this in the roll kit version, but for now, for now it's here.
00:05:22.420 - 00:05:56.030, Speaker A: So, yeah, kind of going back and following our instructions here. If you just copy this guy here, you'll be able to spin up the local Celestia da should boot up. Takes usually a minute or so. Now, once this boots up, the one thing we'll have to do is we'll have to copy this authentication key. This auth key is basically to prevent anyone who isn't you from basically spamming your full node or light client. But you have to copy it over, which is something that we discovered. Setting this up can be a bit of a cumbersome process.
00:05:56.030 - 00:06:25.880, Speaker A: So the roll code guys will hopefully be sorting that one out soon. Coming soon. But there should be an auth token that comes up here, right? So you'll see this little message here, and then you'll get this big auth token guy here. If you go back into Polaris here and go into just this basic init script, all you have to do is scroll down to the bottom. This is probably really small, I just realized you need to go down to the bottom here, and basically there's this auth token place. You'll just want to go replace this guy here.
00:06:26.570 - 00:06:36.650, Speaker B: And this is just for the workshop. Usually if you were running this on a testnet or live, it wouldn't print the auth token. You would have to get it from a file.
00:06:39.070 - 00:06:58.142, Speaker A: Once that's set up, we can just run mage start. For anyone who doesn't know mage, it's like a really cool alternative to make files that allows you to write your logic in actual go scripts. So it's kind of nice for doing complex things. And we give it a second here and it should start producing box validation ignored. But Diego assures us that's okay.
00:06:58.276 - 00:07:05.700, Speaker B: Yeah. That should be a warning. We'll get fixed in the next branch release. Next.
00:07:09.510 - 00:07:16.486, Speaker A: It. Give it a second here. I've been assured by Diego that this works. So if it doesn't know, dude, we.
00:07:16.508 - 00:07:18.040, Speaker B: Ran it like 5 hours ago.
00:07:18.890 - 00:07:41.950, Speaker A: So there we go. We can see that we've successfully submitted a roll kit block to the da layer, which is super awesome. And then from there what we can do is we have a fully EVM compatible chain. So we can go and we can, in the Polaris repo there's some example contracts. So if we go into. Where's an example here? If we go into source, what do we got? Maybe some testing contracts. So consume gas is one of the contracts we have.
00:07:41.950 - 00:08:20.250, Speaker A: So we could do like a quick forge, create, consume gas. And then if we look over here we have a few private keys and stuff that are funded. So we can do forge, create, consume gas. And then what do we else do we need to do here? Because we got to go back. We do like forge, create, consume gas and then we could do like private key equals this. And then you could do RPC URL. And this is just going to be your traditional localhost 8545 that anyone in the Ethereum community is familiar with.
00:08:20.250 - 00:08:32.758, Speaker A: Give that a second. Or in the case of this guy, maybe a few seconds. So maybe dago. If you want to elaborate on some of the updates that are coming that will allow the block time to be a little shorter.
00:08:32.874 - 00:09:27.380, Speaker B: Yeah. So currently roll kit is set to make blocks no more faster than the underlying l one or da layer. So in the current local devnet, the celestic intern is going at like 15 seconds per block, which means that roll kit cannot safely go faster than that. At the moment, however, we are working on this thing called block sync, which essentially allows roll kit to give users soft confirmations, meaning next time we run something like this, it would be very fast. It's essentially the same concept behind l two s, like optimism or arbitrum, and how their sequencer gives users a soft confirmation when in reality the finality of those transactions takes longer than a second.
00:09:28.070 - 00:09:45.334, Speaker A: Sweet. So yeah, as you can see, now that the blocks gone through, we have deployed smart contract. This was a deployer address deployed to here, et cetera. We have full cast RPC compatibility. So we can do like cast receipt here. Sorry, cas code, my bad. Cast code.
00:09:45.334 - 00:10:12.798, Speaker A: We can see that all the code was deployed. So that's our little consume gas contract. It's just a for loop that I think does hashes or something we can do cast TX. You can see all the information about the transaction it went through, the gas price, how much gas it consumed, who the sender was, what block it was included in. And we can do this for the receipts as well. And this just kind of shows, like, we wanted to make sure that even though it's technically running on. I think I copied it wrong.
00:10:12.798 - 00:10:52.542, Speaker A: Yeah, I did cast receipt that even though it's running on Cosmos, and this is a fully cosmos chain, we want to make sure that all the tooling, hard hat foundry, all these things work perfect. And again, we can do, like, cast block. We can see here that that was our transaction that was included. There was some gas used because we had the transaction in there, et cetera. And, yeah, so that's the basics of running a Polaris chain and running it on rulekit and using the Celestia da for data availability. So I hope this looked pretty simple. And if anyone has any questions or anything or wants to run through it, we'll be hanging out here for a bit.
00:10:52.542 - 00:10:56.480, Speaker A: And. Yeah, Diego, anything else want to add?
00:10:58.450 - 00:11:07.410, Speaker B: I don't think so. Awesome. We have evidence of the opstack roll up running on Rokit, running on Celestia.
00:11:09.830 - 00:11:14.642, Speaker A: We can show that guy as well here. So here's actually running.
00:11:14.696 - 00:11:15.054, Speaker B: Whoops.
00:11:15.102 - 00:11:25.314, Speaker A: Here's actually an example of it running all three. So if we kind of step back here so we can see that we have the Da up and running. Then over here we have the Polaris chain.
00:11:25.362 - 00:12:06.470, Speaker B: Yeah, Polaris roku chain. And soon, this video should show the op stack chain that's running on top of the Polaris chain. There it is. I believe that is the op batcher, op node, et cetera, essentially showing the architecture of that diagram that we had in the slides. It's not a regular op stag roll up because it's directly connected to Celestia for DA. Maybe we can show the diagram real quick. That video essentially is like proof that we were able to run this sometime before this workshop.
00:12:06.470 - 00:12:42.430, Speaker B: But essentially, it was a good test of how good Polaris is at being the EVM, because if you try and deploy even a regular op stack roll up on some quote, unquote, evm compatible framework or chain, you're going to find that it doesn't work most of the times. So it was a very pleasant surprise that it works with Polaris and especially with roll kit. And, yeah, can't wait to see people, I don't know, deploying l three s and l four s and beyond with Polaris and op stack.
00:12:45.470 - 00:12:46.682, Speaker A: Sweet. Thank you, everyone.
00:12:46.736 - 00:12:47.820, Speaker B: Thank you. Thank you.
00:12:50.830 - 00:12:54.940, Speaker A: Any questions? Do a quick q a before you move on.
00:12:59.100 - 00:13:00.970, Speaker C: What's an example of?
00:13:06.520 - 00:13:15.370, Speaker A: Would you use this architecture? Diego, maybe you want to elaborate more on the benefits of breaking up the settlement in the DA for the l three.
00:13:20.140 - 00:13:50.020, Speaker B: Somebody would probably want to do this if, let's say, you already. Okay, so let me trace back. Assume there's already, like, a Polaris roll kit, l two on Celestia. Right. And for some reason, we see that that's not enough in that single instance. And we want to be able to essentially scale more. We can have l three s on top of this instance.
00:13:50.020 - 00:14:35.164, Speaker B: I think realistically, it would be more for the purpose of having more dedicated space. Like maybe the Polaris roll up on top of celestia is more of a general purpose roll up for people to deploy applications, defi stuff, nfts, et cetera. But people want to deploy app specific rollups on top of this general purpose roll up. There's also other benefits. Assuming that this op stack roll up on top of the Polaris roll up is not the only one, you do get some form of. Well, not some form. You get very strong guarantees for, essentially, cross roll up transactions.
00:14:35.164 - 00:15:28.572, Speaker B: Right. Like you would have one of the op stack rollups on top of Polaris. Like, make a transaction to the underlying Polaris roll kit, and then the other roll up, because it shares the same settlement layer, can read this transaction, and essentially, you can have the same benefits that you get from having l two s on Ethereum. Right. You get the same form of synchrony guarantees, essentially. And, yeah, I guess to finalize the other reason why we would have this op stack chain post the transaction routes directly to Celestia instead of putting them to Polaris. Could be because, let's say the block size of the Polaris roll up is not the same size as the celestia block.
00:15:28.572 - 00:15:53.640, Speaker B: Right? Like, assume the Celestia block is like, I don't know, like ten megabytes and that the Polaris roll up, it runs at the same speed as the Da layer. Right. And has a maximum size of like, two megabytes. Right. That's a very small amount of data that you have to share with other people on that same roll up. When it will be cheaper to just post it on celestia directly.
00:15:56.940 - 00:15:57.930, Speaker C: L two.
00:16:02.700 - 00:16:09.410, Speaker B: Yeah, I mean, like, you know, the. The nomenclature around l one, l two, l three. And all that stuff gets confusing, to be honest.
00:16:10.180 - 00:16:12.736, Speaker C: Polaris is settled and roll up, right?
00:16:12.838 - 00:16:20.324, Speaker B: Yeah. It's a sovereign roll up. Correct.
00:16:20.442 - 00:16:29.556, Speaker C: But you could do like, faster batching, I suppose. Optimistic change. I had a question.
00:16:29.658 - 00:16:30.310, Speaker A: Yeah.
00:16:31.080 - 00:17:01.308, Speaker C: As an app developer and you're working with Precon files, do you start thinking from the solidity interface perspective or the go module perspective? Let's say, where does your thought process begin? I should first think about starting go modules or should I think about what interface I need from solidity? Because I never built pre compile. So I'm curious what your thought process in building the pre compiles?
00:17:01.484 - 00:17:50.590, Speaker A: Yeah, it's kind of both. And I can show some examples as well because I know a topic that a lot of people are interested in. For some of the standard Cosmos modules that we basically take a Cosmos module and then we build like a pre compiled interface around it, you sometimes have to kind of juggle both where it's like, okay, what's a solidity interface that makes sense for users? And then also how do we adapt or pattern that to a Cosmos module? And we've done a lot of work into making that developer experience really clean and kind of, I guess, unrelated to this talk. But I can show some examples as well. And basically how it works in Polaris is to first write a pre compile. You have to actually go in and you define a solidity interface. So we'll use the staking module as an example that I always like to use.
00:17:50.590 - 00:18:20.312, Speaker A: So isaking module delegate. You have all these events, right? Delegate, redelegate, create validator, very standard in cosmos. And then you have all of these read methods we'll use just for, again, an example. And they're pretty simple, right? Get validators, get active validators, get a specific delegation, et cetera. And we make sure to handle it in a way that is very solidity and EVM developer focused. Right? So this is going to be a hex address, something. Again, we don't really worry about Bec 32.
00:18:20.312 - 00:19:18.552, Speaker A: We don't really worry about any of that stuff. And then as part of the actual compilation process of the node, what actually happens is this will get compiled in big air quotes to basically map to an actual pre compile itself. So if we open the staking pre compile and there's a bunch of abstractions that are here that are doing it all under the hood as part of the build process. But basically you'll look at this here, and it looks very similar, right? Like maybe I should pull them up side by side. It might make a little more sense here now that I do this source cosmos precompile staking back here. So if you look at like, staking go, right, we have a getvalidator which takes, we'll use getvalidators example, right? So it takes an argument, which is a common address validator helper is just some function that does a bunch of stuff, doesn't do that much. It's just like data parsing.
00:19:18.552 - 00:19:49.024, Speaker A: So get active validator. Common address, returns a validator type. And then if we go over back to the solidity interface, get validator, right, takes an address, returns a validator struct. So basically what it allows you to do is it allows you to write pre compiles that kind of look like contracts. It's very much familiar typing like address, address, return a thing. Or let's use an example here. Like delegate takes an address, takes an amount, returns a bool.
00:19:49.024 - 00:20:45.424, Speaker A: And if we look at delegate here, same thing, takes an address, takes an amount, returns a bool. And we're always kind of iterating on these types of things as well. One of the things that we want to build next is kind of like a stronger type system for like numbers. So right now you can see that this amount is just a big int, but it would be cool. And one of the things we're kind of scoping is how do we make an actual Un 256 in go here and then do things kind of like what the SDK does with SDK math, right? Like have a Polaris math library that allows us to do things that kind of like, I don't know if you know, soulmate in solidity land, right? Have nice fixed point math libraries around it and really get the pre compile experience as close as possible to writing solidity. Because that's what I would say is like the end goal. And for instance, here you see that context that's passed in one of the first things we've done here.
00:20:45.424 - 00:21:02.204, Speaker A: I can show another example for the pre compiles is we have this. I think it's in here, wherever it is. I'm trying to remember where it is. It's like polar context or something. I'm trying to remember. It's been a while since I've looked at this. Yeah.
00:21:02.204 - 00:21:27.108, Speaker A: So here VM context. So this is what we pass in for the pre compile. So every pre compile function gets this context. The base context is going to be that SDK context, like unwrapping here. But then we also have nice things that allow for, again, very simple experience that's familiar to solidity devs, right? Like message sender is like who the caller was. Message value is how much ether was passed in block is like chain block. Right.
00:21:27.108 - 00:22:21.924, Speaker A: So we're trying to make it really easy for people who are really experienced with writing solidity smart contracts to translate that experience by using familiar terminology, familiar kind of code structure, use patterns, et cetera, and make it easy for them to build pre compiles as well. Yeah, no, there's some really interesting use cases. Not to plug Scott again, but one of the, like, I absolutely love the way that the guys at Argus are using pre compiles. They're not really using them for state in a way, but what they do is they use a pre compile that allows them to send over GrPC to all the different shards. So they actually use the precompile as like a gateway, as opposed to it being like, oh, we're storing state on the actual cosmos node. So I think those type of use cases are what personally, I'm really excited for, because it allows the EVM to kind of break out of its shell and be like, oh, I have an EVM, but I want to make a network call. Now.
00:22:21.924 - 00:22:32.680, Speaker A: I have the ability to do that because of pre compiles. And getting that dev experience on the pre compiles as good as possible is what allows for those use cases. So that's what I'm super excited.
00:22:34.480 - 00:22:49.144, Speaker D: About. The generated type. How are they generated? Are they generated from looking into solidity definition?
00:22:49.272 - 00:23:39.976, Speaker A: Yeah, exactly. So one of the beautiful things that gets provides us is it provides us this thing called abigen, which is a binary that effectively allows for generating these types. So again, as part of this build process, we generate these ABI gens. So if we look at staking module, for instance, we have a go generate that will automatically go and go and generate these types. So we have here like Cosmos Coin Commission description module validator and has all this information that we generate from the solidity interfaces itself. So the next thing we're kind of doing some work is finding a way to map the GRPC cosmos types to these in a really clean way using reflection and stuff. So we're getting to the point where getting the dev experience as clean as possible and reduce the barrier to entry.
00:23:39.976 - 00:24:46.580, Speaker A: For people writing pre compiles, we think that, my personal opinion is pre compiles. It's not like a race at the bottom in the sense of who can get the best WX, but it also kind of is, I think if you're a company or a protocol or a chain that needs pre compiles for some reason, the solution that you're going to go with is the one that allows you to have the best WX and to fulfill the need. So that's why I make sure that our team spends a lot of time playing around with this, testing the know, I have them playing around with ava lab stuff, playing around with op stack stuff, and seeing, getting feedback, playing with it, see how it feels. Because I think that in our case, especially once you get into topics of cross chain stuff, not really talking about it today, but like IBC as well. If you want a way to talk over IBC, if you want a way to talk to other chains, getting this pre compiled WX to the point where you can write secure, scalable code that is easy to audit, easy to make sure is secure, but also is able to talk to other chains, make TRPC calls, et cetera, is going to be really killer.
00:24:46.920 - 00:25:13.772, Speaker D: Another question is, you mentioned networking, so I'm kind of curious about pre compiles. I'm not an expert in compiles at all. IO is blocking. It can take some time. And how does the EVM with those pre compiles deal with such things? How do you price it? If there's a way to price it, and whatever the network calls take seconds, how would you change respond to that?
00:25:13.826 - 00:25:50.792, Speaker A: Yeah, so that comes down to kind of how I assume you're using, like, if I'm writing a pre compile that makes a network call to know, we'll use Scott again as example, like a shard or something, like a GRPC call. So that's something where you can do multiple things. If you have a three second block time and you have a 30 million gas limit, you could just do the math to figure out like, oh, if it's a 50 millisecond delay, we should add whatever the gas would work out to be for that. Like that part, something naive like that would work. Generally we have just timeouts. So you say if it takes more than 100 milliseconds or more than 50 milliseconds, then just kill it and just revert the transaction. Yeah, things like that.
00:25:50.792 - 00:26:04.764, Speaker A: So right now, I don't know what the exact limit is. Right now there may even not be a limit, but it's something we've thought about where, because we have that context, we can just set a deadline on it from when it enters the pre compile and then just have it.
00:26:04.882 - 00:26:10.404, Speaker D: Abortion fails.
00:26:10.552 - 00:26:16.610, Speaker A: Yeah, it's just EVM. The guess type would be EVM execution reverted in all our case.
00:26:17.140 - 00:26:29.412, Speaker D: Is there some way to do some sort of wrong job? Maybe there's something that can leave on the goaling side of things and somehow talk to EVM. Is this possible?
00:26:29.546 - 00:26:55.310, Speaker A: Yeah. So the other thing that, and I believe this is the way the Argus guys do it, but don't hold me to this. I'd have to ask Scott, is that you can basically have it. So the precompile triggers the job, but it makes the network call asynchronously, so you could make it. So the precompile is going to like, when you call it, it fires off the job, but it doesn't return anything. It's just like, oh, return pool success, job activated. And then another transaction later can go back and pull the result.
00:26:55.310 - 00:27:41.390, Speaker A: Much like how chain links like VRF works, for instance, right, where you have to make the one call, wait for it to come back, and then get it. Something like that, I think is, from a developer perspective, or like, if you're a builder perspective, probably the way to architect that, just so that you know that you don't have to worry about it stalling or causing a transaction to fail for some reason. Yeah, no worries. Does bear Upchain have its own validators? And if so, what are the advantages of using Celestia versus keeping everything within the bear chain? So right now, bear chain is a full all one. So we're not actually using Celestia for DA right now. But what we want to do is for Polaris. We want Polaris to get on as many chains as possible.
00:27:41.390 - 00:28:15.940, Speaker A: And part of that is making sure that it's compatible with frameworks like Rollkit. And we see kind of celestia as a really good partner in that regard, to make sure that people who are building EVM chains don't necessarily have to worry about bootstrapping a validator set, because it is a difficult thing to do. It's not easy, especially if you want to build applications that are scaling to millions of dollars. It's a responsibility to make sure that your validator set is good. So if you can offload that security while also getting the benefits of the NMT and the DA layer, then it's 100% worth it in a lot of use cases.
00:28:16.280 - 00:29:03.110, Speaker B: You can also, like we showed in the video and the slides, if you can deploy an op stack roll up on top of Polaris, that means that you should be able to in the future deploy roll ups on top of barachain, right? So then you could use bear chain as a settlement layer, which I think comes with multiple advantages given the way the liquid staking, sorry, not liquid staking, proof of liquidity stuff works, because ultimately, as a roll up one of the main reasons you want to have a validating bridge is to essentially gain access to the liquidity of the underlying layer. Right. So, yeah.
00:29:07.050 - 00:29:10.150, Speaker C: Polaris has a fee market in the EVM.
00:29:15.150 - 00:29:33.742, Speaker A: So how it works basically, is for exactly that. So the fee market exists in the EVM. Right now. We just use the. Literally, it's the Geth EIP 1559 code. It's literally just part of the block generation process. We're just like, okay, what's the parent hash? Or what's the parent header? And then just run the simple PI controller.
00:29:33.742 - 00:30:12.686, Speaker A: PD controller. I can't remember what it is. Yes. There's nothing really fancy in that regard. We have a thesis that the more code we can borrow from Geth and the execution client side, the better. And I'm giving a talk later today about how we want to move to a model that's, like, fully kind of execution client, consensus client, and utilizing kind of the cosmos side more just for consensus and pre compiles and stuff, while using, like, a fully minimal fork of gas or aragon or wrath or whatever, just to minimize dependencies and make it kind of. If you want to build some crazy cosmos thing, you don't have to worry about that, like, breaking the EVM and.
00:30:12.708 - 00:30:27.060, Speaker B: Kind of vice versa. Otherwise, what is the alternative? You write, like, fee market code in the Cosmos SDK, and then you have to hook it up to the EVM, and then it starts getting very messy very quick. Right.
00:30:27.510 - 00:31:02.240, Speaker A: Yeah. The big thing with Polaris is we wanted to simplicity first. So there's definitely some things that are really opinionated in the way we do things, because of the fact that we want to try to minimize complexity, because we see that as a big part of why a lot of these EVM frameworks end up not being EVM equivalent or have problems just because they're kind of spaghetti code and don't have clean dependency paths and architecture. Et none. No. Never. I would never name a Cosmos EVM framework that's full of spaghetti code and has problems.
00:31:02.240 - 00:31:10.900, Speaker A: Never. I would never do that team like that. Exactly.
00:31:11.670 - 00:31:13.060, Speaker B: They know who they are.
00:31:14.230 - 00:31:27.450, Speaker A: They know it's okay. We love them for providing inspiration to build this. I thought you were going to ask a question, Josh.
00:31:28.590 - 00:31:29.580, Speaker B: All right, awesome.
00:31:30.350 - 00:31:31.370, Speaker A: One more at the back.
00:31:31.440 - 00:31:31.674, Speaker B: Yeah.
00:31:31.712 - 00:31:33.740, Speaker C: I had a question about how the.
00:31:34.910 - 00:31:41.386, Speaker D: State is processed thanks to the set.
00:31:41.408 - 00:31:45.340, Speaker A: Of material for which piece. Exactly like the.
00:31:47.550 - 00:31:48.810, Speaker C: Settlement carrier.
00:32:03.350 - 00:32:05.138, Speaker A: This is probably a Diego question.
00:32:05.304 - 00:32:33.822, Speaker B: Yeah. So the Polaris cosmos as a gate chain is you can just think about it as a sovereign rollup that's running Polaris. Right. So it's like an EVM rollup. And because Polaris is good, and it's really good at essentially being. It almost acts like a pure EVM roll up at that. It's almost like if you took Geth and just made it a roll up, it's almost like a very similar philosophy to what the folks at op labs have.
00:32:33.822 - 00:33:00.694, Speaker B: Right. The op stack chain essentially works in the same way that an op stack chain settled on Ethereum would work. Right. Like, ultimately, the ordering of the blocks and all that stuff is down to the sequencer for the op stack chain. And then stuff gets posted to Polaris. And in this case, in our diagram and for the video that we showed, the DA gets posted to Celestia. But that doesn't have to be the case.
00:33:00.694 - 00:33:31.070, Speaker B: You could build, like, a pure vanilla op stack roll up on top of Polaris using rollkit or on top of Polaris on vera chain. Right. I hope that answers a question. There's nothing different in this setup that you would see somewhere else. It's almost like you could almost cover the celestia part. And I can just tell you that that is Ethereum and that that's all.
00:33:31.140 - 00:33:50.978, Speaker A: Like, this diagram that we've built is just like one. There's hundreds of literally infinite ways to glue this all together, right? Yeah, it's just one. We chose where we thought it was kind of an interesting use case that shows off kind of the work that these guys have done with op and then also roll kit, us, et cetera. So we thought it was kind of comprehensive in that regard.
00:33:51.064 - 00:34:00.964, Speaker B: Yeah. There's many ways to put a set of legos together, I guess. Sweet. Awesome.
00:34:01.082 - 00:34:13.750, Speaker A: Thank you. Thank you, everyone, for coming. I hope not only it was good for roll kit stuff, but also pre compiles. If you guys have any questions about pre compiles, come grab me after this as well. I'd love to chat about it.
00:34:17.400 - 00:34:17.970, Speaker B: Thank you. Thank.
