00:00:02.400 - 00:00:38.242, Speaker A: Okay, welcome everybody. The four people that are in this room today, we're going to talk about sequencers in l two's decentralized, centralized and shared sequencers. But also I'm going to explain how at Morph, we are approaching decentralized sequencers. So, yeah, let's get started. So, my name is Avril. I'm developer relations engineer at Morph. I used to be a developer before, and now I'm doing this kind of job that it's basically seven jobs in one's marketing, engineering, coming to hackathons, coming to workshops.
00:00:38.242 - 00:01:20.096, Speaker A: So that's what I do in morph. So let's talk about what is a sequencer. So here you will see how our diagram of Morph explains a little bit how everything is connected between our sequencer. So basically this is like roll ups. And this consists of several components. I would say each of them is pretty different. They share key components, like for example, the sequencer, which is basically the main component to pick up all of the transactions from the l two mempool, which the mempool is where all the transactions are going.
00:01:20.096 - 00:02:13.122, Speaker A: And then they decide whether to execute or discard the transactions and share this information between other nodes. Then we have the layer one roll up contract. So this is a smart contract that lives on Ethereum. And this receives the batches of the transaction data that happens on the l two network. This receives also a proof, either fault proofs for optimistic rollups or validity proofs, ck proofs for Ck roll ups to basically verify the batches. This is a very good diagram that I will give credits to Gerard Watts from Polygon. This explains really well the role of the sequencer on l two s.
00:02:13.122 - 00:02:54.806, Speaker A: Basically you will see that the user submit a transaction. These read the transactions from the mempool and they execute or discard them. Basically, without the sequencers, none of these roll ups transactions will be handled at all. And all of these batch the transactions up together and they send it directly to Ethereum to the main network. Basically, without this sequencer, there will not be a rolling up, which is like they're responsible for sending all of the transaction data that happens in the l two. And it's important to send all of the data batch to the l one. In this case, we are an EVM network.
00:02:54.806 - 00:03:35.820, Speaker A: So this sends to the l one, which is ethereum, and we have different type of sequencers. Each one is pretty different, I would say they come in different shapes, each roll up. Like for example, polygon, CKVM, linear base, optimism. All of them utilize its own sequencer. So they're basically using a centralized sequencer. Centralized sequencers are the most common kind of sequencer that all of these chains are using. They're used by optimism, arbitrum, sea casing, linea, scroll.
00:03:35.820 - 00:04:33.112, Speaker A: And this is basically a software that fetch all of the transactions from the mempool that they check if they're valid, and then they put the valid one into a batch to send to the main network to Ethereum. It usually is maintained by the core engineers of the roll up team. So it's basically owned by a single entity, which makes it really centralized. So it operates on a centralized server and also use a single account to post all of the batches to Ethereum. This has different benefits, but also has some limitations. For example, I will say the central sequencers focus only on software efficiency and basically the hardware performance. And this results in basically high performance, because we just have one single entity taking care of everything.
00:04:33.112 - 00:05:20.550, Speaker A: So this makes it faster. But at the same time, if a centralized sequencer fails, the roll up stops handling all of the transactions. And this can basically turn off the network, which it already happened with Linea, as we, I think it happened a few weeks ago. So the centralized sequencers basically control of the mem extraction and can potentially censor all of the transactions. And basically it's the opposite of what we are advocating for, which is decentralization. But as I said before, this has the benefit of having a high performance network. Then we have the shared sequencers, such as Preso and Astria.
00:05:20.550 - 00:05:55.330, Speaker A: And this basically allows multiple roll ups to share a decentralized network of sequencers. This is like in the middle of a decentralized sequencer and a centralized sequencer. Basically this is a network that sits in the middle between the l two and the l one. And anyone can basically, in a permissionless way, utilize the roll up as a decentralized sequencer for their own network. So they're almost like a decentralized sequencer service. As a service. Right.
00:05:55.330 - 00:06:43.760, Speaker A: I will say the benefit of shared sequencers is that they are advocating for interoperability. So they have interoper, sorry, I don't know how to pronounce that word. But basically they provide the value to users using roll ups that basically share the sequencer layer. That's why, for example, Astria and espresso use this type of sequencer. But you can see here in this diagram that they can be basically less trusted, but basically they can be more functional or more. Each one has, I will not say this one is better, this one is worse. Each one is different and for different priorities of each network, it just works better for them.
00:06:43.760 - 00:07:18.530, Speaker A: But at Morph we are actually approaching a decentralized sequencer. So I will explain. This is a diagram of how our. It is pretty complicated, but I will go through it. Basically, a decentralized sequencer uses the centralized network of nodes to perform all of the responsibilities of the sequencer. It's basically more time consuming, less consistent, and it's more expensive to call upon a decentralized network of nodes to act as a sequencer. Right.
00:07:18.530 - 00:08:34.770, Speaker A: But the benefit here is that we don't have a single point of failure because we have multiple sequencers running, right? For example, in Morph we have right now seven sequencers in our testnet that are being run by us. But for Mainnet we are approaching to open to partners, plus 20 partners will go through a stake in election process to run their own sequencers. How it will work basically to join this group, these participants need to point to put down some kind of eth as a kind of promise, right? And this is done through the staking contract that I've mentioned before. And they will need to go through an election process to become a sequencer. We will be pretty selective at first for security reasons, but this is a way to make sure that only serious and committed participants get to do the job of being a sequencer. And once they're part of the sequencer set, their main task is to take all of the transactions that haven't been confirmed yet and put them into blocks. So this generates the blocks for the l two, and then they work together to check and agree that everything in those blocks is correct.
00:08:34.770 - 00:09:27.058, Speaker A: They valid the transactions. Then we use a method called tendermint consensus for this agreement, which is a straightforward way to basically all the sequencers to make sure that they're all seeing the same transactions in the same order. And this helps the network be more secure basically. And after they agree on the transactions, these are officially recorded onto the main blockchain. So they send all of these transactions to the l one. And this is basically how the L2 blocks generation are made. Basically following this consensus protocol, which is bftemental, the selected sequencer extract all of these transactions from the mempool and constructs the blocks.
00:09:27.058 - 00:10:17.386, Speaker A: Basically they build the blocks, they synchronize these blocks with other sequencers, and they go through verification and voting. And the end result of this is basically the generation of these new blocks. And this is how basically the network managed to process the transactions. We use a technique called batching so it's something called batch submeter. And normally each block of transactions will be sent to the main blockchain, the l one, one at a time. And basically this can be pretty slow and expensive. So to solve this, the sequencers use basically a technique that basically they put together all of the transactions into, into what I mentioned before, the batches.
00:10:17.386 - 00:11:02.510, Speaker A: And then at certain points in time, the checkpoints, they use a BLS signature to verify that all of the transactions are valid. And so the job of the selected sequencer is to send all of these things to the layer one contract. And when basically the final state of these transactions are agreeing that the transactions are valid. And they basically, the layer one received this, they check that the submitted signature matches with the transactions and they agree with everything and it's completely secure and valid. So you can see here how everything is connected between the sequencer to the roll up. Smart contract.
00:11:03.050 - 00:11:16.890, Speaker B: I have a question, I don't know if. Yes, sure, because each sequencer is running sort of like the same set of transactions. Who gets the key? Does the network share evenly across.
00:11:18.630 - 00:11:38.668, Speaker A: Basically. So the first year, for example, if we're running a sequencer, the first year, you will have 100% sequencer fee. Like you will, basically, you will need to pay the fee. Right. But then we will give it to you the first year if you're running your sequencer. So you will not pay the fee. You will not pay the fee the first year.
00:11:38.734 - 00:11:57.352, Speaker B: Right. And what about like mev extraction? Because obviously in the sequencer, I order some of the transactions in a way that maybe I can extract some mev, because a bunch of sequencers, like, let's say three sequencers running the same set of transactions, like who gets to keep the mev? Who gets to keep the.
00:11:57.456 - 00:12:16.250, Speaker A: Yeah, I'll say in this case the l one, but I'm not really. So, because we're approaching to open to partners right now, it's a being run by us. So I'm not really sure how we are approaching that for Mainnet, but that's a good question. So, yeah.
00:12:17.990 - 00:12:24.918, Speaker C: Is the implementation of the different sequences the same in terms of how they match the transaction?
00:12:25.014 - 00:12:26.086, Speaker A: Yes, it's the same.
00:12:26.198 - 00:12:27.142, Speaker C: So it's the same.
00:12:27.206 - 00:12:27.406, Speaker B: Right.
00:12:27.438 - 00:12:35.822, Speaker C: And how is, is it gonna if you work with partners? Like how, what's the incentive to compete.
00:12:35.846 - 00:13:23.010, Speaker A: Against a shared fee? Basically, yes. So basically all of the sequencers are the same because we basically, they need to go through the same stake in election process. So it will work in the same way. But then they will have a share sequencer, like share sequencer fee and they have this benefit of the first year, they will not have to pay any fee. And this is a way to incentivize partners to run their sequencer, basically. Okay, so yeah, basically all of this works together to send to the l one. And I would say, as I mentioned before, I explained the three types of sequencers.
00:13:23.010 - 00:14:13.530, Speaker A: Right. There's nothing that centralized sequencers have their own benefits. As I say, they are more high performant, they have one single point of failure and the network can really turn off. And at morph you're really trying to approach be fully decentralized. So I would say for Mainnet we are expecting to have multiple partners to run their own sequencers. And by next year, because we are launching mainnet next month, we will open even more slowly, we'll be opening to partners and we will have plus hundred sequencers running. And yeah, it's just very exciting because the only l two that is right now implementing the centralized sequencers is Metis and us.
00:14:13.530 - 00:14:44.250, Speaker A: So we are pretty, we're trying to make the difference into that. And as you know, Morph is a VML too that approaches this. But also we are using optimistic ck Vm to become a fully ck roll up. So our main, our main priority is to be as cheap as possible and as fast as possible, at the same time approaching fully decentralization. So yeah, I hope you enjoy this workshop and yeah, thank you.
00:14:45.230 - 00:14:50.410, Speaker C: What's the speed difference between decentralized and centralized sequencer right now?
00:14:51.340 - 00:14:55.948, Speaker A: I explained before, but I can explain to you again, is there like a.
00:14:56.124 - 00:14:59.280, Speaker C: Specific time difference or multiple?
00:14:59.620 - 00:15:13.116, Speaker A: No, it's just the centralized sequencer is being basically run by the core engineering team of the roll up and they are just in care of taking all of the transactions to put together into.
00:15:13.148 - 00:15:25.480, Speaker C: There'S times that they start batching all the transactions to when they post. So for the decentralized implementation, what's the difference? Because you say it's slower, but like.
00:15:25.520 - 00:15:27.440, Speaker B: By how much, you mean like latency?
00:15:27.520 - 00:15:29.240, Speaker C: Yeah, what's the latency difference?
00:15:29.320 - 00:16:04.276, Speaker A: Okay, so, right, I mean, it depends on the network. I'm not sure what's the latency? Or the TPS of, I don't know, Polygon, I think they have like seven TPS. I'm not sure. Right now our TPS is 20, but yeah, it depends on the network, I would say. And also the centralized sequencers are, it's just multiple sequencers. So let's say if one fails, we have other ones to support that. Right? And so yeah, also, like, that amount.
00:16:04.308 - 00:16:08.812, Speaker C: Of latency makes a very big difference in terms of arbitrage.
00:16:08.916 - 00:16:43.020, Speaker A: Yes, exactly. So I would say that's why I was saying that it's more time consuming than the centralized sequencer, and it's definitely not the best for high performance. But there's one Ethereum upgrade that I don't remember the number right now, the EIP that is going to come in in January, that it's going to fix a lot of these things that the centralized sequencers are approaching right now. And that's why, for us, we are expecting to open really slowly to partners to run their own sequencers. And right now we are, our core engineering team is running all of this, seven sequencers.
00:16:43.400 - 00:17:15.174, Speaker B: And then obviously, you know, there's very few robots that are either, like, they're all running pretty much their own sequences. Like, optimism is the only one that's sort of starting to decentralize, would you say? So that arbitrum, all these big altus are there like your target audience, I guess, or your clients? And then also, like, can you run multiple different l two s with your shared sequencer network?
00:17:15.262 - 00:17:20.090, Speaker A: Oh, so you mean if one partner can run multiple sequencers.
00:17:20.990 - 00:17:30.558, Speaker B: Yes. And also, like, you know, you're running the sequences for optimism from arbitrum from all the different l two s?
00:17:30.614 - 00:17:52.380, Speaker A: Yes, yes. So it's actually, for example, only one. Let's say you're a partner, you can only run one sequencer. But this is because this is the way that we're approaching it right now. It will change over time depending on how we're approaching the Ck roll up as well.
00:17:52.720 - 00:18:06.192, Speaker B: So if I'm a partner and I want to run different sequences for you guys, I'll have one sequencer that's sort of running for arbitrage, one sequencer for optimism, one sequencer for.
00:18:06.296 - 00:18:25.732, Speaker A: Yeah, just because it's different methods. Right. To approach that. Because in our case, you will need to go through all of this, like all of this process that is basically the staking contract. And it depends on each network. Right. But in our network, you can run one depending on if you get selected to do the job or not.
00:18:25.732 - 00:18:27.880, Speaker A: Yeah. Okay.
00:18:28.780 - 00:18:35.588, Speaker C: Would running a different. So you said that the implementation for all the sequences were the same.
00:18:35.644 - 00:18:35.836, Speaker B: Right.
00:18:35.868 - 00:18:46.660, Speaker C: But then let's say, for example, if you run all the same sequences on the l two s right now, they will definitely have, like, different levels of performance.
00:18:47.080 - 00:18:55.512, Speaker A: Yes, yes. I would say it depends on how, you know, how they approach being maybe optimistic roll up or a CK roll up.
00:18:55.696 - 00:19:04.234, Speaker C: So will you guys like, expand into building different sequences for different layer tools or I.
00:19:04.312 - 00:19:12.102, Speaker A: That's a tricky question. I don't know, because that just depends on many things. That depends on many things. Yeah.
00:19:12.206 - 00:19:27.170, Speaker B: Okay, pretty cool. I have a question. Maybe it's a weird question, but earlier you talked about how the most trusted and highest efficiency was centralized sequencers. Why are they the most trusted?
00:19:29.760 - 00:20:14.940, Speaker A: So it's not like they're the most trusted. It's just when you're running our own sequencer, it's just kind of, okay, this only the single entity is taking care of all of the transactions. You know, it requires more time to run different sequencers. So if you just have one, only that one will take care of all of the transactions and, like, do all of this process, basically. That's why. But I will not, I don't know if I will call it the most trust, but it's what l two s are implementing right now, because approaching the centralized sequencers is not easy. It's pretty complicated.
00:20:15.060 - 00:20:17.452, Speaker B: It's also like it has more trust assumptions.
00:20:17.556 - 00:20:19.520, Speaker A: Not just exactly.
00:20:20.940 - 00:20:31.180, Speaker B: If you only have one sequencer, like, they can say, dude, I don't like Lucas sending me transactions. I'm just gonna censor. I don't want none of these meme code that you're training.
00:20:32.000 - 00:20:32.792, Speaker A: Exactly.
00:20:32.896 - 00:20:51.688, Speaker B: And so, like, you're basically trusting arbitram to include you in the membo, or at least, like, considering you. And then when you have a decentralized sequencer, you can sort of. Yeah. I mean, you're. There are some competing. Right?
00:20:51.784 - 00:20:52.420, Speaker A: Yeah.
00:20:52.880 - 00:20:55.672, Speaker B: They're not gonna censor. At least one of them might not censor you.
00:20:55.696 - 00:21:20.186, Speaker A: Right, exactly. Exactly. So I would say each one has different benefits. You can't achieve everything. You can't be the most, fastest network, the most decentralized at once because. But we're approaching to be that way. But, yeah, that's how we are approaching it right now, I will say.
00:21:20.186 - 00:21:41.608, Speaker A: Because we kind of sell ourselves, like, oh, we are a centralized sequencer. No, we are running our sequencers, but we have seven right now, and by may next month, we will have nine or ten. But that makes it basically, we have the advantage of not failing, like, linear.
00:21:41.704 - 00:21:42.336, Speaker B: Yeah.
00:21:42.488 - 00:21:47.792, Speaker A: Right? Yes, yes. Yeah, cool.
00:21:47.896 - 00:21:49.880, Speaker B: Okay, thank you.
00:21:49.960 - 00:21:50.632, Speaker A: Thank you.
00:21:50.736 - 00:21:55.500, Speaker B: Miss the whole presentation. Yeah, I missed it one more time.
00:21:58.340 - 00:21:59.480, Speaker C: Was our own.
00:22:02.420 - 00:22:03.560, Speaker B: Very interesting.
00:22:04.020 - 00:22:04.500, Speaker A: Thank you.
