00:00:03.320 - 00:00:26.304, Speaker A: Hi, everyone. Thanks for coming. I'm Simon. This is Beacon. We're from essential. So we're building what we're calling a declarative blockchain. And the goal of today's whiteboarding session is to give you a bit of an idea of what that is, why it is, how it is through the lens of what applications would look like for such an architecture.
00:00:26.304 - 00:00:47.124, Speaker A: So I'm going to give a bit of context of what we're building, and then we are going to go into a couple of code examples to kind of get into the space of how you go about building applications for this architecture, in this paradigm. Please interrupt with questions like, at any time it may be that those will be better answered once we get to the examples, but otherwise we'll do our best to answer as we go.
00:00:47.252 - 00:00:48.212, Speaker B: Or thoughts.
00:00:48.356 - 00:01:23.624, Speaker A: Or thoughts. Yeah. Comments, concerns, anything? Yeah. So I'll take you on a bit of a journey of how we got to what we're building today. So I suppose decentralized applications and blockchain more globally. Like, we started with bitcoin, and bitcoin kind of gave us the very first glimpse of what could be for those who've written scripts with bitcoin. Scripts basically predicate logic, where you can put the ability to spend Utxos behind arbitrary spending conditions.
00:01:23.624 - 00:02:08.228, Speaker A: So these are not showing complete programs. They are predicate logic which validate true or false. And if they validate true, those are the conditions on which you can spend coins rather than on the provision of a certain signature. So, like following on from that, like, historically speaking, there was like a desire to see, like, can we like endow in some way these, these utxos in some way with arbitrary state that they themselves control and over which they can define arbitrary state transition logic. We then, at least the way we see it, took quite a large jump to the Ethereum model where we suddenly we have this Ethereum virtual machine. It's like, why do we have the Ethereum virtual machine? What we're interested in is achieving consensus over state. That's what we care about.
00:02:08.228 - 00:02:40.450, Speaker A: The virtual machine is a means to that end. If we can all agree on the machine, and we can agree we have consensus over the inputs, we will necessarily have consensus over the outputs. And Ethereum called these things smart contracts. That term goes a long way back. 1994, I think Nick Schabot was the first to use the term, and he actually, from my interpretation, meant it somewhat more declaratively. These were conditions over acceptable and inacceptable states and transitions, rather than. Here are some execution steps that you need to follow.
00:02:40.450 - 00:03:28.770, Speaker A: So I feel like in terms of, as I said, we're building a declarative blockchain, I feel like we were very, very close to stumbling across this architecture quite some time ago, and we almost just missed it. We put everything on chain, all the execution behind this vm in search of it. Seems like it's a reasonable step if you're searching decentralization. All the computation need consensus over that. Actually, turns out that that's not the case if you approach things declaratively. So if you approach it from a point of view of my smart contract is just going to declare what kinds of state transitions are acceptable. I'm going to defer the discovery of what these state transitions are like, what this list of mutations is to some off chain agent, then all I have to do is verify these things on chain.
00:03:28.770 - 00:04:26.079, Speaker A: So arbitrary on chain execution is not necessary. Only on chain validation is assuming that you have some means of coming up with this state that's not on chain. So that's the missing piece then is like, where's this state coming from? And I think a lot of people have probably heard a lot of noise about the intent space, and they're sort of exploring this idea quite extensively. Who's incentivized to produce these solutions and under what conditions? That's not so much the topic of this session, but it's suffice to say that you can create mechanisms out of protocol where people are incentivized to propose state mutations, which you can then validate on chain. The chain doesn't care who calculated that state, just that it was calculated, and that once you run it through the conditions that you've written, that it's valid. This has numerous benefits, like user experience, better security, better auditability of contracts. It's much easier to audit something that is essentially a circuit.
00:04:26.079 - 00:05:03.452, Speaker A: It's just predicate logic than it is to audit something written in a virtual machine, particularly if that's a novel virtual machine for your architecture. There are benefits there. Lots of teams have tried to. I mean, the big example is scalability as we see it. Like a lot of teams have tried to come up with novel virtual machine architecture that improves scalability by having ever more efficient on chain execution. In our view, they're sort of optimizing something that shouldn't exist, like you can, if you can get by with no on chain execution, you should do and just validate instead. Instead rely purely on validating constraints.
00:05:03.452 - 00:05:38.638, Speaker A: On chain constraint validation is considerably cheaper than transaction execution. You can do it hugely, completely in parallel. There's no, if I'm providing here is an atomic state mutation. There's no notion of, at least within the confines of a single solution, there's no notion of order. So like, as long as if I pass out these things and people validate the constraints, they can do that completely in parallel. I don't need to do everything myself because there's no sequential order that I need to make sure is respected. So it's like a very high level view of what we're building.
00:05:38.638 - 00:05:46.070, Speaker A: It'll become more tangible once we go into some code examples. I'll pause there to breathe and see if anyone has any comments or questions at this stage.
00:05:46.570 - 00:06:04.386, Speaker C: So one thing, so you said there is, there are off chain ways to incentivize solvers to essentially fulfill your intent. Can you give one example of what's the way? Yes, the ways to do it reliably, at least in my mind, they're usually on chain, right.
00:06:04.418 - 00:06:22.702, Speaker A: So you can constrain, like if there's some state change that you want to have happen, like whatever that is, you can initially constrain some, for example, some balance that you own that says, I will unlock a small amount of payment and this could be in any token you want to an address that's to be provided as part of the solution.
00:06:22.806 - 00:06:24.582, Speaker C: But this is on chain, right?
00:06:24.766 - 00:06:31.334, Speaker A: The validation is happening on chain, but in a sense, the auction, insofar as this one is happening off chain.
00:06:31.422 - 00:06:39.408, Speaker C: Okay, but the reward payment is still part of the chain, right. Because the token that's spent, it's on the chain. That you also validate the logic.
00:06:39.504 - 00:06:58.104, Speaker A: Yes, it's on the chain, but it's not like a special case or anything. It's just part of the mutation that's involved. So it's kind of. Yeah, you can achieve it at the application layer. So applications can define their own auction logic on their own incentivization logic rather than trying to enshrine it like at the protocol layer.
00:06:58.152 - 00:06:58.900, Speaker D: Gotcha.
00:07:02.210 - 00:08:38.442, Speaker B: Any other thoughts, questions so far before we jump into a token example with this declarative paradigm that will hopefully make this clearer? It's not as much a transfer because there's no execution, because when you say transfer, it's like a verb that implies some movement, although it can be used as a noun too. So before, let's just define our token contract and see how everything works. So this is not a good line. Okay. So similar to other types of contracts that you have seen, we have, our contracts have storages. So we're just going to declare storage block and storages adjust keys and values just like any other state tree that defines state in that way. So in order to have a token contract, we need to have some notion of balances that belong to certain addresses or keys, and a logic to make sure that the state transitions that are proposed by the solver are actually fulfilling what the user wants, and the user defines what they want in terms of constraints.
00:08:38.442 - 00:09:52.420, Speaker B: So in order to represent those balances, let's just add a field here that is a mapping from addresses that are B 256 to the actual values. And then when I want to transfer some token, what I'm interested in is who I am. I mean, that's not what I'm interested in, but what everything else in the system is interested in, where I want to send these tokens to and the amount that I want to send. So I'm just going to define those as variables outside of the storage. Oh, actually, excuse me. So in order to define this logic, I'm going to create a predicate that is a set of constraints. So with the keyword predicates, by the way, this is the approach kind of pseudo code, but almost one to one, corresponding to the pints DSL that we are working on.
00:09:52.420 - 00:10:02.900, Speaker B: So we define this predicate with the keyword predicate that is a set of constraints.
00:10:03.880 - 00:10:15.166, Speaker A: Just that. If you want to, either in real time or later, read about the specifics of that programming language I've written in tiny one up here, docs, essential builders, you should be able to find everything okay?
00:10:15.318 - 00:10:48.660, Speaker B: And instead of the word transfer, I'm going to use state mutations or valid state mutations. That's even more accurate. So let's say it ends here. And so my contract is defined by the storage that it defines, and then the some predicates, there can be multiple predicates. So a predicate is a set of constraints, and a contract is a set of predicates and storage.
00:10:49.520 - 00:11:23.472, Speaker A: Yeah, so contracts can declare storage, in which case they own that storage. And the only way that that storage can be mutated is by satisfying one of the predicates. So you can think of a predicate as like a pathway to validity for that contract. It's very tempting to think of them as functions, because we're used to thinking imperatively, but it's that when a solver's going to come in with a whole set of state, we're going to run that state through one of these predicates. So you can think of predicates are going to contain constraints which we'll see. You can think of predicates as being like an and of all of those constraints, but you can think of a contract as almost being like an or of its predicates.
00:11:23.536 - 00:12:28.396, Speaker B: Yeah, great. Yeah. Like, let's just make that, I don't know, predicate a v, et cetera. And this is just an and so now we want to declare the from that we just talked about, the two and the amount. So these are going to be filled out by the solver, and we're going to get into that in a second. But in the core of it, what we want to do in this predicate, what we want to make sure happens, is that some amount of tokens is decreased from the balance of the from and it's added to the balance of the two. And how are we going to make that? We can refer to a value in the balances map that's declared in the storage here.
00:12:28.396 - 00:12:29.640, Speaker B: Sorry, do you have a question?
00:12:30.050 - 00:12:58.682, Speaker D: Probably jumping a bit ahead. Let's say you have multiple predicates defined, and I'm wondering about how you would solve for them, because maybe each of them, you get to take one and then it settles. And I assume you can't somehow solve for both of them because that might be contradictory, and then it reverts or doesn't function. So what happens if you define multiple predicates but each individually? They might be fine, but then, for example, how does the solver, apart from trying to introduce value or something?
00:12:58.746 - 00:13:46.946, Speaker A: I don't know, like, how do they decide which predicate should they solve? Yeah, so the question was about if there are multiple predicates and I can see a state mutation that would satisfy more than one of them. Like, how do I choose which one I target? That's actually done explicitly as part of the solution data. So a solver will say, these are like all my decision variables, and I'm specifically solving this predicate. Predicates, actually, they have their own address. So a contract has an address, and every predicate within that contract also has an address. And so a solution will say, like these decision variables solve this particular predicate. From the point of view of the contract, it sort of, if the same state mutation would satisfy multiple predicates, then either is fine if they both unlock the ability to mutate the state to the decision variables that are given in that solution.
00:13:46.946 - 00:13:52.374, Speaker A: But the process of picking out specifically which predicate you're solving for is explicit.
00:13:52.502 - 00:13:58.530, Speaker D: And you can solve multiple predicates as long as all the constraints are still there.
00:13:59.390 - 00:14:36.730, Speaker A: So you could submit a solution that contains so solutions can be contain multiple sets of solution data. Obviously, in order to be able to get things like composability, we're going to be solving not just the token predicate, but many other predicates that leverage its logic and extend its logic. So a solution is going to be solving many predicates in many different places at once. And you can solve. Yeah, a single solution can solve multiple predicates on a contract. It could even solve the same predicate multiple times, as is the case with, for example, a transfer. If I'm doing something complex, I'm going to be coming back within the same solution multiple times to resolve this predicate.
00:14:37.390 - 00:15:29.300, Speaker B: Yeah. So as long as the constraints are passing, the solution is going to be included in the block. But if in the block building stage there's some constraint that's not passing, when the state mutations have been applied, then that will not be included. Ok. Ok, so it's a bit of a syntax thing, but let's just do it, because why not showcase pines? So we're going to refer to a value in this balances map, and we do this with the keyword state. And let's say this is the from balance and it's storage balances, and from keyed by the from address. And it's the same thing for the two balance.
00:15:29.300 - 00:16:48.110, Speaker B: So I'm just gonna write it here. So now we're at the constraint stage, and for a valid state mutation that represents a transfer. As I just said, what I want is for my from balance to decrease by amount and to the to balance to increase by amount. So I'm going to declare that with the keywords constraints, maybe even make this like just syntax highlighting. And it's pretty straightforward. Oh, one thing that one syntax we haven't seen so far is the prime notation, and that represents the, the post value of this state's variable. So I want the post states to be the pre state minus the amount.
00:16:48.110 - 00:17:20.760, Speaker B: So because we declared this from balance as a state, by the way, this isn't an assignment, this is a constraint. So this is a Boolean here. And the pint compiler knows that because this is a state, a variable that is defined by the keyword state, then it should be checking the post value of that state and the pre value of that state. So all this happens with just this line. And then I want another constraint that does the same thing. I mean, the plus version.
00:17:23.030 - 00:17:26.758, Speaker A: I've implemented a delta macro for you if you want to use it in your example.
00:17:26.814 - 00:18:02.460, Speaker B: Okay. And a macro is just a shortcut. So we want the delta of the two balance to be the amount. Okay, so this looks good. This looks like it will do what I want, unless there's nothing. Does anyone, before I go on, does anyone see any problem or vulnerability or something that's missing here? That's. Yes.
00:18:02.460 - 00:18:17.838, Speaker B: You're not checking if there's enough balance. Yeah, true. That's true. We're not checking that. Not checking if the amount is positive. Yeah, that's a good point. It's also an answer to another vulnerability that's here.
00:18:17.838 - 00:18:43.710, Speaker B: So I'm just going to make a note of that and I'll add that later. We should be checking that. And one thing that we're not checking here is that what prevents this solver from not spending someone else's balance. So for that we need some kind of signature that will authorize the solver to decrease the from balance. Okay, great.
00:18:44.450 - 00:18:58.710, Speaker A: In a sense, what we have so far, we've taken care of the accounting from the point of view of the token contract. But for it to be useful at all, we need some way of constraining who can spend what. And that's what this signature is going to provide for us.
00:19:00.210 - 00:19:37.270, Speaker B: One other thing is that because constraints are all checked and parallel, it doesn't matter which order border I write them in. So I'm just going to keep adding constraints to the bottom or wherever there's space, it doesn't really matter. And I'm just going to assume that I have a. Actually it's not a constraint. Let's assume that. Oh yeah, let's make it a constraint because it's a bool. Assume that there's a micro like validate signature that takes in the signature and the data that the signature was signed over.
00:19:37.270 - 00:20:09.280, Speaker B: So that's the rest of the variables on the top, so the two and the amount here, and then recovers the signer. So that should be matching from. And let's assume that this micro makes sure of that. Okay, this looks better. But now we need something to prevent against a double spend attack or a double spend. So for that we need the nonce. So we're going to add the nonce and we need to keep track of the nonces in the storage as well.
00:20:09.280 - 00:20:16.220, Speaker B: And it's pretty similar. So just addresses, a mapping of addresses to some integers.
00:20:19.160 - 00:20:34.400, Speaker A: You'll notice there's a couple of concepts here that would usually be handled at the protocol level, things like nonces and signatures and things like that. In our design, we want the protocol to be doing as little work as possible. And so we are rather including these things at the application level.
00:20:36.340 - 00:21:09.304, Speaker B: Yeah. And again, I'm going to assume that there's a micro that, or just like take a delta or maybe some other logic that will be like in a micro safe increments non logic. But let's say that it's just the delta now. So we want to make sure that the nonce delta is one. But here the nonce is a again. So I'm going to abstract that out here. But I should actually be defining nonce as a state variable here because it's in the storage, but there's not enough space.
00:21:09.304 - 00:21:49.304, Speaker B: And it's the same thing that we did with these. So yeah, we're going to make sure that the nonce has increased by one, by the end of all this. Okay. And yeah, so you also want to make sure that the amount is more than zero. And we want that not only because otherwise, like all of this has been for nothing, but also because there's another vulnerability here that I'm wondering if anyone's, like anyone have any concerns about what's written here or anything that they would like to add. Before I go on to, do you have a question to a previous point you can ask?
00:21:49.432 - 00:22:19.040, Speaker D: So I'm wondering why not enshrine some of the complexity in the protocol so that the developers have an easier time building something out? Because if you essentially get it all the time, there's going to be more simplicity at the application layer, constraints are going to be easier to write and so forth. Syntax may be nicer, so I understand the simplicity and it's easier to work with and all that's preference. So why choose to push the complexity up to the developments?
00:22:19.780 - 00:22:23.108, Speaker B: Flexibility is one of the key factors, I think.
00:22:23.204 - 00:22:51.646, Speaker A: Yeah. And also like fundamentally everything that's happening within a solution is order independent. Like it's, there's no, I'm not like, I wouldn't conceptualize this. And soon we'll see, we'll go to another example that will be applying constraints to other predicates. So applying constraints to decision variables that live on other predicates. Nonetheless, the correct mental model is not to imagine it being like a call out, like something is happening. This is being validated and now this is being validated.
00:22:51.646 - 00:23:06.648, Speaker A: Everything is sort of validated in parallel. And because of that, if you have like a global nonce, you kind of get into a mess when you attempt to be reasoning about those things on other, on other predicates, which we'll get to when we get to the ammonia.
00:23:06.664 - 00:23:44.630, Speaker B: Yes. Okay, so with the signature and the nonce. We have added some protection. But there's one other thing that is missing here, and it's that everything that is constrained here is kind of like, okay, like it's under control, but everything that is not constrained. So the negative space of constraints, in a way it's tricky. Like the solver could just change the balance of some other key and we wouldn't know because we're not checking that. Not every other key is being mutated.
00:23:44.630 - 00:24:05.400, Speaker B: So for that we have this intrinsic that is very helpful. And that is the mute keys. Len like the mute mutable, the length of mutable keys. So we want to constrain that in this predicate. All we want is for two keys here to change and we don't want anything else to be touched. So we're just going to add a constraint that will make that possible.
00:24:06.260 - 00:24:18.720, Speaker A: There are actually a number of ways that you could expose this concept at a high level in a language here, for simplicity, we're reasoning about the length of the keys because it's concise to do so. You can also reason about specifically which keys are mutable in this context.
00:24:20.220 - 00:24:27.196, Speaker B: But here, because we forgot what now we should constrain that the amount is zero, as we just talked.
00:24:27.348 - 00:24:32.520, Speaker A: If you want, we'll take the storage block as given, and you can carry on running constraints at the top.
00:24:32.860 - 00:24:34.004, Speaker B: I think this is it. Yeah.
00:24:34.052 - 00:24:35.468, Speaker A: Okay. Then I want to read it. That's fine.
00:24:35.524 - 00:24:52.600, Speaker B: So because the amount is supposed to be greater than zero, then both of these from and to values will change. So this is sufficient to make sure that not anything else doesn't change. But yeah, we could just refer to a specific key and make sure that it's mutated.
00:24:53.050 - 00:25:05.890, Speaker C: Is there now actually a vulnerability? If. Oh, we. Okay, we constraint, you might be greater than zero. Yes, it seems very tricky because if we didn't do that, for example, you could have zero get and modify any two bounds.
00:25:05.930 - 00:25:07.098, Speaker B: Yeah, exactly.
00:25:07.274 - 00:25:12.350, Speaker C: It seems really tricky in this model to not forget something that will screw your contract up.
00:25:14.330 - 00:25:25.052, Speaker B: If you could, if you refer to specific keys that you want to mutate and think of like writing in that way, it is tricky. Yeah, it is tricky. I'm not rejecting that.
00:25:25.156 - 00:26:14.162, Speaker A: I would also say that the contracts like this one are very, I see them as being quite low level infrastructure in the sense that once you implement things like tokens and authentication, which is something that we'll talk about a little bit later in one predicate, the composable nature of them, these predicates can be deployed as these stateless sets of rules that you can almost sort of inherit. It's really. Yeah. Most higher level sort of application thinking doesn't need to get down into the weeds of keys and things like that. They're also, to a reasonably extent, abstracted away from the developer quite nicely in the language. And so, yeah, we're kind of, I guess we're going down into the weeds on them, because I think it's interesting to kind of get into the mode of thinking of like, you know, if I'm doing declarative programming. And my sort of principle is that the solver can set my state to literally anything as long as it's a.
00:26:14.162 - 00:26:18.462, Speaker A: So as long as it follows the constraints. It's just interesting to get into that space.
00:26:18.606 - 00:26:26.558, Speaker C: Yeah, I guess in practice, stuff like demonics, you have a trait or something that you should be replayed, secured or something.
00:26:26.614 - 00:26:27.890, Speaker A: Exactly. Yeah. Yeah.
00:26:28.630 - 00:26:57.594, Speaker B: By the way, I realize we haven't been repeating the questions or comments, so maybe we should do that from now on. Okay. Because of the mics and the recordings. Yeah. Okay, so this is the token contract. Okay. We can jump into the AMM contract if anyone wants to see what it looks like, because it's interesting, because it involves modifying or constraining the state of another contract, because the token defines its own logic.
00:26:57.594 - 00:26:59.550, Speaker B: And the Amm makes sense of that.
00:27:00.490 - 00:27:29.070, Speaker A: And I would say as much as a token contract has its complexity. When you're reasoning declaratively, as you mentioned, the sort of the gains come when you start reasoning about high level concepts. And we'll see that with the MM, like it's fundamentally because you've implemented this stuff underneath, you're able to reason in terms of your application sort of invariance. And it's. And yeah, basically from the point of view of the amM, we'll see that actually what you need to describe in your code is very, very small.
00:27:29.970 - 00:27:36.040, Speaker B: Okay, I'm getting rid of all those stuff space as much as it hurts.
00:27:40.820 - 00:28:04.926, Speaker D: Can you define the constraints upon external predicates or internal predicates, upon not necessarily caring what they do, just the fact that they have successfully executed or been constrained. So, for example, I may not necessarily carry one predicate is doing internally. I would want to check the story finally saying, ok, as long as that predicate is run before me and it's fine.
00:28:05.118 - 00:28:36.950, Speaker A: So what you would do there is you would be reasoning in terms of that predicate, having been satisfied, will translate into some state being mutated. And so what you would do is you would reason about the state directly, because in order for state to be mutated on any predicate, on any contract, one of its predicates has to be violated. And so you'll see like, yeah, if you, and if, as we're about to see, if from one predicate you reason about state on another implicitly, because your constraint is saying, hey, I want this value to change. In order for that value to change, one of those predicates is going to have to be satisfied.
00:28:51.300 - 00:29:40.940, Speaker B: So for the ALM contract, I'm going to, I think I'm going to define the predicates here. Yeah, so we have a storage block here again, because we need some storage to track reserves of tokens. And then we have an interface to the token contract that we just wrote. And it's just an interface to its storage because we want to be able to constrain that. And then we want to write a swap predicate, for example. Actually, yes, swap is also, it has an imprint of connotation as well. But what's a better word for it? Like state mutations, I guess it's like valid reserve mutations or anything.
00:29:40.940 - 00:30:39.130, Speaker B: But let's for simplicity call it swap again. Thank you. And so VMM will want to keep track of the token reserves. So let's say we have a reserves mapping here that is, this is not possible in pint, but for simplicity, I'm going to just key it by a tuple that is just addresses of the two tokens. And the value of the mapping will be some reserve some value. So it's an integer. So this, instead of this we can just like hash the two addresses and end up with a b 256 again.
00:30:39.130 - 00:31:23.420, Speaker B: So, but let's think of it this way. I'm not gonna. Okay. And what the AMm cares about is to preserve the, this, this basically, so the price curve to be constant whenever there's a swap happening. So we're gonna just add a constraint to make that possible. Yeah, let's just define it here. So I'm just going to abstract out the part where we're getting the values from the keys, but in order to get them, of course we need to have some variables.
00:31:23.420 - 00:32:27.310, Speaker B: So like token A address, for example, and then the token B address. And note that I've defined the constraint above, but it doesn't really matter which order it's defined in. So we want to make sure that using this variable that is again filled out by the solver, we get this balance value, and we're just going to pass it to this macro that makes sure that this price curve holds. So let's say reserve a, reserve b for a shortcut. And we want to constrain this. But what we've done so far only has to do with the storage of this amm contract and doesn't really have anything to do with the tokens. So we want to make sure that these reserves actually correspond to the balance of the token that we just defined.
00:32:27.310 - 00:33:40.260, Speaker B: And how are we going to do that? We're going to, we want to maybe let's abstract it out again, but from this address, because we know the interface of this token contract, we can sort of have an instance of the token contract and access its storage balances map. And I don't want to write all the lines to do that. It's not much, it's like two lines of just creating some interface and accessing its storage, but I don't want to dive into it for time's sake. So let's say that we ended up with the a balance and the balance by making that interfacing. And you want to make sure that these reserves and the balance of the actual token correspond to each other. They're linked in a way. So we're going to add a constraint to make that, and let's use the delta micro that we just had, but we erased.
00:33:40.260 - 00:33:45.536, Speaker B: Will Delta be useful here? Yeah, I think so.
00:33:45.648 - 00:34:31.270, Speaker A: Yeah. You can't necessarily have just pull in those balances directly because you may have more than one pool that leverages your token, and if you do that, you're just going to screw up all of your other pools. So we abstract out the reserves, but what we do care about is that the delta of the reserves does equal the delta of the token. They change by the same amount. So yeah, the other thing I was just going to say about the MM in general, hopefully you'll agree that this, I mean, apart from we're pulling some interfaces and doing some accounting here, but this is pretty concise, like we're able to express directly what is the invariant of my application. The application only really cares about this sort of like geometric relationship. It's not transferring anything because there is no transfer verb in this system.
00:34:31.270 - 00:35:12.450, Speaker A: Also, the user is not interacting with an amm in the way they would with a transaction and saying I'm going to swap with this amm. The user on their end is going to be saying, I have token a, I want token b, it's the solver who's going to look at the sort of landscape of available liquidity and say, oh, I can see a solution where the user is satisfied and I can satisfy the predicate of this program. And so essentially each program is really only reasoning about the sort of, yeah, the invariants that it cares about. And the rest is sort of handled either by the user or by the token, or it's handled in sort of the correct place for each abstraction.
00:35:14.590 - 00:35:17.730, Speaker B: Okay, any thoughts, questions, comments?
00:35:19.670 - 00:35:40.472, Speaker D: Just a quick point. I probably is, if the contract is immutable, it exists wherever. So I assume the developer just has to say, I just want this thing to be called once within this time span. So I guess there's going to be like a library esque type of contract which everybody can use for because you don't want to deploy this every single time you want to do a swap.
00:35:40.576 - 00:35:43.408, Speaker B: Do you mean this predicate?
00:35:43.544 - 00:35:56.940, Speaker D: Yeah, so if I'm going to do a swap right now, like I don't want to have to deploy a contract for this. So I assume there's going to be somehow I can pass in maybe a variable as a user to say, within the next five minutes, you can only swap this thing once, otherwise.
00:35:57.760 - 00:36:46.420, Speaker A: Yeah, so like all of the, like, for example, the logic behind a swap, like the constraints that say I want to reduce my balance of token a by up to a certain amount, or increase my balance of b by a certain amount. And as you say, perhaps with us within a certain time frame, these can be deployed as sort of stateless predicates that are kind of templates for these interactions. The way the user leverages them for that particular interaction is they produce a signature, as we demonstrated with the token example, that basically it indirectly constrains the amounts or the addresses that are involved. It doesn't do so directly. The user is not submitting programs like this. Rather they're submitting signatures that lock in certain decision variables to specific values. And so you're right that, yeah, you would deploy, there would be infrastructure that allows all these different kinds of interactions.
00:36:46.420 - 00:37:29.700, Speaker A: As an application developer, I'm thinking about what are the different ways users might want to interact with my application, and I'm providing those predicates, whether they be stateful or stateless as infrastructure. And then all the user is doing is submitting signatures. But I think the AMM is a good case in point because very rarely is a user, unless they're adding and removing liquidity, which is the part that we're not describing here. But very rarely is a user saying, oh, I want to swap token a for token b specifically on this amm. Like that's the sort of abstraction we've seen in intents and solves and things like that things like Cal swap, they just care about their token balances. It's the amm. Insofar as its storage is changed, then it cares about the way in which those things vary with respect to each other.
00:37:31.480 - 00:37:32.048, Speaker B: Yeah.
00:37:32.144 - 00:37:33.056, Speaker A: Is there another question?
00:37:33.168 - 00:37:59.666, Speaker C: Yeah, so I mean, this might just be because of the example is a bit simple, but. So in the token contractor, you find it only allows two keys to be modified, which means we can only do swap from one person to the other. And if I want to say, pay fees too in that token, like what do I do? Can I reuse the contract? Can I do something? Or do I need a token multi swap contract that allows like a modifying.
00:37:59.698 - 00:38:04.484, Speaker B: Order to like from one to many payments, for example.
00:38:04.532 - 00:38:33.130, Speaker C: So say I want to say I want to do this amm, but I also want to encode fee payment at the same time. So I also want to say that, okay, from whoever invoked this, let's say I want to pay fee to the LP's. So with the original token contract, we can't do that because it only does a single swap. It only allows two addresses to be modified. Would I need to have like a more complex token contract to do it, or would I need to, is there a way to instantiate the total contract multiple times so that I can do multiple swaps?
00:38:33.710 - 00:38:53.490, Speaker B: So the question is for, in order to make a payment along with that transfer, for example. Yeah, what's the way to do it? Sorry, I'm not great at paraphrasing, but I'm just repeating for the recording. So yeah, you can. What was the last question you asked? If you can redeploy?
00:38:53.860 - 00:38:59.284, Speaker C: What if there's a way to clone the contract, to use it twice, something like this that makes it easier.
00:38:59.452 - 00:39:38.328, Speaker B: Yes, you don't have to clone the, so you don't have to clone the contracts. So if it's a general use case, enough predicate or contract. So contract here is again like set of predicates. So it's deployed and it lives somewhere and it has an address and anyone can just refer to it by its address. So you don't have to redeploy it every time you want to be referring to it or be using it, but you may want to, I don't know, provide signatures for each time you're using it. So different signatures or time limits. Or you may be wanting to cancel some things.
00:39:38.328 - 00:39:45.500, Speaker B: For example, have a canceled predicate that will make that possible. So you don't have to redeploy a contract every time you want to interact with it.
00:39:45.840 - 00:39:47.540, Speaker D: The point is you just have another contract.
00:39:50.490 - 00:40:23.610, Speaker A: The other thing to point out is that an individual predicate can be solved multiple times in the same solution, which can allow this kind of thing. I think for example, with the fee payment example, the signature that I provide, that sort of locks the amounts that are able to be reduced because the constraints describe that I could unlock slightly more token than I constrain my receiver to receive, and that then becomes sort of like free balance. The solver is able to insert as a decision variable their address so that they receive those fees from them. Exactly.
00:40:24.910 - 00:40:32.918, Speaker D: Aren't you specifying like number of variables that can be changed by number of storage variables that will be changed.
00:40:33.094 - 00:40:34.950, Speaker B: So what's the beginning of the question? How?
00:40:35.070 - 00:40:35.890, Speaker D: No, because.
00:40:40.330 - 00:40:45.710, Speaker B: Yeah, you can specify the number of bounces or keys that will be mutated.
00:40:48.330 - 00:40:54.898, Speaker E: If you deploy that contract saying it has this constraint on the bracket that he only modifies like the.
00:40:54.914 - 00:40:57.490, Speaker B: Balances of true address. Yeah.
00:40:57.530 - 00:41:01.394, Speaker E: And now you want to also send the fee somewhere. Somewhere.
00:41:01.482 - 00:41:02.938, Speaker B: And you don't know to where, right?
00:41:03.034 - 00:41:05.320, Speaker E: No, but like the proper.
00:41:09.900 - 00:41:10.460, Speaker B: You cannot.
00:41:10.500 - 00:41:24.740, Speaker E: Use the existing contract and then like, oh, add some more constraints that do like one more transfer like twice, because there is a constraint saying you only change two variables. How can I come from change two and I will change three.
00:41:24.820 - 00:41:56.082, Speaker B: Okay, I see. So the question is like you previously constrained the mutable keys to be two, but now you want it to be three, for example. And how do you make that, make that possible? And the intrinsic that we introduced to get the number of mutable keys, that is mute keys land, this is per predicate. So this works per predicate, not per solution, or even per contract. So yes, yes, okay.
00:41:56.146 - 00:42:23.890, Speaker A: Yeah. The correct way of reasoning about keys in general is likely to be referring to specific keys. And the language will provide a higher level way of reasoning about these things for conciseness. In the token example, it's convenient to sort of illustrate that, oh well, if I just have this trick, if I just constrain any two keys, I can kind of get what I want. But the developer does have the ability to constrain specific keys in the storage database to be mutable.
00:42:25.790 - 00:42:26.854, Speaker C: One more question.
00:42:26.942 - 00:42:27.950, Speaker B: Of course, please.
00:42:28.110 - 00:42:41.610, Speaker C: You said you can solve the same predicate multiple times during one execution or doing one solving. So what does that look like? So can you solve the token contract multiple times?
00:42:43.310 - 00:43:16.218, Speaker A: Yes. So for example, if I write a separate predicate, that's like a split that says, ok, I have ten USDC and I want to send five over here and five over here as we saw the token contract that we wrote only allowed me to change two keys, and so I can't change those three. But I can satisfy that predicate twice in order to achieve the. Exactly. So then I would be able to provide as many two signatures, for example. And then the solver is able to see. Ok, I can see among both predicates.
00:43:16.394 - 00:43:21.554, Speaker C: They will see the same resulting state. Now they will see different resulting date because.
00:43:21.722 - 00:43:22.146, Speaker A: Right.
00:43:22.218 - 00:43:39.642, Speaker B: Yes. So you can. In the same solution, you cannot have, like, I don't know my balance as ten. And then also twelve. Yeah. Because when the. When the solution is submitted and the pre states and the post dates are checked, so, like, pre state is read by the vm.
00:43:39.642 - 00:44:22.620, Speaker B: And then I. The state mutations are simulated in a way, and then the post state is checked. So at that post state checking stage, one of those will pass, for example, or maybe that won't pass either, but the other one will definitely not pass because you're referring to the same value and you want it to be two different values, and so that solution will not be included. Yeah, yeah. So I think we have four minutes. We could have talked about authentication as well, to show how contracts can own tokens, for example. But I think it's not really like, there's not enough time to get into that.
00:44:22.620 - 00:44:58.436, Speaker B: I think one other thing we can mention is the transient data. So, because a solution is an object that consists of. Of an array of solution data, and that is consisting of the predicate address. So whichever predicate you're solving, the state mutations to make that satisfy that intent, to satisfy that predicate, and then the decision variables. So, for example, the. From the 2d amount that we just talked about. So given those decision variables, the state mutations should be considering the constraints of that predicate.
00:44:58.436 - 00:45:06.620, Speaker B: And then you can also have a transient data. So if you want to refer to any other data that's in this array. So in the same solution, you can also have that.
00:45:08.880 - 00:45:41.120, Speaker A: Yeah, yeah. Transient data is fundamentally what would allow you. For example, we've seen how one predicate can reason about the storage of another by exposing an interface and sort of saying, I want to add additional constraints on the storage of this predicate to be satisfied along with the. Along with the constraints that are in the predicate, who owns the state. You can. In addition, this transient data feature, what that exposes at a language level is the ability to constrain decision variables that are not state. And that's actually the key of how you begin to implement authentication between contracts.
00:45:41.120 - 00:45:44.960, Speaker A: It's a really interesting pattern that we won't have time to go into.
00:45:45.500 - 00:45:54.170, Speaker B: But, yeah, I'm just going to write in more, a bigger font if you want to close. Simon?
00:45:54.470 - 00:46:55.740, Speaker A: Yeah. If you're sort of interested in seeing what we're building, we've been able to go through a very, very small part of what we're thinking about and an even smaller part of the stack, as it sounds today, we're fairly early on in the process of developing these things, but it's a very interesting design space for applications. Hopefully we've explained enough that you can see that with this pattern, you can push a whole lot of complexity off chain. Like if you imagine a much larger application, something that's very hard to compute, but easy to verify that the constraints are satisfied, you can end up deploying applications which, if you were to write all of that code imperatively on chain, it would be prohibitively expensive, I think. Like, for example, some more exotic Defi applications, perpetual markets, things like this that are very, very expensive to run in gas. If you're able to understand those applications in terms of their constraints and their invariants, then that computation of discovering the state is done by incentivized third parties off chain rather than the entire network.
00:46:57.400 - 00:47:01.020, Speaker C: Is it your own blockchain that you're running?
00:47:03.240 - 00:47:28.970, Speaker A: Yes, we're building this as a L2 ethereum. So the exact architecture. One thing I forgot to mention is the other advantage of this design is that, for example, things like for proofs become orders of magnitude easier to produce and to verify because they're essentially circuits. Right? So, yeah, we're deploying as like a L2 to ethereum with. For proofs on the issue.
00:47:31.110 - 00:47:33.864, Speaker B: Question. No, sorry, I thought you were a.
00:47:33.982 - 00:47:37.420, Speaker A: Okay, speaking of fraud proofs, can you.
00:47:37.460 - 00:47:46.240, Speaker D: Leak a little bit of alpha about your novel optimistic settlements? Steve, I mentioned it before, I'm not sure if it's still a thing.
00:47:50.020 - 00:47:56.516, Speaker A: So I suppose maybe you're referring to, like, exactly what form that the forpries take, whether they're optimistic or lexicay. Is that the question?
00:47:56.588 - 00:48:16.650, Speaker D: I recall a long time ago. I think it was in a good intention channel, maybe somewhere else, maybe I'll still privately about how are you going to set it to a figure? And there was a discussion about you've got some known mechanism that you're doing, potential dispute comes up or something like that. So does that bring any doubts?
00:48:17.310 - 00:49:03.956, Speaker A: Yeah, there are some interesting things you can do, especially around, like, clients. If you're interested in building a statistical certainty around the state of the chain without having to validate the entire thing, you can do something that you could call sort of like, constraint validity sampling, where if there are, like, a million constraints involved in a block, you could pull at random, you could parse out at random, a subset of those to a subset of, like, clients that they verify at random. And, like, you build up a statistical picture of certainty that there's no fraud in the block. So you can very quickly, like, in that manner, you can very quickly sweep a block looking for fraud, and as a first phase, and then you can go on to actually proving the fraud once you found it. I think that might be what you're referring to, but I'd have to get Stephen up here to answer better.
00:49:04.068 - 00:49:05.772, Speaker B: Okay. We're at time anyway.
00:49:05.876 - 00:49:07.948, Speaker A: Yeah, we're at time. Thank you, everyone.
00:49:08.084 - 00:49:08.460, Speaker B: Thank you.
