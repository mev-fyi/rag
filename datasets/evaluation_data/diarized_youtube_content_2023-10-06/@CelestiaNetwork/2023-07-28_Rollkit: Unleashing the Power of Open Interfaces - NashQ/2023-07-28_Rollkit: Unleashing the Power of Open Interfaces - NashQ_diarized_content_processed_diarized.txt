00:00:02.330 - 00:01:14.260, Speaker A: I'll tell you about the story of Rollkit. I will go into what rollkit is. I'll tell you about the motivation of this talk about open interfaces. I'll tell you what the interfaces are that rollkit integrates with and like the D interface and the sequencing API, and then wrap it up, presenting you the role kit node and how it interacts with those components. So where do we begin? Mustafa wrote in his lazyledger paper about lazy Ledger and one of the things that was still an open question was execution light clients. One of the current limitations of lazy Ledger is that it's not obvious how to build light clients for applications, so that clients do not have to download all of the applications messages to let the applications know the application state. So how do we solve that? John and Mustafa went to Defcon Japan and thought about this problem and came back with the idea, okay, it has been roll ups, it always has.
00:01:14.260 - 00:02:18.850, Speaker A: The trio of Ismail thought about and said okay, we're going to implement an enshrined settlement layer which will be a roll up itself and other rollups will be able to settle on this enshrined settlement layer. And the thing that the stack that they chose, we was very close to them, was tenormint with Cosmos SDK. So here we already have the first interface, the ABCI interface that they had to integrate with and they had to make a decision. Either we're going to use tendermint and rip out the core, the consensus engine, or we're going to rewrite it from the bottom up and use a new p to p layer. And they chose the happy path because to have a cleaner repository and make it more general and usable. So optimint was born. And in the first years Ismail and Thomas were working on it.
00:02:18.850 - 00:03:10.300, Speaker A: But in the last year we expanded and rebranded. The team grew via rollkit. We rebranded because we will not only support optimistic rolls, but in the future ZK rollups as well. Okay, so where are we at? We have rollkit in the middle. It creates the blockchain and it talks to the state machines through the ABC interface, application blockchain interface, and posts the data and the headers to the data availability chain. And this is us delegating data availability and consensus to data availability layer. So we are a roll up and we already see just with this one interface how much innovation it can create.
00:03:10.300 - 00:04:35.960, Speaker A: So the first idea is, hey, we have an existing tenermint chain and we will switch out tenement with rollkit and we use the same state machine, the same application switch to lines in the Gomod and we will have a tenement chain now as a roll up crescent did that and have a Dex as a roll up, for example. The other thing, which is, okay, I'm not going to use the Cosmos SDK, but the ABCI directly and a community member did that and used fuel to make it ABCI compatible and basically created a fuel sovereign roll up on top of Celestia just by complying with this ABCI interface. And now what you can also do is choose a vm on top of the Cosmos SDK. That's what we're very excited about what Argus is doing. Argus is building the world engine on top of rollkit and they use Polaris. Polaris is a great EVM that is built on top of the cosmos SDK. And they had some talks and I think there will be another talk today, so please check them out.
00:04:35.960 - 00:06:17.960, Speaker A: Okay, now what is the motivation here? You already saw that how ABCI creates innovation through just being an interface you can be compatible with, and it creates an effect of collaboration, because now we have a community, which is the only goal to build state machines through the ABCI interface. And while complying with an interface, you can innovate through different means. So let's say we have the data ability interface, and just because there exists this interface, you can now say, okay, I want to build another data availability layer to comply with that and build it out. The next motivation is we will have interoperability. And I think IBC is a perfect example for that, where different chains can use IBC together to communicate with each other, or I can use different data availabilities layers to switch them out. We also have transparency. Transparency is important because by just understanding that there is an interface and to see how the components talk to each other, we can derive functionalities and we will understand what kind of trust assumptions people make, how they interact with each other.
00:06:17.960 - 00:07:25.398, Speaker A: And it will decrease the learning curve of people getting into this space because they will be able to focus on only one component and will be able to understand how these components work together. Okay, open interfaces make it possible to be future proof. If I built my application and the underlying component would change, I would need to upgrade the whole stack, possibly. But if I can modulize it, I can only upgrade one and specialize it. And this will give developers the ease of that. If you develop with such a framework, you'll be able to pick and choose and it will stay compatible for the future. The fifth point that I think is, I guess a little bit nuanced.
00:07:25.398 - 00:08:48.422, Speaker A: And interesting is that when an application, let's say in web two, looks for funding, let's say it's Twitter. The people who fund the application don't really care about the underlying stack infrastructure stack. So it is either AWS or Google Cloud, but they will use some cloud provider. And the same also applies for web three. In web three, when we want to fund an application, we are also taking a bet on the underlying ecosystem and on the underlying infrastructure. And if you can give the guarantee that hey, you're not taking a risk on this ecosystem because you can switch out components in the future, you can give much more funding and capital to application developers because they will be able to make it future proof and the risk is basically eliminated. And the last point is lower cost and lower switching cost.
00:08:48.422 - 00:10:03.950, Speaker A: I will reference the talk by Chris Gold about it's a type of Mev and his presentation was a TLDR. And I'll just make a TLDR of his TLDR. It's basically if a bridge can give you two options to access to the l one, the bridge can basically charge you as much as you would be charged as going through the l one. So they have the power, the monopoly, to be able to take that. So what you have to do is keep switching costs low from one to another and basically have like a threat of fork is the slow game how we introduced it too. So those sequencers or data availability layers or bridges, whatever, cannot extract that value, because if they do, the other components would be able to switch. And this would of course result in lower cost for the end user.
00:10:03.950 - 00:10:49.606, Speaker A: Okay, so we were in the same developers. Get some water. Sorry guys. All right, thanks. Can them. We were the same developers who did the DA interface for the op stack. Imagine what this now gives as an option for the op stack to give, to choose and pick the different data availability layer.
00:10:49.606 - 00:11:54.450, Speaker A: And we saw the same thing happen with what we did in rollkit. So a similar data availability interface. And we chose to deploy the first sovereign roll up on top of bitcoin. And now there was a huge craze and so many l two s and whatnot are popping up on bitcoin. And the only thing that we did is make bitcoin comply with this interface. And now we spawned a craze of innovation to see like okay, how do we improve bitcoin? Do we want to introduce opcodes into bitcoin to verify ZK roll ups easier? And this is a prime example of how you can spawn innovation through just an interface. So the goal would be to enhance the interface, make it even more compatible with other data availability layers.
00:11:54.450 - 00:13:40.050, Speaker A: One major goal is for OrcA to stay credibly neutral to celestia, which is important for to keep developing the modular ecosystem, and to allow developers to create roll ups regardless of what data availability layer they want to choose. And this will of course go forth with a more canonical bitcoin implementation, avail integration and then following more data availability layers when they come out. And the other part is that the moment we create those data availability clients for layers, other frameworks can also just comply from the other side, which means that the moment we have a new roll up framework, there will already be like those data availability clients that they can comply with. So new roll up frameworks can emerge and use those clients for the benefit. Okay, I'll give you a nice thought experiment. Let's imagine we have two data availability layers and we can now, because it's switch and choose, we can optimize as a community what we want to prioritize. Available blob space, cost per byte latency, economic security, liveness failure finality not liveness failure well, I'll give you an example.
00:13:40.050 - 00:14:57.098, Speaker A: Right, let's say we have two data availability layers, and you don't have to pick and choose. Let's say we have one that prioritizes finality and the other one that prioritizes liveness. So you can always have the finality favoring data availability layer. But if that fails, we can have the liveness favoring data availability layer pick up and us as a community, we can decide how we can interpret and read those bytes. The next interface would be the sequencing API or the sequencing interface. When the modular stack evolves, we know we see specialized software and the same we see also with sequencing, shared sequencing emerging with Astria, espresso, Fairblock and others. And we work together to come up with a common sequencing API with the goal to have a unified interface between all shared sequencers and roll up frameworks so we can plug and play this component as well.
00:14:57.098 - 00:15:52.394, Speaker A: And of course this is a collaborative effort, so we have to decide as a community how to come to consensus. And it's great that we can work on this together. And of course there's also based, right? I mean we can use the data availability layer as a shared sequencer. Now if we think further, okay, we have the bitcoin implementation, now we have based, I mean, the logical conclusion is to make a social experiment. On the 20 April there will be a based bitcoin roll up. And what does it mean based means that I can delegate inclusion and ordering to the data availability layer. That means if I control ordering, I can also control reordering, which means I can control mev.
00:15:52.394 - 00:16:37.574, Speaker A: I'm leaking mev to bitcoin and now I feel this will be a very interesting sight to see how bitcoin as a whole will deal with mev. I'll leave it at that. I think that will be a fun social experiment. To wrap up. We have the rocket node in the middle. We can talk to the state machine through the ABCI interface, we can talk to the sequencer through the sequencing API, to the DA layer, to the DA interface, and through the bridge to something like IBC. And in the middle we have the core, the folk choice rule, which we define how we want to follow the blockchain.
00:16:37.574 - 00:17:48.834, Speaker A: How do you want to interpret that, and how much power do you want to give to those components? And the exciting part here, why I love working on this, is because every single part is influencing meV, extracting mev, or giving back mev to the community. So this is a highly complicated and nuanced topic that you have to deal with. So I encourage everyone to dive more into this research and to see how you can contribute going forward. And this is just the tip of the iceberg. I mean, the moment we have plug and play components, we can have crazy roll up variants and designs to optimize specially for your use case. And like redundancy and picking multiple DA layers or having for example also multiple proving systems. I don't know.
00:17:48.834 - 00:18:58.490, Speaker A: You can have the same data availability bytes and have an optimistic and a ZK roll up on top, a hybrid version. So this is another type of research that I encourage everyone to look into because the design that we created by decoupling components is exploding. Okay, to conclude, modular blockchains need open interfaces. We have high dependencies between each other. So to communicate we have to agree on standards. We need to keep switching costs low because we don't want to go into the slow game where one thing can extract the MEV and keep it, but we have to have a credible threat of a fork to go to something else. Bitcoin will get Mev, and the last part is rollkit is the openroller framework, which will give you the opportunity to integrate with those things, those interfaces.
00:18:58.490 - 00:19:32.110, Speaker A: Okay, thank you so much. Yeah, I want to go back. Okay, I'll still say it. Please join the workshop. We'll have in 2 hours build a roll up on rollcap dev, contribute to our GitHub, and most importantly ask questions. I'll be upstairs with a whiteboard. God, my voice.
00:19:32.110 - 00:19:41.060, Speaker A: Yeah. So, yeah. Thank you, guys. Let's roll close.
