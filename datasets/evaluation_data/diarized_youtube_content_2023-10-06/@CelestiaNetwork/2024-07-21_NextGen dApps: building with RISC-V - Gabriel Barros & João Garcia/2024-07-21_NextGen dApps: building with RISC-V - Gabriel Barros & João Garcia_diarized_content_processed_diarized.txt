00:00:02.120 - 00:00:10.510, Speaker A: Hey guys, welcome to this private session. Feel free to interrupt us at any time because it's not like we are dealing with 30 people at the same time.
00:00:10.590 - 00:00:14.478, Speaker B: Yeah. So if you have any questions, let's make it interactive.
00:00:14.574 - 00:00:28.976, Speaker A: Yeah, this session is a bit experimental anyways because often it's either him or me presenting. So we did a Frankenstein of our slideshow. So we keep things being very dynamic.
00:00:29.128 - 00:00:39.620, Speaker B: So you can even see through the slides that there is some color changes in the middle of nowhere. But that basically shows that we are taking turns to talk.
00:00:39.960 - 00:01:37.700, Speaker A: So the idea here today is to convince you guys that not about the infrastructure itself, but the next generation of apps, they will be more sophisticated and they will need a more resources. Oh, that's nice. So it's going to be built with Ris five and it's going to be built with it because we need Linux vms in order to be. To bring this expressiveness. So I want to start today inspiring guys with some things that happened in the past. So yeah, last year, February, somebody went to Twitter just to poke a little and said oh well, if ethereum is the world computer, why we haven't seen Dune running on it, man, we haven't seen Dune running on pregnancy tests, but not on Ethereum. How's that supposed to work? Right? And then one of our friends working at Cartesi actually made doom verifiable on Ethereum using Cartesi.
00:01:37.700 - 00:02:17.490, Speaker A: But he's just not a curious guy with a yemenite with a drive for challenges. He actually loved games. So he actually started a small project with another, with a few other friends from Kartesi called Rice. You can access it right now and it's eighties nineties style of gaming. They are creating tournaments and a lot of logic around it. But basically you have now the possibility of creating cartridges and you can do it yourself. They have even a playground now that makes everything all the more easier to develop.
00:02:17.490 - 00:02:41.570, Speaker A: I don't remember the dates right now, but they're going to have a game jam in the near future. This is their website. Again. This is just to display how many cool things you can actually make once you have this expressiveness power. Again, we're going to touch on this point many times in the presentation. Another one that I really like is bubble wars. This is so freaking degenerate.
00:02:41.570 - 00:03:15.922, Speaker A: So it's a basic game that we've seen many many times where the bigger character eats the smaller one. But the funny thing here is the size of your character is the size of your Eth deposit. So by eating other characters, you're actually eating their deposit. But to move your character, you need to shoot smaller versions of yourself in the opposite direction that you need to move. So you need to be very strategic because you don't want to get too small. Look at what's going to happen. It shrink a little bit, but just enough that will be still bigger than the next one.
00:03:15.922 - 00:03:19.442, Speaker A: It's very degenerate, man. Yes.
00:03:19.546 - 00:03:22.858, Speaker C: So you said that this is your Eth deposit.
00:03:22.994 - 00:03:23.378, Speaker A: Yes.
00:03:23.434 - 00:03:26.178, Speaker C: So you're essentially spending Eve while playing the game.
00:03:26.274 - 00:03:30.210, Speaker A: Yes. And hoping to steal somebody else's deposit.
00:03:30.330 - 00:03:33.070, Speaker C: Oh, so you win eth. Yes.
00:03:33.370 - 00:03:34.750, Speaker A: Or you lose it.
00:03:35.690 - 00:03:43.530, Speaker C: That's probably the best game ever. So after you eat someone, do you have to sign a transaction?
00:03:44.190 - 00:04:09.520, Speaker A: In a way, yes. You are signing it? Yes. I think they're deploying into one of these fast paced cell tools, so that also becomes part of the strategy, because you don't know when your transaction is going to be included. Right. You know, it's going to be sort of fast enough, but not to the milliseconds. So you need to know where your opponent's gonna be. Cause they can, how to say swerve as well.
00:04:09.520 - 00:04:42.202, Speaker A: Anyway, there's sort of mev in here. Oh, don't even get started on this thing, man. This thing is so wrong. It should have been built, but it's nice, and it can be run and verifiable because Cartesi has power enough to run the physics engine of this. And then there is another interesting example. Cryptopolis was part of an experimental week in Cartesi. Think of it as internal hackathon, and one of our friends, he got my Copley score.
00:04:42.202 - 00:05:13.790, Speaker A: It's like a rewritten version, open source version of thin city, the original 89 one. And he just needed to port it. He had barely any work into making the game work inside the Cartesian machine. He just needed to really plug the IO into a blockchain ecosystem. And then there's people now trying to pick up this project and actually making a whole ecosystem of it. Like, actually, like farming tokens and stuff like that. It's a bit crazy.
00:05:13.790 - 00:06:00.740, Speaker A: And if you guys are interested in knowing other kind of projects, there is a few. Into defi IoT, there is this website called Rollapplab IO, where you can find more projects that have been starting with this. So a quick agenda for today. We just been through the inspiration. We'd like to discuss a little bit about the Cartesian solution in the terms of monolithic and modular chains. Seeing the Cartesian machine itself, what is different about it, then checking out how is the tooling? Like, how do you build things? How does it look like? Finally, as we go to the architecture, we're going to see an encoding example made by Joo. And finally, I'm going to suggest you guys a few things if you want to keep in touch with the tech.
00:06:00.740 - 00:06:31.354, Speaker A: So, to get started here we have the Cartesian solution. It's built by two pillars. The left depends on where you're looking. The right side is the Cartesian machine side of it we're going to see soon. But the first part is the application specific roll ups. That's very important to make this work. I feel like we believe in this because it's where you can stop fighting for resources and you have resources dedicated for your application itself.
00:06:31.354 - 00:07:03.380, Speaker A: It does hurt things like composability, but we also believe, like some applications, they will be standing on their own lag for the most part. So when you think about Facebook, Amazon, like big software companies, and applications itself, they do have lots of integration, but most of the time you're spending on the platform itself, not on the mastercard integration or whatever else that goes on. And in order to explain this a little bit, that's the time my friend here is going to introduce his part.
00:07:03.500 - 00:07:42.332, Speaker B: So. Yeah, I'm Joan. Thank you. Nice to be here. I can pass it through the notebook. Anyway, so one of the first things that we thought when we started designing the solution, and I say we as in a collective of the company, which I totally do not include myself, because I was not there at the time, but I am now. But one of the big hustles back in the day was, what if we could actually run stronger computations, such as machine learning models on chain? The thing is, there are lots of ins and outs to that, but we always wanted to run the machine learning models in a verifiable way.
00:07:42.332 - 00:08:48.742, Speaker B: So, not only with an article that you trust or not with some different approach, like ICP does, where you basically have strong data centers which take away a little bit, in my opinion, from the beauty and poetry that is in the initial idea of the blockchain of you being able to actually host nodes on your own personal machines, to actually be able to understand why it's hard to run these complex computations, which at the end of the day, turn into the examples that Gabriel just show you, such as games or machine learning models. We have to understand general problem that comes from the standard design and the flaws of the monolithic blockchain. Right, monolithic blockchains. They are great for definitely some kinds of solutions. They bring many advantages because integrated components and simplicity brings us to higher composability. But at the same time, they do take away a lot of the customization. Not every application has the same needs.
00:08:48.742 - 00:09:44.152, Speaker B: Not every application has the same requirements. And that leads us to some bad practices in general application design. So, modular blockchains come here to solve this issue, right? All of its layers, the settlement layer, where the disputes are solved, the execution layer, which is personally my favorite, and what Cartesi deals with, which is where the magic happens. You add one plus one, it becomes two, and in a deterministic fashion, the consensus layer responsible for ordering the transactions and the data availability layer. Well, at the end of the day, the data is, there are many things to consider when picking those layers and customizing and what you want to achieve. So you have to think what kinds of depths you're optimizing for. Well, if you're the tools that your app will use.
00:09:44.152 - 00:10:43.266, Speaker B: So the computational intensity, if you just need simple state transitions, if you need to make very complex things, what kind of languages the developer needs to be using. And that brings, of course, many other functionality, sorry, many other resources that the languages bring with them. It's very easy to code machine learning models of Python. It's extremely easy to make gains with c or c hash and all of that. So this container is containerization needed if latency is tolerable outside of the depth scope, because inside, for a good user experience, you need to have fast transactions. But when you have to start interacting with other resources that are on the underlying chain or underlying layer, if outside of the main, this latency is acceptable. It's honestly just so many things.
00:10:43.266 - 00:11:42.626, Speaker B: I could go through this list, but I don't want to really bore you with bullet by bullet. So, a simpler way to actually see what kind of thing you can do is through this chart here. Basically, this is a chart showing just two of the dimensions of what the layers bring to you, and that is the execution layer and the data availability layer. So we have these two axis right here, where computational capacity is in the y axis and data availability in the x axis. And if you're just using Ethereum, you can see that you're kind of bounded to do smaller things like token sales and gentrify DeFi. But as you enhance your computational capacity, you can start thinking about affordable DeFi decentralized games like the ones that Gabriel just showed you. If you start combining this with data availability, you can start doing things like more complex daos, which my friend who just entered here, was actually able to pull off in a week.
00:11:42.626 - 00:12:49.234, Speaker B: If Denver creating quadratic voting solutions, which is totally possible on Ethereum, by the way, but not for you to be able to develop in a week from scratch, then you can go to even more complex things like decentralized social networks that we have some examples going on and even to decentralized. Aih, once you have good data and good performance on chain. So this led us to be able to create some solutions. These are some of the machine learning solutions that we have running on now with Curtesi biometrics classifier, which use machine learning and computer vision to actually perform biometrics spoof detection. We did have some examples also with funny examples with the same type like Titanic Survivor, which basically based on your physical characteristics, would you actually be able to survive the Titanic incident? Iris classifier, which is a KNN example, and lithium, which is one that I really like. It's an option for. It's an option for green energy credit.
00:12:49.234 - 00:12:49.870, Speaker B: Right.
00:12:52.090 - 00:12:52.994, Speaker A: Carbon credits.
00:12:53.082 - 00:13:28.360, Speaker B: Carbon credits, yes, sorry, for carbon credits where we actually use machine learning to detect the validity of the carbon containing containerization when we are factoring forests and trees. So this is very useful for integrating with the IoT solutions and validating them on chain. Yeah. So right now, after these examples, Gabriel is going to give you an quick overview.
00:13:28.980 - 00:14:15.176, Speaker A: So yeah, basically what we are trying to offer, in so many words, is the principles, the basis of what we learn with Ethereum. So maintaining it there, but at the same time bringing the expressiveness of RisC V and Linux. And that's where we go here. So that's the second part. You've seen this for the examples, but it's really important to remember that as we have been developing for blockchain so far, we are most akin to embedded systems where our code just messes with whatever is available as a resource on the system itself. So if you're in an elevator, you go up and down and that's about it. Open and closes the door.
00:14:15.176 - 00:15:38.958, Speaker A: You don't need to really manage resources that much, and therefore your program can basically be written in assembly. But as you're trying to define sophisticated business logic, where you're trying to concatenate data drive relationships out of what is going on in the application, which is basically what we've been doing in web tool for so long, you need to have higher levels of expressiveness. And in order to do that, you basically, it's going to be bounded to the necessity of having an OS, because as you're trying to import any library or reuse any tool. Most of them, let's say 95%, will assume you're running on top of an OS. So even though there is many projects nowadays saying, oh, we can run in rust, we can run some version of Python and things like that, they are not really giving you all the power of that language, because you cannot really leverage all the knowledge of that community, since you cannot just import any library or any tool made with such language, since it will require file system, process management, memory management, things that are not really even a concept when you look at these simple machines like EVM and such. So moving forward, what is the Cortez machine?
00:15:39.134 - 00:16:18.080, Speaker B: Yeah, the Cortez machine is essentially an execution layer. So you can think of it as an execution environment. And the best way you can understand what is basically an execution environment is through thinking about it as a state machine. You do have a state, you do have an input, and this simply generates a new state. It should be extremely straightforward and extremely simple. There's really not much to add into that, but it does have some intricities, even though it looks simple, to make it available on the blockchain, you have to do some crazy tweaks on it to actually make it deterministic. Otherwise it's not verifiable.
00:16:18.080 - 00:16:56.630, Speaker B: Our engineers spent a good while like years actually being able to make Linux verifiable. And our approach to that was to use RIsc five. The cool thing about Risc five is that it's just like the computers that we use every day, just like arm, just like intel, you can just build things and compile them to risc five. And once you're running Linux, you have the freedom and the power to do anything there. So making Linux deterministic was the key point in here for us to make our solution work.
00:16:59.940 - 00:17:44.800, Speaker A: Oh, that was funny transition. So this is the building stuff I was talking about in the agenda. So whenever you're looking at EVM. I've been coding solidity since 2016, and I've transitioned from writing bash scripts to do a little bit of my work from time to time, depending on the project, to actually rely on truffle later on hardhat. And now we can even have like forge helping us as well. And even though the ecosystem improved a lot, the quality of life coding for EVM and similar systems is way better. You can compare.
00:17:44.800 - 00:18:37.128, Speaker A: We are still reinventing the wheel for a lot of stuff. I used to comment that more often, but now that we have a smaller crowd, I guess worth it. At some point I was trying at Cartesi to create a small module to help people create pools, staking pools for the Cartesi protocol. And meanwhile we are looking to what goes about doing logarithmic, the math logarithmic function. It's funny. Have you tried to implement that thing in solidity? It's not available to you, not a primitive. And we started reading, right, we started reading seventies and eighties paper about calculation methods and how to implement them into computational systems, because it's just not something the EVM was made to do.
00:18:37.128 - 00:19:21.408, Speaker A: And we needed to try many different ways of how to optimize this thing because you don't want it to be running for too many iterations as well, and how to compromise on precision, and then it's a mess. And that's just log. You open your node, JS your python, go to math log, and you get that thing there for you for free. So, and we are talking about a platform that's supposed to be about finance, right? We're supposed to be disrupting the finance sector. How can you disrupt anything if you cannot do even log and exponential in a simple way? We can make a discussion and maybe even propose an EIP. Let's introduce log to it. But then that's going to be a cycle.
00:19:21.408 - 00:20:20.858, Speaker A: I also need this and I also need that. So I feel like EVM as a primitive is good, but we need higher layers of abstraction, keep it simple to EVM so we can be sure that it's without flaw and it's very safe. But at the same time, we cannot be stuck on it when we are talking about the next generation of applications. And then when you look at the cartesian tooling, it's like you get all this legacy of stuff that people built before us that we can really leverage for our day to day task of building things. And instead of just having a constructor call where you're supposed to set up everything and then you compile, then you deploy. To actually build a cartesian application is just to understand how to use the docker build system we integrated with the docker build system. So you don't need to learn too much about the intricacies of how to put the binaries inside the Cartesian emulator and things like that.
00:20:20.858 - 00:21:02.884, Speaker A: As long as you follow the template, you can build whatever, you can install whatever. And as it runs here, it will run inside the Cartesian emulator. And that's it. That's simple. So I know that for some junior developers, that can be daunting, but that's the way we've developed so it's reproducible even on the builds, right? And that's what we are trying to offer. Now a second question that often comes up is like, oh yeah, but how fast is it? How does it compare? One of our friends, Carlo, basically created these slides coming next to create just a, a high level comparison, which is not even like that. Perfect.
00:21:02.884 - 00:21:32.914, Speaker A: But just to give a grasp of what we are talking about here. So in a block we can have at most 30 million gas. That's not the ideal. That's how much we can get. So let's be very lenient with ethereum here. Let's say 30 million, then the cheapest useful opcode that is changing anything is either add a sub and it's three gas. If you could create a single contract that only does this operation, you'd get about 10 million instructions.
00:21:32.914 - 00:22:13.590, Speaker A: The truth is way lower than that, but let's go with that. So for a block, we have 10 million instructions. Then we have here the Cartesian emulator just booted Linux, requiring 3.6 million cpu cycles of non trivial cpu instructions. You never, I'm not necessarily arguing that we should put Linux on Ethereum, but you never get something at this complexity running on Ethereum or any system that just tries to improve a little bit what Ethereum has provided us. And then if you actually use the 13 seconds, ten to 13 seconds is about a block time.
00:22:13.750 - 00:22:14.590, Speaker B: Just weather.
00:22:14.710 - 00:22:15.150, Speaker A: Yeah.
00:22:15.230 - 00:22:20.000, Speaker B: You would never get this on the EVM because you can get the Cartesian machine.
00:22:20.540 - 00:22:41.200, Speaker A: Yeah. Verify about it. Exactly. And if you go for the same 13 seconds that you have for a block in a normal laptop like ours, this is not a huge server or anything like that. You get 3.6 billion cpu instructions in the same amount of time. This is the comparison that you should have in your mind.
00:22:41.200 - 00:23:06.934, Speaker A: That block, that little black dot there is stimulus instructions. This is 3.6 billion. So it's a huge gap. So about a roll ups. I will often go through this architecture here, and eventually, if you do have questions, we can go through it, showing you the APIs, all the connections and things like that. But Jean has a better approach, a simpler one.
00:23:07.062 - 00:23:59.390, Speaker B: Yeah. The way I like us to think of how this all works, how do you actually can connect Cartesi to Ethereum to make it all your complex computations verifiable on this layer one or any other layer one that is EVM compatible for, if you will, is very simple. It's an extremely straightforward design where you send transactions to Ethereum and then we already have deployed there and on other EVM chains, of course, our smart contracts that allow you to interact with the framework. So there is one main smart contract that is very important. That's called the input box. And every time the input box or our portal contracts receive inputs, basically Cartesi is triggered. So the Cartesi machines are able to actually start processing based on the implementation of the developer.
00:23:59.390 - 00:24:41.136, Speaker B: They settle back on the later one, and you can read the state directly from these machines. It's pretty simple. The cool thing is, once you start basically spinning up cartesian nodes, and for my application, for my machine learning application, for example, I can spin my node. But if Gabriel doesn't trust me as the node runner, he can also spin his own node. And what will happen is you'll have multiple cartesian machines here. This will basically configure an app chain because they'll be verifying each other. Other cool thing is that you can also integrate it with data availability layers here just to don't make any of my da friends mad.
00:24:41.136 - 00:25:16.586, Speaker B: I didn't put any logo, but it can totally be Celestia, for example. But yeah, it works in the same way. You perform a transaction for your data availability layer, and it makes a block commitment to Ethereum, and at the same time it triggers an input on Cartesian. Right after Cartesi processes it and all your node processes it, they can settle on Ethereum again. And in the same way you can just read the state from Cartesi. Or you can check whichever blockchain or whichever point the data is. If you have to recheck your inputs, you go to da layer.
00:25:16.586 - 00:25:55.070, Speaker B: If you have to see the block commitment or the claim that was settled on Ethereum, you can just go through theorem or any other settlement leave. Yeah, so that basically shows the architecture of how you create app specific roll ups and think that every one of the cartizing machines there is a machine directed to a single application. So that makes you not compete for block space, and it really enhances the power and capabilities, and it does not get you in a bad situation like we had with cryptokitties, like, so long ago.
00:25:56.450 - 00:25:58.746, Speaker A: Yeah, it's for you, man.
00:25:58.898 - 00:26:34.012, Speaker B: Okay, so, yeah, talk strip. Show me the code. So I'm gonna do a very small demo in here of how a Cartesi application can look like. And it's very simple. Let me just change the display settings to mirror so you can all see what I'm seeing at the same time. So this is a very simple cartesi dapp, right? It's called arena mayhem. And here is the basic structure for the Dapp, there are two main functions, handle advance and handle inspect.
00:26:34.012 - 00:27:18.050, Speaker B: Because this is a workshop, I have to show you guys a little bit of the code so you understand exactly how you can build simple things with cartizzi. In a very abstract way. You can think of this like an API where handle advance is basically your post put and delete functions where you're actually changing the state of the machine. While handle inspect is akin to a get function where you're just consulting and analyzing things. So through handle advance I do some very basic routing with ifs and elses. Of course we do have high level frameworks for that, but this is a very simple app which I didn't need a high level framework and I wanted to use as a template just for people to get some snippets and add some codes.
00:27:18.130 - 00:27:18.818, Speaker A: Show the guts.
00:27:18.874 - 00:28:01.676, Speaker B: So let's go to my local host here. This is just a disclaimer. I am a very good designer but this is not my best work. So I'm just going to connect my wallet over here and I am connected to Anvil's basic wallet. So I do have Alice and Bob and they're going to be the players in this situation. I have an assets page where I can deposit my tokens. So I'm going to deposit 100 of my ERC 20 tokens and just confirm the deposit and the balance should be refreshed here.
00:28:01.676 - 00:28:23.950, Speaker B: As I already have some tokens here, you can see that the value changed. What happened here in the code is basically I got a random handle advance because I signed a transaction, sent it to my underlying chain and it triggered a deposit action which is triggered in exactly.
00:28:26.130 - 00:28:29.290, Speaker A: Where is it specifically except transferred.
00:28:29.360 - 00:29:21.376, Speaker B: Yeah, ERC 20. So dear I check if the message sender is the portal's address, which is one of the contracts that I said was deployed on chain, and I can basically perform an ERC 20 deposit. That means inside my application I change the balance and from then I'm just using the input box which is our generic trigger for the cartesian machine and ethereum. Right, or whatever other blockchain you're using. So now that the balance is here, the way I actually check it is through my inspect calls. So I do have a very simple call in here where I check for balance and it's pretty much an URL, it's a very straightforward URL where I can say get me the balance for this token for this user.
00:29:21.498 - 00:29:27.244, Speaker A: So yeah, that would be the equivalent of doing EvM call.
00:29:27.332 - 00:29:56.006, Speaker B: Yeah, exactly. So now that I did have deposited some assets. I'm gonna create a tournament and I'm gonna create my own fighter. Because arena mayhem is what we call a zero player game. And the objective of it is betting and creating wages and betting on your own gladiators to bet other gladiators and fights. So I'm going to create a gladiator called gabriel. And Gabriel is going to use a lens and I will decide his stats.
00:29:56.006 - 00:30:40.714, Speaker B: So he's going to have 30 gp, 30 attack, 20 defense, and 20 speed, for example. I'm going to sign this rejection in here. And now that I did, I can actually see that a game was created and it has pending status. So I'm going to disconnect from Alice, who is creating Gabrielle's gladiator, and I'm going to connect to Bob, who is going to create his adversary. So Bob will see here the list of challenges and accept. And all of this is gotten through those inspect requests and inspect calls. So I can see the balances and I can see the battles that are available.
00:30:40.714 - 00:31:08.480, Speaker B: And it's very simple. I can just call them Python and save the state of the battles. Create an array for challenges and list the matches in here. Once I do this, I can just create another fighter, which is gonna be, I don't know, Philippine. What are you willing to fight your favorite weapon? X? Okay.
00:31:09.790 - 00:31:16.490, Speaker C: Having Krishna HP. What do you think, Krishna? Oh, too late, man.
00:31:18.190 - 00:31:25.702, Speaker A: When we are creating the file, which you just have, so that kind of gets saved as what in the.
00:31:25.886 - 00:31:40.016, Speaker B: Okay, so it's a simple, very simple python code. I don't have any sort of database in here. I just save on regular application memory. So I just have an array and I'm saving the content in there.
00:31:40.168 - 00:31:44.768, Speaker A: This doesn't go to the blockchain or saved it to be just on the application.
00:31:44.904 - 00:31:57.656, Speaker B: So it does register in the blockchain because to send this data to the application, I send it through the blockchain as an input. Right. So in here, let me just check in the desk.
00:31:57.688 - 00:32:03.210, Speaker A: It's not part of the state tree in the same way it's not part of storage, if that's what you're asking.
00:32:05.110 - 00:32:48.550, Speaker B: Sorry, you need a. Okay, so yeah, basically what I'm doing here when I'm creating a fighter is I'm sending this createchallenge method. And inside the createchallenge method, what I do is I check for if the user has enough balance to create the battle, if he deposited his assets. And then I go through the ins and outs of generating a match. So I basically add to the list of challenges. This challenge that was created with its information, you can see that in here, I save a fighter hash because I do a commit reveal strategy. So it's not completely.
00:32:48.890 - 00:32:50.242, Speaker A: Can you increase the font?
00:32:50.386 - 00:32:51.058, Speaker B: Oh, sorry.
00:32:51.114 - 00:32:52.730, Speaker A: Like it's going to be more comfortable.
00:32:52.890 - 00:33:41.400, Speaker B: Yeah, probably, of course. So, yeah, in here, I do not save the fighter himself, because I do some commit reveal strategy, just so it's not cheatable, let's say. And then what happens is pretty much the duel was accepted by Bob. So I'm going to go back to Alice's account, and now that both of them have deployed their fighters, I can just start the fight. I have to resubmit because of the commit deploy strategy, and we can just wait a teeny tiny little bit. And what is happening right here is I'm sending the information to the backend. It's actually generating the computation and creating a log, which I'm able to animate later.
00:33:41.400 - 00:33:50.260, Speaker B: So you can actually see Gabriella and Felipe fighting here. You bet. I did bet. I did bet.
00:33:51.760 - 00:33:54.656, Speaker A: Oh, yeah, you bet. Damn it, man.
00:33:54.768 - 00:34:50.484, Speaker B: Oh, that was a close one. Okay, so the cool thing in here is that you can make basically anything with whatever language you want. And, yeah, for this, I did use Python, and you can see every one of the inputs in here and how they operate. So how I accept challenges, how I create challenges, and if you want to see in a lower level, you can actually use some of the tools that we created. One that I really like to use is the Cartesian explorer. Right, because Cartesian, yeah, also known as Cartesi scan because it actually shows all the transactions that were sent to the machine. We do have a graphql API where everything is registered and every output from the inputs that I sent is created and registered here.
00:34:50.484 - 00:35:00.460, Speaker B: So once you see the inputs, for example, this is the input I sent for accepting a battle. So you can see as a JSON, the command start match and the informations of the fighter.
00:35:00.580 - 00:35:05.792, Speaker A: See how lazy he is? He's not saving data, man, he's sending a JSON file to chain.
00:35:05.876 - 00:35:12.312, Speaker B: Well, I could optimize this, but it's.
00:35:12.336 - 00:35:18.540, Speaker A: Just, it's for the workshop, so it's easier to read. Nobody wants to read exit itself.
00:35:19.840 - 00:35:41.198, Speaker B: And then, same for the notice that I generated. I generated very simple log, which, if I print this, you will be able to clearly see that is every round listed. And, yeah, it's very easy to code and understand what's happening and what's going on. Awesome. That's pretty cool. Thank you. I like it.
00:35:41.198 - 00:35:42.246, Speaker B: Elf as well.
00:35:42.438 - 00:35:46.302, Speaker C: Could you also make it that you play yourself? Could you also make it that you.
00:35:46.326 - 00:36:02.736, Speaker B: Play yourself like you control the character? Yes, you can make much more complex stuff. We do have a showcase downstairs called rives where we actually, which is what Gabriel talked about, where we actually put doom on chain. And we have many other games.
00:36:02.848 - 00:36:05.944, Speaker A: Just go rise IO. You can play right now.
00:36:05.992 - 00:36:15.496, Speaker B: You can just go to rise IO and play right now. Much more complex games than this one that I did right here. Yeah. So let me go back to the.
00:36:15.568 - 00:36:18.448, Speaker C: And it's all running on the cartesian machine and then sort of post it.
00:36:18.464 - 00:36:34.430, Speaker A: To, yes, the claims. Yes. We can go deep into other integration stuff if you guys want to. But I feel like we put the message forth. I feel like you guys understood the overall context.
00:36:36.010 - 00:36:36.650, Speaker B: Oh, God.
00:36:36.730 - 00:36:37.530, Speaker A: Slideshow.
00:36:37.650 - 00:36:47.110, Speaker B: I can control it. Oh, my God. So hard. All right, so two computer science degrees and a master's, I don't think help you with presentations.
00:36:47.490 - 00:37:31.170, Speaker A: So I do have like some closing engagements. The most fun one is this one. So people often ask, is Cartesian Mainnet? Well, we application specific. So what do you want to mean with being a mainnet? But to make this answer actually way easier, the community came up with the Honeypot app, which inverts a little bit the idea of honey pots in security engineering. This one is to make sure that people feel safe when they're deploying with the Cartesi tech. So in regular intervals, the Cartesi foundation to support this project will be depositing CTSI onto this Dap. The dev is basically a mock.
00:37:31.170 - 00:37:59.580, Speaker A: It doesn't have actions besides holding the money. And we're inviting anybody who wants to try out the technology and try to hack it to just steal this money. And it's not even stealing because we are asking you to. It's completely free money for whoever can break the technology. Right now we are eight hundred twenty k. I don't know how much that's in dollars for now, but it keeps increasing. We basically just started with this and it's already at this huge amount.
00:37:59.580 - 00:38:18.890, Speaker A: And also to join Discord, we do lots of events, lots of engagement. We try to build a community in different regions. And discord is very lively. So if you have any question you're trying to build anything, you're looking for grants to start your project. We have it.
00:38:19.750 - 00:38:23.446, Speaker B: We also do all the research and development in public so you can follow.
00:38:23.638 - 00:38:32.650, Speaker A: The development of the protocol. These guys are crazy. They don't have like a slack or anything. They're discussing and laundering the dirty in public.
00:38:36.200 - 00:39:11.950, Speaker B: Yeah. And just to leave it registered because this is a recording. We have two specific programs. Types of grants, right? Yeah, the Devadsy grants that are used for people to start developing and learning on Cartasi so they can actually learn and have some incentives while they learn. And then the Cartasi grants program, which is community grants, which goes up to $50,000 and it's more on the side of incentivizing people to create things that enhance the protocol and the ecosystem as a whole.
00:39:12.850 - 00:39:22.110, Speaker A: Thank you guys. Thank you. Questions? Oh, awesome.
00:39:25.930 - 00:39:30.890, Speaker C: Yeah, I just wanted to understand you're making your cardesi is running on Linux.
00:39:30.930 - 00:39:35.650, Speaker A: Pretty much, yes, Linux is running on Cartasi, but semantics.
00:39:39.150 - 00:39:46.438, Speaker C: It'S full extent. Like anyone who's using Linux to do whatever they have done previously can sort of now do it on chain.
00:39:46.534 - 00:39:46.926, Speaker B: Yes.
00:39:46.998 - 00:40:11.860, Speaker A: Yes, you do. Often when people just jump there when they start realizing the first question they ask is, oh, can I access that API or that server? I'm like, no, you're still inside a blockchain system. So you don't have access to the Internet and then they have access to true time. So these are source of entropy and in order to make it reproducible you needed to remove from the machine, but everything else is there.
00:40:12.480 - 00:40:21.680, Speaker B: You can actually do some like use every tool that is offline in a sense, like a database. Yeah.
00:40:21.760 - 00:40:24.264, Speaker A: You can have networking that is in the loopback.
00:40:24.392 - 00:40:25.220, Speaker B: Exactly.
00:40:25.980 - 00:40:36.004, Speaker C: And what are some of the, like, the biggest limitations that, like from my user experience developing a game? Like what? Like what are some things that I have to get used to when I'm using content?
00:40:36.092 - 00:40:37.412, Speaker B: That's a very good question.
00:40:37.556 - 00:41:09.190, Speaker A: I feel like it's around blockchain itself because as people are thinking about our engine or even a server, they are thinking of this very fast paced level of communication that you won't have on blockchain. Like you can ever improve it, but you're still going to go for some kind of consensus even if it is just to get the ordering of the input. So this kind of delay needs to be figured out by the person who's trying to develop their system. I feel like it's inherent to the problem itself of blockchain.
00:41:09.270 - 00:41:47.078, Speaker B: Yeah. Adding to that, there is a teeny tiny limitation that is one processor. Because we are running this on a virtual machine and to make it deterministic, you can't have parallel processing. Otherwise everything goes crazy for now. Exactly. Because just now, last week a friend of ours, the same guy that did doom, he actually solved a huge problem for us, which he was able to actually delegate operations that behave deterministically to the host. So when he's performing, for example, matrix multiplications, you do have these lights.
00:41:47.078 - 00:41:49.562, Speaker B: Could be. Are they here?
00:41:49.746 - 00:42:00.250, Speaker A: Yeah, in the folder. I remember you putting the CC folder somewhere. I can look for anything, while. That's life. Yeah.
00:42:00.290 - 00:42:41.542, Speaker B: Okay. So basically what he did is you can actually delegate some operations that wouldn't make the application behave undeterministically to the core cpu. So essentially what he does, for example, for LLMs, is delegating all the matrix multiplication operations, which are the hardest operations for LLM. So depending on what you're doing, you can actually do some parallel processing. If this parallel processing does not infer in altering the outcome, you see. So essentially he did a, it's like.
00:42:41.566 - 00:42:43.118, Speaker A: A subsystem call in a way.
00:42:43.174 - 00:42:43.886, Speaker B: Yeah.
00:42:44.078 - 00:42:56.414, Speaker A: So whenever there was a matrix multiplication, instead of actually simulating and emulating the whole thing, because he knows it's deterministic in the result, he delegates to the host machine.
00:42:56.502 - 00:43:12.690, Speaker B: He had to make some tweaks to make it completely deterministic, like not working with floating points, but you can actually pull off some crazy things in which you have full power of your cpu and parallel processing for specific complex maps.
00:43:13.870 - 00:43:19.838, Speaker A: I just wanted to put the slides to see the huge difference that it made. It's so slow.
00:43:19.934 - 00:44:01.376, Speaker B: Yeah, the Internet's slow. It's going to be hard to show, but I know this. By head running lemma model, the lemma 1.0, he had 20 times performance gain. And running Lemma two seven b, he actually got a 120 times performance. So basically generation of a sentence that would take something around that would, a sentence with 100 symbols would take around I think, 5 seconds to generate and Yamaha one model. And in the lemma two model.
00:44:01.376 - 00:44:21.040, Speaker B: Yeah, so yeah, sorry, not lemma one stories stories 110, 100 symbols in 5 seconds. And for lemma two, 7 volts, which is a much more powerful LLM, in 1 minute, it was able to generate.
00:44:21.080 - 00:44:26.758, Speaker A: 100 tokens, 58 seconds from 114 minutes.
00:44:26.864 - 00:44:33.098, Speaker B: Which like, for verifiable AI that you can actually rerun, it's pretty insane.
00:44:33.194 - 00:44:34.190, Speaker A: That's insane.
00:44:35.570 - 00:45:09.652, Speaker C: That's really awesome. And then maybe like what's, what do you think is like the coolest thing that sort of, you know, doing Linux that's verifiable on chain enables, like what? Because obviously when you're, you can play it in many different environments and it doesn't detract from the user experience. So it doesn't really matter if it's verifiable or not. But what do you think matters that is verifiable that you can sort of run on Linux that you can't do on the EVM?
00:45:09.676 - 00:45:57.716, Speaker A: Right now I have this one example, it's another project that's almost, as developers rise, that is in defi space. I don't think it's the ultimate example, but it's just show like the first person to look at this and see, oh, I can actually take this staff that I couldn't before, which is DCA monster. So this guy is super into finance and he loves the curve that uniswap created. I think it's actually very ingenious. But you don't leverage the possibility of actually doing the perfect integral of the, of the curve because everything is still kind of like a tick. Right. And DCA is the ability of like planning how you're gonna do your trading.
00:45:57.716 - 00:46:30.590, Speaker A: Right. For people who are not familiar with it, it's when you say, oh, I want to trade $1,000, but I'm gonna do in hundred dollars increments. And you pace yourself like every day. And no, you do it like that. Now you're going to have a discrete average of what you're supposed to have. But because he has the ability to do this in the cartesian machine, he created a python copy in like a couple of hours of uniswap v two. He was now just updating for the new versions.
00:46:30.590 - 00:46:54.860, Speaker A: And then he is able to get these type of orders where you say, I want to trade $1,000 over a week with a perfect smooth integral of the average. So he has perfect averaging for everybody who makes orders in the platform. And that would be possible in any other evm system, or EVM like system because it takes a lot of computation to do.
00:46:55.280 - 00:47:30.792, Speaker B: Yeah. Personally, I have like three examples that I really like. Specifically, the same answer would be the most defi oriented one. Four examples, the other one that I gave already about the complex Daos that Philippi did. You can extend that to make so much more complex daos, not only with quadratic voting, but you can add logarithmic voting if that's the thing that you are, for whatever reason, interested in doing. But there are some crazy things you can do. I really like the example.
00:47:30.792 - 00:48:20.638, Speaker B: I know you said no games, but in terms of games, speedrunning platforms can be really, really nice because you create a very deterministic environment where people have to compete using the same random seed and no one can cheat. And then like the third one and last one. Regarding AI and machine learning, there's a guy called Kirill that did trust and teach tech AI, which is basically reinforcement learning, verifiably. So it's not just using AI, but actually training it on chain as well. And this is really fun for chatbots because you can actually see the behavior that they had and contest the chatbot owner service provider to actually show that, that chatbot actually gave you this answer. And, yeah, it's good for the user to have reliability.
00:48:20.694 - 00:48:21.290, Speaker C: Yeah.
00:48:22.230 - 00:48:23.150, Speaker A: That's awesome.
00:48:23.270 - 00:48:24.462, Speaker C: Well, thank you very much, guys.
00:48:24.526 - 00:48:27.310, Speaker A: Thank you, guys. I.
