00:00:03.080 - 00:00:22.914, Speaker A: And we're live GM, everybody. Thank you for joining in another workshop for the infinite space Bazaar. Today I will be. Well, we'll all be learning from Robin from abstract. Abstract SDK is an interchange application development platform. Robin, you want to introduce yourself and tell us more?
00:00:23.374 - 00:00:50.354, Speaker B: Yeah, sure, Josh, thanks for having us, first of all. So I'm Robin, co founder of Abstract. And Abstract is a cosmosm interchange development framework. So we try to make it as easy as possible for developers to create cosmosm applications and to launch them on any chain, including the roll ups that you guys are working on.
00:00:51.674 - 00:00:55.814, Speaker A: Awesome. I'm going to go ahead and give you the floor. Excited to learn more.
00:00:56.274 - 00:01:55.018, Speaker B: Yeah. So in this workshop presentation, I'm going to be walking you through what abstract is, kind of the ideas behind it, why we built it, and then we're going to get hands on with a dollar cost averaging application. There is a repository, a workshop repository that we have set up. You can clone that and then follow along as we fill in some of the gaps, some of the quests that we created there, to get familiar with the framework hands on. So what does Abstract do? Abstract is essentially a platform with three components. We have the dev tooling, which is mainly CW orchestrator. It's a library that we've developed that enables you to interact with your smart contracts, to test them, to deploy them very easily, because we saw that there were a lot of problems with the current state of developer tooling in cosmos specifically.
00:01:55.018 - 00:02:41.528, Speaker B: So this tool really solved those. Then we have some front end libraries that enable front end developers to interact with the on chain infrastructure that we deploy and the applications that they will be developing themselves. And then the main component is our on chain infrastructure, Abstract SDK. And that's what this workshop is going to be about. So we're going to be talking about the infrastructure, what it does, and how to work with it. So we're going to be making this application, making this dollar cost averaging application, so just so that everyone is on board with what it actually is. Dollar cost averaging is a way to invest into a certain coin over time.
00:02:41.528 - 00:03:32.454, Speaker B: So instead of buying your token at one price in one big amount, let's say like $1,000, you split it up into buying your token over a period of like a month with $100 each. So there's actually already a product live in the cosmos ecosystem that allows you to do this. And they're called calculated finance. You can go there, you can set up a strategy, and they will automatically buy into a certain token that you selected over time. And charge a little fee for it. So this is actually a product that is quite valuable in crypto. So if we want to like think about how we would make something like this, like from a developer standpoint and a user standpoint, we need three things.
00:03:32.454 - 00:04:11.984, Speaker B: First of all, we need an ability to create this application and to configure it as well as deposit into it. So if I want to buy bitcoin ten times over the next month, then I need to be able to tell the code on chain to do that. So that's the first. And then I also have to give it money to actually make it buy it. The second component is to automate the buying. So there needs to be some kind of cron job going on that every couple of days tells a contract to buy. And then the third is, of course, you need the ability to withdraw your tokens.
00:04:11.984 - 00:05:13.774, Speaker B: So if we want to start coding, what do we really need to know with the dependencies that we have is first of all, the exchanges. So we need to have a place where we can exchange one coin for another. And if we want to do that in our code, we need to go look at the code of this exchange, the API that they expose, and see how to format our messages, how to send the right coins to it, how to work with it. And we also need to know the on chain addresses of those smart contracts or of those pools so that we can actually interact with them. And then on the automation side, we need to write maybe our own bots that will execute it, or maybe we want to rely on external service, but then we also need to figure out how to set it up. So actually building the logic of this DCA app is very simple. You just buy some tokens and have it have some configuration that tells it what to buy.
00:05:13.774 - 00:06:00.298, Speaker B: And when the problem really lies, or the complexity really lies in having to integrate with these other applications and figuring out how to do that successfully. So it's a lot of complexity. Let's say we want to integrate with osmosis or astroport. If we do that, then we have to go look at the source code, which I previously mentioned. We have to import their packages and stay up to date with their code and then write calls to their contract and actually test it. And testing this has been very hard historically, and part of our tooling solves that, but it's still a lot of work, and it adds a lot of code to your code base, and it adds a lot of maintenance. And every project does this from scratch.
00:06:00.298 - 00:07:03.332, Speaker B: Everyone who needs to interact with an exchange is going out there looking at the code of the exchange and then writing the integrations manually. And if you do it for one exchange, that's fine. But if you're working in an ecosystem like the cosmos ecosystem, where basically every single chain has a different Dex, then this really starts adding up, and it's really annoying to do so. What abstract allows you to do is to separate that logic, the DCA application logic and configuration, from the actual exchange integrations. And that way you reduce the scope of your application and you reduce the overhead of having to integrate with these exchanges. So how does that work? So this works with the abstract framework. And the abstract framework is a set of smart contracts that we deploy to every blockchain that we want to support.
00:07:03.332 - 00:08:20.236, Speaker B: And it facilitates creation of abstract accounts and it enables composable applications, and it's also a software distribution platform. So these words might not save much to you right now, but that's what the next slides are about. So just know that an application that is built on abstract is actually built on a smart contract wallet that we call an abstract account. And this abstract account can hold funds for you, and it can execute messages on behalf of other smart contracts. So that makes it kind of modular, right? If you have a smart contract wallet, which is the appstore account, and you can have another smart contract delegate calls to it, then you can start separating out that logic into a specific smart contract, and then just passing on the execution to the smart contract wallet, the abstract account that then actually executes it. So that's what we call modules. Modules are smart contracts that will create some messages and forward it to the smart contract wallet, which we call the abstract account for execution.
00:08:20.236 - 00:09:17.734, Speaker B: And then that will actually manage the funds to the swaps, etcetera. And a module can be an app or an adapter and kind of get into that later. So again, this is all very high level talk about abstract things. So let's give an example. We have created this thing that we call the abstract adapter, and it allows you to execute swaps or any action on a decentralized exchange with a standardized API. What we show here is a DAX action, and there are multiple other kinds of Dex actions, but we're just showing the swap here. And in the swap we give it an offer asset, we give it an ask asset, and we give it some parameters that make us assert slippage so that we don't lose our coins, basically.
00:09:17.734 - 00:10:13.042, Speaker B: And what this allows us to do is to not worry about the actual exchange that is being used, but just call this Dex adapter directly. As an example, I'm the owner of this appsite account and I want to swap some tokens from some us dollars to euros. What I do is I call this Dex adapter. I say, hey, for the exchange osmosis, which is the biggest cosmos Dex right now, I want to do an action and I want to swap. And to swap, I want you to use the US dollars that are in my abstract account and I want to get euros in return. Okay, so you make a transaction, you send that to this Dex adapter. The Dex adapter then figures out, oh, you're trying to call osmosis.
00:10:13.042 - 00:11:27.884, Speaker B: Okay, how do I need to format these messages? What are the addresses that I need? Which pool exactly are you talking about? Because we were providing us dollars and euro, we're not even saying which pool this needs to use. So the Dex adapter figures that out dynamically, it figures out, okay, to swap this asset into this asset, which pools are available, and then it uses the highest liquidity one, and then it creates this message that's not very human readable, and it just forwards it to the abstract account and then the abstract account executes it. So as a user, we have this really nice message, and then the contract basically turns it into the garbage that we just execute to make this stuff work. The cool thing is that this is extensible. So instead of me as a user signing a message to call this DAX adapter, I can create a smart contract that does the same thing. Now the smart contract doesn't need to know about the specifics of these exchanges. It just tells this DaX adapter, hey, can you swap these other tokens for me on this exchange? Thanks.
00:11:27.884 - 00:12:33.684, Speaker B: Our DCA app also uses this because our DCA app needs to do swaps and it will depend on two applications or two modules, the first of which is a Dex adapter, which I just mentioned, and the other is a Croncat app. So Croncad, if you don't know it, it's a cosmosm oriented automation application that is deployed to different chains. So it does cron jobs for you. We created this app to encapsulate that functionality, and then you can take it on as a dependency and you can set up cron jobs with a few line of codes which we'll show later in the workshop. So like I said, we have this Croncad app, we have a Dex adapter staking adapter for different exchanges. We also have a landing. Oh, I think, let me quickly.
00:12:33.684 - 00:12:38.384, Speaker B: Yeah, I froze. Let me quickly. I wasn't sure, if there was no.
00:12:38.464 - 00:12:39.844, Speaker A: Connection for a sec.
00:12:40.294 - 00:13:16.386, Speaker B: No, it's mine. Okay, cool. Sorry for that. Yeah, so we have some modules that are integrated already and that you can use as dependencies for your own application. So like lending market adapter, staking after Dex adapter, all of these integrate with different services and you get a nicely unified API to interact with them. Then we built some apps on top. So we have this ETF application that allows you to turn an abstract account into an ETF.
00:13:16.386 - 00:14:18.912, Speaker B: So anyone can deposit like, let's say dollars into it, and then the manager of the ETF can trade it into different assets and kind of manage the portfolio. We also have a subscription app, which is pretty cool. So this allows you to create an abstract account, and then when you install the subscription app on it, you basically create a subscription that anyone can subscribe to. And then there are some other orders as well. So this is kind of the high level overview of what abstract is, how the accounts work, why we created the modular smart contracts that can depend on each other. The rest of this is going to be a workshop on how to actually use it. So if you go to this URL, for example, you should be brought to a page on GitHub where you can fork our workshop.
00:14:18.912 - 00:15:04.274, Speaker B: You can also scan the QR code if you want, and then there are resources. You can go to the docs abstract money, but we won't really need these right now. I'll be your documentation today, but you can just know that this exists. We have a lot of more high level documentation as well as a detailed walkthrough of starting with a template and then explaining the templates, what I'm going to be doing today, and also just more detailed information on how to get started. So if I can share my screen, that would also be nice.
00:15:04.734 - 00:15:07.394, Speaker A: Yeah, you can just share it and I'll add it up.
00:15:08.294 - 00:15:09.554, Speaker B: Share screen.
00:15:11.134 - 00:15:21.684, Speaker A: And in the meantime, while you're doing that, if anyone has questions for Robin about the presentation or for questions during the workshop, please drop them in the chat and we'll get to them at the end.
00:15:35.064 - 00:15:53.676, Speaker B: Okay, nice. Okay, sweet. Is it possible to switch between the screen share and the presentation or not?
00:15:53.820 - 00:15:56.372, Speaker A: Yeah, I can just swap it right between them.
00:15:56.548 - 00:16:25.754, Speaker B: Okay. Okay, cool. So if you've downloaded or cloned the repository, you should end up on here. So this is the, it's called awesome, awesome workshop. That's the workshop that we're going to be doing today. The main line is quests and there is another branch called solutions. So you can go check out solutions if you want to.
00:16:25.754 - 00:17:37.234, Speaker B: So the quests are set up in a way for you to go through each quest by looking, going to the search bar and then doing hashtag and then the quest number. So we're going to be starting with quest number zero and then you will find some explanation down here and we will talk through what this explanation is. And then I'm going to show you the solution on how to solve this specific quest. So the first one is doing a module dependency. Before we get into that you will see this huge statement here, this const statement. This is a builder pattern that we provide. Remember how I talked about modules, how I talked about apps and adapters being modules? We're going to be building a GCA app and the DCA app is an app contract and this app contract is a type that we provide for you to customize.
00:17:37.234 - 00:18:34.036, Speaker B: So as you see, we have a custom error here. We don't have a custom instantiate message yet, we have a custom execute message, custom query message, blah blah blah. This defines our DCA application. Then in our app we have an id, an app id which is a string and this is a unique identifier for application. When we deploy it on chain we need to make sure that we have the namespace claimed, which is this abstract prefix, and then the name of the application itself is DCA. So namespaces I'll get back to later as well when we show how to actually deploy this application. Then this application also needs to have a version because that's also checked by the infrastructure when your application is deployed that the version is correct and it also helps with dependencies.
00:18:34.036 - 00:19:15.114, Speaker B: So if you have another contract that depends on this UCA application, then it needs to specify what the version is and then that will be checked by the infrastructure as well. Then we have these handlers which I'll also come back to later. But the main goal of this quest is to fill out this dependency. So we have this with dependencies function that will add dependencies to our GCA app. And if you remember the slide I showed earlier where we have our croncad dependency and our dex dependency, this is where we need to add them. So right now we already have a dependency on Croncat. So this is the Croncat Id.
00:19:15.114 - 00:19:56.800, Speaker B: So Croncat Cron and then this is the version of the package zero 2.0. So if you want to figure this out yourself then don't look. But what we're going to do is we're going to add a new static dependency and then the module id will be the abstracts dexadapter. Dexadapter id. This is again published by abstract, so by us. And it's the unique ideas Dax. And then the version requirement will just be the version of the of the package.
00:19:56.800 - 00:20:26.684, Speaker B: So dexadapter contracts and then contracts version. So right now the version is 0.21. Cool. So that is quest one done. Also you should be able to check the code. You will get a lot of warnings, but we will fix those as we proceed with this workshop. So now we have defined our dependencies for the CCA app.
00:20:26.684 - 00:21:16.844, Speaker B: And when we try to install this app, after we've deployed it, when we try to install it on an account, then our infrastructure will check whether these dependencies are met. So if we don't install the Croncat app on the account and we try to install this app, it will fail. If we don't install the adapter on this account before we try to install this app, it will also fail. And if the version requirements aren't met, then it will also fail. So that's just a really nice kind of, I guess an analogy would be to like a package manager. So this allows you to manage your on chain smart contracts as if they were packages. And it makes sure that you don't have versions running amok in compatibilities.
00:21:16.844 - 00:22:02.740, Speaker B: Okay, so that was quest zero. Then if we go to quest one, we are in this update config function that takes in all these different options. This is a way for a developer to change, or for the user, the owner to change some of the configurations of DCA. So new assets, new amounts, refill threshold, etcetera. But of course we only want this function to be able to be to called by the owner of the account. Not just anyone should be able to call us. So to do that we can do an administration.
00:22:02.740 - 00:22:56.394, Speaker B: And the admin is actually something that's already included in our app, in our app contract that abstract provides. So what we just do here is we do app admin and then we assert the admin and we say depths as ref. And the caller is this message is in this message info. So message info sender, let me insert that. And where it gets this admin from is actually the owner of the account. So like I said, every application is basically a smart contract wallet that's called an abstract account with some applications installed on it. And this is gonna.
00:22:56.394 - 00:23:32.174, Speaker B: So this application will be installed on an account and this account will have an admin or an owner. And then this assertion basically says that whoever wants to call this function needs to be the owner of the accounts that this app is installed on. So like a phone, you could say only the person who is allowed to unlock the phone can change the settings of the app. If that's a good analogy, I'm not sure that it is.
00:23:32.994 - 00:23:34.734, Speaker A: I think analogies are great.
00:23:37.194 - 00:24:04.596, Speaker B: That was quest one. Maybe if there are any questions, let me just quickly see in the chat. No questions yet. Okay, cool. So then quest two is a little bit more work. So I think I'm going to go back to my slides if possible. So go through this module dependencies.
00:24:04.596 - 00:24:34.364, Speaker B: This is what I just explained, this app contract. Cool. Now we're going to talk about these handlers. The handlers are how you can customize your application. The unique thing about them is that they have this inserted app object. If you're familiar with cosmosm, you should be familiar with the structure of this function. So you have your dapps, you have the environment, you have some info, and you have the message.
00:24:34.364 - 00:25:39.044, Speaker B: So what we do is we insert this app object into the function, and the app object allows you to do some magical things. These magical things are what we call our APIs or abstract APIs, and they are implemented in our SDK or they can be implemented externally as well. The way that this works is this object that we expose, it implements some traits that can be used by other traits. So like super traits, and then you can compose traits to create complex interactions between smart contracts. So maybe let's just go into the code and show how this is done. For example, in here, quest two, we need to pass on a call to our Croncat API. We define CronCat as a dependency.
00:25:39.044 - 00:26:32.024, Speaker B: That means that it will be installed on the account when this application is instantiated. And that also means that we can call that contract from this contract and do certain things to it. The way that you can do that is to say, okay, I want my croncat API. And this is exposed with this croncat interface. So this is imported from the Croncat app. We have this API croncat interface, and then we provided the depth, it needs the depths to be able to do queries. Then we have this croncat object and then we can call this croncat API to for example, create a task.
00:26:32.024 - 00:27:22.564, Speaker B: So, and then the task. So this will return a message, let's create taskmessage. We'll do that. And then we can add that here. Add message task. Sweet. So for this I'm going to actually jump to the other branch.
00:27:22.564 - 00:28:22.394, Speaker B: So gonna validate these changes. Cool. Oh yeah, use an external function. But here we basically create this croncat API that I was talking about. And then we have this convert task internal that does some croncat stuff that we will come back to and then creates a task with this API. So this is actually also part of number two, is to take this API, call the create task with the specified data, and then it returns a message. And that message will create a task on the croncat infrastructure to repeatedly call the dollar cost averaging app.
00:28:22.394 - 00:28:56.546, Speaker B: So that's that. That was that. And then quest 2.1 is when we create our GCA configuration, we actually want to assert that we can swap between the two assets. So let's say we configure this app to swap between bitcoin and doge. If there's no pool between those two, then it will fail. So we need to verify that there's a pool between those two.
00:28:56.546 - 00:30:02.794, Speaker B: And we do that by simulating. We have our app and then we have this AnS Dex that uses the abstract name service, which is kind of something that I'm not going to touch on too deeply here, but you can read up on it in our documentation. It allows you to resolve kind of like DNS resolve a name into an address or a specific asset or something similar. So once we have this API, we can do different things on it, like simulating a swap, but there's also just doing a regular swap or provide liquidity, like those kind of, or withdrawal liquidity as well. So all the actions that you want to do on exchange you can do with this API. You provided the name of the Dex, and then in this case we simulate a swap and we assert it. So if there's no pool that exists for the assets that the user provided, the simulation will fail and the contract instantiation will fail and it will tell the user, hey, you try to configure this with an asset that we don't support.
00:30:02.794 - 00:30:27.258, Speaker B: I think 2.3 is creating this task. So that's with the Croncat API that I showed earlier. 2.2 is the same kind of simulation logic, but for updating the DCA configuration, 2.4 is removing. So this is another function on the croncad API.
00:30:27.258 - 00:31:04.224, Speaker B: All of these are similar. They just show you how to get an API from the app and then to call on it. So some other APIs that we have are for example our bank API that allow you to do swaps. So you can query the balance. Of course you can deposit into your account, you can transfer, and you can also send and withdraw. So that's one. We also have like odd c for example, that's feature flagged.
00:31:04.224 - 00:31:38.444, Speaker B: There are some other ones here, some queries. Contradictory is like a lot of APIs. You can also read up on this in the documentation. They're all elaborated on. So that was kind of that. And then we have quest number three. And the quest number three is also going to need the slides for this.
00:31:38.444 - 00:32:29.214, Speaker B: Sweet. Cool. So question number three is all about customizing your message types. So every contract has a set of messages like I mentioned earlier. So you have the inside sheet message, the execute message, query message, migrate message, all of these. And because we provide some basic functionality already in the this app contract, we need to make a segregation between the base, the base functionality and the custom functionality. So for execute message, for example, the top level execute message of the contract will be the struct where you provide a custom execute message that will be inserted in this module.
00:32:29.214 - 00:33:29.998, Speaker B: The quests related to number three all go in on how to do that. So if I go back to the code, you can see here that there's like a lot of boilerplate that we used to have to define these messages, the top level messages. Right now you can just do that with the simple, the simple app message type. Actually I will also go back to the class and discard this. Cool. So this is what you should see when you're on request. You can just remove this and make use of the app message types, message types and then provide the thing here.
00:33:29.998 - 00:34:00.328, Speaker B: So we do the type. Our type is DCA app or actually message and query message. So now it says define multiple times. So you can remove this. Cool. Then we have our types defined and we can use them in other places. And there are some CW or exterior tooling that also helps out here.
00:34:00.328 - 00:34:41.573, Speaker B: So that's why we need that then 3.1 is this from trait. So in this task, when we create this task, we're telling Croncat to do a certain action with an interval boundary, which is when it should be, when it should stop being executed. But we don't really want that. We just want it to stop when it fails. So when you're out of funds, it will try to compound that will fail and then the task will get cleaned up. Now we tell it the action to perform and the action is a message.
00:34:41.573 - 00:35:48.984, Speaker B: So wasm execute on this contract. So the DCA contract and then we need to provide it with the message. And in here we are going to need this top level execute message that we just defined. So execute message and then we can tell it to create it from our customer DCA execute message and we want to call convert with the DCA ID being provided up here. So that's DCA ID like this. And then we just, yeah, that works. So now with this task that we used on here in the early request, this task will be added to Croncat and it will be calling our own contracts at this endpoint with this DCA ID.
00:35:48.984 - 00:36:22.070, Speaker B: So that was 3.1 then 3.2 is about this custom instantiate message. Right now we have our app contract, but we don't have our instantiate message defined. This is an empty. So what we're going to do is going to say this here, instantiate, instantiate message. That should be oh, it's app insheet message.
00:36:22.070 - 00:37:09.362, Speaker B: Fair enough. It's a little bit inconsistent. Okay, so now that we have this defined here, we actually get an error in our instantiatehandler function that we provide saying that the types don't match. And that makes sense because it's empty. So we also have to make this app instantiate message and then we can import this and then we can use that message to get our asset here message. I think this is native assets. Oh yeah.
00:37:09.362 - 00:37:49.714, Speaker B: So this needs to be resolved. So what we got in our message is a message entry and this is like a URL. Now we need to figure out what the actual denomination of this asset is. So to do that we use this nameservice that we created with the API. So this is like an API object. Now we say nameservice query, we give it our entry and then a reference to it. Then we got that.
00:37:49.714 - 00:38:38.358, Speaker B: And then uh, this config is just e voila. That's that. Um, cool. That was, that was three. Now we can go to four, maybe the slides again for this one. Cool. So now that you have your application figured out, and you been working with the APIs to make your life easier, you got your instantiations going, etcetera.
00:38:38.358 - 00:39:25.890, Speaker B: But you want to test this. Now how do you test it? That's what used to be pretty hard. But with this abstract client crate that we've developed, it's actually very easy. Together with orchestrator you're able to write interactions with your smart contracts and your applications and execute them on different environments. So we have a little bit of documentation. If you look for abstract clients and crates, you will find that, but I will show you in the code right now how to do that. For our tests, for our integration tests, we're using this environment called mockback.
00:39:25.890 - 00:39:59.280, Speaker B: 32 that is provided by CW orchestrator. It's a wrapper around CW multitest, which is something that's provided by confiot who developed colossal model. And we create this environment and then we add some balances. We set up the croncad contracts which don't use orchestrators. So it's a little bit more manual. So I'm not going to go into that function too deeply. And then we need to deploy abstract.
00:39:59.280 - 00:40:33.054, Speaker B: So abstract is a set of smart contracts that we deploy to different environments. We should also be able to deploy this to a mock environment. So that's what this does. We have our abstract client, we make a builder because we're going to be deploying to the environment. And then we provided the environment, which in this case is our mock environment. And then we have some functions here that help you configure the abstract name service on that environment. So we add these genomes and some contracts addresses.
00:40:33.054 - 00:41:18.256, Speaker B: Then we use CW orchestrator to deploy a Dex onto this environment. So in this case it's Windex. So this is everything that Windex has. So these are pools, these are factories, these are token emissions. Everything that Windex does is deployed to this environment. So if you go into this function, it doesn't actually show the implementation, but it deploys and instantiates all the contracts onto our environment and then returns an object for it. And then we need to upload or deploy the DAX adapter because this is a dependency that we have.
00:41:18.256 - 00:42:05.406, Speaker B: So we do that by creating a publisher. So a publisher is an account that is able to register smart contracts on our platform and we do that based on the namespace. So the namespace from id will take abstract. So abstract is a namespace and this publisher builder will create a new account and claim the namespace if it isn't already claimed. So now we have this account that is a publisher and we can use it to publish the adapter. So we do publish adapter, this will instantiate it as well and then publish it to the infrastructure. And then we do the same for Croncat.
00:42:05.406 - 00:42:47.734, Speaker B: In this case we're creating a new publisher because the namespace is different, that's Croncat. And then we publish the application on the infrastructure. And then quest four is we need to deploy our own DCA app. So we say DCA, that's publisher. Being the DCA publisher, we take the namespace from our id. So now we should be able to publish our DCA app. So now we can say publisher, publish app, DCA mockbeck 32.
00:42:47.734 - 00:43:27.318, Speaker B: And this DCA object is an interface. It's a little bit besides the point. If you're more interested in the tooling, you can go to orchestrator abstract money. And there we explain what these interfaces are and how to use them more deeply. But for now, just know that it's generated for you and you can use this with the client. So now we have this publish app, and then afterwards we can create an account and install this by doing account client account builder. Now we have an account builder.
00:43:27.318 - 00:44:16.146, Speaker B: We can install an app with dependencies because we know that our DCA app has dependencies and we give it the inside shape message. And this will install the DCA application on top of our account together with the dependencies. After this we get account back which contains the application. So we can say account application, give it the type and then get the application. And then here we can do some configuration on it and return it. So that was a mouthful as you could imagine. If you want to do this kind of code without proper tooling like we have, it's basically impossible.
00:44:16.146 - 00:45:05.662, Speaker B: So yeah, the tooling that we have is really, really amazing. So if you're developing cosmos contracts, you don't even need to be using abstract to do it. But if you're, if you want to give yourself an upgrade developer wise, then you should definitely check out orchestrator. Cool. So that was four. Now five is showing some of the orchestrator features that we have. So if I go back to our slides, then you can see that we have this derive macro that orchestrator exposes.
00:45:05.662 - 00:45:55.484, Speaker B: It's called execute functions. And you add it to your custom execute message and it will create functions on your interface that you can use to interact with the app. In this example, we have our executes message which has an update config variant. When we have our interface, we suddenly have this function available called update config and it is automatically generated. And when you call it, it will call the function on the contract and do the actual interaction. In the codebase? Yes, in the code base we can do the same. So we have this app structure which encapsulates all the applications that are deployed.
00:45:55.484 - 00:46:48.954, Speaker B: So we have DC app, DC Daxadapter, Honkin app, etcetera. And then if we want to create a DCA on it, we can say apps DCAapp. And then we have a create DCA function and this create DCA function, if I click it, it goes to my message. So there's no manual function that I wrote to have this available in the tasks. It's just a function that was generated based on the variance. And then in here I can say what Dex I expect. So the test is using, using Windex, we can say frequency, which is specified here.
00:46:48.954 - 00:47:36.624, Speaker B: We can give it a source assets, choose this ans assets. And then we can give it another DNA, the target asset, it's just a name. Now we can do question mark, and then this function will call the contract. And if you want to do something with response, you can also do that. So you can say response equals that. And then we get this app response. And then in the response we can assert that a certain event occurred, or we can, yeah, do whatever with the response.
00:47:36.624 - 00:48:08.644, Speaker B: There could be some data in there that you want to know what you want to assert. So that's five and then 5.1. So this is basically the same thing where we have our DCA app and we want to call, what was it called? DCA. DCA. Nice. And then DCA IDC one. Nice.
00:48:08.644 - 00:48:54.778, Speaker B: So this will DCA. And then, so this DCA is actually a query instead of an execute. So we have the same thing going on here. If you've ever used CW multitest, then you will know that normally when you do a query with CIB multitask, you need to define the response type. So in this case that's two ccaresponse. But because of our, with our macro, we can actually infer it, because we have this macro here already, this attribute. So when you call it, when you call a function, it will automatically convert it to the correct response.
00:48:54.778 - 00:49:50.522, Speaker B: And then we assert that this configuration is what we made it. So that's some server orchestrator magic that you can use in your smart contracts. It also cleans up your testing code a lot, because it's very nice to just say, I have a DCA app and query, mean the DCA configuration or update it or do something. You already have the verbs normally in your API, so just keeping that consistent within your code base and your testing is just very nice. Cool. So then the last thing we need to do after we've tested it, we've made sure that our logic works as it should in a local environment. Then we can do the same, but do it on an actual blockchain.
00:49:50.522 - 00:51:06.878, Speaker B: So what I have here is a binary that's in examples deploy rs, and this is a main function that will create a runtime. So this is like an asynchronous runtime that we need to delegate calls to. And then we create this daemon object. This is a serial orchestrator thing that allows you to interact with a daemon which if you're not familiar with it, all of the software that blockchains actually run, we call them daemons. So you have chunod, osmosis D, et cetera, et cetera, and they expose some ports locally, GrPC ports specifically, and Rolekit actually does the same. So if you go onto the rolekit documentation, you follow along on how to create a cosmosm enabled roll up, then this is the configuration that you should land on. And if you then spin up this rolekit locally, you can give our daemon constructor the information so specifically like the fee, the gas denomination, the ports on which the GRPC is hosted.
00:51:06.878 - 00:52:14.514, Speaker B: And then this will create this chain object which you can use to create your client and to create your publisher, which we've done in our tests as well, and then to publish the app. So just publisher publishapp and do the same as before. So I think this was nice. So now you can run this. This is not going to work because I don't have Rolekit running locally and I think, oh, oh yeah, yeah. Okay, so this failed, which I was expecting, but this just shows you how to deploy to really any environment. So this could be like Juno as well, or osmosis or whatever.
00:52:14.514 - 00:52:44.282, Speaker B: Cool. So maybe let's go back to the site. Amazing. So yeah, if you want to learn more, we have a lot of documentation as well on the link. That was the last link that was shared, orchestrated abstract money. You can read up on this daemon. There's also some documentation on Rolekit specifically, which is shown here.
00:52:44.282 - 00:53:46.700, Speaker B: So how to use Rolekit in your, in your smart contracts to deploy to it. And then I'm kind of at the end of this very long explanation and workshop on abstract if you want to get started with it. We have some bounties to create a social fi roll up. So you can think of different applications that you want users to be able to customize. So let's say I have like a social network and I have different profiles that I want people to have. I want them to be able to manage their own on chain states that describes their profile. Then you can create an abstract application, you can make it very customizable for each user, and then each user will come to your platform and create an abstract account, install your social fi application, and then be able to interact with other people who have the same application installed.
00:53:46.700 - 00:54:22.494, Speaker B: So that's kind of an example of something you could build with this. And if you want more to actually get started, you can go to the docs, you can go to our app template, which is the best place to get started with an application. You can just clone this template. You can then make some minor tweaks and then start implementing the logic. We already have a deployment script written in there. We already have integration tests written in there. So it's really nicely scaffolded for you to just get going quickly.
00:54:22.494 - 00:54:56.324, Speaker B: Additionally, you can also go to our discord where we will answer any questions that you have about anything, basically. So we're very welcoming of questions and curious people and killer developers. So if that's you, then basically come to our discord and join the party. And I think that is kind of it. What would you say is the best resource to quickly pick up rust? Cosmos and Cosmos depth? One each is fine. More practical would be best. Okay, cool.
00:54:56.324 - 00:55:44.224, Speaker B: So if you want to get started with this whole thing, I would recommend doing doing a basic rust, not a course per se, but getting familiar with the concept of ownership is very important. You don't need to get very deep into it. I would say the rust book is oftentimes recommended as the best resource, but it's quite heavy to follow along. There is. Let me look this up really quickly. There is a like workshop tutorial that was developed in the Tera days that is actually really good.
00:56:04.664 - 00:56:06.324, Speaker A: On the cosmosm book.
00:56:07.064 - 00:56:19.302, Speaker B: No, it's a cosmosm academy. So this is how I personally learned my, my cosmos, my initial cosmosm and rust. Oh, I need to connect to YouTube.
00:56:19.448 - 00:56:21.650, Speaker A: You can just put it in a private chat if you want.
00:56:21.802 - 00:56:42.298, Speaker B: Yeah, I'll put it in a private chat. Okay. So this is what I use myself to kind of get familiar with cosmosm. If getting into cosmosm is also very different from getting into cosmos, mainly because of the language difference. So. And the tooling also. So cosmos.
00:56:42.298 - 00:57:31.588, Speaker B: If you want to learn cosmos, then you should go to the documentation of the Cosmos SEK and you should learn go if you want to get into cosmos. And you should learn rust and learn about Cosmos specifically. I would also say the cosmosm book itself is. I think it's book cosmosm.com. Yes. It's also quite elaborate on, like what the cosmos contract is, how it works, the migration. Some of the nuances are quite important to know, but without that knowledge, ideally abstract would still be available to you to just start developing on.
00:57:31.588 - 00:57:55.204, Speaker B: So if you're at that stage, then we'd be happy to receive feedback on our own documentation to kind of get you up to speed faster without having to learn all the basics that deeply first. So are there any other questions?
00:57:55.984 - 00:58:10.824, Speaker A: There aren't in the chat. I'm curious why cosmosm? I know, yeah, we've seen a lot of EVM workshops and a lot of EVM roll ups. But, yeah, I'm curious to know why you went with cosmosm.
00:58:11.324 - 00:59:20.436, Speaker B: Yeah. So, basically, one of the biggest problems with EVM is like reentrancy and contract safety and also efficiency. So when you write your smart contract in EVM, you're kind of exposing yourself to a lot of risks that shouldn't really be there in the first place. And also the fact that cosmosm is WaSm based enables it to be executed on basically any blockchain that enables WaSM execution. So it's very interoperable with other things, and it also allows for a lot more complexity and modularity. So what we're building is, is very, very, very hard to, impossible to build in the EVM world. And while it's currently maybe a little bit daunting and complex, we're making strides more and more, building out the basic modules and the building blocks.
00:59:20.436 - 01:00:32.894, Speaker B: And then it's very easy to create very complex applications with those little building blocks and to really start making things that aren't just exchanges or aren't just money markets, but more integrated applications, because right now it's just very, very hard to do these problems that I mentioned of having to integrate with the different exchanges and managing that code, that just puts a gap on how complex or how intricate you can make your application. And by moving that away and giving developers more verbose, easier access to those on chain functionalities, we can actually create more complex applications. Also over IBC, we have a lot of integrations with IBC. We have something that we call abstract interchange accounts that enable you to have an application on one chain, but also have it on the other chain, and for those two applications to talk to each other between the chains and to manage funds between the chains. So, yeah, that wouldn't be very.
01:00:33.014 - 01:00:34.274, Speaker A: A lot of good reasons.
01:00:34.894 - 01:00:35.674, Speaker B: Yeah.
01:00:37.574 - 01:00:43.954, Speaker A: I know you gave us one example. I'm curious if there's any other things that you'd really like to see built with abstract.
01:00:45.334 - 01:01:45.194, Speaker B: Yeah. So right now we internally are working on an interchange stablecoin yield aggregator, and this will enable you to deposit stable coins into the protocol, and then it will find the best yield in the interchange. So not just locally on one chain, but on all the IBC enabled chains where there is yield available, it will dynamically allocate it to maximize your yield. So that's like a really cool application. Something else that we would really like to see is an aggregator, like a Dex aggregator, because we have all these integrations, but we don't really have any code or any smart contracts that aggregate them. So it would be great to see that, so that we can enable better routing through our smart contracts for executing trades. I see that there's another comment in the chat.
01:01:45.194 - 01:02:41.054, Speaker B: So in the social fi example, these are interacting with each other, which each transaction requires a gas payment. How would you think about something like scomet, which have a high frequency? So this is exactly why I think roll ups are very interesting, is because they allow, they allow you to scale the compute to a much higher level. Because essentially instead of having to have consensus on all the nodes, you can reduce your validator set and increase the throughput of your chain. Also scale the chains themselves. So I have multiple chains for different purposes very easily, and then having actions that are a high frequency become much less of a problem.
01:02:44.114 - 01:02:56.974, Speaker A: Thank you again. I guess one last question here. You went over a few integrations, but I'm curious if there's any others that you think people should dive into for their roll ups.
01:02:58.434 - 01:04:13.158, Speaker B: Yes. So right now the biggest constraint, let's say, is the fact that the roll ups that you spin up don't have anything on them yet. If you spin up your roll up like you do on the documentation, then yes, you have an execution environment, but you don't have any other applications on there. What could be interesting is to help other protocols create this CW orchestrator. Integrate basically with CW orchestrator, so that the code that I was just showing you earlier where we deploy to the environment with one line of code so that's available to anyone. So that if I'm creating my own roll up and I want there to be a Dex, I want there to be a money market, I want there to be an NFT marketplace, then I should be able to just take astropor code and have one line of code provided by astroport that deploys all their smart contracts to my roll up. And suddenly I have the ability to have exchange like do swaps on my roll up, I can do all these nice things.
01:04:13.158 - 01:04:31.564, Speaker B: So if there's an action item here, I would say get into discord, go to the project that you want to be available on the roll up, and tell them if they're called Mozambase, tell them that they need to integrate with orchestrators so that you can throw their contracts onto your own roll up.
01:04:33.424 - 01:04:46.484, Speaker A: That actually leads to. I did have more questions. I had a question, what networks can I deploy to? But I guess it seems like the ones that you have supported in your docs as well as people's custom roll ups are all options there.
01:04:46.984 - 01:05:11.964, Speaker B: Yeah. So basically anything that has the Cosmos SDK GRPC format where we can upload smart contracts, where we can execute smart contracts and, like, do those transactions, all of those are supported. So yeah, any cosmos chain that supports cosmosm or rollup.
01:05:14.224 - 01:05:27.304, Speaker A: Awesome. Thank you again, Robin. I don't see any questions in the chat. I did want to highlight the docs again one more time, and if you have any last words for audience.
01:05:29.484 - 01:05:41.078, Speaker B: I hope this was interesting and it piqued your interest. Thanks for having me, Josh. And I hope to see everyone who's here in the discord. Yeah.
01:05:41.156 - 01:05:49.014, Speaker A: Awesome. I look forward to seeing what everyone builds with abstract and wishing everyone a great day or night. We'll see you in the next workshop.
01:05:49.354 - 01:05:51.010, Speaker B: Yep. Bye.
