00:00:02.320 - 00:00:31.690, Speaker A: Alrighty, we are live. Welcome back to another workshop for the infinite space Bazaar, the Celestia hackathon that's running for 45 days from April 2 to May 17. For today, we have a really exciting workshop. Actually, there's two workshops for today. The first one is today with Callum. He's going to give a workshop on Apollo. After that, a few hours after that, we have a workshop with a crime on marketing and positioning your project.
00:00:31.690 - 00:00:41.574, Speaker A: So Callum, I'm going to hand it off to you. Welcome. I'm really excited about workshop on Apollo. Maybe you can give a brief introduction and kick it off.
00:00:41.994 - 00:01:22.206, Speaker B: Sure thing. Thanks for the intro. I'll quickly start with some stuff about myself. So I work on the consensus team at Celestia. I am a software engineer at heart, so anything programming, I'm sort of all around the code base and I guess what I wanted to talk about is a very sort of like practical guide for any hackers who are out there trying to sort of build on top of Celestia. The entire team a couple of months ago did their own sort of like internal hackathon to try build stuff on it. And it was very sort of like insightful to working on how it is possible to build on celestia and what that kind of looks like, so what the landscape is.
00:01:22.206 - 00:02:02.196, Speaker B: And so I kind of want to share the insights I have to those people who are, for them celestials new, to help them sort of like get on boarded as quickly as possible and sort of avoid the pitfalls that I myself sort of went through. So this is just a short guide. I'll go sort of straight to the point here. Like, I want this to be sort of like very practical and helpful. It is an introductory to what building on solicit would look like. I'm hoping that you sort of develop an understanding for the development lifecycle. So how does it go from just local deployments with your small team? How do you sort of like, depending on which part of the modular stack you're looking to develop on, or maybe you're trying to use all the different components.
00:02:02.196 - 00:03:07.360, Speaker B: How does that sort of all come together then? How does it look like on Devnet? So solicitor has the Arabica Devnet, which you can get tokens on for the sort of test tokens for trying things out, for submitting blobs, for using the data availability layer, and then finally, what does that look like rolling out onto Mainnet? And so as a hackathon, it's good to just see like a working product doesn't have to be out on Mainnet. But I think it's just also helpful to know. So that last bullet point is Apollo, which is a little similar to foundry, but for Celestia, which is something that I've been working on to help with local development, basically trying to make sure that all that sort of like back end work about sort of like deploying nodes so we have a bunch of different ones. There's the consensus node, bridge node, light node, all that can sort of be set up and you can just focus on like the actual piece that you're innovating on what sort of assumptions I'm making. So I'm assuming that you're somewhat familiar to web3 and the concept of roll ups, this sort of like scaling solution. You know, what Celestia does. So it's a data availability layer.
00:03:07.360 - 00:03:55.204, Speaker B: It's there for basically serializing data and making sure that if you're a sequencer, you can't create a fork with two different sort of data sets and try sort of equivocate across those. So solicitor ensures that. And then last thing, I'm assuming that you're somewhat of a programmer or something adjacent. As I said beforehand, this is going to be a relatively technical conversation, hopefully not too technical, but enough to understand. Okay, how do APIs work? How do I query each of these things if I'm building some front end or if I'm using some sort of server system that scrapes from some sort of node? All right, so let me just begin by saying, you know, this modular thesis has been around for a long time, so you have modularity just in the way that we do software development. Right. There's the entire like dry principle of do not repeat yourself.
00:03:55.204 - 00:04:37.666, Speaker B: So, and it's been extremely powerful. It's like one of the reasons why software is such a prominent solution. So when we're trying to solve something, we try to go the software path. And it was maybe almost, almost a decade ago that this sort of like concept of modularity went to the infrastructure level in web two. So you had this sort of microservices era where everything was just its own server and everything was just talking to one another with GRP, sqls. And so now, so let's just try to like push this forward on the sort of web3 front. So applying the same sort of principles that have worked so well in the past to web3, we've sort of reached these like scaling bottlenecks in the past with trying to have everything on this like monolithic architecture.
00:04:37.666 - 00:05:44.400, Speaker B: So everyone, every node doing every single bit of that service, that overall service. And so now we're trying to split it up so we can have specializations. So let's just, specialization is basically this like throughput machine where it's just sort of like churning through transactions, trying to like sort of serialize them and sort of printing these like proofs, these like commitments over the sort of ordering and inclusion of that data. So modularity is great. We can sort of like all agree upon that there is an ugly side to modularity which can get extremely messy. So this is, if you're all familiar with node js, if you're trying to sort of, there's sort of a very modular styled framework as well, in which you'll have hundreds of thousands of dependencies and they can look very messy across different versions. And so this is now something that I've become familiar with or a lot more in the web3 ecosystem, which is now that we have this modularity and there's a lot of different services, how do they all fit in and how do we make sure that they all work together and then we don't sort of face this dependency hell that we've faced in other times in the software cycle.
00:05:44.400 - 00:06:13.794, Speaker B: And so I guess intro into what this looks like for Celestia. So I guess we have at that sort of bottom here, the consensus node, the bridge node, the light node. These are all sort of node types that are part of the celestia network. They all sort of talk to each other through the sensor, like p two p protocol. The consensus nodes are the ones that receive all the transactions. There's a proposal that proposes a block and they will agree upon it. And so you can see these consensus nodes is just publishing the audit set of transactions.
00:06:13.794 - 00:06:51.464, Speaker B: And then you have the bridge node, which is basically trying to bridge between the light node and full nodes and the consensus node. This is more of like just the way that the network typology is set up and hopefully something that's not around forever. And then you have the light node which is basically designed around what the user should be using. So this could be your sort of in browser user. This could be a roll up sequencer. And so that does all the sort of like work of sampling. I'm not going to go into that, but sort of very interesting about how we actually prove that the data is available.
00:06:51.464 - 00:07:35.384, Speaker B: It goes into sampling and then also querying and proofs that when you publish your data that it is there and you can go find it, retrieve it, and then execute over it. So we've got this sort of like that's the celestial part of it, but there is a ton of stuff that's already being built on it. So we have the likes of wallets, you have a faucet. If you're into development, you usually want to have some way where people can get access to these test tokens and try things out and you can iterate on. You have block explorers which provide some sort of visualization if you're doing any sort of bridging. We use IBC and so let's receive an IBC relayer. Also, if you're wanting to use a settlement like EVM, like ethereum or arbitrary or something like this, then you also need a blob stream relayer.
00:07:35.384 - 00:08:17.934, Speaker B: And then we haven't even started into like here is your app here at the top, and you might want to use some sort of shared sequencer which will batch your transactions and make it cheaper to submit it onto Celestia. You might want to use RAS or rollup as a service provider, so they kind of try to bundle all of these things together. So you just have to write your application. This is just the core business logic and you don't have to worry about what happens all underneath. And then you have execution nodes, which are the ones that are just basically taking the transactions that have been committed by Celestia and then executing on them and then submitting some sort of proof that the execution is what it is. So therefore you can run your light node as an application user and query it. So very sophisticated.
00:08:17.934 - 00:09:13.764, Speaker B: And this and a lot of these things already exist in main net production level, but if you're wanting to start with the very basics and you want to locally deploy some of this stuff, it can be very difficult to do. We're going to start with all these different things and we want to be able to promote a local first development so that you can iterate over it in a very fast fashion. You can make changes without having to start, you know, create like a new sort of new account that have funds that you need to then submit data again. So this is what led me to Apollo and so I'm now just going to jump across to my other screen to just sort of demonstrate what it's like. The rest is going to be more like a demonstration. I'm going to move away from the slides. So this is the repo here that I started for people to have a look.
00:09:13.764 - 00:09:45.422, Speaker B: It's basically, as I said, something similar to foundry. So it's a one click deploy, local and easily extendable solicitor network. Very simple instructions to get started. You just clone the repository and then you just go run. So it uses go like the rest of the software in the stack. And then what it will start is a bunch of services which are sort of out of the box and it will include this like localhost 8080. I've already done this in the background, so I've got my terminal which I won't show because it's just a very simple command.
00:09:45.422 - 00:10:11.696, Speaker B: And that's actually running this at the moment. And that will pop up this control panel which shows the services. I can just jump across here so it looks something like this. This is the basic set of services that it comes with. I will explain a little bit about how this can be extended, but you have your consensus node very similar to the diagram I showed you. That's the one that produces all the blocks. You have the bridge node and then you have the light node.
00:10:11.696 - 00:10:40.130, Speaker B: And you'll notice with each of these services they have a bunch of endpoints that you can talk to. So that's like the building block of how these services talk to one another. They each sort of publish their own services that they offer, like endpoints that they offer. And then the way that services are also described is they say what services they require. So for example, the bridge node requires access to the consensus node. So the consensus node says like hey, this is my RPC endpoint to talking to me. And that gets provided to the bridge node and this is what Apollo does.
00:10:40.130 - 00:11:33.334, Speaker B: It's a little bit like how dependency injection works where you list your different modules and what sort of things they provide and what things they require. And then the library sort of works out in which order to start all these things. So you list all these different services and I'll show you what that kind of interface looks like in a sec. And then you just hit run and then I'll run this and then I'll also present some sort of like GUi for you to interact with it. And you can also, you know, stop services or add them on. So if you're only using some minimal set, so say you're building a block explorer and it's directly on a consensus node, you don't, maybe you don't need the light node itself or the bridge nodes, you can disable those and maybe you don't need the faucet because you can get funds directly to your account in the Genesis file itself, request them at a later point. So you can just sort of start like use the services that you want to use.
00:11:33.334 - 00:12:05.104, Speaker B: I can just go through a quick demo of how this works. So we have this like light node running. If you go here, it sort of copies what sort of endpoint it is. And I can do like a request here for example for the account. So this is the account number here of this light node. So every single time you start a light node, if you haven't already got an account, it'll create you one. And so you can just do this JSON query to get it.
00:12:05.104 - 00:12:36.836, Speaker B: It will also show it in the CLI. So there's many other ways you can find the address here. Or if you want to create your own address, you can do one through a wallet and then you basically have this address that you now want to do some actions with. So you want to fund it. If I was to go to balance, for example, this probably won't show me anything. Yeah, so I got UTF. So then you go back to the address and just copy this.
00:12:36.836 - 00:13:08.644, Speaker B: And I can run across to this faucet. I have an address in there. And so this is part of here. So if you look at this faucet API, this will open it here. So this is another service, very simple service where you just sort of submit your address, ask to request funds and then it should send it and show you sort of the hash and everything. So then you can go back here, you can go send a request to your balance. All right.
00:13:08.644 - 00:13:49.234, Speaker B: And now you have a bunch of UTR. So this is just like a simple demonstration of like how you would sort of sit funds in your account. And now if you actually go to the solicitor node API, you can do stuff like submitting blobs. So if you have a look at the submit API, it looks a little bit like this. So I could copy this across, put it in here and then submit that. And that will have like the namespace you're submitting to what the data is, shared version commitments and so forth. I'm not too sure if this is valid data, so I don't know if I want to risk actually like submitting it and getting it wrong.
00:13:49.234 - 00:14:30.222, Speaker B: Of course this is just using postman. If you're actually building your application, you'll be using some sort of like client interfaces and just talks directly with your node, the light node, and behind that it'll be doing all the stuff like verifying. Cool. All right, so that's kind of like Apollo. I just want to show briefly about how you can sort of extend that. So maybe you want to build something else. It doesn't have to be a roll up, maybe you wanting to build a shared sequencer that talks to it or you want to build some like service, some visualizing service could be quite cool where you're sort of like every namespace, you're sort of showing what sort of action and activity is going on in that namespace.
00:14:30.222 - 00:15:16.066, Speaker B: So you're trying to like scrape all the data for the namespaces that people are interested in. So the way you would set that up is there's this service interface that you need to follow and it's just here. And so every single one of these services, the consensus node, the bridge node, light node, follows this interface and hopefully looks pretty intuitive. So you have, the name has to be sort of unique. So when the, when Apollo is starting, it gives every single service its own directory and just has permission to sort of create files and whatnot in that directory. And so if there is two services of the same name, you'll get some sort of like a conflict. The other ones are like the endpoints it needs and the endpoints it provides.
00:15:16.066 - 00:15:46.830, Speaker B: So in the case of the consensus node, it provides this common RPC endpoint. And that's like a label that then you can use if you require that. So these are just sort of like static stuff. And then when you're going through the setup, there's basically these three different steps. And the reason why it's not just a simple start is because you actually have the ability to modify genesis. So before we even get started with the, the testnet, you might want to make some changes to the genesis. Most likely one is like adding your own account.
00:15:46.830 - 00:16:17.726, Speaker B: And I can also show you how that looks. There's a few like helper functions with this, but the way it works is you get a pending genesis. So if you wanted to, you could start up a network where instead of block time being 12 seconds as it is on Mainnet, you want to have it every 1 second. So that would be a consensus parameter in the Genesis doc. So you can just change that. You can do also a few other customizations like we're sort of building v two at the moment. And so you could also start running on v two instead of starting on v one and see what that looks like.
00:16:17.726 - 00:16:51.484, Speaker B: And maybe you want to use some of the new APIs. So that's all done capuleted in this Genesis file. Then once all the services have run setup, so they've returned these genesis modifiers is what they're called. Then the init is called, which then provides the actual genesis. So this is the one that will not change it is finalized and it is the one that it can be used, for example, to start the consensus node because that's the first block that gets executed. Then once everyone has initialized, the final call is like start. And start has done.
00:16:51.484 - 00:17:22.628, Speaker B: The conductor will work in order about, okay, what inputs are needed. It'll make sure that every input is available and can be provided. So basically it just works on the ordering with which these services are created. And then this return is the endpoints that it provides. So similar to this, endpoints needed endpoints provided, very self explanatory. And then the last thing is you can stop services individually or you can shut down the entire thing and that's just done there. And as I said, it will create an Apollo directory.
00:17:22.628 - 00:17:49.870, Speaker B: So it's just under Apollo in the home directory. So if you want to reset everything, you just delete that directory and restart. Else every single time you start, it'll go from that existing directory. So that kind of explains this. So if you wanted to create a new service like a shared sequencer, you would say, hey, I need the endpoint of a light node. So you would add that there and that would be provided to you on start. And then you might want to initialize some sort of like directory.
00:17:49.870 - 00:18:34.884, Speaker B: Maybe you saved some of the transactions before as they're pending, or you have some sort of account data and so you just implement this. And then if we go back to here, I think it's under, there's just a very simple run function which does this for you. So you would just add all the services and it would run. And as I said, this sort of like standard is to run these like four services. I would like to add more. I'd be very interested in adding perhaps a block explorer to help visualize like a report accounts have what sort of funds, but for the moment it's just this simple function which just runs it. And you can see here, here are the four default services.
00:18:34.884 - 00:19:18.292, Speaker B: Cool. So I'm going to move on a little bit and we can come back if we have any questions on Apollo. Happy to discuss that a little bit more. I want to now zoom out a little bit and discuss the flow. So you've got this way with which you and your team can build sort of quickly spin up a test network locally, run your code and sort of iterate on it. The next stage once you finish doing it locally would be to, would be to spin it up on a divnet. So solicitor provides this Arabica divnet which we run nodes for.
00:19:18.292 - 00:19:30.044, Speaker B: So it's easy for you to sort of use the same endpoints. So the same way that the consensus node provides the RPC endpoints or the light node provides its API, you can do the same for.
00:19:41.704 - 00:20:45.924, Speaker A: Hey, I'm going to find out what happened. I'm going to message callum. In the meantime, I hope you guys are enjoying the workshop so far. Let me try to get Callum back on stage. All right, I messaged Callum. In the meantime, if you guys are in the YouTube chat, do you guys have any kind of questions so far? Maybe not necessarily about the Apollo, because I can't answer it yet, but maybe about the hackathon itself. Consider it an impromptu office hour while we wait for column to come back.
00:20:45.924 - 00:22:05.144, Speaker A: All right, how about this? Maybe you guys can share in your chat. What house are you with? All right, we got mind flux. Rock is with mind flux. Who will participate to the office hours? So I'll be moderating. The office hours will be tomorrow around, um, 11:00 a.m.. EDT. Um.
00:22:05.144 - 00:22:24.024, Speaker A: Damn, we got a lot, a lot of mind flux reps here. We got DDA. I think it is because you didn't start the stream with fireworks. Um, that's fair. Um, I can try to see if I can trigger the fireworks. Maybe that will bring back column. So if I remember correctly, the fireworks are.
00:22:24.024 - 00:23:00.074, Speaker A: Yeah, the office hours will be on the discord. So if you guys are not in the discord, I recommend joining. The best way to join the discord is by signing up for the hackathon on the type form. At the end of the type form, you have a link to your discord, to the discord, which will get you in. All right, so now we got a bunch of lumen, please. Oh, hey, Callum. I was just keeping the crowd entertained until you came back.
00:23:00.574 - 00:23:01.582, Speaker B: Thank you.
00:23:01.758 - 00:23:05.154, Speaker A: All right, I'll let you. I'll hand it off back to you.
00:23:06.694 - 00:23:43.044, Speaker B: Yeah, one sec. I just want to set up my. What I was presenting and then continue. All right, yeah, so sorry. Apologies for that back. Now. I just wanted to share what the rest of the sort of workflow looks like.
00:23:43.044 - 00:24:26.404, Speaker B: I'm just on the celestial docs page now. So, as I said, you want to start with your local deployment, and then once you're more refined on that, it's now time to launch on an actual devnet where you can get more users using it. We run a bunch of nodes that will allow you to connect in the same way as you have these RPC endpoints for the consensus nodes. You can also use the same ones for Arabica. So your service will just be able to glide across from that like local deployments to now running on these endpoints. So instead of using, running your own nodes, you can actually just use Arabic. So there's that, there's also the light nodes and bridge.
00:24:26.404 - 00:25:03.176, Speaker B: Most likely you'll want to be running your own light node if you want to verify things or some sort of other subset of services. And then the last thing was similar to the faucet where you need to fund your account. The way that's done for us is with Arabica is through discord. So you'll need to join Discord and as it says in the instructions here, just requested veteran solicitor address. And then once that started you can begin to use Arabica. And we use Arabica as sort of also, what's the kind of like latest stuff. So if there's any sort of new features that Celestia is running, you'll also be able to use that.
00:25:03.176 - 00:25:37.718, Speaker B: So it's kind of like a nightly version. And then we have this mocker testnet, which is more following Mainnet with validators and as opposed to when we do an upgrade to practice what upgrades are looking like. So when you sort of stop and do the next version. And so once you're of course done with Arabica, then it's also much the same, so very similar to then move across to actual mainnet and deploy your service. Whatever it might be. It might not necessarily be a roll up. You could be doing some sort of like, as I said, shared sequencing or some sort of execution layer.
00:25:37.718 - 00:25:57.194, Speaker B: You could try to harass yourself or build some wallet. Very eager to see what sort of people sort of come up with, but that sort of covers the flow. So maybe I'll like pass back to Yaz and let's see if you've got any questions from people that I can answer, and if not.
00:25:59.484 - 00:26:09.944, Speaker A: And I think there's a bunch of questions, I'll hit it off. One is glib, asks what's the difference between setup and init?
00:26:11.484 - 00:27:07.684, Speaker B: That's a good question. So when I first started, I was hoping to like just have a single initialize which would set up the directory. And the reason why I needed this like two stage thing is you sort of need, you kind of need the genesis to know what you want, like a pending sort of genesis to know what, what the actual genesis will be like. So for example, you might want to know what the current consensus params are or something like this in your network. So it kind of needs to be a two steps situation where you provide any modifiers to Genesis you want. So if you want to like add your own account or you want to like stake or do some sort of like set up some IBC connection and then a separate one, which is once it's done for all the services and we have all the ways that they want to modify Genesis so all the things they want want to do, what is the actual genesis? And so then they can use that because that now is now finalized. I hope that answers your question.
00:27:08.744 - 00:27:25.824, Speaker A: Yeah. Let's see if glib has any follow up. But in the meantime, I'll throw some questions at you. So the first question is, what are some of the extension you'd like to see added to Apollo during the hackathon? Like you?
00:27:26.684 - 00:28:06.524, Speaker B: Yeah, so I guess I covered some examples already. Like, it would be cool to see some shared sequencer designs on there. So that's just this, that can be like a very good startup for someone who's unfamiliar. It's a very like simple service. And this fact that it basically takes transactions from users, so it has this like they can submit it through like RPC in the same way, and it kind of bundles them all together as a single batch and then submits them on Celestia. And the reason why that's sort of like valuable is, or like why these sort of sequences exist is there's actually like a sort of fixed cost for every single time you submit data. So it actually is cheaper if you can bundle it together.
00:28:06.524 - 00:28:57.860, Speaker B: And it often like means that the actual, we can have this like separation in the infrastructure where you have just execution nodes who don't have to worry about actually how they get the data gets submitted. They just have to read off Celestia. So that's one idea generally, like something I'm a big fan of is just games. I think there's been an explosion of game developments on Celestia and just generally in the wider web3 ecosystem. So it'd be cool to see people just use games for that. One of the internal hackathon projects that someone did was this Tamagotchi style thing where it sort of read the data on namespaces and created these cool visualizations of what they look like. So if you're, I think they use some sort of like dog maybe as the image.
00:28:57.860 - 00:29:27.746, Speaker B: So if there was a lot of like activity on your namespace, you had a very healthy looking dog, and if it didn't, you, you know, you weren't submitting blobs, you weren't feeding your dog, then it probably eventually died. But it didn't look good. So any of these like cool visualization tools I think is really helpful. I think that's one of the like barriers for like any, for a lot of people from going from web two to web3 is just like, how do I visualize what this looks like? So, you know, how do I see like there's a whole bunch of ones and zeros running in the background, all these computers talking to each other. But what's really important is like how to.
00:29:27.770 - 00:30:12.674, Speaker A: Another one question is why is Callum so handsome? From the audience, it sounds like the. Why indeed? Right? It sounds like the project that you were talking about was like a Tamagotchi, or as one of the nina from the audience saying a tiago, she like, the more that namespace has activity, the more that thing will grow and stuff like a pat. That's really taken care of. Yeah. I'd be curious to see if there's like an open source repo we can share with the hacker if it's open source.
00:30:13.334 - 00:30:50.692, Speaker B: Yeah, I think there's a lot of cool ideas about how you sort of visualize this. For example, there's a lot of visualizations around this being this bizarre, right, where there's all these people coming in and sort of sending their data and we have this like global namespace, global sort of environment where people submit things. So everything sort of like comes to solicitor. And so it'd be cool to kind of somewhat visualize this, visualize this kind of process that's happening where like, sorry, you're submitting your blobs to your namespace, but there are other people submitting their blobs to namespace. And you might use these other services. Like some of the ideas I think could be very interesting are these kind of like service based roll ups. So they don't actually have this like use case for themselves, other than supporting other roll ups.
00:30:50.692 - 00:31:22.360, Speaker B: And a good example of this could be something like DRAM where you have like this VRF function. So a verifiable random function that just get submitted every single block height, and then gamers can use that, or like other applications can use that sort of random seed to then run their applications. Or there could be some other service chains. Maybe you're creating some oracle where you just keep sort of like submitting price feeds. And so rather than being it for one specific change, you're running this oracle for just for this one roll up. Now any roll up can use that oracle data. So it sort of very much shows how this scales.
00:31:22.360 - 00:31:36.794, Speaker B: There's a lot of similarities with this, with IBC as well. Like instead of everyone having to post everyone's headers to everyone, you just kind of post your own header and everyone can read off everyone else's namespace. There's a bunch of really cool features from the fact that we're all sort of sharing this global environment, so to speak.
00:31:38.134 - 00:32:04.554, Speaker A: Well, I mean, I think I speak for everyone in the audience. There's a wealth of different kind of ideas people can get started with on Apollo. I'll get some moments for people to ask any more questions. In the meantime, I'll throw another one at you. So the network that we saw in Apollo, is it a local devnet that is simulated or is it one of mocha or arabica to public test set?
00:32:05.374 - 00:32:44.388, Speaker B: It's all local. So it's basically you're running each of the nodes. It's not 100 node network, of course, it's just one node of each of these types, which is just the basics. And the reason why we actually run these nodes is it actually is the network itself. So you don't get this kind of mock of what I should be dealing with, but how the network actually works. And it also means like for example, I think we're focused very much on roll ups, but perhaps you want to provide some improvements to the actual protocol itself. And so it could be having this like modified consensus node that does something a little bit differently.
00:32:44.388 - 00:32:46.184, Speaker B: You can sort of do that as well.
00:32:47.204 - 00:33:15.524, Speaker A: That's fascinating because it sounds to me like Apollo is like a foundry. I don't know if you're familiar with foundry, but foundry for roll ups, but at the same time allowed you to have your, I believe their, I think it was called Ambil, the testnet that they had in foundry, which allowed you to have a local Ethereum testnet, but like a local Devnet. And it sounds like Apollo is filling in that gap for the modular ecosystem. Would that be a fair assessment?
00:33:16.064 - 00:33:46.244, Speaker B: Yeah. Yeah. Like I'm a big fan of just like local first development, and that's kind of like the large point of that. Like I don't want to have to spend all this time trying to work out, especially if like I'm familiar with select. If you're not familiar with the ins and outs about how to start up all these nodes, it can be a bit complicated. I just think that gives you all the customization you can want. And then when you're ready to push onto the next stage, you can move away from Apollo and it's all the same stuff.
00:33:46.244 - 00:33:52.144, Speaker B: It looks exactly the same, but now it's actually on a Devnet and then it looks exactly the same, but now it's FCO on Mainnet.
00:33:53.464 - 00:34:31.084, Speaker A: Yeah, I mean, that was one of my first impression going into the celestial modular ecosystem. I remember one of the diagrams you showed about a chart starting with the user, but all the different kind of components. That was kind of my reaction. It's modular, it's great for scalability, but it can be kind of overwhelming. And Apollo can fit the need for people where it allows you to get started as a developer, where a lot of that stuff is already done for you, and you can just focus on building your application using like, a local celestia developer environment.
00:34:31.824 - 00:35:11.976, Speaker B: Yeah, that's exactly that. And it'd be cool to see, like, you know, you can build your environment that has a whole bunch of different services, not from the, like, Apollo Repo, but other things. Like, as I said, it'd be nice to have some sort of like, block explorer. I was looking at selenium, so they already do one for, like, the Celestia mainnet and I think for mocker as well. So it'd be nice if you could kind of take and their codes will open source, so it'd be quite easy just to kind of integrate that into Apollo. So now when you start up your network, not only do you have like a faucet and all the sort of endpoints you need, but you also have some sort of block explorer where you can see, okay, there's the data being published in my namespace. This is what it looks like.
00:35:11.976 - 00:35:15.284, Speaker B: This is how much money I have, sort of funds I have in my account.
00:35:16.044 - 00:35:55.324, Speaker A: Got it? Yeah, I would love to see that as well. Selenium is one of my favorite explorers out there, and seeing it integrate into Apollo, I think will be like a great kind of hackathon project. I'll wait. If anyone else has any question from the audience, you guys, don't be shy, ask the question. Right, Callum, maybe one question about the future of Apollo in terms of maintenance and stuff, or, like, you know, what is in store, at least from what you're building, other than the extension, do you want to see hackers building? How do you see it going long term?
00:35:57.304 - 00:36:42.584, Speaker B: Yeah, like, I love it to be sort of this, like, default, as you said, somewhat a foundry way of just kind of like initializing your sort of solution network and whatever application you're building on top of it. It's all open source. So welcome for contributions about how it can be improved. I'm sure there's a bunch of little ways that it can be improved. Yeah. But it would just, I think it's something that's needed to really, like, make that sort of cycle of development far quicker than what it currently is, at least how I've experienced it. So I think as long as there's a bunch of other people finding value in it, it can be a really good, sort of, like, community based, open source project out there for everyone to use.
00:36:43.284 - 00:36:57.664, Speaker A: Awesome. I guess one stupid question. Oh, we have not, you know, we have a question from the audience, and I'm not implying the audience's question is stupid. That would one of mine. Why the name.
00:37:01.054 - 00:37:39.054, Speaker B: Honestly did not like, okay, so my, the way I name things is I don't really give much thought to them, but I don't want to sound like an engineer's name, which is to call something like it's, I don't mind the whole, like, lib, p two p, call something exactly practically what it is, but I've usually in the past, just avoid it. So I usually just give it a name. And so Apollo is because, so let's say we create this, like, idea in our head of like, of space, essentially. And so Apollo was one of the first kind of rockets that would head out to space, and it was very much the start of that journey. Right. So it was very much in the local deployment stage. And so that's the kind of relation there.
00:37:39.714 - 00:38:17.364, Speaker A: I love that the Apollo program used the famous Saturn V rocket. That was a big rocket just to go land on the moon and beyond. That's a suitable name for people to get started in their space exploration journey in Celestia. Okay, like one random question. Let's say I have a crazy idea about, I want to add a new consensus mechanism for Celestia. Would I be able to use Apollo to test it out and stuff, or would that be not the best starting point?
00:38:19.684 - 00:39:07.034, Speaker B: If, for example, you wanted to write your own, like memple, I would probably recommend just forking the Celestia app repo there and making your modifications. And then that also includes a bunch of stuff for running nodes. So that's probably more app for this. I think this is, there are some, like, sort of services, third party services that this, you know, would work well with. But I think if you go into the core protocol, so what actual, the solution network is far better to sort of look at how the current repos do it, kind of fork them, play around with them. There's also, like, a lot of tools there for deploying nodes in a small cluster and then push it upstream, share it to the masses.
00:39:09.334 - 00:39:14.794, Speaker A: One question is how to follow Callum on Twitter. You want to take that one?
00:39:17.514 - 00:39:37.754, Speaker B: I don't exist. Yep. Yeah. I do not have any social media. The best thing, I guess, is GitHub, if you want. But unfortunately, I'm more of a just engineer.
00:39:37.874 - 00:39:40.990, Speaker A: He needs to focus. We can't distract him with Twitter.
00:39:41.162 - 00:39:45.874, Speaker B: Yeah, I've decided Twitter is probably a net negative. That's just my conclusion.
00:39:46.654 - 00:39:56.634, Speaker A: But, like, let's say hacker wants to ask you questions on Apollo. Maybe. You know, the best place for that would be the discord.
00:39:56.934 - 00:40:18.644, Speaker B: Yeah, for sure. Yeah. So discord for any questions on developing anything on select, whether it's with Apollo or not. Yeah. And then also feel free to open issues or pull requests that repo is all public. And yes, I do have a GitHub they made me.
00:40:20.464 - 00:40:53.824, Speaker A: Yeah, let me just try to. I'm trying to find the link to your GitHub. Oh, here it is. So, folks, if you want to check out a polo, I'm sharing the GitHub repo on the YouTube channel. Check it out, play around with it, open issues, create features, hack, you know. And with that said, I think we're at time for today. There's no more questions.
00:40:53.824 - 00:41:03.224, Speaker A: So I want to give a shout out to Callum. This is the first time you're actually giving an overview of Apollo. You only shared it like, a few weeks ago, right?
00:41:03.604 - 00:41:05.100, Speaker B: Yeah, yeah.
00:41:05.292 - 00:41:19.812, Speaker A: Awesome. Well, thank you, Callum, for giving an amazing workshop on Apollo. I was really excited about it, see it in action, and I'm sure a lot of people are going to start playing around with it and hack with it. So, yeah, thank you so much for the workshop. It's been really insightful.
00:41:19.988 - 00:41:29.094, Speaker B: Yeah. If anything, I just want to contribute to that, like, hacking mentality, that hacking vibe. And so I'm hoping this can help with that. If anything, it'll help me. It'll help me with my hacking projects.
00:41:30.594 - 00:41:55.146, Speaker A: Amazing. I'm sure it'll help a lot of people with their hacking project. So, folks, thank you again. Reminder, we have another workshop by accrum on marketing and positioning your project in an hour and 20 minutes ish. Be sure to check that one out. It's a non technical workshop, but it's really, really helpful for how do you market and present your project. But for now, thank you, Callum, for taking the time and take care, everyone.
00:41:55.146 - 00:41:56.174, Speaker A: Have a good day.
00:41:56.474 - 00:41:58.834, Speaker B: No worries. See ya. Bye.
