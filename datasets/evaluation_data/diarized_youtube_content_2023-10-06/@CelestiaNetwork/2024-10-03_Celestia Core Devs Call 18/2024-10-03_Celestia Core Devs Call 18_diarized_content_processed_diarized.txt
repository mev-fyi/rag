00:00:00.120 - 00:00:48.065, Speaker A: Celestia Core devs call 18. My name is Josh and I'll be hosting today. Quick overview of what we're going to talk about and we'll get right into it. We'll do working group updates, updates on cips and then some discussions around upgrade timelines, general CIP process and a forum post that the Eiger team has put up first with working groups updates. I think both Wonder Tan and Renee are here. I don't know who's best to speak on that, but I know that the Schwap update is something that is going live. So I just wanted to get a brief update from y'all on what that looks like.
00:00:50.005 - 00:00:52.297, Speaker B: Hello? Hey, can you hear me?
00:00:52.421 - 00:00:53.281, Speaker A: Yep.
00:00:53.473 - 00:01:00.121, Speaker B: Cool. Yeah, Swap is on Mocha Replica and soon on Mainet.
00:01:00.313 - 00:01:01.073, Speaker C: Nice.
00:01:01.249 - 00:01:12.417, Speaker B: There will be a bunch of little fixes coming soon like the one you mentioned with logs and duplications now that I mentioned. But yeah, things will be so far.
00:01:12.601 - 00:01:43.145, Speaker A: So I think pretty cool. Yeah. And it seems like all of the like resource reductions are very worth it. So it's exciting to see. Yeah, I know that something we talked about in the Slack was moving the current swap call into the DIA working group call. I don't know, we need to discuss more than that, but if there's any context I'm missing that you have, that'd be great.
00:01:43.725 - 00:01:51.105, Speaker B: Not yet. It's just something that is on my to do list and I get to it this week hopefully.
00:01:51.525 - 00:02:02.845, Speaker A: Yeah, no worries. I don't have any updates from the Interface working group or ZK working group. If that's changed since I spoke to the working group chairs, please speak up now. But I'm going to go ahead and move on.
00:02:02.885 - 00:03:06.145, Speaker D: If not one thing that I can say is you can hear me that we are currently in the ZK working group figuring out how to have compatibility. Like there are a bunch of things that we're figuring out. One is compatibility with the Merkle tree for data inclusion proofs, figuring out how to do upgrades, prototyping the ZK accounts on both the celestial side but also rollkit side and also. Yeah, I think that's it. Oh, figuring out what the public inputs will be. These are just minor updates that I wanted to share.
00:03:06.735 - 00:03:44.463, Speaker A: Thank you. I'll get those added in the notes after this. So I guess the next biggest thing to discuss is the V3 upgrade, aka the Ginger network upgrade. I think that two out of so half of the CIP. This is a Meta CIP and it includes CIPs 21, 24 one that's not numbered yet. To reduce block time to six seconds, I need to edit this. And we also have one that does two things at once.
00:03:44.463 - 00:04:33.925, Speaker A: It reduces the or, it sets a cap on the number of pfbs and non pfbs per block and it also. I need to edit this. It sets the transaction size limit to be 2 megabytes. I think we don't need to discuss much on 21 and 24, but I noticed they are in last call with a deadline of last week. So I think it'd be good to talk about moving these to final if they're ready. So column and Nina, starting with Callum I guess, is everything good to go to move CIP 21 to final? Yep, yep. Nice.
00:04:33.925 - 00:05:02.695, Speaker A: And for context, this introduces a blob type with a verified signer. And then for 24, Nina, I just want to confirm that this is also good to move to final. It had the same last call deadline of last week. Yep, all good. Nice. Cool. So with that said, the next two are work in progress.
00:05:02.695 - 00:05:07.975, Speaker A: I guess there's not really much to show here on this page.
00:05:10.635 - 00:05:12.855, Speaker C: We could just do like a summary of like what?
00:05:13.355 - 00:05:55.975, Speaker A: Yeah, so the CIP moves the block time. It reduces the block time to six seconds. This is something that is done with by setting timeout commit and timeout proposed to their respective values listed here. But yeah, the general summary is that this cuts block time in half. There's also a secondary motive or secondary I guess like change here that increases the TTL numb blocks parameter so that the mempool is consistent with the new block time. So yeah, this is open for review and comment. And then once we get that in draft we'll add it to the meta cip.
00:05:56.875 - 00:06:35.235, Speaker C: I think furthermore to the just sort of changing the block time from 12 seconds down to 6 seconds is that the actual like mechanism that that's done changes. So normally you have this like timeout commit timeout proposed which are like local configurations that node operators can set. And so part of this is we're now changing that to be part of the like to be a global parameter set by the application. So application communicates or sets what those timeouts are. They can't be sort of like configured. And then part of so this means that we can, when we do that upgrade, we can all go down from 12 seconds to 6 seconds together. So it doesn't actually take validators modifying those values, it just happens for them.
00:06:35.235 - 00:06:43.635, Speaker C: And so that's part of it was changing the mechanism and then the other part is now implementing with that new mechanism the change from 12 seconds to six.
00:06:45.295 - 00:07:09.155, Speaker A: Thank you for the extra context and for your understanding. Is it's better than mine, I guess. Is there anything that. This is going to be a draft? So once it's there it's definitely open for edits. But I'm curious if there's anyone that has questions about that or want some more clarification from the core app team.
00:07:12.505 - 00:07:22.565, Speaker E: I think the only things that we need to add to it are the data we collected from the experiments for both core and node.
00:07:33.025 - 00:08:22.905, Speaker A: Sweet. I just added that as a comment. Unless there's anyone else that has anything on that, we can move to talking about increasing the essentially increasing the compute limit or setting a compute limit by limiting the number of PFPs and non PFPs and also setting the transaction size limit to 2 megabytes. Yeah, essentially this sets. I mean the abstract is probably a good description. It limits the number of PFBs to 600 per block and 200 non PFB transactions per block. And then this also sets the transaction size limit to 2 megabytes.
00:08:22.905 - 00:08:39.735, Speaker A: And that is ahead of us preparing to eventually increase the limit on block size to avoid block times being too long because for example, an eight megabyte transaction gets gossiped.
00:08:41.035 - 00:09:22.955, Speaker E: So there's two different. I was initially assuming that these would be separate because the goals here are very separate. So the limiting compute is to reduce the amount of time where we block during consensus, where we are effectively checking these transactions. And then the second one for two megabyte is actually for a potential upgrade to fast block slow squares. So it's being defensive. So it is true that a larger transaction or piece of data takes longer to gossip or propagate through a network. If it's larger and you can't chunk it and check each chunk and propagate it that way it sort of like stream it throughout a network.
00:09:22.955 - 00:10:06.571, Speaker E: So that is true. However, that's not like a huge problem when submitting through a mempool, especially with our existing block propagation mechanism. The thing that we're concerned about here the most is that once you increase this value from 2 megabyte to 8 megabyte, you can't go back. So it's like breaking for rollups if you go from 2 to 8 megabyte. And what we want to prevent is that we want to leave the design space open for fast block slow squares. So it's possible that instead of actually increasing the square size beyond 8 megabytes or something, we would actually just continue to decrease block time as much as possible. That's Like a potential path and we just want to leave that open.
00:10:06.571 - 00:10:22.095, Speaker E: So that's the reasoning for adding this consensus breaking change from. Well, it's not consensus breaking yet. It will be consensus breaking when the block size gets larger than two megabytes. Of course. Just to add some color there.
00:10:22.255 - 00:10:25.247, Speaker A: No, that's good. JOHN RAISES HAND yeah, if I could.
00:10:25.271 - 00:10:58.455, Speaker F: Add a bit more color. It's not even that we want to leave the design space open for keeping the block size at 8 megabytes after having increased it, but potentially we want to leave the space open for decreasing the block size but also decreasing the block time such that the total throughput is increased but the block size is smaller. But if the max transaction size is. Or max blob size, I guess the total blob size is 8 megabytes, then you can't do that because it would break any roll ups that depend on 8 megabyte atomic blobs.
00:11:00.595 - 00:11:10.735, Speaker A: Thank you both. On that note, I'm wondering if you would both if you all would advise that we split this up into two cips.
00:11:12.105 - 00:11:18.125, Speaker C: I think the reason why I said they should be the same one is they're both about constraining the system such that it performs correctly.
00:11:18.545 - 00:11:22.417, Speaker A: Okay. Yeah, I guess. Unless perhaps.
00:11:22.481 - 00:11:31.005, Speaker F: Yeah, it's basically like you wouldn't. There wouldn't be a situation where you would want to implement one without the other. This particular motivation.
00:11:33.025 - 00:12:17.173, Speaker A: Makes sense. Cool. Unless Evan has anything there, I think we can leave this open for review and get that in a draft sometime soon. I started here. Okay. So like noticing that Some of these CIPs are still a work in progress. The upgrade timeline that we went over last two weeks ago has definitely changed for V3.
00:12:17.173 - 00:12:32.835, Speaker A: So I just wanted to understand from the core engineers what the timeline looks like now. I think we're planning on like another week or so before it goes on to Arabica.
00:12:34.255 - 00:13:37.435, Speaker E: Yeah, we are currently still trying to get out on Arabica this week. So the week of the 14th at the moment we just merged the less PR and app. So we're going to cut the release candidate after this call for v3.0.0 and then celestial node has one PR to finish reviewing after we bump that PR with this release candidate instead of a commit or it was using like an alpha tag or something, we'll use this release candidate tag and then we need to test on Robusta and then the rest is just like normal release process stuff. And we're hoping to at least get the validators upgraded ideally tomorrow or Friday. I know we normally don't want to get the validators upgraded on Friday, but we do have a rather strict deadline here as we don't want to delay further. So we might have to do that for Arabica.
00:13:37.935 - 00:13:42.743, Speaker A: Cool. To clarify though, that wouldn't be like the Mocha validators that are upgrading, it's.
00:13:42.759 - 00:14:03.827, Speaker E: Just no, no, no, no validators. So this is just on Arabica. So there's four different validators that the DevOps team has keys for, I believe and are running. So that should be a rather simple process. And then we also have to submit signal transactions for each of those validators. And then there's a week delay. So.
00:14:03.827 - 00:14:16.855, Speaker E: Well, roughly a week. Roughly a week delay before the upgrade actually takes place. So the app version will still be on V2 for until next week minimum.
00:14:19.235 - 00:14:35.643, Speaker A: Other than that, I think the timeline for moca and mainnet are roughly the same of beginning of November, around the fourth and beginning of December. Is that correct? Assuming everything.
00:14:35.739 - 00:14:47.445, Speaker E: Yeah. MOCA is week of November 4th is when the actual binary switch. But then we still have to do the signaling and it still takes a week.
00:14:47.605 - 00:14:47.981, Speaker A: Yep.
00:14:48.013 - 00:15:23.995, Speaker E: So then the actual time when code changes are meaningfully changes is the 11th week of the 11th and then week of the 28th we are cutting the other release or cutting the official releases, assuming whatever needs to be fixed has already been fixed from Mocha and Arabica. And then the week of December 2nd is the actual upgrade for V2 V2 to V3 on mainnet.
00:15:24.935 - 00:16:08.915, Speaker A: Awesome. Thank you. The. I think we kind of already answered this going through. We didn't actually look at it exactly, but in this CIP to add number of transaction limits and transaction size limits, one of the changes is not consensus breaking but it does have a meaningful impact on users like rollup developers. So that's why it's being included in the cip. And then the second change is consensus breaking.
00:16:08.915 - 00:16:46.325, Speaker A: So what I wanted to bring up here was a conversation from just from Slack where we were talking about what needs a cip and I think Alum has a pretty good handle on this and that's why I wrote this one the way it did. Basically, if there's a significant impact on users, even if it's not consensus breaking, do we agree that it should require a CIP or do we think that only consensus breaking things need cips?
00:16:56.475 - 00:17:04.015, Speaker F: I don't, I don't think that CIP should be reserved just for things that are data to consensus, specifically things that break consensus.
00:17:04.355 - 00:17:07.179, Speaker E: Not just consensus, but also network breaking.
00:17:07.267 - 00:17:07.795, Speaker G: That was.
00:17:07.875 - 00:17:46.985, Speaker E: That was what I think were like strict requirements for CIPs. But Colm pointed out that it's a bit too strict and there are other things that impact users. Unfortunately there is no like firm concrete thing on impact users. It's sort of like a judgment based on how big of an impact it has. So for example, if there's an API change to like the RPC that would. That might require like a CIP but like a change to the CLI or something probably doesn't. If it's like small and not that many people use it.
00:17:48.665 - 00:18:10.525, Speaker C: There is, it does introduce a bit of a gray area. But I think the whole point about the like cips was to have this like a community engagement and like that involves things that aren't just like consensus breaking. So yes, like a lot of API things which really do affect the way that like people will use Celestia is something that we should be open to like having these proposals, having these discussions and being able to like change.
00:18:13.195 - 00:18:29.895, Speaker A: I think on that note we need to play that by ear and figure it out as we go. But I'll keep a mental note to maybe edit this on the template so that it's more clear.
00:18:31.635 - 00:19:21.165, Speaker E: Another suggestion we do have like the Interfaces working group. So but I think this one was particularly pointed at the change that limited the number of PFPs in each blob. Where this is not an API change, this is not a consensus breaking change, but it is a new default that can have a meaningful impact because now it's effectively like a fee market change by default. Almost like a very crude way to change the fee market in that the fees for something like a message send could be different from the fees required to get included for something like a PFB. Well only a PFB. Those are the only two differences is PFPs and non PFPs. But that's like a.
00:19:21.165 - 00:19:31.165, Speaker E: Crosses some threshold that again, like Colin said, it's kind of a gray area but it's definitely like worthwhile to do.
00:19:38.915 - 00:19:58.535, Speaker A: Mac from the Eiger team put up a forum post recently that I wanted to get some eyes on. Even though it's not a formal CIP yet. Yeah, I wonder if actually I realized Mackie didn't actually write this.
00:20:02.365 - 00:21:04.055, Speaker G: Yeah, it wasn't me, sorry who was working on this change like on making Lumina and Celestia crates compatible and I don't have the insight he has on it. But in general some of the version cons are used in some validation or verification methods. In example on extended data square there is like upper size limit or lower size limit. It's a version const. So we not only provide a node but also libraries like just general types library which has those types and validate on those or the rpc. If this version is detached from the struct itself, it's hard to operate in some regards. In example, all the validate methods would now require the corresponding extended header.
00:21:04.055 - 00:22:02.465, Speaker G: So someone fetches eds if he wants to validate it, he needs to provide also the extended header because otherwise he doesn't know which is the correct upper or lower value of the square. Also it's used for calculating blob commitment. So even if two blobs are equal, their commitment may differ because of the app version. And also I saw that the share v1 which will have this signer field, it's also like verified on Celestial Node site regarding to the app version. And it's mostly fine because on most of the RPC calls you require extended header to be provided to fetch shares. But not everything requires it. In example, GetRange just takes a height.
00:22:02.465 - 00:22:26.175, Speaker G: Yeah, so just we are not sure how to properly nail it in like library context. It's quite easy on the node because in node you can just have a static pool of cons that you refer to. But if it's a library which is like can be anything, then.
00:22:29.275 - 00:22:30.211, Speaker A: Thank you.
00:22:30.403 - 00:22:35.323, Speaker G: I'm not sure I can invite Yanis for the next call if you prefer.
00:22:35.459 - 00:22:59.225, Speaker A: Yeah, my bet on that. You were the last one who had commented on it, but I'm curious if anyone here has a stronger opinion. I feel like this is a good conversation to be had in the Interface working group or even the DA working group. I'm not really sure which one's best for that, but I think we should get ahead of this before it starts to cause any problems.
00:22:59.385 - 00:23:10.965, Speaker G: Yeah, right now it's not an issue because all those cons that are mentioned, they are the same in all versions so far, but it can cause some issues in the future.
00:23:14.975 - 00:23:40.073, Speaker B: Mark. So on the first point, from my understanding, you anyway need an extended header to request a blob so that you can verify the inclusion of the blob and I'm not entirely sure why is that a problem then? To get the extended header, you might.
00:23:40.089 - 00:23:54.965, Speaker C: Want to submit a blob and that requires knowing what the commitment is like. Say you just. Yeah, and you might not have the app version to know when you submit that blob what the commitment should look like. Does that make sense? Like, I think it's valid.
00:23:56.385 - 00:24:03.249, Speaker B: So can you rely on the. On the version of the latest header.
00:24:03.297 - 00:24:12.535, Speaker C: You have like, yeah, that's probably what you should do. You would just use that app version and maybe sometimes it fails because you just upgraded in between.
00:24:16.155 - 00:25:09.995, Speaker G: I'm not saying it's an issue from the node perspective, but rather from like we write a generic library and then I mean it will require passing versions on big API surface like most validate basic stuff, etc. Will require now user passing either extended header or just corresponding app version. Also, if I recall correctly, the blob in proto encoded form doesn't have commitments, so user will need to compute it. So he will also need to provide an app version for which he wants the commitment to be computed.
00:25:17.295 - 00:25:33.725, Speaker B: Column. Do we need like historical versions for this case anyhow? Like, do you need to use a V0 in case you want to compute a commitment from a block in the past or can we always rely on the latest?
00:25:36.265 - 00:25:58.215, Speaker C: Well, you might have this change. Like imagine v4, we change the subtree root threshold and so we release a binary with V4, but the network hasn't actually upgraded to V4, so there's this intermediate point where you don't know if you're someone trying to submit blocks whether you should be using the V3 yet or V4. So you have to like kind of listen in. Okay, the app version has changed and now I have to adjust accordingly.
00:26:02.835 - 00:26:29.455, Speaker B: Doesn't it mean that we need like a, like a versioning for this? Like if these doesn't change value from app to app, but we still have to bump, we still have to check. Or is it v0v1v3? Like what if you decouple this versioning from the up version but be like a separate version on its own of this K parameter or whatever it is.
00:26:30.835 - 00:26:36.855, Speaker C: Okay, but then what that's dictated from. Like when did we use go from V1 to V2.
00:26:39.635 - 00:27:04.305, Speaker B: Whenever we need to update it, right? Or like somehow also encoded in the blob. Like, so blob is sort of like self describing. It says like, okay, I am blob and I'm using this version with this case so that anyone in the past can like see from the blob itself that oh, I can actually compute commitment this way.
00:27:05.965 - 00:27:34.925, Speaker C: Yeah, like, sorry, Evan, maybe definitely want to say. I was just going to say like, I think we can discuss this. There's not 30 people in a call and try to work out how we're going to solve it. I think probably, maybe in the future. I don't know if other people agree with this as well, but I think it draws more attention if this is an issue in a GitHub repository and in the forum. I know, like, for me personally, I don't look in the forum much for like these kind of issues. More for like high level, like discussions.
00:27:37.545 - 00:27:42.715, Speaker A: What, like in this example, what repository would you expect this to be on?
00:27:44.095 - 00:27:45.715, Speaker C: You can do in Celestia app.
00:27:50.415 - 00:28:01.355, Speaker B: It's like an issue that we need to understand and there might be like other solutions that we need to explore besides just like putting versions.
00:28:03.495 - 00:28:03.927, Speaker E: In the.
00:28:03.951 - 00:28:08.935, Speaker B: Structs might be a good one, but there might be more.
00:28:11.075 - 00:28:45.065, Speaker A: Okay. I personally asked the Lumina team to make this on the forum, so I can take that responsibility. But yeah, we can go ahead and move this over to Celestia to get more eyes on it. No, I don't know, like, what the. Like, I'm not going to go look right now to save our time, but I don't know if it requires it to be a forum post or if it just has to be some sort of discussion. I think GitHub is perfectly fine.
00:28:47.885 - 00:28:49.785, Speaker D: Is this in reference to CIP?
00:28:52.245 - 00:28:53.185, Speaker A: What's that?
00:28:53.965 - 00:28:56.505, Speaker D: Is this in reference to a cipher?
00:28:57.315 - 00:29:02.375, Speaker A: This is the beginnings of a CIP that was the goal of starting a discussion.
00:29:03.395 - 00:29:04.455, Speaker D: Oh, I see.
00:29:04.795 - 00:29:27.585, Speaker A: Yeah. But I guess Caleb a little bit. I think this is a good thing to discuss outside of this call, just with respect to everyone's time. But I'm glad that we brought it up so we can get more eyes on that. Someone was going to say something.
00:29:29.525 - 00:29:31.301, Speaker E: No, sorry, I'll take it offline.
00:29:31.493 - 00:29:33.705, Speaker A: Oh, I mean, we have time.
00:29:35.525 - 00:29:38.645, Speaker E: No, it's implementation dt. No reason to cover it here.
00:29:38.765 - 00:30:35.745, Speaker A: Okay, up to you. On that note, I think that's everything that I thought that we needed to discuss. I want to leave the floor open for like 20 seconds or so to see if anyone has anything else that I might have missed that we should discuss now, maybe. Cool. And on that note, I want to thank everyone for coming again. I'm not positive when we'll do the next meeting, so we'll go ahead and schedule that and drop it in the chat. I want to thank everyone for coming and thanks everyone for participating to figure some things out.
00:30:36.605 - 00:30:37.429, Speaker C: Thanks, Josh.
00:30:37.517 - 00:30:38.405, Speaker A: Thanks, Josh. Bye.
