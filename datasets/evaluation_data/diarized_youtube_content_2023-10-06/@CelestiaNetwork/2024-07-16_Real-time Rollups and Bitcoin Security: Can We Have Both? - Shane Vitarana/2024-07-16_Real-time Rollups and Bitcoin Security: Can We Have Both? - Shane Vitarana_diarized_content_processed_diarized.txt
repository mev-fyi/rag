00:00:02.600 - 00:00:09.850, Speaker A: All right, let me get started over here. We're going to talk about real time roll ups and bitcoin security. Can we have both?
00:00:12.110 - 00:00:12.806, Speaker B: All right.
00:00:12.918 - 00:00:44.780, Speaker A: I'm the founder of Stargaze. Stargaze is an app chain for nfts and more. It's the home of bad kids and Celestine sloths. Anyone here have a bad kid or a sloth? All right, now lick your elbow. No one's licking their elbow. What? Okay. Anyway, in a previous life I worked on low latency audio engines for iPhone apps and before that I worked on scaling web two apps at Groupon.
00:00:44.780 - 00:01:37.340, Speaker A: And there's a bit more, but I'm going to continue with my talk. So we're going to talk about building real time rollups without sacrificing the values of crypto. And I'm going to define real time here as a web3 query or a web3 transaction being as fast as a web two API call. Just a little bit of context. The thesis for Stargaze has been that nfts are a stepping stone to bring in more users into crypto. And we want to build the best possible UX because right now we're a product for kind of crypto natives, but also at some point we want to bring in more mainstream users. We've always kind of operated as kind of more of like a bottom up way as opposed to like a top down fashion.
00:01:37.340 - 00:02:22.618, Speaker A: We kind of start out building the apps and then we scale infra as needed. This way, this is kind of more how it works in traditional startups and web two. You can achieve product market fit, you can iterate quickly, you can get feedback from the users. And I'm not saying there's one right way to do things, but the downside of this approach is we can't start with the end game. First we have to re engineer and modify things. It's like updating a plane while it's a in the middle of flight. Of course, I won't be here if I didn't believe in scaling the module away instead of just scaling a single cpu.
00:02:22.618 - 00:02:39.076, Speaker A: Or, I mean, if you think of. If you think of a blockchain as a computer, you can think of ram as data availability, you can think of GPU as execution, CPU as consensus.
00:02:39.228 - 00:02:39.972, Speaker B: Right?
00:02:40.156 - 00:02:50.036, Speaker A: You just don't scale one of them. You break them out into components and you scale each one. So why focus on performance and speed in UX?
00:02:50.148 - 00:02:50.800, Speaker B: Right?
00:02:52.700 - 00:03:01.100, Speaker A: If you look at history, speed was really important in terms of certain products, like winning in their class.
00:03:01.260 - 00:03:01.868, Speaker B: Right?
00:03:02.004 - 00:03:44.680, Speaker A: I remember when the search engine wars happened in like web one. Google won partly because it was just really fast. It was able to produce the results in half a second. Altavistin, Yahoo and others took two to 10 seconds or so. Then if you think about Uber, Uber internally, they're obsessed with the time to find a car. And they train this transformer model called dpeTA with graph theory to be able to optimize the process of finding a car. There's so many other examples of this, like Amazon with their one day shipping and so forth.
00:03:44.680 - 00:04:21.264, Speaker A: And if you kind of apply this to blockchains, if you have a blockchain that has really good ux and super fast, it attracts all these users, and then that will attract more tvl, that'll attract more volume, and then that brings in more users, and then you can learn from them and you can further optimize the speed and performance, and that brings in more tvl and volume. So it has this positive feedback loop. So where do users spend most of their time? They actually spend most of their time querying data on the blockchain. They're not spending most of their time submitting transactions to the blockchain.
00:04:21.392 - 00:04:21.824, Speaker B: Right.
00:04:21.912 - 00:05:08.014, Speaker A: They are finding yield opportunities. They are browsing around for nfts, trying to find a slot that looks like them or whatever, right? So we spent a lot of time optimizing reads. So we built this indexer called constellations, which is built in rust, is super fast, is async and multithreaded. It can index a cosmos chain like osmosis or something like under 5 hours from Genesis. And this is kind of like the secret sauce that makes the website really fast. We also have a geo distributed RPC cluster and we have read optimized rpcs. So like most of the merkle trees, cache and ram, it makes read super fast.
00:05:08.014 - 00:06:01.330, Speaker A: And we're working on like a new version of this that puts the entire merkle tree in ram. So after you've optimized reads, you want to focus on optimizing writes. So there's two ways to, two ways to do this. You can scale the l one, which is kind of like the Solana approach, right? Or you can build roll ups and L2s. So in terms of scaling the layer one, there's also some like lots of good research in this area and scaling tenement comma BFT. Dev from osmosis gave a talk a few weeks ago at Devmos about how he thinks we can bring tendermit down to like a second or two, which, you know, which is going to be awesome. And then obviously the other approach is roll ups, where you decouple consensus and execution.
00:06:01.330 - 00:06:32.672, Speaker A: I really like this approach because you have a separation of concerns, right? You do one thing and do that one thing really well, and then you reduce the latency down to the speed of execution. And the other thing is, it opens the door to fractal scaling. So you can have l three s and so forth, blockchains on top of blockchains. Another thing that I really like about it is that as an app developer, you don't have to leak Mev to the base layer.
00:06:32.816 - 00:06:33.500, Speaker B: Right.
00:06:33.920 - 00:07:23.210, Speaker A: On Ethereum right now, there's a lot of talk on base roll ups because people don't want to leak Mev or keep mev at the L two layer. But I would argue, as an app developer, if Mev is the largest source of revenue in crypto, then you should own that, right? So Rolekit and Celestia are great technologies to build roll ups with. I like Rolekit a lot because for execution, it's just cosmos SDK. So you can have cosmosm, you can have EVM, you can have custom modules instead of tenement. It doesn't have tenement, right. So it's super fast. There's no rounds of BFT.
00:07:23.210 - 00:08:05.388, Speaker A: And also use Lib P two p, which is this modular networking stack built by protocol labs. And it's less buggy and faster than tenement's custom p two p. And of course, celestial data availability sampling, kind of best in class. You can have this super light nodes, and the more light nodes that are running, the bigger block sizes that you have. And that's all great. The other thing you get with rollups is fast precomps. So, because if you're running something like cosmwasm, the native execution speed is super fast.
00:08:05.388 - 00:08:09.580, Speaker A: Like in the order of like a few milliseconds, maybe like, you know, one through five or something.
00:08:09.700 - 00:08:10.220, Speaker B: Right?
00:08:10.340 - 00:08:22.964, Speaker A: So your precaution speed is like pretty much just the latency of one global ping. So, you know, so now the user can click on a transaction and do something in like 100 milliseconds, which is incredibly fast.
00:08:23.092 - 00:08:23.760, Speaker B: Right.
00:08:25.230 - 00:09:08.548, Speaker A: Okay, so I know what you guys are thinking. This is a centralized sequencer. How can we make it not centralized and stuff like that? Well, one thing I like is Babylon bitcoin staking. So this is not live yet, but this is still in development. But the way this works is that the sequencer signs a transaction and stakes some bitcoin on the bitcoin side on the layer. One of bitcoin and then it signs this extra transaction when it signs sequencer transactions. And then if it double spends, it leaks that private key.
00:09:08.548 - 00:09:40.810, Speaker A: And then when it leaks that private key, anyone can kind of take it and then slash the sequencer on the bitcoin side. So this is really good. It prevents forking attacks on the sequencer side. And then another reason why I like it is that this is staking. This is not restaking. So it doesn't have like, additional level of hypothecation. And then, of course, you know, bitcoin is the most credibly neutral network, most dominant currency.
00:09:40.810 - 00:10:14.736, Speaker A: Just lots of capital sitting around and people wanting to earn yield on it. All right, going to go into slow mode a little bit now. So going to use all this and build. We're working on stargazel two, called Astra. And Astra is going to be a cosmosm. Layer two is going to run at near native speeds. It's also going to have native yield.
00:10:14.736 - 00:11:23.166, Speaker A: So we're working with stride Noble and some others on native yield on it and is going to be running SCIP's block SDK, which will enable developers to share mev with stargaze l one as well. Why are we doing this? So stargaze is kind of at a point where, like Amazon was when it was only selling books. We have users that are asking for a bunch of other things. There's already something like 40 some apps on Stargaze, but we want to open it up, make a permissionless environment for people to come and build new apps. What I'm most excited about, though, is this real time roll ups enable a new class of apps when everything's as fast as a normal web app. I'm really looking forward to new zero to one apps, like maybe games and social media and stuff like that. So, yeah, so we're going to have native yield with stride assets also for stables.
00:11:23.166 - 00:12:29.550, Speaker A: We're working with Noble on that. And also there's a new class of bitcoin restaking kind of protocols that are out there that we're going to use for bitcoin yield. So I'm going to talk about how the native yield works with stride. And thanks for the stride guys for this awesome diagram here. So the way it works is that, let's say you're on Stargazel one and you want to send some stars to Astra when you do the transaction, what actually happens behind the scenes is that those stars get liquid staked on the stride side, then it goes through a hyperlane yield route and then it gets locked into a vault. And so the staked version of the asset is in this vault. And then it talks to a rebasing contract that every epoch will mint more of the asset, more of like stars, for example.
00:12:29.550 - 00:13:10.000, Speaker A: Now, these tokens can flow into user accounts and they can also flow into contracts. So this kind of opens the door to building new, different defi apps, because you're having yield flow into your contracts. So some of that yield could maybe go as. It could be protocol revenue. It could be some kind of reward to the user. There's like all kinds of things you can do, do with this. Another thing that Astra is going to have is not going to have a dispute, period.
00:13:10.000 - 00:14:01.950, Speaker A: If you use base or optimism and so forth, there's like, I think like a two week window. If you want to, if you want to withdraw funds, you can go through like some other bridge, but you have to like, you know, pay a fee for that. But there's this technique called pessimistic validation. And this is by Yermoon. He actually gave a talk on this. So if you want to learn more about this, go and watch that talk. But at a high level, the way this works is that the validators for Stargaze l one will run full nodes of Astra, and then they're able to get the current state of the roll up, and they can update the IBC lite client that's running on Stargazel one.
00:14:01.950 - 00:14:49.118, Speaker A: So they're kind of like validating the IBC connection between the roll up. So now you can just do regular IBC between the roll up and Stargaze l one, and you don't have a dispute, period. So this is super nice, but this also opens the door to do IBC routing. So let's say there's another l two on Stargaze. Now you can have atomic cross chain composability because you can send IBC messages across the roll ups and without having any kind of delay or dispute, period. All you had to deal with is the three blocks or so for the IBC transaction to happen. And of course, the end game is ZK.
00:14:49.118 - 00:15:35.060, Speaker A: The end game is to ZK prove execution and consensus. But it's not at the level. It's not fast enough for what we need yet, but that's going to be the end game of this stuff. All right, show mode off. All right, so just to recap here, real time roll ups can give you awesome UX opens the door to new zero to one apps increases like user adoption feedback loop, and then native yield will give more optionality to devs. You have yield flowing into your contracts. And then finally you can secure the roll up with bitcoin staking.
00:15:35.060 - 00:15:54.140, Speaker A: So I think this solves a lot of problems and kind of create something new, a new opportunity for devs to build on. All right, well, that's it, folks. You can follow me or Astarstargaze on Twitter, and that's it.
