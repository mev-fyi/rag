00:00:04.560 - 00:00:49.650, Speaker A: Hello everyone. First things first. Let me introduce myself, maybe someone new joined. My name is Mihau. I'm a software developer at ifworks and at this presentation I will show you the basics of solidity. And because there are not so many of us, I think we will do it in an interactive way. So first I'll show you a couple of slides and code snippets, after which I'll invite you to join me and we will write some code.
00:00:49.650 - 00:01:42.080, Speaker A: Don't worry, you don't need any special software. Your browser, which you're using right now, is enough and we'll see how it goes. If you have any questions, you can raise your hand so that I can notice it. Also you can use chat or preferably ask questions using the questions tab, and I'll be answering them along the way. So feel free to ask me anything at any point in time. So yeah, without further ado, let's start. I'll start with introducing you to the data types that are available in solidity.
00:01:42.080 - 00:02:35.910, Speaker A: So obviously you have booleans, nothing new. You have integers, and you have both signed and unsigned integers. As you can see, there are multiple of them with different precisions. So int eight is an eight bit integer up to int 256, which is 266 bit integer, which is 32 bytes. And you get all of the integers in between, going in by eight. You have the same for unsight integers. Then if you use just int or just uint, this is an alias for the largest type.
00:02:35.910 - 00:03:40.456, Speaker A: Why is it alias for the largest type? Because this is the size of the word in ethereum virtual machine that is used there. And this is what we use for storing amounts of crypto, for instance, that you own. This is a really big number. It's so big that you'll probably never overflow it when simply adding numbers. So this is one nice feature that you have a lot of precision. It's also this big because you don't have any floats in solidity. So there is no floating point arithmetic, just not to make so that you are not tempted to use floats for representing money.
00:03:40.456 - 00:04:43.790, Speaker A: As we all know, floats have problems with rounding and errors, and basically cannot accurately represent based and multiples that we use for money. That's why for money calculations we prefer to use integers, and we have such big integers so that we can safely represent any precision that we use for digital currency. You also have an address type. It represents 20 byte value. It's like an array of 20 bytes that represent the Ethereum address. Think my presentation is gone. Let me check it out.
00:04:43.790 - 00:05:24.996, Speaker A: It. Okay. I think it's back. If someone doesn't see it, please let me know on chat, because that's something weird. Okay, going back to the presentation, every address has a couple of fields. You have a balance which lets you query like that. The current balance of this address, of this account, you have code which if the address is the address to the smart contract, you can get its bytecode.
00:05:24.996 - 00:06:39.570, Speaker A: This way you have a code hash which, as the name says, is a hash of the code, and also a method to call some method on this address. There are many other, I didn't mention them all, but just to give you an idea, there's also something called address payable. So this is the same as address, but also you have new methods that let you transfer value to those addresses. So this is simply so that it's clear in code which variables can be used to send money to you have arrays, and those can be fixed sized or dynamically sized, just like in any other language. Declaration is very familiar. So you specify the type, and in square brackets you specify the number of elements. For fixed size array, there are also like predefined keywords for byte arrays from one up to 42.
00:06:39.570 - 00:07:29.824, Speaker A: So you don't have to write byte 42 in square brackets. And also you have dynamically sized arrays. Those are specified without the number of elements. You have a keyword bytes, which is a byte array. It's different than writing byte with square brackets in a way that in this case the bytes are tightly packed so it uses less storage. String is a byte array that is UTF eight encoded and doesn't have some of the methods that I will show on the next slide. Allocating dynamically sized array looks like this.
00:07:29.824 - 00:08:35.064, Speaker A: You specify the type of the array memory keyword, which I'll mention later, the name of the variable new, you repeat the type and you give the length in brackets. Arrays have members. Fix size arrays only come with a length, and dynamically sized arrays come with some of some methods that let you add or delete elements from it. So push adds zero initialized element. What does it mean? It means that you cannot add a neil or a null or an undefined value because they don't exist in solidity. If you want to add something to an array, you always add at least a zero initialized value. So what is a zero initialized value? For integer, it's simply zero.
00:08:35.064 - 00:09:40.620, Speaker A: For Boolean, it's false. For string, it's most probably empty string and so on. You can push an empty value, a zero value, you can push an existing value, you can also pop from the end of an array in solidity you also get a mapping type, which is sort of like dictionary from Python or a map from typescript. It holds key value pairs. It's declared this way, so keyword mapping and in brackets key type towards value type and the name of the variable you assign to it, just as you would assign to an array in the same way. What's special for solidity arrays? Solidity mapping, sorry, is that they are virtually initialized. So again, every possible key exists.
00:09:40.620 - 00:10:33.740, Speaker A: And if you query for a key that was never set, you'll get a zero value of the value type. So this is again like an example that you never get a nil. In solidity you always get some value, in this case zero value. Another interesting feature, or a lack of feature, is that mappings are not non interruble. If you want to iterate over a mapping, you need to basically implement it yourself. And someone may ask why you don't have such an elementor feature built into the language. I think it's to make you aware of the stuff that you are doing, of the loops that you are introducing into your code.
00:10:33.740 - 00:11:31.500, Speaker A: And you'll see that in many places solidity is sort of low level in this sense, that it doesn't provide you nice abstractions that we are all used to from other languages. Solidity lets you define your own types in form of structs. So a struct is like a set of variables which can be of different type. Those can be other structs and mappings, for instance, so you can freely create your own types and use them in code. We also have enums which are declared just like in any other language. Now let's talk a bit about something again specific to solidity. In solidity you have three data locations.
00:11:31.500 - 00:12:20.930, Speaker A: You get storage, which you should think of as hard disk drive. It's a persistent storage that outlives the invocation of a function. It's simply stored on blockchain and the next transaction can read from that storage. Then you have memory, which is sort of like RAM in your computer. It's volatile, its lifetime is limited to the invocation of a function. Therefore it's relatively cheap to write because it's not stored permanently on blockchain. It's only allocated when the transaction is executed on the minor node and it's gone after that.
00:12:20.930 - 00:13:18.604, Speaker A: You also have something called call data. And call data is a special place where arguments of methods that you invoke are stored. If you attended my previous presentation, you remember that I talked about a field of transaction which is called init or data. And in case of invoking a method of a smart contract, this field was called data. Well, call data is simply this field. So every transaction has some input data in which we encode the method that we want to invoke and its arguments. And then in solidity you get arguments of a function and you don't need to copy them to memory.
00:13:18.604 - 00:14:31.610, Speaker A: You can directly read from this call data, which is used to reduce the number of operations that you do. You don't copy the memory, your transaction spends less gas because it's like a field of transaction, it's immutable. You cannot change this because what comes from transaction, and again, it's not accessible after the invocation of a function ends, because it's an argument of a function simply. But what's interesting is that call data is actually stored on blockchain. How? Because we store information about every transaction that happens on blockchain. That's why we also store information about all the arguments of methods that were invoked. And this is used in many applications and it's also used in L2 protocols, which I won't dive into right now, but this location is very important there.
00:14:31.610 - 00:15:50.980, Speaker A: Okay, I think it's enough of slides. Let's jump into some code and see some examples, and not just me showing you theory. Okay, I'll try to make this window more so you don't have black borders. All right, this is a gist that I created with solidity syntax. You have comments in solidity, I'll copy a link to it to the chat so you can look at it yourself. If you don't want to follow what I'm presenting here, I'll make it a bit bigger so that you all can see. Okay, so you'll see that every solidity file will start with a version of compiler that is used, and this declaration starts with word pragma, then solidity, and you specify the version in semver.
00:15:50.980 - 00:17:10.500, Speaker A: So the same way you specify versions in JavaScript in NPM packet json files. Later on you'll learn that it's important to hard code the exact version for audit purposes. So assume that you want to send your smart contract to an auditor and you ask them to look at your code. They will tell you hey, you should actually hard code the version because that's how we can make sure that what we are auditing is what is actually executed. One exception to this rule is that if you're creating a library, you shouldn't actually hard code the compiler version because then other contracts that use a slightly different version of compiler will not be compatible, and in such cases you should create a range that is as broad as possible. Okay, let's now go into the pieces of solidity. This is not like a proper file, it wouldn't compile, but it shows you the syntax.
00:17:10.500 - 00:18:08.070, Speaker A: So declaring a variable and assigning it is done just like in any other language like JavaScript or Java. If you declare a variable but don't set a value immediately, it is zero initialized. So again there is no nil, there is no undefined. You can declare constants by putting a constant keyword. Compiler will replace those variables with actual values in code. If you declare a variable that is public, the compiler will automatically create a getter function for you. This is convenient so you don't need to write those getters yourself.
00:18:08.070 - 00:18:56.612, Speaker A: Note that no setter will be automatically created. If you actually want to give other contracts ability to modify your state variables, you need to create setter yourself. I just noticed a question. Is there a recommended solidity version last released or n minus one? That's a good question. I would say that as with every piece of software, it is validated after some people use it. Therefore I wouldn't recommend using the latest version unless it solves some critical issue that was in the previous version. Then yeah, you should probably use the latest one.
00:18:56.612 - 00:19:57.290, Speaker A: So a rule of thumb would be to use n minus one, but you need to be careful going back if you don't specify public. A variable is internal by default, which means it will only be available in this contract and those that derive from it. So basically the same smart contract. It doesn't actually mean that the variable is not readable by actors watching the blockchain. You need to be aware that every data that we write to blockchain is public. Nothing in blockchain is private because we wouldn't be able to run those transactions on thousands of nodes. If you want to achieve privacy, you need to use other methods going forward.
00:19:57.290 - 00:21:04.872, Speaker A: As you can see, this way you can declare a variable that is of type address payable. It would be a zero address actually, because we didn't assign anything on an address payable variable. You have transfer method that lets you send some money in case the transfer fails. This method reverts. Why would the transfer failed? Because if you transfer to another smart contract, it can have a callback method that can decline the transfer, for instance, and then this method would revert. You also have send method which doesn't revert and lets you handle the failure in an if statement it just remember to do it. If you don't want to introduce it back in your code, you can create the balance.
00:21:04.872 - 00:21:51.180, Speaker A: As I showed on the slide. You have examples of those fixed size byte arrays here, bytes two and bytes 32. Also a dynamically sized bytes array string. Everything I think is pretty straightforward. Here is an example of a declaration of a fixed size array of five fixed size arrays of bytes. So we have five times 32 bytes. This is a dynamically sized array, and on a dynamically sized array we can push elements.
00:21:51.180 - 00:22:44.060, Speaker A: We have a length property, and what's interesting, you can assign to the length property. Assignments will either cut or extend the array. If you cut, you'll simply get a shorter array. If you extend, the new elements will be set to zero. So again, you don't have undefined snails and you don't have some garbage left over from some data location memory, just as you would have in C plus plus or other low level language in solidity. If you expand the length of an array, you get new zero elements. At the end you can create multi dimensional arrays.
00:22:44.060 - 00:23:44.800, Speaker A: Here is an example of a mapping then assignment to a mapping looks this way. So Charles has a balance of one. If you query for a balance of a non nonexistent key, you'll get a zero. As I mentioned, all keys are virtually initialized. You get a zero value of a given type, and because we specified a public keyword here, compiler created a getter for us which looks this way. It takes an argument which is the key, and returns a value taken from this mapping. Then a different smart contract could query this method this way, simply invoking balances.
00:23:44.800 - 00:24:36.444, Speaker A: You can nest mappings. So a mapping can be you can have a mapping from address to another mapping. It's totally possible there's something like delete keyword which lets you delete an element from mapping, and by deleting I mean setting it to zero. Again, if you delete the whole mapping, it will set all of its elements to zero. Let's now talk about structs. Structs need to be first declared, after which they can be created in two ways. First is a sort of json like way where you specify keys and values.
00:24:36.444 - 00:25:39.770, Speaker A: You can change the order as you wish. The second way looks more like a constructor where the order needs to be the same as it was declared. Um, you can assign to a field in a really simple way. If you delete the contents of a mapping, it will set all of its elements to zero, except for mappings. In this case it will not be zeroed. I'm not sure about that, but yeah, you can declare enums and then use them. This way enums are easily converted to numbers, and also this way you can cast other types to other types.
00:25:39.770 - 00:26:15.160, Speaker A: For instance, you can cast Boolean to a number, and you'll get from false, you'll get zero, from three, you'll get one. Solidity has simple operators, just like other languages. I don't want to bore you showing them all. You can easily look them up in the documentation. I think it's more important to show you the fields and stuff specific for a language for smart contracts. And here we start. The first thing is this.
00:26:15.160 - 00:27:01.430, Speaker A: So I didn't mention it before, but you can think of a smart contract as of a class in object oriented programming language. So instead of class keyword, you'll get a contract. Keyword smart contract is like a class, and an instance of a smart contract is like an object. It has a state and it has some methods. The methods can modify the state of this object. And that's why this in insolidity means the current contract. If you cast it to an address type, you get all of the address properties.
00:27:01.430 - 00:27:49.720, Speaker A: In some previous version you didn't have to cast, they forced you to cast from some version just for readability. If you call a method on this, it is doing an external call instead of an internal jump. What it means is that your contract is called as if from the outside. I won't go into details, but it uses more gas. And in most cases you don't do it. In most cases you simply call some function without this dot. INOS has a question.
00:27:49.720 - 00:28:49.430, Speaker A: In your experience, a contract starts with some special design process board, Trello or some other tooling for design, or you just go direct to coding. So you would design a smart contract just like any other piece of code. So if you were to design a class in an object oriented programming language, you would probably first think about it. First define some methods that you would like to see on it, some state that you would like to it to store. You would probably think about separation across files. So in object oriented programming heals inheritance. In other languages you use composition more, so insolidity inheritance is more preferred.
00:28:49.430 - 00:29:52.270, Speaker A: So you would use a blackboard, you would use Trello and other tools in the same way as you'll see later. It looks really similar to other languages and it's easy to learn. Okay, going forward you get a couple of global variables. Those global variables are accessible inside of functions. So global variable called message represents the current transaction or actually the current message call, so to say. So you get to know who called the method on a smart contract. And this can be another smart contract if you are curious who originated the transaction.
00:29:52.270 - 00:30:37.660, Speaker A: So as you probably remember from my previous presentation, transactions can only be initiated by external accounts. They cannot be initiated by some smart contracts. And if an external account calls a smart contract, it can in turn call another smart contract. So the last smart contract in the chain will see in this field will see an address of its direct parent, so to say. So it will see the address of contract calling it. If it wants to know who originated the transaction, there is transaction origin for it. So that's the difference between the two.
00:30:37.660 - 00:31:42.640, Speaker A: You can also get the value of ether that was sent along with the transaction. You can get the raw call data. And also there is a special method that lets you get to know how much gas is left for computation. As you remember from my previous presentation, every transaction has a gas limit and you can create a logic in your function that takes that into account. So for instance, say that you need to loop over an array in a function, but you're not sure if you'll have enough gas to do it. You can use gas left method and decide based on that. If for any reason you needed to know gas price, you can always use this field to do it.
00:31:42.640 - 00:32:44.514, Speaker A: There's also something called block timestamp. So information about block are current are gathered in this block global variable. The timestamp of a block is the time which miner sets the block to be. So this is again an interesting topic because how do you get to know the time in a decentralized distributed system? Well, in our computers we have a clock that's synchronized with some central server. So when we open our Windows it probably syncs with some Microsoft server to get to know the current type time. In case of Ethereum, you have a peer to peer network and you don't want to introduce any dependence on a central service. So all of these computers around the world can have a different vision or different version of a time.
00:32:44.514 - 00:34:07.050, Speaker A: And similarly to how we choose the single computer to build the next block, we choose the person to set the time. So a miner, by building a new block, can tell everyone else what the current time is. Of course he cannot give you a timestamp that's too much off because we know that blocks are built around every 15 seconds. So if he tries to set a timestamp a minute into the future, it will probably be such block will probably be rejected by most of the network. It's coded into the Ethereum node software. Anyway, this was to give you a warning here, because you shouldn't actually be making your logic dependent on time. So for instance, say you create a game where you randomly choose a winner, and as a seed of randomness you use time well as the algorithm.
00:34:07.050 - 00:34:59.490, Speaker A: Creating a random number is deterministic. A miner could set a time that will make him win the game. I know it's really far fetched, but you need to remember that this is possible. You can get to know that the number of the block in which transaction is mined, its difficulty, which I didn't talk about, but it's another topic in blockchain systems. Also the gas limit of a current block, if you need it for any reason. Let's now see how functions are declared. So a simple function has a name, a list of arguments, and a list of returned values.
00:34:59.490 - 00:35:47.446, Speaker A: The list of types of returned values. So increment function takes an x and increments it by one and returns it. A function can also return multiple arguments because as I mentioned, it's a list of returned values. So you can have a function that takes x and Y and returns a tuple of two values. This is similarly to what you have in go, for instance, and probably other languages as well. Calling such increment function returns a tuple, which you can destructure into two variables this way. What's interesting is that you can name your return arguments.
00:35:47.446 - 00:36:44.472, Speaker A: Again, I only saw this in go, and I think it's a very nice feature. For one, it allows you to completely omit the return statement so you don't have to do it. And also I think sometimes it makes the code more readable because you not only get the name of the function and the name of the arguments, you also get the name of the return. Type it. Okay, now let's talk about some modifiers on the functions, or actually visibliers. Modifier is a name for something else that I'll show you in a minute. You can have a view specifier, which means that this function will only read from state variables, it will never change them.
00:36:44.472 - 00:37:51.630, Speaker A: It's sort of like constant in C plus plus, I think, and other languages. So in this case, if Y was a state variable declared outside of the function, incrementing y inside of a view function would make the compiler complain. You also get a pure specifier, which is even more strict than view. A pure specifier doesn't allow a function to have any side effects, so a function cannot even read the data and also cannot call any other methods that are not pure. It simply is a pure function. It only operates on the arguments that it gets. You have visibility specifiers, so we already mentioned that you can make variables public.
00:37:51.630 - 00:38:59.620, Speaker A: You can also make functions public, and they will be visible to other smart contracts and also can be used internally. External function is visible to other smart contract, but cannot be called internally, which is interesting. Private is only visible in the current contract, and internal is only visible in the current contract and also those that derive from it. So there are four visibility specifiers. There's something called require function. Require function is a function that throws an exception if condition is not met, so it reverts the whole transaction. If this condition is not met, you can specify a required message, a message that will be added to the revert so that it's easier to debug transactions.
00:38:59.620 - 00:39:32.190, Speaker A: And where are we using required conditions? We can use them in functions. We can also use them in something called modifier. So modifier is like an extension of a function. You'll see in a minute how we use modifiers. So you declare it given a modifiers keyword. Modifier keyword the name of the modifier and the list of arguments. A modifier cannot return anything.
00:39:32.190 - 00:40:34.610, Speaker A: Instead of modifiers, we usually put our required statements. So modifiers are often used to validate input arguments and also to authenticate access to some smart contract functions. Such checks are often repeated in the code. That's why modifiers are handy in extracting these repeated pieces of code. And the way it works is that at the end of the modifier, most often at the end, you specify an underscore keyword that denotes the place where the rest of the function goes. You can also put the underscore at the beginning of the modifier. Then the require will be done at the end of the function call.
00:40:34.610 - 00:41:13.950, Speaker A: So how would you use a modifier? Suppose you have a function change owner that takes a new owner as an argument. I forgot to put the name of the type of the variable here, so assume it's an address. New owner. You say that only after some time. Only owner and only in state A it can be invoked. So only after we'll run this piece of code. Then only owner will run this piece of code.
00:41:13.950 - 00:41:52.660, Speaker A: Only in state eight. State A will run this, and only after all of these checks the function will be able to continue. In solidity you get other logic blocks as in any other language. So you have if else statements for loops, while breaks continue. I don't want to bore you with that. Here's an example for loop that loops over an array pretty straightforward. And the last thing I want to mention is events.
00:41:52.660 - 00:42:56.010, Speaker A: Events are again something specific to smart contracts. Events can be emitted, and front ends that are created for smart contracts can easily subscribe to such events. Events are stored on blockchain permanently. So that let's say you're building a decentralized application and it runs in a browser, user goes into your application and it needs to sync the state of the smart contract. Instead of querying for an older state of the smart contract, you can quickly go through the log of events and be up to date fast. So in order to use events, you first declare it. Events can have parameters, and then in a function you emit events this way.
00:42:56.010 - 00:44:08.590, Speaker A: Okay, I think this introduction is enough for us to jump into writing some code of our own. It and yeah, let me share a link to an online IDE that we will use. This Ide is called remix. I'm pasting it on slack right now in the chat and I'm going to screen share as well. Oh, actually I opened it in safari. If you are on Mac, as I do, you should probably use Chrome because it works better in Chrome. So let me quickly switch to Chrome.
00:44:08.590 - 00:45:49.910, Speaker A: If you have any questions, feel free to ask. Okay, I made sure to delete cookies so that I should be having the same state of this ID as you do. When you first open it, you can press anything here on the left you have a browser of the files. We'll simply go into contracts and create a new file. Let's name this file courseol and right now I'll share a link to another gist that will include code that we will copy here and start working with it. So let me find the gist first. I added it to the chat and let's maybe read through it first.
00:45:49.910 - 00:46:47.108, Speaker A: Here we have an example smart contract. It represents a course at a university, so to say, and it's simple enough for us to start playing around with solidity. What you can see at the top of the file is a license specifier from some version of compiler. They make you specify a license. If you don't do it, you get a warning, you can say unlicensed, which means that you don't specify any open source license, so that so your code is closed source. You get the version, the compiler version again, and then the body of the contract begins. As I mentioned, it looks like a class from object oriented programming language.
00:46:47.108 - 00:47:50.060, Speaker A: So you get some fields, you get a constructor, you get a declaration of other elements and functions as well. Let's read through it. So a course has a name, has a teacher address, an array of student addresses, and the mapping from address to point to a number which represents points. This will be a mapping where we will store the results of our students. Then a constructor of a contract takes the course name and an array of students and immediately assigns them. It also uses this global variable message and sets the teacher to the sender of the message. This means that the account that created this smart contract will become the teacher.
00:47:50.060 - 00:49:10.370, Speaker A: We have a points added event which has three parameters, address of the student, his points, and the timestamp. That was done. We have a modifier that makes sure that add points method is only called by the teacher. So in this modifier we require that the sender of the message is the teacher, and if not, the transaction is reverted. With a method that only teacher can call this function, then add points function simply adds points for a student. Again, as you can see here, we don't need to really insert into the points mapping first because every key is initialized to zero, so every student has zero points at the beginning. We can simply increment their points this way, and then we can emit an event to let other applications watching the smart contract know that something happens.
00:49:10.370 - 00:50:20.140, Speaker A: We also get a getter function that, given an address, takes the points of a student and in a really dumb way returns a number which represents the mark of a student. So again, in Poland we usually give marks on a scale from two to five, and you also get a mark like 3.5. We don't have floats in solidity, that's why we represent 3.5 as 35. And this is what you do with every time you need to have some fractions, you represent them as integers. So if someone has more than 90 points, 90 points or more, they basically get a five. Okay, I think that's simple enough.
00:50:20.140 - 00:51:09.802, Speaker A: Let's now copy this code from the list into the remix ide. Follow me for now. I'll give you some time in a moment. So after we copy it, we can go to the second tab. Here we can choose compiler version to be compatible with the version of smart contract. The language is obviously solidity. We can choose autocompile, which will compile the contract after every change.
00:51:09.802 - 00:52:15.018, Speaker A: So if we, for instance, forget semicolon, you'll immediately get an error here, which is nice. And you can also enable compiler optimizations. This is similar to optimizations that you can set for your C plus plus code. Compiler has some heuristics to optimize the resulting bytecode a bit now we have the contract compiled, we see a green arrow here, a green tick here, which lets us know that it was successful. We can now deploy our smart contract. So what will happen right now in our web browser, an implementation of Ethereum is run. This implementation is written in JavaScript, obviously, and it lets us play around with Ethereum.
00:52:15.018 - 00:53:03.230, Speaker A: That's why we don't change the environment here. Remix is also capable of connecting to Metamask, which is an extension that I have also installed here, which enables us to use it in production as well. So if you wanted to deploy a contract to a real network, it's also possible using this tool if you decide to stay with a JavaScript virtual machine. You have a number of accounts here with predefined ether. Let me check if I can share it differently. So you can also say SC. I don't think so.
00:53:03.230 - 00:54:20.120, Speaker A: Unfortunately, you'll not be able to see the list that I'm on pointing here, but you can check it on your own, that you have ten accounts here in this list. All of them are prefilled with 100 ether, and you can use all of them for our purposes. You can set gas limit of a transaction here, the value in ether that you'll send along with this transaction, and a bunch of other buttons. So what we will do right now, we will choose the smart contract that we want to deploy, and we will specify constructor arguments. So for course name I'll put anything in, and for addresses I will actually use addresses that were auto generated for me here. So I'll take the second and the third. Let me create this input data and I will paste it on chat so you don't have to do it on your own.
00:54:20.120 - 00:55:21.680, Speaker A: I press transact. This will deploy the smart contract in this virtual machine, and I can also see the deployed smart contract at the bottom. If I scroll further, you can see an interface to our contract. So you have a button for at points method. You have a getter that returns the smart contracts like the course name. You can see that for the array of students we got a getter which allows us to iterate over existing students. There are two because I set them two addresses in the constructor.
00:55:21.680 - 00:56:32.460, Speaker A: The third one will result in an error, so you get an error revert something was wrong because we run out of the range. You press teacher, you'll get the address of the teacher, and the address of the teacher is the address of the account that was used for deployment. Mistakenly, I used the same account that was used for students. So I'll correct my error right now I'll remove the smart contract and I'll deploy again using the first account. So now we can see that teacher is a different address than students. To get a mark of a student, I can copy his address into the getter and I'll see that he currently has a mark two because he doesn't have any points. Okay, I think that's straightforward enough.
00:56:32.460 - 00:57:44.980, Speaker A: Let's see what the question is. Let's say this course contract needs to have a description field or some other field that is long and expensive to store. Is it okay to add the field to the contract as a property, or would there need to be some other storage like a relational database? So in real life, your decentralized application will either be will most likely be still hosted by some central server. This is what happens right now, so you will never need to start such description in the smart contract. This course name variable is also redundant in this case. So this is just an example. In real contracts you rarely store any strings and if you need such description, you store it in you get it along with the front end of the smart contract.
00:57:44.980 - 00:58:36.500, Speaker A: At my previous presentation, when I showed the slide with comparison between web two and Web 2.0 and Web 3.0, I mentioned that in the future we want to see decentralized applications that don't have any dependency on a central server. In this case, you will be fetching the front end of a smart contract from a distributed storage like IPFs or some other protocol that allows to do that. And in this case also you will fetch such description from some other database and not necessarily do it. Fetch it from blockchain. Why not fetch it from blockchain? Because storing data at blockchain is very expensive.
00:58:36.500 - 00:59:37.192, Speaker A: This is the simplest answer to this question. Okay, going forward now it's time for you to try playing around with this code. I have a task for you and I'll give you a couple of minutes to code your solution. So the task is to modify add points function. Right now it's not verifying the student parameter, so it is totally possible to add students to add points. For students that are not members of the course, the task is to add the validation. You can use any syntax features that I presented so far and you can do it in any way.
00:59:37.192 - 01:00:28.774, Speaker A: And I'll give you a couple of minutes. And let's say that if someone is done, please write on chat. You can also ask questions. I'll answer them and the first person who will finish and will be willing to show their solution is invited to share their screen. So yeah. If you are done, please raise your hand and we will ask you to the stage where you will be able to share your screen. I have a question here.
01:00:28.774 - 01:01:34.650, Speaker A: I missed some of the setup. Which environment should we use? You should use the first environment, JavaScript virtual machine. This will run the implementation on Ethereum JavaScript that I mentioned, and this comes with those accounts with ether available for you to use. I'm getting the following error creation of course error error encoding arguments expected array value Mm, okay, when you are deploying the smart contract, the first argument, which is name, can be like any string that you provide. And the second argument is an array of addresses. You should use exactly what I copied on chat. So an array of addresses looks like an array.
01:01:34.650 - 01:03:04.732, Speaker A: In Json you have a square bracket with square brackets with two elements inside, and those are strings, so they need to be inside. I don't know, what's the name of it? Asterisk. No, I forget the english name for those things. I managed to get my solution ready. Let's use some of the nice features of this airmet platform. I'll try to create a vote whether you need more time or not, because I'm still waiting for someone to volunteer to share their screen and show the resolution. Let's see, it used to be almost all no, but then we get some yes.
01:03:04.732 - 01:04:42.340, Speaker A: So I guess I'll give you more time, even though more people don't want to wait. Let's see, I'll give you three more minutes, and if no one volunteers, I'll show you the solution around the use of a modifier. Yes, you can use a modifier to do this validation. Ah, you may not remember, but you can also pass an argument to a modifier. So a modifier has an arguments list, and you can easily pass an argument of a function to the modifier invocation. So we'll say, by the way, do you see the results of the poll as well, or only the speaker does it? Okay, so the results were that 31% of people said yes, no more time, and 69 said no more time. But I'm still hoping for a volunteer, so oh, even more yes answers.
01:04:42.340 - 01:05:46.540, Speaker A: Let's see the answer, because we have many people waiting for it. Okay, so this is how I implemented it. What changed is that I added only student modifier, and also I added student exists function. So we get a student as an argument, which we pass to only student modifier. Then inside of this modifier I added a require statement which says require that student exists. If not, throw student does not exist and student exists is a getter. You can see that it's a view method so it doesn't modify any state.
01:05:46.540 - 01:06:43.882, Speaker A: In this solution you loop over the array of students, and as soon as you notice that the student exists in the array, you return. You don't iterate further. If after the iteration none of the if statements were true, you return false because the student doesn't exist. So this is my solution. I always like to extract stuff, so I thought that this student exists could be used by someone else. That's why I extracted it. And also I'm using it in this modifier, which looks nice on this method.
01:06:43.882 - 01:07:31.920, Speaker A: Of course I could just simply write this as a first line of this function. But hey, why not use modifiers if we have them in solidity? I see someone saying that they had the same solution but couldn't make it run. I'll give you one more task. If you have any problems with compiler errors, feel free to complain in the comments section. But before I do that, let's see our code in action so you can use this trash button to remove the deployed contract and deploy again. If you pressed autocompile, you don't have to press compile here, it automatically compiled. I'll choose again the first account.
01:07:31.920 - 01:08:13.046, Speaker A: Then in this constructor I will specify the same arguments as before copying it from your chat. And I deployed it. And then let's see, I'll try to call points for a student that doesn't exist. So first let's see what student exists. Student zero is this address. Student one is this address and the teacher is this address. Let's add points for teacher.
01:08:13.046 - 01:08:51.220, Speaker A: He isn't a student and yeah, let's do it. Points for teacher. If we expand here, we will see transaction log and the last transaction has this red cross which tells us that there was an error. Student doesn't exist. So my solution worked. Let's try adding points for an existing student. It worked.
01:08:51.220 - 01:09:51.180, Speaker A: I get green tick and let's now query the mark. After adding 50 points for a student, he should get free. Mark free because he got 50 points so far. Yeah, and we see mark free. Here's. Okay, I got some questions. Is it possible to just add this piece of code to add points? And then here's a loop for ranging over students? Not really, because what you're doing here, remember that require throws an exception when the condition is not met.
01:09:51.180 - 01:11:10.190, Speaker A: So let's say that you have two students and you're adding the points for the second student. In the for loop you first run the comparison between current student and the student that you got as a parameter, and you can see that the first student is not the second student that you got as a parameter and the require is not met, it froze and the function doesn't work. So no, you cannot use require in this for loop creation, of course. Error error encoding arguments argument null invalid arguments I guess you forgot to add arguments in the constructor. Let's say if I can reproduce your error, if I don't set arguments here in this deploy section, if I emptied it out and I think I got the same error expected array value. Argument null value. Yeah, that's why you got the error.
01:11:10.190 - 01:11:35.050, Speaker A: Remember to paste here what I posted on in chat. I'll post it again. No, that's not it. Sorry. Ah, this is it. The array needs to be supplied. Okay, let's run another task.
01:11:35.050 - 01:12:36.300, Speaker A: Two, we have a problem with add points function. The problem is that in blockchain you pay something called base fee for every transaction. So even before your code runs, transaction already burns some fee, some gas. This is paid for every student. For every student that you want to add points. Why not create a method that takes an array of students and an array of points and adds those points in a loop? So this task is as simple as it make at points function. Take two arrays of the same length and add those points for those students.
01:12:36.300 - 01:13:30.850, Speaker A: Again, I'll give you some time, and let's hope just this time someone volunteers. I got a question. Why not use a mapping if you mean passing a mapping. Yeah. Instead of two arrays, if you mean passing a mapping as, as a parameter, you cannot do that. This is the only. Yeah, you cannot pass a mapping as a parameter to a functional.
01:13:30.850 - 01:14:29.768, Speaker A: It used to be this way that you couldn't even pass a struct as a parameter to a function. There is like a new version of something called ABI encoder in newer version of solidity. It's enabled by default. The latest version of solidity actually allows you to pass a struct in a parameter which was not possible before. Let me, yeah, I'll share my solution right now. So if you still have some time, let me quickly code it. Okay, so we want to get two arrays.
01:14:29.768 - 01:16:15.020, Speaker A: Let's first change the parameters, and now we need to do addition in a loop. For that simply let's create a loop it. Before I loop over, I should check that the lengths of the arrays equal, not introduce a bug in my code. Now I need to check that a student exists before I add students for him. So I require that current student it actually exists if not, I throw the same error as before. Student does not exist. And because I now have multiple students, I'm getting rid of the only student modifier.
01:16:15.020 - 01:17:25.710, Speaker A: And now I'm adding students for adding points. For the current student in the loop, I get a compiler error saying that the location of array should be memory all call data. This is what I mentioned on my presentation. You have free places where you can store data for this. I use call data because I don't have a need to modify this parameter. Yeah, this solution should be working if you want to look at it yourself. I'll create a gist and quickly right now and paste a link to it.
01:17:25.710 - 01:18:40.800, Speaker A: Wait a second, I need to do it in a different browser. When I'm logged into GitHub, I'm posting the gist solution in the chat because we need to finish. I'll quickly show you another task that you can do as a homework to learn more about solidity. And I think it's nice to have something to practice with homework. So I mentioned before that mappings in solidity don't provide iteration. So as a homework you can try implementing an iterable map that has the following methods. You can set a key, you can get its value.
01:18:40.800 - 01:19:38.698, Speaker A: You can get a length of the mapping which returns the number of elements you added to it. And then after you get a length, you can iterate over the elements with at method. So you will call the at method this many times as your array's length. So if you have a mapping with three elements, you will call method at three times to get all of the elements. This is my proposal for you. I think we'll post it on discord. So Mateosh, if you're still with us, if you could paste a link to the discord channel on the chat, and after that, that would be it from my side.
01:19:38.698 - 01:21:10.490, Speaker A: Thank you all for your attention and I hope you enjoyed this presentation and workshop. The last question can we display the address of the student? How can I concat address to student that exists? This is a bit tricky. Again, in solidity you don't have methods for string operations, so you don't have a nice method for concatenating a string to a literal, for instance, or making concatenation of the strings. This is caused again by this idea. That programmer should be aware of what he's doing, so you can do it yourself. You can create a loop where you yourself write to a dynamic array creating this concatenation, but then you are really aware of what you're doing, of all the loops that you are introducing, which are money, because every computation costs gas, and in return it costs fees that we pay to the miners for our transactions. And I think this is one of the rationale behind not creating such methods in solidivity.
01:21:10.490 - 01:21:41.350, Speaker A: Thank you for your comments, and again, thanks for the attendance. You, you. Yeah. I hope to see you tomorrow on other lectures. On other lectures in our series. Thanks again. Bye.
