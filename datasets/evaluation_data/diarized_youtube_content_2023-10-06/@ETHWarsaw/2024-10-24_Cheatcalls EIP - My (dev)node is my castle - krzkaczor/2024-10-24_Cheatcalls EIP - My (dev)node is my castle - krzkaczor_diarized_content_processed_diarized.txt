00:00:03.160 - 00:01:13.725, Speaker A: Hi, I'm Chris Kachor and today I wanted to talk about Ethereum development nodes and Ethereum improvement proposal that we've been working on. So first few sentences about me. So I guess one could say that my hobby is working on dev tools. So some time ago I created pretty popular tool called type chain which provides provided because now there are better tools but it provided years ago like a reasonable type Safe interface for TypeScript developers interacting with Ethereum smart contracts. I also created Dev Node which, sorry devcode, which allows to browse deployed smart contracts in Visual Studio code directly from Etherscan. I co founded L2 bit so I worked on layer 2s and now I'm back in Defi ecosystem working on Spark Dao which is part of sky, which was previously known as Makerdao. So I'm working at Phoenix Apps.
00:01:13.725 - 00:02:08.463, Speaker A: And yes, before we talk about Ethereum nodes development node development nodes, I wanted to talk about Ethereum mainnet nodes. So what happens when there's a new block on mainnet? So what happens is that there's a ton of different checks, basically the consensus rules. The Ethereum node makes sure that the new block follows the consensus rules. So for example, in the block there's a list of transactions. So we make sure that all the signatures are signed properly by the sender. Then the transactions are getting re executed and the state in the block is asserted against the state that was the outcome of the execution. There's lots of different checks for balance.
00:02:08.463 - 00:03:07.629, Speaker A: Did someone send the eth that actually existed? Right. Then there are proof of work, proof of stake checks and turns out that when we develop smart contracts we don't care about any of that. Like when we develop smart contracts it's very important to be able to put the state, the system that we test in a certain state. So that's why sometimes we need to mint tokens out of thin air. Like obviously this wouldn't be possible on Ethereum mainnet a node but this is very useful when you develop and test your smart contracts. So for example, in Foundry we have this notion of cheat codes which allow us to basically violate the consensus rules of the virtual machine. So for example, we can warp the time which means moving the block timestamp that we are currently operating on.
00:03:07.629 - 00:04:06.425, Speaker A: So this is useful when our smart contracts has some kind of, you know, locking mechanism that something happens only after a certain date, right? So we can do that. We can deal tokens, which means like mint tokens out of thinner. It applies both to ERC 20s and like native token balance. Like if Then finally we can prank accounts. So this means that we impersonate an account which we don't know private key of. So this is extremely useful for things like for example, you have an Oracle and you want to push new price, you just impersonate some kind of relayer and you interact with the Oracle contract as you are its owner. So you know, we do things like this in test environments and every single test environment that allows to, you know, write tests for smart contracts has some similar notion of cheat codes.
00:04:06.425 - 00:04:56.413, Speaker A: Now finally, let's talk about development node. So by development node I mean a simplified version of Ethereum node, which is not like fully capable of mining or following even some of the more fully verifying even the main net blocks. But it's more suited for development needs. So you know, obviously it has the same virtual machine, but some of the corners were cut, let's put it like this. So I'm talking here about things like unview part of the Foundry or hard hat network. So these are the most popular like local nodes. There was also ganache or OGs out there.
00:04:56.413 - 00:05:59.815, Speaker A: Like this was kind of like older node out there. So these are local development nodes, the ones that we run on our machine. But they're also similar tools run in the cloud. So things like Tenderly or Build pair, they basically do the same thing, but they get you like a shareable RPC link that you can send to your co workers or and basically they see the same state. So these are pretty useful tools and basically what are the exact use cases? So first of all, all of these tools allow us to fork mainnet. So instead of starting with a clean empty state of this development node, we start from mainnet from a certain block and we just keep on adding our own blocks on top of that. So this is awesome because we have access to every single contract that was deployed on mainnet and we just keep on, you know, building on top of that.
00:05:59.815 - 00:07:26.239, Speaker A: So in Spark we use quite heavily different development nodes. So for example, where we test, when we test governance pairs. So governance pairs are basically a governance pair is a smart contract that is being voted on by some decentralized autonomous organization governance system that after it's voted on, the smart contract can change basically this decentralized protocol. So it introduces some changes to the defi protocols, for example. So we write these governance pairs and we have this bot in the repository with the governance spells that executes every single spell in like this tenderly basically in like you know, sandbox and then it gives us a link to front end with, you know, changes from the spell applied. So this allows to you know, see how this spell is going to impact like our, you know, the user view of the protocol. So this is kind of useful and allows us to catch like quickly some you know, problems with the UI and basically like you know, visually inspect the state of the protocol after we execute some governance.
00:07:26.239 - 00:08:31.865, Speaker A: But the other thing is that we have a ton of tests. So both like end to end tests for the front end but also some integration tests for backend System. They use Standardly2 or could use something like Anvil. But basically these development nodes allow us to test the integration between smart contracts and some other components of the broader system. And we also have a bunch of these end to end tests using tender. So development nodes similarly to testing environments, they're pretty adjustable like they are this special JSON RPC codes that allow us to do similar things that with cheat codes in Foundry. So things like we can use hard hatsetbalance to change Ethereum balance of a certain account in hardcut node or there are like unview specific cheat codes.
00:08:31.865 - 00:09:30.713, Speaker A: So the problem here is the lack of standardization of this special JSON RPC code. So some of these methods only exist in one of these development nodes. So for example there's this extremely useful thing called set ERC20 token balance which I again mentioned, I mentioned that it even exists in Foundry but it doesn't exist in and so if you want to quickly set like Mint ERC20 tokens out of thin air, which is by the way not trivial problem, we're going to talk about it in a second. Like you cannot do it easily on anything other than tenderly and build back. So this is like very painful. Then again if we use tenderly then on the other hand EVM set next block timestamp doesn't work as it should. So we're going to dive into in a second what this method exactly does.
00:09:30.713 - 00:10:10.923, Speaker A: But basically the behavior between different development nodes differ. It's not standardized. Furthermore, like you know, these methods have different prefixes, some of them don't exist in different nodes. So all of this results in vendor locking. You start using one development node, basically you cannot switch to other development node because you're already using some, you know, specific features of a given software and on top of that documentation just doesn't exist. Like it's funny because like years ago Ganache figured out some of these cheat codes. They implemented them like this.
00:10:10.923 - 00:10:49.507, Speaker A: Not cheat codes but rather like special JSON RPC method. We're going to have a better name for that in a second. And they introduced them, they didn't elaborate and people just use them. Up to this day and no one still wrote any documentation about exactly what happens, because some of the behaviors like edge cases are totally not trivial. So the solution is Chitco's Ethereum improvement proposal proposal. And of course there's obligatory X ACD on this case. Luckily we don't have 14 competing standards.
00:10:49.507 - 00:11:29.137, Speaker A: There is basically zero standards around that. So maybe we're going to be more lucky with introducing this change. But basically the idea is to normalize this interface for quote unquote special JSON RPC methods. And we simply call them cheat calls because they are like cheat codes. But you call them, you call the method for the nodes. So basically as I described it follows this mantra of My development node is my castle. You should be able to do whatever you want on your own development node.
00:11:29.137 - 00:12:21.395, Speaker A: You should be able to put it into certain state to test certain scenarios and the software should help you with that. We use standardized cheat prefix and basically on the right you can see bunch of example cheat calls. We're going to get to them in a second. But what's pretty cool is that we want to have not only written spec, but also tests for that spec. So we can really have automated tests if is this node conforming to the spec. And this is all pretty work in progress. This is the first time I talk about it publicly, so things can change, but we're going to talk about it at the very end.
00:12:21.395 - 00:13:17.907, Speaker A: So let's go through some of these cheat codes. So for example, time management, I already mentioned that, you know, so like generally speaking we don't reinvent the wheel here, we just rather standardize things that exist in one way or another. So for example here cheat increase time. It's like EVM increase time but it's like properly documented at with tests. And then we had this another thing cheat set next block timestamp. So here the idea is that you code this and it doesn't mine new block but when you send some kind of transaction that makes a development node to mine new block, then this block is going to have the timestamp that you wanted it to have. So this is very important when you do some deterministic tests and basically like, you know, it allows you to write very deterministic tests.
00:13:17.907 - 00:14:09.005, Speaker A: And the problem here is that developers of different development nodes without any docs, they needed to figure out what this should do and guess what, they don't agree exactly on the details of what it should do. So for example, on Anvil it more or less does. I mean, it does what is described here. But for example, tenderly it does ping slightly in a different way. And in some other development node it doesn't exist at all. I'm talking about EVM set next block timestamp, right? So here we try to standardize that. Oh, and also, by the way, you can call this the same cheat with null and then you unset this value, which is sometimes useful.
00:14:09.005 - 00:14:57.003, Speaker A: Then we have a bunch of cheats to have a proper mining control. So you can call cheat mining mode to set a mining mode. So for example, you can use auto, the mining mode, which is default, which means basically with every single transaction you mined a new block. This is the default behavior for something like unveil. Then we have manual mode, which means that you need to explicitly call cheat mine to mine new block. And there's like ordering of the transaction in the mempool. So basically a node maintains a mempool and you can specify if the mempool should work like first in, first out, or order transactions by fee.
00:14:57.003 - 00:15:43.135, Speaker A: So this is what mainnet nodes usually do. And then finally it's like interval mining. So kind of similar to mainnet where you specify some interval and ordering. So all of these are extremely important and useful when you want to test some weird scenarios where you send transaction, but there's a network partition happening and the transaction never gets to actual mempool and gets dropped. So we can use cheat drop transaction to drop your transaction from the bamboo before you mine a new block. So you can, you know, test all of these weird behaviors and see how your, you know, back end system or front end system behaves. Then we have snapshots.
00:15:43.135 - 00:17:15.458, Speaker A: So this is more or less the same as already exists in development node. So we have cheat snapshot which creates a internally like a dump of the whole state of the of the node and gives you an ID representing that dump and then you can revert to that snapshot. So this is very useful when you do some costly, time consuming initialization of some smart contract system like, you know, deploy a bunch of smart contracts, send some transactions to set some admin rights or whatever, and then we get to cheat codes about impersonation. So basically it allows you to act as a address that you don't know private key of. And here we're like debating like, should we support impersonating a single account, which is the case for many development nodes now, or it's just easier to impersonate all accounts. Like from my experience, impersonating all is just much more Useful because you don't need to worry about like you know, impersonating every single account that you want to impersonate. So yeah, this is like open question, should we re add this like singular impersonification? And you might be wondering how does it work under the hood? You know, when node knows if it should impersonate an address or it shouldn't.
00:17:15.458 - 00:18:16.745, Speaker A: So basically the client side code executes different JSON RPC methods when you send transaction with a private key or don't. So this is something that you need to configure is something like vm. Like for example, when you don't know the private key, you need to configure it slightly different. And then it sends, I think it's called if send transaction call, which sends information about the transaction in a JSON form, like an object with few fields. But on the other hand, if you have a private key, what happens under the hood that the client side library is going to sign the transaction and it's going to send a signed blob using a different RPC method. I think it's called if send sign transaction or something like this. So basically this is how node knows if you wanted to impersonate an address or not.
00:18:16.745 - 00:19:07.225, Speaker A: And then with cheat calls you should be able to do introspection on the state of the node. So like we have this meta cheat call called cheat info which returns basically the state of the other cheat codes. Like, you know, are you impersonating go accounts or did you set the next block timestamp? All of that. But also what's interesting, it returns like a version of the spec that node follows. So this might be useful to realize, you know, what's available, what's not. But also it returns bytecode verification info. So here like if you were ever, you know, verifying smart contracts on testnets or on Mainnet, like, you know that it's like pain in the out.
00:19:07.225 - 00:19:57.319, Speaker A: And one of the reasons that it's more difficult than it should be is that you don't know which URL you should actually send the, you know, request to verify your bytecode. So here we could return that information directly for the JSON RPC interface to make this process automatic. So yeah, this is like, you know, DX improvement. Then finally we getting to the more powerful cheat codes like setting balance and storage management. So setting the balance of Ethereum accounts is like pretty straightforward. You just provide address and balance that you want to set. But also we want to support set ERC20 token balance.
00:19:57.319 - 00:21:08.088, Speaker A: So minting tokens of minting basically arbitrary ERC20 tokens, which we're going to talk about in a second. So this is like best effort implementation because it cannot guarantee this in any case because we don't know the exact implementation of the ERC20 token. It's just like interface standardized, but with the other code, with the other cheat code called set storage add, we can basically manipulate any storage slot that node has. And now let's go on a tangent and talk a little bit about how we can actually implement this set ERC 20 token balance. So like, you know, just a reminder, like this is a standard, so we don't say exactly how it should be implemented, we just specify the behavior. But this is I think, the best way to implement it. So the problem is that we want to tweak basically an arbitrary storage slot, but we don't know which slot holds a balance of a particular user in a particular ERC20 token.
00:21:08.088 - 00:21:47.725, Speaker A: So in EVM, storage is just like a huge map of Uint 256 to Uint 256. Basically any slot in this map can be set. So how does it work under the hood if you have a solidity contract? Basically solidity follows this rule that it every single property in your smart contract has an index. So for example, here. Oh, here. No, it doesn't work. No.
00:21:47.725 - 00:22:36.201, Speaker A: Okay, I'm not going to try to use the pointer here. But basically at the bottom of the screen you see total supply, which is a first property in this contract. So it has index zero for, for simple types like uints or basically scalar types. This index is a storage slot index that compiler is going to write and read from. So basically if you would read the storage slot of a zero index, we would get a total supply in a raw unparsed form. But then it gets more challenging with mappings. So mappings like all of these properties have increasing indexes.
00:22:36.201 - 00:23:23.031, Speaker A: So the index of balance off is like one. But of course we wouldn't be able to put all the balances of all the users into one slot u256 slot. So what happens under the hood is that compiler takes an index of this variable and it takes keys in the mappings and hashes them together. And this is the storage slot location. So it's like seemingly random slot in the whole storage layout. So now we need to figure out how to guess this slot. And keep in mind that balance off here is just a simple getter.
00:23:23.031 - 00:24:07.755, Speaker A: Right? But it could be like a function that does a bunch of checks reading from storage locations different Slots. It could also read a balance of some different token and for example, multiply it by some constant or variable, whatever. It can have arbitrary logic. So how to deal with that? So the idea would be to trace this balance of reading. Tracing means basically like inspecting the state of the virtual machine for every single opcode. So here we could find opcodes that read from storage, from Ethereum storage. So these are like slots.
00:24:07.755 - 00:25:17.605, Speaker A: We could find like a list of them and basically iterate through them. And we would see that, okay, this slot accesses some storage slot and we put there a random value and we redo the whole thing, we recall, balance off and see if that random call, if that random value gets returned. And with this approach we could actually find the storage slot that should be balanced if it exists, because it could happen that it doesn't exist because it's multiplied by some constant. So this is like best effort implementation. But in practice this is what Forge actually does under the hood when you do deal with ERC20 token. So this is actually very interesting that this algorithm can be expressed in solidity using some cheat codes in foundry to access list of hot storage locations. So this was a tangent, but basically this is how you can implement under the hood some of these cheat codes.
00:25:17.605 - 00:26:33.085, Speaker A: And what's the status of this whole thing? So this is very early on, like we're talking with hard cut teams and Billboard teams and I'm also reaching out to Fangie and tenderly so we can agree on the shape of the standard and hopefully, you know, make it, make it work. You're all invited to get involved. There's going to be some, you know, Rust work because turns out that now every single development node, open source development node is written in Rust and, and you know, I'm thinking that this is kind of challenging problem because it's like, you know, coordination of different teams that don't necessarily want to talk with each other. So I'm not sure if we're going to succeed with that. But the worst case scenario is that we're going to implement the missing cheat calls that are present in closed source software, but are missing in open source software like Stat, ERC, 22nd Balanced. And worst case, it's going to be still unstandardized, but at least it's going to be less unstandardized, which is now which I consider a win. So that's it.
00:26:33.085 - 00:27:01.015, Speaker A: The EIP is open source. It's like, you know, draft, it's not submitted to the forums yet, but you can find it on GitHub or just scan this QR code to get it. You can reach to me on Twitter. Reach out to me on Twitter. It's karx and that's it. Thank you. Chris will be around if you have any further questions because we're going to dive in.
