00:00:08.900 - 00:00:09.256, Speaker A: Thank you.
00:00:09.278 - 00:00:39.570, Speaker B: Yeah, thank you for having me. So I'm Luis, working with Shadow Network. It's a project incubated by Brainbot, which is an older sort of software development company in Ethereum space. And I'll be talking about Mev user impact that Mev has. And then later also talk more in practice of how we can maybe help mitigate it by encrypting the mempool and encryption. Yeah.
00:00:40.340 - 00:00:41.090, Speaker A: Okay.
00:00:43.780 - 00:00:52.276, Speaker B: So maybe to preface, we really like, we love base layer neutrality and we love sustainable market architecture.
00:00:52.308 - 00:00:52.504, Speaker A: Right.
00:00:52.542 - 00:01:21.772, Speaker B: And this prefaces what I'll be talking about and maybe to say something as well as also we think that it relates to accessibility. So if your base layer is neutral and if your base layer treats everyone the same sort of, and there's information symmetry, then we think we can increase accessibility, which is sort of, I think, a really important goal for everyone working on chain.
00:01:21.836 - 00:01:22.450, Speaker A: Right.
00:01:23.460 - 00:01:48.224, Speaker B: Maybe a little more on this, on this problem solution set is I think in the recent years, mainstream and regulation has really been hostile towards crypto. I think the perception is that it's really an unsustainable market environment from the outside, people don't think it is intransparent, even though we're all about transparency.
00:01:48.272 - 00:01:48.400, Speaker A: Right.
00:01:48.410 - 00:02:54.488, Speaker B: But from the outside it looks hostile and really sort of all these ponzies front running, just not a nice marketplace from the outside. So again, I think via based neutrality, via sort of increasing accessibility and a more sustainable market architecture, hoping to get back, to bring this back and to bring back mainstream appreciation of crypto. More specifically, before I was talking about the more general topic of crypto is broken and hostile. But what we are more about is sort of this transaction supply chain, and we think it's in a bad state in general. So we think it really front running, malicious MEV causes this measurable direct user losses. The larger issue behind this, though, we think is it deters new entrants or deters serious investors from entering the market. And indirectly by sort of quick fixing the MEV and transaction supply chain, we are creating these centralization vectors.
00:02:54.488 - 00:03:35.112, Speaker B: So we're fixing it and we're mitigating some of the issues. But usually we fix it in a way where we're then adding another intermediary and someone which then can censor again or can, it's a centralization force entrenching these actors. So that was just the motivation. But maybe taking one step back is maybe people are not familiar what is front running and what is MeV. So front running is very simple as you're jumping the queue. Essentially you have some information advantage. You jump in front of another person's trade and you steal that person's trade, thus sort of harming that other person because that person's getting a worse price.
00:03:35.112 - 00:04:08.710, Speaker B: MEV is sort of the umbrella term, it's called maximal extractable value. And front running is just one part of this. So there is actually also non front running related MeV. So we're generally speaking about back running related MEV arbitrage liquidations, and those are generally considered to be benign neutral. So we are not even want to get rid of this, essentially. And one thing to note, the front running is illegal in the real world. In crypto, it's considered harmful and detrimental to user experience.
00:04:08.710 - 00:05:31.408, Speaker B: So as I said, we're first sort of talking about the MEV user impact. And the way we are talking about this is my colleague Yannick built this model to simulate the user impact on user trading performance, simulating based on different transaction ordering strategies. So what do we want to show here again, how do various transaction ordering strategies impact the user performance? Which one is the best? The quote unquote best? And one thing to note is caveat or disclaimer, it's really a very simple model and just consider it more like a mental model of how it works, rather than a real world sort of like CADCAD simulation of what would actually happen. So what's under the hood is the assumption is there's just one amm with one single pool. Users are buying and selling prices moving up and down, and the sequencer can either sort of reorder arbitrage or inject their own orders. So yeah, that's this model. First, the first strategy, transaction ordering strategy would be a random ordering, fully randomly ordered, which is unrealistic because people do see these arbitrage opportunities and they will.
00:05:31.414 - 00:05:32.416, Speaker A: Try to exploit it.
00:05:32.518 - 00:05:43.876, Speaker B: But in this case, there would be zero user loss, which would be nice. However, also the price would be maybe not really true to the market price because this would be very random, sort of.
00:05:43.898 - 00:05:44.324, Speaker A: Right.
00:05:44.442 - 00:06:23.170, Speaker B: Again, not really realistic because you have people looking for arbitrage opportunities. This next strategy would be the random ordering, but there is arbitrage. So the sequencer can take an arbitrage opportunity after every block. And we see, the interesting part here is there's a lot less user loss. So you're seeing sort of the user loss. There is a minimal user loss compared to the first one. However, the price is more true to the real price.
00:06:23.170 - 00:06:56.220, Speaker B: It's fluctuating less. And we have a comparing it to random ordering. But then there is an arbitrage after every transaction. So before we had after the block here, it's after every transaction. This significantly increases the user loss, and the price is slightly more close to the real price. And it's pretty inefficient because we have these back running transactions after every order. So it's kind of inefficient.
00:06:56.220 - 00:07:56.236, Speaker B: And there's more user loss. This one is one step even more. Sort of the sequencer is trying to really maximize the back running, so he's arbitraging after every block, but he's also reordering transactions to again maximize his profit, which that increases user losses a lot more again. And then the price is going to be always the same, sort of, and this one is the most extreme form of the sequencer sandwiches. Every single trade, the front runs and back runs, essentially, and that really maximizes the user loss. So that's something I think everyone sort of agrees we don't want this, right? And then I would say, generally speaking, people maybe are somewhere on the spectrum of somewhere in here where they think it's ideal. And sort of our takeaways from this.
00:07:56.236 - 00:08:38.644, Speaker B: We think sandwiching again is the most detrimental strategy. And even simple reordering can actually have impact and a negative impact. So what we're sort of looking at a little bit is we think that the random ordering with arbitrage version, so it's, this, we think is the best trade off. So that has the price is pretty true to the real price. We have minimal user loss, so we have arbitrage, we have no front running. So we think this is sort of, as we currently look at it, it's probably the best kind of trade off, right? Yeah, just some caveats. The model is pretty uninformed, random.
00:08:38.644 - 00:09:36.264, Speaker B: There's results in a zero sum model. We were assuming this maximally simplified world. And it's just illustrative, I think I said this before, but sort of taking this and saying, okay, maybe this strategy, maybe some variation of the strategy, is probably the best outcome for everyone, for the health of the marketplace. With this in mind, we think we can create a more Mez where protocol infrastructure, and especially sort of one, an example of this that we're working on, what we call shutter, is this encryption of the mempool. So it's a threshold encryption technology to encrypt the mempool and prevent, especially front running. How does it work? So transactions are encrypted, batched and signed while still encrypted. So the block proposer cannot see what's in the transactions.
00:09:36.264 - 00:10:16.468, Speaker B: So they can't really censor or front run. And then we're using threshold encryption to remove the need for trust and to decentralize the encryption decryption role. So we have these keepers that are running the DKG. They are collaborating to generate encryption keys and then decryption keys. And that plugs into other protocol infrastructure. So we have to, ideally it needs to deeply integrate with a blockchain or roll up, and it needs to be a protocol level change. But if we do this, if we encrypt the mempool again, then the sequencer or block producer can't really see what's in transactions, can't front run.
00:10:16.468 - 00:10:52.760, Speaker B: And we think this really results in this quasi random ordering with arbitrage. As I said before, this is probably the most attractive strategy. And generally speaking, this increased information symmetry, we think, leads to these direct benefits for users of safer trading. No front running. If you get front run less, then you also get better prices. So you just have a more profitable trading experience, essentially. And we're adding this type of real time censorship resistance because, yeah, if you don't know what you're sort of committing to, you can't really censor based on the contents of the transactions.
00:10:52.760 - 00:11:30.176, Speaker B: So these are the benefits for users. But you could argue that there is kind of the validators or sequences, they're getting restricted, right. They now have to commit to shielded or encrypted transactions. So in a way they're restricting themselves. You could argue that they actually have less power and they can extract less mev. However, we actually think there is also some benefits for them. So one is really this image and sort of the positive image you're projecting and saying this infrastructure, this protocol, is actually a more safe and healthy trading environment.
00:11:30.176 - 00:13:06.000, Speaker B: We think that could really have the benefit, again, bringing back in more serious and more mainstream investors, and then also, then by this, increasing the overall revenue again, the other benefits, we think are really sort of in the realm of regulatory benefits a little bit. So if you can front run, if you can extract mev from the outside, this looks a little bit more like a financial intermediary, because this power is like an unnatural power. And if you're arguing with a regulator, how should you be regulated as a validator or as a sequencer? Ideally, you want to make the case that you are a purely technical provider and not a financial intermediary who can extract value, right? So we think by being able to argue that there is no way for you, even technically, to extract front running related mev that then you have a better argument of plausible deniability of saying, okay, well, we couldn't even front run, so please, we should be regulated like a technical provider rather than like a financial intermediary. And we're seeing actually some regulators around the world, Mika and Bank of international settlement, they are making statements towards also making front running illegal like it is in tradfi, also making it illegal for crypto in general speaking. The sequencer especially can still collect and distribute back running related mev. So there's still this arbitrage aspect to it. Shutter.
00:13:06.000 - 00:13:51.616, Speaker B: We're working on different integrations, so shutter itself is finished, the DKG, but we are implementing it into different other protocols. So the one that is actually already live and providing shielded voting, running live is in snapshot, which is there. It's actually not the MEV use case, but we're encrypting the real time results during the vote, which we think that helps with information symmetry. And we have over 200,000 shielded votes cast and this is just chugging along. I think it's working very well. Snapshot and we're thinking that this is actually the more natural and more the normal way of voting to have a shielded, shielded voting. Then what I'll talking about more detail later.
00:13:51.616 - 00:14:31.144, Speaker B: We're currently working really with the gnosis chain to implement it into the gnosis chain. And we're also working on this essentially optimism grant to explore how to implement an encrypted mempool for pstack based rollups. And there we have the requirements and architecture ready. And just sort of next steps would be actually building it for the. Yeah, and the shadowized gnosis chain, again, is this collaboration with gnosis chain. They have very similar vision on this. Martin is talking about this frequently on Twitter or in interviews.
00:14:31.144 - 00:15:41.648, Speaker B: And yeah, all the benefits, I said before, more neutral base layer censorship resistance, MEV front running resistance. That's what this is about. We have this practical kind of accelerated roadmap where we first build it as an opt in kind of soft fork variant. And yeah, we think that it'll be a nice sort of first example and reference implementation of this idea which then can be looked upon by other and copied by other l two s or ethereum, even ethereum l one itself. Roughly speaking, this is sort of our technical architecture, roughly explaining how it works is the keepers generate first this eon key, which that is broadcasted to the passed on to the key broadcast contract. The users are using this key to derive individual transaction encryption keys which they use to actually encrypt every single transaction. In our current design, they pass on these encrypted transactions to the sequencer contract.
00:15:41.648 - 00:16:38.644, Speaker B: That's where they sort of are just deposited. Proposer listens for those transactions and then uses them to then ultimately build the block and propose the block. And something I forgot to say in between is essentially by sending it to the sequencer contract. That's what fixes the order of the transactions in place by them being in the sequencer contract that says, okay, now they are in this order, do they need to be executed? And this is a nice way to also separate, saying the proposer no longer really has even the ability to order transactions because the order is already fixed in place while they're still encrypted. And then at the end, keepers generate the decryption keys. Proposer is using the decryption keys to decrypt and then again propose the block. Yeah.
00:16:38.644 - 00:17:11.996, Speaker B: And then the one nice thing is really this eon and key derivation method, which saves the step of not having to generate encryption keys every transaction or every block. So this saves a lot of overhead as well. But yeah, generally speaking, again, we're taking this pretty practical approach, this opt in kind of soft fork approach. There's another sort of little shortcut that we're taking initially, which is that the RPC provider actually encrypts the transactions, which not really optimal.
00:17:12.028 - 00:17:12.176, Speaker A: Right.
00:17:12.198 - 00:17:43.684, Speaker B: Then you're trusting, again the RPC provider. But this allows us just to go to market quicker. And then the next step would be this deeper enforcement of rules and an actual hard fork to be able to slash and everything. Again, collaborative effort working on this, in this try sort of setup with Nethermind team and the Gnosis team comparing it to other approaches. So this is not the only way to encrypt the mempool, or the only way to sort of introduce some kind of front running protection.
00:17:43.732 - 00:17:44.136, Speaker A: Right.
00:17:44.238 - 00:18:37.144, Speaker B: Some other alternatives are to just have the RPC protect against MEV on the RPC level, which, good quick fix we would say. But then again, what I said in the very beginning, we are introducing this reliance on centralized intermediaries and introducing another censorship vector and trust vector centralization vector. So not really a long term solution in our opinion. You can use things trusted execution environments like SGX, but yeah, you're trusting then a little bit in a chip manufacturer. And there are vulnerabilities with this. There's other approaches using verifiable delay function sort of type of approaches which that would then require these custom asics. And there's also some design challenges because that's really a time sensitive thing.
00:18:37.144 - 00:18:41.036, Speaker B: And yeah, again, this is hardware, a little bit of a trust in the hardware there.
00:18:41.058 - 00:18:41.630, Speaker A: Right.
00:18:42.000 - 00:19:00.032, Speaker B: Super interesting. And something we're looking at quite closely is MPC fhe, this really advanced type of cryptography, which would ultimately have the ability probably to make everything encrypted and just operate on encrypted transactions. And then we can solve everything.
00:19:00.086 - 00:19:00.256, Speaker A: Right.
00:19:00.278 - 00:19:22.516, Speaker B: And also solve privacy and everything. But that's really not really practical right now. It's not cost effective, not even close to be cost effective. But yeah, super interesting to look at in the future and maybe incorporating small parts of it, of MPC. For example, in effect, the threshold encryption approach at shutter that we're employing is a very simple one specific instance of MPC.
00:19:22.548 - 00:19:22.696, Speaker A: Right.
00:19:22.718 - 00:19:34.104, Speaker B: So we are on that track already. So I talked about the shutterized gnosis chain, which is this implementation for an l one, or like a beacon chain type of ethereum chain.
00:19:34.152 - 00:19:34.652, Speaker A: Right.
00:19:34.786 - 00:20:59.204, Speaker B: But we're also, again, building it for l two s. And in addition to all the benefits of sensors resistance, front running resistance, in addition to the front running resistance, there's also this interesting way to look at it in relation to the sequencer decentralization roadmaps. So in a way, with the encrypted mempool, you can reap most of the benefits of a decentralized sequencer, which is especially this real time and strong censorship resistance without actually having to decentralize. So this could actually open sort of the ability or the optionality for roll ups to have this alternative sequencer decentralization roadmap. And this setup then we think overall then has actually improved latency because you still have the centralized infrastructure, you still have all the benefits of less complexity and less sort of overhead communication, overhead and decentralization. So we think it could actually have improved latency over this decentralized sequence setup while still being kind of strongly real time censorship resistant. And yeah, again, I said this already, I think the l two sequencers would still have the ability to extract and distribute back running related mev.
00:20:59.204 - 00:21:17.984, Speaker B: So that's not impacted by this at all. And then beyond this a little bit, what we're working right now on is we're also looking into these other hot topics, I would say in Mev, right, shared sequencing, intense ofas, how does an encrypted mempool combine with these?
00:21:18.022 - 00:21:18.224, Speaker A: Right.
00:21:18.262 - 00:22:35.824, Speaker B: Especially super interesting, I would say, in the intense case where initially you would say that an intense based trading narrative is kind of the opposite approach to something like shutter, because in this intense vision, you are revealing a lot of information about your trade beforehand in order for solvers to find a better solution. Whereas shutter, the idea is you're not revealing anything, right, because you want to be protected against that. However, we think it actually works quite well together either. In a way, we think it would make sense to really make it transparent what information you reveal. Right. So being able for the user to decide, I now want to voluntarily reveal information for this part of the transactions, but for this other, I don't. So these combinations and making it more transparent and giving the user the option of revealing or not revealing, but also just later in the transaction supply chain, in the intents based transaction supply chain, you have the issue again, you have then solvers or solver builders creating these matched kind of intents and they're building these partial blocks, right.
00:22:35.824 - 00:23:40.990, Speaker B: And then they don't want to get front run again from other solvers, for example. Right. So then we would say at this point, you probably benefit again from some sort of commit reveal or shutter DKG type of system later in the transaction supply chain and for autoflow auctions, we think it combines nicely. Generally speaking, Shutter reduces the MEV and reduces the front running or minimizes it, and then using OFAs to distribute and kind of distribute the remainder of the MEV. And that's sort of it, again, sort of the gist of it. We're trying to build a more sustainable market architecture, trying to bring more fairness, accessibility to on chain use cases, and especially if you're building a roll up yourself or have a defi sort of front running prone dap, we'd love to get in touch. And again, talking about mev, also more generally speaking about sequencer decentralization, we're super interested in this.
00:23:40.990 - 00:23:51.250, Speaker B: Also, apart from. Also, more generally speaking, apart from the encrypted mempool and shutter. So, yeah, we'd love to get in touch and follow us on Twitter. Yeah, thank you so much.
00:23:56.500 - 00:24:02.150, Speaker C: Thanks, Luis. Does anyone have any questions? We have some more time.
00:24:06.040 - 00:24:11.460, Speaker D: How will you do liquidations and arbitrage if you encrypt the mempool?
00:24:11.800 - 00:24:38.080, Speaker B: Yeah, good question. So, without going into the actual details, the simple way of answering is the way shutter works, or this type of encryption works. It can only prevent front running where it's at MeV, because essentially the easiest way to explain it with the sequencer, the sequencer receives encrypted transactions and the order of the transactions is fixed in place.
00:24:38.150 - 00:24:38.770, Speaker A: Right.
00:24:39.140 - 00:25:13.160, Speaker B: So they can't put transactions sort of before this. But then they are the first ones and they have the order. They have the power then to decrypt and then to put transactions immediately after in a way. So they can then extract all the back running related meV, does that make sense? So they can't front run because the order is in place of the transactions that are there, but then they have the power to put transactions afterwards because they're still the sequencer. They still have the overall transaction ordering power.
00:25:13.230 - 00:25:15.864, Speaker D: But the sequencer does not know what's inside the transaction.
00:25:15.912 - 00:25:16.412, Speaker A: Yes.
00:25:16.546 - 00:25:20.156, Speaker B: Yeah. Well, then they know.
00:25:20.178 - 00:25:20.412, Speaker A: Right.
00:25:20.466 - 00:25:21.016, Speaker B: It's revealed.
00:25:21.048 - 00:25:21.388, Speaker A: Right.
00:25:21.474 - 00:25:46.260, Speaker B: So shutter is a commit and revealed scheme. And then it's decrypted. And the sequencer revealed he's the one who receives the key from the shutter system. And then they're the ones being able to decrypt. They're the first ones who see everything, essentially. And they're the ones who are able then to put transactions immediately afterwards. They can't change the order, but they can then put them right afterwards.
00:25:48.120 - 00:25:53.368, Speaker D: There's defined ordering and they put transactions at the end of the block or something like that.
00:25:53.534 - 00:26:01.640, Speaker B: Yes. Or in a separate maybe. Annie, can you explain on this? Or you don't have a microphone?
00:26:06.720 - 00:26:07.084, Speaker A: Yes.
00:26:07.122 - 00:26:24.930, Speaker E: Basically, after the transactions are decrypted, then they know the state, then they see which arbitrage opportunities are there and which liquidations are possible. And then basically in the next block, in the beginning, they can put whatever they like in there.
00:26:32.660 - 00:26:33.360, Speaker A: Great.
00:26:33.510 - 00:26:35.190, Speaker C: Do you have any other questions?
00:26:40.120 - 00:27:30.804, Speaker B: Does this approach, what does Satter has, does it have any downsides on the obvious downside of being more complex? Does it impact the user like normal retail user anyway? Yeah, two main sort of downsides, we would say. One is slightly increased cost. So this process costs a little money, the generation of keys. So there would be a small sort of additional transaction fee attached to it that goes primarily to the shutter keepers, but we think that'll be offset by, again, people not getting front run. So you'll then have better prices. And overall, the economics need to be worked out in a way, and they will, I think, be easily worked out in a way that the transaction fee is smaller than the expected loss from not getting front run.
00:27:30.842 - 00:27:31.332, Speaker A: Right.
00:27:31.466 - 00:28:15.648, Speaker B: And it's quite easy because the losses are pretty huge. So we think it's going to be quite economical to map to model this, especially for larger transactions. And then the other trade off is to do with latency. So this encryption decryption takes a little bit of time, a couple of seconds, essentially. So depending on how you look at it. This is added to it, or in the L one case it can be even parallelized with some of the other sort of block production process. But if you compare for the sequencer for the L two case, because the current user experience on L two s is you get this instant transaction inclusion and transaction result immediately.
00:28:15.648 - 00:28:26.884, Speaker B: So there it would increase the execution latency by a couple of seconds while still having this instant transaction inclusion latency. So you would get the result immediately.
00:28:27.012 - 00:28:27.304, Speaker A: Sorry.
00:28:27.342 - 00:29:03.510, Speaker B: You would get the transaction inclusion receipt immediately that your transaction will definitely be included. And then a couple of seconds afterwards you would get the result of transaction. So two trade off costs and the other one latency. But we think, again, the latency is actually not really that of a problem, depending on what your preference is. But we think it should be for normal trades, it should be very acceptable to wait a couple of seconds. Right? So maybe if you're a high frequency trader, you're not really happy about this, but if you're a normal user who just wants to buy something, you should care more about your price than a couple of seconds, right?
00:29:07.160 - 00:29:37.950, Speaker F: Like bundle and you. Sorry, I remember reading some discussion that that kind of makes the transactions that are encrypted end up being happening over two blocks because you need to submit them encrypted and they have to be included in one block and then they are decrypted and only in the next block you get the actual result. Like the execution of the.
00:29:40.240 - 00:30:20.010, Speaker B: This was an earlier design that we worked on where we built it purely on chain as a smart contract kind of solution on top where you don't have to modify the underlying protocol, then it would have to work like this. Then you have this kind of first shutter smart contract, which then in this next block passes it on to the target smart contract. But we moved away from that design because of that downside. Also other downsides, composability, cost. So in implementing it into the protocol, you don't have that specific problem. But yeah, you have the increased latency, but it's just part of the block production then. So it's not a second block, but it takes a little longer.
00:30:29.460 - 00:30:36.030, Speaker C: Okay, I think that's it. So thank you very much, Luis, and thanks everyone for listening. So thanks.
