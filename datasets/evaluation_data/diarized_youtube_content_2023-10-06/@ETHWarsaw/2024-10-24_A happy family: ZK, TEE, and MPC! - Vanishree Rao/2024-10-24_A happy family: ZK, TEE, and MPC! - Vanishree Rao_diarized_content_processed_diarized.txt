00:00:02.440 - 00:00:34.135, Speaker A: Hey everybody. My name is Vanishree. I am the founder of Firma. Firma is a universal proof generation layer. It is designed to generate proofs for any proof system in a cheap, performant and reliable manner. And it functions as a marketplace where the supply side consists of any kinds of machines, GPUs, FPGAs, VPUs, etc. And as far as the demand side is concerned, we can generate proofs in any instance where ZK is used.
00:00:34.135 - 00:01:39.799, Speaker A: That is what we are building. And we are coming out of stealth in just a couple of weeks. And today I'm going to talk about not just zk, ZK is our main focus, but we are not just going to talk about ZK but about ZK and two other very powerful cryptographic tools, multi party computation and trusted execution environments. And the reason why we are talking about this is that as many of you may know, recently there has been a huge amount of debate trying to pit one against the other in search of the superior one. And my goal here is to say the following. There is no one superior tool, but instead each one comes with its own purpose. And I have three main goals.
00:01:39.799 - 00:02:25.871, Speaker A: This is my first goal. It is to let go of this misunderstanding that there exists a superior one. And then the second one is to give some sort of a mental framework to decide which tool to use in which situation. And then the third goal is to demonstrate that they are complementary in nature by showing an application where all three of them can come together to achieve something that no single one of them could have achieved so effectively. Okay. Okay. So the agenda for today is that I'll first give you a framework, the framework to think about.
00:02:25.871 - 00:03:25.015, Speaker A: Okay? You have an application, you have so many of these cryptographic tools. Everybody's talking about them saying that one is better than the other. What do you have to do? How do you analyze the need of the application and the power of tools in hand? And how do you choose some tools versus others? This is the mental framework, right? I'll try to give a mental framework. And then we will apply this framework to these three primitives, right? 0 knowledge proofs, multi party computation protocols and trusted execution environments. And then finally we'll talk about data protected proving delegation. This is something that we are working on here. What is happening is that we are, like I said, we are bringing together all the three primitives to achieve something that no single one of them could have achieved.
00:03:25.015 - 00:04:18.657, Speaker A: Okay, so first the framework I want to build up to the framework, right? Let's start by noticing this fact, this reality, right? In a kitchen, think about a blender and a knife. What's more useful? Knife is more useful when you want to chop vegetables, while a blender is the apt one when you want to puree soups. It's not that one is more superior than the other, more superior to the other. This is exactly what is happening in cryptographic tools. Each one comes with its own purpose. And let's start with a cheat sheet of when to use which tool. This is just a cheat sheet.
00:04:18.657 - 00:05:37.305, Speaker A: Again, we are building up to the framework. So use zero knowledge proofs when you want when you use zero knowledge proofs, if the situation is that one party needs to convince another party that some computation is done correctly and one of the two things hold, you either want some part of the computation not to be known by the verifier, that's the ZK part, or you have this verifier who is very likely resourced, who cannot do the entirety of the computation. It's likely resourced, right? This is when you have to use zkp. When do we use tee? Think of tee. The aspect of TE to keep in mind is it's a cheaper and a less secure version of zero knowledge proofs. Plus it has an added benefit that the person who is proving also doesn't get to know what the secret is. This is what the power of trusted execution environment is.
00:05:37.305 - 00:06:50.335, Speaker A: And then when do we use multiparty computation protocols? You want to use multiparty computation protocols when the power of the security level of trusted execution environment is not enough because there are so many ways to break a text. If your situation is in such a way that the level of security that TE gives is not enough. Or to begin with, from the very get go, the inputs on which you want to compute the function is not just with one party, it is with multiple parties. Then multiparty computation is the way to go. Okay, so now the framework. It's really helpful to think about your situation as a puzzle, right? Let's say you have an application where you are trying to figure out a cryptographic solution. Think of the situation as a piece of the puzzle and think of the tools as the other pieces of the puzzle.
00:06:50.335 - 00:07:53.783, Speaker A: And you're deciding which other pieces of the puzzle puzzles you need to put together to complete the puzzle, right? And this isn't enough. This isn't the entirety of the framework. The core aspect of the framework is that there are three important questions, very clear questions. If you try to answer these questions, it'll get you a long way in solving your problem. Those three questions are what functionality are you trying to achieve? What security do you desire? What cost are you willing to pay? Right. Cost in terms of ux, cost in terms of building it, building the solutions, et cetera. I'll add more flavor to each of these these as we go ahead, but let's take the same argument from the other side.
00:07:53.783 - 00:08:45.621, Speaker A: Let's start with zkp, TE and MPC and look at what functionalities do they allow? What security do they provide? What cost do you pay if you use any of them? Right. Let's start there. And then we will try to summarize everything that we said and try to have a cohesive framework in mind. The functionality that zero knowledge proves. So even before I say that, here is something that is very important to answer these questions, right? Functional. When you talk about functionality, you shouldn't care about anybody acting maliciously. The right answer to this question comes when you look at all the parties in your system as completely honest.
00:08:45.621 - 00:09:17.971, Speaker A: Think of every party in your system to be completely honest and then see what is it that you want to achieve. And that's the functionality, right? In the case of zero knowledge proofs, there is a prover and there's a verifier. Assume that they are both honest. What is it that we want to achieve? We want to achieve that the verifier gets. The prover convinces the verifier of the correctness of the computation. Even when the verifier is lightly resourced, this is the functionality. There is no cryptography happening here.
00:09:17.971 - 00:09:52.465, Speaker A: Yet when you describe functionality, there is no cryptography happening. It comes when you think about security, right? So what is this security that zero knowledge proofs provide? You consider two situations. Situation one is when the prover is bad and malicious. Situation two is when the verifier is malicious. When the prover is malicious. What you don't want for this prover to be able to do is to convince the verifier of some wrong statements. This is what we want, right? This is the security.
00:09:52.465 - 00:10:48.073, Speaker A: This is the security that zero knowledge proofs need to provide the soundness property. And when the verifier is dishonest, you don't want the verifier to learn the secret information about the computation, right? This is the zero knowledge aspect about zero knowledge proofs. And what is the cost? The cost? My belief is that the cost you pay when you are using zero knowledge proofs. Now, with the presence of ZKVMs, it's not so much in engineering, but it is in rigging up this network of provers, maintaining them and incentivizing them. This is exactly the problem we are solving with firma. And I believe that that is the heavy lift without Firma. Okay, that's about zero knowledge proofs.
00:10:48.073 - 00:11:46.515, Speaker A: And how does the piece of the puzzle of trusted execution environments look? So what is the functionality it allows for? Remember we said that think of TES as just a cheaper and a less secure version of zero knowledge proofs. So it gives you very similar functionality properties. Somebody is running some computation and somebody is getting convinced that this computation is run correctly. Right. This is basically it. And the security is that besides what was happening in besides what was happening in zero knowledge proofs, like I mentioned just a while ago, there is this additional very interesting power of trusted execution environments that even the person who is doing the computation doesn't know what the secrets are. So this is an interesting property that you can put to use in some applications.
00:11:46.515 - 00:12:37.043, Speaker A: Cost sourcing tes, maintaining them and incentivizing them, ensuring that there is an optimal level of incentives for them. This again, just the way it is hard for zero knowledge proofs proving here you have a similar cost. Multi party computation protocols. Multi party computation protocols have a bad reputation that they are very expensive, but you can actually in certain situations, if you architect your system very nicely, these can be very powerfully useful and very efficient. You need a systems solution there. So multiparty computation protocols as we know are you have not just one party doing the computation, but multiple parties. I have a secret.
00:12:37.043 - 00:13:09.501, Speaker A: You have a secret, he has a secret. We all talk to each other and find out something. Let's say who has the highest. We all hold a number in our. We all write a number in a piece of paper and then we figure out who wrote the highest number without any of us revealing any number to anybody. That's the really cool aspect of multi party computation protocols functionality. I gave you a very high level example, so let's formalize.
00:13:09.501 - 00:13:48.245, Speaker A: Formalize it. Multiple parties collaboratively compute a function of inputs that exist with multiple parties. This is the functionality. What is the security in this example that I gave you don't want any of us to know any information about the numbers that the others have, except for the fact, except for the fact that is revealed the highest value. Who has the highest value. That's the only thing that is revealed. Nobody gets to know anything about anything else.
00:13:48.245 - 00:15:00.695, Speaker A: During the course of the competition, during the course of the collaborative, like in the protocol, we talk to each other. Nothing is revealed from whatever we reveal to each Other, nothing else is revealed. So that is the security you need, you get from multiparty computation protocols and the cost, like I said at the very beginning, it's considered to be inefficient, especially because computation is not the hard part. The communication is the hard part in multiparty computation protocols. And that typically is the case. Again, you can have system solution where this can get mitigated and one shouldn't shy away from considering to use multiparty computation protocols. Okay, so we looked at how to apply the framework for each of these tools and here is another important aspect about the framework, right? And that is the following.
00:15:00.695 - 00:15:41.765, Speaker A: How do you think about the security and the cost aspect of your application? It's not the same way as you think about the functionality aspect of your application. It's more dynamic, right? Functionality is very clear. You're building an application, it needs to achieve something that is not negotiable. The level of security, the amount of cost you are willing to pay. That is probably. It's a more flexible part of your puzzle. So finding the pieces of your puzzle is.
00:15:41.765 - 00:16:37.885, Speaker A: It's not a very rigid process, it's a very dynamic process. And the graph here is to give another cheat element to keep in mind that if you try to. It typically is the case that if you try to achieve more security, if you try to ask for higher level of security, you're likely to pay more. It's very natural, right? You're likely to pay more in terms of UX or engineering cost, et cetera. And it is. The dynamic nature of finding a solution to your problem is very clear here. Where do you want to place, where do you want to be on this curve of the amount of cost you're willing to pay versus the amount of security you want? Right.
00:16:37.885 - 00:17:09.901, Speaker A: So actually, before we go ahead, let's summarize. I talked in a very technical, at a very technical manner. But let's zoom out and try to see where this all comes together. Back in the day before crypto, right? There was their cryptography. Cryptography research had been very active. It still is very active. The research is very active.
00:17:09.901 - 00:17:41.973, Speaker A: And a typical advice cryptographers used to give to non cryptographers is that don't do your own crypto. Don't do your own cryptography. We don't have time for that here in crypto, we don't have time for that. We have. I think this is the way to go. I am guilty of subscribing to that kind of thinking back then, but that is not the way to go. This is the way to go.
00:17:41.973 - 00:18:23.063, Speaker A: Where we build, we break, we build, we break. But very carefully though, because embrace technology at a pace where you cannot wait for all of us to be trained cryptographers. That is the state we are living in. And this is the way to be. But what is helpful when we are doing something like this is having frameworks like these. And it is good that we are shining light on very otherwise esoteric areas of cryptography. Multiparty computation.
00:18:23.063 - 00:19:03.691, Speaker A: When I was working on multiparty computation 10, 15 years ago, I had. I couldn't even have dreamt that something like that could see the day of flight. But now that isn't the case, right? So I want to go back. I went too ahead. Yeah, I wanted to stay there. So that is why I wanted to give a framework. Right? We have been thinking about mpc, we have been thinking about te, we have been thinking about zk, pitting against each other, trying to find what is the right tool to use in any given application.
00:19:03.691 - 00:19:55.115, Speaker A: And my thinking was to have to begin this consideration with more formal framework in mind. And I tried to formalize that framework. That was this part of the talk. And now. So the rest of the talk is. The rest of the talk is to mention something that we have been working on. It is data protected proving delegation, where all these three tools, seemingly, seemingly competing tools, coming together to build something that no one single one of them could have achieved.
00:19:55.115 - 00:21:07.025, Speaker A: Sorry, I'm getting thirsty here. Okay, so this is a very cool concept, right? It starts by. It starts in a very real setting where you're trying to do zk, which is, like we said, what is the cost you're paying for zk? It is improving, right? And if you're having these phones generate proofs where, for example, you're trying to prove something about your identity, the proof needs to go out of your phone. Worldcoin is an example. When that happens, your architecture is not scalable. With the increase in the size of the computation you want to prove or decrease in the amount of resources your phone has. It's not a future, it's not a scalable architecture.
00:21:07.025 - 00:21:53.027, Speaker A: Instead, what if we have a way for these phones to delegate these hard tasks to more resourced machines? But there is a problem. And what's the problem? The computation consists of. The computation is done on data that is sensitive, right? It has this personally identifiable data. And that is why the whole premise of doing computation on the phone is that it has sensitive data. It has to lie with the users. That is why you wanted to do it at the client side, but. But it's bad user experience.
00:21:53.027 - 00:22:58.825, Speaker A: Many a times you cannot even do it feasibly. If you are using this old Nokia phones, you cannot hope to generate proofs for sizable computation on these phones. Natural question, how can you delegate proving while ensuring privacy or security of this data? That is the main question, right? The solution to that is this protocol that we call data protected proving delegation. And this is what we are building. And here is the high level idea, the crux of it, the idea, the core idea. We are not the first people to think about it, There is some amount of work, but we are productizing it by having system solution, systems approach to it where MPC is not going to cost exorbitantly. Here's the idea.
00:22:58.825 - 00:23:52.875, Speaker A: You have your phone that has the sensitive information that is unable to generate proofs. There are all these machines that are able to generate proofs that there are multiple of them. This machine secret shares, this witness, this sensitive data to all these machines secret shares in a way where no single share or even n minus one of the shares reveal anything about the data. And then these GPUs will talk to each other through MPC protocol. And there are these tes that are helper machines that are lying on the side to help you make the MPC as efficient as possible. And then they generate the proof and send it back. So you see there is.
00:23:52.875 - 00:24:53.237, Speaker A: You want to do zk, you're using MPC and you're using te. If you were to just do ZK and delegate the proving, it didn't solve this specific problem again because of the fact that it contains sensitive information. So how do you solve this? By putting all these three complementary technologies together to achieve dppd. Again, Ferma is building this and that's all I wanted to say. Yeah, so we are coming out of stealth soon. We are at Fermat or xyz. Please if you're building in zk, come and write to us and find me on Twitter DM or head over to Ferma XYZ and there's a form there.
00:24:53.237 - 00:24:56.085, Speaker A: Please fill it up and we'll get back to you. Thank you so much.
