00:00:00.250 - 00:00:06.138, Speaker A: To zero x hack with me is Vitali Drogan. Hey Vitali.
00:00:06.314 - 00:00:07.040, Speaker B: Hi.
00:00:08.050 - 00:00:19.200, Speaker A: Vitali is the call developer at ZK sync and Metrolabs, and he's going to tell us more about ZK sync and why roll ups are not enough.
00:00:21.810 - 00:00:22.462, Speaker B: Yeah.
00:00:22.596 - 00:00:24.640, Speaker A: Okay, Vitali, great to have you.
00:00:25.210 - 00:00:25.702, Speaker B: Thank you.
00:00:25.756 - 00:00:27.010, Speaker A: The stage is yours.
00:00:27.090 - 00:02:06.626, Speaker B: Enjoy. Okay, so I've been developing Zksync for a year now, and Zeke sync is ZK rollup on ethereum. So ZK rollup, as you may know, is a system where we just do the side chain, but we use validity proof of the side chain stain transition in this second blockchain, and we compute zero knowledge proofs, put it on Ethereum, and Ethereum verifies that Sachin is performing correct state transitions. But to be secure, roll ups and the ZK roll up in particular should put data on chain so that everyone can verify state. Because the main problem with roll ups is that someone can corrupt the state. And this is why we must put Kodata on chain. What we want to do, what is really interesting and new, is to do Zika roll up that is EVM compatible.
00:02:06.626 - 00:03:08.954, Speaker B: What we mean by that is that you can implement your smart contracts using your usual programming languages like solidity or something like that, and compile it to the bytecode of some normal virtual machine and then execute this bytecode in Ethereum model. You don't have to learn anything about zero knowledge proofs, circuits, constraints and so on to be able to use it. And that's what we are working on now. And roll ups are really great. It can reduce cost of the transactions by a factor of 100. Even today we have deployed the casing on the main net and our gas cost is around 500 gas per transfer. Right now, our roll up can support only ERC 20 token transfers, but it's still a pretty interesting use case.
00:03:08.954 - 00:04:13.246, Speaker B: And if we, for example, take the whole Ethereum for our data availability storage, we can support really low transaction gas prices. So for comparison, as you may know, Ethereum transaction just ethereum transfer is 21,000 of gas and ERC 20 transfer is 30,040 and so on. And our cost when we take a lot of space in Ethereum is around 200. Right now it's 500, like really practical cost. So it's pretty interesting, but it's not that easy. So it's not enough. People think that if we just scale it 100 by a factor of 100, we can, for example, take over some payment systems that already are deployed, like PayPal and so on.
00:04:13.246 - 00:05:09.866, Speaker B: So it should be enough right, but not so easy, because if you decrease prices, you can expect really big demand. And this demand can be much higher than the scalability that you create. So what we do and demand can have really will be really high if you reduce gas prices. So this is how it will look like. It's just how gas fees scale up. But if we just divide by factor of 100, number of user will go high as well. So what we thought about it and the solutions that we propose, we call it ZK Porter.
00:05:09.866 - 00:06:15.394, Speaker B: And what it will do is the following. So imagine I'll stop this slide and maybe explain how this relapse works and try to make understanding about how really cool ZK Porter can be. So as I said, ZK rollup works like this. We have smart contract on Ethereum, where users interact with it and deposit some funds, assets and so on to this contract. And then these assets, they appear on this separate chain from Ethereum, which is our roll up chain. And users can send transactions to each other and do some smart contracts, call in the future. And Ethereum doesn't know about this.
00:06:15.394 - 00:07:04.670, Speaker B: So what roll up do is we aggregate these transactions in batches and we might prove that these transactions that happened in the side chain are actually correct. And we publish the new root hash. So this is representation of our state. In this side chain, it's Merkel tree, and we have accounts that aggregate to one root hash. So we publish new root hash. We publish proof that this root hash is correct. And this way Ethereum knows that in this side chain there were nothing fishy about these transactions.
00:07:04.670 - 00:08:14.294, Speaker B: They were signed by the users, they were properly authorized, they didn't have any overflows and so on. So these were proper transactions that happened. And they made from one state route, from one route to another. Also, we publish, as I mentioned before, we publish some data that needed so the users can restore the state. Why we do that? Imagine that we have these operators of the side chain and then everyone does transactions there and everything is great. But if these operators go offline immediately, then we have a big problem, because users must somehow withdraw funds from this contract. From the point of view, the whole time users interacted in this roll up, all the funds was locked in this big smart contract on chain.
00:08:14.294 - 00:09:06.762, Speaker B: And then they have to withdraw somehow these funds. What they must do is to prove somehow that in the last state that was before the operators just went offline, they have some funds. If they prove this to the operator, they can withdraw it and be free. So this is essential property of security and it's much cheaper than Ethereum because for each transaction we post only a small amount of bytes. It's pretty cheap because cold data, we just store these bytes in cold data. So in transaction arguments, we don't store it in Ethereum storage, just put it in transaction arguments and forget about it. And everyone who is interested can just read the Ethereum blockchain history and find this data needed to restore state.
00:09:06.762 - 00:10:05.038, Speaker B: Restore state and everything is great. It's cheaper because coldata is very cheap. It's like 18 gas per byte of cold data. For example, storage is 20,000 gas per 32 bytes per one slot. But even 100 times cheaper than Ethereum is not good enough, because when demand will rise and rise in the future, what we expect is that Ethereum will be really expensive. So only roll ups can live really on Ethereum, but roll ups will become much more expensive. So they will probably become like Ethereum today if you just scale it by factor of 100.
00:10:05.038 - 00:11:19.714, Speaker B: So what we propose is like hybrid temporary solution that will enable onboarding of a lot of users that don't have these strict security guarantees of roll up. So in roll up, even if you have one operator and it goes offline, nothing really happens to your funds, you can always withdraw it. Then there is another solution. It's often mentioned by the name of validium. Validium is when you do all the things that I mentioned in roll up, but you don't publish public data. This way transactions becomes almost infinitely cheap. Of course it's not the physio, but why is that? Because when we do some state transition which can be like, imagine like 20 Ethereum blocks, but from the point of Ethereum, it will be just one state transition, which can be represented by published state root on chain.
00:11:19.714 - 00:12:09.574, Speaker B: And this represents all the data that you need for all transactions that executed off chain. But it's not good enough because users can, of course they lose something if they give up this roll up property. So what do they lose? Let me show you something like that. Yeah, so this is how our lab looks again. It's just each state update we publish called data. But I'll return back to this slide. So here what we want to do is we can actually in one state tree, we can have both of these words at once.
00:12:09.574 - 00:13:09.482, Speaker B: And I can explain that it's not a problem and it have a lot of good features. So we have all the users that will want to have all the security of the full roll up. They will just have their accounts in this roll up subtree of our whole state tree. And what it does is just for every important really big contract. Imagine Defi and so on. Every state change will be published on chain and it will never be lost. But there will be other subtree where we don't publish state changes and transactions for these people will be really cheap and they can interoperate between each other.
00:13:09.482 - 00:14:10.746, Speaker B: So how roll up looks? I already explained just one tree where we publish called data on each state update. Each time we change route, we publish to Ethereum. And Ethereum network actually is working as data availability solution for us. So the only thing that we want from Ethereum is that it accepts our transactions, it stores them and it checks the proofs of our state transitions. And the security is as good as l one. Because if Ethereum is okay, then operators cannot do anything in this setup. And yeah, then we add SK Porter accounts.
00:14:10.746 - 00:16:01.466, Speaker B: And what is interesting about these accounts is that we actually have to have some data availability. Because as I said, if you don't have any means of restoring your account data, then all the funds that you have can be frozen. So what we do, instead of using Ethereum or just ignoring this problem and not publishing this data at all, we have separate people that are storing this data for these users and these guardians, the data availability committee, they accept these changes of the ZK Porter state route and they receive stream of the updates from these accounts. So when we do some transaction, if state of the account in roll up changes, its delta goes to Ethereum. And if we have some state change in ZK Porter, then its state delta goes to guardians and they have to sign that they receive this state delta. And only if they sign that they receive all data availability needed for the state transition, they sign new route and then state route can be updated on Ethereum and ZK roll up security is not affected by this. Why? Because users that live in ZK rollup, they can always withdraw their funds.
00:16:01.466 - 00:16:48.378, Speaker B: And we actually do one little trick to do that. I'll mention it later. I'll mention it now. So imagine that you have some contract that stores something important. Let's start with something easy like NFT. NFT is contract that stores its owner in its own state, in Ethereum at least. And if this account changes owner, if this NFT is in the ZK roll up, it will change its owner and this new owner will be available on Ethereum network.
00:16:48.378 - 00:18:32.838, Speaker B: And later, if this whole system just shuts down, user can prove that he is the owner of this NFT and he will withdraw his funds. And in Porter, if this NFT is in Porter, it changes owner, new owner will be available in this guardian's servers. And later if everything stops, user will rely that they will provide proof that he actually owns this NFT and then he will withdraw it on chain. So how this will work in our system. So the problem is, imagine tokens, tokens, Erc 20 tokens or any other they store the state of this token balance sheet, the ledger of who owns how much in their own state. And this is problematic for this setup because every user that owns this token is actually that availability for this user will be determined by this token. And it's not really good because for example, if you're really poor and you can't afford using this Zk roll up, if this token will be in the ZK roll up, you will just be really upset because every interaction when you send this token to anyone else, it will be really expensive because by default tokens store the state in their own tree.
00:18:32.838 - 00:19:22.822, Speaker B: But what we want to do is to allow any contract store their state in the state of the user. So how it will look like a lot of the contracts, they look like this. You have mapping from address to some data. And really if you think about it, it's used a lot for determining, just writing down like what user, what address owns something. And what if we just store this data that user owns in his own account tree. We do this stuff, we call it like delegated write. And delegated write is when one contract writes to another contract storage.
00:19:22.822 - 00:21:03.140, Speaker B: But the slot actual collision is almost impossible because the writer does not control where exactly in the storage of this account he writes. And going back to the token description how it will look like token will store this balance of the user in the user account tree itself. So if the user is in the ZK porter, all transfers from ZK Porter user to other ZK porter user will be almost nothing. It will be really cheap because all the state that is changing when you transfer token in this delegated writer setup is actually happening here. And you don't touch token contract when you change your balance because your balance is stored in your subtree. If you send these tokens to your user who is in the roll up and he pays for this security, so he wants the security of the roll up, you have to pay for the balance change that will be posted on Ethereum and that will be more expensive. So what we actually lose when we give up this data availability on chain in the l one, what we give up is not that much actually.
00:21:03.140 - 00:22:41.866, Speaker B: If you think about a lot of the side chains, how they work, they just have Ethereum and the users just play in this side chain and somehow this data is breached to Ethereum, the only guarantee there is, economic guarantee. And you can't really hope that users will just, you really hope that operators won't do anything wrong because they can do anything. Actually all the possible things that done in the side chain are determined by the consensus code, which is usual programming language code that is run on the operator machines. And they can collude, change it to anything they want and they can stall all your funds from the side chain. So the usual arguments on why they would not do that is because to have this consensus in the side chain, they have to have some token to represent their vote in this proof of stake. And they really like their token and they don't want it to lose value, because if they just collude and sell everything in Ethereum, from the Ethereum point of view, then of course the stocking will drop. And that's why it's not really good guarantee.
00:22:41.866 - 00:24:42.390, Speaker B: Because if you have a lot of funds in this side chain, you just risk that cost of losing their token is not actually that bad compared to the reward that you have if you lose it. But in ZK rolapse, it's pretty interesting because it's not possible to do almost anything, because this state transition in the side chain, in the l two chain, is not just determined by arbitrary code that is run on their computers. We have this zero knowledge circuit that is known to the Ethereum, and this circuit checks that all the signatures were present and users authorized in transaction and so on and so forth. Though operators can't really do anything, they can't stole your funds because they don't have transactions from you that sends all your funds to the operators, they can't corrupt the state and do some weird things with contract, if you have smart contract there, what they only can do is freeze your funds. It's pretty bad too, of course, because they can ask for ransom and so on. But the attack surface for this kind of chain is much much better than side chains that are popular right now. And what triggers this, what can happen really is that somehow validators, these data guardians, will collude and then they force shut down this network.
00:24:42.390 - 00:26:00.026, Speaker B: And then nobody can exit from porter, they can freeze this. Actually, let me make this point clear. So if small number of validators collude, they can just freeze liveness of the network. But then we trigger this forced exit or exodus mode when everyone can exit just by providing the proof. And since you have a lot of honest validators, you can always find someone who will give you this data and you will exit. If most of the network is colluding against these ZK porter users, they can freeze their funds, but they lose their stake. So this argument works here, like economic argument, they don't want to lose their stake, but the only thing that they can do is just freeze funds.
00:26:00.026 - 00:27:14.920, Speaker B: What is interesting about this setup is that it's opt in, and you can choose your security guarantee. You can have account in Porter, you can have account in rollab, you can migrate your account from Rollab to Porter. Migration back is much harder. So we don't want to support it, but just the details. If you want, you just generate new key, and you have your account in the roll up, and this big number of users that have different amount of money, amount of ideas about how secure they should have their funds, they can live together and they can have interoperability, because from the point of view of the casing circuit, just like zero knowledge circuit, it's not a lot of difference really between roll up accounts and porter accounts. They share the same state tree. You can make transactions that touches any number of porter accounts, any number of roll up accounts, and so on.
00:27:14.920 - 00:28:14.410, Speaker B: And scalability in porter is much better, because if the cold data becomes a bottleneck, in the roll up case it's like 2000 TPS, but in the composite you can just execute much more, just publish new stat hash and so on. It's like 20,000 plus. It's not totally a reputatory number, but it's just to show that it's really high. After there, you just get rid of call data, you have another bottlenecks and scalability. But you have argument why we can support actually 20,000 plus. And again, transaction cost is different for different users. For roll up accounts, it will actually scale with l one, because we pay in gas.
00:28:14.410 - 00:29:29.106, Speaker B: For data availability, you will have always have your prices, they're denominated in gas. It will be much lower, but it's still denominated in gas. So it's 100, let's say, than l one importer transactions, prices fixed, no matter. Of course we have some influence of gas prices on Zika porter transactions, but it's not that big. Okay, interesting use case is that, imagine that this popular stuff that we have, like Uniswap, which is pair trading pair on chain, it's a contract that have balance on its balance sheet, which is really big of two tokens, and then it swaps between that. So how. Let me do a little back on the envelope calculation of how cost of the interacting with such smart contract will be, if some users from rollap will interact with it and some user from porter will interact with it.
00:29:29.106 - 00:30:33.990, Speaker B: For roll up users, it will look like that. Okay, I changed my mind. Let's think about it from the point of view of Uniswap account. Uniswap account have these two balances which represents this state of this contract. And imagine that we do a lot of swaps with this contract. And really what changes is these two balances in the end of the block, when no matter how many interactions with this uniswap pair will occur, we will have to publish only two balances on chain, which is in Unisop cases, this in total will be 32 bytes, which is balance of token a plus balance of token b. And what is interesting is that users that interact with it, they can share this cost of on chain data between each other.
00:30:33.990 - 00:31:32.970, Speaker B: Because if this pair is really popular, we have a lot of interaction with it in one block by block. I mean this side chain block, which can be a lot of blocks actually, but it's just technical detail. And each user can pay their own little share for this 32 bytes on chain. Because we don't have to publish their balance changes on chain, it will be really cheap. So what we imagine will happen is all the important DeFi contracts will be in the zike roll up. They will store the important data like tokens and so on, will store important data in the user's account tree. So this whole system just will be cheap for ZK porter accounts and expensive for rollups accounts, but more secure.
00:31:32.970 - 00:32:42.954, Speaker B: What is interesting also that this can happen only in ZK rollups. So optimistic roll ups, I will mention it. So I mentioned, this side chain solution is just like economic guarantee on all that happens there. Optimistic roll ups are much better than that, but they are probably not good enough compared to the ZK roll up. So in optimistic roll ups, you execute transactions off chain, but you publish these transactions that you execute in Ethereum. And then if something bad happens, someone can prove, using this data that everybody published on Ethereum to prove that this operator was malicious, this transaction is incorrect, and then they can revert the state, punish validators and so on. So they have this fraud proofs approach, and they can't do something like that in a fraud proof approach.
00:32:42.954 - 00:33:39.470, Speaker B: Why? Because as I mentioned, we have this idea of proving somehow, from the point of view of Ethereum, that our state transitions was correct. And for that we publish zero knowledge proof. It's constant time really small and it just verifies everything that happens off chain every transaction. But from the point of view of optimistic roll up, every transaction data is proof of what happened in this roll up. So they can just omit some transactions and do these kind of tricks that you do with the caporter. And let me just try to think about use cases that can be used there. So it's the same account tree that is used by Porter and roll up accounts.
00:33:39.470 - 00:34:25.986, Speaker B: You can test something in porter and interoperate with any real accounts, real contracts on main net. It's just really great for testing stuff. And if you migrate, you just write this code, it runs, you just migrate it, redeploy it on Porter. It's great. NfTs. So NFTs are interesting use case because some of them are already a little bit centralized. Because the use case of NFTs like Cayman NFTs or some other stuff, they are defined by company, that means it.
00:34:25.986 - 00:35:59.178, Speaker B: So you actually trust that this company will support it, will accept it and so on. What can happen is you can just move your trust of this company and to this data availability approach. And then even if you think about it, these companies can store data for this kind of nfts and they can be in this data availability guardians and provide the service to the users. So transactions will be cheap, they will be in this shared ecosystem with every important contracts on the planet. But that availability will be provided by these servers. Microtransactions if you have whales, of course they will probably not probably, but certainly prefer zig roll up and it's really cheap for them. But if you have a lot of small payments, that is done by users that don't own a lot, it just makes sense to do them in ZK Porter because they just should be cheap then sex trading.
00:35:59.178 - 00:37:31.200, Speaker B: So if you have a lot of users that already trust these big centralized exchanges and trade stuff there, they can gradually move to this defined infrastructure by first making their trading go through the ZK porter. Because it's of course not that decentralized and great as roll up, but it's much much better than anything that centralized exchange can provide and sidechains and so on. So they can move there and from that place they can move to the roll up. Okay, that's it. So what I want to stress is ZK roll ups is interesting and they are really the only solution from my point of view and many others that will be used as a scaling building block in future. And here I try to provide this eZk portal construction that will help to onboard a lot of users without centralization and so on. And they can enjoy Ethereum for cheaper prices, even cheaper than roll ups, promise you.
00:37:31.200 - 00:37:55.140, Speaker B: And this stuff again I would say is pretty unique to ZK roll up. You can do something like that in optimistic roll ups and such a will not even mention it because they are not secure at all. So that's about it. If you have any questions, I will answer it. Thank you.
00:37:57.610 - 00:38:21.006, Speaker A: Vitali, thank you very much for your time and for the presentation. I don't think we have any questions at the there any. Do you have a discord or a place where people can ask a question if they have any later?
00:38:21.188 - 00:38:55.000, Speaker B: Yes, we have a discord. I will gladly answer any question because maybe I said something specific or wrong and you can always find me in Twitter. It's like I don't remember dwush or something like that. Vitali Drogan and if you will search for it, you will find me and tag me and I'll try to answer any questions. I'm really interested in that. And if it will be posted in YouTube or something like that, I'll probably go there in comments too.
00:38:56.090 - 00:39:13.550, Speaker A: Yeah, I'm putting your Twitter handle right now on the screen so everyone can find you easily. Yeah, that's it. And do you have a ZK sync Discord channel?
00:39:13.700 - 00:39:15.600, Speaker B: Discord? Yes.
00:39:18.210 - 00:39:24.986, Speaker A: You can send me the link. I will make sure to post it in the video description.
00:39:25.178 - 00:39:31.582, Speaker B: Just go to Zekasinkayo and you can find all our contacts there. Okay.
00:39:31.716 - 00:39:49.350, Speaker A: So I'll make sure to put it in the description so everyone watching later can reach out to you. Vitali, thank you very much again, great having you. Thank you for sharing your knowledge and hope to see you again soon.
00:39:49.500 - 00:39:53.190, Speaker B: Yeah, thank you. Goodbye.
00:39:53.530 - 00:39:54.450, Speaker A: Thanks. Bye.
