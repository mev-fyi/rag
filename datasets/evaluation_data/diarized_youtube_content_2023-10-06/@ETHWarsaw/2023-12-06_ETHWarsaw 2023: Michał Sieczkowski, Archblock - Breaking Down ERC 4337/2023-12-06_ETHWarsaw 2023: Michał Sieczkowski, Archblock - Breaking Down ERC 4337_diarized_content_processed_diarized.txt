00:00:02.070 - 00:02:08.090, Speaker A: You okay? So I already had a chance to introduce myself. So I've been in this space since around 2018, building dapps mostly, and during this time I have seen many projects try to attract a large audience, and none of them, in my view, has succeeded in that. Blockchain apps are still very niche and bizarre compared to other Internet services that we use, like PayPal or Twitter. They are nowhere near the adoption of those services. So in my view, there are many reasons for that, and one of them is the difficulty in onboarding to blockchain systems. So in this talk, I would like you to take on a journey into account abstraction and in particular ERC four three seven standard that aims to simplify user flows. Let's see if the remote workshop isn't still my secret code.
00:02:08.090 - 00:03:10.510, Speaker A: Okay, a little agenda before we start, I divided this talk into three sections. First, I would like to get you a little more excited about the topic and discuss new possibilities that are uncovered with alcant abstraction. Then we will dive into the standard and try to explain it step by step. We won't manage to go through all of it today, there are just too many things. But hopefully you will have a solid understanding of how it works. And we'll finish off by listing what else is there to learn about it, talking about some pros and cons, and also how far we are in implementing the standard. So this is the structure for this talk.
00:03:10.510 - 00:04:05.788, Speaker A: Now, this is a workshop stage and I'm coming to you with a talk. So I would like you to follow one rule. It's very harsh, but I hope you will forgive me. The rule is that you ask questions as soon as you have them. I would like this to be more discussion than a talk. So at any point in time, if something is unclear, please raise your hand or wave at me if I don't see you, and we'll start discussing what is unclear and hopefully make everyone understand what is going on. Okay, so why should we care about account abstraction? Let's take a typical web two onboarding first, and you are all aware of this.
00:04:05.788 - 00:04:53.244, Speaker A: You go to any random website and you create an account. Usually confirm it via email, and you're good to go. You can post your first photo on Instagram or like a friend's post on Facebook. Right now, for dapps, it's a little more complicated, so we first ask our users to download a wallet app because our browsers don't have that built in yet, so they need to download metamask. Then they need to create an account in the metamask store the seed phrase and that itself is really a lot to ask. I to this day don't have a good strategy for storing my seed phrases. I don't know.
00:04:53.244 - 00:05:33.288, Speaker A: Should I buy a safe and put it there? Should I put it under the carpets? It's too much for me. Then the user needs to purchase funds and transfer that to their account. Only then they are able to do the first action. So initiate a transaction and then we ask them to learn how gas works. Let me just increase the sleep time.
00:05:33.374 - 00:05:46.010, Speaker B: Technically you create an account when you initiate because before you just have seed run, but blockchain don't know about you.
00:05:48.460 - 00:07:13.404, Speaker A: I'll address that in a sec. Just let me make this not sleep so fast. Very good point. Of course the remote is disconnected. Okay. Yeah. You guys noticed very well that not only you need to store the seed phrase, you also need to come up with a password to protect the seed phrase that is stored in metamask.
00:07:13.404 - 00:08:08.272, Speaker A: Right. To address this, can you repeat for us? Okay, I'm Alexander Kwaskov and my point is that you just generate seed frazzes and from seed frazz generate private key and maybe public key, but blockchain don't know about you before you initiate first transaction step, because on this step you just create an account. But in your steps it's another. Yes, this is just a simplification, let's say from user's point of view they have no idea about eos or anything like that. They just use some metamask wallet. Right.
00:08:08.406 - 00:08:12.130, Speaker B: For me it was very important.
00:08:14.340 - 00:08:56.080, Speaker A: Okay, let's move on. We will discuss EOAS contract accounts in more detail in a sec. Okay, so once they have funds in the account, they can initiate the first transaction and we ask them to learn about gas. So before, previously it was quite simple, gas price, gas limit. Now it got super complicated and we try our best in uis to abstract it away. But in my view, metamask is still difficult for users. So once they send out the transaction, they need to wait for it.
00:08:56.080 - 00:09:44.368, Speaker A: It needs to be confirmed. You see that a lot is happening here. So what is account obstruction? Account obstruction comes with a bunch of promises. So one of those promises is that you will be able to log into the DAP as you would into a normal website. So social login, let's say you log in with Facebook or login with Google. What else? Account abstraction would allow us to give users possibility to change their password, private key in this case. So in case they think that, oh, I may have been sloppy with this password, with this private key.
00:09:44.368 - 00:10:42.390, Speaker A: I would like to change it now. They will have the ability to do that. What's more, we can provide them with a scheme that allows them to recover their account if it's lost altogether. So you can ask a bunch of friends to help you recovering your account, which is social recovery. What else could we do? We could provide a way for users to pay only with one currency. If someone is onboarding into your investment platform to invest USDC into your protocol, why would they care about Eth? Right? They only care about the currency they are transacting in, which is, for instance, USDC. We could also think about sponsored transactions.
00:10:42.390 - 00:11:29.394, Speaker A: So having a way for app developers to pay for the execution of their apps, it may not be feasible on Ethereum, where transaction fees are super high, but on other cheaper chains, why not? What else? We could improve our user experiences in batching multiple calls into a single transaction. So users are still confused about the approve in ERC 20. They don't understand why they need to do that. And we could abstract it away. We don't need to explain them. What is it for? We can make this whole in a single transaction. And something that's probably more exotic.
00:11:29.394 - 00:11:53.770, Speaker A: We could have services that take subscriptions, like Netflix, like so your DAP could be authorized to get some funds from your wallet every now and then, and you would be paying for that execution as well as part of the subscription. There are many, many other possibilities.
00:11:56.390 - 00:12:24.710, Speaker B: Online, we have payments. It's not real payments. It's like clearing payments, not real payments. And if you don't take service for this payment, you can claim it back and then return for you. But in cryptocurrency, you can cancel transaction.
00:12:28.330 - 00:12:52.980, Speaker A: That's totally fair. We don't have chargebucks in crypto, and some consider it a great benefit. So depending how you look at it. Okay, so having account abstraction, what we could eliminate from this flow that we walked through. Well, if we used all of that, we could stay with just those boxes that are not crossed out.
00:13:02.440 - 00:13:11.280, Speaker B: Any doubt? Because normally I don't use any doubt. Orange box.
00:13:15.890 - 00:13:50.060, Speaker A: Yes. The point was that only orange boxes are happening repeatedly. The red one and green ones are one time setup. That's true. And I put the metamask in red because this is the biggest step, in my view, in this whole flow. This can be solved in many different ways. Let's go further, because this is just a general idea for what is possible.
00:13:50.060 - 00:14:49.860, Speaker A: Okay, so what you see here is nothing new. You probably heard about it before. You've seen a project doing some parts of it. And these are just a few off the top of my head, starting with a project that the company I come from did a couple of years ago and sunset it in 2020 due to skyrocketing gas prices, which is uniloggin. All of those tried to achieve the same goals using a bit different methods. So today we will show you what is the latest thinking about solving those problems. Okay, and what is account abstraction? What in my view, account abstraction is used for nowadays.
00:14:49.860 - 00:15:41.590, Speaker A: So I think it's an umbrella term for a set of proposals that can be divided into two categories. First category are proposals that require change to the Ethereum protocol, and the second one that don't. Now, we all know that Ethereum is getting crowded. It's increasingly difficult to coordinate a change of protocol. We saw how long it took to switch from proof of work to proof of stake. That's why I believe that the proposal that don't require protocol change is most likely to succeed in the future. Just to give you a glimpse of what those other proposals do.
00:15:41.590 - 00:16:50.214, Speaker A: So EIP 30 74 was about supercharging eos to have more capabilities, and EIP 2938 was about allowing smart contracts to initiate transactions. As I mentioned, we're going to focus on EIP four three seven, which is about creating a separate transaction system that runs parallel to Ethereum and integrates with it nicely, obviously. Okay, so let's dive into it. Before we talk about the specifics of the proposal, a little recap. We have two types of accounts in Ethereum. There are externally owned accounts controlled by your private keys that we mentioned, and there are contract accounts. Well, contract accounts are nothing else but smart contracts.
00:16:50.214 - 00:17:33.460, Speaker A: They are governed by the source code that they get deployed with. What is important is that only eoas can initiate transactions currently. This is limiting, in a sense that account abstraction was hard to build before. Right. Okay, so let's spend a minute to talk about why eoas are bad. So you download metamask, set up your seed phrase, and create a bunch of accounts. Basically, having a seed phrase is a single point of failure.
00:17:33.460 - 00:18:18.920, Speaker A: If you lose it, you lose access to all of your funds and they cannot be recovered. If you have the private key, you have unlimited capabilities to what you can do with your funds. You can transfer arbitrary amounts without any limits. Also, if someone steals your seed phrase or private key, they can steal anything. So pretty much unbound possibilities. Now, smart contract wallets, on the other hand, allow us to define flexible security rules. So one of the most popular is multisigs.
00:18:18.920 - 00:19:19.700, Speaker A: You can protect your account with a bunch of private keys. So this is something that you're probably very familiar with. With contract accounts you can create those transaction limits or recipient whitelists. For instance, you only ever transact between those couple of your accounts, and you only use this protocol. Why leave an empty, not empty, but open door for transferring funds anywhere else? You don't need it. So you can start thinking about transactions as you whitelist addresses that you interact with and not allow for anything. You can also implement social account recovery that I have already mentioned, and this is cool enough that I wanted to spend a bit of time here.
00:19:19.700 - 00:19:51.590, Speaker A: So, very simple scheme. Again, it works this way. You have the private key to your wallet. You are the only one that can operate it. If you lose it. You have a bunch of addresses set up of your guardian addresses. These can be your friends or your own account stored somewhere else, somewhere safe, and you can use those addresses to rotate your main private key.
00:19:51.590 - 00:20:44.050, Speaker A: Hopefully this gives you, and what I have mentioned yet is that in order to change the guardian addresses, you need to issue a transaction and wait a couple of days. So hopefully it gives you this leeway before, let's say someone steals your laptop and you know about it, you have a couple of days to react, to rotate your keys and protect your assets. Okay, so sure, yes, I think Argent Wallet implemented that a while back, and that's the only one I have from the top of my head right now.
00:20:46.660 - 00:20:49.490, Speaker B: Externally managed, for example.
00:20:58.290 - 00:22:04.816, Speaker A: Okay. I would still advocate having this decentralized, right? Yeah. So all of those capabilities with smart contract wallets is like, you can use them now, but not conveniently, which you'll see in a sec, and I will show you what is the goal of this proposal in the first place. So let's start introducing some code that we will wrap our hands around. So this is the simplest contract wallet. It has a single function that executes arbitrary operations. In this execute function, what it does, it first authorizes the operation, so checks the signature, for instance, and then it executes it.
00:22:04.816 - 00:23:30.720, Speaker A: So what is this user operations struct that is passed there? Think about it as a transaction in Ethereum, it has very similar fields, like the recipient of the operation, the data field in which you encode, what method you're invoking, and with what parameters. For instance, the value field, which says how much if you're transferring with that operation, if the data field is empty and value field has some number, then it's just a simple if transfer, right? You are all aware of those things here. Very good question. So this is a struct that is passed to execute function. The wallet needs to be able to authenticate this operation. It's a normal signature verification scheme, as you would do with transactions. That would be true if you were the only one to send it.
00:23:30.720 - 00:24:31.450, Speaker A: And we'll see in a sec that it doesn't need to be. Okay, maybe I can give you another example of a real life example of this scheme. So the way gnosisafe works is basically like that. It has an execute method that takes some user operation, and in this signature field you would pass multiple signatures. So for instance, if you are a free out of five multisig, it wouldn't be a single signature, it would be free signatures just to, because the signature gathering happens off chain and you pass everything in one transaction on chain. So this is very generic for now. Don't stick to anyone interpretation of that.
00:24:31.450 - 00:25:43.080, Speaker A: Yes, exactly. So if you didn't have an ounce, then someone could look at the data of a previously submitted user operation and submit it again. So for instance, you submitted an operation that transfers one if from your wallet to some other wallet. If you didn't have a nonce, then someone could just do it again. Yes. Thank you for helping out. I'm not sure I get your question.
00:25:43.080 - 00:26:28.090, Speaker A: Okay, you're going one step further so far. I'm talking about us submitting the transaction ourselves. So this will become clear in the next slide. Maybe. Let me just explain a bit. So this is the status quo of using those smart contract wallets. Think of this part as your gnosis safe.
00:26:28.090 - 00:27:23.470, Speaker A: You're still required to have a separate externally owned account. To operate the gnosis safe. You wrap this operation that you want performed on the smart contract wallet in an Ethereum transaction. So what does it mean to user onboarding? It means that they need to still set up the metamask account. They cannot use the smart contract wallets on its own at the back. Very good question. The signature here is validated by the smart contract.
00:27:23.470 - 00:28:20.602, Speaker A: It knows the rules how to validate this transaction. So for instance, if this is a safe multisig, it knows the set of configured owners and it can check that the signatures that came were actually from those owners. Yes, exactly. The whole thing you see here is a single Ethereum transaction. So yeah, calling the wallet and then wallet calls, for instance, another contract in a single ethereum transaction. Okay, so let's go further because you'll see how we could improve this scheme. So I mentioned already the problem.
00:28:20.602 - 00:29:11.740, Speaker A: You still need to have a separate externally owned account to use your smart contract wallet it's not like a standalone wallet at all. So what we want to achieve is this scenario where user uses only the smart contract wallet. And I'm going to base the explanation on a great article by David Phillipsons. You could have implemented account abstraction yourself. I recommend it a lot. So what could we do to get rid of the separate externally owned account? For starters, we could ask someone else to submit our user operation on chain. So this is exactly what we do.
00:29:11.740 - 00:30:19.170, Speaker A: We find an executor that will cover the transaction fee and execute the operation on our smart contract wallet on chain. As part of this execution, our wallet needs to refund the executor so that they are not doing that voluntarily. And this would be good, right? So now every time we want to do some operation on our wallet, we don't send a transaction, we send an operation to an executor that does it for us. This is something that we discussed just a second ago. Now this has its problems, unfortunately. And the first problem here is that the executor needs to be sure that they will get the refund. If not, they would need to trust the wallet that they will do that, they will refund them.
00:30:19.170 - 00:31:31.470, Speaker A: It's impossible to ask them to trust the wallet because anyone can have their own implementation of the wallet that's not verified on ether scanned executor would not be going through each smart contract and trying to figure out if they will not be cheated. So what they would end up doing is they would try to simulate the transaction before issuing it on chain to make sure that they get refunded. Now this is problematic because simulation does not perfectly predict the future. Simulation is run in the context of some version of the mempool. And what the mempool will be is determined by the block miner. Right? To simulate transaction means to take the latest state of the blockchain and execute it locally on your machine. You can simulate a transaction in a vacuum, so you have some state until this block, and you just simulate this one transaction.
00:31:31.470 - 00:32:20.060, Speaker A: You can go further, you can take transactions that are already in the mempool and try to compose a block yourself and simulate your transaction in the context of that. But you will never be sure that you chose the same transactions as the miner would, and you don't have that certainty. What is more, you can be gamed so the transaction can read from storage that will change at the time of execution. Exactly. This is the second point. It can use an opcode that is only predictable at the time of execution. Right? So you cannot know what timestamp the block will be even because this is determined by the miner in a blockchain system.
00:32:20.060 - 00:34:17.860, Speaker A: Sorry, guys, I need to reconnect. I will make my phone not go to sleep. Let's try. All right. It. Okay, we're back. Okay, so this was the first attempt.
00:34:17.860 - 00:34:57.212, Speaker A: We asked the executor to submit our user operation on chain. This introduced the first problem that the executor would need to trust our wallet. Let's now think how to solve that problem. Well, in blockchain systems, whenever you want to eliminate trust, you introduce smart contracts. Right. So this is exactly what we're going to do. We're going to introduce an entry point smart contract that is a singleton.
00:34:57.212 - 00:35:41.120, Speaker A: It's a single instance for all of the wallets on the blockchain. It is trusted in a sense that its source code is well known and it has been audited. People agree that it's safe. Okay. And now this smart contract will have a method for handling our user operations. Let's go through what this method does. It first checks that the wallet that this user operation is for has enough funds to cover for the execution of that operation.
00:35:41.120 - 00:36:39.716, Speaker A: They can do that by taking a look at the gas limit that was set in the user operation. Next they call the execute op on the wallet. Keeping track of how much eth was used and knowing that number, the function refunds the executor. Now for that last part to work, we need to introduce a deposit system in this entry point contract. So again, we cannot trust the wallet to refund the entry point. In this case, we need to ask the wallet to deposit into the entry point. First deposit is happening before you can execute the operation.
00:36:39.716 - 00:37:04.744, Speaker A: Right. So you already see the problem. It's like two things to do. One thing doesn't sound good. Right. That would be it, yeah. So I'm not going into this direction because we're going to fix the problem.
00:37:04.744 - 00:37:29.212, Speaker A: Right, but that would be it. You would probably need an eoa at the beginning to deposit from your wallet to the entry point, and only then you're able to use the wallet standalone. Right. Very good point. It defeats the purpose. Exactly. We also need to mention a new field in user operation, which is sender.
00:37:29.212 - 00:38:10.500, Speaker A: So the entry point needs to know for which wallet the operation is. So we introduce the sender. Thank you. And this is how this scheme would look like on a diagram. So now user asks the executor. Executor calls handle operation on entry point. Entry point calls execute up on the smart contract calculates how much gas was used and refunds the executor from the wallet's deposit in entry point contract.
00:38:10.500 - 00:38:49.260, Speaker A: Any questions at this point? Can you repeat. Yes, exactly. Anything that we need to agree on, some type of interface and then anything can be a wallet. Also, bear in mind that the method signatures I'm showing here are simplified in the standard. They are called a bit different. They may have more parameters. This is simplified to make this consumable in this explanation.
00:38:49.260 - 00:39:25.374, Speaker A: Okay, so I think you see now that we have solved the problem number one. Let's remind ourselves what the problem was. The problem was that the executor had to trust the wallet that it will return its funds. Now they don't need to trust. We have the entry point contract contract in the middle. It will always refund the executor. That's cool.
00:39:25.374 - 00:40:15.280, Speaker A: But we introduced two more problems, right? The problem number three we already talked about is that the user needs to deposit into entry point first. And the problem at number two is a new one. So now the verification of the user operation happens in execute op method. Let's go back one slide. So user sends their operation, it's passed on through this contract here, and the verification of this operation. So for instance, signature verification, or if it's a multisig, those free signatures are verified. It happens here.
00:40:15.280 - 00:41:35.084, Speaker A: It is paid for from this wallet's balance. The executor gets always refunded. So what does that mean? That means that someone can send a bunch of fake user operations so they can impersonate us, pass them to the executor. Executor passes them along this chain and they drain our deposited balance in entry point. Yes, exactly. So can you guys in the front hear the question from the back? Not really. Okay, maybe not the question, but the statement was that executor needs to still have funds in their eoa to put the transaction on chain.
00:41:35.084 - 00:42:07.090, Speaker A: Yes, that's exactly the case. They are providing the service for us so that we don't need to have the eoa on our own. Yeah, they don't lose anything because they get refunded. Right. We will talk about their incentives in a bit. Is the executor is going to. Can you repeat next slide.
00:42:07.090 - 00:43:03.150, Speaker A: Okay, so that's a good point. Would the executor be passing along the invalid like the user operations of someone pretending to be you? Yes, they would, because they get a tip for that which we haven't mentioned yet. But we will get to that. They are incentivized to provide the service. They don't care who pays, they are just the relayer here. Right? Very good point. Okay.
00:43:03.150 - 00:44:25.550, Speaker A: No, he will, because if the execution fails, it happens in this execute up stage, and the executor is always refunded. So entry point calls execute up. It checks how much gas is used. It doesn't care whether the execution completes or fails, it just checks how much gas is used and refunds the executor. How. Okay, so you're asking about number one here. The entry point will simply, the fees are paid in if the entry point will simply see how much if this wallet has, and it will take the gas limit field from the entry point from the user operation and calculate based on that.
00:44:25.550 - 00:45:35.870, Speaker A: Yeah, that's, sorry, that's the answer. Because up until this point, guys see zero one happens in entry point. It's a safe, well known smart contract. So you know what happens only when you call an arbitrary contract execute up. In this case, at this point, you cannot simulate, you cannot know what happens up until this point. You know what happens. So if the execution would revert in the first step here, the executor would not pass it on chain.
00:45:35.870 - 00:46:23.488, Speaker A: So yeah, the executor. These are all the details that you guys uncover during this talk. This is very cool. I haven't even thought about all those possibilities when I was preparing the presentation. So, yeah, executor at this point also needs to simulate. It just simulates up until the first point, right? Okay, let's go further. Let's take another attempt at the scheme.
00:46:23.488 - 00:47:21.280, Speaker A: So what we will do is we will extract validation from execution. So we introduce a new method to the wallet contract called validate up, and we will change the implementation of handle up in entry point. So now what the handle up does? It first calls the validate up. If it fails, you stop execution. Now, then it sets aside if from wallet's deposit into the entry point to pay for execution. It takes the maximum amount of if that would have been necessary for the execution. Then again, it calls the execute up, keeps track of how much gas it uses and whether the call succeeds or fails.
00:47:21.280 - 00:48:41.618, Speaker A: The refund. The refund to executor happens because we have the deposit system in validate up. We will put only the validation part, so we will authenticate this user operation. So if you are a wallet, for instance, NASA safe multisig in validate up, you would put the signature verification, and in execute up, you would put the code that operates on the data of the user operation, right? Yes, exactly. And execute op is protected, which you don't see here it's protected in a way that only the entry point can call this, and entry point calls this method only in handle op method. So execute up is not available to anyone outside. If you want to do that, you need to first call validate op.
00:48:41.618 - 00:48:44.100, Speaker A: You need to basically use the entry point.
00:48:48.630 - 00:48:54.870, Speaker B: Would the validate op execute like a validation of separation and then launch some ease?
00:49:02.690 - 00:49:39.330, Speaker A: Not really. Validate op only performs the authentication and the entry point contract sets aside if itself. So the logic for setting aside some if is in the handle up function. We're not pulling any funds from the wallet yet. We rely on this deposit system. So the wallet has deposited in the beginning, but you're aiming at the next point, which we'll get to in a sec. Let's see the next slide.
00:49:39.330 - 00:50:01.370, Speaker A: So what changes here? Let's take a look at it. Is it can be mutable? Yeah, I think so. It can be mutable, but.
00:50:19.810 - 00:50:56.570, Speaker B: Yeah, validate with this. Validate of existing.
00:51:03.740 - 00:51:40.496, Speaker A: Okay guys, let me explain. So that, you know, everyone is following, you guys are going ahead. So what we're doing with this scheme so far, we extracted the validation part to a separate function and we will restrict the function in its possibilities. We will do that in order to enable simulations that are reliable. So let's now talk a bit about that. What does it mean to make simulations reliable? So first of all, you will invalidate op. You will only allow it to call wallets associated storage.
00:51:40.496 - 00:52:29.540, Speaker A: So for instance, wallets own storage. Now how does that help? It helps in a way that if you were an attacker, you would try to make the simulation fail in execution. Right. So for instance, let's assume that a user operation, like multiple user operations depend on one oracle value. If you control that oracle value, you can invalidate multiple user operations during execution. So they all simulate just fine. But then right before the execution you change the value so that they all fail.
00:52:29.540 - 00:53:15.030, Speaker A: So that would be possible if we didn't have this first point here. If we restrict that, then the attacker would need to basically set this storage multiple times and that costs. And so this is basically denial of service protection. You don't need to understand exactly the next two points. This is just to give you intuition. And the second large point is that we will forbid those opcodes that are unpredictable in simulation. So now that we have that, let's take a look at what changes.
00:53:15.030 - 00:53:36.780, Speaker A: Okay, that's a very good question. So the executor provides a service for us. They can choose what user operations they work with. If they see that the user operation does not follow the rules, they just discard.
00:53:43.410 - 00:53:44.206, Speaker B: It.
00:53:44.388 - 00:54:26.830, Speaker A: Yes, it happens on the executor implementation level. Exactly. Yeah. You can look at the bytecode to see if those opcodes are used, or you can also try to simulate, I think in reality they don't analyze the bytecode, they probably just simulate. And if that is used, then exception and that's it. Okay, so let's go through this scheme. Now what happens here? The user gives their operation to the executor.
00:54:26.830 - 00:55:07.090, Speaker A: They wrap it in transaction called handle up. Before they do that, they simulate validate up. Now this is important because the user wallet will only pay for this part. For execute op. Validate op would be charged to the executor. So they are responsible for making sure that they don't pass invalid user operations on chain. We have restricted validate op so that they can run reliable simulations.
00:55:07.090 - 00:55:24.020, Speaker A: If they still pass invalid user operation on chain, it's their own fault. They lose ease right after execute op, entry point refunds the executor.
00:55:27.060 - 00:55:35.052, Speaker B: Okay, so maybe I have two questions, one in simulation and one on blockchain.
00:55:35.196 - 00:55:41.764, Speaker A: Exactly. Yeah.
00:55:41.962 - 00:56:07.610, Speaker B: And second question, when it comes to applications and infrastructure, is it like in a single application like smart contract wallet, so the user does send some, I don't know, HTTP request for the application and all the close patterns inside one.
00:56:11.290 - 00:56:13.480, Speaker A: Can you try to rephrase the question?
00:56:14.010 - 00:56:25.280, Speaker B: So when it comes to the application, is it one application that you have?
00:56:31.170 - 00:57:15.630, Speaker A: Okay, I think I get what you're asking for. So this scheme is developed separately to applications. So application developer does not need to worry about that. That will be implemented similarly to how blockchain nodes are implemented. So there's a single, or a couple of implementations like gas parity. There will be a couple of implementations of this executor that run the same protocol that we are just describing here. And users of our applications will be then communicating with nodes of those executor.
00:57:15.630 - 00:58:11.840, Speaker A: Okay, any other questions for this slide? Okay, I think this goes back to who pays for what. The executor only would pay for validate op if it failed. Right. If something fails in execute op, it is charged to the wallet. So this can be unbound. This can be hard to simulate. The executor doesn't care it's charged to this guy.
00:58:11.840 - 00:59:13.530, Speaker A: We have pretty much, I'm halfway through the presentation. We have time. Okay, we will cover that later. Let me go back to this. Okay, so with this approach, we have solved problem number two. Let's remind ourselves, what was the problem number two, the problem number two was that someone can exploit the system by sending multiple invalid operations that would be charging from user's wallet. Now we have extracted validation to a separate function that is charged to the executor and they can easily simulate it.
00:59:13.530 - 01:00:31.560, Speaker A: Hope you guys agree with me. Let's now solve the problem number three. So you already pointed in this direction that now that we have this validate op extracted and it's constrained, it's easy to simulate. We can also as part of this function, ask the wallets to provide if for execution. So the wallet doesn't need to deposit anymore to the entry point beforehand. During the validate op calls call, the user wallet will transfer enough if for the execution, it will transfer the max amount of if that would be needed for the execution. Now you can be asking, are we refunding the wallet at the end of the execution from the entry point? What do you guys think? Can we refund the wallet at the end of the execution? Let me rephrase the question after this step.
01:00:31.560 - 01:01:22.022, Speaker A: During this step, the wallet pays for the execution. Then this happens, we spend some eth and probably not all of it. Can the entry point simply transfer the money to the wallet back? You're talking about the reentrance. Exactly. So we are again executing unknown code. So we cannot rely on that and we will not. We will simply use the pool pattern, right? You guys know that if you send if to an arbitrary contract, then a fallback function can be called which can fail, use too much gas, like an unpredictable amount of gas, or even try to attack your VR re entrance as you just said.
01:01:22.022 - 01:02:18.810, Speaker A: Right? So instead of doing that, we will simply leave the money at the entry point and the wallet will be able to withdraw it later or it can be reused for future operations. So if that's just a small change, then the user will not care. It will stay in the entry point and can be reused in the future. So from his point of view, it doesn't matter whether it's deposited into the entry point or is staying in his wallet. That's why this parameter is called required payment. It's not called max execution gas or something like that because some money is already deposited into into the entry point. The entry point only asks for east that's missing, right? To cover for the maximum execution.
01:02:18.810 - 01:02:33.690, Speaker A: And boom. We have solved the third problem with this system. We don't need to deposit beforehand, user don't need a separate.
01:02:40.430 - 01:02:41.290, Speaker B: Wallet.
01:02:48.310 - 01:03:26.010, Speaker A: You're saying that EOA still needs to create the wallet in the first place? Okay. Typically in order to deploy a smart contract, you need to send a transaction from EOA to create it. Right. We're not going to cover it today, unfortunately, because we don't have unbounded time. But Erc for three three seven came up with a solution to that as well. So unfortunately not today. But you'll see that mentioned on the next slide.
01:03:26.010 - 01:04:29.802, Speaker A: Yeah, we already touched a bit on that. So up until now, executor was a volunteer. Like they were refunded, but no one paid them anything for their simulations or maintaining their endpoints to listen for your user operations and integrating with the blockchain, this was like a thankless task. So we introduced a model similar to how we price our ethereum transactions. User operation can specify max amount of if per gas unit that they want to pay, and also they can separately specify how much of that fee should go to the executor. This is purely like a copy paste of EAP 15590. That's a very good question.
01:04:29.802 - 01:04:34.430, Speaker A: I'm afraid I'm not super familiar with all the details of GSN.
01:04:44.960 - 01:04:57.570, Speaker C: So the idea is that you can find a third party to pay for your transaction instead of paying it yourself. But I'm not really familiar with the details. It's called gas station network, if somebody wants to look it up.
01:04:58.900 - 01:05:32.640, Speaker A: Exactly. This should actually go onto the slide where I showed you the projects that were aiming at solving account abstraction. This was an earlier attempt at this problem, basically. Okay, we have achieved the goal that we were talking about. So let's do a quick recap. Users can now use their contract wallet as primary count. So instead of transactions, they are sending their user operations to executors.
01:05:32.640 - 01:06:39.600, Speaker A: Executors pass them on chain. They get paid for execution from if that's stored in the wallet or already deposited into the entry point. And we also have a way to tip them, to incentivize them to pass our transaction faster and so on. Right? The question is, can this scheme be, let's say, generalized to use any tokens, not ease? Right? Yes. Unfortunately it's not as easy as just changing the currency. So the money flows that you are seeing on those diagrams is not that easy. But the standard has a way for doing that as well.
01:06:39.600 - 01:07:23.140, Speaker A: Unfortunately, outside of the scope of the stock. Sorry, not sure how that would work. This is, this is more about on chain actions. Okay, I think the question is, in these flows that we described, does the user contract smart contract wallet user need if in their wallet.
01:07:26.710 - 01:07:29.220, Speaker B: And they top up my.
01:07:32.230 - 01:08:08.482, Speaker C: So let's assume this situation. There is a company like a regular company, it's web two plus web3. I'm paying them with the credit card. They top up my account on the smart contract of the relayer. So they own the relayer and they store my balance, my eth balance inside of their smart contract. And then theoretically, if I just sign the transactions, they could execute that on my behalf, right? So I don't really need to top up my account. I don't even need to own an EOA in the first place, is that correct? As long as I have a private key and I sign my transactions, theoretically, I don't need it.
01:08:08.536 - 01:08:54.860, Speaker A: Yes, that's pretty much it. Okay, we're nearing till the end of talking about the standard. One important optimization that we need to talk about. So far, we've been talking about passing, like, individuals individual transactions on chain, and you already see that executor's role is similar to that of a miner. But miners don't do blocks of one transactions, they do blocks of multiple transactions. And this is exactly what we will do here. We will bundle multiple user operations in a single Ethereum transaction.
01:08:54.860 - 01:09:42.540, Speaker A: This way, we will save gas by not paying the fixed 21,000 fee every time. Also, it saves gas on cold storage accesses. So when you access the storage for the first time, it's more expensive than if you do it repeatedly in a transaction. So the only change we need to do to our signatures is in the entry point. Handle op is now called handle Ops. It takes an array of user operations, and this is how the diagram looks like, pretty much as you would expect. And I would like you guys to take a look at one important thing.
01:09:42.540 - 01:09:54.750, Speaker A: All the validations happen before all the executions. Can someone explain why is that the case? Sorry.
01:09:58.840 - 01:10:01.590, Speaker B: Why does it happen? Because you want to make sure that.
01:10:05.100 - 01:10:24.450, Speaker A: Yeah. So to answer the question first, if you interleaved first validate, then execute, then validate, then execute, then the first execute could mess up with the second validate, right? So the stimulation would not be predictable. Again.
01:10:27.700 - 01:10:41.010, Speaker B: It changes space. And the next idea should take that into account. For example, the first operation change the price.
01:10:44.520 - 01:11:38.490, Speaker A: Yeah, so what you're talking about is that the first operation could swap on Uniswap and mess up with the second operation validation. Right? That's why we don't interleave validations with executions, because validations are. Yes, that would be the case if you allowed the validate op to read other contract storage. But remember that we have restricted validate op in some capabilities, so your validate op cannot read. Yeah. So perhaps there are those side effects that you will end up when you implement your app against this scheme that you would, for instance, want to do something more in the validation that we haven't thought about? I don't know. I haven't implemented that yet.
01:11:38.490 - 01:11:55.736, Speaker A: What if the, can you repeat operations of different users?
01:11:55.848 - 01:11:57.500, Speaker B: Let's say I'm the malicious one and.
01:11:57.570 - 01:11:58.430, Speaker C: I only.
01:12:00.640 - 01:12:02.670, Speaker B: Validate and will crash them.
01:12:06.640 - 01:12:10.432, Speaker A: Can you try to again represent, okay.
01:12:10.486 - 01:12:41.336, Speaker C: What, I'm trying to find a loophole where we are bundling operations from different users. Right. And I'm the malicious one and I want to make sure that my operations never validate. Somehow by changing my state, maybe that in the next block it will no longer validate or something like this. Would it be possible for me to constantly mess with the bundle so that it will never get through? I'm not sure if this is okay.
01:12:41.358 - 01:12:55.130, Speaker A: I think the answer is no, because we have restricted validate up enough so that the executor can simulate it. If the user operation does not pass the simulation, they drop it.
01:12:56.860 - 01:13:49.630, Speaker B: That's minimum that is required to refund the executive no matter what. So the transaction itself you have to do is poison the pool.
01:13:51.410 - 01:13:52.346, Speaker A: Transaction.
01:13:52.458 - 01:14:05.200, Speaker B: That poison the validate office transaction can fail, and the validate office list.
01:14:09.760 - 01:14:10.076, Speaker A: The.
01:14:10.098 - 01:14:27.800, Speaker B: Validation makes sure at all whoever owns their wallet, they will pay.
01:14:33.300 - 01:15:17.548, Speaker A: Yeah, this explanation is very good. What I can say to add on top of that, for instance, can this validate mess with this validate? So can first validate mess with the other one? No, it cannot, because we restricted the storage accesses. So you can only access your own storage. You cannot change, let's say, second operation storage. You could be asking question. Let me say that you could be asking question. Okay, so what if I send two user operations of my own? Can my first validate op mess up, mess with the second validate op? Yes, it could, because it's accessing the same storage.
01:15:17.548 - 01:15:26.740, Speaker A: That's why there is an additional restriction that a bundle cannot contain two operations from the same wallet.
01:15:33.410 - 01:15:34.350, Speaker B: Storage.
01:15:41.710 - 01:16:26.972, Speaker A: It doesn't need to. It doesn't need to access the storage. For instance, it needs to access its own storage to know what is the set of multisig owners. Okay, guys, we have 30 minutes. Let's move on. So what I showed you here is that via a very simple change in our methods, you can now accept multiple operations and bundle them together in a single ethereum transaction. This is why in the standards they don't use the word executor, they use the word bundler.
01:16:26.972 - 01:17:05.260, Speaker A: So I've been lying to you the whole time. For gas optimization, you do it basically to save on gas. So this is a diagram from Vitalik. How he. I wouldn't say this is the most beautiful diagram, but this is how he sees it. You have a mempool of user operations submitted by different users. You have a bundler that creates a bundle that gets included into a single transaction as part of Ethereum block.
01:17:05.260 - 01:18:04.360, Speaker A: If you ever research altools, you start to see similarities here and there, and we'll see another similarity on the next slide. So, finishing, what else is there that we will not cover today? So let me start from the last point. Aggregate signatures. This is something leveraged by optimistic l tools, already optimistic roll ups. You can assuming the wallets use the same validation scheme. So for instance, they do a simple signature verification. You can bundle operations of different wallets that use the same authentication scheme.
01:18:04.360 - 01:19:05.212, Speaker A: Now if you have that, then you can make use of a clever piece of cryptography called aggregate signatures. So basically you combine multiple signatures into one, and on the smart contract level, you verify only one aggregate signature to make sure that all the individual ones are valid. You're nodding. So you know the scheme. Okay, and what else? We haven't talked about paymasters. Paymasters is again by introducing another smart contract to the scheme, a clever way for us to, instead of paying in ETH, pay in ERC 20 tokens, or even have someone sponsor transactions. We haven't talked about wallet creation yet, but I would like to mention one cool feature here, the same as with EOAS, where you create a private key from which you derive public key and you know your address even before it is funded.
01:19:05.212 - 01:20:28.076, Speaker A: Right here they came up with the same property that you can deterministically know the address of your wallet before it's deployed on the network underneath it uses create two opcodes. Some of you may be familiar. Now this is important because if you know the address of your future wallet, then the user can pay for deployment of their wallet themselves from the start. So you can create a website where you integrate with some onramp provider and they pay with credit card. The onramp provider provider transfers some, let's say USDC, to the future wallet address, and some bundler then deploys this wallet and gets refunded. This is possible using the standard, but unfortunately I will not show it to you today. Yeah, yes, it looks like building blocks.
01:20:28.076 - 01:21:20.080, Speaker A: Exactly. I don't expect them to try to, let's say, get in the job of Ethereum protocol or anything like that. Last slide will be about that all right, so how does the design that we discussed compare to standard Ethereum transactions in Mempool? We can talk about some properties that are maintained. So let's tackle decentralization first. Bundlers are not some centralized actors. Anyone can become a bundler. They operate a peer to peer network, public one, just like Ethereum mempool.
01:21:20.080 - 01:22:52.062, Speaker A: So it's again censorship resistant in the same sense that Ethereum mempool is censorship resistant. Additionally, if you ever, for instance, bundlers are all against you, you can still set up an eoa and communicate with entry point on your own, so you can send transactions to the entry point yourself. You don't need to rely on the bundler. Worst case, if something happens. Right, I mentioned wallet address predictability, which is still maintained, like with EOAS. And the last one I want to mention is that because we have the same fee model, you can also replace user operations in the mempool by submitting a new one with a higher tip to the bundler. You had a question? Yeah.
01:22:52.062 - 01:23:30.850, Speaker A: So the bundler is not incentivized to censor your transactions. If he does that, then someone else picks up your transaction and gains. Right. We have a peer to peer network, so you can discover nodes, right? Yes, they operate a peer to peer public, peer to peer network, just like Ethereum. Miners do. Nothing. That's the whole point.
01:23:30.850 - 01:23:57.574, Speaker A: Everything that you've seen here is possible given the current Ethereum protocol. It's an EIP that does not require a hard fork. We have solved the problem with smart contracts. I find it very entertaining. Not theoretically. You'll see in a second. All right, what are the new benefits? We already talked about it, but let's recap.
01:23:57.574 - 01:24:57.280, Speaker A: So you have verification logic flexibility. So your account is not only protected by a single signature, single private key, it can be protected by multi sig or social recovery, whatever execution logic flexibility. So eoas can send one transaction at a time. If you use smart contract wallet, you can batch multiple operations into a single transaction. So this example, approve and swap, for instance, on uniswap and another big one, your wallet is upgradable. So it's upgradable in multiple senses in a sense that you can change the composition of your multisig wallet, so change the owners of the wallet, but you can also replace the logic of the wallet altogether. Right? If you deploy the wallet under, sorry, behind the proxy, using the proxy pattern, then you can do basically whatever you want.
01:24:57.280 - 01:25:54.682, Speaker A: And that's a big one because you may have multiple assets and you don't need to move those assets from one wallet to the other, just to change your implementation right now. What are the downsides? Slightly increased attack vector for DOS attacks. So hard to explain, but in principle, ethereum transactions, you only verify one signature and you're done. Here you allow for somewhat constrained but arbitrary verification logic. So perhaps there is something that we haven't thought about, and we are actually susceptible to some attacks and gas overhead. This is where the fun stops. Unfortunately.
01:25:54.682 - 01:26:48.500, Speaker A: On Ethereum mainnet, in order to create your account, someone calculated that given using a standard implementation, you would pay 300,000 gas. Let's compare that to EOa zero. You generate a keeper, and that's it. What about transfers? Simple east transfer 21,000 gas. You all know that in ERC four 3780, what's interesting is that token transfers are not much more expensive as opposed to transactions. Right? I'm not sure if this calculation was already unbundled or not. I suppose that this was already unbundled.
01:26:48.500 - 01:27:43.590, Speaker A: In my view, the biggest reason why we're not all using that already. Perhaps the other one is that implementations are not ready yet. But I suspect this is also the reason. On Ethereum Mainet, it's absolutely expensive, given 30 gigabyte gas price, and now not really up to date price of Ethereum. Of ether, it would cost $23 to deploy a smart contract wallet this way. So this is the reason why previous projects like uniloggin failed, because deploying a wallet cost like $100 when gas prices skyrocketed. We see the same problem on Ethereum Mainet here.
01:27:43.590 - 01:28:32.630, Speaker A: So we should look to other chains where it's more manageable. And because this is all based on smart contracts, it's compatible with any EVM chain. We have talked about Ethereum, but you can port it to any other chain just as easily, which I think is very cool. The question is if we have any fork proposal that would make the scheme cheaper. I'm not aware of that, perhaps. Yeah, and someone asked before about implementations. These are just a few.
01:28:32.630 - 01:28:58.510, Speaker A: A couple more I haven't managed to track. Was there update? Was there status? But looking at the source code, it's happening. People are building that. There are commits from a day ago or a couple of hours ago. So it's coming. That would be it. Thank you very much.
01:28:58.510 - 01:29:16.130, Speaker A: Hope you guys any closing questions? Yes, I can send it to you later.
01:29:16.680 - 01:29:20.420, Speaker B: Can the Bundler force transactions?
01:29:21.880 - 01:29:59.230, Speaker A: Can the bundler force a sequence of transactions? Yes, this is actually another source of income for the bundler. MeV is possible on user operations, just as if your miner can order the transactions to benefit them. Bundler can do the same. It is complicated, but people are doing that. Ethereum is dark forest. Okay, thank you guys again. Close.
