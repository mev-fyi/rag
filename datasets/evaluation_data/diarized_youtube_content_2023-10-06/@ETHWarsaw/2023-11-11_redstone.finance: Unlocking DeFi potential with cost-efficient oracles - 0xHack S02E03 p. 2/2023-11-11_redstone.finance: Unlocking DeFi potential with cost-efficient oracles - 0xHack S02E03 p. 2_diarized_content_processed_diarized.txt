00:00:03.050 - 00:01:29.526, Speaker A: Thank you again for having me here. I'm a software developer at Redstone and today I'd like to tell you about the Redstone project and how we want to improve the blockchain oracles. As you probably know from the first presentation, a blockchain oracle is a third party service that connects smart contracts blockchain with the outside world world, meaning providing data like real world data, to the blockchain smart contracts. And the main use case for oracles today is providing pricing data. Because this pricing data may be used in lending markets, in decentralized insurance products, in liquidity aggregators, derivatives protocols, and even algorithmic stable coins like DAI and many, many more projects. There are a lot of ideas here, so pricing data usually are provided for cryptocurrencies and for fiat currencies, and sometimes for also stocks. But there are also many ideas what kind of new data can be provided on chain and the current most popular model how blockchain oracles work is that they post the pricing data to the blockchain regularly, for example every ten minutes, which has some advantages like this approach is quite easy to understand and easy to manage.
00:01:29.526 - 00:02:35.390, Speaker A: However, it becomes quite expensive and which leads to expensiveness of oracles in general and creates huge limitations. For example, in sense of that oracles cover really small subset of tokens and some small subset of assets in general. It also disables easy ability to switch to the new blockchain. But today new blockchain appears really often and this approach needs to run a separate oracle instance for every new blockchain. Another problem which is not connected to this approach is that oracles are often centralized and prone to manipulation. All these problems resulted in more than $1 billion hacked and stolen from Defi protocols that used blockchain oracles. And we at Redstone want to propose a solution which we already implemented in some stage.
00:02:35.390 - 00:03:38.660, Speaker A: And this solution has three main key points. The first one that we don't want to use blockchain like Ethereum blockchain for storing the data because Ethereum was not designed to store larger data sets. Instead we want to use cheaper storage that allows more data providers to come into the game. The second point is adding insurance to DeFi protocols in sense that data providers will pay some stake. That covers data reliability risks. And the third key point is that we want to create an accountable system with permanent track of each record and each data that was provided by data providers. And how do we do this in terms of cheap data storage? We want to leverage the rweave blockchain which actually was created to store large sets of data.
00:03:38.660 - 00:05:07.162, Speaker A: It also has many other advantages, but even if we compare a cost of 1gb storage, on Arweave it costs only $35, while on Ethereum it costs more than one and a half million dollars. So the second thing is managing the provider obligations and this insurance thing. And we do this through introducing manifests which kind of describe what data data providers need to provide. How often do they need to provide the data? And we do this currently as just a JSON file which has design structure. The second thing here is that, as I've said, providers need to pay some stake which can be taken from them in case of wrong behavior, for example, providing wrong data, or not providing data at all because of, for example, technical problems. And this problem resolution or dispute resolution will be handled using the smartweef contracts smartweef contracts are smart contracts built on top of the RWF blockchain. They have very interesting model of lazy evaluation and we addressed and see great potential in this protocol.
00:05:07.162 - 00:06:29.100, Speaker A: And we also contribute a lot here. And we've already implemented our own SDK for Smartweef contracts, which is much more efficient than the original SDK because of caching and modular architecture. But it's a topic for a separate call, so I'll skip here and move to the third point, which is I think one of the most important here. And the point is the efficient data access, and it's managed using this on demand fetching. We call it something like on demand fetching, meaning that we don't store the data on Ethereum, blockchain or any other EVM compatible blockchain, but instead we provide the data on demand and we provide the signed data so that they can be verified using the smart contract code which we've already prepared. And another advantage that comes here is the compatibility with any EPM compatible blockchain like Ethereum, Binance, smart chain, Cello Avalanche, Polygon, XDaI and others. And let's move to the architecture and I'll try to give you a general overview how the whole Redstone protocol works.
00:06:29.100 - 00:07:24.790, Speaker A: The core unit here is the Redstone node. It's something similar to blockchain node, but at this moment it doesn't communicate with other nodes, which will change in future probably. And the main thing that Redstone node does is fetching the data from multiple sources. Currently we fetch data from more than 60 sources, including different exchange APIs like Dexas APIs and simply on chain dexs data. We also use standard cryptocurrency exchange APIs like Binance, Kraken, CurrencyCom and many others. We also fetch data from Yahoo Finance website and European Central Banking API, and we fetch all this data. And the next thing that we do with this data is the data aggregation.
00:07:24.790 - 00:08:47.650, Speaker A: For example, if we fetch data for bitcoin price from 50 sources, we will take the median value. It's similar to this maker Dow approach, but we do this already here and we fetch the median value and then we sign each data point separately because each breadstone node has its own private key and it's used to sign each data point. And when the data is signed, we post it to the so called data cache layer and to the RV blockchain. Posting data to RV blockchain can take about 20 minutes, so it's not really useful in terms of real time data. That's why we also use this data cache layer. And data cache layer is currently our HTTP API and we are also working on integration with streamer, which is a pubsap decentralized network. And if users want to use the Redstone data, they will fetch them from this data cache and they will be able to use, and they are able to use the data using this HTTP API in simple web integrations, even not decentralized apps or in decentralized apps, but without the smart contracts.
00:08:47.650 - 00:11:00.622, Speaker A: But they also can use the data using in smart contracts. And I'll tell you much more about this because we've implemented a special tool called Redstone Flash storage that allows to integrate Redstone data in very straightforward way. Just a few words, what happens on arbiv blockchain also because arguably blockchain is used by Redstone to keep the data permanently and to manage disputes, because we also thought about this dispute resolution protocol, which is not implemented yet, but it will work on the smartwave contracts. What is already implemented is provider strategistry, which is a catalog of providers and their manifests and their manifest history that can be managed by providers and can be displayed and used by any user that has access to our web application, because the web application is actually connected to the arbitrated smart contracts and show this data that can be used and that should be provided by our current providers. So let's move to this Redstone flash storage thing because I think this is the most important part of our solution. So when dev developer wants to use Redstone data in their smart contracts, they need to install an NPM module called Redstone Flash storage and wrap the ethereum contract instance, the JavaScript contract instance, using our special wrapper. And this wrapper will update the contract logic in the way that when the contract will send a transaction or will run a view function, we automatically will fetch the data from the rest and API fetch the signed data and attach this data to the transaction so that on the on chain layer the smart contract will be able to verify the data and use it in smart contract code.
00:11:00.622 - 00:12:40.880, Speaker A: And today I'll show you this on the live coding session bit later. But one thing that worth mentioning is that we put really much effort to the Redstone flash storage optimization and we can say that currently reading the data using Redstone flash storage which actually includes this signature verification, is cheaper than reading the data from the Chainlink Oracle, which is the most popular oracle for blockchain nowadays. And of course these costs doesn't include data write costs, which are really cheaper thanks to the affordable rv storage. Okay, so let's go to the demo and if we go to the app Redstone finance, we can see all the data points that we currently provide, including crypto, mostly crypto, but also stock prices, currencies prices, PST, avalanche tokens, tokens from the avalanche ecosystem, ETF indexes and also commodities like grains, energies, metals and livestocks. And we can do all of this thanks to this scalable model with on demand fetching. If we go to the bitcoin, for example details, we can see the price chart with the bitcoin prices which were provided by the Redstone Oracle. On the right side you can see the sources, the list of sources that were used for fetching the bitcoin price.
00:12:40.880 - 00:13:52.738, Speaker A: We've also implemented this tool to compare the prices for different sources which can be useful for for example, finding arbitrage opportunities. And on the bottom you can see the list of RWF transactions that were used to keep these on RWiFF. As I've said, we use more than 60 sources now, including Texas simple cryptocurrency exchanges and also like ECB, European Central banking API and others. And this application, as I've said, has this interface to manage manifests by providers. So if we click for example to the main Redstone provider, we can see a list of provided data with the details containing which sources are used. And providers also have a web interface to interact with their manifests and to see the manifest history. Okay, so let's go to the most interesting part and let's try to use the Redstone data in our smart contracts.
00:13:52.738 - 00:14:28.900, Speaker A: I've already prepared a small project with a single smart contract called example and a simple test file which uses hard hut testing framework. So if I'm a blockchain developer and I want to use the Redstone data. I would go to the npmgs.com and try to find this Redstone flash storage module. Let's type redstone. We see the Redstone flash storage on the third position. Let's go here.
00:14:28.900 - 00:14:56.886, Speaker A: And it starts with the simple explanation that I've already told about. Let's go to the installation section. So the first thing we need to do is to install Redstone flash storage. I won't do this because I've already installed the Redstone flash storage here. So let's move to the getting started section. It contains two main parts. The first one is modifying our contracts and the second one updating the interface.
00:14:56.886 - 00:15:56.442, Speaker A: So let's start with modifying our contracts. The first thing we need to do here is to extend our contract with the price where contract implementation. So let's simply copy this to our contract code. Okay, and from this moment we can use the pricing data in the contract code using this get price from MSG method. And we need to pass a single argument here which is Pyte 32 value created from the simple string. So in our contract we would like to use Tesla price in USD and we can go to the prices in the Redstone web app and check that Tesla price is actually available and has DSLA symbol. So we can actually access this price using this method.
00:15:56.442 - 00:16:44.990, Speaker A: Let's do this. Let's replace the price here, replace the symbol, and let's do the same thing. Okay, so now we need to update this function modifier. Great. One thing that we need to check is that Redstone has eight decimals in their values, which means that we multiply the values by 100 million. It's a common approach that Chainlink also uses. Currently we've already prepared our smart contract to use the redstone data.
00:16:44.990 - 00:17:46.250, Speaker A: And the next thing that we need to do is to update our interface. And firstly, we need to import this Redstone flash storage wrapper. Let's do this. And we need to wrap our contract instance using this wrapper builder. And we can select this price feed that we want to use. We can use the Redstone stocks. It also can be checked on the Redstone application and we can also specify the asset.
00:17:46.250 - 00:18:52.680, Speaker A: In our case, we need to have the Tesla asset, Tesla price asset. So it should be enough. And now in every place where we want to access the Redstone data in every function, we need to actually replace this standard contract instance with the wrapped contract instance. So let's do this. Okay, and the last thing that we need to do is the provider authorization because our smart contract needs to know what providers is trusted and like what Ethereum public address can sign the data, the data that we can trust. And this can be done using this authorized provider method that we've prepared. And this method automatically analyzes the price feed that we provided here and actually uses the appropriate provider Ethereum address.
00:18:52.680 - 00:20:15.760, Speaker A: Okay, so now we can call this test, yeah, and we can see that the provider was authorized and actually that these methods from the contract were called correctly can take a closer look on these functions. In the first function we send a transaction and we update this private variable in the contract state called last price with the Tesla price. The second function doesn't interact with the state, simply fetches the Tesla price from the Redstone oracle and if it's greater than 1000 then it tells returns true and last price simply returns the value from this contract state. And in the toast code, firstly we send this transaction update this price in the contract state. In the second step we actually call this is overpriced function and in the third state we return the value from the contract state. Yeah, so that's how it works. And let's get back to the presentation.
00:20:15.760 - 00:21:24.276, Speaker A: Just a few words about traction in our project. As I've said, we already integrated data from more than 60 sources, more than data for more than 1000 assets and already generated more than 1 billion signed data points. Also our Redstone API, which is a JavaScript wrapper for the Redstone HTTP API, was downloaded 40,000 times since the launch. And we already have a few fully working proof of concepts including Komodo, which is Komodo, this trading synthetics protocol built on Ethereum and also built on the seller blockchain. And we also have a working demo working project lending protocol on the avalanche blockchain. Here's our team. We have Kupa who is our founder and very experienced technical guy.
00:21:24.276 - 00:22:13.428, Speaker A: We have other three developers, including me, the author and the other. And the first part is also very experienced software developer and we also have margin who is our head of growth. And of course as each blockchain team I think we are going to expand our team. We are currently closing the seed investment round and we want to find from ten to 15 new talents. So if you are good developer or just a good person, so reach out to us, we'll be happy to talk and find opportunities for you. And you can do this using our website. We have a contact form here, so simply go to the Redstone finance or you can write an email to hello.
00:22:13.428 - 00:22:29.590, Speaker A: At Redstone Finance or you can join our discord at Slash Discord and say hi and we'll be happy to chat with you. Thank you very much. So I'll be happy to answer your questions if you have ones.
00:22:50.500 - 00:23:07.828, Speaker B: When prices are provided by the Oracle, we cannot afford that. The delay as other users. Okay, that really depends because the delay is very intentional for us.
00:23:07.994 - 00:23:08.710, Speaker A: So.
00:23:11.400 - 00:23:22.650, Speaker B: You can actually read data directly from the medianizer without the delay. It's totally up to you. Both of them are provided and.
00:23:24.720 - 00:23:25.036, Speaker A: There.
00:23:25.058 - 00:23:35.390, Speaker B: Are some projects that are actually using direct medianizer values if that's required. So I hope this answers the question.
00:23:40.260 - 00:24:06.470, Speaker C: Yeah, guys, so if you have any other questions, feel free to ask them in the chat. We have both Alex and Pavel to answer them. We're going to give you some time to type that. Well, it looks like we don't have any questions for today.
00:24:08.680 - 00:24:09.044, Speaker A: So.
00:24:09.082 - 00:24:16.940, Speaker C: Yeah, guys, thank you very much for joining the meetup today. Next meetup will be in December 2.
00:24:17.010 - 00:24:18.190, Speaker A: Tuesday of the month.
00:24:18.960 - 00:24:24.700, Speaker C: Alex, thank you for the presentation and the live coding session. And Pavel, thank you for being here.
00:24:24.770 - 00:24:26.572, Speaker A: Thanks. It was a pleasure to host you.
00:24:26.626 - 00:24:29.150, Speaker B: It's a pleasure. The studio is nice.
00:24:31.120 - 00:24:34.060, Speaker C: Yeah. So we'll see you next month, guys.
00:24:34.210 - 00:24:37.976, Speaker A: Thank you guys. Thank you again. Bye.
