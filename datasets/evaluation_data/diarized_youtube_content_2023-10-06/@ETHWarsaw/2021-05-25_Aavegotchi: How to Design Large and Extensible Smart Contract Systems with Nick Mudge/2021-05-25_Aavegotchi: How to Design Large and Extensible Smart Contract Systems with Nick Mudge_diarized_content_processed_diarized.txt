00:00:00.170 - 00:00:05.790, Speaker A: Back, guys. And with me I have Nick march from Avagochi. Hi, Nick.
00:00:06.290 - 00:00:07.040, Speaker B: Hi.
00:00:07.890 - 00:00:21.470, Speaker A: Nick is solidity developer and EIP 25 35 author, and he will tell us more about that. So without further ado, Nick, the stage is yours.
00:00:22.130 - 00:01:18.194, Speaker B: All right, thank you all. All right, so first I'm going to cover some basics on what is an EIP. So maybe some people know about this, some others not. So I'm just covering it. So EIP is an Ethereum improvement proposal. It's a standard that is used by Ethereum to write software, and it applies to implementations of ethereum nodes and also contracts, contract standards. And so when an EIP is written for contracts, the EIP will solve a particular problem and then provide specific contract interfaces, which are function signatures and events that solve the problem, that are used in solving the problem and that enable interoperability with other contracts and software.
00:01:18.194 - 00:02:11.730, Speaker B: And sometimes you see ERC used like ERC 20, ERC seven two one, that's used interchangeably with EIP. So when there's an ERC 20, there's also EIP 20 really referring to the same thing. All right, so here's just a quick example of a simple contract standard. This is EIP one seven three. This solves the problem of owning a contract and then provides here the interface for the functions here to an event to use for people to own a contract and to transfer ownership. That's just a simple example. Okay, so now I'm going to go into what problems does EIP 25 35 diamond solve? Okay, so it solves the 24 kilobyte max contract size limit.
00:02:11.730 - 00:03:06.726, Speaker B: So this is the problem where you're writing a contract and you keep adding more functionality to it and you keep adding more. And eventually when you try to deploy it, it won't deploy because the bytecode of the contract is too large. And sometimes that's not a problem. You can break your contract into multiple contracts and solve it that way. Other times you really want all your contract functionality in one contract coming from the same address. Like for example, if you're implementing a non fungible token and you need all the functionality for that NFT to be in the contract from the same address, then you can run into this problem. There's other scenarios we could run into this problem as well.
00:03:06.726 - 00:03:54.662, Speaker B: So that's something that EIP 25 35 solves. So here it says, organizes contract functionality, a systematic way to isolate compartment different functionality and connect them together and share data between them as needed in a gas efficient way. Add structure and organization for large contract systems. So it really provides a standard way to implement a larger contract system that follows the same pattern of expansion. Okay? So it eases contract integration with user interfaces and other contracts by reducing contract functionality to a single ethereum address that does not change. Okay. Yeah.
00:03:54.662 - 00:04:48.746, Speaker B: So I have found that when dealing with contracts and user interfaces and other software, the less contract addresses you have to deal with, the easier it is to integrate or work with other software. Because if you're adding or removing new and old contract addresses, then you have to update all the places that they're being used. But if you just have one address that has a bunch of functionality and that can have more functionality over time, then the software that uses you just have to deal with one address. You only have to worry about one address rather than multiple addresses. Okay. Flexible upgrades only replace or remove parts desired. Highly extensible, can add unlimited functionality in a structured, organized way.
00:04:48.746 - 00:05:58.400, Speaker B: So typically when upgrading contracts, it's typically done in a couple of ways. One, you have a completely immutable contract and the way you upgrade is just deploy entire new contract and migrate any data to the new contract or do some kind of data migration scheme and switch everything to a new address. Or you might have like a proxy contract where a proxy contract uses an implementation contract and you deploy a different implementation contract and then update the proxy with the new implementation contract. But basically in both those approaches, you have to throw away all your functionality and redeploy the functionality again. But with the EIP 25 35, you can just update the things that changed or just add the things that are new. You don't have to replace everything. So that can be a good thing.
00:05:58.400 - 00:06:46.526, Speaker B: All right, so it says if you plan to build a contract system that can grow or change over time, then a diamond is a good choice because it enables a system to grow in a systematic and organized way. All right, so now I'm just going to go over a little bit of some basics on what exactly a diamond is, how it's implemented a little bit here. So a diamond is a fallback function that delegates or borrows functions from other contracts. And these other contracts are called faucets. A faucet is a side of a diamond. A diamond maps functions to faucets that implement them. So you got a fallback function.
00:06:46.526 - 00:07:44.486, Speaker B: And when functions are called on this contract, it looks up a mapping to find out, well, which contract should it borrow the function from, and then it borrows it. So basically the diamond uses a fallback to borrow functions from other contracts. And that's really the simplicity of it. So this is just a little diagram that shows what's happening. So there's a mapping from function selectors to faucet contract addresses. So you can see there that when function one is called, then it knows to get the function from this address and so on. Okay, so let me give you an example of this being useful.
00:07:44.486 - 00:08:16.690, Speaker B: And that's something that's happened. Okay, so avagatchi. So avagatchi implements erc seven two one functions because avagatchis are erc seven two one tokens. So avagatchis are nfts. So the way Avagatchi is implemented is it has this Avagatchi faucet. It implements all the ERc seven two one functions. So this faucet is added to the avagatchi diamond.
00:08:16.690 - 00:09:12.770, Speaker B: And then we have an avagatchi game. Faucet game related functions like petting an avagatchi are put into this faucet and then avagatchis can wear or hold items like hats and shirts and grenades, all kinds of things. And these are ERC 1155 items, another kind of token or NFT. So this faucet implements ErC 1155 functions. So you can see the pattern here that related functions are separated and put into their own faucet. So that we have a diamond with a lot of functionality, but it's organized by faucet and each faucet has related functions. Okay, we have a shop faucet which is used functions that enable buying avagatchis and items.
00:09:12.770 - 00:09:41.950, Speaker B: SVG faucet function storing and retrieving the on chain art for avagatchis. So avagatchi stores its image data on chain. And so this faucet has functions for storing the image data and retrieving it. Okay. And then various other faucets implement more functions. Okay. So then deploy and launch.
00:09:41.950 - 00:10:17.274, Speaker B: Avagatchi is live, users are playing success. Okay. Turns out we need a marketplace that lets users buy and sell their avagatchis. No problem. So we just write a marketplace faucet and deploy it and add it to the existing avagatchi diamond. So this is just an example of after launching and deploying, need some more functionality. Well, you can just add that functionality and you don't necessarily have to touch or deal.
00:10:17.274 - 00:10:43.806, Speaker B: It's just new functionality added to the diamond. It doesn't necessarily have to change or affect other parts of the diamond. Okay. Users want to be able to bridge their avogades from polygon to ethereum. So maybe you want to bridge between different blockchains. Okay, no problem. Write a bridge faucet, deploy it as avagatchi diamond.
00:10:43.806 - 00:11:10.890, Speaker B: So you get the idea. So you want new functionality, you can just add another faucet. Now, sometimes you might want to add some additional functions to an existing faucet. That's okay, too. You can do that. You can also remove functionality as well. Okay, so this slide here is just to kind of reduce things to the simplicity.
00:11:10.890 - 00:12:06.380, Speaker B: So, a diamond really has three things that makes it a diamond. It has a fallback function that borrows and executes functions from faucets. We've covered that. And it emits the diamond cut event anytime any function or faucet is out of, replaced or removed. So this event emits anytime there's a change to a diamond, anytime there's an upgrade. So, this is a way to track or make diamonds transparent so that you can see the historical change of diamonds. Now, if every faucet has its source code verified, that makes it enables third party people to be able to trace the development of a diamond and see what's been added and what's been removed, and you get the idea.
00:12:06.380 - 00:13:09.154, Speaker B: Okay, so has these things, these three things has the fallback function, these things, the fallback function, the diamond cut event. The last thing is the loop function. So, a loop is, in the diamond industry, a loop is a special magnifying glass that's used to look at diamonds. And so, in this standard, the loop functions are four functions, standard functions that tell you what's in a diamond, what faucets are being used, and what functions from those faucets are being used in the diamond. The standard describes these three things and how they're supposed to be so that they comply with the standard. All right, these things are standardized for interoperability, so that if you standardize the event, you standardize the loop functions. Then you can write software that.
00:13:09.154 - 00:13:38.406, Speaker B: Generic software that works with all diamonds. Here's some tools. So, there's a website called Looper dev, which is a generic user interface for viewing and executing functions on diamonds. Also provides upgrade information. So this is like an ether scan for diamonds. So you go to this website, you put in the address of a diamond, and then it can show you all the faucets it's using. All the functions from those faucets.
00:13:38.406 - 00:14:06.850, Speaker B: It can link to either scan, so you can see the verified source code. It can show a list of upgrades that have been done and then also allows you to execute functions on diamonds. So that's pretty useful. And the standard really enables this user interface to work. Okay, hard hat. Deploy plugin for hard hat that provides built in support for deploying diamonds. Solid state solidity.
00:14:06.850 - 00:15:09.190, Speaker B: This is a new library, solidity library that employs diamond storage exclusively and provides a diamond implementation. So I haven't covered diamond storage, which I will, and soon. But diamond storage is a way to organize state variables in diamonds. Okay, I also have a link here to, there's some existing diamond implementations that people can start from or use. Okay, so here's just a little brief look at the Looper website. Okay, so diamonds create and solve problems of their own. So unfortunately, diamonds, there's some problems with them that the standard and the documentation also has solutions for overcoming these problems with diamonds.
00:15:09.190 - 00:15:50.418, Speaker B: So when implementing diamonds, the built in state variable layout functionality that solidity provides isn't sufficient. It doesn't really work with diamonds. And so solidity manages your state variable layout. So solidity developers don't have to think about it. But with diamonds, you need to have a way of organizing state variables. And once you just have a systematic way of organizing your state variables, then you don't have to think about it either. You just follow how you do it.
00:15:50.418 - 00:17:10.522, Speaker B: And so diamond storage is a pattern of laying out state variables in diamonds and also in proxy contracts that works. And there's another pattern called app storage. App storage is a specialized version of diamond storage. The advantage app storage has is it can make it more easy and convenient to share state variables across different faucets of a diamond. So if you want to be sharing state variables between different faucets, then app storage is good for that. Regular diamond storage can also be shared between different faucets as well, but it can be a little bit less convenient. Okay, so because diamonds just has a fallback function, it can be OPAC, meaning like if you go look at the verified source code of a diamond, you just see a fallback function and you don't know, well, where's the source code for the whole diamond? As you've seen earlier, this is really solved with the diamond cut event and the loop functions.
00:17:10.522 - 00:18:13.886, Speaker B: So they bring the transparency back to diamonds and then tooling like the looper can then use that to show all the information for diamonds. Also like testing code can be used to inspect diamonds to make sure everything is correct when implementing diamonds. So testing code can take advantage of the diamond cut event. It can also take advantage of the looper functions. Okay, so one thing that's commonly asked about diamonds is how do you call a function from one faucet that exists in another faucet? And there are multiple ways to do that, and it depends on the situation. But commonly the easiest way to do it is to create a solidity library with internal functions, not external functions, internal. And then import the solidity library into your different faucets because your different faucets can then use the internal functions of the solidity library.
00:18:13.886 - 00:19:08.302, Speaker B: So that's a really simple solution. All right. So if you want to learn more about diamonds, then it's good to know understand how contract storage state variable layout works. This is found in solidity documentation, how delegate call works, and how diamond storage and App Stores work. This can be found in blogs or in the standard itself. You can also learn about how faucets that are deployed can be already deployed. Once faucets are deployed, you can actually reuse deployed faucets from other diamonds.
00:19:08.302 - 00:19:53.540, Speaker B: So that's kind of an interesting case where like, say you have an ERC seven two one faucet, you deploy it, add it to your diamond. Well, there's no reason you can't just reuse that already deployed faucet for another diamond. So you can share deployed code among different diamonds. So that's something that you could get familiar with or do. And you can also learn more about doing upgrades. So a good place to also learn more about diamonds is looking at the documentation for Avagatchi's contracts. There's overview of diamonds there.
00:19:53.540 - 00:20:20.140, Speaker B: You can join the diamond discord. There's people in there discussing diamonds and various things. Okay. So also there's a bunch of references here and useful information. And I'd like to know if there's any questions or anything at this point. I know I kind of went through this quickly. Hopefully it wasn't too fast.
00:20:31.250 - 00:21:02.330, Speaker A: I don't think we have any questions at the moment, but I put all the links in the description of your video. So in case someone wants to get in touch with you, we have just one question and what's the best way to contact you? So your email address is right at the screen and there is also a link to Nick stack in the video description. And you can find all the links?
00:21:04.110 - 00:21:18.060, Speaker B: Yeah, yeah. I can be emailed. I'm on discord as, I'm on Telegram as mudgen. I'm on Twitter, so I can be DM'd there.
00:21:19.390 - 00:21:20.186, Speaker A: Awesome.
00:21:20.368 - 00:21:21.100, Speaker B: Yeah.
00:21:21.750 - 00:21:29.540, Speaker A: Nick, thank you very much for taking the time to do this presentation and yeah, thanks a lot.
00:21:30.150 - 00:21:31.460, Speaker B: Okay, thank you.
00:21:32.950 - 00:21:34.510, Speaker A: See you, Nick. Bye.
