00:00:00.090 - 00:00:02.750, Speaker A: With me is Alexander. Hi, Alexander.
00:00:03.330 - 00:00:04.080, Speaker B: Hi.
00:00:04.770 - 00:00:27.350, Speaker A: Alexander is a runtime engineer at parity. So if you want to learn, start building on Polkadot. That's the time Alexander will give you an introduction to substrate. And. Yeah, Alex, I'm very happy to have you. I'll give you the stage.
00:00:28.330 - 00:00:58.090, Speaker B: Cool, thanks. Happy to be here. All right, so I was already introduced. I'm Alexander, and I'm going to give an introduction to substrate for solidity developers. Polkadot was already mentioned. It's not going to be the focus of this talk. The key thing to note is that because substrate is so flexible, you can use it to build a Polkadot based chain.
00:00:58.090 - 00:01:50.494, Speaker B: So that's one of the things that you can do. That's not the focus of the talk. The talk will focus on introducing substrate, the framework. So, right, Polkadot, the chain and the sort of Internet of blockchains or the connection between blockchains and substrate, the blockchain building framework that allows you to build this kind of chain. All right, where are we at? We want to build blockchains, right. Sort of going back to the basics. What are we building? We're building this thing where we have this general format where we have a header and a body, and then you have some sort of state transition function to the next thing.
00:01:50.494 - 00:02:39.600, Speaker B: And this allows us to do all kinds of fun things, including building cryptocurrencies. And there are different ways that you can now make building this easier. And what I want to do is introduce the substrate blockchain building framework as a way to do this more easily. Right. To build your own well state transition function. So how do I think of substrate? I think of it as building blocks, as these Legos. That allows you to put together a blockchain from these different pieces to get the particular blockchain that you want.
00:02:39.600 - 00:03:57.030, Speaker B: So this image and the idea of Legos makes it, of course, seem as if all of those building blocks are exactly the same, but that's, of course, not the case. So we look at a blockchain more as consisting of these different components. And so substrate is not just, okay, you have these building blocks, but it provides different building blocks already pre built so that you can focus on building the particular thing or assembling the pieces in the particular way that you know best or that you're focused on. So that you don't spend your time building a telemetry system. Right? For example, on the right hand side, one of the building blocks, you don't spend your time rebuilding a telemetry system. You can just use the building blocks provided by substrate. And then substrate is built in this modular way where you could swap out the telemetry system for something else, or you could swap out the database for something else without changing the RPC.
00:03:57.030 - 00:05:03.674, Speaker B: So in this image, you can see that we have a node consisting of these different components pulled together, and then you will see that there is an executor mentioned here and a runtime. And this brings me to a point where I want to start sort of comparing contrasting substrate with ethereum and solidity. But first, before we come to that, I want to look at another set of building blocks. So we have this executor with this runtime button. Time is also going to be a complex thing. The runtime is the core logic of your blockchain. It defines the state transition function, right? The arrows that we saw earlier, it defines the state transition function, the logic of how blocks are produced.
00:05:03.674 - 00:05:44.400, Speaker B: And so it can get fairly complex if you're building a complex blockchain. And so it will also be made up of pieces. And so there is sort of a framework within a framework in substrate, which we call just frame, which allows you to assemble runtimes based on these reusable components called pallets. So pallet is right. It's just a runtime module that you can put in there. So substrate doesn't just come with components to put together to create a node. It also comes with this framework frame for building runtimes, assembling runtimes together.
00:05:44.400 - 00:06:51.810, Speaker B: That allows you to define the state transition function. All right, so now that we've introduced these rough components, the building blocks of the node and the building blocks of the runtime. Now let's start contrasting with Ethereum. So when we draw the comparison between the two, I think it can be useful, actually to see the similarities. And if you zoom out far enough, it actually looks fairly similar. So on the outside, you have this ethereum node or substrate based node, right? And if you squint a little bit, you could say that, well, both have a runtime, right? One has the ethereum virtual machine, and on the other side, on the substrate side, we have a frame based runtime. And those runtimes allow defining modules in there that can be adjusted as needed.
00:06:51.810 - 00:07:57.080, Speaker B: So in a frame based runtime, you have these pallets, these modules that you can put in there, and in the EVM, you can deploy smart contracts. So you have this modular system. So from 10,000 foot distance, sort of squinting hard, they look the same, but of course they're not, right. There are differences and I want to start looking into those differences. Now, what is one of the key differences? Says right here on the slide. One of the key differences is that substrate does not just come with a means of defining a protocol, which is the runtime, the state transition function. It also comes with a meta protocol that allows a way of defining how to change the state transition function.
00:07:57.080 - 00:09:07.866, Speaker B: So you have a way of upgrading the runtime without forking the chain, right. Of course, you can always upgrade the node, right? Add something there and then roll it out. You sort of talk to people in the community and they roll out a new version of the client. But if you want to make controversial changes there, you might see a split, right? You might see a fork, as has happened plenty of times with Ethereum, ethereum classic, or with bitcoin, bitcoin cash and so on, you will see the split. So if you can, you want to avoid relying on people to coordinate to roll out all of these different nodes in the ecosystem. Sorry. Okay, so what you want to do instead, and what substrate allows you to do is you define the state transition function in the beginning, your runtime, and then you send a transaction that includes a new runtime into a block.
00:09:07.866 - 00:09:48.358, Speaker B: And then from then on, for example, in this case, block 43. From that point on, the new runtime will be the state transition function of your blockchain. So it's part of the consensus what the runtime is. And so if you change the runtime, everyone will upgrade automatically. And of course they can still fork if they really want to. You cannot keep people from forking, but the default will be to run with a new logic, if it is agreed upon. So you will have this runtime, version one on the left hand side, you have these four modules that are included.
00:09:48.358 - 00:11:18.498, Speaker B: And then you do a forklift upgrade, and you have a different runtime, version two that includes other modules, in this case six, and all without doing any forks. So this was our image before, where we saw the similarities now. So if we come to the differences where you can upgrade a smart contract in Ethereum, at least, if the smart contract was sort of set up in the right way, right, you can upgrade it, or if you can just, of course, deploy a new contract and then have that be version two, what substrate allows you to do is to swap out the whole runtime and then that it can include new modules and so on and whatever you want. But you can swap out the whole runtime and so change the state transition function. So the flexibility of the logic is at a much deeper level compared to vcm virtual machine. All right, so one of the things, it's a very sort of, I would say, very shallow surface level difference is sort of the difference in language, right? On the substrate side, we have rust as the programming language and then some macros on top of that to help with defining the runtime. And then on the Ethereum side, we have solidity and other smart contract languages to define.
00:11:18.498 - 00:12:09.782, Speaker B: And that's going to make some difference, right? And so some of the difference that we see in this image here in the slide here is just the difference in syntax between the different languages. But again, if you squint and you look at it from a little further away, you can see that the structure is fairly similar. You have the struct asset balance that includes free and reserved balance. You have a name accounts, that is a double mapping from an asset ID and an account ID to the struct that we just defined. So again, if you look at it not too closely, it will look the same. And then you can see that substrate is a little bit more elaborate. And part of that is just that it's rust, right? It's just the language.
00:12:09.782 - 00:13:43.960, Speaker B: But part of it is also one of the differences between substrate and Ethereum, that it gives you a lot of flexibility to adjust things and a lot of screws turn and things to adjust that you just wouldn't have. And that's why you have more moving parts, right? You annotate with pallet storage, and then you can define a hasher. So Blake 2128 Concat is a hasher that determines how your key is hashed to access the access storage, right? With just a quick recap, storage being the sort of persistent state of a blockchain that, for example, stores the accounts, as we can see here, to store the balances of users. So we see both the similarity and also the differences between the two systems here. And it sort of already points to the thing that I want to talk about now, which is the difference in motto, sort of like substrate going with more of a motto of, with great power comes great responsibility. And Ethereum going more of a motto of mine, your own smart contract, right? As long as Ethereum doesn't have any significant bugs, to some extent, you can just build your own smart contract. And if you make sure that that one doesn't have any reentrancy attacks and is secure, then you can be sure that it works out fine.
00:13:43.960 - 00:14:38.806, Speaker B: But it also has limited tools. And so in substrate, you can define things, you can change things that are both dangerous but also useful. So I want to take the time, take a moment to look into some of the dangerous useful things that you can do in substrate that you might not be able to do in Ethereum. Two of those that I want to mention are right now are unsigned transactions and custom priorities. So in a normal blockchain, you have a user sign a transaction, include a fee that goes to the block author usually, but include a fee, and that allows for spamming prevention. Right, the whole Sibyl thing. And this is a good way of doing this.
00:14:38.806 - 00:15:16.958, Speaker B: And of course, substrate supports this. But what you might want to do is you might also want to include transactions that don't follow this model. And substrate gives you the ability to define transactions that are not signed and do not include a fee and include custom priority. So what's an example of this? I want to apologize in advance for the amount of code that I'm showing. So in order to make it a bit more readable, I'll highlight what I want to point out. So this is an implementation of validate unsigned, right? So you cannot just pass in unsigned transactions. You need to validate them.
00:15:16.958 - 00:16:30.886, Speaker B: Otherwise you open yourself up to, for example, Dos attack, denial of service attacks. So what you do is you check, for example, like, oh, I expect a heartbeat call. And then if a particular call comes in that you expect and that you can validate, then you can sort of do that validation, which I've allied it here. And so this particular validate unsigned is from I'm online. So in Polkadot, the blockchain to sort of allow the shared security and the interaction between other blockchains, the validators, they produce blocks, but they also send this heartbeat that we see here to show that they are online, because it's important that all of the validators are reachable, are available. You sort of send a heartbeat, and that heartbeat is not going to not include a fee, it's going to be a free transaction for them. And instead of sort of being signed at the transaction level, the unsigned transaction includes a signature that then is validated.
00:16:30.886 - 00:17:32.502, Speaker B: So there is no fee involved, but there's sort of a signature inside of the transaction that is checked by the other validators. And so then if the signature checks out, then the heartbeat will be stored. And then it's like, okay, this particular validator is online and is doing well. And then the other highlight is the priority, right? When we validate the transaction and say like, yes, this is valid, we can include some information, including a priority of how important is this transaction to include in the block. I would say that I'm online probably has a fairly high priority because it's sort of part of the consensus system, but for something else that is much more optional, you might decide on a different thing, right? You might decide that a validator can include some data in the block if there's enough space or whatever. So it's a low priority kind of thing. All right, so that was unsigned transactions.
00:17:32.502 - 00:18:17.594, Speaker B: And one of the things that it allows to do is, for example, custom priority. So another dangerous but useful thing is to set the transaction feeds. I have another example here, this one with a little bit less code showing how substrate handles this. So I don't have a lot of slides on this. I'm going to gloss over some complexity here. But substrate comes, or more exactly, frame comes with a weight system. So weight in some senses is similar to gas, but in other senses different, where gas is evaluated after the execution is complete, while weight is estimated before the execution begins.
00:18:17.594 - 00:19:15.986, Speaker B: And so substrate and frame allow to calculate the weight based on the inputs to a transaction. So in this particular case, we have a set storage extrinsic, which is a transaction that you can include in the block to change some storage item. It's a privileged operation in frame system, but that's not very important for us right now. What is important is that the items are part of the signature and thus available for the weight computation. So we can calculate the set storage weight, which you can see in the highlight. We can calculate that weight by passing in the length of the items. So the more items, the more weight is going to be taken up by this transaction, and the higher the fee is going to be.
00:19:15.986 - 00:20:12.180, Speaker B: So it's sort of proportional, and we can react to the transaction. The second one that's in the highlight is the dispatch class operational. This is one fairly crude but very useful way, another way of, in some sense, defining transaction priority. So dispatch class operational means that this is a crucial transaction that needs to be included in a block. And there is a part of the block that's reserved for operational transactions so that they can be sure to be included, so that it cannot be droned out by other regular transactions. And this is another thing that you can pass in this signature. All right, what's another dangerous but useful thing that you can do? One of the things is you can schedule recurring work.
00:20:12.180 - 00:21:24.714, Speaker B: So in Ethereum, you might, for example, have an oracle, but in order to have an oracle on Ethereum, you need to have some middleware, some external system to the node, pass in transactions that will be to sort of process regularly like a regular transaction, or if you want to, for example, tally a vote, you need to have some externally trigger this vote tallying to run that logic. What substrate allows you to do is to schedule recurring work. So here's another example. Again, sorry for the amount of code, it's going to be a lot. But again, I have highlights here to show you sort of the bits that I want to point out. So we can define an uninitialized function which will be run on every block. So it includes the block number and it's a hook, right.
00:21:24.714 - 00:22:25.630, Speaker B: You receive a call to this function when the block is being initialized. And so you can execute some logic every block here. And one of the things implemented via the uninitialize is actually the scheduler. So what the scheduler allows you to do is not just to execute something on this particular block, but you can tell to the scheduler, hey, please, on block number 5000, please execute this call. And what it will do is sort of, I want to highlight in the other highlights. So what it does is it calculates the cumulative weight of all of the calls that are part of the particular queue that it's processing for the particular block right now. And then it will dispatch that call, which is the third highlight.
00:22:25.630 - 00:23:14.830, Speaker B: It will dispatch that call and execute it, and then deposit some event with the result of the dispatch. So this is very simplified. This will not actually compile as it is on the slide, but it sort of shows the structure right. You can execute some logic every block. And of course if the scheduler didn't check the weight right, it might actually lead to an overweight block. And this can actually still happen, because directly above the third highlight, you can see that a call is always executed if it is the first call. So if something has way too much weight, but it is the first call, it will still be executed and might lead to an overweight block.
00:23:14.830 - 00:23:56.998, Speaker B: And so that is mostly fine, but if you didn't check weight at all, you might have arbitrarily heavy blocks. And that's of course something to avoid because you want to keep to your block time with your blockchain. So again, this pattern of great power, but also great responsibility. And then one of the last things is you can define your own consensus. I've already alluded to this with the components and want to sort of elaborate a tiny little bit on this. So you have the consensus, which is a module in the node. And then I sort of allied it earlier, that it's also going to be a module, a palette in the runtime.
00:23:56.998 - 00:25:02.320, Speaker B: And those two working together, right? And you can then define a custom consensus. So Polkadot, for example, is proof of stake. But with substrate, you can build a proof of work blockchain where the runtime component, for example, includes noting down the block author and then includes some logic to compensate, to mine some tokens to that block author, and that's in the runtime. And then the consensus logic in the node is going to be the mining of mining the hash, whatever, as we all know from bitcoin and friends. So you can swap out. And of course, this is incredibly powerful, but also incredibly dangerous, because if you screw up your consensus logic, your blockchain will not work. And there are more, right? There are a lot of screws that you can tighten or loosen, a lot of parts that you can swap out.
00:25:02.320 - 00:25:48.522, Speaker B: Sorry. And that you can do. One last thing that I want to talk about is I drew the similarities between substrate and Ethereum. And one of the things that I want to point out is that there is something called the contracts palette. And so you might be saying, like, all of this palette stuff sounds great, but I still want to be able to write smart contracts. And I'm happy to say that you can, you can still write smart contracts even in a substrate ecosystem. So if you have parts of your logic that you would like to write as a contract, or you want to make your runtime extensible for others to write smart contracts, you can do that via the contracts palette.
00:25:48.522 - 00:27:00.870, Speaker B: And so really, the comparison, maybe coming back to this one last time, you could say, like, oh, we have the runtime, and then the runtime can, but does not have to include the contracts palette. And so you could have a similar decentralized exchange smart contract on the substrate based node in your substrate based chain as you could on Ethereum, because so extensible and configurable, you can have smart contracts too. You can have your cake in Ed two. And then there are different options. Like, there is a shout out here to ink a rust based smart contract language that compiles to wasm that some people at parity are working on that allows you to sort of execute very easily with very little overhead. And then there's also actually an implementation of the EVM that can run in a substrate based node. I think the project is called Frontier, where you can actually execute solidity smart contracts in the context of a substrate based runtime.
00:27:00.870 - 00:27:19.640, Speaker B: And I think there's, of course, plenty more to talk about. I'm open for questions, but I think that's it for now. I cannot hear you, Anthony.
00:27:21.180 - 00:27:22.490, Speaker A: That should be better.
00:27:23.100 - 00:27:24.650, Speaker B: Yes, perfect.
00:27:24.960 - 00:28:01.552, Speaker A: Thank you very much for your presentation. Introduction to substrate. I don't think we have any questions at the moment, but if you drop some links where people can reach out, I can see that you did that on the last slide. I'll make sure to put them in the YouTube video description so people can reach out to you if they have any questions after watching the video. Yeah, happy to have you. Thanks a lot for your time. And, yeah, let's keep in touch.
00:28:01.552 - 00:28:03.210, Speaker A: Hope to see you here again.
00:28:03.980 - 00:28:04.772, Speaker B: Bye bye.
00:28:04.836 - 00:28:05.780, Speaker A: See you. Bye, Alex.
