00:00:24.160 - 00:00:51.958, Speaker A: Awesome. Hi, everybody, welcome to e four so x Starknet. We're co hosting together with Starknet team. We're e four so crew. We're hosting biggest Ethereum focus conference in central and eastern Europe and eastern Europe or somewhere around that. And we're gonna go right into today's topic of the meetup. So this time we're gonna be deep diving into what's happening on Sarknet ecosystem.
00:00:51.958 - 00:01:33.112, Speaker A: We have three awesome guest tonight. So first off, we're gonna start with Dylan from Sarkant foundation, who's gonna guide us through the culture of building at Starknet. Small round of applause for dylan, and then we're gonna move on. Awesome. Then we're going back to our regular so Marcello from Herodotus talking about how Cairo is not just starknet. Another small round of applause. And we're going to be wrapping up with the description of how Starknet is getting to decentralization done by Mikoya Barbitsky from.
00:01:33.112 - 00:02:07.982, Speaker A: Never mind. See you caught up with the small round of applause for after every person. And just to remind you why we're doing all of that, so e four so is organizing a conference this year beginning September 5 to eight, happening in that particular location. So we already know the venue. It's going to be two days of conference and two days of hackathon. If you were last time, you know it's fun. If you want to come again, we're more than happy to host you.
00:02:07.982 - 00:02:29.984, Speaker A: And for the new ones, remember that we have the early bird tickets on sale right now. So if you go to our website, you can get tickets for a lower price. And without further ado, because I'm starting to go red, which is always signed for me to stop talking, we're going to go to the first presentation. So a bigger round of applause this time for Dylan. Come over here and we're going to get you set up.
00:02:36.884 - 00:03:35.544, Speaker B: We have one normal profile picture, and it's not mine. Perfect. Hi, everyone. It's great to be here in Warsaw. Hi, I'm Dylan from the Starknet foundation, and I'm here to talk about Starknet. Over the next 15 minutes, we'll be talking about what Spark net is, how we differentiate, and I'll highlight some of the innovation ongoing. So people often ask me why they should build on Starknet.
00:03:35.544 - 00:04:22.924, Speaker B: And it's pretty simple. The first thing is cheap call data, cheap and powerful computation and native account abstraction. Together, these form a highly scalable solution, backed by mathematical proofs called starks that ensure verifiable and correct computation. This forms a backbone of what we call the integrity web, resolving the need for inclusivity while enforcing a broad social consensus, again, all enforced by scalable and transparent proofs. But it's not just about the technology. Our community is a big reason why people build on Starknet. It's extremely collaborative, it's extremely active, and people here love to experiment.
00:04:22.924 - 00:05:20.834, Speaker B: They're also willing to help, especially if you have an idea that's fairly unique. Before we can get into why Starknet or how starknet differentiates, we do need to understand the core issues on the l one and understand what ZK rollups are actually trying to solve. Some of this might be a little basic, so bear with me for some people, but to get a little idealistic, the core issues of a blockchain are about one, accountability and two, inclusivity. That means anyone can join the network, and anyone can participate in the network. Ethereum has done a pretty good job on that, but there has been tension as it tries to scale while managing, while enabling users to actively participate. Centralized entities have it pretty easy. They just get bigger and better computers.
00:05:20.834 - 00:06:00.762, Speaker B: But decentralized entities like Ethereum? It's quite difficult. Ethereum has tried before. The l two strategy has tried increasing gas limits, increasing block size, but that's costly and it excludes people from the network. So how do we solve this? We'll get into that soon. But the reason why I'm bringing this up is because it's all about cost. Every interaction between a Dapp and a user needs to be verified by every participant on the Ethereum outline. So when you do a transaction, you are paying for not only your computation, but also the computation that comes after you.
00:06:00.762 - 00:06:54.806, Speaker B: For people to reverify and resync the network over time. We solve this with validity proofs to scale Ethereum and offer cheap computation. So instead of reverifying the entire interaction from scratch, Arcnet offers these validity proofs that attest to the integrity of the computation. Verifying this proof is significantly easier, cheaper, and faster than reverifying the original interaction. Again, this is huge because it saves a lot of money for gas and also improves throughput. This is extremely important and an absolute game changer for developers of all projects, but particularly for app developers. App developers care about building a cool project, but they really care about getting users, and users are price sensitive.
00:06:54.806 - 00:07:46.538, Speaker B: They're not going to go and play around on a new app if they're paying a ridiculous amount of fees. So we open up the door for cheap computation for more users to test out your app. But it goes beyond that. With powerful and cheap computation, app developers can add more complex features to their applications and actually expand what is possible from an app development standpoint. So not only do they get more users, they can build better apps to get more users. And I think that is kind of huge to understand that we are taking away the restrictions of the EVM on Starknet and we'll get into some of the differentiation a little bit later with Cairo and yeah, I mean Starknet, we're growing pretty well. We're one of the largest ecosystems by full time developers.
00:07:46.538 - 00:08:31.064, Speaker B: This is a chart from Electric Capital as of December 31, 2023. You can see Starknet's the only project in the top 16 that has a green in the growth for 2023. That's a good thing. It kind of shows the resilience and growth of the Starknet community. We've been accused, we are very builder first. We've been accused of being too developer focused, but the numbers speak for themselves and people like building on Starknet because we have the single best stack for building complex and unique applications, period. And honestly, so like this is just a microcosm of our ecosystem.
00:08:31.064 - 00:08:51.534, Speaker B: There's a lot here and frankly I can probably name 70 other projects within the starknet ecosystem. Literally, I've given out 64 grants in the past month and a half. We'll get to that soon. There's a lot of things building here. This is not all of it, but this is just some of it. This is a lot. And we have everything from infrastructure to cool and unique applications.
00:08:51.534 - 00:09:45.298, Speaker B: And that's because of Chirop. Circlet is not EVM compatible and it's been purpose built because we are optimizing for performance over compatibility with the EVM. We use Cairo, which is a provable programming language for validity groups. Provable programmed just means you create a proof rather than that doesn't need to be re executed by all the people on the network. This proof is basically the validity proof that attests to the integrity of the computation. And kind of in contrast to solidity which is built on the EVM, Cairo is built on the Chiro VM. There's a reason for this because ZK rollups require a completely different architecture than is necessary on the l one with EVM based on ZK circuits.
00:09:45.298 - 00:10:42.684, Speaker B: That means that compatibility with the EVM is actually a performance compromise, which is why Starknet decided to build an ecosystem completely independent of the EVM. And yeah, I mean Cairo's pretty awesome, you should check it out. And it's actually kind of cool, because we call this the Chiro filter. If you are building on Cairo, you are probably a unique and special dev. Every dev in Starknet is unique and special, but especially the ones that are pretty good at Cairo because we're not EVM compatible. It does create this new, these kind of side effects and it's been kind of very important for the social identity in Sarknet. Really people in Sarknet, I would say our average developer, really does think from first principles to actually leverage a powerful and cheap computation that Starknet is actually able to offer.
00:10:42.684 - 00:11:23.130, Speaker B: I'll get into some of these things because it is quite a fascinating area about the culture that we've built in Sarknet. The first side effect is this motivation filter. There's no point in building and learning Cairo if you're just building a low quality project. If you want to copy and paste your project to the hundreds and hundreds of l two s out there and the hundreds more that will be created eventually. Just there's no point in building on Sarknet. So the point I'm trying to make is the projects that are actually coming on board, the developers that are coming on board are actually building interesting applications, not low quality projects. So that's a motivation filter.
00:11:23.130 - 00:12:02.128, Speaker B: The second side effect is the fact that the EVM on the l one is not immutable. This means the EVM changes and will continue to change over time. So if you are building on an l two, a ZK roll up that is EVM compatible, just know that the compatible EVM side will change because it's not immutable. That means you will continue to have to go through maintenance, update your code base so that you can maintain composability with EVM. That just adds maintenance burden to what you're building. And then finally we have fragmentation. So I kind of like to think about ZK rollups on a spectrum.
00:12:02.128 - 00:12:57.254, Speaker B: So on one side you have extremely compatible with EVM, and on the one other side you have not compatible at all with EVM. So start Zkrollups exists across this spectrum with different projects having different compatibility with EVM. So the developers that are launching and pushing it to all these different l two s will have to deal with the fact that there's minor code differences for all these ZK rollups. And this fragmentation is going to continue to get worse. So these are just a few reasons why it's just better to build your own ecosystem beyond the powerful computation side, but reasons to build your own ecosystem independent of the EVM. And that leads us to freedom to innovate. Again, Cairo VM is optimized for performance and security, whereas Cairo the language is optimized for ergonomic programming.
00:12:57.254 - 00:13:46.288, Speaker B: It wasn't easy building an ecosystem from scratch again independent of EVM, but as Arc net has evolved, the tools and infrastructure has matured and stabilized as well. Now, with the unique features of Cairo on Starknet specifically, we have really amazing developers coming on board to build cool things and really innovate. And here's some of the innovation. My innovation is I create Drake games. But yeah, we'll start off with fully on chain games. I was chatting a little bit earlier about this, but we have a ton of games being built up in the Starknet ecosystem. I find this extremely cool, not only as a gamer, but as a person who loves crypto.
00:13:46.288 - 00:14:42.284, Speaker B: So historically web3 games have suffered because of various aspects. We can get into all the details on tokenomics, but from a technical side, all they did was store assets on chain and kept all the game logic off chain in a trusted environment. Now, with cheap and powerful computation afforded by sparknets, we're seeing developers actually build fully on chain games. That means they're pushing the game logic in a smart contract on chain where we can actually manipulate the game data, the game assets in a trustless environment. This is kind of cool because it solves literally the composability elements that Vitalik was talking about when he decided to think about a decentralized ecosystem like Ethereum for his World of Warcraft weapons. So that's gaming. We are supporting a ton of projects in that space.
00:14:42.284 - 00:15:19.874, Speaker B: If you are interested, feel free to talk to me about any of these sectors too. But for Defi okay, I did include a kubo. Akubo is one of the most efficient dexs out there. Avenue is an extremely smooth aggregator, and they actually released this paymaster to abstract away gas fees. Then we have Giza leading the way with ZKML. We have Herodotus as well for storage proofs to access past current and cross chain Ethereum data. We'll have a chat from him later today.
00:15:19.874 - 00:16:10.914, Speaker B: I think I missed open infrastructure open source code infrastructure for app gene development with Madara Kakarot is building a fully compatible EVM rollup leveraging Cairo. And then we have our wallets and tooling side, which is extremely interesting as well because all of our wallets are smart contract wallets. So Argent and Bravos can use that and create actual really innovative use cases within the wallet to allow social recovery or capping of spending limits. So I think this is really cool. And I'll double click on AA accountabstraction not alcoholicsanonymous on this slide. So just very quickly, usually you have two types. You have externally owned accounts, which are usually wallets, and then you have smart contracts.
00:16:10.914 - 00:17:00.456, Speaker B: On Sarknet, all accounts are smart contracts. And this is really cool because it allows for increased customization and increased flexibility for the developer. What I'm super excited about is what we can do with account abstraction with regards to user experience and actually creating and forming some social constructs that we see in the web. Two design space and then yeah, we, as part of the Stocknet foundation, been kind of very proud to be involved with some of these initiatives that we've been releasing over the past few months. I think it's been incredibly rewarding for me to work with the teams to support them and get teams to build on Sarknet. So just here's a list of just a few of the things that we're doing. We have a lot more in the pipeline, but the first one I want to talk about is seed grants.
00:17:00.456 - 00:17:42.724, Speaker B: These are just small grants of 25k for MVP type projects. Then we have Catalyst, which is an initiative that we released over the past month where we actually had a 20 million SARC initiative to distribute to our top dapps within the Starknet ecosystem. I'm working on this program called Propulsion, which is a gaming initiative for 20 selected Sarknet games for up to $1 million each that they can get based on gas usage. We're going to be announcing something next week on that, so keep your eyes peeled. It's pretty exciting and I just want to double click on the Sea grants program. That's a lot of money right there. So we actually released on May 7.
00:17:42.724 - 00:18:27.982, Speaker B: So a little bit over a month ago with 20 projects in a pilot program, and we actually crossed a 200 applications as of yesterday. With that, we have approved 64 of them and distributed $1.6 million in a little bit over a month. And this is not going to stop anytime soon. This sea grant program is for MVP early stage projects. Use cases vary, but it's really about leveraging and supporting some of the really experimental and exciting projects building in the Sarknet ecosystem at the early stage level. These are projects coming from hacker houses, hacker thons, and we want to support the winners of those and pretty exciting.
00:18:27.982 - 00:19:26.838, Speaker B: But the key thing to take away from this is if you are an MVP or proof of concept project, if you are active in the Sarknet community and you plan to build using existing Starknet tools, then you should apply for a sea grant, actually, before getting into the thank you slide with sea grants, catalysts, and some of the other programs that we mentioned on the, I guess, two prior slides from now, from here, we will now. And a major upcoming program which will be more suited for established builders. We will have a program in place to work with any team or any size developer team that wants to build on starknet. So be on the lookout for all those things. We have a lot coming, so just come build on Sarknet, see what you can do, experiment. We love to see it. And if you have any questions, I'll be here after this call, after this chat.
00:19:26.838 - 00:19:27.794, Speaker B: Thank you.
00:19:33.194 - 00:20:18.806, Speaker A: We have time for some questions, if you want to ask them. Or you can ask Dylan after the, after the meetup. And by the way, there's a stark hack happening right now, right? Yeah, but I think the submissions are already closed. As in, you cannot join. Okay, so, Marcello, come up. Okay, yeah, I see. I find it offensive that this carafe has water.
00:20:18.806 - 00:20:50.274, Speaker A: It looks like carafe for whiskey or something. And we're gonna amend this for next meetup. What? I'm just trying to make it slightly funny. Please work. Yes.
00:20:59.414 - 00:21:24.994, Speaker C: So, hello, everyone. My name is Marcello. I'm the co founder of Herodotus. And today I want to talk about, like, why Cairo is different than starknet and why, you know, you should not associate the language just with a roll up. You can do like, much more than just write smart contracts. And I want to convince you why you should do this. So, for some context, we use Cairo a lot at Herodotus for a bunch of good regions.
00:21:24.994 - 00:22:00.184, Speaker C: Yeah. And this is why I wanted to convince you why you also should do the same, but maybe for context also. First off, Dylan, thanks a lot for this amazing introduction to a lot of topics that I'm going to talk about. So what we do at Herodotus, we develop storage proofs that allow you to write smart contracts, access historical data, and also like, cross chain Ethereum data so you can build like, amazing stuff such as Snapshot X. Cairo, on the other hand, I feel like it's a super misused word. It means the language, virtual machine and a lot of other stuff. But today I'm gonna explain that and demystify a lot of myths.
00:22:00.184 - 00:22:42.074, Speaker C: All right, so worries Cairo and worries darknet. So Cairo is a language that allows you to write smart contracts on Starknet, but most importantly, it's a language that allows you to write provable programs. Startnet, on the other hand, is a ZK rollup which is implemented in Cairo, to which you can deploy applications also written in. I call it a different dialect of Cairo. But yeah, these are like two separate things, and I will get into that today. So first off, like a mental model behind provable computer. For those of you who don't know, maybe first, whoever is a developer, please raise your hand.
00:22:42.074 - 00:23:19.822, Speaker C: Ooh, nice. All right, so provable compute. The idea is that basically we can make a claim like a statement which is made of like some computation that we define with like for example, Cairo. Then we take some inputs, we can have like some subset of this input that are private. I will explain what are private versus public inputs in a second. And finally, given this inputs and that program, we get some outputs. This is basically the statement that you want to, that the verifier wants to convince the prover wants to convince the verifier about given like a proof.
00:23:19.822 - 00:23:51.724, Speaker C: So inputs, we have public inputs. These are like visible to both the prover and the verifier, whereas private inputs are visible only to the prover. So they are not like leaked to the verifier, which is pretty important, especially in the context of Zqroll. But we'll get into that. Awesome. So finally, we have this protocol where basically the prover generated proof provides it to the verifier, most likely the blockchain. And we have some checks that are by the way, probabilistic, and we can reject or accept the proof.
00:23:51.724 - 00:24:13.464, Speaker C: That's the mental model you should have behind any provable computation. But you can express this computation like many ways. So let's talk about it. So the OG way, just use circuits. But there's a lot of reasons why you should not use circuits today. But yeah, there are like three main tracks. First circuits, then zkvms, and then finally transpilers.
00:24:13.464 - 00:24:55.574, Speaker C: So circuits circumflex, for example, tornado cache is implemented in that. You have generic, you have noir, socrates, like yeah, pretty old stuff. And on the spectrum of zkvms, you have chiro is a zkvm, you have SP one from succint, you have Risc zero from Risk zero, you have era VM as well. And finally, transpilers, so far I can mention one, there is like the one built by Neil foundation, which given some llvm, it's gonna generate like a circuit. So now, why Cairo? First off, writing circuits is hard and slow. Like really slow. It takes a lot of time, it's pretty complex.
00:24:55.574 - 00:25:17.928, Speaker C: Oh, perfect. Writing circuits takes a lot of time. It's pretty complex. So it's expensive to audit them. And the go to market is like slow. So if you don't have to write circuits, please don't. So let's talk about zkvms.
00:25:17.928 - 00:25:40.898, Speaker C: So, virtual machines, basically you can have some instruction set that you can execute ZkVM. You just prove the execution of that. You can have like commonly known instruction sets such, I don't know, Risc like JVM anyways. But the problem with them is that they're not ZK friendly.
00:25:40.946 - 00:25:41.178, Speaker D: Why?
00:25:41.226 - 00:26:20.374, Speaker C: Because they were not designed to be ZK friendly. On the other hand, Cairo was designed specifically to be ZK friendly. And that said, the gap will get bigger and bigger and bigger because Cairo will keep being redesigned to be more and more ZK friendly, whereas brisk would be just brisk. Now, Cairo, as a language, you have a brass like front end. So it's nice, it's usable. And finally, in my opinion, it's the most important property of Cairo. You have one owner of the stack, like Starcourt is designing the language, the compiler, the VM, pretty much everything.
00:26:20.374 - 00:27:10.296, Speaker C: And this results to be very good property historically. I guess a lot of you use MacBooks, iPhones, Apple owns pretty much the entire stack and that resulted to be something amazing. So yeah, that's a very good reason. So now I want to walk you through like the entire pipeline. What's happening when you use Cairo, how you go from the language to the actual execution and why this is different than Starknet and what type of stuff you can do and then what actually start this from a more technical standpoint. So step number one, we write some code, we express it in like Chira. So again, it's a provable language that allows us to wrap our computation like a stark proof and prove its validity in the end.
00:27:10.296 - 00:27:38.818, Speaker C: So we write that code, looks for crust, then we pass it through the compiler, we get something that is called Sierra. Sierra is an intermediate representation, but this is optional. This is very specific to Starknet. Maybe. Let me explain why. The reason is that when you prove some program, you want to prove its successful execution. But in the context of blockchains, you also have reverting transactions, right? So how do you prove that the transaction is reverting and also why you want to prove that? Well, there is a very good reason.
00:27:38.818 - 00:28:19.954, Speaker C: It's like ddos, right? What if as a sequencer you just keep receiving transactions, you execute them, and then it turns out that you cannot prove that they are not successful. Like someone can just attack you on purpose. It's a huge problem, especially if you want to decentralize the network. So we have this abstraction layer called Sierra, which basically allows you to prove that hey, that transaction is not provable, it's just going to fail. This basically gets compiled into caravan bytecode. I speed run this slide where we need Sierra from bytecode. We just executed with the Chirovm.
00:28:19.954 - 00:29:23.604, Speaker C: This generates like a trace. And finally this trace needs to satisfy something that we call the error. So algebraic intermediate presentation really specific to the proof system. And if these constraints are satisfied, okay, I think you can see it's pretty much the same, the same slide, we are able to generate the proof. So where's darknet? But maybe first, what are the applications of all of that? So application number one, back in the star cracks days, you could build stuff like diversify, you could build stuff like immutable, like Dydx, pretty amazing applications, but you have use cases kind of off the purely blockchain use cases. One of them is like Giza where you can prove some machine learning, like inference, like linear regression and models like XgBoost and a lot of other amazing stuff, and you can prove the inference. So you can prove that you properly executed some machine learning model.
00:29:23.604 - 00:30:19.018, Speaker C: Pretty, pretty cool. And also you have something that we developed, it's called a data processor. So you can take arbitrary historical or cross chain data, you can express some computation that needs to run over the data, and we can just prove it, generate the proof and that's it. And this can be applied to pretty much any use case where you want to convince someone about some claim, you don't want to reveal the information or you don't want the other party to re execute that, and you can use Chira for that. So what is starknet then? So starknet is pretty much a program that is able to maintain its own state, which we also call a roll up. So here what the claim is, and I mentioned also previously that we explained what are private and public inputs. So public inputs are these that are visible to both the prover and the verifier, and the private inputs are only visible to like the prover.
00:30:19.018 - 00:31:03.158, Speaker C: So how does it apply in the context of like roll ups? As probably many of you know, we have like ones that post state differences and entire transactions to the chain, and why we can choose between those, it's because maybe specifically to ZK rollups, why you can post state differences is because you don't really need to see the entire list of transactions to then be able to re execute them. You can just say, hey, there was a listed transaction that satisfies this program that represents rollup. I executed that correctly. And here are the stages. You cannot do this type of things outside of ZK rollups. So you can prove pretty much this type of claims and you just show that the transition from this stateroot to this other stateroot is valid. Pretty cool.
00:31:03.158 - 00:31:33.366, Speaker C: So this is Starknet. You can also run like smart contracts on top of that, because again, we have a VM which is able to run anything and yeah, that's it. So now our contributions to the Cairo ecosystem. So we developed storage proofs. So again, you can write smart contracts that access historical and also cross chain data. And on top of that you can build cool stuff such as Snapshot X. We also developed a verifier on Starknet for this.
00:31:33.366 - 00:31:57.814, Speaker C: So just take any Chira code, prove it with stone, which is an open source prover developed by Starkware, then verify the execution of that with integrity on Starknet, which has been developed by Herodotus. You can also do privacy on Starknet using like Garaga, or finally use the data processor. And thank you. Now time for questions.
00:32:07.674 - 00:32:49.432, Speaker A: We're going to have time for questions after that as well, unless you have a question for yourself. Okay, we're good. Thank you, Marcello, and let's move on to our last presentation today. Nicolai stage is yours, just to keep you interested. For that, Starknet has provided t shirts in various different sizes, which is not very typical for a conference. So we're gonna have nice merch out there in the foyer after the conference. And as usual, drinks and pizza and fun networking.
00:32:49.432 - 00:32:52.804, Speaker A: But don't escape just yet, and don't steal all the t shirts.
00:33:28.364 - 00:33:56.574, Speaker D: Alright? Good evening everyone, and thank you for being here. Thank you for having me here. Hi, I'm Mikoy Barvisky. I am from Nethermind. Nethermind is an organization which has been quite active in the Ethereum space since 2017. We are quite proud of our Nethermind client, which is like the Ethereum client, which, by the way, for the record, has been mostly developed and is being maintained mostly in Poland. And we are quite proud of that.
00:33:56.574 - 00:34:58.184, Speaker D: But we are also quite active in the starknet space and we put a lot of effort into developing components of Starknet. From its core components. We have a full client implementation in Starknet, to developer tools, to user applications like blockchain, Explorer, et cetera, et cetera. And, well, I'm here to be telling you about. Actually, it's a funny title and already suggesting something. And I was recently rewatching Madhe Fury Road and I felt it was quite actually appropriate for this presentation. So can I draw you into a bit of an interaction? And does anyone know how many nodes are there in Starknet blockchain network at the moment? One.
00:34:58.184 - 00:35:45.732, Speaker D: Any other attempt? Okay, 100. Any other? Well I would say zero at the moment and that is true. Let's just admit that, right, Darknet is operational. It is a L2, as we already heard today, it is a validity roll up, but at the moment it is pretty much centralized. The current architecture includes a, I will show it in a second, but I'll just list it quickly. It includes a centralized sequencer, a centralized prover that is maintained by Starkware. There is a single mem pool and well, that's really it.
00:35:45.732 - 00:36:36.144, Speaker D: So the big powerful set of features already available in Starknet are mainly due to its stack which has been described today, and Cairo stack and the whole stark crypto system. These are the functional features of Starknet. But Starknet is not yet decentralized. So the idea of the L2 is to what we call this, recover such aspects of a blockchain system as liveness, censorship, correctness, immutability. At the moment we have correctness due to the validity roll up system. We have immutability because everything that's happening on Starknet blockchain is checkpointed on l one. But we don't have liveness, we don't have censorship resistance.
00:36:36.144 - 00:38:13.154, Speaker D: So I mean, and you can see that also l two beats, they are derating it quite aptly by rating the state validation data availability aspects of Stocknet as well. We are pretty much there, but the liveness is pretty much undermined by the ability or the possibility or risk of sequencer improver failure and the censorship, they focus on the exit window from the blockchain. That's one of the aspects of lack of censorship resistance at the moment. The fact that Starkly's development started with the functionality first was a conscious choice and right now we can say that it is functionally robust and quite mature and developer community seems to confirm that. But we still have a lot to catch up on when it comes to the decentralization. When it comes to liveness, we will need to get to a point where the startnet network will run on a certain level of decentralization, the decentral level of multiple nodes running in a network. When it comes to censorship resistance, well basically the operation and the composition of the validator set of the network will need to be controlled from l one.
00:38:13.154 - 00:39:02.806, Speaker D: And, and this is where we will say we will have achieved sufficient censorship resistance. So the architecture of darknet is pretty much this at the moment. So as I said, there is a single mempool. Actually, contrary to that diagram here, there is a single mempool, there are centralized sequencers, there's a central prover as well. All the transaction requests are filed into the the mempool gets processed by the sequencer. The blocks get then proven, that is the proof for the block is generated and then submitted to a verifier. The logic of the verifier is implemented on l one, and the very successful verification will then stamp the outcome of the block on the startnet core contract on l one as well.
00:39:02.806 - 00:40:06.884, Speaker D: This is where the state divs are stored as blobs. This is where the proofs are stored in the collateral. So to get to the decentralization, we will need to, I'll just start pointing fingers. We'll need to get these mempools, sequencers and provers will need to get them decent, well need to get them implemented in the actual full node implementations. So we can remove the central sequencer, mempool and approver and we can replace them with a network. Okay, okay, so you may actually ask, but we have already full neutral gateway against Ethereum and they are at the moment serving the API into Starknet. So in fact, in order to communicate with Starknet, in order to integrate with Starknet, you need to communicate with an RPC interface exposed by a full node client.
00:40:06.884 - 00:41:17.882, Speaker D: This also means that in order to submit a transaction in Starknet, you need to send a request into a full note implementation, but that request will be forwarded to the central sequencer that's related. Okay, so how do we move on? The first dependency here is the ability for the nodes to communicate over the p two p network. Once we have that, we'll need to decentralize the sequencer, and for that we need to implement a consensus protocol. So the first stage, or the next incoming stage is the p two p and the stable p two p implementation. The next big stage is the consensus implementation. So first we need a consensus protocol to be designed and then implemented in parallel. We are actually working on scaling which a lot of the scaling improvements can be done, let's say orthogonally to the p two p and consensus implementation.
00:41:17.882 - 00:42:29.144, Speaker D: So I'll just say a couple of words about that as well. Right, anything. Right, so where are we with all that in terms of p two p? At the moment, there is an already stable version of the p two p specs for the messages in the p two p network. The spec also assume that implementation is based on lib p two p, which is a fairly known standard in the crypto space. The implementations of the Fullnode client are pretty much well advanced in implementing the syncing logic, and juno, for the record, is now capable of syncing the blockchain content from a network of Juno nodes. So internally, Juno can sync. We've now been working with Pathfinder team to ensure the integration between Juno and Pathfinder, and literally last week this has been confirmed in a sense of we are now able to sync Juno and Pathfinder nodes on the full content of sepolia network on stagenet.
00:42:29.144 - 00:43:44.054, Speaker D: The progress is quite steady, and this gives us pretty much the ability to soft commit to being able to launch a p two p testnet in somewhere in July, hopefully, and that would be between all the client implementations. So that's where we are with the p two p. By the way, the syncing algorithm that we are working on is a fairly naive one, but it's still effective in parallel. We are also working on something which we call snapsync. I mean, some of you may know this is one of the features of Nethermind client which has the ability of quite high performance internal syncing of ethereum, and we want to implement the same thing in Juno. So Juno will have snapsync, and hopefully, well, hopefully, well, once it works, we will probably be proposing to implement the p two p features of the snapsync into the actual official specs, so that other clients can also use snapsync if they want. So once we have p two p, the consensus is the next big step.
00:43:44.054 - 00:44:36.444, Speaker D: And this is where we are less advanced, let's say. So the work on the consensus protocol design is pretty much driven by stackware with close collaboration with informal systems. And never mind, this is where the specs are not yet designed, not yet written, but a discussion on proposals for the consensus protocol are public. I mean, can be viewed on the community forum. And. Well, it is still quite hot, the discussions, but there are some assumptions which I think are valid at the moment. So one of them is the initial version of the protocol will be based on tendermint, because it is pretty much bottle tested, and we assume that starting will be a fairly small network.
00:44:36.444 - 00:45:55.838, Speaker D: So tendermint consensus will not be a bottleneck. Tendermint gives us immediate slot finality, which is benefit when it comes to further processing, and we are aiming to support MEV and MEV on those, let's say, single slot finality enabled protocols is quite well developed and researched for now so this is in contrast to dAG based protocols like diagnostic graph, where MEV is not really well researched and not explored. So tendermint is a conscious choice, but we definitely are looking at DAG based protocols as an alternative, as a subsequent step. So based on vanilla tendermint, we are designing or discussing additional features. There is the need to be able to throttle the blocks. That's because, I mean, going deeper into the details, the block execution step is in general different when it comes to computational effort than the block proving step. So there may be a mismatch or misbalance when the nodes are processing blocks.
00:45:55.838 - 00:46:34.328, Speaker D: And we may need to be able to control that. We may need to be. We may need to hold back some of the block propagation so that the provers can catch up. That's the reasoning behind it. And there's a couple of implications, which will still need to be, need to be designed, let's say. So we know that we are discussing proof chaining and parallel proof computation, let's say, which will need to have the proof aggregation mechanism designed, et cetera, et cetera. So in all this, there is also the discussion about how staking will work within this consensus protocol.
00:46:34.328 - 00:47:09.358, Speaker D: And again, this is quite an open design space at the moment. So this is not yet settled, not yet decided. So when I was telling about the possible timelines for the p two p I was giving July in here, I will not yet commit to any timelines. That's months ahead, realistically. And when it comes to teams, I mentioned three teams involved in this design and implementation in parallel. In nethermind, we've kicked off the baseline implementation in go. That's of tenderbind.
00:47:09.358 - 00:47:48.424, Speaker D: That's because Juno is written in Golang, and we want the whole stack to be implemented in Golang for efficiency. So that's where we are. We are at this stage when it comes to the Juno implementation. Now, few improvements on the scalability or like the volume of Starknet at the moment for. For convenience, we tend to use the ERC 20 transfers as the performance metric. So for Starknet, this is on average about 40 transactions per second. Max recorded was 52.
00:47:48.424 - 00:48:48.994, Speaker D: And we definitely want to go over that. And there's a couple of ideas in progress to improve that. We are working with starkware on the parallel transaction execution, which will pretty much give us improvement between four to five to eight times. And there is, I mean, Marcello was telling about the chirostack, I think he didn't mention the Cairo native. There's a concept, there's a library and a mechanism which assumes and allows for compilation of Cairo code to machine's native code ahead of time. And that in experiments had shown somewhere between 20 to 200 times efficiency and performance improvement. So we are working on getting that integrated in the actual block if I part of the sequencer and the effects will be combined with the parallel transaction processing.
00:48:48.994 - 00:49:34.444, Speaker D: At the moment, Starknet is also going through the process of shortening the block times. The current block time is six minutes per block. We will, well, we will start net will shrink that over the next few months down to ten to 20 seconds per block on average. And that should be like a no brainer. That should be quite easy. With these other improvements implemented, it should be able to go down to between two to 5 seconds per block and almost like immediate block confirmation on l two. So if you combine all that well, by the end of the year we hope to have about 500 DP's and that's a very conservative assumption.
00:49:34.444 - 00:50:17.862, Speaker D: So yeah, and guys, this is all happening and this is all, or most of it is actually open and open source. So anyone really anyone is able and invited to contribute to it. And if you're an individual contributor, a developer, these are the ways to join. You can either apply for roles. We have a number of open roles in Netherlands. There are discussions on telegram and community forums which you can either read and or contribute to. There is an internship program which undermines runs and that's again another way of getting exposure onto this.
00:50:17.862 - 00:50:51.648, Speaker D: And there is a regular startnet core dev meeting online which is open and anyone is invited to observe the progress and discussions. So that's for the individual contributors. If you are an organization interested in getting into this space, probably Startnet's foundation is the best point of contact. I mean we as in mind, we are happy to help you in getting in contact with the foundation. So, yeah, that's where we are. So you've seen the numbers, you've seen the timelines and. Yeah.
00:50:51.648 - 00:50:54.924, Speaker D: Thank you for, for your patience. And thank you for having me.
00:50:58.584 - 00:51:00.884, Speaker A: We have time for questions.
00:51:12.464 - 00:51:13.848, Speaker E: Okay. Okay. Okay. Yeah.
00:51:13.896 - 00:51:14.160, Speaker C: Hello.
00:51:14.192 - 00:51:46.158, Speaker E: Hello. So my name is Stefan. You just mentioned that you are considering about using transaction parallel transactions. Yeah. So like any EVM chain like logic in EVM chains, that transaction in EVM chains goes one by one. And if you are considering using parallel transaction, you are considering to go in asynchronous model. So such, for example, such a venom venom chain.
00:51:46.158 - 00:52:05.970, Speaker E: TVM. Yep. Okay, so how would you describe your positioning on transaction, on paralleling transactions that you just mentioned without, or I'm sorry, are you gonna became an asynchronous or.
00:52:06.042 - 00:52:35.814, Speaker D: Still, right now the design is all around the concept of transactional memory, and it's basically an optimistic polarization. You can execute transactions in parallel as long as they don't interfere with each other one way or another. And that way you just need to roll them back. Roll them back in the, in the sequencer and execute them in sequence. Yeah, indeed. I'm sorry, there was another question. Yeah.
00:52:40.574 - 00:52:45.958, Speaker B: So how many nodes would you aim for when you're trying to decentralize?
00:52:46.126 - 00:52:51.606, Speaker D: So we expect to have around 50 active sequencers. Cool.
00:52:51.670 - 00:52:54.694, Speaker B: Are you trying to decentralize both the sequencers and the provers as well?
00:52:54.734 - 00:52:55.638, Speaker D: Yes, that's right.
00:52:55.686 - 00:52:58.750, Speaker B: And would the idea be that each node would run both of those?
00:52:58.862 - 00:52:59.494, Speaker D: That's correct.
00:52:59.574 - 00:53:00.990, Speaker C: Okay, cool.
00:53:01.062 - 00:53:02.406, Speaker B: And then one mempool.
00:53:02.590 - 00:53:07.674, Speaker D: No no, no. Each of them would be a mempool as well. MMPO as well. Cool.
00:53:13.214 - 00:53:30.708, Speaker F: So you mentioned snapsync. Right. And correct me if I'm wrong, but this should be fairly easy to do since you have snapshots on Ethereum layer one. Right, like state snapshot. Can you tell us more, how do you plan to design this?
00:53:30.806 - 00:53:46.576, Speaker D: So snapsync does require the nodes to be able to respond for certain ranges of that tree. Right. And this needs to be implemented in the protocol and in the nodes themselves. We wouldn't be syncing from l one.
00:53:46.760 - 00:53:47.768, Speaker F: Yeah, I get that.
00:53:47.856 - 00:53:50.204, Speaker D: Yeah. So I mean, that's about as much as.
00:53:50.704 - 00:53:56.032, Speaker F: But, so snapsync works in a way that you can sync just a part of the tree.
00:53:56.088 - 00:53:56.778, Speaker D: That's correct.
00:53:56.896 - 00:54:08.766, Speaker F: Okay. Because also I assume you could just download the whole tree from another node or from ipfs and just compare it with the hash that it's on layer one, right?
00:54:08.870 - 00:54:10.598, Speaker D: That's correct. Yeah, that's exactly right.
00:54:10.686 - 00:54:41.694, Speaker F: And then I have another question, because you mentioned there's some ways that you're going to improve the performance of the system, but you focus only on the execution part, which was surprising to me because it seems like it's not the execution that is often the bottleneck, but more like memory constraint, the state that it's ever growing. And sure, you can have 1000 dpss by the end of the year, but in two years it's going to be lower because of memory access constraints.
00:54:42.554 - 00:55:08.564, Speaker D: That is a very valid question. In my team's research, we've been focusing on the execution implement execution first. The memory performance aspects we've left pretty much, and so thank you for raising this. If you would like to dip into this deeper, I'm happy to put you through to people who are smarter than myself in my team.
00:55:10.584 - 00:55:13.564, Speaker A: Awesome. Do we have anything else? No.
00:55:17.784 - 00:55:22.562, Speaker C: So how is nethermind l one client going pretty well.
00:55:22.618 - 00:55:23.954, Speaker D: And updates last week.
00:55:23.994 - 00:55:24.314, Speaker C: Perfect.
00:55:24.394 - 00:55:25.014, Speaker D: Perfect.
00:55:25.354 - 00:55:38.762, Speaker C: So you are saying that the consensus protocol is not designed just yet. Is there any chance that the proof of stake consensus mechanisms can be used for that?
00:55:38.898 - 00:56:04.054, Speaker D: So, I mean, okay, if I wasn't clear about this, so the consensus protocol that is being designed will be a proof of stake. And there is a discussion on how the staking will work, etcetera, etcetera. But again, that's fairly early stage and some of that I'm not really able to reveal yet, but it will be, there will be staking, there will be the whole environment of staking in stocknet as well.
00:56:04.134 - 00:56:04.794, Speaker C: Thanks.
00:56:06.574 - 00:56:07.594, Speaker A: One more.
00:56:12.914 - 00:56:19.174, Speaker C: Are you already start to selection the node operators or the validators?
00:56:21.114 - 00:56:25.114, Speaker D: That's not within my area of responsibility.
00:56:25.234 - 00:56:26.418, Speaker B: Let me say that I got it.
00:56:26.466 - 00:56:27.134, Speaker C: Thanks.
00:56:28.914 - 00:56:35.134, Speaker A: Cool. Do we have any more questions? Okay, one more. Okay, but this one is the last one.
00:56:37.854 - 00:57:12.430, Speaker G: So you mentioned you'll be using tendermint for consensus. And correct me if I'm wrong, but I think with the tendermint's BFT, you need two third of the that's correct, like validators in order to produce a block. And if one third of them are offline or malicious, will actually stop. How big of a risk is that to the entire like say starknet network? And if there's like any kind of workarounds, for example, is it possible to retrieve the states from some other like da layer or.
00:57:12.502 - 00:57:41.968, Speaker D: Yeah, so it pretty much is possible to rebuild from l one. Well, we are taking the tendermint with its security assumptions as it is just to focus our thinking on adding layers on top of tendermint. So I mean, what you said is valid. We don't really have any specific angle of attack to tackle this. We just take them in with its benefits and drawbacks.
00:57:42.096 - 00:57:42.964, Speaker E: Thank you.
00:57:45.384 - 00:58:01.056, Speaker A: Awesome. Thanks so much. Thank you. Big round of applause. Nice. So that's all for today. Please head now to the little foyer.
00:58:01.056 - 00:58:28.452, Speaker A: So it's there and to the left, you'll find drinks and pizza there. And come over network and remember you can get e four, so tickets already at a discount price. It's one bit. If you want to volunteer for the conference and work with us, get nice fancy tickets like that. Come talk to someone in green if you want to apply a speaker as sponsor or some kind of partner. Also talk to someone wearing green if that's a different shade of green. Don't talk to them.
00:58:28.452 - 00:58:34.184, Speaker A: And that's it. We'll see you, probably, I guess, next month for another meetup. And thanks so much for coming and have fun.
