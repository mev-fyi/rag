00:00:02.490 - 00:00:33.186, Speaker A: Hello everyone. My name is Togral. I do research at scroll but you can mostly find me shit posting on Twitter. That's what I mostly spend my time on. And today we're going to be talking about bridges, specifically trustless bridges and whether they are a myth or a reality. So you might have seen quite a few of these articles or papers. So this is an example from near protocols.
00:00:33.186 - 00:00:52.454, Speaker A: Rainbow bridge. It says ethnier Rainbow bridge is a trustless, permissionless protocol. Blah, blah blah blah blah blah. Or another one. It's the harmony bridge, it's horizon, a gas efficient trustless bridge for crosschain transactions. Or yet another one, ZK bridge. Trustless.
00:00:52.454 - 00:01:11.140, Speaker A: Crosschain bridges made practical or even from the EF pages page. So yeah, you have trustless having equivalent security to underlying domains. So trustless. Trustless, trustless, trustless. Even more trustless. Trustless, trustless. So let's first define what trustless is.
00:01:11.140 - 00:01:45.280, Speaker A: But let's not use the definition that avalanche uses because no, they already deleted this definition after I called them out. But let's just read this beauty because it's beautiful. The avalanche bridge is trustless in the sense that no party is able to access any of the funds held as collateral or mint wrapped assets. All transfers across the bridge must be approved by six out of eight independent parties. Blah, blah, blah, blah. Beautiful. Doesn't really make sense, but sounds great.
00:01:45.280 - 00:02:32.250, Speaker A: So what is actually trustlessness? And no trustlessness doesn't mean that we don't make any trust assumptions whatsoever. Doesn't matter what we do in life, there are always some sort of trust assumptions being made. So what is trustlessness then? So you can define trustlessness as the minimum amount of security assumptions required to interact with a protocol through a full node. And I'll explain what a full node later is later. So it's essentially the minimum amount of assumptions you can have in order to use a protocol. It's not really possible to make fewer assumptions than that. So what is a full node? A full node is a client that can verify the correctness of the consensus and execute the state transitions of the protocol.
00:02:32.250 - 00:03:22.090, Speaker A: Note that there's a difference between verify state transitions and executing them, because you can use something like zero knowledge proofs to prove the correctness of the state transition function. But then you make an additional assumption by executing. I mean, you actually take all the transactions, execute them, and verify that the outputs produced by those transactions are correct. And that's the role of the full node. And what does a security assumption mean? Security assumption is a mechanism property that we expect to hold no matter what. So, for example, when we use a BFT consensus mechanism, let's say tendermint, we assume that there's two thirds of the participants are honest. And if they're not, the protocol is no longer functional.
00:03:22.090 - 00:04:00.322, Speaker A: It just breaks. And so every single thing that we use doesn't matter whether it's on the cryptography side or on the protocol side, we always make some assumptions that they should work. And so it's impossible for us to just dismiss those assumptions. So, for example, when you use ethereum, you have to assume that the hash function is secure and the signature scheme that you use is secure, et cetera, et cetera. And there's no avoiding it. Trustless, in essence, defines the type of interaction that you have with the protocol. So trustless interaction with the protocol is an interaction through the full node.
00:04:00.322 - 00:04:54.060, Speaker A: So if you use your wallet, for example, and you don't connect to your own full node through an RPC, but you use something like infura, it's no longer trustless because you trust infuria to provide you the correct data, and you trust infuria to actually send your transaction to the network. Whereas if you connect your wallet to your own RPC, then you don't really trust anyone else, because as long as your full node works, then you know that all the data that you get is valid data. And another thing that a lot of people get confused about is whether trustlessness is a spectrum or whether it's a binary thing. And it is a binary thing because as I described before, it's a minimal set of assumptions. So if you add another assumption to that minimal set, it's already not that minimum set, it's a bigger set. So therefore, it cannot be a spectrum. It's a binary thing.
00:04:54.060 - 00:05:26.662, Speaker A: So, yeah, you cannot have a spectrum of trustlessness for a given protocol. And bear in mind that trustlessness will differ from protocol to protocol. So in Ethereum, your minimum base assumptions will be different from the minimum base assumption that you take for bitcoin, et cetera, et cetera, et cetera. Solana will be completely different. And raise your hand if you think that your funds can be stolen if you run a full node. Good. Congratulations to those who raised their hands.
00:05:26.662 - 00:06:02.650, Speaker A: You're completely wrong. Why? Well, it's simple. As long as you run a full node, your funds cannot be stolen because essentially your full node verifies all the state transitions and checks whether everything is running as intended. Let's assume that there are no bugs. If there are bugs, it's a completely different story. But for now, let's assume that there are no bugs. But you might rightfully ask, what if a dishonest majority produces an invalid block that steals your funds? What happens then? Well, in that case, your full node will just reject that block and it will fork.
00:06:02.650 - 00:07:12.198, Speaker A: Yes, it will result in a fork, but at least you know that you will never accept an invalid block. And that's what a lot of people misunderstand, is that while you need an honest majority assumption for the protocol to function as attended, if that honest majority assumption fails for some reason, and there's a dishonest majority that can propose an invalid block, it doesn't really affect your full node because it'll just reject every invalid block that is proposed and just continue as if that block was never produced in the first place. And another game similar to the one that the question that I previously posed raise your hand if you think that roll up bridges are trustless. Congratulations again, the people who raised their hands are wrong. And again, why? Because it seems pretty obvious you don't really make any honesty assumptions. So it should be trustless, but it actually isn't. So roll ups rely on fraud proofs or validity proofs to facilitate communication to ensure the safety of your communication between the l one and the roll up.
00:07:12.198 - 00:07:53.374, Speaker A: And so fraud proofs require one out of honesty assumption to be secure, and validity proofs require the security assumptions of the underlying zero knowledge proof system to hold. Which means that we make additional assumptions for that to work. So think about it in this way. So if you hold your funds on a full node, then no matter what happens, your funds can never be stolen. And what happens if you bridge your funds to roll up? Can they be stolen? Yes, there is a scenario where they can be stolen. So in case of an optimistic roll up, they can be stolen if there are no honest parties challenging. And in case of zero knowledge roll ups, they can be stolen.
00:07:53.374 - 00:08:46.862, Speaker A: If there's a bug in the zero knowledge proof, or your zero knowledge proof is insecure by specification, the right question to ask is, is trustless bridging even possible? Short answer, no longer answer also no. So the security guarantees of your bridge, the funds should be equivalent to that of a full node. So what I described before. So if your bridge from chain a to chain b, if that communication is trustless, you should have the same security guarantees that you have when having your funds on chain a. Well, it's not really possible, because any bridge, by definition, introduces some kind of an additional assumption. Unless you're bridging between two chains sharing the same properties and the same guarantees. So they share the consensus.
00:08:46.862 - 00:09:22.106, Speaker A: They share everything. The DA is the same, everything is the same. But at that point, it's indistinguishable from a single chain. You can run two chains and verify it via single full node, but from a user perspective, that's indistinguishable from having a single chain. So with that out of the way, let's go through the stuff that we started with, and let's see if these bridges can actually be qualified as trustless or not. So, is Rainbow Bridge trustless? The answer is no. And the reason why it makes an honest majority assumption.
00:09:22.106 - 00:09:52.662, Speaker A: So, Rainbow Bridge is a light client, essentially. So it bridges funds from one chain to another and has a light client on another chain that verifies that the bridging was done correctly. And if that chain, for some reason has a dishonest majority? Well, yeah, your full node can ignore it. But if your funds are being bridged back, then there's nothing your full node can do. Your funds are basically gone. Horizon, is it trustless? Again, no, same thing. Honest majority assumption.
00:09:52.662 - 00:10:16.686, Speaker A: It relies that both of the chains are honest, and if one of them break, then your funds are gone, basically ZK bridge. Yeah, surprise, surprise. Same thing. No, same thing. Honest majority assumption. So, with that out of the way, next time you see a trustless bridge, think about this. It's a trust me bro bridge, or it's a trustless bridge.
00:10:16.686 - 00:10:31.480, Speaker A: But there are certain terms and conditions that apply that you need to be aware of. Or in some cases, a trustless bridge. It's just a trust minimized bridge. So, for example, in the case of roll ups, thank you for your attention, and feel free to ask any questions.
00:10:36.970 - 00:10:38.540, Speaker B: First one right here.
00:10:39.550 - 00:10:40.154, Speaker C: Hi.
00:10:40.272 - 00:10:41.638, Speaker A: Hello, Bartek.
00:10:41.814 - 00:11:00.062, Speaker D: So you said that you're assuming that there are no bugs in your full node. Why do you make a strange assumption that secure circuit is somehow different? I mean, what if there are no bugs in your circuit, then it seems to me that it's trustless now, because.
00:11:00.196 - 00:11:29.980, Speaker A: If there are bugs in your full node, then essentially there's a bug in the protocol. So it's more trivial to get a social consensus to revert and ignore that bug or whatever. Whereas if there is a bug in one of the smart contracts, it's much more difficult and unrealistic even to expect that the entire chain is going to roll back to patch that bug. Which means that you make a much bigger assumption that the social consensus will actually agree to roll back and fix it.
00:11:30.910 - 00:11:35.770, Speaker D: But assuming there is no bug. Sorry, assuming there is no bug.
00:11:36.430 - 00:11:39.626, Speaker A: Assuming that there's no bug in a proof system.
00:11:39.728 - 00:11:45.630, Speaker D: Yeah, in the proof system, would you consider this to be almost trustless?
00:11:45.970 - 00:12:15.670, Speaker A: It's almost trustless, but it's not, because you can still have not a bug, but just the system itself is broken by specifications. So, for example, we had an example like that with Zcash, where it was discovered that an incorrect specification of the protocol led to a possibility that people could mint money out of thin air. And so essentially the same thing can happen in any system that uses zero knowledge proofs.
00:12:20.110 - 00:12:22.300, Speaker B: Okay, another one here.
00:12:23.630 - 00:12:26.780, Speaker A: Am I being ganged up on by LTB people?
00:12:27.230 - 00:13:27.326, Speaker C: No, I hope not, at least. Yeah, so thanks. And I generally agree with most of what you said, but now when I think about something that I actually know probably most about, which is like Starkx exchanges, which are also L2s but not general for general computation. And the way it works is that with the escape hatches that are built in and forced transactions, which means that because it's a kind of simple setup where Ethereum does know the miracle route of the whole state, which means that assuming there is no bug, then I can always unlock my money by providing a miracle proof to the contract on Ethereum, which in that case, in my head, is that I can consider it trustless, assuming there are no bugs in the smart contract. Right. And would you say that still this is not a trustless bridge, but you.
00:13:27.348 - 00:13:49.650, Speaker A: Don'T need a bug for that to happen? What if the proof system is broken, and I can just produce an invalid Merkel tree that moves funds from you to me, for example, and then I exit by proving the inclusion to an invalid Merkel tree. There's no bug there, but the proof system is broken, and you can still produce an invalid state transition.
00:13:49.730 - 00:13:53.240, Speaker C: Wouldn't you call it a bug in a proof system that would allow that?
00:13:54.250 - 00:14:26.302, Speaker A: But I would say that a bug is an implementational, come on, the implementational side. So, for example, if you're implementing and you implement the specification correctly, whereas if there's a fundamental problem in the proof system that you're using, then it's not really a bug, it's just a broken proof system that you're using. So that's what my argument is. Bugs aside, you can protect against bugs somewhat by using multiprovers, et cetera, et cetera, whereas you cannot really protect yourself against an invalid proof system.
00:14:26.436 - 00:14:48.950, Speaker C: Yeah, I agree. I think that actually you can think about, in theory, if everything is working perfectly as the theory would set, like almost as academic discussion, it would be trustless, assuming that nothing wrong would happen. The construct itself is valid, I would say, but in the practice, you're right, there are security assumptions. Always undergrow with a number of elements of the system. Thanks.
00:14:49.100 - 00:15:03.360, Speaker A: Yes, so if you can prove that you can guarantee that the proof system has no vulnerabilities and is completely sound and robust, then yes. But I'm not aware of any way you can actually prove that.
00:15:04.210 - 00:15:05.054, Speaker E: Hey man.
00:15:05.172 - 00:15:05.790, Speaker A: Hello.
00:15:05.940 - 00:15:08.202, Speaker E: What would be, in your opinion, architecture.
00:15:08.266 - 00:15:10.110, Speaker F: For a trustless bridge?
00:15:11.090 - 00:15:40.490, Speaker A: I don't think there can be one. So, as I said before, the only way you can have a true trustless bridge is if the consensus and everything is shared between two chains. In a sense that it's essentially just one protocol that has two different databases that move data from one to another. But at that point, it's not really distinguishable from having a single chain. So I would say that it's not really possible to have a trustless bridge.
00:15:41.550 - 00:15:45.542, Speaker E: Not even with a light client that would send the proof to a different chain.
00:15:45.606 - 00:16:15.474, Speaker A: But a light client relies on an honest majority assumption. So for example, let's say if I send my USDC from chain a to chain b, and I want to bring it back, but there's a dishonest majority running the chain b, and they produce an invalid block that contains an invalid transaction in it that steals all my USDC, and they try to bridge it back, there's not a lot you can do there. So light clients are just not enough because you still need that honest majority assumption there.
00:16:15.592 - 00:16:27.410, Speaker E: But isn't this the same point as 51% attack on bitcoin? Sorry, isn't this the same as 51% attack on bitcoin? It is possible, but it's not feasible.
00:16:27.570 - 00:16:58.580, Speaker A: But with a 51% attack, I cannot really steal funds because a full node will just reject an invalid block, whereas in here I can bridge back and steal funds because full node cannot do anything because it's a light client implemented on another chain. So the difference here is that a full node in Ethereum or bitcoin or any other l one can just reject an invalid block, whereas if you're bridging back, there's nobody to reject that block. Thanks.
00:17:00.710 - 00:17:03.060, Speaker B: Anyone anymore in the back?
00:17:07.290 - 00:17:08.040, Speaker A: Hello.
00:17:09.130 - 00:17:21.690, Speaker G: So I'd like to ask you if by saying it is not possible to have trust in bridge, you mean your trust is as weak as the weakest element?
00:17:22.750 - 00:17:41.518, Speaker A: Yes, essentially you introduced an additional trust assumption always when bridging, and therefore the overall security of the protocol is always weaker than just using an l one without bridging. So you're always going to have additional trust assumptions involved there.
00:17:41.684 - 00:18:08.118, Speaker G: Yeah, but how do you respond? Because if you start thinking like that, you can solve all the problems using redundancy. Let's say you have a light client, you can verify it in multiple ways. Multiple, like in all proof systems we know, for example, and you pick five out of seven. But if you think like that, like you, it's like turtles all the way down, right?
00:18:08.284 - 00:18:57.320, Speaker A: Oh, 100%. You can minimize the possibility of that happening. So for example, there's talk about using multi provers for roll ups to basically have multiple different proof systems commit to a state, and then if both of them agree on the state route, then the bridge functions as intended. Whereas if they disagree for one reason or another, the bridge stops. And then you either use governance or some other form to resolve that. That obviously minimizes the possibility of something going wrong, but that still doesn't completely remove it. Because while it's improbable to imagine that two different proof systems can have the same vulnerability, that's still theoretically possible.
00:18:58.010 - 00:19:18.142, Speaker G: Yeah, but what you're saying here is that you don't believe in the probabilistic proof. You don't believe that the proof something can be proved like 99 per nine. Nine. And like you say, this is not enough, but this is how zero knowledge proofs work these days. Right, but would you say that you don't believe in zero knowledge in general.
00:19:18.276 - 00:19:50.620, Speaker A: But every single zero knowledge paper mentions that there's a negligible possibility that they can be broken, which means that there's a possibility. Obviously it's completely negligible, and the probability is usually like two to the power of -100 or something completely impossible, but it's not zero. So that's why I would say that there's a difference between trust minimized to the point where the probability of something going wrong is negligible, versus trust minimized trustless where the probability of something going wrong is zero.
00:19:54.270 - 00:20:03.718, Speaker B: Thank you. Any more takers in the frontal?
00:20:03.894 - 00:20:22.290, Speaker F: Given that you stated that those breaches can't be trusted, what is your desired route of the entire ecosystem to go forward? Is it possible to enhance those bridges? Given that trust being trustful is impossible?
00:20:23.190 - 00:20:27.926, Speaker A: Could you repeat a bit louder because I can barely hear you. Sorry about that.
00:20:28.028 - 00:20:52.090, Speaker F: Given that you stated that bridges can't be trusted fully, what are your recipes for the ecosystem to go forward? Given that from my perspective, there are two ways either somehow make the bridges as secure as a zero knowledge proof as was stated earlier, for example, introduce something like big blocks.
00:20:52.250 - 00:21:45.680, Speaker A: Yeah. So while when I say that they cannot be trustless, they can be hardened and made secure to the point where the probability of something going wrong is very small. So an example of how you can do that is by using multiprovers, as I mentioned previously, where two different proof systems agree with one another, and you can even use three or more. So it's up to you how many you can use. And the same can be true on the smart contract side, so you can use multivarifiers. So let's say you take a specification of the contract, and you implement one in solidity and one in Viper, and if both of them agree on the same outcome, then the bridge functions as intended. And if they disagree for one reason or another, then you know that one of them is broken, which means that you stop the bridge and then you analyze what happened.
00:21:45.680 - 00:21:51.150, Speaker A: That, in my opinion, is the most secure setup you can have for a bridge.
00:21:53.010 - 00:22:07.640, Speaker F: Do you consider promoting solutions like increasing the block size? Sorry, would you be satisfied with solution that included removing bridges and increasing the block size?
00:22:08.730 - 00:22:47.780, Speaker A: But that's not really a viable option, especially let's take Ethereum as an example here. One of the core philosophies of Ethereum is that you should be able to run a full node on relatively cheap hardware. So increasing the blocks, even if we assume that there are no bottlenecks and you can just infinitely increase the gas limit, will result in full nodes being inaccessible to average users, which means that we either have to rely on centralized services like rpcs, et cetera, et cetera, run light clients, which are okay for a lot of users but are not the solution per se.
00:22:51.270 - 00:22:56.718, Speaker F: Is it better or worse than having bridges that are faulty?
00:22:56.894 - 00:23:24.030, Speaker A: I feel like having bridges is a better option because you can harden them and the likelihood of something going wrong is much lower. But on top of that, if you don't increase the block size on Ethereum, people always have an option to just use Ethereum without using bridging to roll ups, et cetera, et cetera. So they always have that option, whereas if you increase the block size, in a lot of the cases, people just won't be able to afford to run a full node.
00:23:28.130 - 00:23:32.042, Speaker B: Thank you. Okay then. Thank you Togo.
00:23:32.106 - 00:23:32.700, Speaker A: Thank you very much.
