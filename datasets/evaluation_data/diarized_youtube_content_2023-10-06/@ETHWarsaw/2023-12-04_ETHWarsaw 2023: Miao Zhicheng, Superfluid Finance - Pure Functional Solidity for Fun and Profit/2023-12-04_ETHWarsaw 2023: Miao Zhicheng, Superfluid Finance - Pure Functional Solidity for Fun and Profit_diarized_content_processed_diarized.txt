00:00:02.810 - 00:01:08.046, Speaker A: Will present on solidity. So let's welcome Miao warmly in Warsaw. I was thinking, should I be louder? Okay, thanks everyone for coming this talk and it seems there are some people interested about the functional programming, right? So quickly, my name is Miao, I co founded a superfluid and you may find me with my funny handle that I inherited from my childhood. Hell Wolf, from various places except Twitter. Okay, so I'm going to talk about functional programming in solidity today. And so the goal of this talk is demonstrate the possibility of kind of limited functional programming in solidity and showcase an example of using this paradigm to build super token. I don't know if I actually that today, but make you interested also in functional programming.
00:01:08.046 - 00:01:46.350, Speaker A: So first question of course is who here thinks know what is functional programming? General. Okay. And also practiced it to some extent. Okay, good. I have a good crowd here. So a quick example in solidity, right? So how it looks like? It looks like normal solidity, but with a few that I kind of separate in three sections. First section is kind of pure functions.
00:01:46.350 - 00:02:06.930, Speaker A: So you call those underscore pure functions. It return a data structure and that's kind of retrieving the data. Sorry, those are not pure functions. Those are like retrieving the data. The second section, like shift flow, that would be like the pure function which you send a structure inside and do some transformation. Return A and B. I'll show that in a moment.
00:02:06.930 - 00:02:54.900, Speaker A: There's something tricky about memory. Then in the last section you just apply the storage operations, right? So kind of, it's still solidity, but you separate the pure logic per se. Right? So that's just a quick example. Let's dive into what is it about? Right? So what is functional programming? Let's start with that. So the way I see it is that the functional program is really about more describe your program in terms of what it is as opposed to, say how you should do it, more declarative as opposed to prescriptive or imperative, like describing how step by step, how it's done. Right. So more what and less how.
00:02:54.900 - 00:03:34.894, Speaker A: So implement as much code as possible in kind of in data definitions, equations and the logic formulas, or sometimes called properties. And for this code, kind of strictly pure functions are your friends because kind of reference your transparency, that's a word people use in the FB community, functional program community. So kind of same input, same output. You are guaranteed with that. I use a word explicitly say strictly pure functions, but in solidity you should know that there's pure functions, but it's deceptive. It's not strictly pure because of memory stuff. I'll show in a minute.
00:03:34.894 - 00:04:41.910, Speaker A: What do I mean? So it is really about deferring the side effects. So what are the common side effects? The storage access is definitely side effects. Whenever you access storage, you lose the ability to have a referential transparency, right? So that means that you can't guarantee that when you call a function, you get the same result because you're accessing something that is outside of your control often. And other things like integrations with external code, like glue code, like for example, you call uniswap and do something, those kind of external transactions and those are the interactions. That kind of computation strategies is more abstract sense, right? So when you describe a bunch of equations, there's nothing said about how those computations are performed. In which sequence is it in parallel? Is it in sequence? So computation strategy is also part of the side effects, which is a bit more abstract and probably less obvious often. So to make the code actual use for implementing the computational strategies, it's needed.
00:04:41.910 - 00:05:37.378, Speaker A: So what are the computational strategies? Most of language has this built in. You don't even notice like solidity, any other imperative language, JavaScript or something. You do take it for granted when you write a code, you know that, okay, this code is going to be executed before that. So kind of taking for granted, typically sequential also, right? Some people may call it monas. We'll explain what that means in a moment. But the thing is, things can be concurrent and kind of like graph computing, right? So think of, I think the best example I would give is like your spreadsheets, when you write things in spreadsheets, write a formula or anything, you don't write, okay, which cell should be calculated first? It's all just dependent graphs, right? So when you change one cell, all other formulas depend on that. Cell will also get updated.
00:05:37.378 - 00:06:09.170, Speaker A: So in that sense it is concurrent. So there's nothing said about how the cell should be calculated. You don't write that as a spreadsheet maker, right? So that's where in a computation strategy also it's kind of abstracted away. But with normal programming language, you don't get that apart from kind of more pure functional programming language. Now, abstract stuff going away. We talk about why functional programming. I think the best paper, the classical one, would be from John Hughes.
00:06:09.170 - 00:06:53.118, Speaker A: Really recommend anyone haven't read it? Read it, because the title is why functional programming matters, right? Title says itself. So it is a gateway drug to the functional programming. So going to repeat myself. So one of the quote I would like to give is from the paper is that as a software becomes more and more complex, it is more and more important to structure it well. And well structured software is easy to write, easy to debug, and provides a collection of modules that can be reused and to reduce future programming costs. Right. It's very prescient about what I said there.
00:06:53.118 - 00:07:54.546, Speaker A: And I think for the smart contract space, especially important, this principle. I mean, in a bull market we want to move fast and break things, but when you actually want to take over the world with this new financial system, you might want to take it more seriously than that. So it is important to kind of learn from some of the past great minds about this. I think this is really how to manage complexity and how to make sure that your smart contracts is under control, is more secure. Ultimately, the keywords is a better debugging, better reusability and less maintenance costs. I claim that it is the best way to structure smart contracts, but it takes time to get there because there are a couple of language, of course, but most people still using solidity. Right.
00:07:54.546 - 00:08:35.920, Speaker A: So let's see how far we can get with solidity to try this programming style. So that's what I want to achieve here today's. Should I say something about this? I mean, how do we nowadays test our stuff, right? Some people say testing production, right? Good for them. But maybe in smart contracts, if you want to deal with people's money, we do a lot of extensive testing. Right. So before you go out, before you kind of deal with other people's money, you might want to test a bit more. Right.
00:08:35.920 - 00:08:59.446, Speaker A: Some limited post production form of vacation. I don't use the correct word here, unfortunately. I need to change that. So people you may know about tools like Sera, they provide this verification language. They can help you to provide more assurance after the testing. Because testing don't necessarily address everything because it's manual. Right.
00:08:59.446 - 00:09:33.374, Speaker A: But you have from trail of bits they have tools such as echidna, if you heard of. It's a kind of great fuzzing tool that can automatically help you to discover more cases without you to write a lot of code. Nowadays in foundry you also have an invariance test which does kind of similar thing. But I think Akidna goes way ahead. I would recommend you to have a look from the trail of bits called echidna. A e c h I d n a if I spell correctly. Yeah, but the other approach would be more kind of correctness by construction.
00:09:33.374 - 00:10:41.914, Speaker A: What does it mean is that when you create a code, you try to have as much as correctness built in, right? So I think functional programming is one way to getting closer to that, right? So that's much more sophisticated way. But if you structure the code in a more functional programming way, you are getting closer to more correctness by construction. But let me give you more example, as opposed to talking a bit too abstract. So what about solidity? Solidity is nowhere near being able to kind of express all the functional programming ideas, but we can emulate some of the ideas. So here are some of the technique that I have been using in some of the production code. First of all, there's custom type, so you kind of have bit more type system facility from solidity, since I don't know when the custom type is from eight point something, right? But there's another thing called operator overloading, it seems like 8.19. This is one of a little trick you could use.
00:10:41.914 - 00:11:27.734, Speaker A: So as example. So here you can define a type alias, actually type wrapper, in this case for the int 128, and you define bunch of functions, they call it free functions, which is a confusing word, I call it a free range function, meaning that these functions you can define outside of the contract space, globally define them, those are, look fine, you have a pure return, which is pure function. Then the last one is 8.19 introduced. It's called operator overloading. So to make it easier, simpler to use, I guess. So you can have redefined the plus and minus operators for this particular data type, right.
00:11:27.734 - 00:12:11.746, Speaker A: So this will help you to make the type little bit more type information will be more strong, so that you can't do more than what you define here. So that's one small technique. It may be trivial to some people, but it's important, I think, to make sure that you get as much out of your compiler as much as possible. And unfortunately they did only halfway. So if I need to mix different types, let's say I want to multiply the flow rate and time. If you multiply a rate and time, you get what return a value. But unfortunately solidity don't allow that type operator overloading.
00:12:11.746 - 00:13:04.582, Speaker A: So I kind of just using this external library trick, right, you can export this function globally and tie to that particular type. So now I can do like flow rmul r multiply time. So far it's only syntactical, but let's go a bit more than that. I'm talking about now the strictly pure functions. So not just a pure function syntactically from the solidity, but strictly, what do I mean here? So I would advocate using this programming style, you clone everything. I know some people are going to say, what about gas cost? Let's not go there. So referential reference types passed with memory keywords can be kind of modified by the pure function, which is weird, but that's like JavaScript, right? You pass object, even if it's const, you can change it.
00:13:04.582 - 00:13:29.840, Speaker A: That's kind of the idea from there, probably when they did it. But if you want to have a referential transparency, you want to avoid that. So what you do is create a boilerplate function called clone. So each time you get a memory object from somewhere, you clone it. And so you make sure that you never change the input. It's kind of force yourself a kind of coding style. People argue about a gas cost, but I'm not going there.
00:13:29.840 - 00:13:58.782, Speaker A: In fact, it's quite small if you measure it. So unfortunately, there's no general way of doing Mem copy per se. Right. So that means that the boilerplate code is a bit slightly annoying, but you only need to do one clone for each object. Sorry, structure type. So it's kind of manageable. But I wish there was more general mem copy kind of function so that I don't have to do this boilerplate.
00:13:58.782 - 00:14:35.186, Speaker A: Small thing. All right, so an example. So this RTB function, meaning real time balance function. So you have input, which is a structure called a basic particle, then you have a time. So basically you are calculating of this very abstract data type per se at this time, what value is it? What balance value is it? Right. So you access the flow rate and you multiply by the time delta and you plus the settled value, right? So that's kind of the one liner equation. And the settle function.
00:14:35.186 - 00:15:06.960, Speaker A: There's an a clone, as you can see there. So that's the trick that you make sure that you don't touch the input memory. So make sure that it becomes strictly pure. So just force yourself to have this kind of code sign away. Right. So it will benefit a lot if you keep doing that, because then you kind of have a much stronger referential transparency when you write solidity. But you have to follow this because solidity don't offer full kind of support, and you have to force yourself to do something like that.
00:15:06.960 - 00:15:41.260, Speaker A: Okay, so now we have something like still kind of not so alienish, but let's see an example. Let's generate some tests with what we have so far, right? So this is using foundry that I say, okay, I want to generate a bunch of random, like using the foundry fuzzing. Right? I have randomly generated m one. I think it's time. X one is probably the. Let me check. Operating one.
00:15:41.260 - 00:16:10.446, Speaker A: Yeah, I think that's the value. Right. If you see the function signature, there's a bunch of value generated by foundry randomly, and there are two function pointers for doing the actual test generation. So I have this more general equations to assert. The last assert is the most important. Right. That's what I want to assert.
00:16:10.446 - 00:16:41.514, Speaker A: I'm going to assert whatever operation you do. In the end, the property holds, which is everything sum up to zero. So that's what I want to test. But how do I generate all the test? I just passed the functions like uu underscore shift two, shift two. Then the second one would be uu flow two, flow to flow to, shift two, shift to flow to. So I use one generator function to create four new, different cases. This is kind of like the high order function insulated.
00:16:41.514 - 00:17:21.370, Speaker A: You can do that, but it's, ergonomically, it's not that great, but it does help. Less boilerplate when you write generate test cases, for example. So what's a playbook? The playbook would be that you define a data structure, perhaps with the help of custom types. Also, you define a clone function. So if there's mem copy, that'll be great. But they don't. So create a strictly pure function for the data, like basically a data transformation function, but these are all strictly pure functions.
00:17:21.370 - 00:17:57.334, Speaker A: Now, the very important part is finding the kind of properties and write test for these functions, because now you have strictly pure functions, then you can write the property on the test. And now foundry has great support for almost like property based testing. Right. So using that and test all the equations you want. Sorry. Yeah. What does it represent? Yeah, thanks for the question.
00:17:57.334 - 00:18:53.894, Speaker A: I didn't want to explain that, because the time limit, but in this case, it represents the balance of account, which is dependent on the block time. Let's say the block time is the time settled at, so that when the time moves, your balance also changes. So this is a data structure to allow that to happen. And this data structure also allows to implement additional operations, such as shifting the value, which is transfer, basically, and off flow, meaning that you're connecting two accounts and you flow the balance from one account to the other. Yes. You need to save the necessary data in order to allow you to implement these operations. Do we save this structure? So far we don't touch any storage yet.
00:18:53.894 - 00:19:03.526, Speaker A: So far it's all pure memory data. Right. So we're good. All right. We're not there yet. Right. I think I have only ten minutes, so I need to be a little faster.
00:19:03.526 - 00:19:29.460, Speaker A: Sorry. Okay, so first example, the property would be ADM potence, right? So if I settle the, there's a settle function, right. If I settle the data twice, it should return the same thing. That's what it means at the item potence, I guess. So you settle twice with the same value, you get the same thing. So you never get a different value. Then you have an associativity law, right.
00:19:29.460 - 00:20:03.438, Speaker A: If you do the operations with a bracket like bracket in the first two versus the second part, then it should equal to each other. That's another property. It's important for the data. For the data. I might not have time to go there, but if you are familiar with some of other functional programming stuff, you might have some memory of that. So now we come to the important part. Now we have a bunch of equations, but they don't touch any data.
00:20:03.438 - 00:20:53.294, Speaker A: So what are we doing? Right. So we can't really go to the blockchain. Now I have to mention the most dreaded word in functional programming, the m word. It's so called a monad. And basically, in simpler words is how can we make those pure functions actually work in blockchain? So we kind of have to sequence everything in a sequential way, right? So we run one function after each other and apply some storage update. So one of the way to kind of emulate that concept in solidity is to implement getter and setters, but as virtual, pure virtual functions. And do they call pure virtual, just virtual functions in an abstract contract? Right.
00:20:53.294 - 00:21:19.974, Speaker A: So you defer the implementation of that to the final contract. So this way you can implement this abstract contract without having to specify how that's actually done. So this become reusable. So the idea is you want to make a sequential computing strategy that is reusable for other people. Right. Okay. Fairly abstract so far.
00:21:19.974 - 00:21:57.662, Speaker A: I hope this one can show you. I think back to the first quick example I showed in the beginning of the talk. So in this case I implemented a reusable dual flow function. This is no longer pure function. This actually does the computational strategy, right. So you load some data which is virtual function, the one that using that contract has to implement what is get flow rate? What is get this index? Right. You load those data as memory, you pass that memory structure to the shift flow pure function, you get the new data out and then you apply the storage, storage update.
00:21:57.662 - 00:22:33.150, Speaker A: So retrieving data do some transformation and update. That becomes kind of reusable. Building block, thanks to the virtual function, but this is just one way of doing it. There's other way which I actually skipped. So let me just do a recap. I will not go there. So the playbook is, you define the data, you define the stricter pure functions for those data, for transformations, and you find the property and the right tests for those properties.
00:22:33.150 - 00:23:10.490, Speaker A: Then you're stitching together with kind of strictly separation of the pure functions and side effects, especially the storage one. And that's it. That's kind of the playbook as far as we can go with solidity, as far as I can tell. Right. Can I do this in production? I claim we can because we actually do. So, yes, I'm from superfluid again, so that's what we do for some of the code. So the super token is basically kind of yacht 20, but with additional capabilities.
00:23:10.490 - 00:23:43.682, Speaker A: So we have upcoming feature called GDA, which I didn't explain, general distribution. So it's like you can distribute from one account to any number of accounts in streams in one transaction, or update the flow rate in one transaction. That feature is actually entirely implemented with this new paradigm. We have also actually Cairo v zero implementation. They call it v zero. I think. I think v one is totally breaking everything.
00:23:43.682 - 00:24:27.038, Speaker A: That's as far as I remember. So the V two or whatever v three implementation, we will definitely use a new strategy if you're using solidity. So yes, you can do that in production. And I encourage actually to try that out. And one side of the story is that I actually used some of the Satora tool and I can say for sure that it helps with the formal vacation. Using Settora, for example, you can find the code example, even the Satora verification code from our repo. A teaser just for today, the talk.
00:24:27.038 - 00:24:55.274, Speaker A: So can we use solidity instead? So far we talk about using solidity directly. Maybe we can just use you, but using a different, higher level functional programming language to kind of transpire to you directly as opposed to using the solidity. Right. So just as a teaser, I'm actually working on a project on that. Can't show that yet. If you're interested, after the talk, I'm happy to disclose more. So I'm kind of on time.
00:24:55.274 - 00:25:27.700, Speaker A: So thank you for listening. So let's make solidity code better using functional programming now. Okay, thank you. The transcript can be found from our monoreppo and in the wiki area you can find the transcript. Yeah. Any questions? Happy to answer any question. Can you explain a bit more that EFF parameter that was seen in the.
00:25:27.700 - 00:26:05.566, Speaker A: Yes, I think I maybe overdid it to that one. Do you have more specific question about EFF? What does it mean? Yeah, like what exactly it's used for. Looked very monadish when it first appeared, but not exactly. Yeah, okay. All right. Yeah, good question, because I did skip that explanation because when you do a virtual function here, right. But implementation might attach some special context because otherwise I might lose, I mean, if I want to store to some specific storage or whatever, that context has to be provided.
00:26:05.566 - 00:26:33.942, Speaker A: That's why it's kind of opaque bytes memory, the EFF name here. So I kind of overdid it. It should be just a context because then the virtual function implementer can put whatever the context they have, so they have information regarding what's related to this. So that's kind of the case. But actually the EFF name itself, if you know about algebraic effect, that's kind of what I'm taking the name from. Right. So there's an alternative implementation.
00:26:33.942 - 00:27:22.458, Speaker A: Actually if you dig into our code base, I actually did a token f, which has a bit more strange way of doing the reusable code, but I didn't show it here because that's too esoteric. But that's kind of the idea from. Yeah, sorry, let's get you the mic. I understand that you started doing functional programming in so easy because it is your extensive background and it was easier for you to write functional code than regular code. So what amount of years did you do functional programming before starting doing that? Okay, so as a confectioner I started programming. There was only probably two programming languages I consider serious, C plus five and Perl. And so that was the days.
00:27:22.458 - 00:28:27.422, Speaker A: I'm not a computer science background. I mean, I started computer science, more like computer science and engineering. So what we were told to learn is C, Perl, Java, all this kind of thing. But as my career moves on, then we learn more and more functional programming, get into in touch with functional programming more. I used to work for Twilio and they had extensive use of scala at some point. So a lot of people advocating Scala went to work for Twilio, and that's kind of where a lot of people talk about Scala is like a wannabe Haskell in the JVM world, right? So that's kind of the thing. But personally I always kind of aspire to do the functional programming, but only kind of recently started to kind of dig really deep into profession of Costco at the moment.
00:28:27.422 - 00:28:53.160, Speaker A: Quite okay. Yes, I would say yes. Actually my secret project is entirely in Haskell so if you're interested, we can talk about that later. Yeah. You might not like my question, but anyway, the gas cost. Yeah, do like this approach. The benefits of this approach outweigh the potential extra gas cost.
00:28:53.160 - 00:29:42.774, Speaker A: So I did measure, and even by simply knowing how the memory copy gas cost is, I can tell you that it's insignificant in the grand scheme of things. Right. So what I mean is, for example, reading a storage 500 and the writer's fresh storage is 20,000, right? So that storage actually overrides the gas cost for most of the things. And external core also sometimes copy, like passing the core data and to the memory and actually internally memory copy. It's really low. I mean, I encourage you to find it out yourself. Don't take my words.
00:29:42.774 - 00:30:19.700, Speaker A: I claim it's really low, but I might be biased. But I say comparing to all other significant gas costs, it is not necessarily a concern. But do verify yourself. Okay, the final question. Yeah, this is more like a comment. So if you like functional programming, you can do a Haskell smart contract in Cardano and you can do lisp smart contracts in many other blockchains. So you don't need to stick to EVM if you really want to talk to yourself.
00:30:19.700 - 00:31:46.374, Speaker A: No, I want to stick to EVM work. So I'm going to introduce something to EVM someday. Yes, maybe near future. Okay, have you tried using compilers apart from the solidity word, something like industry standard LLVM with some custom backend for the EVM, or in general compilers out of ethereum word solidity and so on? What I have considered, I don't know if it's matching what you are saying here is what I'm trying here, which I said is secret project is I'm compiling an unnamed higher level functional programming language to solidity u directly then I can use. Because then you guys can use solid compiler to compile the solidity u to the evm code, right? So I'm not creating anything new language, any different compilers. You might be right, but I think you may well be right actually. So.
00:31:46.374 - 00:32:18.092, Speaker A: But I think there's an engineering cost problem, right? So to creating more things is more expensive, I mean by definition than creating less. So I'm actually looking into creating a minimum, but to achieve this right, so I'm trying to find a middle way, but I think you might be really. Okay. All right, thanks. Give it up. Cool. For super.
00:32:18.092 - 00:32:19.230, Speaker A: Thank you very much.
