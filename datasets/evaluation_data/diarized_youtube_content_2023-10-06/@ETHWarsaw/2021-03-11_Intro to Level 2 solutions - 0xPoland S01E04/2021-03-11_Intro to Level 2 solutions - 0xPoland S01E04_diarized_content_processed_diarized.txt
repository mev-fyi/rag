00:00:07.180 - 00:00:47.870, Speaker A: Hello everyone. Welcome on the fourth meeting of Zero exponent. I'm super excited. Today we're going to do some really exciting things. So without further ado, let's see what's going to happen. So first of all, I want to give a shout out to our organizer e forks and maker, thanks to whom it's all possible. And I want to say thanks to our media partners, cryptodev TV and Zusumid Bitcoina, who help us promote Zerox Poland and help us in our mission to bring more software developers to blockchain and ethereum space.
00:00:47.870 - 00:01:29.576, Speaker A: And I want to remind everyone who don't remember yet that we have a student workshops coming any week now. So please subscribe. You go to students Zeroxpoland dev. Let's see if we can see the address in the bottom corner. And if you're a student or if you're a fresh graduate or you know how to code and you want to learn how to code Ethereum, make sure to subscribe, make sure to sign up and join the workshops. And finally, I want to remind you there is a hackathon coming in May. The date has changed a little bit since the last time we talked.
00:01:29.576 - 00:02:15.028, Speaker A: So it's two weeks, Hackathon starting on May 14. We're going to announce the sponsors and we're going to announce the speakers pretty soon, any week now. So make sure you follow us on Twitter, make sure you follow us on different channels to see when the announcement is going to be. But I can today confirm that we have $40,000 in awards. So you can see already it's going to be pretty high profile. So join the discord, follow us on Twitter, make sure you stay tuned to make sure you know what's going on. And for today, I'm super excited to announce our today's speakers.
00:02:15.028 - 00:03:01.156, Speaker A: And I think I'm especially proud we get to this moment. This first free meetings were kind of laying out the basics, explaining the blockchain, expecting it, explaining Ethereum, solidity, Defi, a lot of basic things. And today we're finally getting to the point, we're getting to the edge, we're getting to the verge, we're getting to where the things are happening on the blockchain now. And the topic for today is layer two solutions or level two solutions. And we have two amazing guests. One is Bartek Kipushevsky from maker, with whom we're co organizing the whole event. And Bartek is a legendary person in polish blockchain space and beyond.
00:03:01.156 - 00:03:49.296, Speaker A: He worked on tons of very important parts in the maker Dao ecosystem. And he going to do today an introduction to level two solutions on the blockchain. And as a second guest, we're going to have Alex Buhowski. Alex is a CEO of ZK Sync, which is a leading zero knowledge based scalability solution, a layer two solution for Ethereum that is completely over open source and it's getting a lot of traction right now. And there is a lot of very interesting things going on in this space. And Alex just announced some very interesting things a few days ago. So he's going to talk about compatibility between Zksync and Ethereum and solidity.
00:03:49.296 - 00:04:08.680, Speaker A: So he's going to talk about all of that today. Yeah. Without further ado. Really, really excited. And I'll let Bardic take over. So Bardik is joining us. Bardik, I think you need to share your screen and when you do, we're going to switch.
00:04:08.680 - 00:04:12.240, Speaker A: Yeah, I'm leaving you with Bartek.
00:04:13.620 - 00:05:08.690, Speaker B: Right. Thanks, Marek, so much. Super excited to be here. My name is Bartekushevsky. I'm with Maker for the last three years and this is really the intro to some of the much more advanced topics, I guess. And I kind of decided that whenever I talk about roll ups or different scaling solutions, I think it's actually quite important to understand what is the reason why it's so hard to actually scale blockchains while retaining the permissionless nature of permissionless blockchains. So treat it as a bit of a background info, as an intro to much more advanced talk that will.
00:05:08.690 - 00:06:02.940, Speaker B: My understanding is that that's going to follow mine. So I'm super excited. I hope that I can learn a lot from the subsequent talk as well. But going back to the basics, let's see why blockchain validation is actually so important and why this is foundational to how we actually architect scaling solutions. So back to the basics, essentially Ethereum. Similarly to bitcoin, you can think about Ethereum as a blockchain that down at the database level consists of blocks. And these blocks need to propagate across the network.
00:06:02.940 - 00:06:35.436, Speaker B: And all these blocks, they contain transactions and they are propagated in a gossip network between the different blockchain nodes. Right. So this is more or less how it happens. There are some mining nodes, they are trying to find a new block. Each block contains transactions. And whenever the miner announces that the new block is found, they will actually propagate this block across the network. And that actually takes some time.
00:06:35.436 - 00:07:37.324, Speaker B: But eventually all the nodes participating in the network, they should receive the same block. I'm kind of ignoring sync problems, I'm ignoring the problem of two different miners finding different blocks in more or less the same time. So just for the sake of simplicity, let's just simply assume that after a while we're going to end up, every single node will eventually end up with a block that's been created by one of the miners. Now what's inside the block? And I think this is actually something that's interesting so that we understand where are the scalability problems. Each block contains a bunch of transactions, and all these transactions, they somewhat change the blockchain state. So as much as the state can represent anything, we will sort of consider a simple scenario where the state is simply the list of balances of some token. In this particular case, it's MKR token.
00:07:37.324 - 00:08:27.374, Speaker B: And let's just have a look at this simple example. Right, this is the initial state. Bob with 1000 MkR, Alice with 200, and Charlie with zero. And there is a list of transactions that should be processed from the top to the bottom. And the question is, what should be the post state? So I'm going to pause for a second for all you to think how many tokens Alice will have once this block is actually processed. So it should be a very easy question, I guess. And all of you that ended up with 500, they are, right.
00:08:27.374 - 00:09:17.914, Speaker B: Whoever came with a different number, they have to sort of consider the fact that the last transaction from Bob will fail because he doesn't have 600 mkr. So even though he tried to send Ali 600 mkr, that final transaction will fail. And any nodes that actually validates the transaction will simply ignore it. And the final state from Alice is 500 mkr. So obviously we should be very interested in making sure that we do understand the final state. Because if we are mistaken, what is the balance of Alice or whoever that can result in double spending, that can result in all sorts of problems. Right? So blockchain, at its core, it's really a state machine.
00:09:17.914 - 00:09:40.920, Speaker B: It sort of takes a pre state, a bunch of transactions and it computes the post state. The thing is that on a technical level, we do not store the state inside the block. It's impossible. It's just too much. Right. On Ethereum state is huge right now. I think it's over 60GB, maybe more.
00:09:40.920 - 00:10:36.870, Speaker B: And instead of storing the whole state, we actually compress it into one hash using some more or less advanced crypto techniques. But the point is that at the end of the day, all we store inside the blockchain is what we call a state commitment. It's a hash that is computed from the whole state, right? So just by looking at the block, we do not know how many MKR tokens Alice has, but we can actually compute it itself knowing the pre state, the sequence of transactions and the post state. Actually the presate is not needed because the pre state is the post state of the previous block. But I'm sure that you get the point. Right. So again, how does it look like from the user's perspective? Well, first miner finding a new block versus user that learns about the new block.
00:10:36.870 - 00:11:47.954, Speaker B: And now in most circumstances the user will be interested in actually knowing what is the current state, right? So what are the options for the user? They can actually ask the miner, right? They can ask the miner what is the state? And the miner can reply, and maybe this is good for the user. But frankly, even though the miner has computed the block and they claim that this is the post state, well, there is no way to know. So really without doing anything else, we're back to trusting the minor, right? And the minor can lie for whatever reason. So the easy way to actually find out if the minor is not lying is to simply validate the state ourselves, right? So this way we do not have to trust the miner. We do not have to get this info from the miner. All we need to do is to look at the blockchain, look at the list of transactions, and we can actually compute the state ourselves. And this is literally how the bitcoin work and how the Ethereum works.
00:11:47.954 - 00:12:49.346, Speaker B: And this is how people running so called full nodes participate in the network. And this is crucial, right, because being able to validate the blockchain actually allows us to not trust the minus, right? Allows us to sort of look at miners as entities doing some service for us. But at the end of the day, there is no trust relationship with the miners, right? So once we verify, we can be sure that Bob has 400 MkR and we can do whatever we want to do with this information. Now, if you look at the full network, you'll see that there are different participants, right? There are people that are mining blocks, there are full nodes that are verifying these blocks. But to verify the block, you actually need to run the full node. You need to have a computer that does that. So obviously not everybody will do it.
00:12:49.346 - 00:14:08.160, Speaker B: There will be users relying on some extra providers and they will be sort of relying on other full nodes to provide them with whatever information they want, right? And they will establish some sort of a trust relationship with these nodes. So let's see what happens when something goes wrong, right? The miner mines a block. They claim that this is the post state and upon verification, and we need to be able to actually verify this, right? So as you may be aware, on ethereum network, every single new block is added to the blockchain every 15 seconds. And as long as I can keep up with the blockchain, as long as I can verify that block in this time window, I should be okay. I don't need to trust the minor. But what if instead of 15 seconds and let's say 300 transactions, suddenly now there's like a supercomputer right on the mining side and they actually put a lot of transactions inside the block, like 20,000 transactions. How am I supposed to verify that? I may not be able to keep up.
00:14:08.160 - 00:14:57.530, Speaker B: So because I can't keep up and I cannot validate that block myself. Well, right now, I mean, I'm at the mercy of the miner, right? I cannot verify all these blocks. My computer is just not fast enough. And I need to ask this supercomputer about the state. So really running a validating node on a consumer grade laptop is actually necessary if we don't want to trust miners. And at the bottom of all the scalability problems for blockchains lies the problem of the speed of validation, right? This is a real scalability bottleneck. And this is actually confusing for a lot of people because they kind of assume that it's okay for miners to actually have all these super fast computers.
00:14:57.530 - 00:15:55.898, Speaker B: Well, actually it's not, right. There's literally nothing right now on Ethereum stopping us from increasing the block size and from reducing the time between blocks. But if we did that, then we won't be able actually to validate independently network. And same with bitcoin, right? The trust assumptions on bitcoin network are even lower so that the time between blocks is even longer and the blocks are smaller. So it takes actually less time to validate blocks. It makes it much easier for anyone to run the full node. So what would happen if everybody colludes and everybody was evil, right? So the miner actually mines fraudulent block and they actually include a fraudulent transaction inside the block.
00:15:55.898 - 00:18:04.038, Speaker B: Well, everybody's lying on the network. However, there is this one guy, right? Just one full node in the whole network that is not colluding, right? So we call it one honest node security assumption. And if there is just one guy that doesn't trust everybody else and they are able to independently verify the network, they can raise an alarm, right? And because they raise an alarm, we kind of hope that other users that are relying on other nodes, which again, they are lying, right? And they don't know that, but they hear the alarm from this one honest validator, they will sort of propagate this alarm and now some sort of a chaos will spread across the network and maybe other users will launch or will spin off their own nodes and they will actually verify that indeed the rest of the network is colluding, right? And we will be able to literally reject that network. That's actually fraudulent. And I think it's important to understand that all it takes for this to happen is one honest validator, right? So this one honest validator assumption, this is not like 51% attack or anything like that. I mean, it takes one full node to validate the blockchain as long as, of course, we can actually do it, right? So to sum up, it's other miners that actually validate other miners full node users, they also validate miners. And as a result, on public bitcoin and Ethereum network, miners just simply don't cheat, right? I mean, bitcoin is on for the last, over ten years, Ethereum last six years or so, and I've never heard about any single incident of any single miner, including non valid transaction inside the block, which is interesting because there's literally nothing stopping them to do so.
00:18:04.038 - 00:19:27.534, Speaker B: However, no minor, to the best of my knowledge, has ever done that. So as you can see, it is possible that miners can include the invalid transactions. They just simply don't do it, right, because they would be immediately caught cheating and the rest of the network will reject them. And all it takes is the one honest, full note for this to happen. And this is why we insist that it should be possible on a public blockchain for anybody with decent computing power and not a huge data center or supercomputer to actually be able to validate independently from the rest of the network the state of the blockchain. So this is the foundation, right? Now let me introduce another concept, because everything that I said so far is actually around what we call optimistic verification, right? So the minor, which we will call subsequently an optimistic minor, they will not provide any kind of a proof that the state is actually correct. If you go to the ether scan, and if you look at the transactions, you will see in ether scan a block and you will see the state commitment.
00:19:27.534 - 00:20:18.158, Speaker B: You have to just trust, there is no proof that this is the correct state, right? You can verify it yourself independently, but you have to trust it. And remember that for this to work, the state cannot be huge. And we put artificial constraints on the size of the block, right. And this is why we can only put so many transactions inside the blockchain. Now there's another technique, and you will learn about the details of this technique in the subsequent presentation. And that is that the miner not just tells us the post state, but also they provide the cryptographic proof, which we call a zero knowledge proof that the state is indeed correct. So this is the proof, that's literally proof that the miner is not lying.
00:20:18.158 - 00:21:20.502, Speaker B: And this is the cryptographic proof that this post state is actually a valid post state after processing all these transactions that are inside the block. So you can see immediately that now I do not have to verify anything really because I can be certain that this post state is correct. And now suddenly I can think about scaling it much more, right, because I can imagine that there's this zero knowledge super fast minor that actually puts a big bunch of transactions. And all I need to do is to look at the proof. And if I see that the proof is actually correct and I can do it on even my phone, then I'm certain that the posttase is correct. Right? So it sort of looks as if, well, zero knowledge proofs, they actually solved a scalability problem, right? All we need to do is to include zero knowledge proof and we can make blocks as big as we want. And the scalability issue is gone.
00:21:20.502 - 00:21:55.326, Speaker B: Well, there's just one more problem unfortunately. And that is that even though I know that the post state is correct, all I can see on the blockchain is the state commitment. I still don't know what is the actual state. It's just a commitment. Right. So I'm back to the question of finding out what is actually a state, what is Bob's balance, if that's what I'm interested in. And well, I can ask the minor miner can actually give me a state and what they can give me is so called inclusion proof.
00:21:55.326 - 00:22:42.420, Speaker B: And I can check if indeed that state is part of that commitment. I can verify independently that miner is not lying. So I don't need to trust minor. However, even though I don't need to trust minor, I need to get this answer from minor and that inclusion proof. If the miner, for whatever reason refuses to give me this answer, like for example, I mean they're happy to give me the answer for Bob, but for whatever reason they don't want to give me the answer for Alice, well then I do have a problem because I just don't know. Right. And we will maybe talk about this a little bit later.
00:22:42.420 - 00:23:30.130, Speaker B: But again, this is actually something that is a known problem in all scalability solutions. If I don't get the answer from the miner, I need to recompute the state myself. And if that state is huge, then I will need a lot of computing power to actually do so. It's not impossible to do, but I'm kind of back to the scalability problem one way or the other. All right, so that was sort of the foundational background. So let's have a look at the actual roll ups. What is a roll up? Because everything that I said up to that point is kind of independent from the actual l two.
00:23:30.130 - 00:24:19.678, Speaker B: What is l two and how does that relate to L one? Well, it's actually super simple when you think about it. It's a way to sort of pack one blockchain inside of another by simply putting a block of what we call an l two, like layer two blockchains as one transaction inside of l one blockchain. Right. So again on the left you have your l one blockchain, like Ethereum, and you've got all transactions that you put inside the block. And we can imagine that there is one transaction that contains a state commitment from another blockchain from another block. Right. So it's almost like a recursive structure.
00:24:19.678 - 00:25:27.094, Speaker B: So inside this one state commitment, we can pack the whole block with its own post state as just one transaction. So you can clearly see that by doing this, we can pack a lot of transactions inside the l one block and we can do it recursively. You can imagine having l three blockchain, l four blockchains, and so on, and you'll end up with literally unlimited scalability if you actually chose to do so. And again, two different options. Optimistic roll up minor. We call it a roll up. This second layer solution and zero knowledge minor, that will not only they will need to provide the post state, but they will also need to provide the zero knowledge proof so that anybody who's actually observing L one and l two, they are certain that this post state is correct.
00:25:27.094 - 00:26:30.140, Speaker B: With the optimistic roll up, again we are back to this verification game. We need to sort of look at all these transactions from L two and we need to independently verify the post state. And again, all it needs for this construction to work is the one owners validator assumption. Now why this is called a roll up? It's called a roll up because not only state is posted to L one, but also all these transactions are packed and they are kind of included not as a state of l one, but they are, let's say transferred to l two when this transaction is included. Right. So we can reconstruct the state of l two just by looking at the L one. And that's why it's called a roll up, because the state and all the transactions of l two are sort of packed inside this big package and it's actually included inside L one.
00:26:30.140 - 00:26:57.010, Speaker B: So let's just look at the details again. We've got the zk minor, they provide the ZK proof. And. Well, with. And we are certain that this new block on L two is correct because there's a proof. Right. I mean, they cannot cheat.
00:26:57.010 - 00:27:38.418, Speaker B: Well, with the optimistic miner, it's a little bit different situation. And they can cheat. We need to trust them. So it is possible, in theory at least, that one honest validator, they actually find that this state commitment is actually wrong. So they need to raise an alarm. Right. And the way it actually works is that if anyone verifies the block and they find that the state commitment is wrong, they can submit what's called a fraud proof to l one to a smart contract on L one.
00:27:38.418 - 00:28:40.978, Speaker B: And once the fraud proof is verified, this new state will be rejected by L one. Right. And of course there must be some sort of a crypto economic mechanism to punish the miner. But this is sort of aside. At the bottom of the whole construction is the ability for anyone to verify the state commitment and to be able to submit a fraud proof. And because it takes some time and because people, these nodes may be offline, well, every single roll up construction, optimistic roll up construction, they actually include what we call a fraud proof window, which is literally the time that the honest value data have to submit the fraud proof. And typically it's about a week or maybe even two weeks, depending on the actual roll up.
00:28:40.978 - 00:29:31.330, Speaker B: And after that time, it's just simply assumed that the state is correct. Right. And again, if we're interested in actual state, like the question, what is Bob Samka balance on l two, we run into the same problem. We will literally either run full node or trust somebody who does run the full node. So this problem of actually computing the state is very same as on l one. We either trust somebody who does that or we are able to compute the state ourselves. So this whole construction sort of brings us to what is probably the most contentious issue when we compare optimistic roll ups and Zika roll ups.
00:29:31.330 - 00:30:10.034, Speaker B: And that is the withdrawal problem, so called withdrawal problem. So imagine now that l two blockchain is like a casino. You enter a casino, you buy casino chips and you play all sorts of games inside the casinos. And these are all the transactions that are happening on the l two blockchains. And then after a while you actually want to go back. So you probably want to exchange your chips back to cash, right. Typically when you exit the casino, I mean, there are places to do that, right? So the happy path is kind of simple.
00:30:10.034 - 00:30:57.738, Speaker B: The users, they are asking the l two minor whether they can withdraw tokens from L two. And the happy path is that the miner verifies this transaction. And with the optimistic roll up, because the miner can cheat, we actually have to wait through this fraud proof window. And this is probably one of the biggest drawbacks of the optimistic roll up construction. We have to make sure that the minus state that's committed on L one, this is actually correct. So the minus not cheating for Ezekiel roll ups, this is not the problem because miners cannot cheat. But that's only when miners actually respond.
00:30:57.738 - 00:31:38.010, Speaker B: Right. What happens when the miner is down? And this is a bad scenario, right, because this is literally imagine yourself trying to get out of the casino, trying to exchange your chips, but there is nobody there, right? It's just closed. So all you have is your chips, but you want real cash, right? And you wait and you wait. And then suddenly you learn that maybe the casino is bankrupt and they just simply don't have any cash, right. And you're left with those plastic chips, which is probably not what you wanted when you were playing the games in casino. So this is a SaaS scenario. The down operator, the new blocks are not produced.
00:31:38.010 - 00:32:20.810, Speaker B: And we need to actually make sure that there's some sort of a way for end users to withdraw these MKs or these tokens from l two, even though the l two minor is down. Right. So this is normally possible for annual up construction, or at least it should be possible for analog construction. But it needs to be kind of remembered that for this to actually be possible, you need to be able to produce a state. So you need to make sure that you can actually compute state and validate the state. Right. So again, we're back to this state validation issue that I talked about earlier.
00:32:20.810 - 00:33:21.514, Speaker B: And I guess probably the most tricky scenario is when the miner is actually censoring particular users. So maybe when Alice wants to withdraw tokens, the miners will respond. But when Bob wants to withdraw tokens, the miners sort of pretend that they haven't heard Bob's request. So this is hard because it's impossible to prove whether indeed the miner is censoring or whether Bob is cheating and he's actually telling everybody that he's being censored, but in Bob, they never sent the withdrawal request. Right. So this is a known problem in computer science, and this is a very tricky and interesting issue. And again, there must be sort of some kind of anti censoring protection for end users.
00:33:21.514 - 00:34:37.030, Speaker B: And if indeed Bob feels like they are censored, there must be a way for them to circumvent the minor. So I would normally expect from any relapse solution to actually provide end users with a solution to this problem. All right, so the takeaways, let's compare these two setup the optimistic roll ups and secure roll ups. Well, because there's assumption for optimistic roll ups that everybody should be able to validate the optimistic roll up, and there should be this one honest validator. A lot of people are regarding optimistic roll ups as what we call a sharding solution, and they won't scale as much, especially if everybody jumps on the same roll up or on the same shard, because the validation of this optimistic roll up will be kind of constrained by the same problems as validating Ethereum blockchains. Right? So we'll literally move all the traffic from all l one to one roll up on L two. That's not going to solve a lot.
00:34:37.030 - 00:35:25.890, Speaker B: On the other hand, zk roll ups are true scaling solutions and external validators are typically not required. And I say typically because in a happy scenario, that's indeed true. There must be some solution to not that happy scenario when all the nodes on the zika roll up chain are down for whatever reason. Right? Then optimistic roll ups are actually easier. They don't rely on any sophisticated math and sophisticated cryptographic assumptions. They are probably much easier to verify and reason about. But they do rely on certain crypto economic assumptions.
00:35:25.890 - 00:36:14.360, Speaker B: Right. We do need to have at least one honest validator, and we need to have some sort of incentives or incentive structure to make sure that miners do not cheat similarly to bitcoin or ethereum. I mean, miners are actually incentivized not to cheat. On the other hand, ziki rollups, they do rely on cryptographic assumptions. It's much more difficult to prove. The correctness and support for general smart contracts is also much harder. And this is why it is likely that we will see generalized optimistic rollups a little bit sooner, and they will probably provide short to medium term term relief to the current ethereum congestion problem.
00:36:14.360 - 00:37:25.950, Speaker B: On the other hand, I believe that Zikarolabs eventually will provide us with solution to build generalized smart contracts. And once everybody will be certain that this is correct, and the crypto behind them is sound. They will very likely provide the final solution to scalability. Right, and the withdrawal time again, one week or two week withdrawal time from optimistic roll ups, that can be super problematic for a lot of use cases. However, I think it's worth to understand that there's already some interesting designs in the works that will solve the problem for many use cases. So Makerdao, for example, is working on one such design for withdrawal of dai tokens, the stablecoin that anybody can mint using makerdao system. On the other hand, Zikarolabs, they don't suffer from this problem.
00:37:25.950 - 00:38:18.800, Speaker B: However, when provers and miners on Zikarolabs, they go dark then can be very problematic as well for the end users. Very unlikely scenario. But again, I think we should really, especially in blockchains, which are adversarial environments, we should always sort of focus on the worst case scenario and ask hard questions. And yeah, this pretty much sums up the foundations. So I think we've got like maybe ten minutes for questions and. Yeah, so let's go to Q and A.
00:38:36.630 - 00:38:59.206, Speaker A: Hey, welcome back. Let's wait. It's probably going to take a few minutes to take questions. I propose to take not too many questions yet. Let's do maybe two or three questions now and then let's do a longer Q A after Alex's presentation. Yeah. So, Baptek, thank you very much for your presentation.
00:38:59.206 - 00:39:43.270, Speaker A: In the meantime, it's super happy to have you here. And yeah, I hope we finally get a little bit cloudy, foggy terrain of layer two solutions gets a little bit more understandable if it's not yet fully understandable. Don't worry, take your time. It is a lot of information. It feels very natural for me right now, but I remember back in the days, it was all very confusing with zero knowledge, with optimism and all that stuff, with rollouts and so on. And here we have a first question, how the validator detects a badly working miner.
00:39:44.670 - 00:40:39.240, Speaker B: Anybody should be able to validate a block by simply taking all the transactions, taking the pre state and looking at the post state and seeing if it matches with what was actually advertised by the miner. Right? So this is literally like how ethereum and bitcoin work on the base layer and this is how you should be able to do it on an l two layer as well. Right. It's the same technique. I take a prestate, I execute all the transaction, all the transactions in a sequence, and I should be able to compute what we call a post state. So no difference really on the roll up or l two from basic l one.
00:40:40.190 - 00:40:44.682, Speaker A: I think the difference is what do you do once you detect it? And on the main app?
00:40:44.736 - 00:41:35.050, Speaker B: Yes, what do you do? Yeah, what do you do on the main net? That's a very good question. What do you do if it detects the invalid block on the main net? Right? I mean, normally people don't think about it because they kind of assume that all the blocks are correct, but what are they not? What do you do? Like I said in my presentation, normally you should be able to raise an alarm and you should be able to reject such a block and not propagate it further in a gossip network. For the optimistic roll up, what do you do when you actually detect a bad block? Like I said before, you submit a fraud proof, and this fraud proof is actually submitted to a smart contract on L one, and the smart contract will verify the fraud proof and it will reject the block.
00:41:37.410 - 00:41:55.380, Speaker A: Awesome. I think we have at least one more question. Let's see. We can get it. Let me read the question and I'll let you answer. What are the timeframes of these solutions? Anything will be deployed this year. Good news coming.
00:41:56.950 - 00:42:47.314, Speaker B: Yeah, so a lot of solutions are already out there for Zikarolaps versus loop ring diversify, immutable for NFTs. They are, from what I'm hearing, quite close to be ready. But these are all. And of course ZK sync and Alex will tell you much more about ZK sync. So all these solutions for Zika rollups are already out there. However, to the best of my knowledge, they're not general computation solutions, but specific solutions for specific transaction types. In the optimistic space, again, versus arbitram, versus optimism, and probably a few others.
00:42:47.314 - 00:42:59.800, Speaker B: And optimistic roll up from Optimus, for example, is announced to be launched quite soon, I believe, in March. So it's coming. It's actually very soon.
00:43:00.410 - 00:43:16.940, Speaker A: Really feels like just around the block. So we have a lot of more questions. So let's pick one. Then we have an Alex talk and then we go to questions. Would you be available to questions after talk?
00:43:17.390 - 00:43:20.400, Speaker B: Yeah, sure. Yeah, I'll be hanging around for sure.
00:43:20.930 - 00:43:32.260, Speaker A: Awesome. So the last question before the next presentation, what is the incentive to prove the fraud when you're not a direct participant of a roll up?
00:43:33.350 - 00:45:06.446, Speaker B: I believe it's the same incentive as for anyone to run a full node on the blockchain. Like what is the incentive for anyone to run a full node? So think about an exchange that swaps tokens from one blockchain to another, or swaps tokens from a blockchain to fiat. This is what exchanges do. And given the huge amounts at stake, if you like, they probably shouldn't trust any miners, right? Because if the miners collude, they could double spend the tokens and the exchange will take huge loss. So every single centralized exchange that I know, they all run full nodes, right? They all are independently verifying blockchains. And what is the incentive here? It will be very similar, for whatever reason. If you are interested in making sure that as soon as the new block on l two is published on L one, if you want to make sure that this block is correct and the state commitment is correct, you probably should run a full node on l two, whatever your reasoning is behind it, right? So one interesting use case is somebody trying to make fast withdrawals possible, right? They can look at the l two state.
00:45:06.446 - 00:45:42.314, Speaker B: They can verify that state. And if they are certain that the state is correct, they don't have to wait through this one week or two week window. Because they are certain now that there will be no fraud proof, right? Because the state is correct. The fraud proof is only possible if the state is wrong. But if I'm sure that the state is correct, that I can be certain that the state is correct, right? Marek can ask me if I'm running a full node, I can tell. Marek? Well, look, Marek, I mean, trust me, the state is correct. But then of know Marek needs to trust me.
00:45:42.314 - 00:45:55.680, Speaker B: So maybe he doesn't trust me. So maybe he can run the full node himself, right? And just verify himself. So I guess the incentive is for anyone that does not want to wait two weeks.
00:45:58.450 - 00:46:11.980, Speaker A: It's a good one. Okay. I didn't thought about this last part with waiting. That's a nice detail. I was not realizing about optimistic roll up. If you run a full node, you don't need to wait. It.
