00:00:08.740 - 00:00:33.132, Speaker A: Hey guys, we're back. I just received a message from YouTube that they did remove our YouTube channel. So we're currently looking for a new hosting and we're going to give you some updates on our discord and Twitter once we set that up. But right now I'm with Harry Papacharicio, developer advocate for Chainlink Labs. Hey, Hari.
00:00:33.196 - 00:00:35.090, Speaker B: Hi, Antek. How's it going?
00:00:35.620 - 00:00:37.170, Speaker A: I'm good, how are you?
00:00:37.620 - 00:00:39.344, Speaker B: Very good, thank you. Very good.
00:00:39.382 - 00:00:39.970, Speaker C: Awesome.
00:00:40.980 - 00:00:50.100, Speaker A: So Hari will give you an intro to Chainlink and yeah, the stage is awesome.
00:00:50.250 - 00:00:50.660, Speaker D: Thanks.
00:00:50.730 - 00:01:14.670, Speaker B: Thanks, Antek. So yeah, very excited to be part of the Zero x hackathon. Really can't wait to see what everyone builds. My name is Harry Papa Carissio and I'm a developer advocate for Chainlink Labs. And today we're going to be talking about Oracle's decentralized data and external computation. So I'm just going to share my screen if you just bear with me.
00:01:26.890 - 00:01:27.686, Speaker D: Okay.
00:01:27.868 - 00:01:55.658, Speaker B: Hopefully you guys can see that. So basically today, blockchain and smart contract adoption and innovation has really skyrocketed the past year. And we're seeing some really great things being built by all these people and we're seeing so many amazing opportunities ahead of us as we continue to push for this technology to kind of take us into a new age of what we like to say, economic fairness, transparency and efficiency.
00:01:55.754 - 00:01:56.398, Speaker C: Right?
00:01:56.564 - 00:02:30.822, Speaker B: And these hackathons are really the front lines of the battle for this, basically where the real innovation happens and where some of these great projects are being born. So with that being said, let's jump in. So today we're going to talk about smart contracts. We'll just give a brief recap of what smart contracts are. We'll talk about the Oracle problem. Then we'll talk about Chainlink price, feed and also defi. We'll talk about Chainlink VRF, and then we'll go through some use cases for your hackathon submissions.
00:02:30.822 - 00:03:12.402, Speaker B: And then we'll talk about where you can go as a developer to learn about Chainlink. And then we'll go through a couple example projects as well. So first of all, smart contracts, right? So what is a smart contract? A smart contract is essentially a highly secure, tamper proof digital agreement that runs on decentralized infrastructure, such as a blockchain, right? So compared to a traditional digital agreement, in a traditional digital agreement, one of the parties in the digital agreement is also the party that actually executes and enforces the digital agreement.
00:03:12.466 - 00:03:12.934, Speaker C: Right?
00:03:13.052 - 00:03:29.322, Speaker B: So it's almost a conflict of interest because you've got one of these parties that's kind of incentivized to act in bad faith, executing and enforcing the agreement, and then you've got these other one or more parties in the agreement as well that kind of have to trust that the other guy is going to act in good faith.
00:03:29.386 - 00:03:29.854, Speaker C: Right?
00:03:29.972 - 00:04:02.886, Speaker B: So that's kind of one of the main differences between the two. So a smart contract runs on this decentralized infrastructure, such as a blockchain, that's separate to the parties that are within these digital agreements, right? And in terms of transparency, in a traditional digital agreement, the party that's executing and enforcing the contract can choose how transparent or they wish to be. Basically, they can be very transparent or not transparent at all. And sometimes this can create issues such.
00:04:02.908 - 00:04:04.280, Speaker D: As we've seen in the past.
00:04:05.850 - 00:04:53.026, Speaker B: So you might say, well, okay, so why smart contracts better than these traditional digital agreements, then? And it basically boils down to five things, and the first thing is security, or what I like to call tamper proofness, right? So because these smart contracts are running on this highly secure, decentralized infrastructure, they can't be hacked, they can't be gained. No one can influence the execution of the agreement because it's running on this decentralized infrastructure, right? Whether it's dozens or hundreds or thousands of nodes, one party in a digital agreement can't say, I'm going to change the outcome of this contract. They can't do it, right. It's highly secure. Two, reliable, guaranteed execution.
00:04:53.138 - 00:04:53.654, Speaker C: Right.
00:04:53.772 - 00:05:00.310, Speaker B: Because once again, these smart contracts are running on this decentralized blockchain infrastructure. You've got guaranteed execution.
00:05:00.390 - 00:05:00.634, Speaker C: Right?
00:05:00.672 - 00:05:11.494, Speaker B: The smart contract is executed on all of the nodes, and they're all in perfect sync with each other, and they're guaranteed they're going to execute the agreement as per the way it was written.
00:05:11.542 - 00:05:11.850, Speaker C: Right?
00:05:11.920 - 00:05:55.546, Speaker B: There's no, oh, this web server was down or this payment system was down. We couldn't actually pay you out your insurance agreement for some reason. There's none of that. The blockchain 24 7365, it's constantly running, processing transactions and executing agreements, right? So you've got guaranteed execution. Three, transparency, right? So in traditional digital agreements, like I said, the party executing and enforcing the agreement can choose how transparent they want to be, and sometimes they're not very transparent at all. But in a smart contract scenario, transparency of the agreement is actually unavoidably built in to the contract and the infrastructure itself.
00:05:55.648 - 00:05:56.106, Speaker C: Right?
00:05:56.208 - 00:06:19.502, Speaker B: So there's much higher level of transparency between parties within a digital agreement. Four, trust minimization. So we've got reduced counterparty risk because all the parties that kind of take part in a digital agreement, like I said, they don't have control over the execution of the agreement, so they don't necessarily need to trust each other anymore.
00:06:19.566 - 00:06:19.794, Speaker C: Right.
00:06:19.832 - 00:06:32.070, Speaker B: Because they're trusting in the smart contract's ability to execute and do what it's going to do, which it always will, because nothing short of maths or physics not working like it does today is going to stop that from happening.
00:06:32.140 - 00:06:33.350, Speaker D: In this scenario.
00:06:34.830 - 00:07:01.554, Speaker B: Five, efficiency. So all of these traits that I've talked about already, security, guaranteed execution, transparency, trust minimization, they lead to basically provide an opportunity where we can kind of migrate some of these existing manual and cumbersome processes to more automated, highly efficient ones that basically smart contracts can help facilitate. And this leads to better efficiency and.
00:07:01.592 - 00:07:04.050, Speaker D: Reduced costs as well, in many cases.
00:07:05.590 - 00:07:51.722, Speaker B: So, just to reiterate, in a traditional digital agreement example, it's always going to favor the side of whoever is executing and enforcing the agreement. So in the case of such as a crop insurance agreement between a farmer and an insurer, the insurer will say, you pay me $1,000 a month and I'll insure your farm. And if you have drought conditions, you'll get paid. And the farmer says, okay, and they pay the $1,000 every month. Then there's some big drought and a whole bunch of farmers put in the claim, and the insurer says, well, actually, I should pay you out, but I'm not going to because we have to pay all these people out, and we've got these vague terms and conditions in kind of legal jargon in our agreements.
00:07:51.786 - 00:07:53.298, Speaker D: And I can actually get out of it.
00:07:53.384 - 00:08:21.222, Speaker B: And then the farmer has to take them to court if they want to basically get paid. So they're trusting in the brand. In a traditional digital agreement, you're trusting in what's called paper guarantees. You're saying, trust my insurance company, trust my bank, trust my whatever. It's just a brand based guarantee where you've got high counterparty risk and usually you've got low transparency.
00:08:21.366 - 00:08:21.962, Speaker C: Right?
00:08:22.096 - 00:08:34.142, Speaker B: Whereas with a smart contract scenario, we move to what's called a math based guarantee, where we've got low counterparty risk and transparency is unavoidably built in.
00:08:34.196 - 00:08:34.366, Speaker C: Right?
00:08:34.388 - 00:08:53.394, Speaker B: So that's kind of the monumental shift from these brand based digital agreements to math based digital agreements, right, where you know that they're going to execute, you know that the other entity or entities within the agreements don't have control and they can't do the scenario that I just described where they're like, oh, actually.
00:08:53.432 - 00:08:54.374, Speaker D: I don't want to pay you out.
00:08:54.412 - 00:10:04.730, Speaker B: Like, it's not possible. So now that we know why smart contracts are so awesome compared to these traditional digital agreements, let's talk about their biggest limitation. Now, smart contracts are not able to connect to external data or any off chain resource on their own. So you might ask, well, why can't a smart contract just make an API call to a web API or somewhere? And the simple answer is that the blockchain is deterministic and everything needs to be able to be validated by all the nodes on the chain, right? So if making an API call is part of that validation, then nodes can get out of sync and maybe the API gets hacked or something and you kind of lose your determinism. Each node needs to get the same result back so that they can continue executing a smart contract in perfect sync with each other. Otherwise you don't have determinism. So this is defined as the smart contract connectivity problem, right? Not being able to connect to external data systems and events.
00:10:04.730 - 00:10:18.650, Speaker B: And this actually limits the use cases for smart contracts purely to things that can only be done on chain, such as moving tokens around or doing payments in the native asset of the blockchain.
00:10:18.810 - 00:10:20.770, Speaker D: Based on smart contract logic, right?
00:10:20.840 - 00:11:17.150, Speaker B: Which is great, but actually the majority of digital agreements need some kind of external data or input or external trigger, basically. So the next question you might ask is, well, how do we solve this problem? So to interact with the outside world, we need what's called an oracle, right? And an oracle is any device that interacts with the off chain world to provide data or connectivity to smart contracts, right? So they report the result of that data or off chain computation on chain so that the blockchain can stay deterministic. So just to give an example, a smart contract might say, I need to get the price of oil. And an oracle will say, okay, I'll get you the price of oil. And then it returns the result. And that result is then the input back to the smart contract, which goes to all the nodes in the blockchain. And all the nodes go, yep, this is the input.
00:11:17.150 - 00:11:19.586, Speaker B: Now let's all continue. And they're in perfect sync with each.
00:11:19.608 - 00:11:21.890, Speaker D: Other and we kind of keep that determinism.
00:11:26.010 - 00:12:15.538, Speaker B: Now here's where things get really interesting, right? Using a single centralized oracle actually creates a single point of failure for smart contracts and compromises the overall security of the digital agreement in this scenario, right? Because if you've got this highly secure, decentralized blockchain running on this highly decentralized infrastructure, but then you're triggering your smart contract from this single oracle, then your end to end security is only as good as the weakest part of that system, and in this case it's your oracle, right? So all of those traits that I talked about before, such as trust minimization, tamper proofness, et cetera, it all goes out the window once in this scenario because you've got a single oracle triggering.
00:12:15.554 - 00:12:17.080, Speaker D: Your smart contract, right?
00:12:20.250 - 00:12:45.162, Speaker B: So we've gone from, we've got this awesome, highly secure system that no one can hack and it's awesome, but we can't do much with it because it's limited to on chain functions to, we've got this awesome, highly secure system that can do all these cool things now because we can connect it to external data and inputs and computation, but it's actually not that secure because we're triggering it in an insecure way by using a single Oracle.
00:12:45.226 - 00:12:45.694, Speaker C: Right?
00:12:45.812 - 00:12:50.242, Speaker B: So the next question one might ask know, how do we solve this problem?
00:12:50.296 - 00:12:50.900, Speaker D: Now.
00:12:53.350 - 00:13:32.302, Speaker B: The answer to all of this is a decentralized oracle network, right? So Chainlink is designed to be a modular, decentralized oracle network for getting secureable and reliable data on chain and for triggering external computation. So we want to bring the data or trigger external computation in a decentralized way, right? And by doing this, we solve this oracle problem by extending the decentralization and trust minimization that we have in the smart contract layer. We take it and we extend it out to the data delivery and data.
00:13:32.356 - 00:13:33.998, Speaker D: Source layer as well, right?
00:13:34.084 - 00:13:37.018, Speaker B: So we've got a better overall decentralization.
00:13:37.114 - 00:13:38.480, Speaker D: Across the whole system.
00:13:38.850 - 00:13:54.594, Speaker B: And you can do this with as many nodes or oracles or as few as you want. It's entirely flexible. Now this flexibility and heterogeneous design is one of Chainlink's strongest features, right?
00:13:54.712 - 00:13:56.190, Speaker D: Being able to take any input from.
00:13:56.200 - 00:15:16.014, Speaker B: The real world, add it on chain as well as any output from the blockchain and sending it back to the real world. But to do it in a decentralized way, right? And this end to end connectivity, reliability and security is actually the real value proposition of smart contracts, right? Being able to perform digital agreements that we do today, but to do them in a better, more secure, more tamper proof, automated and highly efficient way. So to try wrap your head around this visually, here's a simple example of how a chainlink decentralized oracle network can provide price data to a smart contract in a secure, tamper proof and decentralized manner. So as you can see here we've got a number of chainlink oracles here fetching price data from various price points, and they're aggregating the data and coming to a consensus on a final result there. And then that result is fed on chain. And just to reiterate, none of the nodes in this example here, and none of the data providers either, that none of them can influence the final result that's fed on chain because we're kind of doing it in a decentralized way.
00:15:16.052 - 00:15:17.022, Speaker D: Here, as you can see.
00:15:17.076 - 00:15:33.202, Speaker B: So that final figure cannot be influenced by a single entity in this kind of data delivery or data source layer here. Now, DeFi is currently one of the biggest and most popular use cases for.
00:15:33.256 - 00:15:36.514, Speaker D: Using a decentralized Oracle network such as Chainlink.
00:15:36.642 - 00:15:36.982, Speaker C: Right?
00:15:37.036 - 00:15:49.626, Speaker B: So if you're thinking of doing something in the DeFi space to get you started, we've gone ahead and found some of the best blockchain node operators in the business and we've combined their skills and experience to build what we call.
00:15:49.728 - 00:15:51.962, Speaker D: On chain reference contracts, right?
00:15:52.096 - 00:16:38.326, Speaker B: So these are decentralized on chain reference points that these operator node operators kind of contribute to with the goal of providing these single aggregated final price results that take metrics into account, such as volume and things like that. And these reference contracts can be considered the source of truth for various currency pairs, like the price of ETH in USD, for example. So we've got an example here where we've got dozens of exchanges, few data providers there, a number of chainlink nodes, which is sourcing price data from the data providers and the exchanges. And then they're kind of coming to a consensus on an aggregated result, and then that's fed into the reference contract.
00:16:38.438 - 00:16:40.506, Speaker D: And that reference contract says, yes, this.
00:16:40.528 - 00:17:02.674, Speaker B: Is the price of ETH USD at this very moment across the whole market. And then the on chain user contracts can then access the reference contracts and use that price data at will. Now you may ask, why is having such a highly secure and tamper proof data delivery layer so important?
00:17:02.792 - 00:17:03.314, Speaker C: Right?
00:17:03.432 - 00:17:47.658, Speaker B: And great question. One of the answers basically is defi attacks, right? So we've already seen attacks that have kind of lost projects, literally millions of dollars due to using centralized oracles or not having sufficient market coverage in their oracles, and people end up losing money. So as a community, we really need to make a conscious effort to try and avoid this from happening in the future, because in the end, people lose money when this happens, right? And if crypto has taught us anything, it's that if you've got a protocol that's open to being exploited and someone can profit from exploiting it, then the protocol is going to be exploited eventually.
00:17:47.754 - 00:17:48.400, Speaker C: Right.
00:17:51.970 - 00:18:42.146, Speaker B: Now, the best place to go to kind of check out the price feeds or data feeds is to go to data chain link. So as you can see here, we've got a whole bunch of currency pairs here. I'll open up the ETH USD one, and you can kind of see each node in the network independently gets data from some of the highest quality data APIs and reports the answer on chain. And you can see that the answers are all there. Everything's transparent as well. And most of the most popular crypto or fiat currency pairs are supported, and we're constantly adding new ones as well. Right, and the best part about it is if you don't want to use these reference contracts, if you want to use your own nodes, your own data providers, et cetera, you can create your own Oracle network as well.
00:18:42.146 - 00:18:58.022, Speaker B: It's completely flexible. So going back to Defi, like I said before, it's one of the most popular use cases of blockchain technology at the moment, and it's always innovating and it's got a ton of momentum and.
00:18:58.076 - 00:18:59.958, Speaker D: Knowledgeable people working in the field.
00:19:00.044 - 00:19:12.346, Speaker B: Right, and Chainlink currently supports some of the top projects in DFI already. And I think at the moment, when I checked this morning, there was something like $75 billion in assets locked up.
00:19:12.368 - 00:19:16.726, Speaker D: In decentralized finance right now, which is absolutely mind blowing.
00:19:16.758 - 00:19:17.146, Speaker C: Right.
00:19:17.248 - 00:19:20.734, Speaker B: And I think as time goes on, DFI is going to continue to get.
00:19:20.772 - 00:19:22.480, Speaker D: More and more popular as well.
00:19:25.010 - 00:19:46.338, Speaker B: So here's just a couple of examples of some top D five projects currently using chain link price feeds. So we've got Ave, which does lending and borrowing with casual $11 billion locked up there. Synthetics, couple of billion. They do synthetic assets. And then we've got sushi swap and Bancorp, which are dexes, and they've kind.
00:19:46.344 - 00:19:47.846, Speaker D: Of got quite a bit locked up as well.
00:19:47.868 - 00:19:51.702, Speaker B: So I think just between the four of those, it's something like $20 billion.
00:19:51.756 - 00:19:53.238, Speaker D: In TBO locked up.
00:19:53.324 - 00:19:53.622, Speaker C: Right?
00:19:53.676 - 00:20:00.442, Speaker B: So that's $20 billion of crypto locked up in these protocols and secured by.
00:20:00.576 - 00:20:15.280, Speaker D: Chainlink price feeds so that users can access Defi and use Defi on those platforms. So it just goes to show how widely accepted and used these price feeds are in Defi today.
00:20:16.770 - 00:20:18.926, Speaker B: So we'll go through an example in.
00:20:18.948 - 00:20:19.710, Speaker D: A couple of minutes.
00:20:19.780 - 00:20:34.514, Speaker B: But if you head over to the docs, chain link site, which is our docs, you'll get to see how to implement how to use these price feeds in your hackathon submission. And it's really easy, guys. It's literally a few lines of code. If you want to use these reference.
00:20:34.562 - 00:20:37.640, Speaker D: Contracts, we'll show you in a couple of minutes.
00:20:39.770 - 00:20:45.322, Speaker B: But Chainlink is more than just price feeds, right? So Chainlink provides the ability to do.
00:20:45.376 - 00:20:47.498, Speaker D: Off chain computation as well.
00:20:47.664 - 00:20:52.710, Speaker B: Now, one of the more pressing needs for off chain computation was to implement.
00:20:52.790 - 00:20:55.850, Speaker D: A verifiably random number generator, right?
00:20:55.920 - 00:21:04.926, Speaker B: So random numbers have actually been used for thousands of years. Whether it's flipping a coin or rolling a dice, the goal is always to.
00:21:04.948 - 00:21:07.838, Speaker D: Leave the end result up to random chance, right?
00:21:08.004 - 00:21:33.042, Speaker B: And random number generators in a computer are similar, right? They're an attempt to achieve an unpredictable random result. But until now, getting random numbers on chain has been an issue, right, because the previous conventional way was to rely on on chain things such as an on chain hash or using a centralized.
00:21:33.106 - 00:21:37.430, Speaker D: API that can kind of be hacked or something like that. Like I explained earlier.
00:21:37.590 - 00:21:49.102, Speaker B: And we see exploits happen in this as well, right? I think literally last week there was a random number generator NFT exploit where.
00:21:49.236 - 00:21:56.960, Speaker D: Someone was able to mint an ultra rare NFT, right? Because the source of the randomness was being done on chain in a predictable way.
00:21:58.850 - 00:22:16.726, Speaker B: So chainlink VRF brings a solution to generate provably random numbers. This means that the on chain contracts that request a random number can actually verify that the random number was actually generated in a verifiable way using the.
00:22:16.748 - 00:22:18.454, Speaker D: Seed that was given, right?
00:22:18.572 - 00:22:37.834, Speaker B: So the seed is basically a source of input for a pseudo random number generator. So in this example flow here you might have a smart contract that says, hey, I need some randomness and a chain link oracle goes, okay, I'll get you a random number. The chain link Oracle sends the result back.
00:22:37.952 - 00:22:41.806, Speaker D: And when it goes back to the smart contract, the smart contract knows that.
00:22:41.828 - 00:22:49.918, Speaker B: It was verifiably random, created with the seed that the smart contract gave, and that it was created by that exact.
00:22:50.084 - 00:22:52.080, Speaker D: Chain link Oracle, right?
00:22:52.530 - 00:23:10.114, Speaker B: And not some hacker or other system or anything. Now, there's a number of interesting use cases already using this in production today. One popular use case that I like is minting NFTs with provably random traits.
00:23:10.242 - 00:23:11.800, Speaker D: I think that's pretty cool.
00:23:12.970 - 00:23:36.250, Speaker B: And as the NFT space grows bigger and bigger, I expect to see a big uptake in VRF, especially for things like random allocation of packs or sets, because anything that deals with collectibles, whether it's baseball card packs or digital NFT drops or anything like that they all deal with some kind of random allocation.
00:23:36.330 - 00:23:41.220, Speaker D: For these collectibles, right? Users want randomness when they get these things.
00:23:44.230 - 00:24:01.154, Speaker B: So just wanted to reiterate quickly that chainlink can be used to integrate to any API, right? Whether it's a web API, an enterprise backend database, an iot sensor, API enabled physical device such as a car, literally.
00:24:01.202 - 00:24:02.742, Speaker D: Anything, you name it, right?
00:24:02.876 - 00:24:21.774, Speaker B: And in addition to that it's blockchain agnostic. So we're live on Ethereum, polygon, binance, smart chain, XDI, and there's more to come as well. So if you want to access off.
00:24:21.812 - 00:24:31.666, Speaker D: Chain data or computation via non kind of traditional methods such as an iot sensor or a database or something, you.
00:24:31.688 - 00:24:34.174, Speaker B: Can use what we call external adapters.
00:24:34.222 - 00:24:38.290, Speaker D: And external initiators, right? So these allow you to connect to.
00:24:38.440 - 00:24:45.046, Speaker B: Basically any API, no matter how unusual it may be, and basically use that.
00:24:45.068 - 00:24:56.700, Speaker D: Source of data or computation in your smart contract, right? And we'll get to those in a little bit. So let's go through some use cases now.
00:24:57.470 - 00:25:32.322, Speaker B: So if you're looking for some cool ideas to implement for your hackathon submission, highly recommend you check out this awesome blog post done by our content team. It's called 77 smart contract use cases enabled by chainlink and you can find it on our blog at blog chain link. And there's some awesome ideas here for things to implement. If you're kind of stuck for ideas, and they span various categories such as DFI, gaming, nfts, insurance, supply chain, et cetera, there's plenty of stuff there. If you want some inspiration, I definitely.
00:25:32.376 - 00:25:36.902, Speaker D: Recommend checking that one out now.
00:25:36.956 - 00:25:39.654, Speaker B: Next, where as developer can you go to learn?
00:25:39.772 - 00:25:44.310, Speaker D: Where can you learn how to use Chainlink to come up with your awesome hackathon submission?
00:25:45.770 - 00:25:52.522, Speaker B: So the first place you should definitely go is to our docs. This is at Docs chain link. It really is the go to place.
00:25:52.576 - 00:25:54.726, Speaker D: For info on how to use Chainlink.
00:25:54.838 - 00:25:59.774, Speaker B: And we've got code examples, we've got setup help, we've got a really great.
00:25:59.812 - 00:26:11.486, Speaker D: Hackathon resources page as well I think here in the developer reference. There we go. So there's some cool links there that.
00:26:11.508 - 00:26:15.026, Speaker B: You should check out. So definitely have a look there.
00:26:15.128 - 00:26:17.090, Speaker D: We'll get back to the docs in a minute.
00:26:17.670 - 00:26:21.666, Speaker B: Next, highly recommend you check out our blog at blog chain link.
00:26:21.768 - 00:26:24.534, Speaker D: We've got a special developers tab with.
00:26:24.572 - 00:26:37.138, Speaker B: Some really great content specifically for developers, and it's all kind of geared towards specific use cases or specific tools or features. And the best thing about it is it's all kind of done in a.
00:26:37.164 - 00:26:39.590, Speaker D: Step by step follow the bouncing ball.
00:26:39.670 - 00:26:41.786, Speaker B: Kind of way where you can kind.
00:26:41.808 - 00:26:45.658, Speaker D: Of follow along really easily. So for example, how to get a.
00:26:45.664 - 00:26:52.686, Speaker B: Random number on Polygon. If you go in here, you can see it's got all the setup steps you need, it's got code, you can.
00:26:52.708 - 00:26:58.250, Speaker D: Kind of go through step by step deployment and you can kind of achieve what you're trying to achieve really easily.
00:26:58.330 - 00:27:01.154, Speaker B: So definitely recommend checking the blog out.
00:27:01.192 - 00:27:02.900, Speaker D: There's some cool stuff on there.
00:27:06.150 - 00:27:22.774, Speaker B: Chainlink, YouTube, definitely check this out as well. So we've got an official YouTube channel, we've got a whole bunch of playlists. We've got a specific engineering tutorial playlist too, which I highly recommend you check out if you search for Chainlink engineering tutorials. And there's a whole bunch of really.
00:27:22.812 - 00:27:26.394, Speaker D: Great stuff that can help you in your hackathon journey here as well, such.
00:27:26.432 - 00:27:31.994, Speaker B: As building and using an external adapter or dynamic NFT creation, right?
00:27:32.032 - 00:27:44.270, Speaker D: So there's plenty of stuff here, highly recommend you check it out as well. Now the solidity and smart contract starter kits, these things are awesome.
00:27:44.420 - 00:27:47.802, Speaker B: So if you go to our repository.
00:27:47.866 - 00:27:54.398, Speaker D: On GitHub, you'll see these three starter kits pinned to the top of the repository.
00:27:54.574 - 00:27:58.610, Speaker B: So what these are are basically working.
00:27:58.680 - 00:28:03.126, Speaker D: Repositories based on EVM development environments such.
00:28:03.148 - 00:28:12.646, Speaker B: As truffle, brownie or hard hat. And they all contain complete and working smart contract examples that basically allow you.
00:28:12.668 - 00:28:14.826, Speaker D: To use all the main chain link.
00:28:14.848 - 00:28:17.402, Speaker B: Tools and features such as VRF, any.
00:28:17.456 - 00:28:22.810, Speaker D: API or price feeds, right? And in addition to the contracts, there's.
00:28:23.390 - 00:28:32.718, Speaker B: Proper deployment scripts and proper tests and proper configs to kind of package everything together in a really cool and easy to use way.
00:28:32.804 - 00:28:34.062, Speaker D: So that when you want to start.
00:28:34.116 - 00:28:36.446, Speaker B: Building smart contracts that use Chainlink, you.
00:28:36.468 - 00:28:49.234, Speaker D: Can just kind of use the starter kits and you've got everything you need to kind of get going, right? And then you can just take the contracts, modify them, do whatever you want and it's all ready to go. And it's easy. So highly recommend you check those out.
00:28:49.432 - 00:29:07.226, Speaker B: If you're a JavaScript person, recommend checking out the truffle or the hard hat starter kit. If Python is more of your thing, then definitely check out the brownie one. It's really cool. If you're not sure, if you're not experienced with any of them, then I.
00:29:07.248 - 00:29:17.926, Speaker D: Probably recommend to start off with the hard hat starter kit and see how you go. So just wanted to also say Chainlink.
00:29:17.958 - 00:29:24.206, Speaker B: Is an open source project and we're constantly improving and we'd love to get your input or feedback on anything.
00:29:24.308 - 00:29:24.622, Speaker C: Right?
00:29:24.676 - 00:29:26.718, Speaker D: So the Chainlink community is one of.
00:29:26.724 - 00:29:31.934, Speaker B: The friendliest and most helpful communities out there. And just if you have any questions.
00:29:32.052 - 00:29:35.302, Speaker D: Jump into the Chainlink discord or the Xerox discord.
00:29:35.466 - 00:29:43.570, Speaker B: We've got a wealth of resources and we're happy to help. And if this is your first hackathon and you're just getting started, then.
00:29:43.720 - 00:29:45.622, Speaker D: Awesome, so glad you're here.
00:29:45.756 - 00:30:01.862, Speaker B: Hackathons are a great place to learn, great place to grow, great place to kind of get your name out there as well. So just contribute and definitely submit what you create, even if you think it's not polished. And we just want to see you basically contribute.
00:30:01.926 - 00:30:02.442, Speaker C: Right.
00:30:02.576 - 00:30:06.154, Speaker D: And if you're a veteran, then you.
00:30:06.192 - 00:30:07.162, Speaker B: Know what to do.
00:30:07.296 - 00:30:11.454, Speaker D: You've been here before and you know how much fun you're going to have, right?
00:30:11.572 - 00:30:16.698, Speaker B: So I think if we go to the bound here on our GitHub, we've.
00:30:16.714 - 00:30:20.370, Speaker D: Got five prizes of $1,000 in link.
00:30:20.440 - 00:30:23.678, Speaker B: Here and you can see there's some judging criteria.
00:30:23.854 - 00:30:29.700, Speaker D: So if you're not sure, you can kind of check out the prize information over here.
00:30:31.110 - 00:30:37.526, Speaker B: So I think now we'll go through a couple example demos to kind of.
00:30:37.548 - 00:30:41.590, Speaker D: Give you guys an idea of kind of how to use some of these chain link tools and features.
00:30:42.010 - 00:30:44.086, Speaker B: So what I'm going to do is.
00:30:44.188 - 00:30:46.326, Speaker D: I'm going to go to the docs.
00:30:46.518 - 00:30:57.446, Speaker B: Like I said, and if you're completely new to doing this, highly recommend you check out the tutorials here. We've got a beginner one, an intermediate.
00:30:57.478 - 00:30:59.854, Speaker D: One and an advanced one. So you can kind of go through.
00:30:59.892 - 00:31:04.686, Speaker B: Them in that order if you want. But to start off with, I think.
00:31:04.868 - 00:31:19.886, Speaker D: What we'll do is we'll start talking about price feeds, actually. So we've got a section on price feeds right here. As you can see there's some info.
00:31:20.078 - 00:31:25.666, Speaker B: And what we're going to do is we're going to go through an example of how to get the latest price.
00:31:25.768 - 00:31:31.558, Speaker D: From a reference contract and to kind of get it into your smart contract. So if you literally go to the.
00:31:31.564 - 00:31:33.778, Speaker B: Get the latest price section here we've.
00:31:33.794 - 00:31:36.506, Speaker D: Got a code example and there's a.
00:31:36.528 - 00:31:38.506, Speaker B: Deploy this contract using remix button that.
00:31:38.528 - 00:31:54.142, Speaker D: You can just press right and it opens up the remix ide. Might just make this a bit bigger. Hopefully you guys can see that. Okay, so let's go through the price consumer contract now.
00:31:54.196 - 00:32:07.810, Speaker B: So we're importing the aggregator V three interface library here and we're kind of creating this new price feed object based off of it. And when you create your smart contract.
00:32:08.150 - 00:32:17.846, Speaker D: All we're literally doing is we're instantiating this and we're passing in the reference contract address, right? So if you go back to the.
00:32:17.868 - 00:32:25.094, Speaker B: Docs over here, there's a contract addresses section that you can click on if you go there.
00:32:25.132 - 00:32:29.898, Speaker D: Depending on what chain you want to use price feeds on, you can kind of pick whichever one you want.
00:32:30.064 - 00:32:31.546, Speaker B: In our case, we're going to do.
00:32:31.568 - 00:32:37.930, Speaker D: It on Ethereum on the coven network. So let's say you want to access.
00:32:38.000 - 00:32:40.046, Speaker B: The ETH USD price feed, then you.
00:32:40.068 - 00:32:58.754, Speaker D: Just kind of copy this reference contract address and you kind of throw it into here, right? So we're saying we want to access the eqsd price feed reference contract. Once that's done, literally all you need to do is kind of call the latest round data function on your object.
00:32:58.872 - 00:33:00.018, Speaker B: It's that easy.
00:33:00.184 - 00:33:23.690, Speaker D: And in our case, we're just going to see what the current price of ETH USD is, right? So here's the main net version here. But what we're going to do is we're going to compile it, then we're going to deploy it to Covenant.
00:33:29.410 - 00:33:33.450, Speaker B: Just quickly. If you haven't got any test ETH.
00:33:33.530 - 00:33:40.206, Speaker D: Or link, which you'll need for doing this kind of thing. Well, not link, but you'll need ETH for the price feeds.
00:33:40.238 - 00:33:42.866, Speaker B: One, there's some good instructions in the.
00:33:42.968 - 00:34:18.218, Speaker D: Developer reference section here, so you can kind of check that out if you need. Yeah, quiet Testnet link and install configure and fund metamask. So you can check that out if you're not sure what to do. But once you get to a point where you have a deployed price feed contract here, you literally just need to call your get latest price function. And there you go, we've got the price of ETH and you can use it in your hackathon submission, use it in your defi application, whatever you want to use it for. So really easy to do, literally a.
00:34:18.224 - 00:34:24.526, Speaker B: Few lines of code, you get all the benefits that the chainlink price feeds offer. They're already used by all the top.
00:34:24.548 - 00:35:23.010, Speaker D: Defi projects, so it's really a no brainer if you need price data to just check out these price feeds. So if we go back to the docs now, maybe let's take a look at the next one, which is VRF, right? So let's say you want to build a submission where you kind of need randomness, whether it's for an NFT or for something and you want to use VRF, so you come to the docs. The get a random number page here has a really great simple code example that we're going to follow along with. So if I go, you could just click on the link there, but I've already got one open here, so I'll just use that one. So if we go back to here. So this is the random number consumer contract, right? In this case we're importing another chain link library called the VRF consumer base contract.
00:35:23.350 - 00:35:25.794, Speaker B: And we're setting some variables here, which.
00:35:25.832 - 00:36:17.586, Speaker D: I'll go through in a minute. And in the constructor we're basically just instantiating the VRF consumer base object here. And it really just takes two parameters, right? It takes the link token for the network that you're in and the VRF coordinator contract address for the environment that you're in, right? So the link token is just the address of the link token for the network. The VRF coordinator is, there's a smart contract that sits between other contracts and chain link oracles that kind of acts as an intermediary for all random number requests, basically. And if you're not sure what to put, if you go to the contract addresses section of using randomness, it's got all the information you need there.
00:36:17.608 - 00:36:19.358, Speaker B: So if you're working on polygon, you've.
00:36:19.374 - 00:36:32.822, Speaker D: Got the information here. If you're working on binance or if you're working on Ethereum, it's kind of all here. Now, one other thing you need to put in is the fee in link as well, right?
00:36:32.956 - 00:36:36.310, Speaker B: So whenever you're doing computation in Ethereum.
00:36:37.210 - 00:37:39.070, Speaker D: Where you're kind of changing the state of the chain, you kind of need to pay gas in the form of ETH, right? So it's similar when working with Chainlink, whenever you have a request for external data or computation, you also pay gas, right, but in the form of link to the node operators, right? So in this example, a VRF request costs 0.1 link, so we need to specify that here. And once that's done, then we're kind of ready to request our random number, right? So we have a get random number function here and it takes a seed number as an input, right. So we need to kind of provide that to the node to use to create our verifiable random number. And it's literally just one line you call request randomness and you pass in the key hash the fee and the user provided seed. Right, and. Sorry, I forgot to go over the key hash actually.
00:37:39.070 - 00:37:52.942, Speaker D: So the key hash is taken from the contract addresses page as well here. And what the key hash is is that's the public key of the chainlink node that's going to fulfill the request for randomness.
00:37:53.006 - 00:37:53.282, Speaker C: Right?
00:37:53.336 - 00:37:56.530, Speaker D: So the node saying this is my key hash.
00:37:57.110 - 00:37:58.546, Speaker B: Whenever you want to send me a.
00:37:58.568 - 00:38:10.150, Speaker D: Request to get your random number, use this, send it to me, I'll send you proof back. That kind of proves that the random number was generated by me and not by someone else.
00:38:10.220 - 00:38:10.454, Speaker C: Right.
00:38:10.492 - 00:38:28.510, Speaker D: So that's very important as well. So once you kind of pass those things in, the smart contract will basically reach out to the VRF coordinator contract up here, and that VRF coordinator will then pass the request to the chain link oracle.
00:38:31.410 - 00:38:33.258, Speaker B: And when the chain link oracle fulfills.
00:38:33.274 - 00:38:40.770, Speaker D: The random number request, the VRF coordinator will verify that it was created in a verifiably random way with the given.
00:38:40.840 - 00:38:44.290, Speaker B: Seed that was kind of given by the smart contract.
00:38:44.870 - 00:38:56.598, Speaker D: And then the random number result will come back and this fulfill randomness function will get called and we'll store the random number result in this variable here.
00:38:56.684 - 00:38:57.414, Speaker C: Right?
00:38:57.612 - 00:39:41.672, Speaker D: So that's kind of the end of the line for this example. So I'm just going to compile this and deploy it to Covenant. Okay, so we've got a deployed contract here. So we've got a get random number function here which we're going to call. So let's say I put in a seed and I call it, you'll see that we actually get an error, right?
00:39:41.806 - 00:39:47.036, Speaker B: This error, like I said before, it's because the contract doesn't have any link.
00:39:47.138 - 00:40:15.588, Speaker D: In it and we need 0.1 link as a minimum to send as payment for the oracle to basically fulfill our VRF request. So what we need to do is we need to copy the contract address and we need to go to metamask and we need to actually send some link to the contract. So in my case I'll send one just because we've got, so that we.
00:40:15.594 - 00:40:17.300, Speaker B: Can do ten requests if we want.
00:40:17.450 - 00:40:23.240, Speaker D: So what we're going to do is we're going to wait for that to go through, and once that transaction goes.
00:40:23.310 - 00:40:23.930, Speaker C: Through.
00:40:25.980 - 00:40:50.592, Speaker D: We'Re going to make the request again, and hopefully this time we'll get a successful result. Okay, so now we can successfully make a request for randomness now that the contract has been funded for link. So that transaction has now been sent.
00:40:50.646 - 00:40:53.152, Speaker B: So the VRF coordinator has basically gone.
00:40:53.206 - 00:40:56.124, Speaker D: Okay, you want to request a random.
00:40:56.172 - 00:40:59.116, Speaker B: Number with this seed, buy this oracle.
00:40:59.148 - 00:41:16.644, Speaker D: Here with this key hash, and then the coordinator will send it to the oracle. The chainlink oracle will then give the result back along to the VRF coordinator contract. And the coordinator contract will verify that it was created in a verifiably random.
00:41:16.692 - 00:41:21.640, Speaker B: Way using the seed that it was given. And it will also verify that the.
00:41:21.710 - 00:41:26.516, Speaker D: Random number was created by that oracle with this public key hash.
00:41:26.628 - 00:41:28.604, Speaker B: And if everything looks good, then we.
00:41:28.642 - 00:42:21.596, Speaker D: Should get a random result back here and there. You can see we've got a random number here. So we have a verifiably random number in our smart contract. And you can do whatever you want with it, you can chop it up into smaller numbers, you can use it to do whatever you want, basically. So that is Chainlink VRF in terms of just a basic example. So the next one that we'll go through is an API request, right? So let's say you need to reach out to find some kind of market data or anything. So in this example we've got a public API here where we can get kind of crypto price data, but in this case we're interested in volume data, actually not the price data.
00:42:21.596 - 00:42:34.032, Speaker D: So you've got an API that you can reach here and we want to create a smart contract that kind of consumes this data and uses it on chain in some kind of way.
00:42:34.166 - 00:42:34.560, Speaker C: Right.
00:42:34.630 - 00:43:15.692, Speaker D: So we're going to open the make a get request code example here. So I've got it over here and we're going to kind of see how we can kind of do this now. So once again we import chainlink library. In this case it's the chainlink client library. And in our constructor here, we don't need to specify the link address, the address of the link token because with this library you can kind of use this function and it will kind of do it for you, which is cool. We need to specify a fee again in link. So once again it's 0.1
00:43:15.692 - 00:43:34.464, Speaker D: link. Now in this case we've got these two things called Oracle and job ID, right? An oracle is basically an oracle contract. It's a smart contract that it basically sits between smart contracts requesting data and then nodes that fulfill these requests.
00:43:34.512 - 00:43:34.820, Speaker C: Right?
00:43:34.890 - 00:43:55.464, Speaker D: So we need to specify one here and we also need to specify the job ID. So each node has a number of jobs set up that it can basically do tasks and fulfill these requests with. So we kind of need to specify job ID as well. So in terms of what to put.
00:43:55.502 - 00:43:58.456, Speaker B: Here, you can go to for example.
00:43:58.558 - 00:44:02.508, Speaker D: The market link website here and you.
00:44:02.514 - 00:44:05.144, Speaker B: Can kind of explore all types of jobs.
00:44:05.192 - 00:44:40.730, Speaker D: So I think we're on the coven. Yep. So if you want to do, in this case it's a HTTP get and our result is going to be a number, right. Then we want a get and uint two five six type job, right? So we go here and we can see, okay, this one does a HTTP get. It passes a result to something that we specify. We can multiply the result and then it converts it to a number and sends it on chain, right, which is kind of what we want. So you can then copy this node job ID.
00:44:40.730 - 00:44:45.916, Speaker D: And if you go to the job spec in the address here, you can.
00:44:45.938 - 00:44:49.084, Speaker B: Get the oracle contract address as well.
00:44:49.282 - 00:45:26.084, Speaker D: And you can then plug those two numbers into the job ID and the oracle field here, right. And then you can kind of use this job here as part of your request. Now just take note that if you don't get a response it might pay to reach out to the node operator via their website or discord or whatever, because some of them do have a whitelist for certain jobs. Having said that, I'm not sure if the whitelist is in place in testnets all the time, but definitely just keep that in mind if you don't get a response.
00:45:26.132 - 00:45:26.730, Speaker C: Right.
00:45:27.260 - 00:46:20.250, Speaker D: So in our case we're going to do a similar job basically where we're going to do a HTTP get and we're going to have a number returned. And when it comes to building up the request, right, all you need to do is it's literally once again a few lines of code. So you create a new request here. You say when the request comes back to our smart contract, we want to call this fulfill function which is down here. And the request that we want to do is a get on this URL here, which is the one that we just saw here. And as part of our request we want to traverse the returned json path and go down to this volume 24 hours element here, as you can see.
00:46:20.780 - 00:46:23.812, Speaker B: So we specify that and because solidity.
00:46:23.876 - 00:46:43.632, Speaker D: Can'T kind of do decimals and things like that, we want to multiply the result so that we can kind of avoid any issues if we need to do any arithmetic or anything like that. And once that's done we call the send chaining request to function, passing in the request the oracle and the fee, right?
00:46:43.766 - 00:46:49.810, Speaker B: And that will send the request to the oracle contract that we specified up here.
00:46:50.420 - 00:47:56.984, Speaker D: And the specified chain link node that contains that job id will basically listen out and go hey, there's a job that's for me and it will kind of take it, it will fulfill the request and it will send the result back and eventually it will come back to our fulfill function and the final result will get stored in the volume parameter here, right? So let's give this one a go now. So I've compiled that one, I'm going to now deploy it and once it's deployed, remember, because we're doing an external data request, we need to fund the contract with link once again. So I'm going to send one link to the contract and right now we can see that this volume variable here.
00:47:57.022 - 00:47:59.544, Speaker B: Is zero because we haven't done anything.
00:47:59.582 - 00:48:47.176, Speaker D: With our request yet. But once that transaction has gone through I'm going to call the request volume data function, which is this one here. And like I said before, we're going to build up a new request, we're going to access this API here, do a HTTP get on it. Then once we get a result we want the node to traverse down and to get this value here and then we want it to multiply the result and basically send it back to us, right? So give that a second to kind of complete first. So once we kind of get a result then we kind of have it stored in our smart contract and we can kind of use it wherever we.
00:48:47.198 - 00:48:48.170, Speaker C: Want, right.
00:48:50.220 - 00:49:07.440, Speaker D: And there we go. So there's the volume. So as you can see, to get external data from some kind of external API, it's really easy, especially if you're just doing a HTTP get or a HTTP post. You can kind of use the standard adapters.
00:49:11.540 - 00:49:12.816, Speaker B: If you need to do some.
00:49:12.838 - 00:49:59.776, Speaker D: Kind of other API connection such as connecting to like a database or something that's a bit different. Check out the nodes section of our docs here where we talk about jobs and more specifically external adapters and external initiators as well. We've got some great documentation on the blog as well as on YouTube for external adapters as well if you kind of need to go down that path. Or check out the adapters section on market link as well because there's some adapters for all kinds of things such as IPFs and all these kind of different systems and APIs that you can kind of use as well in your submission, right? So we've gone through an example of.
00:49:59.798 - 00:50:01.696, Speaker B: How to use the three core kind.
00:50:01.718 - 00:50:33.160, Speaker D: Of chain link tools and features using simple remix examples. But what if you need to now take those libraries and basically that code and use it as part of your hackathon submission, right? So going back to what I was talking about before, we've got our starter kits here that you can use which contain working smart contract examples in a bundled up repository that you can kind of use as part of your submission.
00:50:33.500 - 00:50:37.836, Speaker B: If you've already got a repository started and you just want to import and.
00:50:37.858 - 00:50:53.584, Speaker D: Use the libraries in kind of the way that we did in remix here, you can go to the developer reference and go to install instructions and it kind of gives you the instructions you need to import the Chainlink library into your existing project.
00:50:53.782 - 00:50:54.530, Speaker C: Right.
00:50:55.060 - 00:51:20.410, Speaker D: But for the purposes of this demo, I think maybe we'll just choose one of the starter kits, probably the hard hat one, because it's the most beginner friendly probably, and we'll kind of go through an example of that one. Right, so if I just go to my visual studio here. So let me just make this a bit bigger, hopefully you guys can see.
00:51:21.660 - 00:51:26.376, Speaker B: So I've kind of pulled a copy.
00:51:26.408 - 00:51:53.936, Speaker D: Of the hard hat starter kit here to my local machine and we'll kind of go through it quickly. So we've got the three contracts that we just went through in remix. We've got them here as well in the starter kit. So your API consumer for accessing any API, your price consumer for using price feeds, and the random number consumer contract for using Chainlink VRF.
00:51:54.048 - 00:51:54.710, Speaker C: Right.
00:51:56.120 - 00:52:49.652, Speaker D: In addition to this, we've got some deployment scripts, right? So these scripts deploy those three contracts to the specified environment and they kind of give you some hints on how to then use the deployed contracts. In addition to this, we've got a bunch of what hardhat calls tasks. So tasks are kind of just repeatable steps that are kind of bundled up in a really easy to use reusable way. And we've got tasks specific to each contract, such as API consumer request data or read data, or for a price consumer, read the value of the price feed contract. And then we've also got some generic tasks as well, such as fund a contract with link, for example. So you'll see how the tasks work in a minute. In addition to this, we've got some tests for each of the contracts as well.
00:52:49.652 - 00:53:11.580, Speaker D: So if you're working locally and you want to do some unit tests, there's an example of a couple of simple tests on these contracts and you can kind of use them as inspiration to kind of create your own tests or you can modify these ones. But yeah, they're great for kind of verifying your smart contract logic, especially in a local development environment.
00:53:12.800 - 00:53:15.388, Speaker B: Speaking of, hard Hat offers what's called.
00:53:15.474 - 00:53:52.596, Speaker D: The hard Hat network, which is a local development environment that enables developers to do testing of their smart contracts in a local blockchain and not a live public one where you need to deal with tokens and this and that. And the good news is the starter kits are set up in a way so that you can work on these local networks even though you're doing Oracle requests and things like that. We use mocks and things to kind of mimic having a decentralized oracle network connected, even though you don't. So that actually is a good segue into the hard hat config file.
00:53:52.628 - 00:53:53.016, Speaker C: Now.
00:53:53.118 - 00:54:43.544, Speaker D: So the hard hat config file is where you specify, first of all, you specify what network you want to deploy and use your contracts on. So you can use the local hard hat network. Like I said, in this case, we'll stick with a public coven testnet. In addition to this, you need to specify certain environment variables, right? So you need to basically specify an RPC URL. You need to specify your mnemonic or private key which you can export from metamask so that you can kind of generate these transactions. And if you're going to be forking the main net. So hard hat has this forking feature where you can fork mainnet and run it in a local environment, which is really cool.
00:54:43.544 - 00:55:20.276, Speaker D: If you're going to do that, you can kind of specify the environment variable for this too. And you can kind of get a key from alchemy for doing that if you want. If you're not familiar with these environment variables, you can use a EMV file. So there's an example file here where you can kind of just plug in your RPCRL, which you can get one from infura. You can plug in your private key, which you can get from Metamask exporting it. And if you're forking mainnet, you can kind of plug in your alchemy RPCrL too. And then you kind of set that as your env.
00:55:20.276 - 00:55:50.908, Speaker D: And then you kind of don't need to mess around with the environment variables. Apart from that, I think that's most of it. So let's go ahead and now try and deploy. So if I go NPX hardhat deploy, what that would do is it will go through the deployment tasks or scripts.
00:55:50.924 - 00:55:52.976, Speaker B: Here in the deploy folder and it.
00:55:52.998 - 00:56:02.516, Speaker D: Would deploy each of the smart contracts to the given network. So in our case, we're doing it to the coven network, and as you.
00:56:02.538 - 00:56:03.796, Speaker B: Can see, as it deploys them, we.
00:56:03.818 - 00:56:10.100, Speaker D: Kind of get some output as well, which is pretty handy. So for price feeds.
00:56:14.940 - 00:56:15.576, Speaker B: We can kind.
00:56:15.598 - 00:57:04.820, Speaker D: Of see a task here that says run price feed contract with a command MPX hard hat read price feed and then you pass in a contract number and a network. So basically what this does is it runs the read price feed task which was over here. And because we've deployed our price feed contract to the network we can kind of specify it here and if we run that here we should hopefully get some output. And there we go. So there's the value of our price. So exactly the same as what we were doing in remix, just doing it using the hard hat starter kit here. And we've got a working code repository.
00:57:04.900 - 00:57:08.936, Speaker B: You can kind of easily integrate this with other aspects of your hackathon such.
00:57:08.958 - 00:57:33.996, Speaker D: As your UI, et cetera. Let's go through one more example. So let's do a VRF request. So run random number consumer with the following command. So we're going to run the request random number task now and we're going to pass in our deploy VRF consumer.
00:57:34.028 - 00:57:36.988, Speaker B: Contract address and we're going to specify.
00:57:37.084 - 00:57:41.832, Speaker D: A seed as well and the network as coven.
00:57:41.916 - 00:57:42.550, Speaker C: Right.
00:57:45.480 - 00:58:16.192, Speaker D: So once again this will call the specified task. So in this case request random number, which is here. And there we go. So it now says to read the returned random number once a result comes back. We now run the read random number task and we pass in the contract that we just deployed, the VRF consumer contract and we specify the COVID network as well.
00:58:16.246 - 00:58:16.512, Speaker C: Right.
00:58:16.566 - 00:58:53.528, Speaker D: So hopefully if I run that now, should hopefully have a result. And there we go. So we've got a random number back in our contract, right. So as you can see, really easy to use, easily able to integrate it to your other parts of your hackathon submission. And if we want to run the tests, run NPX hardhat test and that will run through and execute any test script that is in the test folder here, basically. So we'll let that run through.
00:58:53.694 - 00:58:56.204, Speaker B: So as you can see it's got.
00:58:56.242 - 00:58:59.420, Speaker D: Everything you need to kind of use Chainlink tools and features.
00:59:01.440 - 00:59:02.172, Speaker B: In a proper.
00:59:02.226 - 00:59:07.184, Speaker D: Code repository format, not just in a remix example that you can't connect to.
00:59:07.302 - 00:59:09.372, Speaker B: Front ends and things like that easily.
00:59:09.516 - 00:59:34.730, Speaker D: So highly recommend having a play with these things, modify the contracts, copy the contracts, do whatever you want, use the deployment scripts and tests as inspiration or as a guide for kind of doing your own and have a play with it. So I think we're just about at time. That's all I had. I think so, yeah.
00:59:37.980 - 00:59:39.370, Speaker B: Just wanted to say.
00:59:42.140 - 00:59:42.856, Speaker D: Really look forward.
00:59:42.878 - 00:59:54.780, Speaker B: To seeing what everyone is going to build and if you have any questions, like I said, reach out to us. We're in the discord whether it's the chainlink or the Xerox discord. Happy to help if there's any issues.
00:59:54.850 - 00:59:59.504, Speaker D: Happy to answer questions. And we can't wait to see what.
00:59:59.542 - 01:00:02.736, Speaker B: Kind of applications and smart contracts you.
01:00:02.758 - 01:00:06.160, Speaker D: Create to kind of take smart contracts to the next level.
01:00:06.230 - 01:00:06.704, Speaker C: Right.
01:00:06.822 - 01:00:08.644, Speaker D: So yeah, really look forward to seeing.
01:00:08.682 - 01:00:11.124, Speaker B: Everyone in the discord and can't wait.
01:00:11.162 - 01:00:14.470, Speaker D: To see what you guys come up with. Thank you.
01:00:15.800 - 01:00:23.770, Speaker A: Thanks a lot, Corey. I saw some questions in the chat, so maybe you can take a look.
01:00:25.900 - 01:00:26.650, Speaker B: Sure.
01:00:27.260 - 01:00:40.140, Speaker A: We had questions from Louis and he also posted some questions in discord which you can answer after this live session.
01:00:40.720 - 01:00:41.470, Speaker B: Sure.
01:00:43.440 - 01:00:44.510, Speaker D: Sorry, go.
01:00:46.720 - 01:00:49.004, Speaker B: It doesn't make an average of prices.
01:00:49.132 - 01:00:53.168, Speaker D: From each oracle input node. Okay, great question.
01:00:53.254 - 01:00:58.312, Speaker B: So it doesn't just take an average.
01:00:58.476 - 01:01:13.140, Speaker D: It aggregates the responses, but it also takes other metrics into account, such as volume and liquidity and things like that. Because you don't want to weigh an exchange or an API.
01:01:13.720 - 01:01:19.656, Speaker B: Let's say it's an exchange. You don't want to weigh that the same when it's got small amount of.
01:01:19.678 - 01:01:22.404, Speaker D: Volume or liquidity as say an exchange.
01:01:22.452 - 01:01:24.132, Speaker B: With a high amount of volume and liquidity.
01:01:24.196 - 01:01:24.520, Speaker C: Right.
01:01:24.590 - 01:01:28.024, Speaker B: Because in the end, market coverage is.
01:01:28.062 - 01:01:31.820, Speaker D: Kind of an aggregated and weighted result, basically.
01:01:31.890 - 01:01:33.196, Speaker B: So you kind of need to take.
01:01:33.298 - 01:01:45.730, Speaker D: Other things into account as well there. Okay, let's see, what was the next question?
01:01:48.840 - 01:01:51.616, Speaker B: Does Chainlink services usage like price feed.
01:01:51.728 - 01:01:54.932, Speaker D: Or VRF come with a cost?
01:01:55.066 - 01:01:55.796, Speaker C: Right?
01:01:55.978 - 01:02:00.064, Speaker B: So yeah, definitely. Whenever you're doing any kind of external.
01:02:00.112 - 01:02:16.940, Speaker D: Computation or kind of external request for a chainlink node to kind of either get some data or do any computation, then yes, you need to kind of pay the node operator in the form of link.
01:02:17.010 - 01:02:17.340, Speaker C: Right.
01:02:17.410 - 01:02:21.260, Speaker B: Because not only are they providing the service for you, but they are also.
01:02:21.410 - 01:02:27.696, Speaker D: Sending the result back to you on chain and they have to pay gas costs and things like that as well.
01:02:27.798 - 01:02:40.436, Speaker B: So there's definitely a cost with the price feeds. If you're just using the reference contracts because you're not modifying the state of.
01:02:40.458 - 01:02:47.540, Speaker D: The chain or anything like that, you can actually use the reference contracts without having to fund the contracts.
01:02:47.880 - 01:02:50.004, Speaker B: Your smart contract with link, right?
01:02:50.042 - 01:02:51.850, Speaker D: So you don't need link for that one.
01:02:55.180 - 01:02:56.936, Speaker B: I think someone's asked to share the.
01:02:56.958 - 01:03:13.308, Speaker D: Link to the 77 use cases article, and I'll definitely put that in the chat now. And once the YouTube video is live or wherever it's live, we'll modify the description and we'll put in all the.
01:03:13.394 - 01:03:14.908, Speaker B: Links that I discussed in the talk.
01:03:14.994 - 01:03:17.150, Speaker D: We'll make sure they're in the description as well.
01:03:28.520 - 01:03:30.070, Speaker B: Was there any other questions?
01:03:43.580 - 01:03:45.930, Speaker A: Did you have a chance to read out all the questions?
01:03:47.580 - 01:03:51.880, Speaker D: I think I answered all of them. Let me see.
01:03:51.950 - 01:03:52.472, Speaker C: Great.
01:03:52.606 - 01:03:53.690, Speaker A: Thanks a lot.
01:03:55.100 - 01:03:58.716, Speaker B: Yeah, if anyone has any other follow.
01:03:58.738 - 01:04:14.524, Speaker D: Up questions, just ask us in the discord. We'll be happy to help. Yeah, absolutely. Someone just asked about binance smart chain. Yes, Chainlink. You can use chain link with binance smart chain.
01:04:14.572 - 01:04:15.852, Speaker B: So if you go to our docs.
01:04:15.916 - 01:04:24.580, Speaker D: Chain link and whether it's price feeds or VRF, you'll see contract addresses and details for binance smart chain.
01:04:27.160 - 01:04:41.320, Speaker A: Awesome. So I guess those are all questions for today. Hari, thank you very much for taking your time to do this workshop. And yeah, thank you for hanging out on discord.
01:04:42.220 - 01:04:43.210, Speaker D: No worries.
01:04:44.320 - 01:05:00.060, Speaker A: And thank you guys for watching. We're going to start tomorrow at 11:00 a.m. With a presentation from Pedro from Wallet Connect. Thanks again, Hari.
01:05:00.800 - 01:05:04.380, Speaker D: Thanks Antech. Can't wait to see what everyone builds.
01:05:05.200 - 01:05:08.030, Speaker A: Absolutely. See you guys.
01:05:08.920 - 01:05:10.080, Speaker B: See you later. Bye.
