00:00:03.810 - 00:00:39.860, Speaker A: Hello everyone. Welcome. My name is Pramak, I'm from itworks and I'll be hosting today's show about Ethereum tooling. We'll be talking about waffle and letters specifically, I will wait a couple of minutes for late persons to join. I okay, can someone confirm on the chat that you can see my screen with a presentation? That's okay. So the presentation is for people starting from basics. No experience, nothing here.
00:00:39.860 - 00:01:12.700, Speaker A: Okay, so let's start again. My name is Tremek. I'll be talking about Waffle and others. And here are some ground rules for today's presentation. This is a remote presentation, so we might experience problems with connectivity or things like that. So if you didn't understand something during the presentation, or my connection broke up, you missed something. Or your connection broke up, you missed something.
00:01:12.700 - 00:01:48.018, Speaker A: Don't hesitate to raise your hand in Armit. I'll just go back, repeat where we have time for this. So what is Waffle? Waffle is a tool for developing smart contracts. And developing smart contracts consists of two major things, compiling the smart contracts and testing them. So that's the basics. So what do you compile? You compile solidity. This is what you have learned yesterday if you attended the presentations.
00:01:48.018 - 00:02:28.340, Speaker A: This is what we're going to focus on today as well, on solidity. But there is also viper which can be compiled and used on Ethereum as well. And Waffle also allows to import and compile contracts from NPM modules. We're going to use this today as well. So this is the first part, writing and compiling the smart contract which then you can test and later deploy on Ethereum. So when it comes to testing, there are some specific chi matchers to use. I'm going to show a couple of them in a moment.
00:02:28.340 - 00:03:23.640, Speaker A: It allows fixtures. Fixtures is a kind of optimization to used in the database and blockchain where you set up some initial status or state of the blockchain and then you can reuse the state in different tests to speed up your testing time. And in waffle you have integration with iter's JS which might come in handy because when you are writing an app, a decentralized app that communicates with blockchain, then you can use iters as well. So you use the same thing on production in your app and in testing. So this is it. Two major functions of waffle to compile the smart contract and to test it. And the qualities are that waffle is, or aspires to be rather minimalistic fast.
00:03:23.640 - 00:04:18.098, Speaker A: And there is a focus on having a friendly syntax for developers. And waffle is open source, so you can check it out, you can contribute, you can go to GitHub, check it out if you want to contribute, look for labels with help wanted or good first issue. These are the kind of issues where you can take a look as a newcomer. Maybe you can help. Okay, what's inside? What's waffle made of? Mainly typescript. There is mocha and jest. So today we'll be using mocha and testing framework mocha, and we will be using chai with a set of custom matchers to ease the test development and testing of the contracts and Javascript library etters.
00:04:18.098 - 00:05:21.930, Speaker A: I'm going to talk about it some more in the next slides. Okay, so the first part, smart contract compilation, what is it exactly? So we have a contract in solidity, for example, exchange solidity or whatever, something you might have written yesterday, a solidity code. So what do you do with it using waffle. So if you run waffle with this contract, then you will get three artifacts. The first one is bytecode. So bytecode is the compiled code that's going to be run on the Ethereum virtual machine. So when you deploy your contract, what's executed on Ethereum on this virtual machine is the bytecode, not the actual code, but compiled into bytecode.
00:05:21.930 - 00:05:59.254, Speaker A: You also have application binary interface, in short ABI. So this is sort of metadata for your contract. So it describes it's computer readable and human readable as well. It describes your interface. So you know what functions you have. You can use this ABI when building a different smart contract on top of different smart contracts. So you know what its API is, you know how to decode its input, how to decode its output, how to decode its events, and so on.
00:05:59.254 - 00:06:39.090, Speaker A: And the third artifact is flattened code. So flattened code is basically just code, but rolled into one file along with its dependencies. It sometimes come in handy. So running waffle in CLI is just run waffle, but you might want to have some configuration. So here I have some example configuration. So what I have shown here, this is an example config that also uses defaults. So if you have this, you might not have this at all because it defaults anyway.
00:06:39.090 - 00:07:37.814, Speaker A: But I wanted to show you what kind of things you can configure. So source directory, where are the source files with solidity localizes output directory where will the compiled stuff go? Node modules directory where are the node modules from where you want to import other smart contracts, and where will the flattened code go? Simple enough. That's all you need to do to have waffle and to have this first part of compilation. Okay, so I was talking about importing code from node modules. So you are writing your smart contract. You might want to use some other smart contracts, import them and override them, or derive from them. Basically use them.
00:07:37.814 - 00:08:31.590, Speaker A: So what kind of contracts you would want to use from node models? So the most important one, most known one is opense. If you want to write smart contracts in Ethereum, then you must know this library. This is a library that contains a lot of popular smart contracts that are used all over the place. For example, there are token implementations and interfaces located inside. There is also contracts for ownership management. Like if you want your smart contract to have restrictions about who can execute which functions, then you might do it yourself. Or you might use the ready made contracts from openzepalin.
00:08:31.590 - 00:09:16.934, Speaker A: They are commonly recognized. So the good thing about using zeppelin is that the other smart contract developers and auditors know it. They're well tested, well recognized. So it's good to, if there's an implementation, for example, for ownership management, it's better to use Openseeper in one than to write something of your own. Here's an example. So you import a contract ownable, which allows you to restrict function for only the owner, and you say that your contract is ownable. And that's it.
00:09:16.934 - 00:09:42.270, Speaker A: So easy enough. Next, safemap. This is also located in open zeppelin. You can use it from that. So this is a small utility library for math operation. So first let me demonstrate a problem. Take a look at this function, unsaved subtraction.
00:09:42.270 - 00:10:23.222, Speaker A: You have a variable base with a value of one, and you return one minus two. So you would expect that, you might expect that you would get minus one, but actually underflow happens. So you don't get one minus one. You get a big, big number because of underflow. And same way you could have overflow. So that's why I call it unsafe. So you might do some checking yourself, or you might just use safe math.
00:10:23.222 - 00:11:36.050, Speaker A: So if you use safemath like here, using safemath for uints, then it extends the integers with some additional functions. Like for example here again, I have one, I say one sub from subtraction two, and then I'm not getting minus one, I'm not getting underflow, I'm getting a transaction revert like error. So it's better to have a reverted transaction than to have an unsafe underflow and problems coming from that. So you have add, you have sub from subtract, you have mal from multiply and you have div from divide. It's worth using it and forgetting about underflows and overflows problems. Just keep in mind that it might throw an error and reverse your transaction. If there are any questions just raise your hand or write your question in my workshop section.
00:11:36.050 - 00:12:31.382, Speaker A: If there are none, then I continue. Okay, so we're talking about compiling the contracts using smart contracts from node modules, about Openseeperlin, about safemap, and the second part is testing the smart contract. But before we can get into testing smart contract with huffle, first I want to do some intro. So intro interacting with blockchain. How do you interact with blockchain? Because imagine you write an app like Javascript app react angr whatever and you want to connect to the blockchain. So what is blockchain? How do you connect to blockchain? Blockchain.com no such thing.
00:12:31.382 - 00:13:29.110, Speaker A: Right. So what happens is you might want to connect to a particular node of the blockchain through JSON RPC and get the data from there, or send the data to it. And a blockchain node is part of the blockchain. So this is how you interact with a blockchain. But do you write those RPC calls yourself? Well you could, but it would be more productive to use JavaScript library for Ethereum, for blockchain. So what do these libraries do? So they ease the process of connecting to the blockchain. So they wrap those JSON RPC calls into Javascript functions that you can use easily.
00:13:29.110 - 00:14:20.550, Speaker A: They also allow you to do key management. So for example, you operate with your private key. If you send a transaction, you need to sign your transaction with your private key. You need to know your public address which is derived from that private key. So Javascript libraries allow you to also easily manage your keys, sign your transaction, manage nounces, stuff like that. So the popular libraries to do just that are iters and web free. So today we're going to focus on eaters, they more or less do the same thing is the process of connecting to blockchain or a blockchain node.
00:14:20.550 - 00:15:27.066, Speaker A: So here is some example from etters. Let's say you have a private key and you want to operate with Ethereum blockchain, you want to check your balance, you want to send some transaction. So what you need to do is create a wallet which is based on a private key. So then this instance of etters wallet has your private key inside, has derived your public key, will manage your transaction signing for you. But a wallet with a private key or with a private and public key. On which blockchain is this wallet created? Is it a wallet on Ethereum blockchain? Or it might be on a different ethereum based blockchain or it might be on a testnet. So the Answer is that it's account on every EVM blockchain.
00:15:27.066 - 00:16:30.654, Speaker A: At the same time it just might have different balances because it's just a pair of public and private key and you can use the same keys on different blockchains, you can send transactions to different blockchains, it's just the same keeper could be used. So if you want to send a transaction then you have to have two things. One is your keys and the other is which blockchain are we connecting to. So here's an example. We want to connect to Mainnet, so we connect to blockchain through providers. Ethers allows you to get default provider and a default provider happens to be a provider to a main net. So now if we attempt to create a wallet the second time with a private key and with a provider, now it's a wallet with provider.
00:16:30.654 - 00:17:06.590, Speaker A: So also an instance of a wallet. But now we know which blockchain are we connecting to and who we are, what's our public address. So then when I call, get balance, then I will get a balance. And this is the balance of a public address derived from this key. And on mainnet because we use this provider. Okay, so that's the introduction to ethers. This is a wallet, allows you to use your account and connect to some blockchain through providers.
00:17:06.590 - 00:17:44.010, Speaker A: And another thing I wanted to talk about is also contracts. So contracts are entities on the blockchain that also have a public address. So here is an example. Let's say you have basic token, something you compiled with waffle. So you have this output. Remember the outputs we have from compiling smart contracts. And now you would want to deploy your contract, put it on a blockchain.
00:17:44.010 - 00:18:29.030, Speaker A: So what you do when deploying a contract? Well, someone needs to deploy it. Someone needs to be the one sending the transaction. Someone needs to be the one paying the transaction fees. Someone might become an owner of this smart contract. So we have a wallet, so this person is going to be deploying the contract. The second argument to deploy contract is compiled contract, what are we deploying? And the third part is an array of arguments for the constructor. So constructor of a smart contract might take parameters.
00:18:29.030 - 00:19:14.310, Speaker A: So we provide the parameters in the third argument of deploy contract. So again we have wallet, who is sending, deploying the contract, what are we deploying? And what are the constructor parameters? And we have an instance of a contract. So this is a little bit similar to an instance of a wallet, but this is instance of a contract. So it also has an address. It also will have a balance like this. You can get balance of a contract through a provider. Contract provider get balance of the address and you get a contract balance.
00:19:14.310 - 00:20:30.814, Speaker A: And with a contract instance you can do a little bit more because contracts have methods or functions, so you can call them. So how do you do that? So this is from Iter's docs, because we're talking about Iter's contract instance. You say contract method, you call it, you get a JavaScript promise. And this would either be like get only, you might only get values from read only functions, view only, or you might send a transaction to a blockchain that changes the state of the blockchain. So you call a method, you provide arguments to the function, and the last part is optional overrides to a method call. So what the overrides could be? Well here the overrides, it can be a gas limit, it can be a gas price, it can be a nouns. If you need to manipulate your nons yourself, it can be a value.
00:20:30.814 - 00:22:12.270, Speaker A: So how much iter do you send to a function if the function is payable? Also chain id if you need to operate it yourself for some reason. And here's example, contract some faction, not very creative on my part, with some parameter and with some overwrites, and then you get a transaction that will either succeed or be reverted, or you might have to wait some time before it eventually is mined and succeeds or reverts. Okay, so this is ethers, a quick recap for this intro to interacting with blockchain. So we had the libraries, we're talking about iters, we're talking about providers, but we still don't know where exactly do we connect. I was mentioning some node, but how do you do it? Normally if you want to have an app that connects to some node, like which node is that? What do you do? Well, there are Ethereum APIs which you can use. One of the most popular ones are infura and alchemy, so they expose normal HTP or HTTPs endpoints. So you use them like you would use, let's say standard non blockchain API.
00:22:12.270 - 00:23:54.826, Speaker A: It's just an API exposed over HTTP, and you send your data there or get your data from there and they take it on themselves to have nodes and keep the state, probably cache the state of the blockchain and you just use them as API, or if you want to do it yourself, then you can host your own Ethereum node. So if you host your own Ethereum node, then you know its address and you can point your provider to this node, you can get data from there. Other example is metamask, because metamask injects a web free provider, which a web free provider is compatible with, can be used in ethers as a provider, or it could be in memory development. Blockchain network like JavaScript implementation of a blockchain so this is what you can use, for example in remix, if you have used remix yesterday, or this is what we'll use today with testing. You run the tests, you spin up a blockchain node in JavaScript and then use it as a provider. You interact with this never leaving your local machine. Okay, so that was the introduction to how you interact with blockchain.
00:23:54.826 - 00:25:13.160, Speaker A: And we get back to testing the smart contracts with waffle. So you test the smart contracts, but what does waffle give you? Because if we're talking about ethers and if you're talking about mocha, you could do your own mocha setup you could use on your own. But what can waffle give you? Well, for example, it could give you chi matchers, which are useful for asserting in the tests. Like for example, you get a balance of a token, but the problem is that without a custom chime matchers you cannot compare it easily with normal JavaScript numbers. Because you don't get a JavaScript number, you get an instance of a big number. The reason is that on blockchain you might have very big numbers, because decimals are implemented with big numbers and a set point where the decimal is. So you might end up with very big numbers that could go out of scope of a JavaScript number.
00:25:13.160 - 00:26:31.540, Speaker A: That's why this call to get a balance gives you a big instance of a big number. And thanks to a chi matcher from waffle like you can use it in Chi, you can do comparison with other numbers, and then it would convert it to a big number and compare it. Another example is revert. So revert is something else than to fro, because fro is any JavaScript error, and revert is a special kind of error that we expect to happen on the Ethereum virtual machine. So with this matter you can say that this transfer, would you expect this to be reverted on the blockchain, or you might want to expect this to be reverted with a special message that you expect, like insufficient funds. So this is the kind of stuff you can do with waffle it also gives you this deploy contract function. It gives you the built in JavaScript implementation for testing stuff like that.
00:26:31.540 - 00:27:25.650, Speaker A: So here's an example or anatomy of a test with waffle. I will try to go over from top to bottom and explain what's going on slowly. So we use chai like normal expects from Chi. We use a contract JavaScript class from etters, which we're going to need. We have a deploy contract from waffle which allows us to deploy a contract. We have a mock provider, so I was talking about providers to mainnet for example. But this is a provider to use with development JavaScript implementation.
00:27:25.650 - 00:28:20.786, Speaker A: So this is perfect for tests. Solidity are the matchers. So we use the solidity matchers with chai. Then let's say we have a contract here, it's named template. So imagine you have built a contract, so then you can import its built artifacts that are in JSon. And then what's going on is you create a provider, then a blockchain implementation gets created and started. And with this you have some premade wallets, wallets that have some funds, have some etter.
00:28:20.786 - 00:29:19.670, Speaker A: So you need etter to pay fees and have balances. So if you take a wallet from a set of default wallets, then here's the example of deploying a contract. So again, who is deploying the contract? This wallet, what are we deploying? Sorry, this contract here, the constructor arguments just happen to be empty. We have deployed the contract. Then we can use another chimatcher to assert that its address is a proper ethereum address. Then we know that the deployment and completion and everything went smoothly. We can call a function, we have an instance of contract we can call some function here happens to be called my function, I'm not very creative.
00:29:19.670 - 00:30:02.200, Speaker A: And here's an example of using function overrides or method overrides. So we want to transfer etter to a contract. So first check the initial state, check a balance of a contract, we expect to be zero. Initially we just deploy the contract. Then we call a function with overwrites. The overrides say we are sending some meter, and then we assert that the balance of a contract has increased by the same number. So the test checks that the function correctly gets the address payable and everything.
00:30:02.200 - 00:30:38.042, Speaker A: Okay, are there any questions? Because today the first part I was talking, that was my part, and in a moment will be your part. You will do some coding. So if there are any questions, it's a good time. I guess not. So as I said, I was talking a little bit. And now you will code a little bit. But first let's set up some ground rules for the remote workshops.
00:30:38.042 - 00:31:24.640, Speaker A: So keep in mind that the workshop is not a competition. As far as I know, the competition starts tomorrow and today is not a competition, no judges and so on. So we are here to learn, not to compete and okay to be lost. If someone has finished, but you are just starting, it's okay. Everyone has their own tempo and we'll try to do it together. Be prepared to share your screen. So either to ask for help like you are lost, or you don't know something or have problems, just show your screen, show what you're having problems with.
00:31:24.640 - 00:32:04.860, Speaker A: And on the other hand also to help others. So someone has problems but you have done it. Just go ahead, show what you have done, show the solution. And yes, so these are the rules. Hope you agree and we can start. So I have prepared some playground with tests with the ethers and waffle setup. So all you have to do is clone my repository and try to build it, try to test it.
00:32:04.860 - 00:32:38.870, Speaker A: Let me know if everything is working out for you. I will send this on the chat. Sorry this is not formatted. Quite righteous. Okay. I don't have NC formatting option. Let me send it one by one.
00:32:38.870 - 00:34:20.950, Speaker A: The second it it. Okay, so the expected output is that the repository will build and that the tests that are there, you're going to be writing your own tests will pass. Okay, have started a vote. Is the setup working for you? Where we're able to clone, install dependencies and run the tests? Just let me know how it goes. Okay? Someone that said no, is it not yet, or do you have problems that you need help with? If you need help, just raise your hand and we'll try to deal with it. Okay, not yet. So if there is problems with it, then raise your hand.
00:34:20.950 - 00:35:48.160, Speaker A: I will also send you some docs. So we have docs for waffle, we have docs for eaters, we have reference for open depending contracts, and we have docs for solidity itself seems to have disappeared. Okay, anyone wants help, just raise your hand. Otherwise I think we'll get going. Okay, no hands. So let's get started. Let me do a little introduction to this workspace.
00:35:48.160 - 00:36:47.540, Speaker A: Zoom in. So what's going on in here? This is a Javascript setup for writing and testing smart contracts with waffle and letters of course. So we have chai opens a pelling mocha. It waffles as dependencies, everything that is needed. And here is a template contract. This is something you have seen this is something you can use as a reference a contract uses openzapellin, uses safemap, has some function, has some functions and example file with tests. This is also more or less something you have seen on the slide.
00:36:47.540 - 00:38:05.980, Speaker A: So we use the compiled. Give me a second. It has a weird program that I have never seen before. I'll try to help Daniel on the site and also keep explaining how can solve the problem. Anyway, this is an example file with tests we have deploy contract mock provider, something you have already seen. Here is an example of calling the methods. You expect this one to be reverted.
00:38:05.980 - 00:39:00.450, Speaker A: Here's an example to calculate the gas used by a transaction, call a transaction, you wait for it to be mined and then you have gas used which might sometimes comes in handy. And here is your exercise. You're going to write an Ifer etter splitter. So here's the task. Write a smart contract that will split the etter that was transferred to it through the overrides into two addresses. So you assign two addresses in the contract constructor, assign it to two fields, and then have a function that receives some error and split them between the two addresses evenly. I think that's simple enough.
00:39:00.450 - 00:39:56.530, Speaker A: Good for a start, test the balances. So use the matchers and the tests to assert the balances before and after the operation. And also if you have an OD number of iter transferred, just send back the reminder back to the sender and that's it. Optional thing for more advanced user users if there are any, you can have a dynamic array of addresses, but just start with the basics. Split ether into two. So here you have a starter ether splitter, a contract that you're going to implement. And here is a started test case.
00:39:56.530 - 00:40:54.404, Speaker A: It has some wallets, it deploys the contract, the compiled contract iter splitter. And there is the first test. It deploys correctly and has an address and your task is to create more. So in the test you would send ether, expect it to be transferred to other users, like here for example, it's Bob Charlie, you can use those wallets, split data into two, test the balances and don't forget to rebuild your contracts. So it's best to always have yarn build and yarn test every time you build contracts and test so you don't forget it. And yeah, good luck. Let me know if you have questions.
00:40:54.404 - 00:41:49.990, Speaker A: And now it's time for you to answer the question. So yes, you can have a beneficiary array, but the basics are not arrays, they're just two functions. So how about something like this. So you have address payable first, address payable second. We just focus on two addresses. Don't worry about arrays. And in the constructor you have the first person, you have the second person, and you assign just to keep it in the contract state after the constructor has been executed.
00:41:49.990 - 00:43:02.032, Speaker A: Okay, so then in the tests your constructor arguments would be bob address and for example or Charlie address. There are the two wallets, but keep in mind where you'll assess the balances that they already have some balances, so you need to keep that in mind. So check their balances before the function, check them after because they are not nonzero at the beginning. Okay, hope that helps. And just let me know if you have problems. We still have time to do it so we're not in a rush. Okay.
00:43:02.032 - 00:44:58.950, Speaker A: Would someone that has finished would like to show his solution? We still have second part of the exercise, so we might start slowly moving on to the second part. But has someone finished? Would someone like to show his solution? Don't worry if it's not finished or not ideal. It it has someone finished can show your solution. No need to be shy or anything. Me ask do you need more time? Please vote because I have second part about events. But we can also spend some time to finish this. So let me know, do you need more time? I don't see a yes.
00:44:58.950 - 00:45:42.950, Speaker A: So we can move on. So here's an example of implementation. I did it just about now. So it's also not perfect. No need to be perfect. So step by step, we have a contract. We have two beneficiaries, we assign them, they are address payables, that allows us to send funds to them.
00:45:42.950 - 00:46:25.840, Speaker A: And we have a split function. So it's a public payable function, no arguments, don't need anything. So the amount that gets transferred is message value from a built in native transfer. And what are we transferring to each of the two? Well, the value divided by two. So first transfer, we send history, second transfer, we send history. That's it. But also if you transfer eleven, for example, you would get five.
00:46:25.840 - 00:47:21.940, Speaker A: Here you would send five, send five and you would get a remainder of one. So if you want, make sure that, or take a look. If after division, if you multiply it by two, if it's the smaller than the amount, or you could also check if also you could check if this balance is nonzero, then you have message sender transfer. So you send the same amount back, the remainder amount back, and that's it. So two examples of a test. So we test that the value gets sent to a first beneficiary. So I deployed my contract with Bob and Charlie as the beneficiaries.
00:47:21.940 - 00:47:57.760, Speaker A: So I check initial balance of Bob, I split with a value of ten. I check Bob's balance again, and I expect his balance to be equal, the same as initial plus five. And that's it. So we check that he got his share there. Another test, make sure that the contract has no remainder. So this part is the same, we split. And then to make sure I check splitter provider get balance.
00:47:57.760 - 00:48:47.840, Speaker A: Basically provider get balance of splitter address and I expect this to be zero. If it's zero, then I know that there are no leftover reminders on the smart contract. So the proper implementation or homework if you want to finish, you would need to test the second beneficiary. You would have to make sure that this remainder is exactly where it needs to be, not just that the balance is zero. Yeah, these are the example tests for this. Again, the implementation. We assign from the parameters to the fields and we send out the values.
00:48:47.840 - 00:49:06.900, Speaker A: That's it. Raise your hand if you have question. You have a question. If not, I will be moving to part two. No question. So, part two. So now we want to have some events.
00:49:06.900 - 00:49:58.804, Speaker A: If you haven't finished, but would like to continue, just don't worry about the values, finish it later. But now try to do the events. So we want to have blockchain events for the splits. So if there is a split, you call the function split, or however you called your function, then you want to emit an event called fund split. It would say that this amount of ether has been split between the first beneficiary and the second beneficiary, and the conditional event if the remainder gets returned. If you're behind, if you're lost, then don't worry about the remainder, just focus on the first part. If you're on track, then emit this event.
00:49:58.804 - 00:50:27.964, Speaker A: In the case the remainder gets returned. Here's an example, try matcher that checks a token for its events. So see there's await expect the token transfer. This is a function. In our case it would be splitter split. We expect this to emit and again we need to provide on which contract an event is happening. In our case it's splitter.
00:50:27.964 - 00:50:55.770, Speaker A: In our case we have just one contract. So it's straightforward. We expect on a splitter to emit. Here will be fund split with some arguments. So we'll have Bob address, Charlie address and the value that has been sent to the beneficiaries. And that's it. Let me know if you have problems.
00:50:55.770 - 00:51:52.600, Speaker A: If you're still stuck on the part before, now would be a good time to show what you have problems with. I can be of help. So let's see an example of the first event. So we declare the interface of the event. We have an event called fund split. And we say that we're going to be emitting address of a first beneficiary, address of a second beneficiary, and amount that gets transferred to each of those. And in the implementation we just emit fund split address of a first person, address of a second person and amount that has been transferred.
00:51:52.600 - 00:52:36.952, Speaker A: And example of a test. We expect splitter split to emit on this contract an event called fund split with arguments of Bob and Charlie with value of five. Simple enough. And that was it. Okay, so that was my first part about waffle etters and data splitter. And now we'll begin, or maybe in a moment because someone might be joining just for the second part. So in a few minutes I will begin the second part about ERc twenty S.
00:52:36.952 - 00:54:12.090, Speaker A: It will build up on the, on the things that we have done so far. Yeah. Let me ask you, have you finished the, let me know if you have actually finished the exercises or, and you're just too shy to show it because I don't know if would anyone like any help with the exercises? Like you can show where you got so far. If not, then you're stuck on your own. So the second part about Erc twenty s is in a similar format. So we'll also have a little bit of talk and then an exercise. So exercise will be a separate smart contract, but the formula will be similar.
00:54:12.090 - 00:55:06.490, Speaker A: So if you're dealing with problems, some technical problems, or you just don't know what to do, then I think it makes sense to. Can we have a discord channel where we can contact later? Sure. So there is a discord channel. There's me. So if we ask the organizers, we'll hook up on general and see if we talk there or if there is a separate channel for this. Or you can just discord me directly. Here I am.
00:55:06.490 - 00:57:17.420, Speaker A: If you need this, I posted my discord handle. Or just ask her on general your questions and I'll be happy to answer. Okay, so I see that most of you haven't finished the exercise. So would anyone would like to show what has problems with, we can solve it together? It would be. It's a good time to do this now before we move to the second part with ERc 20s. If not, we'll begin in a momentum polish. I was supposed to be talking in English, I guess so are there polish blockchain materials? I will send a link on discord if I find any good material.
00:57:17.420 - 00:58:05.630, Speaker A: In the meantime. Also before we start on the chat, I sent my discord handle. So that was a discord handle. And also I have an email. So if you have any questions or if you would like me to check your solution, or if you almost finished your solution and need some help later, just ping me on discord, send me an email for sure. I will try to help. Just contact me and we can work something out.
00:58:05.630 - 00:59:07.504, Speaker A: And in the meantime, I start the second part of the presentation. So part two, we're talking about tokens. So what are tokens? So a Token is a smart contract, basically. So something you also write in solidity, test and deploy. So in a sense it's a digital asset or a currency. So you can have your token that represents euro or someone else's currency, you can trade in it, you can exchange it, or it could represents some kind of asset, it could represent shares, shares in something different kind of things. So these are tokens and there are various standards for it.
00:59:07.504 - 00:59:39.224, Speaker A: The most important and the most known one is ERC 20. This is something that we will take a look at today. Two others that are known is ERC eight to seven. So we won't get into it. You might want to read about this. If you're interested in tokens, there's also ERC 721. This one is especially famous as of recently.
00:59:39.224 - 01:00:23.316, Speaker A: This is the NFT non fungible token. You might want to be interested if you are interested in that. If you have heard about NFTs, you might want to read about the standard and see what it represents. But now we're talking about ERC twenty s. So what is an ERC 20? So here's an interface of an ERC 20 smart contract, at least the basics of it. There's a little more which will be next, but the basic are a name, a name for your asset or currency, a symbol, a shorthead name. Decimals.
01:00:23.316 - 01:01:40.770, Speaker A: As you might know, there are no proper decimals on the EVM Ethereum virtual machine. So there's a set point where is the decimals, how many decimals there are in a number. So this is this value, there's total supply, which says how many of those tokens are in circulations, how many of those are out there balance off. So how much the tokens does this person own? Similar to get balance for ether that we have done in the exercises and transfer, also similar to ether transfer, here is answer to whom and what's the value that we are transferring? And that's it. So that's the basics of an ERC 20 smart contract. And we'll have an exercise in a moment right now, so you can implement your own smart contract token. It's not that hard.
01:01:40.770 - 01:02:23.696, Speaker A: So the first exercise is to write your own token. So again you have in the same playground, zoom in. Here's a waffle token. It's just a name which implements the interface of ERC 20. But the functions are not implemented, revert not implemented. So your task is to implement them. And here is a test for it.
01:02:23.696 - 01:03:11.120, Speaker A: Here's a couple of tests. You might want to add some of your own, but to make them pass, I have used an implemented version of a token. So here's how an implemented version of a token looks like. It's called wafu token ready because it's already made implemented. It just derives the implementation from Openzepellin. So if you do this, you pass just the names, then you have your own token in just those five lines or so. But we want to write something ourselves.
01:03:11.120 - 01:04:25.270, Speaker A: So if you were to comment this line, because right now if I run the test tests, we have the waffle token test pass because we are using the readymade solution, right? You can write describe only to write only, execute only. Those tests would be a little bit faster. If you comment out the ready solution and uncomment this one, which is the not readymade solution, then the tests, or most of the tests will be red and your solution is to make them green. So again, comment out this ready line, uncomment this line, go to waffle token and try to implement it. So let me show you a little bit what's in there. We have a name already there. You can change it to your own, have a symbol, you have decimals, you can change it to your own, you can leave it.
01:04:25.270 - 01:05:04.400, Speaker A: We have a map of balances. So balances are implemented with a map. We have a map of address to ue to integer, unsigned integer. So the map represents who has how many tokens, simple enough. And we have a constructor with initial balance. So the role of the constructor is to assign an initial balance, because if you don't have an initial balance, then you don't have any tokens to play around with. It could be mating.
01:05:04.400 - 01:06:07.144, Speaker A: So a token could have tokens in advance, like here. It could have a system of minting where you add or create new tokens, but here, let's just have an initial balance of tokens. So your task is to assign to a map the initial balance to the sender, implement total supply, implement balance off, and implement a transfer which just changes the mapping. And these three are for the later part of this exercise. So don't worry about them for now, just focus on those ones. Yeah, and that's it. So again, write your implementation, make the test green, have a total supply balance of transfer, and let me know how it goes.
01:06:07.144 - 01:07:32.226, Speaker A: Let me know if someone has finished, or let me know if someone has problems, then we can work something out it. So the question we would set in the constructor would send the balance of a sender. So the sender that creates is the owner. So let's say that he has all the balance. Initially we can have something like this. So we have a total supply field. So in the constructor we say that the total supply will be initial balance.
01:07:32.226 - 01:08:30.830, Speaker A: In our case this is not going to change. And you say that the sender will have all the initial balance. We can start with this. So in our case the sender will have all the funds and then he can distribute them. In the real world you might have some initial distribution of the tokens, but today let's just say the sender has everything. Okay, so about the question. So yes, the solidity creates getters for public fields.
01:08:30.830 - 01:09:48.550, Speaker A: So you can do this two ways. You can have a private total supply and then return it in the function. Or if you want, you can comment out the function that is there and just have a public variable. So yeah, two ways you can do, that's it. So to show what are we talking about? So yeah, for example, I commented out the total supply, we cannot use it, and we can have a public variable with an override. Then as you point it out, it would have a getter created and it will be the same. We can assign to this the initial balance and the result should be, should be the same for our case.
01:09:48.550 - 01:11:27.910, Speaker A: How you are doing? Let me ask you, do you need more time? Okay, let me know if you need more time for this part one, let's it. All I can see is a no. So let me continue now let's prepare for the part two of the exercises. So my goal was to have a token splitter. So we had an editor splitter. It got some etter in the function, in the parable function, and split them into two simple, so this is something you might have done, like forgetting the remainders and everything and events. Just the basic mechanics of this were like this splitter into a payable function.
01:11:27.910 - 01:12:24.980, Speaker A: So you have some amount, and you get it from message value. This is the editor that has been sent in the transaction from the overrides of the transaction. So you have this editor at this point, this value that has been sent in the transaction at this point in the execution is in possession of the splitter smart contract. It has a positive balance. It has this as its balance. And what it does is we transfer half to first, we transfer half to the second, and the transfer comes from the splitter contract to the first, and from the splitter contract to second. That's more or less it when it comes to the transferring mechanics.
01:12:24.980 - 01:13:29.468, Speaker A: But imagine you have a task of creating a token splitter. So you almost have created your own token splitter, but sorry, ether splitter and a token. And if you want to split it into. Now, the mechanics are a little bit different because what would be the amount that we split? So it's not that easy as it might seem, because there's no payable in terms of tokens. So you don't have a native message values that would hold some tokens. So forget about payable, forget about message value. And how do you transfer tokens and split them in two? So one idea might be to just put them out in the parameters right of the function.
01:13:29.468 - 01:14:32.610, Speaker A: So you say I want to split token in two, and I say that I'm splitting ten. I'm saying so in the parameters of a function. But this doesn't solve the problem, because saying that I'm splitting ten tokens in the parameters is not the equivalent of actually sending them. Because you can say in the parameters that I'm splitting 100 tokens, it doesn't mean that the splitter gets access to those tokens, that he receives them. Because there is no overrides for the transaction for tokens, you cannot send this transaction and send some tokens along those because there are different contracts. Let me illustrate this a little bit. So the first scenario, we have Alice, we have the contract of ether splitter, and we have a bob and Charlie that are waiting for their money.
01:14:32.610 - 01:15:53.800, Speaker A: So we are sending a split transaction and some ether alongside it. The ether splitter received the additional ether through payable mechanics and is able to do a transfer to bob and a transfer to Charlie. So this is what we have done in the previous part of the presentation. But now imagine you have this token, you have this or almost have the token, and imagine you're doing a token splitter. So you want to split the tokens in the same way we were splitting the etter. But then it's not that easy as with atter, because if you want to send a split transaction to token splitter, it needs to have the access to your tokens that you are splitting, but transferring, if you want to transfer the tokens to the token splitter, transferring is a different function on a different smart contract. It's not as easy as having split cruise tokens because there is no such thing in an ethereum transaction.
01:15:53.800 - 01:16:55.916, Speaker A: So the first idea might be to first transfer tokens to the token splitter and then execute the splitting function. But then you run into problems if you have multiple users. Imagine Alice transfers her tokens to token splitter and wants to split, but before she does that, someone else comes around and splits the tokens to someone else. Like you would have to have some ledger to say which tokens belong to who, basically redoing the token mechanics. So it's different than with etter. I can tell you two different approaches for this problem. So one problem is using a different token standard.
01:16:55.916 - 01:17:53.890, Speaker A: So remember I was talking about different token standards. So one of those, this one, ac eight to seven, allows you to do a transfer and call which combines two transactions into one. It combines a transfer transaction and a different arbitrary transaction that you want to execute. So in this case, if this token was this different token standard, you could have a user function transfer and call, and in one transaction you would send the tokens to token splitter and execute the split. Everything would happen in one transaction. So multiple users could use the token splitter this way. This can be one solution to a problem and another solution to this problem.
01:17:53.890 - 01:18:55.190, Speaker A: Something that we would want to do today is using the full ERC 20 specification. Remember those functions that we didn't implement for now? So this is where they come in handy. These are the three new ones. So what we have here is a transfer from. So what it allows you to do is a person or a contract can transfer someone else's tokens if he has the approval to do so. So let's see, we have a transfer from, and it says the parameters from which account we want to transfer to whom and how much. So imagine that the token splitter would be able to transfer from Alice to Bob or to Charlie, the value that it needs to transfer.
01:18:55.190 - 01:20:07.332, Speaker A: Then we would start the transaction with a split, and the token splitter would access the token, access Alice's tokens himself, and send them to Bob and Charlie. And this is only possible if Alice trusts the contract, has read its source code and says that I want to approve, I want to approve a spender. In this case I want to approve splitter contract to spend my money to spend my token up to this value. And additional part is allowance. We say this person allows this spender contract or person to spend how much or how many of his or her tokens. So this is this additional interface. So now we can go back on track to implement, to implementing.
01:20:07.332 - 01:20:50.920, Speaker A: So first continue this exercise and implement the remaining functions. So we have the transfer from the approve and the allowance. And that would be a different map. That would be a map that says whom to spend how much of his token. So that would be a double map. We will have a map of address to address to value to un. So again a mapping of token owners to token spenders to their values.
01:20:50.920 - 01:22:36.440, Speaker A: And using this map we can implement the transfer form. Transfer form also just changes the balances in the map, but does so making sure that the spender has approval from the token owner. We have the approve that changes the approval maps and allowance that reads the allowance map. Is that clear? Does anyone have any questions for that? If not, then just go ahead and try to implement those free reminding functions. Kind of clear the crypto zombie tutorial. It, it. Okay, so those additional functions we're going to need for the token splitter.
01:22:36.440 - 01:23:24.360, Speaker A: So we have to implement them and get started with the token splitter. So the token splitter is the next contract that we have here. Here's how it looks like from the beginning. It is a token splitter, but it operates on some token which has been deployed at some address. So in the constructor we assign the token address and later we will operate on this, do a token transfer from. And the tests are here. Token splitter tests.
01:23:24.360 - 01:24:08.170, Speaker A: So here we're deploying two smart contracts. So we are deploying our token. Initially Alice will have a thousand of those tokens because this is our initial balance. We have a splitter. In this case, this is a token splitter and it gets the token address in the constructor parameter and we check that the deployment has been executed correctly. We check that the splitter has a proper address and you check that splitter token. So it's token address field.
01:24:08.170 - 01:25:17.820, Speaker A: We make sure that we make sure that it is correctly associated with our token address, that one of the two deployed tokens. Yeah. So if you are behind or if you want to move quicker, then what you could do is implement the ready token. We have remembered this is the one that is already implemented, so then you can move ahead with the token splitter. If you are on track, then you can try to implement the token yourself, whichever way, the exercise is to have a Token splitter. So again, the mechanics are Alice approves the token splitter to use her tokens. We send the split transaction to the splitter, which is now a token splitter, not a splitter.
01:25:17.820 - 01:26:22.230, Speaker A: And that splitter takes the tokens from Alice's account, uses transfer from. I also have an event, but let's leave that for the last part. If we still have time, we can do it. If we run out of time, you can do it yourself later, but focus on the mechanics. So, the token splitter split the tokens in the same way you want to check the balances, make sure Bob and Charlie gets their tokens. And so let me know if something is not clear in this exercise. We have ten minutes left.
01:26:22.230 - 01:27:03.960, Speaker A: Now would be a good time. This would be a good time. If you have any questions or if you need to help, if you need help with something. Okay, ready or not, we'll be wrapping up. So let me show an example of a solution. Just the mechanics not worrying about the events. So, token splitter test.
01:27:03.960 - 01:27:34.500, Speaker A: Let's check out an example of a test. Just one. So we say, first beneficiary receives the share. So we check initial balance of Charlie at zero. Initially, because he doesn't have any tokens, we approve. In this case, Alice approves. And this is because Alice has deployed the contract in the first place.
01:27:34.500 - 01:28:46.920, Speaker A: So when we say token approve, we say that Alice approves. If we would want someone else to approve, then it would be token connect, for example, David, then approve. In this case, it would be David or this wallet sending the transaction. In this case, it's Alice. So Alice approves the splitter to distribute her tokens up to ten units, and then I'm able to execute split on the splitter, on the splitter contract. And what is the split in the token splitter contract doing? Well, we have the amount passed as a parameter, but we're not sending it from our balance from token splitter balance, but we're sending it from Alice's account or from the sender account. So we do token transfer from.
01:28:46.920 - 01:29:35.960, Speaker A: We say that we are transferring from message sender, in this case Alice. We're sending to one of the beneficiaries, and we're sending half of the amount. And that's it. So, not counting the events and everything, and some maybe additional checking that the amount is nonzero, it's just two lines and going back. So we did the approve, we did the split, and now we're able to check that balance of one of the beneficiaries has increased by half of the amount. Yeah, I hope that helped. And that's it from me for today.
01:29:35.960 - 01:30:18.082, Speaker A: So thank you very much. And if you haven't had time to finish it or you had problems or you just need more time, you can send me your solution or your partial solution, however you like to my email address. I will send it on chat so it's not lost. So this is my email address. You can contact me. I will try to be helpful. This is my discord handle on so we have discord.
01:30:18.082 - 01:30:29.730, Speaker A: If you have any questions, you can hit me directly or general, whichever is easier. Thank you very much and good luck. Bye.
