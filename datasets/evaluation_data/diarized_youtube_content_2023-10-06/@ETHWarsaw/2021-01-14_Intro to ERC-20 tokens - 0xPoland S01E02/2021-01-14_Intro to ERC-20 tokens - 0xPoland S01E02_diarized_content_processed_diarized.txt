00:00:04.700 - 00:00:44.072, Speaker A: So this is a second episode of Zero Expoland. We're going to have a wonderful evening today learning Ethereum, and we're going to give it just 1 minute more for everyone to gather. And we're going to start. And in the meantime, I'm going to tell you a little bit about what's coming. So what's coming? Well, first of all, today is a second meetup, January the twelveth today, no surprise here. And just in the following weekend, we're going to have a workshop. So for everyone who would like to learn more about coding Ethereum, building smart contracts, they are invited.
00:00:44.072 - 00:01:21.290, Speaker A: But keep in mind there are only ten places, so please subscribe on our meetup website. And when you do, please make sure that you will fill in the form. There's only ten places, there's only ten people who can attend. So make sure that you're going to do all the formalities to get in. And starting from February, we're going to have a meet up once every month. And as I was already saying last time, we're going to have even more interesting events coming. Starting in March, we're going to have workshops for students who would be interesting to joining Ethereum space.
00:01:21.290 - 00:02:09.568, Speaker A: And it's going to be a series of events, probably six or eight, around 1 hour, 1 hour and a half each. So there's going to be an opportunity to learn really a lot. And finally, for our season finale, we're going to have a Wigan workshop just a week before a hackathon. So there's going to be a hackathon, two days of hacking, there's going to be awards, and there's going to be tons of time to learn and hack and do wonderful things. And for today, we're going to have two presentations, first coming from Petrek Schlachak. And yeah, I see the slide is not fully updated, so don't look at the titles. Pelt Schlachchak going to talk about ERC 20 tokens.
00:02:09.568 - 00:03:07.668, Speaker A: So we're going to learn all about, there's going to be a beginner presentation, so we're going to learn all about basic of tokens and why it's so important and how it works under the hood. And for second presentation, I'm going to do it myself. And it's going to be more advanced this time. It's going to be Ethereum under the hood about algorithms and data structures and why it's important to understand them, to fully comprehend the whole Ethereum and blockchain and smart contract space. So I would like to make a shout out to our media partners to cryptodev TV and Luzumich bitcoina who are supporting us in our mission to get as many blockchain and especially Ethereum developers to the space. Get as many new people building the future of economy together. And we are at works and together with Maker we are organizing that meetup.
00:03:07.668 - 00:03:43.124, Speaker A: So without further ado, if you don't follow us yet, then please follow us on Twitter on zeroxpoland. You can check out all the materials from our presentations are available at zeroexpoland Dev. So please feel free to go there and check that out. And yeah, for now, without further ado, I'm giving away Mike to piot to talk about ERC 20 tokens. Are you ready?
00:03:43.322 - 00:03:46.284, Speaker B: Yes, I am. Can you hear me well, Maric?
00:03:46.432 - 00:03:47.608, Speaker A: Loud and clear.
00:03:47.774 - 00:04:17.008, Speaker B: Okay. Fantastic. So, hello everyone. Thanks again, Mark, for the warm welcome. Today we'll be taking a look at how ERC 20 tokens work on Ethereum. And this is a beginner friendly talk. So if you are a beginner, you can feel right at home, because we're going to cover the ERC 20 from the basics, explaining why and how it works.
00:04:17.008 - 00:05:08.370, Speaker B: And I have a little bonus at the end for the curious. So let's start with a simple question. What is money anyway? And as the richest man in the world said, money is an entry and a database. And this is how we're going to think about money in this talk. Okay, here it is, a database and some entries. So we've got money, right? Not exactly. It turns out that you need one more thing for it to function properly as money, right? Because we can have this nice database table, we can know that Alice has some money, Bob has some money, Charlie has some money.
00:05:08.370 - 00:05:41.772, Speaker B: But this is kind of static. Nothing changes in this table. So we need to introduce the way to make changes. And this is going to be achieved using some way to transfer money. So here we have a way to transfer money. And in this example, Alice is transferring money to Bob and she's transferring $1. And you can see that this is the balance deducted from her account.
00:05:41.772 - 00:06:34.136, Speaker B: And also, the same dollar is given to Bob. Now, a few things that it's nice to notice here. First of all, even though this dollar is transferred from Alice to Bob, there is no way to really distinguish the dollars between each other, right? You can see that, of course, Bob's balance updates. But after the update, there is no way to know which one of those $200 was the one given to Bob from Alice. And similarly, it's not really possible to know which one of those 105 was deducted from Alice's balance. So this is what we call fungibility. So no way to tell the different units of money apart.
00:06:34.136 - 00:07:12.824, Speaker B: Okay, so, so we've got the basic properties. First, we need to know which person has what balance. Second, we need to be able to transfer the money. And third, the money has to be indistinguishable from each other because otherwise we run into problems. Okay, so unsurprisingly, you'll find that blockchains like Ethereum have this as their transaction format. You have a from and this is analogous to, of course, to the transfer function. You have a from, which is an address.
00:07:12.824 - 00:07:45.988, Speaker B: So blockchains like Ethereum don't use names or identities or whatever for knowing the senders and recipient. Basically everybody on the blockchain has a pair of cryptographic keys. And this is a fancy way of saying that they know a secret number that they don't tell anyone. And there is another number which is their address, which is public. And this identifies them on the blockchain. So from is some address to is some address, right. We've got value.
00:07:45.988 - 00:08:11.016, Speaker B: So how much is transferred? And then data. And this is very interesting, but we'll talk about it later. Okay, so here is an example of a blockchain transaction. You can see that from is some address. And this address we know belongs to Alice. And we know it because it's an example. And the second address belongs to Bob.
00:08:11.016 - 00:08:49.560, Speaker B: The value that's transferred is one ether. Basically this works just like this example, but with cryptocurrency on the blockchain. Right? Now the curious among you have probably noticed the field called data, right? Because the original design of money didn't specify anything like data. And here is where Ethereum innovates over what blockchains did previously. Basically, the data field is a way to talk to smart contracts. Okay, fancy words. Here is a smart contract.
00:08:49.560 - 00:09:44.212, Speaker B: It's relatively simple. Basically this smart contract has this field called value and this function called increment. It works sort of like classes where if you call the increment function, the value gets updated. So you can imagine this transaction, right? The previous transaction was from Alice to Bob and it sent some money. This transaction is from Alice, but the recipient is the counter contract. Okay, so the money transferred is actually zero in this case, but the data is calling the increment function, this one. And this changes what is actually stored on the blockchain.
00:09:44.212 - 00:10:41.976, Speaker B: So it turns out that this little script is actually a database sort of, right? You've got the data and you've got a way to modify it. It's sort of like a database, no SQL included. But hey, we got to live with what we have. But wait a second. So if a smart contract is basically a database, this means that we can get a smart contract to represent money, right? So, okay, let's look at this. This is a way to do money, but as a smart contract, a program running on the blockchain. So here we have a contract, a token, and instead of just having one single value stored inside it has a mapping and a mapping.
00:10:41.976 - 00:12:06.100, Speaker B: You can think about a mapping as a database table that has a key and some value, right? And then you can query the value by the key. So the key in this case is an address is who owns the coins? And then the value is how many coins do they own? So this is a mapping from an address to an unsigned integer. An unsigned integer is a fancy way of saying that it's not less than zero. So every address can have a balance, and this balance will either be zero or something positive. But as we discussed previously, just knowing this mapping is not enough. We need to have a way of interacting with it to actually do something useful. So we have a function of transfer, and similarly to what we had in the example with the abstract database here, the function transfer has three parameters, from, to and value, and it updates the balances, right? So the balance of the sender, which is the from, right, is deducted.
00:12:06.100 - 00:12:40.476, Speaker B: The value is deducted from this balance, and then the recipient's balance is increased by the value. So basically the same thing that happened here, right? Alice's balance gets decreased and Bob's balance gets increased by the value. But now it's a programmable smart contract on the blockchain. Lots of fancy words. You can see that inside. It's simple code. Now I've got a note here that says no restrictions.
00:12:40.476 - 00:13:52.004, Speaker B: And thanks note for reminding me that this code is really, really insecure because it allows anyone to call a transfer and say that someone transferred money to someone else. But then I will be able to call this function and say that actually, you know what? Marek has transferred all of his money to me and now I have all of that money without Marek knowing about it or saying that he wanted to do this. So this is obviously insecure. And we can add a slight modification. So this is token v two, right, v two, because we have significantly improved it. And you can see that the from field has been removed from the transfer and the account, the address that the value is being deducted from is actually the sender of the transaction. So this is something specific to Ethereum.
00:13:52.004 - 00:14:58.444, Speaker B: But when you send a transaction like this, when you call a smart contract with some data calling some function, the from field from this transaction, and this transaction is signed cryptographically. So this means that only Alice can send a transaction from Alice. This from value is then exposed to the smart contract as message sender. So this is how we ensure that only the appropriate person, only the person that called the transfer, can transfer the money out. So if I were to call the transfer function saying that I want to transfer money to me, well, I'll be transferring money from my own account, not Marek's. And if Marek actually wants to transfer money to me, then he himself needs to call the transfer function. But once again, the note is kind enough to remind me that actually I'm missing something here.
00:14:58.444 - 00:15:58.908, Speaker B: And what I'm missing, well, I'm missing a check that I have enough money. So let's see how this can be achieved. Token v free oh wow. We have achieved peak agile version free in under like ten minutes. But basically now it's more secure because we've added this one additional line. The require is a keyword in solidity, which is the programming language that we were using all along, which basically cancels the execution of the transaction, makes it like never happened if the condition doesn't hold right. And what is the condition here? Well, in order to spend from my account, in order to send someone some value, I first need to have enough value in my balance.
00:15:58.908 - 00:16:46.652, Speaker B: So we check that balance of message sender is greater or equal to value. Now this is all great. This is our own nice implementation of a token on Ethereum. But if everyone were to roll their own token, we would have problems. So this is where ERC 20 comes into place. Instead of everybody creating their own custom weird token implementations that have different function names, different field names, different behavior, we have a standard, right? ERC stands for Ethereum. Request for comments.
00:16:46.652 - 00:17:38.432, Speaker B: 20 is just the number 20 because there are many different ercs. And these ERCs define standards that people in the ethereum ecosystem can use when developing their own applications. And ERC 20 is a standard that defines how a token should look and behave, so that someone willing to interact with that token doesn't have to learn and implement everything all over again. If they have something that works with one ERC 20, it will work with a different ERC 20 because they are compatible. So here is what the standard actually entails. We have a name, so each token has a name right. I have this example here.
00:17:38.432 - 00:18:08.336, Speaker B: One of the well known tokens in the space is tether. And the name for tether is tether. USD. Now we have also a symbol, and the symbol is USDT. We also have decimals. And this gets tricky, right? The decimal value for tether is six. What does that mean? That means that one tether, one USDT, is actually represented as a million units.
00:18:08.336 - 00:19:00.712, Speaker B: Okay? So in the smart contract where you have the balances stored, then if someone has just one USDT, the balance will actually say a million. So this is funny because I can be a millionaire just by owning a single dollar. The other thing that we have from this kind of descriptive part of the standards, we have the total supply. So each token has to actually declare how many tokens in existence there are. Okay, straightforward. Each token declares that. Now we have a section of the standard that talks about what values can be read from the smart contract.
00:19:00.712 - 00:19:49.950, Speaker B: So we can read the balance of someone, someone has an address and we can query their balance. So if I had one tether calling the balance of function will return that I indeed have this one tether. And of course, because we have the decimal set to six, the function will return a million. Okay, we also have allowance, and let's skip this part for just a second because the next slide is going to deal with this and we need to talk about the rest. We have the transfer function. The transfer function is also standardized. It takes the input address, sorry, it takes the destination address and the value, and it uses the message sender as the input address.
00:19:49.950 - 00:20:23.168, Speaker B: And you can see that this function returns a boolean. So the standard defines that if an operation succeeds, this function has to return true. And if the operation doesn't succeed, the function has to return false or revert. Okay, so we also have transfer from and approve. And this is connected to allowance, which we'll get to in just a minute. And we have some events which also get their own slides. So let's move on to approval.
00:20:23.168 - 00:21:20.856, Speaker B: And the picture in the background isn't a coincidence. Approval is basically the mechanism that happens every time you do online shopping. So imagine I wanted to buy something on Amazon, right? I go to Amazon, I type in a nice book, okay? I browse the books, I click to purchase the book. And what happens? Well, Amazon calls my bank and says, hey, we need the money from the guy. And the bank sends the money to Amazon. Well, the same thing can happen with smart contracts that represents tokens. Basically, I can approve an exchange, a shop, or any other smart contract to be able to take balance from my account.
00:21:20.856 - 00:22:40.448, Speaker B: Instead of me having to send the money to them, they can send money from me to themselves if I have approved it previously. How this looks? Well, here is a simple example. Let's say that Alice wants to trade some of her tether for some of her for new ETH, right? So she will pay tether and get eth. Well, what she does is she calls the tether smart contract with the approve function, right? And this is part of the standard, the approve function. And what she does is she specifies that she approves the exchange to be able to spend as much as 1000 USDT from her account. Later, the Alice can trade on the exchange and she can say, hey, exchange, I want to trade 200 USDT for zero two eth. And the exchange will then take the money from Alice's account using another function defined in the standard, which is transfer from.
00:22:40.448 - 00:23:48.970, Speaker B: Okay, so the exchange calls transfer from specifies that it wants to take money from Alice's account. The money should go to exchange's account, and the money is equal to 200 USDT. And because the allowance at the beginning was 1000 USDT, after this operation, the allowance is only 800 USDT. Now this is all great. And you can also use the allowance function, which is the other function that allows you to read data alongside balance off. So you can use the allowance to see how much allowance a spender has for a given owner. So in this case, we could query how much money has Alice approved the exchange to spend? However, the approve function is actually a bit tricky to use because, okay, consider this.
00:23:48.970 - 00:24:45.684, Speaker B: Alice wants to approve Bob to spend a $1,000. Later on, Alice wants to approve Bob to spend a different amount because she changed her mind, either increasing or decreasing. Let's say that Alice actually wanted Bob to be able to spend more. So she decides to approve Bob for not 8000 but 8200 USDT. Then Bob calls transfer from to get the money to himself. He gets 500 USDT and his allowance is decreased, meaning that it's now 700. However, if the order of events were slightly different, right, and this might happen because the transactions can be included in a different order on the blockchain.
00:24:45.684 - 00:25:46.412, Speaker B: Well, first Alice approves Bob. Then Bob takes the money out. Then Alice approves Bob for the higher amount. But because the approve function sets the value, then Bob's allowance is actually now 1200 instead of 1000, even though he spent the money. And this is why I included the scream cat emoji. Because this is a very undesirable situation. So this is why the ERC 20 standard has been extended by the two special functions, increase and decrease allowance, which when called, do not set the allowance to an absolute value, but rather increase or decrease it by a specific amount.
00:25:46.412 - 00:26:55.620, Speaker B: And in this case, if the second transaction was not approved, but rather increase allowance by 200, then the transaction ordering wouldn't matter. So this is why those two functions are needed. And now, after we've discussed allowance, it's time for events. Everybody loves events, especially zero x Poland, which you're attending right now. And the events on the blockchain are special because events on the blockchain are a way for the transaction to signal to anybody watching the blockchain what happened inside. And basically, events are something that's emitted during execution and then included in a transaction receipt. So what is a transaction receipt? Basically, whenever a transaction gets mined on the blockchain, and this is also fancy lingo for saying that the blockchain now just includes this transaction.
00:26:55.620 - 00:28:16.540, Speaker B: This transaction has a receipt, so you can know which block that transaction got included into the hash of the transaction, whether the transaction succeeded or failed, and you also get the events. So if I am a client, an application that reads the blockchain in order to show whether or not some money has been transferred, then I can rely on those events to see whether or not the events were emitted and how much money was actually transferred. And this is great because it improves Ux and also enables us to see what's going on behind the hood. Okay, I have a bonus for you. Right, so you've been all through the ERC 20 standard. Now you know everything about how the ERC 20 tokens work. Now let's spice things up with ERC 721, right? If your head isn't spinning, I don't know what to do to make it spinning, because this is a radical change in how the tokens are constructed.
00:28:16.540 - 00:29:04.572, Speaker B: As I said before, tokens that represent money need to be fungible, right? So the units are indistinguishable from each other. Well, ERC 721 tokens are distinguishable from each other. Each of the cats that you can see in the picture is actually an ERC 721 token. And each one is unique, so you can tell them apart from each other. How is this achieved in the code? And this is the best part. This is the cherry on top. At its core, an ERC 20 is a mapping from an address to a Un.
00:29:04.572 - 00:29:56.696, Speaker B: Right, an unsigned integer. And in this way, each owner knows their tokens. But what an ERC 721 is at the core is the mapping from Un to the address. So that each token knows their owner, and this enables the tokens to be non fungible, nonfungible, meaning that the units of the token can be distinguished from each other. Very fun stuff. I encourage you to read more about each of the topics, explore it a little bit, see what tokens exist in the ecosystem, and most of all, keep learning about Ethereum. My name has been Pyramid Schlachak.
00:29:56.696 - 00:30:13.730, Speaker B: You can hit me up on Twitter at pslakchak, where I occasionally post some nice stuff. Thank you very much. I'm giving it back now to Marek. And yeah, thank you very much once again.
00:30:17.720 - 00:30:42.620, Speaker A: Hello everyone back. I think we have one question to Fiot's presentation. Let's try to answer that. I'm opening right now. Oh yeah, here it comes from at the bottom of the screen. As a smart contract programmer, you are responsible for writing metal like balance, transfer, or approve or. Most methods and classes are at the abstract level in solidity by default.
00:30:43.200 - 00:31:35.370, Speaker B: Thank you, Jaku, for this excellent question. And no and no actually is the answer. So when you're programming smart contracts, you don't re implement all of those methods unless you're doing something very custom. But also, none of those things are actually built into solidity. What you want to do is you want to install a library containing battle tested audited smart contracts, for example, Openzeppelin's smart contracts, and then use them to create your own tokens. And open Zeppelin's library includes a reference implementation for ERC 20 with all of the custom stuff that you might potentially want, which is great because you're not reinventing the wheel. And also, your code is then secure at the end of the day.
