00:00:03.400 - 00:00:16.273, Speaker A: Hope I got that right. Thank you so much. Yeah, not too bad, not too bad. Yeah. Hi, welcome everyone. Thanks for staying here this very late hour on the second day of the conference. Not too bad.
00:00:16.273 - 00:01:00.765, Speaker A: Maybe before I start, who of you have a definition for what a TE is like? Does TE ring a bell with anyone? Trusted execution environment. Okay. Like a few people. Okay. Yeah. So I'm here to try and convince you that certain things that are desirable in the long term we could incrementally achieve today if we settle for a trade off temporarily. And so how can we unify Ethereum? I'm going to talk about how we can reach something that we like to call real time proofs RTP today.
00:01:00.765 - 00:02:09.509, Speaker A: And so the idea behind T1 is to basically try and get to an incremental real time proving system that we can then incrementally have lean more and more on additional cryptographical primitives such as zero knowledge, as those progress. So now let's talk about the rollup centric roadmap for Ethereum. Who of you knows what the rollup centric roadmap is scaling? Roadmap 1 people 2, 3, 4, 5, 6. Okay, so then you will probably have been told how the rollup centric roadmap managed to scale Ethereum. And my point would be? Well, we scaled the performance part of it. We managed to get to an ecosystem where we can have those roll up off chain components run at high transaction per second rates and low user fees. What we are missing though is composability.
00:02:09.509 - 00:03:42.095, Speaker A: We lost this desirable property of defi Lego building blocks where you could have some money on Arbitrum, 1,000 bucks, and you could do something with those thousand bucks to a contract that lives on scroll. You can't do that today. Now why can't you? Well, when I was Joining scroll some two years ago, early 2022, everyone thought ZK rollups were the answer. ZK rollups were an answer to composable scalability because people would be able to have ADAP live on Ethereum mainnet and look at the state of the ZK rollup and therefore compose into it. Now this is hopefully going to happen at some point, but what prevents us from having that luxury today of composing between scroll and arbitrum is that scroll or any ZK rollup nowadays still needs minutes, if not hours to actually come up with a zero knowledge proof of an Ethereum block. And optimistic rollups of course, need a way longer withdrawal challenge, period. The result of this, and there's many theses for how this came to be is that indeed quite few of active Ethereum users use rollups.
00:03:42.095 - 00:04:47.345, Speaker A: Our research, our quick analysis on on chain data shows that it's roughly 1 in 5 Ethereum users who are active on on roll ups. And this is surprising, one would think, well if rollups scaled, Ethereum people would live on rollups and never have the need to even go on Mainnet and pay those extravagant fees and have all of those issues. So yeah, we are still getting there. We still need to solve this. And an hour ago there was a panel here, a panel on how L2s are or are not parasitic towards L1. So DL1 and there was a several theses were stated such as that rollups be shorts and how the scaling problem might be solved but for this tiny asterisk of liquidity fragmentation. And my point here is, well we're actually quite far away from having solved scaling whilst liquidity remains fragmented.
00:04:47.345 - 00:05:42.525, Speaker A: And the fact that only 1 in 5 people use roll ups is proof to that, in my opinion. Some people would say, well ZK is getting fast. I see there's some ZK OGs sitting in the audience here and there's some people such as Justin Drake claiming that real time proving with ZK becoming tomorrow or the day after. But let us ask ourselves what it would mean for ZK to be sufficiently fast. Now what does it mean to be real time proving to be proving Ethereum blocks in real time? Any guesses from the audience? How fast do you need to be? Less than 200 milliseconds. Less than 200 milliseconds. Okay, and how fast are we today? A few seconds.
00:05:42.525 - 00:06:19.959, Speaker A: Oh, we wish the answer was few seconds. No. Right now we are on the order of magnitude of minutes to hours when it comes to proving something like an Ethereum block. So usually an L2 EVM L2 block we don't need to go quite as slow, I would argue as 200 milliseconds depending on how our friends at DEF and et al fix timing issues. Timing games with MEV on mainnet, like on with respect to validators and the MV supply chain. But the upper bound is the block time of mainnet Ethereum, 12 seconds. Right.
00:06:19.959 - 00:08:04.487, Speaker A: We need to be able to have someone transact on this off chain system, say a ZK rollup, do things that off chain system needs to come to consensus about its state. And then some entity, some proverbs, needs to come up with a proof for the state transition from the previous state to the new state of the off chain system. Now this very thing needs to make it two Ethereum validators who are proposing a next block in time for them to actually still become included during the 12 second interval. So this is actually very fast and we are orders of magnitude away from this. And this is in a world where ZK rollups are paying a lot to actually have this performance. So how can we make this possible today? How can we approach real time proving today? Now, I used to be a vehement opponent of trusting anything else in pure cryptography. And then I realized, well, what is a better system? A system where I need to rely on insecure bridges with running off a multisig because I can't possibly wait to have my funds withdrawn from Arbitrum if I want to trade on scroll for 7 days or do I prefer to have a TE based security system ideally reinforced with additional non t defenses? And myself I opened up to the idea of actually going with the latter.
00:08:04.487 - 00:08:26.433, Speaker A: Now I would like to try to convince you this may make sense, but maybe before I do like to whom does this sound outrageous? Trusting a TEE with your funds, trusting a TEE with your blockchain. One person? Two. Three. Okay, three and a half. I'm with you. Yes. I would never.
00:08:26.433 - 00:09:30.295, Speaker A: The problem with tes is there's a certain like the common criticism will be but SGX is insecure. But a week ago we had the zero day and if you are running a seven year old machine and you didn't apply the recommended countermeasures and you also didn't upgrade your firmware, then a ciphertext of some secret keys will be revealed. Yeah, not good. Not a terrible tragedy, but still not good at all. Now how can we prevent this in a blockchain context where we want the TE to be able to secure not a million bucks, not 10 million, but actually a very big amount of of funds. Like obviously there will be some sort of limit above which a state actor will be able to take a microscope and pay some people to get into your te. I call this incremental real time.
00:09:30.295 - 00:10:29.597, Speaker A: Proving how we can get there is start with a TEE and then apply additional measures, additional defenses in an incremental way. And so the vision is again let us remind ourselves what we are after to reach this United States of Ethereum situation where the different rollups not only provide for low fees and high tps, but actually are able to compose. Now how we can get there is what we've been working on with T1 protocol over the past half year or so. And our suggestion is the following. No laser pointer here, unfortunately. So you'll need to bear with me. Now, my idea for incremental real time proving is to start with a system that is the TEE enhanced worker.
00:10:29.597 - 00:11:46.553, Speaker A: This is the entity that is executing blocks and producing new state routes. And those state routes are making their way to the Ethereum smart contract that only checks in its simplest form the ECDSA signature of the whitelisted TE entity. But now you can think about measures, how you can limit the maximum damage that the zero day vulnerability in the TEE might introduce. One suggestion towards this goal is to have another role, a validator. This could well be a restaking role, an actively validated service that draws upon the crypto economic security of Ethereum stake and to avoid the bootstrapping like are you guys familiar with restaking how say eigenlayer works? Anyone? Okay, great. So yeah, this is how we no longer have to bootstrap a valid data set, right? We get tap into this vast economic security. But we don't want those people to actually have this big computational burden of having to execute every user transaction.
00:11:46.553 - 00:12:44.115, Speaker A: Instead we impose upon them a simplified set of conditions that need to be checked. And one idea for how to do that is we start with the user intent to do something, to trade, for instance, at a limit. Now the user will encrypt this intent to the pub key of the TE worker. Let's say, let's say it's a single TE worker. Later we can expand upon this and this ciphertext of the intent will then be put into an ordering by the validators, by the AVS validators. They will blindly order such transaction candidates. So intents over here, does this make sense to you guys? Who does this make sense to? Okay, cool.
00:12:44.115 - 00:14:23.529, Speaker A: So this is a countermeasure towards having the TEE vulnerability reorder transactions, reorder intents. Once the intents reach the worker in here with this system, we are already removing the ability for the T that's compromised to extract value to front run and background users. For instance. Now a second idea that I wanted to share with you is to have something that we started calling match proofs, wherein upon the execution of the intents that only the worker is able to decrypt and execute, will the worker share not only the new state of the world, the new state of the rollup or L2 system, but also the plain texts of users intents, and then will the validator be able to check whether the new state of the world matches what the users originally intended? So they will be able to check, hey, maybe the T worker was compromised. And instead of Giving the user at least 4000 usdc per eth. They actually gave them 0usdc because they will be able to match those no longer encrypted intents with the outputs from the workers. And there's a little asterisk here.
00:14:23.529 - 00:15:16.065, Speaker A: Does anyone see a problem with this? A missing piece? Well, the very idea behind the validator is that they must not have to trust the worker. So they can't just receive the plaintext of the user intents. We actually need to enforce that the user, when they originally create the ciphertext, also commit to the plaintext. For instance, they hash it and publish that. And only then will the validator be able to check whether the plain text of the user intent indeed was what the user originally came up with. Now this is an important consideration to continuously be making when working with tes. We assume like we are in a maximally adversarial situation.
00:15:16.065 - 00:16:04.049, Speaker A: We assume that the TE be broken, which by the way should probably be assumed for ZK and cryptography and so on as well. There's limits to what this secures as well. But if we assume a TE can be broken, we are able to actually prepare better for a situation where these outputs are not trusted. We continuously treat anything that comes from this guy as not trustworthy and we only ever trust what the user signed with the private key. Does this make sense to you? Who does this make sense to? Cool. Okay. Yeah, that's not too bad.
00:16:04.049 - 00:17:12.382, Speaker A: Now those different types of proofs, we call them integrity proof from the worker and the match proof from the validator alongside some subset of the transaction data would go to Ethereum and some other subset of transaction data would go to an alternative da. And this way we could have a system that is actually able to settle on Ethereum on every Ethereum block, up to every ethereum block every 12 seconds. And then there's additional ideas that you could consider to security harden this further. One idea I wanted to share at this point is we could either in the, let's say in the Ethereum contract, we could also look for certain situations that are suspicious. We could assume that for some reason the validators actually are no longer trusted. Maybe there's a bug and eigenlayers contract, so maybe there was sufficient bribe and a zero day exploit in the TE worker. Now what we could do is we could have heuristic ZKP requirements.
00:17:12.382 - 00:18:43.341, Speaker A: We could have a system that actually stops the balance updates on Mainnet Ethereum until if it detects too big an outflow of funds or a situation that is suspicious and then block on receiving a zero knowledge proof of the state transition. This would slow down the system to what we are used to from ZK rollups. But we could play with the hyper parameters here. We could dynamically adjust the aggressiveness of such a heuristic. And we could also lean on and leverage ZKP acceleration and be more aggressive as we go or be more aggressive as the TVL secured by this system grows. Any questions about this diagram? Yeah, okay, but there's like still MEV capability here because if validator and worker collude, they can work towards extracting additional value on the user's cost behalf. So how do you address that? So the question is, well, if I understand correctly, hey, but there's still collusion risk because the worker has the private like the private key that is able to decrypt the user intent.
00:18:43.341 - 00:19:20.685, Speaker A: And they could collude with the validator to finalize block in a way that extracts MEV by for instance frontrunning the user. Is that adequate? Yeah, that is a risk. And remember, this is a tee, so this guy, they can't just go to the validate and collude. They need to break the TE first. Because what the software that the TE is running does is waits for a finalized block signed off by a validator. It can't just decrypt an arbitrary user intent. That's not what the software does.
00:19:20.685 - 00:20:13.499, Speaker A: And because we have a TEE around it, the owner like the operator of the TE node can't just change the software. So I feel like this is actually a good synergy for what TES makes sense. MEV could be maybe some few thousand dollars, maybe if there's huge market movement, maybe it would be on the order of tens or hundreds of thousands. But you need to have broken the TE right before it and be ready. So I feel like this is a pretty decent trade off, a pretty decent compromise that would make me sleep well enough. Is that satisfactory? It is a compromise, of course, of course. It's a suboptimal world that we live in.
00:20:13.499 - 00:20:56.297, Speaker A: Sure, sure. This could happen. And there's more that can be done. You can envision for instance requiring a consensus of workers. You could envision requiring a consensus of workers that each are running a different vendor's te so that the chance that an attacker be able to break intel tdx, intel sgx, amd, sev, snp, arm Trust zone and also have colluded with the validators that are actually validating this exact block is diminishing. And you could think of additional ways of Making this less likely. If you have ideas, hit me up.
00:20:56.297 - 00:21:52.663, Speaker A: I'd be interested in learning. In learning more. Any more questions about the design? Yeah, if they occur, what, how this system could work out this. Could you repeat please? Yeah. What about mishandled mistakes and so on, how they could pass through this system? Mishandled proofs? Yeah. What do you mean by that? Like mistakes that happens in design or and could evolve the whole system. So like smart contract bugs or ZK circuit bugs.
00:21:52.663 - 00:22:45.869, Speaker A: Sure. Like a risk that we have in any system that includes a smart contract. Is that the smart contract be buggy? Of course that could happen. If we have a heuristic ZKP system, there could be a mistake problem with the ZK circuits. Yeah, of course these are things that could still happen. And a nice thing about running systems that are considered sufficiently secured on their own in a TE is that you make these a bit harder to exploit. So an additional step one could take, and some people, some other companies are working on this, is to take this entity as well, the validator, and put them in a TE and maybe they get like a better yield or some additional inflow of volume because of that.
00:22:45.869 - 00:23:44.175, Speaker A: And you could also envision putting a ZK prover inside the te. So what this takes away is the ability to easily, once you've spotted a bucket ZK circuit, leverage it like you also need to then control the te. So this is an approach that's known as security or defense at depth, where you have additional like several layers of security, each of which adds to the security rather than dividing it. Any more questions? This is my last like content slide. So if you have any questions about the presentation, now's the time. Okay, Hubert, go ahead. Sorry, Chris.
00:23:44.175 - 00:24:39.159, Speaker A: In this schema is the worker, is it just doing the state transition function or is it also keeping state? So in this situation it's not defined whether the worker be stateful or stateless. Both options are possible for pragmatic reasons. Us at T1, we are starting with a stateful worker just to be able to test sooner. But I envision having a stateless system. Yeah. Because in a stateful worker, if there is a need to rollback because of changes in the Ethereum, how do you do it? Is it rigged? In that case, I think rollbacks are very tricky. And another thing that makes stateless work as more attractive is indeed multi vendor tes.
00:24:39.159 - 00:25:15.659, Speaker A: Like if you have multiple vendors and you want to not only round robin, but you want to somehow distribute this security duty, a stateless system would indeed be desirable. Yeah. Okay. Thank you. Any more questions? Okay, if there's no more questions, what I would, of course, encourage you to check out is our new website. We've just launched the website because of the Warsaw blockchain week. It's t1protocol.com
00:25:15.659 - 00:25:39.915, Speaker A: or you can just join us. We are hiring. We are hiring for founding engineering roles, and I would be keen to learn about whatever questions or ideas you might have after the talk as well. Feel free to hit me up on Twitter. DMs are openresta, oresta. Other than that, thank you so much for your time.
