00:00:00.650 - 00:00:59.710, Speaker A: Welcome to Uncommon Core where we explore the big ideas in crypto from first principles. Today I brought on Dan Robinson and Georgios Constantopoulos who are both research partners at Paradigm. Together we explore the topic of Mev or minor extractable value. Blockchains like Ethereum have this dirty little secret that while in most regards they are very decentralized, the ordering of transactions within a single block is actually completely in the hands of a single miner. They can insert their own transactions, rearrange those of users or even censor them completely. Mev describes how much value Miner can extract from users and other miners by using these powers to their advantage. And if you've never looked into mev before, I think you'll be both shocked and fascinated by the complexity and sophistication of the war that is raging inside Ethereum's memory pool.
00:01:00.050 - 00:01:08.112, Speaker B: Enjoy. Dan and George, thanks so much for coming on the show.
00:01:08.246 - 00:01:09.776, Speaker C: Thanks for having us on.
00:01:09.958 - 00:01:11.410, Speaker D: Thanks for having us.
00:01:11.860 - 00:01:15.116, Speaker B: Dan, could you start by introducing yourself to our audience?
00:01:15.308 - 00:01:22.864, Speaker C: I'm Dan Robinson, I'm a research partner at Paradigm. And in past lives I was a lawyer and then a crypto protocol engineer.
00:01:22.992 - 00:01:32.600, Speaker D: Hi, I'm Georgios Consandogulos. I used to be a consultant in crypto and now I'm also a research partner in Paradigm.
00:01:33.100 - 00:02:38.648, Speaker B: I brought you to here to talk about one of my favorite topics which is mempool games and mev and front running in Ethereum. So, to start this conversation off, most people have used wallet like MetaMask before to send a transaction on Ethereum and they roughly understand how the user experience works from their perspective, right? So you create a transaction, you set a fee rate and then you publish it to the network. And if you selected a high enough fee, then most of the time you should hear familiar bing a few seconds later and your transaction has been confirmed. But I feel like this is one of the cases where behind a simple user experience there's actually a lot of complexity hidden that most of the time the user doesn't need to be aware of, but in some cases they do. So what actually happens between a user broadcasting a transaction and the moment it confirms on the blockchain?
00:02:38.824 - 00:03:48.784, Speaker D: So after you have broadcast your signed transaction, it gets sent to the node which your client was connected to. And after validating that transaction, that node sends it over its peer to peer network to its rest of its peers and then these peers proceed to send it over to the next nodes and so on and so forth. And this transaction then gets stored in an in memory database which we call the memory pool. And the memory pool can be thought of as a bucket of transactions which still have not been confirmed but will be chosen by the miners for confirmation in one of the next blocks. And typically miners choose these transactions in order to maximize their profits. So they would usually take the top, let's say, 100 transactions sorted by the product of the gas that the transaction will pay and the gas price of the transaction and afterwards the transaction will get mined and so on.
00:03:48.902 - 00:03:58.710, Speaker A: So this memory pool, or mem pool in short, is actually transparent for anyone to see. So is there anything that other people can do with the information?
00:03:59.640 - 00:04:54.120, Speaker C: Yeah, so I think there's a few ways that people who are watching the mempool can exploit this knowledge of other transactions and or the ability to get transactions in before others to profit. So one sort of typical such example is when somebody participates in an arbitrage on uniswap. Basically when the price changes, the first person to do a trade on the uniswap pair right after the price of that asset changes gets arbitrage profits. And that's what I would call something like benign mev because it's something that somebody's going to get that profit and it doesn't depend on knowing anything about any other transactions in the mempool. It just depends on being the first one to take advantage of a change in the world's state. But then obviously strategies get a lot more complex and also a lot more potentially. You could call them malicious.
00:04:54.120 - 00:05:34.512, Speaker C: So one would be another uniswap example is if somebody front runs a transaction. And so that would be if you see a transaction in the mempool that has a very generous slippage limit, you can cause that transaction to execute at a worse price by trading ahead of it on uniswap. And then after the transaction you can trade in the opposite direction on uniswap to lock in your profit. And so it works somewhat similarly to how front running works in traditional finance. And it does depend on not only being able to get a transaction in quickly but knowing the content of other people's transactions to do this and that profit ultimately gets taken from the user in the form of worse execution on their trade.
00:05:34.576 - 00:05:39.060, Speaker B: So how common would you say this kind of front running with uniswap transactions?
00:05:40.140 - 00:06:19.520, Speaker C: I think with uniswap transactions the slippage limit, setting a relatively low slippage limit means that on a not particularly big trade, typically it won't be profitable to do this. So it doesn't happen that often. You see it happen when there's really huge trades on uniswap that push the price really far which could make it possible to profitably front run it. And when trades have too generous slippage limits or when the price when there's been positive slippage in which case the front runner can basically take that.
00:06:19.670 - 00:06:34.490, Speaker B: Yeah. So I guess intuitively you would expect when the fees go up, as they are right now, fees on Ethereum are very high right now that the amount of arbitrage opportunities for miners actually goes down for miners, but for frontrunners actually goes down.
00:06:35.180 - 00:06:41.364, Speaker C: Yeah, like the quantity of them for sure. And of course a lot of the high gas prices are also driven by these front runners.
00:06:41.412 - 00:07:20.020, Speaker B: So let's say you are one of those frontrunners. So you actually operate a front running bot. So if you try to front run a trade on uniswap and you see the regular traders transaction in the Mempool, and you just swoop in with a slightly higher gas fee to basically skip the queue and get your transaction mined ahead of them. So that's not really how it works, right? Because if a front runner can front run a regular user, then the front runner themselves can be front runner, right?
00:07:20.090 - 00:08:11.024, Speaker C: So I think there's ordinary users getting picked off by this. But then there's also this war going on at a higher plane between all these front runners trying to front run each other. And that takes the form of you can try to minimize that by having your transaction have exactly the same or just under that gas price, or even exactly the same gas price, and just putting a lot of them in order to hope that it gets included at the same place. But ultimately, yeah, if you confront run something, someone can get in and get ahead of you, potentially blocking your transaction. And so what we see there are these priority gas auctions where when there's a front running opportunity, different bots compete to get it. And it's a costly auction because you have to pay the gas, or at least some gas, regardless of whether you win or lose, because your transaction could still be included and fail.
00:08:11.072 - 00:08:17.124, Speaker D: And this has been empirically seen to be a driver behind the increase of gas prices in the ecosystem.
00:08:17.252 - 00:08:32.588, Speaker B: So I believe the academic term for that is actually an oil pay auction, because even the failed bids pay some amount of gas. And that's a very unusual type of auction that hasn't been studied all that much, right?
00:08:32.674 - 00:09:00.896, Speaker D: But the detail here is that when this auction plays out, let's say there's ten bids for 1.5 million gas at some gas price. Then the people that see that, the ones that would lose the bid, the auction, they can replace their transactions, their 1.5 million gas transactions with a very small gas transaction in order to kind of cut their losses from participating in this auction.
00:09:01.088 - 00:09:07.412, Speaker B: Do you know, maybe off the top of your head, what is the minimum that you have to pay as a front runner for a failed bid?
00:09:07.556 - 00:09:15.916, Speaker D: The minimum would be a 21,000 gas transaction, a normal pay ETH transaction. That's the cheapest transaction you can make.
00:09:15.938 - 00:09:34.496, Speaker B: On ethereum, and that applies only to your last transaction, right? So in a typical priority gas auction, two frontrunners who compete for the same transaction might replace that transaction 100 times, every time bidding a little bit higher. But you don't have to replace all of these transactions, right? Only the last one.
00:09:34.598 - 00:09:56.488, Speaker D: Each time, you're replacing only the previous transaction. So indeed, you do not need to care about all your previous transactions that are unconfirmed because they're all basically the same transaction. You'rebroadcasting the same transaction with the same nons, just with a bigger gas price. So the moment that you replace once all the other previous transactions are gone, right?
00:09:56.574 - 00:11:00.110, Speaker B: Okay, that's interesting. So the way I find this topic so interesting is because it's a game with so many layers. At the bottom layer you have basically users competing with bots for trading opportunities to get their transactions included. And even this layer is invisible to like 99% of users. But on top of that layer you have this game of bots versus bots that we just discussed. But on top of that layer you also have another layer, which is the bots versus the miners. Because if we consider like a very naive strategy in which the bots compete for frontrunner running opportunities against each other, a very naive strategy would be they each basically whenever they get outbid, they raise the bid on their transaction by 10,000 gas, right? And that way basically the price of the transaction gets bid up very fast until it captures the entire Arbitrage opportunity.
00:11:00.110 - 00:11:38.372, Speaker B: And what happens there is basically the Arbitragers get nothing and the miners get everything. So that shows us that there's this big incentive, even though the bots compete with each other and they are actually at war with each other, to also unite against this even bigger enemy, which is the miners. So I would be curious to learn what, if any, strategies do the Arbitrage bots employ to basically enforce cooperation among each other and improve their global outcome against the miners.
00:11:38.516 - 00:12:39.404, Speaker D: So yes, there are ways that you can kind of improve this result by basically finding a way to reduce the number of players in the system such that the auction price doesn't get you don't get all these thousands of failed transactions trying to capture the value. So what you do is that you have to figure out the ways for all these bots to collaborate. So recently a project called Keep It Dao and we didn't say that earlier in the podcast, but nothing we say in this podcast constitutes of any approval or anything of any of the projects that we mentioned. So Keep It Dao did this idea where they say if anybody tries to front run us, we will instantly overbid so that the profit opportunity instantly disappears. So they just say we'll go nuclear. We don't care about you outbid us and we will just make it nonprofitable for you and for us. But they don't care, basically.
00:12:39.404 - 00:13:33.390, Speaker D: And this creates an interesting situation where you are never incentivized to try to beat them. And if they have good enough infrastructure which allows them to always exercise this quote unquote grim trigger, the result is that everybody should cooperate with them and act as a unified entity. And this means that you went from a situation where you had multiple front runners who try to frontrun each other to have a situation where all the bots collaborate with each other, which is a net improvement on the previous situation. You're kind of holding the mev hostage. You're saying if you try to go for our mev, we will kill the mev and there is no more, there is nothing else to take. So that's literally what it is.
00:13:33.840 - 00:13:46.732, Speaker B: Yeah. And not just we kill the mev, but we hit you, but just a little bit. Right. So you as well take a small loss because of your transaction. That your failure transaction.
00:13:46.796 - 00:14:00.580, Speaker D: Sure. But because you're the keeper though, you're a big player and you can keep playing the grim trigger until all the people that are willing to defect are gone and basically you've scared away everyone and then everybody plays by your rules.
00:14:01.720 - 00:14:11.968, Speaker B: Yeah, right. Maya, my point is you need to make it not just zero EV for someone to challenge you, but you need to make it actually minus EV because otherwise they would be griefing.
00:14:12.004 - 00:14:23.020, Speaker D: You correct. Where the minus EV is the opportunity cost from all the gas that you keep paying and the mev opportunities that you are losing.
00:14:23.520 - 00:15:09.756, Speaker B: Exactly. Yeah. Okay. So the event that brought mev back on my radar recently is an article that you two wrote together which showcased what I thought was an amazing case study for what we just discussed, which is actually the earlier stage of this conflict of users versus frontrunners. And I think your article was the most accessible and dramatized also, which made it so accessible to so many people. But article on front running and the mempool that I've ever seen and I think it pulled a lot of people into this topic. Why don't you basically recap what happened?
00:15:09.938 - 00:16:11.090, Speaker C: Sure. So, to set up the story, somebody was a liquidity provider on uniswap on a uniswap pair and they had accidentally sent the uniswap liquidity tokens to the uniswap pair itself. And normally when you send a token to the token contract itself or any token contract, it's usually not recoverable unless there's a special case for it. And my initial reaction when I heard about this from the unisoft support discord was that these tokens were lost. And then I basically jolted awake in the middle of the night realizing that actually the tokens were not only not lost, but that anybody could grab them simply by calling burn on the uniswap pair. And that's because of a detail of how uniswap works. And the key thing here, the reason that this became such a strange nightmare is because any address could do this call and they would get the money, basically.
00:16:11.090 - 00:17:03.136, Speaker C: And so I could do this and I went and checked and the pool still had these tokens in and they worth about $12,000, but anybody else could as well. So I had to do it pretty if I wanted to white hat rescue these funds, I'd have to do it pretty quickly. But then I had heard about something, a story from a few years ago from Phil Dion, who's who's a researcher who studies mev and ethereum transaction shenanigans. And as a result, I knew I couldn't actually do this. And so that was the puzzle that we found ourselves in and that I recruited Giorgio's to help with. So to understand why I couldn't just make this call. The analogy that we use in the post is to a science fiction book called The Dark Forest, which I don't want to spoil on this call, but if you haven't read it, it's a really great book.
00:17:03.136 - 00:17:49.872, Speaker C: It's in the three body problem trilogy. And it has this concept in it of this kind of game theoretic environment of a dark forest. And this is an environment where there are such advanced predators around that anybody who is detected will almost certainly be destroyed instantly. And so a strategy in order to destroy somebody is basically just to reveal their location in the forest. And this was the metaphor that came to mind when I heard about a particular kind of front running bot, a really scary one called a generalized front runner. And we were talking before about the uniswap frontrunners that do this very particular strategy by sandwiching uniswap trades. But there's a lot of mev, and in fact, computing all possible mev would be an impossible is an impossible problem.
00:17:49.872 - 00:18:45.152, Speaker C: But there's a strategy that you can do to grab a lot of it, especially when you're in these circumstances that we were in where anybody can make this particular contract call. So what you do is you watch every transaction in the pool. You run the transaction trace for it, you look at every step of that transaction, every internal call made, and you test, what if I made that call? What if I made that call but changed the parameters to be my address? Basically, you sort of brute force on every single transaction that you see in the mem pool. If I did this, would I make a profit? And if so, then you generate that transaction and you front run it. And this is a common problem for security researchers who are doing something like a white hat hack. I imagine it's also a problem for black hat hackers because it's in the nature of a hack often or of many kinds of hacks that anybody can do them. It's not some specially privileged address.
00:18:45.152 - 00:19:29.792, Speaker C: So I think some require multiple steps and therefore are less vulnerable to this. But this was a case where there was literally an internal call that we would have to make in order to recover this money. And if anybody saw this call, they'd know exactly how to get the money. And so that was the environment in which we were dealing. Know, I felt a little bit paranoid freaking out about this, but I'd heard some horror stories from Phil before about it, and I didn't want to risk this money by doing that. So I called in Georgia to try to obfuscate it. And one high level point I want to make about this is that on chain smart contract security is a really difficult and harsh environment where often if there's money that can be exploited from a smart contract, someone will do it.
00:19:29.792 - 00:19:44.612, Speaker C: But this money had been sitting there. Anybody could have grabbed it by calling a documented function on the contract and nobody had for at least 8 hours. But as soon as we actually tried to, we would get sniped. So the Mempool is an even harsher environment than the Ethereum state itself.
00:19:44.746 - 00:19:47.636, Speaker B: How did you even go about approaching this problem?
00:19:47.818 - 00:20:11.836, Speaker C: So the main thing I did because as I mentioned in the post, I'm a DeFi thought leader who has never actually deployed a contract to Ethereum before I called in some help. So this included a couple security researchers like Sam's Son and also Was, who handled a lot of the actual implementation. So I'll leave it to Georgios to kind of describe what we tried to do and what ended up happening.
00:20:11.938 - 00:21:20.496, Speaker D: Yeah, so the situation is that this is basically a cat and mouse game where you try to make the time until the attacker finds the trace which generates the jackpot. You try to make that time as long as possible so that basically your transaction can get included and get mined. So basically, if you have, let's say that you put a big enough gas price and your transaction would get included, let's say, in the next 15 or 30 seconds, you need to be lucky enough that the attacker doesn't find it. So what we did after given some advice from the people that Dan mentioned, is that we split the process in two. So instead of just saying make a transaction that calls the uniswap function which was required, we said we would have two transactions that are required to make the step to make the rescue. And the two transactions, they would be sent from two different accounts in two seemingly unlinked contracts. But the moment that one of the transactions got included, it would be sort of like a precondition for the other transaction to be also executed.
00:21:20.496 - 00:22:11.532, Speaker D: So for an attacker to be able to kind of extract the winning transaction, they would need to both play the first transaction, then play whatever other transaction that would be in the Mempool, and then also play the second transaction. So you can see that we're kind of trying to do some sort of obfuscation in this procedure. So what we did is that we sent the first transaction with gas price, let's say 100. In reality, that was more like three or 400 due to all the yield farming mania. But that's another story. We sent the first one with 100 and the second one with 80, let's say. And what happened was that instead of using my own local node which had fallen behind for a few days we used Infura as our node.
00:22:11.532 - 00:23:13.304, Speaker D: And what happened is that when I send the first transaction and I also send the second one in the same block, so you don't wait for the first one to get confirmed, you just instantly broadcast the second one. And then what happens is that I got a client side error from the server from Infuria, basically that your transaction got rejected. And what possibly happened was that because when you send it to Infuria or any other hosted service, typically they have load balances. And what that means is that maybe my first transaction got load balanced to one mempool. Sorry, when I say load balanced, it means that they have, let's say, ten computers behind some common unified endpoint. And when you talk to the one endpoint in practice, what this does is that it sends your transaction to one of the other computed. So what possibly happened is that my transaction went to the first transaction, went to, let's say, computer one, and then the other transaction went to computer two.
00:23:13.304 - 00:23:49.076, Speaker D: And because the second transaction required the first transaction to succeed, typically geth would have both the transactions in the mempool, so it would throw no error. But because in this case I suspect that the transactions were in different mempools, it was not able to know that there would be no error. So it simply rejected the transaction, which it was a kind of a bespoke situation for us at that moment. And we were under time pressure because as Dan said, it was already, I think 8 hours or something. It was 02:00 a.m for dan. It was 08:00 a.m
00:23:49.076 - 00:24:06.200, Speaker D: for me. I still haven't didn't have my coffee yet. So we had to get this done quickly before somebody wakes up and sweeps the money. So let's just do it in two transactions. What can go wrong? I explicitly told Dan there's no chance anybody's watching.
00:24:06.270 - 00:24:48.692, Speaker C: Like, come on, yeah, put yourself in our position there. We'd been spending hours trying to engineer around this kind of monster that we'd actually never seen and only knew about secondhand through effects that we know that it has had. And in the meantime, there was this time pressure because anybody could just remove their own liquidity from the pool and accidentally trigger this call. So as a result, we thought the bigger risk was someone doing this. And so we got sloppy and thought look, it's still making a call. This is deep in the call stack. It's making a call to an authorized contract that nobody else can call.
00:24:48.692 - 00:24:58.328, Speaker C: Reading an address from storage, which it is passing to the uniswap pool. We thought that would be enough to prevent the front runners from getting us.
00:24:58.414 - 00:24:59.588, Speaker B: But it wasn't.
00:24:59.764 - 00:25:34.980, Speaker D: No, it wasn't. Because literally the only change was firstly, in the script that you're writing, you say send this transaction, then send the other transaction. And the only change that we did was wait for the so it was send the first transaction, wait for it to get confirmed, and then send the second one. And so we check it, we see the first one get confirmed, we see the second one get broadcasted so we didn't get the previous error. And I'm like, okay, it worked. We won. And then I click the transaction hash, I go to Etherscan, and I get revert uniswap, insufficient liquidity.
00:25:34.980 - 00:26:06.290, Speaker D: And then at that point is like, okay, we got wrecked. And then we go and Dan finds the transaction which Front run us. And it is this kind of monster of a transaction which has 20 self destructs in it, and it somehow transfers 12.5 or whatever the amount was to the attacker. And it was a pro. The Etherscan account had hundreds of thousands of dollars. It had multiple transactions in the past days.
00:26:06.290 - 00:26:13.090, Speaker D: It was literally something completely automated and not by some random person.
00:26:14.100 - 00:26:22.484, Speaker C: And those self destruct, as I understand them, are from gas tokens. So that's another thing, a tool that Frontrunners use in order to reduce their.
00:26:22.522 - 00:26:31.288, Speaker D: Gas costs, for which, incidentally, Phil Diane, who is the author of all these Mev papers, is also one of the.
00:26:31.294 - 00:26:41.880, Speaker B: Co creators of if the second transaction would have been picked up by the infuria Mempool, would it have worked, your idea? Or is it speculative?
00:26:42.300 - 00:27:05.888, Speaker C: We don't know that it would have worked. It probably would have had a better chance. But if the attacker was able to just basically construct a representative block every second and run the transactions in it and do this process on it, and they could do this potentially massively in parallel, then it wouldn't have stopped them. The hope was just to slow them down for a few seconds, because the.
00:27:05.894 - 00:27:38.380, Speaker D: Idea is that the attacker just applies the Mempool state on their local state all the time, and they try to see, is there a profitable opportunity here? And then they literally take all the internal calls that the function created, that the call made, and they just say, okay, this makes me money. I can change this parameter, and I will execute it as a standalone transaction. Imagine that our transaction did a bunch of things, but he took the one little piece that they needed to extract the profit.
00:27:38.800 - 00:27:57.744, Speaker B: Your strategy was basically so you have a generalized schront who does a complete simulation of every transaction to see if they can make money by taking your transaction or transactions, mutating them and replacing them all with their own address or.
00:27:57.782 - 00:28:08.484, Speaker D: A subset of our transaction, because a smart contract call can do ten things. So they don't need the whole transaction. They need the one little piece which will make them the money.
00:28:08.602 - 00:28:44.780, Speaker B: Yeah. So your strategy is basically to make that simulation more costly for them and take longer. And then you hope that basically so the block discovery process in Ethereum, that's also something unusual for an auction right. Because you never know when the next block is going to be found. It could be in a second from now, but it could be in 30 seconds from now. And both are sort of equally likely, actually. So you hope that you make the simulation of the front journal take a little bit longer and then also for a block to come in before they finish their simulation.
00:28:44.860 - 00:29:46.128, Speaker C: Yeah, that's right. Ultimately, I think we could have done better on this obfuscation, but this kind of obfuscation is an arms race that the white hats are destined to lose. And the reason is it's just sort of a fundamental law here that for your transaction to be included before the front runner is able to get it, some miner has to produce this block and be able to run this block and validate it and mine on top of it and broadcast to the world before the attacker can. And so I think sometimes you'll get lucky. But winning those races, I think in general, is probably going to be a losing battle. And this is something where in this particular case, the fact that it was an internal call that anyone could make, there's basically nothing we could have done to actually make it impossible or really hard to compute. There's nothing we could do to make it harder really to compute for the attacker than for an honest minor or at least not much harder.
00:29:46.128 - 00:30:10.184, Speaker C: So that's kind of the fundamental limitation here of the obfuscation strategy. So if we'd known a minor or if we were able to mine a block, that probably would have been the better strategy, and that would be to directly submit the transaction to somebody who could include it in a block without it ever being propagated through the mem pool. And so in that case, it would still be possible for someone to rewrite.
00:30:10.232 - 00:30:21.280, Speaker D: Not just knowing a minor, but also guaranteeing that the miner does not broadcast the transaction to other miners or users. Mempools right. Yeah.
00:30:21.350 - 00:30:29.596, Speaker B: So I don't think that would be a smart broadcasting policy by a miner to broadcast their transactions. That would put them at a competitive disadvantage.
00:30:29.708 - 00:30:49.384, Speaker C: Well, most miners do when you submit a transaction to a minor. Typically they do, yeah. So one reason they do is in order to make the execution of their blocks faster because if people have already seen the transactions, potentially, although I got to take that back because that's not true in Ethereum because you have to run the whole block. That's true. On Bitcoin. It's not true. Yeah.
00:30:49.422 - 00:30:54.200, Speaker D: This only happens on Bitcoin because they apply the UTXOs as they arrive.
00:30:54.540 - 00:31:07.330, Speaker C: Right. So cancel what I said. But this actually is the policy that most miners do. So, like, Sparkful has an API that you can submit to, but it will broadcast it to other ones. I don't know why they do this, actually.
00:31:08.820 - 00:31:17.780, Speaker B: Do you think there are any white gloves service. For basically broadcasting a transaction exclusively to a bunch of money pools.
00:31:20.200 - 00:31:40.360, Speaker C: We haven't found one, I haven't seen one, and nobody in the security community that I've asked about this problem has seen one. It's mostly done, I think, bespoke by individual miners with people that they have relationships with. I think it would be a great service, but it's kind of a very niche service. It would really be primarily for like, white hat hackers.
00:31:40.860 - 00:31:47.044, Speaker B: I see a ton of opportunities for a service like that. So I think someone should definitely do it if they hear this podcast.
00:31:47.092 - 00:31:49.164, Speaker C: I hope they do. I hope they do.
00:31:49.282 - 00:31:49.516, Speaker D: Yeah.
00:31:49.538 - 00:33:11.140, Speaker B: And I mean, this brings us kind of brings us back to what you said earlier, right? So this is a race that the good guys are destined to lose because one of the reasons is that if there's like a $10,000 arbitrage opportunity, then the bad guys are willing to spend up to $10,000 to get this. But I mean, the owner of the $10,000 also should be in theory, but in practice they are not. And the WiFi hackers, they never are, right? So they don't have any funds to spend on securing someone else's money, typically not unless there's some insanely reliable bug bounty or whatever, some way for them to recoup the losses. So that's like one reason, I think, why and we've seen this with BZX the last days. They had a bug exploited and Whitehead actually found the bug and they didn't pay out the bounty. And I just think it's shocking and extremely poor foresight to basically make it so that people are not willing to recover funds for you in the future. Right, so, anyway, so we already touched on briefly that there's another layer of the game on top of the ones where the bots play against the user and the bots play against the bots, and then the bots play against the miners.
00:33:11.140 - 00:33:38.080, Speaker B: But there's actually one that is the reason why some people are very worried about mev as a concept. And to highlight this, I picked out a tweet that you sent out a few weeks ago, George, and it says good day to everyone except those that do not think mev is a serious threat to the stability of Ethereum and other chains. So what do you mean by that?
00:33:38.150 - 00:34:32.048, Speaker D: Firstly, let's just say that all of these attacks that come around inserting reordering transactions by front running and so on, miners can do them for free. Miners are the ultimate. They hold all the cards in this game. And mev is the minor extractable value. It's how much ETH a miner can account given a set of transactions, some state and some contracts. And they can just get it by inserting transactions, censoring transactions, or reordering transactions. Right? So today it's the users or the bots doing the reorders, but eventually miners will wake up and they will either do this themselves or they would outsource this to some service that does it for themselves.
00:34:32.048 - 00:35:58.904, Speaker D: And you will periodically, I think that eventually we will start hearing more publicly about such services popping up. And basically the issue, the big danger of mev towards the stability of Ethereum is the following. So what they can do is that they can kind of start reorganing like doing multiple forks of the chain as blocks arrive in order to get mev, which was already extracted in a previous block. So let's say that we're at block, let's say ten and there's $100 of mev at block eleven, and then block Twelve gets mined by some minor. I as a minor, I am incentivized to reorg out block twelve and block Eleven and remind the transactions of block Eleven with some reordering or some censorship or some of my own new transactions in a way such that I profit. And so this results in me canceling out two very legit blocks in order to improve my profit. It is the sort of attack that you will hear that miners won't do because it is against their interest, because it undermines the chain's stability.
00:35:58.904 - 00:36:13.904, Speaker D: Kind of like how selfish mining works. But this kind of time bandit attack where you reorg past blocks in order to extract already extracted mev is a particularly dangerous one.
00:36:14.022 - 00:37:14.848, Speaker B: Let me actually say something very briefly about time benefit so because I actually had a big change of mind about this topic. So something about the difference between Bitcoin and Ethereum. So in Bitcoin, when a miner reorganizes the blockchain, and let's say they go back ten blocks and they remove one transaction, replace it with another, right? For example, a classic double spin attack, what happens there is that all of the other transactions go back into the mempool and then they just reconfirm again in the same order. So basically in Bitcoin, nobody except in very rare circumstances is even affected by a double spend that would target an exchange. And that's generally true for UTXO based chains. But can you describe how that is different in a stateful chain such as Ethereum?
00:37:14.944 - 00:38:11.200, Speaker D: Right? So this happens because Ethereum's transactions are much more interlinked in a way. So in the UTXO model, you add some inputs to your transaction, you destroy these inputs, and you create some new outputs while in the account model. So this means that the transaction is solely limited to the data that you pass to it. While in the account model, your transaction is very much dependent on everything else that happened in that block. Because, for example, maybe, I don't know, maybe you had a price. Let's say that you made a trade on uniswap and because there was some other transaction that happened before your transaction on uniswap, it gets outside of your slippage limits, which ends up reverting your transaction. While this kind of thing would never happen in Bitcoin or a UTXO kind of chain.
00:38:11.200 - 00:38:14.260, Speaker D: So I understand that this is what you meant.
00:38:14.420 - 00:39:03.236, Speaker B: Yeah, exactly. So in Ethereum, in Bitcoin, all the transactions would replay just fine and users would be unaffected. But in Ethereum, people who have nothing to do with the attack could see their transactions reverted, like without any fault of their own. So we can see why any kind of reorg in a chain like Ethereum would have a much more destabilizing and harmful effect on users than it would have in Bitcoin. So that is my first point and a second thing that I've changed my mind on recently. So we've seen attacks described that are like fee sniping, for example. This is very similar to the Time Bandit attack is where basically, instead of building on the block of another minor, a minor would go back and fight again for the same reward of that block.
00:39:03.236 - 00:40:36.340, Speaker B: And there's a pretty easy solution to that to prevent that kind of thing from happening, which is the original miner doesn't keep all the fee to himself if he thinks that other miners are not incentivized to build on that block. What he does instead is he takes the reward, but then he pays some of it forward in the form of anyone can spend transaction, which is any kind of coinbase reward is an anyone can spend transaction. So any other miner, especially incentivized to build on their block that has the big reward by getting some of that reward in the future. And I always thought that you can solve basically Time Bandits attacks in that way as well. So if there's a block that has a lot of mev, then a miner was worried about their block being reoccurred, they would just pay some of that reward forward for, let's say, the next 20 blocks in order to ensure that their block is very 20 blocks deep. But there's actually a special case, and I think that's actually the reason they invented the new name for this. The Time Bandit Attack, is when you don't actually know how big the reward in these more stateful chains is going to be ten blocks from now, 20 blocks from now, because you have all these Dex trades going on and Liquidations and so on, and so many different Assets Moving Against each other.
00:40:36.340 - 00:41:10.236, Speaker B: So and if you imagine that, for example, there is a front run opportunity for, let's say 1000 east now and it's not worth reorgang for the other miners, but then ten blocks later, suddenly the price of ETH doubles, what happens then? The reward of going back in time and actually taking that arbitrage opportunity now has doubled. And that's the kind of risk that you have in Ethereum, but you may not have in Bitcoin.
00:41:10.348 - 00:41:45.988, Speaker C: Yeah, I mean, I think this is one reason why actually we haven't seen yet very much apparent mev extraction by miners is that it's an extremely specialized activity that right now is effectively outsourced to these front running bots and ultimately goes to the benefit of miners. I mean, minor fees are way up, in part likely due to mev extraction. But we think in the future that miners are either going to get savvy on this or they're going to find other ways to outsource it that resulted more value capture for the miners.
00:41:46.084 - 00:42:33.436, Speaker B: Yeah. To anyone who's listening to this episode now, I think it's important to acknowledge how early we still are in the game because you look at this game that is rigged incredibly hard in the favor of miners. So basically nobody should or almost none of this mev, all of these front running opportunities and so on should go to anyone else but miners. But in practice, only a small amount of it does. And that shows you how inefficient and unoptimized miners are in Ethereum today and how much they're still to gain for them. So do we have any idea how big mev is? Are you aware of any ways or heuristics to measure it?
00:42:33.538 - 00:42:59.896, Speaker C: So I think one estimate for it would just be transaction fees, which is, of course, literally minor extracted value. So total transaction fees on Ethereum way up, I think it's been around $3.5 million a day for the past week, which is far higher than Bitcoin's fees. Yeah, I think that's sort of the clearest. And in some sense, every transaction, every fee paid by any transaction is minor extracted value. Right. From the estimates.
00:42:59.896 - 00:43:41.264, Speaker C: I've seen some estimates and I don't know how accurate they are, that the actual amount of mev that's potentially extractable is orders of magnitude higher than that. And some of that mev may require doing things that bots can't do. And that would be, for example, censoring transactions entirely across a period of multiple blocks or reordering transactions not according to their gas price. And so these kinds of if you sort of extend mev or obviously double spending and even reorgang a chain, these are things that really sort of only miners can do and that potentially could be massively profitable or of course, could destabilize and destroy the chain just from a high level.
00:43:41.302 - 00:43:50.196, Speaker B: Where does mev come from? Like, when you look at a chain, what are the attributes of that chain that you look for? To predict that this chain is going to have a lot of mev, this.
00:43:50.218 - 00:43:52.512, Speaker D: Chain doesn't smart contract.
00:43:52.656 - 00:45:08.380, Speaker C: I think specifically the property of Bitcoin. That means that there's much less mev other than explicit rollbacks and double spends, is the primary property for that, is that there's very little contention. There are very few cases in which I send a transaction and whether it gets included or not, whether it's valid or not, depends on whether someone else sends a transaction at the same time or sooner and beats mine. If I'm spending my own funds, if I'm just spending on my own UTXO, there's literally nothing that anyone can do to prevent it from being included other than obviously censoring the base layer because there's no way to make a transaction that conflicts with it. Some Bitcoin transactions, like multi sigs or transactions that spend from different UTXOs controlled by different parties, potentially could be invalidated by other parties. And in something like a suma auction, which is a protocol designed by James Preswich for cross chain Dutch auctions between Ethereum and Bitcoin, there's sort of a protocol there that could potentially create a little more contention. It's not technically impossible in Bitcoin, but it's so limited.
00:45:08.380 - 00:45:12.430, Speaker C: Bitcoin is so limited what you could do that most transactions don't have.
00:45:14.320 - 00:45:21.772, Speaker B: So, Georges, do you know how layer twos interact with this? Would the lightning network, for example, create more mev on Bitcoin?
00:45:21.916 - 00:46:51.016, Speaker D: Yeah, exactly. So something I wanted to touch on is that any protocol that involves dispute transactions which must be included within some time in the chain, which means anything involving Lightning, the recent coin swap proposal for Bitcoin, for privacy, all of this, they involve timeout windows, everything. Layer two in Ethereum, including roll up state channels, plasma, whatever has been designed in the recent times, aragon has been having some ideas around how to do some optimistic mechanisms which introduce disputes. All of these mechanisms, they directly increase the amount of mev in the system. So today, to answer the question, yes, the existence of Lightning increases the available mev in the system by the exact amount that you can dispute for inside the Bitcoin transaction. So if there's a channel with, let's say, 10,000 Bitcoin or ten or whatever, the moment a dispute transaction about this, rather not a dispute, a stale channel, close transaction goes to chain, there must be either a justice transaction included within some time or there must be some cooperative closed transaction. If none of this happened, the money gets lost.
00:46:51.016 - 00:47:16.660, Speaker D: And so the big danger in this is that the miner can just say, I never saw these transactions or well, censor these transactions, which in the end means that this is a chance for a miner to get bribed either out of band or via some output. And, yeah, this creates increased mev opportunities in Bitcoin.
00:47:17.960 - 00:47:45.416, Speaker B: Yeah. So, Dan, you already mentioned that there can be malicious forms of mev. And the way I understand it, so these are the ones that would actually incentivize miners, destabilize consensus for users, and then you have benign forms of mev. So let me ask you, can mev be good for blockchain security as well, or is it purely negative?
00:47:45.608 - 00:48:46.524, Speaker C: Right, so benign mev happens is going to be there regardless of whether anybody's doing any of these strategies. So the first trade on uniswap, it's got nothing to do with monitoring the mempool or with Censoring transactions. It's just something that somebody's going to get. And the only question is who, if miners were able to effectively extract this benign mev, if miners or someone else, like Keeperdao or like Optimism's sequencer, which, full disclosure, we're investors in optimism paradigm is. But if one of these parties were able to extract this kind of benign mev, then potentially it could be used to either secure the chain or fund sort of other public goods that are beneficial ultimately to the chain, keeping the chain safe.
00:48:46.652 - 00:49:59.240, Speaker B: Yeah. So I already gave two things earlier where I recently changed my mind by thinking more about mev. So I actually, until like, a few weeks ago, had this a pretty extreme position on mev, which is that most mev is benign mev, which is something that I still think and benign mev directly contributes to the minor rewards in a vastly non destabilizing way, and thereby it secures the blockchain. And if you combine this with this previous gap that we had in practice, in theory, the mev that can be captured by miners is like magnitude higher than it is today, then shouldn't this mean that we can secure a blockchain purely by mev? So if you think this, like, all the way through, then could you, in theory, have a blockchain that does not have a block reward, that not only not has a block reward, but maybe even has some kind of deflation or something, right. Isn't that like the perfect kind of blockchain?
00:49:59.740 - 00:50:42.792, Speaker C: So my answer would be yes. But it probably requires changing how ethereum works, because if all transaction fees go to the miner of the current block, then there's this very destabilizing influence where miners could reorg each other in order to fight for those transactions unless they pay it forward. Right. But if you can mandate that they do, if you can take some of these transaction fees and spread them out over subsequent blocks, then potentially that could be a more consistent, more positive effect on stability. And so I think Georgia's can talk a little about EIP 1559, which is a proposal for upgrade ethereum that does something like this and potentially could have this effect.
00:50:42.846 - 00:50:44.888, Speaker D: How does it help with MAV in this case, though?
00:50:44.974 - 00:50:50.888, Speaker C: Because it means some transaction fees will be spread out over multiple blocks. You burn them. Right?
00:50:51.054 - 00:50:51.770, Speaker B: Yeah.
00:50:52.140 - 00:50:54.344, Speaker C: And there's a block reward that gets distributed.
00:50:54.472 - 00:50:54.908, Speaker B: Yeah.
00:50:54.994 - 00:51:01.096, Speaker C: So in effect, you're securing the chain by making the block reward more valuable.
00:51:01.288 - 00:51:02.396, Speaker D: Let's repeat that.
00:51:02.498 - 00:51:11.168, Speaker B: On the one end you're burning the rewards, and on the other you are distributing them, but over a longer period of time and in an extremely consistent way.
00:51:11.334 - 00:51:13.232, Speaker D: How is it in a longer period of time?
00:51:13.286 - 00:51:29.430, Speaker B: Because well, I guess it's still wrong in the sense that only the base fee is burned in ERP one five nine. Whereas mev is not really in the base fee, it is in the correct.
00:51:31.400 - 00:51:36.536, Speaker C: That'S a flat tax on Andre. I think it would matter.
00:51:36.638 - 00:53:15.656, Speaker B: I have no doubt in my mind that ERP one five nine is very beneficial for blockchain stability because it creates this consistent incentive for the blockchain to move forward and it removes some of this destabilizing effect that transaction fees have that we also discussed. So totally right. One other thought. So if we think that all benign mev makes the blockchain more secure and could be used on the other end to lower like the block subsidy which means there's less inflation for holders and so on. And earlier in the podcast we discussed that there's a game going on between frontrunners and miners. And right now the miners capture only a very small amount of the possible benign mev that they could capture because the frontrunners are way more like, I don't want to say intelligent, but they are way more developed and sophisticated and way better at cooperating with each other so far. So shouldn't we as users or not as users maybe, but as people who think about ethereum and develop products on it and so on, shouldn't we want miners to get all the benign mev? Shouldn't we try to make that a reality? In what sense do we benefit if a front runner extracts value from users? I mean, if miners get it, there's like a very strong case that this is positive for users because it secures the chain and it can be used to reduce inflation on the other side.
00:53:15.656 - 00:53:20.520, Speaker B: But if frontrunners get it so this, in my opinion, is actually way worse.
00:53:21.020 - 00:54:12.940, Speaker D: So I would agree with the general thinking, but I think that it is based on a flawed assumption that firstly there is only benign mev. And secondly, even if there is no benign mev that you're able to separate programmatically between benign and non benign mev. So the issue that I see is that the kinds of malicious mev there is a very gray line between the two, at least on a programmatic level. Because, for example, imagine that you censor a CDP liquidation transaction so you don't let a CDP get liquidated. Or for example, you censor an Oracle update in order for a CDP saving transaction to get included. Is that benign mev or is that malicious mev?
00:54:14.160 - 00:55:17.264, Speaker C: That's funny, my definition, my categorization, and I'm not 100% sure on this, but between basically benign mev and what I would just call non benign mev would be that benign mev does not depend on knowing anything about transactions that would be included after the transaction that you are including. And so being the first trade on uniswap in a block has this form where it's a strategy that does not depend on knowing anything about the transactions that come after oh and then also don't depend on blocking transactions censoring transactions from being included within one block. And so if you limit your strategies to only ones that don't have foreknowledge of subsequent transactions, then I think that filters for only benign mev. For only the kind of mev that's like being the first trade on uniswap in a block where someone's going to get it and you're just winning a race for it.
00:55:17.302 - 00:56:14.208, Speaker B: So I would actually go back to what George just said. So I don't see why we actually need for what I said, for this idea we should distribute more mev from frontrunners to minors. So I don't see why we need to distinguish at all between benign and non benign mev. Because the front runners can only capture benign mev, right? So by definition so they can only of the three things that mev that generates mev, they can only insert transactions whereas miners can insert, they can censor and they can rearrange. Right? So those three things so the front runners by definition have only benign mev. So whatever mev we shift from front runners to minus is thereby by definition 100% benign and the non benign MVP can be captured by minus anyway.
00:56:14.294 - 00:56:14.592, Speaker D: Right?
00:56:14.646 - 00:56:33.956, Speaker B: So that would be my thinking. But this brings us just in general, this topic of distinguishing benign and non benign mev brings us to the final part of this podcast actually, which is if we could, would we want to mitigate mev?
00:56:34.148 - 00:57:15.590, Speaker C: I think I agree with you that mev going to miners is very probably better than mev going to frontrunners. I think certainly for especially some kinds of mev, it's bad for the users ultimately. I think arbitrage, by the way, is not this like a user typically trading on uniswap. An end user wants there to be an accurate price and so if it's just sort of a random retail trader, noise trader, then Arbitrage is at least as likely to help them as it is to hurt them in terms of their execution. Yeah, arbitrage on uniswap plays a very valuable role and so that's going to be there no matter what.
00:57:19.180 - 00:57:40.588, Speaker B: Sorry to interrupt, but to give an even more clear example, if you have a CDP in Maker and you're about to get liquidated, you want the keepers on chain which are by definition front on us, right? So you want them to be as efficient as possible to liquidate your collateral as soon as possible so you get a better price.
00:57:40.754 - 00:58:30.616, Speaker C: A lot of Ethereum depends on there being these incentivized actors out there that are watching the chain and doing all this work and that's why a lot of these systems can be as simple as they are. I think. As far as the other kinds of mev, I think some it would be better to reduce or have them redistributed basically to the users. Some I think potentially it could be worth it to have the miners still extract them. I think certain kinds, particularly censoring transactions is the sort of thing that we really just hope a system like this does not have. And ultimately Ethereum, I think would basically have failed. I'm sorry, I think Ethereum would have failed.
00:58:30.616 - 00:58:46.892, Speaker C: If even a benign entity has the power and makes the decision to include transactions at all on the chain or not, that's sacrificing some fundamental principles that regardless of the value being extracted or where it's going, potentially damages the entire.
00:58:46.966 - 00:59:50.544, Speaker D: Experiment in my opinion. And from past discussions I believe there are three types of high level techniques that you can use to mitigate mev. Firstly, obfuscation. So firstly, our dark forest for example, case is a situation where you try to separate your transactions in some way so that they don't look like they have an mev opportunity behind them. Another thing that you can do is some form of commit and reveal scheme. So first you would commit your transaction on chain so that it doesn't look like there's some mev to be extracted and then the moment that you reveal it, the ordering is already committed to and this is related to the second type of mitigation which is the separation where you want to separate execution from ordering. And there's more or less kind of like three techniques which you can use for separating execution from ordering.
00:59:50.544 - 01:01:00.008, Speaker D: And they're all based in the fact that the miner or the block producer in the proof of stake or whatever, they don't know the clear text transaction before they have committed to its ordering. So basically what they all do is that in one case you can say that I will have a verifiable delay function, the miner receives a transaction encrypted and they can only learn the clear text transaction, let's say 15 seconds later, but they must commit to the ordering of the transactions in that block, like now. So basically you just enforce that they commit to the ordering now, but they only learn the content later. And you can also assume that any transaction that gets submitted encrypted and ends up being an invalid transaction gets interpreted as a no op so nothing happens. And anytime that you do this kind of encryption with verifiable delay functions there's also its counterpart that you can also do it with threshold encryption. Similarly to how you can say that you can do secure randomness either with verifiable delay functions or with threshold encryption. They're more or less counterparts of the same solution.
01:01:00.008 - 01:01:34.680, Speaker D: And the third way that you can do this is by just saying that the block proposer before they include your transaction. They promise you by putting up a security bond. They're saying here's ten Ether that I will include your transaction at index number five in the block and then the block gets mined and if your transaction was not at the index that they promised you to they will get slashed. Yeah, and then there's another way which I'm not a huge supporter hold on a second.
01:01:34.750 - 01:01:47.784, Speaker B: So before we move on to the final method, I would have a few questions about separation. So are these generally techniques that you can use on any layer, including layer.
01:01:47.832 - 01:02:47.372, Speaker D: One, assuming that your layer one is built with this in mind. So doing this on Ethereum or Bitcoin, they would require a fundamental change or okay, I believe that what you could do in Ethereum is that you could have a smart contract which does the following. The Miner puts up a bond on a smart contract and says that this transaction hash will be at this transaction index. And I'm just making up the protocol as I go. And then after the block is mined, the user would then take the merkel Patricia proof of inclusion of their transaction and they would post it on chain if the index did not match. And this is doable because you can access the block hash via smart contract and you can also provide emerick proof which shows that your transaction was included in that specific block. So I believe this is doable.
01:02:47.372 - 01:03:02.964, Speaker D: So the proposals offering receipts and bonds for transactions at a specific index I believe is Doable on Ethereum, not Doable on Bitcoin. The time lock and threshold encryption ideas, they both require consensus level changes.
01:03:03.082 - 01:03:13.824, Speaker B: So does the mev auctions that are being pioneered by optimistic rollup also fall into this category of separation?
01:03:13.952 - 01:03:24.076, Speaker D: Not exactly. I think they fall more in the bundling and batching kind of situation. Although Dan is more familiar that so you can chime in here.
01:03:24.258 - 01:04:49.796, Speaker C: Yeah, the sequencer component of optimism system is something that could be done on layer one as well. I think the fact that it's combined with the optimism roll up gives some benefits. But the basic idea, yeah, is that if you have someone who's responsible for sequencing transactions, who basically has to sign every transaction for it to be included before particular on the fast track, on the fast path for transactions, then you can provide a lot more assurances, soft assurances, but assurances to users about the ordering of those transactions. And that could prevent these kinds of mev. But that requires the users essentially opting in and or actually the contracts themselves have to opt in. Because if there's another way to call this contract that doesn't go through the sequencer or doesn't go through something like a another way to do this would be Starkware has full disclosure, where is another company we're invested in has a project called VDO, which is basically VDFS as a service. And so if you just had somebody instead of having a sequencer, you just said every transaction has to have a VDF on it and go through this smart contract that could potentially prevent the same kind of thing, but only if the contract opts in.
01:04:49.796 - 01:04:58.730, Speaker C: So this wouldn't have helped us with the uniswap situation that we had because that contract doesn't have this kind of constraint on it. Anyone can call it.
01:05:00.060 - 01:05:12.652, Speaker B: I see, but you could in theory build like Unisor version three in a way or Unisor version four or whatever in a way that requests specific contract, but it has to go through a sequencer in order to call it.
01:05:12.786 - 01:05:22.960, Speaker C: Yeah, I think that's certainly any contract could be built in a way where the rules for accessing it are gated by either something like a VDF or something like a sequence.
01:05:24.180 - 01:06:01.084, Speaker B: So the way that I understand. The concept of an mev auction is that you auction off the right to order the transactions separately. This is also basically the first time that you can measure how high mev even is in a market based way because you have a free market for bidding on that mev. And if you assume that not the cartel, that the price is like price discovery, then you would actually discover the true price of mev. Would you agree with that?
01:06:01.202 - 01:07:06.400, Speaker C: Right, so, yeah, the mev auction concept, which was proposed by the optimism team, if you did sort of like a pure auction on a per block basis per minute, basically, where anyone can be the sequencer for the next minute paying for it, you potentially could get a much more accurate price per mev. I think the solution that this is sort of a future potential part of something that could be done with optimism, it's not part of the initial system and the details aren't really all worked out. But I think is more likely to be gated in some ways. And rather than just being a free for all auction precisely in order to avoid the really most malicious forms of mev. So having something like a whitelist of participants who can be removed by governance, so that's the sort of thing but I think you still potentially learn a lot about how much mev there actually is potentially on a chain.
01:07:07.540 - 01:08:13.688, Speaker B: So another question that I would have about optimism so I don't know if that's still on the roadmap, but in the original idea, the proceeds from auctioning of the sequencing rights would be used to fund basically public goods on Ethereum. And I'm skeptical why anyone would use this chain when you could also just fork the chain and pay the mev back to users. For example, this concept is very established, right? So for example, traditional finance, you have exchanges where basically the worst kind of users get paid back from running efforts of the stronger traders. And I believe this is even something that is implemented today in synthetics, for example. So why wouldn't such a version of the optimism chain be vastly superior to the one that just gives away the money?
01:08:13.854 - 01:09:11.540, Speaker C: It's tough to discuss because I think it's all very uncertain exactly what these things will look like, so and it's hard to discuss without more detail. I think in general, the answer to why won't someone just fork away something that does something good into something that's that's that's more neutral or doesn't do the positive thing, but it's slightly more profitable, I think is spontaneous order. Like ultimately things like roll ups have pretty strong network effects and you basically only want to be on a roll up if there's other users on it. And so even just a relatively small fuzzy factor like having not just not extracting malicious mev, but also but redistributing the benign mev to positive goods, I think could potentially be enough to make that the shelling point for everyone to use that roll up. And I think it might be tough to fork that interesting.
01:09:11.710 - 01:09:32.400, Speaker B: Yeah, I think that's a very good explanation. So in terms of mitigation, so we discussed, you can obfuscate basically your transactions in Ethereum, or you can try to separate execution from the transaction ordering. So what is the third field that you can do?
01:09:32.550 - 01:10:23.180, Speaker D: Both what Roll up does and what you can imagine that you have a service which aggregates transactions and puts them on chain is that the Grand Golf creates a bundle. Which means that either all transactions in that bundle would get included, confirmed or none of them. So basically what you do is that you would batch together a bunch of transactions and you try to enforce this condition. So what you do is that you enforce that the ordering happens off chain and then any kind of attempt at interfering with the ordering fails and that's it. So you make a bundle and you say, anybody that tries to touch this bundle and reorder it invalidates the bundle.
01:10:23.260 - 01:10:58.060, Speaker B: Let's assume that you have sequencing service that is off chain and users submit their transactions to it. And maybe there's also a Commit, Reveal scheme or whatever to make sure that the actual operator can't change the order of transactions and then that service bundles the transactions and publishes them to Ethereum. So why can't at that point a miner look at the bundle and just unbundle it and rearrange it in any order they want?
01:10:58.210 - 01:11:31.092, Speaker C: Right. So I think that's a case where you need the individual users and then potentially the contracts in some cases to opt into this. So you could do it. If the users opt into it, then at least their signature won't be valid. It won't be an independently valid transaction from them. It'll only be valid when basket with these other transactions. So basically if the user opts into this but then in other cases where it's like front running yes.
01:11:31.092 - 01:11:47.020, Speaker C: There's no reason someone couldn't front run the whole batch. And there, I think as its own transaction and there the hope is that basically the transactions within the batch cancel out and all happen atomically and in sequence, guaranteed. So that mitigates it to some extent.
01:11:48.320 - 01:11:52.696, Speaker B: Okay, so that is very similar to what you said earlier about uniswap and optimism.
01:11:52.808 - 01:12:05.600, Speaker C: Yes. But that sort of system is not going to save you from the generalized front runners because they can still read through the entire internal call stack of that of that batch.
01:12:06.980 - 01:12:07.404, Speaker B: Okay.
01:12:07.462 - 01:12:07.684, Speaker D: Yeah.
01:12:07.722 - 01:12:15.732, Speaker B: So something that you can't prevent is when there's an opportunity that anyone can take, they will still take it.
01:12:15.866 - 01:12:16.500, Speaker C: Yeah.
01:12:16.650 - 01:12:52.428, Speaker D: These are all funny implications of the blockchain's main feature. That is the transparency. Because all the data is out there. That means that anybody can just go and pick them apart and reconstruct them in any format that they want and use them to their advantage. And from a first principles perspective, that's why the solution with the encryption of the transaction feels like it's the most proper one because it exactly tries to basically force the ordering to happen at a time when nobody knows what is inside the transaction.
01:12:52.524 - 01:13:54.164, Speaker B: So maybe for the last question to zoom way out. So neither Bitcoin nor Ethereum have been designed with the goal of fair transaction ordering in mind, in the sense that there's zero guarantee that transactions are ordered in the actual sequence that they came in to miners. And that is basically the whole reason why we have to talk about this. So do you think that there's going to be a new generation of blockchain? And I'm very careful even to entertain these ideas because Bitcoin and Ethereum have such strong network effect and it's so hard to make something that's like ten X better. But if I had to pick one thing that could be ten X better one, or the one or two things that would be that would be like fair transaction ordering. So do you think that's even possible? And how likely is that, that we see something like that?
01:13:54.282 - 01:14:41.952, Speaker C: I think it's possible. I think it's also possible that this happens on layer two on Ethereum. And I described ways that this could work with optimism or starkware. I think ultimately any solution, this is something that Bitcoiners used to say was, oh, if anybody just creates a better feature, we'll just add it to Bitcoin. And they don't say that anymore because nobody adds anything to Bitcoin anymore. But I do think on Ethereum it's very hard to change Ethereum, but it's very easy to build something on top of it. And so hopefully if some other blockchain finds a way to solves this problem, then potentially that will help users on Ethereum as well because someone can build that kind of system on top of Ethereum.
01:14:42.016 - 01:14:50.772, Speaker B: Okay, guys, so I thought it was just an amazing discussion and I'm so glad that we did this. Thanks guys.
01:14:50.906 - 01:14:52.148, Speaker C: Thanks for having us on.
01:14:52.234 - 01:14:52.610, Speaker D: Thank you.
