00:00:13.210 - 00:01:08.958, Speaker A: Of Novic Labs, where we build this tool called Bibler. It's a smart contract development task runner, and we recently launched Bidr EBM. It's a a test development network, I mean a development network which has this very interesting feature that whenever your transactions are gold phase, it generates a solid factory. And this presentation is going to be about how we do it up. But going back to the beginning, let's talk a little bit about how solidity dividends has evolved. For me, this started on 2017. I was a bitcoin maximalist or recovery maximalist back then, until one of my friends, Manu, convinced me to join them to build their first DAP.
00:01:08.958 - 00:02:09.320, Speaker A: And I knew nothing about Ethereum, but I began reading about it, got super excited again about crypto, and started building this stuff. And I wasn't in charge of the smart contract, so I knew nothing about solidity, just doing some front end stuff. And the day came where I finally had the smart contracts to integrate them, and the first thing I tried to do was the most basic thing, just send it to the contract from my UI. And I was super happy about that, but all I got was invalid opcode and what the fuck was going on. Invalidoco. I was sure that I was using the right compiler, how can I have it? Invalidoco I wasn't doing anything with locals, I wasn't modifying the contract, just compile, execute. Invalidoco, no sense.
00:02:09.320 - 00:03:19.740, Speaker A: So I must have spent at least one day trying to figure out what was going on until my friend Manu again came and told me, oh, invalid code, there's a new keyword now payable. If you don't add payable to your smart contracts, you can't send it to it. And he was like, man. I checked every single line of the documentation, every tutorial, everything, and he was like, okay, man, it's the lineage, it's a lineage of technology, that's why they call it like that. But it will eventually get better. And ever since then, this is how I felt whenever I tried. I mean, with time I developed my own techniques for the guidance, like this one between every single line of JavaScript, and at least like that I could figure out which transaction was failing, or this one, just commending random chunks of solidity and rerun everything until I eventually figure out what was going on.
00:03:19.740 - 00:04:37.890, Speaker A: But I kept thinking about what Manu told me, that it will eventually get better and it got a little better. We got reverse reasons that are super useful, but I don't know, we weren't comfortable enough with the space of improvement so we started working on builder, our development tool, and last week we launched what we call integrated JavaScript and solid exceptions. These are native JavaScript exceptions that combine both your JavaScript stack rate up until the moment that you call it into your contract. And on top of that you get entire solidity stack rate. So in a single trade you get the entire picture of why your test is failing. You get like up until which point in your test it fails and then you get where in your contract it failed. And also it recognizes a bunch of common errors in solidity, like calling a function that doesn't exist.
00:04:37.890 - 00:05:40.322, Speaker A: And it gives you a precise error message on those cases, instead of just reverting without reason, it tells you you are going to call a function that doesn't exist. So how do we do that? Before going into that, let's talk a little bit about how stack practices work on a normal environment. So let's say that you are running a fitness path program, just a binary. Whenever you have a data structure that everyone knows the stack or call stack. And whenever you call into a function, a new stack frame is created, that is local variables with a bunch of metadata. And whenever you return from a function, a stack frame is popped from the stack. And if this program needs to generate an exception, it will just start the process that is called stack and rolling.
00:05:40.322 - 00:06:26.310, Speaker A: It gets popping up stack frames one by one until it gets into a narrow handler. And I know that super easy. It's the same program that is responsible for doing the stack frame. So, sounds easy, but the thing is that in solidity in the ABM in general, we don't have a callback. Why? I have no idea, but it's that way. There are some people proposing an EIP to have an actual callback in the EVM. I don't know who they are and I don't know the state of that EIP, but I think it's a super valuable effort and I hope that seeks someday.
00:06:26.310 - 00:07:42.830, Speaker A: And the other problem is gas. So in C plus plus or whichever language, you can generate extra code or extra metadata just to do things like stack tracing. But in ethereum you pay every single local that you execute. So solidity is kind of forced to generate as smallly vital as possible. So things like metadata for extract trace doesn't seem to belong there. So that forces us to generate stack trace externally your only copy, to be an external server of the EVM, and somehow map the EVM execution into the solidity sources. And what does this mean? That you execute your contracts, trace the EVM trace in this case is just get a list of upcodes that got executed, and then you have to do lots and lots of things to reconstruct the solidity semantics.
00:07:42.830 - 00:08:27.760, Speaker A: So our first challenge was how to get from opcodes to solidity. When you compile a smart contract, you get a ton of output between those things. There are bytecodes, so bytecodes are just a list of instructions, not much. And luckily for each bytecode you also have a source map. And a source map is an option that tells you a little bit about the bytecode. It just has an offset length of five that maps into a chunk of a file that generated that off code. And then it has this chunk time thing that we talk about that later.
00:08:27.760 - 00:09:25.860, Speaker A: But okay, this is super useful and without this we wouldn't have done nothing. But the problem is that it's still super low level. We need to have a more semantic model of the things. So from a bico we want to be able to get which contract it belongs to, all of their functions, if they are payable, external, internal, their selectors, everything. Which source were they defined mean? I don't know. I think this doesn't look like hard, like hard. But this was probably one of the most challenging things because you get the output of the compiler and the solidity input, and then you have to recreate lots of logic from the compiler just to mimic what it does.
00:09:25.860 - 00:10:22.014, Speaker A: To be sure that you are actually creating a model that maps what solidity uses. For example, grading a selector of a function sounds easy, but when you start to take into consideration all the different features from solidity, I assure you that computing selectors is super hard. Okay, so if we have this model, the next thing is to reconsider the callback. And this is the easiest part. You don't have a call stack in the ABM, but you have a new VM and you can create your own code stack. It's just a stack. So when you execute a smart context, you save the list of codes that got executed.
00:10:22.014 - 00:10:59.920, Speaker A: That's nibn phrase. And you inspect bye by one iterating. And whenever you find a shamp here, you pay attention to that jump type thing that the source map give you. And what's in there is whether the shamp was jumped into a function, a return or an internal shamp, like an it. So it's easy. If your shampoo is calling into a function, you push that function into your stack. If your shamp is every time you pop a function and that's it.
00:10:59.920 - 00:12:06.638, Speaker A: I mean some city, there are some complications because there's things like modifiers that are in actual functions, but still we wanted to show them on our stack traces. So we have some special cases for things like that, just to make the lives of developers easier. Because I know if you just call to a function that is only owner, you may end up just showing only owner and not which function was called. But apart from that, creating a call stack is pretty easy. So next challenge, external calls. What I just said about the call package, in fact super simplification, because the EVM is a very weird machine. Whenever you have to do an external call, like delegate call or all of those, the semantics of that is that you have to create another evm, an empty evm, and you execute there at the other contract.
00:12:06.638 - 00:13:14.326, Speaker A: So in fact a spread of the EVM is a reclusive thing. So you get a list of outcodes that were executed up until an external code, and then you get another phrase and then some of those continue. And of course this other phrase, these are smart contracts, can also have an external call. So it's a reclusive thing by nature. So yes, creating the call stack for each of these traces individually is very easy, but then you need some logic to combine them because they are just different executions with different stack traces. And how do you combine them? Well, it depends, it depends on what going to the smart contract do if the external calls fail. So most of them, especially if you are doing anything low level, will just forward the airlock and eventually revert the transaction.
00:13:14.326 - 00:14:27.214, Speaker A: But you have to detect that because some codes just don't forward errors and ignore them. If the error is forward, that means that you have to combine the stack traces, like merging them somehow and keep going. Because maybe you are still on an external coil and you may have to merge this thing multiple times, but that's fine. I mean we added lots of logic to detect those cases, but once it's done, we got steps closer. Another challenge, and this is also a big one, is recognizing which contracts are you running. Because up until now I was assuming that I knew which smart contract I was looking at, but that's not the case. When you are running lots of tests with multiple smart contracts, you only have an EVM that executes chunks of bytecode, and that bytecode belongs to a smart contract.
00:14:27.214 - 00:15:12.186, Speaker A: But figuring out which one is not that easy. For each smart contract there are two different bytecodes generated. One for deploying it and the other one for running it on runtime. I mean it's the deployed bytecode, and recognizing the deployed bytecode can be very easy, especially if you don't use libraries. It's just an exact match, you just search for it and that's it. But the problem is that when you use libraries, when you link libraries, you are actually modifying the bytecode. You just have to add an address somewhere in the bytecode.
00:15:12.186 - 00:16:18.886, Speaker A: And also when you are deploying smart contacts, you are also modifying the bycode because you are appending its parents at the end of it. So the exact match search thing doesn't work. What we did is to create a modified write that lets you search for these bytecodes. It's a kind of tricky thing, but in generators we created a canonical representation of each bike code by zeroing out the places where addresses are going to be placed, and then use that canonical representation to save the bike model that we talked about before. And then when you're executing a bike code in the ABA, and you don't know which model you belong to, you just search it on the drive. If you go to the match, you're done. That's fine.
00:16:18.886 - 00:17:10.200, Speaker A: But if you don't, there are two possibilities. It might have got stuck because the next byte is the beginning of the parents of a constructor. And if that's the case, you can check if that node has a constructor associated and use that. But if not, you are probably stuck because of a library that got linked and you have the normalized version of it associated to the tribe. So what we do there is to check all the descendants from that node, figure out which of them use library, and try to normalize our bytecode as if it were one of those. And rerun the search. Rerun the search.
00:17:10.200 - 00:18:08.780, Speaker A: And that works. It has some issues about how to implement this. And you can't use things like normal drives using recursion, things like that. But after some work, we got this working and we were super happy because we thought that this was the last missing piece to get stuck tracing. So we started doing some integration tests and everything worked great for some time, because then we started doing crazy things with our smart contracts, and we figured out that most of them fail on things that are just not mapped by solidity. So I know I told you that for every bytecode, for every of code, you get these source map objects. And that's true, but some of them mean nothing.
00:18:08.780 - 00:19:41.718, Speaker A: They are just there to keep the indexes sync, but they just carry five minus one. That means this didn't come from solidity, this was auto generated. We could have stopped there because you kind of have a stack rate and up to some point you have a stack rate, and if your users were actually using reverse require and things like that, they have the entire thing. But giving a great developer experience means going directmile to get that perm message or to get that info to your users just to make things better. So what we did was compile lots and lots of contracts with weird error conditions and just look at their back code for weeks. I mean it's a very stressful thing to do, especially at the beginning, but then you get used to it and you start recognizing the different error patterns that solidity generates. And once you are pretty certain that you can recognize them by hand, you can codify that in JavaScript and just repeat the same thing and detect them.
00:19:41.718 - 00:21:15.170, Speaker A: The thing is that you may overfit a little bit too much on how you recognize the pattern, so you have to create some Lucy heuristics. You can't just look at the actual code that solidity generates, because that may change from version to version, and you have to do things a little bit more flexible. So our characteristics are things like okay, this smart contract failed in a knob code that's not mapped, okay, so let's look at the latest map, source code, opcode and things like that. I don't know, maybe, I don't know. Each of them work like that with super loosey heuristics, but that also means that they can go wrong. So what we did was create a whole lot of unit testing, especially for this part of the thing, and eventually got it working correctly. So our final challenge, how do we show this info? Because so far it's just a TV data structure or JSON, and we need to show it to the user.
00:21:15.170 - 00:22:27.900, Speaker A: So one of the ideas we had was just to create a mocha reporter. Reporters are just the UI that happens to be shown when your test fails. And that was a nice idea, but it felt a little bit too coupled to mocha, because BidlarVm doesn't just work on mocha, but it just run everywhere, no brand. And also we don't want to tie vlad to mocha. For example, some guy from Chinese came to say hi and told us that they are using, or trying to use vlad with chess, so dying it to mocha would face like a failure. And the other thing is that we really wanted to show these solid stack prices in the context of JavaScript, because before your transaction failed, you probably executed a whole lot of other things, mostly your JavaScript, to set up the smart contract in a particular state that make it fail. So we wanted to take that into account.
00:22:27.900 - 00:23:41.614, Speaker A: And what we did was using some not so well known, but very well documented and supported VH APIs that lets you create stack braces as you wish. So we get a stack brace up until the point where you started executing the ABM, you started executing your contract and combine that with the solid stack rate. So that's how we got this result that I show at the beginning. This is just a shark field session with a few sharks field frames, the whole solid stack trace and it automatically generated error that was recognized with one of those heuristics. So how can you use this? You just have to install builder. It has plugins for almost everything. So if you are using tropical four traffic five waffle, you just install your plugins, create a super simple configuration file, rerun your test and you have stack traces.
00:23:41.614 - 00:24:28.730, Speaker A: So that's it. Thanks everyone. So I just wanted to say thank you to the people who supported this effort, some people at the EF, and mostly to the team Sina and Collier who have been super helpful, and to all my friends who support me while I was presented with this, asking lots of questions. That's.
