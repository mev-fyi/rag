00:00:15.130 - 00:01:26.550, Speaker A: My name is Iga Yoboy and I'm a developer at Open Zeppelin. For those of you who don't know us, at open Zep we build developer tools and perform audits of decentralized systems which power multimillion dollars economies. We work with Ethereum foundation on the solidity compiler Audi, and we created the most popular smart contracts library, which has over 1 million downloads and over 180 contributors. As you can see, we spent some time writing and auditing smart contracts, and today I'm excited and delighted to share my findings on how you can improve your solidity developer experience with hot loader. But before we jump to the next slide, please raise your hand if you ever written a smart contract in solidity. Yes, developers, developers, developers. Okay, this is a compact disk.
00:01:26.550 - 00:02:17.122, Speaker A: Back in the days, developers used it to ship software and it was literally immutable code. Once you ship it, you can't change a single line on it. It affected their practices. Back then, developers were really careful about pasting and polishing their code because they knew once it's out, you can't change it. Does it remind you something? We do today's Internet Explorer six is the first browser I ever used, and it's the first browser I've written code for. Back in the day it was working the following way. You would edit your mixture of JavaScript and HTML in external editor.
00:02:17.122 - 00:03:17.020, Speaker A: Then you save it. And once you save it, you go back to the browser and you refer the page to see what has changed. And if you have to change something else, you have to do it again. And does it remind you something? And what do you think? How rich developers tools Internet Explorer six had? The answer is no, it hasn't any developers tools and I'm here not to smash Internet Explorer six. It was a great piece of technology at the time. You will see a lot of similarities about how developers tools were back then in the day and how developers tools are today as Ethereum, blockchain and blockchain in general. We're going to see a quick video, but before that I'm going to explain what's happening here.
00:03:17.020 - 00:04:02.026, Speaker A: Yes, so I have a really simple smart contract. It's called counter. All it has is one state variable called count and you can go either up and down basically with smart contract just counts up and down and has appropriate methods. Increase counter, decrease counter which you can modify with state variable. And on the left there is a front end representation of this smart contract written in create react app. It displays contract address as well as the current value, which is 32. And grab two buttons to increase and decrease the counter by one.
00:04:02.026 - 00:04:47.506, Speaker A: And let's say we realize that increasing counter by amount is not good enough business logic, and we're only going to increase it by the number of free in which video. I'm going to modify the smart contract to do that, and it's going to be reflected on the front yam. Let's see. So first I'm going to edit smart contract itself and save it. Then I'm going to compile it with a compile command. Once it compiles, I'm going to deploy it. But because ethereum blockchain is immutable, every time you deploy it you have to initialize your new contract.
00:04:47.506 - 00:05:33.878, Speaker A: And my old contract has a value of 32, but now I have to provide a new value for the count. An initial value, I'm going to go with one to three. And also because new contract has a new address, my react app can't pick up the files required operating. So I also have to restart my create react app, which takes some time, but you see how I run out of things to say while it all happens. And let's say, does it even work? Okay, so I'm going to press the button metamask as usual. Yes, it works. It went from one to three to one to six.
00:05:33.878 - 00:06:33.962, Speaker A: And so over a minute we achieved incredible things. We just changed the counter. So now it says free, right? And I believe you would agree with me that there's quite a lot of steps involved for something trivial. I call it one line change problem. Let's break it down quickly in order to, at a minimal change, one line smart contract which is tied to some front end app, you have to change a smart contract, then compile it, then deploy, then restore a state, then restore a state. And if you had some complex state restoring state can be really nontrivial because once you deploy all the contracts, all your state is gone. And it was in the middle of debugging some issue, and suddenly you have to reroll everything.
00:06:33.962 - 00:07:28.620, Speaker A: Everything is gone. And I personally, and then you have to refresh the browser. But if you think about it, how it really should be, if you look at Internet Explorer six, it's not like how we do things anymore. Now we have this luxury of development tools as like hot loading on front end web dev servers which just refresh everything for us, watch our files, you just type code in your editor, hit save, and everything works in web development. And I believe it should be the same experience when you develop applications for Ethereum. Excited to present you solidity. Hot loader solid hot loader addressed this problem.
00:07:28.620 - 00:08:01.380, Speaker A: We're going to see another video. It has the same setup. Raise a counter contract which you now familiar with, which you're now familiar with, and same front end on the left. But right now initial value is 28. There is a console at the bottom and we're going to repeat the same steps as just we did before. But at this time we've solidified hot loader enabled. Do it.
00:08:01.380 - 00:09:08.410, Speaker A: You want to change the file and save it. As you can see, it starts to compile things in the console while I'm randomly clicking everywhere. And suddenly our front end does refresh and if I press the increase button, it does increase by free. But as you can see, the state of account stays the same, which is strange because the state if you deploy your contract should change. You would think, why? How is it possible? Let's quickly break down what solid hot builder does for you. Compiles your smart contract, essentially running a compile command for you so you don't need to type anything. Then it deploys a new binary code to the local node such as Ganesh with tricky step, and then it refreshes a browser page fail.
00:09:08.410 - 00:10:06.030, Speaker A: Let's dig into how exactly it deploys the new code in the way you preserve your state and address. That is upgradability. Behind the scenes Talizia code loader relies on upgradability pattern which allows you to change implementation of a smart contract without losing its state or address. Three hot loader uses implementation by open Zeppelin SDK. It's called upgrades and I'm going to give a quick explanation how it works. But if you want more, if you want to know more, go to openzeppelin.com SDK and you'll find everything you want to know about it with far more examples and very detailed explanation.
00:10:06.030 - 00:11:43.738, Speaker A: So how it works create a proxy contract which pretends to be your contract and handles all the calls. And it uses DJ call instructions to redirect the function calls to contracts which do contain the implementation logic, while the proxy contract calls all the state and address. In that way we always interact with a proxy contract. That is why our state and address is preserved at all times. And then we change the code and hit save. In our editor what happens is the new bytecode gets compiled and uploaded to the blockchain, and proxy address implementation is changed to the new contract implementation, and all the calls after you upgrade it go to the new implementation. In that way you can achieve frictionless transition from old code to new ones where you preserve the state and your dress which is placed nice, rest really well with front end tools being great and awesome for many cases, not always works for every project, every environment, every setup.
00:11:43.738 - 00:13:12.310, Speaker A: And I was thinking can we do better? Can we create some solution which will be a silver bullet for seamless development in any environment with any framework or library? We have to talk a bit about Ganesh before. As you all know, Ganesh is Ethereum NPC client which is really good for development and testing, has slightly used and has quite a few features to help you with testing and development. And in particular it has these custom methods. EVM snapshot, EVM reverse EVM, increased time and mine they allow you to do things which are not possible on production ready nodes such as parity and gap. For example, EVM shot allows you to take a snapshot of your blockchain, do some stuff and then go back to this state which is not possible on my net I guess, unless it's without, but then it's expensive. And with other commands which is increased time allows you to jump in time forward to really helpful with testing. And even mine allows you to mine a block.
00:13:12.310 - 00:14:39.720, Speaker A: As you can see, something similar between these commands is that they allow you to do things which are not possible on main net, yet it's extremely valuable and helpful during testing and development. And I was asking myself, is there any meeting commands for our test development ethereum clients? I want to suggest present the TVM update command. Just to be absolutely clear, this is on the stage of an idea proposal and research at this moment. The idea behind this command is it will allow you to upgrade smart contracts in really hacky way without like mining blocks or altering anything else. Essentially just swapping an implementation of one implementation of a smart contract with another implementation. So I'm going to give a quick example how it's going to work. Let's say we have the same smart contract count here, which you now have expert knowledge on, and the original implementation just improves the count by one, but you want to allow it to be increased by any arbitrary amount.
00:14:39.720 - 00:16:06.334, Speaker A: And on the left we have a series of calls from top to bottom. And to start we're going to call getcounter which will return 32 is the initial state of our contract. And then we're going to call EVM update to update the smart contract with a new bytecode which will be bytecode allowing to increase it by any amount. And after that we're going to call increased counter method increasing by free. But this call is not going to fail because now our contract has a new implementation and after that we're going to call a getcounter method which returns now the value 35. In that way not only we upgraded our smart contract, we also preserve this page and address which is really important for developers tools because you want to hide all the complexity from the user a developer and to hide it inside. The dev tools Elis approach has in my opinion a huge surface and opportunity for other developers tools as well where ability just to modify implementation of any smart contract.
00:16:06.334 - 00:17:09.686, Speaker A: Of course not going to happen on the blockchain anywhere, anytime. But again, it's very valuable for developer tools and will enable all sorts of tricks which will create a huge value for the development process. I want to talk a bit of future web3 devtools in the way that I believe that future is not predefined. There are many, many possible futures and as you all know, almost a century ago gas cars were competing with electric cars. But for some reason, for various reasons, electric cars lost the battle to the gas cars and only right now electric cars starting to get some traction. And in this way blockchain doesn't particularly have to happen. Where are other futures where it happens in 100 years.
00:17:09.686 - 00:18:02.194, Speaker A: But I personally don't want it to happen in 100 years because I want to see it happen. And I believe that if our developers tools will stay on the level of Internet Explorer six, it's going to be hard to bring new developers to the fear maker system because the expectations right now of the developer is so high. They've been like super spoiled. And unless we make this awesome web free developer tools happen, I would say it's going to be incredibly hard to achieve developer adoption. I urge you all to try hot loader today. Do it. Just run NPX CLI unpacked tutorial command.
00:18:02.194 - 00:18:46.690, Speaker A: And by the way, this is the slide where you take a picture. But if you're security concerned person and don't want to run random calls on your machine, you can just go to our open Zeppelin GitHub account and clone starter kit tutorial. This is a tutorial which has data hot loader there enabled so you can play with it. It also has upgradability in ClI so you get more than just hot loader to play with and it's rather polished experience. Thank you very much for time and attention. It was a pleasure.
