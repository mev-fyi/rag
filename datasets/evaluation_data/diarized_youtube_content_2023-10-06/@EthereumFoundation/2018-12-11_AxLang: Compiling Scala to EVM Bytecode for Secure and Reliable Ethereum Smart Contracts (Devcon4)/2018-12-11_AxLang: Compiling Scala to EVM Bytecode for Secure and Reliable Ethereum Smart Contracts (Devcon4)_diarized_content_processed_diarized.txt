00:00:00.970 - 00:01:13.890, Speaker A: So I'm very excited to talk to you today about Axelang, which is a new programming language for Ethereum smart contracts that we are building, and in particular we'll talk about the compiler for it. First of all, Axoni is the company I work for, and it's a technology company that builds blockchain platforms and smart contracts for the capital markets. In fact, our smart contracts will soon process live derivative trades worth trillions of dollars in notional value. You can understand that a secure and reliable language is very important to what we're doing. This is why we are building Axelang, which in a sense is not a new language because it's really Scala. So when you are writing an Axlang smart contract, you're really writing Scala code that you can compile with a regular Scala compiler. Formal verification is very important for us as well, but I will press forward to the main topic of this talk, which is the compiler.
00:01:13.890 - 00:02:23.402, Speaker A: The first thing about the compiler is that it's actually two compilers, a frontend and a backend. The frontend compiler is a Scala compiler plugin written in Scala, of course, and relies on the Scala compiler infrastructure. And the backend is written in c and it's written from scratch. These two compilers interact through a common intermediate language that has the four properties I'm listing on the side. First, it's unambiguous, human readable language, agnostic and retargetable. And I want to highlight the last two by saying that the intermediate language is not tied to Axelang in any way, or EVM, at least it's not supposed to. So in theory you can convert other languages into it, like solidity or viper, and you can target other machines like ewasm looking closer into the front end.
00:02:23.402 - 00:03:26.670, Speaker A: This is an example of what it does. So it converts the program on the left to the code on the right. And two things I want to point out here is that types are being reduced into bytes, and storage accesses become explicit. The line you see at the top is how this happens, which is through a scala function that pattern matches the scala syntax tree, which is the tree input parameter, and converts that into the intermediate language tree. I think this is a very robust and elegant way to implement a language specification. Another feature of the intermediate language is that you can use list expressions that you can compose very nicely. I wish I had more time to talk about this, but I will now proceed to the back end of the compiler.
00:03:26.670 - 00:04:50.600, Speaker A: Compiler engineers will find the back end very familiar because it uses an intermediate representation that is pretty much a norm in compiler development, and that is three address code and static single assignment. And this intermediate representation is naturally compatible with optimization and static analysis. So that's why it's the norm and compilers that don't have that are not great compilers. So the cuts here is that these intermediate representations are not compatible with a stack based machine like the EVM. So for that reason we add another phase which we call stackify that makes the transition into EVM bytecode. So putting all the pieces together, this is how the compiler looks like. And I want to note that the backend also can decompile raw bytecode into these intermediate representations, so we can optimize and analyze raw bytecode that was produced by other compilers as well.
00:04:50.600 - 00:05:24.380, Speaker A: To summarize, Axelang we believe Axelang has a highly modular and scalable implementation. It utilizes an industry grade compiler framework which is the Scala compiler, and we are getting very close to open sourcing it. So please follow us on Twitter and YouTube for more updates on that. And we are also hiring, so also feel free to reach out to me if you have any questions. Thank you.
