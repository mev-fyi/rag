00:00:14.090 - 00:00:54.234, Speaker A: Hello, I'm Joseph Alina. I'm the technical lead at Polygon Hermes. And today I'm going to present mainly the public testnet that we publish last Monday. First of all, I'm going to explain a little bit how the CKBM works and then we are going to proceed to a demo. How a CKBM works from the user perspective. Well, a user should not see any difference like working with any other network. What we will do is first we will send transactions to a sequencer.
00:00:54.234 - 00:01:38.186, Speaker A: A sequencer will already give a state. That means that the state will be final. As far as you trust a sequencer, sequencer in the first version is going to be a centralized sequencer. We will decentralize later on. But if you trust a sequencer, this transaction is final and you have the warranty by the sequencer that this transaction is going to be mined, it's going to be processed, the sequencer will collect transactions and at some point we'll send these transactions to the blockchain. And then at this point, the state is final and safe. Here, we don't have any proof yet, it's just the transactions are set and we have the warranty that those transactions are going to be processed in that order.
00:01:38.186 - 00:02:29.382, Speaker A: And because they are on chain, they are not going to be changed. So you know that they are final and you don't need to trust the sequencer anymore. You know that these transactions are final and in background, in parallel, it's going to be the prover, actually, that's going to take all these transactions and it's going to prove that this implicit estate, so this estate that everybody can compute, but it's not on chain because in on chain these are only the transactions, the data availability, if you want, the transactions are going to be processed, but it's going to be converted to a real state. And this is proved by the prover. This is the big difference with optimistic roll ups. In optimistic roll ups, you need to wait for somebody to challenge this estate in a ZK roll up. This estate, the proverb just set this estate and you know for sure that this is valid.
00:02:29.382 - 00:03:11.606, Speaker A: It's at this point where the user can withdraw the funds. So here the most important piece, or the differential piece of a ZK roll up is the prover. The prover is a zero knowledge proof. If you want a validity proof that validates the transactions. Which transactions? Ethereum transactions. It's taking a state, it's taking a set of Ethereum transactions and it's computing a new state and validating that this state is valid. So how the prover is built, so what's inside the prover? Well, the prover is a set of technologies, but the way we built is we have a circuit with a traditional circuit written in pill specific language.
00:03:11.606 - 00:03:56.226, Speaker A: We built for the ZKBM that's mainly a processor. It's a generic processor. It's generic, it's with some specifies it's a processor that's built with this zero knowledge technology. And on top of this processor we are running a program, we call it a ROM, that actually is an ethereum. It emulates Ethereum. This program is the one that is actually taking the transactions, analyzing the transactions, checking that the signature is valid, discounting the balances, checking the fees, deploying the smart contracts, executing the smart contracts and doing exactly the same. That does gas or that does send in Ethereum node, just processing these transactions.
00:03:56.226 - 00:04:33.154, Speaker A: All this goes to approver. And this prover is the one that's verified on chain. If you zoom in, in the processor, well, we have mainly a processor is this ZK processor. All this processor is very tailor made for the ZKVM. So it's not like a very generic processor. It's this part that's generic. But there are specific pieces that are made explicitly to be optimal for running the EVM program.
00:04:33.154 - 00:05:07.994, Speaker A: The ZKBM program. This processor has a ram, has a ROM which contains this program that's executed, contains a storage. Because the ABM, you should be able to store values and get the values. It have also kind of a superprocessor that handles all the binaries. Operations here includes addition, subtraction and torque exors and so on. Has a model that's for arithmetic. In the ABM, it works in 256 bits.
00:05:07.994 - 00:05:36.994, Speaker A: So this arithmetic circuit actually does all these operations in the 256 56 bits. Okay. And then has the hashing for ketchups and other hashes that are also inside the processor. Inside this processor, on top of this processor there is this ROM. This rom is written in assembly. It's a specific assembly for this processor. And here this contains all the logic.
00:05:36.994 - 00:06:00.750, Speaker A: Actually it contains all the serum logic. Where we are processor here. Here I want to show you just a snippet of code of how this looks like this is just, for example, the opcodes dupe one and dup two. But here we have all the opcodes. We have implemented all the theorem opcodes at this point. And then once we run this, then we need like the cryptographic prover. The cryptographic prover.
00:06:00.750 - 00:06:34.810, Speaker A: What we do is mainly we are using starks with a very optimal way to compute proving systems. We are using goldilocks, it's a technology from people or colleagues in polygon zero that makes to build these proofs really fast. And it's a can for recursion. So it's approver can aggregate many proofs. And at the end this is a stark. And at the end what's doing is we are converting, we are verifying this stark with a snark. So at the end we just in ethereum we are just verifying a normal gross 16 or plonk proof.
00:06:34.810 - 00:06:58.226, Speaker A: It's a circumcise in the bottom of that piece. So this is the stack, the cryptographic stack for verifying that. Okay, so let's cross fingers and let's try to see the demo. Let's see if it works. If it doesn't work, you can try it. Okay, you can go to public ZKBN test net and test it. You will see that it's very simple.
00:06:58.226 - 00:07:28.502, Speaker A: The demo that I'm going to do is first of all I'm going to breach it. Let me just switch. Okay, so the first thing that I'm going to do is I'm going to breach. So I'm in gongo early network. I have an account here that has three go early already and it's just a strike new account that I just created before this. So the first thing that I'm going to do is I'm going to transfer, I'm going to breach three ethers. Well, 00:25 ethers.
00:07:28.502 - 00:07:49.060, Speaker A: This is the maximum that we allow here in this testnet just to protect some denial of service attacks here. And we are just to transfer to the layer two. So I'm in Guerreli right now. So I'm just black. Let's see if ethereum works. Okay, here we are. Let's bridge it.
00:07:49.060 - 00:08:25.982, Speaker A: Okay, so let's sign. Let me just modify the gas fee so that it goes faster to go early. So you never know save and then just send this transaction. So we just deposit the transaction. This transaction is mining in Guerley. We need to wait also a little bit so that this transaction is kind of a final, so that this transaction is included right now. This is already done.
00:08:25.982 - 00:09:07.370, Speaker A: What we have done is we just put this transaction in a Merkel tree and then the root of this mercury tree of all deposits is passed as the state of the roll up the sequencer. Actually there has not been any special transaction on chain because the sequencer already takes in account that. Okay, so now let's finalize this and this finalized. What is doing is collecting, is doing an l two transaction to collect these funds. This ethereum in the layer two. So here when I push here, the first thing that asks me is just to switch the network. So I'm just switch the network.
00:09:07.370 - 00:09:28.162, Speaker A: Now I'm just signing the transaction. Just signing the transaction in layer two. I just signed into transaction. Let's see if it works. There we go. Here is. Okay, so now if I check the count, I'm in the layer two.
00:09:28.162 - 00:09:59.610, Speaker A: Now I have the zero to 25 ether in the layer two. Okay, so now let's go to do something with this account. Okay, let's create a smart contract and deploy it in this layer two. So let's go to remix. Just going to use an example, very simple smart contract. This looks like remix is gone. Let me just, this is just a very example.
00:09:59.610 - 00:10:17.538, Speaker A: Smart contract. So let me compile, let me compile this smart contract. Here is. And now I'm going to deploy it to the layer two. So I'm going to connect this to metamask. Okay. I'm just using this account.
00:10:17.538 - 00:10:37.350, Speaker A: And then I'm just, well, this is, I don't know if I'm connected to the last one. Well, just connect here. This is the one that I just did. I have the 25 ether here. Let's deploy this. Okay, so just deploy this smart contract. It asks me to sign.
00:10:37.350 - 00:11:11.620, Speaker A: Just confirm this transaction, see if it goes. Internet is not like the fastest thing here, but here is. Okay, so now here we have the smart contract. If we do a, get a, we get a zero. But if we, for example, we set a 22. So this, we generate a transaction to set this state variable to 22. We sign it, confirm, just get the value.
00:11:11.620 - 00:12:04.658, Speaker A: And I see here 22, right here. Okay, so I just deployed that in layer two like any other network here. Okay, so what's going on in here? So let's go to the, to the, this is the roll up smart contract in the layer one. Okay. And here we see two kind of transactions. One are the sequence batches, like here, where here you can see in the data that here are all the transactions that we are setting, okay? But in parallel to this, we have the batches, is the prover that's generating batches, that's actually validating these transactions. And here is where all the magic happens.
00:12:04.658 - 00:12:35.354, Speaker A: Okay. Here in the blockchain, you cannot see much, but here is the proof. Actually, this is the growth 16 proof in this case, that validates all the transactions that we have been processing. Okay, so until here is. Well, maybe I can give you a bonus track here so we can go for example to Uniswap. Okay, this uniswap is already deployed as is without compiling, recompiling anything. It's just a normal uniswap.
00:12:35.354 - 00:13:00.710, Speaker A: It's deployed in layer two. And here we can do for example a transfer. Let me just change the account to the first one so that I have some tokens to change. And here I want to convert from foo to bar. Just normal swap, fetching the price. I'm just doing the swap. Confirm swap.
00:13:00.710 - 00:13:45.018, Speaker A: Why should sign the transaction? So here we have deployed, so here we have already deployed the full uniswap version three in the layer two and all this is verified in the approver. Just confirm that now. This is confirmed. Now here the Uniswap interface has some rating, takes maybe some 10 seconds or so to realize that the transaction has been moved. But that's mainly the thing. Okay, so let me go, well just let me see if it finished. This here is okay, so I already did the swap, so I can just check in, in swaps just like normal, like any other ethereum transaction.
00:13:45.018 - 00:14:28.654, Speaker A: So let me switch back to the presentation. So nothing fancy, right? That's the cool thing. And that's the strange things, even for me explaining. For me here I'm just feeling that I did a demo of ethereum. But this is the interesting thing, it's that all this is validated in the prover. All these transactions that are really complex or all the uniswap transactions and everything, this is validated inside the prover. And this is what this ZKBM and the main importance of this design, you don't have to recompile anything, you just take the code, exactly the same code.
00:14:28.654 - 00:15:00.510, Speaker A: You don't have to reautate anything, you don't have to learn anything. You can use exactly the same tooling, you can use the same language, the same gas model. It's no difference for developers. They should not notice any difference in deploying, in working with ethereum or in ZKBM. The only difference should be the gas price and the quantity of transactions that you should be able to deploy. This is a testnet, please test it. We have been running for this week already.
00:15:00.510 - 00:15:32.760, Speaker A: We have more than 1000 accounts. Most of them are just deploying transactions. Some of the projects already tested, already tested without any big issue. We have some reports of some bugs that we have infixed also and we will continue work. This testnet is a little bit like a baby. It was born last Monday, but it's going to get stronger. And this is the previous stage just to the main net.
00:15:32.760 - 00:16:08.338, Speaker A: Okay, and what's the limit of the scaling? This we don't know yet. What's clear is not going to be in the prover. It's going to be maybe in the data availability, it's going to be maybe in the sequencer, in the other pieces. But because why? Because the prover can be parallelized. And here the important part actually for example, we are running seven provers at this point because this week there is many transactions, some of the provers have been stopped. So we are just trying to catch up with some of these transactions. But this is the cool thing, we can run as many provers as we want.
00:16:08.338 - 00:16:51.390, Speaker A: So if there is a lot of demand we're just running more provers. And the only thing you need to take in account is what's the cost per transaction because running these servers are not free. So what's this cost? Well the cost right now is less than one cent per transaction. And this is in AWS cost, which is probably the most expensive cloud service in the world. And there is also a lot of optimizations that are coming here in GPU. We believe that we can improve one order of magnitude and there is other improvements that we are working on that. But prover is not the bottleneck anymore.
00:16:51.390 - 00:17:28.166, Speaker A: What's missing? Not much. So we are fully compatible. We are running all the opcodes, everything works as ethereum is. There are some things that we are already implementing. They are not implemented yet and I'm just listing here, but everything is there. What is missing is the preip is the original ethereum transactions. This is mainly to deploy mainly nosisafe, but it's just for these smart contracts that have the same address in many chains.
00:17:28.166 - 00:17:57.430, Speaker A: They are using these primitive transactions that they don't include the chain id. We are implementing those and then we are not supporting yet. The Shadow 56, the Blake and the paintings precompiled to smart contracts. But this is a work in progress. All of them are doable and we will work on those in the coming months. There is the audit. I don't want to enter in detail in the audit, but this is probably the most challenging part that we are facing right now.
00:17:57.430 - 00:18:31.642, Speaker A: There is a full plan for running these audits. If anyone interested in that please contact me. What else are we working on? We are working also in aggregating of the proof right now, the aggregator right now we are running one proof per batch. So we need to aggregate all these proofs in a single transaction, in a single proof. Actually we are working in this proof. This is not that much because we have all the recursion of added on and it's just putting them together, but it's a piece that we need to put there. And we're also working with the AIP 4844 for dying sharding.
00:18:31.642 - 00:19:04.310, Speaker A: This is clearly the future for the scalability and we are already working on that. We are very excited on that. I have to recognize that when I read this EIP I was very skeptical at the beginning, but it's really the way to go. We can implement insight and it really will go even faster and it's even better than what I would do. It's just that the only thing is that you need to go a little bit deep to understand this EIP. That's really interesting. I'm very excited for the scaling testing.
00:19:04.310 - 00:20:06.030, Speaker A: We are running the ethereum test suites right now. We are at 97% of passing all these tests. There are edge cases that we are still working on that, but I'm sure that very soon we will be covering the, we will be in 100% of the theorem test on that roadmap. Of course we just launched at the public testnet we need to audit and we will launch when it's ready here. We want to be enough safe enough sure that 100% safe is going to be impossible, but we want to be responsible and we want to audit this very well. And when we feel comfortable then we will launch a reminder, everything is open source. You can take a look, you can see, you can review, everything is in the GitHub repositories and yeah, GKBM is no longer a myth.
00:20:06.030 - 00:20:08.670, Speaker A: Here you have the GK.
00:20:15.350 - 00:20:22.020, Speaker B: Thank you so much. We have a couple of minutes for questions, so if you have a question, please raise your hand.
00:20:23.910 - 00:20:46.300, Speaker C: Hello. Thank you for the presentation. The EVM is not a frozen object, it's living and it's evolving with new Eips and we are going to see possibly big change like the EOF or other things like that, and they will be way easier to implement for core devs and for you. So are you worried that some possible EVM change will be hard to translate into circuit in the future?
00:20:48.750 - 00:21:23.990, Speaker A: We need to see which are those changes. And once I see the changes, I will tell you. But there is one thing that because this is some of the questions that I receive, sometimes it's more about the upgradability of what happened if the EZKVM upgrade and then what happened with the roll up, it will upgrade. And if you want a decentralized system. But here is. We need to understand as a community that the ABM at this point is evolving because it's work in progress. But at some point this will need to be frozen.
00:21:23.990 - 00:21:53.730, Speaker A: I don't know when and how. And I'm not talking about the ZKBM, I'm talking about the ABM. So the ABM, if you want, I believe, I hope. And talking with people with EF, they already think very much on that time. Is that at some point, maybe in two years, three years, five years, once the ethereum is finished, then the EBM will be frozen. And then it will be also the time to freeze the roll ups.
00:21:54.310 - 00:22:05.490, Speaker D: Thank you for the presentation. Great talk. Could you detail a little bit what are the h cases that you are meeting regarding the failing tests?
00:22:06.650 - 00:22:30.170, Speaker A: Here we have Carlos in the room that's responsible for testing. You can ask them, but they are very complex one. It's a call of a static call and then do a self destruct and do whatever. These are very edge cases. Very edge cases tested. But you have to look at it because you never know. And it's important.
00:22:30.170 - 00:22:36.478, Speaker A: That's why those tests are there, but are really edge cases at this point. And complex ones.
00:22:36.644 - 00:22:54.046, Speaker E: Hi, thank you for the presentation. When you were showing on ETL scan the contents of the batch, you showed that there was encoded set of transactions. Is there any way to decode them to see what exactly is in the batch?
00:22:54.158 - 00:23:19.366, Speaker A: Yeah, it's mainly are the transactions one after the other. We have some internal tooling just to take a look on that. Well, actually they are open source. You can check the repositories, but we are building it. And in any case, it would not be difficult to interpret at the end. It's just a format with rye of transactions.
00:23:19.558 - 00:23:28.400, Speaker B: I think we have time for one more question. So if you can lend the microphone to our speaker. Cool, go ahead.
00:23:29.410 - 00:23:30.926, Speaker F: Hey, thank you. Can you hear me?
00:23:31.028 - 00:23:31.438, Speaker A: Yes.
00:23:31.524 - 00:23:45.880, Speaker F: Okay, first of all, congratulations. This is amazing. When you launch. Let's suppose it's early next year. Obviously, it's a very complicated system. If you find some bug or something that needs to be addressed. What can you do in that situation?
00:23:46.890 - 00:24:24.154, Speaker A: Bootstrapping decentralized systems is not an easy topic. Here we have the experience of Hermes 10 in our team. And here you do some, I would say, nasty tricks. Here is maybe you do an upgradability. Things that you can do is so you can upgrade the smart contracts with a time lock. And you can do, for example, is limit the withdrawal flow. That's living in the smart contract so that it's like if you are working with less as a certain amount you are purely decentralized.
00:24:24.154 - 00:24:51.110, Speaker A: But if you want to run fast and run bigger numbers then you have the option to go centralized or just white. There are some tricks for bootstrapping, but this is our just temporary solutions until we feel comfortable. At some point the roll up should go along. We are building a decentralized system and it should be safe enough. Here is how we are managing that in the beginning.
00:24:52.170 - 00:24:55.170, Speaker B: Thank you so much Jersey Valencia, please give him an applause.
