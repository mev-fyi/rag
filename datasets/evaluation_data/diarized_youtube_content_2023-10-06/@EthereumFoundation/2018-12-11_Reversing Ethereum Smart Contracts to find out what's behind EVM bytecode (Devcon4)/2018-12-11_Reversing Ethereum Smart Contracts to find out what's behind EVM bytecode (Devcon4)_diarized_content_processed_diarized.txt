00:00:00.570 - 00:00:48.746, Speaker A: Thank you everyone. Just a quick question. How many of you come from the it world? It security world? Okay, so some of you already know what is reversing and what is useful. So I will try to make it simple for the other. And the purpose of today is to understand what's behind the EVM bad code, typically the that will be stored on the blockchain. And to help you to understand how famous security tool works, actually. So I'm Patrick, I'm a security researcher, and typically my relation with blockchain come because I was doing blockchain transaction tracking and stuff like that.
00:00:48.746 - 00:01:41.230, Speaker A: And for that reason I needed to analyze bytecode, like self destruct bytecode and transaction, et cetera. So that's why I start actually my project that is called octopus. So it's a security analysis framework. Typically I support EVM, of course, but I also support some other platform like EOS and Neo. So if you want to take a look at the bytecode of the smart contract of Neo and EOS, could be a good occasion. And let's start. So I will do a quick introduction and after that I will talk to you about the control flow graph and why we need to use reversing at some point.
00:01:41.230 - 00:02:26.438, Speaker A: And as a developer point of view, why you can need to use reversing. So typically reverse engineering will be really simple. For smart contract, the purpose is you have the EVM bad code and you want to translate it to EVM assembly. And the reversing of smart contract typically will be the analysis of this EVM assembly. So if you take a look at the bytecode, you can have two type of EVM bytecode. The first one will be like this big one with a loader code. It's actually the loader code that will push the runtime code into the blockchain.
00:02:26.438 - 00:03:02.840, Speaker A: Typically this shame will be present if you take a look at the contract creation transaction and if you took a look at the input data. So in that cases you will get the loader code. And we are more interesting about the runtime code, that will be the final code of your smart contract. So this code will run into the EVM. I will not spend too much time on that and so on. So first step, we need to disassemble the bytecode. So pretty simple.
00:03:02.840 - 00:04:06.730, Speaker A: Maybe some of you already saw the opcode tool from ether scan and it's typically what it does. It's like a disassembler, basic disassembler. And the way it works, the disassembling in general, you will need to have like a correlation between the opcode and the evm instruction. So it's typically you just take the EVM instruction set and you do the matching and that's work. The more tricky part will be about the control flow graph. So for those who don't use tools like binary ninja, Ida, et cetera, typically a control flow graph is like a graphical representation of your program logic. So typically if you have an if else, et cetera, you can directly identify it based on the representation, graphical representation, and most of the time you will need to actually in every cases you will need to create block or nodes and edges, so connection between those blocks.
00:04:06.730 - 00:05:18.686, Speaker A: So for that you have some instructions that are really critical and that help you to recreate the CFG. The two first one are the jumps of course, so it will help you to create the edges and the other one will help you to do the decomposition of your inline evm assembly into basic blocks. So to simplify, it will look like that before, after, and the next step is to do the connection between this basic block. So if we take like a basic idea that could be I want to do static analysis and I will just check if the instruction before jump is a push instruction that will push the jump target offset into the stack. It could work. Actually it will work for potentially 50 60% of the time. But at some point you will get some issue and typically it will come when you have a stack operation.
00:05:18.686 - 00:06:34.662, Speaker A: So typically in these cases you have one basic block, you have no push on it and you have a jump. So if you don't know the value on top of the stack, you are not able to determine which will be the jump target offset. So there is multiple techniques to simplify that and help us to recreate the CFD. The first one that I used is you do like a dynamic analysis with stack evaluation. So before you have this graph with some orphan block, typically so do's block have not been called during my emulation of the graph. But if I do just a static analysis like there is a push two and a jump, those basic block will not be assigned to the graph. And in case of stack evaluation it's largely better because in these cases I'm able to place this block to another graph, another path into the graph.
00:06:34.662 - 00:07:34.326, Speaker A: Also the graph look largely better. So once you have done that, actually a good thing to do is to identify which basic block, assign all the basic block to the function. So if you take back this graph, you will see that there is a typical pattern for a switch, and actually this switch in evM bad code is the dispatcher function. So typically the way it works, the dispatcher function will be the entry point of the smart contract. And depending of the first four byte of the transaction payload, that is called the method id, you will go to one pass or another. So in this example, typically you will get two different method id. So you can identify them pretty quickly with this typical pattern.
00:07:34.326 - 00:08:35.780, Speaker A: So you have a push for of the function ash or method id. We check if it's the same value than the first four bart four byte of the transaction. And if it's my bad and if it's okay, you will do a push too of the function offset and you will jump to it. Okay, so that's the dispatcher function. And using that you are able to determine and find all the basic block associated to this function. So in this example you will get like seven different function that is collaborative and you are able to do so because you have doing analysis directly on the dispatcher function. Having the function is really cool, but it's even better if we have the name of the function.
00:08:35.780 - 00:09:34.582, Speaker A: So typically the name is not stored into the EVM bytecode. The way you can recover it is by using the four byte identifier. So the method id, the fact is the method id are compute based on the function name text. So typically if you have a transaction with the method id, typically, typically you will get this transaction, you have this ash, this method id. And if you use like a function signature reverse lookup database, you will get the matching between the signature and the function name text. So the most famous one is four bytes directory that work perfectly and there is a lot of inputs on it. So really good to use.
00:09:34.582 - 00:10:25.458, Speaker A: And you will see that depending on the text signature, you will get the byte signature. So using that you are able to recover the name. So in this example it's actually the greater smart contract. So you get the grid and kill function. But you can also use this technique, this recovering technique in order to get an information about the arguments of the function. So typically in this example you have distribute tokens and in the first case you have like an array of unsigned integr and in the second case you have just an unsigned integral and you can see that the signature are different. Quick cushion of that you can have a collision for the function signature.
00:10:25.458 - 00:11:28.022, Speaker A: So in these cases, the best way to find out which function signature is the good one is to check if you have like call data load upcode in the function. That will mean that you have arguments and you can pretty well define how many arguments and which type of arguments using this way. So why using reversing? So there is actually multiple way and multiple reason. I have list like four of them. There is many other, but it's just to give you an idea and give you some appetite about this subject. So if you are a user, typically a user of the atrium blockchain, you potentially want to do some reversing if the source code is not available. So the reason for that is when you create a smart contract, the source code is not mandatory.
00:11:28.022 - 00:12:21.590, Speaker A: So you can create a smart contract just by sending the bytecode. And it's typically what cryptokitties have done. So in cryptokitties you have like four solidity source code, and in the cryptokitties core you have a call to the gen science contract and more specifically the mix gens function. And actually this solidity source code is not available on Zagitub, there is only the three other one. And the reason for that is because it's all the mutation of the gen, of the kitties. So they don't want it to be public and they don't want it to be analyzed at some point. But the community start to take a look at that.
00:12:21.590 - 00:13:23.040, Speaker A: So the first step they do, they start to do like diffing between genome DNA and some people, and actually no, it security people start to do the reverse and analyze of this smart contract. So there is some blog post really interesting about that. And they also write an equivalent of the logic into python or in other language, so you can directly try it using command line tools. So it's really cool and typical application of that. Another reason, as a company, of course you have security edit, but I will talk about that later. Another reason could be bytecode optimization. How many of you think that the EVM bytecode is optimized? Okay, so good.
00:13:23.040 - 00:14:34.626, Speaker A: I don't know if some of you seen this tweet from Ryan from trailsbits, and actually he found out that at some point in the blockchain, a lot of smart contracts use exponentiation to calculate the value one. So the fact is, exponentiation cost ten gas. So that means a lot of people spend gas for nothing. And even more, if the argument of the exponentation instruction are constant, you can directly simplify it by a push, like really simple. And if one of the arguments are zero or one, you can calculate directly the value at compilation or directly modify by the runtime variable. So it's more specific cases, but it works pretty well. And Martin from the Atram foundation do some testes about this superposition and reproduce this on 16 random blocks.
00:14:34.626 - 00:15:43.950, Speaker A: And if I note that 73% of all the exponentiation invocation could be simplified and could be optimized so it start to be something. Actually I don't know if there is some modification directly on the solidity compiler to fix that, or potentially if you use the optimized flag, do we change something? I don't know, don't take the time to check it out, but definitely we potentially need to say to the solidity gig that there is some optimization to do on this part. Another reason that is more famous is typically security audits burgunding vulnerability research. And the fact is I don't know if some of you use one of this tool. I'm pretty sure some of you does. And typically this tool use directly the EVM bytecode in order to do their analysis. So the reason for that, and most of them use like pattern matching detection for vulnerability.
00:15:43.950 - 00:17:11.750, Speaker A: But the reason for that is the EVM bad code will be what is stored on the blockchain. For the moment I don't remember if there is some vulnerability related directly to solidity, I mean directly to solidity implement bug into the code, but potentially it could be detected in this way. And the last reason that is for me why I start looking at smart contract is for everything related to transaction tracking analysis of smart contract interaction from threat intelligence point of view, like threat actor, like malware, auto, et cetera, that will use smart contract in atrium in order to move their money without being detected at least. So a typical case is also the techniques that have been used by jay from trailbit just before me is to do some post mortem smart contract analysis. So if you have a smart contract that is destroying you, go on etoscan and you will see that. So at this point you are disappointed. But the fact is, as I told you, the smart contract bad code and the runtime code is available directly into the smart contract creation input.
00:17:11.750 - 00:18:13.850, Speaker A: So if you just take a look at this transaction, you will get the loader code and the runtime code. You just need to cut the loader code and it's okay, you get your smart contract by code back. So that's all for me. I hope you have learned something and I give you some appetite to learn about EVM badcode. I encourage you deeply to participate into the creation and the community behind Deostool that are really good. And also if you want to see some other of my talk like more specifically about reversing in general, but I also done a talk recently about the analysis of the implementation of the lo word from parity technology. So potentially some of you, if you are interesting on ewasm wasm, you could get some interest.
00:18:13.850 - 00:18:25.200, Speaker A: And I have done a workshop recently about creating pattern to detect some type of vulnerability, so everything is available directly on the link. Thank you.
