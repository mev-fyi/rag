00:00:19.930 - 00:00:59.262, Speaker A: You just heard Carl talk battle lot of high level things. My talk is unfortunately the slides don't look like Carl's talk, so it's a little bit different. I want to ground what Carl just talked about in the actual tech behind the op stack. Right. I want to present to you what the op stack looks like under the hood. I want to present to you the theory of how you build modular blockchains. Right? Not just, oh, let's make some charts and let's figure it out and somebody will piece these things together.
00:00:59.262 - 00:01:27.286, Speaker A: I want to give concrete APIs and functions that describe the different layers of a system like this, so you can really start to wrap your head around how something like the op stack works. I'm going to be continuously out of breath because we're like 8000ft up in the air. It's really hard to talk. So here you go. Modular roll up theory through the lens of the op stack. Aka you just watched Carl's talk and now you understand how this whole modular rollup thing actually works. Okay.
00:01:27.286 - 00:01:47.594, Speaker A: All right, let's go. We're going to do drawings. We always do silly drawings in these talks. So here we go. First, I want to give some context. So I'm going to be talking about the theory behind modular rollup architecture. The op stack is a specific software stack that turns this theory into practice.
00:01:47.594 - 00:02:11.986, Speaker A: Right. This is about taking that theory and turning it into specific software components that you can then use to build modular chains. And I just don't like talking about theory alone. I think theory alone is not very useful unless you ground it. And so I'm going to be using this stack to keep the talk grounded. Right. I'm going to be using the abstractions that we came up with in the op stack to keep things grounded.
00:02:11.986 - 00:02:27.914, Speaker A: I'm also going to use typescript types to represent things. Typescript is God tier. Don't at me here is typescript ascending into heaven because truly greatest language of all time. I hope you enjoy. Let's go. All right, so modular roll ups 101. Lost the mic.
00:02:27.914 - 00:02:36.698, Speaker A: Oh, there we go. We get it back. Give some brief history. Back in 2020. Everyone was building monolithic roll ups. This is what they looked like. Beefcake roll ups.
00:02:36.698 - 00:03:07.410, Speaker A: Really? Absolutely. Ripped six pack ab roll ups. It was one giant code base and it was really hard to understand where the separations were. And what did data availability mean. Basically everything was defined and limited by our proof systems, right? So we were like, okay, what is a roll up? Well, an optimistic roll up. We have to build this fault proof. So we're going to build the fault proof, and then we're going to figure out how to make the system work like the EVM inside of a functioning faultproof.
00:03:07.410 - 00:03:19.418, Speaker A: And we did that because we had no clue what we were actually doing. We had no clue what roll ups really were. This was us. How do we roll up? Who knows? Let's just build something. Oh, yeah. That's what we did. Mental models are really, really important.
00:03:19.418 - 00:03:47.154, Speaker A: If you don't know what you're building, you're going to build it wrong. As an aside, I think this is funny. I've been working on this stuff probably for, like, five years now, and every six months, we sit there and we're, aha. It actually works completely differently from how we thought it works. Like, the other day, Carl and I are sitting there, and we're like, oh, withdrawals are just totally not what we thought withdrawals are. So it's crazy. It's just think, you know, we really don't understand the problems that we're working on.
00:03:47.154 - 00:04:19.550, Speaker A: It takes a long time for us to build those mental models. And so if you don't understand something, that's okay, because not everybody does. Nobody really understands what they're working on, even when you're working on it and building a whole protocol out of it. Then we finally got it. So between 2021, 2022, we started to really understand roll ups in more detail. The first key realization was that proofs should be execute or should be separated from execution. We should not allow the structure of the proof to control the behavior of our execution layer.
00:04:19.550 - 00:04:36.818, Speaker A: So here we go. With the power of mental models, I vanquish the monolithic roll ups. Oh, Jesus. Oh, they got ripped in half. Oh, no. And so then we got stuff like optimism's EVM equivalents upgrade, arbitrum's nitro upgrade. All the same idea.
00:04:36.818 - 00:05:08.570, Speaker A: Let's separate proofs. Let's just run the EVM as built with minimal modifications to make it work like a roll up, and have the proofs be so general that it doesn't matter what you do on the execution layer, you can do whatever you want. All right, then we also came to realize that we could break out the data availability layer. Bra. Right? So we got a fork, and it added a data availability committee. Arbitrum releases Nova with the data availability committee. This is all a realization that we can also separate data availability.
00:05:08.570 - 00:05:43.734, Speaker A: Right? We can include a different thing that's not Ethereum, and these systems can still work with different security properties. And so roll ups were coming modular. Right? We start to see this, we generally start to see roll ups beginning to break down into three primary layers. If you've looked at modular roll ups before, because people have been screaming about this for the last year, you kind of understand where it's going. Consensus, execution, settlement, that's the high level idea. But that's the high level, right? Isn't that just modular blockchains? Yeah, in a way. But really it's about taking the theory of modular blockchains and putting it into practice.
00:05:43.734 - 00:06:13.538, Speaker A: It's about saying, okay, let's not just have charts in a blog post that says, well, if you separate it, if you put this, it could be this thing, and if you put this, it could be a validium and whatever. But actually saying, let's define a software stack makes it possible to put the things together for the average person to not have to build the whole thing from scratch. And it was time to make things official. So this was modular blockchain design and being put into practice. But at the beginning was very messy and very haphazard. Right. People were kind of just ripping things out.
00:06:13.538 - 00:06:30.630, Speaker A: They were kind of just tweaking the execution layer and hoping that it worked. There wasn't a formality around it. So you know what time it is? It's formalization time, like loosely formalized because I never graduated college. So I don't know how to do that. But it's good enough. It's good enough. All right, so here, section two.
00:06:30.630 - 00:06:42.602, Speaker A: Now the section numbers are completely messed up. I just never even got around to fixing it. But whatever. Beep boop. Bias warning. I'm going to use the abstractions that we define in the op stack. I think these abstractions are good.
00:06:42.602 - 00:06:56.942, Speaker A: There are other abstractions out there, but I think the op stack's abstractions are pretty good. So deal with it. I'm going to use those. Like I said, there are three primary layers. We got consensus. Inside of consensus, we got two things. What we call data availability.
00:06:56.942 - 00:07:19.510, Speaker A: You've heard of that before, derivation, you may not have heard of that before. Then execution, then settlement. So let's look at consensus. Let's specifically look at these two subcomponents. We've got the data availability layer and we've got the derivation layer. Right? So what is the data availability layer even? Right. Let's try to formalize this a little bit.
00:07:19.510 - 00:07:54.962, Speaker A: Well, it's like the place where you post data. Right? Like how does that actually work? So let's get slightly more formal, I like to say, and I think a good way to think of the data availability layer is. It's an ordered list of blobs. It's just an array of byte strings, right? That's the most abstract way that you can think of the data availability layer. There are certain properties that you might want out of a data availability layer in practice, right? You really want this to be a mostly immutable, append only list. You want the data to actually be available. But that's an implementation detail of the data availability layer itself.
00:07:54.962 - 00:08:22.090, Speaker A: At the highest level, it really just looks like this. It's an array of byte strings. In the context of ethereum, right? If we look at this, what is that array of byte strings? It's pretty straightforward. It's just every new block. Every block is our blob, right? And it's this array of blocks that just grows and grows and grows and has pretty good data availability properties and has pretty good immutable mutability properties. So you can do that. Here's whatever some code of.
00:08:22.090 - 00:08:47.990, Speaker A: We're pulling the data from. L one blocks. Those are our blobs. Same idea in 4844, except you're looking at the 4844 data sidecar instead of looking at the primary block. Got stuff like Celestia, and you got like a stack of postits. Like you could do it with a stack of postits if it's like a sufficiently good stack of postits. All right, so array of blobs, pretty straightforward, generally, blobs, blocks.
00:08:47.990 - 00:09:18.718, Speaker A: Now let's get into derivation, because derivation is what I think to be one of the more interesting layers in this whole system. At a high level. Derivation is taking the data availability layer, and it's understanding what that data means, and it's parsing it and using that data. Plus the current state of your layer two system, it's producing the inputs to your chain, right? It's producing, for example, I'll get to it. But it can produce transactions. That's sort of the classic example. In our case.
00:09:18.718 - 00:09:48.920, Speaker A: We use the engine API. The op stack uses the engine API. Why the engine API? Yeah, it's like one of these things we're opinionated on, basically, we think, as optimism, we're building this EVM equivalent. Optimistic roll up. The Ethereum already standardized the separation between the consensus client and the execution client. It didn't really make much sense to come up with a totally new way of driving execution. You might as well just reuse the same thing, because the APIs are there.
00:09:48.920 - 00:10:14.734, Speaker A: All right, let's go. So let's formalize this. What does this actually mean? I think this has a relatively simple function signature. And it kind of looks like this. You have this derivation function and it takes the previous state of your roll up or your system. It takes the data availability layer and it's either going to produce a payload for you to execute on the execution layer or it's going to produce nothing. And it might produce nothing.
00:10:14.734 - 00:10:50.442, Speaker A: If, let's say you're a roll up and there just haven't been any new transactions published to layer one, it might just say, well, I looked at this new block that came in from the data availability layer and there's nothing new to put into the roll up, so I'm just going to produce nothing. Or it could look at a block in the data availability layer or a blob, whatever, and it could say, okay, actually here there's a transaction that we need to execute on our layer two system. So let's make this a little more concrete. Let's look at derivation in bedrock. We look at data from three locations. The number one piece, like the most common place we look for data is sequencer data posted to a specific address on layer one. This kind of makes sense.
00:10:50.442 - 00:11:32.714, Speaker A: The sequencer collects a bunch of user transactions, compresses it, shoves it onto layer one and it posts it on to a specific address. Not a contract, interestingly enough. And here's the many, actually very complicated if you want to derive this and make it extraordinarily efficient. So it's in multiple files here, but you could make this much simpler if you really wanted to, at the expense of gas costs. Then we derive data from a second location, which is deposits sent to the portal contract, which is basically our deposit contract. So when there's a deposit event emitted by the portal contract in a block, we're going to derive a layer two deposit transaction. Here's how we do that.
00:11:32.714 - 00:12:02.014, Speaker A: Right, whatever. Then the layer one block data itself, every time there's a new layer one block. We're going to derive a special transaction on layer two that carries the information about that layer one block into layer two into the layer two state. Here's how we do that. Whatever. The point is that we can transform all of these different sort of data sources into payloads that get executed on layer two. And this abstraction is actually really, really powerful.
00:12:02.014 - 00:13:02.966, Speaker A: And I want to kind of hammer this in, because if you want to build a roll up, you did what we do, what we just talked about, right? You read sequence transactions, you read deposit data, read block data, whatever. But that's not the only thing you can do with this. You can derive data from almost any piece of information that lives on Ethereum or lives on your layer one or your data availability layer. So I want to just show you a toy example of something that I think is really cool that you can do with this. Let's say that you had a layer two without user transactions, without anything, right? And the only way that you derived these engine payloads was every time there was a uniswap swap event. On layer one, you derive a transaction on layer two that includes the assets and the amounts, right? And you feed that transaction into a smart contract on layer two that keeps a running tally of the volumes. That kind of looks like something like all of a sudden you have this thing, this provable thing that is deriving data from layer one and is generating some sort of state on layer two.
00:13:02.966 - 00:13:23.120, Speaker A: And it kind of looks like an indexer. You can essentially build an entire verifiable indexer as a roll up. Are they just roll ups? Who knows? I think indexers are kind of just roll ups. People just didn't realize it. There's a lot you can do with this. You can derive layer two payloads from anything on layer one. And you can do so much with that.
00:13:23.120 - 00:13:34.782, Speaker A: All right, section four. See it skipped. Section three. This is whatever. Section three, four. What is the execution layer? Let's get onto it. It is what you think it is.
00:13:34.782 - 00:13:58.360, Speaker A: The execution is what you think of it is. It's the interesting part of the state transition function. It's the fun stuff. It's where you get to do your crazy applications. Of course, in this system, it's also represented as a function in a very abstract way. It looks like this. You take the previous state of your system, you take a payload that was derived by the derivation layer, and you're going to transition your state into the next state.
00:13:58.360 - 00:14:27.358, Speaker A: This is very abstract in this statement. It says nothing about the EVM, it says nothing about the actual state transition function. It just says you need a state transition function. Derivation and execution in this system work together. They work together to form something that I call the state transition function loop. The loop is very simple when there's a new element that comes in from the data availability layer. So let's say a new block was produced on Ethereum.
00:14:27.358 - 00:15:02.038, Speaker A: We're going to pass that into the derivation function. And the derivation function is going to do one of two things. Either the derivation function looks at that block and it says, there's nothing in here, there's nothing to put into the layer two system, there's no payloads to derive. No transactions were published to the special sequence or address whatever. And in that case, it's just going to wait for the next element to come from the data availability layer to look for the next thing that it might derive. Then the other option it has is to return a payload. If it returns a payload, it's going to pass that payload into the execution function where the state is going to get updated.
00:15:02.038 - 00:15:23.838, Speaker A: Then we're going to go back to the derivation function to see if there's anything new to derive. And this thing just repeats and repeats and repeats. And this is your entire transition function, if you want to see that as a little drawn out image. Essentially we have the data availability layer. A new blob comes in, we derive something. Is it null? Then let's just wait for the next thing to come in. If it's not null, then we're going to derive a payload.
00:15:23.838 - 00:15:45.318, Speaker A: And then we have to execute that payload, see if we derive anything new and it goes in this beautiful figure eight for all of time. Right. This is how derivation and execution work together to form the state transition function loop. All right. Execution in bedrock. Let's make this a little more concrete. How does this apply to what optimism is doing? In optimism, it's just the EVM.
00:15:45.318 - 00:16:09.038, Speaker A: We just changed the EVM. Mostly it's just EVM. We added a few things that you need to do to make a system roll up compatible. The primary diff in our diff is the addition of a new transaction type called a deposit transaction type, which allows contracts on layer one to interact with layer two. Right. It's what allows you to perform deposits. It's essentially the message passing layer.
00:16:09.038 - 00:16:41.446, Speaker A: You need this in the EVM right. Now, I don't know that we know of a way to do it without adding this diff, but it's a very, very small diff. And essentially we're now at less than 1000 lines of code in a single MIT. Here's the diff like Carl showed, and actually 71 of those lines are this circle CI config file. So it's 750. This gives you a really important thing because it gives you support for multiple clients. It means that we can very easily port our diff to multiple clients.
00:16:41.446 - 00:17:23.754, Speaker A: And if you don't have multiple clients, running a bug in a single client can be catastrophic for your roll up, no matter how good the proofs are. Because the proofs are just confirming the execution of your clients. If the proofs are just confirming the execution of your clients, and there's a bug in your client, then the proof is going to say, go ahead, the bug executed correctly and nothing matters. So you need client diversity. And having this small diff is a critical part of that if you want. I don't know if people can scan this should scan this is the diff. Or you can go on our GitHub repo op Geth and you can find it's a single commit, which makes it extremely easy to rebase onto the latest head state of go.
00:17:23.754 - 00:17:43.498, Speaker A: Ethereum makes it super easy to deal with. So, all right, let's continue because I don't have a lot of time left. Just because we're doing the EVM doesn't mean you have to do the EVM. This approach is really, really flexible. There's nothing in this that says you have to do the EVM. You can do whatever you want. You can annoy the maxis and do a bitcoin.
00:17:43.498 - 00:18:07.400, Speaker A: You can put a Game boy inside of a roll up, you can do a python interpreter inside of a roll up. As long as you have a state transition function, you can put it behind the engine API and the rest of the system will just work. Publishing transactions to Ethereum will just work. The fault proof system will just work. Everything just works. You just switch it out. As long as it compiles to mips, you're good, you're fine.
00:18:07.400 - 00:18:34.830, Speaker A: So like Carl said, the sky's the limit. You have so much flexibility with this design, and I highly recommend that you mess around with it. Okay, onto the really final part of this talk. Settlement. Settlement, like kind of the fakest part of all of this. It's a little hard to understand. Is it even a real thing? And I think, yeah, in a way, this is how I'll define it for the sake of the opiece tag.
00:18:34.830 - 00:19:15.886, Speaker A: Settlement is a view that another chain has your chain, and it's about making claims about the state of your chain to another chain and being able to back those claims up. And so if you think about that for a second, that means that you can settle to multiple chains at the same time. There's nothing about this definition that says you can't settle to Ethereum and bitcoin at the same time. There's nothing about this claim that says you can't have multiple settlement layers, settlement mechanisms to the same chain. Right. Because you could be making claims and you could be backing those claims up in different ways. Essentially, it's just about making claims and backing them up and actually, let me get to that in a second.
00:19:15.886 - 00:19:47.990, Speaker A: Well, we'll see. Whatever. Fine. All right, so you can make all sorts of claims about a system, but the one that you'll find most commonly is making a claim about what we call the state route of the system. The state route in Ethereum. If you've played around with Ethereum before, you're probably familiar with it basically is just a commitment to everything, right? The full state of Ethereum. So similarly, generally the easiest thing to do is just to make a claim about a commitment that commits to everything.
00:19:47.990 - 00:20:18.162, Speaker A: And then when you make that claim about the commitment that commits to everything else, you can just prove against that commitment. And now all of a sudden you can do pretty much whatever you want. But that doesn't mean that's the only way to do commitments. You could do commitments about specific claims on layer two. Like this very specific thing happened on layer two. It's just that the most general and generally the easiest thing to do is to make a claim about the state route. In order to make a claim about the state route, we need a function that looks like this.
00:20:18.162 - 00:20:51.734, Speaker A: It's this validity function. This looks very straightforward. We have a previous state, we have the next state that we're trying to figure out if that next state is valid given the previous state. We have the data availability layer, we have the derivation function, we have the execution function, all stuff that we've already talked about. And we spit out a boolean, right? We spit out something that says, is this state transition valid? And so, key question of how do you actually make this work in practice? Right, this sounds great, but how does this work in practice? So look at this carefully. Let's try to figure out where each one of these inputs comes from. On chain.
00:20:51.734 - 00:21:29.198, Speaker A: Let's say we're settling to ethereum. Where does this come from? So state is a given the previous state, we agree on the previous state. Generally that's how we want to design these systems. We start with a previous state that we agree on, and then we have a next state. And even if we don't agree on the validity of the next state, we generally agree on the fact that this is the thing that we're putting into the function. So the first two are givens, the derivation function and the execution function are literally functions, right? They are pieces of code that run, and you could implement those things on chain. The old OVM, optimism's old architecture, implemented those things literally on chain.
00:21:29.198 - 00:22:03.874, Speaker A: So you execute the entire function on chain. Generally speaking, that's not feasible, depending on how complex your system is. So we tend to bypass this, and instead of implementing the functions on chain, we basically implement something that acts like a proxy of the function. And that's usually either fault proofs or validity proofs, right? These are our proxies for the execution, because it's too expensive to actually carry out the execution on chain. But you can think about how this fault proof or this validity proof is representing the derivation in their execution functions. It is the code of those functions. It's just that we execute it in a different way.
00:22:03.874 - 00:22:48.270, Speaker A: We execute it in a way that is actually feasible to do on chain. But the interesting question is, how do we access the data availability layer, right? How do we get access to that data availability layer on the chain that we're settling on? Of course, it's another function. If you remember, our data availability layer takes the form of this array of blobs. So we want a function to access this data availability layer. And kind of an easy way to do this is you have the thing that says get blob by index, right? If it's an array and you have like get blob by index, you can access any element array. But there's something really important being formalized in this idea. And the important thing is that there's two properties that this function kind of encodes under the hood.
00:22:48.270 - 00:23:21.610, Speaker A: The first property is that the ability to resolve this function, the ability to actually return a blob by a given index, is fully dependent on actual availability of data. On the data availability layer. If the data is not available, how are you going to return something out of this function? You just can't. The second thing is that you have to depend on a mechanism to prove that the blobs are correct. Because otherwise I can just give you anything, right? And I can just say, oh, the data was ABC, but it was really something completely different. So you need a proof mechanism. Let's see if we, okay, let me go to this really quickly.
00:23:21.610 - 00:24:05.050, Speaker A: Go back for a second. Okay, so in know the proof mechanism. We'll get to that in a second. But for something like, let's say, celestia, celestia's data lives on a chain other than Ethereum. And so what we need, if we want to prove that a given piece of data is correct, we need to first carry over commitments to Celestia on Ethereum, and then we need to prove against those commitments. So now we're essentially relying on the, not only are we relying on the availability of the data availability layer, we're also relying on the correctness of the function. Essentially the light client that is carrying commitments to Celestia onto Ethereum other than two things that you need to think about when you want to use something like Celestia as your data availability layer.
00:24:05.050 - 00:24:40.434, Speaker A: All right, so let's just look quickly about how bedrock sort of does this validation in bedrock. We start with the latest block. This is the magic, right? Ethereum has this beautiful thing that Ethereum, from the latest block, you can access everything. It's beautiful. The block hash hidden inside of the latest block hash is all of the information about Ethereum for all of time. Because I can start with the latest block hash and then I can reveal block, and I can reveal the previous block hash, and I can reveal the previous block hash for that. And I can just go back in time to infinity, and I can access every single block in the entire history of Ethereum.
00:24:40.434 - 00:25:29.190, Speaker A: And not just every single block, I can pull out every single piece of data in every single block in Ethereum. And so what I'm going to do in my validation function is I'm going to start with the latest block, and all of this is kind of hidden inside of the fault proof, but my program is going to walk backwards and walk backwards and walk backwards and figure out which blob in the data availability layer. In this case, Ethereum blocks. It's going to start the state transition function loop from that's the loop that we just saw, and it's going to apply that loop over and over and over again in the program until you get a final state and you compare that final state to the final state that you proposed. And all of this happens inside of the fault proof. So none of this computation really happens on chain. If you want to challenge it, you just have to do a single step.
00:25:29.190 - 00:26:22.166, Speaker A: But this is the magic of Ethereum, which is that the data is guaranteed to be available and the data is guaranteed to be correct because you're settling and putting data onto the same place. All right, so bringing it all back together really quickly with the multi headed angel thing going on here, there's a lot of content, but there's not that many components to something like this. Remembering the components, we got the data availability layer, which this is array of bytes, array of blobs. We've got the derivation function, which takes the previous state and the data availability layer, and it's either going to spit out a payload or it's going to spit out nothing. You've got the execution function, which takes the previous state, and it's going to take in a payload generated by the derivation function. It's going to produce a new state, and you've got this validity function. And then inside of this validity function you have this get blob by index, right? So all of this composes each one of these different layers is an API that you can plug into.
00:26:22.166 - 00:26:35.814, Speaker A: So you can take this and you can build your dream chain. Right? This isn't just theory. This is in the optimisms code base. In the bedrock code base. You can build whatever you want. Do you want to build a bitcoin plasma? Yeah, you can build a bitcoin plasma. You can do it really easily.
00:26:35.814 - 00:26:57.098, Speaker A: Go build a bitcoin plasma. You want to build a bridge that's actually a roll up. And it has multiple data availability layers and multiple settlement layers. Why not? You want to build another paralyzed VM and raise like $200 million from vcs? Why not? You can do that. You can build whatever you want. You just have to fit the APIs, right. We've boiled this all down to a set of APIs.
00:26:57.098 - 00:27:06.802, Speaker A: If you fill the APIs, you can build it. So that's the whole talk. Thank you. Try to remember life. My name is Kelvin. I'm building the optimism collective. It bedrock specs.
00:27:06.802 - 00:27:16.750, Speaker A: Get in touch. Thank you. Build something cool.
