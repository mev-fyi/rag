00:00:18.210 - 00:01:29.150, Speaker A: Everybody, I'm Casey, and I asked to moderate this panel because I've been working on EVM and EwaSM lately, and I know there are no other experts besides these panelists. So you saw Martin's talk yesterday on. Well, it was on Primea, but it mentioned the precursor to Primea, which is ewasm, and that started in December 2015. By the summer of 2016, the first commit was in April, but by the summer, there was a pretty working prototype for the EVM to ewaSm transpiler. So that was the EVM 2.0. So after the 2.0 proposal came the one five proposal from Greg and Pavel.
00:01:29.150 - 00:02:34.870, Speaker A: And you just saw Pavel's talk earlier about EVMC, which is sort of the API to plug in and be able to swap between ewaSm and Evm one five. And then came, earlier this year was Julia. Yesterday also, we saw Alex's talk about Julia, which he and Christian designed to upgrade solidity and be able to make solidity target the EVM 2.0, the next versions of the EVM 2.0, and one five. And then. And since then, also, Pavel has made a lot of progress on the legit vm.
00:02:34.870 - 00:02:59.760, Speaker A: So it's sort of been backwards, where first EVM 2.0 was proposed, then more progress on EVM one five. I hope this makes some sense. So I think I'll ask our panelists, what is ewasm, and what is EVM one five?
00:03:04.260 - 00:03:05.810, Speaker B: Who wants to talk first?
00:03:08.960 - 00:04:35.960, Speaker C: When I arrived, I guess ewasm had made some progress, substantial. And a few things struck me. One is, people were sort of excited because, gee whiz, you could run c contracts in ewasm. And as a c expert, I said, why on earth would you want to write contracts in c plus plus? Haven't people lost enough money on the blockchain already? And the other thing that struck me was, why on earth would you want to hand over to an outside committee the definition of anything to do with the core consensus protocol? And I looked at the current EVM and said, there's an awful lot of white space for more opcodes, and this thing's not broken. It just needs a little work. So I set out to say, what do we need to do to this to bring it up to modern standards and make good use of modern hardware? So I got to work on that, and I got a lot of help from other people on the c team. The documentation would not have happened without Christian.
00:04:35.960 - 00:05:19.610, Speaker C: And so the team put a fair amount of work into that. We've got a couple eips. Martin has put a lot of work into the ewasm proposal. So they're sitting there and we'll need to make some choices, and we might throw both of them away and say, okay, we've learned a lot. What should we actually do? We might choose one of them. We might stick with what we have and ask, can we advance our compiler technology to compile what we have into code that runs better? And Pavel can speak better to how possible that actually is.
00:05:20.540 - 00:05:34.350, Speaker D: Yeah, I would be very happy to have any of these, but to add it more constraint to the control flow would help a lot there, and I believe we can do much better in Jit like evms if we have that.
00:05:36.160 - 00:05:46.976, Speaker E: But just a step back. So last year when you came around and EVM 1.5 came around, it was still in a point of time where Webassembly was not finalized at all.
00:05:47.078 - 00:05:47.440, Speaker C: Right?
00:05:47.510 - 00:06:20.120, Speaker E: And there was no knowledge, at least we didn't have any knowledge when it's going to be finalized. There's no idea since then this year the first version came out, so that problem went away. And back a year ago, we had no idea when it's going to be finalized and how it's going to look like when it's finalized. So that was a big concern. And I think because of that, EVM 1.5 made a lot of sense to maybe bridge the gap or have like a backup plan, assuming that EVM 2.0 would be finished in time.
00:06:20.120 - 00:06:42.610, Speaker E: But we cannot release it because the webassembly isn't finished. And then if we could finish even 1.5 quickly enough, it could be a good bridge between the two. But that problem went away today, well, earlier this year. So how do you feel about the brokenness of EVM since? Did anything change?
00:06:45.560 - 00:06:47.700, Speaker C: I think ewasm is going to die.
00:06:48.440 - 00:06:49.780, Speaker E: Why do you think that?
00:06:49.930 - 00:06:56.340, Speaker C: Because there's been so many attempts to get a binary format running in browsers, and they've all failed.
00:06:57.080 - 00:06:59.444, Speaker A: You're saying webassembly is going to die?
00:06:59.572 - 00:07:03.450, Speaker C: Yes. Wasm is going to die, whatever I said, I don't know.
00:07:04.140 - 00:07:55.290, Speaker A: That's a bold prediction. But maybe we can step back and say, what are the problems with the current EVM 1.0? I mean, one problem is that the gas limit in each block is not enough to do everything people would like to deploy contracts to do. Because one example is the Blake two B, pre compile. There's a proposal for these native pre compiles, and pre compiles solve the problem of contracts that people would like to deploy, but they might take 100 million gas when the current block gas limit is 6 million gas. So how does EVM, one, five, or webassembly solve this problem?
00:07:56.860 - 00:08:12.060, Speaker B: Well, Webassembly would allow you to just compile code directly to webassembly, so you most likely don't need native contracts because you would just write them in Webassembly.
00:08:13.540 - 00:08:46.840, Speaker C: Yeah, it's partly gas, but it's partly just that it's too mean. Pavel was working, I remember on one of the pre compiles you were like pushing all the compiler flags as far as you could and trolling through multi precision libraries to find one that was mostly in hand coded assembly. We just can't get enough speed out of the VM for these pre compiles.
00:08:47.900 - 00:08:56.156, Speaker A: How is one, five and 2.0? How are those becoming faster than 1.0?
00:08:56.338 - 00:09:15.060, Speaker C: Like my little grade school example, you do a multiply and you're doing one instruction on a 64 bit pair of registers, as opposed to long division or long multiplication on a collection of registers.
00:09:16.360 - 00:09:55.010, Speaker D: I think the current issue we have is quite big difference in terms of speed comparing to native code, so we cannot actually effectively encode the algorithm we want there. For example, some hash functions, if you like, to implement them in pure smart contracts that make them quite expensive. And you have to pay for that, you have to pay a lot for that, because it's just the current EVM is not capable of express enough.
00:09:56.820 - 00:09:57.184, Speaker C: To.
00:09:57.222 - 00:10:24.920, Speaker D: Have comparable speed comparing to native code. And I believe that's what for example webassembly gives, it's at least comparable. Like if you implement the same hash function in C and webassembly, at least you have comparable of them and not having ten to 100 times slower performance.
00:10:26.140 - 00:11:11.320, Speaker E: But actually if you take a step back to the first version of EVM and look at why do we have, or why did we had an identity contract just for cheap memory copying? That maybe shows that we didn't had everything thought through properly. And we started to introduce these precompiles, especially the one for copying memory. That means loading and storing memory was too expensive, yet we still wanted to do it. So we introduced the precompine. Another bigger issue, which Greg mentioned several times already, is the bitwidth everything is 256 bit. And there was a proposal even before the 1.5 to have 64 bit arithmetics in EVM.
00:11:11.320 - 00:11:49.408, Speaker E: You have folded that into the CMD proposal, so it's still there. But if we just look at these two problems, that it's quite wide for arithmetics and we started to introduce all these precompiles just to get around that. That probably shows that we didn't figure out the prices properly. And with Webassembly, as Pavel said, it resembles the instructions much more closer to traditional computers. So there's a much, probably much easier way to figure out what the real cost for those instructions are. And by figuring out the real cost, we can probably avoid having pre compiled.
00:11:49.584 - 00:12:07.690, Speaker C: That would be nice. It's worse than ten to 100. My graph was scaled by square root, and the slowest exponential operation compared to the fastest native code was 10,000 to one.
00:12:10.400 - 00:12:13.470, Speaker B: But that was on EVM to wasm, right?
00:12:14.640 - 00:12:19.820, Speaker C: It was actually go versus C plus plus compiled straight to assembly.
00:12:24.260 - 00:13:48.120, Speaker A: Another advantage of another motivation for the EWaSM proposal was to be able to write contracts in other languages that target webassembly as a compilation target versus only targeting EVM. So we have the EVM two ewasm transpiler as a prototype. We don't yet have the ewasm two Evm transpiler. So the reverse, which would make the EVM one five proposal equivalent to almost the ewasm proposal, because then you could still write languages. Write a contracts in languages that Target webassembly, transpile those to EVm one five. I've asked before, what would it take to write the EVM, the ewasm to EVM one five transpiler? And Greg said it would be easy. Martin said, good luck.
00:13:49.500 - 00:13:50.468, Speaker E: Good luck.
00:13:50.644 - 00:13:52.008, Speaker C: You told me it would be easy.
00:13:52.094 - 00:13:55.048, Speaker B: It's not impossible. I would never say it's impossible.
00:13:55.144 - 00:13:56.508, Speaker C: You said it would be easy.
00:13:56.674 - 00:13:58.270, Speaker E: You told me it would be easy.
00:13:59.360 - 00:14:01.884, Speaker B: I don't know. It's going to be some work.
00:14:01.922 - 00:14:04.080, Speaker C: It was on a fire escape in Berlin.
00:14:06.580 - 00:14:07.760, Speaker B: Was I sober?
00:14:08.180 - 00:14:09.250, Speaker C: I don't know.
00:14:11.060 - 00:14:45.340, Speaker A: And also one of the motivations for just skipping EVM one five, because the original proposal was just going straight to 2.0. The EVM one five proposal came later. And one of those reasons was because, well, it must be hard to write a JIT compiled VM. And then Pavel wrote a prototype of an EVM JIT. VM was that easy? Pavel.
00:14:46.960 - 00:15:38.860, Speaker D: So actually, the prototype of that, it's still a prototype. It was done even before the launch of Ethereum. It was one of the performance benchmark project that we want to have to actually assess what can we do in the future in terms of smart contract performance. But, yeah, it still struggles with some cases. And as I said, we can do much better in this case. But on the required step, it's at least this control flow restrictions and subroutine support directly in the EVM bytecode. That would allow even more optimizations.
00:15:38.860 - 00:16:09.720, Speaker D: But on the other hand, JIT compilers are hard. The network consensus depend on that. And the risk is we might get hard or it might be never finished in terms of removing bugs and finding edge cases, because that's much more complex construct comparing to interpreter.
00:16:11.900 - 00:16:38.736, Speaker F: Another problem with just in time compilers is that I'm not sure if there is a just in time compiler that provides a fixed upper bound in terms of resource consumptions. And this is a very important guarantee that we need in order to do the gas calculations properly, right? I mean, usually just in time compilers generate code that is faster and takes less resources, but we don't have a guarantee. Or do we?
00:16:38.838 - 00:17:18.780, Speaker C: Well, as I said, we can't do a Jit, it's exploitable. It has to be a compiler that runs at deployment time, not at runtime, which means it can be a full compiler depending on how long we want to take to load a block. And my understanding is storage is the main constraint there anyway. But I remember in my testing I came up with one performance bottleneck, and you said it's not a priority, I don't think I can get to it. And the next day you had it fixed.
00:17:20.240 - 00:18:30.196, Speaker D: Yeah, this is a bit different issue. In Ethereum we actually care about the worst cases because this is what the cost must be for. This affects more complex optimizations, but also the big integer libraries that actually try to squeeze the easy cases first. But this is not what we point to. We don't care if we can divide quickly for small numbers, because what we care is to have the worst case covered. So yeah, that would be much more difficult to control that within the JIT, because it's like you have the big, at least in the evM jIT that depends on LLvM, you have a big backend library that does that for you, and it's really hard to tell what it's actually doing. But yeah, I guess there are different approaches to that.
00:18:30.196 - 00:18:39.320, Speaker D: And for example, ewasm has some JIT prototypes that are not depending on LLVM.
00:18:43.060 - 00:19:26.780, Speaker C: Of course, one of my bigger concerns is not technical. Either of these programs technically does the job. I'm much more concerned about who controls the specification, and I really believe that the Ethereum community should completely control that specification. The web browser space is not the Ethereum space, and I would not want to get wedged with the wasm group moving in a direction they need to move and us shaking our heads and going, no, we don't want to go in that direction.
00:19:27.120 - 00:20:11.964, Speaker B: Yeah, I disagree with that, because I think it's much more pluralistic to go with a larger community, a larger body of people standardizing and coming to consensus on a virtual machine, instead of just using a virtual machine that was created to only be used in one specific use case. And if you look at the browser use case, it is very similar to the blockchain use case. We need secure, portable and size efficient bytecode. Right? It's the exact same concern we have in the blockchain space.
00:20:12.162 - 00:20:13.788, Speaker C: Technically I agree.
00:20:13.954 - 00:21:23.940, Speaker B: And furthermore, it's open to participation. You can go to the Webassembly community meetings, you can voice your opinions, you can submit proposals on GitHub. It's very open, and it's easy to get involved within the blockchain space. I know of at least three other blockchain projects outside of Ethereum that are already prototyping and actively have wasm running in their systems. So we're seeing a lot of momentum, I think, pick up around it. And I think that's sort of just going to be the way it is, because once we start to have consensus around a vm, everyone is just going to be the obvious choice. Everyone's going to use it, and it's going to be a recursive feedback loop, right? It's going to be a feedback loop where since there's more people using it, we're going to get better tooling for it faster, we're going to get better implementations, et cetera.
00:21:25.160 - 00:22:06.850, Speaker E: But it's not like hypothetically, if you introduce EVM 2.0, it's not like that VASM would introduce a new update and that magically would work on Ethereum. As you mentioned in your talk, both 1.5 and 2.0 have a verification code which has to run prior deploying the contract, and that verification code verifies according to the eWASM specification, which is the current list of opcodes in Webassembly. So if they introduce new opcodes, they wouldn't work without us making decision that we want to support them. So I don't really see that as a risk that we would be exposed to random new instructions being supported by ethereum without our review first.
00:22:07.940 - 00:22:48.044, Speaker C: I'm more concerned. So we come along and there's an issue with WaSm. I mean, bugs show up in specs, or if not a bug, an ambiguity. And we resolve it one way and it works for us, and we can't wait. If something's a little weird in a browser. It's not a big deal and the committee will get around to it, but if there's anything that breaks consensus, we have to fix it immediately. And then eventually it gets around to the committee and they go, no, we don't like the way you fixed it.
00:22:48.044 - 00:23:16.490, Speaker C: We're going to do a different fix. And I just feel like over time we will wind up forking away from that standard and we will lose these benefits of shared design and tooling anyway. In fact, we're a fork to begin with. We're a subset. I spent a couple of weeks trying to get C plus plus into waSm. I succeeded, but it wasn't easy.
00:23:17.340 - 00:23:27.816, Speaker E: I think that's misleading. It's a subset, but the only subset being we don't let floating point operators. Yeah, that's the only subset, but you.
00:23:27.838 - 00:23:31.470, Speaker C: Have to convince the compiler not to do that.
00:23:31.920 - 00:23:35.432, Speaker E: Yeah, that should be pretty easy. I mean, if you don't use floating.
00:23:35.496 - 00:23:42.160, Speaker C: Point inside, the compiler can decide that it's going to use the floating point unit just because it feels like it.
00:23:42.310 - 00:23:44.560, Speaker A: Fortunately, we're out of time, so we'll have to.
00:23:44.630 - 00:23:45.200, Speaker E: That's fine.
00:23:45.270 - 00:23:46.770, Speaker B: Good floating points.
00:23:48.020 - 00:23:49.440, Speaker D: What about Julia?
00:23:50.180 - 00:23:50.880, Speaker A: Sorry?
00:23:51.030 - 00:23:52.500, Speaker D: What about Julia?
00:23:54.760 - 00:24:02.116, Speaker A: Julia, I think, Christian, you're going to cover Julia a little bit in the flexibility solidity. Talk later?
00:24:02.298 - 00:24:06.440, Speaker F: Not too much. I mean, Alex talked about it in quite big details.
00:24:07.820 - 00:24:29.870, Speaker A: Well, it's a very active debate. EVM one five versus ewasm. Hopefully we can, through the magic of transpolation, come to a united front and move forward with the evolution of the. With evolving the EVM 3.0. Thank you.
00:24:34.960 - 00:24:35.930, Speaker B: What do we do with her?
