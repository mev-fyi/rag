00:00:21.770 - 00:00:24.240, Speaker A: They're subjecting me to this again.
00:00:24.610 - 00:00:25.360, Speaker B: And.
00:00:26.010 - 00:00:59.310, Speaker A: And the title was supposed to be a placeholder, but George, he liked it so much, he made me keep it louder, louder. I was supposed to have a headset, too, so I didn't have to do this. But here we are. My job when I got here was to take this interpreter and make it go faster. I wanted to make it scream like this. This was exactly the image I had in mind. There was a kid in junior high art who just drew pictures like this over and over.
00:00:59.310 - 00:01:08.260, Speaker A: I love them. The art teacher didn't. And there's a little video you can play here. This is the jit that I'm competing against.
00:01:09.590 - 00:01:12.690, Speaker C: There's no sound. It's screaming.
00:01:13.030 - 00:01:31.930, Speaker A: Oh, well, you don't get to enjoy the sound. What I had was a jit. This is a Plymouth Belvedere. It's a comfortable family sedan. Compared to the jiT, it looked like this. It was pathetic. It was really pathetic.
00:01:31.930 - 00:02:09.590, Speaker A: And what was I going to do? Okay. To make it faster. The first thing I wanted to do is I didn't really know how the code worked. I couldn't really understand the yellow paper. Some people tell me it's wonderful, but I'm a machinist, not a mathematician. So the idea was a small series of correctness preserving transformations, assuming the code was correct to begin with. I make a small change and I run a test.
00:02:09.590 - 00:02:45.170, Speaker A: And Dimitri here had a wonderful suite of tests. I'm not sure how many tests are there, Dimitri. I know at one point I broke thousands of them, and I wasn't looking to make any structural changes to the machine. Just get out of the way. Anything that was hurting the performance. A lot of the instructions were using infinite precision arithmetic. Almost none of them needed to.
00:02:45.170 - 00:03:33.300, Speaker A: I was able to get away with 512 bits. The gas calculations were being done with 256 bits. The go machine had already switched to 64 bits. Two to 256 is approximately the number of atoms in the universe, which I thought was probably more gas than anybody was ever going to need. So in general, also, there was one routine which was doing all of the gas and memory computations. It was doing it for every single instruction that it ran. And that routine was generally more expensive than the computation itself.
00:03:33.300 - 00:04:16.410, Speaker A: So that was a matter of breaking it into little pieces and running only those pieces that were relevant to the routine that I was trying to run. There it goes. And so when you're done, you've stripped out everything from that Belvedere that was in the way of making it go faster. And you have the Roadrunner, which was Plymouth's attempt to compete with the Dodge charger. And it did pretty well. And this is the interpreter, which is shipping in today's code, the loop test. It's hard to make much faster.
00:04:16.410 - 00:05:02.750, Speaker A: It just goes in a circle, and the jet sees that circle and reduces it to almost nothing. The RNG test is a little random number generator. Old style newth generator just does a lot of computation that's respectably faster. Not where I wanted it. The RC five interpreter is the old RC five cipher, so it's not much used anymore, but it's a good example of an actual program. And to get from there, the approach was to start making more actual changes to the structure of the interpreter. So I wanted some new, faster opcodes.
00:05:02.750 - 00:06:04.180, Speaker A: I wanted a constant pool that is currently, if there's a push instruction, the constant to be pushed is laid out right in the bytecode. It's in most significant byte first order, and it has to be loaded up into the stack one byte at a time. So I create a pool of preloaded constants. I can index them with one byte and move them onto the stack with a quick assignment. So that's specifically a new push C instruction that just has that one byte, so I can just index in. The other thing I did, which Jeffrey has also done in the go interpreter, is that all of the jumps in the EVM are computed go to. How many Fortran programmers left in this room? Wow, three.
00:06:04.180 - 00:06:45.498, Speaker A: I make four. That's scary. It's the only language I recall besides assembly with computed go to. Trouble with the computed go to is at runtime, you have to check as to whether the go to is going to somewhere valid or just landing in the middle of nowhere. And that takes time. So what we do is at load time, we look to see is the place it's going to constant, is the place it's going to correct. If so, I replace the jump with a jump v or a jump vi, and I can just do the jump at runtime.
00:06:45.498 - 00:07:24.646, Speaker A: And both the go and the c plus plus interpreters have found that to be pretty advantageous. And so tomorrow's interpreter, which is running on my machine right now and not anywhere else, we're starting to look pretty good. The loop is a little better. Still not wonderful. The random number generator is starting to get pretty competitive with the jit, and rc five is really doing pretty well. Paul's got some work to do to catch up with me. And here we have a race.
00:07:24.646 - 00:07:37.920, Speaker A: We have the jit is the charger on the left, and we have the interpreter on the right. And make it scream. Roll it.
00:07:39.410 - 00:07:40.960, Speaker C: Where'd soup go?
00:07:45.650 - 00:07:49.700, Speaker A: There's a video to play here. Somebody knows how to play.
00:07:55.370 - 00:07:55.926, Speaker B: It.
00:07:56.028 - 00:08:06.280, Speaker A: No, this guy, he's a video. He plays. There we go.
00:08:07.770 - 00:08:08.520, Speaker C: Sound.
00:08:10.490 - 00:08:46.740, Speaker A: Legit? Twinning. I'm patching up. That's a quarter mile. Yeah, heck, with Teslas, they don't burn enough alcohol. So that went backwards. So where to go from here? Well, then to get from here, you have to start doing completely different. This is a blown Hamai that burns alcohol instead of gasoline.
00:08:46.740 - 00:09:27.492, Speaker A: And these are ideas on the table we're going to work with. First, just some fine tuning. Right now we're using the boost library for the 256 bit arithmetic. It's really designed for much bigger arithmetic. So right now it's using 564 bit words to do just 464 bit words worth of arithmetic. So I'm going to look at the GMP library, which will use just four. It's written in assembly language instead of c, and we'll see if we can do better with that.
00:09:27.492 - 00:10:26.964, Speaker A: If nothing else, those four words will line up on cache line boundaries, and that's always good. And 64 bit arithmetic, we've got to get some opcodes for 64 bit arithmetic, because counters especially nobody's going to count for the number of atoms in the universe. The interpreter can only make a little bit of good use of this, but the jit can really be helped by knowing that it's only got 64 bits to work with. Simd. An awful lot of silicon on the chips right now is SIMD operations. And a lot of crypto stuff can take a really good advantage of SIMD registers. So we're looking at that and more structural changes right now.
00:10:26.964 - 00:11:01.500, Speaker A: DVM is a stack machine. If you want to add two numbers, you push a one on the stack, you push a two on the stack, then you say an add, it adds two, it pulls two of them off the stack, it pushes another one on the stack, and off you go. This was like really great for hand calculators. Very good way to do hand calculators. Real chips anymore are register machines. The problem here for a jit, that's the way you do it. But jits tend to run in the background.
00:11:01.500 - 00:11:39.996, Speaker A: They can run slowly. So I'm looking basically for a very fast order n algorithm to get me from stack code to registered code. I've done it before for a different vm, a java vm. So I've got to find a way to make it work for the EVM and probably would go with just 256 registers. I think that'll be enough for most purposes. Again, I can index them with one byte so I don't blow up the code too much. And the code becomes basically three address code.
00:11:39.996 - 00:11:53.890, Speaker A: So one byte for the operator, three bytes for the source, the other source, and the destination. And that goes backwards. But, gee, I like that. I want one of those.
00:11:56.420 - 00:12:00.210, Speaker B: And we'll see what happens.
00:12:05.220 - 00:12:07.830, Speaker A: And that's that. Who's next?
