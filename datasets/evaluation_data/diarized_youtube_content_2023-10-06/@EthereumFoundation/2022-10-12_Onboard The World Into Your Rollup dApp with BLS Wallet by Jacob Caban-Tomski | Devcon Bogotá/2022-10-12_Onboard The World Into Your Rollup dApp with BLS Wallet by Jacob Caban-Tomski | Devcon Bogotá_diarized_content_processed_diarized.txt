00:00:15.370 - 00:00:17.840, Speaker A: And welcome everybody. How's everyone doing today?
00:00:19.170 - 00:00:19.920, Speaker B: Nice.
00:00:21.410 - 00:01:11.714, Speaker A: All right, I'm Jacob Kamontomsky. I'm a developer on the BLS wallet project, and here with me today is James Zackey, who is our project lead, and we're going to talk about BLS wallet. Anyways, what we're going to cover today when the next slide pops up is we're going to go over at a high level the team and project outcomes, a little bit on the basics and a high level overview of BLS signatures and aggregation. We're then going to cover where BLS Wallet is today with some examples and some of the features we have built in, and then we're going to cover where we're going next with the project. And finally, we should have ample time for questions. So we'll kind of go over the team and some project outcomes to start. This is our wonderful team over here.
00:01:11.832 - 00:01:13.314, Speaker B: Half of it off a little.
00:01:13.352 - 00:02:18.550, Speaker A: That's okay. We're scattered all across the globe. We're part of the privacy and Scaling Explorations group, which is a subgroup of the Ethereum foundation. We work mainly with zero knowledge proofs and L2 scaling technology. Our goal is to bring more privacy and scalability to the Ethereum blockchain system. So some of the outcomes we want to try to reach with our project, and the primary one are north star or here in the southern hemisphere of the southern Cross, is going to be reduce the cost of l two transactions, primarily by reducing the amount of data that is rolled up into l ones by reducing transaction size. Currently with some initial numbers, which are a little difficult to see right now, we've essentially simulated running 150 ERC 20 transfers, both regularly, normally on a roll up, as well as bundling them all together into a single l two transaction using BLS wallet, and we've gotten it down the transaction data size by about a quarter.
00:02:18.550 - 00:03:08.498, Speaker A: We're hoping that we can go even further than that. We still need to measure the impact that we're going to have on layer one gas costs to see how the transactions are actually going to be reduced. But our team likes to limbo and we want to see how low can we go with using some things involving address books as well as some other indexing things to reduce that call data even lower than where it's at. We'll get into how we reduce that size in a moment. So another outcome we're looking for is to be able to improve wallets. One of the features with that is going to be account recovery. Sometimes people talk about as social recovery so if your private keys are compromised, is there a way you can swap to a more secure set of private keys and what kind of features, functionalities and security that will enable.
00:03:08.498 - 00:04:41.270, Speaker A: And then we also want to have upgradable functionality for wallets so you can change what features and things it has over time so that wallets can serve a more diverse set of users across the entire ecosystem. And finally, we want to make Dapps a lot easier to use. And so part of that is by having a baked in multicol, or we call it multi actions, where you can take multiple transactions and put them into one, and then also having sponsored transactions where the user does not have to pay gas on their end and the Dapp sponsors it instead. So that way when users first come in to try a Dapp for the first time, they don't have to go say, to an exchange to buy Ethereum so they can pay gas for transactions. So to start off, we're going to cover BLS signatures and aggregations at kind of a high level. BLS stands for Bon Lin Chachem is a pairing cryptography based signature scheme used in the Ethereum consensus layer, zcash and a number of other projects. It is deterministic for a given public key and message validators currently are using BLS signatures specifically on the BLS twelve, three eightyve to sign messages on the consistency layer and then inside of the EVM execution layer we have access to the BN 254 curve via EIP 197 that allows us to which we use in BLS wallet for both signing and then verifying on chain the transactions.
00:04:41.270 - 00:05:46.250, Speaker A: We're hoping in the future via newer EIP that we will be able to actually move to the beacon chain curve for more security and for better access to frameworks that the beacon chain is using to improve that signature. But the most important thing for us is signature aggregation. And what we're able to do with the BLS signature scheme is take multiple signatures and merge them into one signature. So normally with the signature space you'd have taking up, we can shrink it into just one. And this is really good for reducing the data that we roll up into an l one, because normally when a roll up goes in, it takes all of the transaction data as well as the signatures for each of those transactions, specifically the rs and v components of that signature. Instead, we can use one BLS signature across all of those transactions plus one ECDSA signature, and save on that data that we roll up. And that's in the example we saw before, why the actual transaction data payload is much smaller.
00:05:46.250 - 00:06:59.790, Speaker A: If you're interested in learning a bit more about the underlying op pairing cryptography, there's a really good visual guide at cryptology which will go into the actual aggregation and more about the actual BLS signatures. So let's get into where we are today with BLS wallet. So at a high level, as per most normal DAP usage, you're going to have a browser that's going to have a extension usually in the wallet, and that's going to be communicating to some RPC node. And we have the same setup in our example prototype extension. We're then going to, in our case though, have a set of user operations that we forward to an aggregator service which is going to take many disparate operations and merge them all together into one and submit them to an l two node which then will execute against our contracts for the verification of the signatures, and then through the smart contract wallet to dive into that a little bit more. At a high level, we're going to have a DF starting out by generating the operations which contain a set of actions, and we'll go into what that format looks like in a second. The wallet extension will then use the BLS client module to sign all of those with those BLS signatures.
00:06:59.790 - 00:08:01.414, Speaker A: Those are then submitted into this aggregator service to create a single bundle of operations with one aggregated signature. Then the bundler aggregator will take that set of transactions and we'll submit them into the L2 EVM, where we can do some work with expansion to expand the call data parameters into more advanced or more verbose data. We do the BLS signature verification across those, and then finally for each of those operations and actions, we submit it to the actual contract wallet, and that is then executed against the actual underlying DF code. So the first feature we're going to dive into is the multicolor action for this. So this is a library that our teammate Andrew helped write. If you want to try it out, you can NPM install BLS wallets clients still keeping that edge of that stage in there. We're going to have a bundle that we're generating and the wallet's going to sign it.
00:08:01.414 - 00:09:01.346, Speaker A: That operation is going to have a nonce, which is going to be the current wallet nonce. For if the wallet hasn't been created yet, and it's going to be lazily created, it'll just be zero. We then have an array of actions where those actions are atomic. So if any one of these actions were to fail, then they all would fail. Inside of that you can specify an f value as part of that the contractor targeting and then finally the encoded function that you'll send over. In the case of the example we have up here, we're doing an approve and a swap on a simulated DeX, and instead of it having to be two separate transactions, we can just merge it into one via that format using building on top of this, we've built a prototype browser extension wallet called Quill and fast cool called Quill with Andrew and Katuk. And as you can see here in an example we have a standard transaction confirmation which contains three actions inside of it, one of them in the middle being an approve.
00:09:01.346 - 00:10:02.190, Speaker A: So instead of a user having to go in and separately run a transaction for approve and say transfer and something else, we can do it all in one and have just one confirmation dialog pop up to them. If you want to learn more about how we have this set up and how you can integrate the Dapp into it right now, you can find out more at the link below in our GitHub repo on how to integrate that in. So next we'll get into sponsored transactions. So right now the pattern we're using to have these sponsored transactions is to have our normal flow. But in the middle we're injecting in this top center portion the aggregator, an aggregator proxy which essentially is taking those operations we would normally submit to an aggregator and is instead sending them to it where it qualifies to see if they can be funded for free gas basically. And so then that aggregator proxy will add that payment bundle in there and then submit it to the normal aggregator, which requires a fee. And this allows for us to have those gasless transactions.
00:10:02.190 - 00:10:43.210, Speaker A: Our teammate John has built a very cool demo using Scaffoldeth for the Scaffoldeth community, which is a single pool Dex. As you can see here, it's a just single pool Dex with a swap. It does use the multi action as well to do the approve and the swap inside of it. And then it all runs inside of the browser with no need for upfront gas because the aggregator proxy is going to subsidize it. And so that allows for a free transaction. You can find out more at the GitHub repo below and it also is deployed at singlepooldexreactapp versel app. We're also looking into doing this directly via a contract.
00:10:43.210 - 00:11:44.000, Speaker A: The way the aggregator currently works is when it receives a bundle, it's going to actually introspect and look at whether, when it simulates executing that transaction, if it gets paid either in f or we also allow ERC 20 tokens. If it sees that it happens, it will include it in the bundle. It's going to submit to L2. So one of the ways you can take advantage of this inside of a contract is just have it pay transaction origin and then the aggregator will get paid. You can also do things potentially like gate this payment via an allow list, ownership of an NFT, or potentially even something like a ZKP proof so that you can only allow certain people to have access to that. This also allows anyone potentially to be a bundler and submitter, potentially even MeV bots that are looking for profit and be able to submit those in so that you don't have to go through a specific aggregator and you could submit to say just a general, say bundle mem pool going on top. We still have more research to be done to figure this out, but we believe it should be pretty feasible and possible to do.
00:11:44.000 - 00:11:48.890, Speaker A: All right, and now I'm going to hand things over to my teammate James.
00:11:48.970 - 00:12:16.690, Speaker B: James, thank you. You've done pretty well, given the slides have been a bit off and we've just lost our speaker notes, but okay. Yep. So with recovery, it's kind of catastrophic. With an EOA, if your private key is compromised, you're basically racing against an attacker to secure your assets. But with a smart contract wallet, we've implemented a recover function that requires basically setting a recovery hash from that hash. Yeah, we've got the notes now behind the timer.
00:12:16.690 - 00:13:02.838, Speaker B: Yeah. So with a recovery hash, it just consists of the address that you're going to trust to call the recovery function and the hash of the wallet's public key that you're addressing and some salt so that an attacker can't actually deduce your recovery address or the wallet that will call that. So when you do call recovery, you pass in those parameters and you are the caller itself. Then you can immediately reset your BLS key and yes, basically stop the attacker who may have attempted to take some of your assets or set some of the other functions. So if an attacker steals your key and tries to reset your key, they can't do that because there's a one week delay in setting that parameter with your recovery. You can do that straight away. So as soon as you see a problem in that someone's trying to set something that you didn't, you can intercept it.
00:13:02.838 - 00:13:59.842, Speaker B: With this. We take advantage of the fact that when you first set your recovery hash, it will set it immediately, but otherwise it's a secure function, so it will have a delay and in doing that, you can do something quite fun with that, in that if you want to onboard your users, you can put a wallet inside the browser and have them use that. You can send them some assets, like give them basically a web two usability experience, but they actually have web3 assets in their browser wallet. But then at some point they may wish to secure those assets further. So you have the smart contract deployed, you have the key inside the browser, but that's not very secure. So you can do something like suggest to the user that they set the recovery hash of their browser wallet, and you can do that via the DAP, and then from the secure wallet that you've prompted them to install. Like if it's our prototype extension quill, you can then recover the wallet that was in the browser.
00:13:59.842 - 00:14:30.946, Speaker B: And what you've done is effectively set the private key to the extension key rather than the one in the browser, so that one's lost and you've secured it. We find that's just a smooth way to onboard people. So where to next? So let's sort of start with where we began. So we were looking primarily at aggregating signatures, obviously to reduce the call data towards layer one on roll ups. And we wanted to, I don't have slides here. So, yeah, I wanted to leverage account abstraction, which was at the protocol layer first. So that was EIP 2938.
00:14:30.946 - 00:15:12.954, Speaker B: With that, we realized there could be some delay for that, and also that seems to have paused since then. So we decided at that time to focus on a BLS only signature scheme, because that's what we needed, and that would be a contract wallet. We did some preliminary optimizations, like parameter deduplication. So if you have a bundle with a lot of common parameters, you can effectively, like factorization, you take it once out the front and fill in the gaps. So something like an airdrop is really valuable. So if someone wants to do an airdrop, they can send a bundle of transactions they pass in one contract they're interacting with, it's one sender, it's one address that's calling it, and then some of the parameters are the same except for the recipient. And in that case, you can effectively deduplicate the parameters.
00:15:12.954 - 00:15:30.286, Speaker B: There. I've got to ignore that screen. There we go. Yeah. Some of the wallet features we then focused on were, as Jake described, sponsored transactions, multi action recoverability and upgradability. And then we heard about EIp four three seven. That started to gain some interest and popularity.
00:15:30.286 - 00:15:55.034, Speaker B: And at that time, our contracts were going for audits. So we're trying to figure out do we just finish what we're doing or look at that. So then we decided to look towards being compatible with 4347. So that's where we are now, where to next? We still focusing on aggregating signatures for the lowest cost transactions. On L2 we will be focusing my slides moving around. Yeah, still focusing on aggregating signatures. And then we are working on being four three seven compatible.
00:15:55.034 - 00:16:24.840, Speaker B: One of our colleagues is almost there with that and I noticed is that draw in the background, say hi, she's working on four three seven. What I should explain. Yeah, four three seven is doing account abstraction on chain. So they've got basically a smart contract template for that and a structure for how that will work regarding paying gas as well. The way we originally did it, as Jake described, is putting in a reward to the TX origin so that MEV bots can process the transactions. But there's also the way using the alt mem pool that four three seven proposes. So we can do either of those depending on what the DAP wants.
00:16:24.840 - 00:17:04.338, Speaker B: Further optimizations. The 4337 user operation contains more gas parameters to take care of the way they do that. But for when we want to do it the direct payment way, we can again optimize those parameters out by not passing them in, having a preceding function that then populates them with zeros. And then from there we can do public key mapping. So we have smaller data sent in for the larger addresses, sorry, larger public keys, and also doing things like floating points. So if a bundle has a lot of variables that are actually within a specific range, we don't need to pass in a UN 256 bit number for each of them. We can actually have some smaller range for those.
00:17:04.338 - 00:17:38.480, Speaker B: So saving bytes wherever we can. There's a lot of things we want to do there, just almost like say a refactor phase. We want to bring some of the stuff we have in our current wallet basically into modules. So we may consider using safe for that and some of the examples in four three seven. And then we will inherently benefit from 4844, which is towards dank shutting. So when we take a step back, what we're doing is lowering the transaction costs on L2. And when you do that, it increases the number of viable applications that can be built or viable solutions that can be put out there to solve problems.
00:17:38.480 - 00:18:02.950, Speaker B: And I like to sort of visualize it like this. On the x axis we've got transaction costs and we have a lot of defi things going on. And that works on layer one, even if it's during a busy time and there's high gas costs. A high value asset transfer is worth it. You will pay $100 a transaction to move something of significant value. Similar if there's a hyped up NFT drop, people will spend the gas to do it. But that's not everyone.
00:18:02.950 - 00:18:43.810, Speaker B: That's kind of, I would say, a very small set of the population. With roll ups, you can get cheaper transactions towards tens of cents or less, and then you can casual gaming. It warrants that you can spend tens of cents for a certain type of interaction, and that works there. But what we want to do is go towards this with EVM roll ups, adding the BLS signature scheme gives you some savings. And obviously all the other things that reduce the L2 transaction cost will open up the applications towards microfinance in developing economies. So this is where we are now. We're live on Arbitrum, nitro, Gyoli, testnet, and we're going to be deploying to arbitram and optimism after some auto fixes and other L2s that are EVM compatible or equivalent.
00:18:43.810 - 00:19:34.158, Speaker B: We'll seek to basically get this into wallets currently and to encourage DApps to use it. So we'll first target applications where this will have a direct benefit to help sort of priced out users and of course, support regular web3 wallets with integration via 4337. Because that seems to be where the attention is with wallets and further optimization will just be ongoing. We'll look to do those other optimizations to make transactions cheaper for the wallets that already have it integrated. And of course, things just get even better when 4844 drops. So this is how it feels to me that we've got, on the one hand, a lot of real world problems that kind of are cut out from the web3 solutions due to the cost per transaction. But we hope that once that joins in, that we will get these real world problems being solved by web3 solutions.
00:19:34.158 - 00:19:56.538, Speaker B: And yeah, we just sort of are looking forward to that time because I think that's when we'll get, again, a resurgence of a lot of activity. We'll have a lot of users who will actually be able to benefit from the primitives that we're building, that everyone's building in the community. So this is us. We're web BlS wallet. If you want to learn more, check out our in browser demo. It's at blswallet.org. Maybe don't hit it all at once in case it crashes, but it'll be fine.
00:19:56.538 - 00:20:03.310, Speaker B: Check it out GitHub there's a discord web3. Well, and yeah. Are there any questions? Okay, just a question. Yeah.
00:20:03.380 - 00:20:40.654, Speaker C: Okay, again, congratulations for the project. It's going to be very useful to the community. My question is, when you create the wallet and make these changes you're proposing, that is great. You need also to update the clients because for instance to support the multiple transactions one sign it. It's amazing idea. Are you talking to with execution layer clients to help them to adopt their clients. How are being those conversations?
00:20:40.722 - 00:21:06.110, Speaker B: Absolutely. Yeah. So quite a while ago we started that journey, we started contacting, I think this was even end of last year, started contacting some wallets just to see which ones might be interested, how to begin that conversation. And so it's a very good question. We had some interest from wallets. Certain wallets are saying yes, we want to do this, it's quite interesting, but with what we had, it just seemed to not get integrated. So there was a bit of a delay, I think from wallets, but we were also not live yet.
00:21:06.110 - 00:21:49.022, Speaker B: So I think once we're live that will be helpful. When 4337 came about, which is the on chain account abstraction, there was a lot of conversation and interest around that standard. And so maybe the wallets will integrate that standard sooner and then we can have those conversations again. And to say, look, here is an implementation and these are the features of this one. And I'm sure there'll be other implementations for other signature schemes. So there will be a change on the wallet side so that they have to sign with a different signature scheme and then obviously in the UI and all that apart from the quill extension, which is basically a reference browser wallet. We've also gone through a large design, I guess a set of design to look at what future wallets can look like.
00:21:49.022 - 00:22:03.650, Speaker B: So these can form a bit of a, you know, a bit of design help for wallets as well. Okay. But the client.
00:22:07.750 - 00:22:13.510, Speaker C: With the clients like geth or nibbles. Are you talking to those teams?
00:22:14.810 - 00:22:38.942, Speaker B: No, that's okay. The diagram maybe shows it better. This is a bit slow. Yeah, so the nodes don't need to change. So the clients say, the aggregators, here we go, this one. So at the moment we have a dedicated server that will do the bundling. We've already had conversations with one particular layer, two about this, to say that they would want to integrate this.
00:22:38.942 - 00:23:08.690, Speaker B: So for us that's been not been the barrier. We've heard great enthusiasm from the L2 networks to say as soon as wallets are doing this, they're going to put it in. The nodes have a vested interest to reduce their costs for us. I did an early litmus test in a sense to talk to them and they're like, if this is in the wallets, we'll put it in the next day. Almost like that was the signal I got from them. But as it stands, this is one solution. The 4337 solution is a little different because I think it's an alternative mempool.
00:23:08.690 - 00:23:14.140, Speaker B: But yeah, maybe check out their talk. For more information on that, we got a couple of questions over. Oh, sorry, over here. Yeah.
00:23:14.670 - 00:23:37.502, Speaker D: Hey, Jesse from Coinbase, two questions. One is, if we're exploring kind of EIP 3437, is there anything specific we should be keeping in mind with BLS to make sure that there's like compatibility there just on the Coinbase side? And then the second question is, how does the atomicity actually work in the user operation transactions? How is that actually implemented and executed on the actual layer?
00:23:37.646 - 00:23:54.070, Speaker A: Yeah, I can cover for the BLS signatures both the current, I think it's influencelism is the repo and our wallet under the covers are using the same BLS verification and solidity, and also the same client libraries. So they should be largely compatible for that.
00:23:54.220 - 00:24:16.606, Speaker B: Yeah. Regarding what's required on your side, it would just be the signing. Like the client side would just need to sign the BLS signature for that part. And then depending on which way you go directly or via four three seven, it would just be interacting with the contract wallets that it deploys. The second question. Sorry, what was the second one again? Oh yeah, sorry. That's right.
00:24:16.606 - 00:24:51.842, Speaker B: So for the multi actions, we have a set of, it's basically an array of actions inside a user operation. And I think four three seven has done the same thing. It's the same format that you can specify a set of actions. It's kind of a cascaded function so that I can call a try on one of them. And so if one of the actions fails, then it reverts, and then, so all of them revert within that try. And then I catch, and then I go on to the next user operation. So each user operation is in a loop, and within there it calls the set of actions to the wallet.
00:24:51.842 - 00:24:59.180, Speaker B: And if one of the actions fails, only the user operation is reverted, not the rest of it, because of the try catch, which is nice. That solidity has that. Now.
00:25:01.470 - 00:25:04.730, Speaker A: Who do you anticipate running these aggregated proxies?
00:25:05.250 - 00:25:08.990, Speaker B: We hope that it gets merged into the nodes. Into the layer. Two nodes, yeah.
00:25:09.060 - 00:25:43.114, Speaker A: To start out, we would expect like a Dapp would probably run its own aggregate proxy just to kind of like bootstrap the process eventually it could potentially be larger swath of say like nodes having compatibility with that. We also think that if we're able to kind of move more towards that contract funding for the gas that will make it so it does not matter kind of where you submit it, when it eventually is executed on chain, that's when the actual payment subsidiation will happen and so then it's less important. But just to start out we're having that kind of more centralized service just kind of get things going.
00:25:43.312 - 00:26:00.830, Speaker E: Thanks for this presentation, I appreciate it. Does quilt have any sort of priority on test automation for end to end testing, usability testing? Seems like wallets right now don't pay very much attention to the user experience.
00:26:00.980 - 00:26:01.662, Speaker B: Yeah, good question.
00:26:01.716 - 00:26:03.920, Speaker E: What are users seeing? What are they clicking on?
00:26:04.370 - 00:26:21.446, Speaker B: Yeah, no, definitely. That's a very good question. So firstly, that quill isn't. We don't want to release quill as a wallet. It's meant to be like a reference implementation to show how other wallets can integrate the client. We had considered spending more effort making the UI match the designs that have come about. So the designs we have are there.
00:26:21.446 - 00:27:00.980, Speaker B: So if you go to our discord, I think in the design channel we have a link to the design brief that was done, or I forget what we call it as a whole, but there's just been a large design process done to look at what wallets of the future can look like. Multi chain, multi wallet, and all of that being very usable. So we've done that as more of an exercise to say this is what wallets can do. But again, we had considered putting that into Quill, but because we don't want to necessarily launch it, we leave them there as reference implementations, quill being the technical one and the design being for other wallets to learn from, if that's a value. So there was some user research done with that as well. I think we still have some time for questions. Yeah, we got question at the front.
00:27:01.910 - 00:27:37.870, Speaker F: Thank you so much. This is amazing. I'm just learning about BLS, so don't mind if my question is too naive, but with developments like ZKe EVM on L2s for signature aggregations and atomicity, I can basically do as you showed approve and then transfer a bunch of things. What do you think about recursive proofs? So if I have multiple transactions, I have each proof and I take them and just submit recursive proofs so in that case, how do we think about developments in ZKE EVM and BLS?
00:27:39.570 - 00:28:06.360, Speaker A: Yeah, and you might have some thoughts on this, too, James. I think we haven't really fully looked into what it's going to look like, but we think this wallet BLS wallet ecosystem would work in any EVM compatible system. And so we might be able to even reduce some of the data that needs to be proved or run over in those ZKe EVM setups. But we haven't done a ton of experimentation yet to see that, I think. But there is the possibility that it will help.
00:28:07.130 - 00:28:08.262, Speaker B: I think that's our time.
00:28:08.316 - 00:28:09.078, Speaker A: That's our time.
00:28:09.164 - 00:28:09.702, Speaker B: Thank you.
00:28:09.756 - 00:28:10.600, Speaker A: Thanks, everyone.
00:28:18.400 - 00:28:35.280, Speaker G: All right. Thank you so much for that. Next up is a talk by Patrick, who claims to be an intern at infura and in the past has been an assistant professor at many universities. Please welcome Patrick for his talk on validating bridges, roll ups and plasmas.
