00:00:15.530 - 00:00:45.500, Speaker A: Hey, everybody. So the next talk is going to start in a bit. It's going to be a tale, a snark's tale. A story of building snark solutions on the mainet by savvy, according from the graph. But before we get ready, does anyone have any interesting snark tail? Do people actually use Zkps here in any user way.
00:00:47.230 - 00:00:47.594, Speaker B: Or.
00:00:47.632 - 00:01:03.918, Speaker A: It's one person. That's nice. Could you tell us your snark tale? When is your first time? Just sit back, close your eyes, and tell us about the first time you ever used a snark. He doesn't have a microphone, but I'm.
00:01:03.934 - 00:01:13.296, Speaker C: Going to run there. Well, to send the transaction on the.
00:01:13.318 - 00:01:22.740, Speaker A: Mina network, which is a ZK layer one. Nice. That was a nice. And not push at all shill of Mina.
00:01:26.680 - 00:01:27.252, Speaker B: But yeah.
00:01:27.306 - 00:01:27.876, Speaker C: Appreciate it.
00:01:27.898 - 00:01:33.720, Speaker A: Thank you for sharing. Finally, please welcome on stage Savvy from the graph.
00:01:39.100 - 00:01:57.580, Speaker C: All right, thank you. Yeah, so I'm a cryptographer at semiotic labs, and this is a joint work with Jackson Blazinski from Edge of node. Like I said, we're core developers from the graph, and basically we're just kind of going to walk through one of our stories of trying to build solutions using snarks and then actually running them on Ethereum mainnet.
00:01:58.720 - 00:02:00.128, Speaker B: So up first, I think everybody here.
00:02:00.134 - 00:02:26.920, Speaker C: Has at least heard of a snark. So let's just kind of quick recap of the main character of our story. This is the expanded acronym of Snarks non interactive argument of knowledge. In particular, what we care about is the succinctness property of these snarks. So it's kind of like that computation compressing the scalability solution for Ethereum, those properties. One notable omission.
00:02:29.100 - 00:02:30.056, Speaker B: From our snark here.
00:02:30.078 - 00:03:09.348, Speaker C: Is we don't have the ZK piece. And so in our solutions, we don't necessarily care too much about the ZK, the privacy piece, which is really this scalability piece that we're after. Then also, as I'm laying out the acronym snark, I notice something that one of my coworkers, ten year old daughters noticed, and she said, shouldn't it be called a snack? And she's not wrong. All right, so our story, every story has a challenge, a reason for it to exist. And this is our challenge. Let's see. You can't really see the bottom line there, but that's all right.
00:03:09.348 - 00:04:11.044, Speaker C: So basically what we're trying to do is we are trying to use a snark to resolve, like, 1 million independent payment channels within the graph protocol. So the graph protocol, the way that they ensure indexers get paid is they have an entity called the gateway, and every time the indexer provides a result from a query, they get paid some amount. And so then the gateway issues them a receipt that's been signed by the gateway, and then it says, what's the value of your transaction? Right. So the nice thing about the payment channel that the graph uses is that you can basically instantiate up to a million independent kind of payment channels. And these are all asynchronous. So the gateway can just be firing away receipts as the indexer is serving queries. And so the indexer ends up with a bundle of, say, a million different receipts, and their total amount that they're owed is kind of the sum of the total value over all of those receipts.
00:04:11.044 - 00:05:42.224, Speaker C: And so for the indexer to be able to prove that they're owed the total amount that they're owed, they need to somehow prove that all 1 million of these receipts have valid signatures, that none of these receipts have been repeated, and that the total value adds up to the total value that they claim that they're owned. And so one way they could do this is they just take that bundle of a million receipts, throw that on chain, and then run some BL signature verification on all 1 million receipts. But that's a little costly, so we want a better solution. And so the solution seems like really well suited for a snark, right? Basically, we want to take this computation of a million different signature verifications, throw it into a snark that can say, yes, all 1 million of these are valid, total value adds up to the claimed total value, all IDs are unique. And then you get out just one nice little succinct proof with some claimed total value amount that goes on to chain, and you run your snark verifier algorithm on chain, and the indexer gets paid. So, let's look a little closer at this problem and why it's interesting, this table here that we're generating, right, this bundle of receipts, we've got a million different receipts. And so whenever we talk about snarks, there's always this talk of like, okay, what circuits are used to verify your computation and all that type of stuff? So basically, our circuit needs to take in, needs to prove 1 million different signature verifications.
00:05:42.224 - 00:06:42.552, Speaker C: So initially, we're thinking about using BLS signatures. You can maybe say that a BLS signature can be proved with a circuit of size, say, two to the eight, if you wanted to prove all 1 million of those transactions with this size two to the eight circuit. You could just take the two to the eight circuit, copy and paste it, and then you have some huge size two to the 28 circuit that you're going to be using in your snark to verify and to prove and verify. And so what's interesting about that is two to the 28 is about the biggest circuit size you'll see, right? So in all the literature and all this, people run their asymptotics and they go up to its size two to the 28, and we haven't really seen much bigger than that. And so already we're talking about trying to prove statements that are at the edge of what people have used. Another really interesting thing about this primitive is we're trying to use a snark as a black box. So really we're just trying to get incorporated into this payment channel protocol, and we don't really want to have the snark impose any extra requirements on the protocol itself.
00:06:42.552 - 00:07:08.930, Speaker C: Right. We would just want the snark to be this black box. We plug in a scalar table, we get out of proof that proof goes on chain, you can verify it, and you don't really impact the security of the system in any way based off of your snark. And then the final thing here, the business side of this. Oh, yeah. Can you make this whole process of proving and verifying cost less than $30? Otherwise it's not very useful to the indexer. Thanks.
00:07:09.940 - 00:07:10.690, Speaker B: Go.
00:07:11.480 - 00:07:45.640, Speaker C: All right, so now we're going, we got our challenge. We're trying to prove this massive table of data and basically prove this massive table of signature verifications. How do we know whenever we're done, right? How do we know that we've succeeded? There's a bunch of different metrics to quantify snark performance. We use prover time, prover memory, proof size, and verifier compute. So prover time is basically just, it's the amount of time that the proverb spends generating their proof, right? So in this case, it's the indexer. The indexer has their big table. They're going to run this proving algorithm and it's going to take them some amount of time to generate that proof.
00:07:45.640 - 00:08:11.536, Speaker C: Prover memory. This is an actual physical requirements of the machine that they're using to generate this proof, right? So if they got a laptop with 16 gigs of memory, the algorithm requires more than 16 gigs of memory. You're going to run into issues. You're not going to be able to generate a proof proof size. This is the size of that proof that gets spit out of the snark. This is what gets sent on chain. So this is obviously important, right? The bigger your proof is, the more expensive is to store it and then verify a compute.
00:08:11.536 - 00:09:00.852, Speaker C: These are the computations that are run on chain in the verify algorithm. And for the purpose of this talk, whenever we talk about the verify compute, we're really going to just highlight the most expensive operations that the verifier is going to run. And so this gives us kind of like a quick way to filter out techniques and estimate gas costs and all that. Just another thing on these figures, right? We'll see them repeatedly. This x axis. Basically, this is showing our statement size as it's growing, right? So we said we want to prove this big table of signature verifications. The goal is to get to this kind of size two, to the 28 instance, and then by seeing how these metrics trend, we can kind of get an idea for engineering solutions, right? And we get an idea how our problems are growing and stuff like that.
00:09:00.852 - 00:09:19.816, Speaker C: So those are our plots. And now we start our story. And I like maps, and I like stories with maps. And so we are going to have a map. But a quick caveat about maps is this is a map of the world in 450 BC. It's accurate, but we can tell it's not the full truth.
00:09:19.848 - 00:09:19.996, Speaker B: Right.
00:09:20.018 - 00:09:43.136, Speaker C: There's a whole lot to be discovered still. So here's our map. This is cryptography land as we saw it at the start of this program, and especially in particular when we're looking at snarks. So we've got kind of two major continents of snarks. We've got transparent snarks, and we've got these non transparent snarks. And so non transparent snarks. These are snarks that require some sort of trusted setup.
00:09:43.136 - 00:10:00.410, Speaker C: So we saw yesterday when we're talking about dank sharding, and we're going to have this KZG trusted setup ceremony. That ceremony is what is required for these non transparent snarks. Transparent snarks. The idea is they don't require this kind of trusted setup ceremony. You can kind of run them out of the box.
00:10:01.580 - 00:10:03.076, Speaker B: So that's our map.
00:10:03.268 - 00:10:48.488, Speaker C: Now we say, where do we begin? Right? How do we start this story? And really, when we started out, we said, okay, one of these unique properties of this problem, it's a black box. Like we said, we don't want the snark to impose any security requirements on top of the system. That we're using. And so when we think about this trusted setup, we can debate how the practical implications of this trusted setup, right. If you only have two people running the trusted setup ceremony, you have to trust that both of them are honest. As you increase the number of participants, that level of trust might change. But the point is, you're still making an argument, right? There's still some other additional argument that goes on top of the math of your proving system.
00:10:48.488 - 00:11:34.356, Speaker C: And so initially, we said, we want this thing to be as black box as possible. We don't want to have to deal with those extra arguments. So we want to start with the transparent snark. All right, so now, knowing that we're going to be using a transparent snark, where do we go from here? And so we start by looking at our problem statement, and we start trying to find what's the next best snark to use. Thing that's unique about this problem statement, right, is it's highly structured. So basically, we're kind of proving the same function a million times. So if we could kind of reuse these circuits, maybe we could significantly reduce costs, either proof size, verification time, that type of thing.
00:11:34.356 - 00:12:02.188, Speaker C: And so, in particular, what we're curious about is we could come up with one circuit, some f circuit, that can be used to prove all of these snark things for a single row. And so then if we could do that, then could we generate proofs for each individual row and then somehow aggregate them all together, and then we get some aggregate proof. And the hope is that the aggregate proof will cost only about the same to verify as verifying this single small proof.
00:12:02.364 - 00:12:05.564, Speaker B: So, people have been looking in snarks.
00:12:05.612 - 00:12:31.992, Speaker C: You can see where we're kind of going with this. We are going to recursive Snarkland. And so in this space, there's a couple of primitives. Halo is one of the big ones we hear about, and there's talks on it this week, but at a very high level, recursive snarks. It's kind of like what I was saying, right? We have the ideas. We have a circuit. We want to repeat the computations on that circuit and then kind of like aggregate these proofs together.
00:12:31.992 - 00:13:08.980, Speaker C: And the way that recursive snarks kind of get around this in practice is you take your original circuit, you can augment it with some snark verify circuit. So it runs the verify algorithm of your proving system, and then you have some resulted F prime circuit. And then this f prime circuit is kind of what you start chaining together to prove all of your rows. In our case, prove the rows of the scalar table. And the really important thing here is the cost to verify. And like the cost and proof size is really only tied to the cost for proving and verifying this one f prime circuit. So that's really encouraging.
00:13:08.980 - 00:13:48.560, Speaker C: Maybe we could significantly reduce our problem using this. We use a primitive called nova, so it hasn't seen too much traction in this community that I've seen yet. But it's a newer primitive. It was presented at crypto this year. What it really has going for it is it can do kind of what halo does, but it has the smallest constant size verifier circuit. So we remember that f prime, we have that little verify circuit. Nova is the smallest that exists in the current literature, and it's constant size, so it doesn't depend on the size of your original f circuit.
00:13:48.560 - 00:14:22.540, Speaker C: Just a note. In our case, this f prime circuit ends up being about size two to the 15. And so this is this constant proof size. And the verifier work is tied directly to this kind of two to the 15. Another interesting thing about Nova is it uses another iOp called Spartan. And what Spartan does, or its advantage is it's a very fast prover, and it might still be the fastest prover in the literature. It doesn't use any V FFTs, and it also has a relatively efficient verifier.
00:14:22.540 - 00:14:51.056, Speaker C: Some more notes about Nova. The actual open source implementation that they have, they've instantiated it with bulletproofs IPA. So this is kind of like the expensive IPA that people talk about in the literature, the expensive polynomial commitment scheme. But the idea is this, bulletproofs is only used for a circuit of this size. So you end up with a bulletproofs instance on your polynomial commitment. It's tight to this size. And then, just another note on their open source implementation.
00:14:51.056 - 00:15:25.516, Speaker C: They're using these pasta curves so similar to Halo. When you're generating these recursive proving systems, you have some kind of unique mathematical primitives that you got to use. And so in that particular is called these cycles of elliptic curves. And nobody uses the same thing that pasta does. And it actually worked together on this, so nothing too surprising there. What gets surprising now is whenever we actually start looking at our costs, the first thing that we notice is these constant size here. So the proof size is constant.
00:15:25.516 - 00:16:09.890, Speaker C: This verify compute is constant. So basically, what we're saying is, as we increase on our x axis here, we're basically proving more and more rows in our scalar table and this proof size and this verifier compute stay constant, because again, the proof size and the verifier compute are tied only to that f prime circuit. So we get this nice kind of constant proof size verify compute, that doesn't depend on the number of rows that we're trying to prove. The prover time here, this is pretty much linear in the instance size that we're trying to prove. So linear in the number of rows that we're trying to prove, because basically the prover has to do the work, right. So in this particular instantiation, the prover is just kind of going row by row, kind of proving and accumulating. So you kind of just see this linear growth here.
00:16:09.890 - 00:17:00.184, Speaker C: And so, based off the implementation that we have available, we would estimate 51 hours to prove using Nova for an instance as big as we want to get. That may or may not be a fundamental limiter. But really what we see the big limiter is this, verify compute. So even though verify compute is constant, it still is a very expensive operation that needs to run. And so in particular, it's part of this bulletproof polynomial commitment scheme. You have to run this elliptic curve multi exponentiation, and it's size two to the 15, so 32,000 basically up to curve multiplications. And so the problem really is Nova is written to work with pasta curves.
00:17:00.184 - 00:17:46.670, Speaker C: Ethereum only has pre compiled support for one curve, Alt Bn 128. And so this is kind of a famously known problem at this point. So if we wanted to run this verify algorithm, we would have to implement smart contracts for pasta curves. So that in itself is a cost that we would have to absorb. And then if we did, we would see, based off of some people who have done similar work, a scalar molt would still cost about 350,000 gas. And so if we could use some algorithms for speeding up this multi exponentiation, we could get these total costs down to 764,000,000 gas, or $76,000 off of some estimate of gas to dollar ratio. So clearly this isn't the solution that we're looking for.
00:17:46.670 - 00:18:19.304, Speaker C: Maybe there's some engineering things we could do. We could take advantage of alt BN 128 also as a cycle. But for now, we'll table this and we'll go look elsewhere. So where do we go from here? Again, we want a transparent snark, and we really like to use primitives that can take advantage of things that are supported by Ethereum. So we look for primitives that use ALBN one and 128. Altbn One and 128 is a pairing friendly curve. So we're going to look for transparent snark primitives that use pairings, and we don't really have to look too far.
00:18:19.304 - 00:19:05.240, Speaker C: So Nova, the same authors who wrote Nova, they also authored something called quarks. And so this is another transparent snark primitive. And in particular, what's unique about it is they invent some pretty unique polynomial commitment schemes that use pairings, but they don't require trusted setup. And so they can get some significantly better performance than, say, bulletproofs from a verifier standpoint. So it's pretty unique. Again, similar to how Novo was written, they're using Spartan as their IOP. So basically, they take one of their polynomial commitment schemes, either copus or Dory, pair it with Spartan, and then now they have a snark.
00:19:05.240 - 00:19:25.180, Speaker C: The nice thing about them, they've got fast and space efficient provers. That's a property of both the polynomial commitment schemes and the spartan primitive. The proofs are they're a little bit bigger than what you would get out of something like bulletproofs, but they could be manageable. And then the nice thing about them, too, they have relatively cheap verifiers.
00:19:26.160 - 00:19:26.636, Speaker B: Oh, yeah.
00:19:26.658 - 00:19:36.032, Speaker C: Then just another comment. There's actually some more research by the same kind of group of authors about Spartan that is used to prove kind of like SIMD computations. Right?
00:19:36.086 - 00:19:40.628, Speaker B: So you have basically our scalar table, right?
00:19:40.634 - 00:20:20.610, Speaker C: We have one circuit, we have multiple inputs, single input, multiple data, and so they've got some stuff off the shelf that can seemingly help us with our problem. So we get really excited about this. So then we start digging into quarks, and we want to use it, and we want to try to build snarks with it. The first problem that we run into is there's no open source implementation. So that in itself makes things pretty challenging. There's no copus, nor is there a dory PC. Although I was talking, it sounds like there might be a dory implementation available somewhere as of a couple of days ago, but I haven't seen it yet.
00:20:20.610 - 00:21:12.610, Speaker C: So, knowing that this polynomial commitment scheme is kind of like the primary cost driver for these snarks, we implemented the Copus PC using the rust arcworks libraries, and then we ran it to get some benchmarks right, and kind of get some estimated costs. And so these are the results for a copus PC. The one thing that we see prover time now is pretty nice, right? That's 565 seconds for the biggest instance size that we would want to prove that's nice. The prover memory requirements. If you have a machine that has four gigs of memory, you should be able to run this again, this is our proof size. So we're in the orders of kilobytes here, right? Basically, at the biggest instance, we got a proof of about 9. Then this verify compute again.
00:21:12.610 - 00:21:49.260, Speaker C: We'll see. This becomes the big problem. We're talking about doing elliptic curve arithmetic. Again, similar to how bulletproofs was doing. The instance sizes are significantly smaller, but there's still significant work to be done there. To contrast copus with Dory, which is the other polynomial commitment scheme, dory takes advantage of some precomputation to reduce this verifier time, or this verified compute work even further, and as a consequence, their proofs are about three times bigger. So just take these proof sizes, multiply by three, and then the verify compute is significantly less like we'll see on the next slide.
00:21:49.260 - 00:22:10.630, Speaker C: So, quirks look promising. At least the polynomial commitment schemes look promising on paper. The problem is now, if we want to start again running this verifier on Ethereum, the problem is, particularly, even though there is Alt BN 128 support, there is no exponentiation support. So.
00:22:12.360 - 00:22:13.110, Speaker B: Yeah.
00:22:15.800 - 00:22:47.948, Speaker C: So that's, that's a significant problem. And basically, we simulated, we implemented some GT arithmetic. We simulated the total cost, and we got down to about 4 million gas to do one exponentiation. And so a whole dory verify would cost about 125,000,000 gas or $12,000 so smaller. But we're still not there yet. And so now we start asking questions. Where do we go? Do we really want to use a transparent snark? Let's go see what this plunk is all about that everybody's using.
00:22:47.948 - 00:23:10.016, Speaker C: So, plank is very popular. It's got a ton of support. Proofs are small, verification is, the cost is known. And really what we'll see, really importantly, is plonk is supported. The verifier is supported by pre compiles in Ethereum. So all of the heavy arithmetic is cheap. So we dig into plonk.
00:23:10.016 - 00:23:57.270, Speaker C: Fortunately, like I said, plonk is so popular, there's a lot of high quality open source implementations. There's a lot of high quality blog posts describing plunk, and we see the famous small verify compute small proof size. The problem with Plonk, and this is a known problem, too, and this is why everybody is trying to make this prover efficient and trying to optimize circuits, is this prover time and prover memory is expensive. So planck needs to run FFTs, FFTs require n log n work, and they are also not space friendly. And so if we try to prove just a raw two to the 28 size instance we're looking at, that's 500 minutes. So we're looking at about 8 hours. And you need about three terabytes of memory on your machine to be able to complete a proof of this size.
00:23:57.270 - 00:24:23.420, Speaker C: You could do it. You could go to the cloud, rent a gcp instance, and you could get it done for about $200. But you're not going to be able to prove this out of the box. All right, so now we start asking our questions. We start getting introspective. We've surveyed some snarks. We've flip flopped between transparent snarks to trusted setup snarks.
00:24:23.420 - 00:25:07.240, Speaker C: What are the important questions here? So one thing that really popped up is why is Planck's verifier so much cheaper than, say, Dory's verifier? And so if we just look at the algorithms that are being used, Planck's verifier requires pairings. Pairings require GT exponentiation. So a pairing should be more expensive than a GT exponentiation. And if we actually do the math, Dory's PC should cost only about 16 times what plank costs. And so that seems like a reasonable trade off that somebody would be willing to make if they don't have to run a trusted setup. And so the reality is, as we saw, the cost is about 500 times plank verifier. And so really it's this pairing check EIP.
00:25:07.240 - 00:26:01.804, Speaker C: And so one of the big points that we're trying to take away here is we've seen that there are kind of cost competitive, transparent snark primitives. In particular, there are interesting polynomial commitment schemes, these copis schemes, dory schemes, that could be useful, but we'll never be able to run them on Ethereum mainnet because things are too expensive, because they're not supported by, say, pre compiles. And so one of the questions, and this is kind of just like a thought question, right? Is Ethereum ecosystem artificially selecting for snark primitives with costs that don't reflect reality? We say Ethereum is driving snark research, and it is, and we're seeing like a flurry of development, especially for primitives like plonk. But is, I mean, the reason is it's cheap to verify. And so the question is, costs aren't reflecting reality. We want to address this question. If there are other people who have kind of run into some other things like come talk to us.
00:26:01.804 - 00:26:32.548, Speaker C: We have ideas of how to address this with the last minute. Where do we go next? Right, so we've gone all over the place. We've surveyed a bunch of snarks. Actually, there's a ton of snarks in practice. Right. And you look at all of these, this was our path, but there's a whole bunch of places we can go. The other point here is snarks generally we think of them as proving kind of arbitrary programs, NP complete or NP statements that power as a cost.
00:26:32.548 - 00:27:16.420, Speaker C: There are other proving systems that have cheaper costs. Signatures are one such proving system. So we sell away from the land of starks to the land of homomorphic signatures. And so what a homomorphic signature does is it basically allows you to sign data and then if you like, sign two messages, you can add those two messages together and the result is a signed message for the sum of the two underlying messages. So it's a pretty cool primitive. Haven't really seen it used much in practice, but we have a unique application here on blockchain and so we could take advantage of that and run this referenced scheme. And basically the bottom line is we get small proofs, small verify time, similar to plonk.
00:27:16.420 - 00:27:42.140, Speaker C: These costs are about the same cost of aggregating just regular bill of signatures. So elliptic curve arithmetic and we can get something done for less than $30. Quote I like. It's worth thinking about again. This is we are edge and node, semiotic labs, record developers for the graph. I'm with semiotic AI. We're looking for people who are interested in these types of problems.
00:27:42.140 - 00:27:52.490, Speaker C: We're also looking for people who are interested in AI reinforcement learning, all kinds of good stuff. We're looking for people. If this was interesting, reach out. Thank you.
