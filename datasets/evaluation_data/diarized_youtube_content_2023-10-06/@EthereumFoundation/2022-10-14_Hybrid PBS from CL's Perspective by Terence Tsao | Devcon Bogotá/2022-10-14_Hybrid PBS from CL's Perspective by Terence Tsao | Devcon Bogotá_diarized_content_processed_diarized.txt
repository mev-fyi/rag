00:00:13.130 - 00:00:35.810, Speaker A: Hybrid PBS in transensus layer. I'm Terrence, I'm a core dev. And as of earlier this week, we are part of Option Labs. So I had to change my name real quick before I get in trouble. So let's get started. So this talk is about consensus layer interfacing with hybrid PBS. It's not so much your searcher builder, your typical Mev talks.
00:00:35.810 - 00:01:15.490, Speaker A: So we want to understand more. What does it mean when Consensus layer interface with hybrid PBS from its tonality, such as Latency File and censorship? Then we'll also talk about Mitigations. Just to reiterate what I said, everything in the purple, we will go over it. We'll have Relayers Matboost, which is a relayer aggregator. We have consensus layer client, execution layer client and validator client. And this is what Me and my team and other teams have been working on over the last few months. So, background, why are we here? Right? So there's options, and options are nice.
00:01:15.490 - 00:01:41.782, Speaker A: So the first options which most people use these days is normal block processing. So as a consensus layer client, you know which validators you're serving. You know when validators are proposing a block. So you will build the block for the validator and post merge. We utilize Execution layer Client to prepare payload. So consensus layer client uses execution. Layer client to prepare payload.
00:01:41.782 - 00:02:39.198, Speaker A: They put a payload in the block that passes to the validator. Validator signs it return the block and Consensus layer client broadcasts the block. So here, the separation of concern is nice here because Execution Layer Client and Consensus Layer Client, they're both very complicated piece of software, but they only need to know each other through the engine API. So the separation of concern is very nice. The second option, which people are starting to use more and more now, is that I can outsource block production, right? As consistency client. If I want to participate in the Mev game, I can utilize the relay network. I can, hey, relay network, can you propose a block for Me? And the block are usually more profitable and also in the background, consistency client can also talk to the educational client, hey, can you make me a backup block? In the event that the relay network doesn't work, I can still use it.
00:02:39.198 - 00:03:21.622, Speaker A: And this is kind of the paradigm that we're heading towards. And it's important to understand, what does this mean? So this is today's number, and hopefully you guys can see it. I capture it this morning. There are 55% of the network participation is using Mev block production. It is outsourcing their block. And then out of the 55%, 81% are dominated by flashbox relayers and there's seven active relayers. So let's talk about the first risk latency, right? So when you propose a block, normally under your local setup, you have your Consensus layer client, execution Client, validator client.
00:03:21.622 - 00:04:37.042, Speaker A: So how does this work? You ask Execution layer client to prepare a payload and then you pass the payload to Validator client to sign it. Validator Client sign the payload and then you broadcast the payload. Simple, easy, very easy to reason about, right? But with mev block processing, it's a commit and reveal approach, right? Why is it commit and reveal? Because as a relay, as a builder, you don't want Validated Client to steal your transaction if it's in the clear text. So you made them sign it first, then return the signature and then you give the full transaction. So given it's a commit and revealed approach, there's some more steps in the middle, right? If you get a header, the relay network return the header, then you sign the header and then you submit the sign header and the relay network return the full payload, which is transaction in clear text. So as you can see, there's like two more steps here, right? And besides that, it's also on a different network, right? It's not local anymore. So ideally you want the relay network to broadcast the block as fast as possible instead of giving it back to you and then you broadcast it.
00:04:37.042 - 00:05:20.274, Speaker A: So hopefully most of the relayers have been publishing blocks by themselves instead of just passing back. So for that, you do save some latency, which is nice. So let's ask ourselves, right, do the additional runtrap and latency matter because like I said before, when you have your El and your CL, they are both in the local setup. It's lighting fast, it is reliable because they just go through hardware, they just go through electron circuits, right? But if we do a relay network, it's slightly different. You are actually talking to some infra provider GCP or AWS on some regions. I was able to capture some numbers. Unfortunately, I haven't been home for the last two weeks.
00:05:20.274 - 00:05:54.542, Speaker A: So these numbers are slightly old, but on Gordy with a thousand validators. They're not many validators, but yeah, just a thousand validators. But given it's Gordy, the network topology may be slightly different. But I hope we can get a picture here, right here. I'm not even using mev boost, I'm just talking to the relay directly. It takes about three times slower to propose a block given the additional latencies. Right? So what does this mean when there's additional latency? Because when you propose a block, usually how it works is that you run a four choice to get head.
00:05:54.542 - 00:06:18.822, Speaker A: Then you build a block based on the head. Then you get a payload from the execution engine. Then you broadcast the block right at the four second mod, which is one third of the seconds per slot. attestors will vote what is the head of the chain. And if the attestors did not see your block, then your block may get orphaned. And that's not ideal. You do not want to lose a block, right? So this is what we don't want.
00:06:18.822 - 00:06:49.806, Speaker A: We don't want something that's taking up so much in the middle with the gate header, sun header, and submit blind block. Right? So this to me is worrying. And then let's look at some more numbers on block arrival latency differences. This is actually capturing on main net. This is my at home set up at home with 300 megabit bandwidth. So this is as at home set up as possible and we capture over 15,000 samples. And then the MVB block took about 500 milliseconds longer.
00:06:49.806 - 00:07:43.050, Speaker A: Right? And what does this mean from the submit attestation timeline? It just means that if the block takes longer to arrive, then attestants will unfortunately miss it like that, right? If you're waiting in the front for that long, then you will essentially eat up the time that you have. So you don't want to be the lazy block, you don't want to be the late block because you would get orphaned right. At the top example, block C was supposed to build on block B, but it built on block A. And then because the block B was late on the bottom example of block E, instead of building on block D because of proposed boost or something, it was supposed to be the head, but it's not the head. So block E built on block B, therefore C and D got orphaned. Right. So another set of numbers, 50% of the orphan block actually came from relayer from September 17 to 27th.
00:07:43.050 - 00:08:45.726, Speaker A: And there are the orphan block slot, the relays, they're using validator ID the entities. Right? And that's unfortunate. You could ask that, okay, well, maybe it was going to get orphan one or another, we don't know. But still, like 50% of it come from the relayers. It's not just like sunshine, rainbow and butterfly, right? There is risk to this, right? We often tell people, hey, we should use the relayer because it's more profitable, but it also comes with risk, right? If using a relayer makes your block two to three times more profitable, but you get orphan 10% of the time, is it worth it? That's something that you have to ask yourself about. And another risk I think with latency is your centralization, right? The whole point of mev boost is to make validator decentralized because now we can extract mev at home, so it gives everyone equal access to mev. You don't want it to look like this, right? You don't want people start realizing, oh, well, if I have a better latency, then I won't get orphans.
00:08:45.726 - 00:09:20.874, Speaker A: So I'm going to move by at home staking node close to the relayer so it becomes a negative externality. This is what we don't want. So what's the takeaway with this? Right? The takeaway is latency matters both for hybrid or even maybe for little PBS, right? And latency can lead to centralization risk, which we have known a long time already. And it's actually really hard to optimize towards network latency at the client level. I don't think there's much we can do. I think on the map boost side, there's talks about instead of Marshall or Marshall JSN. We marshall on Marshall SSD.
00:09:20.874 - 00:09:58.794, Speaker A: There's some improvement there from the relayer perspective. I hope they have really good network config. They have a lot more peers. I feel like they have a robust infrastructure there. I think that's as much as we can do because unfortunately, if someone just have a slower Internet connection, they want to use a relayer, I mean, this is going to be affected, right? It's important we educate these risks besides latency there's also faults too right? So what does fault mean? Fault here means that sorry, the site got a little mess up there. So when you ask for the header, the relay network failed to return a header. So that's a commit phase or the fault can happen.
00:09:58.794 - 00:10:52.614, Speaker A: When you submit a header, the relay failed to reply the payload, so that's the second fault. So we'll focus on these two type of faults here, right? So the first category of faults is just get header faults when you get header, and then the relay network fail to reply and they can be categorized as like you have a Mail form header, you have a consensus Invalid Header, you have a Payment Invalid Header or you have a Nonconforming header. So we'll go over them one by one. So what does it mean when a header is mail form? Right it just means that it is syntactically invalid it has an invalid structure you have to invalid signature can the CL client detect it? Yes, you can. Right? Because when you armaged, if it's not the right structure, then, well, you know it's wrong. You also can verify the signature. So this type of faults we can detect, and then we can mitigate.
00:10:52.614 - 00:11:10.110, Speaker A: So this is fine. Another type of fault is just consensus invalid header. So that just means that the block hash is invalid, the transaction is invalid. But for this we unfortunately cannot validate because we cannot see the full transactions. Right. We cannot calculate the block hash ourselves. So that's something that we just have to trust blindly.
00:11:10.110 - 00:12:06.974, Speaker A: That's unfortunate, but it is what it is. Then you have payment invalid Header so at this type of fault, it just means that well, the builder was promised to pay. The valid proposer some eve, but E failed to pay. So consensus layer client cannot detect that type of fault. We rely relay. We trust relay to simulate it. That's just why relayer is trusted for us and then there's also the non conforming header just means that when the validator register you basically say hey, this is a guess limit I want to use but the guess limit is incorrect the timestamp is incorrect the block catch is incorrect right can consistently client detect that? Yes he can so those are like what we say the commit faults so now we'll jump into reveal faults this is the second type of faults right so what are some reveal faults? So the payload could be invalid or the payload is unavailable.
00:12:06.974 - 00:12:47.774, Speaker A: And keep in mind, there's no falling back for this because you sign the signature ready, right? So at this point you can complain on Twitter, you can probably complain something else, but there's not much you can do here to basically make the block as a whole. So a mail form payload is similar to a mail form header. It just means that it is invalid. The full payload does not match the header. Can the consensus layer client validate? Yes, it can, but hey, it's too late, right? At that point you lost the block already, there's not much you can do. And it's the same with consensus invalid payload. You can validate the transactions now because we see everything but hey, it doesn't work too late, sorry then unavailable.
00:12:47.774 - 00:14:08.726, Speaker A: This means that the relay network just went to sleep when malicious decided to turn off. It did not reply back the header to you, so it did not fulfill its commitment, right? And then you know when it does that because you never received the payload and still there's nothing you can do there because you already signed something, your signature is out there. We have this concept of falling back to execution layer client just if Get header goes wrong, you can produce with your local execution client, that's probably fine, but if the Get payload fails, then you cannot produce with your local execution client just you don't want to double sign. So the return header, the first commit can fail two ways you can either fault or time out, right? We do prefer fault better just because you get a response right away, you can start propose the block right away if the timeout is kind of sucked because you have to wait for them to time out, you wait for them for a second, then you lost a second of your precious time there. So let's go through some many incidents. I don't want to sound like I'm pointing out their fault incidents, but I do think it's important to go over these type of incidents so then we can learn as a community, right? The first incident is September 16 flashbots relay. They fail to a Marshall deposit for the payload reply the damage, we missed three blocks.
00:14:08.726 - 00:14:52.118, Speaker A: The second one blocks Ross relay. This one is when the relay did not validate the block and then they replied the consensus is valid, we missed 88 blocks here. The third one is blocks Ross. Again, this is consensus invalid payload and the damage of that is 15 blocks was missed. So these type of things do happen, right? False happen. And then it seems like it's mostly happened on the commit and then also the reveal phase. So we need some mitigations like a circuit breaker and for example, as a beacon client, I can detect when there is a lifeless failure and then when the lifeless failure is determined by clients.
00:14:52.118 - 00:16:22.374, Speaker A: Say if you miss three slots in a row or the chair misses eight slots or 32 slots, if that type of thing is triggered, then we just default to local execution engine, right? So this is to prevent the dominant relay builder go offline and it doesn't solve the cases I mentioned before just because those happen maybe like 0.1% of the time for this, this happens all the but for this, this is a stronger defense. Then you have your relay monitor for example, such that you can monitor relays based on performance, such as behavior, such as behavior which is like safety and liveness and performance which is latency and people can see how the relays are performing and people can figure out based on that do I want to connect to the relay? So it just makes the information more available. Then we have features like Be filtering. So as a proposer you can say hey, I only want to use a relayer if they give me something that's over this value, right? So there's some nice things you can do there. So what is takeaways, right? We're still early but we need more robust relay and also we need a way to hold relays more accountable, right? For example, a simple idea, just you monitor all the missing slots and the orphan slots live and then you pull the API, the relay API. And then if you see, hey, the missing slots is coming from the relay, okay, I'm going to just shout out loud tweeter or something so that people know hey, there is an incident right there, it's happening live.
00:16:22.374 - 00:17:16.054, Speaker A: You need to turn off your relay or you need to switch local processing. In terms of just like faults timeout, I think I prefer githeader faults, then I prefer githader timeout, then I prefer git payload faults just because with gate header faults you can propose a block just like still and then it's most likely fine. And I do believe that relay quality will improve over time just because it's still relatively early ish they're still learning and we're still learning and something that will prove over time. So okay, last section, censorship. That's something that we have been talking a lot about. So as of today, let's see, 49% of the main applause have some sort of offac compliance building and that's unfortunate, just that's already over half, right? So we have to understand who is sensor, who can censor. Builder can censor, right.
00:17:16.054 - 00:17:50.078, Speaker A: If you're a builder you don't want to build blocks that can send like of compliant transaction you can censor or the relay can censor as well. Right? So therefore it's really hard. So what's the problem here? Problem here is the MV Boost is a neutral piece of software. It doesn't care about censorship, right? And then the UX of just figuring out how do we defend censorship is still early. Right now essentially everyone chooses the relay that's non censoring. That's it, right, but then it's hard to figure out who is censoring at a given time. It's like you don't know who is censoring.
00:17:50.078 - 00:18:51.042, Speaker A: I mean, we just look at the news, we do Google search and that's it. We need more information there. So potential solutions, right? These are very experimental ideas that I just have been thinking in top of my head. You can have some active inclusion such as map boots here or this, you can have some sort of censorship or censorship oracle so for active inclusion, high level, how it works is just like a proposal. You express the intent to force transactions into the payload, right? And the relayer has to present those slide transactions to the builder and the proposal will only accept those transactions if they are included or the block has been full. Right? So for this you do require some sort of multi proof to make sure that hey, the transactions are actually included and then consistently client can do the validation. So what's the downside with that? Right outside that, there's more timing because now as a proposer at the previous slot, you do need to send the transactions.
00:18:51.042 - 00:19:47.974, Speaker A: You want to send the transactions during the previous slot. So you need to figure out what's the timing for that. And now the proposers also need access to the ManPool to the execution layer state. There's also some latency complexity here just because now it may take longer to propose a block. And then you can also have, this is like a poor man version of just censorship filtering. Basically proposal, you just monitor the man pool for the top transactions that's based on gas fee at the given time. And then when the relayer replied, the relayer have to show approve that hey, this top end guest transaction are included unless that the guest is at this price at a given time, right? So we don't really trying to force transactions inside, but we just want to make sure that the top end transactions are actually getting in here.
00:19:47.974 - 00:20:50.186, Speaker A: We're assuming that okay, if someone's getting censor, someone will probably use a higher GS fee and stuff. So it's not ideal because you kind of lose this inclusion control, but it's probably easier to implement. Then there's also ideas like censorship oracle you can introduce a new adder to police censorship, kind of like relay monitor and now as a proposer and maybe boost when I receive a header, I can ask this oracle this new adder be like, hey, is this a sensor one? If they reply yes, then I won't use it. Right, but then again, you're putting trust on like a new actor and that's obviously not ideal because who is going to monitor the censorship oracle and there's always that problem. So there has been a lot more research going on which I'm really happy to see. Right. Vitalik posted a research a couple of weeks ago on just how do we constrain builders without bringing block proposal burdens to the proposer? There's ideas like using blood prefix and stuff and highly recommend you to take a look at that.
00:20:50.186 - 00:21:21.638, Speaker A: And then there's from Bonaby, I think it came like last week, which I haven't had time to read it. It basically enforces proposal commitments on chain and then I think that's very neat. I definitely want to take a look at that very soon. So what are the takeaways? Right, I think the takeaway with this just important to figure out who can censor and then who can fail the censorship because there are so many adders in the picture. There's proposers, there is Mev Boost and then there's also the relayer. Right. It's important to figure out who does what.
00:21:21.638 - 00:22:09.782, Speaker A: And then I do think we need to leverage the builder API a lot more because the builder API is probably the best thing we have today. It's the best defense. We use builder API a lot more. We can provide more ways to basically organize defenses against censorship such as inclusion list block, prefits and then there is like a spectrum of solutions and then out there, which we're thinking, but the simplest solution typically has more trusty assumption. So I'm not sure if that's the way that we want to go. So, some final thoughts for me, I think censorship resistance should be the highest priority aside from scaling and withdrawal. Like what is ethereum if 50% of the transactions are censored, right? That's something that we have to ask ourselves about.
00:22:09.782 - 00:22:58.742, Speaker A: Right? And I do think the hybrid PBS is basically our best toolbox to defend against that because it allows fast iterations. And then before we enshun into full protocol PBS, then we kind of lose that because everything will be hard for base. Right. For hybrid PBS you have the builder API, then you can play around with that and then we can figure out what works best and what doesn't work best. And then I know people that have been working on hybrid PBS such as Map Boost, Relays Builders, they have been getting a lot of bashing and stuff and I don't think it should be that way. I think we should be working together as one team and to basically advance this censorship thing forward. So yeah, definitely shout out to all the teams that have been working on that.
00:22:58.742 - 00:23:13.018, Speaker A: I mean, they are the real heroes. So yeah, that's all I have today. Thank you so much for having me and yes, thank you. Terrence, we have some questions for you.
00:23:13.184 - 00:23:13.898, Speaker B: Hi.
00:23:14.064 - 00:23:34.726, Speaker C: So, regarding Latency, the numbers you showed were more or less the same as Danis in the first day. So if you have 50% of the network proposing through relayers and 50% of the orphan blocks are coming from relayers, I would have taken that as a sign that Latency did not matter. That would be the expected.
00:23:34.858 - 00:24:28.062, Speaker A: Yes, but I do think that we can do better from the orphan point of view. Right? Because now if you look at 20 plus kids orphaned a week, let's say you just have ten plus giga orphaned, then it's probably better than 20 plus giga orphan. Right? I'm coming from more like the orphan's perspective, because when something orphaned, then it's obviously not ideal because that transactions could be included and there may be some us concerns there. Hey, Terrence, thanks for a super informative talk. Can you say a little bit more about the three relay faults that happened recently? Like how were the malformed headers or payloads generated and how was that mitigated? How do we prevent that in the future? Right. I would say the relay landscape, there's still a lot of work to do there because they need more testing. I need spare tests, any more end to end tests.
00:24:28.062 - 00:25:07.118, Speaker A: And in terms of the fault, right, the first file is flashball, and then they fail to commercial the deposit. And that point is too late because someone already submitted the header and stuff. They already have the signature, so there's not much you can do there. But then they fail to Amart shows because they did not test the payload with a full signature embedded. And the second fall and the third file are basically the second incident and the third incident are basically the same. And I think the block relay so the block's rock relate did not validate the payload, which is what they're supposed to they're supposed to make sure the payload is valid before they pass it to the proposal, but they just did not validate. Yeah.
00:25:07.118 - 00:25:55.162, Speaker A: Hi, Terrence, thanks for the talk. I was curious about the out of protocol cr lists and the proofs of transaction inclusion. Have you done any research into it? Is it practical? Like, would the builders or the relayers be actually able to calculate the proofs in time? Yeah, there's something still under research. I think Chris from flashbox does just open a PR, so I need to look at it. But high level, I think how it should work is just that say you're proposing a slot n. At slot N minus one, you have access to the main pool, and then you see some transactions that get filtered. You basically at slot M minus one, you basically present those transactions to the relayer, and the relayer will also present those transactions to the builder.
00:25:55.162 - 00:26:25.186, Speaker A: And then the builder will essentially build a block, just include those transactions real quick, and then send it back to the relayer at the end after the signature is done, when you get the payload. Right. So they can include a multi proof to basically prove that the signatures sorry, to make sure that the transitions are basically, indeed included in the payload. I don't know yet that's something still under research. Yeah. Hi. Alex Mead Coin Metrics.
00:26:25.186 - 00:26:53.886, Speaker A: Thank you so much for your talk. Really loved it. Just wondering if you would comment on your opinion about maybe non public relays? Do they exist? Is this a possibility? Just wondering. As for now, I don't know any non public relay. I only know the seven relay that was present in mevboost.org. And I also think that if there is non public relay, it's probably hard for us to know just because it's coinbase, it's using a relay there, it's tracking mev. They're not open to public.
00:26:53.886 - 00:26:56.834, Speaker A: I mean, that's not something that we can easily find out.
00:26:57.032 - 00:27:32.894, Speaker D: Why do we think that proofs help in that? Like what he was talking about before, proof of inclusion of transactions. Why can't you just, if the things that are not included once you see the actual payload, disconnect from that relay? Because the relay, even if there is a proof, could always just not release the block, or the block could be invalid or there could be all kinds of faults that make the proof kind of meaningless. And what you end up doing is anyway, disconnecting from the relay. In either case, can we just make it simpler on ourselves and just say, please include these transactions, if they don't, you disconnect from them and next time that won't happen.
00:27:33.092 - 00:27:40.574, Speaker A: No. Yeah, I fully agree. I think that's possible and I think there may be a better solution. Yeah. Hey.
00:27:40.612 - 00:28:04.534, Speaker E: Yeah. Apologies if I already messed this before, but you said that 50% of the network is making use of Mev Boost. Do you have more like fine grained numbers in terms of whether or not with the numbers of institutional stakers versus home stakers? I just know, like, in the institution that I work at, there are security considerations. Mev Boost is sort of like a centralized actor at the moment.
00:28:04.652 - 00:28:43.294, Speaker A: Yeah, there is a site for that I'm happy to share with you after, but yeah, there's a site that actually actively track, for example, Lido coinbase binance, like the top three, just like what relays are they using and stuff like that. And what percentage for each relayer. There is active tracking on that, but I don't have the data in the slide. Sorry. But there is a site for that. Given all of this a validator that's deciding whether they should run Mev Boost or use mev or not, what would be your advice to them? I would say this is a hard question for me personally. And then me and my team have different debates.
00:28:43.294 - 00:29:07.900, Speaker A: I think for now, it's too early to be using this type of technology unless you know what you're doing. Just because we don't have any public infra out there. I will give you an example. Just like for example, for the second incident when the block rod relay has the bug, it took them 6 hours to turn up the relay, which they could turn up right away. But as the public validators, we don't know. Right? I don't have the access information. Be like, hey, there's something wrong.
00:29:07.900 - 00:29:22.750, Speaker A: I basically need to shut. Up. MVP Boost, the best thing can do. People can go to Twitter, but I'm not sure that's the best media for these type of things. Right. So I would say wait. Yeah, that's my advice.
00:29:23.110 - 00:29:49.682, Speaker B: So you mentioned at some point that if you can't reach the relayer, your execution client sorry, the consensus client will reach out to your execution client and build your unblock. It'll default to that. So that makes sense if you can't get the header right. But you mentioned there were two situations. One, where you sign the header and return it, and then you can't get a receipt of that. Is that not a slashing risk?
00:29:49.826 - 00:30:02.186, Speaker A: No, you cannot get it. Right. So once you sign the header, you basically pass the header to the relayer. You don't want to use your local block anymore because now it's a slash risk because now you're assigning two blocks.
00:30:02.298 - 00:30:04.826, Speaker B: So you don't default to building your own block.
00:30:04.858 - 00:30:06.014, Speaker A: In that situation, no. Okay.
00:30:06.052 - 00:30:06.666, Speaker B: I misunderstood.
00:30:06.698 - 00:30:10.460, Speaker A: Yeah. Good. Thank you very much. Darian, amazing talk.
