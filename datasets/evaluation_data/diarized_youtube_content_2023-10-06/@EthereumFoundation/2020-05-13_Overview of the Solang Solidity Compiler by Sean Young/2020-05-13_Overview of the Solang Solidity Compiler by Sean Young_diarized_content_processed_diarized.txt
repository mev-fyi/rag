00:00:00.510 - 00:00:44.560, Speaker A: You. My name is Sean Young, and I'm going to present the Solan clinity compiler. So I have about 20 slides to go through, so I'll go through these fairly quickly. So what is Solang? It's a solidity compiler, which compiles liberty into webassembly. It targets different blockchains. So currently target substrate, ewasm and sawtooth and other ledgers, if they're interested, could add themselves. Now that the EVM backend is getting more stabilizing, that would be a very interesting target to add.
00:00:44.560 - 00:01:39.390, Speaker A: So Solang is written with different tooling than Soul C, so it's written in Rust. When you write in a compiler, you have to deal with ASDs and control flow graphs, and these are represented actually quite well in rust enums. So I think Rust is a quite suitable language. It uses llvm as a library, so it uses llvm for its optimization passes and to write out the WASM file itself. There are also some other advantages to using LLVM, which I'll talk about later. It has a solidity grammar, and from that the parser is generated. So recently I've been adding try catch and adding this to the password, which is about ten lines of code.
00:01:39.390 - 00:02:28.954, Speaker A: So it's fairly straightforward with a generated grammar. So on different blockchains, there are some underlying differences which might be visible in the language. On substrate, the address type is 256 bits. By default, it can actually be different from that depending on how substrate is compiled. So the address type insulinity is different. Also, constructors can be overloaded in substrate, and substrate uses different ABI encoding than ethereum. Lastly, there's a print function which is just useful for debugging.
00:02:28.954 - 00:03:09.950, Speaker A: This is only available in development chains, but it does really help. So here's a funny little example of a solidity contract on substrate. So we have an overloaded constructor. The ABI encodes a function selector for the constructor. The ABI encoding for in 64 is simply eight bytes, little endian, so all the types are fairly simply encoded. So we have a function hello, which takes a string. A string simply has a single field with length, followed by the bytes of the string in the Abi encoding.
00:03:09.950 - 00:03:36.130, Speaker A: And then we have a print function call, which is built in, which calls the substrate print. And here we also can do string concatenation. I'll talk a little bit more about that later. So, a brief history of Solang. Is my screen very blurry?
00:03:37.030 - 00:03:39.122, Speaker B: No, it is crystal clear for.
00:03:39.256 - 00:04:14.382, Speaker A: Okay, okay. It's blurry for me. Okay. So in March I wrote a prototype. So this was a simple grammar for a very limited set of solidity, some LLVM, and within a weekend of hacking I could get a very primitive contract to run. So late in December I was awarded a grant from the web3 foundation. And this was specifically to complete solidity language support for substrate.
00:04:14.382 - 00:04:58.746, Speaker A: This was divided into ten milestones. Five of those have already completed. So these are the remaining milestones for the web free grant. And in September this will end. This should mean that Solang has feature language support complete doesn't mean that the output is optimal. The first aim is to get language correct. Also there will be differences between Solc and Solang language.
00:04:58.746 - 00:05:45.370, Speaker A: For example, on WASm it would be quite difficult with the current scheme to support assembly statements. Also there are some additions, like the print thing I just talked about, and the different ABI encoding on different chains. So a little bit about how when I set out to write Solang, I wanted to build a traditional compiler. I didn't want to do anything revolutionary. I also wanted to be simple. So there are some fairly simple stages to the compiler. So the first thing compiler always does is parsing.
00:05:45.370 - 00:06:50.260, Speaker A: So we have grammar and we have a custom Lexa, and the Lexa is really needed because of the pragma statements. So if a Lexa tokenizes pragmatility with the simver, then it will produce a lot of tokens when it should just take the value as everything up to the first semicolon. So the next stage in the compiler is the resolver. So the parser outputs the abstract syntax tree and resolver well resolves all the symbols in, that generates all the warnings and errors, et cetera. And in Solang it also makes it simple. It goes straight from the ast to a control flow graph. This is actually where the bulk of the code is in the project.
00:06:50.260 - 00:07:18.646, Speaker A: This is where all the language support really is. And this is also a front end compiler because it uses LLVM. So the next part is there's also a standard library. So this is some C code which gets compiled into llvm irr by clang. And this gives us a heap. So we have malloc and realloc, et cetera. We can implement things like string compare and stream concatenate.
00:07:18.646 - 00:08:10.362, Speaker A: We have a keslak hash for changes, don't provide it. That's what we have at the moment. But this can be expanded to have much more things you might want in a language. So in the print statement earlier, it would be useful to be able to print ints or addresses or so. So string formatting would be a very useful thing. And that would be implemented in C, added to the standard library, and then compiled into LVMir. And then this will be linked into one big llvm code and then using global dead code elimination, any unused functionality will be removed.
00:08:10.362 - 00:08:50.100, Speaker A: So having a large standard library doesn't mean that the resulting wasn't file would be any bigger. So the last stage of the compilation is the EMissa. The control flow graph generated by the resolver is specifically geared towards LLVM. So there's mostly one to one mapping. We have to do some tricks for phi nodes, we also have to generate some specific things for WaSM. So because WASM doesn't support two five, six bit arithmetic, we have to have some arithmetic functions. We have to have an ABI encoder decoder.
00:08:50.100 - 00:09:52.744, Speaker A: So we have an ABI encoder decoder for Ethereum ABIs and we have one for parity scale abis. It also does a linking with some library and it has to do some touch ups to the final WaSM in order to make it correct. And there's custom code for each particular target to generate target specific calls to the externals, for example. Lastly, we also need so in this directory in source ABI we have some codes to generate ABIs. In substrate these are called metadata files. This is because in substrate the file contains more than just the function constructors and events. It contains names, comments, will compile a version generated.
00:09:52.744 - 00:10:44.670, Speaker A: The file in the future may contain the hash of the wasm. So you can check the ABI against the wasm, make sure it's the correct one. So Solang is a Hyperledger project, and Hyperledger have the mentorship program, which is a bit like Google Summer of code. And through this, this year there's a mentorship program for Solang language server. So this is for ides. So in an IDe when you write solidity, it can tell you where errors and warnings are. It can do syntax highlighting, give you information about identifiers, et cetera, things that make life easier when you're writing code.
00:10:44.670 - 00:11:42.220, Speaker A: So that's mentorship happening this year, hopefully be more next spring after wait and see, of course. So here's some future ideas of things I would like to work on, but nothing has been done so far. So one of the advantages of using LLVM is that we can use the LLvM linker. So anything that can compile to llvm IR can be linked. So if solidity had a foreign function interface, then any C code or rust or whatever could be called from steadyty and then linked into the wasm. People want to run all sorts of crazy stuff on chain, so this would help them do that. Also, this could be helpful to add crypto, which is written in C to smart contracts.
00:11:42.220 - 00:12:28.750, Speaker A: Another thing is we would like push and pop on memory arrays because we have a heap in our standard library and a real lock. This actually isn't that hard to implement. This is just a question of wiring things up. The other thing I've had many people ask about is improved data structure sensitivity. So we want hash maps, linked lists, sets, trees, all those sorts of things, either in memory or in contract storage. And it'd be great to have those available if you have hash maps, et cetera. You might want generic types to use those.
00:12:28.750 - 00:13:18.830, Speaker A: So something like, something in typescript would be great, though this is all hypothetical really, and I really would like to collaborate with the source C team and see what they think. I do not necessarily want to take solidity in its own direction and away from the official solidity. This is kind of just ideas of what would be good. So the other thing with standard library would have much better string processing, and that just makes life easier for when you're debugging code. As Lionel Stauville said, all you need is printf in order to debug any problem. So this would be just make life so much easier. And.
00:13:18.830 - 00:13:36.070, Speaker A: Well, that's it actually. Yeah. So it's just me working on a project now. There are people interested, but if you want to get in touch or ask any questions, please do. And thank you very much for your time.
00:13:36.920 - 00:14:02.990, Speaker B: Great, awesome. Thank you, Sean. All right, same procedure as every talk. If you have a question in the room, please do raise your hand or shout so that I know that you would like to speak. And for the people on the live stream, we will give you a minute now to think about. If you have questions, then please put them in the GitHub chat. We know you have a delay, so we are waiting for you.
00:14:02.990 - 00:14:12.660, Speaker B: Anybody here in the room has any questions with regards to the Solang validity compiler? Yes, Chris.
00:14:14.140 - 00:14:16.010, Speaker C: Hey, thanks for your talk.
00:14:18.300 - 00:14:19.050, Speaker A: So.
00:14:22.220 - 00:14:46.588, Speaker C: I agree that we should come together more and talk about potential features. The main problem I see is that the language you're working on has substrate as the main and maybe only target. And this is why your language and solidity sometimes have to make different trade offs.
00:14:46.604 - 00:14:47.170, Speaker A: Right?
00:14:51.460 - 00:15:24.270, Speaker C: So, I don't know, I just wanted to say that, for example, memory push and pop, right? If you have a heap and memory is cheap, and then this is certainly a good idea. But as a feature facility, we try to not add features that lure people into thinking that the operation might be cheap, but it is not in the end. So this is a certain trade off we have to make here. I think you're muted.
00:15:27.810 - 00:15:59.680, Speaker A: Thank you. I totally agree. So when as and when ewasm happens, then some of these concerns might somewhat go away around memory usage, et cetera. Also, now that the LRVM EVM backend is quite stable, I think it would be quite interesting to add that as a target to Solang as well.
00:16:01.490 - 00:16:07.020, Speaker C: Yeah, I would be very much interested in some benchmarks there for the llvm EVM backend. Yes.
