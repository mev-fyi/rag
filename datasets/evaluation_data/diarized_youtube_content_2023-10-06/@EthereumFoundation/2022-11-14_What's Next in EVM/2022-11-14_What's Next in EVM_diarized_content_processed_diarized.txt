00:00:16.090 - 00:00:49.260, Speaker A: Epsilon team at Ethereum foundation. And this talk was originally about what's next in the EVM, but we shorted it a bit because lightning talks. But what I want to tell you about today is to give you a quick introduction to EOF EVM object format. But we have to start with the current EVM. We have. So one of the design goals of current EVM was simplicity. And the thing is that we kind of overdone it.
00:00:49.260 - 00:02:15.910, Speaker A: And the current EVM can just execute whatever bytes you will provide to it. And that's why I kind of sometimes thinking about it as a garbage eating machine. So it brings some success to EVM, but must also bring some inefficiencies to it. So one of these inefficient aspects of EVM is that you need to do a lot of work, except above the actual work the instruction are doing internally. So this is like the checks that every step in the interpreter you will need to perform to make sure the EVM works as specification wants it to go. And this is kind of the motivation we want to clear it up. And the cleanup of that is to introduce a container, binary container, for the programs in EVM, so that it will kind of translate the mixture of different features and some missed features in the legacy EVM to something that is a bit more structured and polished.
00:02:15.910 - 00:03:31.070, Speaker A: So the main aspect of EOF is to provide some metadata about the program, including the version number, and split the bytes into code and data sections. We can also do a bit more about that. This is kind of the next proposal that can be applied to the MEV of EOF, which is to introduce functions, so we can partition the code section into more pieces with additional function type information. And to work with the functions in EVM, we will introduce two new instructions. One is to call the other code blob, and one is to return from the call to the caller. And the calling the functions internally allows you to move you between the different code sections. In the code sections you can use relative jumps, which would replace the existing dynamic jumps.
00:03:31.070 - 00:04:45.640, Speaker A: This is the control flow instructions that will allow you move it around in the code sections and it won't be allowed to actually cross the boundaries of the partitions. And as I mentioned, having to this control flow features, we can deprecate the existing jumps semantics in particular. This is really useful because we can drop the jump. This analysis which has to be performed about EVM programs before every execution, and if we kind of adapt all of that with additional code verification, that will happen. We can eliminate these first three checks in the EVM. So this is the additional aspect that can be added to that which we can verify how the functions behave internally with simple algorithms. But to sum up all of that.
00:04:45.640 - 00:05:39.050, Speaker A: Yeah, this kind of improved version of EVM that has some nice control flow, have code and data separation and support native functions. Yeah, so that's mostly what I had to show you today. These are pointers when you can find more information. I think in particular the EFCC talk from this year, it's kind of the extended version of this talk. So yeah, you're invited to see it after it. And yeah, the five bullet points in the end are all the ips that kind of specify the broad aspect of UF. Yeah, I still have 1 minute, so if you want you can shout some questions from the audience.
00:05:39.050 - 00:06:05.220, Speaker A: That's a hard question. I mean, we're kind of competing with the proto dank sharding and withdrawals right now. So yeah, it's hard to tell. Actually some of these aspects were prepared for Shanghai, but not all of the features I talked about today.
00:06:07.590 - 00:06:25.302, Speaker B: Hi, I have a quick question. I'm here. So in one of the slides you strike through stack underflow and stack overflow. Can you give a bit more details around that?
00:06:25.436 - 00:07:07.782, Speaker A: Yeah, this is done by code validation. So when you want to deploy a code it will go through additional validation process. And in particular when you don't have dynamic jumps, you can statically check if the function will never stack underflow. Stack overflow is a bit more complicated, but you can compute like the maximum stack height the function reaches. And then whenever you call the function you can check if you still have enough stack space available. So the second one is a bit more complex and it has some trade offs. I think it's my time, so thank you very much.
00:07:07.836 - 00:07:09.330, Speaker B: Thank you, bye.
