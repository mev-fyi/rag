00:00:05.480 - 00:00:30.000, Speaker A: Thank you very much for coming. So today we're going to talk about side chains and layer two. And the talk is about how they're different, yet very similar in some ways. My name is Georgia. I do consulting and research on off chain protocols, and my main focus on interoperability and scalability. So the big question is, like, why do we want to interoperate? And this is the answer. There's a lot of currencies.
00:00:30.000 - 00:01:04.700, Speaker A: Like they all want to talk with each other. And if the multichain thesis is to survive in the long term, we have to figure something out. Why do we want to scale? So I just learned that there's a talk by Joe Lubin happening right now. Like when 1 million if devs, who cares about the devs? What about the users? And there is no way to get the users without being able to scale with quick confirmation and quick low fees. So let's go back to where it all started. So blockchain released this paper, and I think it's the first time that sidechains was mentioned as a term. Turns out I'm wrong.
00:01:04.700 - 00:01:56.056, Speaker A: This never happened. The first mention of sidechains was by Satoshi in 2010, which he mentioned on bitcoin. Talk as usual, like that side chains could do interoperability. However, what he actually was talking about was merge mining, which is a completely different technique. Three years later, you have Greg Maxwell, a very prominent bitcoin core contributor, who describes a scheme called coin witness, which was very similar, which is very similar to what people call today ZK rollup. And then we have this guy called killerstorm, who actually described the first side chain construction by utilizing certain types of proofs. So the two way peg, as described in the blockchain paper and by Killerstorm describes a mechanism by which somebody locks some money in an escrow.
00:01:56.056 - 00:02:32.964, Speaker A: And then via pegging transaction, you create the same amount of money on another chain, and that is a side chain. And in that side chain, you may have a different rule set. Like maybe the chain progresses faster, maybe it has smart contracts. And then when you want to get your money out, like you provide a burn transaction, and then the people of that side chain, they allow you to withdraw your money back on the original escrow. And there's multiple ways that you can implement that. So let's dive into it. The main problem that we're trying to solve is how we can observe another chain state and convince ourselves that this chain that we're being shown is legit in bitcoin.
00:02:32.964 - 00:03:06.900, Speaker A: That's very easy work. Hashes are very easy to reason about. They're quantifiable, you can do some math, and you can figure out exactly how hard it is to attack. The trick here is that however, if the proof of work algorithm is very expensive, you need to be able to verify it. And doing it with any fancier like proof of work algorithm, it's very hard, and you cannot verify a script, for example, on EVM. And the way that you do this is via a thing called SPV proofs, the way that most light clients work. And there is a very close interaction between sidechains and light clients that I will get to very soon.
00:03:06.900 - 00:03:32.232, Speaker A: So instead of providing the full chain, you provide the chain of headers along with merkel proofs of your transactions. And what you're trying to convince is that the chain that you're giving is actually the longest chain. This is too expensive, this is too long. It's linear. I need to provide you so that you're guaranteed that I'm giving you the best chain without ever having any trusted checkpoint. I need to give you Genesis, a bunch of miracle proofs. And you should be convinced that's way too expensive.
00:03:32.232 - 00:04:21.384, Speaker A: So there's some techniques called nippopows, the one technique called superblocks, nippopows by Dionysus Zindros, and fly client by Benedict Boons, who should be around this area. So you should talk to them about that snarks, which Barry like alluded to earlier, and stateless spvs. So stateless SPV is another technique by James Perstitz, who's also around, and you should talk to him about it. The problem here is that all work is not equal. If I have the bitcoin chain with a bunch of hash rate and a bunch of asics, and the Ethereum chain with the gpus, and like, a different hash rate having an asset on the one chain and on the other chain, even if it represents the same kind of collateral, it's not actually the same. And I have developed this mental model where I want to think of cross chain assets as alloys. So it's similar to how in chemistry, you can combine one metal with another and get some different properties.
00:04:21.384 - 00:05:09.852, Speaker A: I think that moving a bitcoin from the bitcoin chain to some other proof of work chain, perhaps like tokenizing bitcoin on litecoin, for example, for faster confirmation times, is an option. But however, due to the difference in the hash rate, you're no longer as secure as you were before. So you can call that BTC 30. And what about the BTC X where X can be TBTC, WBTC, upeg it some derivative off of the bitcoin which tries to peg the price to it and it's going to be used in the deFi space, for example. However, the assumption here changes from the honest majority of the miners to the honest federation. For example, if you're doing a federated peg or to the whole mechanism around it working, so you have technical risk arising. So each solution has a different tradeoff space.
00:05:09.852 - 00:05:48.196, Speaker A: There is no for lunch. What about proof of stake side chains? So proof of stake side chains don't exist. What about proof of stake like clients, which the argument is that it's equivalent. This is a proof of work block, many proof of work chains, many proof of work blocks. And you accept a proof of work block only if the hash of the block header plus some nons that you change is less than the number. So let's take this and switch this. In the proof of stake situation, you replace the nons with signatures and you accept the block only if the blocks that you have received have signed like more than two thirds of stake.
00:05:48.196 - 00:06:59.932, Speaker A: So how does this look like? How am I going to do a proof of proof of stake? I will pick some blocks like every, some amount of time. I will check that each time the validator set would have changed in this proof of stake side chain I would verify that they signed on the latest block. This means that also, of course it's linear because I have to give you still linear to the size of the chain blocks, but also the side chain smart contract or the light client must always be aware of the latest stake distribution because how will I know that who is the two thirds that I'm receiving the money from the signature from? There's an attack here which I want to call the cross chain nothing at stake attack, which basically says usually in proof of stake change you have the nothing at stake problem where validators start building on two chains. And basically if you can take the data from one chain and put it on the other, you can slash them for equivocating, for double signing. However, what if I have a chain, like I'm a validator, I have a chain that I'm building on, and then I'm just having a hidden chain that I'm also building on, but I'm not sending it to anybody except light clients. The light client must be able to take the signatures that I gave them off out of band and put them on the main chain. I'm not aware of any chain currently that has this mechanism implemented.
00:06:59.932 - 00:07:43.260, Speaker A: Tendermint right now has a few documentation, has some documentation exploring this. They call this, if I'm not mistaken, the phantom validator. Because you're a validator, but not really because you're sending stuff out of bound. The issue also with this is the long range attack. Because what if in order to incentive align this mechanism, you need to slash? How do you slash if the person that fed you with the signatures is now unbonded? It's complicated. So the rule that you must say is that you will only accept proofs like signatures from people that are still bonded, you reject from unbonded validators. How do you know which validators are unbonded? I don't know.
00:07:43.260 - 00:08:36.700, Speaker A: Currently the dominant approach is having a trusted checkpoint via so that you always know what is the latest bonded set of validators. This is an open problem. There is many other solutions that you can take, but again, they all tend to some subjectivity which does not exist in proof of work. Everything so far, we assume that each chain is individually secure. If both chains are secure, then sure you can do, you can make them communicate with each other security and requires that you have something that is high cost, something that is high cost, is not scalable, that has high cost, is not scalable. So side chains consider harmful. What if the side chain like mechanism, if you try to use it for scalability, and if you try to use it for scalability, inherently it will be less secure.
00:08:36.700 - 00:09:26.972, Speaker A: Does not want you to get out. So what if the liquid side chain suddenly becomes devil and like they say, no, your money is gone, you're done. So we don't want that. The decant taxonomy that we have for sidechains then means that we have the federated side chain, which is the multisig allah liquid, the proof of work side chain which is with nipple pause for logarithmic spv proofs and some reorganization proofs. Because as we all know, I hope when you have a proof of work chain that forks like you want to be able to punish for that fork. And you have proof of stake side chains where you have basically a multi sig which gets rotated each time the stake changes during elections, and you also add some equivocation. And the thing is that you trade always security for scalability if you want to use it that way.
00:09:26.972 - 00:10:07.070, Speaker A: There is a great paper released like last week actually by Alexei and friends on communication across the CBD ledger. Right now they're doing a workshop on it, which was very unfortunate because it conflicts with this talk. So make sure you read this paper to elaborate on to conclude on my point about sidechains interoperability solution, it's not a scalability solution. You need an independent security model. And the moment that you have an independent security model, my argument is that you're not in the layer two domain space. It's a layer one that talks with other layer ones. It's like on the same level, how do we scale then? What's going to happen off the chain? So Paddy Macari is around here.
00:10:07.070 - 00:10:54.724, Speaker A: Everything that's working on off chain scalability requires that you have a layer one, a layer two, and some mechanism to make them communicate. You need to put the minimum amount of data on chain, because the chain has a finite amount of space. And if you're going to support 1 million f devs, you're not going to be able to hold all that capacity. And maybe ethereum two is going to do it. But what if it doesn't? What's layer two? So I call it a delayed settlement protocol with layer one guarantees. So you have a protocol where you lock some money on the layer one, then you perform some off chain operations, and then you have guarantees that are equivalent to your layer one security model, that you'll be able to get your money out. And there's two dominant approaches right now, which is the commit chains approach, which is like what plasma is, roll ups, nocoost.
00:10:54.724 - 00:11:23.460, Speaker A: And they have some certain different trade offs, whether they can do smart contracts or not. And there is channels, and the dominant channel approach is the lightning for bitcoin. And as far as I can tell, there is some state channels initiative, which everything merged, and kudos to them because it was a very hard task and they have different properties. But we're not going to talk about channels in this talk. So let's dive into the commit chains. So firstly, we had plasma, like 2017. Vitalik Joseph, they published this paper, nothing in the paper worked.
00:11:23.460 - 00:12:20.612, Speaker A: And it describes basically a mechanism where you have an operator that takes hashes of the side chain and it puts them on the layer one. And the security of the commit chain or the plasma, it comes under the assumption that you're able that anytime that something bad happens, you can take some fraud proof from the plasma chain state, put it on the layer one, compare it to the hash that was committed earlier, and you can get your money out within some time. And it has some synchrony assumption that you must be able to get your money to get the fraud proof in within a week's time or two weeks time. So this is like a synchrony assumption that very security oriented folks will argue against. But again, that's not the topic of the talk. The problem with the plasma construction is that the operator, it's at their sole discretion to give you the data. So what if they don't like you have some state, they create a merkel tree of the state, or of the latest utxo set, they commit it, but they don't give you the data.
00:12:20.612 - 00:13:00.076, Speaker A: You have a problem then, because in certain, they can create an invalid state transition, and this invalid state transition will never be revealed, and you will never know that you no longer have your money. So there have been changes lately to the plasma like protocols to fix that. And it turns out that maybe, yes, maybe plasma was a premature optimization. Maybe many people might have raised money on plasma on something that might be broken. What can we do? That's how technology will move forward. So how are we going to solve the data availability problem? We cannot. So what we're going to do, instead of having off chain data fraud proofs, we'll put data on chain with fraud proofs.
00:13:00.076 - 00:14:00.180, Speaker A: And that's what we call optimistic roll up. And this is what currently the crypto economics lab and the plasma group teams are working on, which is basically that you take all the data that is off chain, you create a smart encoding of them, and you dump it on the call data of the layer one. And that's kind of cheap because the data is not part of the chain, it's just part of the database. Like here and the other people that are working on this. Another independently thought of construction was called merge consensus by Mikara and John Adler, which basically says what I just said, you commit all the Merkel route, and also you put an encoding of the transactions and you use basically the layer one as a data availability oracle. And then if you plug out the fraud proof and you put a validity proof, Zk, snark, stark, like whatever you want, whatever they call it these days, you have a ZK roll up. And I'm saying this just so that we can get over the word salad and understand the bits and pieces that make a mechanism.
00:14:00.180 - 00:14:51.636, Speaker A: Ziggy roll up means that you have the commit the new merkle route of the latest state, or the transaction that happened. You take zero knowledge proof, which attests that this state transition is valid, and you put it on chain. The smart contract verifies that the state transition was valid with moon mask. The problem with this is that maybe you need the trusted setup, as we saw in snark September, where like five new snarks were released maybe we can remove the trusted setup, but I wouldn't build all cryptography that is released on 2019 and they can be expensive like proving times are expensive. Verifiers are also expensive and they can be slow. So again, no free lunch. And note on the onchain data availability because it has been pumped as an idea that is going to solve all our problems.
00:14:51.636 - 00:15:30.704, Speaker A: I'm not a fan because the blockchain is supposed to be the verification layer. The blockchain is not a file. Storage and filecoin and other chains that are going to do that do not exist yet. So we know that this is a hard problem and maybe won't get solved. Solving the data availability problem will give us the ability to do defi and all the other use cases that we're trying to figure out for this industry on the layer two, cheap and fast. But on chain data availability reduces your scalability benefits. You cannot have infinite throughput like with the other layer twos because again, you're bounded by the layer one's capacity.
00:15:30.704 - 00:16:26.896, Speaker A: So it's really a constant size improvement. And also it's parasitic in my view. By parasitic I mean that the moment that you start utilizing the chain so heavily, what about the other apps that are not on your layer to your roll up or whatever you call it? Are they all going to come to your roll up? I think that's too ambitious. And there is a post by Vitalik recently where he elaborates on this, and he's a fan about this idea, which some takeaways from this talk is that we know how to do both proof of work and proof of stake side chains, it's hard to implement them. You need them to both be individually secure and having an honest majority assumption for more than one layer one is hard, as we have seen for multiple 51% attacks on smaller chains. Layer two inherits security from layer one and I have a small taxonomy of what goes where. I'm a fan of the direction.
00:16:26.896 - 00:17:02.930, Speaker A: This is like the current direction that we're going, it seems, but we should be very skeptic about how much we're just dumping on the layer one because nobody can sync an ethereum full node and this is not going to help with it. The conclusion is side chains are for interoperability, layer two is for scalability. Side chains are not layer two, thank you very much and I'll be happy to take some questions for three minutes and also I should have changes. You can find the talk at scaling at Sidechains 2019 pdf. There is a microphone if anybody wants to do a question. We have three minutes. Approach one.
00:17:12.860 - 00:17:35.150, Speaker B: Hi, thank you very much for the talk. So you gave, I think, very detailed criticisms of both layer two and sidechain solutions without highlighting too much of their positive aspects. What solutions are you actually fond of?
00:17:35.600 - 00:18:01.532, Speaker A: I'm fond of the plasma construction for simple state transition for payments, because this industry solves payments and I'm happy, like, if I can get a construction that can do multisig time locks and that's it. And plasma does that fine. Right now, plasma for simple payments, I do not care much about smart contracts. Like smart contracts, multig time locks are sufficient.
00:18:01.696 - 00:18:03.210, Speaker B: Okay, thank you.
00:18:14.350 - 00:18:30.362, Speaker C: Thanks for the breakdown. One thing that you didn't talk about, which I thought would be interesting to hear your perspective on is hybrid approaches for roll ups. So where we use proofs of work from other chains to make the data availability there, but do the fraud proofs on another chain.
00:18:30.506 - 00:18:39.774, Speaker A: Right. Is the question that I have a roll up where I don't post all the data on chain only for specific state transition.
00:18:39.822 - 00:18:43.854, Speaker C: So it's using availability from something other than the l one that you're.
00:18:43.902 - 00:19:15.786, Speaker A: No, I do not think that's good because your security model changes wildly. The security model that I want is I have the layer one. I know exactly how secure it is. I know that I have the bitcoin chain. It has this much censorship resistance, this much capacity. I can dump all this data the moment that I'm going to use bitcoin cash as a data availability layer, which is what you're talking about, means that I have to trust bitcoin cash is miners. And do you know how easy it is to send source bitcoin cash? Very easy, like 10% of bitcoin's hash rate.
00:19:15.786 - 00:19:21.834, Speaker A: So no, if you're going to dump data somewhere, dump it on one chain, in my view.
00:19:22.032 - 00:19:24.180, Speaker C: Okay, thank you.
00:19:26.070 - 00:19:27.940, Speaker A: Okay, thank you so much.
