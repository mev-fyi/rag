00:00:11.370 - 00:00:52.490, Speaker A: Everyone, I'm Madhir Gupta from Palima, and I'll be talking about a short topic of handling revert exceptions in solidarity. So by default, if a transaction reverts, the whole state is reverted, and everything done before that is reverted in easier. So for example, if you are doing a batch transfer and one of the transfer fails, all the other transfers will fail as well. Sometimes you might want to just skip that transfer and let the others continue. It's not natively possible in solidity 0.5 and earlier versions, but it is a planned feature in solidity 0.6 that is the upcoming major version.
00:00:52.490 - 00:01:30.502, Speaker A: But even right now we can emulate this try cache behavior using low level calls. So I'll be talking about how to do that. One disadvantage of using low level chords is that it will bypass some of the static checks that the solicit compiler provides. So if you use this technique, you should know that you might be missing some static checks. So this is a sample code. I know you might not be able to see it, but how it essentially works is that it's a two step process. First you generate the call data that you have to use to call a low level smart contract.
00:01:30.502 - 00:02:20.646, Speaker A: Use a low level call in that you enter the function name and the parameters and the data that you have to pass for the call. Then solidity using the function encode with selector will generate a call data that will be passed on in the next step to call any that can be used to call any smart contract. The next step is to essentially just call the smart contract using the low level call. So how low level call works is that it will never revert. If the subsequent call reverts, it will return false as the result, and then you will be able to handle the revert yourself. So in this case you can see I'm doing a low level call, and if it reverts, it will return the result as false. If it goes successfully, it will return the result as true.
00:02:20.646 - 00:03:04.914, Speaker A: If it returns false, then I'll have to handle that case, maybe log it somewhere that this transaction failed. And if it was true, I can just continue with my process, my batch functions, and I don't have to worry about it anymore. It's a bit clunky right now, but in solidity 0.6 it's very clean and it's something that I'd really love to use in future batch maintain batch functions will become really easier with this. So this issue on GitHub you can follow, it tracks the progress of the implementation in solidity 0.6 and hopefully you will be able to enjoy that. If you need more info about that, there's more info on my blog, mother blog.
00:03:04.914 - 00:03:09.080, Speaker A: You can visit that as well. And that's my short talk. Thank you.
