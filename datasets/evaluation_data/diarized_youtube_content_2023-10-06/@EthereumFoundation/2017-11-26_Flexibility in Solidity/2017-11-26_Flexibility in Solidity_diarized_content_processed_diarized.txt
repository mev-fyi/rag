00:00:08.570 - 00:01:03.890, Speaker A: When you design a programming language, you have to make compromises constantly. There are people who request features, and of course features are nice, but with each new feature, the language gets more complicated and thus easier, harder to understand, and it's easier to make a mistake, the more complicated the language is. So you have the constant balance between functionality and safety. Of course there are features that are safe, but yeah, that's the compromise you have to find. And this has not been the case for general purpose programming languages for several years now. But in blockchain, there's always the factor of cost. So smart contracts have to be very cheap to execute, and that also limits the features you can add in a language.
00:01:03.890 - 00:02:17.212, Speaker A: Back in the days when solidity was started, the initial goal was to create a usable high language, high level language, as fast as possible. And I think we succeeded in that. But of course, we made some decisions which turned out to be not, that turned out not to be the best decisions, and now is the time to change them. And solidity is still a language that changes, and that allows us to make the necessary changes to the design. And yeah, the path we want to go is we want to keep features that are relatively safe and they look like high level features, but most of them are actually quite low level. So we want to have features that look like high level features, but are still cheap. And we want to remove everything that can surprise users or has some magic involved.
00:02:17.212 - 00:03:02.960, Speaker A: And then a third factor is we are adding formal verification tools that are easy to use. And I would like to stress this easy to use part, because that is essential. And we will see that later in the talk. And then if that is not enough for you, we provide direct way to access very, very low level features of the Ethereum virtual machine. And the important point is here that we remove everything that is kind of intermediate level. So, for example, address call will be removed in the future because it has some magic, some unexpected things involved that we would like to avoid. So if you want to do such low level things, you have to go all the way down to the Ethereum virtual machine.
00:03:02.960 - 00:04:00.204, Speaker A: Okay, this is kind of the path we want to take. Now let's talk about some new features we added in the last year. This contract here is a simple database that stores people by an identifier, a name and some flag that says whether they are owner of something. And you have a function there which allows you to add one person to the database. It already looks quite repetitive, but it gets even more complicated if you want to add a function that can append a list of people into that database. The problem many people run into is that you kind of have to create an array out of these three things here. And what you usually do is that you add three parameters which are each an array.
00:04:00.204 - 00:04:51.090, Speaker A: And this of course creates the problem that you have to check that all of them have the same length because you have an ID that corresponds to a name and this flag. This looks really ugly. But fortunately now what you can do now is, sorry, what you can do now is this. And we added structs as a central feature to the ABI, which allows you to actually just directly pass this struct from JavaScript into the contract and remove all these weird repetitions. And of course you can also return an array of structs. So this is not yet available, but yeah, thanks. So we hope to get that fully functional by the end of the year.
00:04:51.090 - 00:05:49.350, Speaker A: The way what this was possible was through a change in the compiler itself. So we could have done that the old way, but we decided to do a full rewrite of the ABI encoder and decoder. And this is a snippet of the solidity code generator and how it looked before this change. Yeah, this is also really ugly. The EVM is a stack machine, and because of that you have these pop and Dup operations, and in the code generator you constantly have to keep track which variable is where on the stack. And because of that we have these comments, and it's really really complicated to understand what this code does and also complicated to write new code. And this is how it looks now.
00:05:49.350 - 00:06:31.620, Speaker A: And it leverages a new intermediate language we introduced called Yulia. Alex talked about that, I think yesterday or the day before yesterday. So I will not go too into depth about that. But you see, this is really readable. It has variables. You know what happens, you can use names we have for loops and so on. And what you also see is you have these angle brackets here, and this is because this is an intermediate language mixed with a very very simple string templating engine to make it more flexible.
00:06:31.620 - 00:07:29.792, Speaker A: What you see here is the full function to do any encoding of an array into the ABI encoding. So it does handle memory arrays, call it arrays, storage arrays, arrays of arrays, arrays of constant length, arrays of dynamic length, and so on. And the way it works is that, for example here at the top we have length equals length fun, and at the time of compilation this length fun is replaced by the name of the actual function to retrieve the length of the ray, which is of course different for statically sized and dynamically sized arrays. Um, okay. And a language becomes more and more useful, the better tools are available for that. We already see that in the questions that were asked in the previous talk. Remix got gigantic updates.
00:07:29.792 - 00:08:24.392, Speaker A: I think Jan will talk about that later today. We now can track variables, have breakpoints, see references of variables, and I think soon can also rename variables and so on. We have a way to export the AST, which is the result of the parsing step. This allows many new features, and one of them is a tool to do code coverage not based on syntax, not just based on lines, but on semantics. So for example, is a less than operator actually tested to do what it does, and then a standard JSon I o. This is a way to get more fine grained control about the settings of the compiler. Yeah.
00:08:24.392 - 00:09:20.600, Speaker A: Then I have a very special announcement to make. And this is that the solidity documentation that we only have in English for now is now also available in Spanish. So please give a big round of applause to these five people who, these five people who did that in their free time, just as voluntary contributors. I think this is really important to make Ethereum accessible to the world. And languages like chinese or Russian should also have their own translation of the documentation. And I want to spend the rest of the talk on formal verification of solidity. And whoops, I think I showed this slide to you last year in Shanghai.
00:09:20.600 - 00:10:19.252, Speaker A: This is a smart contract, and it has comments which allow a formal proof that the sum of the balances in this token contract never changes. And the way it works is that the smart contract gets translated by the compiler into a language called Y three, and it mixes this translation with the comments you have here. And then you run an external tool on that to create the proof that the balances are constant. The sum of the balances are constant. But what you see is that there are almost as many lines of commons in this code as there is code. And you also see that these commons use a language that is slightly different from solidity. So it requires you to learn a new language, it requires you to learn how to use these tools.
00:10:19.252 - 00:10:49.284, Speaker A: And this makes it very hard to use this formal verification tool. And the harder it is to use, the easier it is to make mistakes. And also it is easier for form. Verification is only useful if people understand what is actually proven there. So the statements that are proven there have to be understood by humans. And if that is not possible, then nobody will use formal verification, and it's useless. And because of that.
00:10:49.284 - 00:11:49.610, Speaker A: So yeah, perhaps that approach was not so great. So we took a step back and reconsidered, and how it looks now is like this. We replaced y three by a tool called an SMT solver. SMT solvers are less powerful than general theorem provers, and because of that, this smart contract. In this smart contract we cannot prove that the sum of all balances is constant, but we can prove that the sum of the two balances that are modified is constant. So what happens here is we have a require statement, which doesn't have much to do with the formal verification. This is just the regular solidity requirements require statement, and then we store the sum of the two balances in the before variable, we perform the modification, and after that we check that before equals after.
00:11:49.610 - 00:12:45.664, Speaker A: And this is a regular solidity assert. So if the sum of the balances is not the same, then this will throw an exception at runtime. But using the SMT solver you also get a proof at compile time that this assertion will never be triggered. More specifically, what happens is that you can use this tool with require statements to have expressions that you assume to be correct, and then the tool proves that there is no assertion that fails, there is no overflow or underflow in your arithmetic operations, no division by zero, no constant conditions, no unreachable code and whatever. We will come up in the future. And so let's take a look at a simpler example. This is still an experimental feature, and because of that you need this first line that activates the s and t checker.
00:12:45.664 - 00:13:47.070, Speaker A: And yeah, the function here just takes two numbers and adds them. Of course there's a problem, because we can have an arithmetic overflow here in this edition, and this is exactly what the so if you run the compiler on that, then this is the message you will get. And the great thing about this SmT solver is that it's more limited than y three, but it has a feature that y three did not have. And this is the following so if an assertion fails, it tells you why it fails. And I think this is really important because otherwise people say, I don't know, it doesn't work. But okay, let's just comment it out or whatever, throw something at it so that it doesn't complain anymore. But this tells you why it fails, and kind of forces you to think about this addition and think about why it might create an overflow, and then take the necessary steps to prevent the overflow before it happens.
00:13:47.070 - 00:15:00.470, Speaker A: Currently what people often do is create runtime checks about overflow, add runtime checks about overflow in arithmetics. But this can be really dangerous, because if you end up in a situation where you have an overflow because of some internal mechanism of the smart contract, then the smart contract will be stuck because it will always throw this exception because of the overflow, and you perhaps can't get the money out or whatever. But if you already get the warning at compile time before you deploy your contract, you can think about why it happens and prevent this from happening in the first place. And how you prevent it is like this. So you add a require statement, which of course in the end has the same effect as if you would just check if there is an overflow. But the benefit is that you see that there's an additional condition that is present about these numbers A and B, and the SMT solver will now see the require statement, take these conditions into account, and then check again whether the overflow will happen. And of course it sees that a number less than two to the 100 plus a number less than two to the 100 will be less than two to the 256.
00:15:00.470 - 00:15:47.140, Speaker A: Okay, yeah, let's take a look at another example. This is an actual example from the underhanded solidity coding contest, where there was a loop that used an unsigned variable and decreased it, but checked against greater or equal than zero. And of course this loop condition is always true. That's of course something that can be detected from the type of the variable alone. And you don't really need an SMT checker. But yeah, this was a simple example to present here, and it can do much more complicated conditions. And yes, this is what we'll see next.
00:15:47.140 - 00:16:38.816, Speaker A: And this talk was quite dry about programming language theory, so I would like to end it with an exciting math puzzle. So here we have a circle plus circle equals ten. Circle times Square plus square equals twelve. Circle Times Square minus triangle times circle equals circle. What is triangle? Any guesses? So yeah, easy as PI. We just write a small solidity program that is equivalent to this puzzle, and we add the conditions as require conditions, and then at the end assert false. So assert false.
00:16:38.816 - 00:17:12.844, Speaker A: Sounds weird, why would we do that? And the reason is, if the SMT checker can prove so a failing assertion, so assert false is not bad. It's only bad if it's actually reachable code. So false assertion will not be triggered if it's not reachable. So the SMT checker has to prove to us that this assert false is actually reachable. And it's reachable if all the three required conditions above are true. And of course it doesn't just tell us that it's reachable. It tells us how it's reachable.
00:17:12.844 - 00:17:44.410, Speaker A: So what are the exact inputs to get to this failing? Assert. And we see that triangle is one. Okay. This kind of shows the power of the SMT solo. We don't really know yet. So it's still experimental and not fully finished yet. We don't know how it will behave on very complicated contracts, but, yeah, we're optimistic, and let's see how it goes.
00:17:44.410 - 00:17:45.700, Speaker A: Thank you for your attention.
