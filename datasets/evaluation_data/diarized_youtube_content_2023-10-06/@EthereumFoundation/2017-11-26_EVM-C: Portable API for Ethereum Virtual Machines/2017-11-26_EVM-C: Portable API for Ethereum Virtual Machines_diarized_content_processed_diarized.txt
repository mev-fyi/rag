00:00:25.170 - 00:02:07.160, Speaker A: So I'm Pavel Boliza, and this talk will be about EVM and EVMC, which is portable API for Ethereum Viltur machine. I'm a software developer. I specialized in c, and currently I'm working mostly in the CPP Ethereum project. And I'm the author of evmjit, which is alternative EVM implementation that translates EVM bytecode to native machine language. And I also try to come up with the APA for EVM that is called EVMC. So this talk will have two parts. First one I would like to explain what exactly am I talking about and what do I mean by EVM API and EVM interface? And in the second part, I would like to show what have been done so far, what we want to do in the near future, and explain some design decisions we made so far to be able for you to better understand why things look as they look at the moment.
00:02:07.160 - 00:03:38.180, Speaker A: So, EVM, the Ethereum virtual machine, one of the most important components of Ethereum software and Ethereum ecosystem. So it's, in short words, virtual machine that actually can execute small programs or small scripts called smart contracts. And yeah, where it is, every ethereum client, at least full nodes, have EVM somewhere inside. Usually there is one implementation of that, but we have some examples where EVM clients can actually have more of them. And CPP Ethereum is one of the examples here. But the problem I would like to address is the fact that evms are somehow embedded inside the client. You can have more or less indirect access to it to EVM through JSON RPC, some test RPC systems, VM tracing, storage backlog and so on.
00:03:38.180 - 00:05:21.490, Speaker A: But what I try to address is, I would like this composition to be look more or less like this one. So this fin layer that actually connects evms to Ethereum clients to be very well specified, very well documented, and to be also usable from different programming languages. And also what can add to this scheme is to be able to actually plug in the same EVM implementation to different clients. Okay, so EVMC is one of the possible solutions to this problem. And it's exactly what I meant before. It's Evm API that uses C language to connect these two now separated components. The EVM Ethereum virtual machine to be connected with Ethereum client and why C language was chosen, not because it's the most beautiful one, but it happens that C is actually accessible for many programming languages.
00:05:21.490 - 00:06:51.630, Speaker A: The obvious examples are C and C plus plus. But for many popular languages that are around, you can actually at least use some C libraries and execute functions from C libraries from that languages. I tried all this stuff with go using the Seago tool, and also in Python using cffi library, but I'm sure there are the other examples when you can at least use C libraries in more high level, more abstract languages. And second important part of that is we want to have polymorphic interfaces there. So we would like to be able to use different to switch between different EVM implementations and runtime. Not that we want to build a client with this one and decide on the build time what actually implementation we like to use. Yeah, we want to have a switch that user can actually use to decide what kind of backend they want for its task.
00:06:51.630 - 00:08:24.590, Speaker A: And third important part we took account of to make some design decisions is composability. So the composability means actually we can do something like that. When having some concrete implementations of VM, we can add more and more layers on top of that that actually delegate the execution to the lower layers. But on the upper layer you can make some additional decisions where actually you want to send your code to. So for example, if we consider interpreter and JIT like EVM, you might want to actually have top layer that actually decides if the code should go to the JIT one or to the interpreter one. And the top layer can actually, for example, count the number of executions of particular code. If we have some hot code that is executed in many transactions, we may want to actually translate that using the JIT EVM to some native machine code and speed up the execution.
00:08:24.590 - 00:10:05.790, Speaker A: But that may not have sense if the code is not frequent enough to actually pay the cost of overhead of doing the translation upfront and not having may not make a lot of sense. The second example of such composition can be having actually different languages in smart contract. If we consider the proposed eWASM and EVM 1.0, we can just add very simple layer on top of that that actually can recognize if the smart contract uses the webassembly like language or EVM one bytecode. So how actually this EVMC looks like this is actually the single file, a single C header file, and includes declarations on functions and structs and also all the documentation is this file in form of comments. So this is actually the only source you should care about. And I paid attention to actually have good enough documentation to understand how it works just reading the single file.
00:10:05.790 - 00:11:41.150, Speaker A: And at the moment this is part of my EVMG project as long I'm experimenting with that. And the API is not finished yet, it's included in this project. Okay, so the whole design has some kind of two parts, two sides, and one is related to the client, to the client side, and one is related to the EVM itself. On the client side, what have to be done? You need to implement some context class and contact class provides virtual methods and can answer questions coming from EVM. And these questions are something like get me the balance of given account or get me the storage at given storage slot for given contract. All this information cannot be provided to the EVM upfront because we don't want to send the whole state to the EVM to execute smart contracts. But DVM need a way to actually extract this information on demand.
00:11:41.150 - 00:12:56.520, Speaker A: And on the second side, on the EVM side there is EVM class and EVM class. It's quite simple. There is a way to actually construct the EVM instance and there is a way to destroy it. And the core function is actually execute function when the information, what is to be executed is encoded in your message object, and also the context is provided for the execution. And EVM uses this context interface to ask for more data if needed. So in case you would like to implement new client but you don't want to in the same time implement EVM. There you would like to use some of EVMC compatible evms available.
00:12:56.520 - 00:14:46.710, Speaker A: What you have to do, your job is to implement the context class and there are eight virtual methods that have to be implemented and you have also encode your information what to execute in the message structure. And if you would like to for example implement the EVM, but you don't care about the rest of the Ethereum client like network stack, non storage database and so on. All you need to do is to implement the create and destroy pair of functions and the execute one. So not to be confused, this design operates on the object oriented concepts, but on the way you will do that you will have to translate it down to the c so it gets more obscure and complex. So what we have so far with this. So as I mentioned at the beginning, the C client have actually two EVMs and one is classic interpreter and it actually does not use the eVMC, but we plan to do it in the near future. But evmjit, the jit like eVm uses the evMC interface and it's compatible with the recent hard fork of Byzantium.
00:14:46.710 - 00:16:31.538, Speaker A: There is also the Hura project that a prototype of ethereum client with ewasm backend and there is also a prototype of EVM implemented purely in C language. I also prepared some time ago a prototype of GaF with the evmjit plugged in and the Python client with evmjit plugged in. This still needs some work, and it requires updates to the current status of the code, but it's quite fun to play with that and what we want to do next. The missing piece of EVMC API is VM tracing, and this is a showstopper for a moment because we cannot replace existing VMs completely because this missing feature is important in other places. If this is in place, we would like to move the CPPA interpreter to use the eVMC interface as well, and I also plan to release experimental GAF with evmjit as a virtual machine. There recently also, someone considered using this interface together with fast testing project okay, that was all from mine. Thank you for your attention.
00:16:31.538 - 00:16:57.920, Speaker A: And in case some questions, I'm available for full whole devcom around. Thank you. It's.
