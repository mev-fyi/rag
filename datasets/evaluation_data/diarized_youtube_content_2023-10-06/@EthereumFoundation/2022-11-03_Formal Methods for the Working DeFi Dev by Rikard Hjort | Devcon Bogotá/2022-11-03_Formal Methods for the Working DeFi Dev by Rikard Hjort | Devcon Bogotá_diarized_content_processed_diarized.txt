00:00:12.010 - 00:00:42.060, Speaker A: Why am I doing this? Talk. The candid motivation is I want you as developers to do more of the work that you assign to auditors yourselves. We get a lot of questions inst someone signs up for an audit. The audit is going to start in two months. The code will be frozen and then we invariably get the question, can we help you prepare for the audit somehow? Can we help you make sure that the audit runs smoothly? There's a few obvious ones. Let's see. Do you have a pointer? I do.
00:00:42.060 - 00:01:23.800, Speaker A: These things I'm not going to talk about because I hope, dearly, that if you hire an auditing company, you have good tests, they run, they pass. You have integration tests, you got documentation, and you make sure that your devs are available for the couple of weeks that you're going to spend on an audit in case a question comes up. Those are the basics. But I know a lot of teams are really highly skilled and they're very motivated and they want to do more if they can. Well, what can you do? What's the secret sauce to getting a good audit? Actually? What's the secret sauce of the auditors? Auditors like us. Different audit companies do different things. But we have our own little method of working, which I'm going to share with you.
00:01:23.800 - 00:02:03.810, Speaker A: Invariance. We like something called invariance. Sometimes you call them properties or property based tests or whatever your favorite equations over state. I usually just use the word invariance for everything. They help you find more bugs, write better docs, trust your code more. They help auditors because as auditors, especially, we, we're going to be looking at invariants and trying to find more of our invariants of our own, basically. So if you come with a little set of these that you've already gone over, you've done some of our work for us and we can focus on either deeper work or we can work more efficiently and get you done faster.
00:02:03.810 - 00:02:51.026, Speaker A: So we want you to come up with invariants of your on chain code. They're also good fuss targets. We're going to get to that. One thing we found, especially developers, they can tell you exactly like, oh, you have to go to this function and this function, you will see exactly where this variable get updated and everything. And once you start talking about invariance and we say things like, well, just the sum of all balances, always match the total balance and so on, then we find that a lot of auditors or sorry, developers start looking at their code from a new angle because this is sort of a top down angle. It's almost like you're coming back to the design phase, moving out of the optimized imperative code and thinking in a more declarative fashion. Don't have to read all this.
00:02:51.026 - 00:03:31.440, Speaker A: I just like to have things I know this is being recorded. I myself like to pause slightly, talks and read slides. So I put more here than I'm going to read, so don't read all of it. I'm just going to say really quickly, here's how we're going to structure this talk. We're going to go over how to make invariance. I call that status just equations. Then how to prove invariance, at least in a pen and paper fashion, which is what we often do, talk about how to approach things when you can't really get your proof to work, and also how to use your invariance to do fuss testing and even monitoring, if that's something you want to do.
00:03:31.440 - 00:04:06.540, Speaker A: And if you have code working right now, if you have a laptop up, you can bring up your own code, go over your own code. Because I'll be explaining how to come up with invariance. If something comes to mind and you want to write that down, please do that. I'll be working over an example from an audit we did a while ago. So if you don't have any code you're working on right now, or you just want to follow through now and then go out and start working on variants on your own after this session, that's fine too. It's a lot to cover. An hour isn't really enough.
00:04:06.540 - 00:04:33.970, Speaker A: Anyone here interested? We can just grab a table. I'm happy to take anyone from this crowd anywhere and just keep going with the workshop if you want to keep working on invariants afterwards. So just grab me. We'll find a table somewhere. And as many of you who want to keep going, we'll just keep going. I like this a bit too much. It feels almost pathological, but I love when developers come up with invariants.
00:04:33.970 - 00:05:06.880, Speaker A: So testing versus invariance testing is I guess I didn't see the previous talk, but I think he was talking about how to do better tests. Tests are sort of like the camping knife. It's like if you know what you're doing, you can use it for almost everything and you'll get out of most things by just doing a bunch of testing. It's our first and most robust line of defense. There's a myriad of resources to help you test better. There are talks here probably how to test better again, I assume you already know how to do tests. I assume you do unit tests, that you do integration tests, you try deploying on testnets and so on.
00:05:06.880 - 00:05:38.374, Speaker A: And my analogy for tests is sort of like an experiment, right? You're trying a single thing. You're going to see what happens if I do exactly this call, or I do this little sequence of calls. It's great. And we often like, especially test driven developers like to talk about testing as some sort of silver bullet. Even if they say it's not. Then you can kind of feel like, oh, testing is what you need and that's going to solve your problems. But I don't know any developer that actually trusts their code enough.
00:05:38.374 - 00:06:29.046, Speaker A: It's like, oh, my test suite passed. Bring on the billion dollars TVL. That doesn't happen, right? You sit down and you really think through it and you talk to your colleagues like, well, are we sure? Have we thought about everything? And that's sort of like theory. Reasoning about code is like developing a theory. If testing is just an experiment in a physics or like a science context, they help you verify that your theory is correct. And if you do enough experience, you might be pretty convinced. But you also probably want to make sure, go over your theory and see if, like, are there any holes in it? Does my theory lead to inconsistencies? Even if you tried 200 prime numbers, maybe prime number 201 is going to be the one that breaks your little mathematical theorem.
00:06:29.046 - 00:07:02.146, Speaker A: So you need to be reasoning about what your theory is saying. The thing is, there's very few resources about this. I had one five minute talk by my professor when I started college saying, like, here's how I run over code in my head. And I think that's the end of it. And it feels like reasoning about code is something you learn from experience. It's something we're always doing when we're debugging, doing code review, doing design discussions, we're kind of like, simulating things in our head, but there's not much resources about it. No one's really teaching you how to do it.
00:07:02.146 - 00:07:37.310, Speaker A: It's just sort of like, well, you're a good developer. With time you learn it. So I want to change some of that by giving you some structure. If you don't know where to start recently about your code to make it more secure, here's going to be a few steps to get you going. This is meant to either intimidate you or titillate you, depending on what kind of person you are. But we're doing something that's sort of analogous to math proofs. So in math, you were taught both, like computing answers, like figuring something specific out, but also how to do proofs, how to make sure that the algorithm that I'm doing is always going to work.
00:07:37.310 - 00:08:10.906, Speaker A: Again, it's sort of like the analogy testing versus reasoning, experiment versus theory, reasoning about CODIS analogists for proofs. Before anyone, say, curry Howard like, I'm not talking about something like that if you're a theoretical computer scientist. I'm talking about something very straightforward that I think anyone who has taken a basic code boot camp should be able to do. And just like proving there's a method, there's a bit of archistry. It's not always straightforward. I can't guarantee you that your proofs will work even if your theory is correct. But there's a structure to it.
00:08:10.906 - 00:08:53.190, Speaker A: You don't have to just be flailing around trying to prove random stuff. And with that, we get to the actual invariance. What is an invariant? What are we looking for and what are we trying to do? So this is very small. So one way to think of a good invariant, it's something that it's obvious that the code is doing or should be doing, but if it works correctly, it should be doing this specific thing. But it's sort of incidental from the code. Nowhere in the code is this like directly enforced. It's just something that sort of should be obvious from your business logic.
00:08:53.190 - 00:09:41.960, Speaker A: Ideally, it's really something really high level, like a liveness claim that this contract can never get stuck and so on. But to be completely honest, starting with really simple invariants will get you quite far most of the time. And we'll do a very simple invariant here today. And I can tell you from experience that even those really simple invariants that aren't like super high level claim that the entire protocol is perfectly secure, they still help you find bugs in your code. And we find bugs all the time using them. Invariant defined as it's not varying, it's constant in mathematics, it's unaffected by a designated operation or an invariant quantity, function, configuration of a system. It's something that's always true.
00:09:41.960 - 00:10:29.446, Speaker A: You can think of what's the code behind the code because the code is very exact, it's imperative it tells the computer or like the EVM, exactly how to do every little step. So it's imperative not declarative is one way to say it. And here's your chance to be declarative. You say something like, here's the equation that should always hold. I think any, ERC, 20 contract should have this property, right? You keep track of the total balance, you're minting, you're burning, you're transferring. And we just kind of assume, or like we hope, or we might be very confident that the total balance is going to be the same as the balances in each individual account that has interacted with the mapping of balances. So this is just a way to say, take all the balances in the mapping and sum them up.
00:10:29.446 - 00:11:01.360, Speaker A: If someone knows way too much about the EVM, like I do, then just think of as every time you wrote directly into a mapping. Technically, the mapping contains a bunch of other stuff, but don't worry about that. And again, a gradient variant is something that's obvious from the intended business logic like this. Of course, the total balance should be just all the actual balances that are out there. But it's not necessarily obvious from the code. Nowhere in the code is just that there's no one summing over the balance anywhere in the code. Here's a working example.
00:11:01.360 - 00:11:52.154, Speaker A: If you don't have any code of your own you want to pull up and follow along on your laptop, you can go to GitHub Alchemics Finance V Two Foundry repo. It should be pinned at the top. We're working at the contract Alchemist, so we're going to be like control effing through a little bit of it if you want to follow along properly. Or you can just watch the slides really quickly. This is sort of a slightly more involved version of the sum of all balances, total balance invariant. They have something called shares that they use to make sure that you get your yield in proportion to how much you have staked, essentially. And then for every specific yield token, there exists a total shares valuable so slightly more involved than the sum of all balance.
00:11:52.154 - 00:12:28.860, Speaker A: This is total balance invariant. Here's how you'd frame it as the mathematical equation. If you go into the mapping of all yield tokens that contains the token address as a key and a set of params, that's this yield token params. If you go into the params total shares, that should be equal to the sum over all the accounts. This value of each account, that's just one invariant we came up with. We proved it turned out helpful. I'm not sure if we actually found any bug on that one, but we do find bugs on those kinds of things quite often.
00:12:28.860 - 00:13:04.950, Speaker A: But the question is, so if you're sitting here with your own code, for example, or you're watching this later, you're thinking about your own code, how do you come up with good invariants? How do you come up with looking for something like this? And there's a few tricks. First is to come up with many. Try to think of anything you can state as an invariant, state that as an invariant, and then focus on the ones that seem to be important. Second one is go over storage variables. Do they have obvious relationships? This was a good example. You have the balances and you have the total balances. Of course, that should just stick out as a sore thumb.
00:13:04.950 - 00:13:35.646, Speaker A: These two things should have a very tight relationship between them. Ghost variables is a nice trick. That's sort of just like introducing variables that don't exist directly in the code, but that you can use when you're reasoning over pen and paper. I'm going to give you an example. The optimizing is always fun. Like you're doing a lot of optimizations. Even if you're not a big optimizer, you're not iterating over all the accounts of all your users, for example.
00:13:35.646 - 00:14:17.950, Speaker A: That's a sort of optimizations. As solidity developers, we need to optimize. But what if you just think, I don't have to optimize at all? You write the code as you would in a dumb java program, and then you just state the invariant saying like, well, this naive implementation and this optimized implementation are identical modulo gas usage. Go to your design spec. I hope you have one. You all write design docs, right? Read it over, see if there's anything you're mentioning there that's obvious. Like that's something that there's a good chance it says something in the design doc like, well, these two variables should have a relationship to each other that might not have been carried over to your code comments.
00:14:17.950 - 00:15:03.870, Speaker A: Those are usually good invariants. You can also work from unit tests like replace some unit test values and start thinking about what if we'd start fussing it? What if we use symbolic values? What properties would they have to satisfy and then just try to state them as equations or something similar. It doesn't have to be a mathematical equation, it can also just be a very exact description. That's what happens if you open a math paper. It's not all just a set of equations, it's a formal line of reasoning written in English and that's fine too. So ghost variables are just a way to introduce variables into your invariance or your system. Descriptions that don't exist on the chain or that you don't have on the chain.
00:15:03.870 - 00:15:58.074, Speaker A: So impossible to compute functions we've seen already some overall balances. You can think of that as sort of a ghost variable. You can't really do it on chain for several reasons, but you're absolutely free to use it in your invariance and just make sure that whenever you're adding or subtracting from a balance somewhere in that mapping, then that sum gets updated. Another one is like, well, total deposited ever. For example, how much ether has this contract ever received? Maybe you're not actually tracking that. You can't probably actually track that in your contract. But if you're just reasoning about your contract, then you can say like, well, how much ether has ever been in this contract? Make that a variable and use that in your equations and hopefully you may decide that some of these ghost variables actually deserve to become state variables.
00:15:58.074 - 00:16:38.502, Speaker A: It might make sense to actually keep track of these on chain the way we do with totals, even if it's just for monitoring, even if it's just a little view function, even if it costs a little bit of gas. It's going to help you reason about your code, monitor your code and make sure you can run your tests on chain state forever. Here's an example of the optimizing, just to give you a quick look of what that can look like. Here's a really simple optimized normally optimized piece of code. When you give rewards, then you increment the total reward ever variable. That should be a semicolon there. And where did all semicolons go? Must have done a search replace.
00:16:38.502 - 00:17:22.038, Speaker A: Oh well, what happens when you keep copying over from different resources? And then when you withdraw a reward, you just calculate whatever a user has a specific stake and you can say the last time they received a reward. You calculate how much reward they've earned. Since then you update some variables and you send them some tokens. The really dumb way to do this is when you say give rewards, you just iterate over all the users and you give them a bit of reward. And then when they withdraw, you just set their rewards to zero and you send the tokens. You can't do that, right? That's not really possible. And if you do that, I will slap your fingers but you can definitely make a statement like, hey, these things will give the exact same results for a single user.
00:17:22.038 - 00:18:00.098, Speaker A: Right. If we call the Give Rewards with a certain number of amounts and then I call Withdraw Rewards, I should receive the same things from both of these implementations. That's a nice little invariant question. This would be just like, we're going to get to part of the reasoning. Yeah. I want to also emphasize, and I will emphasize a few times, you need to show your work. Again, I feel like a math professor here, but show your work because there's a lot of work involved in coming up with the invariants and then proving them.
00:18:00.098 - 00:18:42.500, Speaker A: And if you do this to yourself in your notebook and then you throw your notebook away, then, well, the next person is going to have to redo it or the auditor is going to have to redo it. And that can be expensive for you, so make sure that you have it. I don't know how you like to document things. If you like to do it in your codes directly in your code comments, or if you want to have a Google Doc somewhere, whichever, but you could have a few pages in a Google document that say, like, hey, what if we implemented like this? Here's our actual implementation. These should be equivalent. Here's pen and paper proof showing that it should be this doesn't work in a real contract. Sorry.
00:18:42.500 - 00:19:15.914, Speaker A: Don't go deleting all your semicolons. All the examples here are illustrative. This one isn't pulled from an actual deployed code. It's just a quick example of what de optimization looks like. Or I can say, oh, it's pseudocode because some of you might be writing Viper and the process still works. Okay, now we get to actually proving them. So you come up with something that you say like, well, this should always hold over my contract forever proving.
00:19:15.914 - 00:19:57.900, Speaker A: I had a math teacher who said, like, well, proving sounds scary. You just need to convince someone. How good does your proof need to be? Well, you're going to have to show it to someone. If that's you, if that's your friend, if that's Nature magazine, then whoever you're talking to, you need to convince them that, yes, I know my argument is sound and it's complete and my theorem holds, right. The good thing about code is that it's usually boring and straightforward. It's pretty mechanical because hopefully the code is pretty straightforward. And all you need to do is check a bunch of places, which can be boring, but straightforward usually.
00:19:57.900 - 00:20:26.606, Speaker A: So how do you prove an invariant? Well, straightforward, you figure out where are all the variables or ghost variables that are ever written to where are they modified. You find all the locations in the code. You list every function that modify any of these invariants. You make a list if it's a Google Doc, if you have some cool emacs tool to do that. Go ahead. Just make sure you have a list of them. So this is like manual verification.
00:20:26.606 - 00:20:47.180, Speaker A: Of course we work with tools. We mechanize things. We love building tools that do these things. But it's actually really very useful, especially for smaller contracts that just do it as pen and paper a lot of the time. So don't get intimidated when I say just write it down. Write it down in a document and follow it through. It doesn't actually take that long most of the time.
00:20:47.180 - 00:21:19.898, Speaker A: Then you check what's called a base case. You check that the invariant will hold from the start in the constructor, the initializer, wherever. Just make sure that your invariant isn't invalidated immediately as the contract is deployed. That's usually the easy part. And then the hardest part is the inductive case. You find all the locations that you noted here and you go over all of them. You can assume as you go into the contract that's the transaction start, that the invariant holds.
00:21:19.898 - 00:21:55.650, Speaker A: And then you just look at all the locations that modify the variables. You do some symbolic updates. Just say like, I'll show you what that means in a second. And then you check that your invariant still holds. If you do all these and you find that the invariant holds from the beginning and it holds at the end of each function. If it held in the beginning, then you're done like the invariant holds forever in this contract on the working example. So if you pulled up the code, then you can control f for our variables, which are total shares and balances.
00:21:55.650 - 00:22:38.986, Speaker A: If we look over the contract, I usually use a silver searcher and some other tools. Just look, get an initial search for where are all the places where these variables can be modified. There are more structured ways to do this, but just this used to the fastest. Make sure you look for assembly code because it can modify your storage variables and make sure you find all the relevant locations. Also look in the contract you inherit from because, you know, modifications can happen there as well. Use a dependency graph tool if you need to. In this case, we find these three functions modify our total shares and balances, add yield token, issue shares per amount and burn shares.
00:22:38.986 - 00:23:06.310, Speaker A: These two are internal, this one's external. I can just tell you the add, the first one add yield token is fine. It just sets the values to zero constructor and initializer doesn't really touch any of this. So everything's zero. So we get initially zero equals zero because the total shares for every yield token starts at zero and all the balances start at zero. So this is a sum of zeros and we get zero equals zero. That's true.
00:23:06.310 - 00:23:52.230, Speaker A: So the invariant holds initially and then we go and find the issue shares for amounts. We find that in these two locations, our variables to balance us and total shares get modified. Technically, it also makes sense to reason about, like, could there be reentrancy in here? Actually, in this case, that wouldn't matter. Are there many different paths to this function? No, it's a very straightforward function. Technically, there's a path here, but that doesn't matter for us because the only relevant changes are in this basic block. There's failures, but if this function fails, then state doesn't get committed and it's still fine. So we find that we add a number of shares to total shares.
00:23:52.230 - 00:23:58.854, Speaker A: Read very carefully. Accounts, recipient, balances, yield, token. Shares. Yes. Heel token, seal token, total shares. Shares, yes. Okay.
00:23:58.854 - 00:24:23.582, Speaker A: We just add shares to both sides. Note that we don't really care how the shares were computed. This might be an external call. Like, anything can happen here. It doesn't matter. What we know is that if we come to this location in the code and we go through this line and this line, our invariant will hold. Once we're out of it, this one is left as an exercise to the reader.
00:24:23.582 - 00:24:57.740, Speaker A: It's slightly more not challenging. It's just the exact same thing. But, I mean, now we've proven this invariant, and it may sound slightly meaningless, but it's sort of like one of those questions that come up as you're developing, hey, am I sure that, well, total shares and the balances, they should always match? I should check that at some point. Maybe I haven't. But now you have checked it and you wrote down your proof, hopefully. And now you know, and you don't have to worry about it. That's one good thing.
00:24:57.740 - 00:25:24.274, Speaker A: You can convince everyone that the invariance holds. The case may seem trivial, but as things get hairier, the bugs get scarier. And this class of bugs are definitely out there. People do forget to do the second variable update. I mean, it wouldn't be crazy to find this code without the second line. Here it happens. Someone slips through a code review, and then it happens.
00:25:24.274 - 00:26:11.278, Speaker A: And now you're in deep shit because this is actually used to calculate rewards. And if this line was missing, you'd be in deep trouble, and your auditors would find it and report it a critical vulnerability. And again, make sure you save yourself somewhere useful, somewhere you can find it, somewhere you can show your colleagues so you don't have to redo your work. Chris, did anyone pull up some of their own code and is looking for invariants in? Some. Okay, cool. Okay, so I know that you're all hardcore super developers, and your code is not always this straightforward. So what do you do then? Failed proofs.
00:26:11.278 - 00:27:09.394, Speaker A: And I don't mean like if you find that the proof doesn't hold, then your variant is invalidated, and you need to make sure that figure out why it doesn't work and fix that. What I talk about here is failed proofs is when you actually fail to prove it. You didn't really conclude that your invariant doesn't hold, you're not sure it holds, what can you do? Especially as code gets hairier. Well, when that happens, it's actually a good guide to refactoring and refining your code. So here are some basic tools that we can use and we usually recommend, like, if we can't prove if we can't prove an invariant, and we really try to, then we usually ask you like, hey, can you make this a bit more clear? Because we haven't been able to convince ourselves, we haven't been able to convince you. You should want to be convinced of this invariant. And until that happens, we should make sure that we can either help each other reason through the code, or we can make the code more easy to reason about.
00:27:09.394 - 00:27:40.160, Speaker A: So if the function's logic is too complex, if you really don't want to refactor, one thing you can do is instead of giving a name to each function, you give a name to each basic block. Does everyone know what I mean when I say a basic block? Okay, going back. So a basic block of code is the code that will always be executed together. So, for example, if you enter this function, this can't fail. There's no branching here. This can't fail. Well, this can't fail, actually.
00:27:40.160 - 00:28:24.190, Speaker A: But if we ignore reverting failures for this case, which we can, because reverts will just mean that nothing happened, these three lines will always be executed together, and so will this condition. But this line may or may not be executed. So you can think of this as a basic block and this as a basic block. If you have a while loop, then the body is a good example of a basic block. If there's no more branching in it, basically anything that's like, you can treat a solid chunk of code that will always be executed together with each other. If you had thrown this line into here or like another if case, then it would not be in the same basic block. And then it would be harder to reason that your invariant holds.
00:28:24.190 - 00:29:15.002, Speaker A: That's what a basic block is a single piece of code that will always be executed together. And if you have really complex logic and your functions are really big, you might want to instead of giving labels to just the functions, you give labels to each basic block. And the reasoning works the same way. If you can prove that after each basic block as you go into it and as you come out of it invariant holds, then your inductive proof is fine and your invariant holds. What we find sometimes is that you will only, like, the variables that need to be updated together are updated in slightly different places. And then we get an argument like, well, you know, but they will always, because of some sort of reasoning about the possible execution conditions, they will still always be executed together. Well, why don't.
00:29:15.002 - 00:29:37.006, Speaker A: Just colocate them, put them right after one another to make it easy to reason about them. If you have complex arithmetic expressions with rounding, ignore that for now. Treat numbers as real numbers. Don't worry about rounding at all. You can do rounding error analysis separately. Write your stuff as functions. Imagine it's all real numbers, make sure your invariant holds, and then you do rounding error analysis.
00:29:37.006 - 00:30:10.830, Speaker A: We did a talk on that yesterday. I'm sure you can find the link in the DevCon videos about how to do routing error analysis to make sure your contracts are safe. If you have a bunch of different invariants, a nice thing is to do what's called framing conditions. You just write over each function which storage it modifies. So you can look at a function and say, like, well, this function modifies all these storage variables. If it doesn't modify any one of the ones you care about, then you're fine. If it modifies one of the ones in your invariant but not one of the others, then look out.
00:30:10.830 - 00:31:02.606, Speaker A: But it's just a good way to build up your code with comments that will make it easier to reason about in a structured way. If you're doing this more and more again, did you check everything? Imports, inheritance, both up and down, inline assembly? There's a bunch of places where you can have storage modifications that you weren't thinking about. Control f ing is not enough. And if the code keeps changing, if you're doing this as you're prototyping, you're doing it wrong. Once you've done a proof and you checked everything and your code changes, you will need to recheck your proof. So this is very much something you will do towards the end, ideally when the code is frozen or almost frozen. So again, if you're asking an audit firm to audit your code, you should ideally freeze it before and that will like, whenever you freeze it, you can start doing this or slightly before.
00:31:02.606 - 00:31:40.666, Speaker A: Do you have a question for the live stream? So pretty much when I have the client that really likes to change the assumptions of the whole project, basically, then I guess I should write those invariants but recheck them every time the changes happens. Yes. Yeah. And I mean, that can be a statement of work. Hey, we did all these things and then, oh, we just wanted to add a new functionality and like, okay, I'm going to recheck these things. That's going to take me four days. But you already checked them.
00:31:40.666 - 00:32:13.750, Speaker A: Like, well, you changed the code. That's sort of the negotiation with the client. And it also kind of emphasizes that you do need to freeze your code as much as possible. Again, if you document your proofs really well and they don't refactor everything and change the entire design, then change like looking over the proofs should be pretty straightforward. If you're used to it, you can kind of work from the diff just oh, they made this code diff. And you can make sure that all these changes would still respect the invariant. Just look at all those locations and make sure that the invariant is still respected.
00:32:13.750 - 00:32:20.070, Speaker A: Do you have the microphone? Thanks, Yao.
00:32:21.550 - 00:32:41.680, Speaker B: Yeah, I just wanted to add that maybe the thing he's talking about with frame conditions helps with that. Because you write down what storage slots each function is modifying. Tell your client like, hey, you make the modification, write down the updated storage slots, and then that minimizes how many functions you have to recheck your invariant for. Because if they didn't change which storage slots it was asking, you don't have to recheck it.
00:32:42.210 - 00:33:27.840, Speaker A: And there's a feedback loop here as well, right. If you write down your framing conditions, put them in the function, and then you can make sure that the client knows to respect them or again, update their framing conditions. One beautiful thing about this way of working that we found is a lot of our clients get trained to do this more and more themselves. They start producing better code. It's more readable, it's not always less complex, but the important things are more colocated and so on. So I would say personally, if clients keep changing the code, make sure that they understand that there's a cost to that. If they still want to do it, of course they can do it, but also help them to train them to be better at when they do that.
00:33:27.840 - 00:34:15.680, Speaker A: They also make sure that the proofs that you produced or that they produced that they have are also kept up to date. Right? Yeah, I like things. It's like colocation, sort of like imagine like if you I don't know if anyone writes Java or C or JavaScript. Imagine if you use one of the basic data structures like hash tables or something, and you manually had to manage the number of items. You had to manage all the internal variables. This is sort of a kind of encapsulation. I know people don't always love using libraries for different reasons, gas optimizes and so on, but try to make sure that your code behaves more like it like all the things that are relevant to this little data structure, update it in the same place.
00:34:15.680 - 00:35:23.726, Speaker A: How do you recommend testing basic blocks if they're like, within a function, like unit? Testing them, like for invariance? If you want to assert invariance for a basic block, I mean, it's just the same thing, right? Let's say that this was a really complex function and there's a bunch of code here and a bunch of code here, and there's a bunch of different paths through this function, right? I would name this basic block, whatever basic block these contain, I would name that something. And then instead of checking every function, instead of going over every function and proving this, I would just prove it over the basic block, like here. So I know I can assume as we go into this block when we are here, assume the invariant holds after the basic block, which I know will be executed together. I can show that it holds. And then for every basic block, you just go, well, in this basic block, it's not modified. So if it holds before, then it holds after the basic blocks up here. If it gets modified before, if it doesn't get modified, so it still holds.
00:35:23.726 - 00:36:26.840, Speaker A: Right. So it's sort of like instead of showing that the invariants hold over each function, you do it over the basic block and you give them a name or something. And if for some reason this was down here, one of the updates were down here, then that's a good reason to move it up so that they're in the same place, because that will make you reason. It's a lot harder to reason about it if they're in the different basic blocks, because then you have to think about everything that happens between there. But if you colocate them, then it's a lot easier. Okay, I do want to function well, you need I mean, technically, you could say like you needed to hold from if it holds in the beginning of the transaction, it holds at the end of the transaction, but maybe the invariant breaks between two blocks, but your invariant holds for the whole function. How do you recommend dealing with that? It's just much hairier proof to make.
00:36:26.840 - 00:37:27.978, Speaker A: If you really need to do consider if you really need to do that, if you really need to do it that way, then you do need to treat the entire thing as one block and reason about all the possible paths between. I'm a little short on time if I want to get through this. So we do have ten minutes of questions at the end, right? So if there's something that just one quick question. Hello. If you have an ID, for instance, that you generate and you increase one by one, this ID will eventually overflow, and you cannot prove that it will never overflow, but it will require millions of transactions. So in practice, you can prove it, but it will be never reachable. So what is your view on this? You state your assumptions, you make the assumption that there will never be two to the power 256 transactions on the ethereum blockchain, and you move on with your day.
00:37:27.978 - 00:37:51.940, Speaker A: That's it. All right? The counter in open sepling contracts can be unchecked on its increment because it will never update. It will never overflow, if you know what I'm talking about. If you don't, then doesn't matter. I just need to move on. So if you're having a lot of trouble, look at the invariant that's giving you trouble. Pick one function, look at all the relevant variables and try to group them.
00:37:51.940 - 00:38:11.690, Speaker A: You may have to create a few different paths. Use helper functions like this one's really good. They have the burn shares and issue shares. I think that might have been in our recommendation. Like, well, these things will have to be updated together. Let's make sure they're updated in a single place where all the relevant things to burning shares happen together. Right.
00:38:11.690 - 00:38:40.542, Speaker A: Don't do it all over the code if you can avoid it. Remember, this is what you need to show. The invariant holds at construction time initialization. And if the invariant holds at the beginning of a basic block, it holds at the end of the basic block. Prove that for all the blocks, then the invariant holds. Anyone who likes discrete math, this is an induction proof. We're security auditors.
00:38:40.542 - 00:39:08.906, Speaker A: We have slightly different priorities, sometimes from developers. So security is the most important thing. Simplicity is the second most important thing. It can depend. But the thing is, simplicity is so tied into security that we really care about simplicity. And we'd rather have you skip a neat bit of functionality if it just makes things too complex and then save that for version two or something, or an extension. And optimizations are the least important thing.
00:39:08.906 - 00:40:07.194, Speaker A: I know that doesn't resonate with everyone, but if these things are so much more important to you than keeping things simple and having it make it being easy to reason about security, what you can do again, it's a lot of work. But then again, you should probably spend ten times more time on securing your smart contract code than you spend on writing it. So it might be worth it. You can start with simple functions and prove that it's sort of like the de optimization thing. Start with something simple, prove that it's correct, then start doing incremental optimizations and prove at every step that your proof still holds, right? And you end up with slightly more complex proof, but you'll end up with a proof nonetheless, saying that your invariance still holds over your more optimized code. I do want to talk about invariance as test targets we like to use foundry. You can take your invariance and didn't create a bunch of tests to just test those as properties.
00:40:07.194 - 00:40:41.660, Speaker A: Like you take the invariant we had here and there you go. And you run a test that just does a bunch of different operations and it interacts with your protocol in a bunch of different ways. And at the end it checks your property. That's pretty straightforward. A really cool thing you can do is if you could instrument your testing to just at the end of every test you're running, check your invariant, make sure your invariant is always holds everywhere. It can be hairier, there's things. I'm going to show you one trick to do it.
00:40:41.660 - 00:41:09.486, Speaker A: It's not the most elegant way, but it's the most simplest that will get you going quickly. Here's a dead simple idea. We take the contract we just had and we just wrap it. So we take all the functions that affect user accounts. So we make sure we keep track of all the users we have so we can do the sum of all the balances thing. And then whenever there's an interaction, we make sure we add that user to the set. Then we do the regular update.
00:41:09.486 - 00:41:53.134, Speaker A: And at the end of every function, we check our invariance. And we do this for all the relevant functions in the contract. And checking the invariance is just checking? Well, the ones we have, this one's called a two. So checking a two is just doing this thing. We're summing over all the balances, and then we make sure that matches the total shares. So now you're checking your invariant at the end in each and every interaction you're doing with your contract. Again, I mean, I'm sure bunch of you are cool hackers, and you could do this with I forget the name of the Foundry op code, but you can update the EVM code of the contract in place to do this in a cooler way and in a more robust way.
00:41:53.134 - 00:42:19.180, Speaker A: But this will get you going pretty quickly. So, yeah, basically, your job is to update ghost variables, the variables that you have in storage. You can always check your ghost variables you need to keep track of with a wrapper. This might also convince you that some of your ghost variables should be actual variables. Maybe it makes sense to keep track of a set of all your users in your code. I don't know. It's a trade off you have to make.
00:42:19.180 - 00:42:49.250, Speaker A: And finally, I just want to mention you can also use this for monitoring. I think someone mentioned it. There's two approaches to monitoring. Roughly one of them is just doing it on chain. If you find some important variants that you can check on chain, you can put them in, requires an assert clause. And then if for some reason at the end of a transaction, they are violated, you bail, you stop the protocol. That's good, because you can halt the contract before bad things happen.
00:42:49.250 - 00:43:09.398, Speaker A: No one's going to be able to mess with your toll shares and steal a bunch of yield that way. It is pretty scary, though, because it can cause liveness bugs. You don't want your contract to end up in a state where it can never proceed. And now all the funds are stuck. So talk to your auditor. It's like talking to your doctor. We're here.
00:43:09.398 - 00:43:40.100, Speaker A: Have them on speed dial. Ask like, I'm not sure about this, but I have this little thing in my code, and they might say, that's fine. Or they might say, come right in, drop everything you're doing and let's talk about this. And obviously, gas costs. You have to put the gas cost on all the users. Or you can do off chain monitoring a poor man's monitor. We'll get to that, but you can deploy it later, even if you already have a protocol up and running, you can still deploy some off chain monitoring can cause liveness bugs, obviously.
00:43:40.100 - 00:44:25.498, Speaker A: What do you do if you detect a failure? Maybe it's already too late. Your invariant got violated, someone stole all your money and it may not prevent hacks that happen in a single block. Someone uses splash bots and violates some invariants, and now the damage is already done before your sentinels can come in and halt your protocol. A portman's monitor is actually just using your foundry fussing tests and running them constantly against on chain state and pinging a dev. If for some reason they get violated after that. First I should mention, what can you do next? Well, you can keep finding invariants. You can add more, document them, share them with your auditors, share them with your users.
00:44:25.498 - 00:45:15.034, Speaker A: You probably have a bunch of white hat users. Hopefully that can if you make bold statements, they will take that as a challenge and go and try to find violations of them. And the good thing is you can kind of keep doing this long after deployment, finding, finding good invariants, making that we will improve your documentation and that we'll improve your monitoring so security doesn't end when you deploy. Another thing I want to mention is we like symbolic execution. We like formal verification. So we're working pretty hard on making sure that if you write your invariants in foundry and you fuss over them, you can try as many million inputs as you want. We also have a tool that will let you run it symbolically, so try it on all inputs.
00:45:15.034 - 00:45:35.830, Speaker A: There's a bunch of trade offs. You should do fussing first because it's fast. You can write your tests using solidity. Same thing because we used a foundry test. Anyway, you're limited to what you can express in solidity. Whereas with our KVM foundry implementation, you can kind of use all of matching logic. Not all of matching logic, but a lot of matching logic.
00:45:35.830 - 00:46:13.282, Speaker A: It's a nice logic. Fussing is extremely fast. This symbolic execution is pretty slow. It's getting faster. My CTO is looking at me, I might have called it it's orange, but it's turning more and more yellow. Doesn't require any human intervention. This often requires human intervention because a symbolic execution or engine or approver might not be able to complete it, might not be able to say yes, I proved it, or no, I found a counterexample, it might say C three can't handle this query, so you're going to have to help me out here.
00:46:13.282 - 00:46:44.714, Speaker A: And that can require some expert human intervention. Symbolic inputs are 100% input coverage. You're testing every possible value. So if you prove your invariance with K, ABM and Foundry, then they're proven this was contentions yesterday. The idea of false positives and false negatives. I think it's unfair to say that you have false negatives with Fussing because, well, it's not like Foundry comes or Echidna comes and says like, oh, actually we didn't find anything, so therefore it's safe. But the problem is sometimes that's what developers or users think.
00:46:44.714 - 00:47:03.662, Speaker A: So that's why you can think of that as a false positive. You can't really have or a false negative. You can't really have a false negative or a false positive. With symbolic execution. Either we prove that this doesn't hold, or we prove that it holds either your invariance correct or it's not. Or you get stuck and you need a human. And then you need to do some things that are easy to try, hard to master.
00:47:03.662 - 00:47:39.520, Speaker A: Easy to try means that you can get in on our alpha release and do it. Hard to master means you might have to call us and we'll help you. And we're happy to help you along. Here's what can look like forged tests will run the standard 256 tests for you. You can turn this up to as many million as you want with KVM Foundry. This is an example from Rolls talk yesterday. KVM was able to prove that a specific invariant just held that was written initially as a foundry test.
00:47:39.520 - 00:48:10.620, Speaker A: Again, go and look at his video if you want to check that out. I would be remiss if I didn't mention that we are starting a research branch at Runtime Verification. So if anyone's research minded or just curious, please go to Research runtimeverification.com. We have a bunch of research challenges there. If any one of them look interesting, just reach out to us. We'll see how we can help you along, or if we happy to hear your ideas on any of the research challenges. I think that's what I got.
00:48:10.620 - 00:48:40.580, Speaker A: We do have ten minutes for questions. I was promised, so I've seen a few hands. Again, if someone wants to try this right now, pull up some of your code, try to find a few invariants. I'll just do a little train out of here, and we'll find a table somewhere and sit down and work for as long as we have to. If you go home and you do this later, write me at Twitter or@runtimerevication.com you can always reach out to us at Discord. We're happy to help.
00:48:40.580 - 00:49:12.950, Speaker A: This is a past talk. The videos should come soon, so check that out as well. It's important to what you'll be doing, because eventually your invariant will contain a division, and then all bets are off and you need to know what you're doing. Cool. Yeah. So the idea that you can do pen and paper proofs as a really robust method is new to me. I guess my question is, it might be a bit vague, but how do you think of the risk of let's say I take that seriously and I write my proof, I convince my team member.
00:49:12.950 - 00:49:53.446, Speaker A: How do you think about the risk that we've still missed something? Is it common in your experience, if a client takes it seriously, that they kind of mess that process up the good thing is that if they do, then if you write invariants and like, hey, we have a proof, we will also check the proof. It's part of the audit. Yeah, we're the ACM journal you're submitting to. We'll make sure that you're reasoning it sound because, like, oh, this is a good invariant. We trust you guys, but let's double check, right? As for pen and paper versus so this is still formal verification. Someone said, like, oh, it's not formal verification because it's pen and paper. No, it is formal verification.
00:49:53.446 - 00:50:14.074, Speaker A: It's not mechanized form of verification. You wouldn't take a math paper and say, oh, it's not a formal proof because it's in English. It's still formal proof. It's about how you reason and how good you are at formal reasoning. It's about how many nines you need, right? I mean, it's a Swiss cheese model. You may not ever catch everything that you want to catch. The world is chaotic.
00:50:14.074 - 00:50:53.118, Speaker A: But if you start with your pen and paper proofs, that will get you very long way. And in the end, a few of these things might be like the invariant I showed you. I wouldn't even necessarily want to mechanize that because there's more interesting things to mechanize. But here's a pen and paper proof that's fairly convincing. And we'll make a little note somewhere that if anything happens that updates any of these variables, we need to double check it, right? It's sort of like an index for you to work with. I sort of grabbed the mic. Whoever has the mic, just go, okay, so obviously part of the limitations of defining invariants would be like if it's a house and the invariant is no thief can go through the front door or come out if he somehow got in.
00:50:53.118 - 00:52:00.674, Speaker A: Let's say that's the invariant. So obviously the limitation would be that we sort of didn't define that, oh, there's also a window, or there were roof tiles, or there was something to that effect. Now, obviously you didn't make the statement that it's like an absolute thing, but how do we work towards that kind of comprehensive or exhaustive type of invariant definition? Well, to work with your analogy, what you do is something like instead of saying the thief can't go through the front door, what you care about? The thief can't get in the house. And then you have to say, what are all the ways to get in the house? What can happen? Is there a hole in the walls? And where is there a window? Can you get in from the roof? It's sort of the same thing here. One thing we do a lot is a really good target start an audit with is where are all the places where any token transfers happen? Those are a great place to work backwards from, and then there's always inline assembly. But let's forget that for now. But just look at all the places where tokens or ether changes hand.
00:52:00.674 - 00:52:42.646, Speaker A: And then you can start looking like, well, if we cover all the paths that can reach those locations and those are all safe, then we're safe. And then of course, what if the token can do weird things? If it can block users or something. Something you need to keep in mind. But yeah, that's sort of the approach, right? Like find like, well, take the floor of the house as the thing that this thief can never reach and then exhaustively enumerate all the way someone can reach the floor of your house, I guess. Yeah, exactly. So, I mean, a lot of these things like, well, the devs can upgrade the contract and take all your money. That's an assumption.
00:52:42.646 - 00:52:47.742, Speaker A: Sorry, but barring that, we're doing reasoning. Who has Mike?
00:52:47.886 - 00:53:44.078, Speaker C: I have Mike. So in the example you showed where you talked about basic blocks, my reaction was and reasoning about invariants before and after. As it's written, they're not necessarily accessible to us. Maybe we instrument it. But yeah, I can't really get in there easily with the tools I have in my hand by hand, like forge and say, okay, this is an invariant that holds over this if statement or like the block in there. So I'm curious if there is a way I'm missing. And then this also maybe part two is, does verifiable code look different than readable code and testable code? Because if I'm to, I imagine pulling this out into a lot of helper functions.
00:53:44.078 - 00:53:50.660, Speaker C: That's not my preference in this case. So I'd like to hear your thoughts on that.
00:53:52.070 - 00:54:41.906, Speaker A: Also, first of all, Foundry comes with some limitations that you don't have in a very mature language like Java, there's all kinds of reflections and Python, there's just nothing you can't do. This function is internal. So we can't really unit test with Foundry, which is also a good reason to do this kind of reasoning. Because instead of having to go through all your code with a tool, you can just go and say like, well, I know solidity well enough to say that, well, the only way this storage lock can be modified is either in inline assembly or somewhere where this is exactly named in this way in this specific contract. I don't think anyone's made a solidity. No, there's no other way around it right now. That's why this reasoning is pretty good, especially right now with the state of solidity.
00:54:41.906 - 00:55:29.174, Speaker A: You can tackle these things on pen and paper quite easily that you can't really do with Foundry. Ask for the readable. I say they all come together pretty well in the sense that you don't have to have small helper functions all over. But again, the data structure example, right? Like if you think of your Java hash map as a single entity, make sure that it might be a good idea to have the updates or deletions from that just be colocated. And it might as well probably be a function, right? So it's not about going crazy. I wouldn't say like break these out too in a helper function. Like we have the burns and we have the issues, that's fine.
00:55:29.174 - 00:56:17.890, Speaker A: It's only two places. Verifiable code, well, testable code, especially now if you're using foundry testable code, kind of requires you to put everything public, which a bunch of costs that you might not want to pay. But verifiable code, I'd say now, it just really relies on this that you have all the relevant changes to things that have a clear relationship are colocated, whether that's in functions or anywhere else. And write a bunch of inline comments that say how you're respecting this environment and so on. I'd say that the enemy of this is maintainable code. That's why the good thing here is like, well, things we don't maintain that much code here. Like, we deploy it and then it's deployed.
00:56:17.890 - 00:56:45.918, Speaker A: So you don't have to worry that much about like, well, what if we change the code and then we forget to update the code comments because we're kind of relying on the idea that things get frozen here. That's one reason that formal methods haven't really had a breakthrough in web two or standard back end development because everything has to be maintainable. If you have to redo your proofs all the time, then it might not be worth it. So the fact that code is frozen is actually pretty important here. Does that answer it?
00:56:46.004 - 00:56:50.800, Speaker D: Okay, I actually have a follow on question to that right here in the back.
00:56:51.250 - 00:56:51.662, Speaker A: Hi.
00:56:51.716 - 00:57:40.682, Speaker D: Yeah, you said that you should be doing these proofs only during the or when the code is frozen because you don't want to have to be redoing your changes over and over, which is right. You don't want to have to be redoing this work. But you have something to mechanize, the invariant checking, you can do it not only with changes, but you can also get valuable feedback during the development cycle, right? And that has other benefits too that you sort of alluded to in your symbolic execution is that you don't have to rely on the fact that you have to manually look at all the places where storage is updated. You don't have to worry about the fact that you made a delegate call into a library and oops, actually that library had an inline assembly block that is secretly changing that. That all gets sort of handled for you automatically during mechanized proving. I guess I quibble with what you have said there, that you should only be doing your invariant proofs. You should probably be doing it much more frequently.
00:57:40.826 - 00:58:00.600, Speaker A: Yeah, I'm more talking from experience, I would say start writing invariants. As soon as you hit your docs, you're doing your design. Start writing invariants. Keep them up to date in code. Realistically, that doesn't happen as much as I'd like. If you want to be a unicorn and do that, I love. You, but I know most people here won't do it.
00:58:00.600 - 00:58:51.254, Speaker A: That's sort of what I was getting at. And especially, like, yeah, if you do your instrumented tests, then go right ahead. It's also, like, from experience, sometimes designs change enough during the process that maybe teams don't want to invest all that time in, because these instrumented tests can take a while to do as well. If you want to have some examples, go to that Alchemics V two foundry repo. It's called that because we're working on setting up foundry tests sort of like this, but even more powerful and extensive. So you can see some of the work that goes into doing, like, full foundry checking of a bunch of different invariants. But all the invariants came from an audit where we found them and wrote, like, formal English proofs of them.
00:58:51.254 - 00:59:22.800, Speaker A: Lucas over there actually did that. Yes. This paper and a bunch of other things in our publications are actually really good resources. If you just want more examples of this, there's an entire section where we just go over, like, ten different invariants and give fairly formal proofs or hand waves about why each of them holds. So it's a great place to go and see more examples. There's also links if you go again to the beginning in the lecture notes are slightly more extensive, there should be links in there.
00:59:25.830 - 01:00:26.174, Speaker E: Kind of a follow up on that. It strikes me that some of this could be related to behavior driven development. I don't know if I haven't really seen this in the solidity web three world, but think of, like, a TDD loop, but then zoom out. So instead of writing a failing unit test, red green refactor loop, you're doing a red green refactor loop at, like, app or protocol functionality level. So instead of, like, the standard arrange, act, assert way that we might set up a unit test in behavior driven development, they call it given when then so given some background, when some action gets taken, then I expect these assertions at the end, and I think it could fit well with threat modeling, like actors assets actions. I was just curious if you've seen that, because when we're doing BDD and I'm trying it out on a slidy project, you got to keep those green. And so I wonder if there's a way to kind of drive some of your development with invariance that you use in the BDD world, you use cucumber, which is, like, runnable English language, so I thought that might be a pattern.
01:00:26.174 - 01:00:27.270, Speaker E: I didn't know if you've seen that.
01:00:27.340 - 01:00:33.640, Speaker A: No, I haven't, but I want to talk to you. That sounds great. I want to check that out. Cool.
01:00:35.930 - 01:00:57.120, Speaker B: Hello. I just wanted to make one clarification that the inductive proof at the function level is what you need to perform to get the invariant to hold, but the basic block level is easier. That's why it's presented as an alternative. So if you can show it at the basic block level, then it holds at the function level, not necessarily the other way around. So if you can't show it at the basic block level, try it at the function level. Still might hold.
01:00:59.730 - 01:02:03.170, Speaker A: Does it work with Viper? The KVM? I guess it's language agnostic. KVM doesn't actually work over Viper. So the thing is, like well, the thing we're developed now works over foundry, and foundry works over solidity. But I mean, there's nothing stopping you from setting up your own little pipeline where you build your contracts in Viper, test them in solidity with foundry, or just hack on foundry to make it include a Viper compiler and then do the same things because it's all EVM at the bottom anyway. I'm sure someone's going to hack together a Viper extension of foundry eventually, but just curious if you had any examples of mechanized invariant tests that you like to look to or that I could look over. Just I still haven't wrapped my head around the mental framework for parsing out what invariants should look like. Maybe like a mix of English, like pen and paper invariance and code might be helpful.
01:02:03.170 - 01:02:48.926, Speaker A: Yeah, I'd say check out the alchemy paper for a good run through of. So there's a section in the beginning that lists invariance, and there's a section in the end that proves the invariance and in between are just all like the findings, reports with mechanized proofs. We have a bunch of tests come talk to us. It depends on your background and where you want to start. We have just a bunch of different resources depending on what you're interested in, your starting level. There's the make or die multicolateral die proofs if you want. Like, well, here's a full formal treatment which has some English language stuff, but it's also like, fully formally specified at the function level, all of it.
01:02:48.926 - 01:03:15.724, Speaker A: And that's all verified. That's a good example, but hang around, we'll clear you out. It. Oh, yeah? Anyone in a oh, shit. Anyone in a runtime verification t shirt? Is there no workshop after this? Okay, cool. So, yeah, we can't hang around here now. Okay, fair enough.
01:03:15.724 - 01:03:17.310, Speaker A: Okay, thanks everyone.
