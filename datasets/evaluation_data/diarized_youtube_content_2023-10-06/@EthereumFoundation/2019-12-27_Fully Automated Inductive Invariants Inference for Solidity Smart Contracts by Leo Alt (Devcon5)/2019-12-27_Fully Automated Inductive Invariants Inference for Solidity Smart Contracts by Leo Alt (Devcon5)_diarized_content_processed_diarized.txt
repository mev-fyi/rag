00:00:13.610 - 00:01:18.098, Speaker A: Smart contracts and how inductive invariants help prove assertions that should be true on the contract level concerning an unbounded number of transactions. So this is all implemented inside a splitter compiler in the module called SMT checker, which runs if you use a pragm experimental checker and simply run the compiler. So the static analysis trying to prove that the assertions you have in your contract are never violated, no matter the number of transactions. So first I'm going to start with the demo screen is kind of small. I'm not sure if you guys can read this, but I have a really tiny contract that sort of emulates a really toy state machine that have a state variable x, a function ant that changes x from zero to one. So x starts with zero in the constructor, g changes one back to zero. So you have the state machine that starts with zero, and then you can go to one and go back to zero and just keep doing this forever.
00:01:18.098 - 00:01:59.220, Speaker A: And then I have this third function called invariant that asserts that x less or equal one. And this function varies public. So whenever you call it, it should be true, otherwise, otherwise it's going to be work, right? So these things in assertions true. So because of the implicit constructor action is initialized at zero, right? So it will start at zero. You might go to one if you call f. You might go back to zero if you call g after calling f. So it is true, right? Yeah.
00:01:59.220 - 00:03:19.094, Speaker A: And this is what the SMt checker is going to try to prove, that that assertion is always true. So if we look at this program as the actual state machine, as a control flow graph, we have the constructor initialized back to zero, and then it goes to this block called this artificial node that I call the interface, which is the idle state of the smart contract, right? Doesn't have an active execution, you have to call it. So it stays in this interface until you call a function from the contract which could be f g or invariant. So f changes might change x goes back to interface g, saying an invariant can go to sync error state if the assertion is false. So what the teacher is going to try to do is statically see if you can have a path from the constructor all the way to the mirror state, and for that you might actually go through this loop a bunch of times, right? It's going to try to see if you can get from the constructor to the error state, no matter the number of transactions you might have to go through. So I'm going to try it. This is the code it's basically the same code, and I'm just going to run compiler on it, and it does not say that it's wrong, therefore it's fault.
00:03:19.094 - 00:04:30.420, Speaker A: Sorry, it does not say it's wrong, therefore it's safe. But compiler also outputs a bunch of weird stuff that still looks ugly, but it's going to look nice eventually. But part of it, what it tells us is this thing here. So what this is telling us, this is a contract invariant, because it's an invariant on the interface node. So what this is telling us that on the interface node it's always true for all values that x can have, that X is less than two, right? And because we're talking about integers, this means it is the same as x less or equal one, which in this case is the same as our assertion here. But if we change the code slightly here. So I added this function age that now it's a new rule in our safe machine that says now if x equals seven, make it 100, and then I change the assertion to x less or equal seven.
00:04:30.420 - 00:05:48.780, Speaker A: Is the assertion correct? Yes, exactly right. This is a weird local state, but considering the global contract state, it's useless, right? But still we try to prove the assertion anyway. And when we do that, the compiler also says safe, and it also gives us a bunch of information, again about things that are true at certain points in the comfort flow graph. And similarly we can check what's going on with the interface node, and it gives us the same invariant again. So before I tried to prove x less or equal one, and it gave me x less or equal one, so it learned that, but now I'm trying to prove x less or equal seven, and it still gives me x less or equal one, even though I'm trying to prove something else. So both these two properties are invariants of the contract, right? So the compiler proved that they are true, but they have to be different somehow. So what is the difference between x less or equal two and x less or equal seven? You know, the answer ever doesn't count.
00:05:48.780 - 00:06:40.006, Speaker A: Seven minus two is five. That's true. So to check the difference, to understand what's fundamentally different in this case, between accelerate, circle two, and circle seven, we need to analyze each of those invariants with respect to each function separately, without considering the rest of the state of the contract. So we analyze each invariant only looking at the function, each function, without caring, as if the other functions don't really exist at all. So if you plug in this invariant before body of f, and then after as a post condition for f. Does the invariant still hold after f? It does, right? Because even if we change it, it still holds. And same here, right? This also holds.
00:06:40.006 - 00:07:16.662, Speaker A: It's less or equal seven. If you change it to one, it still holds. What about G? This invariant still holds, right? So even if it was one which would fit the invariant, if you change it to zero, it still holds. And it's the same here for seven. You use it as precondition even if the changes still hold. But now here's a catch. So here for x less or equal two, for the artificial useless function that I added, if we execute this function with this invariant, is it still true afterwards? Yes, it is.
00:07:16.662 - 00:08:02.534, Speaker A: Right. So here you can see that x less or equal to really makes this function useless, because it's not really going to be changed. But with this invariant, we see that invariant does not hold after the function is locally executed when human invariant itself as a precondition. So what this tells us is basically that x factor equal two is inductive, whereas x factor equal seven is not. And what that means in a higher level is that if you take the invariant and conjoin it with the local behavior of the function alone without caring about the rest, the invariant should still hold after that execution. This is what differentiates an inductive invariant from a normal invariant. An inductive will have to be true after the execution as well.
00:08:02.534 - 00:08:28.160, Speaker A: So it implies itself with the variables being on the next state. So inductive invariance is. Sorry. Actually, if you go back to the previous slide. Yes, public variable. I can change the variable to maybe seven, and then the contract. Sorry.
00:08:28.160 - 00:09:01.862, Speaker A: Yeah, this is the contract. Yes. But even if it's public, you couldn't change it, right? If the variable declared public, you got a public getter, but you can't change it by the getter. You would need. Can you show the code with the seven in it again? So here you're starting at the invariant. X is less than or equal to seven. But how does it learn the two invariant, the actual inductive invariant? Because these two are the only ones that hold, right? That really matter.
00:09:01.862 - 00:09:31.918, Speaker A: But I just don't see two anywhere in the code here. So where does it come up with two? Oh, with the one here, it's less than two because of integers. It's less or equal one or less than two, right? I guess I'm just not understanding. Is it like a heuristic it picks up? Or is it just picking a model? Or how is it d three? Just picking a model that says two is the smallest number I can find that it's true for. Or how does it come up with two specifically? Because that's inductive one. The others are not inductive. Whatever you pick greater than two is not going to be inductive.
00:09:31.918 - 00:09:52.666, Speaker A: I think he's asking the lower level question, which is algorithmically, how do I write a solver? Like this section from this code. No, but in character two. Yeah, but the reason for that is that it looks for inductive invariance. But three would be inductive too, right? Like if you were to say x less than or equal, three would be inductive. Yeah. So why doesn't it pick three? I don't know. You're probably right.
00:09:52.666 - 00:10:05.866, Speaker A: It probably looks for the strongest one. Okay. Yeah, because three would be weaker than two in the sense that X, let's circle two would imply. But there's no algorithm. You wrote that, does that choose. Oh no, I didn't write that. So that comes from spacer.
00:10:05.866 - 00:10:41.990, Speaker A: Yeah. Very good. Any other questions here? Okay, so loop invariance, sorry, inductive invariants, they're used to summarize a relevant piece of code without really caring about the rest of the code. So you're interested in a single piece of code and you want to summarize that and you might have information, or you might not have information about the rest of the program. Right. So you want to summarize that little bit. And this is particularly and actually classically useful for loops.
00:10:41.990 - 00:11:07.200, Speaker A: Right. Because loops are the core of the challenges in program verification. Right. That's the termination part. That's why you don't really know how to solve a nice way. So we try to not, we, like just people in general have tried to summarize loops in a way that you can still go on and prove your program. So now I'm going to show a little loop example.
00:11:07.200 - 00:11:47.930, Speaker A: Is this assertion correct? Yes, it is. Right? Yeah. So they're unsigned integers, so this value is zero. So that's safe. But I'm going to run a compiler anyway and it tells us it's safe and also a bunch more stuff. But if we look for the information that it gives us about the loop pattern, we see this. So this is an invariant on the loop pattern, and this is an inductive invariant for the loop.
00:11:47.930 - 00:12:37.342, Speaker A: And this says that this is actually y and this is x. So this is telling me y less or equal x. And here we see the condition is y less than x. So the difference between these two is that y less or equal x is an inductive invariant on the loop, it still holds after the loop is executed. So y less or equal x is the core property of this loop here, after the loop in the control flow of this program, the condition of the loop has to be false, right? At this point here in the code, this has to be false, otherwise it would still be in the loop. Correct. So we have that this is also true at that point y greater or equal x, which is a negation of this condition here.
00:12:37.342 - 00:14:14.490, Speaker A: So if we have these two things together, we can imply that y equals x, right? So deriving an inductive invariant for the loop right away enables us to prove a property that heavily uses the computation of the loop. And on that matter, inductive invariance can also be used to prove recursive programs where you can plug the inductive invariant as the inductive hypothesis of the recursive function. But then how exactly do the inductive invariants help us prove contracts help us prove contract invariance? So invariants that hold on the contract level state variables so invariants that are true before and after the execution of any public function. And here, when I say invariant, I actually mean contract invariants in this sense before and after each function, and not the classical invariant definition that it has to be true at ever for encounter. So, as I showed at the beginning, you can model this contract as this control flow here containing a loop, right? Where you go to the interface after the constructor, and you always go back to the interface after the execution of a public function. And here, the really nice thing about this way of modeling it, or this way of seeing it, is that we can model each of these transitions from these nodes to horn clauses. Horn clauses are forcerologic formulas that have a very particular shape.
00:14:14.490 - 00:15:20.050, Speaker A: This one, it's an implication where the had or the implied part of the implication is then here going to be the predicate of the block we're going to where the parameters here are the state variables, right? So here x is going to be the parameter for all my predicates here. And the predicate is true if that the predicate is true for a certain value, if that block is reachable for that value for x. The rest of the horn plots here on the left side of the implication, we have constraints. And here I get constraints from the execution of the constructor and the predicate of the block I'm coming from also on the variables that the value that entered that block. Yeah. So if there's only one predicate on the left side, it's called linear horn clause, and if there's more than one, it's still a horn clause. But it's called nonlinear horn clause and it's a lot harder to solve.
00:15:20.050 - 00:16:00.046, Speaker A: And this is just an example of a bunch of other rules that we generate from encoding this contour flow graph into horn clauses. Not all of them are here. This is just to show some of them for the lack of time. I'm not going to go by each of them. We can talk later. Okay, so as I mentioned before, the problem that we're trying to solve is can we get funding constructor to the air state? And in the first example that I showed, the air state was unreachable. And the way to find out is that all these green nodes form a fixed point where every transition leads to a node that is already in that set.
00:16:00.046 - 00:16:42.222, Speaker A: So you never get out of that set. And you finally see that error state is not reachable at all. And this is all possible because of this really nice encoding that we can do directly from the control flow graph to the foreign clauses, which looks very similar. And this is only possible because of these two results. So we go all the way from poor logic to exponential positive lead fixed point logic, which is actually what we're doing. But there is a connection between this logic and constraint mark classes, which gives us this really nice encoding. But what if now I change my first example from G, changing y from one to zero to two.
00:16:42.222 - 00:17:31.158, Speaker A: Now is the error state still unreachable or is it reachable? It reachable. It's reachable, right? Yeah, so I'm just going to run it quickly. And here it says, yeah, it's reachable. Your assertion is wrong, x can also be two. And what it also tells us, and this is going to look better eventually, but which is really important, is these things here, this is telling us backwards which transactions or which loop iterations led. And this is just encoding of that thing. But this is telling us that we can call invariant and make the error reachable.
00:17:31.158 - 00:18:02.242, Speaker A: But because X is two, there was a transaction that made x two. Before that there was a transaction that made x one. And before that there was transaction that made x zero. And if we look back in the graph, so this would be the first one. So we deploy the contract, right? So x is zero. This is the flow that we go through from constructor to interface. The next one we call function f, which then changes x from one to zero, and we're back at the interface.
00:18:02.242 - 00:18:40.530, Speaker A: The next one, g, changes it to two. Now we finally call function invariant and reach the error where the sequence here is deployment f g and invariant. So this is how the SMT checker does things. And in the back end it uses these tools called foreign solvers, which is similar to similar in a way to SMT solvers. It also uses SMT solvers and horn solvers. Basically they take all these rules that I wrote and a reachability query. So they say can I get to predicate error? And it tells you yes, right now.
00:18:40.530 - 00:19:57.830, Speaker A: And the way these horn solvers do this is you can use predicate abstraction, all these techniques here, but the one we use is actually a tool called Spacer that does SnT based on biomoderl checking with a technique called PDR, meaning property direct reachability. What it does is from the error state it tries to does a backward reachability check, trying to get all the way to the constructor, which is the only fact, it's the only predicate that is not actually implied by any other predicate. And it does that by generating a bunch of quantifier free SMT queries that invoke an SMT solver and use interpolation as a method for abstraction to find predecessors in the state doing the backward reachability and generate new lemmas and invariants. So this is implemented in this litter compiler in the module called SMC checker. By now there's a lot of support to the language. There's a few things missing, but it can already verify a lot of things. And this module, this part of it, the horn based algorithms can already find bugs or proven variants for multitransaction properties.
00:19:57.830 - 00:20:57.034, Speaker A: So multitransaction safety properties, but there's still things missing. So what's next? Function calls are really important, and we want to do that by creating what we call function summaries. So you create those function summaries and then you can assert that that summary is true for a certain set of variables. And this can also be nice to show that there's no changes in the state of the color contract. So this is of course related to reentrancy, synthesis of external functions that you don't have access to the code might also be nice when generating kind of examples. This all would lead to the possibility of verifying really complex contracts and setups when you have multi contract, multi transaction properties that might be really hard to find otherwise and maybe eventually model the entire state of the blockchain. Another thing is showing nicer looking counter temples in invariants.
00:20:57.034 - 00:21:45.770, Speaker A: So I showed all the output from the compiler. So that's of course I had to change something internally to output all that stuff that's not supposed to show all that that way. So it has to be nicer, better usability. In terms of right now the only way to use SMT checker is actually compiling the compiler yourself with C three or CVC four linked to it. But we are working on having it enabled via Salt JS and the JavaScript version, which I guess is what most people use via the JavaScript frameworks. And we are also working with other people from consensual time replication and other projects on creating a very simple formal specification language. And we welcome anyone and everyone to be part of creating this language.
00:21:45.770 - 00:22:15.362, Speaker A: We are discussing things in this repo, so feel free to come in and give ideas. So finally, to conclude my talk, SaSMC solvers are very powerful and very fast. At least we try to sell them that way. Eventually they'll stop be that fast because we try too hard. The technique we use here is PGR. It's an unbounded model checking technique to solve the horn. Plausible that model our control flow graph.
00:22:15.362 - 00:22:41.822, Speaker A: And the goal we have here is to prove that safety properties are sound, even when you consider an unbounded number of transactions. This is all in the solidity compiler. You get it for free simply by using the experimental sync checker. But you need to have assertions. So it's a property directed reachability, as I mentioned before. So it needs to have a property to verify. It's not going to tell you random things just out of the code itself.
00:22:41.822 - 00:24:03.210, Speaker A: You need to have status of properties in the program. And finally, the contract conducted invariant that we generate and with output from the compiler can also help verification of pipe code afterwards, which sometimes. Thank you everyone have time for questions? Yeah, okay, only the work, or also requires would be. The requires are used as assumptions. Okay, so right now this only works at the level of a single contract, and you're working as a multi contract interaction. Yeah, exactly. How about you also to put assertions in for that? Well, if you have assertions in the first contract and you're calling a second contract, the difference is that the second contract might do things you're not really don't really know what it's doing, or sometimes you do and there might be reentrancy things that changes the state of the first contract and then would affect the property that you want to prove afterwards.
00:24:03.210 - 00:24:22.540, Speaker A: So yeah, this is how it can change, but by now it's mostly implementation effort, just putting it into code. Thanks everyone.
