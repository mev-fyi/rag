00:00:12.890 - 00:00:55.802, Speaker A: My name is Liraz, siri, and this is Drosh. I know your name. And we've been working on account abstraction in various forms for a few years now. And Yoavais, who is not here, is from the Ethereum Foundation and he has been our colleague. And, yeah, we're working on this in collaboration with Nethermind. And originally we were working as the opengsn team on meta transactions and all of it kind of merged into account abstraction, ERC 4337 standard. But we're going to talk about how account abstraction is generally useful regardless of the implementation.
00:00:55.802 - 00:01:50.830, Speaker A: So let's talk a little bit about accounts in Ethereum. So right now, the default account, well, what you get is an externally owned account and it is a one size fits all EC DSA key. And the other option you have, if you want to have your own smart contract that would be controlled by code, but you would still need an EOA to interact with it, probably your current wallet is an externally owned address. There are some limitations with that. The first one is maybe some of us have gotten used to it by now, but key management can be hard. And there's a little bit of a paradox with key management intrinsically because there's a secret that you're on one hand, trying really hard not to lose, because if you lose it, you can't do anything with your account anymore. And when you don't want to lose something, what do you do? Well, you create many copies of it and you make sure the copies don't get lost.
00:01:50.830 - 00:02:36.480, Speaker A: But on the other hand, you also don't want the key to be stolen. And we don't want something to be stolen. What do you do? You try to hide it from adversaries, make it really hard to access, maybe minimize how many copies there are to be stolen in the first place. And the engineering strategies when you just have this one key that you're trying both to prevent from being stolen and from being lost, they're kind of mutually exclusive or they pull in different directions. So key management is hard even if you know what you're doing. The other big limitation of EOAS is just access control. Whether you're just playing a blockchain game or you're a multi billion dollar corporation, if you're using an EOA, it's like the same access control policy.
00:02:36.480 - 00:03:07.270, Speaker A: So that's very limiting. You don't have granularity, you wouldn't have multi SIG support. There's no ability to implement roles. You can't have spending policies. It's just one size fits all mechanism based on this access to a secret key. The other big limitation of EOAS is gas payment. So you're paying gas directly from the EOA and it has to be an ETH, the native token.
00:03:07.270 - 00:03:58.730, Speaker A: Now, potentially there are many other ways that you might want to be paying gas. If you're a fan of dog coins, maybe you want to pay gas in that you don't want to hold ETH. And the other big limitation is that, well, if you do have to maintain an ETH balance in every account, it's hard to split up your activity between a lot of accounts because then you have to top off all of the accounts. And the ETH that you top off, it has to come from somewhere that's probably attached to your identity. I mean, you may be KYC at exchanges and identity is known to at least some players and then it's not too hard to track. And even if we split up activity, oh, this is all coming from one source, so that's a privacy problem. The other big limitation of EOAS is just in terms of efficiency.
00:03:58.730 - 00:05:01.578, Speaker A: Many times what you actually want to do, it spans more than one transaction. So let's say you want to approve and then you want to transfer. Those are two transactions, but really you are thinking them as one operation. With EOAS, you would have to send two separate transactions and that might not work out. It also might be a little bit more expensive because of that, but there's no optimicity built in and if there is a revert on chain, that's pretty expensive. And that happens sometimes, especially with things that are very time sensitive. So what is the alternative? What is account abstraction? Well, basically what we're saying is EOAS are the one size fits all past and we want to move beyond them to a world where we can really manage the logic that controls our account.
00:05:01.578 - 00:05:54.906, Speaker A: And the logic can be pretty arbitrary and then that opens up a lot of possibilities and that is the future of how accounts are going to work. So what are the use cases for this? The one that's been talked about since the beginning is social recovery. Let's say something bad happens to that secret that you're trying to both prevent from being lost and from being stolen. Well, maybe you have some friends that you plugged into your account and three out of five of them can help you restore your wallet and you can do even fancier things. Let's say your friends suck and they're trying to steal your money. Well, you could have a delay mechanism built in. So if your friends suddenly try to recover your wallet when you don't need a recovery, you as the account owner would see that in advance and the operation wouldn't happen immediately.
00:05:54.906 - 00:06:50.606, Speaker A: So you would have time, let's say maybe a week to respond to that. The other really interesting use case is a dead man switch. Nobody lives forever, unfortunately. And then what happens if you need to pass on your crypto but you're not around to help do that? So with the dead man switch, you could have a mechanism like, okay, if you haven't accessed your account from your main key for the last year, then another key that your family members have access to, it would become active. So usually you're in control, full control of your account. But then a year later you haven't been active, something wrong happened. Your account automatically passes to multi SIG controlled by your family.
00:06:50.788 - 00:07:16.358, Speaker B: Just one thing I want to explain. These are all features that account obstruction can give. But it's not that everything is come fully baked into account abstraction, opens the door for wallet creators to add all those features. None of those features are something that will be on day one, maybe a limited set. These are options that are open to do more.
00:07:16.524 - 00:07:54.930, Speaker A: Oh, now we can both talk to you and we can talk over each other if we need to. That's a good point. I was talking to you about that when you were preparing for the talk. That would be nice. So that's a really good point. This talk is intended to inspire, hey, we can do these things now, but we have this infrastructure built in. But this all depends on the code that's running your smart wallet account and that's up to wall developers, that's up to anyone that wants to get involved.
00:07:54.930 - 00:09:05.322, Speaker A: And most likely there are many use cases that are interesting that will not be covered by this talk. So use the sky's the limit in terms of imagination. But we would like to talk about some of the use cases that we've been thinking about. So one of the cool things that happened during ETH Bogota is there was a project that implemented an idea that we've been thinking would be pretty cool is well there's this signing mechanism in most mobile phones. The problem is the signing mechanism doesn't support ECDSA curves, so it's using some other mechanism. But because account abstraction doesn't lock in ECDSA as the only way to sign, what you can do is you can have per device keys that essentially get your phone and you link your phone to your account. Now your phone can authorize operations on your account and a team actually implemented that in the recent hackathon, which we thought was pretty cool.
00:09:05.322 - 00:09:59.434, Speaker A: Multisig is a very obvious use case. So now you would be able to just get that out of the box. Another one is BLS aggregation, which requires a little bit of explanation. BLS is a mechanism to aggregate signatures and that's cool because it reduces your gas costs and because we have the ability to implement any signature verification mechanism in the account, then now we can have more efficient signature validation and save some costs. The other big one is eventually we know that the signature mechanisms that we're using are going to be broken. It's only a matter of time. Quantum computing is making significant progress, no longer theoretical, the qubits are getting up there.
00:09:59.434 - 00:11:11.538, Speaker A: Eventually we will all have to stop using ECDSA, but there are alternatives and hopefully by the time this becomes a pressing problem, we will just be able to use any quantum resistant signature mechanism that we want. That is maybe like gas efficient and secure and you can swap that so you have a lot of flexibility once you abstract away how you do signatures. And it's not hard coded. So other interesting use cases are spending limits. I mean, if you using your wallet for small day to day things, maybe you're paying for coffee, for a meal, or for something that is not usually life changing, then it makes sense for that to be something that you can do very easily. That shouldn't be too hard. But then if you're making a very big investment, then you might want to add like a more secure way of doing that.
00:11:11.538 - 00:12:29.770, Speaker A: So you go get your ledger really depending on what is the spending limit that you're comfortable with for different levels of security. And you would be able to implement that because again, you can have arbitrary logic inside a contract that is controlling your account. The other cool thing that you can do is, well, you can have different roles and you can delegate specific actions to those roles. So if the account is a corporate account, you can give payroll authorization to people who are in charge of that and you can specify the spending limits. Another example would be if you have a legal department or you just want to delegate voting power for certain tokens, you could do that in a way that still limits your exposure just to that. So they would be able to vote with the tokens, perform governance actions, but not like transfer the tokens, for example. And usually in companies, I mean, this is something that's very common in corporate bank accounts.
00:12:29.770 - 00:13:47.942, Speaker A: You give different roles in the company, different powers. So the CFO might be able to transfer a larger sum, but there's still a 24 hours delay. And then maybe other C level executives could veto that if maybe the CFO's key was hacked or their computer was hacked, or the CFO is untrustworthy for some reason. But another example would be, well, you want to give an auditor the power to monitor payments and then the auditor has responsibility. They have the responsibility to reach out to authorized parties and then verify that what they're seeing happening on chain is what is supposed to happen. So this way you can tap maybe like a third party accounting firm, maybe the one you already work with, say, hey, we owe it to our shareholders that our treasury management doesn't get compromised. And how about like, we plug you into our treasury in a way where, yeah, you can't, you can't perform.
00:13:47.942 - 00:14:20.910, Speaker A: We don't have to rely on maybe your computer security or your staff. We don't want exposure to them in terms of being able to transfer funds. But we do want to give you the responsibility of whatever you see happening. Talk to the people who are in charge. Make sure that it is an authorized action. And within this delay limit, if it isn't, just veto it just like cancel the transaction. So you could give them the power to cancel but not initiate transactions.
00:14:20.910 - 00:15:02.582, Speaker A: And I think the one that's going to be very useful very soon is session keys. So in fact, I think this is something Argant recently implemented for their StarkNet wallet. So the idea is, well, you want to play some blockchain game and you don't want to have to click approve every time. Like a message needs to be signed. That would really distract from the gaming experience. But you also don't want to give this game full power over your wallet. That would be crazy.
00:15:02.582 - 00:16:18.950, Speaker A: What if there's a security bug in the game? So ideally, you want to create a session key and the session key has the ability to do whatever is needed but limited to the gaming contract, nothing else. And then the worst thing that can happen is, I don't know, maybe your game stored, your NFT items are stolen if the game gets hacked, but everything else is safe. And you could just store this key inside your browser. So as soon as you authorize this, as soon as you generated the session key, from that point onwards, you don't have to be in the loop in terms of authorizing transactions and it just becomes transparent. So that's a really nice one with session keys. Also, you can mix what we were talking about before. So you could have a session key not only has maybe limited access to a specific contract, but maybe you have multiple devices and you want very easy things to be not secure, things that are not very risky to be very easy from your computer.
00:16:18.950 - 00:17:24.902, Speaker A: So maybe if you just want to sign into an event or, or, you know, something that doesn't have world changing implications if your computer gets hacked. So you authorize your browser and you would still have control over your account in case something goes wrong. Browsers are not the most secure platforms, but you could just limit how much power the browser has over your assets. So there's also a big UX issue with Gas, where the traditional web two world where most of our users will be coming from. Gas is not really a concept. So if you have a server, you're not really thinking about who's paying to run the server and how do I share in the costs. It just somehow works behind the scenes and users who are new to this space will not be really familiar with the concept of Gas and it's also a hassle even for people who are familiar.
00:17:24.902 - 00:18:53.400, Speaker A: So with abstract accounts, you can have a lot more flexibility in how you handle this. So for example, if you're a game, especially if you're running on a cheap layer two, you could decide, hey, it's worth just subsidizing the transactions. As part of my onboarding process, it's very common to have to budget some amount in order to acquire users. So if it's not prohibitively expensive, maybe you want to do that and then later that's worth your while. Another very obvious one is just being able to pay gas in any ERC, 20 token, anything that has value. So if I pay you in USDC, there's no reason that I would also need to send ETH into your account for you to move that USDC and maybe pay your bills with it. It's nice if you have an account, whatever you have of value there, someone sends you a PayPal transfer, they don't have to send you some other PayPal tokens so you can move your US dollars in PayPal to somewhere else.
00:18:53.400 - 00:20:21.170, Speaker A: So payment becomes a lot easier. But also maybe you're participating in some governance, and the governance of that project doesn't want you to have to think whether it's worth your while to pay the gas for the interaction or not, so they just decide to subsidize that. Or maybe you have some allotment and if you go beyond the allotment, you have to pay in that project's tokens, the nice thing about being able to interact with the blockchain without needing ETH is it also has some privacy. So because if you go through the usual KYC process, someone knows who you are. And there are companies that are dedicated to linking all the information together so you don't have privacy. But that wouldn't be an issue if you can just receive payment in any token and also pay for the gas in any token. Because let's say I'm a contractor and I work online for you, I'm pseudonymous, I do the work, I give you an address, you pay me, and I would be able to pay my bills with that or buy something online or whatever, and I wouldn't need to also acquire ETH.
00:20:21.170 - 00:21:30.070, Speaker A: And I could also separate let's say I'm working with different customers, I could give each of them a separate address and the customers wouldn't necessarily need to they don't need to peek into my bank account or my equivalent of bank account and see how much I'm making and what is the balance there. We're doing that, and maybe some of us have gotten used to it, but it's really weird where you're working for someone and you give them the number of your bank account and they can see exactly what's going on there. That's not very private. Once we have gas abstraction as a built in feature, then we don't really have to worry about that anymore because we could just easily generate new addresses for everyone that we interact with if we wanted to. There's also an interesting use case for enabling cross chain operations. There are many ways to do that. And yeah, that's just something that becomes a lot easier once you have this functionality built into the protocol.
00:21:30.070 - 00:22:41.070, Speaker A: There's also some typings that you get from just being able to batch different transactions together, also from being able to guarantee that the transactions are going to execute with automicity. So for some things, it's useful if everything happens together. And if everything doesn't happen together, then you don't want it to happen because it wouldn't make sense for the transactions to execute separately. And whether this happens, like in a gaming environment or there are some financial scenarios, I mean, imagine the simplest one would be you have to approve, you have to give some authorization to a contract to perform an action on your behalf. And then you want to give them another transaction to actually perform the transaction. And those both need to execute together. Otherwise you just wasted gas.
00:22:41.070 - 00:24:11.040, Speaker A: And there's a sort of general use case that's interesting where you can actually implement these time delay flows. So, for example, let's say I want to be selling my ETH when it hits 5000, but I don't know when that's going to happen. I don't want to sit in front of my computer. So it would be possible for me to just pre create the transaction, but make it conditional on certain things happening. Like, okay, only if the price of ETH is 5000, or only after this time, or whatever the condition is, my wallet would agree to execute and pay for the gas for that transaction and also maybe a transaction fee. And you would put that into a registry and the registry of future time delayed or event driven transactions and searchers, they would be able to monitor this registry and see, oh, these are transactions that their conditions have just been met, so they can compete on executing it for you. And that opens up a whole range of interesting use cases, because now it doesn't have to be you that pulls the trigger at the exact moment the conditions are met.
00:24:11.040 - 00:25:21.118, Speaker A: If the conditions are met, the transaction will be executed for you by searchers. And it could be time delayed, it could be based on essentially whatever the conditions make sense. Maybe another example would be there's an NFT series and you have to be or an event that you have to subscribe to in a certain time window. Okay, so a little bit about ERC, four, three, seven, which is so this is the standard that we have been working on and Paul here is the guy who implemented the contracts. So, yeah, please, if there are any technical mistakes, correct me. Okay, so this is the first step towards protocol level account abstraction. The nice thing about our approach is that it doesn't require any change to the rules of consensus.
00:25:21.118 - 00:26:20.226, Speaker A: So we can kind of experiment for free and we don't have to solve governance in advance. The way we're doing it is, okay, we essentially create mempool, a new type of mempool for anyone that wants to participate in this. And you don't need more than a single network. This mempool, essentially it accepts something that is essentially a transaction. We're calling it user operation. But a user operation is equivalent to a transaction, but it's a transaction that works with these account contracts. So what that does is it makes contract wallets a first class citizen and it totally does away with the need for having an EOA.
00:26:20.226 - 00:27:42.998, Speaker A: You don't need an EOA to control this account. The way that works, maybe a little bit about how that works. It's kind of similar to how flashbots mev private mem pools. Like the principle behind it is you can have a mempool where bundlers they are provided an incentive to submit your transaction. And essentially we took that idea, or originally this was Vitalik's idea and we added the gas subtraction part to it to make it a more general purpose. And then the bundlers, their job is to just take these user operations and eventually they bundle them together and they submit them when they're creating bundles that that go to the actual blocks. Okay, the other advantage of doing things this way is that we're separating validation from execution.
00:27:42.998 - 00:29:47.030, Speaker A: So you can have, if I'm a bundler and I am paying for the gas of your transaction, there's some risk involved for me because what happens if you don't pay me? What happens if I execute your transaction on chain and turns out that it ends up well, at the very least you expect to be repaid in gas because otherwise why would you participate in the scheme. So to make it very safe for bundlers to participate, what we've done is we've provided a contract level guarantee that you're always going to be paid back regardless of what happens with your transaction when it's executed on chain. So we've separated validation from execution and what the bundle needs to do when they accept the transaction. They're just verifying that they're doing this off chain initially just okay, if I accept your transaction, I'm calling this fusion function and am I going to be paid back for the gas? That's all they're verifying. So it's pretty cheap for them to do that and later totally separately when the transaction is submitted it gets executed. But by then you don't really care as a bundler, even if it reverts, it's your problem just like with a normal transaction because you're still going to get paid. And without this, it wouldn't really be possible to create a permissionless pool of bundlers that are participating in this protocol because the bundlers would have to trust that they're not going to get cheated.
00:29:51.310 - 00:30:12.726, Speaker B: We use the term bundler which are node validators just like any node validator that also support account obstruction. One of them is enough to run a network. The more they are, the notebook is more resilient to a censorship and other things. But a bundler eventually and eventually all validators hopefully will be also bundlers.
00:30:12.778 - 00:31:20.920, Speaker A: Right now we have so exactly, you don't need a consensus change, you don't need like 51% of validators participating in this scheme because ultimately you're generating just regular legal blocks and we have Nethermind as an implementation that is supporting this. The more clients support this, the faster your transactions are going to get executed. Okay. With ERC 4337 then, once we have this scheme, we can also use it to make roll ups cheaper because you can batch transaction, you can aggregate signatures. That's another advantage and like I said, doesn't require any protocol changes. So on any you can, we can start experimenting with this. Is there anything you want to add?
00:31:23.370 - 00:31:57.314, Speaker B: Okay, technically a bundler can run as a separate entity. It is much, much better for it to be a node, to be more resilient. So the way to add it right now, the way we currently adding it early because it's still on test, is adding it as a separate server. The wallets don't care its implementation, in order to be highly scalable and to be able to batch more, it has to be a node in the network. Nethermind already have a node that can run on Nethermind and there's a work to add it also with a guest code.
00:31:57.512 - 00:33:41.650, Speaker A: So what's next? Well, yes, we can start experimenting and have account abstraction in any EVM compatible chain without consensus changes. But the goal is to do away with EOAS eventually. We don't want to eat EOAS and we know we're going to have to move away from them eventually at some point, and there are various ways of thinking about this. So we want to have account abstraction as a basic feature of the protocol, but we want to do it in a way that doesn't enshrine any particular wallet or gives an unfair advantage to any particular wallet. And because the EOAS are effect and they're very common, and they probably will be until we move away from them and will take a few years, we need a way to convert EOAS seamlessly to smart contracts. So there will be some default implementation where yes, everything in the future is an abstract account, including EOAS. But if you haven't upgraded your EOA, if you haven't inserted code into your EOA, if you haven't activated it in some way, then it just behind the scenes continues behaving like an EOA, but it has the functionality allowing you to upgrade it.
00:33:41.650 - 00:34:24.946, Speaker A: Of course, this would require a consensus change and there are various ways it can be achieved. We're discussing one way would be there's create a new transaction type and then you can set the code for your EOA. This is now the code that's running your EOA. Or there's also been a suggestion, EIP 30 74, maybe that in combination with another EIP, we could also set default proxy contract for all addresses. DOL you want to add anything?
00:34:25.128 - 00:35:03.574, Speaker B: Yeah, by default there's basically two options. One of them to let a user decide the exact point of time where he wants to upgrade its EOA into a contract wallet, either using a transaction type or new opcode on such. The other way is to decide that at one point of time all EOAS start using some default implementation we've deployed and tested thoroughly before, which behaves exactly like an EOA. So all user will not notice a difference, except that from now they have a way to modify to replace the actual implementation.
00:35:03.702 - 00:35:10.942, Speaker A: So they have a smart contract that just behaves exactly like an EOA until they decide otherwise. Right?
00:35:11.076 - 00:35:27.878, Speaker B: Yes. The basic contract doesn't offer any of the advanced features we described earlier, except the one feature which is replace implementation. The user can replace implementation once it is replaced. The sky is the limit, which are.
00:35:27.884 - 00:35:30.306, Speaker A: The use cases that we've use cases.
00:35:30.338 - 00:35:40.000, Speaker B: And all the use cases that other people will try to find. Okay, I think that is if anyone has question Paul.
00:35:40.520 - 00:35:43.188, Speaker A: Now we're going to talk about well, how do you join this?
00:35:43.274 - 00:35:43.524, Speaker B: Okay.
00:35:43.562 - 00:36:57.100, Speaker A: Yeah. So how do you join this count abstraction revolution? You can start experimenting with ERC, four, three, seven right away. And at ETH bocata, we had eight wonderful submissions and this is something that's already working, so you don't have to wait. You can add useful features like the one we discussed batching or key recovery or any of the things that we've been talking about. You could build features that were totally not possible with UAS that we haven't thought about. And if you do, if you're building anything cool, then you should definitely apply for an EF grant because we want to see this used and adopted and we want to see the experimentation and want to update this presentation with more interesting use cases. So definitely apply for an EF grant if you have a cool idea that builds on ERC, on the CRC.
00:36:57.100 - 00:38:04.528, Speaker A: The other thing is, if you are building a DAP, you have to think about a future where contract wallets are first class citizens. I mean, contract wallets are already pretty common, especially for teams. Multi sigs are an example. But still, many DApps assume that they're going to be interacting with an EOA and that is just an obstacle for us to move forward. It means your DAP already can't interact with things like Gnosis safe wallet if you're assuming you're making assumptions such as how signatures are validated. So there are easy ways to make your DAP compatible both with smart contracts right away and account abstract accounts in the future. And that's ERC 1271, which just checks if the caller has code.
00:38:04.528 - 00:39:10.580, Speaker A: And then there's a mechanism where it can just invoke a function instead of assuming that they can rely on this ECDSA key. The other one is if you can benefit from batching in your user interface, and many DApps, especially games can, then you should check if you're connected to a contract wallet that supports it and that will create a better experience for your users. It will save gas costs. The other thing is with how gas is paid. So if you have a DAP, you should think about different types of gas payment. Models. An easy example is if you have a token, then it makes sense perhaps that your users should be able to pay for the transactions in your token when you're using your DAP.
00:39:10.580 - 00:40:36.032, Speaker A: And if you don't have a token or you want to subsidize your users, that's easily accomplished with account abstraction. You set up a contract that authorizes to reimburse your users for whatever criteria you feel comfortable with. Maybe the onboarding process, maybe they have to perform some action, but it's something that's possible now. And a lot of the improvements that we're going to get for DAP usability is going to also require some wallet support. So wallets are an important part of usability for DApps. And as a DAP developer, you have some influence by collaborating with wallet dev, saying, okay, this is something that would be beneficial for my use case. And you can have a bit of an influence by just saying, okay, this is this is useful for me.
00:40:36.032 - 00:41:07.332, Speaker A: I need this feature in the wallet, for example, supporting count abstraction. So other than talking with us, we're happy to help anyone that's implementing different use cases. We do have an SDK up later. Jov will share on his Twitter the links. But there's an SDK. There's an SDK.
00:41:07.396 - 00:41:08.504, Speaker B: You can come up to us and.
00:41:08.542 - 00:41:28.012, Speaker A: We'Ll give you yeah, or we'll just give you but I think I think I just open this right now and show where this is pointing to. Wait, this is very small. Why is this so yeah, so we have our SDK. It's on GitHub ETH infinitism account abstraction.
00:41:28.156 - 00:41:29.932, Speaker B: It's not the SDK, it's the contract.
00:41:30.076 - 00:41:31.628, Speaker A: Oh. Where's the SDK?
00:41:31.804 - 00:41:33.540, Speaker B: Ethan finnetism bundle.
00:41:34.280 - 00:41:47.556, Speaker A: Okay. Oh, the link is broken then. All right, we'll fix that. Yeah. Okay. Oh, this is the SDK.
00:41:47.748 - 00:41:51.604, Speaker B: This is the reference implementation of a bundler. Simple bundler. And the SDK.
00:41:51.732 - 00:42:07.630, Speaker A: Oh, cool. Okay. So that's the SDK. We will fix the link later. You can also read up on the ERC and oh, maybe that's the right link. No.
00:42:09.360 - 00:42:10.432, Speaker B: That'S the itself.
00:42:10.486 - 00:42:44.830, Speaker A: Yeah, that's the, ERC itself. So you can read the ERC. It's very detailed, but you can get very precise understanding of how it works. There's also a discussion on the Ethereum Magicians forum. And of course, it's nice to be able to talk with people. So we have a discord server, and you're very welcome to join and ask questions. And even after this event, like, if there's something that you don't get to ask us in person.
00:42:44.830 - 00:42:49.230, Speaker A: And yeah, maybe now we will just take some questions.
00:42:49.840 - 00:43:13.280, Speaker B: Yes. Over there. Okay. In terms of development roadmap, what we've developed are the interfaces and the core contract that performs its magic. We call it entry point. It was audited, but then was extensively modified to support L two S. That is not yet audited.
00:43:13.280 - 00:43:44.584, Speaker B: We still have some work on it. The API probably won't change, so a wallet will be able to work. So it's not deployed on main net only on testnet currently. But you can create and start experimenting with wallets. On top of that, the interface of a wallet, the change a wallet needs to be quite minimal. I can go through it adding a single method or two. Yeah, we have a sample yeah, we have a sample that uses that adds account abstraction support to Gnosisafe.
00:43:44.584 - 00:44:39.528, Speaker B: You add a module and you basically make okay, a single owner gnosisafe an account abstracted compatible. So yes, you can create and there are some work on creating wallets today in term of applications. Yes, it's chicken and egg application needs a wallet in order to work it's for basically a hackathon. An application can work without a wallet, but it's not something that your user want to sign blindly, a hash, if you're good with that. It's also possible to with an application can work with account abstraction even today. The way gas abstraction works is that when you submit a user op, the contract itself validates itself, the signature and its nons in order to accept the request. But there's also a pointer to what we call a paymaster.
00:44:39.528 - 00:45:33.968, Speaker B: A paymaster is a contract that before submitting the transaction has a chance to decide whether it agrees to pay or not. If it says okay, that is, it doesn't revert, it will use its own balance, its own stake and everything to pay for this transaction. Now, what this paymaster does on chain depends on the paymaster. So the most obvious example of a paymaster is that the validation will be I will check that this user has a balance of enough die and has approval for me to use this die and I will grab enough die to cover this transaction and at the end I will refund it with excess. So eventually the user pays with tokens for the transaction. It's the most obvious use case of a paymaster. But there are other use cases if you want a voting Dapper and you don't want the user to pay anything.
00:45:33.968 - 00:45:49.190, Speaker B: Okay, so the check is that the user is eligible to vote. If a user is eligible to vote and didn't vote yet, I agree to pay. It's another example of a paymaster. Other examples are still open. You can write whatever you like.
00:45:50.120 - 00:46:47.108, Speaker A: Just to contrast right now, if you're using Gnosisafe, then someone on your team has to pay the ETH from their account. Even if the Gnosisafe has plenty of ETH, someone still needs to pay from their own account just to have that transaction finalized. So with account abstraction that wouldn't be necessary. Your account would be able to pay for yourself. And this doesn't require a paymaster, but let's say you're safe. Or going back to the Agnosisafe example, if Agnosisafe doesn't hold any ETH or doesn't hold sufficient ETH or you don't want to have to care about the balance and continually, like, exchanging and topping it off, then whatever you have a balance of assuming it's enough to pay for the gas. You would essentially include in your transaction a reference to something we're calling a token paymaster.
00:46:47.108 - 00:47:52.910, Speaker A: And token paymaster can be a completely autonomous contract on chain that it accepts tokens. It would pay for the transaction in ETH and then it would settle in some way. So an older reference implementation recreated was just uniswap using uniswap in that single transaction, which was kind of expensive. There are cheaper ways of doing it, but just it's very simple. In one single atomic transaction it gets paid, it gets an allowance in whatever token you have, it pays for the gas, it charges the transaction fee and then it gives you back the remaining tokens. So with account abstraction, if you want to use that, for example, then you would just include oh, the entity that is paying for the gas is a token paymaster. But there is a way for the token paymaster to receive a commitment from your account to pay it back.
00:47:52.910 - 00:47:57.116, Speaker A: So it's not just subsidizing the transaction. That's also possible.
00:47:57.298 - 00:48:32.292, Speaker B: It makes it possible. Right now you have to split it because of different concern. If you need some corporate level security using Safe and if you want a game, you will use MetaMask. And if you have private, you use Treasure. Now, if you want them all in the single address, yes, you will be able to do it with account abstraction. Probably you still might have multiple abstracted accounts for different purposes, but for different reason. If the reason to have multiple addresses is only security, then yes, you will be able to use abstracted account to find something that can cover all bases.
00:48:32.356 - 00:48:38.008, Speaker A: Yeah, because you can just limit your risk exposure to each device depending on how much you trust it.
00:48:38.174 - 00:49:14.632, Speaker B: Again, I'm not saying that there will be one wallet that will give you all these use cases. You'll find a wallet that give you all the use case you need and use that and you always can switch. I think the first use case of a signature is chain signature. Just think of it. You start using MetaMask and after a few years you collected a lot of NFDS and a lot of money. But you can't change the security model. Your browser holds your private key, so you have no idea if anyone hacked into your computer and grabbed it through a copy of your computer without changing the address.
00:49:14.632 - 00:49:31.512, Speaker B: You can't change the security with account obstruction, with single operation of change owner. Now the treasures are on the same account, even if with the basic simple account I just changed the owner and now I am really secured because the previous private key is no longer relevant.
00:49:31.576 - 00:50:11.540, Speaker A: Yeah, even before you get into the really fancy stuff that you can do with account abstraction, the basics are actually pretty useful just by themselves because right now if anything goes wrong, then it's really hard to transfer everything from one EOA to another. I mean, you would have to create separate transactions for each asset that you hold. That could be pretty expensive. And if your computer got compromised, you might need to do that in a huge hurry, you know? So it's just not the best situation to be in. Even very simple improvements like this will make a big difference. Bye.
