00:00:13.130 - 00:00:56.414, Speaker A: Been in Ethereum since 2014, worked in C plus plus client in the Solidity compiler, did Dow Stuff, White Hat and the APC and Dow Wars back then. Then I worked on to payments for many years and founded Rotkey. Today I'll be talking about user transactions and how we can start to understand them. Like what are they and how can we decode them in a human readable format. Everybody has used Ethereum in here and we have all faced these two big problems. Like you do not know when you have a transaction, you do not know how to get it. Like there is no built in way to get transaction for an address.
00:00:56.414 - 00:01:28.614, Speaker A: You need to utilize some kind of third party service and that will never be decentralized. Also, once you have these transactions, you really don't know what I mean. There is a complete lack of a universal tool that will decode a transaction to human readable format. There is some third party services, but again, they are centralized and they tend to be protocol specific. What does the transaction look like? Everybody has open nether scan and sees this hex blob. There is no metadata, there is no human readable info. That's what every new user to Ethereum is greeted with.
00:01:28.614 - 00:01:59.266, Speaker A: There is no way to understand what your transaction like three, four years ago has done. There are ways we are no longer in 2014. There are ways to gain insights. So you can see stuff in Ether scan with the graph and other centralized APIs such as Covalent, Morales, et cetera. So we have all used Ether scan. What are the ways to decode the transaction with Etherscan is that it looks like this is a complicated transaction that does swaps over multiple protocols. It's easy to use.
00:01:59.266 - 00:02:36.350, Speaker A: You just type in Etherscan transaction the has and it gives you useful insights and it's totally free. Of course, there are cons with Ether scan that's centralized, it's proprietary and close source. That means that there is no way for me as a developer to see how they do what they do or extend it in any way. They know everything about you. I mean, I know the guys from Adascan, they are good guys, but you never know who in there could be malicious. They can match IPS to your addresses and know who owns what address and where they are located. And it actually does not decode everything.
00:02:36.350 - 00:03:17.270, Speaker A: We have all seen that there are transactions that Ether doesn't have insights for and there are other tools that actually can do this. The graph is a way it's kind of an indexer per protocol. They have subgraphs and they index the chain for a particular protocol and then you can query this index and get any insight you want. The pros is that it's very good for single protocol data. So for example, here we have the Ave v two Ethereum by Masari. This is the subgraph that say the Ave guys can run in their interface and query any information they want for their protocol. But it has many, many disadvantages.
00:03:17.270 - 00:03:47.586, Speaker A: It needs payment per query. This is their vision that everybody should be paying for every query. It's built for single protocol data. So the subgraphs so there is no generic solution. If you have a portfolio tracker or a wallet or something that wants to decode every single transaction, no matter what protocol it is in, subgraphs will not work. You will have to basically query every single subgraph and create a subgraph for everything that is not supported yet. And it does not work with local labs, what I like to call True DAPs.
00:03:47.586 - 00:04:23.060, Speaker A: So basically, when the company that makes the application hosts the code, they can have an API key and pay for the queries. But when it's a local application, there is no way for this to happen. And there are these other centralized APIs like Covalent, Morales and Alchemy. They're easy to use. They have pretty cool APIs which can decode transactions, give you all the transactions, but the same concepts others can apply. Like it's centralized, it knows everything about you, it's proprietary, so you cannot extend it. It's not modular at all.
00:04:23.060 - 00:05:04.766, Speaker A: So, having seen the ways that we can get insights about data, let's see how we can actually get accurate historical data. And let's go to the original scene of Ethereum. Like, this is absolutely bonkers. If any of you has tried to get the history of transactions for your address, you will find out very easily that there is absolutely no built in way to do this for Ethereum. There is no RPC method. This is all due to the way that EVM works and how the clients are built. But it's absolutely crazy that there is no way for you as a user to get all of the transactions for your address.
00:05:04.766 - 00:05:36.594, Speaker A: Someone that comes as a developer outside from web three and comes to Ethereum and sees this, they think that we are just crazy, that this is broken. It's not all gloom and doom, though. There are ways to do this. Ether scan again comes to the rescue. They have many APIs, and if you combine three, I think so this one for transactions, then there is one for ERC 20 transfer and one for NFTs. If you combine all of them, you get a pretty accurate picture of what transactions your address has done. Of course it has drawbacks, right? It doesn't detect all address appearances.
00:05:36.594 - 00:06:07.700, Speaker A: It's rate limited, but you can pay for bigger limits. But rate limiting means that it takes time for your query to actually work. It is centralized, so it can go down. They can cut access to the API, or they can do what I said before, that they can monitor you and map IP to your address. The truly decentralized way to go around this is something by my friend Thomas Jraz. It's called trueblocks. It is really the best and most complete way to get transaction data.
00:06:07.700 - 00:06:29.980, Speaker A: Trueblocks detects all appearances of an address. Really? I have seen demos where TJ basically shows Etherscan and then compares it with Trueblocks. And you can see that for some addresses, trueblocks does indeed detect more appearances than Etherscan. It is decentralized. So it runs on top of your local node. So you do not need to do any other network queries. It's super fast.
00:06:29.980 - 00:07:00.420, Speaker A: It's really like milliseconds or seconds, depending on the amount of addresses that you query for. And it's built to share this index with others. Of course, with everything in software, there is drawbacks. It is hard to set up. So TJ, who's a lone wolf since I met him in Sankhai in 2016, now he has a bit bigger team, but it takes time to build something that's easy to use by others. It does require a local node, so you need to be running an Arigon node, I think. I'm not sure if it works with others.
00:07:00.420 - 00:07:58.530, Speaker A: And of course, you require Trueblocks itself to create the index. So, building on this, I would like to present what I try to call the stack of True Decentralization, which is something that we should be striving for in crypto. So everybody should try to run their own node. So something like a dub node or a Raspberry Pi, with whatever setup you guys want to have, you should run your own client, right? Like for whatever chain you have, run a client for that chain that you want to use. And Trueblocks actually works for all chains, all EVM chains. So you can have an indexer like Trueblocks on top that will index the chain and provide you an answer to the question, how the heck? So what transactions does my address have? And on top of it all, to come and bind it all, you have the aggregating and decoding level. That something like Rotkey, but not like a decoding.
00:07:58.530 - 00:08:42.654, Speaker A: So Rotkey right now is an application. But imagine platform where you can have a generic way to go from transactions to a common readable format for what they do. And it's actually consumable by humans going from how we get data to what actually would go into this decoding platform that my talk is about. So once you have all the data, like either from Ethercan or from Trueblocks, what kind of data is this? If you have tried to play with understanding transaction history of Ethereum, you know that there is two ways to get data. It's either a trace, a transaction trace, or transaction receipts. There are two kinds of traces. One is the gift style trace, and the other is a parity trace.
00:08:42.654 - 00:09:13.546, Speaker A: I'm going to go through them a bit fast for those of you who do not know what they are. So gift style trace is the tracing that comes with a Git client. When a transaction happens, it touches multiple contracts, right? So you make a transaction to a contract and this 1 may make a call to another contract and so on and so forth. And as they do this, they touch the state of these contracts and they make some changes. So this is what the trace of a transaction is. And the Git style trace is the most complete. It's like super detailed.
00:09:13.546 - 00:09:53.046, Speaker A: It has every single step of the execution with the Opcode, the program counter, the storage diff, et cetera. It's super detailed. It's very hard to use because for complicated transactions you have like a huge thing that you don't really know what it does and it can grow extremely huge, like in the gigabytes for really complicated transactions. Then we have the Parity style trace, which comes from the now defunct Parity client. But it is used, I think, Aragon for sure, and Nethermind maybe Besu, I'm not sure. They have three commands. One is a trace that's pretty cool and useful.
00:09:53.046 - 00:10:34.514, Speaker A: It gives you a call stack like this of what did your transaction do, the call trace of the transaction. And this actually does not require an archive node. By the way, the screenshots is from a very nice article by Banteg on traces that came out like two months ago, I think. So Google Bantegon's transaction traces and you can read about it in more detail. And the other thing that you can use to understand how a transaction, what has it done? Is the Parity style trace diff. It gives you a state diff for each account that you touch. It gives you the difference in balance, code, nons and storage.
00:10:34.514 - 00:11:10.738, Speaker A: The cool thing is here, if you have the API, you can play with it a bit and you can have readable names for the storage slots and how did they change. So this is a very useful insight on what did the transaction do. And of course then transaction receipts. We've all seen how a source code of a contract looks like. They have events. These events are actually contained in something that's called the transaction receipt. So let's say for a token transfer, it's, I don't know, like transfer source, destination and value or something, almost everything generates them.
00:11:10.738 - 00:11:40.986, Speaker A: It looks like this, it's all hex. But if you have the abi of the contract, you can decode this into a human readable format. This is how you gather that data. But gathering this data is actually expensive. It takes time and exactly because this is expensive in resources, persistence is key. So any kind of platform that you create and the thing that we have created, the dropkey needs to have data persistence. You can choose various ways.
00:11:40.986 - 00:12:54.930, Speaker A: We've gone with a simple SQLi database for now. But this way when you have gathered all of the data and you know that they are true and will not change, then you can just take it out of the database and reuse it instead of having to re query again true blocks or Ether scan or make a trace. Again, we talked about where you can get data, how to get it, and then I'm going to go to the meat of the presentation, which is the decoders themselves. So we want to get human readable format of the transaction data? Yes, of the transaction data. So we have gotten either receipts or traces and with this amazing inkscape graphic that I made, guys, I'm really proud of myself for this. We can see that you can check for its log, the address and then send it, depending on the address, to either the generic ERC 20 transfer decoder if it's a uniswap swap to the uniswap decoder and so on and so forth, like Ave, et cetera. And all of this will at the end emit a common event format.
00:12:54.930 - 00:13:24.010, Speaker A: What's more, some decoders feed data to other decoders. So the ERC 20 transfers create the ERC 20 transfer event and this gets fed to uniswap, which translates it into swaps. Such a decoder platform is made on modularity. This is Rotkif repo and this is where we have all the decoders. And it's like a huge list. It doesn't have all of them because they don't fit on the screenshots. But the idea is that it's easy to write, easy to use and drag and drop.
00:13:24.010 - 00:14:14.602, Speaker A: So you drop it in there and it's caught by the system and then a new decoder is taking into account whenever we decode a transaction. That's the idea. We're not there yet, we build binaries and this is not as modular as it should be, but the idea is that it should just big drag and drop. This is how the source code looks like. This is, I think, a hop protocol to breed to another chain. So it's hard to read, probably, but the idea is that from the ERC 20 transfer decoder you get the ERC 20 transfer and then you see, oh, it's a spend. The counterparty is the f bit of hop and the asset of f matches and the amount matches.
00:14:14.602 - 00:14:51.254, Speaker A: So then we transform it into the common event format for hop and give it a nice readable explanation which breeds the amount of ETH to either your own address or to some other address in the chain. So the name of the chain via Hope protocol. I talk a lot about the common event format. It's kind of a POC because we are our only consumer right now. It's changing. So this is how it looks in the code. It has like sequence index inside the transaction.
00:14:51.254 - 00:15:40.090, Speaker A: So where did it happen in the transaction timestamp? Location? Location is mostly something that we use in Rotkey because we subtract everything into this format. Not only Ethereum transactions, but your Kraken trades, your Ethereum staking. Everything gets subtracted into this list common denominator format. We have the history event type and history event subtype. So this is what defines the meat of how you define an event the asset and the balance change and then some extra stuff like the location label is along with the counterparty is if I send it from me to someone or if I got from else and some extra data, like if it's a CDP for maker. We have the CDP ID here. Et cetera.
00:15:40.090 - 00:16:17.810, Speaker A: As I said, everything is broken down into this thing. Like a swap is three of these events. So it's amount out, amount in and fee out or it can be two if there is no fee. We are working on this, it's not final, but this is like the idea. This is how a front end can consume and solve this code. This should be read unfortunately because I didn't take a nice quizzes from the bottom to the top. So I claim my budger AirDrop.
00:16:17.810 - 00:17:18.262, Speaker A: So it has two events, the gas fee that's burned and the AirDrop claiming then approval to one inch v two and the gas fee for this and then the swap in one inch for basically immediately dumping the tokens. This is the same thing that you saw in the previous screenshot. Basically these events, each one of them is one line here. So this is how they are consumed in Rotkey itself, which is a portfolio training. So I would like to actually also talk a little bit about the abstraction layer of the vision of rotkey, which is like, if you take this a step further and not just focus on just EVM code, but anything. Like any event you can get into. Like an open source middleware that offers an abstraction layer for everything.
00:17:18.262 - 00:18:07.000, Speaker A: Accounts balances, PNL over multiple protocols and jurisdictions. So this is kind of the vision that we would like at some point to go with Rotkey. So we went from a portfolio turning up to a common EVM decoder and now more towards a middleware that would offer an abstraction for everything in accounting for crypto. Why, right? Like people would ask why the heck? Why would you need this? Because everybody's reinventing the wheel. There is again as I said, different protocols, different exchanges, chains, jurisdictions, it's impossible to keep up. I have talked, I have spoken with people in both small startups and big names in the field for portfolio tracking and crypto accounting. Everybody is saying that this is just too much to keep up.
00:18:07.000 - 00:19:06.822, Speaker A: Maintaining just one module is a full time job. So I believe that there is a solution to this problem. So the problem of everybody reinventing the wheel has a solution that we can have an open source platform or middleware if you want, maintained by a core team, but with contributors from the entire industry and used by multiple projects. And for the problem of different protocols and jurisdictions and being it impossible for a single organization to keep up, I would like to propose a solution that we can have people incentivized from ethchain and protocol with appropriate know how to come and implement modules in this platform. Again, my amazing inkscape skills. Imagine a middleware where you have like, someone who wants to do portfolio and accounting. The core uses Bitcoin and Ethereum, plugs in the Yen module, the Ave module.
00:19:06.822 - 00:19:44.210, Speaker A: He also wants to do accounting, plugs in the accounting module. And because he's in Germany, he plugs in the German accounting with FIFO, multiple depot and LIFO accounting methods. And imagine this middleware basically being used by many people in the field. And in the end, just everything plugging into this. Because it's better to use a common open source middleware rather than every single application. Reinventing the wheel. Any such platform would have some super basic requirements.
00:19:44.210 - 00:20:09.034, Speaker A: It needs to be open source. Like, everybody tries to reinvent the wheel in a proprietary closed source way. This is just absolutely idiotic. It needs to have a modular architecture so that, as we saw before, Be pluggable have pluggable modules. You're in a different country than Germany. You can just plug the, I don't know, Netherlands accounting module. You don't use ethereum.
00:20:09.034 - 00:20:33.938, Speaker A: You use Kusama. You do the substrate module, and you can do all the polka dot Kusama et have. This is a hard requirement to achieve, but it needs to be multilingual. It needs to have multilingual bindings. Because we Atky are a Python house. We know how to use other languages, but most of our code is in Python. Such a middleware should not limit the user.
00:20:33.938 - 00:21:24.902, Speaker A: We cannot ask the entire industry to switch to Python if they are to use such a thing. The platform should be built in a multilingual way. And as for incentivization, the creators and maintainers or modules should be incentivized to actually contribute to this platform. If it becomes an open source standard, then everybody should be like, oh, wait, I mean, we made this new platform. We need to write rotky module for it also because otherwise it's just like nobody will use it. And the core team that builds and maintains it also needs to be incentivized in some way in order to be able to keep building. The ways that this can be is through support to the various teams or through SLAs for software level agreements for companies that may not want to have open source code.
00:21:24.902 - 00:21:52.334, Speaker A: So you can have dual licensing. So it's a bit funny. I wanted to show I saw the timeline thing and I was in the template that they gave us and I thought, hey, why not put a timeline? So how the heck did we get here? 2017? I just need to do my taxes in crypto. And I was like, okay, what is the way to do this? There was bitcoin tax. There was nothing else back then. I'm not going to use a centralized service. I just don't trust them.
00:21:52.334 - 00:22:12.882, Speaker A: So I just made some Python CLI scripts. It worked. I've not been sued by the German government yet, so it worked. I don't know and later built a UI around them. In 2020 we made it into a company. We were a team of two people and maybe we had 200 users, 300 and maybe ten paid. So last year the app had grown.
00:22:12.882 - 00:23:01.510, Speaker A: We hired one more developer and we were 2000 users and 200 paying users in the beginning of this year. There is many people who use Rotkey right now. Some like it, some complain with they always want more and more, but it is at a level that many people can use it. We are a team of seven now, around 6000 users. It's hard to know because it's an open source app and we don't have analytics and 550 paying users. We came all this way without anything, like it was completely bootstrapped and from basically your donations through Gitcoin and from integrations with other companies, like Optimism gave us a grant lately. Before that there were Kusama and so on and so forth.
00:23:01.510 - 00:23:47.254, Speaker A: So for getting this POC that I described here to the full Rotki vision, we would need to go further from here and try to grow and potentially get some funding because with the current team that we have, it's well impossible to actually build this vision. The POC cannot grow to a level of something that can be used by the entire industry with just six people, six developers. This is just impossible. So with this, I'm coming to the closing notes. So if you like the stuff as you had like open source local fest, the modular thing that can be used by everybody in the industry, then please talk to me. Or check out this thing again. Check out Rotky.com
00:23:47.254 - 00:24:13.806, Speaker A: jobs. We have some open positions. We came here thanks to you. Like seriously, it's a boost up project and we would not be here without Gitcoin donations and without our premium users. So keep supporting us. You can donate in Gitcoin grants or buy premium subscription and unlock all of the features of Rotkey and you can join our community in Twitter or Discord. Like that's where all the support is.
00:24:13.806 - 00:24:35.300, Speaker A: It would be pretty cool for you to if you can join the chat and join our community. If you're interested in helping us grow in realizing this vision that I try to present here, then talk to me either like any day in the conference or write an email to leftteris@rotky.com. Yes, with that. That's all, thank you very much.
00:24:42.310 - 00:25:13.280, Speaker B: Okay, you mentioned the graph and truth blocks. One thing that I don't understand about these two tools is to query historical data is that they use a client node and this node is basically in charge of storing this data in an SQL database. Isn't this centralized way of saving data? Is this when IPFS comes into play? And if that's the case, can you explain how IPFS and SQL database work together to solve this?
00:25:13.970 - 00:26:00.250, Speaker A: IPFS doesn't come anywhere in there and True looks completely different. Things so the graph, it creates an index on top of your already existing node data, and Trueblocks does the same, but Trueblocks does it in a generic way for all of your transactions. While the graph has specialized subgraphs written by developers of particular protocol that basically write an indexer just for this protocol, and this lives on top of your node data, it is decentralized. Like, the graph, by design, is also decentralized. Trueblocks is itself also decentralized. It creates this index and this index is shared. I think it's pinned in IPFS and shared with others who use Trueblocks.
00:26:00.250 - 00:26:11.410, Speaker A: I'm not totally sure on the details of sharing of Trueblocks because I'm not the developer, but I think that this is how they do it. As for the graph, they have a decentralized network.
00:26:13.110 - 00:26:28.902, Speaker C: If I'm understanding this right, the idea is if we build this out and get it out there, then we could get around using services like Tenderly and just basically run tenderly at home for transaction tracing and simulations and all that.
00:26:28.956 - 00:26:41.680, Speaker A: Yeah, I view it more from a historical perspective and Tenderly is a current emulator, but yeah, I suppose that you could also do the same. Correct me if I'm wrong. Tenderly is proprietary, right?
00:26:42.130 - 00:26:42.830, Speaker C: Yeah.
00:26:42.980 - 00:26:53.730, Speaker A: Yes, I think that they work with traces. They're pretty good, but yeah, proprietary with such a design. Yes, I believe that we could use this as an alternative.
00:26:55.430 - 00:27:30.634, Speaker D: Ola, awesome presentation. Great work. From the developer perspective on solidity developer, I think it will be very useful for, for example, I write a smart contract and I write the decoder. Let's say I write the decoder and I host it on IPFS. Have you thought about that? Like how we can have, let's say, Parable, where we define the Uri, or Hash, where we set our decoder, and you guys can use it because you have a list of decoders on GitHub, right?
00:27:30.752 - 00:27:52.682, Speaker A: Yeah, I mean, this is just a different medium of delivering the decoder. But yes, there is exactly what you described. So I'm not going to write every decoder. My team is not going to write every decoder. That's impossible. But the idea is exactly that you when you write your smart contract for a protocol, then you say, okay, I'm also going to write a decoder for this. And then somehow it should be delivered to this midway.
00:27:52.682 - 00:27:59.378, Speaker A: Yes, it can be through a link. This that's the POC of what we have right now. The drag and drop in the folder in GitHub.
00:27:59.554 - 00:28:13.094, Speaker D: I think it has a lot of value if you can also validate the decoder. Because if I do it, I can write a malicious decoder. But we wanted like a validation system, and this is a place where I think you can add a lot of value.
00:28:13.292 - 00:28:16.820, Speaker A: Okay, yeah, that's good feedback. Thank you, guys.
