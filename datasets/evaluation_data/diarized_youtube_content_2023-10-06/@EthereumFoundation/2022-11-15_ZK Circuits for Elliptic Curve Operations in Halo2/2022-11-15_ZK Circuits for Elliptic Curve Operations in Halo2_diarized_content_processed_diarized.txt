00:00:14.010 - 00:00:50.666, Speaker A: Welcome everyone, and thanks to Barry and Ying Tong for the great introductions. So today I'm excited to tell you about this elliptic curve library we've been building in halo two. Okay, so first let me tell you what library can do. So it's a halo two library for doing various elliptic curve operations. That in particular has a configurable trade off between the proving time and verifier cost. So the operations we can support is that for generic elliptic curve, you have to put in a few constants. We can do addition doubling multiscular multiplication, and then for pairing friendly curves, we can do optimal eight pairing verification.
00:00:50.666 - 00:01:29.554, Speaker A: And we can also do ECDSA signature check. So we've also put this library into the scroll and PSC aggregation circuits for the KZG back end of halo two. Okay, so before I tell you more, let me show you some numbers. So for ECDSA signature verification, you can see that if we have a small proof size at the top, we have a longer proofer time, around 10 seconds, a little over, and then if we increase the proof size, we're able to get things down to around 3 seconds on a MacBook air. Weirdly, we found that on the cpu, the MacBook Air beats a fancy AWS.
00:01:29.602 - 00:01:30.200, Speaker B: Box.
00:01:32.170 - 00:02:10.866, Speaker A: For multiscaler multiplication. With 100 base points, we can get things to around 56 seconds using larger proof size. And as you can see, that's still an improvement over the small proof size setting. And finally, for pairing check on BN 254, which is the curve on Ethereum, we can do that in about 15 seconds, again on the MacBook Air. Okay, so let me tell you how we build all of these circuits. So we have a very modular approach. So in halo two, you're allowed to use a lot of custom gates, but we're very simple minded, so we use a single custom gate.
00:02:10.866 - 00:02:55.140, Speaker A: Our gate has four vertical cells, and unfortunately, I forgot to highlight them. But starting from the top, our gate is just a plus b times c equals d. So in this example on the right, if we want to compute a dot product of one comma three with two comma, four, we're first going to apply a gate on the top four cells. So that will say zero plus one times two equals two. And then we're going to overlap it with a gate on the bottom four cells. So that would say that two plus three times four equals 14. So this simple overlap optimization gains us about a 25% gain for all dot product operations, which turn out to make up maybe 80% of all of the operations we do.
00:02:55.140 - 00:03:55.814, Speaker A: So our setup is that we have a number of advice columns. With this custom enabled, we have a single lookup table for range checks, and then we have a bunch of selector columns. Okay, so we wrote a pseudo layouter in Halo two, which allows us to configure where these columns are placed in different regions. So as a configuration to our circuit, we allow a fixed number of advice and fixed columns, and we sort of tetris these vertical concatenations of our basic gate into the columns. On top of this, we built a basic library called halo two. Base of basic gadgets like inner product range check indexing into an array, doing various bitwise operations, and doing comparisons on top of this gate. And that allows us to almost completely abstract away the manual assigning of cells that you may be familiar with if you've ridden some halo two.
00:03:55.814 - 00:04:48.060, Speaker A: On top of that, we build our elliptic curve library, mostly, maybe 95%, only using these abstractions. One thing to note is we found it's actually very difficult to outperform using this very simple gate. Using fancier custom gates, we tried a number of what we thought were very clever things that did not improve the proving speed. Finally, I wanted to mention one very critical optimization that we made, which is that we previously enabled lookup arguments on every single column, and that was crucial in doing our range checks. We did one optimization to have special columns whose only purpose is to hold cells that are looked up, and we copy all cells. We want to look up to those columns. Although this sounds a bit trivial, it actually reduces the proving speed by about the proving time by about 50%.
00:04:48.060 - 00:05:41.690, Speaker A: And again, we can configure how many of these special lookup columns we need, depending on the circuit. Okay, so just to show some plots on the results, if we vary the number of columns, as the number of columns grows, the proof size grows, and typically speaking, the proving speed will increase. So you can see, for the optimal eight pairing for a single column setting, the proving speed is about 250 seconds on the left. And as we expand the number of columns to around 15, we get pretty sharp drops in the proving time. But things sort of plateau after that. On the right, you see a very similar phenomenon for ECDSA verification. We were a little bit surprised that things trail off at this small number of columns, and we're sort of exploring whether there's something in the backend which could let us push it further.
00:05:41.690 - 00:06:25.750, Speaker A: All right, finally, I want to tell you how we plug this into the existing aggregation circuits. So if you have a KZG back end halo two proof, then to recursively verify the proof, you need to do two things. First, you need to do a bunch of multiscalar multiplication on the KZG commitments that comprise the proof. So these would be multiscaler multiplications on the bn 254 curve. And secondly, you need to do a pairing check. So in the current aggregation setup, the pairing check is deferred, meaning that in the aggregation circuits only the multiscalar multiplication is done. So our target was to integrate our library into the existing aggregation circuits.
00:06:25.750 - 00:07:24.102, Speaker A: So to our knowledge there are two one is out of PSE, it's this plank verifier repo, and one is out of scroll, which is halo two snark aggregator. The way that both of these work is that there are various generic traits for an elliptic curve library that they use, and they sort of abstractly write on top of these elliptic curve traits so very nicely. That allows us to plug our library into these aggregators simply by reimplementing all of these traits in our language. And again, a nice feature is that both of these libraries are able to output EVM verification code for the final aggregated circuit. So here are the results. So in a setting where we have seven advice columns and eight fixed columns, so of the advice columns, six are standard columns. With this basic gate enabled and one is a lookup column, we're able to verify the actual ZKVM circuits recursively.
00:07:24.102 - 00:08:11.370, Speaker A: So we just tried out the EVM opcode circuit and then a combination of the EVM and state opcode circuit. And so even on a MacBook air, we're able to do the recursive aggregation of the EVM circuit in a little bit over around ten minutes. Note that the scroll and PSC numbers are not precisely comparable because we have slightly different versions of the state circuit inside. Unfortunately, when we aggregate the EVM and state circuit together, it exceeds the memory constraints of our MacBook Air, but we'll try it on the server soon enough. Okay, so that's it. So in summary, we have this library, halo two ECc. We can support pretty much all the operations that we know of that you'd want to do on elliptic curves.
00:08:11.370 - 00:08:34.340, Speaker A: Just some highlights would be the pairing check, the ECDSA signature verification, and the ability to configure the base curve without too much work. And we really wanted to highlight that our base component library, halo two base, which we open sourced this week, which allows us to write these circuits in a much more modular and configurable way. Thanks, and I'm happy to take any questions.
00:08:43.430 - 00:09:00.040, Speaker B: Are there any questions okay, I have a question. So I am one of the authors of the halo two library. So if you could change two things about halo two, what would they be? No more.
00:09:02.490 - 00:09:33.714, Speaker A: If you asked me for two things, the first thing would probably be, and this might be very difficult to change. So halo two has a function called synthesize, which constructs your circuit. But the design of the library is that synthesize is called multiple times with different purposes and different interpretations of the input. So when we're developing, that's actually the biggest source of bugs, because we sort of forget that on one of the times the semantic meaning of some of the inputs is a little bit different. I don't know how that would be pulled out, but that's the biggest difficulty right now.
00:09:33.912 - 00:09:55.850, Speaker B: Okay, is there a question? No. Halo two is a very low level API in the sense that you can configure really every detail about your circuit. So have you found that to be more helpful or more annoying?
00:09:56.350 - 00:10:35.510, Speaker A: We really like the configurability, and that's why we're spending so much time in the halo two ecosystem. Initially we found it very difficult to manage, but the way we found to be productive in it is to sort of really restrict ourselves, as you've seen here, and then slowly add on more complexity, almost as not really a pre compile is not the right word, but just almost as a special addition to our library, and then restrict ourselves to only work within this sort of constrained universe of the freedom that halo two offers. But the reason we like that freedom is that if we ever need something more fancy, we know that we can sort of add it to our base components.
00:10:35.850 - 00:10:41.734, Speaker B: Cool. And my last question is, what are you using halo two ECC for?
00:10:41.932 - 00:10:54.190, Speaker A: Yeah, so we're building a new project called axiom, which is a trusses indexer, which allows you to take any fact, historic fact, from a ethereum and prove it on chain for use in your smart contract.
00:10:54.850 - 00:10:55.420, Speaker B: Cool, thanks.
