00:00:14.330 - 00:00:24.480, Speaker A: We are with Joseph J and Naim and they are going to share about asset right abstractions, a case for smart contract wallets. Go ahead.
00:00:31.290 - 00:00:56.222, Speaker B: Thanks. Hey everybody, my name is Joseph, this is Naim. We are from project called Pawn. And today we are not going to talk about pawn, but about something that we developed for the community because it's important to us and to our cause. So we are going to talk about asset rights abstraction, our case for smart contract wallets. So I'm the CEO of Pawn. Whatever being a CEO means.
00:00:56.222 - 00:01:37.094, Speaker B: Naim is a smart contract dev. So he's actually the guy who is going to tell you the interesting stuff. I'm here just as a staffing. So first, why. So why did we start developing a smart chronic wallet? In short pond is a generalized borrowing and lending protocol. But we also need a whole bunch of tooling out there in the ecosystem and since it wasn't available at the time, we decided to develop it ourselves. So in pawn, our kind of holy grail, what we want to see, what we want to build in the ecosystem is seeing long term loans, mortgage type of loans being issued on chain.
00:01:37.094 - 00:02:27.660, Speaker B: So we are looking at like 510 15 years contracts that should last on chain and should be actually perceived as legitimate. Like today, what we see in d five is mostly short term or something that will get set up and can be erased like 30 seconds later. But we kind of want to get us to the point where people will be able to back their long term mortgages with digital assets. And this is an important piece of the ecosystem or like piece of the tooling that we need. So we decided to dive into smart contract wallets and kind of allow using the assets that you own while you're using them to back a loan. But our case, or the case for our smart contract wallet is much wider. So today we are going to dive into that.
00:02:27.660 - 00:03:36.850, Speaker B: So most people, I guess, know smartconic wallets as a multisig or something that allows you to operate a wallet or operate an account as multiple users. But there is much more. So depending on your level of technical knowledge or just like the time you spend in the ecosystem, just a quick rundown. What are actually smart contract wallets? So contract wallets are essentially smart contracts that are creating a proxy between a user or like an end user account and another contract with some extra logic added. So there are some examples, why would you use it? So first, you can enable, you can create more events automations or call wrappers around multiple contracts and do more things in one transaction than you would otherwise be able to do. Good example for that is gnosis safe or safe as it was recently renamed, which uses it for multisig interactions. Or another great example is a defi saver smart contract wallet, which makes it easier to operate in the defi ecosystem.
00:03:36.850 - 00:04:33.060, Speaker B: Another example would be just general identities. So there's a lot of talk about decentralized identity standards and a way you can use multiple keys in one smart contract and essentially use the contract as your on chain identity. There is a whole bunch of attempts around the did, or there is also the argent wallet, which essentially does a very similar thing. Now, smart contract wallets aren't definitely useful for everything. They have some downsides. So that's especially the gas overhead, because again, you're using an extra proxy, you have to do more computation in every single transaction that you're using it for, and secondary, you may require some level of integration. So EIP 1271 for signed messages would be one example of what everybody, everyone else has to integrate in order for smart contract wallets to work just as like a user account would.
00:04:33.060 - 00:05:50.026, Speaker B: So in our specific case, why do we want to mess up with asset rights? As I mentioned, we want to allow the case where you kind of can have your cake and eat it too, where you can have assets in your custody, but still create some sort of a deed, some sort of a right for another person to eventually be able to access those assets and kind of take them with them. So the very basic case for us is essentially creating a hook in the wallet in someone else's account that allows you to essentially drain the wallet if a certain criteria is met, and obviously if the other person consents to it. So they would actually sign up for that in another contract. What is this good for? Is that you don't actually have to move those assets that you have in the account. You can just create this right that will allow someone else to access those assets. And if some people state from the previous talk from EA or just the enterprise ecosystem, this could be useful for even like KYC. Assets or assets that require KYC, because you don't have to move them from wallet, you can just wait until the point where you actually have to move them.
00:05:50.026 - 00:06:33.420, Speaker B: And that's the point where you can kind of start dealing with KYC, because the actual asset didn't move, nothing happened to it. So again, for us, the case is a defi mortgage, where we just want to allow someone to buy a piece of Decentraland lock it as collateral, keep that in their custody, still allow them to use it, but use the value of the asset as a backing for loan. Another example would be like Dow voting rights. Again, you still want to use those, but you might want to utilize the value. That's kind of backing the particle token. The same goes for gaming items or ens. Names are again a perfect example.
00:06:33.420 - 00:07:02.210, Speaker B: Another useful thing is that you can also allow asset renting. You can just reverse the case and essentially just give someone the right to transfer the right to someone else, but keep the token transfer right and keep the ownership of the asset and withdraw it later if certain criteria is met again. So this is the basic intro. And now finally, now is the interesting stuff. So passing the word over to Naim.
00:07:04.950 - 00:07:32.880, Speaker C: Thanks Joseph. Hi guys, my name is Naim. Before we start, for those who don't know me, besides, I'm being a smart contract dev. I'm also a contemporary circus artist. So even though I'm used to performing in front of people, I am not used to speaking in front of people. So I'm super nervous now. And I was thinking, how can I make me less nervous? So I decided I want to perform you something.
00:07:32.880 - 00:08:09.106, Speaker C: Unfortunately, I'm jumping on a trampoline which cannot be fit here. So I'll just show you a video of me being shot from a human cannon. It thanks guys. Yes, it helped me. It helped me a lot. So back to the topic. Let's define some requirements for this contract wallet.
00:08:09.106 - 00:08:50.278, Speaker C: Obviously it has to act as a normal contract wallet. That means that you have to be able to call arbitrary call data on any address, basically. And the nice feature enable tokenizing asset transfer rights. We want to enable tokenizing these rights to fungible, non fungible and semifungible assets. And one of two things it means is actually to enable the ATR token holder to transfer the assets from owner's wallet. So you don't own the asset, but you are able to actually transfer it. And the second part of it is prevent the owner without the ATR, without the ATR token to transfer it.
00:08:50.278 - 00:09:58.410, Speaker C: So yeah, you are not screwed if you are a token holder. So, high level wallet design first, after some prototypes, we tried to implement our own smart contract wallet, which is something we realized we don't want to do because we'll be basically reinventing the wheel. So after some research of gnosis safe, we realized they have two very nice components. One is guard and one is module. For those of you who don't know the safe ecosystem that well, guard is a contract which you can basically link to your safe, which will check every transaction made from your safe before and after the transaction. In our context, it's a guard which will basically enforce the transfer rules. Okay, so if we see that the safe has the ATR token minted, but is not the holder, we'll basically revert the transaction, and that's the responsibility of the guard.
00:09:58.410 - 00:10:55.920, Speaker C: The second component is a module. This enables to execute a transaction without actually reaching the owner's threshold, which is also something we really want, because we want the ATR token holder, which is not the owner of the safe, to be able to transfer or start the execution of the transfer from someone else's safe. So yeah, that's cool. With these two components, which I was very surprised they have, we were able to build this ATR smart contract on top of ignosisafe, which is really great. We encountered obviously some challenges, so we will talk about them right now. First is approval issue. While minting an ATR token, it's pretty obvious that you don't want to mint an ATR token and have approved addresses at the same time.
00:10:55.920 - 00:11:35.434, Speaker C: Because if you do, the approved address can transfer the asset without even triggering the guard or the module. So this is obvious like thing we have to solve. Next is something we called stalking attack. It's basically a type of attack where I as an attacker will create a malicious asset. I will tokenize its transfer rights, I will transfer it to my victim's wallet and remove it with some non standard way. So let's say the asset can be transferred by the owner. I as attacker am the owner, so I'll be able to withdraw that.
00:11:35.434 - 00:12:10.402, Speaker C: In that case, the victim's wallet goes into state where every execution will fail because the guard will not have the proper, sufficient tokenized balance. So it's also bad. Then we have challenges like EIP 1271, where the input of the function is basically just hash and signature. So we cannot enforce the rules if we don't know what is actually verifying. Then there is a gas overhead. It's a contract wallet. There always will be some gas overhead.
00:12:10.402 - 00:13:05.954, Speaker C: Plus there is a lot of checks for every execution, right? Then there is the non standard assets we currently support just the standards we cannot support non standard asset because we are actually enforcing the transfer rules. Right? So yeah, that's one challenge and not possible to use the delegates call, because then it will alter the logic of the smart contract. And again, you are able to transfer it or do whatever you want with that. So let's talk about the first one. Yeah, approval issue. While minting ATR token, we need to check that the asset, which ATR is going to be minted, doesn't have the approved address. Currently there is like four types of approvals.
00:13:05.954 - 00:13:47.220, Speaker C: For ERC 20, it's approval amount. For ERC 721, it's approved id or set approval for all. And for ERC 1155, it's just set approval for all. Only one of these approved function has actually a getter for the address. So it was a big issue at first. But after realizing that all the approval exit or all the transaction which are approving the assets are done through the wallet, then we can basically just track all the approved addresses and on the time of minting we can check that the asset doesn't have an approved address. So yeah, cool.
00:13:47.220 - 00:14:27.938, Speaker C: We need to check the approved addresses. The stalking attack, how I described previously, it's the malicious asset which is transferred from the victim's wallet by, in a non standard way, it would revert on insufficient tokenized balance. But we still want the ATR token holder to be able to transfer it to any asset. So because of that, we need to basically divide the transfer function into two. First is claim where I as an ATR token holder am transferring the asset to my wallet, which is cool. There is no possibility of stalking attacks. So yeah, we'll let you do that.
00:14:27.938 - 00:15:06.880, Speaker C: And the second is the generic transfer to any address. But in that case we require the recipient permission. In this permission, the recipient can actually specify what type of asset is going to be transferred by whom, some expiration stuff and so on and so on. So it's much harder for an attacker to actually execute this stalking attack. It's still possible, but it's much much harder. But still, because it's possible, we need to implement a function to recover the safe from that attack, which we did. That's a good one.
00:15:06.880 - 00:15:46.710, Speaker C: So after solving some challenges, the final design looks like this. You can see the ATR token or the ATR module. Here is the guard. It's implemented as a proxy for basically be more future proof. If there is some widely adapted ERC which we want to support, we don't want to force every safe owner to deploy new ones. We'll basically do like a force update for them. Then you can see the operator's context.
00:15:46.710 - 00:16:43.798, Speaker C: This is a contract responsible for tracking the approved addresses per the collection and our ponce factory, just to be sure that the address we are interacting with is actually safe. And then there is some gnosis safe contract and the owner because of this proxy, still we didn't solve all the challenges. So open challenges are enable EIP 1271. It will be possible if the wallet basically pre approved the hash. In that case, we can actually check what is approved and if it doesn't break any transfer rules, it'll say, yeah, okay, this hash is approved. So every call for the is valid signature will return true or the magic value for this hash. Gas overhead.
00:16:43.798 - 00:17:44.906, Speaker C: Of course we want to have the gas cost as low as possible. So currently minting the ATR token has a constant overhead, which is nice. And transferring the asset via the ATR token has linear overhead because it's depending on number of tokenized assets in the safe. Because we need to check that every tokenized asset after the execution is actually there and that the tokenized balance is still sufficient, then there is an issue with nonstandard asset. I think this issue will be there like forever because we can work only with the honest assets. So if somebody is trying to give you his ATR token for some malicious asset, which is not standard, defines some approved functions or transfer functions, we cannot basically prevent him to do that. And if you accept this ATR token, then yeah, you're screwed.
00:17:44.906 - 00:18:14.010, Speaker C: Sorry. And the possibility of using delegate calls. There is actually an option to whitelist some addresses to be able to use the delegate call or to call the delegate call ad, but we cannot do it generally. We cannot say, hey, you can call delegate call on any address because then it's a huge security issue for us. Yeah. And I think that's all. So thank you.
00:18:14.010 - 00:18:16.490, Speaker C: There was me and Joseph.
00:18:19.790 - 00:18:22.698, Speaker A: Thank you so much, Naim and Joseph. And thank you for.
00:18:22.784 - 00:18:26.350, Speaker B: I also think we have two more. Thanks to Shildo. There are two slides where.
00:18:26.420 - 00:18:27.614, Speaker C: Yeah, two more slides. I'm sorry.
00:18:27.652 - 00:18:28.240, Speaker D: Yeah.
00:18:38.270 - 00:19:15.582, Speaker B: Maybe it's stupid to put two more slides after a thank you page, but stuff happens. If you can go to thank you. One as actually number 18. Yeah. Cool. So I realized maybe some of the graphics weren't really visible here. So if you go to pond mirror XYZ, there is an article about the pondsafe where everything should be described.
00:19:15.582 - 00:19:30.200, Speaker B: Also, you can just check out our website on pond XYZ where you can see our audits, see our repos. We have a bunch of documentation for users or developers as well. And finally, well, here's our pop.
00:19:33.150 - 00:19:47.120, Speaker C: Yeah, thanks for coming. And I think we have six more minutes for questions. Is it right? Yeah. So if any of you have a question, anyone? There we go.
00:19:55.330 - 00:20:15.880, Speaker D: Thank you. Good afternoon. How are you going to handle the. I don't remember which was the correct aip, but there was one that will allow you to approve and transmit in the same transaction. Have you any plans for that? I think it was 1271 or something similar.
00:20:16.730 - 00:20:22.410, Speaker C: Come again? If we want to support standard that can approve and call in the same transaction.
00:20:22.910 - 00:20:37.360, Speaker D: Yes, I believe there was one of the eips that allowed you to sign several transactions at the same time.
00:20:38.930 - 00:21:14.540, Speaker C: If I understood it correctly, there is one eip, I think it's 1373, something like that. It's a token standard which implements another set of approved functions. These approved functions can basically approve and call arbitrary data in one transaction. We are actually supporting that. So beside these well known 27, 20, 111, 55, we are also supporting seven, seven, seven. And these 1363. I'm not sure about the number now, so I hope I answered your question or it was something else.
00:21:14.540 - 00:21:17.020, Speaker C: Anyone else?
00:21:31.330 - 00:21:49.990, Speaker E: Thank you. Lending out nfts is always a bit tricky, and you mentioned you can lend it out without using collateral. How is that realized? And is that compatible with any existing wallets that would display nfts?
00:21:50.730 - 00:22:33.620, Speaker C: Well, the idea about not using collateral is that you will use collateral, but the ATR token. So basically, if I want to lend you some asset, some whatever asset, I will first tokenize its transfer rights. I will send you that asset and I'll keep the transfer rights to myself. So you are stated as an owner of that asset in the whole defi ecosystem, but if you stop paying me my installments or whatever, I'm still able to transfer it back from you, even though normally I don't have the rights to do that. So it's not like uncollateralized in very technical sense. But you are not using the asset itself as a collateral. You are using the transfer instead.
00:22:33.620 - 00:22:40.420, Speaker C: Anyone else?
00:22:41.350 - 00:22:42.130, Speaker B: Yep.
00:22:47.530 - 00:23:10.846, Speaker F: Hey guys. Thank you. So, would you elaborate a little bit about the account rental you were talking about account rental or so, and bribery attack for the account rental. So if I understand correctly, then we'll be allowed to rent our account on the usage of. Yeah, go ahead.
00:23:10.868 - 00:24:27.542, Speaker B: It was about specifically the assets, but Naim, if you want to take that one, is the renting case. All right, well, so essentially what NyM did, which I didn't realize when he was developing it, but I thought it was super cool, is that within the realm of the sales, which have this particle guard and module enabled, because you would generate them using a specific contra factory, you can still transfer the asset to essentially like any safe that has that particular guardian module, and the ATR token will still be executable, and you'll be able to essentially get it from anyone's wallet within that particle realm. So obviously, you have to realize the particle asset has this deed created around it, but it's essentially the same as having real estate property and having a deed on that property. And then we can be like friends that want to reuse our gaming assets. We can have the asset token regenerated. I can safely give my magic sword to Nyme's wallet. I will tell him to give it back to me in 30 days if he.
00:24:27.542 - 00:24:45.200, Speaker B: I can just claim it back. And obviously you can put it into contract. You can set kind of like exact parameters on how the return should happen. But the asset token, the ATR token is basically the thing that will execute a transfer later on.
00:24:47.970 - 00:24:50.250, Speaker A: Perfect. Thank you so much, Naim and Yusuf.
