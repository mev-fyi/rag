00:00:14.170 - 00:00:55.850, Speaker A: Starters, everyone. My name is Igu Yoboi. I'm a solitary developer, CEO, founder, and previously worked at Openzeppelin and co founded a Defi startup called Baby on Finance. Today I'm excited to present you a workshop titled Unlimited Size Contracts. Before we jump into action, you might want to download a GitHub repo for this workshop. Either use the QR code or just Google GitHub wire IO workshop and you'll get it. We also will need a foundry for this workshop.
00:00:55.850 - 00:01:41.900, Speaker A: If you have it, great. If you don't have it, just install it using the link in the slide and then run two commands, foundry app and forge build. I know Internet is pretty bad here, and so for some reason you can't download it and install it. Don't worry, the repository will stay up and you have access to it. And I'll post the slides tomorrow and I'll be doing some live demos so you can just watch and get the idea what's going on. Let's jump right into it. All right, who has ever deployed here and written a smart contract? Please raise your hand.
00:01:41.900 - 00:02:27.290, Speaker A: Yes, lid developers. Okay, who has ever run into the issue of a contract size limit here? Please raise your hand. Wow, it's way more problem than I thought. So yeah, this picture, it illustrates my personal pain while working on finance. We pretty quickly ran at the issue of a contract size limit, and it's not easy issue to address and it causes us a lot of pain. And one file developer I know in solitary space called this limitation, I quote, bane of my existence. So this is how big this problem is, and we are going to tackle it today.
00:02:27.290 - 00:03:11.642, Speaker A: So there is a few solutions for this. Well, you can reduce bytecode size using various techniques, and essentially it's like alternative sport to guess golfing. I called it bytecode golfing. I certainly do not recommend it because it's like a diminishing return sport. With each optimization, you have less and less space left for each new function, and it even may compromise the security of your project. So I would be wary of using this technique. And I suggest to try to design your architecture from day zero in the way it supports your contracts to be unlimited size.
00:03:11.642 - 00:04:08.650, Speaker A: Other solutions are external libraries, static precompiled rotor and a dynamic rotor. We will cover them in this workshop and hopefully have some time for questions and discussions. All right, we're going to use a simple contract as a baseline contract for this workshop. It's called a counter. It has a few functions, a set function which sets int variable to a new value, a get functions which retrieves this variable, and finally a const functions which just returns a constant. These are good functions for a baseline contract because they essentially utilize one s load operation, one s store operation, and returning the constant value. And these examples are quite well spread and real smart contracts.
00:04:08.650 - 00:04:43.862, Speaker A: All right, let's jump into the code. Here we have our counter contract. Again, I'm not going to spend any time on this. It's pretty basic. What is important about it? It's rather small. So if we look at it bytecode size, you can see it's under 1 kb, which is great, and we have a lot of space left. But let's say a product team says oh actually we need to implement this new call feature called quote a function.
00:04:43.862 - 00:05:26.594, Speaker A: And a quote function is a function which returns just like big string, which takes all the space. And then if you look at this big modeler, it takes almost all the space in the contract with few left. And if we try to implement it in very naive way using solid inheritance, so we just okay, so the counter, the big modeler, done, job done. And then we discovered that no big counter is over the size of the limit. We can't deploy it, nothing can be done, it can't be optimized. So how we can solve it? The first solution is external libraries. External libraries is a feature of a solidity.
00:05:26.594 - 00:06:23.046, Speaker A: So how it works is that in your contract, in your methods, you just call a library instead of implementing it in the contract. In this case we have two libraries. One is called storage leap, which contains our original counter methods such as set, get, const. And finally we have quote lip, which contains the only quote method which contains this big string. And if you look at the implementation details, the catch here is that you need to pass this parameter which is canonically called self and has a storage type. And this, like a special syntax in solidity, allows you to modify storage in external contract. And essentially external libraries, salinity is just abstraction layer over delegate call, and that's basically it.
00:06:23.046 - 00:07:31.200, Speaker A: There is not much to this, and if we go back to our presentation, we can quickly sum up all the ups and downs with this approach. So the good part about it, it comes with some security guarantees by solidity. The main important one is library can't call self destruct. So library can't destroy your smart contract, which is important because it's not the case if you use diligent code directly, essentially proxies, where if a proxy contract calls self destruct, your contract is done. It's somewhat easy to add one more leap. You can always introduce one more leap and it's gas efficient to a degree, but a bit later on this and the main downsides of this is that it's not truly infinite, because to add one more function, you need like external wrapper function, which stack up quite quickly and eventually you will run out of space in your surface contract. And it doesn't matter how many lips you can write more, there will be just normal space.
00:07:31.200 - 00:08:18.140, Speaker A: And the final downside, maybe for some projects, external libraries can support upgradable contracts. So once you deploy your external libraries, it's like set in stone and you can't change it. The next approach is a static pre compiled rotor. This work was pioneered by Alejandro Santander from synthetics. He also previously worked at Openzepillion, and he's known as Fernaut on Twitter. And if you want to take a look at production ready like stable code, I suggest you check out hardhat router package at the synthetics repo. And what we are going to take a look at a simplified example.
00:08:18.140 - 00:09:06.090, Speaker A: So the idea for the static router is pretty simple. It's a smart contract, which has no external functions, and it only has a fallback and receive functions. And what it does, it calls a forward function inside both of them. And the forward function consists of two parts, the lookup part for the implementation address and the assembly part for delete call. I'm not going to spend time on this. I'm just going to say this is like a canonical implementation of a proxy delete call in assembly, which is used by all the proxies. And what it does, it basically sends your function call to whatever the implementation contract is and then returns its results.
00:09:06.090 - 00:10:00.750, Speaker A: And the interesting part is here. So in solidity, each function has a signature. And as you can see here, we have a switch for a signature method, and based on the signature of a code function, we pick up an implementation address which is later used for delegate call. And as you can see here, we have four functions registered for a counter modular, which is a get set const, and one function registered for a quote modular. Because it's so big and based on function signature, we do pick up a right implementation address and then use it for delegate call. And again, if you go to our contract sizes, why it works because these are three separate contracts. We have a big modeler which is within the limits.
00:10:00.750 - 00:10:53.534, Speaker A: Then we have counter module, which is also within the limits. And finally, static rotor itself is pretty small because it's just with one function though the more functions you have, the more its byte size grows because you have to add each function here as a new line, though it grows way less than external libraries. Example. And if we go back to slides we can see what are the benefits of using it. It's extremely gas efficient. Why? Because it's all pre compiled in bytecode, so you don't need to waste any expensive operations. As a s load on the rotor itself, your function call goes to the rotor and then immediately calls diligent call.
00:10:53.534 - 00:11:28.694, Speaker A: So your most gas overhead comes from diligent coal, which is about 2600 gas. It's almost infinite. It will take really lot of functions before you run out of space in this rotor. In terms of adding these constant signatures and contract sizes, it doesn't require external functions. Well, the downsides are pretty expected because it's essentially a proxy. You can't use constructors, you have to use initializer methods. And cross modular calls can be tricky and you have to use explicit storage slots.
00:11:28.694 - 00:12:12.274, Speaker A: So your different model is do not write to the same storage. And then finally development and maintenance overhead can be tricky because you need to pre compute all these signatures and addresses upfront and you don't want to do it by hand, which is I recommend check out again hard router. They built a plugin which does that for you. Well with second approach how you can achieve infinite size and compared libraries. It's better in the way which gives you more control using assembly and low level language features. The next idea is iteration on a static router. It's not necessarily better, it is a different approach.
00:12:12.274 - 00:13:16.300, Speaker A: It depends on your project. I call it dynamic rotor. If you're interested in product level battle tested implementation of this idea, I highly recommend you to check out AP 25 35 by Nick Much Vcap covers far more things than just unlimited contract size, but one thing it certainly does achieve is unlimited contract size through a dynamic router. I've written a simplified example of this dynamic router, so let's get to it so we can see how it works. It's quite similar to a starter rotor, in the same way it has a fallback receive functions which just forward every function call to our forward function. But the difference comes in this line. If in a static router function we have a switch case which just goes or have for this signature I have this address.
00:13:16.300 - 00:14:21.002, Speaker A: In a dynamic router we are using smart contract storage mapping which is called modulus. And as you can see here we pick up an implementation address using message signature and then the rest of the implementation function is the same. We just provide this implementation to delegate call, and essentially it works in the same way. The essential difference between static rotor and dynamic is the static router has all the signatures and all the implementations and races hard coded in its bytecode, where dynamic router use mapping on the storage of a smart contract to track them. And that adds pluses and minuses to this approach. So the pluses is once you deploy your dynamic router, you can add more modulus, even it's already deployed, or you can fix bugs by updating it. Here I have this function, update modulus, and it's also pretty straightforward.
00:14:21.002 - 00:14:52.300, Speaker A: As you can see we just iterate and add selectors to implementations. The downside of this approach is you have to manage access rights. You can't allow anyone to update functions of your router. That would be disastrous, a critical issue in security terms. And there are different ways to use it. You can use open Zeppelin access roles or some other techniques, but that's out of the scope of this workshop. But you just have to keep this in mind.
00:14:52.300 - 00:16:00.160, Speaker A: And if we go back to presentation, dynamic router is the first router which is truly infinite, because all the mappings between function signatures and implementations are inside the storage, which is, as we all know, very big in solidity. Then you can literally add infinite amount of functions to this router. So it's very good for a complex system which would require upgrades and have long expected lifetime. Then another option, another plus I just mentioned, it can be updated anytime. Well, I mean it can be a minus if you're getting hacked, but generally it's a plus, has no external functions. So the main downside of this is it's a gas expensive wis function is essentially here is rigging a storage which is extra sload, which is about 2000 gas. And the set part, you have to pay it for every contract call.
00:16:00.160 - 00:17:08.230, Speaker A: And then another downside is you have to manage access rights. Who can update this router? If you want to build a truly unstoppable contract, maybe you don't want to have any upgrades. And there can be many solutions like governments and multisig, but you eventually have to figure it out for yourself. These are the three main approaches which you can use to tackle infinite size contracts. And then what's the difference between infinite size contracts and normal contracts? In this approach it comes down to a gas overheads. Essentially here in this table we are comparing our base contract with free approaches in terms of gas and why gas is important. Like a short story, when was like a bull run and gas prices were high, we were seeing the function calls for the users in the price ranges of $100, $2,200 and even $300 for some projects.
00:17:08.230 - 00:17:54.562, Speaker A: And a lot of these gas costs were coming from using proxies, because proxies has gas overhead at each function call. And if you really have a complex defy system where protocols call each other and they all proxies, this amount of overhead stacks pretty heavily, even within your own protocol. And it's important to keep an eye on these gas every head calls. So let's dig down a bit in these numbers. The first base contract are the numbers for our base calls. So it's like no delegate code involved. And then if you look at that, the base call for a constant call, it just returns a number.
00:17:54.562 - 00:18:41.698, Speaker A: It's very small. And the first number in red is just what's the overhead and gas. And the second number in red is in percentage. And you can see for a simple return call of a constant value, the overhead is actually around 2000%, which is insane. And you may say, oh, it's not practical to return a constant value. But you will be far from the truth, because the famous UC 20 token has a function called decimals, which returns how many decimals the token has. And you have to call this function if you're a defy developer, because in order to handle EC 20 token, you have to know how many decimals this token have.
00:18:41.698 - 00:19:27.774, Speaker A: And one of the most common UC 20 tokens, like USDC, they approximate contracts. So every time you call decimals, you're overpaying roughly 2000% or probably more. But anyway, let's take a high level look at these approaches. So as you can see, indeed, static router is the most gas efficient approach. So if you have to build a gas efficient infinite contract, and you know what kind of functions you're going to have and don't plan to upgrade, then it's like a great solution. And then dynamic rotor is more expensive, even more expensive than external library. The reason I wouldn't recommend external library.
00:19:27.774 - 00:20:21.310, Speaker A: As you can see it has unusually high overhead for quote, more than double than it should. And I think it has something to do with how solidity pass with big amounts of data. But I haven't dipped the bytecode yet. But just be wary. If using external libraries and you pass or return big amounts of data, then your gas expenses may surprise you. And to take a look at this, what will be the high level conclusions of this overview is that your gas overhead obviously is more significant for functions which are low in gas. Essentially, if your function has only a single s load, then you would pay a lot of gas.
00:20:21.310 - 00:21:23.122, Speaker A: So what it means in practical terms, which I also encountered, is that if you need to build a function which returns some data around your protocol smart contract, you may want to bulk them all this data in one function call. So you don't need to call five functions in a row because you would pay a guest overhorse on each call. Essentially, batching view functions might be a good idea. Then again, the bigger the baseline guest cost for your function, the less you care about it. So let's say you have a function which is quite expensive, let's say 300K, then suddenly five k overhead doesn't look that bad. Though there is a catch to this, in many protocols, not all functions are equal. Essentially, if you look at typical vote functions such as deposit or withdraw, which are mostly called by the user, so you won't achieve the maximum gas efficiency on these functions.
00:21:23.122 - 00:22:16.662, Speaker A: And some, like admin functions which are rarely called, you may want to skip optimizing gas for them. And because the gas is so important, I spent some time thinking and trying to figure out a trick how we can improve this. And I came up with solution which we use successfully in production to reduce the gas cost of our contracts. I never found anyone using it somewhere on the Internet or on GitHub. That is why I had to coin the term for this approach. So I'm calling it like loaded router. And so the approach is pretty simple, because if you go back to a static router, to a static router, in our case, it doesn't take much space.
00:22:16.662 - 00:23:42.260, Speaker A: And even if it grows, there's still a lot of space left. And what you can do essentially is again, using solitary inheritance, you can inherit some functions of your contract to a static router, which allows them to be as gas efficient as the contract itself, because it's essentially a contract itself. So in the other ways, if there is some space in terms of bytecode size left in your static router, you can put the functions there, which either people use the most in your system, or the functions which has the highest gas overhead, like calling decimals. And this allows you to save quite a bit of gas, because just to give better explanation of this, if you combine static rotor with a counter modular, we don't get to this forward function, because static rotor now is counter modular, and that results in a quite significant gas savings. And the same approach can be applied to dynamic router. Just going to show you the code, but it's pretty straightforward. You again can have counter modeling, but here's the catch with a dynamic router, because in dynamic router we can update implementations of a function.
00:23:42.260 - 00:24:45.202, Speaker A: If you place a function like get set on the router itself, you will never be able to update it. So that is why it's rather risky and you should be very mindful which functions you put on dynamic router, because you don't want to be in a situation where a critical bug was found in the function and you can't update it. And it's just like a terrible situation to be in. And with this approach we can crunch some guess numbers. So now here we're using routers themselves as a baseline, and then they are loaded version essentially as improvement. And as you would expect, because we move a constant function from sitting behind the delegate code back on the router, it results either to 95% improvement or 97% improvement. For a constant function it results around 54 or 68% improvement for a get function which is a single S load.
00:24:45.202 - 00:25:44.438, Speaker A: And single s load function is not that uncommon as you might think, because for example erc 20 balance off function is just a single s load. And again, this function is called a lot and I don't really expect it to be changed. And then finally for a single S store operations, the savings amount is about eleven or 18%. So it's not that much, but still sizable. And looking at these numbers, my suggestion would be is to move logas function on the router if they use a lot. So this is the most best saving or just the functions you expect user to be user facing. So the functions people will use the most again as a transfer function, a deposit of withdraw or claim reward.
00:25:44.438 - 00:26:43.440, Speaker A: And then finally the pure functions which just returns the constant have the biggest impact on this. And just to give with some practical meaning, let's take a look at the two most common contracts. Essentially EC 20 token and Erc seven to one, which is an NFT. We can see surprisingly many functions of receive 20 function 20 token, such as name and symbol and decimals. In most implementations they really return a constant. Just like name is like my great token, symbol is like three letters and decimal is like 18 number, right? And in most projects really these functions will never change. And literally, if you write in ERC 20 token which has decimal functions which will return different values, I might have a problem with you, please let me know.
00:26:43.440 - 00:27:35.486, Speaker A: And even going back, even going later. So total supply, many UC 20 tokens has a fixed total supply, right? So there is again no reason for this function to be upgradable or to be sitting behind the daily jade call. And then things gets tricky. So I can see how transfer allowance or proof can be changed in the future. Maybe standards changed, but it's up to every developer you have to make call on yourself whenever your project will encounter these issues in the future or not. And the same logic more or less applies to EC 721. But these are just two common contracts I really wanted to show on them.
00:27:35.486 - 00:28:33.070, Speaker A: Kind of logic I would fall if I would build a complex system where I would just sit down and look at my contracts and look at which methods are not going to change for sure, and which are safe to put on the router itself to save the gas. And which makes the most sense because for example, at Babylon finance we had this admin model which had a lot of admin functions, but it's pretty much only us or governance we're calling them. So we really didn't care about the gas cost of it. So I was confident just putting them behind the digit call and being upgradable. And let's jump back to the code. So here you would see, once we put these functions on our routers, they do grow in size. So a loaded static router is slightly bigger than just a static router.
00:28:33.070 - 00:29:22.080, Speaker A: That's because we merged all these functions on this contract. And eventually you hit the size of how many functions you can put on your router, which we did. And that is why you also should be mindful that you have to put the functions on the router, which your absolute top priority in terms of gas. So if it's questionable, don't do it. And the same applies to dynamic router, so it's higher. But to repeat my security concern once again, dynamic router is different from static router in that sense, that if you put a function on the router itself, then it can be upgraded later. And you should be super careful doing this.
00:29:22.080 - 00:30:21.170, Speaker A: The repo is already public and it has all these examples as well as the test, which actually makes sure that all we discussed is worked. So here you can see that creating static routers is simple because it has everything encoded in it. While to create dynamic router we need to build all these modulus. So we need to dynamically fetch all the selectors for the methods. And then we create a model definition, which is an array of selectors binded to a certain implementation. And finally we can use with modulus to initialize our dynamic router with update modulus. And this is the same way you can update existing functions or add new even after the deployment.
00:30:21.170 - 00:31:07.966, Speaker A: And here we have tests to make sure that all these functions work and if you will be checking out this repo later, you can run the following command test guess report to see all the guest numbers we just looked. And speaking of these guest numbers, these numbers are produced on 0.8 solidity compiler with optimizations at on and about 200 optimizations run on. Let's get back to our presentation and that will be it. Thank you for your time. I hope you find it useful. I hope you built unlimited contracts successfully and never experienced the pain I did.
00:31:07.966 - 00:31:14.090, Speaker A: Please follow my twitter. I do post development stuff there. Bye.
