00:00:00.570 - 00:00:47.340, Speaker A: Yeah, I just had him, Leo work with Foundation, Ethereum foundation on the solidity team, doing language design work and compiler work, and also doing formal verification, which is what this talk is about. I'm going to talk about solidity's SMT checker, which is a formal verification component that gives compile time results about safety decks. So have two questions. So how many people here are solidity developers? Okay, cool. How do you feel about audience participation? Okay, cool. You asked how. So the answer is you're going to help me solve this.
00:00:47.340 - 00:01:51.998, Speaker A: So I want to first introduce what is SMT? Why SMT checker? So the SMT comes from satisfability modular theories, and an SMT solver is a tool that will take a formula like this, a first order logic formula, and try to answer this question. Can we find integer values for ABC such that this formula, when we substitute the values for these variables, evaluates to true. So we can go together over the formula just to give a little bit of context to whoever's not familiar with electrical connectives and these kind of things. Okay, so it's a boolean formula, right? It's a conjunction of constraints. So this formula kind of returns true or false, right? A boolean value. These constraints are satisfiable together or not. So first we have this part of the formula which basically says it's kind of like a function definition, right? So there's a lot of syntax abuse here, but we're going to ignore that for now.
00:01:51.998 - 00:02:44.180, Speaker A: So this says that for whatever x f of x equals x times 42. Okay. Then next we have two constraints over the input variables we chose. So we're saying that a has to be greater or equal b, and b has to be greater or equal C. And then last, we applied function f we defined before over a and c, saying f of a has to be greater or equal f of C. So now the question again, can we find integer values that evaluate the formula to true? Yes. Okay, can you give me values for ABC? No, but basically the right path f for a has to be larger than.
00:02:44.180 - 00:03:16.300, Speaker A: Yeah, so now you told me that it's possible, right? It's possible to give values for ABC such that the formula is true. Does that work? It works, right? Zero greater equals zero, true. Same thing for Bc. F of a zero f of f of c, zero. It's true, right? But unfortunately, that's not the one that I had here. Anyway, so this one works, right? Also this one works. And this one works.
00:03:16.300 - 00:04:10.686, Speaker A: How many solutions? How many different sets of values for ABC, do you think we can get for this formula infinite. Right now, a slightly different question. What happens if we change the comparison of f of a and f of c to this? And repeat the question, is there a set of values for ABC that make the formula true? So there's a consensus saying no, and that's correct. And when that's the case, we say that the formula is unsatisfiable because there is no set of values that satisfy the formula. So in the previous case it was satisfiable. Now we have unsatisfiable. And why did I choose this formula? Could have chosen many other formulas.
00:04:10.686 - 00:05:30.698, Speaker A: So the reason is we can read this formula in many ways, right? It can be just a logical formula, but this formula happens to we can also read this formula as this part here highlighted right now, being a property we want to prove about a function, right? Application of the function, that part being local constraints, say on input variables, and here basically a function definition. So this is basically how we just proved correctness of this smart contract. Here we have a function definition which would be encoded in the SMT language as the first term of the conjunction. Here we have two local constraints, right? That evaluate that are encoded, sorry, as those two constraints. And here we have the application of the function. But you will probably notice right now that in the code I have assert f of a greater or equal f of C, because it's a property I want to prove, right? And here in the logical formula that we give to the SmT solver, it's actually less than. So it's the opposite operation, right? The reason why we actually ask for the opposite is if this is unsatisfiable.
00:05:30.698 - 00:06:30.410, Speaker A: If we try to prove the negation of the property and the solver says it's unsatisfiable, this means that there's no behavior, there's no values for local rivals with that encoding that actually break the assertion, right? So in this case, the solver will tell me it's unsatisfiable, which means the assertion is safe again, because there's no way you can go through the program and break the assertion. So for all cases you can ever come up with, the assertion is true. But let's change a little bit. So is that assertion true? Is that assert correct for every input? It's not, right. So for our query to the SMT solver, we negate the property, right? So I want to find values. I want the SMT solver to give me values for my variables that actually break the assertion. So I want F of A to be different from F of C, and in this case the solver will tell me it's satisfiable.
00:06:30.410 - 00:07:35.254, Speaker A: And here are some values and this is exactly the output that solidity compiler will give you at compile time when you run exactly that code. So here we see that compiler will say assertion violation happens here for this assertion. For a one B one C one C zero sorry. So the SMT checker as a summary after the example, as you saw, it's an SMT based so we use SMT servers. So it's an SMT based smart contract form of verification framework. It's built in the compiler, which is for us one of the big advantages compared to other ways to formally verify your code. The way it works the way the approach our approach is that we encode program logic from solidity into SMT statements and use SMT server to run those queries that I just mentioned, and we use those to check for assertion failures, overflow, underflow, trivial conditions, and reachable code.
00:07:35.254 - 00:08:48.060, Speaker A: And all of that happens automatically when you run the compiler. One characteristic of this approach, which is close from the form verification community called bounded model check in, is that this approach is sound but not complete. And what that means is if it's sound, which this approach is whenever it says the assertion is safe, it is actually safe. But whenever it says the assertion is not safe. Here's a counterexample that might be not true, so you might have to verify it and see that this might have been caused by an abstraction of some unsupported features or functions, which is the case for our approach. But then bin sound but not complete also gives advantage that it's pretty fast and light compared to other approaches, and it gives useful counterexamples because it's applied directly on solidity code instead of EVM bytecode, which then you would have to map back to solidity program variables, which doesn't necessarily work. So here are some other frameworks that have been already in the ecosystem for some time.
00:08:48.060 - 00:09:40.010, Speaker A: In the EVM formal semantics side, we have ETH, Isabel and KAVM, which are KVM specially is pretty established as a really good framework for formal verification of smart contracts. It's more expressive, but it also means that it's harder and takes longer to give you proof. So these two approaches have pros and cons. Klab is a really nice debugger for k proofs, and they will have a workshop tomorrow, so make sure to check that out. For EVM bytecode verification, there are tools like Oyante, Metro and Mayan which do symbolic execution and bytecode and try to find bugs basically. And there were other projects that were translating solidity to language that were already verifiable, like y three. Fstar and Zeus did that with Llvm if I'm not mistaken.
00:09:40.010 - 00:10:32.762, Speaker A: So how do we use it? You just need one line of code right now it's an experimental feature. It's a very experimental feature right now. So if you use it, you will find internal compiler errors, you will find unsupported features and all kinds of things. But we are working on it to make it of course much more usable and hopefully non experimental one day. But then the next question is, how do I actually use it? So if I just insert this line of code there, then sure it's going to enable the run of the SMT checker, but what is actually doing? So you need, right, formal specifications, right? So whenever you prove your program safe, you only prove it with respect to specification. Otherwise you're not proving anything. So you need to specify what properties you're actually proving in solidity.
00:10:32.762 - 00:11:13.450, Speaker A: Or with the SMT checker you don't need anything extra, you use the normal require and asserts from the language itself. So requires and asserts in a compiler are translated into runtime checks, right when it's compiled to EVM bytecode. But here in the SMT checker we use them as the formal specification. So we use requires as assumptions and asserts as verification targets. So whatever conditions you write in a require, the SMT checker is going to assume it's true. And whatever you write inside an assert, it's going to try to prove. Okay, so how to use a require, actually.
00:11:13.450 - 00:12:17.898, Speaker A: So there's a lot of debate for quite a while already on requires and asserts and when to use each or what, which one means. So I just copied it, I'm going to read it from solidity docs. The required function should be used to ensure valid conditions on inputs and contract state variables, or to validate return values from calls to external contracts. So here in this example, we have a contract that has a state variable a, a bunch of functions g and h, which suppose that we don't know right now what they do, and we have this function f that takes an integer x. So here we're using requires to filter values for a and x, right? So we want for some reason a to be zero and x to be less than 100. Then we sum both, we put it in a, and then after that we know that a less than 100 is true, right, because of the requires before. So if you want to prove that the last statement should actually have been an assert and not a require.
00:12:17.898 - 00:12:45.514, Speaker A: Because a require, we're just going to assume it. And with the assert, we're actually using past knowledge to prove a new property about your code in the end of the function. So what about asserts? The assert function should only be used to test for internal errors and to check invariants. Properly functioning code should never reach a failing assert statement. And this is really important. If this happens, there is a bug in our contract which you should fix. Same example.
00:12:45.514 - 00:13:27.640, Speaker A: Now just using asserts everywhere, can we assert a equals zero over there? Very likely not, right? Of course it depends on what g and h are doing. But if we don't really know what it's doing, we cannot say assert a equals a because a can be whatever, right? And especially for x here, if you say assert x less than 100, it's a public function. So anyone can call this function with x equals to 100. And your assertions are already wrong. Right. So this is really important to notice. Like you should only assert things that you're really sure are true at that moment for every single execution path that reaches that point.
00:13:27.640 - 00:14:08.658, Speaker A: And here the assertion is correctly placed at the end because it's a new property. You're proven. Yeah. Does that checker use modular verification? Will you assume that any value. Yeah, at this moment, yeah. So for example, when you have, I'm going to talk about this later, but if you call an external function, for example, which you don't have control over or don't know the code, then when a function comes back, we have to reset all knowledge about state variables, right. Because you might have this contract you called, might have called your contract back, which changed a.
00:14:08.658 - 00:14:49.726, Speaker A: So you can't really keep the knowledge about it. But modular verification, one of the research goals that we have is to actually infer properties from different functions and see what state invariants we can come up with automatically. This is not done yet, but it's on the to do list. What about false positives? So I mentioned earlier that the approach is sound. So if it says it's safe, it's safe, but it gives false positives, which is basically false counterexamples. So your assertion might be correct and safe, but the tool says it's not safe. Why does that happen? It happens because we have to abstract the encoding sometimes.
00:14:49.726 - 00:15:39.642, Speaker A: So for example, for complex types and functions, say like cryptographical functions, our approach is not expressive enough to actually implement it. So we have to use symbolic variables on the application of the function, and that's as far as it gets. So we don't really know what the actual value of the function call is going to be. So these abstractions might lead to false positives. Also, if you call external function, if you call external functions, we do clear the knowledge after the call, after the function call. So it might not have been the case that state variable a got rewritten, but you never know. So to be safe, again, we have to clear the knowledge.
00:15:39.642 - 00:17:06.060, Speaker A: Also with contract state invariance, you as a developer of the contract might know that certain properties are valid throughout your contract, but the SMT checker is not yet smart enough to deduce those properties automatically. And one point that I wanted to mention in this talk is you can actually help the SMT checker, you can help the tool to actually find the proofs, and it's a very simple way to do it. You can flood your code with requires, so every assumption, even very simple things that you know are true at that point, even if it might sound redundant to you, it might help the solver, because the more constraints you give the last false positives the tool is going to issue. So I'm going to run a couple of examples right now. I think I have like eight minutes. Can everyone read? Not in general, but the screen what I did push. Yeah, when I started this one.
00:17:06.060 - 00:18:04.442, Speaker A: Okay, so this is like a very tiny token and not very interesting. So we have a map in with balance constructor initializes the balance of the message sender with a bunch of tokens, and accounts can transfer tokens to each other. Right? So there are a few lines, a few extra lines in this piece of code, right, compared to normal token implementations. So first of all, this is a normal one, right? We require that the message sender actually has the amount in their balance, but here I'm actually storing the old values for the balances for the person sending the transaction and the person receiving. And yeah, the person received the account receiving the amount. Here the balances are updated. Right? And here you have an assertion that says that the sum of the balances before the operations have to be equal, the sum of the balances after the operation.
00:18:04.442 - 00:18:42.620, Speaker A: Oh, sorry. Yeah, this should be the right assertion, but I wanted to break. Okay, so here the compiler tells us the assertion is broken and gives a bunch of values for our variables, right? But there's something weird, right? So it's saying that it gave zero to both two and message sender, which commonly people prevent. Right? So we can just add that here. I want message sender to be, oh, this is actually not going to work. So I'm just going to say that they have to be different. It's fine if there is zero.
00:18:42.620 - 00:19:28.440, Speaker A: Okay, now it changed, right? So two went to one before it was zero. Master sender, still zero, but that's fine because they're different. And the assertion is actually saying that the balance before was greater than the balance right now, which means that some tokens vanished. Right? So the assertion is basically saying every time there's a transfer, tokens vanish, which hopefully is wrong, and the tool set is wrong. Can see balance from plus balance to is actually the same as balance of zero plus balance of one, which are the accounts. So if we actually fix the assertion. There you go.
00:19:28.440 - 00:20:01.266, Speaker A: If it doesn't comply, it means it's safe. I'm going to move on to a slightly better example with a bunch of false positives. Oh, not this. Okay, so here we have, yeah, this contract. See, this external contract doesn't matter. For now, I'm going to remove it. Oh, sorry about that.
00:20:01.266 - 00:20:46.420, Speaker A: It's not the one. I want to show this one. So we have just like kind of an account that has some, it stores the balance, its own balance, and here it counts how many transactions, how many times. The fallback function was called increasing the value, increasing the balance of this account. So here we have the fallback function that says that the value stand has to be greater than zero. And this is just to give a constraint and avoid overflows later, requiring that this account cannot have more than 1 million. The balance cannot be greater than 1 million.
00:20:46.420 - 00:21:56.640, Speaker A: So here we just increase the sum and increase the count, right? And here we have a function called average that computes the average value that was sent per transaction. All right? So here I put this required, because if there was no transaction, doesn't make sense to compute the average. But here we have an, so here we compute the average, and we assure that the average has to be greater than zero, right? Because if you did have a transaction, because of this line, we don't count zeros in a transaction. So the assertion is true. Agreed. Okay, so it's telling us that the assertion is actually not true and gives some value. So it says that if count is one and sum is zero, then the average is zero, which is correct, right? But then the question is, can this ever happen? Can it ever happen that count is one and sum is zero.
00:21:56.640 - 00:22:23.720, Speaker A: Why? Exactly. So message value is an integer, right? With this require, we're saying message value is actually at least one here, and count only increases by one. So this property here is true. Right. It's an invariant. It's true, like, at any point of the contract. Right.
00:22:23.720 - 00:23:00.606, Speaker A: But it's hard for the SMT checker to figure that out on its own. And that's what I meant with you as a developer of the contract, know these kind of things, and you can help the SMT checker by adding those invariants whenever you have these harder checks. Let's see. Okay, now it's fine. So I have one last example, which was the one that actually closed here. Yeah. It's the same contract, just with the extension that we have this external contract, and we call some function af in external contract.
00:23:00.606 - 00:24:18.346, Speaker A: And what happens here is that when we call the external function, the knowledge gets basically erased, and you would need to add new constraints after the function call. You maybe even need to repeat constraints in order to help the solver to actually prove it and not get false positives. Yeah. And one last thing that I wanted to say is future plans that we have for the tool. Yeah, we have more examples, and I'd be glad to talk about the tool more offline if you guys want to talk about it as future plans. We have what I mentioned, which is this sort of function, modular verification part, which is kind of involved with the state invariant automatic deduction, which is a very hard thing to do, but we want to try it anyway. And also, one other thing we want to introduce rather soon is actually the ability to let developers give this invariant.
00:24:18.346 - 00:25:04.474, Speaker A: So something like, you could write something like declare your invariant, and this would be one of them. And with this invariant, this invariant would be applied as a require in the beginning of every function and asserted in the end of every function. In the end. We could even use that to get inductive proofs and, yeah, just give more power to the SMT checker and actually get harder properties proven anyway, even though they're pretty hard. So, yeah, open for questions. Not sure how much time there's left. Yeah, no time left.
00:25:04.474 - 00:25:09.340, Speaker A: So we can discuss offline. Time is gone. Thank you.
