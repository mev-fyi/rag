00:00:15.610 - 00:01:12.766, Speaker A: Welcome everyone. We're about to kick off. We're going to be conducting today for your very guys a competition in golf. Around the golf, you might say, that will also be formally verified. So we'll be writing smart contracts in whatever language you prefer, and you'll submit your contract to our CI server, which will run a suite of formal verification proofs against that bytecode. And if you do manage to pass our spec so you have an approved correct contract, then there's a competition for making the most gas efficient such contract. And in particular we'll be doing it today with an ERC 20, since this is the one with the most straightforward specification.
00:01:12.766 - 00:02:35.902, Speaker A: Of course there's some caveats on what the specification actually looks like, and we've made a little bit of an opinionated choice here, but we'll go over that in return. So when I said that we'll be doing a competition, I actually meant we'll be doing two competitions at the same time. Namely, there's this EVM golf competition that I just described making the most provably correct ERC 20 implementation. But there's actually a second contest going on behind the scenes. And if you're feeling like the first one might not be too much of a challenge for you, or if you're thinking that formal verification is just a sham, then you can participate in the second competition which asks you to submit bytecode that has some sort of bug in it, but it still passes the specs somehow. If you believe that the specs and the methods that we have created with the formal verification process that has been set up, then you can try to fool it and you can try to submit bytecode that passes those specs but are otherwise faulty in some way. I mean, it's hard to define when there's no longer a spec to talk about, but I'm sure we'll be able to figure something out.
00:02:35.902 - 00:03:41.490, Speaker A: So you'll be able to compete in both of these competitions, and we'll get to the details soon enough. First, I'm not going to be talking too much about the theory behind what we're doing today, because we need to have time to actually do some hacking. But let me just mention that the proving methods that we're using here for this workshop are going to be using the K framework, and we'll be writing our specs and looking at our specs written in the act smart contract specification language. We'll get into it. Okay, so let's get deeper into the specification. I'll come over to the other side. So sometimes people say that an ERC 20, ERC 20 specification, as if it is some sort of certification.
00:03:41.490 - 00:04:32.842, Speaker A: It's really not. It's more of an interface that really just tells you what the methods should look like in your contract and doesn't actually say anything about the behavior. Of course. I mean, we have some intuition around what this should be, but there's actually a whole range of different kinds of behavior of different CRC 20 tokens, and it gets kind of annoying when you start dealing with them. And you have to check whether this particular EC 20 actually did return a boolean at the end of its transfer function, or what's happening in the case where you're sending to the zero address, stuff like this. So in order to actually have a specification, we need to make a choice on all these decisions. And let me present our choices.
00:04:32.842 - 00:05:53.706, Speaker A: But before I do that, I, I'm going to show you the language in which we're presenting these choices. So this is our specification format that we have developed in order to be a literate language that should intuitively make sense, uses common mathematical words, and we have created it in such a way that from a small specification like this, we should be able to generate a suite of reachability claims. So proof obligations, essentially that you can port to right now only cable. There are more back ends that we're planning. And so let me show you how this works. On the left hand side we have the specification in the access language, and on the right hand side we have a simple function, a simple transfer function. So what we do is, well, actually, let me go and just say the main claim of the specification is in this storage header.
00:05:53.706 - 00:07:02.180, Speaker A: So under the storage header we're saying how the balances of the people involved are being updated. So we're saying that whatever their initial balances were from Val and Tupac, they're going to be updated with a corresponding value as a result of calling the transfer function. Okay, but this doesn't always happen, because there are some scenarios where you do call the transfer function and your balances aren't updated, namely if you don't have enough money to send, or if there is an overflow when you're trying to add the value to the receiver. And so this should be reflected in the spec. And here it is, we see that there are actually four conditions associated with this particular act, and the first three are associated with an if and only if header, or this ifs. And that means that in the two specs that are going to be generated, or the two reachability claims, or two proof obligations that are going to be generated from this.
00:07:03.910 - 00:07:04.660, Speaker B: Act.
00:07:05.530 - 00:08:08.558, Speaker A: We are going to assume all of the conditions in the if and only if header to be true in the past case and to be false in the failed case. So what? The nature of that claim is that it amounts to saying that only if in the case where we are still within the range of a u into 56 bit word, then these storage updates should be performed. And when any of these conditions are not met then we should be in the fail case. And the fail case asserts that everything must revert. No storage updates are to be performed. But there's another type of condition that we can make in an act and that's the if header. The conditions in the if header are assumed in both the fail and the pass cases.
00:08:08.558 - 00:08:51.110, Speaker A: So obviously this restricts the nature of your claim. It makes it slightly weaker by assuming additional assumptions. And so if you have an if editor like this, you must have a corresponding next spec that assumes the negation of that if editor. So in this particular spec we're saying that the caller id should be different from the two, meaning that the sender should be different from the receiver. Because we have to treat this case somewhat differently. I mean, we actually then would only be referring to a single entry in the storage rather than two separate modes. So we need to write that spec a little bit differently.
00:08:51.110 - 00:10:13.610, Speaker A: Then during the course of this competition we'll be making, we have a suite of these spec that we'll go over soon enough and they will generate these proof obligations. And your bytecode will be associated with that proof obligation. And the proof will be run on our CI machines. And after they have been run, if all of your specs are passing, if all of the proof obligations have been proven, then we will be taking the execution traces. So the method by which we're proving things is through a symbolic execution that gives you a complete exploration of the possible things that could happen through the execution of this method and through this execution trace, we're able to walk down all of the branches and look at the final result in the gas, the final gas result, so the final gas consumed by this method in each branch. And when we do this gas extraction, we take the maximum value. So the worst case scenario calling this function, and this is going to be your value that you're competing with.
00:10:13.610 - 00:10:54.110, Speaker A: So we get a symbolic expression like this. If you know your evm, then you know that whenever you do a storage update, what actually determines the cost of that has to do with whether the storage that you're updating was zero. Or whether you're putting it to zero. And so we'll see conditions on this form when they are the most general. But of course you can take the worst case scenario, and this is what we'll be using. Okay, so with that, let me just say how this will all go down. As I said, all proofs will be running our service.
00:10:54.110 - 00:11:39.050, Speaker A: You don't actually need to do much yourself. Of course, if you're interested, you can come and chat to us and we can talk about it. But for the purposes of this competition, the only thing that you need to do is to write an implementation, get the bytecode of that implementation, the runtime bytecode, and make a pr to a repo that we'll be showing you soon, and everything that is provably correct will be analyzed for gas. Okay, so I think it's time to go over the specs. They can be found at this repo, which is the repo we'll be working with. It's GitHub.com erc 20 golf.
00:11:39.050 - 00:12:16.898, Speaker A: And as I mentioned, there were some opinionated choices we made while making this spec. Well, the first one or the most important ones are listed on this page. Will not be caring about logs. So you can forget about logs for your implementation. For the purposes of this contest, everything must revert if call value is greater than zero. So this is following the convention of both Viper and solidity. This is actually true with a minor caveat.
00:12:16.898 - 00:13:34.180, Speaker A: The storage location, the way that the EVM deals with the storage under the hood is a simple key value mapping of integers to integers. And so, in order to translate the variables that are being used in near c 20, like balances and total supply and allowances, you need to place these at a particular location of these integer transitory mapping in the UAM. And there's a convention for how you do this. And the most crucial thing to know here is how do you make sure that you need to encode basically the balances and the allowances mappings in a particular way. And this is a particular hashing scheme that solidity uses in order to make sure that whenever you look up the balance of a particular address, you won't have any collisions with any other address in the balance. So we can go over those details if you want to, but you can actually also use the Viper convention, which is extremely similar. It hashes the arguments in the same way, but only in a reverse order.
00:13:34.180 - 00:14:20.000, Speaker A: But if you're using solidity or viper to write your contract, this will be of course done for you. As a final opinionated, choice. If the allowance of a particular person with respect to some executor is the max possible un, then transfer from should not decrease the allowance of spender. Okay. And all the submissions are due at 1225. Let's go over the specs. Would you like?
00:14:21.090 - 00:15:12.510, Speaker C: Sure, yeah. So I'll demo the specs for you and also how the CI server works and cover in detail everything you need to know to participate. Can you see the screen? Yeah, of course. Is the size okay? Can I make it a bit bigger?
00:15:24.530 - 00:15:26.486, Speaker B: Hey, cool.
00:15:26.668 - 00:16:23.778, Speaker C: So first I want to show you the structure of this repo. Has everyone been able to find it? First of all? So we're looking for this repo on GitHub server, hopefully has it. And I'm going to show you first just the structure of this. So we've got in here a readme, a configuration file that you don't need to worry about, and the most important stuff is in this source directory. And here, firstly, we have our specs, which is spec MD, and these are the specs that Martin was referring to. This is written as a markdown file, and it's got these specs that will be tangled out of it. You do not need to edit this because this is the part that's given to you for targeting, but you do need to read these if you want to write implementations that will actually pass to make sure that you understand all of the nuances.
00:16:23.778 - 00:17:24.906, Speaker C: Hopefully not too many nuances, but there are some. So Martin has already covered how these specs look, but I'll maybe just pick another one and quickly go over any other features. But the idea is you want to read these, and these interface lines correspond to the familiar ERC 20 interfaces. And we use the solidity or the Ethereum contract ABI for computing interface selectors from the call data, which is, I guess, assumed. But basically what that means is that if you're writing the total supply function, that means that the force four bytes of the call data have to be the shot three of this string. So it has to be something like this. So just keep that in mind in case you were wondering how to write this.
00:17:24.906 - 00:18:28.826, Speaker C: Of course, if you're writing it in solidity or Viper, then this is done for you. So I think hopefully these are pretty readable, and the best way to address any difficulties would be when we get to the practical part, if you raise your hand or just say something and we can discuss the meaning of these specs. That's not clear, but I hope these are pretty readable. So you can see for example, the convention with the return values is here in this last line. The bottom means you return one when this thing is successful. So now I want to show you actually how to run this with your own zero implementation. So if you go back to the source directory, you'll see some other files, and the most important one for you to edit is this file bid runtime, which contains the runtime bytecode of your submission.
00:18:28.826 - 00:18:44.500, Speaker C: And you'll see that there's already one in here, which is the sample one that's provided. This is coming from a basic solidity implementation, the source of which is available or where is it available?
00:18:46.330 - 00:19:08.154, Speaker A: It's in the repo, in the main kind of directory. So if you go up the level, yeah, that's okay. So this is like the par that you can compare yourself against in the competition, and it also assists you if you find these specs hard to read. Then you can simply read the solidity and then get a handle on what's going on.
00:19:08.352 - 00:19:30.706, Speaker C: So to be clear, this solidity that's in the root of this git repo passes the specs. So your thing needs to be behaviorally equivalent to this. So this is one way to check. And except for the constructor, which we will not be verifying, you don't need to worry about how this contract is deployed. You only need to worry about how.
00:19:30.728 - 00:19:32.690, Speaker B: The state transitions once it's deployed.
00:19:34.950 - 00:19:35.266, Speaker A: Right.
00:19:35.288 - 00:20:25.970, Speaker C: So going back to this, what you need to do is put your bytecode into this file. So you can delete this file and then output your own bytecode into it. And I think you're actually allowed to because you'll see in the repo, in the readme this repo. Here's how you would do that with you can also use cell C to output Yule, to consume Yule and output evM bytecode. And these are the instructions for Viper. And maybe you have your own funny tools that you want to try. And actually, apparently it's allowed to have this header, but it's not necessary.
00:20:25.970 - 00:21:24.950, Speaker C: So just simply having the hex in here as ASCII is fine. I don't know how salsa you will have. So now I will show you how this gets processed. This is enough work for the repository. So what's going to happen when you submit a pull request where you've edited this in runtime file is our CI server will automatically pick up the pull request and it's going to run the K framework prover using the specs generated from the root API language against your byput. And then after that execution is done. Here's an example where the CI is running.
00:21:24.950 - 00:22:38.586, Speaker C: When this execution is done, if you had a successful proof, all the specs, all the reachability were successfully proved, it will actually do a symbolic analysis of the gas along all these execution traces, and it will calculate, as Mark said, the maximum gas consumed, and then there will be a report produced. So here, once you want to track your progress, you can go to Dap CI ERC 20 golf. And here, for every pull request this repo, there will be a hash, which is your entry. And you can see here, the last one was 1042. And if you look on the right hand side, you'll see that there are 16 specs in total, and 16 of them were accepted, meaning that this is a correct implementation that's been formally verified. And now if you click on this link, well, you'll be able to see an overview of how everything passed. But also, very importantly, you'll see next to every passing behavior you'll see here on the right, you'll see gas and gas analysis.
00:22:38.586 - 00:23:22.794, Speaker C: So, I want to show you these. So, gas is a bit technical, but this is the K term that we've extracted from the symbolic execution that represents the state of the gas at the end of every execution of this function. The, that's a bit complicated is because there's going to be branching in here, and it's going to depend on the state of the call data. But that's a little bit hard to read. But the thing that the submission will look at, or that the contest will look at, is the gas analysis. So if you click that link, you'll see that we have actually. Can you guys see this? So basically what this is showing is that this balance of that this balance of function is actually going to consume 530 gas in every case.
00:23:22.794 - 00:24:05.286, Speaker C: This is actually a very simple example. But now, if we move on to something a little bit more complicated, like this transfer function, and we look at the gas analysis for that, it's a little bit more complicated. So here you can see the first thing is the tree. So that's actually the gas. In all the cases, you can see that it's conditional on the starting balance and the ending balance. And then if we also compute the minimum and the maximum gas used, and your contest entry is going to be the maximum gas used, and we will completely ignore what happens in cases where your execution is supposed to revert. So if someone is over underflowing or they're not approved or something like that, we don't care how much gas is used because the user made an error and we're not going to try to save them any gas.
00:24:05.286 - 00:24:58.394, Speaker C: So you can do whatever you want in those cases, provided you. So I think this probably gives you everything you need to get started. So we encourage you to get started as soon as possible because it'll take about 15 to 20 minutes for these executions to run in the CI. We can run a few in parallel, of course, but to increase the chances of your submission executes by the end of the workshop, please submit it as soon as possible. And don't worry about getting the absolutely best implementation you can because I think simply getting something that makes some improvements over solidity will already give you a good shot. And the goal is to have fun and learn something. And of course we can continue playing for the next couple of weeks or months if you want to continue to get it down.
00:24:58.394 - 00:25:47.894, Speaker C: So just to make this workload completely clear what you need to do, I'm going to just quickly make a submission to this thing to show you. So here I'm in the ERC 20 golf repo, and let's say I want to make an optimization to the bytecode. And in particular I'm going to use a tool. I'm going to use a tool very nice called SED, which stands for solidity enhanced deployment. And what's really nice about it is it actually comes with most Unix systems, and solidity actually uses this to implement its compiler optimizations. In fact, most of the compilers implemented this is the state of the art way to work with optimized bytecode. And I'm going to apply a trick.
00:25:47.894 - 00:26:55.810, Speaker C: The syntax is a little bit arcane, but this is a really powerful tool. So for example, if you do a push zero in the EVM, what that does is it puts zero on the stack and that costs you three gaps. But in this particular case, because we're in this non payable regime where you're not supposed to send any value and otherwise it's going to revert, we can actually know that most of the time the call value is going to be zero, but the call value opcode only costs two gaps. So we can actually, every time we need to push zero, it could be quite a few times because that's quite a useful number to have. We can actually replace every occurrence of push zero with call value off code, which I'm going to look up here in my little cheat sheet is actually 34 in hex. So if we do this to the bytecode, that should actually implement this one of pretty sophisticated compiler optimization. So now you'll see that we've actually changed bytecode in some way and I can actually commit this and make a pull request.
00:26:55.810 - 00:27:18.360, Speaker C: Now you just go up here. Now of course you'll make the pull request on your own fork or whatever.
00:27:22.090 - 00:27:23.240, Speaker B: Just go through.
00:27:26.970 - 00:28:09.242, Speaker C: So once I, once I click create full request here, it's going to get hopefully picked up by the CI straight away. And then we can start verifying and see how much gas we saved from implementing this solidity enhanced deployment optimization. Great, it's already running. And if I go to this website, which again is DAP CI DRC 20, which is a nice dashboard for viewing these builds, you'll see that there's a new one. There's a new one at the top. You can see it says running 16, so none of them have been accepted yet. It's going to take a little while.
00:28:09.242 - 00:28:50.134, Speaker C: Form of verification is expensive and slow, but you'll see these gas analyses coming in as these groups happen in the next 2 minutes. Probably the first one will come in and also coming in so you can see how you're doing. And hopefully it'll take under around 15 minutes to complete all of them. And then this will be the first submission. And I challenge you to see if you can beat this one using any tools of your choice. Even an easy way place to start is to apply some of these manual kinds of bytecode optimizations. You can also try writing self c with the optimized flag because the included submission was not compiled with that.
00:28:50.134 - 00:29:21.230, Speaker C: So that should already give you some pretty good savings. And then of course writing it in raw ADM or Yule or whatever you like will probably give you even more. So I think that's it, and I think it's a good time to start working. And please, because this is a workshop, the idea is you're supposed to ask questions and we might help you understand the spec language or this tooling. So please don't hesitate to engage with us and your neighbors.
00:29:22.550 - 00:29:26.162, Speaker A: Are there any immediate questions? Yes.
00:29:26.296 - 00:29:27.220, Speaker C: Is there.
00:29:29.030 - 00:29:32.930, Speaker B: Starting gas at the time function starts?
00:29:36.150 - 00:29:52.780, Speaker A: Yes, the dispatch and all that is included. None of the deployment is included, so the length of the bytecode doesn't matter. But everything that happens from pc counter one until a return is accounted for.
00:29:56.110 - 00:29:57.740, Speaker C: Any value.
00:30:01.710 - 00:30:04.620, Speaker B: Valid storage value.
00:30:06.830 - 00:30:25.330, Speaker A: Yeah, so exactly like storage could be anything, but I mean the storage locations that you'll likely be working with are the ones that come from the mapping of balances and allowances.
00:30:27.830 - 00:31:14.370, Speaker C: Sorry, there's one really important thing that I missed, which is to do with storage thing thanks for bringing that up. So I mean, one of the ways that in general you can try to optimize storage is by packing things together to try to use that storage or something like that. And regardless of whether that would be a good idea for an ex 20 token, that isn't really compatible with our approach here, because what we're formally verifying actually needs to specify exactly where the storage lives firstly. And secondly, the semantics of your contract actually change if you start to reduce the size of the integers that you're using, because you'll start to overflow in situations where you otherwise wouldn't have. So that's not really going to work. And in particular, you actually need to look at one more file in this repo, potentially depending on how crazy your purchase, which is a storage md. This is the storage specification.
00:31:14.370 - 00:32:02.738, Speaker C: And if you're just using solidity to Viper, then all you need to do is follow the subordinator of the storage layout that we gave as an example, which is balances total supply and allowances. So as long as the variables are declared in that order, they'll be put in the right places. But formally, what's actually going on? And if you're using a more low level approach, then it's actually mapped out in this file. I hope that probably if you're going to do something like this, then you already know how splitty places its variables. Otherwise it's going to be a few things to learn. But for simple variables that aren't mapping like the total supply, they're just going into the slot number that corresponds to starting from zero and then the order that the variable is declared. The total supply, for example, lives in slot one.
00:32:02.738 - 00:32:29.770, Speaker C: So if you want to store the total supply, you just do s store one and then the supply. While mappings like balances and then two deep mappings like allowances are a bit more complicated. They're computed using hashes. And there's actually two different conventions. As Martin said, there's solidity to Viper and they hash things in the opposite order. And by default this file is going to be configured to use solidity order. So this is why it says solidity here.
00:32:29.770 - 00:32:58.440, Speaker C: And if I wanted to use Viper instead, what I would do is you need to actually replace this with Viper, and then we're going to hash things in the opposite order. Now for the details of how it's actually hashed. I think the best thing would be that if you're interested in experimenting with this, is that you raise your hand and one of us will come and show you to make sure that it's correct. Just because maybe most people aren't interested in that, it's not worth spending 5 minutes explaining it right now.
00:33:00.170 - 00:33:02.710, Speaker B: Allowance owner.
00:33:05.450 - 00:33:18.086, Speaker C: Allowance is like. Yeah, I think the easiest way to remember source destination. So owner and spender is also correct. Okay, so then let's get started. And if you have a question, please raise your hand.
00:33:18.108 - 00:33:21.120, Speaker B: Or just it.
00:34:32.550 - 00:34:56.058, Speaker C: Just one interesting. One interesting piece of information. So this one that I tried with said to replace 60 zero with 34. It actually corrupted something, and the formal verification just came back negative. Very bad. Very bad results. Don't try this one.
00:34:56.058 - 00:35:06.640, Speaker C: You will be wasting your time. So I would say this is success for formal verification. Maybe a bad day for.
00:35:09.810 - 00:35:11.402, Speaker A: Did all of them fail?
00:35:11.546 - 00:35:34.870, Speaker C: No, actually, just one. Well, the way we set it up is the first failure causes it all to all to stop, so not to waste time. So it looks like the transfer from function fails. Nothing actually passes before that fails pretty quickly. Again, if that's your cup of tea, another thing interesting to investigate would be to figure out why this optimization is unsafe, maybe how to make it safe.
00:36:00.770 - 00:36:02.000, Speaker A: Works or not.
00:36:13.890 - 00:36:41.120, Speaker B: Again, it's, um.
00:36:56.770 - 00:36:58.210, Speaker C: You want to bring the good luck?
00:37:03.510 - 00:37:08.038, Speaker D: I'm not sure. I haven't taken. I only took a small break to.
00:37:08.044 - 00:37:11.126, Speaker B: Get this, so I don't know when.
00:37:11.148 - 00:37:22.840, Speaker D: I'm supposed to take lunch. Yeah, I can ask for someone to cover.
00:37:27.210 - 00:37:28.920, Speaker B: How dare I contact you?
00:37:29.970 - 00:38:01.480, Speaker D: I should. Do you have a slot? Yeah. Typing could search by my username Archer four one five. Yeah, right there. Okay.
00:38:02.250 - 00:38:03.160, Speaker B: I don't think.
00:38:10.570 - 00:38:13.960, Speaker D: Yeah. Oh, yeah, I'll be there. The party. Okay.
00:38:14.410 - 00:38:46.120, Speaker B: Thank you. So only.
00:39:02.410 - 00:39:02.886, Speaker A: Sort of.
00:39:02.908 - 00:39:05.350, Speaker C: I have no idea how to optimize for gas.
00:40:25.210 - 00:42:16.120, Speaker B: Just kind of growing out and then used the existence. Your grand first building security. We do the. That's like the most.
00:42:51.730 - 00:42:53.680, Speaker C: 914 four.
00:42:54.890 - 00:43:10.310, Speaker B: It's.
00:43:20.450 - 00:43:20.814, Speaker A: You.
00:43:20.852 - 00:43:29.280, Speaker B: And. But you're still watching.
00:43:36.130 - 00:43:36.880, Speaker C: Yeah.
00:44:35.850 - 00:44:51.880, Speaker B: Questions or even for any check?
00:44:52.970 - 00:44:53.720, Speaker A: Yeah.
00:45:49.890 - 00:45:50.960, Speaker C: Bigger than.
00:45:54.850 - 00:47:45.230, Speaker B: 8008 silent.
00:47:47.110 - 00:47:50.370, Speaker A: So I guess you would want one test that exercises.
00:47:55.370 - 00:48:03.720, Speaker C: How many? I'm kind of surprised it didn't take.
00:48:07.210 - 00:48:38.560, Speaker B: No dysfunctional functional branch point right now. Functional branch point to a certain branch range. I don't know. But.
00:48:56.890 - 00:49:22.640, Speaker A: We got a new submission, which is solidity run with the optimizers flag, which comes in, clocks in at exactly the same amount of gas as solidity run without the optimizer flag. So the solidity didn't actually run any optimizations here. But we do see that the metadata is different. So this could have changed something, but it didn't actually change any of the relevant semantic code.
00:49:23.430 - 00:49:41.880, Speaker C: Try with more optimizer runs. No, the default means you run it. It assumes you like the piece of 200 times. So it probably just tries to reduce the size of your bytecode, reduce the deployment cost. That's how it works.
00:49:44.170 - 00:49:49.320, Speaker A: No, I mean the bytecode identity of up to the very last.
00:49:56.170 - 00:49:59.560, Speaker B: Time just happened.
00:50:00.370 - 00:50:01.120, Speaker C: Yeah.
00:50:41.130 - 00:50:47.254, Speaker B: Which one? Yeah.
00:50:47.292 - 00:50:47.542, Speaker C: Yes.
00:50:47.596 - 00:50:50.620, Speaker B: You guys here? Um.
