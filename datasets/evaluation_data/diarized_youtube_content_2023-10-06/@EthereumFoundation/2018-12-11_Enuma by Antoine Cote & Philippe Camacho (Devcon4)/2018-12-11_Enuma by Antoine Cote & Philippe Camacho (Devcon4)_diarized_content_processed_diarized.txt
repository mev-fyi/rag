00:00:00.250 - 00:00:11.550, Speaker A: You. I'm Antoine. This is Philip. We're from Enuma Technology. Enuma is an engineering company. So basically everybody in the company is. Is a developer.
00:00:11.550 - 00:00:54.490, Speaker A: We've been around since 2015, worked on different blockchain projects way back. We started with bitcoin, multichain, Ethereum, worked with different blockchains. So we got a grant from Ethereum in May to work on sprites payment channels. So I'll show you what we've done here. And we've also been building kind of like after we've done the work on sprites, we started working on decentralized exchange and how we can make them more performant. Because I don't know if you've used the decks that are available out there today, but a lot of them are really slow. You have to wait a while for your transactions to be confirmed.
00:00:54.490 - 00:01:19.990, Speaker A: So we're trying to solve that problem also using state channels. Let's see. I would have done it live, but I was having some problem with the Wifi. So I recorded the demo just about an hour ago. Here, just to show you. This is the sprites demo. So what we have here is on the left side is a merchant website.
00:01:19.990 - 00:01:50.270, Speaker A: So imagine you're going to the convenience store and you want to buy like, I live in Hong Kong. In Hong Kong we have this card that I can top up with money, go to the merchant, swipe it and buy things. So that's my merchant website. I think it has not paused. So I can select some items. And we're using the Dai stable coin here because I don't want the price of my PEPC coke to change day to day. So I select some items.
00:01:50.270 - 00:02:29.730, Speaker A: So 1.6 die and then click on checkout. So I get a QR code and then using the application, this is on my iPhone, I'll tap to log in and unlock my wallet. By the way, we're mostly a back end engineer, so sorry for the UX. If anybody here is talented in UX, we're hiring. But this is mostly a dev demo to show that you can connect to the channel. Then the balance will show up and the history of transactions.
00:02:29.730 - 00:03:01.842, Speaker A: Then I'll click on make payment, scan the QR code, it's very fast. And confirm that payment to the merchant. And then it says payment successful. The merchant should see the balance of 1.6. So by the way, here there's like three parties involved. So there's the end user going to the shop, there's a payment provider, who's the middleman? And then there's a merchant. And where sprite comes in is that we use the conditional payments so that I can pay the payment provider.
00:03:01.842 - 00:03:48.550, Speaker A: The payment provider can turn around and give the money to the merchant, and then that payment is done once I reveal the pre image, and then the merchant can at some point decide to withdraw, which actually does. This is where the unchained transaction comes in. Typically, the merchant would withdraw maybe just once a day or once every few weeks. All the other transactions are done at L2. This part was just to show the blockchain transaction id, actually. And I'll pass over to Philip to talk a bit about what we've done since with decentralized exchange.
00:03:50.250 - 00:04:31.410, Speaker B: Thank you, Antoine. Hi. So, as Antoine mentioned, we are also working on secure decentralized exchange. And we've been working on this since a few months. And our initial approach was to use these payment channel year two techniques with the idea that all the user would be part of a network and create channel between each other and then be able to exchange tokens. Right. And after analyzing this and trying a lot, we realized that there are many shortcomings to this approach.
00:04:31.410 - 00:05:27.458, Speaker B: For example, if you use these payment channels in general, you need to have collaterals in order to ensure that the payments go through. Then, okay, we need to build this network. But how do we do this? I mean, it's not easy to build a network. It's not only about cody, it's about incentivizing users to join the network, and so on and so on. So we had more questions than answers. And also there are like technical challenges, like, okay, we have plenty of orders that are spread across this decentralized network. How do we match these orders? Who is going to do that? So after thinking a lot and banging our heads on the wall, we decide to step back and think again about the problem.
00:05:27.458 - 00:06:01.194, Speaker B: Right. The problem when we build an exchange is that we want to avoid to be the next empty Gox. So what does it mean? It means that if we want to avoid that, users should be always in control of their assets, their token. So having a decentralized network is a way to achieve this. But maybe there are other solutions. And that's why we end up with this concept of trustless exchange more than decentralized. And the nice thing is that we get kind of best of both worlds.
00:06:01.194 - 00:06:07.170, Speaker B: We have first something that would be more like hub based. I didn't put centralized because it's.
00:06:09.270 - 00:06:09.586, Speaker A: A.
00:06:09.608 - 00:07:21.720, Speaker B: Word you want to avoid, but it's the idea that we have a coordinator that would take all the orders, match them, and update the balance correctly, but at the same time, it would be trustless. And if we have these both things, we can be both efficient and secure. So at the very high level, how would work? Well, we'll have this hub that will take the orders and match them. And from time to time, it would synchronize the blockchain to ensure that all the balances have been updated correctly, and users will use the blockchain only to deposit and withdraw, and all the rest will be made through the hub. So, yes, there's still quite some work to do on this, in particular, analyzing the security in detail. When you build a new protocol, you need to verify, be sure that there's no flows and problems, and also being able to implement the feature of an exchange like atomic swaps and partial order. And now Antoine is going to show a little demo of what you have so far.
00:07:23.770 - 00:08:14.870, Speaker A: Thanks for that. Yeah, the demo may not look so impressive, but what we've done is we've implemented all the theory of how at L2, an exchange would be done, atomic exchange, completely trustless. And so what's missing from the demo would be the on chain part, like depositing and withdrawing at the end. But just to give you an idea of how this would actually, some of the code we have, like, we actually create an exchange object, we create multiple different trading pairs. There's two parties involved here that are going to deposit money in the channel and then trade with each other. So they do create order objects. And then these orders are being matched, and each order, you see, when I place an order, the order has to be signed by the first party.
00:08:14.870 - 00:09:06.546, Speaker A: And then to take an order that's been placed in the order book, I also have to sign. If you're interested, come see us after. I'll give you all the details. But when I run it on my old MacBook, this is a 2015 MacBook, we take advantage of all the cores should finish pretty soon. It just got under like 2000 transactions per second, again like at L2. So we are working on mechanisms to handle the deposits, the withdrawals, and also there's some synchronization that needs to happen on chain at some frequency. But this is the kind of number we can expect even from an old machine.
00:09:06.546 - 00:09:14.400, Speaker A: And this is horizontally scalable, so we can add more nodes to the network. Okay, thank you.
