00:00:17.690 - 00:00:52.030, Speaker A: Hi everyone. I'm Joseph Poon. I'm here to talk about plasma. And this is going to be sort of overview for about the first ten minutes. So if you already seen the other presentation, a little bit of this might be review. So the second half is going to be sort of exploring the narratives around data availability and the data availability problem. Vitalik has been talking about this data availability problem for the past several years and is very critical when it comes to ethereum based layer scalability such as Sharding.
00:00:52.030 - 00:02:01.998, Speaker A: And today I'm going to be talking about the implications of data availability when it comes to building transactions, when we're talking about plasma in particular. So plasma is a project that right now is being architected and after that will be written and it's co authored by And Vitalik. And hopefully a lot of people in the Ethereum community can contribute because I think this can be a lot of fun. So plasma at its core is about building a blockchain on top of a blockchain. So you write the smart contract inside Ethereum and you initialize it by basically taking a library and modifying it to whatever particular use you need. So for example, you can build some social network, some decentralized exchange or even some private blockchain. I think the private blockchain example is pretty interesting because you can build a private system with your own rules, with your own participants, with whatever terms you want, but also enforceable on the public network.
00:02:01.998 - 00:03:12.422, Speaker A: That's pretty effective because right now a lot of private blockchain systems are role playing, right? A lot of the systems they're building today can be modified by the operators of these systems. If it's these five people, then you're sort of like, well, all my money is sort of at the whim of these five people. If you bond your activity in a private chain to a public network, that allows everybody in the world to sort of say, okay, this allows the ethereum network to sort of be this base layer for all of these private chains interacting in the future. And that could be an interesting aspect to develop on. And the way this works is that in the smart contract you make it so that the consensus rules are defined inside Ethereum itself where you upload the smart contract and it's enforceable via fraud proofs. And each individual plasma chain has its own consensus mechanisms defined inside the smart contract and it could be written in solidity or in the future, more likely Viper. And the goal is to build decentralized applications at scale where you can create billions of transactions per second is sort of the goal given certain security constraints.
00:03:12.422 - 00:03:51.160, Speaker A: The presumption is that you're not really trusting them. And the way you do that is that let's say you're Alice, you have one ETH held inside this plasma chain and this plasma block periodically commit block hashes onto ethereum. So it's very, very small measured in hundreds of bytes, which can encompass perhaps gigabytes of data. This is not proof of existence. Proof of existence is another form of role playing that people use when it comes to building blockchains inside blockchains. This is actually enforceable. The notion is if you create an invalid block, if a block is invalid, it can be penalized and rolled back.
00:03:51.160 - 00:04:35.362, Speaker A: And what this allows you to do is allows you to create a lot of transactions inside a system. This is, of course, assuming data availability. And data availability is an interesting problem that we'll get into in greater detail later. And essentially, this is an example if someone submits an incorrect transaction, an incorrect block rather. And then what happens is someone submits a proof onto Ethereum and you submit a merklized proof. And it's actually very similar to the previous presentation about TrueBit, where you have merklized enforcement and merkalized attestation. And by having merklized attestation, you can represent information a very, very compact way.
00:04:35.362 - 00:05:09.950, Speaker A: So, for example, if this very specific, let's say 100 bytes within a block inside this plasma block is invalid, you just say, okay, these 100 bytes are invalid. Here's a proof that these 100 bytes were inside this plasma block. And then you submit that inside Ethereum and it's very, very compact. That allows you to say, okay, one piece of this entire block is broken. Let's roll it all back. And then in that moment, the individuals that created that block get penalized. And that allows some measure of honesty when it comes to propagation.
00:05:09.950 - 00:05:56.910, Speaker A: But the core notion of plasma is not around the notion of markalization of information. The core notion is about exiting in the event of data unavailability. Data unavailability is an interesting problem because you can't prove when someone is withholding data, it's sort of like if Alice and Bob says, alice says, oh, I gave the data to Bob. And Bob says, no, Alice didn't give it to me. Who do you know is right? You really can't be on having this trusted third party. And in Ethereum, we try to reduce that as much as possible. And what you can do in plasma, this core of plasma's construction is this allows you to exit in the event blocks are withheld.
00:05:56.910 - 00:06:24.534, Speaker A: So plasma blocks in this case. So it's saying that if, let's say, block number four is committed, so this 100 plus bytes is committed onto Ethereum and it's like, wait, I don't have this data. I can't prove this as false. I can't prove that it's invalid. So then what you do is you then submit it and then not submit it. You exit. And basically you exit from that chain because you're like, well, someone's not giving me the data.
00:06:24.534 - 00:07:02.978, Speaker A: There could be bad data in there. There could be bad state transitions. It's sort of like if a party starts sucking, you just leave. You don't try to make it's like a party is a disaster. You're just like well, you can try to make it better, but you could just leave and join another party and it's much more fun that way for everybody. And the fun part is when you do blockchains and blockchains, you could do blockchains and blockchains and blockchains and blockchains and that gives you even greater scalability where you could do like potentially billions at this point representing a single use case for example, like fun posting in some live chat. You could do that and build a system where you could make that enforceable in some way.
00:07:02.978 - 00:07:37.102, Speaker A: And that gives you a great deal of computational scaling. This is not just computational scaling of financial activity, but potential anything. This could be a system where you move from centralized data services like Reddit or Twitter or whatever it may be, and you can credibly decentralize this since capacity is significantly increased to an incredible degree. This also lets you do computation using MapReduce. So you go like, okay, map. And you map out all the blockchains and blockchains. They do computation across many, many different blockchains and you reduce the results back down.
00:07:37.102 - 00:08:11.222, Speaker A: It's sort of like returning variables. So you just have one way of splitting up the work and one way of returning the work. And that's sort of how you reach incredible computational scale. So the design goals is one blockchain can encompass all worldwide computation. Maybe not all as in everything, but all as in like there's no necessary constraints given the security properties of the system. And the goal is to do trust minimization where you're not trusting the people operating these plasma chains because you can ultimately go to Ethereum and enforce invalid state transitions. And the goal is to payment and ledger scalability.
00:08:11.222 - 00:09:23.210, Speaker A: Ledger scalability is interesting because ultimately you want records and it's sort of like state channels gets you an x percent x times scalability. This can give you many, many x and Ethereum sharding can give you many many other x's and then at that point you can reach incredible scale. And I believe that this is very much in the near future measured in very short time frames, not like ten years plus, but closer to low digits and amount of years. But transaction data I think can give you an example of the problems that we're dealing with. This may be a little bit more architecture, so if you're a little bit, it may be a little bit hairy. This requires some knowledge in the way atomicity works, but basically what we're talking about is that you want to create a transaction and then let's say you just broadcast it inside this plasma block, you're done, right? Not really. You can't attest to this payment if the block is being withheld remember like that block number four I was going over earlier.
00:09:23.210 - 00:09:56.346, Speaker A: If that happens, then if you make a payment, you don't really know if that payment is in there and you don't know if the correct amount is in there, you don't know if the current state is correct. It's just being withheld from you, and you can't even prove that it's invalid. It's sort of like all you can do is just say, well, maybe my payment is in there, maybe it isn't in there. Or maybe it's wrong. And if it is in there and you try to withdraw an old state, then you get penalized. If you try to withdraw and it isn't in there, well, then that makes no sense. That won't work.
00:09:56.346 - 00:10:44.762, Speaker A: And if it's incorrect, well, you have a big problem, right? And normally when an incorrect state is attested to, you just exit. But in this case, you may not have enough information to exit. So that's sort of a problem that needs to be addressed within the context of data availability, and you're not sure if those funds are spent even further, right? Someone maybe that transaction went in to this plasma block, and maybe later it gets withheld because it gets spent, a separate transaction spent it. So that could be a big problem. And this problem also exists when you put funds into a plasma block as well. So how do you address this? You address this by creating this two phase commit process. This is a very different way to do it.
00:10:44.762 - 00:11:38.474, Speaker A: This is not a hard necessity for a lot of problems, but if you want 100% certainty, this is sort of how you would do it in the event of data withholding, we don't have this problem on the Ethereum base chain, right? On Ethereum, all you do is you just broadcast a transaction, it gets confirmed, you're done. The reason it's not a problem in Ethereum is because it has presumptions of everybody having the data available. Ethereum works by I receive blocks. I don't trust anyone else, right, anyone else on this network. And when I receive it, I compute it, I validate it, and I just make sure that it's true according to the consensus rules on my computer. And what happens is I can process the current state, but you could also do a full replay of the entire blockchain history in order to have 100% assurance. That's not necessary, but you're capable of doing that because you have the data available.
00:11:38.474 - 00:12:39.440, Speaker A: In this case, when you split up into all these different plasma blocks that are only committing very small pieces of data onto the Ethereum main chain, what happens is that in this plasma block, there could be information you don't know about and when someone's withholding, you can exit. But what happens if you don't have all the data? So in this case, what you do is you create and broadcast the transaction, much like you do normally. And in this case, the plasma block gets signed by a validator, so it gets included into a plasma block. And then step three is where it gets weird. Alice commits that she saw her transaction get submitted into a block, and she can give that to Bob, or she can submit it onto the plasma chain so that there's, like, a second record. So it's sort of like I submit a transaction, and I submit another transaction, saying, I saw the first one. And then at that point, when Bob sees that second step, whether it be directly from Alice or from the plasma chain, bob now has assurance that the money is his.
00:12:39.440 - 00:13:31.790, Speaker A: Why do we do this? Right? Alice needs to be sure that the transaction has occurred, and she's able to reference it. Remember that merkelize proof stuff? So Alice now is able to reference that that transaction existed, and now Alice is able to be assured of it, and now she's willing to attest that, okay, this money is no longer mine. And this is sort of the one weird trick to make this all work. And as Bob, you're only willing to accept the funds when you receive that second step, because at that point, Alice cannot claim the funds according to the consensus rules written in solidity or viper on the base chain on ethereum. Basically it says, like, okay, once the second signature happens, alice no longer has any claim to the funds. And essentially, we're dealing with three parties here alice, Bob, and the plasma chain itself. So let's go over these four steps.
00:13:31.790 - 00:13:50.166, Speaker A: There's Alice. There's Bob. This is the chain, and that's sort of the state. So that's the third thing I was talking about. Alice has one ETH. The plasma chain is there and then ethereum on the base layer, which periodically gets commitments and exits and deposits. So Alice signs a payment.
00:13:50.166 - 00:14:13.770, Speaker A: So this is, like, very similar to how ethereum works. You just send a payment into the plasma chain. Ultimately, a plasma chain creates a block, and then it sends a commitment onto ethereum, and it says, hey, I made a block. Here's a couple hundred bytes. Alice and Bob then get the data of that plasma block, and it says, like, okay, I see this block is legit. Okay, there is a payment going on. Alice and Bob both see that there has been a payment from Alice to Bob.
00:14:13.770 - 00:14:52.230, Speaker A: Notice on the top right, it shows Alice or Bob, because either Alice or Bob can claim this according to the chain itself. Step three, this gets a little bit tricky, but it'll make sense. So Alice then submits a commitment signed by herself that she has seen that previous transaction, and essentially she's able to prove it because she sort of, like, can see the data there and sees the Mercalized commitments. So she's like, okay, cool. This money's no longer mine. She passes it off into the plasma chain and Bob. And now, from her perspective, it's not her money anymore.
00:14:52.230 - 00:15:19.502, Speaker A: If she tries to claim it, that's bad news for her because she's not able to do that or gets penalized for Bob. It's sort of like, well, okay, if he hasn't received it yet. Oh, there's a slide. Skipped. Oh, well, anyway, so for Bob, let's say Bob hasn't seen it yet. That should be a dash. Then bob doesn't yet know whether it's Alice's or Bob's.
00:15:19.502 - 00:15:43.290, Speaker A: From his perspective, it should be Alice's. And for the chain, it sees it as Bob's because it received that transactions and confirmed in this case. Now that should be a dash line to Bob, not a solid line to Bob. So we're correct here. Now, Bob now sees the funds as his because he has that commitment and the original transaction. So Alice now has no claim. And in the top right, you now see Bob has the one ETH.
00:15:43.290 - 00:16:45.690, Speaker A: So creating this two phase construction allows Bob to know that Alice no longer has any claim to funds. And Alice has assurance that she will have the funds available if the block is withheld at any point in time. So, as an example, let's say Alice tries to maliciously withdraw the funds. If Alice tries to withdraw the funds during step three, what happens is that when it's not fully committed to Bob yet, she submits a transaction onto the ethereum main chain, the ethereum root chain, basically what we call ethereum today. And let's say the holding period is 14 days before she can correctly withdraw and she has to put up a bond. Assume that Bob believes that the money is his because he has the information available to prove that Alice has committed to the fact that she saw her original transaction. Then what Bob can do is take that proof that says, alice says, hey, I saw this transaction hit the block.
00:16:45.690 - 00:17:20.410, Speaker A: Here's a proof that this transaction hit the block, and here's a commitment that I have submitted this transaction. Bob should say, okay, that money is mine now. But if Alice tries to take that money, bob could submit to ethereum that says, okay, Alice tried to submit this. Bob sees it on the blockchain and he says, okay, Alice screwed up or is trying to take my money. Here's a proof because Alice gave it to me and I saw it on the chain. And now what happens is Bob is even happier because she takes her bond and it's his money back. So this type of construction, by constructing a two phase commit process, you're basically making attestation on information availability.
00:17:20.410 - 00:18:02.040, Speaker A: And this is going to, I believe, be an emerging theme when you're dealing with states where not everybody in the world has information, right? We're not dealing with global state anymore. How do we deal with this? Right in channels. The way we deal with it is we can only move forward if both parties have it available. But we're dealing with perhaps thousands of parties, billions of parties, maybe eventually. And different people will have different sets of data. So the goal is to be able to make it so that you can have attestation correctly and to scale and perhaps the blockchain can be the ultimate arbiter. In this case, ethereum can basically be the Supreme Court of Computation across the world.
00:18:02.040 - 00:18:03.140, Speaker A: Thank you.
