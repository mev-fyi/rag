00:00:00.730 - 00:00:25.880, Speaker A: Hello. So yeah, welcome to our talk. My name is Eric, my name is Matthias and yeah, we are going to run you through some new features and solidity that we worked on in the past month. And so we have the link to the slides on the slide itself and also this QR code. We are quite curious if this works for you.
00:00:26.490 - 00:00:32.742, Speaker B: We tested it numerous times, but you never know. And every phone special works.
00:00:32.876 - 00:00:34.822, Speaker A: Yeah, but I mean, at least it looks nice.
00:00:34.876 - 00:00:38.490, Speaker B: No, it did work. Apparently at least one person managed.
00:00:39.870 - 00:01:16.120, Speaker A: Yeah. So I will quickly run you through the agenda. So first we want to talk about some language features, the most prominent ones. Also we have introduced some compiler features, like some changes there, and then the next point is like future development. What are we planning to do in the future? So we will also have A-Q-A session afterwards. Let's start with the language features. Yeah, quite exciting stuff going on there.
00:01:16.810 - 00:02:00.882, Speaker B: Yeah, we spent quite a lot of time on a new inheritance system and my mic just went out. Okay, a new inheritance system, which doesn't actually mean there are no actual new features. We added keywords and checks that you can program in a more safe way that the compiler does more checks. So starting with override and virtual, you know them probably from other languages, c plus plus, et cetera. Here you see a contract written in the pre 60 version. There's nothing special to see here. You see, we override the contract three times to the total supply function.
00:02:00.882 - 00:02:48.130, Speaker B: We always call the base function of the previous one. And yeah, nothing special here this changed in the new version to look like this. So you see we have a virtual keyword which you need to specify if you want to override a function. Otherwise you can't override it, and similarly have to specify override in the function that overriding, and again virtual if you want it to be overridable. So it's not implicitly virtual again. And the final inheritance here, we didn't specify virtual because we don't intend to override again. Yes, so far we have multiple inheritance.
00:02:48.130 - 00:03:48.442, Speaker B: In pre 60 it looked like that. There is again, nothing especially exciting to see about this. We have the RSC seven seven contract, which implements also IRC 20. We just showed the total supply function here with one implementation, and in the new version you now have to again, hold on a second, I'm slightly confused. Right, okay, so you see it's an interface. That means you don't need to specify virtual because it's an interface, it can't have an implementation, and it must be overridden. So no virtual required in the deriving function, you need to specify all the contracts or interfaces that you want to override.
00:03:48.442 - 00:04:32.530, Speaker B: If you leave out one here it will be an error and the compiler will yell at you. Also, if we were inheriting from two contracts with their own implementations, then you still need to override it explicitly. If you leave out the whole implementation in the derived class, it will also be an error. So we want you to be explicit and to know which base implementation you're calling or doing your own implementation. Then we're moving on to abstract contracts in pre 60. Again, a simple example. Here we have total supply defined but not implemented.
00:04:32.530 - 00:05:28.790, Speaker B: And this, well, it compiles, it gives you no error. No code is generated for the total supply function because there's none. And you will get an error if you try to new this contract, but not before. So you might have silently not working code and your compiler would not tell you. And in your code base you wouldn't notice. Now with after 60 we introduced the abstract keyword, which you can see at the top, and now you will get an error as shown here, because you haven't implemented that function and you must specify abstract if you have an abstract function like without a body. So it tells you here that you should either make this contract also abstract or you provide an implementation.
00:05:28.790 - 00:06:07.310, Speaker B: This propagates more safe code and you catch mistakes earlier in the whole process. Then a small new thing regarding interface inheritance. You can now inherit from interfaces which wasn't possible before. So you can easily show that the interface for Erc seven seven is also an interface for ERC 20. And yeah, those are so far the inheritance features. Moving on to fallback and receive split.
00:06:07.470 - 00:06:43.070, Speaker A: Thanks. Yeah, so in the fashion of being more explicit in your contracts or in contracts in general, we also decided for a fallback and receive split. So I will show you what that means. So this is a pre 60 contract with a fallback function defined, and this is called for both. So for nonexisting function signature, or if there's any ether received. So what's happening here? So if you send any ether.
00:06:44.770 - 00:06:45.134, Speaker B: The.
00:06:45.172 - 00:07:34.298, Speaker A: Transaction is successful and the contract keeps the ether. So we decided to split it up into the first part, which is receive. So we introduced a new receive keyword here. The function signature of the receive function looks kind of similar, but without the function keyword. And receive is being called if you send any ether to the contract via send or transfer, and this contract reverts if you call a nonexisting function. And to handle this part, there is default part of it. So just before the talk we talked quickly about the proxy pattern.
00:07:34.298 - 00:08:24.350, Speaker A: And so I'm quite happy that we have this example here. I mean that's the pre 60 version of it. So there's the fallback function, and in there you have an inline assembly code which then has like the delegate call magic. And this is called for both, or was called for both, for nonexisting function or ether, if any ether was received. And here we introduced keyword. So this contract then gives you a warning because there's no receive ether or receive function implemented. And the compiler, as I said, gives you this warning.
00:08:24.350 - 00:09:21.482, Speaker A: And then you can just implement the receive and the fallback function and then do in this functions what I. And just a quick wrap up. So receive is executed if there's like a plain ether transfer and fallback is executed, there's a matching function signature, or there's an empty data field, there's no repeat function. The next one might be a little bit controversial, but I think for the sake of clarity it's a pretty nice feature. So we made the length member of Aries read only. So it's a little bit hard to come up with a good example here. But we just thought, okay, we will have this stack, it's a contract called stack, and you can pass it a length via the constructor.
00:09:21.482 - 00:10:14.990, Speaker A: And this is the pre 60 behavior. And then you would have like a push and a pop function. So nothing special here, but it has some pitfalls. So I mean, first of all you could pass like a very high number as the length, and this could result into overlapping storage. And also accessing length looks cheap, but if you want to delete, then it's quite expensive. And so what I said before is making this read only prevents multiple ways of accessing storage here. And this is the zero 60 version, so it should do the same.
00:10:14.990 - 00:10:53.200, Speaker A: But here in the constructor you would need to define a loop. For example, use an empty push function, and then push and pop are implemented similarly. And this code, we hope that it's more explicit because you would see the cost of it. Instead of just assigning to the length, you would use this loop, for example. Yeah, I think that's about it. The next one, it's something we are really excited about. It's try catch support.
00:10:53.200 - 00:11:02.234, Speaker A: So just to give you an example how this could work. So we have a pre 60 contract.
00:11:02.282 - 00:11:02.880, Speaker B: Here.
00:11:04.790 - 00:12:29.500, Speaker A: And we have the contract consumer and it has a feed and a rate function. And now the thing is, you want to react on the revert in the function data, but how would you do that? So there's no way of doing that. So we decided to go for a try catch pattern that you probably know from other programming languages, and this is an 60 version of the contract. So again the body of the data function just reverts. And here in the rate function there is the new try catch pattern. So as you can see you could just call the function again and then keep the return, define the return values, and in case there is no revert or no assertion failing this would in this example then return the value and flag the call as successful in this example, because the rate function has undandable as a return value. So for the actual value and states the success of the call.
00:12:29.500 - 00:13:41.570, Speaker A: And in this example, so there is a reason given for in the revert, so revert reason and the first catch block that you could implement reacts on that. So in this case, because the function always reverts, we would reach the catch branch and you could read out the actual string that was given. In this case we return a zero and mark this or flex this as not successful, there's another branch that you could also implement. So just imagine you have a revert without the reason string, or like I said, an assertion that fails. You could define another catch branch here that reacts on the low level data, and then here you could do whatever. And it's also possible to use both. So we just wanted to keep it out because then the example would have been too big, but usually you would implement both branches.
00:13:41.570 - 00:13:58.380, Speaker A: What else to say? Yeah, I think let's talk afterwards if there are any questions. Next are the function call options and matthias will take over again.
00:13:58.990 - 00:14:41.750, Speaker B: Yes, function call options, you might know them as gas and dot value, as shown in this example. To transfer way or gas to the function that you're calling. We changed the syntax of this. This change was triggered by actually another feature that will come right after this. But I actually like the new syntax a lot. It follows the named arguments syntax, so you specify in curly braces the variable names and then the values. And I think it looks less confusing because before it looked like another function call, which it really wasn't.
00:14:41.750 - 00:15:47.318, Speaker B: So I think this is a big plus, and it is also very consistent with the new feature, which is high level support for create two. So this is one I really like, because if you wanted to create a new contract using create two, you had to do it manually in inline assembly, as shown here, you first had to get the code from the contract you want to create, in this case product. Then we call create two. In low level assembly with ten way. We specify the code, we specify the length of the code, and we specify an individual salt, which is creatively named salt. In this example we check if the creation succeeded, we reward if it doesn't. And there's actually a problem of this, apart from being very low level, and some of you might see it, some don't.
00:15:47.318 - 00:16:24.370, Speaker B: Does anyone see a problem here? All right, that's why we introduced this. I didn't see it in the beginning either. So here the new syntax really just call new. In the contract you use the named argument syntax from before. For function call options, you specify the sold and the way you want to send. And the difference here is it's easier to pass arguments to the constructor, which we didn't even show in the previous example. But you notice we have now a constructor that is payable.
00:16:24.370 - 00:17:06.790, Speaker B: We actually needed one, but the compiler couldn't check it before because it didn't really know what we're doing in the low level assemble. Now this wouldn't compile if I hadn't added this constructor. And if you don't specify salt here, then it would be just a normal new, a normal create call basically. And I think yes, these are all the noteworthy mentionings of here. We have some miscellaneous features we also want to mention, but weren't big enough to warrant whole slides. Eric, would you like to introduce.
00:17:07.690 - 00:17:27.850, Speaker A: Yeah, so we have global enums and structs, so they don't need to be defined in a contract anymore. We use array, slices, arrays, the syntax, you probably know the syntax from other languages, so you would just define the begin in the brackets.
00:17:28.510 - 00:17:54.530, Speaker B: And finally we have a new ASM statement, leave. You might know return, which basically ends the whole function context. Leave just ends the current yule function so you can be more precise where to exit and have more freedom in your control flow. We're moving on to a tool that Eric wrote almost alone.
00:17:57.610 - 00:19:10.790, Speaker A: Yeah, so this tool is called solidity upgrade, and it came out of the necessity like to just give you a quick in our testing pipeline we have some external projects and therefore contracts that we're always testing with new compiler versions. So want to see how changes that we are doing actually affect existing code bases. So we have, for example open, we have no, and developing these features we have to upgrade the contracts. And as Matthias already told inheritance clarifications would need a lot of manual updating of the contracts. And just to cut this a little bit down, we decided to build this tool on our own. And then it turned out that there was also some public interest in it. And then we said okay, yeah, why shouldn't we make this kind of public and write some nice documentation on it? And so this is the reason why ended up in, and it's kind of simple.
00:19:10.790 - 00:20:03.022, Speaker A: So it's based on lip solidity. So it's a c plus plus tool and it just parses and compiles through lipsolidity. And it's a hybrid solution. So we are checking the errors that are being reported by the compiler and then we are doing like a simple textural source manipulation based on regular expressions on the contract itself. So for example, this is a pre 60 version, just like three contracts, and there's some inheritance in it. And compiling this with the newest compiler version would lead to several errors that are being reported, but the tool is able to upgrade the contracts for you. And yeah, I would just quickly show you the command line invocation here.
00:20:03.022 - 00:21:03.110, Speaker A: So the tool like SSS is called solidity upgrade. You would just pass a source and the previous example, there are no errors being reported or no errors left because there are no upgrades. So you could also have the situation that there are still errors that the tool couldn't upgrade itself. So we implemented most of that, the tool is able to upgrade automatically. So for example the inheritance features, but of course, because the semantics of an assignment to length member of an array is not so easy. So we left that out and we also experimented a little bit and integrated some zero 50 features, for example the default ability for functions. And yeah, we would love to get some feedback on it, so if you're interested, just consult the documentation.
00:21:03.110 - 00:21:42.400, Speaker A: There's a subsection in the compiler, in the section using the compiler, and we're kind of interested if this is useful for contract developers. Next one, compiler features I think we are running OPM without tell here. So the first one, which is also an interesting feature, is the JSON import. So before, I don't know, I couldn't remember which version was it introduced? I think it was introduced in.
00:21:43.810 - 00:21:44.734, Speaker B: I think so too.
00:21:44.772 - 00:22:36.430, Speaker A: Yeah, so as you might know, it's possible to export the AST in a JSON format, and now it's possible to import this again and then run the compilation on the imported ast. We also put a lot of effort into the wasm back end. So every feature that is. Do you know the intermediate representation called Yule, like the inline assembly language? So yeah, as I said, this is the intermediate representation of our solidity code. So everything that can be compiled through Yule, like every solidity construct that can be compiled through Yule can now also be compiled to eVASm, which is a webassembly subset for the EVM.
00:22:37.650 - 00:23:51.640, Speaker B: Yeah, the ABI encoder version two is no longer considered experimental. We still need to specify the same old pragma experimental instruction to use it though, so that you don't have to update the contracts. Mainly not considered experimental means there are no warnings anymore if you use it, and there is no experimental literally in your bytecode when compiling it. Otherwise, the Yule optimizer Yule is basically our intermediate and assembly language, is now also no longer experimental, and is automatically activated when you specify the normal optimized flag before it had its own flag. We are going to have a short look into future things we're currently working on, starting with the Yule backend, which basically means solidity first to Yule and then compile that to the EVM or whatever backend we want. Then I think this is your part.
00:23:52.410 - 00:24:56.922, Speaker A: Okay, so we also looked into a LSP implementation, so a language server protocol that's quite useful for IDE integration. We just started looking into the specification that comes from Microsoft. And yeah, I think there is a prototype. And because we have the feeling that the community is quite interested in this feature, we are also eager to implement that. And then there's some other things, but no word like worth to mention here is like the mutable, immutable variables that could be, for example, only assigned once in the constructor and are then constant. But this is also an open discussion, and if you feel that you want to contribute or participate in the discussion, you could just look through our issues and try to find the discussion there. Also, we have a mailing list.
00:24:56.922 - 00:25:18.458, Speaker A: I think it was set up like a year ago. Right now we're trying to actually open up discussions there, and it's a Google user group and there are some posts and some things going on, and we would really love to see more people participating in the discussions there.
00:25:18.644 - 00:25:26.120, Speaker B: Important thing to note here is it's about language development here, not about questions about solidity or things like that.
00:25:26.650 - 00:26:08.980, Speaker A: I mean, it's about solidity, but it's mostly like language design. The next thing that we are very excited about, it's the solidity summit. So at the end of April we will have a two day language summit here in Berlin. It's a two day friendly sized single track event with talks and workshops. So if you're interested in attending this, then just navigate to the URL and sign up for it. And we are happy to receive proposals for talks, workshops, yeah, would be very nice to see you there.
00:26:10.550 - 00:27:06.214, Speaker B: Otherwise we're very approachable on various online and offline resources. You can post issues and feedback and feature ideas on GitHub. You can visit us in the gitter chat, and you can participate in our Google Hangouts meeting twice a week where you can either just listen in, talk to us, ask questions of if you want to do stuff yourself. We always happy to help and direct you to interesting issues. Another thing we forgot to mention, if you have projects in solidity that compile on the current version, please approach us. We would love to integrate them in our CI. And yes, I think questions? Well, you can always approach us later.
00:27:06.412 - 00:27:07.398, Speaker A: Thank you.
00:27:07.564 - 00:27:23.640, Speaker B: Thank you. Wait, there's a question. He asked how many people are currently working in the compiler? I think we are seven to eight now, but it's like only a few are full time and it's very spread over the week.
00:27:24.890 - 00:27:47.980, Speaker A: Yeah, I think eight to nine. I mean, there are people also involved in other projects in the foundation, for example, and they're just like coming in for a week, doing some stuff there. And we also, I mean, we have some external contributions. We are always trying to see how to increase that. Yeah, but I think like eight to nine should be fine.
