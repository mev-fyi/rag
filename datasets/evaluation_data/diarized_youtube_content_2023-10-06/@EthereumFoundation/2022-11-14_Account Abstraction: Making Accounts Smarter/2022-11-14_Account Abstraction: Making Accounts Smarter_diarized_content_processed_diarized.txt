00:00:12.490 - 00:00:46.410, Speaker A: Okay, thank you. My name is Drosh. We work on the opengsn gas station network. But recently we're working with Jord Weiss, which was supposed to pass this presentation, but he's sick in the hotel well, so we are covering them up. We'll talk about account obstruction and what can be done with it. First, what is account obstruction? But before we talk, what is account obstruction? What is an account on Ethereum? Account comes in two flavors. One of them is externally owned account that we all know, and the other are contract based accounts.
00:00:46.410 - 00:01:23.720, Speaker A: And if you have a wallet, you're probably using an EOA account. EOA accounts are very easy to start to work with, but they have quite a few limitations. First of all, key management is very, very problematic. The private key is tightly coupled with the address, which means you can't change it. You have to keep it secret because if you lose it, you lose everything. But if you make copies in order not to lose it, someone can find it and then he will get everything and you will lose everything. So key management is hard.
00:01:23.720 - 00:02:11.602, Speaker A: There's one fit all access control. You can do everything. It might be good for you for personal usage, that you can do everything. But it is very, very limiting. If in a way all these operations by abstracting away, we mean it is not the node that performed operation that checks the signature, that checks the security of the node, check the balance, perform the payment, but we abstract it away and make a contract, the wallet contract being responsible for all of these. So the key management becomes simpler because the wallet can do a key management by itself. Access control mechanism.
00:02:11.602 - 00:02:13.800, Speaker A: If we want the gas payment, he does.
00:02:16.330 - 00:02:34.110, Speaker B: A lot of things become easier. But just the easiest way to think about this is making contracts, wallet contracts. First class citizens, they're no longer second class citizens of Ethereum. And that you don't need an EOA in order to operate your contract wallet. You can start from a contract wallet and you'll never need to have an EOA.
00:02:34.530 - 00:03:00.374, Speaker A: Okay, from now, when we're talking about accounts production, now we are talking what can be done with it. Now with the next slide, with all the features, none of them are implemented by us. They are about to be implemented by you. We only open the door with accounts in order to be able to add all these cool features. So the first use case is recovery. Right now, the recovery sucks. You can't recover private key, can't really recover it.
00:03:00.374 - 00:03:33.326, Speaker A: You have to save this private key somewhere as multiple funny words or otherwise with account obstruction, you can implement into your wallet social recovery or other recovery mechanism. You can add a deadman switch. Like if I'm unfortunately someone died and you don't want to lose all the assets he has, it can set a deadman switch that is after a period of time that he's not using the account. Someone else will inherit this account like.
00:03:33.348 - 00:03:40.926, Speaker B: A multi SIG that your family controls, but it only becomes active a year after your key is not active.
00:03:41.118 - 00:04:19.630, Speaker A: Yes, we're talking about a recovery, but multisig, of course, when you're talking about signature cases, multisig is something that we see. We want to have our accounts. Another option is per device keys. You might want your phone. Your phone has a very strong hardware to protect keys, so it might be very easy that the protection of your phone, whether it's fingerprint or whatever or other biometric check, this is the way to control your account. And if you lose this device, yes, we have recovery. I will assign another device as my wallet signer.
00:04:19.630 - 00:04:59.334, Speaker A: These are pair of device keys. There are other signature scheme you can use. BLS signature has a very cool feature which can be compressed very nicely and which reduce gas on L, two networks. So it's an extension that can be added on top of account abstraction on those networks to reduce the gas fees. And if you are looking into the future, we know that ECDSA signatures sometime in the future will become weaker. That is, the attack will become stronger. And with the quantum machines, eventually within 510 or 20 years they will be able to be cracked.
00:04:59.334 - 00:05:52.842, Speaker A: We want to be able to upgrade our accounts, at least our important ones before then. So quantum resistant signatures might be a way and again, each of those cool features we are talking is not a systematic change of all accounts, is a specific account. Want to experiment or want to add a feature? Okay, you upgrade your account and now you have those features like any of those on the slides around. Sorry, did you miss anyone? Okay, now we're talking about some roles right now. As I said, with EOAS you have a signature and you can do everything. When you use smart account, you can put roles, you can allow different roles to do different things. Maybe on your home, on your personal account you want to do the master, to do all.
00:05:52.842 - 00:06:16.920, Speaker A: But if it's a corporate account, you might say that you want the legal department to be able to vote but not move tokens. You want an auditor to be able to cancel pending events, but not generate events, I don't know, set to a payroll system to be able to submit to known addresses. Again, the sky's the limit. What you can do, and it is still you can add it to this account.
00:06:21.710 - 00:06:24.474, Speaker B: Wait, maybe a little bit about session keys, sorry.
00:06:24.592 - 00:06:46.930, Speaker A: Okay, we talked about the high end of accounts. That is accounts corporate account. There is also the lower end. You have your personal account, but you also want to play games. With games, even the single accept per request might be annoying. You don't want to accept each operation. So for games you might assign your account session key.
00:06:46.930 - 00:07:16.732, Speaker A: This key is allowed to make transaction for specific target specific game. And now you are wallet free. You free the UX from accepting each transaction and you know it is limited. It's only this game, so it can be your own wallet. But you didn't sacrifice for this game your entire security. Is this the next? Yes. Okay, we talked about the security, about the role access.
00:07:16.732 - 00:07:57.668, Speaker A: Now let's talk about the gas abstraction. With normal accounts, the account has to have ETH in order to pay for the transaction. With account obstruction, we want to abstract away the gas. We want to be able for a third party to pay for a transaction which is very very good for onboarding. Like Adapt want to pay for transactions for its deployment of its client or client that use its own account. If you have a token, it might be useful to use your own token. So the user will be able to pay with your DApps token for transactions and for traders.
00:07:57.668 - 00:09:05.280, Speaker A: If a trader want to trade on uniswap with Dai, why should he have ETH to pay for gas? He has Dai, why not pay with that? So paying with token is a cool use case that we really want to have in the system. Privacy, if you think about it, if you go and you want to protect your privacy and use a mixer like tornado cash or other and yes, you put the money in. Now you want to get the money out, but you have to have gas in order to withdraw this amount. How did you get that gas from some KYC account? So you are not really anonymous when you withdraw funds from a mixer. You are not anonymous even though you would like to be. So if you're using a Cant absurd model, you can use part of the amount that you withdraw from the mixer as a gas payment. So this way you can withdraw completely anonymous from a Mixer.
00:09:06.020 - 00:09:27.496, Speaker B: One thing quick to add is the gas sponsorship model is very flexible. DOL gave an example of Onboarding where you're subsidizing the fee entirely. But you can have arbitrary logic. It's implemented by a contract. You can limit that in any way you want. You can subsidize if you want, only some transactions. You can make users authenticate in some way.
00:09:27.496 - 00:09:43.196, Speaker B: You can decide only to subsidize governance actions. I mean, it's arbitrary logic. So anything you want, you can do with this. You decide what the conditions are, including asking for repayment in another token, as.
00:09:43.218 - 00:10:11.232, Speaker A: I said, all of these are features that you have to implement. We implement the infrastructure. I'm only suggesting crosschain operation. Since you are abstracting as you have a contract. You have a contract that can pay for its own deployment and you have a mechanism that can pay for the deployment and for execution transactions. The next thing to think about is that I want to make operation on multiple networks. I am on first network.
00:10:11.232 - 00:10:38.684, Speaker A: I can pay on there. But I want to use my account on other networks. So it is possible to create a paymaster mechanism, payment mechanism that I will be able to perform that operation on those other network. It use my signature. I approve these transactions. So it's not some other party acting on my behalf, it's me acting on those networks. But I don't have any balance on it.
00:10:38.684 - 00:11:28.750, Speaker A: I don't have to have any ETH balance or native token balance on those networks. It's a system that can move the payment between the networks meet you. Why are we keeping moving back? And lastly, we have a wallet. So there's a link for the entire presentation. Everything at the end. As we said, with EOA accounts, I'm limited for performing a single operation at a time which cannot be batched and requires acceptance on each operation. It's very easy to add to a wallet account performing a batch and doing atomically a sequence of operation.
00:11:28.750 - 00:12:01.226, Speaker A: Another use case, we can see that you want atomic operation or a delayed operation. That is, I create an operation and I want it to be executed later. A service can do it. And again, it is my account that performs this operation because I gave some service the rights to do it at a later time. Okay, these are all cool ideas. Some of them are very old regarding.
00:12:01.258 - 00:12:40.400, Speaker B: Just the event driven flows because they're very interesting. Maybe a couple of examples. One, let's say there's an NFT that mints at a certain time. Then you don't have to wait in front of your computer and then you just create the transaction. Then you could preregister the transaction into a registry contract of pending transactions and then searchers you provide them an incentive to execute the transaction when the time comes and they're competing with each other. Another use case would be, let's say you want to perform some trade in the future, pending on certain conditions, price, whatever you want. So all this becomes possible and doesn't require any trust.
00:12:46.290 - 00:13:36.880, Speaker A: Why do I keep sending it back? Okay, with the ERC 4343 through seven, we wanted to create an implementation of account obstruction that can be executed today. Not something we have to change the protocol, but something we can add today. So we define a mempool of what we call a user operation. User operation is a transaction in our terminology. So just like the normal user mempool of transaction, there is the mempool of user operation that nodes can resource transactions from. They collect them to batch them and send them onto the network. But.
00:13:39.250 - 00:14:15.820, Speaker B: The key thing about this separate mempool, it's not a private mempool like Flashbots. It's just separate because it's accepting this user operation instead of a regular transaction. But the key thing that's different about this is just it doesn't require you to have an EOA to interact. It doesn't require you to have the ETH to pay for it because what you're doing is you're specifying within the user operation the conditions that will make it worthwhile for bundlers to submit your transaction on chain and they make sure they get refunded for gas so it works out.
00:14:17.550 - 00:15:17.946, Speaker A: Okay. So our implementation what it does, it takes as I said, these user operations you no longer need an EOA to send this user operation the node themselves take the user operation, collect them into batches and put them on chain. Perform the validation that is validation is the signature nonsense and payment and then perform the execution that you want to make. If you read the AP, most of the AP is not about usability, about how Wallets work, but how we protect the network. It is very important that those nodes that handle operations, like when they handle transactions, are not susceptible to denial of service attacks. So we had a lot of mechanism to make sure that they cannot be attacked. So we batch them together so that they will be cheaper and sending them on chain.
00:15:17.946 - 00:16:17.582, Speaker A: Since it is contract based, it can work on any EVM based network today where we want to take it to the next level. Right now, when you create an Account Abstracted Wallet, we want to make it a first class citizen on the network, a first class account on the network. Right now it isn't, it is second class because there are some differences between UA accounts and some applications require UA accounts in the way they work, in the way they require signature. Think of permit. You cannot do permit directly with a Wallet account. We do want to make them first class citizens. So the next stage, after what we have done today, which is having a contract based mechanism to deploy them on chain, we want to add them into the network to what we call enshrine four three, seven into the network.
00:16:17.582 - 00:17:06.642, Speaker A: So that account abstracted account will be account and transaction in the system just like normal accounts. And then to make it possible to convert any EOA account into a smart, into account obstructed, that is, there's going to be a way. It is not fully hashed yet. It will take some time until we finish it and until it be approved into the network. But there's going to be a way that you have a normal account and you want to have those extra features so you will be able to enable this account. There are several ways how to do it. One of them is that you will actively have to convert your account EOA account into a smart account abstracted account.
00:17:06.642 - 00:17:34.010, Speaker A: The other way is that they're going to be some point of in time where all EOA accounts will become abstracted, but with a default implementation that emulate completely the normal EOA account. And from that point, yes, you can keep the same implementation or you can switch to a different implementation if you want extra features like all of those that we described earlier.
00:17:34.750 - 00:18:17.510, Speaker B: So one thing to maybe refine a little bit is we believe EOAS will need to go away at some point. So right now they are enshrined into the protocol, and we've discussed some of the limitations around that. So at some point, EOAS, even if there's backwards compatibility, they will not be part of the protocol anymore. We don't necessarily think that it makes sense to enshrine any specific alternative. Like, this is an ERC. Maybe there will be improvements in the future, because that could be dangerous. But what's clear is abstract accounts are going to be enshrined into the protocol.
00:18:17.510 - 00:18:42.130, Speaker B: There are going to be accounts that can do all the things that we discussed out of the box for new deployments and for older deployments. So otherwise you would need to transfer all your assets from one away to another. And that's very expensive and cumbersome and potentially risky. So that's where we're headed. And in terms of the implementation, yeah, like all said, there are various ways of going about it to be determined.
00:18:46.150 - 00:19:28.956, Speaker A: Okay, what can we do? You can start experimenting with ERC, four, three, seven. Now I see people who experiment with here in the hackathon. Yes, over there. Also, you can add useful features to your accounts. Innovate, do whatever you like. And if you find something that you think is good for the public, you can apply for an EF grant. And if you're building a DAP, as we said, wallet accounts are a bit different from UA accounts.
00:19:28.956 - 00:19:52.410, Speaker A: So even today, when you're looking with DApps, this is not strictly related to account abstraction, but to wallet accounts in general. Make sure that you are not forcing the user to use accounts. Like if you are checking signatures, there is an extension, the 1271, that allows a wallet account to check a signature, because it doesn't have a signature by itself.
00:19:53.580 - 00:19:56.516, Speaker B: When we say wallet account, just to be clear, we're talking about contract wallet.
00:19:56.548 - 00:20:26.210, Speaker A: Yes. If you have a token and want to have permit, be aware that permit, as it is today in USDT and dai, does not support a wallet account. You cannot use it from a wallet account. Again, because it is a signature. There are some other tweaks, like TX origin and stuff. Again, in general, try to be supportive for wallet accounts, because these are the future. Not only the gnosisafe today, but also account obstructed in the future.
00:20:26.210 - 00:20:41.400, Speaker A: Also, if you're using gas, sponsorship models should also think about it, how to interact. This probably will need an interaction between your application and the wallet in order to provide the UX, how to provide this to your users.
00:20:48.000 - 00:21:19.190, Speaker B: And the last item would be regarding wallets. If you're developing DApps, then maybe there's some space. If you find that wallets are not supportive enough of contract wallets, then you can voice your concerns and try to lobby for that. As a DAP developer, that really helps. So getting everyone on board is a process that we could use your help on.
00:21:21.240 - 00:21:44.110, Speaker A: Okay, it is before the last the QR code is missing here, so if you want the link to all this, I can give you it, but it doesn't appear on this version of the presentation. Any question? Yes, question.
00:21:46.480 - 00:22:33.340, Speaker C: So I have two questions, like one related to how currently account abstraction exists as of today. As an implementation, can you provide an example how it can be potentially used as it is in present form? And the second question is related to the next step. They're curious about smart contracts containing code. Then is there a distinction between operation that involve the smart wallet calling its own code versus calling the code from a different contract? Is it like on code becomes like a proxy for other contract call while interacting with other contracts in that ecosystem?
00:22:34.640 - 00:23:41.772, Speaker A: Okay, for the first question, how to add it? Account obstruction is an interface or basic implementation that we have in our source code that your wallet need to inherit. Provide a method or two and then the contract wallet supports account obstruction. There's also a sample how we add on top of existing safe without touching the code, adding a module to make it account obstructed enabled. You do need a wallet application or browser extension that will be able to use it. We have the basic SDK how to write it? There are several wallets sol wallet described behind you demonstrated in the hackathon and also hackathon project that try to use there are no implementation in existing wallet like MetaMask doesn't support its rate currently you have to use some other wallet, but this is now in the work. There are several wallets that are adding account abstraction support regarding how the call is done. This is the basic solidity.
00:23:41.772 - 00:24:04.010, Speaker A: A wallet is a contract. When someone make a call, it validates. It is allowed to make this call that is either the owner or through account abstraction validation method and then it makes a call outside. So any other contract sees this contract as the account that makes the operation, like whether it's a token transfer or voting or whatever.
00:24:06.060 - 00:24:07.508, Speaker D: We have another question.
00:24:07.694 - 00:24:08.044, Speaker A: Yes.
00:24:08.082 - 00:24:36.048, Speaker E: So regarding smart contract wallets, can you comment on the situation on when you need to use L two solutions? Because in most of the cases you cannot because you have a smart contract wallet deployed on mainnet and you cannot deploy it on every L two like Rvtrum or Optimus because for instance sorry.
00:24:36.214 - 00:24:38.690, Speaker A: It will become a different antist. That's what you mean.
00:24:39.720 - 00:24:49.704, Speaker E: You will need to represent the exact deployment to get the same address in order to do things like claim AirDrop course.
00:24:49.822 - 00:25:18.192, Speaker A: Yes, the short answer yes. We built it in a way that it will create the same address. So you can have the same address on multiple networks? Yes. As a wallet developer. It requires some work from you in order for that to be possible. But it is not that difficult and it can be done. Even the minimal the minimal implementation of that is happening when you just funding your wallet the first time.
00:25:18.192 - 00:25:38.950, Speaker A: Think of it. You open your wallet software, you see the address. It is not deployed anywhere. You see your address, you go to index and you move ETH or whatever into it. And then you make a transaction with that wallet. If you think of it, this wallet contract will pay for its own deployment and then execute. Yes, that's how a count abstraction implementation works today.
00:25:38.950 - 00:25:40.184, Speaker A: So it works.
00:25:40.302 - 00:25:41.450, Speaker D: Any more questions?
00:25:44.380 - 00:26:21.412, Speaker F: Hey, thanks. Thank you for your presentation. I guess we all agree about the importance of account abstraction. And this is what Luxo was working on starting from 2018 and starting with ERC seven to five standard. And I was checking this ERC like way before, and I couldn't understand because it was way too complicated. But I have just two questions. Can you explain more about how users can choose the implementation and about the cross chain execution? And just an open question.
00:26:21.412 - 00:27:11.750, Speaker F: Maybe we can discuss that later. Don't you think that the standardization of the account, like the account, need more standardization of other stuff? I will give you an example if you have your account needs to receive token, it needs to implement on ERC seven to one received. On ERC 1155 received and token received for ERC two to three. But what if we come up with a new standard in the future we need on ERC 6700 maybe. And maybe also we need something related to followers or like I don't know why, because now it's related to token. Now the hype is token. Maybe in the future it's not.
00:27:11.750 - 00:27:14.084, Speaker F: We can discuss that later if you want.
00:27:14.122 - 00:27:41.256, Speaker A: I'll try. From the beginning. Yes, there were wallet accounts before count abstraction. They exist from the beginning of Ethereum, which is not far away, but they exist. We didn't invent the will. We created a standard which allows the framework which allowed nodes to support such accounts. Accounts to be able to behave as close as possible to UA accounts, like pay for their own deployments, which it's a bit tricky.
00:27:41.256 - 00:28:17.460, Speaker A: It's possible. Again, we didn't invent the wheel. Creative was there. We did standardize on a way to perform to separate validation from execution in order that validators what we call bundlers can be self sustained and can be Dos protected. Yes, the AAP is complex, but most of this complexity comes from these protection mechanisms. We should rewrite it in a way that is more account friendly. Because most people don't implement a bundler.
00:28:17.460 - 00:28:36.252, Speaker A: They want to implement an account. So they need to know what they have to do, maybe some of the limitations they have on what they do. And they don't care about the low level implementation. Yes, editorial work is required for this spec. I agree. And cross chain execution. A cross chain execution.
00:28:36.252 - 00:28:57.448, Speaker A: Let's take it off chain again. Nothing of it is in the core of the EIP. Like BLS. There's no BLS in the core. What there is in the core, for example, is the ability to do signature aggregation that you check the aggregation in one place for entire batch. This is in the core. BLS is merely an implementation of that.
00:28:57.448 - 00:29:18.750, Speaker A: We nerd several interface. You add another contract to perform it, but it's separate from the core. So it is modular. All the feature, like specific feature of wallets. You suggested some callback that exists today and maybe callback that will exist in the future. The wallets will have to implement them. Right now your EOA doesn't support them anyway.
00:29:18.750 - 00:29:38.532, Speaker A: The idea is that when you deploy an account abstracted contract, I'm not think it's even written in the spec, but we expect it to be an upgradable proxy that the owner can upgrade. And if it is an Upgradable proxy, we have a basic implementation and then the owner can change it.
00:29:38.666 - 00:29:43.460, Speaker F: Don't you think we're sacrificing security? If like we're going with upgradable.
00:29:44.200 - 00:30:09.470, Speaker A: What you do need to do is to make sure that on your first upgrade, you upgrade it in a way that now you add security. For example, after the first upgrade, specific mechanism will be able to upgrade. Okay. Account obstruction can be abused. I will not prevent you from creating an insecure wallet. I think you can create a secure wallet with it.
00:30:11.680 - 00:30:48.090, Speaker B: Thank you. Yoav is watching us and sending us messages, trying to participate in the question and answer session. Yoav just said, hey, what happens? Post validation is not part of this standard. It's not part of ERC four three seven and anything can happen. We can talk about ideas on how to make it happen, but it's not specifically related to the standard that we're working on right now. It's kind of outside of the core because we want to make the core as general purpose as possible because maybe we don't have all the best ideas yet.
00:30:49.020 - 00:30:56.124, Speaker A: By the way, if you think there is security breach and something we can add to this definition, I'll be glad to talk and we'll be glad to add it.
00:30:56.242 - 00:31:06.544, Speaker D: We are over time. However, this is a break time. So if you guys have lots of questions, we're happy to yield them. If you guys are happy to have more questions. Anybody else?
00:31:06.582 - 00:31:07.490, Speaker A: Anyone else?
00:31:10.820 - 00:31:30.120, Speaker G: So how can you make sure that a wallet smart contract wallet will be able to prove that it's, for example, only controlled by one individual versus multisig, such that the receiving contract can make a judgment call on whether it should reject or accept that call?
00:31:30.270 - 00:31:30.584, Speaker A: Right?
00:31:30.622 - 00:31:31.610, Speaker G: So, for example.
00:31:33.500 - 00:32:18.420, Speaker A: We have a separation, okay? The model we have is like this. A smart contract has a separation between validation and execution. Execution is anything it calls out you execute external content, whether it's a tongue and other validation, gets the user operation and validates whatever it likes. The minimum is validate the signature and validate the nons that it's not a replay and it's a valid signer. But it can do more. It can check the actual executed method and say, okay, I restrict access to this destination. Or if it's a complex rule, I restrict access to this destination for this signer, because I have multiple signer and each one has a different role and is allowed only specific method.
00:32:18.420 - 00:32:42.752, Speaker A: The target contract, like a token USDC token USDC token doesn't receive all this information. USDC receives transfer from a sender and it will accept it. It is the wallet logic, the logic inside the wallet, within its validation, whether to allow or disallow specific the operation we are now trying to make. Did I make myself clear?
00:32:42.806 - 00:32:43.760, Speaker G: I'm not sure.
00:32:43.910 - 00:32:45.276, Speaker A: Yes, it is complex.
00:32:45.468 - 00:33:23.720, Speaker G: Yes. If your target smart contract does not have additional computational things going on that require it to for. So, take royalties, for example. I can circumvent royalty payments if I transfer an asset from Alice to Bob, and right now with an EOA, I actually have to transfer the private key to circumvent the royalty payment. If I allow a smart contract doing that, I can change ownership.
00:33:25.420 - 00:33:29.588, Speaker A: Of that. No, because the owner of the tokens is the smart contract.
00:33:29.684 - 00:33:46.964, Speaker G: Yeah, I understand, but the point is, if I can transfer the ownership of the wallet address from Alice, you can transfer yeah, that's exactly the problem. So that is exactly the problem if you're in a royalty situation. That cannot be so.
00:33:47.002 - 00:33:48.692, Speaker A: If you want a wallet just a second.
00:33:48.746 - 00:33:50.448, Speaker G: Otherwise you're circumventing royalty.
00:33:50.544 - 00:34:21.330, Speaker A: If you want a wallet doing something illegal, I'm not saying that we support it, I'm saying that a contract may support it. For example, if you want a soul bound wallet that you can't transfer the owner at all, go ahead, create such a wallet. If you want a wallet that doesn't support set implementation, then create a wallet that will refuse to change implementation. When you fixed, you reach that implementation you don't allow to change. You can create such an implementation. We don't block such an implementation, but we support others.
00:34:21.860 - 00:34:43.312, Speaker G: Understood? Is there any standard, a way to communicate what type of wallet implementation it is such that the targeting contract can check whether because you don't know, right? The targeting contract needs to know the context of the wallet implementation to make a judgment call about the owner.
00:34:43.376 - 00:35:13.424, Speaker A: Okay, first of all, target contracts out there in the wild don't know anything about the caller except that it is a message center. They can check the code if they like. But you are talking about the use cases that don't exist with EOAS, so they really knew. Also, for smart contract calls for any operation, you are talking about the other thing. You talk about standardization, how to know. Yes, it is required. We are providing right now the infrastructure for account abstractions for wallets to be built about.
00:35:13.424 - 00:35:54.060, Speaker A: On top of it, standardization between the account contracts and, for example, the wallet application that use them is something that the ecosystem will benefit. But it doesn't exist yet, because neither the wallet nor the contracts exist today. So usually it will be siloed like a given application with a given wallet contract with given UX for it. But we will try to push and try to find innovations from the community to support such integration and such APIs. Your scenarios are interesting, but I don't think they exist at all in the ethereum ecosystem.
00:35:54.640 - 00:36:09.170, Speaker B: The short answer is an NFD can just check the code of the caller, and if they want to restrict themselves to primitive wallets, they can certainly do that. All of this will happen on a layer above what we're doing.
00:36:10.580 - 00:36:15.824, Speaker D: Did Yuav have some questions you wanted to present?
00:36:15.942 - 00:36:17.260, Speaker B: I'm a proxy for you right now.
00:36:17.270 - 00:36:21.510, Speaker D: Are you guys okay for a couple more? Okay, I'm coming.
00:36:24.360 - 00:36:25.624, Speaker A: Hi. Thanks for the talk.
00:36:25.662 - 00:36:28.730, Speaker B: I believe you're also an author of EIP 2771.
00:36:29.900 - 00:36:38.260, Speaker A: Is that right? Yes. Okay. This is the basis of meta transactions with Opengsn.
00:36:38.340 - 00:36:55.804, Speaker B: Yes. I was just curious what you see the role of EIP 2771 having in an account abstraction world, and also for those who don't know, it just explain a little. It doesn't it's not needed because it's not needed anymore.
00:36:55.852 - 00:37:42.160, Speaker A: Opengsn tried to do gas abstraction, which we later implemented into account abstraction for existing EOA accounts. And the requirement of the gas station network and network of relayers, which are the actual senders of transactions, meant that the target contract, being token or other, couldn't tell the real sender, so they had to be modified. Support EIP 2771, add the method so that it can tell the real sender, which is a pain. Adaptation of this requires the target contract to be changed. Doesn't support existing tokens, for example. If you want your token to be metatransaction enabled, you have to rewrite it. So yes, it was problematic.
00:37:42.160 - 00:38:32.030, Speaker A: It was good for DApps to add support for existing users to sponsor the gas. Account abstractions has much higher goals to replace the accounts, and it supports almost all existing contracts, as I said, with the limitation of contracts that limit themselves to EOAS, it supports any contracts on the chain, all tokens, for example. So yes, with the limitation, you need to add support for some tokens in your account. That's right. I agree. So the target here is not helping adapt building subsidizing with account obstruction, though you can do it. The target is letting the user have control of his own account and do it in a better way.
00:38:32.800 - 00:38:36.370, Speaker D: Thank you. Jorah, do you have another one? I mean, last one, maybe?
00:38:38.260 - 00:38:39.010, Speaker A: Thanks.
00:38:40.180 - 00:39:07.812, Speaker H: So I haven't looked at 4337, so it might be like a basic question, but how does ownership of the account work like the abstracted account? Is it private key held? So it's kind of like an externally owned smart contract account. Is it single owner? Is it multi owner? And the other question I have is, is this like a complementary standard to auth and Auth call? Or how would that work when Auth call is implemented?
00:39:07.876 - 00:39:39.604, Speaker A: Okay, the answer for the first question is all of the above or any of them, because each wallet can decide. As I said, we had a wallet here that demonstrates how to use zero knowledge proof instead of signatures. Another wallet that implements RSA signatures from your phone. You want EOA. Yes. Our simple implementation uses an EOA as an owner, but it's just one implementation. The other question regarding author and author, it is possible to do some of the features with author and auth call.
00:39:39.604 - 00:40:06.680, Speaker A: They basically do the abstracting payment. We believe that it is far too complex feature to justify these two opcodes because they don't do anything else of their counterproduction. They don't change. They enshrine the ECDSA, for example. So they can be combined, they can be used together, but we hope for other alternatives.
00:40:07.740 - 00:40:10.608, Speaker D: A huge round of applause for Syrian Drawer her.
00:40:10.694 - 00:40:12.160, Speaker A: Thank you very much. Thank you, everyone.
00:40:12.230 - 00:40:13.330, Speaker D: Thank you so much.
