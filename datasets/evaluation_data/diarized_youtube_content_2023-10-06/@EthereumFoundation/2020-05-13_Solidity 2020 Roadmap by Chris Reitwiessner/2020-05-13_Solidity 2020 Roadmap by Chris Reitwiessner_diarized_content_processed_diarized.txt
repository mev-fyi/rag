00:00:00.420 - 00:01:03.770, Speaker A: You okay, so I will talk about Solidity's roadmap for 2020. Having said that, the solidity project is not a project that has fixed roadmaps, and this is also one reason why we're having this summit here, to talk about future features and agree if we want to have them and how. So there is one thing we very much focus on and that is completely set, and that is the reimplementation of the code generator using our intermediate language, Yule. We are currently roughly at 50% implementation of the full language features. And yeah, we'll talk more about that later. And then a second important thing is the SMT checker. So our formal verification tool.
00:01:03.770 - 00:02:18.370, Speaker A: We would also like to get almost full coverage of the whole language until the end of the year. But yeah, for both these topics we'll have to see our party cat. And then maybe more interesting for you, we plan to have at least one, maybe two breaking releases with new breaking features. Some features can of course also be introduced in non breaking releases. And yeah, I would just like to highlight some of the breaking features that I myself find interesting. And for one, this is a feature that makes the copying semantics more explicit and also makes at least reference types immutable by default. So if you want to have a memory array where you can change values, then you have to specifically mention that at the point of declaration there will be a discussion session on that topic on day two at 07:00 p.m..
00:02:18.370 - 00:03:04.384, Speaker A: CST. And then another topic, safemath. By default this is arithmetic overflow checking at runtime, introduced automatically by the compiler. We did not introduce that for a long time, for two reasons. The first is that we think that the existing optimizer has a hard time dealing with that, and the second is that it can introduce new bugs. But we see that everyone is just using the Safemouth library, and because of that we would like to have a discussion on whether we should introduce that by default or not. And that discussion will be on today at 340 p.
00:03:04.384 - 00:03:54.160, Speaker A: M. Then another interesting feature is call data variables. We already have the call data location specifier for function parameters of external functions, but there's no really big reason why call data cannot be used for any other variables. So local variables and parameters and internal functions. And I think this could yield nice performance improvements because it does not. Because when you have a memory variable and just use that for call data content, then you always need a copy to memory, which could be unnecessary. And in addition it guarantees that you can modify such the content of such variables.
00:03:54.160 - 00:04:57.632, Speaker A: Then another interesting topic is language servers. So during the last, actually last weeks, few months, we noticed that people have a hard time debugging solidity code. And just in general working with in general the development process could be better. And because of that we thought about implementing a language server as part of the compiler. Language server is an initiative started by Microsoft to standardize the interface between compilers and debuggers and IDEs. And as soon as you have a language server for a language implemented, then any IDE that also has language server support can work with that language. So this is a nice generic way to provide access to compiler features.
00:04:57.632 - 00:06:18.050, Speaker A: And the cool thing about that is things like Gotodefinition are probably rather easy to implement for us. And while several IDEs already might have that feature, the interesting thing about implementing it in the compiler itself is that when you use the gotodefinition feature in the IDE, it uses exactly the same code that does the identifier resolution during code generation. So you're 100% sure that it goes to exactly the same definition that is referenced in the final code? Yeah, tomorrow at 04:30 p.m. And then also in the same direction we want to improve the output of the compiler that can be used for debuggers. Or more general, I don't know, how would you call it, code inspection routines. This is an initiative that was started by the Truffle team last year, or maybe even two years ago, and some more teams joined in the meantime. And yeah, the discussion about that will be today at 08:50 p.m.
00:06:18.050 - 00:07:30.500, Speaker A: And yeah, two things that we always do in parallel, regardless of specific features, is improving the new Yule based optimizer and improving the webassembly output. And these two are kind of interconnected. And yeah, talking about Yule, let's go a bit more into detail about Yule, because there are still some misconceptions around about Yule. Yule is a simplistic intermediate language we have been using for quite a long time, at least for parts of the compiler. And the idea behind Yule is that it should be human readable, and not only machine readable. And we hope that we can build our Yule optimizer, or currently we hope that it has that feature to generate code that is still readable by humans. Even after the optimization.
00:07:30.500 - 00:08:46.850, Speaker A: There will be two sessions around Yule. One of them is about Yule plus that is an extension of Yule developed by Nick Dotson. And that is today at 05:10 and then right after that at 540, a discussion group about new features for Yule. And yeah, our hope with Yule is that it allows people to understand much more what is happening behind the scenes in the compiler, that it allows to actually inspect the generated optimized Yule code that is then very very close to EVM bytecode. And it allows this Yule code to be fully audited. And because of that you do not have to rely on a definition of the solidity language or absence of bugs in the compiler. Yeah, let me just quickly check the time.
00:08:46.850 - 00:10:10.604, Speaker A: The nice thing about Yule is that it has very few features, but it is a structured language, so it has for loops, user defined functions and so on. And it is extensible and typed, which allows it to be used for different purposes. For example, we're thinking about adding memory allocation features to the optimizer that allows lifetime tracking of memory objects and out of bounds access and so on. And yeah, all this will hopefully be covered in the discussion later today. As far as the Yule code generation in the solidity compiler is concerned, we are pretty far ready so early. I said 50% but yeah, 50% of the features does not mean 50% of the smart contracts out there. So please try it out whether it already works for your smart contracts.
00:10:10.604 - 00:11:11.600, Speaker A: And you can try it with salt C minus minus IR. This shows you the originally generated intermediate code for the smart contract. But this is usually not something you would like to look at because we are writing the code generator in a highly modular way, which means we have many many different functions for each tiny functionality that constantly call each other and the optimizer, it will inline all that. And most of these functions in the end just do nothing. So what you would like to look at is the output of salt C minus minus optimized minus minus IR minus optimized this is a bit weird. So if you just use minus minus IR minus optimized, it will show you the intermediate code after optimization. But if optimization means no optimization, so if you did not switch on the optimizer, then it will be the same as before optimization.
00:11:11.600 - 00:12:01.300, Speaker A: So please always use these two flags together. And having said that, Yule output from solidity is still experimental, so we might change any of these flags in the future. We might introduce different built in functions and so on. So this is still experimental, while Yule itself is not experimental anymore. So if you want to take Yule code and use it as input then this is pretty safe. I never say it's foolproof because no software ever is, but it should be pretty safe and it is being used out there already. Then one last thing about the SMT checker.
00:12:01.300 - 00:13:04.180, Speaker A: There is a session at day two on 06:00 p.m. About more or less formal aspects of solidity, a formal specification language. And I'm not the expert on the SMT checker in the solidity compiler that would be Leo, but he told me that it can do already quite a lot. It does function abstraction, which is really nice. So when you call a function internally, it does not always inline it, but instead it tries to infer properties of the function and just use these functions. And I think invariants are not yet implemented, but this is something on the roadmap and also one of the main topics of this session on day two. Bye.
