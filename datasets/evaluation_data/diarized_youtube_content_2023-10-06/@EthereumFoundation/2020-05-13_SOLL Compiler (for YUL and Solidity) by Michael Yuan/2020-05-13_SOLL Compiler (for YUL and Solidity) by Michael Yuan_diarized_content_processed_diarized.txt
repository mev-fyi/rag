00:00:03.350 - 00:00:37.422, Speaker A: The SOL team, that's how we position it. It's an llvm based toolkit for solidity and ur actually. So it's solidity on LLVM. That's where the name came from. It's not very imaginative, but anyway, so we are very distributed team. I live in Texas, but most of the engineers that work on Sol, they live in Taipei. And in a minute you're going to know why because a lot of this compiler talent actually come from the semiconductor industry.
00:00:37.422 - 00:01:23.060, Speaker A: So that's our background. It's primarily in compilers for chips and for hardware and things like that, and also for enterprise software. Myself has a background in enterprise software. So Haidai Thai from our team would give a more in depth overview of Seoul tomorrow. He has a talk schedule for tomorrow, so if you like what you hear today from know, make sure that you catch his talk. Oh well, my publisher made me do it. So this is a book I wrote last year and it has a lot of solidity and developer tools, and it's probably too much of an entry level book for this audience, but I just want to put it here.
00:01:23.060 - 00:02:46.522, Speaker A: It's published by Anderson Wesley in the US. So anyway, let's get started. So first of all, the burning questions you all want to ask is why another compiler? Why do we need another compiler? What were we thinking when we started almost a year ago when we decided to write another compiler? So I want to put up the two quotes with Alec had back in 2018, and he talked about one of the major strengths of Ethereum or any decentralized ecosystem really is a diversity of tools and diversity of software, right? It's decentralization of software. So that's where we see ourselves in this ecosystem, is to provide, I wouldn't say alternative, but to provide another way to do another tool chain for a prevailing language like solidity or URL, so that we can have multiple front end, multiple back ends, then to have another toolkit that provide more stability to the ecosystem. So that's where we see ourselves coming from. So what is it? What exactly this know just that it's solidity on VM. So at the current know, if you look at the released software of Sol on GitHub, there's three major parts.
00:02:46.522 - 00:03:34.682, Speaker A: The first is we have solidity to evaSm. Compiler evasm stands for Ethereum flavored webassembly. You already knew that. So it can compile solidity source code to Webassembly, Ethereum flavored webassembly. And the second aspect of it, it's Yule to evasm compiler. And another interesting aspect of it is to generate EVM targets, the traditional current generation EVM targets with the help of the EVM LVM project, which is Project Alan Lee led. So most importantly, our position of it is not just a compiler that you can use out of the box, it's a collection of tools and libraries to build your own language tools in the Ethereum ecosystem.
00:03:34.682 - 00:04:35.710, Speaker A: That's how we see this project going in the future. So here is a GitHub link to this project. It's second state, so it's easy to remember. So before I go further, I want to take a minute to talk about why know that's Ethereum flavored webassembly, why do we choose that as a compilation target? Why don't we just do evm directly? First, of course, is that because there's already a solid EVM compiler and it's widely used and we don't really necessarily want to compete with that from the get go we try to choose another compiler target that is up at the coming. And also because as a team we also build our own webassembly runtime. And the mode of that webassembly runtime is evadone. So if you go to our other project, it's called SSVM, it's second state virtual machine.
00:04:35.710 - 00:05:39.410, Speaker A: It's a fully compliant webassembly virtual machine. It can be used on the server side and also primarily used on the server side, I would say. And it has a mode that is called evasm mode that you can actually, we have confirmed it passes all the state for evasm tests, so it passes the test suite 100%. And so with so and ssvm you can actually now start an EvASM private node and use so to compile your solidity contract into webassembly and run it on that. So it's sort of like a mini testnet and or simply use our testnet. There's a testnet that we had in partnership with cybermiles that use the older generation of what they call ethermint, ethereum on tenement. And then we put the ssvm evosum in there to replace the guest virtual machine.
00:05:39.410 - 00:06:27.650, Speaker A: So that provide a complete end to end solution that allows people to compile from UL or solidity source code to webassembly bytecode and then run this webassembly bytecode in an actual blockchain. So that's the work that we have done so far. So here is a demo. I'm glad it runs because I don't have to go to YouTube for that. But it's animated, Jeff. So it basically shows that the big chunk of text that you just saw, sorry, this goes too fast, but the big chunk of text you just saw is compiled bytecode encoded into hex format. And so this is your standard guest console that connect to our testnet that allows.
00:06:27.650 - 00:07:17.970, Speaker A: So it goes over again it unlock account and put that in there and deploy it as a contract. So what contract that is? That contract is the ERC 20 contract that compiled to Webassembly bytecode and then run on the evolution testnet using. So there's a lot of tools, multiple tools that we have developed so far. So it basically shows you that you can use the console to make transfers from inside the contract. So that's just the work that we have done that we can demonstrate here. So if you go to our software release page, that you can see the current status of the compiler. The current status of the compiler.
00:07:17.970 - 00:08:21.930, Speaker A: So with every release we test all the almost 500 test cases from the U library and we pass almost 80% of it. So here the text on the bottom of the page says the features that are currently supported by Seoul. There are still many features in EO that are not yet supported that we're still working on that. But as I have also heard that your language itself is evolving. So we definitely want a closer partnership with the rest of the solidity team and your team so that we can have a really strong roadmap that we would be able to support all those features in the near future. Currently it passes over close to 80% of all the test cases of Yule. And what about the solidity front end? It's less impressive.
00:08:21.930 - 00:08:50.046, Speaker A: Solidity has 80 testing contracts. Those are not unit tests, but four tests with complete contracts. And we can pass 27. There's still a lot of features that are not implemented. Solidity features that are not implemented. So however, we have found some of the solidity contract we can use. So C to compile it to yo and then use to compile it to webassembly.
00:08:50.046 - 00:09:33.546, Speaker A: That path that we have walked for a couple of those contracts. But straight from solidity, we can support one of the most commonly used contracts that ERC 20 contracts. So that's where the demo that you have just saw is the ERC 20 contract written in solidity, compiled by so and then deployed on evasive. So below is some of the text. Here is some of the unimplemented language features in solidity. So as you can see, there's still a bunch of things that we are thinking about. What's the best way to implement even basic features like return multiple value? It's still our roadmap.
00:09:33.546 - 00:10:09.702, Speaker A: So Hadadai from our team going to be able to talk more about this tomorrow. That's why we choose to implement some features first and why some are difficult to do well. We just talk about. So as a compiler tool. So as a compiler tool as of today I think is a prototype. So it's not yet ready for production use, obviously, because it doesn't pass all the test suites. So it provides some interesting features.
00:10:09.702 - 00:11:15.940, Speaker A: And however, going forward, what we really see, so as a toolkit, as a library of components that other people can use to build their own languages. So for instance, because it's based on LVM, it's an intermediate language, so it can support multiple language front ends. Right now we have demonstrated partial support for solidity and UL, but there's UV binding for rust that can compile into our OVM not through our tool, but can be mixed and matched with a rust compiler in that way. And there's more than 20 languages LVM already supports. So by building on that framework, we thought there may be an opportunity for us to become one of the tools in the tool chain or in the tool chats that people can use. Then I put here is an article from etc course Alan Lee that he talked about. He wrote it yesterday, he talked about building domain specific languages using.
00:11:15.940 - 00:12:22.470, Speaker A: And then on the back end, on the front end, that we are envisioning a toolkit that can support components that can support multiple programming languages. On the back end, we are envisioning the toolkit can support multiple runtime targets. So we have already shown Webassembly and we have shown through EVM, LVM project, we can support today's EVM. But what about, I thought, more interesting use cases or not really more. You know, one of the popular use cases is the non blockchain crypto use cases. If you look at other projects out there like Facebook, Libra, or the chinese central bank project, the digital Z project, those are all, I would say, projects that are rooted in crypto but not blockchain based. So they use a lot of infrastructure that come from the crypto world, like the digital wallet, the smart contracts, things of that nature, but not necessarily blockchain based.
00:12:22.470 - 00:13:50.066, Speaker A: Is there a possibility to build a toolkit that makes solidity a more of a more general programming language that can be used in those kind of scenarios? So here's what we mentioned with a toolkit like so that we might be able to do so. For instance, one of the things that has going on in the academic world for a very long time is formal verification. But before blockchain come on, it's very few, very little code has been actually formally verified or have that kind of security. Even in the banks people don't bother to do that. But solidity is probably one of the early first languages that has a lot of tools around formal verification. But is it possible that can we use formally verified solidity application in cloud computing environment instead of just in blockchain? Can we set up, say, a function of service, function as a service or a container service on Amazon cloud that can run solidity code, formally verified solidity code instead of having to have a blockchain on the back end, things of that nature. That is something that from our point of view, it's really interesting that we want to make Soul part of the bigger story in the Ethereum system as a blockchain system and also in the cloud computing system.
00:13:50.066 - 00:14:19.350, Speaker A: So anyway, that's all I have. And again, the project on GitHub is GitHub Secondstate Sol, and we'd love to hear your feedback and we'd love to have more collaboration with the community. And I think I'm two minutes left, so thank you very much and if you have questions. Wonderful. Thank you, Michael.
