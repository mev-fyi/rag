00:00:11.610 - 00:00:35.526, Speaker A: So I'm I'm Lakshman and I'm going to be talking about some work that I've been doing with work with Ethereum Foundation. It's not particularly glamorous work, but it's kind of necessary work to get them.
00:00:35.548 - 00:00:36.200, Speaker B: To do.
00:00:37.930 - 00:01:35.130, Speaker A: Is like making sure we have kind of a decentralized relayer network. I'll talk a little bit about the problem, probably won't spend too much time on that because I'm clearly familiar and then I'll kind of talk through what we've built so far and kind of what the next steps are. Okay, so this is like a very primitive diagram about what an on chain mixer is. I'm actually really excited about this primitive in particular because it's one of those things that is pretty obviously different on chain versus off chain. In privacy in particular, you really don't want people to see what you're doing. And so trusting someone to mix your funds, like trusting a socket wallet or something like that, makes for a completely different user experience as something that is completely trustless. And you're like hiding in a crowd found in plain sight.
00:01:35.130 - 00:02:16.310, Speaker A: So just real quick overview how these things work. You put money into the contract and then let's say a bunch of other people put money into contracts. You are a BCD and put money in money and then later a prime from another address you can generate a proof, a zero knowledge proof that says you are one of those people who put money in without saying which one. And that entitles you to some of that money. And so to someone looking, someone doing a chain algorithm like that, looking at the network and trying to analyze whose money is whose, they just see 410 or thousand going in and thousand going out. They can't. So yeah, pretty powerful primitive.
00:02:16.310 - 00:03:08.470, Speaker A: So real quick overview of why relayers at all are even necessary. So one of the main things that I've heard that people want to use these kind of thing for is funding addresses that are not associated with any of the addresses you currently have with Keep so you can interact with the network with them. So in this case, let's say A is one address, a prime is another address. Want to fund a prime and you put money in a prime, then has to withdraw the money with this zero proof. But if they have zero, that's where relayers come in. This also isn't like a new idea. Many projects talk about meta transactions, transaction abstractions.
00:03:08.470 - 00:04:15.870, Speaker A: The idea is for certain things, you might want a third party to run transactions for you. So this is what that new kind of transaction flow looks like. So A deposits money into the contract, presents a signed transaction to the relayer, who then runs the transaction on their behalf. And then over the course of that transaction, money comes out to a prime and not pictured, but some of that money might come out as relay, as like a reward for the service. And so this is kind of the case I'm trying to make, is that the central relayer defeats part of the purpose of a trusted mixer. And a lot of the projects, the olive oil implementers, some of them here right now are obviously shipping with a single central mixer, which is I think when you're shipping an MVP, you kind of want to ship the parts that you really want to test initially. So it makes sense maybe not to do like a fully featured thing at launch, but a single real error has two problems.
00:04:15.870 - 00:05:16.478, Speaker A: So one from a user perspective, if you know that the company running the relayer is the same as the company, kind of like serving the client code for interacting with the mixer, there's no way for you to know. That there isn't some communication going on there, or even more kind of nefariously that there's some communication going on behind the scenes from the web server servant client code in the relayer. And if there's some pattern in how the time between deposit and withdrawal in the client code, then the relayer might be able to figure out who you are. Another thing is obviously if you have a single relayer for serving a mixer, there's issues with censorship, issues with artificially high speeds. So ideally, we would have many relayers serving each mixer. So that is what we're trying to solve. At we're currently in the process of integrating it with one mixer.
00:05:16.478 - 00:06:01.120, Speaker A: We're looking to integrate it with everyone else. So it's like pretty, I would say pretty alpha stage. But the ideas are that anyone like you or I could just run a docker container that is a relayer and you immediately be a part of this network. Any existing mixer doesn't have to change their contracts anyway to use this and just has to change their client. So literally install an MPM package and change how they find relayers. So this part, I'll kind of go over the main parts of what this is. I might try to actually speed through this because it's a little technical and leave more time for questions.
00:06:01.120 - 00:06:49.534, Speaker A: But this is kind of like analog the previous diagram where you looked at where you had someone who's trying to interact with the mixer. You have a mixer contractor for relayer, and we're adding these four components. The really key parts are the client, which is like an NPM package that you can put into wallet or mixer client code. The daemon, which is just like kind of the server of the relayer essentially. And then two more contracts that are necessary but sort of serve as a discovery mechanism for relayers as well as like transaction forwarding. These we have like our first we've kind of been doing some research into the right way to do reputation in particular. And so we have like our first eliminations and stuff.
00:06:49.534 - 00:07:37.626, Speaker A: But we're also talking with the gas station network to see if we can integrate down, and they I see as kind of filling that role as well. So first, talk quickly about clients. The client's main role is find relayer, so it communicates with the reputation contract. The idea is that let's say this is a client, this is a user. So this is also where, let's say, the wallet code or the Mixer client code in your browser on your mobile. And so through our library, it figures out where your relayers are, and it allows you to submit transactions to those relayers. And this is structured pretty simply in the GitHub repo.
00:07:37.626 - 00:08:06.258, Speaker A: You can see it's just like an MTM package. And right now, I have an example of getting the best relayer IP. Of course, I can do, like, a core address or something. It doesn't really matter. But that's designed to be very simple. So next is the daemon. So really, we're going to share, like, a reference sort of API that this should expose to properly communicate with the client.
00:08:06.258 - 00:09:05.530, Speaker A: We were also releasing, like, a reference simulation of this that does some fancy stuff around transaction simulation. But this is something that technically, like, anyone can create a custom version of. If this becomes, like, a high volume activity, you'd imagine that people would want to create really high performance things that look at the network and make sure you're not getting front run and stuff like that. Right now, we do some very basic transactions. So basically, what happens in the current version of this code is for any transaction, it simulates running that transaction, sees how much running that transaction changes your own e belt, and if it's, like, beyond a certain amount, basically. And super simple. If you have docker installed, it's literally just running a few commands to run that.
00:09:05.530 - 00:10:10.080, Speaker A: So this is designed so that anyone could run. It would be really cool if ransom people run relayers. These are the two critical pieces for this test. There are some other routes, but basically, for a given transaction, you need to tell clients what the fee you charge is, and you can tell clients, and you need to be able to mint those transactions, share the transaction. And so, finally, this last piece, which is a board of reputation contracts. So the idea here is that the reason we wanted to start, we want to kind of, like, create this set of abstractions that we can talk about with something else, is because it's nice to have trusted discovery, some kind of understood mechanism of relayer discovery. And this is something we can play with.
00:10:10.080 - 00:10:32.598, Speaker A: Forward a contract is very simple. It just literally forwards calls to the application contract and the state Mixer. Yeah. And the reputation contract. Yeah. I can talk at length about this. I don't think I will right now unless people want to talk about it.
00:10:32.598 - 00:11:36.490, Speaker A: But there's an ETH research post that I publish of Barry WhiteHat on this. So if you just Google for really just spreading your research. You can kind of see our thinking there broadly. It's like the more ether you've burned in service of life, in service of relaying transactions, maybe the higher reputation is but there's a lot of parameters to be tweaked there and something we're still actively cool and so finally the next steps are a big part of what I'm trying to do in Devcom. Talk to a bunch of mixer teams, talk to a bunch of wallet teams, see how we can integrate this into the existing flows and talking with the gas station networks and some other kit. Cool. So that's me on Twitter at the top and that is where the repo is for surrogate.
00:11:36.490 - 00:11:42.720, Speaker A: Probably have a lot of time for questions.
00:11:43.490 - 00:11:46.270, Speaker C: How do you protect against the front runners?
00:11:47.970 - 00:11:52.254, Speaker A: What do you mean? For the relayer. From any partner? From someone else? Yeah.
00:11:52.292 - 00:12:12.790, Speaker C: So it depends on your design, how you pay back the relayer for the service. So if I submit a transaction as a ReWare and if you return it to message handler then the front primary is incentivized to get it because he wants to raise from primary.
00:12:16.090 - 00:12:30.380, Speaker A: There's sort of a trade off between yeah, it's something we thought about a lot. I think the easy answer is you would expect that to factor into the fee market. It's kind of part of the cost of doing business of running every day.
00:12:31.970 - 00:12:58.120, Speaker C: No, but how do you protect because on the first day when we launched another cache we didn't so we got from run sorry. For another cache. So then on the first trial when we launched the main net, we got front run right away. So that's why we're like okay, so we're saying.
00:13:00.490 - 00:13:15.558, Speaker A: I didn't really go into detail on this, but the address of the recipient go ahead. Goes in the proof. Yeah. Address of the real error. Yes. So because the address of the real error is one of the inputs in our okay. Yeah.
00:13:15.558 - 00:13:23.390, Speaker A: Because you mentioned you can't front run. I don't know what you're talking about, but you literally can't from I understand it.
00:13:23.540 - 00:13:41.186, Speaker C: Okay. So you're using the same production but that means you have to design a smart contract in a way that would decode the TT proof prevent from dynamics because in that proof you have to.
00:13:41.208 - 00:13:55.720, Speaker A: Have the address of the relay that's right. So that can exist in the contract or like the thing that's right, that's right.
00:13:59.690 - 00:14:11.414, Speaker B: So if I'm a relayer and I say I will relay your transaction but I don't, what happens then?
00:14:11.552 - 00:14:58.758, Speaker A: Yeah. So there's actually another interesting trade off here in designing the client logic. You can either broadcast to every relayer and then relayers kind of are at risk or you can broadcast to one relayer and then the client's kind of at risk. And there's a spectrum of choices and how you choose to kind of your broadcast strategy, essentially and retry strategy that lie along that spectrum we are opting towards in this implementation, and this is open discussion to protect the client experience. So the client logic, by default, will try a ton of relayers and retry. So there's more a little bit of risk that relayers get screwed, but we'd.
00:14:58.774 - 00:15:00.294, Speaker B: Rather be competing effectively.
00:15:00.342 - 00:15:13.946, Speaker A: Right. So they can lose again, we'd rather push the competition of the relayers and make it a little more expensive to them than make the client experience worse. But the way it completely solves the problem is just fed it to everyone immediately.
00:15:14.138 - 00:15:17.586, Speaker C: But then Rewers are going to lose money.
00:15:17.688 - 00:15:33.414, Speaker A: Yes. So that'll factor into again, there's a trade off here and fundamentally what happens there is that just factors into the fees market. It's like another cost, but it's not.
00:15:33.452 - 00:15:34.870, Speaker C: Convenient for the user.
00:15:41.790 - 00:15:46.346, Speaker A: Yeah. It's paying for not having to wait. Yeah.
00:15:46.368 - 00:16:01.310, Speaker C: GSN has the same problem. So I talked to them, they said, well, I proposed an idea, maybe if they have some sort of mempos and everywhere can share the mempools so they don't execute the same transaction.
00:16:02.710 - 00:16:09.380, Speaker A: That's an interesting idea, but then.
00:16:13.110 - 00:16:13.438, Speaker D: There'S.
00:16:13.454 - 00:16:18.920, Speaker A: A way to grieve it, obviously. Yeah. The way to grieve this is just not share your stuff. Yeah.
00:16:19.690 - 00:16:30.070, Speaker C: Then it's like you would have to have some sort of teacher man or something who is going to watch GSN. They wanted to have future men on it, they just haven't.
00:16:33.150 - 00:16:39.766, Speaker B: So if you say that the approach you're going is that you kind of broadcast the transaction.
00:16:39.798 - 00:16:40.746, Speaker C: This is something I want to do.
00:16:40.768 - 00:16:47.950, Speaker B: To all of the relayers. So how is this going to work? Because every relayer, they can have a different fee right, that they want to charge for.
00:16:48.020 - 00:16:50.750, Speaker C: No, basically only one relayer will succeed.
00:16:51.250 - 00:16:57.598, Speaker B: Yeah, I know, but I as a customer, I mean, every relayer charges a different fee and they choose which fee.
00:16:57.614 - 00:16:58.258, Speaker C: They want to choose.
00:16:58.344 - 00:17:11.320, Speaker B: They want. But then if I broadcast to everybody, am I accepting any fee or only the lowest one or range that I'm willing to pay?
00:17:12.330 - 00:17:25.986, Speaker A: Yeah, there's like a bunch, like you might say there's some predicates you can define for each subset of every try and depending on kind of like how restrictive or not restrictive, that predicate is like, how much you pay and how much you weigh.
00:17:26.018 - 00:17:30.640, Speaker B: Changes like a filtered protocol this.
00:17:44.210 - 00:18:27.680, Speaker A: Cool. How do you boost track reputation? Yeah, that's really tricky. Not completely completely obvious. Yes, it's my short answer. One mechanism is to just kind of like have like the kind of naive mechanism that we've been thinking about starting with is just having entry probably just burn, not using otherwise. But obviously that only distracts the amount of membership, lead times, the number of people.
00:18:31.170 - 00:18:36.118, Speaker C: Do you use reputation as a mechanism to choose which reward?
00:18:36.314 - 00:18:37.060, Speaker A: Yeah.
00:18:38.630 - 00:18:46.420, Speaker C: But how then the other new rewears will compete rewears with.
00:18:48.410 - 00:19:06.700, Speaker A: Yeah, there is a tendency. Yeah, I guess one thing that you could do so right now. This is certainly a challenge. If you've been around for a long time, there's a higher chance that you can discover in the future.
00:19:07.070 - 00:19:07.722, Speaker C: Yeah.
00:19:07.856 - 00:19:16.478, Speaker A: But one thing that you can do is have the ability to kind of like re up on your addresses like that.
00:19:16.564 - 00:19:16.862, Speaker B: Yeah.
00:19:16.916 - 00:19:33.090, Speaker C: Or maybe you can use a ReWare reputation mechanism, but not like every request would use that reaperation points to choose everywhere. So maybe we can do some randomness.
00:19:37.510 - 00:19:40.398, Speaker A: We can definitely just put that force that in the client.
00:19:40.574 - 00:19:45.160, Speaker C: Yeah, that's basically the pitch from Algorand. That's how they choose the.
00:19:46.970 - 00:19:48.200, Speaker B: Sign of night.
00:19:50.330 - 00:19:52.142, Speaker A: But we could just do some rent.
00:19:52.306 - 00:19:53.850, Speaker C: Exactly, it's in the client.
00:19:54.750 - 00:19:57.946, Speaker A: Yeah, it's a good idea. Standardizing that.
00:19:57.968 - 00:19:58.540, Speaker C: Also.
00:20:01.570 - 00:20:55.680, Speaker A: I'm not sure what slide number it was, but there was like a reputation contract slide. Could you maybe still explain because I clicked my name. Yes. Again, I kind of went over these a little quickly, partially because we have our initial implementation, but this is something that we're exploring, swapping out or maybe even like proxying some other systems that's doing reputation, like gas vision somewhere. But what we've implemented is there's like a portion of each relay that you can choose, the relayer portion of each relay or fee that the relayer can choose burn. And then the reputation is just a function of the number of times they've relayed and the total amount they've burned. Good.
00:20:57.570 - 00:21:00.640, Speaker C: And the most important question is production ready?
00:21:03.270 - 00:21:05.860, Speaker A: Almost production ready. Very close.
00:21:08.710 - 00:21:09.822, Speaker C: No pressure.
00:21:09.966 - 00:21:10.660, Speaker B: Yeah.
00:21:14.070 - 00:21:29.030, Speaker A: I think by the end of the month, I mean, we're kind of like working with you and the other Mixer amendations, like in launch that all I do is once you guys are ready to launch what you're already launched.
00:21:32.030 - 00:21:37.658, Speaker D: How are you who do you think will be the biggest users of these things?
00:21:37.824 - 00:21:41.230, Speaker A: That's mixers? Yeah.
00:21:41.380 - 00:21:42.478, Speaker D: Specifically who?
00:21:42.564 - 00:21:45.310, Speaker A: It's a big question. Specifically.
00:21:47.010 - 00:21:48.720, Speaker E: Everyone sending money.
00:21:49.890 - 00:21:50.878, Speaker D: Do you think so?
00:21:50.964 - 00:21:51.600, Speaker A: Yeah.
00:21:52.710 - 00:21:59.810, Speaker E: When you send ETH or die or whatever wallets should just default you're sending.
00:22:03.110 - 00:22:34.300, Speaker A: There'S one thing that's like a little tricky, which is that the NMD set is defined by how much you're sending. The reality is if you're sending 10,000, there's probably not going to ever be a large amount. And so there's going to be some my guess is there going to be some multimodal distribution around which specific anonymity sets are really popular. The way I think of it is.
00:22:34.990 - 00:22:39.086, Speaker E: Right now, the way that states or native cash works is that they have.
00:22:39.108 - 00:22:41.226, Speaker A: A specific use case which is you're.
00:22:41.258 - 00:23:12.694, Speaker E: Trying to disconnect the output from the inputs and so therefore you have to have enforced same amount on both sides. You can't match them together, but if you look at, say, the Zcash blockchain where they have just a shielded pool that anybody can send any amount into and then send any amount out of your anonymity step becomes everybody who's ever sent money into the pool. And so they don't enforce.
00:23:12.742 - 00:23:14.058, Speaker A: Like, you have to send a specific.
00:23:14.144 - 00:23:32.750, Speaker E: Amount in and a specific amount out. So people can send 10,000 E's into the shielded pool and then send any fraction of that 10,000 E within the shielded pool. And it's only if they decide to leave the pool that they might need to think about what their amount that they're sending out.
00:23:32.900 - 00:24:10.170, Speaker A: Yeah, I think the shielded pool approach actually I think this is what this is broadly what UI Nightfall is doing. They're kind of creating who knows what they're actually going to do with it, but they're trying to create some standards around a shielded pool contract. I think that is useful for I almost think of that as slightly separate segment of markets and mixers. My big open question there, and I don't have like a positive or negative kind of sentiment yet, is if shield pool gets really large, how does that affect? Is there a cap on your hand that scales up worse demographically?
00:24:11.790 - 00:24:25.840, Speaker C: You can have multiple shield pools probably with a fixed amount of network tree participants, so that will not be like a very expensive once you fill in one show.
00:24:27.490 - 00:24:58.780, Speaker A: Yeah, that's right. So you'll have segmentation that might be smaller than a mixer, but gives you the option of any quantity. So there's a trade off there, Tony, to kind of like, answer my opinion on your question. I think it's going to largely be people who want to move small amounts of ETH to interact with contracts from addresses that are not associated with their contracts. I think it's like small amounts of ETH. I don't think it's going to be like large amounts of.
00:25:02.350 - 00:25:03.274, Speaker C: Maybe people are.
00:25:03.312 - 00:25:10.606, Speaker E: Betting in a controversial locker market or exactly. Setting up voting in a controversial Dow or something right.
00:25:10.708 - 00:25:12.960, Speaker A: Doing things that they want.
00:25:14.050 - 00:25:21.200, Speaker C: Think about that feedback. You ask like, you want to RSVP, but you don't want to show the people like you have.
00:25:24.890 - 00:25:40.200, Speaker D: I think it's mostly people that want to kind of watch their coins and disassociate their holdings from their real world identity that all of your answers weren't about that. Is there a reason why you don't think that's going to be the main reason? The main metric for us.
00:25:41.950 - 00:25:42.426, Speaker C: It could.
00:25:42.448 - 00:25:45.850, Speaker E: Be a matter of breaking the link between KYC exchanges.
00:25:47.150 - 00:26:00.910, Speaker A: That's a perfectly valid yeah. Do you know wasabi has like, how does wasabi segment based on the amount you want to send? Do they have fixed amounts?
00:26:01.330 - 00:26:18.820, Speaker D: They don't have fixed amounts, but they will tell you how good your anonymity set is based on how much you want to mix. They do have six. Oh, sure. But you can choose to mix like.
00:26:22.070 - 00:26:22.830, Speaker A: Right.
00:26:23.000 - 00:26:25.202, Speaker E: It'll break it up into a .1 chunk.
00:26:25.266 - 00:26:27.300, Speaker A: Looks like I'm out of time, so let's take a few.
