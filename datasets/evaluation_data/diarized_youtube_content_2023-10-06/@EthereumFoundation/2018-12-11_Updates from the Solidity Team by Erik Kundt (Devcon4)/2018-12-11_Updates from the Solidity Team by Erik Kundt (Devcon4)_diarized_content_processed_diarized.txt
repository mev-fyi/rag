00:00:07.370 - 00:00:50.906, Speaker A: Hello everyone, welcome to my talk. I wanted to give you some updates from the solidity team. So my name is Eric and I just joined the team half a year ago, so it's nice opportunity to actually be here and talk about what we did so far. So first of all, I want to quickly give you an overview of what I'm going to talk about. So first I want to introduce some of our new tune team members to you. Then I want to talk about the audits that the compiler got. Also want to talk about Solidity 50, which is probably what you are going to be here.
00:00:50.906 - 00:02:01.170, Speaker A: And then want to talk about what's coming up, what we're currently working on, and what will be released on upcoming versions, and also how to contribute possibly to the. So, okay, first of all, what happened to the team? You might know that for the last years, almost like Alex and Christian were working on the compiler and on the infrastructure, but now we grew the team to seven people in total. So we have another Christian that joined who cannot be here, unfortunately. Then we have Christian, you might know him. And then we have another Chris that joined, and he is our technical writer, so he's mainly working on the documentation. Then we have Daniel, me and Leo, and we're all working as software engineers in the team. Next one, what happened with the audits? So last year the compiler was audited by Coinspec for Auger, and this happened in the end of 2017, and they discovered ten issues.
00:02:01.170 - 00:02:46.206, Speaker A: Fixed nine. And the last issue is part of the inheritance changes, and you can also find a report on medium. So the second audit that we got started in June and was done by the people from Zeppelin, was sponsored by the foundation and by Auger. And they work very closely with us and they audited a specific compiler version. But the issues are being fixed in develop already and so most of them will be part of 50. And there's also an interesting talk about that, about the audit itself. It's going to happen tomorrow at 140 p.
00:02:46.206 - 00:03:26.386, Speaker A: M. At our ultraviolet room, and it will be done by Manuel from open Zeppelin, and he will talk about the outcome of this audit. All right, so solidity 50, we're almost there. So Salsi is ready, but Salsi Js. There are still some things to be done, but we are hoping to get this done in the next days. So yeah, watch out for the new version. And yeah, now I want to talk about what actually changed in the new version.
00:03:26.386 - 00:04:18.920, Speaker A: So we had some design goals there, so we wanted to improve safety. That was the first and foremost goal. And we wanted to do that by requiring users to be more explicit, by removing disambiguities or weird behavior, and also by adding runtime checks to the compiler. So I picked some of the language features, some of the most important ones. So first of all, we now have explicit types and explicit visibility, explicit data locations, new scoping rules for function, local variables. We have a new constructor syntax. We also introduced emit for events, then also the address payable and some others.
00:04:18.920 - 00:05:14.300, Speaker A: And now I will go through all of them in detail. So explicit types what that does mean. So here's an example of a contract. So we have a loop there, and this example still uses VAR for a variable type. And here is an issue, because the compiler deduced the type of the variable I to an unsigned eight bit, and so the maximum is 255. So this condition will always be true, which means that this will result in an infinite loop. So now you have to be more explicit about the type, and VAR is now disallowed, which means you have to declare the type of the variable I.
00:05:14.300 - 00:06:11.654, Speaker A: And now it will be fine. So next thing are explicit visibilities. So brought another example here. So we have a contract here, and it has an owner, it has a constructor that calls an initialized function. And here in the initialized function, the owner will be set, the caller will be the owner, the caller of the initialized function. And now if withdraw is called, there is a require that the owner has to be the caller, and then the balance gets transferred. So the problem here is that functions are, the visibility of functions is public by default.
00:06:11.654 - 00:07:05.370, Speaker A: So anyone from outside could call this initialized function, and then also the requirement would hold in the withdraw. So could be then also withdrawn. And we change that. So the visibility specifier is now mandatory. What does that mean? So here the constructor got the visibility public, and the initialized function is now internal, which means it can only be called internally. And then here you can see that the requirement, if someone from withdrawn is called, then the requirement will be true here. All right, explicit data locations.
00:07:05.370 - 00:08:32.720, Speaker A: So I bought another example. So here we have a contract and you have a struct called data, and we have an array of these structs and the function f. And here we are going to access this array and store it into the variable called member. And as I said, the location specifier is now mandatory. So you have to use storage here in this case, yeah. Okay, so storage references, it's the same example that I had before. So we still have the struct, we still have this array here and we have the function and we are initializing here member and then setting the name that was given as a parameter to the function to the member name of, of the data, and then we're pushing this into the array and now they have to be initialized.
00:08:32.720 - 00:09:43.970, Speaker A: So the background of this is that we have a component in the compiler that tried to find out if storage references were initialized before. And because in some cases that was not possible. So the decision was made to make it explicit so that you have to initialize storage members storage references before using them. All right, so scoping rules. Before 50 we had JavaScript like scoping rules. So in this example you have the variable I and three is assigned to it before it was initialized. And because one of the goals was to be more explicit, we also changed that to block scoped C 99 style scoping rules.
00:09:43.970 - 00:10:47.610, Speaker A: Here for the two for loops that you can see, the I is declared also in the for loop, and it's visible only for in this block. So that's the reason why you have to redeclare it in the second loop. Then we introduced new constructor syntax. So what does that mean? This is an old example. So I took the contract that you've seen before. So here you can see the contract is called old and before 50. To define a constructor you had to declare a function with the same name as the contract.
00:10:47.610 - 00:11:52.870, Speaker A: But again, to be more explicit about that and to prevent mistakes, we introduced a new keyword called constructor, and it has to be used to declare the constructor. And it's not allowed anymore to have a constructor that has the same name as the contract. What next? So image for events here again, the example that you've seen before. So we have a contract here and it has an event called withdrawn. And so we have the function withdraw. It's from the example before. So we have the require again, and we have the transfer call, and then the event is emitted.
00:11:52.870 - 00:12:55.870, Speaker A: But this can also be confusing because it could also be a function call. I mean, there are coding guidelines that say that you should start your function with a lowercase letter, but if you don't do so, there can be certain mistakes be making. And again, to be more explicit, event invocations must be prefixed. So here we introduce the emit keyword, and if you want to invoke this event, emit has to be put in front of this. All right, next one address payable. So we split the address type. So in this example you have a target and you want to transfer one ether and call transfer on this target.
00:12:55.870 - 00:14:00.218, Speaker A: And now address payable is required. So that means that if you have an address type that is not payable, the transfer function would not be available on this type. Then there's a second example of implicit or explicit casts. So if you want to convert this to an address type, you need to be explicit about it. So you have to use a fallback function, payable fallback function such that this example would compile. And then there are a few other things that we changed. So we have the ABI encode and decode changes and also some changes to the call family.
00:14:00.218 - 00:15:18.530, Speaker A: So call delegate, call kjack 256. Now take a single byte parameter and if you want to use it then you have to use the ABI encoder before to encode and decode the arguments there. And also we change something to the viewpure and view pure functions now use steady call with the exception that for library view functions they use delegate call. And we also put together a list of breaking changes. You can find it in our documentation. And we also put together or compile the list of how you have to change your contracts such that they will compile with 50 okay, so what's coming up with the next versions? We have fuel, which is a very interesting topic I want to talk about. We introduced some formal verification in form of the SMT checker.
00:15:18.530 - 00:16:08.326, Speaker A: We're planning to do some inheritance rule changes, then also contract metadata and the Avi encoder V two. So what is Yule? I don't know if who of you attended to Alex talk yesterday. And the prism room. So Yule is an assemble language and it's an intermediate representation internally in the compiler. It aids auditing the code base and generates code. It allows for a lot of optimization and it also allows multiple backends. So solidity could compile to Yule and then in the end to EVM and also solidity to Yule to ewasn.
00:16:08.326 - 00:17:13.720, Speaker A: That will be something that might be interesting in the future. And also Viper could, and that's emphasized use yule to also then support EVM or ewasn backend. And if you want to find out more about Yule you can also consult our documentation. And I also brought a short example so that you get an idea of how ul does look like. And here is the power function and we have high level keywords like switch, case, default. But as you can also see multiplication and also dividing, it's a representation of opcodes in a more functional style. So like I said before, this increases readability and also helps auditing the code.
00:17:13.720 - 00:18:23.530, Speaker A: And if you want to find out more about Yule and also about the optimization that I talked about, then I would highly recommend you to join the talk today by Christian. It's at 04:30 p.m. In prison, and he will talk about the optimization that we put in already and also some things that we plan to do in the future. All right, so coming to formal verification, so we're using technique called S and t's satisfability modular theories. And this helps seamless verification of safety properties such as underflow, overflow, division by zero, trivially conditions or unreachable code, and also assertions. So verifying runtime checks at compile time. And we have a component for that and it's called the SMT checker.
00:18:23.530 - 00:19:13.340, Speaker A: So this is one example so you can enable the SNT checker is an experimental feature right now and you can enable it using a pragma here. Pragma experimental SMT checker. And so if you compile this example with the SMT checker enabled, you will get some warnings. So the first warning is that the for loop condition is always true. So I is initialized with 200, and that means that if I is greater equals zero, this condition will always be true. So that's the first warning. And the second warning is an underflow resulting in a value less than zero.
00:19:13.340 - 00:20:03.402, Speaker A: And this is I then gets incremented. So at some point you will get an underflow here, skip this example. And there's also a talk by our colleague Leo, and it will happen tomorrow at 04:00 p.m. On the ultraviolet stage, and he will talk about some details on how to actually use the SMT checker, what's coming up. So we're planning to do some inheritance rule changes. And so inheritance is a crucial part of solidity contracts. But there are some open questions.
00:20:03.402 - 00:21:15.362, Speaker A: So what about explicit shadowing? Can visibility our state mutability levels change? And there is an open poll request right now where a lot of discussion is happening. And so we are hoping to get more people join this discussion so that we will come up with a cohesive set of rules that we can implement. What else? So, contract metadata. Contract metadata is generated for each contract, and it stores as a json object, and it contains all details needed to reproduce the compilation. And a swarm hash of this metadata is appended to the bytecode. Unfortunately, it's not used by a lot of verification tools that are out there yet. And you can find the documentation about the metadata also in our documentation and this is how the contract metadata will look like.
00:21:15.362 - 00:22:36.374, Speaker A: So you have the contract version, you have the language, so solidity, you have the compiler version is included and also some settings like the compilation target EVM version and if the optimizer was enabled or disabled, because this will result in different output. And here you can see the hashes that I mentioned and this is then included. So then the Abi encoder v two, what is the Abi? So we have a contract ABI and that's a specification how to exchange data with a contract. And for each public function, a decoder and encoder is generated. Currently that's handwritten C plus plus code, and it's very error prone and it's hard to test. So that's why we introduced the Abio encoder V two. And this is written in Yule and it ensures safety properties such as short input, too short input, or invalid values.
00:22:36.374 - 00:23:46.390, Speaker A: And it also supports complex data types such as drugs, multidimensional arrays. And you can also play around with the new ABI encoder and enable it via pragma, experimental pragma. All right. And then I want to quickly tell you how you could potentially contribute to the project. So there are many ways to contribute, so you can always request a feature. We have discussions on existing design issues and also including documentation improvements and also the examples that we have in the documentation, our issue tracker, we have introduced some labels, for example help wanted or good first issue. So if you go through all the open issues and see the labels, then you can probably directly start working on it if you want to.
00:23:46.390 - 00:24:35.434, Speaker A: And also you should watch out for gitcoin bounties. And if you have any questions about them about that, you can always reach out to the solidity dev channel. Yeah. And now we have some time for questions, if there are any. So I think there are two microphones here in front of the stage. Okay. Doesn't look like there are any questions, so don't worry.
00:24:35.434 - 00:24:37.900, Speaker A: Thank you. Oh, there's a question.
00:24:44.530 - 00:24:51.598, Speaker B: Hello. So currently if you declare that your solidity function returns. Can you hear me?
00:24:51.764 - 00:24:53.360, Speaker A: Not so well, sorry.
00:24:54.310 - 00:25:12.470, Speaker B: Hello. Okay, sorry. So currently in solidity functions, if you declare a return variable, that the function returns something and don't explicitly declare a return, there's no notices or errors about that. Are there any plans to change that for solidity?
00:25:15.530 - 00:25:24.460, Speaker A: Not that I know of. I mean, the team is also sitting there, so if you want to add something to that.
00:25:26.190 - 00:25:37.578, Speaker C: Yeah, I think there's an open issue about that. We do warn if the variable is not used at all. So if you never assign to it and do not have a return statement, then you get a warning.
00:25:37.674 - 00:25:38.318, Speaker B: Okay.
00:25:38.484 - 00:25:44.042, Speaker C: But yeah, there's an open discussion about how and whether to change that.
00:25:44.116 - 00:26:15.820, Speaker B: I have one more question. So currently, the function identifiers for the way that, how they're identified when you're calling them, they only have the name and the parameters in the identifier hash. Right. But this can allow where you can call a function that actually returns something or doesn't return something when you expect it to, and even though it should error in that sense, it doesn't, because the identifier only checks the name and the parameters. Are there any plans to include the return variables into the function identifiers or no?
00:26:17.150 - 00:26:24.974, Speaker C: Yeah, that's something that hit some people at the point where the compiler was changed to actually enforce the return size.
00:26:25.092 - 00:26:25.760, Speaker B: Okay.
00:26:26.530 - 00:26:39.522, Speaker C: That's a very tough thing to change. I mean, the ABI is something you don't really want to touch. Yeah, done that like that in the beginning, but yeah. Okay.
00:26:39.576 - 00:26:40.660, Speaker B: All right, thank you.
00:26:43.270 - 00:26:44.066, Speaker A: Hello.
00:26:44.248 - 00:27:04.060, Speaker D: I'm currently using API encoder version two to handle complex structure, which is a very nice feature to have in solidity. You say it's on your roadmap for the next step. However, my question is how dangerous it is to use a current experimental version, and how long do I have to wait to have a proof solution for that?
00:27:04.510 - 00:27:07.322, Speaker A: For the Abi encoder V two, you mean?
00:27:07.376 - 00:27:07.980, Speaker B: Yes.
00:27:09.950 - 00:27:16.734, Speaker A: So maybe like one part of your question was missing, because can maybe repeat the question?
00:27:16.852 - 00:27:29.954, Speaker D: Yeah, just I'm using it right now, but it's still experimental, so I want to know if it's dangerous to use that in production and if it's dangerous, and it might change, when will I have a good version that I can deploy on the main net?
00:27:30.152 - 00:27:46.982, Speaker A: I mean, that's hard to say. So it's an experimental feature, so I wouldn't recommend to use this in production at all. And because we have so many things going on, it's hard to say when this will be ready, but maybe Christian has in addition to that.
00:27:47.116 - 00:28:23.140, Speaker C: So we're pretty confident that it's not dangerous to use. One of the main reasons it's still experimental is because it's much more expensive. So the new ABI coder was built in an extremely modular way where we have tiny functions for very simple tasks, and that helps ensure that it's correct. But it's more expensive because the EVM jumps around all the time and we will take it out of experimental as soon as we have the Yule optimizer that will remove these inefficiencies, basically.
00:28:25.430 - 00:28:26.786, Speaker B: Can I ask a question?
00:28:26.968 - 00:29:02.880, Speaker E: Hi. So solidity .5 has a lot of breaking changes, right? Lack of backwards compatibility. I've got contracts that are already deployed to the chain using previous versions of solidity, and I'm running into some challenges trying to interact with those contracts using 0.5 because of the things, the way that they were written back in the day using const and various other bits and pieces. Have you thought about how to write code in 0.5 to integrate, to interact with existing contracts? Is that a thing that you've thought about, or are you expecting that everyone's just going to write all new contracts going forward?
00:29:03.890 - 00:29:14.740, Speaker A: No, of course we are expecting this, that you have contracts compiled with different compiler versions. There is a plan for that.
00:29:21.940 - 00:29:35.190, Speaker C: Sorry Eric, I just have one addition to that. Probably the best way to do it. If you write an interface for your contract and that interface is valid in 50, that's probably the best way.
00:29:38.770 - 00:30:17.260, Speaker A: Hello. Thank you for the presentation. So currently solidity is 0.5, which is Alpha software. What do you think will it take for solidity to become 1.0 software? You mean in terms of time? That's really hard to say because like I said, I just joined the project half a year ago and I joined it when it was in version 422, so now we're 50. So it might take a while, but it's really hard to say when it's like in version 1.0.
00:30:17.260 - 00:30:19.900, Speaker A: Thank you.
00:30:20.990 - 00:30:26.320, Speaker C: Yeah, I joined the project only four years ago and I think it might still take some time to get to.
00:30:31.710 - 00:30:39.280, Speaker A: All right, I think time is up, but maybe we have still one more question. I don't know.
00:30:39.650 - 00:31:09.110, Speaker F: Yeah, I would like to ask about the capability of the language in terms of returning multidimensional arrays like array of struct or array of strings, and also about the capability of the string data type that has limitation in terms of getting the length or doing some sorts of concatenation.
00:31:11.130 - 00:31:32.000, Speaker A: So the question was when? This will be point like your question about multi dimensional arrays, this will be included in the new API encoder. So if you want to interact with the contract and then if this component is finished, you should be able to use them.
00:31:32.850 - 00:31:37.600, Speaker F: And how about adding the capability to the string data type?
00:31:39.910 - 00:31:57.542, Speaker A: You mean regarding the length and concatenation? Yes. Is there anything that we plan for that in the future? Sorry, I have to refer to my colleagues. Is it working? Sorry?
00:31:57.596 - 00:32:21.390, Speaker C: Is it working now? Yeah, we're kind of reluctant to add features that have unbounded gas usage. And string concatenation would be one of them. But you can use Abi encode pact on byte arrays that will do exactly. Byte array concatenation, which is something can be discovered by accident or. Yeah, it's a neat trick.
00:32:26.290 - 00:32:28.300, Speaker A: All right, cool. Yeah, thank you a lot.
