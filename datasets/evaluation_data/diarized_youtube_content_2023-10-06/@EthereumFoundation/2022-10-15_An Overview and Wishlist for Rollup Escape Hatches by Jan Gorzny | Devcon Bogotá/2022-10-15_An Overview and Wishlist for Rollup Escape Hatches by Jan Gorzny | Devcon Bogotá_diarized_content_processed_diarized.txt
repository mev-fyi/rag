00:00:13.130 - 00:00:47.110, Speaker A: I'm really interested at, and I think a lot of people in the security field sort of should be as well. And that's escape hatches for roll ups. You've heard a lot about roll ups, so let's give a brief introduction about what they are. Then we'll talk about the specific feature I care about, and then we'll talk about some features that those features should have. So what a good roll up might want. So this will be sort of similar to my colleague's talk from earlier, except not bridges. Okay, so what is a roll up? Well, if you attended a lot of these talks here at Devcon or elsewhere, you've seen a bunch of more or less mutually consistent definitions.
00:00:47.110 - 00:01:48.314, Speaker A: But essentially it's some sort of layer two scaling solution, or maybe layer three or layer four if you're really forward thinking. And it's some system that just takes transactions and executes them off chain and then batches them and compresses them and does something to get you some sort of savings and pushes some data onto layer one. And so essentially it's a system that's replicating your layer one blockchain like ethereum, but it's doing it elsewhere with some nice advantage that gives you scalability in some sense or savings. And so how does the system work? Well, usually you get some transactions, and then your system design is very dependent on the implementation. But typically there's something called a sequencer that gives an order to the transactions that are taken, and then this order of ordered set of transactions is executed in some state transition function. The state is updated and something gets pushed to your layer one chain where it's eventually considered final. But this is great when everything works, but what happens when things don't work? In particular if your sequencer goes offline or some other component? Possibly.
00:01:48.314 - 00:02:32.640, Speaker A: But typically these escape patches are discussed in the context of sequencer failures. What happens? Because if you had a bunch of money or assets or tokens locked up in one of these roll ups, and suddenly the transaction that says give me my money back is no longer sequenced, you're kind of screwed. So the functionality of an escape hatch is some way to get program state or digital assets, because tokens are basically just program state off of this roll up system, even when your sequencer or some other component has failed. Now obviously there's some sort of caveat. Some things probably can't fail and always work with an escape hatch, right? If you have a bug in your smart contract, maybe no escape patch functionality is going to work, because maybe that's what's broken. But we'll talk about that. And some people have actually started to look at this.
00:02:32.640 - 00:03:20.906, Speaker A: This list, thanks to l two beat but rewritten for our paper, does suggest that various roll up projects right now are thinking about this and trying to implement these solutions. Now, some of them have the none there. We're not going to talk about the specifics, and I'm also, unfortunately I don't have enough time to talk about even one of these approaches, but if you are interested, let me know or go contact the project and say hey, how do you do this? But even when they're implemented, they're often not exactly done. In some cases the design is not well understood. In some cases the code is literally a stub and it says hey, it's going to come later. But now that the rest of the roll up functionality is done, ZK parts are all coming together and everyone's got roll up state working. It's time to start thinking about this feature that you sort of kept pushing off and into the future.
00:03:20.906 - 00:04:04.300, Speaker A: Because ultimately, while I hope this feature is never used by any roll up ever, we would like to see it exist so that if someone does have any issues, you get your funds back and things work out in the user's favor. And then ideally you fix it and your roll up gets back up or whatever. So it's being done, but maybe not done all the time or entirely correctly. And so I'm going to discuss what I think some nice features would be in a roll up. Now these would vary, and just like in the cases for bridges, for features, some functionality is probably contradictory and you can't necessarily do all of these at the same time. But there's some things that probably should be nice and obvious. First, they should be well engineered components of the system.
00:04:04.300 - 00:04:34.590, Speaker A: That usually means very modular. And in case you need to upgrade your roll up, you can upgrade part of it or all of it, or just this part. Maybe this is the only part that's concerning, because if you saw on that list, some people just force a transaction, whatever that means. Others suggest proposing new blocks, whatever that means. But this should be a full fledged feature, not an afterthought. Second, it should be secure. We always think about security at quantsamp, and certainly a roll up is essentially a bridge that's even more complicated.
00:04:34.590 - 00:05:13.950, Speaker A: And we don't want to have to deal with exploits that arise for the roll up because of this functionality. If you do this, do it right and make sure you test it and audit it and all that. And finally it should be correcting. You shouldn't really have to use consecutive escape hatches. This is a bit confusing, but I have heard some people say, well, our plan for a escape hatch is to just migrate the state to another copy of our roll up and then everything will work. But as a user, am I going to be really trusting of the same type of roll up that just went down on me? I'm not so sure that that's going to be the case. So ideally something that gets you sort of out of the system.
00:05:13.950 - 00:05:47.322, Speaker A: Maybe correcting is not the best name is something that I'd like to see personally. But beyond that we can think a little bit deeper about what it means to escape from a rollhead roll up. In particular, if you're taking assets out, that's pretty well understood. And a lot of them do have functionality for forcing transactions for ERC 20 tokens, for example. But what do you actually really want to escape? Maybe you want to escape more than just ERC 20 tokens. The obvious case is what if you have an NFT minted on your roll up? Obviously you probably want that back too, without having to go through extra hoops. This also very much depends on the actual bridging that's being done.
00:05:47.322 - 00:06:27.574, Speaker A: But maybe there's some other things you want that are valuable to you. They should be built in. If you have a DAP that you have on l one, you should sort of migrate it to l two and sort of expect minimal extra friction introduced by this feature. So in particular, if that DAp is supposed to escape some state as part of this functionality, it should come for free in air quotes because doing extra work sucks. And finally, it should be transaction efficient on the layer underneath. If you escape from a layer two roll up and everyone else is trying to do this, there's going to be a gas war and things are going to get expensive and things are going to get messy. If you can do this in a nice way that aggregates many user state or does something clever, I think that's really the way to go.
00:06:27.574 - 00:06:57.442, Speaker A: Now I'm not saying I have solutions for these, but that's just what I want to see. Some other properties that'd be really nice, be global. So in particular, if you call an escape hatch functionality, you don't have to do it for every dap that you've deployed on that l two. So if I'm using uniswap and something else on some roll up, I want to just say escape everything, not escape uniswap and then also escape whatever the other DAP is that would be ideal. It'd make my life a lot easier and it should be automatic and live. Ideally it's always available because who knows when the system could go down. Hopefully never.
00:06:57.442 - 00:07:30.030, Speaker A: But if it does we don't know when it'll be and it should be triggered hopefully automatically so we're not depending too much on social consensus. I mean it might be unavoidable but it should be very clear when you can trigger this functionality and when you want to do that it should be available to you or at least the community should be able to make the decision. But automatic would be ideal. So that's what I think they should do. Have I missed anything? Please let me know. Do you disagree? Please also let me know. You can contact me on email or Twitter there.
00:07:30.030 - 00:07:38.240, Speaker A: Find me around here and we do have a write up of this at a non blockchain conference so I can send you some papers about that. Thank you.
