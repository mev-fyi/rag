00:00:12.890 - 00:00:39.138, Speaker A: All right, so thank you all for being here. The first talk of the day after Rave is kind of a challenge, but hopefully we'll make it fun. So, my name is Julianize. I'm one of the three co founder at Argent. And this morning I'll be talking about account abstraction. Why it's a game changer for the UX of DApps. But I think an alternative title of my talk could be how to scale self custody.
00:00:39.138 - 00:01:39.450, Speaker A: So let me start with a pretty obvious statement, and I hope we all agree in this room that self custody matters, right? Blockchain is an amazing technology that for the first time can enable true digital ownership. But of course, you don't really own an asset if you give custody to someone else, to a third party. And I think the recent event of this summer with the problem with Celsius is kind of a good wake up call of what bad things can happen if we rely on custodial solutions. But of course, we all know that self custody is hard, right? If we look at crypto Twitter, we'll see every day users explaining, oh, they lost access to their assets or their assets got stolen. And, I mean, sometimes these people are experts. If you look at the tweet on the top right, it comes from Yuga, the founder of a well known DeFi project. So even experts are making mistake and are basically struggling with self custody.
00:01:39.450 - 00:02:25.130, Speaker A: So the question is, why self custody so hard, right? And we believe at Argent that the problem lies in how Ethereum accounts were designed. At the beginning of Ethereum, it really lies at the heart of the EVM. So let me dig a little bit into Ethereum account to try to understand why there are a problem and then see how we can fix that. So this is pretty basic. I'm sure all of you know about Ethereum accounts, but I think sometimes it's always good to take a step back and see things with a different perspective. So we all know that on Ethereum there's two types of accounts externally on accounts or EOAS, in short, that can initiate transactions. And then you have contract accounts that can contain logic.
00:02:25.130 - 00:03:13.494, Speaker A: And we know that an EOA has an address for identification announced to make transaction unique and a balance in ease to pay transaction fees. And we say that a user owns an account through a pair of cryptographic keys, also called a signer. Right? And what's the link between the two? Well, the address of the account is derived from the public key of the signer, and transaction from the account can only be initiated by the private key of the signer. So there's really a link between the two. And on Ethereum, that link is not random. We need to use a very specific signature two scheme called ECDSA on a very specific elliptic curve. SEC p details are not that important, but what matters is that all of this is out coded.
00:03:13.494 - 00:04:12.410, Speaker A: All of that logic is out coded in the EVM. And so if we take a step back, we see that in the user space, we have the signer, the key pair, and then on Ethereum, we have the EOA with all the EVM logic to validate and execute transactions. And we see that there's really a type coupling between the two, right? These are basically two sides of the same coin. And that's kind of the problem, because on Ethereum, we have merged the concept of the signer, the object that's authorized to spend your token, with the concept of the account, the object holding your tokens. On Ethereum, they are basically two sides of the same coin. And that's, of course, a problem, because if the signer is the account and vice versa, that means that if you lose your signer, you've lost everything. If I have your signer, I have your tokens, right? That basically means that on Ethereum, the entire security relies on users managing a secret, this private key, this signer at all cost.
00:04:12.410 - 00:04:47.926, Speaker A: And as a user, you cannot make a mistake. If you make a mistake, you lose everything. And I mean, if there's one thing we've learned from 40 years of the Internet, is that we humans, we suck at managing passwords and we humans, we make mistake. So of course, this is absurd. And this concept, this paradigm, will never work for mainstream users. I mean, do we really expect the next billions of users to basically being able to manage that single secret at all cost? I mean, we are pretty convinced that the answer is no. So can we do better? And fortunately, yes, we can do better.
00:04:47.926 - 00:05:17.806, Speaker A: And there's something called account abstraction. The idea of account abstraction is really to decouple that relation between the signer and the account. With account abstraction, every account is a smart contract that can contain its own logic. For example, you may want to use a different signature scheme, or you may want to use a different elliptic curve. Or maybe you want to use multiple signers to validate transaction. Think of a native multisig. Or maybe you want to rotate your signer based on some logic that you've defined.
00:05:17.806 - 00:05:58.650, Speaker A: With account abstraction, all of this is possible. Another way to see it is that with account abstraction, every account is a smart contract with custom logic that can initiate transactions. So no smart contract can become top level accounts. And the good news is that with true account abstraction, there's no more EOAS, right? Because every single account is a smart contract. And you may have heard about account abstraction lately, but actually it's not a new concept. If we look back, we see that Vitalik started talking about account abstraction as early as 2016, with the first EIP being proposed early 2017, EIP 86. We at Argent and people like nosis with diagnosis safe.
00:05:58.650 - 00:07:03.410, Speaker A: We started building smart contract wallet in 2018, which basically were a form of account abstraction. The idea was really to solve this UX problem for self custody using smart contract. But we did so at the application layer and we came with ID like social recovery, fraud monitoring and so on. In 2020 there was a new EIP, again led by Vitalik EIP 29 38, where the idea was to add a new type of transaction to let smart contract become first top lever account, so enabling smart contract to basically make transaction and pay for transaction fees. Soon after there was EIP 3074, which took actually the opposite approach, which was trying to enable some of the smart contract feature on existing EOS. And then recently there was a new EIP again led by Vitalik EIP 4337, which basically is a generalization of smart contract wallet. The idea is to decentralize some of the infrastructure that is needed to write and to operate smart contract wallet.
00:07:03.410 - 00:07:51.620, Speaker A: And I think EIP four three seven is very interesting for different reasons. First of all, it does not require a fork, so it lacks smart contract wallet. It works at the application layer and it's actually a good architecture, I think, which can lead us in what native account abstraction should be in the future. So let me dig a little bit into 4337 rapidly. So on 4337 users, they don't make transaction, they send user operation. And they send this user operation to a high level mempool on which you have bundlers like miners that can basically take a bunch of these user operation and burden them into a normal l one transaction. And that transaction is sent to a specific contract, a single turn called the entry point.
00:07:51.620 - 00:08:42.798, Speaker A: When that transaction reach the entry point contract, the entry point will basically orchestrate the validation and the execution of this user operation. And it does so by calling two method on the wallet a first method to validate the transaction, basically asking the wallet are you okay to execute that operation and will you pay the fee to do so? And then a second call to execute. So we see that with 4337 there's a clear separation between validation and execution. Okay, I mean, all this is great, but is this really the end of account abstraction? I mean, every reach the holy grail. Of course the answer is no. Each of these EIPS that have been proposed over the years, they all bring some of the features of account abstraction, but they also all have limitation. If we look at EIP four three seven, the main limitation is that it lives at the application layer.
00:08:42.798 - 00:09:26.242, Speaker A: So basically 4337 wallet lack smart contract wallet. They're a second class citizen because they still live on a chain which relies on EOAS every single DApps the tooling. I mean, the way developers thinks about account, we all think in terms of EOS and that makes smart contract wallet or four three seven wallet second class citizen. And that's actually a blocker for their adoption. So what can we do next? Well, what would be ideal, of course, is to bring 43371 layer down to bring it from the application layer to the protocol. And actually the people who propose 4337 are working on that right now. But what we think at Argent is that we shouldn't wait for that to happen on l one.
00:09:26.242 - 00:10:11.706, Speaker A: I mean, we are now in an era where L2 S are picking up. It's actually an amazing opportunity to fix some of this limitation of ethereum. I mean, the EVM is a great VM, but we know that there are some limitation. There are stuff that we know can be improved. And so we believe that L2 is actually the great moment to do so. And that's why we've been really excited lately because two of the major L2 providers, namely Stacknet and ZK Sync, have committed to ship with native account abstraction. And so at Argent we've been working with them quite closely for the past year, trying to bring our experience as a smart contract wallet company and making sure we can really design account abstraction the way it's needed for users and for the next wave of users.
00:10:11.706 - 00:10:49.318, Speaker A: So in the remaining of the talk, I'll basically focus on StarkNet and give you some example in the Stacknet ecosystem. But just remember that everything I will say applies to Zksing as well. So with account abstraction, every account is a smart contract. But of course it cannot be any smart contract, right? The protocol or the VM needs to know how to interact with that account contract. That means that the account must comply to a certain interface. And so we've been working with StarkNet and OpenZeppelin on defining that interface for Stacknet and we came up with the following interface. It's written in Kro, so don't worry.
00:10:49.318 - 00:11:32.140, Speaker A: The style might be a bit surprising. But what's important to note is that just like in the IP Four Three seven, we have a method to validate a transaction. So every account must expose a method to say, to validate and decide what kind of signature schemes it wants to use, what kind of nons mechanism, and so on. And there's a method to execute, to really execute the call and interact with other contract. And because we are starting with a blank page on Stacknet, we did something very cool is that we introduce multicolored natively. So on Stacknet, every transaction is actually a multicol by definition natively. And I'll come back on why that is exciting in a few minutes.
00:11:32.140 - 00:12:07.298, Speaker A: On top of these two methods, we also have a method to validate the deployment of an account. That means that no account contract on StarkNet can pay for their own deployment. Again, it's something that enables a great user experience. And finally, we have one last important method called isvalid signature. And the idea of isvalid signature is to basically verify off chain transactions, right? Again, I'll come back to that. But smart contract they cannot sign. But they can delegate signature to signers to keys, but they must expose a way to say, okay, this signature is actually valid for myself.
00:12:07.298 - 00:12:41.082, Speaker A: And on Ethereum this is the equivalent of VIP 1271. Okay? Since this is a developer conference, there's basically five things that you need to remember as a developer if you want to build for account abstraction. The first one is that accounts are smart contract and so they need to be deployed. Thankfully, this is something that wallet will take care of, but you still need to think that there is an account behind every wallet. The address of this account is computed like a smart contract. So there's no link between the signer. Like on Ethereum, it's a new address for a smart contract being deployed.
00:12:41.082 - 00:13:11.480, Speaker A: Transactions can have multiple signature. So you need to think that you cannot assume that an account has only one signer. Maybe it's a native multisig. So you shouldn't make any assumption. And signatures can basically be an array. And then if you want to verify offshore signature, you cannot use a local EC recover that you've been used to. You need to actually ping the account and say is this signature valid? And finally you can and you should use multiples because it improves the user experience by a ten x factor at least.
00:13:11.480 - 00:13:57.634, Speaker A: And that's basically all you need to remember. So if you are the developer, if you come out of this talk by remembering these five points, I think we are in good position. Okay, so as I said, we've been working with StarkNet on defining account abstraction there and of course we built a wallet because at Argent that's what we do. And so we actually built the first wallet with native account abstraction called Argentx. I promise you this is the only slide where I will chill Argent but it's still needed since I'm on main stage. So Argent's first wallet on StarkNet native account abstraction, which is kind of amazing, works as a browser extension. So it works on Chrome and Firefox, you can have multiple accounts, it works on StarkNet Testnet and StarkNet mainnet and it does the usual of a wallet.
00:13:57.634 - 00:14:29.540, Speaker A: You can send and receive token, you can interact with DApps, but as I will show, it does much more than that also. And it's 100% open source. So if you are interested, please check the repo, feel free to contribute and if you haven't tried the wallet, do so as well. And it's been actually an amazing ride. You may not know how the Stagnant ecosystem is going, but actually since we started Rgenx in January, we've had more than 250K downloads. So I think that's quite of impressive. And we are securing more than 90% of the funds on StarkNet mainnet today.
00:14:29.540 - 00:15:20.498, Speaker A: So how does Rgenx work? So typically when you think of a wallet, for example, like MetaMask, you think about the client and you think about a key that can sign transaction. Well, with account abstraction, you need to think about the account contract as well. So Rgenx is really these three things a client front end keys that can sign transaction and then account contracts that live on chain. And it works from a user or DApp developer's point of view, it works exactly like you would expect from your MetaMask. For example, when you connect your wallet and you do an action, the wallet will pop up, you can review the action, approve the extension, will use a key to sign the authorization. All this is sent to the account contract on chain, which will validate and then execute the operation and call the target contract. Okay, so now let's get to the interesting part.
00:15:20.498 - 00:16:02.858, Speaker A: The unique features that I enable by account abstraction. So I mentioned that on Stacknet we have native multicol. The idea of a multicol is that you can actually make a sequence of operation as one atomic transaction. Think, for example of the infamous ERC 20 approve end call, right? On Ethereum. If you want to interact with a DAP that requires a token, you need to first make a first transaction to approve your token, wait for that transaction to be mined, then you can actually make your call. Well, with multicol, because your account is a smart contract, it can orchestrate these different operations in sequence. So you can actually in one transaction, do your approve and your call, or maybe you can do your approve and then five calls.
00:16:02.858 - 00:16:53.418, Speaker A: And we're seeing on StarkNet, DAP developers are experimenting with that. For example, if you go on Aspect, which is an NFT marketplace on StarkNet, when you want to buy NFTs, you can add them to your shopping cart, which is an experience that we all know. And so you see all the NFTs that you want to buy, you finish your session, then you go and you actually buy this NFT in one transaction because your account will orchestrate the buying all of these NFTs. So in terms of UX, it's an amazing improvement. Another thing that we are doing on Stacknet that you can do because of account abstraction is social recovery. The idea of social recovery in a nutshell is to get rid of seed phrases. How do you do that? Because your account is a smart contract, you can program it to support a second key and you can define that that key cannot transfer token, it cannot interact with DApps.
00:16:53.418 - 00:17:32.278, Speaker A: It can actually only do one thing, which is to replace the signer key in case of a problem. And you can imagine that. Now, you give that recovery key to a party that you trust, that we call a guardian. Think of it, for example, as a service and the day you lose your computer, you lose access to your wallet. Well, instead of having to think about a seed phrase private key, no, you just contact your guardian. This service you authenticate with whatever mean you've agreed with him and the service will make the only transaction it can do on your account and reprogram your account with a new key. And of course you can use a service, but you can decide to be your own guardian.
00:17:32.278 - 00:18:08.998, Speaker A: You can use a ledger to do so, for example. And we are working on ledger to enable exactly that. So social recovery is really a way to get rid of seed phrase to provide a UX that users, normal users can understand. And it's 100% noncustodial because you as the owner of the main key, you can decide who's your guardian and you can change that guardian at any point if you want to. So that's really cool. What else can we do? Well, we can do fraud monitoring with two FA. Imagine that again on your account, you program a second key and you decide that that second key must co sign.
00:18:08.998 - 00:19:24.910, Speaker A: Okay? So I was talking about a new cool feature, the idea to do fraud monitoring with two FA. I think I was explaining that you can add a key to your account and that key must cosign every transaction. So you turn your account into a two of two multisig and you can choose to give that key to a service. Now imagine that every time you make a transaction with your Rgenx wallet, the call data, so the raw call that will be executed on chain can be sent to that service for analysis and that service based on some business rules that you may have decided maximum daily limit or trusted DAP and so on. So it can use whatever logic you've decided to decide if the transaction is secure, it's something that we know is legit or if it doesn't know if it knows the transaction, it can co sign automatically transparent to the user, right? You've just made one approve automatically the transaction is sent. But if for some reason the service detects that it's a call to a contract that he doesn't know, for example, he may ask you to confirm who you are using a second factor just to make sure that no one is abusing your account. So suddenly you can bring fraud monitoring with two FA on chain thanks to account abstraction.
00:19:24.910 - 00:20:01.114, Speaker A: What else? This one is something that I'm very excited about, the idea of session keys. And I think it's particularly relevant now for onchain games. So if you've played an onchain games, you've, I guess all been frustrated by the need to sign transaction. Every time you make an action, having your wallet pop up, you approve and then you come back to the game. So on chain games today is basically going on and off of the game to approve transaction. Well, the idea of session keys is to say no. Imagine that your game, the DAP, the client generates a temporary key in your browser and asks you to approve that key.
00:20:01.114 - 00:20:36.978, Speaker A: But he asks you to approve that key with a set of constraint policies. For example, the DAP will say I want to sign transaction, but only for 25 minutes the duration of a session and I will only call this contract and that contract and this and that method. That's the only thing that I want to do as a user. You can approve. So yes, that's one confirmation with your wallet, you say, yeah, I want to start a session on that game under this condition. And next, when you start playing the game, every time you click on a button, you make a game action. The DAP can send the transaction directly to your account and the transaction will be approved.
00:20:36.978 - 00:21:25.314, Speaker A: So you no longer need to sign, you no longer need to confirm. You can actually focus on playing the game, but you know that your account and your tokens are secure because the key you approve can only do a very constraint set of actions that you have approved. That's something that several games are actually now integrating into their logic on Stacknet. So I do believe that that's a pattern that will come and that really will enable the UX of on chain games. Another thing that we are experimenting, and it's a collaboration with cartridge and ledger, is the idea to make the account much more modular. So imagine that your account is kind of a base contract, on top of which you can add plugins and each plugin can have a different logic to validate and execute transactions. So you can imagine that there's a plugin which contain the session keys that I just showed.
00:21:25.314 - 00:22:24.234, Speaker A: There's another plugin that may work as an UA, just a signer, but then there's another plugin which much stronger security, that will be a multisig or that will use social recovery. As a user, you can actually pick and choose the plugins that you want for your wallet and really design your wallet for the purpose the use case that you want to use it. If a wallet for gaming where you will spend maximum $50 may not need the same security requirements as the wallet you use for trading on DFI, for example. And by making the account modular, a user can really choose, pick and choose the experience that they want. And finally, one last feature that we are exploring is the ability to use the secure enclave of your phone. Because your account can be programmed, you can actually program it to verify signature on a different elliptic curve. And for example, you can use it to verify signature on a curve that's approved by the NIST and that is implemented in the secure enclave of your phone.
00:22:24.234 - 00:22:53.458, Speaker A: And suddenly you are turning every single smartphone into a hardware wallet. And that's actually something that someone has done on Stacknet. So he built an account that uses that logic to verify signature. So you can really now turn smartphone into hardware wallet. The use cases that I showed you are the stuff that we are building and exploring at Argent. But I believe that account abstraction opens a completely new design space for user experience. And so we're only scratching the surface of what can be done.
00:22:53.458 - 00:23:44.802, Speaker A: So I hope that I've convinced you that account abstraction is needed for the UX of the blockchain, but I think more importantly, to really scale the user experience of self custody. And the thing is that if we don't do that, and if we stick to the EOA model that we have today, my bet is that the next wave of users, they will turn to centralized solutions. I mean, most of us in this room we are using already a Coinbase or an FTX or Binance account because, yes, it's simpler. So can we really expect the next wave of billion users to not do that? Of course they will. So we need to find a way to build a user experience that is on par with decentralized exchanges so that we beg self custody at the heart of every interaction on the blockchain. I'm personally convinced that only account abstraction can do that. So let's make it happen and build that together.
00:23:44.936 - 00:23:55.734, Speaker B: Thank you, Julian. Thank you very much for this. I also was looking at your Twitter and you actually wrote a what the fuck is account abstraction? So that's super cool. If you want to read more about.
00:23:55.772 - 00:24:17.918, Speaker A: It, yes, if you want to know more, there's a three part series called what the Fuck is Account Abstraction? You can find it on Twitter. And also, if you're interested, we are actually having a panel on this main stage at 05:00 P.m. Today with Vitalik Dan Finlay from MetaMask. And then you have which has been pushing for EIP four, three, seven. So if you want to know more, please stick around and come at 05:00 P.m..
00:24:18.004 - 00:24:26.060, Speaker B: Perfect. Julian, thank you very much. Co founder of Argent, giving a round of applause again, please. Thank you, Julian. Thank you very much. Thank.
