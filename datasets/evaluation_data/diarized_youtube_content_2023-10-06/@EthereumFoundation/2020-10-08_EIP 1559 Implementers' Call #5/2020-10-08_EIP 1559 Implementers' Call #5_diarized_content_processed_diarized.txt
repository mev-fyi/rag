00:00:00.570 - 00:00:24.998, Speaker A: You. So we are recording to the cloud. Thanks everyone for coming to the fifth 1559 implementers call. Just shared the agenda in the chat. Basically there were a couple of things I wanted to cover today. First, just to get kind of a status update on both the implementers and researchers side. So I think Abdel and Barnaba can help cover that.
00:00:24.998 - 00:01:40.006, Speaker A: Um, we had the merge transaction pool pr to talk about, but that got decided Async, so that's already merged in. And the two other things I guess I'd like to get people's thoughts here on are the survey I just shared last night which gave a lot of, I guess projects concerns about 1559. I'm mostly interested in the stuff that relates to implementers around JSON rpcs and opcodes and whatnot. And if people have suggestions of how we can plan to just include that to make it easier for projects to test. And then there was this other document like the main net readiness checklist to just kind of walk through what are the things we'd like to see from 1559 before it gets ready to bring back all core devs for main net considerations? I know last time we had talked about moving to like a proof of work testnet, so I'm curious to get everyone's thoughts on that and what the best next step is from where we are right now. Yeah, so maybe we can start with updates. Abdel, do you want to just give a kind of overview? I think it's been like a month since the last call.
00:01:40.006 - 00:01:43.534, Speaker A: So what you and the other implementers have been working on?
00:01:43.652 - 00:02:45.022, Speaker B: Yeah, so we have been working on implementing the latest changes from the specification. So the computation of the base feed has been changed and we updated the implementation accordingly. We redeployed testnet from scratch and we were able to sync also with determined client, which is great. And now I'm finalizing the remaining changes, the removal of the transition period and also the use of single transaction pool. So that will be available, I hope tomorrow and I will restart a fresh testnet with a version aligned with latest specification. We are also aligned about the gas price behavior. So Mika submitted a pr and I approved it and it has been merged.
00:02:45.022 - 00:03:25.680, Speaker B: So we decided that the gas price opcode should return the effective price the user will pay. Actually this is minimum between fee cap and minor bribe plus the basic and this is it. And yeah I was able to spam the network and reach almost the maximum block elasticity. So I was able to target 38 million gas blocks and yeah everything was fine. So this is pretty cool.
00:03:26.850 - 00:03:40.420, Speaker A: That's it. That's great. You mentioned like you're working on the latest changes of the spec. Do you know where the go implementation and the nethermine implementation are at with regards to that?
00:03:41.830 - 00:04:04.780, Speaker B: I think my client is on the call, so maybe he can give an update about netamine. But I know that get people. So vulcanize is still investigating the consensus issue, so I'm giving them some help using the transaction sender tool to try to reproduce consensus issue.
00:04:05.550 - 00:04:09.850, Speaker A: Okay. And yeah. Do you know about nethermind?
00:04:11.570 - 00:04:15.760, Speaker B: Yeah, I said that I think that there is someone.
00:04:16.530 - 00:04:20.526, Speaker A: I don't think so. Light science is not from Nethermind. Sorry.
00:04:20.708 - 00:04:41.800, Speaker B: Okay, sorry. Nethermind. So they are also aligned on the basic computation. And I saw in the chat that he already removed the transition period. So that should be fine. When I will redeploy visa nodes, we should be able to sync again.
00:04:44.410 - 00:04:49.500, Speaker A: Great. I know someone kind of jumped in to say something while you were talking.
00:04:53.470 - 00:04:53.930, Speaker C: No.
00:04:54.000 - 00:05:00.140, Speaker A: Okay, cool. Barnaby, do you want to give a quick update on the R D side?
00:05:00.690 - 00:05:40.890, Speaker D: Sure, yeah. Thanks, Tim. So recently I've published a notebook on strategic users that was the latest, let's say, public release. The idea behind it was to kind of look at this idea that, well, 1559 is useless because anyways, users will keep competing on the tip. And I think what the notebook really shows is that you can have this sort of strategic behavior, but it doesn't last very long when the network is not subject to wide, let's say, shifts in demand, which is most of the time. So yeah, that was published. Maybe I can drop the link in the chat after.
00:05:40.890 - 00:06:51.946, Speaker D: That would be great. We've been working with Fred, who's on the call looking at the transition period out of the legacy transactions and into 1559. So trying to model it, trying to simulate it, and even trying to look at an idea that was floated around the discord channel to have some kind of tax on legacy transaction where the tax is increasing over time, which is kind of like, let's say the stick to the carrot of making users shift out of using the legacy transaction and into 1559. So we intend to model it then another notebook on the floating escalator, or the combination between 1559 and escalator. So trying to understand a bit better what it looks like. I know that the escalator hasn't been really talked about for some time, and I feel the consensus is more like, okay, we should just go ahead with 1559 and not really bother with the escalator. But anyways, I think it's still interesting in terms of research, even as, let's say, an extension to this strategic behavior notebook.
00:06:51.946 - 00:07:54.162, Speaker D: So, yeah, that's under review, and it should be published also fairly soon. And the last one that I've been working on and that, I think is quite nice. So when the, let's say, strategic user tackles this idea that 1559 is just going to degenerate into, like, a first price option, the learning users, I'm trying to tackle the idea that 1559 is a UX improvement. So this, I think, is not really understood really well by users or by whoever is looking at 1559. Like, what do we mean by Ux improvement? Exactly? And so what this learning agent notebook is trying to show is that over time, agents learn to either take the price that 1559 is giving them, so basically the base fee or leave, not even enter the queue. And in that sense, it's a UX improvement, because over time, you're learning to just become, like a price taker. So the market is just quoting you, okay, it's 100 way to get in now.
00:07:54.162 - 00:08:30.522, Speaker D: Take it or leave it. And that's it most of the time. And so you see over time with these learning users that after a while, they understand that, okay, I should probably just either take it or leave it. And you can really see then this idea of ux improvement dynamically, let's say, appearing just from the interactions of the user. So I think it's quite interesting. And then related to that, I think it's something I've discussed maybe in the Discord channel, but looking at wallet defaults. So this idea that most of the time, you're a price taker, but sometimes the base fee is shifting very rapidly.
00:08:30.522 - 00:09:19.360, Speaker D: So you have, like a uniswap launching their token or something, and then you might not want to be a price taker anymore. Then you might want to revert back to this strategic behavior, which I look at in the first notebook. And in that case, probably you also want your wallet to kind of shift from this price taker or at this price quota mode to a mode where it gives you more flexibility to say, no, I really want this transaction to go in quickly, so I'm willing to pay a much higher premium. So when should that be like? When should you switch from one mode to the other? And what should the defaults be in the wallet? So most likely defaults would look like what you currently have in metamask, like free, like fast, medium slow, something like this. But how should we set these parameters? That's kind of where I'm at at the moment.
00:09:20.930 - 00:09:40.294, Speaker A: That's great. Yeah, that's a lot. I had a couple of questions, I guess the first one around the transition period. Do you think that still makes sense if we've removed it from the EEP? With Mika's recent pr, I should have.
00:09:40.332 - 00:09:55.882, Speaker D: Specified that the transition period we're looking at is Mika's pr. So I'm not looking at the previous model of. Yeah, I'm looking at mikas where you cast the legacy transactions into the 1559 form.
00:09:55.936 - 00:09:56.586, Speaker A: Okay.
00:09:56.768 - 00:09:57.594, Speaker D: Yeah.
00:09:57.792 - 00:09:58.202, Speaker A: Okay.
00:09:58.256 - 00:09:59.660, Speaker D: Yeah, got it.
00:10:01.810 - 00:10:44.860, Speaker A: Cool. Yeah. Anyone have thoughts, comments, questions? Okay, in that case, yeah, I guess I can share my screen real quick. So puja, myself and a couple other folks from cat herders spent the past few weeks reaching out to a bunch of projects to get their thoughts on 1559. So there was a lot of feedback. We shared a report detailing most of it. I'm not sure most of it is relevant for this call, but the bit around implementation really is.
00:10:44.860 - 00:11:28.234, Speaker A: And so I was curious to get people's thoughts about how we could address the things that people mentioned would help them prioritize 1559 support. So we asked projects what would make your life as easy as possible to support this? And obviously the first thing that came up, or the thing that came up the most often was having a public testnet, but especially having one that's suitable for end user applications to use. So that has JSON RPC support for 1559. And it was also mentioned that it would be great if this was kind of standardized across clients so that there's not like any major differences between how base you and. Sorry, go ahead.
00:11:28.352 - 00:12:03.540, Speaker B: Yeah, I would suggest something about that. Instead of implementing RPC endpoints in each client, I will suggest that we implement only one microservice dedicated to that. That will take Ep 1559 transaction parameters and will create and sign the transaction and submit them to Ethereum client, unless we think we will have it in production on main net. But I'm not sure I think we can leverage that and avoid that every client team implement it.
00:12:03.990 - 00:12:15.510, Speaker A: So that would work for sending, but would it also work for reading transactions? Because I think that was one of the other concerns that came out, like just being able to query the transactions and whatnot on the network.
00:12:19.290 - 00:12:21.400, Speaker B: I see what you mean, yeah.
00:12:21.710 - 00:12:24.650, Speaker A: How do you expose them right now in the block explorer.
00:12:27.390 - 00:12:53.010, Speaker B: Basically? Oh yeah. Maybe we can update the front end actually and implement the decoding logic. Actually. Yeah. That will be easier actually to display transaction parameters directly in the explorer.
00:12:53.350 - 00:13:00.020, Speaker A: Yeah. But I guess what I'm wondering is how does the Explorer get the data from basic right now? Like how does it query it?
00:13:02.010 - 00:13:05.106, Speaker B: I don't remember the exact endpoint.
00:13:05.298 - 00:13:22.190, Speaker A: Okay. Because there is, I feel like if there's something already in Besu that at know the block explorer we have used, maybe that's a good first starting point for something we can standardize across clients and just make a bit more explicit. So it might be worth looking into that.
00:13:22.340 - 00:13:24.560, Speaker B: Okay, yeah, I will do that.
00:13:26.930 - 00:14:09.340, Speaker A: Sorry, just taking a quick note. Yeah. And then obviously the other thing people mentioned was like having it be part of a network upgrade. I'm not sure we're quite there yet. And then this might be interesting for you, Barnabay, but a couple of projects mentioned, if there was any incentive with regards to gas prices specifically to use 1559, they would prioritize it. I think Mika's pr kind of gets us half of the way there at least right, where if you can keep using legacy transactions, you'll just pay a higher tip to the miners. So I guess the converse of that is like if you use 1559, you'll pay a lower price.
00:14:09.340 - 00:14:16.960, Speaker A: Yeah, I think that's maybe sufficient to start, but I'm curious if other people have thoughts about that.
00:14:19.010 - 00:14:29.330, Speaker D: Do we understand from that that the project is incentivized to implement 1559 so that its users get to transact?
00:14:29.830 - 00:14:54.780, Speaker A: Yeah. And that was like, I guess the common theme for the projects who are most willing to implement 1559 as soon as possible are projects who really cared about their users gas price experience. So I think that having the end users of someone like Argent or gitcoin be able to pay a lower gas price was a good motivation for them.
00:14:55.150 - 00:14:59.606, Speaker D: Okay, yeah, that makes sense. Not incentives to pay them to implement.
00:14:59.718 - 00:15:42.954, Speaker A: No, the transaction isn't as an incentive. Yeah. And the other thing, so the other thing that was mentioned is like having obviously like the basic libraries. So ethers, JS and web3 js support this as soon as possible would help because a lot of projects basically just rely on that. So the ethers JS maintainer said it should be pretty easy for him to add support for it. The other thing that was mentioned is just having a clear upcode definition. So a lot of projects, smart contracts rely on transaction gas price.
00:15:42.954 - 00:16:12.100, Speaker A: I think we need to understand what are the implications of changing that. So right now, from what I understand that the change that was made would only affect 1559 style transactions, which shouldn't break anything that exists. But I don't know if there's some weird kind of, I don't know, second order effects for contract developers that the API changes what it returns based on the type of transaction. I don't know if anyone has thoughts on that.
00:16:12.710 - 00:17:03.214, Speaker C: I believe we're pretty safe on that front. The way we ended up setting gas price for 1559 transactions makes it so it's basically still the same thing. So it means this is the gas price that the user paid. The one caveat is previously, for legacy transactions, the gas price a user paid and the gas price a minor received are the same. In 1559, the gas price a user paid and the gas price a minor received are different. And so previously, the gas price opcode could have been used to identify how much a minor received for the transaction, theoretically, and also used to identify how much the user paid for the transaction. With 1559, it only represents how much the user paid for the transaction.
00:17:03.214 - 00:17:13.782, Speaker C: Now, I don't know of any applications that care about how much the miner got paid. There are many that care about how much the user paid, and so that's why I went with that.
00:17:13.916 - 00:17:17.490, Speaker A: Is that worth adding to the security consideration section of the EEP?
00:17:17.570 - 00:17:23.402, Speaker C: I feel like the backwards compatibility section, yes. Send me a message after this and I can go at it.
00:17:23.536 - 00:17:39.520, Speaker A: Okay, I'll write a note for that. Yeah, I feel like somebody might look at that and find something with it, but that makes sense. And I guess the other thing we discussed in the past is like the base fee upcode, that's not part of the EP yet, right?
00:17:44.440 - 00:18:07.470, Speaker C: It is not, no. There's a push currently from the core devs for various reasons to actually get rid of gas inspectability in general from the evm. And so that would probably hurt our chances of inclusion if we're adding things that make it so people can inspect gas stuff.
00:18:08.240 - 00:18:15.424, Speaker A: Okay. And I guess right now the only way to get the opcode is to get the block header, right?
00:18:15.622 - 00:18:29.110, Speaker C: Yeah. So you could prove it on chain, so you could get the transaction proof and then prove it based on the block hash if you really wanted to. But that could only be done afterwards, so it'd have to be the next block that you could do that.
00:18:30.280 - 00:19:06.610, Speaker A: Yeah. And I think that kind of relates to the next point is people would like to see kind of an API that tells you what the base fee will be for this block. So you take the previous block, you calculate how full it was, and therefore you estimate what the next block's base fee will be. I'm not sure this falls within the skills of people in this group, but something like that, the sort of eat gas station like API that just does that math for them is something people mentioned that would make it easier for them to add support for 1559.
00:19:11.860 - 00:19:13.920, Speaker C: I don't think that would be particularly difficult.
00:19:14.070 - 00:19:17.616, Speaker A: Yeah, go ahead.
00:19:17.638 - 00:19:19.772, Speaker C: They want that from the clients?
00:19:19.916 - 00:19:20.272, Speaker A: No.
00:19:20.326 - 00:19:23.408, Speaker C: Or they want that just like a place they can go on the Internet.
00:19:23.504 - 00:20:09.844, Speaker A: A place they can go on the Internet. And yeah, this call is recorded and will be uploaded to YouTube, so maybe somebody picks this up. Eth gas station, if you're listening. Yeah, that was brought up and then, yeah, obviously the rest was kind of pretty standard, but just having good documentation like we just mentioned, I think around the opcodes and explaining what the changes in behaviors are, communicating changes to the EEP and whatnot, and having channels for support. And I think with the discord there, it's been kind of a decent place so far. If the volume grows, we can maybe move to some other place for support specifically. But yeah, that was kind of the list of what would help various projects kind of implement the ep.
00:20:09.844 - 00:20:38.860, Speaker A: One thing that was nice in this survey as well is there was like a pretty smooth distribution of when projects would want to start working on the EP. So I feel like as this develops, we'll probably get more and more users who are slowly kind of trickling in and are interested. So it's nice to just start with kind of a smaller batch of people who are very interested in this and want to see it done ASAP and then slowly reach out to more projects.
00:20:40.080 - 00:20:40.830, Speaker C: Yeah.
00:20:45.210 - 00:21:34.600, Speaker A: So that's basically what I had on that, and then the last thing I wanted to bring up was just this kind of main net readiness checklist. So I think a lot of people in the community had been asking for a date for 1559 because that's obviously impossible to give to people. The other approach is to give them a list of things to do and try to obviously update it as we learn new information and we make progress on it. So in short, obviously we'd need all clients to have an implementation right now. Geth Beisu and Nethermind are working on it. Nethermind, I believe, is still hiring someone as well to do this. So if you're watching this and you're interested, you can click the link and apply for the job.
00:21:34.600 - 00:22:14.660, Speaker A: Open. Ethereum and Turboget are fine with joining the implementation later. I've talked with them and I think they don't have as much interest in implementing every incremental version of the EEP, but once it's actually done and settled, it shouldn't be a major challenge for them. To implement it, especially with the recent changes to the transaction pool and whatnot. That makes it a bit simpler for clients to implement. In terms of the open issues. I think the biggest one we discussed this on the last all core devs, but is the denial of service risk on main net.
00:22:14.660 - 00:22:55.470, Speaker A: This is something I don't think EIP 1559 can address head on. There's a couple efforts that are being done to address this, so there's EIP 29 29, Geth is working on snapshot sync. Besu is working on another flat database approach that makes these denial of service attacks less likely. Turbo get from the start is optimized to deal with that as well. And so I don't think again, 1559 can directly address that. When I asked about changing the block slack limit, people didn't seem to think that would make big enough of a difference. So going from 1.5
00:22:55.470 - 00:23:46.080, Speaker A: to x instead of two x didn't seem like it would make 1559 much more likely to be adopted sooner. But it's really more about having client level basically databases that store the state in a flat format instead of a try and everything that goes around that. I don't think it should have a major impact in terms of timelines. If given that there's still work left on 1559, that it won't be in the Berlin upgrade, I think it should probably land in the upgrade after that, and that also gives times to clients to work on that. And then the next up, the transaction pool management. This is basically moot due to Mika's pr, so I'll update that. The transaction encoding decoding was the other big question.
00:23:46.080 - 00:24:06.840, Speaker A: I know, Abdel, you've mentioned in the past that EIP 20 718 would make this easier. I'm not sure what actually is the status on 20 718. It seems like it's kind of in limbo for Berlin. I don't know if anyone has kind of a better view on it than me.
00:24:09.530 - 00:24:24.426, Speaker C: It's in limbo for Berlin. I almost certainly will go in with or prior to 1559. I don't see really any reasonable path where it doesn't go in. There's enough things depending on it that it's going to go in either Berlin or right immediately after.
00:24:24.608 - 00:24:34.560, Speaker A: Okay. And does it make sense to, I guess keep doing what we're doing for now and once it's accepted we adapt 1559 to support it?
00:24:36.450 - 00:24:54.230, Speaker C: I don't think so. If it were me, I would just switch everything over to 20 718 so we don't have to deal with it later. I think the ODS of 20 718 not going in are so low that we should just move forward with it personally, but I'm not an implementer.
00:24:54.890 - 00:25:20.974, Speaker B: We could do something like if we don't want to delay security audits and all that stuff, validation of the economic model, we can deploy public testnet with the actual implementation because the type transaction envelope will don't change any of those results. And on the integration testnet we could start implementing it. Maybe we can do this.
00:25:21.012 - 00:25:27.710, Speaker A: So have like two versions of it. So once we have a more public testnet, then we get to that.
00:25:27.860 - 00:25:28.560, Speaker D: Yeah.
00:25:30.850 - 00:25:56.922, Speaker A: I think, yeah, maybe that makes sense. And it also gives us a couple of weeks to see what happens on the Cordev side. And if it gets accepted in the next cordev's call, which is next week, I believe, then it'll be a bit clearer where things are at. Okay. And then the last thing was the transition period. This is also kind of, I guess your pr, Mika, means that there's no more transaction period at all. Correct.
00:25:56.922 - 00:26:06.410, Speaker A: It's just we convert legacy transactions to 1559 and we allow that forever. Or we interpret them, sorry, as 1559 and we allow that forever.
00:26:07.250 - 00:26:10.586, Speaker C: Yeah. Where forever means TBD.
00:26:10.778 - 00:26:11.520, Speaker A: Yeah.
00:26:11.890 - 00:26:20.400, Speaker C: We have no currently built mechanism for getting rid of them, at least on one five nine, but some future EIP probably will maybe.
00:26:20.950 - 00:26:23.300, Speaker A: Yeah. Cool. That makes sense.
00:26:26.230 - 00:26:49.340, Speaker B: I think there is another thing that came out from the Discord channel, the replaced by. I don't know if we want to talk about that. Yeah, I think Mika has some ideas about how to deal with that. Adding some transaction parameters. Can you explain that quickly, if you don't mind?
00:26:50.510 - 00:27:42.300, Speaker C: So there's a few options. I think I lost track. So Barnaby may know more, but I think the first question is we need to establish exactly what everybody expects from the replace by fee protection. So if you just do replace by fee naively and you just say, hey, as long the fee is higher then you can replace it. You can replace a transaction with one addo e. So one way gas price increase and it's effectively a no op, but it will force the whole network to propagate your transaction against us as a debt now service attack vector where you can just bump the transaction by insignificant amounts forever and just keep hammering the network and the network will continue to accept your transactions. So we want to avoid that.
00:27:42.300 - 00:28:39.760, Speaker C: The problem is that with one five nine, if you bump just the minor bribe, there's no guarantee that the whole minor bribe would be taken because you could be hitting the fee cap. And in fact it is most likely that if your transaction is pending for more than a block, you are blocked by the fee cap, not by your minor bribe. And so if you're just bumping the minor bribe, then we end up with the same situation where someone can just keep bumping minor bribe and not actually change their transaction at all. They cannot pain anymore. And so there's some concerns about denial service tech vector if you just bump the fee cap. Similarly, if your transaction is not pending because you're blocked, then that also does nothing like you pay the base fee, and if the base fee is below your fee cap, you can bump that to 40 billion and you're still going to pay the base fee. And so bumping, that doesn't actually change anything.
00:28:39.760 - 00:29:54.054, Speaker C: So the last option is, well, what if we bump both? And bumping both, I think does work in most scenarios. I think there's some very edgy cases where it's possible to not have your actual fee changed when you bump both. But arguably we don't care that much about those edge cases because they're not really strong service vectors, and as long as we have a minimum increase, then it also doesn't matter too much. The last option is to just say that nodes will not propagate any transaction whose base fee is sorry, whose fee cap maybe feecap plus binary bribe, not sure which, probably just feecap is less than the current base fee. This is a novel idea that we think we probably need to spend a little more time thinking about, but in theory, if we did this, then all transactions that were being propagated should be able to be included in a block almost immediately. The only reason they can't be included in a block is potentially because their minor brackets too low. What this does tell us, though, that we also need to talk about is if the minor bribe is zero.
00:29:54.054 - 00:31:04.538, Speaker C: Let's say we currently don't have a mechanism for pushing that out of the pending pool. It is possible to set a minor bribe that is below a minor bribe that every binder is accepting but have a fee cap that is higher than the base fee fee cap. Should that transaction be allowed to propagate? And if so, how do we define what the minimum minor bribe is for a transaction to propagate? Do we do it like we do currently, where we just say every node in the network has a propagation variable where they say we were willing to propagate any transaction that has a minor bribe of this or higher? That's probably the simplest solution, and we just hope those are generally set in line with miners. These are all the things to think about and discuss. I'm currently favoring that last option where we say the nodes will not propagate any transaction that has a base fee lower than the current blocks base fee. Sorry, a fee cap lower than the current blocks base fee plus minor bribe set per node at startup. So each node can define what their minor bribe is and they'll propagate everything else.
00:31:04.704 - 00:31:14.750, Speaker B: So we don't propagate those transactions on the P two p layer, but we do accept them on the RPC endpoint if the price is below base fee.
00:31:16.050 - 00:31:26.370, Speaker C: Yeah, that would be my assumption. So that way your local node will always accept your transactions from you. If you're talking directly to your own node, it's going to accept everything just like it does right now, I believe.
00:31:26.440 - 00:31:35.234, Speaker B: Okay, it's not the case in Bezo implementation. So I reject transaction. But yeah, I will update the so.
00:31:35.272 - 00:31:47.866, Speaker C: I think, I believe the other clients at least open ethereum and get, and I'm pretty sure another mine, if you are talking directly to the RPC, it will accept anything because it treats you as kind of a privileged user when it comes to what it accepts, and.
00:31:47.888 - 00:31:48.746, Speaker A: So it will accept it.
00:31:48.768 - 00:32:01.086, Speaker C: And I think they all actually have a separate pending pool, sort of where transactions are protected from being ejected from the pending pool on that node. If the node received it over RPC, not over p two p. There are.
00:32:01.108 - 00:32:21.220, Speaker B: Some rules, there is minimum gas price and also minimum bump percentage. But yeah, if the transaction comply with those rules, it will be accepted. And this is what we do for legacy transaction, but we implemented a different behavior for 1559 transaction, but. Okay, I see what you mean.
00:32:22.630 - 00:32:54.158, Speaker C: Like I said, that's my current preference is that we go with the we basically just don't propagate anything that's got a minor bribe that node thinks is too low or a fee cap that node thinks too low. And then I think we can allow basically almost any strategy for fee bumping replaced by fee, because the things that are being propagated are all things that should really probably be mined next block. Like, it is very likely that the thing that's being propagated is going to be mine very soon because the base fee is high enough and the minor bribe is high enough.
00:32:54.324 - 00:32:58.080, Speaker B: Okay, that makes sense. Thank you.
00:32:58.690 - 00:33:01.860, Speaker C: Do other people have thoughts on strategies there?
00:33:03.430 - 00:33:28.070, Speaker D: Wait, you could still increase your fee cap indefinitely even if it's above the base fee, right? I agree that with this idea that you drop transactions where fee cap is lower than base fee, but how does that alone prevent me sending 1000 transactions with just a little bump in the fee cap every time? Like you still need the bribe.
00:33:29.930 - 00:34:10.070, Speaker C: So I think we still do need a minimum percentage, just like we have currently on the network, which is I think 12.5% for geth and open Ethereum. I think. But I think it matters less whether that's a fee cap bump or a base fee bump, maybe, or apply, or both. Sorry, bribe bump or fee cap bump, or both of them. If we're kicking out transactions that aren't likely to be mined soon and we have something that the user has to keep increasing, I guess it does have to minor bribe, doesn't it? Because if it's base fee, then they can spam.
00:34:10.650 - 00:34:21.850, Speaker D: Yeah, okay, it's fine to have the base fee greater, lower than your figure, but I think you still need some kind of bump rule.
00:34:25.070 - 00:34:42.926, Speaker C: Okay, so the minor bribe has to be bumped by some percentage. Say we can keep it the same, 12.5% if it's easy, and then the fee cap can stay the same. But if fee cap of a transaction is lower than the last block's base fee, then don't propagate it over the network.
00:34:43.118 - 00:34:44.660, Speaker D: That sounds good. Yeah.
00:34:45.350 - 00:35:34.942, Speaker C: So I suspect as soon as we tell this to the Ethereum client developers, they're going to tell us that they're going to grumble about the dev p two p layer currently isn't synced with blocks, for lack of better term, because of rollbacks and whatnot. The devtoop layer doesn't really know what the current state of the network is. And so client implementers historically have been very pretty loathed to create a dependency there where the p two p layer needs to understand what the state of the network is because you can get out of sync. Like two clients cannot agree on the current state of network. So client a will say, hey, I've got the new transaction. It's got a base fee that matches or is higher than, sorry. It's got a fee cap that is higher than the base fee.
00:35:34.942 - 00:36:04.700, Speaker C: The node you're sending it to, however, sees a different view of the network. And so they say, no it doesn't. You're lying to me and you're now a bad peer. And so we have the problem now where how do we tell whether a peer is bad or a peer have a different view of the network? And so I think for that reason, historically PTP layer has not correlated with blocks at all. They try really hard to not care about what the current state of network is.
00:36:07.310 - 00:36:08.202, Speaker D: That's interesting.
00:36:08.336 - 00:36:18.510, Speaker A: Yeah, that feels like it would make things much more complicated if we needed to add, if we needed to change kind of the statefulness of the dev P to p protocol.
00:36:19.810 - 00:36:40.600, Speaker B: But I mean, there are higher layer. You can do that in the transaction pool or something like that. You can flag the transaction as not eligible for inclusion in the p two p network, and I think it's manageable. Okay, yeah, I don't know, get enough, but.
00:36:43.770 - 00:36:44.182, Speaker C: Guess.
00:36:44.236 - 00:37:09.040, Speaker A: Yeah, what I'm saying is I would push for similarly to how Mika, you mentioned adding the base fee opcode kind of goes against the current of the cordevs with regards to gas observability. I would try to keep things somewhat like philosophically compatible with dev PDP. But if we can do that verification just at the client level before we propagate it, I think that makes sense.
00:37:10.070 - 00:37:56.960, Speaker C: I think it works as long as it's not a condition for flagging a peer as bad. I believe the clients all have mechanisms for flagging peers as bad peers and eventually disconnect from them. We would need to make this a condition where you say thank you for the transaction. I still trust you, but I reject your transaction, and I don't know if we have that concept at the moment anywhere else. It's usually either you receive something that is very valid and you can assert this is good, thank you, or you receive something that's bad, in which case you say you're a liar and I'm kicking you off of the network, or I'm disconnecting from you. I don't know if one of the client devs might know better. I don't know if we have anything that's kind of like wishy washy, like that.
00:37:59.490 - 00:38:04.674, Speaker B: This is bad that we don't have. Get people on the call, we should have some next time.
00:38:04.712 - 00:38:17.960, Speaker A: Yeah, we can follow up offline with them and with other client devs to see what they think. But clearly the whole, I guess, replaced by fee is kind of a big open question. We still need to figure out. Okay.
00:38:20.730 - 00:38:58.740, Speaker D: I want to point out as well that either way there's going to be some amount of complexity. Even if you don't want to do the statefulness and all, when you manage your transaction queue and when you want to check, like if you don't have a rule, for instance, that says refuse any transaction where the fee cap is not high enough, you still need to look at your transaction queue and update the order based on where the base fee is and how that might change. The actual tip that you receive as a miner. So at some point in time, I think you do need to take into account the fact that base fee is moving and that the transactions, their validity is depending on that as well.
00:38:59.430 - 00:39:05.622, Speaker A: But we can do that at the client level. Right? Like we don't need to do that over death to the p. And also.
00:39:05.676 - 00:39:27.760, Speaker B: You can manage the delta between because you know that the basic can go up or down, up to one on eight. So you can have an idea about how many blocks it would take to in best case, catch up with the transaction price and you can evict or reject transactions that are really far from the base.
00:39:28.610 - 00:39:37.150, Speaker D: Yeah, I guess you can have many different strategies as a client, but. So Dev P two p is not considered part of a client.
00:39:38.450 - 00:39:39.150, Speaker A: Okay.
00:39:39.300 - 00:39:41.010, Speaker D: Yeah, that's what I was using. Thanks.
00:39:41.080 - 00:39:44.500, Speaker A: So it is part of the client, but it's a different spec.
00:39:46.550 - 00:39:48.270, Speaker B: Yeah, different protocol.
00:39:48.430 - 00:40:15.370, Speaker A: Yeah. Whereas the transaction pools is kind of left to, there's no rules about what clients have to do with it. Each client can do whatever they want and they don't need to agree with each other about how they handle it. Even though in practice most of the behavior ends up being the same, at least we don't have to write a spec for it that says this is how the transaction pool works. So this is what makes it easier to do it there than in dev PDP.
00:40:16.670 - 00:40:17.740, Speaker D: Okay. Yeah.
00:40:21.730 - 00:40:50.854, Speaker A: Okay, cool. So I'll add that and try to summarize this conversation here in the open. Issues. Other couple things that were just on the list of the testing in general, I think we haven't spent much time on. I know, Abdel, you mentioned we should maybe start thinking about reference tests and whatnot. I'm not sure if the EEP is stable enough for that yet or. Yeah.
00:40:50.854 - 00:40:52.440, Speaker A: What are your thoughts on that?
00:40:54.030 - 00:41:26.660, Speaker B: I think, for example, the basic computation is stable enough to start some kind of reference test because otherwise each client team will implement. Yeah, we will not leverage the work and that will be good to have this kind of test to ensure that. And it will also help other teams when they will want to implement the spec. Let's say when Turbogate and Openeter want to implement the heap that will help them also.
00:41:31.440 - 00:42:09.610, Speaker A: Yeah, I think we can probably start slowly adding some, like you mentioned, I think on the parts that are a bit more. Yeah, so we kind of discussed this already. So with the community testing, basically the JSON RPC. Abdel, you said in the chat, I think that right now the block explorer is using get transaction by hash. So that already supports 1559 no. So I guess I don't understand, how does the block explorer get the transaction information?
00:42:10.480 - 00:42:29.920, Speaker B: Currently the block explorer only display the legacy. Okay, so for example, you have a zero gas price for. Yeah, we need to update this endpoint to add the minor bribe and probably even the base fee.
00:42:31.140 - 00:42:33.056, Speaker A: So the base fee is in the block header though, right?
00:42:33.078 - 00:42:43.136, Speaker B: Yeah, but we have the block hash as the response of this endpoint so we can query to retrieve the block header.
00:42:43.248 - 00:43:14.828, Speaker A: And I think there what would probably be best is to just come up with a spec that both we vulcanize and methamine agree on before we implement it. Because again, that came up, I know with a lot of the tracing APIs and whatnot, clients have very different behaviors. And as part of the 1559 conversations that came up, like it would be great if the behavior here was the same. So I think it might make sense to just see if no one has super strong divergent opinions. We should just come up with a.
00:43:14.834 - 00:43:29.204, Speaker B: Spec currently for legacy transaction we exactly have the same output. So yeah, we can do the same for the two new parameters just aligned on the names and we can just take the names from the spec. That will be the best.
00:43:29.402 - 00:43:34.724, Speaker A: Okay, cool. Just so I understand that the idea.
00:43:34.762 - 00:43:46.212, Speaker C: Is get transaction by hash will still work as normal. It's just it will also include 1559 transactions and they will have a couple of different fields.
00:43:46.276 - 00:43:46.890, Speaker B: Exactly.
00:43:52.700 - 00:43:57.964, Speaker A: I guess let's just ask other clients before we commit to that. But that seems reasonable to me.
00:43:58.162 - 00:44:17.250, Speaker C: And would that also e block with the true flag for full block so the one that returns all transactions, I think it's get blocked by hash I believe is the one. Would that also do it? Yes, I believe there's only two that return transactions, is that correct?
00:44:17.860 - 00:44:19.330, Speaker B: Yeah, I believe so.
00:44:22.360 - 00:44:31.960, Speaker C: Do we have plans at the moment to introduce or support 1559 transactions for eth send transaction?
00:44:33.100 - 00:45:22.250, Speaker B: So this is what I talked about earlier, my opinion on that. If this is only for Testnet, I would suggest that we implement a common service for that and we just deploy it in the same infrastructure as the testnet so that client implementer, not client but wallet providers and people can start playing with that without waiting for metamask or web3 GS to add the new field. I guess if you want to use that on main net, you will have to implement a new endpoint to submit 59 transaction unless you use an external signer. But yeah.
00:45:24.380 - 00:45:30.570, Speaker C: Would it make sense to have e send transaction just support either?
00:45:32.700 - 00:45:35.240, Speaker B: That would be best. You make some fields optional.
00:45:40.480 - 00:45:49.570, Speaker C: It would probably be good, Tim, to make sure. Someone's tasked to actually writing the specs for those three. It'll be three new.
00:45:52.820 - 00:45:56.320, Speaker A: Yeah. The changes to the JSON RPC have to be separate eips.
00:45:57.620 - 00:46:16.170, Speaker C: Yeah. Well, they, yeah. Don't have to do anything. Of course. Ideally, yes, there'd be an AIP for each of them that specifies the changes that are being made to the JSON RPC. And then from there, clients can implement it and wallets providers can implement it and metamask can implement it and fury can implement it.
00:46:16.940 - 00:46:21.130, Speaker B: I thought they were out of scope. The.
00:46:25.200 - 00:46:29.020, Speaker C: Okay, yeah, they're not core ips, they'd be interface.
00:46:32.000 - 00:46:35.890, Speaker A: We basically need one eip per JSON RPC call, right?
00:46:36.580 - 00:46:48.212, Speaker C: Yeah. And I believe there's three of them that we need. Get transaction by hash, get blocked by hash and send transaction. There might maybe get blocked by number as well.
00:46:48.346 - 00:46:59.270, Speaker B: Yeah. Because you want to add the base. Yeah. Get blocked by hash and get blocked by number as well because you need to add the base header for.
00:47:01.500 - 00:47:06.584, Speaker A: And how about eat send raw transaction? Does that have to change as well?
00:47:06.782 - 00:47:11.288, Speaker C: No, I don't have to change because you're just sending a byte array. It's already signed.
00:47:11.384 - 00:47:12.030, Speaker A: Okay.
00:47:12.400 - 00:47:15.020, Speaker C: Input, output, ignore it.
00:47:15.170 - 00:47:18.910, Speaker A: Okay. Exactly. So there's four of them and we need to eat for each of those.
00:47:19.840 - 00:47:27.628, Speaker C: Ideally, people in the past have done one monolithic one. As an editor, I recommend separate. They go through smoother.
00:47:27.804 - 00:47:43.910, Speaker A: Okay. So unless somebody on the call right now wants to commit to it, I can follow up on that, I guess. Yeah. I'm just a bit cautious because Abdel is a person and he is here to throw it on.
00:47:45.720 - 00:47:50.150, Speaker B: Mean, I can take some. Yeah, that will be the occasion to start my first.
00:47:51.320 - 00:47:59.156, Speaker A: I mean, sure, if, if you want to do great. Sold. So Abdel will have you write those Eips.
00:47:59.348 - 00:48:00.580, Speaker B: Okay, nice.
00:48:00.750 - 00:48:43.480, Speaker A: Cool. Okay, so yeah, I think this covers JSON RPC public. Testnet we already kind of, I think, is dependent on having this JSON RPC a bit more fleshed out. And the other bit, I guess, in terms of testnet is, I'm curious, right now we have the POA network. It seems like there's some small changes to make to the spec before everybody's kind of all syncing and happy there. Is it worth starting to discuss a proof of work network now or do we still need like a couple of weeks before that because of the changes? I know get is still having the consensus issue on the POA network.
00:48:47.020 - 00:48:48.970, Speaker C: Isn't Nethermind already done?
00:48:49.420 - 00:49:10.316, Speaker A: Yeah, I think Nethermind and us are thinking maybe with some recent changes to the EEP, there's some small tweaks to do. But I suspect, like in the next week, us and Nethermind at least should be on the same network and up and running. I don't know if Nethermind supports mining, not yet at all, or 1559 mining.
00:49:10.428 - 00:49:12.370, Speaker B: No, not 1559.
00:49:13.940 - 00:49:31.112, Speaker A: Okay. So I think that's something we probably want at least, like having more than one client support mining before we launch a proof of work testnet. So we can actually try to mine blocks in two different clients and make sure that they all come out the same and work.
00:49:31.246 - 00:49:51.630, Speaker B: Yeah. And in parallel, maybe we can start because we were thinking also about launching single client testnet. That could be a single client proof of testnet, and that will be the candidate to add other clients next, for example, the one to validate the economic model.
00:49:52.960 - 00:49:57.536, Speaker A: And do you think we could do that with BesU already? Is there anything we need to change with BESU to do that?
00:49:57.638 - 00:50:00.610, Speaker B: No, that should be fine. Yeah, we could do that.
00:50:01.300 - 00:50:48.976, Speaker A: Okay, so maybe it makes sense, yeah. To just start off a small Basu proof of work testnet to make sure at least everything works and we can produce blocks and we can run your transaction generation script on it. And in the meantime, we'll see over the next couple of weeks how other clients get ready and what the extent of their mining support is. Cool. And then, yeah, just worth mentioning, I guess Nethermind was using 1559 as part as, I believe, like a private network or a network they're working on with one of their clients. So I think they might have some data to share on that in the next few weeks or months. And then Falcon and cedo both have 1559.
00:50:48.976 - 00:51:27.324, Speaker A: The falcoin devs have joined our slack or discord. Sorry. So, yeah, if people have questions for them about how the network has gone, they're there and they can answer those. And I guess in terms of R and D, the biggest thing that also came out in the survey with the community is kind of the lack of a proper, not like even economic analysis of the EEP, but kind of just like a proper description of the mechanism. Because a lot of people's concerns when they were opposed to the EEP was. There's not even like something to critique. Right.
00:51:27.324 - 00:52:14.780, Speaker A: There's just like this eep which specifies the behavior, but it doesn't kind of express the intuition behind it and whatnot. I'm not sure who could help with that. But to me that feels like something that would be valuable having a sort of, I don't have background in economics, so I don't know how this stuff is usually done, the sort of like econ spec version of the EeP that kind of explains why this will actually be better. I know that Tim Rothgarden is working on a comparison of 1559 versus our current model, so I'm not sure how much of it will be covered by that. But I don't know if anyone here has thoughts about how that can be done or ways, just those concerns about not having something that specifies the economic properties of the mechanisms that can be shared broadly.
00:52:15.760 - 00:53:23.520, Speaker D: Yeah, I can say that. First, like the paper where Vitalik introduces 1559 has some motivation, some modeling, and I think it's been a bit overlooked by people who say there's been no economic analysis. That's where it comes from. First. Then the IP was written, which arguably has less, let's say economic or at least microeconomic motivation for it. And then Tim Roughgarden, I think his angle is really much to say, well, what do we bring by having EIP 1559? How does it change? Why is it better than the current model that we have? And how do we even quantify what better means? I do expect that his report will be very enlightening in terms of framing it, but as I said before in the discord, I don't expect it will be like, yes, we should do it, or no, we shouldn't. It's really more like, what is even the correct way to think about this? What are the metrics we care about? What do we mean when we say it's a UX improvement?
00:53:26.420 - 00:53:44.056, Speaker A: Yeah, and I think that's good, actually. I don't think people are looking for a justification as much as a description. And I think it's probably easiest to describe by contrasting with what we have today. Do you have a link to Vitalik's paper? If you could send it in the chat, I'll add it to that list there.
00:53:44.238 - 00:53:44.970, Speaker D: Yeah.
00:53:49.900 - 00:54:16.450, Speaker A: Cool. And then the last bit, I guess. Barnabay, I can link some of your notebooks here, but in terms of simulations you mentioned, obviously kind of all the stuff you're working on right now, is there anything you still think is missing after that? Is there other big areas you'd want us to have simulations on that you think we haven't addressed yet or have had the bandwidth to start working on?
00:54:17.220 - 00:55:02.384, Speaker D: Right. There's a few things I discussed at the very beginning of the call, which is more what I'm working on. So one big chunk that I left out, but almost let's say by design is this idea of minor collusion. It's something that we do plan to, let's say simulate or at least try to get a broader understanding of what the behavior is. The reason I'm not focusing on this at the moment is because I do think the analysis by team will be at least a useful starting point. It's kind of trivial to define something where it fails or it succeeds automatically, but I think it's not going to bring much to the. Apart from that.
00:55:02.384 - 00:55:10.550, Speaker D: Yeah, I think I should probably help you fill that PBA because it looks like there's nothing, but I can send you something.
00:55:10.920 - 00:55:24.200, Speaker A: Okay, that's great. Yeah. And I'll add all the stuff you mentioned at the beginning of the call as well. So we'll have at least some meat there. And then the last bit was the community outreach. This is still out of date. We published a report yesterday.
00:55:24.200 - 00:56:00.976, Speaker A: One of the big things that we mentioned in the report is there was a very small number of exchanges and wallets that answered. So I think if we do more outreach, I'd personally like to focus on those two groups. Yeah. So to just get more wallets perspectives, I feel like exchanges are probably less affected by this and they tend to be pretty reluctant to share data publicly. So I'm not sure how realistic that goal is. But I think on the wallet side, we can definitely reach out to a few more folks and get their perspective on it. So we'll keep on doing that in the cathoders.
00:56:00.976 - 00:56:48.630, Speaker A: We'll probably have an updated version of the report. I don't want to give a date, but like in few weeks, few months or something, once we've talked to a bit more people on that end. And that's all I had on the agenda. I don't know, is there anything else people feel we should discuss? Okay, well, in that case, yeah. Thanks a lot, everybody. This was really good. We'll have full notes for the report, for the meeting, and I'll share a summary on, on Twitter in the next hour or so.
00:56:50.920 - 00:56:51.990, Speaker B: Thank you, guys.
00:56:53.960 - 00:56:54.530, Speaker A: Thanks everybody.
