00:00:16.010 - 00:00:43.030, Speaker A: Hello everybody. How's it going? My name is Martin, I work at Open Zeppelin and today we're going to be talking about deconstruction and why it's probably the future of crypto UX and probably security too. Let's begin. So let's first define what account of traction is. And to better understand this, it's better to speak about smart accounts. You might be familiar with them already. Smart accounts are basically smart contracts that behave as accounts.
00:00:43.030 - 00:01:22.274, Speaker A: They verify transactions, they hold assets, privileges, roles like owner. They can also call other contracts, which is very important. Some known examples of this is the very popular Nosisafe multisig argent wallet that has social recovery and instadap. Now, account abstraction is basically a smart account can also pay for its own transactions. That's pretty much it. What can we do with them? Well, basically we can have custom validation schemes. This means you can use Ethereum signatures, Bitcoin signatures, whatever signature you want, multi signature or any other criteria or logic you want to implement.
00:01:22.274 - 00:01:52.010, Speaker A: For example, this is only valid on Wednesdays. You can implement key rotation in case. Picture the scenario in which you compromise your keys instead of migrating all of your assets and roles and whatnot, you simply rotate the keys and you're done. You are safe. We can also have guardians social gori, which is a very good feature. And session keys. Think of session keys as basically, for example, a JSON web token or a set of permissions.
00:01:52.010 - 00:02:36.202, Speaker A: You grant for example, a website, a web application. So you sign once a set of permissions defined by some policy or something and then that website that can act on your behalf without you having to sign each transaction every time. Which basically gives us web two experience on web3. So how does it look today on STARTnet? This is basically the interface of an account. We are going to focus on the last four ones which are execute, validate, validate declare and validate deploy. We can think of this in a two step execution flow. First, the validate step.
00:02:36.202 - 00:03:03.190, Speaker A: The validate step you can define arbitrary logic to determine whether a transaction is valid or not. There's a few limits in here. For example, you cannot read other contracts. Storage this is to prevent spam. Picture the scenario in which there's many transactions that depend on the storage of another contract. That contract changes that storage and then invalidates lots of transactions that could be a spam. So that's prohibited.
00:03:03.190 - 00:03:58.150, Speaker A: So this validate function is used by sequencers to know in advance whether a transaction is valid or not. Because instead of an EOA in which you simply verify the signature, you cannot do that as simply in here because you need to execute some code. And this execute step does what you would expect. Finally, since counts are contracts, you need to deploy them and you need to pay for deployments. So how do you do this? Well, basically we can do contractual deployments which is you calculate the address of your contract before you send funds to that address that has no contract yet. Then there's this validate deploy function that the protocol uses to validate whether the funds on this address can be used to pay for this transaction or not. And then, basically, you deploy your smart account, well, account abstraction.
00:03:58.150 - 00:04:25.774, Speaker A: And finally, in STARnet, you can use Opensable contracts for Cairo, in which we have an account regular account, which is the STARnet signature scheme. We have an ETH account, which is Ethereum signatures, and an account library that you can use to build your own custom accounts. And I hope that by now you got the idea that it means a huge improvement in onboarding user experience and security.
00:04:25.972 - 00:04:27.600, Speaker B: Martin, that was asked.
00:04:27.910 - 00:04:28.370, Speaker C: Sorry.
00:04:28.440 - 00:04:34.260, Speaker A: One last thing. There's a pop for this talk. You can just ask me right now.
00:04:34.710 - 00:04:42.120, Speaker B: I mean, since this was the last talk, you have the chance to get some questions from the audience. Of course, we still have time.
00:04:43.210 - 00:04:54.300, Speaker C: So, in the Ethereum version of account abstraction, you will have a separate mempool and a boundaries and stuff. So I guess in StarkNet, this role will be replaced by the sequencer itself.
00:04:54.910 - 00:04:56.540, Speaker A: I didn't get the last part.
00:04:58.830 - 00:05:07.690, Speaker C: In Ethereum, in order to execute a abstraction, you need a separate mempool and a boundary system. So what would be the equivalent for StarkNet?
00:05:07.770 - 00:05:10.590, Speaker A: Right, so, I mean you mean EIP 4337?
00:05:10.660 - 00:05:11.182, Speaker D: That's right.
00:05:11.236 - 00:05:13.890, Speaker A: Right. And you're asking about the paymasters?
00:05:14.390 - 00:05:24.558, Speaker D: No, we're talking about how is there an alternative mempool that actually relays, like, vendor transactions or how does it happen concretely, on StarkNet, the use of account abstraction.
00:05:24.734 - 00:05:36.598, Speaker A: So, basically, you send a transaction and the sequencer picks that transaction, validates this validate function, and if it's okay, then it's inserted into the block. I'm not sure I got the question. Right.
00:05:36.684 - 00:05:38.646, Speaker D: So account abstraction is actually built in right.
00:05:38.668 - 00:05:38.950, Speaker C: Sorry.
00:05:39.020 - 00:05:45.580, Speaker A: Oh, that was it. Yes. There's native account abstraction on the system. There's no EOS, so they're completely replaced by them.
00:05:46.270 - 00:05:52.270, Speaker C: How do you ensure that in the validation process, the validation result will be the same in the actual execution?
00:05:53.570 - 00:05:55.022, Speaker A: Well, what do you mean?
00:05:55.076 - 00:06:00.366, Speaker C: For example for example, if one transaction depends on the block timestamp okay, sorry.
00:06:00.468 - 00:06:14.542, Speaker A: Yeah, so that's part of the limitations. So you cannot read any external information from the contract. That includes, like, block timestamp, other contract storage. So you cannot use anything that depends on anything else. That the very same contract.
00:06:14.686 - 00:06:19.286, Speaker C: So does that mean that every wallet address on StarkNet cannot use those?
00:06:19.468 - 00:06:26.946, Speaker A: No. No, they can. But not on the validate step. They can on the execution step, but the validation step has these constraints to prevent spam.
00:06:27.058 - 00:06:27.606, Speaker C: Got it.
00:06:27.628 - 00:06:41.850, Speaker E: Thanks for the great talk. And one question. Could you just have a lot of execution code in the validate step and only at the end find out that it's not validate, not a valid transaction, and thereby spam those nodes?
00:06:41.930 - 00:06:55.818, Speaker A: Infinitely, definitely. But there's smaller chances for some other reasons. You're saying that you could invalidate the transaction on the execution part, not the validation.
00:06:55.914 - 00:07:01.658, Speaker E: I mean in the validate function. Put a lot of stuff in there, complex stuff. Like it takes a long time to compute.
00:07:01.754 - 00:07:03.658, Speaker A: Only in the end, there's a gas limit.
00:07:03.754 - 00:07:05.910, Speaker E: Okay. How much is the gas limit for the validate function?
00:07:05.980 - 00:07:06.726, Speaker A: I got to know.
00:07:06.828 - 00:07:08.790, Speaker E: Okay, but that's the solution.
00:07:09.690 - 00:07:12.966, Speaker B: All right. Thank you so much. This was the end of day one.
00:07:13.068 - 00:07:13.880, Speaker A: Thank you.
