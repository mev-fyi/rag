00:00:00.410 - 00:01:02.266, Speaker A: You okay? Let's get this started. Thanks everyone for joining second public 4844 implementers call, bunch of spec updates today and then hopefully we can spend a lot of time talking about definite three hi level. Like last week there were a couple different spec issues we had to go through. I think we resolved all of them, so we'll go into those as we cover the spec. We definitely want to chat about CKZG. There was some changes done to the interface and also support for Rust and Nim that we want to discuss. And then trying to put together a spec for the Devnet.
00:01:02.266 - 00:01:31.980, Speaker A: What that looks like talking about this blob testing a bit more and yeah, I think that's pretty much it. Oh, and Jesse just added something about the capella spec changes. So maybe to start Anzgar, you closed the fee market issue and you opened up a bunch of new spec issues. Do you want to just give us a quick update there? Where are we at on the fee market?
00:01:34.590 - 00:02:04.834, Speaker B: Sure. So the fee market pis finally merged. There wasn't really any changes since last week's call. The only one kind of substantive spec change that did happen was the one we agreed upon. That is to reduce the minimum price per data gas down to one for the pr itself. So that has happened. And I think my understanding is that the current testnet uses kind of the original value that was there.
00:02:04.834 - 00:02:57.598, Speaker B: So basically that is the one place in which the fee market right now, I think the spec and the testnet then do diverge, but other than that, nothing changed. So that's much now. And then basically I opened prs for all the remaining places where at least from what I can see about the EIP, basically there are still things, actual specs change that will change between now and bringing this domain in, just basically. So we have all of them open because people on all codefs did express a desire to basically get to something at least close to a spec freeze as soon as possible. And so these three places are one just appear again to change this minimum data gas price back to something other than one. Yeah, it's more met as a place of discussion. So we could do that.
00:02:57.598 - 00:03:44.130, Speaker B: We could not do that. We could change it, pick a different value, whatever, but at least now there's a place where we can make that decision. The second one was the one that we also talked about last week, which is the returning the modulus from the pre compile. Actually the pre compile does not currently return any value, so it would now just return the modulus. Although Dunkrad, I didn't really give Duncrat any time to add the rationale section. I only did that yesterday evening, but he already, still already delivered and wrote something about the rationale. And we might have to add something, not only return the modulus, but also return some second value.
00:03:44.130 - 00:04:24.334, Speaker B: I forget exactly what that was. Maybe Duncan can talk about it in a second and then the third one just for completeness. I think we all kind of agreed in Bogota and everywhere that we should initially kind of reduce the throughput of the EIP, start with a smaller one and then ramp back up in later hard forks. So just to actually get that into the spec, I also created a third pr that's maybe the one that the most people would have opinions on. I just picked two blobs target four blobs max. So zero point 25 megabytes target 0.5 megabytes max as something that seemed like a sane starting value.
00:04:24.334 - 00:05:07.360, Speaker B: But if people are opinionated, should be higher. Lower, yeah, that would be a good place to also come there. And I think that's all for my there's one more small thing that came up during kind of getting all this prs merge right now we do have external links in the EIP, which is a little bit annoying because that's against the EIP editing rules. So the bot is always unhappy. So right now, basically author approved prs do not get auto merged. We should fix it in some way. We should either get some EIP editors to modify the bots and allow this, or we should remove the external links, but this is not a great place to be.
00:05:09.650 - 00:05:50.750, Speaker A: Yeah, I think on that note, the EIP editors are literally discussing adding external links ASAP and especially like having a sort of allow list for external links. And the CL specs would definitely be part of that. I can follow up on that to see if there's a way to just make that single change quicker, but we're not always blocked on that. Sweet. Any comments? Thoughts on the various spec changes that Angar just discussed?
00:05:57.270 - 00:06:25.470, Speaker C: The modulus one, do we think that it seems like the minimum data gas price and the reducing of throughput, those are constant changes, and so it seems like we probably are comfortable with leaving those open for a little bit longer and having discussion. But the modulus one is an interface change. Do we think we can get that merged in the next week ahead of the next all core dev so we can say at least all the interfaces or. Yeah, I think we can hopefully get to all the interfaces being merged?
00:06:31.900 - 00:06:53.200, Speaker D: I think I would say yes. Just one modification that still needs to make. We need to just the modulars. We also meet the block size as a value should also be returned. But yeah, that's all. I don't see quite happy about tomorrow.
00:06:56.690 - 00:07:08.500, Speaker A: Awesome. So there's no contention around the approach. It's just a question of actually merging it. Because I know on the last call we had like four different options, but.
00:07:10.150 - 00:07:13.890, Speaker D: Yeah, we don't know about that. What were the other options?
00:07:13.960 - 00:07:48.880, Speaker A: I haven't heard about was Vitalik had like these four options. So two of them were like Modulus opcode, and then. Yeah, there was the question of taking the modulus as an input versus returning it as an output. I think we all agreed that we preferred it as an output on last call, but then the only other design choice was would we want this as an opcode instead? My personal opinion is no, but I don't know if there's someone who strongly feels we should have it as an opcode instead.
00:07:55.240 - 00:07:58.552, Speaker C: I think we had the whole debate about this last time and we landed on this.
00:07:58.606 - 00:07:58.824, Speaker A: Yeah.
00:07:58.862 - 00:08:02.170, Speaker C: So if anyone has final move with it.
00:08:05.800 - 00:08:32.850, Speaker A: Okay, great, then yeah, let's try and get this merch in the next week or so. And yeah, that would be nice to come on. Awkward as and have only basically the two constants left to tweak in the EIP. Marius, what do you mean in the chat? So we need a spec at some point that blob transactions are not sent via broadcast anymore.
00:08:36.070 - 00:09:39.420, Speaker D: So if we allow blob transactions to be sent via broadcast, that opens up a DoS vector on the transaction pool. And the thing we came up with in Bogota was to disallow transactions to be sent via. And so we have two types of sending transactions. Basically one is just broadcasting them. We usually broadcast to the square root of the number of peers. And the other way we do it is we announce the transactions that we have and peers can ask for the transactions by hash and we spec Eve 68, which basically enhances this announcement message. So we not only announce the transaction hashes, but we also announce the transaction type and the transaction size.
00:09:39.420 - 00:10:18.790, Speaker D: And doing so makes it really easy for clients to only pick blob transactions or only pick non blob transactions, depending on their state. If they have enough blob transactions in the transaction pool, then they will not fetch further blob transactions. Or if they are currently being DOS or don't have the compute bandwidth, then they're not going to fetch block transactions.
00:10:19.370 - 00:10:20.120, Speaker A: And.
00:10:22.890 - 00:10:51.600, Speaker D: We have the spec for 68. Also, we rolled out the implementation in gas, but we don't have the spec that blob transactions are not allowed to be broadcasted, and broadcasting blob transactions is a protocol violation. And we kind of need this for security at some point. So we need to create a new spec for that.
00:10:54.290 - 00:11:05.794, Speaker A: And so this means, just so I understand correctly, it's like you can still send a blob transaction in the public mempool, but your peers will have to specifically request it from you. Is that correct?
00:11:05.992 - 00:11:22.502, Speaker D: Yes, exactly. It's like you're not broadcasting the transaction, but you're announcing the transactions to your peers, and they will fetch it from you. It just turns around the announcement mechanism, basically.
00:11:22.636 - 00:11:25.898, Speaker A: Anskar. Right.
00:11:25.984 - 00:11:40.240, Speaker B: I was just wondering, Maurice, am I correct in my understanding that right now, the kind of the broadcast would not include the gas price or the data? Gas price?
00:11:41.970 - 00:11:49.262, Speaker D: Yes. The broadcast only includes the size of the transaction and the type of the transaction.
00:11:49.406 - 00:11:49.810, Speaker A: Okay.
00:11:49.880 - 00:12:25.550, Speaker D: And it's good enough, I think it will allow you to create a transaction pool that if you don't have any valid blob transactions and you have enough time to verify them, you will fetch them. And you can hold, like, maybe 100 blob transactions in memory or something and make sure that you have enough blob transactions to fill the next couple of blocks.
00:12:28.210 - 00:12:38.260, Speaker A: Should you add the max fee to that? So that when you broadcast a transaction, you're saying it has this max fee. And so this way I can know.
00:12:40.630 - 00:12:51.030, Speaker D: If we start adding more fields, then it becomes very brittle because people can always lie about these fields.
00:12:53.290 - 00:12:57.270, Speaker A: Okay, I see. You need to verify the balance.
00:12:58.730 - 00:13:10.506, Speaker B: How easy would that be to later modify? Because the nice thing, of course, is that this is not, like a consensus change. So it sounds like this should definitely be good enough to kind of roll the out and everything.
00:13:10.688 - 00:13:17.680, Speaker D: It's very easy to just create a new youth protocol version and add fields to this announcement message.
00:13:18.050 - 00:13:18.462, Speaker A: Okay.
00:13:18.516 - 00:13:35.060, Speaker B: Because it feels like this is something where, like, six months into having the eip life and just seeing behavior, we can always just revisit and see if maybe some propagation of Bob transactions. Not ideal, and we can improve it or something, but this would definitely be. Sounds like this would be good enough.
00:13:35.590 - 00:13:44.840, Speaker A: For the long and so for the disabling of the gossip. Is that an extension to eat 68, or do we need, like, e 70 for that?
00:13:48.410 - 00:13:49.820, Speaker D: E 69?
00:13:51.070 - 00:13:52.986, Speaker A: We had e 69 already.
00:13:53.168 - 00:14:39.240, Speaker D: No, we kind of made the choice not to go ahead with e 69 because e 69 just adds the withdrawals to the block body. But we changed the structure of the messages before. For example, when we added 1559 without a new ETh protocol version. And since it's only optional fields, it's kind of fine not to create a new ETh protocol version. The kind of similar thing with this, we can create a new ETh protocol version, but it's not really needed.
00:14:39.770 - 00:14:49.180, Speaker A: Yeah, it feels like conceptually having it all in e 68 would be nice, because you can say this is the Eat protocol version change for port four four.
00:14:50.830 - 00:15:23.160, Speaker D: Why we didn't do it in e 68 now is because we want to roll out e 68 now. And it's not a change that needs to know about withdrawals. It doesn't need to know about blob transactions. It just modifies this announcement message. And so we can roll it out now. We can have clients update, and in six months we can actually use it. Okay, that's the idea.
00:15:23.690 - 00:15:29.080, Speaker A: Okay, so then let's split it to e 69. Does that make sense?
00:15:30.730 - 00:15:39.450, Speaker C: This may be a dumb question, but I'm trying to learn what's preventing us from just putting this in 4844 as like a component of the specification.
00:15:40.670 - 00:15:42.720, Speaker A: Networking just has this.
00:15:44.050 - 00:16:05.714, Speaker D: So having this rule about the blob transaction actually kind of fits into four eight four. So that would be my proposal to add it to four eight four. Yeah, I don't know.
00:16:05.752 - 00:16:17.510, Speaker A: And is it basically just saying these transactions cannot be gossiped in a mempool? They need to be announced using e 68 and then sent to peers?
00:16:18.170 - 00:16:19.340, Speaker D: Yes, exactly.
00:16:20.030 - 00:16:26.700, Speaker A: Okay. Do you want to make that change, or is it helpful if somebody else makes the change to the spec?
00:16:29.550 - 00:16:47.540, Speaker D: I'm not an author of void for four. I have no idea about the spec of void for four, so I don't want to intrude there. If someone wants to take over, that would be really nice, and I can help them with it.
00:16:49.990 - 00:17:41.890, Speaker B: Yeah, I can do it. And also, just to mention, because that was one of the last small changes with the fee market pr, someone pointed out that the mempool issues section was no longer kind of relevant because that was written with a dynamic block pricing in mind back when it was still kind of charged dynamically in gas. So that was mostly deleted and replaced with a small section. The small section does already say that basically recommended changes would be to no longer propagate large transactions. I kind of wanted to link to Marius's EIP, but again, one of these external. It's not an external link, but it's a link to an EIP that was not yet merged, and that's not allowed either, so I couldn't get linked to it. But once that is in a state where we are allowed to link to it.
00:17:41.890 - 00:17:46.020, Speaker B: It would be a small change to actually basically explicitly mention it and stick to it.
00:17:47.750 - 00:18:16.094, Speaker A: Yeah, I guess. Is it possible? Can we do the change now without the link? We can just mention e 68 in text. Right. And we did this for the merge IP to get around this. And then once it's merged we can just add a link. But I think it would be good to have a PR for that sooner rather than later, even if we don't have a merged link to the actual e 60 80 IP. Sounds good.
00:18:16.132 - 00:18:22.094, Speaker B: And I can double check with Marius that the way we mentioned in the AP makes sense.
00:18:22.292 - 00:18:42.374, Speaker A: Awesome. Thanks, Anskar. Um, okay, there was another pr. Is Terrence here? Actually, I don't see him, but Terrence added. Yeah, I'm here. Okay. Sorry.
00:18:42.374 - 00:18:49.980, Speaker A: Oh, sorry. Yeah, lots of people on the screen. Yeah. You had your pr for the engine API that you wanted to.
00:18:55.710 - 00:19:22.354, Speaker E: Take credit away. That was Proto's pr. But I do think we need to do something with it other than just having the pull request out there. It's been there for a few months. I think there's two ways to go about it. The first way, it just merge it to the master and then because we're going to have a v two at some point anyway. So therefore when we have a v two for the long term, we can just deprecate this one.
00:19:22.354 - 00:20:07.740, Speaker E: And then the second option is just have like a four a four folder and just put that in a four a four folder, similar to what we did with the consensus spec. Yeah, I just don't think for the short term in a pr is a good idea because first of all, it is very hard to find. It took me and my teammates a few minutes to find it. So yeah, I'm open to both options and I'm curious to hear what people think. And I don't think there's any engine API authors here, unfortunately. But whoever is working or whoever has the right to merge engine API PR, feel free to speak out.
00:20:09.650 - 00:20:28.418, Speaker A: So is this about whether to make the get payload versions and the new payload versions different from prior versions? So having the version increment as the payload changes. Right.
00:20:28.504 - 00:21:07.002, Speaker E: So I think in this definition, which is v one, get blob is a separate engine API call. But then for v two, I think it's meant to be coupled. So when you say get payload, it also returns the blob bundle as well. I think for now we just have to worry about v one because that's what gas has implemented and it's quite nice. I don't think there's that much implementation complexity. It's just two codes versus one code. But yeah, so my point is just like if we have this definition, I think we should put it somewhere else that's more official.
00:21:07.002 - 00:21:12.110, Speaker E: So therefore other clients can begin experimenting it, such as? Nevermind.
00:21:15.110 - 00:21:58.640, Speaker A: Basically, I guess I would rather not set up a whole 4844 folder because we don't really have that in the execution APIs. Like there's just one spec. I would lean towards just merging this and then maybe the two people I'd want to get like a sanity check thumbs up on are Mikhail and Matt, who both left comments on the pr. But I can send it to the two of them, see if they have any objections to merging it as is. And then yeah, we can discuss the v two method separately. But I agree having this actually merged would be good.
00:21:59.170 - 00:22:00.960, Speaker E: Okay, yeah, sounds great.
00:22:02.950 - 00:22:07.186, Speaker A: And assuming that either Mikhail or Matt doesn't have an objection, I think we.
00:22:07.208 - 00:22:08.340, Speaker E: Can just merge this.
00:22:09.830 - 00:22:57.394, Speaker A: Yeah, so one thing I would say though is if we keep get payload separate, we need get payload to have the pre and post fork versions of the payload. So I would imagine this would look like having a get payload v one that's like the merge fork, get payload v two that's capella fork, and then either include the execution payload fields in that one, or we would need a v three in order to separate the withdrawal version from the Capella version. So if you have to implement three versions of that, I guess that's, can.
00:22:57.432 - 00:23:29.258, Speaker D: We not have them as optional fields in v two? So we already have v two for withdrawals and I don't believe we actually need v two for withdrawals. We could just have optional field, but the way we implemented right now we have v two, and I think it should be possible to add the blob stuff as optional to that's.
00:23:29.274 - 00:23:34.800, Speaker B: In fact the way I'm adding it in right now, just adding another optional field seems to be fine.
00:23:36.450 - 00:23:57.590, Speaker A: Okay, sure, I mean, that's fine with me. Okay, so we merged this one as is as a separate call, which we've, is there still, yeah, I guess. Is there still value in this separate call if we're adding the optional fields to get payroll v two.
00:24:04.860 - 00:24:08.570, Speaker D: In the separate call as is? Probably not.
00:24:09.900 - 00:24:10.650, Speaker A: Okay.
00:24:15.520 - 00:24:16.670, Speaker D: I don't know.
00:24:17.520 - 00:24:32.240, Speaker A: I mean, does it unblock people working on prototypes now to have this get blobs bundled v one call merged? Or should we close this pr and instead open one with get payload v two with optional types for the blobs?
00:24:34.420 - 00:24:48.676, Speaker E: I think either is fine, but we just have to make a decision because from the execution layer client point of view, they need to know what to implement. We don't want them to spend time working on the separate code, but at the same time no one will use it.
00:24:48.698 - 00:24:49.028, Speaker A: Right.
00:24:49.114 - 00:24:59.370, Speaker E: So I think it's important to come to consensus soon. And I do think maybe on Thursday we can bring this up again to see what people prefer and. Yeah.
00:25:02.220 - 00:25:07.950, Speaker A: Oh prolo, do you want to give your, why do you like develop?
00:25:09.760 - 00:25:57.260, Speaker F: So we split it out to enable people to work on this without having merge conflicts or consistency issues. If the ongoing withdrawals work and the changes to the engine API by just isolating it to a single method, it's really easy to work with. And since we only call this API against one single node, we know the content is consistent. We can expect the blobs to be there after we see the blobs in the block or the payload that we just retrieve with the regular method. So I don't think there are many consistency issues to worry about and we can just use this method long term. A combined method might make sense, but I think it's very like pre major optimization.
00:26:08.350 - 00:26:39.954, Speaker D: So just one small thing. It's very important for execution layer clients, once you call, get payload to stop building new payloads and just cache the one that they have at this specific point. I think it's something that most execution layer clients already do, but it's just something to keep in mind for execution.
00:26:40.002 - 00:27:43.840, Speaker A: Layer devs, I guess. Yeah. Given all the prototypes use this now and it's easier to work on it separately. I would also lean towards just merging it if like client and Mikhail don't see a strong objection and then worst case we can just deprecate it in favor of get payload v two with optional fields once we're ready to integrate stuff together a bit more. Anything else on this? Um, okay, next big spec thing is the rebase on the consensus layer side of Ford four four on top of Capella. I have this on the agenda for the Cl call later this week, but curious if anyone had thoughts about this. Yeah.
00:27:49.070 - 00:28:06.030, Speaker B: I'm in the process on the execution layer side within geth of pulling in the withdrawals pr into our EIP 4844 devnet. I think Jesse is working on the lodestar version of that for the Cl and Mophie on Prism.
00:28:17.250 - 00:28:17.914, Speaker A: Sorry.
00:28:18.052 - 00:28:53.162, Speaker E: Yeah, sorry for interrupting you. I think from our end. So there's two withdrawal pr out there today, I think one from Danny, one from polters. They are essentially changing how the withdrawal works. By basically removing the withdrawal queue. And it's not clear to us whether those will be merged or whether we'll stick with the away. But that actually does dramatically different with the current capella spec today.
00:28:53.162 - 00:29:01.890, Speaker E: So for us, we're waiting until Thursday's consensus layer code to basically, to basically see we can come to consensus.
00:29:03.830 - 00:29:04.290, Speaker A: On.
00:29:04.360 - 00:29:11.010, Speaker E: What the withdrawal mechanism will be before we start putting four, four on top of capella.
00:29:11.370 - 00:29:17.800, Speaker A: Okay. What does it look like in the code right now for you? Is it on top of.
00:29:19.130 - 00:29:39.760, Speaker E: Yeah, right now it's on top of Bellatrix. But since Capella, we're not sure what the final state of withdrawal will look like. We're just waiting until Thursday. But yeah, it kind of sucks because ideally we can rebase today pretty easily, but given that withdrawal is still kind of in the flux. Yeah, we're just waiting on that.
00:29:41.970 - 00:30:09.480, Speaker A: Okay, got it. So I guess I'm not sure we'll be able to close out the withdrawal issue on Thursday, hopefully. But yeah, I think there's a chance we still discuss it for another few weeks. What's the most useful thing for people working on prototypes now if we don't have a clear withdrawal spec on the CL side?
00:30:10.410 - 00:30:28.090, Speaker E: Well, I think we need to know what is the scope for deafnet three? Whether withdraw should be there and if withdraw should be there, it would draw just part of the beacon block and beacon state object or it's withdraw part of the state transition. I think those needs more clarification.
00:30:30.530 - 00:30:32.958, Speaker A: Right, sorry, go ahead.
00:30:33.044 - 00:30:44.454, Speaker B: I was going to say, I thought we decided last week we do want to include at least the block changes for capella withdrawals. I mean, indemnity.
00:30:44.602 - 00:30:48.370, Speaker A: Do those change based on POTUS's pr? Terence?
00:30:49.990 - 00:31:22.320, Speaker E: So those change would matter because in POTUS Pr the beacon state does not have the withdrawal queue anymore versus currently the beacon state has the withdrawal queue. But if it just beacon block itself then it's probably fine. But if the beacon state, it does matter. And then I also assume that you just have a flag that says, hey, we're going to skip withdraw or something. So therefore, basically the withdrawal objects are basically stuff with zeros or something here.
00:31:24.050 - 00:32:14.826, Speaker A: Yeah, my preference would be that we don't want the devnets to be blocked on withdrawals work. That said, if there's a way to make it somewhat like future proof that ideally we sort of stub withdrawals or something so that it just doesn't require a ton of work once we have a withdrawal spec to merge everything over. I don't know, what's the simplest way to accomplish that. But I don't think we should try to test given how unstable the withdrawal spec is right now. I think if we have a clear target for four. Four four, that's somewhat independent, that would be best. But I don't know if there's a way to do that in client teams.
00:32:14.826 - 00:32:18.590, Speaker A: Is that just including the fields but having zeros stubbed?
00:32:20.230 - 00:32:43.278, Speaker E: Yeah, I think for beacon block it's fine. We can include withdraw those in the beacon block. I think those are fairly stable. It's the beacon state I'm worried about. But then it just also kind of weird that you have withdrawing the beacon block but not in the beacon state. I think my preference is for deathnet greed to unblock this. Just go ahead without withdrawal.
00:32:43.278 - 00:32:48.300, Speaker E: That's my personal preference. But yeah, I'm also happy to hear others feedback as well.
00:32:51.950 - 00:33:41.766, Speaker A: Yeah, I think for us it'd be generally better to include the withdrawals consensus types and then stub out the consensus logic. So that means like stub out the block processing and the state processing, but then just keep the fields in the block in the state so they would just remain empty because we'd never apply anything to them. Yeah. So that'd be preferable for us. But it does kind of stink that the withdrawal types might change. But if there's no corresponding state transition block transition logic, then it's relatively easy for us at least to change the. To update the types.
00:33:41.766 - 00:33:47.230, Speaker A: To reflect the type changes. But I don't want to make this too lighthouse centric.
00:33:48.290 - 00:34:00.820, Speaker E: Yeah, we can do that as well. I think you're assuming the latest consensus back which the withdrawal has secure because we actually have that implemented. We're just thinking whether we should remove it or not.
00:34:01.990 - 00:34:29.610, Speaker A: Yeah, our preference would be to keep the capella types even though they are a little less stable. And then just once we have a devnet target, just like we'll freeze that and maybe we'll have to diverge from the withdrawal specs to some extent on the devnets. But yeah, I don't know, maybe we'll have more clarity Thursday.
00:34:30.510 - 00:34:40.240, Speaker B: Yeah, I was going to add, I mean, we have at least a couple more weeks of work of Devnet. Is there a chance stuff will become more clear or. What's the contentious issue here, Tim?
00:34:42.050 - 00:34:54.180, Speaker A: Terrence, I think you could explain it better than me because POTUS wrote it. But just how the withdrawal queue is designed to accommodate partial versus full withdrawals beyond that, I'm not sure.
00:34:54.630 - 00:34:55.234, Speaker D: Right.
00:34:55.352 - 00:35:28.378, Speaker E: So there's basically a trade off right now between in terms of stack simplicity versus Ux. So there's two way to go about it. The first way is just include the withdrawal queue in the state. But with that it's slightly more complicated for the beacon stage. Now you have to implement the queue and then this is also client implementation. Every client implements this differently so people have different preferences. And the other preferred method is just to remove the queue from the beacon state.
00:35:28.378 - 00:35:44.500, Speaker E: But that kind of have a shape here. Ux for live people, they want to do full withdrawal. They have to wait a few more days and that's the trade off. But yeah, I don't want to go on rent here but I think that Thursday meeting we can follow up more on this.
00:35:44.870 - 00:35:53.880, Speaker B: Yeah, I don't have a perspective on them. I'm just curious whether why it would take more than a couple of weeks to figure out this issue. But sounds like.
00:35:54.570 - 00:36:14.714, Speaker A: Yeah, I think a couple of weeks is what I would expect as well. It's just the pr I believe came up late last week. So on Thursday's call we might have a resolution. I think if we don't it would be the call after that. Right. I don't think it would go beyond or even between the two calls. It needs to be galed on the call.
00:36:14.714 - 00:36:23.562, Speaker A: But it's possible that in two days we don't have a resolution. But in two weeks I would be surprised why we wouldn't.
00:36:23.706 - 00:36:30.626, Speaker B: Okay, because I would highly prefer waiting on some stability in the withdrawal spec because we know AIP 44 four won't go out without it.
00:36:30.648 - 00:36:30.882, Speaker A: Right.
00:36:30.936 - 00:36:40.290, Speaker B: So I'm on the strongly preferring we get as much in there for our Devnet three as possible. That'll put us, in my opinion the best shape.
00:36:40.730 - 00:37:44.760, Speaker A: Okay, so we can definitely wait until at least Thursday's call. Yeah, does that make sense, everyone? I had a very rough hack MD with what I think we should aim for in the Devnet. Let me share the link here and I'll share my screen as well. And I'm curious what people think about this. So high level obviously 4844 in and then if this PR has been merged, this is merged. So the fee market pr would be part of the El spec. I don't think we have any other pending prs on the EL that we'd want to include in the Devnet.
00:37:46.960 - 00:37:48.620, Speaker C: What about the modulus Change?
00:37:48.690 - 00:37:57.710, Speaker A: Yeah, I guess. Is that something that we want to try and have in indefinite three?
00:38:00.160 - 00:38:03.120, Speaker B: I think that one minor enough to where we can do it either way.
00:38:03.190 - 00:38:07.436, Speaker A: I don't feel strongly it'd be preferable.
00:38:07.468 - 00:38:10.384, Speaker B: If we could get it in, but it's not.
00:38:10.422 - 00:38:39.432, Speaker A: So I think, yeah, let's try to get it in then, especially if we're waiting. So if we think we can resolve the modulus in the next week or so, and we're waiting on withdrawals on the Cl side as well, I would rather we get it in. Okay. And I think the gas price and the number of blobs we can just leave as is. I don't think we need to change the constants there. Is that reasonable for everyone? Yeah. Okay.
00:38:39.432 - 00:39:00.530, Speaker A: And then eat 68. Do we want to have this as part of the devnet? I guess. Do we need. I'm curious, Maris, is this something you think we need as part of the Devnet or if client teams are going to start working on it anyways, should we just leave this out of scope and if a certain client has it, then great.
00:39:03.620 - 00:39:04.770, Speaker D: Sorry, what?
00:39:05.300 - 00:39:11.824, Speaker A: So for the next 4844 devnet, should we push for an e 68 implementation across all clients?
00:39:11.952 - 00:39:12.630, Speaker D: No.
00:39:13.240 - 00:39:37.070, Speaker A: Okay, and so this means then what I would also exclude is this upcoming pr by Anzgar about not broadcasting the blob transactions. Because if we don't have e 68, we need to broadcast the blob transactions. Um.
00:39:40.420 - 00:40:07.820, Speaker B: Just for the record though, but by the way, I would prefer if this. If basically we only include that into the prospects anyway as a recommendation for client developers. I don't think it should be part of what we technically spec out. Like, it should be part of the issues rationale section, not of the spec section because it's not a consensus change, but it could be overruled if people feel strongly that it should be part of the spectrum.
00:40:07.920 - 00:40:24.190, Speaker D: It kind of will be a consensus change for us. A bigger change than just a spec change because we will drop notes that don't adhere to this.
00:40:29.780 - 00:40:30.144, Speaker B: Right.
00:40:30.182 - 00:40:34.800, Speaker A: But it's still okay because it's a protocol violation.
00:40:35.620 - 00:40:38.032, Speaker E: Yeah, right.
00:40:38.086 - 00:40:46.340, Speaker B: But it's still more like we don't have a eip for. You're not allowed to dos your peer, but you'd still also be dropped.
00:40:50.200 - 00:40:50.516, Speaker A: If.
00:40:50.538 - 00:40:53.190, Speaker D: You dose us right now, we're not going to drop you.
00:40:55.080 - 00:41:01.850, Speaker B: Right. Or like send Malpom. I'm sure there's something peer to peer that I can do to make you drop me.
00:41:03.580 - 00:41:09.070, Speaker D: And there's no send an invalid packet. Right.
00:41:13.200 - 00:41:16.828, Speaker B: Yeah, we can see about it. I wouldn't feel terrible about having.
00:41:16.994 - 00:41:22.370, Speaker A: Okay. But yeah, let's leave all of that out of Devnet three, though.
00:41:24.740 - 00:41:27.490, Speaker C: What's your thinking for leaving that out of Devnet three?
00:41:28.260 - 00:41:38.710, Speaker A: I guess 868 being like having to add all this peer to peer code beyond the core consensus logic, that would be my.
00:41:41.960 - 00:42:02.988, Speaker D: We don't have it implemented yet, not even in gas. We only have the e 68 change, but not the different transaction pool. The only dropping people if they send stuff on broadcast. I would also leave it up.
00:42:03.074 - 00:42:40.080, Speaker A: Yeah, because without it, we can figure out if all the consensus changes work across all of the clients. Right. Then this is this extra step of just the networking across all of them. But if the core consensus logic does not work, that's a deeper problem. Okay. On the el side, anything else that's missing or that we should specifically exclude? I think this generally looks good. Okay, Cl spec a bit more tricky.
00:42:40.080 - 00:43:12.840, Speaker A: So these recent changes probably aren't that recent anymore. I did this last week, but just as a heads up, like, we coupled the blobs to the block for recent history, but I believe we decoupled them for historical sync. We lowered the blob retention period to about two weeks. So this is already merged in the spec, but just wanted to highlight them. I'm not sure what your question is, Alexe.
00:43:17.770 - 00:43:18.790, Speaker G: No, it's.
00:43:26.220 - 00:44:01.990, Speaker A: Okay. In terms of just pending prs. So rebasing on capella. So we said we're going to wait until the withdrawal conversation is resolved. There might not be this pr, but yeah, we'll have to do something along those lines, but not for now. We had this other pr to the update, the interface for KZG. I know we had this on the agenda as well.
00:44:01.990 - 00:44:12.520, Speaker A: George or Denkrat. Do either of you want to give a quick update on where this is at, and if you think we should include this in the next iteration of the Devnet?
00:44:13.580 - 00:45:16.536, Speaker H: So the idea is that in August we made proposed API for the KCG library that clients would interface with. That API was pretty low level, so as to make the C library the CKCG library pretty minimal. But in Bogota, we discussed this with Dankrad and Ramana, who know more about how the KCG library looks like, and they are okay with making the crypto API a bit more high level. So instead of exposing eleven functions, now we expose three high level functions. The nice thing about this is that this is less burden to the client devs, so that they only interface with the high level functions and they don't need to care at all about how the cryptography works. They don't need to do all this hashing fiat Samir stuff. All of this is handled basically by the KCG library.
00:45:16.536 - 00:46:08.300, Speaker H: So I was away, but today I came back and I've been kind of reviewing the PR, the changes since then, and I think I can get it ready today for merging. And Ramana told me that he has made most of the changes on the library side. So we are pretty much kind of ready on this. But depending on when the next definite is, it might be a better idea to keep the old thing going. I don't know. Like if it's in two, three weeks, I guess it's a good time to use the new API. But if it's like this or next week, potentially it's better to use the old API for more stability.
00:46:08.720 - 00:46:29.730, Speaker A: I think it would be more like two weeks because we already discussed we're going to wait for withdrawals on the CL side, which will probably take up to a week or something like that. So I think if this is on the order of two weeks, it probably makes sense to try and go for it and have it as part of spec.
00:46:30.340 - 00:46:39.190, Speaker B: Yeah, I was going to add there's still a good deal of crypto code in the clients that would be nice to move out. Maybe that fits nicely with this work.
00:46:39.660 - 00:47:32.950, Speaker A: And there's crypto code that won't be implemented in the clients. If this change lands are starting now, I won't implement all of the crypto code that will be in these libraries. I would much prefer for it to be in CKZG. Okay, that makes me lean towards let's include this pr as part of our testnet spec if it means that we can simplify a bunch of the next prototypes. And then I guess next week let's make sure to come back to this on the call. And if for whatever reason this is being delayed or whatever, I wouldn't want this to hold up to testnet. But I think if we can have it, then we very much should push for it.
00:47:34.140 - 00:47:53.260, Speaker H: Agreed. I will talk to Ramana, who is not on this call, and ask his opinion about how it's going to be next week. But from what he said, I think it should be okay. Of course, new bindings will need to be written because maybe, I don't know, I need to see the interfaces.
00:47:54.000 - 00:47:56.144, Speaker D: I think some of the bindings are already done.
00:47:56.182 - 00:47:56.528, Speaker A: Basically.
00:47:56.614 - 00:48:15.590, Speaker D: I think he's been following very closely the PR already. Yes. So I think the bindings are already up to the new. I mean there might be minor adjustments to the bindings, but generally we've already adjusted them to the new format and four bytes and everything.
00:48:16.040 - 00:48:22.280, Speaker C: Is there an open branch or something for TKTG that implements the new spec just because.
00:48:22.350 - 00:48:23.930, Speaker D: Yeah, there is.
00:48:26.620 - 00:48:27.370, Speaker A: Yes.
00:48:29.100 - 00:48:34.490, Speaker D: Four, eight four underscore 38.
00:48:40.490 - 00:49:12.280, Speaker A: That's the one. Okay, nice. Okay. And then on the Cl side, we had another open pr that was blocked on this fee market changes. Can we go ahead and merge this prolo?
00:49:17.030 - 00:49:27.402, Speaker F: Once the pr from anscar with the fee market is merged, then yes, this is merged. Yeah, it was like this morning.
00:49:27.536 - 00:49:41.742, Speaker A: Great. Yeah. So it's probably worth just sanity checking that there was no changes in the pr that made that sort of deviate from this.
00:49:41.796 - 00:49:46.366, Speaker F: But, yeah, check if there are any changes there and then this is ready.
00:49:46.548 - 00:51:02.370, Speaker A: Cool. So then this is something we would want in the devnet as well, obviously, because it's like the counterpart on the Cl side to this laylist fee market change. Um, anything else on the Cl side that we would want to specifically include or exclude from devop three? Okay. And then on the engine API, we already discussed this, but basically we would use this blob specific API rather than get payload B two. And then we can try and get this merged today or tomorrow. And then last thing on the Devnet three scope, there's a question by Alexa in the chat about withdrawals on the El side. My feeling is that if we're going to be including them on the CL side, we should also include them on the El side.
00:51:02.370 - 00:52:07.840, Speaker A: But I'm curious what people think about that. Well, so that would affect whether we have withdrawals in the payload attribute struct, which is like Clel API. My preference would be to include that just because we're going to have to eventually include it anyways, but I don't know. So this is basically we include them in the El and also in the engine API. Is that the implication here? So we would include withdrawals in the payload attributes portion of the engine API as well as all the execution payload structs would include withdrawals field as well. So that would obviously impact the execution API or engine API endpoints. Okay.
00:52:07.840 - 00:52:14.880, Speaker A: Does this make sense for everyone?
00:52:18.020 - 00:52:30.580, Speaker E: Makes sense to me. But it's also worth, like, we probably should also ask Taku Nimbus and them as well. Just they are also like big client teams. So I'm curious to hear their thoughts.
00:52:33.740 - 00:52:45.660, Speaker A: I see Ben from Teku here. I don't think there's anyone from Nimbus. Wrong button. You can see me? Yeah. Nothing to add?
00:52:46.670 - 00:52:54.030, Speaker B: I can't speak intelligently to this need Enrico, but he's not available today, so he will catch up later and then feedback.
00:52:55.890 - 00:53:33.020, Speaker A: Yeah. And anyways, I guess we're probably going to be discussing withdrawals and how they relate to Devnet three next week. As well. So yeah, it's worth having teams look into it, but I think we have a bunch of other things that are a bit more settled that we can make progress on until then. And then, Roberto, you had started a GitHub issue, the track sort of status of things on the Devnet. So I guess if people want to share updates there, that's the place to go as they're working on it.
00:53:34.190 - 00:53:41.870, Speaker B: Yeah, it's just meant to be an informal tracker, even though we have a lot more clients starting to be implementing it, hopefully.
00:53:42.690 - 00:54:30.600, Speaker A: Cool. Anything else on Devnet three? Okay. And then we have a few minutes to go, I guess. Yeah. One more thing I wanted to make sure we cover is the CKCG bindings. We said we're planning to have some for go, I guess for Rust and Nim. Do we have a plan to expose things? I was just going to say for Rust.
00:54:30.600 - 00:54:43.244, Speaker A: I think Romana volunteered to help with that, but there hasn't been progress, I think just because the API is still stabilizing. Yeah.
00:54:43.282 - 00:55:01.536, Speaker D: So in terms of the APIs, it's also best if someone from a client who wants to consume it comes forward and then it can be done together. I think Ramana is happy to work that out, but it's hard to just build an API for language that you don't actually use yourself and then you'll.
00:55:01.568 - 00:55:36.610, Speaker A: Probably not build the nicest API for that language. Yes. So Poon is available from our team to work on that, so he's off today. Alexa, you have a comment saying CKZG needs additional discussion? We have a minute to go. Is there something specific you think we need to discuss on this call? What do you think is the most important thing here?
00:55:37.640 - 00:56:36.244, Speaker G: Yeah, it would be cool to have synchronized version between Gokzig and CKZG and all the binance in terms of cryptography output consistency. So we cannot synchronize with go with Geth because we cannot verify blobs because with CKZG we have different outputs, we have different formats in setup, in KZG, setup like that. And it prevents us from finishing the EAP, actually, and, well, it's not yet cross platform, this library CKZG. And we could collaborate on fixing this inconsistency and absence of other platforms than just Linux, I believe so.
00:56:36.282 - 00:56:51.240, Speaker A: I know we have the group chat for CKZG. Is that the place where we should discuss this? Or do you think we need an actual call to go over this in more detail? What do you think is the best way to get this resolved?
00:56:51.740 - 00:57:00.430, Speaker G: Yeah, maybe let's continue to in the chat. I just wanted to raise the problems and find someone to calibrate on this.
00:57:02.080 - 00:57:06.610, Speaker D: So who is currently working on GokZG actually? Is Protolambda working on it?
00:57:07.780 - 00:57:16.940, Speaker F: Yes, I maintain Goka SG. I just need the staple spec or something of the spec implemented.
00:57:17.100 - 00:57:18.384, Speaker D: Yeah, that's what I would suggest.
00:57:18.432 - 00:57:18.692, Speaker A: Right.
00:57:18.746 - 00:57:26.310, Speaker D: So let's wait until we have that and that should be like very soon and then we just implement the same interface for both.
00:57:30.920 - 00:58:20.888, Speaker A: Okay. The only thing we didn't have time to cover on the call was the blob testing. We discussed it last week as well and we have a group chat for that, so I don't think there's much to cover. Last thing before we hop off, there's daylight savings happening in the US and Canada this weekend. Are people okay if we move the call to 1530 UTC rather than 1430 so it'll be an hour for North Americans it would be 1 hour later than it currently is for North American it would be at the same time next week that it currently is for Europeans. I don't know when you all change times. Oh, you already did it.
00:58:20.888 - 00:58:45.456, Speaker A: Okay, yeah, we're on. Is 1 hour later like 1530 UTC? Does anyone have a strong objection to that? It makes life of North Americans slightly more tolerable. I don't know what time that is in Europe though. It'd be 330 in the UK and.
00:58:45.478 - 00:58:47.840, Speaker B: 430 in central Europe.
00:58:49.780 - 00:59:35.740, Speaker A: Okay, that seems reasonable. Shawi Asia Pacific lives matter. Is there a big difference? Lighthouse and tech coating, does 1530 UTC versus 1430 UTC make a big difference in Australia? Well, so I think it's pretty late regardless for. I mean I can represent lighthouse at whatever time. Okay, nice. I assume you were also in Australia. I did not know you had spread to more continents.
00:59:35.740 - 00:59:57.172, Speaker A: Got an american presence now. Okay, that's great. Okay, I'll move it to 1530 UTC then. Yeah, it doesn't seem like there's super strong objections. Sweet. Thanks a lot everyone. Yeah, this is really good and talk to you all on a cl call in two days.
00:59:57.306 - 00:59:59.510, Speaker C: Everyone have a great day.
00:59:59.960 - 01:00:04.000, Speaker A: Bye. Thank you, bye.
