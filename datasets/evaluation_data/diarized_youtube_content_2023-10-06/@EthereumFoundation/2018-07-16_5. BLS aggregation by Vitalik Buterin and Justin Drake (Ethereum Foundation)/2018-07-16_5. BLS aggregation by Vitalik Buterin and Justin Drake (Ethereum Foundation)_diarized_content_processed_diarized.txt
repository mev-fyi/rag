00:00:07.920 - 00:00:48.270, Speaker A: You. Hello, everyone. This is the session where we talk about the elastic. So, let's start off by reaching the point of all this. It's a minute. That makes the theory easy for us to process signatures from many hundreds or potentially thousands of elevators all at once. Which is convenient because it basically means that we massively increase the number of elevators that we can support as part of the access.
00:00:50.320 - 00:00:52.172, Speaker B: Which was responsible for.
00:00:52.306 - 00:02:18.250, Speaker A: Being able to reduce the safety minimum from 1500, along with a whole bunch of other things. Okay, so DLS signatures were invented by elNs. Very surprisingly, they use elastic curve pairings. So they use a very particular kind of elastic curve fairing that requires various creepy black magic to figure out the parameters, or they have no idea how to do it. But fortunately, we have the parameters handed down, handed down from the sky by the crypto gods, and so we can just use them. So, dependent signatures are that, first of all, they are kind of very simple arithmetically. If you can kind of abstract away kind of black box, the admittedly extremely complex components of the units in terms of not just Owen to curve addition multiplication, but also Owen to curve pairings, and we'll see how simple they are later.
00:02:18.250 - 00:03:07.740, Speaker A: So, there's only one signature that can be made with a particular message, and this is important to some application. I'll just give one example. Back in the start of 2014, I was reading through an old version of the NXP protocol specification, and one of the things that they needed is they were doing for a station, they need a random number generator. And the random number generator that they use will set the signature of a block into the random key for the next block. Now, for that to not be totally vulnerable to stake riding, obviously there has to be only one possible signature they could need. Otherwise they could try a bunch of different signatures and choose the one that's correct. So for this port, the problem is for this they use deterministic.
00:03:07.740 - 00:04:23.376, Speaker A: And for anyone who I know might know, one of the problems was basically a protocol for using a particular generating random value in a non part is not verifiable. And so it turns out, and no one would be able to tell that this signature was not deterministic. And so basically this protocol ended up having a horrible. So that's a fun story from 2014. So, pls signatures do not have a slot. They are friendly to aggression signatures, friendly to aggregate signatures broadly to any other schemes. They can be slightly shorter than most occurred signatures.
00:04:23.376 - 00:04:55.160, Speaker A: So either signatures or probably not both, can be a 32 lifelong, or probably 48 lifelong. Any more signatures? Yes. Okay. Next. This is an article I wrote about pairings, if you want to read every night their own time. Next. So this is a logic comparison.
00:04:55.160 - 00:06:05.510, Speaker A: So basically, formally speaking, and a logic curve is a mathematical equation of the form y squared equals x u plus a, x plus b, or a x or conscious. And if you do this over real numbers, it creates a nice 3d curve that kind of looks curving, but it's definitely not on the list. So I know there's some explanation for why the problem looks. And the idea is that you can create this operation that you can define as addition over what's occurred. And the definition of addition is basically that if you have three points on a curve, p, q and r, and those three points happen to also be on the same straight line, then we define that equals t plus r equals zero. And so from this you can define, you can also define the idea that two points are on the same vertical line and then they are zero and zero is. And then from that you can survive what addition is how you can define p, one, two, and this is obviously commutative but really fun fact.
00:06:05.510 - 00:06:25.404, Speaker A: And you can prove this yourself using the addition formula. Or there's some really nice reason for it that I also have no idea what it is. Next, there's one curve. So all of these curves are not.
00:06:25.442 - 00:06:30.412, Speaker B: Done over the real numbers, they're done over a finite field and specifically over.
00:06:30.466 - 00:07:45.270, Speaker A: A numbers module at some prime number if you don't know what module I explained a bunch of times. But basically the idea is that every single number that you're working with, if it's an elliptic curve point, it'll be basically public private key is our value to module n and public user of the curve points. And there's only n of them. And there are tickets on module p, which basically every number, so number that's like seven integers, can be mapped to a public key or a Social Security. And like here in this musical letter e of one, is sometimes referred to as a generator. So you might sometimes refer to that it has these properties that basically equals e of a plus e of b. So basically there's a concept of curve addition kind of maps directly to the concept of.
00:07:45.270 - 00:08:24.668, Speaker A: Basically it has a kind of property with some integer addition. And you have a concept of ellipse curve multiplication, where elliptic curve multiplication is basically just adding a point to itself many times. But there is a more efficient algorithm to do. And you have the linear property again, b of a times a before e of a graphics times k. So you can do addition both in the world of numbers and in the world. And you can multiply those to curve points by numbers and by all. This matches up in the way that you would expect e of n or zero as a point of infinity.
00:08:24.668 - 00:09:11.784, Speaker A: Given k, you can officially compute e of points e of k, but given e of k, you cannot efficiently compute k. And this is kind of a hard to do that problem that everything else here is a recognition. So, this is where life gets more interesting. So, basically, there's another function that sometimes gets called lowercase and lowercase e is a function that takes f input two o's to curve points. And as an output, it gives an element of Mc to the twelve. So it's basically a weird special kind of modular complex. One of them is bilinearity.
00:09:11.784 - 00:09:55.042, Speaker A: So, e of a one plus a two, and b equals a two of b. You'll notice that you are going to plus the times, because additive. But in the world of FP, twelve turns into multiplication. And you can do the same thing on right, the left side or the right side, and same thing for multiplication. So, e of a times a equals to e of a, e to the power of a, obviously e of anything. And the point of infinity is equal to one. So, in the world of multiplication exponents, it's one that's the identity instead of zero.
00:09:55.042 - 00:10:54.774, Speaker A: So that's why zero max to one. Notice that the existence of an elliptical pairing function makes the decisional problem easy, but not be a computational. So, for those familiar with cryptography, basically, if we have four points g g times x g times y and g times x y, can you check if those four points actually have evaluation? And I find it problem, and with a logic, you can do it. But if you don't have g of x y, and you do have g g of x and g of Y, but not x and y, we still have no way of calculating g times x y. Now, it does remain an open question whether or not there even exists a mathematical structure where computational digging is also easy by this reason. And that would actually be really useful for cryptography in a bunch of ways. But as of yet, we don't have that.
00:10:54.774 - 00:11:51.440, Speaker A: But we do have these structures where you can do decisional digital, which is great. So basically, decisional digging is good enough to do general purpose. For general purpose or knowledge proof, you might be able to also make a structure. The left side of Herring and the right side of the herring are in two different elliptic verbs. So, these are often called g one and g two, but g one g two. And these funny modular complex numbers that have e function outputs all have ordered n, which basically means if you take any value in any of these roots and multiply by n, then you get basically equal to zero. So for those who can follow, that basically is kind of up to curves and or super experiences.
00:11:51.440 - 00:12:35.040, Speaker A: So the next question is, I gave the word next basically. Ideals signatures work, right? First of all, messages for a PLS signature. Another important point is that messages need to be hashed into, not like you don't hash messages into 32 bytes. You hash messages into analyst curve point. In this example I have that. But technically you can flip around the world if you want. So basically this requires special hash details about how to do it safely.
00:12:35.040 - 00:13:19.910, Speaker A: You have to hash into a point where nobody knows a message into g two. Your private key is a number, and then your public key is the g. One point that you'll see number and a signature is you basically multiply your privacy by the message. And if you want to verify a signature, well, verification requires an elliptical pairing check. And the pairing check basically is you verify it. That's like e of the public key and the message equals to the pairing of the generator. So ip of one and the signature.
00:13:19.910 - 00:13:47.180, Speaker A: And if you kind of understand the bilinearity property, you can kind of theoretically equation and understand that it makes sense just as a quick poll how many people can. Theoretically, it does make sense that we talk about signature, equation, equation. Okay, that's good. So next. Yes. Now here's the fun part. DlS signatures for aggregation.
00:13:47.180 - 00:14:29.372, Speaker A: How do you aggregate a bunch of signatures? You just add them up. That's literally what it is. You just add up the signatures. How do you aggregate public keys? Why does an aggregate signature correctly with the corresponding aggregated public key? Well, it's basically using plans here at the equation, and makes sense that it's true by linearly. Right? So basically you have a bunch of these equations that are all true. And what you're really doing is you're basically adding up the left side of the equation. So because of the linearity property, basically you have the pairings that correspond to the left side.
00:14:29.372 - 00:15:04.392, Speaker A: Because you're adding up, because you're taking the sum of the keys that are on the left side, it basically becomes the sum of the product of all the pairings on the left side. And then on the right side, you're adding up, you're adding up signatures. And so it also becomes a product. And the product of a bunch of equations that are true is also an equation that's true. So basically, the hearing computation matches out as well. So basically that's all it takes to aggregate. Now there is one challenge which is a rogue key attack.
00:15:04.392 - 00:16:42.260, Speaker A: So basically it's this weird club attack where basically you publish a public key which you don't know the value of, but where you can basically take the keys, the public keys that everyone else submitted, and then from those keys you take the inverts of all those keys and then you add the key that you do know about, and then you can do it where basically you don't know the sequel number that you can use to make signatures for yourself, but you basically set up your public key so that the aggregate public key actually is a public key that you know that you know privacy for. So you can sort of come out early out on behalf of the entire committee. This is very dangerous, obviously. So there's a fix which is basically that there's like five different fixes. And whatever you sign up, you basically require the submitter to prove ownership of the privacy that corresponds to public that they submit, and by using that prove that they're not submitting a row to you. So notice that you can also make an aggregate signature for multiple messages, but this requires basically more pairing computation check. So you have, instead of having just one pairing thing on the left side, what you would do is the expression would be on the left side you would have pairing of one set of keys attached, one message times pairing of another set of keys, another message, another message, hash times pairing another set of keys, another message, hash, and so on and so forth.
00:16:42.260 - 00:17:35.536, Speaker A: So you can basically make one hybrid signature for as many pairings and as many messages as you want. Next. So as far as performance goes, so from a data perspective, the signature size is basically nine, six bytes with ndls, and that's true regardless of the number of participants. Plus you need to have one bit per participant. And the purpose of the one bit is to basically specify whether or not signature. And then if you already know what public key is, then you can basically calculate the aggregate signature and you can verify it. The verification time is one pairing computation, so more precisely, kind of two pairing computations and one pairing finalization from anytime optimization standpoint, but that's always more detailed.
00:17:35.536 - 00:18:18.590, Speaker A: Plus one elliptic curve addition per participant, you have to add off the public keys. To meet the aggregate public keys, we make the aggregate signature. It's only the timer that has to add off the signature, so everyone has to add off the public keys. Fortunately, elliptic permission is like incredibly quick to compute and even 1000 local, so you can totally do all of the permissions. The one detail is that every single public key has to be stored in RAM, basically because obviously you have to look up 5000 public keys and then add them all up. But if you're not.
00:18:47.280 - 00:19:06.716, Speaker C: In terms of performance, the concrete performance, the bottleneck is the pairing. So you have to do about two pairings if you want to have the aggregate internal single message. And each pairing is about 2.5 milliseconds, maybe optimizable to something like one millisecond. So that's the ballpark in Python.
00:19:06.748 - 00:19:11.940, Speaker B: It's 0.4 seconds and with pypy it's zero point 15. But that's because Python is slow.
00:19:18.310 - 00:19:34.502, Speaker A: Do people have questions about caring? I think we're happy to either go through what's about the math, or more application level questions. Can you go back to the slide where you explain how the signature works? Sure.
00:19:34.636 - 00:19:36.470, Speaker B: Can you go back to the signature?
00:19:37.450 - 00:19:39.080, Speaker A: Yeah, that one.
00:20:02.310 - 00:20:09.174, Speaker B: For what it's worth. Like there, the proof of concepts Python implementation that I made basically contains an implementation of all of this.
00:20:09.292 - 00:20:49.970, Speaker D: So if we think about not just the signatures themselves, but the actual mechanics of aggregation, right. You could also think that you don't even have to store all the public keys in RAM, potentially because the signature aggregation is associative and commutative. So what you can actually do is that you can group them up as they get aggregated and actually verify at each point. So I've received two messages which have two different aggregates. I verified them and then I passed them on as another aggregate. And then you just have a very efficient aggregation mechanics.
00:20:51.750 - 00:21:07.420, Speaker E: That would work. Some nodes are going to be missing from these bit fields. You're having to add up things in the bit fields, but yes, so if the bit fields are mostly full or something, then you could imagine it being faster to subtract the nodes that aren't there, stuff like that.
00:21:08.830 - 00:21:10.460, Speaker B: It's a very good point.
00:21:13.710 - 00:21:45.010, Speaker C: I mean, another optimization kind of at the networking layer is instead of having a proposer be in charge of aggregating all the attestations for his own proposal, it could be the next proposer who does that. So you have proposal order various signatures and then the next proposer does the application. So from a networking standpoint, you kind of reduce half a round trip or a round trip.
00:21:47.670 - 00:22:34.520, Speaker B: I think basically that reduces the number of network trips between a block and a successive block for two to one. Now it might make sense to increase the number of network chips somewhat, because once you go into having like 50,000 keys in one message, then you start running into the issue that can one proposer really download and add up 50,000 signatures? And if that becomes an issue, then you can do shorted aggregation. So basically you can imagine a node in a peer to peer network deciding to specialize in, say, some particular chunk of the bit field. And then one participant would say, I aggregate all that they know about, say the first 500. Another would aggregate all they know about the second 500. And then you can have each participant aggregate square root of n instead of n. And that basically gives you all the efficiency you want instead.
00:22:36.090 - 00:22:46.600, Speaker A: So basically the proposal is have the proposer get the signature from each other notary or whatever, and then they aggregate it all themselves.
00:22:48.410 - 00:23:08.930, Speaker B: That's the naive way of doing it. And as the naive way of doing it becomes too inefficient, which would probably could start happening as we move from small sets of validators to the live net with 400,000 or whatever validators total, then it would make sense to add in some kind of this kind of two level sharded aggregation structure.
00:23:10.150 - 00:23:16.980, Speaker A: Can you sort of target someone for, can you target someone for exclusion during this aggregation process?
00:23:17.750 - 00:23:20.260, Speaker B: What you can probably do is.
00:23:22.890 - 00:23:23.254, Speaker A: You.
00:23:23.292 - 00:24:00.320, Speaker B: Can though, if we do this kind of. Okay, so first of all, there's two aspects, right? So in the simplest model, where the proposer has to aggregate all the signatures, then yes, the proposer can exclude whoever they want up to a maximum of whatever the minimum number is that they have to include. But then what we're doing from, and from a fortuous rule standpoint, first of all, you can still count them if you want to, because you can use like ghost. And from an incentivization standpoint, you can have, and from generally, from an accounting standpoint, you can allow any of the messages that were not included to become included in the next block. Okay, yeah.
00:24:02.290 - 00:24:11.698, Speaker D: Britannic, you said that the parameters of the curve were not found, but somehow the cryptogods have given them. So what did you really mean, seriously?
00:24:11.874 - 00:24:30.586, Speaker B: Basically the idea is that actually generating these curves that have this specific setup that they are pairing compatible, they require very specific properties of how the numbers work. And even something like calculating how many points there are in a curve like this requires extremely advanced algorithms that are.
00:24:30.688 - 00:24:31.898, Speaker D: Can we do it?
00:24:32.064 - 00:24:35.950, Speaker B: Fortunately, we don't have to, because we can just use the BLS twelve, 381 parameters.
00:24:37.570 - 00:24:38.718, Speaker D: They already did it.
00:24:38.804 - 00:24:40.400, Speaker B: Yeah, they already did it.
00:24:41.090 - 00:24:54.094, Speaker D: And the second question is that maybe I've missed it, but do we already have that hash function as well? Okay, sorry, back the hash function, which maps into a group back one.
00:24:54.212 - 00:24:54.734, Speaker B: Yes.
00:24:54.852 - 00:24:57.790, Speaker D: Okay, we have that as well. Yes, totally implementable.
00:24:57.870 - 00:25:18.090, Speaker B: Yes, totally implementable. No, for the hash function, I already did it. And Dan Bonet gave the green light to the approach, which is you basically hash into the x coordinate, and then you derive the y coordinate from the x coordinate, so that way you generate a point that you don't know the corresponding discrete log for. That's basically the one thing that matters.
00:25:21.790 - 00:26:00.994, Speaker C: I mean, it's quite old crypto, and other than the new curve, which is quite recent, but it has been audited. Another good thing is that there's a bunch of other projects in the blockchain space who are starting to use BLS. So definity. I learned about Polkadot today. There's Chia. And just in general, it seems that there's more awareness around this, and I think even bitcoin is considering BLS signatures as an alternative to snorl, maybe. Is this a signature scheme you're considering to be like the kind of enshrined.
00:26:01.042 - 00:26:06.650, Speaker A: Base signature scheme for the transactions and execution layer?
00:26:07.710 - 00:26:14.250, Speaker B: So my personal answer is that I prefer the execution layer to have nothing enshrined and to just be a computation framework.
00:26:15.730 - 00:26:20.110, Speaker C: Yeah. So signature abstraction, account abstraction in the shot.
00:26:32.630 - 00:26:44.760, Speaker E: Is the curve part of any official standard, like, I don't know, NIST or ISO or anything? Because otherwise it might come with funky export restrictions or problems on Apple devices and things like this.
00:26:47.930 - 00:27:16.090, Speaker C: I believe the only project that is intending to use it, and is not even using it right now is zcash. I mean, it is part of a family of curves. But yeah, they have an implementation in rust which they've also audited. So they've audited the implementation and the curve separately. And the number is 2.5 milliseconds. That's from this specific rust implementation.
00:27:16.090 - 00:27:38.990, Speaker C: And I believe, believe Sean Bowie, who was leading that effort, spent a long time, maybe two years, writing this library, the specific curve. Also chia network intends to use it.
