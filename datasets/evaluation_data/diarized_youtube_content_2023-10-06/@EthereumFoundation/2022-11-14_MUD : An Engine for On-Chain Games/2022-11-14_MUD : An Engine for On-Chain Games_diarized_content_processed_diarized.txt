00:00:12.810 - 00:00:56.350, Speaker A: Good morning everybody. My name is Justin and along with Alvarius and our friend Kelvin from Optimism, we're going to go over new technologies for on chain gaming. So Alvarius and I work on Latis, among with many others. It's a project that's been out of Xeroxpark in order to push the envelope of on chain gaming. We basically want to enable people to build crazy things on top of Ethereum and things like full on virtual worlds, worlds whose rules run on the EVM and whose state is secured by Ethereum. People usually refer to those projects as on chain games, but we prefer to call them Autonomous Worlds because we think it goes well beyond gaming. It's about giving autonomy and sovereignty to complex systems.
00:00:56.350 - 00:01:11.140, Speaker A: So the problem is building large on chain projects is actually really hard, which is why today we're going to go over two new key pieces of technologies built by Latice and Optimism in order to enable autonomous worlds. And I'm going to pass it to Alvarius to go over the first one.
00:01:12.390 - 00:01:44.910, Speaker B: Cool. So the first key piece of technology that we want to introduce today is Mut. Mutt is an on chain game engine, or how we'd like to call it an engine for autonomous worlds that we develop here at Lattice. And when we started working on on chain games, there was no engine to build upon. So we had to run through all of these very common, very general problems, very non trivial problems as well. But they were common in all the games we were building. So we set out to build this key missing piece of infrastructure and build Mud with the goal of solving all the hard problems of building onchain games.
00:01:44.910 - 00:02:37.690, Speaker B: So what are the hard problems of building on chain games? Well, they fall into mainly three categories. The first one is how to make sure that your client and your contract state are always in sync. Then the next one is how to architect your game in a way that makes it easy to add more content later without having to refactor the entire code base. And then the third thing, if you care about impact beyond just an individual game, then how do you make sure that your game is interoperable with all the other games out there? So, before I go into how Mud solves all of these problems, let me quickly go over the previous common approach of approaching these challenges. Usually the most common approach before was you have one struct per entity type on your contract. Like, if you want to have a monster, then you have a monster struct. And in that struct, you store all the data for that entity.
00:02:37.690 - 00:03:46.900, Speaker B: And then of course, on the client, you have to replicate that interface in order to represent the state there. And then you have getter functions for each individual type of entity that you want to sync to your client and you implement your logic based on these specific structs. And every time you modify one of these data structures, you have to emit a custom event that then can be caught by the client to then update the local client state. And this sounds already pretty annoying, but it gets even more annoying when you want to now add content because now you have to add a new struct and you basically have to edit your entire network stack in order to make it compatible with this new struct. From the event over the getter functions to the event handling on the client, you have to modify everything. And then on the interoperability side, basically all you have are existing interfaces like ERC 20, ERC 721, et cetera, which were not built for onchain games and are very limited in what they can express. Right? So our goal with Mud is to solve all of these general problems so that you, as game developers, on chain game developers, can just focus on making a fun game.
00:03:46.900 - 00:04:13.550, Speaker B: All right, so this is for the why. Now let's go into the how. How does Mud solve these problems? Mud is built around an architecture pattern called entity component system. This is a very popular pattern in the traditional gaming industry for a reason. But if you're not familiar with it, I'm going to give you a brief crash course on ECS. In ECS, an entity is just a numeric ID. So in our case, it's just a UN two, five, six.
00:04:13.550 - 00:04:37.502, Speaker B: And then you have components. You have components that store the data for this entity. So in our case, we could have a component that stores the data. You can think of it as a mapping from the entity ID to the component value. You can think of it as a fancy standard Ethereum mapping. And then you have the systems which implement the logic. So components are only data.
00:04:37.502 - 00:05:30.840, Speaker B: Systems implement the logic and systems don't act on specific entity types because there are no specific entity types in ECS. But rather, an entity is just the collection of components that are attached to it, basically. And so your move system, as an example, doesn't care about whether it's moving a donkey or a dog. It only cares about whether this entity that it is moving has a position component attached to it, and then it can modify that position component. And if you think about it, that's actually, in a way, how Ethereum already works today. You can think of addresses as entities and then a token contract, like a ERC 721 token contract, can be thought of as a component and a system mixed together and attached to this entity to this address. If you wanted to model this in like pure ECS, then you would just have a balance component that stores the data and then a transfer system that implements the logic of transferring stuff.
00:05:30.840 - 00:06:19.350, Speaker B: All right, so with ECS in mind, how does Matt handle the state sync in Mud there is a very central contract, the World Contract. And every time you add a component, which is also a contract, it gets registered on the World Contract. And then every time that component gets updated, an event is emitted automatically through the World Contract. That means the client only has to listen to this one central stream of events coming from the World Contract and can then keep the local state in sync, basically. And the great thing is, with Mud, you don't have to worry about any of that because Mud handles all of that for you. What you have to do as a game developer is just create a component contract, give it some ID, and then create a component on the client and give it the same ID. And Mud handles the state sync automatically.
00:06:19.350 - 00:07:04.014, Speaker B: And the great thing with this general approach is also that we can provide generic indexes that help your client catch up faster and reduce their RPC load. And you don't have to write any custom subgraphs because all the data is stored in a very generic way, and that's why we can have indexes. Cool. Now to the fun part of adding content. As a quick reminder, in ECS, entities are just a collection of components. So our fighter entity here is actually just a collection of a health component, an attack component and a movable component. And now if we want to add more entities or stronger entities like a Dragon, then we can just modify those component values, give it more health, give it more attack, and suddenly we have a Dragon.
00:07:04.014 - 00:07:33.050, Speaker B: Another way to add more content is to modify or like recombine existing components together. For example, remove the movable component and suddenly you have a defense tower. And the last way of adding content is adding new components. Every time you add a new component, the number of possibilities of combining your components actually doubles. So you can just recombine your components in a new way. You have double the amount of entities you can now represent. As an example, you add a healing component.
00:07:33.050 - 00:08:10.460, Speaker B: Now you can build a healing shrine, a healer and a healing potion without changing any of the existing logic. And then when it comes to Interoperability, in theory, everything that you build on Chain is interoperable to everything else already. You just have to make like a custom integration for everything, which gets obviously kind of annoying and is not scalable. So, in other words, interoperability needs interfaces to scale. And you can think of Mud as an interface for those on Chain worlds. You can read the state from your own world in the exact same way as you can read the state from other worlds. So all those worlds are just by default interoperable with each other.
00:08:10.460 - 00:08:50.674, Speaker B: And you can think of existing interfaces like ERC 721 as an interface for ownership. But Mud, on the other hand, since every component is a standardized way of storing the data, and we have the standardized query system. Basically, Mud is an interface for anything. Like, you can just write a query for any world out there and just represent whatever you want. Basically, this query, this very simple query, gives you all the Movable attack entities owned by this address, but you can get Arbitrarily complex with that. So this is how Mud solves all the problems for building onchain games. But the great thing for Mud is that it's actually completely genre agnostic.
00:08:50.674 - 00:09:27.838, Speaker B: We built two different games in house at Latice over the last couple of weeks, two completely different genres. The first one is called Skystripe, and it's an on chain RTS. The goal is to build your army to defeat your opponents and then steal the loot from the center of the island and then escape with the loot as the first person. It uses 39 components, 20 systems, and not a single line of networking code, because Mud handles all of that for you. And we're actually going to play tonight or not tonight, this afternoon at the Hacker Basement at 04:00 p.m.. So if you want to check it out, come there. And then the other game we've built is yet to be announced.
00:09:27.838 - 00:09:49.960, Speaker B: It's an onchain Voxel game. It features an infinitely procedurally generated world. You can mine, you can build stuff, you can craft stuff. And it only has eight components and seven systems. And also here, zero networking code. And those two games are completely different genres, but they build on the exact same infrastructure. They just use different components and combine them in a different way.
00:09:49.960 - 00:10:11.040, Speaker B: Yeah. And this is Mutt as a summary, with Mud, you don't have to write a single line of networking code because Mud handles all of that for you. Adding content is completely trivial. Adding a new component doubles the amount of entities, the types of entities you can represent. And any Mud world is by default interoperable with any other Mud world. And that is how we solve all the problems.
00:10:15.670 - 00:10:58.910, Speaker A: Cool. All right, I'm going to drop some more crazy stuff. Full nodes are great. So after this short introduction to Mud, I want to go over two kind of advanced features mental model from what Mud is. So the interesting thing with full nodes is that they give you access to the entire chain directly from the node database. With a node, you can do things like, oh, what is the counterfactual of this? Can I execute a transaction, but slightly change the storage of that contract? Like, what would happen if I were to make a transaction on uniswap and I have a billion die instead of, like, ten? The problem is that traditional DAP clients today are not full nodes. They rely on things like inferra or alchemy to serve their data.
00:10:58.910 - 00:11:35.846, Speaker A: And then they have to build this complex state machine of indexers and events in order to serve the data they need to their users. As an example, the uniswap client has to connect to a full node and it has to fetch the state it is interested in just in time, because otherwise it would take way too long. So as you move around on uniswap and you select different pools, you have to wait every single time to know what's going on. I don't know if you've ever read the uniswap client code, but it's pretty insane just to be able to keep such a short like a simple state machine in sync. And there needs to be a lot of custom code and indexers. Additionally, the uniswap client cannot actually simulate transactions. It doesn't know what will happen if you execute that single swap.
00:11:35.846 - 00:12:11.586, Speaker A: So the way it actually works is you have the uniswap client and then remotely you have a full node and you have a bunch of indexers. And the uniswap client has to make very slow network requests in order to be able to populate the information that the user needs. So why don't we put the full node and indexer inside the client, right? That would allow you to make instant queries. You would be able to index the chain however you want. You don't have network delays anymore after you're synced and then you can simulate transactions, right? That would be amazing. And actually for the Ethereum OGS here, that's how Mist was working, which was the Ethereum browser like five years ago. But the thing is, full nodes are super expensive.
00:12:11.586 - 00:13:21.546, Speaker A: They require a lot of bandwidth and storage, they have very expensive cryptographic data structures that are needed in order to serve Light clients. So it's pretty much like it's not really practical today to put full nodes in the clients. And so because of that, most DApps today, like if you use DeFi or whatever kind of stuff, usually the UX hurting network calls, you have to wait a lot for every single thing. You have to wait for the TX to be mined in order to know what the side effects of what you have done actually is. There are services today, like tenderly and stuff that allow you to simulate transactions, but they add additional complexity to the code base and more often than not they need to use remote indexers which add yet another surface of things that can possibly go down in complexity. So can we do better now that we have slightly better infrastructure than when web3 JS and Ethers JS was invented? Is there a way to essentially have archaic and eat it too? The one interesting fact about autonomous words or on chain game is that they're more often than not standalone, unlike traditional DApps. What that means is that the state transition function of an autonomous word almost always only depend on its own state.
00:13:21.546 - 00:14:11.126, Speaker A: So as an example, when Darkfrest was running on XDI, darkfrest could have run on a chain with nothing else but Dark Forest. Dark Forest didn't care about the other things on XDI, right, that's unlike most DApps today, which rely heavily on like a plethora of different services on chain that they connect to things like Oracles, things like ERC 20 contracts and so forth. And again, this is unlike as an example, uniswap, where if you were to want to simulate the transactions of like a uniswap trade, you would need to know about the other smart contracts, like the ERC 20s on each side of the pool, because they could be implemented slightly differently. So one mantle model for what Mud is is that it's a namespaced full node. Which is why we think this goes like, well beyond gaming. It's a way to build actually, like, better clients than what exists today. And the reason we can build a namespace full node is because, as I said earlier, autonomous words are mostly standalone.
00:14:11.126 - 00:14:55.450, Speaker A: So Mud syncs a World, the word contract that Alvarez talked about, it's a namespace for data and logic. So data are components and logic are systems. So Mud can sync the data of every single component connected to every single entity and download the EVM bytecode of every single system. And the way it does it is it does its initial sync via a general Mud indexer or a full node, and it keeps its state up to date via a full node or a Mud stream service. Mud doesn't need the cryptographic data structures that are usually in a full node because we don't want to serve light clients, we just trust a node remotely. But what we want to be able to do is build extremely snappy applications by having the entire state in logic client side. So the thing that is interesting with Mod is that components are self descriptive.
00:14:55.450 - 00:15:27.154, Speaker A: Components have on chain schema that explains how to interpret their actual row bytes. And so the Mud client can read their onchain schema. And so compare that to a full node. With a full node, you know the actual storage slots of every single contracts, but then you just have like 256 bits of like you don't know what that is. This is why people write view functions in their contracts in order to be able to load actually contextual data from those applications. With Mud, what you get is a key value database of entities mapping to a bunch of components. And it doesn't matter who deployed those components, the client just knows what they are.
00:15:27.154 - 00:16:02.046, Speaker A: It knows what their name is, it knows what their structure is. So as an example, when you think like a Mud full node, so a Mud client, you would know that the first entity has position 1245 and health 200. So it's way more contextual than the way full nodes are done today. It's because Ethereum is trying to be as general as possible, whereas here we impose constraints in order to get features. This allows a client to run complex queries on components without any network delay. So you can run aggregated queries like oh, give me all the entities that have a position and a health with value ten. You can do crazier stuff like aggregates and stuff like that.
00:16:02.046 - 00:16:38.074, Speaker A: But all of these are executed instantly in like one millisecond on the actual state. So if you were to rebuild Uniswap with Mud today, or at least the Uniswap client, you would be able to move around and do things without any network delay. When it's synced and downloading, the actual Snit snapshot usually takes like less than a second. So the other thing that is pretty interesting with Mud is that it ships with a local EVM. So when you make a transaction in Mud, that is, when you call a system, what Mud does is it runs an EVM on that system given it knows its bytecode and it injects the ECS state. When that actual EVM bytecode needs to write, the state needs to read the state. It registers all the side effects that happen.
00:16:38.074 - 00:17:24.570, Speaker A: So as an example, if you were to call the move system on entity one and you say move to x ten y minus three, mud can run that into an EVM and know that the side effect is that like oh no, the position component of entity zero one is ten minus three. It also sends the transaction on chain, of course. And then when the transaction has been mined on chain it compares the side effects that happen on chain with the one that were predicted. If they match, nothing happened. And so from the user's perspective, it seems like the transaction was essentially executed instantly, which gives way better UX and when it's not the case when the prediction fails. So as an example, if someone else kind of like clashed with our state by having their transaction execute before ours, or if we were behind the tip of the chain, we just revert the side effects and apply the actual ones. But that happens quite rarely actually.
00:17:24.570 - 00:18:00.226, Speaker A: This is how modern MMOs work. They do prediction and rollbacks all the time. So yeah, with mod you can essentially read and index components without network delay, client side, and you can also simulate transactions without waiting. And we think that sorry, we think that this actual increase in user experience is pretty insane. We've seen it for games because that's what we were trying to do. But I can't wait for someone to build a DeFi protocol on Mud and make it like the Snappiest swapping protocol ever. Another thing I'd like to talk about is this concept of extending words with Mud.
00:18:00.226 - 00:18:35.342, Speaker A: So today with fully on chain permissionless app things like Uniswap or Darkfrest, developers can extend the protocol via new contracts and custom client. Right. That's the power of those applications. So as an example, in Uniswap you can build an LP kind of like liquidity mining program on top of Uniswap permissionlessly. You don't have to phone the Uniswap company in new York to ask if you can do that. Similarly with Dark Forest, you can create smart contract players or new features. However, the problem is that developers that do that, they need to ship new clients and indexers when they do that.
00:18:35.342 - 00:19:16.798, Speaker A: So as an example, if you want to build a yield aggregator sorry, not a yield aggregator, a swapping kind of like aggregator that finds the best prices. Well, you need to build one inch, you need to build a new client. Also users need to know where those new features are. They have no idea that someone out there built new contracts and new features for that specific DApp. And that actually creates a clear distinction between first party code and third party code, which in our opinion greatly hurt interoperability and creativity. So as an example, in Dark Forest you can do something like hey, I'm Team XYZ and I'm going to deploy a thing that marks some planets as rewarding and if players captures them, they get some ETH. That's pretty cool, you can do that.
00:19:16.798 - 00:19:57.670, Speaker A: But now how do users know that this exists, right? Where are the contracts? Even if you had that information in your client, how does your client know what to do with that data? Does it render a button? Does it trigger a shader? Similarly, you probably have to rebuild all your indexers from scratch. So you get a fragmentation essentially between first party code and third party code. So again, can we do better? In Mud, the central contract is the word contract. If you know the address of the word contract, you know everything. You know about all the components, you know about all the systems, you know about all the entities. And the thing that is interesting with the word contract is that it actually has no owner. If you deploy yeah, so it has no owner, it's permissionless.
00:19:57.670 - 00:20:24.580, Speaker A: And so that means there is no difference between first party code and third party code anymore. Everybody is first party. So the creators of the word contract, the deployers of that contract, actually have no special kind of access to it. They're not privileged in any mean. The world contract is non upgradable. So the rule is anyone can create components and systems. So when Alvarez was talking earlier about the health component and position component and the move system, anyone can register those components and those systems on the world itself.
00:20:24.580 - 00:21:09.486, Speaker A: And when you do that, when you create new components, that is like new data or new systems, that is new logic, they're accessible in the client, they're indexed, they can be found in a debugger and they can be executed in local EVM. And there's actually no difference between what the core team deployed and what any other people did deploy as well. So the rule is that all systems can read from any component and those components can be deployed by different teams. So as an example, you could write a system that runs a query on the world that queries a component deployed by Team XYZ and a component deployed by Team TTT. And they can actually aggregate those data together. The only rule is that components have to whitelist which systems can write to their state. And that's really important because otherwise an attacker could deploy a system that just resets everybody's inventories.
00:21:09.486 - 00:22:01.886, Speaker A: So the way it looks like is you have this graph of components and systems that kind of like trust each other, but also you have this interesting social phenomena where users of those applications decide what is real. So if you have two position components that don't match with each other, the users have to decide, okay, do we believe in position one or in position two? And that's already what happens today on Ethereum. If I deploy a new Dai contract, my Dai is worthless. So it's all based on essentially what you think is real, but it is made in like Mud is architected in such a way that you never have the problem where you need to create some form of like, oh, we need to give or upgrade keys to a dow in order to let our players upgrade this. No, this can emerge naturally, essentially, from the web of trust of the players themselves. And this leads us into an interesting kind of idea of augmented reality. So this is not the augmented reality, you know, with fancy glasses and hardware.
00:22:01.886 - 00:22:36.298, Speaker A: It's more about layering base rules with new interpretations. So beyond the core components and systems all players believe in, probably the ones that have been deployed by the core team, the low level physics, it is possible for anyone to create augmented reality layers that only a subset of players engage in. And that permissionlessly. So we're going to illustrate this. Imagine a game, very simple game. It was deployed by one core team. It has three components position, Movable, and resource.
00:22:36.298 - 00:22:50.126, Speaker A: It has three systems. You can move, you can pick up a resource or you can drop it. And you can see there are three players. There 70 x five. There are little characters riding horses, and you have a bunch of resources on the floor. What players do is they can ferry resources around. This game doesn't actually have any goal.
00:22:50.126 - 00:23:19.180, Speaker A: It's just some rules of physics, essentially. And like, as an example, I can call move on my player and I would move my horse from one place to another. Now Team TTT, Team TicTacToe comes in and they deploy two new components on the world because they can, they don't have to ask anyone. Those two components are the stake component and the board component. And they add three systems challenge, accept, challenge and resolve. Now, all clients are aware of those new components and systems. They just don't know what to do with it yet.
00:23:19.180 - 00:23:55.014, Speaker A: If you open your game at that time, you'll see a little install box. It's like, hey, there is some piece of JavaScript that is linked with those components and systems. Do you want to use them? If you do now you can play a radically different game while still being compatible with the low level rules. So as an example, I can take my player, I can move to the gold at three, I can pick it up, move again, and I can come next to that player at seven and call the challenge system on that player. That challenge system is new. It was deployed by the team TicTacToe, and I attach one ETH to my transaction. The other player, if they're aware of that augmented reality layer, can accept the challenge stake the same amount.
00:23:55.014 - 00:24:28.846, Speaker A: And now this new system is going to create a new entity, nine, because anyone can create entities and attach the stake component and the board component to it. So now for the players that have the actual code that allows them to experience the TicTacToe augmented reality, they can see a board on the floor and they can play TicTacToe. They can drop the resources in order to play TicTacToe and someone can win. They can call the resolve system and they can take the stick and destroy that entity. And you can do that without clashing with the rules that all other players believe in. So TicTacTo is just like tennis. Like tennis is an augmented reality layer.
00:24:28.846 - 00:25:00.150, Speaker A: On top of our physics. I can drive in my car and look at tennis players and we're not breaching the rules. Like, we're all living according to the same rules, but we're just like experiencing the world in different ways. So it's an augmented reality and from the perspective of other players, they're just like, what the hell is going on? Why are people dropping resources on the floor, on the grid, but they can still coexist together? So there are a lot of augmented reality out there. The main one is capitalism. It was made up. We all wear the glasses that allows us to see capitalism.
00:25:00.150 - 00:25:32.322, Speaker A: But I can interact with an anarchist that doesn't believe in money. I can go and have dinner with them and we won't actually experience the same augmented reality, but we share the same low level rules. Competition is also an augmented reality. The thing that is interesting with this game is that it has no goal. Some people just made a set of interesting rules and resources, but now anyone can come in and essentially puts a competitive layer on top of it. Minigames are also augmented reality. So for the people here that have played Minecraft in Minecraft servers, a lot of people build minigames.
00:25:32.322 - 00:25:57.920, Speaker A: You have to break the rule underneath people's feet and fall into lava. Those minigames actually don't clash with the rules of Minecraft. They're just like new systems that have been created on top. And you can do that permissionlessly. You don't need a governance for the world because the world is onerous. Anyone can deploy new components and systems, and players believe in whatever components and system they care about. And now I'm going to pass it to our friend Kelvin, who is going to drop some more cool stuff.
00:26:00.290 - 00:26:29.190, Speaker C: So you want to build an autonomous world? Good luck. Good luck. Have fun trying. Just kidding, of course. I'm going to be talking to you today about the Op stack. Technically, we were originally hoping that this talk would be after the other talk about the Op stack. So just pretend that you're 5 hours in the future, you've watched the other talk and whatever time doesn't matter anymore.
00:26:29.190 - 00:26:57.534, Speaker C: So introducing the Op Stack, except Carl has already done it 5 hours from now, kinda. We still need to write all the docs. So if you want to use this, you're going to have to dig deep a little bit. You can talk to me afterwards about how you can actually achieve this, but all right, introducing the Op Stack. I want to talk to you a little bit about basically how you can achieve this. Build your own system today and get really good security guarantees at the same time. All right, so boom.
00:26:57.534 - 00:27:56.354, Speaker C: What is the op stack? Essentially, the Op Stack is rollups gone modular. Over the last year, we've been designing and building this thing called bedrock, which is the next major upgrade to optimism. And while we were doing that, I think we realized that the key part of building a solid roll up client was to make it as modular as you can possibly make, sort of. We'll talk about this a lot in the talk later today, the back to back talk that I have with Carl. But we kind of realized at a certain point that if you really want to maintain one of these things, you can't allow different parts of the system to bleed complexity into other parts of the system. And the classic example that we saw over the last two years was we separated execution from proving this was the big thing. This is what basically optimism's, EVM, equivalents upgrade, arbitram's, nitro upgrade, they all followed the same pattern, which is let's build the client the way that we want to build the client and then let's make execution work on top.
00:27:56.354 - 00:28:25.434, Speaker C: So the end result of all of this over all this time is that we've broken up our system into a highly modular system with lots of different pieces. We think that there's three simple layers that kind of follow what you think, oh, there we go. Look, you've seen these things before. Consensus, execution, settlement. You've seen these things before. If you've heard anything about modular blockchains, you kind of have an idea of what the Op stack is all about. Except the Op Stack is putting this modular theory into practice.
00:28:25.434 - 00:29:11.830, Speaker C: So the real difference here is it's not just charts on a blog post about, okay, if you plugged in this data availability layer you'd get this behavior. And if you plugged in this Data Availability layer, you'd get this other behavior instead. It's actually concrete components that you can implement and you can switch out to get the behavior that you want. So I'm going to talk to you about the core concepts, the different components that you can switch out and sort of what you might do if you wanted to build a game to use these different components and do something really interesting. So the first layer that we like to break out of these different there's obviously the three primary layers inside of consensus, we think of two sub layers. Quickly here we've got what we call Data Availability and Derivation. But I'll start with data availability.
00:29:11.830 - 00:29:41.154, Speaker C: So you've probably heard about this. You probably have a basic idea of how this works. Data Availability is where you publish your data, right? So the idea is, well, people don't always want to publish their data to Ethereum. All the roll ups originally were built under the idea that, okay, we're always going to publish our data to Ethereum, so let's just build our architecture under that assumption. And so the stack basically says, well, actually, whatever. As long as you kind of have an array of blobs, that's what we call them. They can be blocks if you're Ethereum.
00:29:41.154 - 00:30:04.170, Speaker C: They can be blocks if you're Celestia. They can be all sorts of different things. But essentially what you want is an array of things where you can publish data to. And ideally, you have some properties about this data availability layer. Ideally, it's somewhat immutable. Otherwise, the whole thing is just going to keep reorgang itself and that's going to be really annoying. Ideally, the data is actually available.
00:30:04.170 - 00:30:46.294, Speaker C: Otherwise you can't do anything with it. So there's some properties that you want about this. But the nice thing is the Opie stack basically says, well, whatever. You can define any Data Availability layer as long as it fits this basic idea that it's an array of byte strings, you can slot it in as your Data Availability layer. So, concretely, what can you do with this? I think the easy example is instead of putting all your data onto Ethereum, you can use something like a Data Availability Committee instead. Reduce your costs, make your system cheaper. I think this is a really good application for gaming because basically you don't need those sort of ridiculously high security guarantees that you do when you have a basic roll up where you're just putting data on Ethereum.
00:30:46.294 - 00:31:36.460, Speaker C: The ability to switch this out for a Data Availability Committee or a different Data Availability layer altogether is really important to get the exact sort of security properties that you want depending on the amount of value that you actually need to secure. All right, derivation. Derivation is interesting. I think derivation is one of the coolest parts of the Op stack design. And essentially the idea is that derivation is how you are pulling inputs for your blockchain from the data availability layer. So derivation is basically like a function that's aware of the structure of the data availability layer. Let's say we're putting data on Ethereum, it's aware of the block structure, it's aware of how data is put onto Ethereum and it parses that data, it pulls it out and it turns it into inputs to your L2 execution engine.
00:31:36.460 - 00:32:29.146, Speaker C: Derivation is really important and generically, you can understand why this is important. Let's say we're a roll up. The same thing that we're doing for Unannounced game will be announced soon. If you're one of these systems, what you do generically is you post data to an address on layer one and maybe you have deposits and maybe you have some other sort of information and you transform all of that. Maybe if it's data posted to layer one by the sequencer, let's say you decompress all of that data, you transform it into inputs on L2, and then you're going to execute those inputs. Derivation is really interesting and I think there's a lot of hidden things that you can do inside of here that maybe aren't always obvious. One of the things that I think people can achieve with this is have in game events or have events on your chain happen when things happen on the layer one.
00:32:29.146 - 00:33:06.786, Speaker C: So let's say you want to have an in game event happen every time there's a uniswap swap event on layer one over a certain value. What you can literally do is in your derivation function, you can take our derivation function, you could tweak it slightly and you can say, okay, I'm also going to look for uniswap swap events. And then whenever there's a uniswap swap event, I'm going to generate a transaction on L2 that makes this thing happen. And the end result is that in my game, fireworks go off. Whatever you want, you can basically modify this however you want to have the state of your layer one define what's going on on your L2. It doesn't just have to be transactions. You can build amazing things with this and it can be very, very stateful.
00:33:06.786 - 00:33:44.900, Speaker C: So you can do a lot of cool stuff here. Boom. Execution. Okay, execution is probably what you think execution is. It's your execution engine on L2. It's your state transition function. It's the thing that takes the inputs that were generated by the derivation layer and it takes the current state and it's going to translate that state into a new state, right? It's going to take that state to a new state and that state is going to be used to drive new inputs and it's going to be you get it right? Every time I make a transaction and something happens in my Voxel game and the world updates, that's what's happening under the hood in the execution engine.
00:33:44.900 - 00:34:32.494, Speaker C: The execution engine in the Op stack lives behind the engine API, right? So what we decided to do was Ethereum, while it was going to the merge, needed consensus clients and it needed execution clients, right? So you need a way to talk between the consensus client and the execution client. And that interface between the two clients is the Engine API. So what we did was basically take the same API and you stick the data availability and the derivation thing, and you separate that from execution by that same exact API. So it looks exactly like Ethereum looks. The nice thing about this is that you can plug in absolutely anything in here. It doesn't have to be the EVM. You can take the EVM and maybe you can make some easy tweaks.
00:34:32.494 - 00:34:55.850, Speaker C: You can add a new pre compile. You can tweak a few opcodes if you really want, and that'll just work really easily in Optimism in Bedrock, we add a new transaction type. We add this deposit transaction type. That's really easy, but it really can be whatever you want. It could be bitcoin. It could be a Game Boy. As long as you have a state transition function and you wrap it inside of the engine API, you can do whatever you want.
00:34:55.850 - 00:35:28.578, Speaker C: And it should just work. The whole thing should just work. So if you want to build a game and you want to use the EVM and you want to add a new pre compile because you have some complicated game state function that's just too expensive to run inside solidity, then just modify the EVM. If you want to run a totally different execution client altogether, you can also do that. And it just sits behind the same API and all the rest of the stack, all the roll up stuff, all the transaction stuff, it just keeps working as if you didn't do anything at all. All right. And then finally settlement.
00:35:28.578 - 00:36:13.774, Speaker C: Settlement is this weird one. It's a little fake. What does this really mean? I like to say that Settlement is about establishing a view of your system on some other system, and it's all about making claims, right? I'm making a claim about the state of my system onto another system. And so Settlement is really useful. Obviously, in traditional roll up settlements is really useful if you want to do withdrawals, if you want to be able to move funds out of your roll up onto, let's say, layer one, you need to be able to settle the state of L2 onto layer one so that I can say, okay, that is the true state of L2. Let me pull it out, let me operate on it, and maybe I'll give you a withdrawal as a result. But the thing is, you can do a lot of really interesting things with Settlement.
00:36:13.774 - 00:37:06.530, Speaker C: You don't just have to make claims about, let's say, the total state of the system. I think a really interesting way to think about Settlement for gaming is that you can have a short lived chain that plays some game. Let's say we all want to play a chess tournament, right? We can play a short lived game, and then at the end of the game, we see who wins the whole tournament, and we can make a claim, and we can say, Kelvin won the whole tournament, and that's the claim that I'm settling. And then you can have this generic proof system that will just prove arbitrary claims about the state of your L2. And so you can prove this idea that, okay, Kelvin won, and then we can resolve that winner back to layer one, and we can pay that person out, and then we can throw the chain away because we don't need it anymore. So we got this short lived verifiable system, right, this game that we know that the whole thing ran as it should have ran. There's no weird state coming out of it.
00:37:06.530 - 00:37:37.982, Speaker C: We prove that back to the base layer, and then we can throw the whole chain away and we don't have to worry about storing it. And so for short lived, high capacity games, you could really bump up the gas limit. You can do crazy stuff because you're not worried about state bloating to infinity. And then you could just settle any sort of information about the state of your L2 back to layer one. All right, no sequencer, no problem. Actually currently a very big problem. But this is just an idea of basically where we imagine this system going in the future.
00:37:37.982 - 00:38:30.522, Speaker C: Because there's a big issue, which is that every single time I talk about this idea, somebody comes up to me and they ask me, doesn't that mean you still have to run all this sequencing infrastructure? And the reality right now is, yes, but we want to get to a future where the answer is no, right? Because most people don't really want to run this infrastructure. You want to focus on building a game, especially, let's say you just want to build something small. You want to run it for a couple of days, you want to put it up there. The reality is, I'm sure that the average person does not want to deal with the level of stuff that we have to deal with at optimism to keep the sequencer running. So we have this concept that we're exploring called shared sequencing. Basically, shared sequencing is taking all the headache of running your own sequencer, and it's deleting all of that. And the basic idea is that all of these different autonomous worlds can share a single sequencer.
00:38:30.522 - 00:39:21.754, Speaker C: And of course, when I talk about a single sequencer, you can see there's multiple machines there. I like to think about the sequencer as sort of a single logical entity. But in the future, what's going to happen is you're going to get decentralized sequencing. You're going to have something that looks like a leader election where at any given time slot, there's a specific sequencer, and that sequencer is sequencing your roll up. And then there's the next time slot and the next sequencer comes in, right? So the thing with this is you can do something really, really interesting if you have one sequencer sequencing all of these different chains at the same time instead of having multiple different chains that are talking to each other. The problem today is if I have let's say I'm Ethereum and I have Cosmos, right? I want to interact between a Cosmos chain from Ethereum. They don't share a validator set, which means that my communication inherently has to be asynchronous.
00:39:21.754 - 00:40:00.166, Speaker C: But if you have a single sequencer producing the blocks on many different autonomous chains of autonomous worlds at the same time, you can get this amazing property of atomic composability between all these different chains. You basically have a single sequencer saying, okay, there's a transaction coming in on chain A and there's a transaction coming in on chain B. And I'm supposed to guarantee that they can come in atomically. And I can do that because I sequence all the chains at the same time. So now you have different games, different worlds, different realities that can interact with each other. They're their own states, right? The validation is separated. None of the validity of one of these chains depends on the validity of the other chain.
00:40:00.166 - 00:40:30.690, Speaker C: But they can talk to each other as if they're on one unified chain. That's crazy. Right? Now I can have an action in one game all of a sudden create some simultaneous action in another world at the same exact time if those two worlds want to talk to each other. So this is part of something that optimism is playing with that we're calling the superchain. We think that this extends a little bit more than just shared infrastructure. I think that the incentive here is not just to share infrastructure. It's to share code, it's to share a set of values.
00:40:30.690 - 00:41:13.694, Speaker C: It's to basically collaborate on having all of these different games and all these different worlds. Maybe it's not games, maybe it's entirely different roll ups. But we think that there's a strong incentive for these systems to not just be able to transact atomically, but to really be able to collaborate with one another towards some coherent vision. Because you're much better joining in on this system than you are trying to build your own chain separately with your own sequencer set. And you have to run all the infrastructure and you don't get to talk atomically with the rest of the system. So long live the superchain. I would highly recommend, if you're interested in this, how this might work in more detail, come to the back to back talk with Carl and me later this afternoon.
00:41:13.694 - 00:41:59.166, Speaker C: We'll go into much more detail about how all this works. All right, where are we? All right, so the other question I get is why make it free and open source, right? Aren't you basically just like, letting people compete with optimism and build their own roll up? And the answer is like, kind of, yeah, right. This is the idea. Basically the argument is that the reason we have to do this is because there's just no other way to do this. We think that there's going to be this explosion of people who are interested in building layer Twos, interested in building Layer threes. We're already seeing all these big l One systems come in and they're experimenting on the execution layer, right? They're competing with Ethereum on the execution layer. They're saying, we're going to build a parallelized VM and that's our advantage.
00:41:59.166 - 00:42:52.530, Speaker C: And if you really want to survive, you're going to need to be able to compete on this stuff. And we think you're going to need to be able to compete on this stuff without having to have 25 engineers work on this problem, like three years, for three years, like we did. And instead, you're going to want the ability to have three engineers figure out how to do this in three months to start a business out of it. So this is basically the argument. If you want to really make it possible for Ethereum to continue to compete and for people to experiment on the execution layer, experiment on the derivation layer, experiment on all these different layers, it just has to be available, right? If there's not a permissive license on it, you can't use it. If it's not modular enough, if it's too hectic to try to hack in your modifications to the execution layer, you can't use it. So the goal is just make it as available as possible so that ethereum can continue to compete on every single layer of the stack, but you can still stay within the ethereum ecosystem.
00:42:52.530 - 00:43:30.606, Speaker C: And this is us today. This is where we are. We got Lattice, we got a couple other people. And this is the world that we're imagining, right? We're imagining that basically everybody is building on a system like this and they're collaborating and they're working on a shared infrastructure. And by working on a shared infrastructure, you share audits, right? You can share engineering time. It basically takes you 100 times less effort to build 100 companies instead of having every single company fragment and build their own system. You basically have all the freedom in the world without actually worrying about the low level technical details about how are you going to publish transactions to layer one.
00:43:30.606 - 00:43:55.826, Speaker C: Reliably? How are you going to deal with reorgs, right? How are you going to make the proof work? Because all that stuff is extraordinarily complicated. There's no reason why every single person who wants to build one of these chains should have to basically build it from scratch. Doesn't make any sense. All right, so some closing remarks here. Basically, go nuts. Build something crazy. You can do so much with this architecture, right? You can swap out the data availability layer, make your chain cheaper.
00:43:55.826 - 00:44:28.020, Speaker C: You can swap out the execution layer, build an entirely on chain game. You can literally take an emulator of some system, you can put it into the execution layer, and you can even prove that the whole emulator functioned properly. You can do an enormous amount of stuff with this. And the nice thing is you don't have to worry about how are you going to go build the sequencer, how are you going to go build the proof and all these different things. You basically get all that for free. So that's the idea. Where are we? Yeah, thanks for coming to my Ted Talk.
00:44:28.020 - 00:45:01.802, Speaker C: Where are we right now? So the code is all there. It's possible to hack on this stuff. The next goal is to take all these modules and make really clean documentation so it's clear what you have to change, where you have to change it to make all this possible. If you go in today, lattice has been extraordinarily brave to go in and basically hack this system together and really make it work for them. And we've seen other people do it as well. If you're interested in doing this, come talk to me later, and I can give you pointers. But the goal is right now, it's still a little early.
00:45:01.802 - 00:45:33.926, Speaker C: We're looking for people to come in, help us figure out where the APIs aren't clean enough, right? Help us figure out where the documentation isn't clean enough. If you know what you're doing and you're really interested in hacking on something new, come find me, and I will try to help you get started with this whole thing. And the goal is make this accessible to the average person who just doesn't want to deeply understand how this whole architecture works. So that's me. I'm going to hand it off now. All right, cool.
00:45:34.028 - 00:46:14.690, Speaker A: Three minutes left. Announcement time. Announcement time. So just like the Op stack is meant to essentially increase pluralism by making something free and open source and easy to use, we kind of did the same thing with Mud. Mud is MIT licensed at Soft launch today and to kind of pave the way forward, lattice and Optimism have been working together over the last month and a half on an autonomous world that was built on Mud and runs on the Op stack. So we're pretty excited to show Opie craft to everybody. It's a 3D Voxel game powered by Mud running on a crazy degenerate Opie chain.
00:46:14.690 - 00:46:41.398, Speaker A: Yeah, I even have a video. I will see if it plays. But Alvarez and I yesterday were trying to build a house, so yeah, that's running on DVM, guys. It's a procedurally generated world. I can't wait to see what people will do with that. You can deploy Marketplaces, Oracles, extend it, build augmented reality, tennis, capitalism, whatever you want. It's going to be open source soon.
00:46:41.398 - 00:47:06.070, Speaker A: It's playable today. Let's actually see how we build the house. I remember it was quite hard given we didn't really have consensus on how the house should look like. Do. Yeah. Okay, cool. We did it.
00:47:06.070 - 00:47:28.216, Speaker A: Opcraft is going to be soft launch and playable at the autonomous World Arcade at 04:00 P.m. Today at the Hacker Basement. So if you want to play it, come there. Additionally, we're going to have a tournament of Skyscrive, which is the RTS that was built with Mud. We have playlisted it weekly for the last month. People really like it. There are StarCraft players that don't even know that it's running on chain.
00:47:28.216 - 00:47:43.180, Speaker A: They just like the game. So, yeah, we're going to try to hit 64 players, so come along as well. Hacker Basement 04:00 p.m.. So what about the other stuff? Well, Mud is actually already available. We just don't really talk about it because it's not very documented. It's like the op stack. It's on mud.
00:47:43.180 - 00:48:01.610, Speaker A: Dev the code is on GitHub. We have a bunch of teams building stuff with it, but talk to me if you're interested. The Op stack is going to be announced soon by car all at 01:30 P.m. On the main stage. And yeah, that's us. Thank you, guys.
