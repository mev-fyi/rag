00:00:04.810 - 00:01:26.760, Speaker A: Hi, I'm bjorn and welcome to bridging the DAB talk contracts, talking across chains. So I will use the next half hour to tell you a bit about a project, give you an overview on a project that we kicked off roughly one and a half years ago in the larger context of another project, project, which we call Polkadot. To really understand what we're trying to do, I want to give you just a brief gist of Polkadot. So Polkadot is our take on a next generation blockchain protocol with key tenants being scalability, interoperability and governance. It really is a heterogeneous multichain proposal, a framework that is set to enable independent blockchains to exchange information and value in a trustfree manner. Now, for this larger vision to become a success, we need a component that we call the birch. And the birch in that context, is supposed to enable blockchains that are self secure, that provide their own means to come to consensus, to really communicate with each other.
00:01:26.760 - 00:03:01.400, Speaker A: Now, when we started with that project, we realized that we really got an opportunity to create value for existing Ethereum developers rather than shooting for the moon in a few years. And in order to understand in what way this can help Ethereum developers today, it's important to understand the problem that we are facing today. Those teams that building Dapps today, and I mean most of you are aware that the name of the game is scaling, right? We still haven't figured out how Ethereum mainet can scale, and I personally at least, am very skeptical that Shastra will arrive within the next twelve months. And I think it will rather take a few years until we really get there. And what we've seen over the last years is that we have this amazing ecosystem, like hundreds of projects that have been working hard on implementing certain Dapps, right, certain daps with a certain smart contract architecture. And it's sad, but the reality is that a lot of them can't go live today on mainet because transaction fees are prohibitively low, prohibitively high, so the debts are economically not feasible. And second, we get into these situations where the network is just congested, right, the blocks are full.
00:03:01.400 - 00:04:41.430, Speaker A: And some people may say, right, but we have all these other EVM scaling approaches that can potentially help us today, or rather in a few months when they are done. And a lot of them we call L2 scaling solutions, right? So we have one to one micro payment channels such as microraident. Or we have state channel approaches from the wonderful team, from funfair, the general state channels from counterfactual or the great work that spankchain has been doing. And last but not least, there's plasma, right? But what a lot of people forget is that those approaches are not applicable to most DAP architectures that exist today. So these teams that have set out like a few years ago when these ideas weren't around yet, right, and have written like hundreds and thousands of lines of code, right, are in a situation where they're like, if we want to use these approaches, these L2 scaling approaches, that really means they have to start from ground zero, they have to rearchitect their whole dap. And that is where I believe parity bridge can at least help in the intermediate time until Chespa is around, right? So let me introduce you to what that is, parity bridge. Basically it's a federated system that allows to relay arbitrary messages, any kind of messages, between two EVM networks, between two EVM chains.
00:04:41.430 - 00:06:00.458, Speaker A: For the sake of this presentation here, let them call them main and sidechain, right? So we have two, there are three critical parts of that bridge that exist today. One is rust software that connects to two Ethereum nodes via RPC or IPC. You can choose and really just watches the chain for certain events to be triggered. Then second, there are meet space entities, persons that run the forgement software, and they are the authorities that validate and eventually relay the messages from one chain to another. And last but not least, we have smart contracts on both chains that coordinate between these authorities, the validation, the relay and eventual delivery of the messages. Now, what can you do with them? Right? That's the biggest question. Well, the nice thing about that is this general approach is that you can have a DAP that has a smart contract on one chain that suddenly calls a function on any contract with any parameters on another chain.
00:06:00.458 - 00:07:24.540, Speaker A: It's that simple. And security of that message relay is guaranteed by trustworthy authorities. So for every and each message that's being relayed, it's required that a certain number of authorities have signed off of that message relay. And overall we try to keep the system as simple and general as possible. Now how can that help mitigate these scaling issues that we run into? Well, if you can offload a large amount of transaction from one chain to another, right, that is an approach you can choose. And really what you can do there now because of this arbitrary message relay approach, is you can spread out your DAP between those multiple chains. So you have the assets that need to live on Mainnet, right? On the Ethereum mainnet, maybe those that have to be interact with exchanges or maybe some identity of the user that can stay where it is, right? But those interactions within the app that happens on chain, right, that are really computationally expensive or require a lot of transactions, those you try to outsource to another app.
00:07:24.540 - 00:08:40.606, Speaker A: So that's one part. The other exciting part about that approach is, in my opinion, that you can really get early access to new features, features that have yet to become available on the main net. So if you take as an example that the sidechain is being run by parity theorem nodes, right, in a POA network, you could have today wasm smart contracts being run there, you could use private transactions, or you could try out Constantinople opcodes that will only become available in half a year. In general, when Ethereum Mainet upgrades there's one note of caution I want to add here, and that's very important to me. While this is really great for the moment, in the long run this isn't going to solve the scaling issue in the whole, right? That's why the slide says mitigating scaling issues and not solving them. Because what that means here is that if you spin up a new side chain, that means you also have to secure that side chain. And as more side chains, there are as more resources you need to secure these individual side chains.
00:08:40.606 - 00:09:29.182, Speaker A: And we all believe that that can't scale securely. Nonetheless, in the meantime, this is a way to get your application live. So for the side chains, what options do we have? I believe you can choose between three flavors right now. Either you say, hey, I need all the transaction throughput that's available on a new chain for myself for my own app. In POA parity Ethereum, you can get up to maybe 500, maybe 1000 transaction per second. And then you just say like, hey, I spin up my own dap specific chain. You get a few befriended projects to run an authority node and thereby secure your chain.
00:09:29.182 - 00:10:24.050, Speaker A: Or you say, nah, actually there's this other team and we have applications that interface with each other that are reliant on each other, and we both make a consortium and we spin up our kind of friends of dapps chain. Or last but not least, you use an existing bridge that bridges existing networks. For example, the Ethereum main network with the coventest network. Now let's take a look how parity bridge actually works. The next few slides will show you a walkthrough for a message being sent from main to site. What you can see in these diagrams is on the left side there's a main chain. On the right side there's a side chain.
00:10:24.050 - 00:11:02.480, Speaker A: On the main chain you have a contract deployed that's called bridge contract. Right? Now, it has one function that's called relay message. On the side chain, you have a bridge contract as well, right? And it has a function called confirm message. Now, some app wants to use this bridge. What the DAP does it deploy is extension contracts. So contracts that know how to interact with these bridge contracts. So we have on the left side sending contract, which is part of your DAP, it has some function.
00:11:02.480 - 00:12:24.522, Speaker A: And on the right side we have on the side chain a receiving contract which is also part of your application, and which has a function accept message. Now, we also have bridge authorities, right? This integral part of the system that actually facilitates the message relay between the two chains, and that watches both chains. Now let's say a user kicks off a transaction with your application. It calls some function, and some function again calls relay message, because it wants to send over a message to the other chain that again kicks off, it triggers an event called relay message. The bridge authorities see that event being triggered, they wait a few confirmations, because they want to wait until they have a higher degree of finality, right? Because the main ad has only probabilistic finality, and you really don't want to relay a message that might be reverted after the fact, right? So after a few block confirmations, the authorities confirm the message one by one. On the other chain. Once a certain threshold which is configurable has been achieved, another event is triggered, which is receive message.
00:12:24.522 - 00:13:29.870, Speaker A: And then this contract, the bridge contract. On site calls whatever the recipient contract is, and calls a function called accept message. There, that's a message delivered, and there can be whatever transaction should be kicked off by. This interaction can be kicked off by accept message then. So that said, the message relay the other way around from site to main is not identical to this interaction. And that is mainly due to the reason that we build on the assumption that transaction costs are significantly higher on the main side than the site side. And that means bridge authorities really want to interact as little as possible with the main blockchain and gather signatures, gather these confirmations on the side chain.
00:13:29.870 - 00:14:12.000, Speaker A: So how can you utilize it as a DAP developer? Like, what do you have to implement? Critically, there are two interfaces that you need to be aware of. You can see both here. One allows you to relay a message. It only has two parameters. It's the data, whatever your message is, as well as an address, which is the recipient address on the other chain. Also, you have a function called accept message which your recipient contract has to implement. Right? And that's it.
00:14:12.000 - 00:14:58.534, Speaker A: One thing is to be noted here. All information obviously needs to be encoded in the data parameter, and the recipient contract needs to be able to decode that message and do certain actions based on this decodedation. Now, I brought you a few examples of what you can do with that. So, for example, you can use it to build an ESC 22 C 20 bridge, for example. Let's take Auga as an example. You build a contract that allows you to lock up Auga on rep on the main net. That contract sends a message through the bridge to another contract on the side network.
00:14:58.534 - 00:16:23.574, Speaker A: And, you know, assign that many auger tokens that only live on the side network to this person, and vice versa. Pretty straightforward as well. You can do that with native currency. So on the main net, you could lock up ether on one side and create wrapped ether on the other side, which is really an ERC 20 token that is redeemable for one ether on the main network. And the last example I brought here, and that's the one I'm most excited about probably in this compilation here, is that you can have an ESC 20 token on the main network, lock it up, and then give the user, whoever locked it up, native currency on the site network. And that really means you suddenly can have a stablecoin packed native currency on the side chain, right? You can have dai being essentially the currency that you use to pay for gas on your site network. And if you combine that, for example, with fixed gas prices, you suddenly have a situation where those people that run DApps or those people that interact with DApps on your site network have full control and full understanding of what their transaction and their interactions will cost.
00:16:23.574 - 00:17:36.650, Speaker A: There will be no volatility. And this last part really was made possible by something we call block reward contract, which allows a smart contract to inform the consensus engine how many new tokens should be minted and who they should be assigned to. But basically, the options are pretty much unlimited of what you can do. Everything you can write in a smart contract, you can do that. Now, here are a few of the projects I've personally talked to that have either been using the parity bridge or that have been waiting for the arbitrary message passing in order to split up their DAP between multiple chains. Now, as always, there are certain caveats with this approach, and there are certain caveats with our current implementation that I don't want to not talk about. So, number one, currently all of the bridge authorities, right, these authorities that relay messages should also be authorities on the site network.
00:17:36.650 - 00:18:40.802, Speaker A: So they should be the validators, the block producers of new blocks on the side chain. That is because currently the system is designed so that most transactions that happen on chain happen on the site network. And you don't want the authorities to have to pay for all these transactions, right? For both reasons, spam protection as well as costs. But if the bridge authorities happen to be the POA authorities on the site network, they don't have to pay for the transaction that it put in their blocks. So that works pretty well in my opinion. It also works pretty well with the trust model that you have to assume around this application. Because after all, if you don't trust the authorities on your site network to truthfully maintain integrity of this side chain, right? Then you also wouldn't want to trust a bridge that relays messages to this chain, right? Another one.
00:18:40.802 - 00:19:55.478, Speaker A: Currently the Spritz authority set is immutable, right? It's very trivial to change that. We can just add another contract logic that allows you to have a majority vote and vote a bridge authority in or out, however you want or add whatever governance mechanism you want. Last but not least, if you connect two chains and one of the chains is a proof of work network, then unfortunately you are facing the problem that you don't have deterministic finality. Which means if you want to be fairly sure that nothing is being reverted, you want to wait a few transactions and that introduces latency that we don't want. That said, if you got two networks that have deterministic finality, there's really no reason to wait longer than once finality has been achieved on any block. Last but not least, there's a very important note of caution here. The contracts I've been talking about here, they haven't been audited yet, so please use with caution.
00:19:55.478 - 00:21:46.190, Speaker A: They're in an alpha phase, right? So further challenges. Transactions on mainet are very expensive, right? So if you relay a transaction from the site network back to the main network, then you need at least one transaction to be made by authorities, and that's the transaction that actually relays the message, right? So now who should pay for that transaction? That's still a problem we are facing. I believe in most cases it won't be a big problem because the application that decides to implement the site network and to utilize a bridge has an intrinsic motivation to pay for these transactions because it obviously increased the value of the network, the overall network and its application. Second, what happens when a relayed message kicks off a transaction that actually runs out of gas. Right? Like we are facing a more async situation here, and that's not trivial at all to mitigate. Another thing that shouldn't be unnoted is that there is still missing tooling for side chains, right? Even though we finally have an open source blockchain Explorer, which is absolutely fantastic, right? Which you can spin up for your site network, we've still met Miss Metamask and inferior and other kind of things that we usually want in order to effectively build on a network. Last but not least, there are UX considerations that you have to take into account when you follow this approach.
00:21:46.190 - 00:22:59.170, Speaker A: For example, you might end up in a situation where the user that interacts with your DAP has to switch between networks, which is not quite nice. Also, the user might have to own native currencies on both networks. So last thing, a bit about the roadmap that we are looking at next things we want to do include we want to enable bridge authorities to vote on a new bridge authority set. What I just said dynamic bridge authority sets. Second, what we really want is that the bridge authorities are tracking whoever is an authority on the site networks, and that leafset are pretty much identical. Further, we are exploring methods, how the site network can be proof of stake and the side chain validators, the validators of that chain actually stake ETH on the main net, which is a fairly interesting approach. Furthermore, we are interested in finding more interesting use cases, writing more extension contracts.
00:22:59.170 - 00:23:59.400, Speaker A: And last but not least, there's still tooling that should be in place. For example, monitoring tooling that allows us really to inspect and see what is happening in the bridge and what messages are being relayed and debug problems. If there are any problems, I invite all of you to please have a look at our wiki read contribute chat with us. I can't wait to hear what you want to build with that and on what network you want to build it. Is it coven? Is it your own app specific chains? Are you going to team up with giveth or some other teams to build a new chain in the meantime? As long as the main net doesn't scale? Thank you so much. So I've got another five minutes for questions. I can repeat it to you though.
00:24:00.810 - 00:24:17.358, Speaker B: On the roadmap, I noticed you guys had no intention to audit your contracts. Is that something that you're going to do? I'm sorry, on the roadmap you guys didn't list any intention to audit your contracts. Is that something that you guys are going to do? Because that hasn't really worked out well in the past.
00:24:17.444 - 00:24:37.614, Speaker A: Yeah, most definitely. So what I want to see first is a bit more experimentation. Right. We haven't actually released arbitrary message passing Birchat. It's already in GitHub. You can play around with it, it works. But we want to write a few more integration tests.
00:24:37.614 - 00:25:02.010, Speaker A: And then I expect us in the following weeks to release it, then deploy a test version between COVID and maybe Rupsten. Right. Play around with it, invite more people to play around with it, see if it really fulfills these requirements and meets these needs that people have. And then once we got there, sure, definitely. Either we do it or we team up with a few teams to audit these contracts.
00:25:02.090 - 00:25:02.446, Speaker C: Thank you.
00:25:02.468 - 00:25:06.814, Speaker A: Yeah, thank you for the question. Hi. Hey.
00:25:06.852 - 00:25:28.246, Speaker C: Thanks for that, Bjorn. And thanks. It looks really exciting. One question I had was with the bridge authorities, who do you envision those would be like, what are the incentives for actually securing those relay messages across screens, across chains, and how to punish bad actors that might seep in.
00:25:28.428 - 00:25:59.738, Speaker A: Right. I can envision multiple scenarios, right. Number one, the most obvious one is the DAP that needs to utilize the chain. Right. Being at their own chain, or the multiple daps that want to spin up their own chain, they have an intrinsic motivation to facilitate this transfer. And after all, the price isn't really the problem. The cost, expenses to spin up a node today, I believe, for Ethereum may not cost like what, $150 a month to run a node.
00:25:59.738 - 00:26:14.850, Speaker A: So that isn't really the point. And to my knowledge, I think POA network has been running the bridge for over half a year now. And I think the costs were negligible.
00:26:16.550 - 00:26:39.706, Speaker C: Reason I ask is one of the most exciting use cases which I've thought of with something like Thundercore or something like that, being able to use dai on one side chain and move it over, you can end up, if some application becomes really valuable or really of high use. Right. These bridge authorities are going to be presumably taking in Dai and being able to direct it in the main chain. There might be a lot of value moving from one chain to another.
00:26:39.888 - 00:26:41.420, Speaker A: That's true. Right.
00:26:43.390 - 00:26:51.690, Speaker C: Obviously there might be an incentive there, right, for them to direct Dai to some other contract that's not the intended contract.
00:26:51.850 - 00:27:28.970, Speaker A: Right. I can. So multiple aspects, right. I still think this is only an intermediary solutions, as I said, because I think we need to come to a point where we pull security for all these chains, right? This multichain future where you have like thousands of chains that all secure themselves, be it in this model, right. Where you have EVM chains being bridged by parity bridge, or in the Cosmos model where you have all these zones that have to secure themselves. I don't think that's feasible in the long run. Right.
00:27:28.970 - 00:28:13.240, Speaker A: For me, this is really an approach for all these applications right now that are facing these issues that they have been working on all that code for multiple years and they are facing the situation a, either you wait another three years until Shastra is here, or you restart from scratch and try to implement it with L2 solutions, such as state channels. Right? That said, I'm not quite sure if that. Are you asking about the danger of having too much value locked up in a PoA chain?
00:28:14.940 - 00:28:47.984, Speaker C: Well, maybe not necessarily PoA, but for instance, you could mint dai on the main net, right? And then there's some application that uses dai, say, on another chain. Maybe it's like a proof of work saying, or pilipala or something, right? And you send, I don't know, a million dollars into the other chain through the bridge. Value gets generated there or whatever. Then you want to secure it back on the main net. You want to send it back, you want to make sure that that's destroyed or properly accounted on the main net. But maybe it's just not the right use case for this kind of.
00:28:48.102 - 00:28:54.416, Speaker A: No. Okay, I get. So you're asking how can I trust these authorities effectively?
00:28:54.448 - 00:28:56.500, Speaker C: Because they can send the die wherever, right?
00:28:56.570 - 00:29:50.470, Speaker A: That's always the case, right? It's the same thing as in ethereum proof of work, or in any kind of proof of stake system. How can I trust that the validators who validate my chain, be it the chain or the bridge, doesn't really matter in that sense, right? Like, don't collude, right? Don't build a cartel and say, like, oh, I'm actually going to take all the value out of that bridge. Very good question. I think as a user, you got to be really cautious to interact with certain chains with too much value. Right? I wouldn't want to transfer a million die over to a chain that I know is rarely being used where there may be two authorities only that have aligned incentives to actually collude and steal your money. Right? Yeah.
00:29:51.160 - 00:29:53.130, Speaker C: Thanks for that. I appreciate it. Thank you.
00:29:57.290 - 00:29:58.280, Speaker A: Thank you.
00:29:59.530 - 00:30:09.270, Speaker B: So how is the fault tolerance maintained at the delivery of the accept message? Is there a ring signature or something of the validators?
00:30:09.430 - 00:30:36.530, Speaker A: No. So what is happening? The bridge authorities do two things, right? When they watch a message coming from main to a site, on the site matches, they all have to call a function on the site network. Right. And you have a configurable threshold. And if you say seven out of ten authorities have to sign off on the message, only then the message is actually being relayed. Otherwise, not. Right.
00:30:36.530 - 00:30:56.730, Speaker A: And in the other way around, you gather signatures before. Right. They gather signatures on the site network and then the last authorities submits one transaction on the main network that accumulates all these signatures and the contract checks that all the signatures are there. In that way you have fault tolerance.
00:30:57.950 - 00:31:14.410, Speaker B: Is there on state channels where there's kind of this awaiting period after message has been relayed. Is there something like that? So that maybe somebody can bring an attestation saying that actually that's not what happened on the opposing chain?
00:31:14.570 - 00:31:40.286, Speaker A: Currently not. Because really, you take the set of which authorities as your point of reference. If they say, hey, that message was relayed, it's actually relat. And in order to make sure there's no reorganization, they wait a few confirmation block confirmations in order to be sure that actually, whatever kicked off this relay happened on the one side of the chain.
00:31:40.398 - 00:31:41.010, Speaker B: Thank you.
00:31:41.080 - 00:31:44.800, Speaker A: Thank you for the question. I got to head off. Thank you.
