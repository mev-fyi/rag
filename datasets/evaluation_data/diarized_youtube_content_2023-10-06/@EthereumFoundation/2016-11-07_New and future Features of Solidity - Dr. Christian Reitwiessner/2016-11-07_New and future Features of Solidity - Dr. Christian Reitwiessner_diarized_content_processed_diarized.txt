00:00:20.730 - 00:01:42.660, Speaker A: The slides are there. Great. So yeah, this talk will basically, yeah, I just want to tell what we did during the last year and what the plans for the future are with regards to solidity. I want to start with explaining what the initial goals were for solidity. So the idea was to have a statically typed language that is easily readable for web developers, or for not necessarily web developers, but for, I don't know, casual programmers. So yeah, we chose something that looks like a symbiosis between JavaScript, C, Java, and it should be high level, but at the same time it should be also very efficient because there's not a lot we can do inside a single block, at least currently. And yeah, keep that in mind because sometimes solidity looks really high level, but actually it's not that far away from assembly.
00:01:42.660 - 00:02:34.450, Speaker A: Okay, what happened? Since Defcon one, we extended solidity to be more flexible, more usable, so we added some usability features. And not to forget, we made it safer. At least I hope so. So what exactly did we do? Next slide please. It's now possible to build custom types in solidity, and that leverages the new features of inline assembly and libraries that were present for Defcon one already. But we added so called internal library functions and not to forget the using x for y. So let's look at an example.
00:02:34.450 - 00:03:36.100, Speaker A: This is I think Nick Johnson's string library, at least a small fragment of it. And inside this library you have this struct slice which defines a new type, and it's basically a view on memory. It has a pointer, which is so it's a kind of rather low level object. It has a pointer and a length, so it references a chunk of memory. And the function to slice can be called on any string, and it creates such a slice object that references the data of that string. That is important because usually when you create so we want to be able to reference parts of strings, and if we use just the string type itself, we would have to copy it all the time. And using this slice we can talk about parts of strings.
00:03:36.100 - 00:04:22.412, Speaker A: At the bottom we have a contract that actually uses this slice. It takes a string, it calls to slice, which converts it to such a slice and then checks whether it starts with foo. So it checks whether the prefix is foo. And no, not yet. The great thing is that you can so using this, using strings for star statement, you can basically attach functions from a library to an existing type. And that's why we can call s to slice. Although S is a built in type that usually that of course does not have the function to slice.
00:04:22.412 - 00:05:49.470, Speaker A: And I think this is a really powerful tool, especially when coupled with inline assembly, because you can create tools using inline assembly without having to change the compiler. So you can basically add types that look like built in types, but you do not have to look into the compiler. What we also did is we extended the AST output capabilities, and one of the goals there is to provide more, make the compiler more accessible to external tools which want to do static analysis or debugging. This is still a bit fluid, so we might still change the design of the AST output. But as an example we have the statement return x plus y, and this gets converted into the following JSon a representation of the AST we have an id which is used to reference other nodes in the AST. Oh, perhaps I should. AST is short for abstract syntax tree, and that is basically a representation of a structured representation of the source code of a program.
00:05:49.470 - 00:07:34.304, Speaker A: And so this return x plus y is decomposed in the return statement. And then inside this return statement we have a binary operation which is the addition, and the two operands again are inside the binary operation, and these are the two identifiers, x and y. And you can see this attribute Src that is a reference to the actual position in the source code where this piece of the ast came from. And that is very important for the debugger, because at any point in the code it can show you, if you debug a transaction, then at any point inside the execution of the transaction you know where that was, where you currently are in the source code. And you can also do more analysis on the AST and perhaps analyze the ast for insecure stuff and notify the user and point to an exact location in the source where this problem is. Yeah, concerning safety, we already had several talks about formal verification, so I won't say anything about that. With the release of solidity, we added some changes that intentionally broke backwards compatibility in order to add some safety features, and some of them were that we created exceptions in more situations than before.
00:07:34.304 - 00:09:04.270, Speaker A: And the effect of an exception is that a transaction is rolled back, or at least a call inside the transaction. So whenever you encounter a troublesome situation or some situation where it's not really clear how to deal with it, at least not for the compiler, then this basically undoes the effect of the transaction. This can be dangerous in some situations, especially when you, for example, have a loop and one of the iterations inside the loop always triggers an exception, then it's impossible for the loop to go through. So this is something to be aware of. But we chose to rather revert the transaction than reverting a transaction is less of a problem than getting stuck. Failed creations now throw an exception, division by zero throws an exception, and function calls to a non contract. This function calls to a non contract is especially important because if you call a non contract, if you send ether together with it, it will just accept it and it might be forever stuck there.
00:09:04.270 - 00:10:08.000, Speaker A: And then we have the payable modifier. So you now have to explicitly specify for every function whether it is allowed to receive ether. And the default is to reject ether, so it's harder to accidentally send funds somewhere. And to make the version transition safer, we also added the version pragma, which means you can now specify the compiler version your source code is designed to work with. And if we change the compiler, if we change the language in the future, then this version pragma will tell the developer, yeah, there might be some changes, so you probably have to take a look at your source code and modify it accordingly. And then we also fixed a problem with modifiers. So modifiers are kind of properties you can attach to functions which insert a prefix and a suffix into the function.
00:10:08.000 - 00:11:07.590, Speaker A: And this underscore part there is where the actual function is inserted. And previously it was more syntax based, which means if the function had a return, it actually returned. And in the sense that it also skipped the trailing part here. So this locked equals false would have been skipped before with a return, but it would not have been skipped if you just completed the function. And this now hopefully makes it possible to create mutexes which allow a function to be active only once, in that there is a variable in storage called locked in this example. And if the function is active, it's set to true and it's automatically set to false again, if the function exits. And if the function is locked, then you cannot call it.
00:11:07.590 - 00:12:16.148, Speaker A: Okay, how does the full future look? Again, formal verification then one important and large feature we will add is something I call authenticated sources and binaries. This means that the compiler will automatically insert a hash of the metadata into the bytecode. And using this hash you can retrieve the metadata from swarm. That means that the metadata will contain a lot of information about the contract. This includes the ABI interface. And the effect of that is if you load up a smart contract inside mist and want to interact with it, you do not have to copy and paste the ABI anymore. It will automatically retrieve it from swarm, and it's also authenticated in the way that that is the ABI the programmer intended the smart contract to have so you can't make any copy paste errors.
00:12:16.148 - 00:13:33.036, Speaker A: And it will also have a link to the source code and link in the sense of link to swarm, of course, which means that the source code is hash authenticated and this hash is part of the bytecode. So it's the exact source code the programmer used when compiling a smart contract. And it will also have the compiler version, which means mist can automatically retrieve both the ABI interface and the source code, and the compiler with the correct version compile the source code and verify that this is actually the source code and then show the source code documentation to the user. And since the formal verification conditions are part of the source code, it can even automatically do just in time formal verification of the smart contract. Okay then, templates is something we would like to add. So this is sometimes called generic data structures or generics, and I hope that it will also increase flexibility because you can implement one routine, one algorithm once and then reuse it for multiple data types. We will also add functions as first class citizens.
00:13:33.036 - 00:15:07.840, Speaker A: This means you can have things like anonymous functions, lambda functions, and use them as for example as callbacks in Oracle queries. So currently Oracleize uses some kind of manual solution to that problem, because if you make a request to Oracleize, then the Oracle smart contract invokes the oracle system and retrieves the data, and then calls back the original contract in a later transaction. And currently this callback goes to a fixed function with a fixed name. But in the future it will be possible to just supply a callback function as is usual in asynchronous programming. And yeah, speaking of asynchronous programming, not sure if you've seen this proof of concept hack two weeks ago about the, about the await way to program. In the future we will explore new notations for how to do asynchronous programming because often smart contracts are a sequence, consist of a sequence of things to be done in exactly this sequence. And it kind of doesn't really make sense to put these different steps in different functions, and it's much easier to actually program that sequentially.
00:15:07.840 - 00:15:56.320, Speaker A: It's probably hard to explain without example. Okay, you will see. So what else do we have? Yeah, we plan to add algebraic data types and as I said, templates, but it's probably too hard to explain the source code in this talk. And there's another slide with even more complicated future solidity code, and I would just encourage you to take a look at the slides later and read the comments. Yeah, and this is just a rough idea of how it could look like. So I hope that the URLs of the slides are published soon after the conference. Yeah, I think we'll also have relevant Reddit posts.
00:15:56.320 - 00:15:59.660, Speaker A: Okay. Thank you. Thanks, Christian.
