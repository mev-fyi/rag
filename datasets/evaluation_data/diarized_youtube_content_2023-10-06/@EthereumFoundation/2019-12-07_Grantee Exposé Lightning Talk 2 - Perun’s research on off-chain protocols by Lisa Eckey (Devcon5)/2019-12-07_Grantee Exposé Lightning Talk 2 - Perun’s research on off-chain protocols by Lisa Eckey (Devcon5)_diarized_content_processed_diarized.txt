00:00:05.270 - 00:00:57.398, Speaker A: Hi everyone, I am from Perun ofchainlabs and I want to take this chance today to present what we've been working on in the last few years, who we are. We are two teams of applied cryptography researchers in Darmstar, Germany and Varshau, Poland. And we provide cryptographic protocols improves. But our focus, our goal is how we can use smart contracts to scale blockchain. In particular, I want to present to you today three protocols that we've been working on. The first one you might have heard about is called Perun and Extensions where we try to build a framework for state channels. The second one is called Fairswap where we try to use smart contracts to build a fair exchange protocol.
00:00:57.398 - 00:01:49.414, Speaker A: And the last one is a very recent one called Fastkitten where we use trusted execution environments to build secure private smart contract executions. So let's start with the first one, peer and extension. Smart state channels is an extension of payment channels. And most of you will have heard about payment channels. And the idea is to get rid of these very long duration and costly single payments on the blockchain and encapsulate them into a channel which is secured by a channel contract on chain. And this allows to make off chain direct payments between two participants really fast without additional costs. And our goal here is to take these existing payment channels and make them more powerful.
00:01:49.414 - 00:02:31.698, Speaker A: And we did this in three lines of work. And the main component that we used is the observation that we can put contracts that we can put on chain also in state channels. And not just one, we can put multiple contracts into a state channel. And this is a nice observation because if we can do this, then we can also put a channel contract into a channel. And this is really nice when we want to connect more than two players. In this case, for example, we have Alice and Ingrid who have a channel and Ingrid and Bob who also have a channel. And in both of these channels we now put a channel contract which opens a new virtual channel between Alice and Bob.
00:02:31.698 - 00:03:16.534, Speaker A: And this is really nice because for opening this channel we don't have to go on chain, but this completely happens off chain. We can also update this and close this off chain and use it as much as we want. Again, we can also open contracts inside the virtual channel, as many as we want. And the third extension that we've very recently published is that we can also connect more than two people. We can connect end parties by putting an end party contract into channels. And these end party channels also provide the same properties as a direct or virtual channel. But enough about channels, I have two more proposals to talk about.
00:03:16.534 - 00:04:16.874, Speaker A: The second one was fairswap. And Fairswap tackled the problem of fair exchange which is really hard to solve without a blockchain classical example is when you have a seller and a buyer and a seller has a file x and the buyer is willing to pay for this file, but only if it's the right one, which is here measured over his hash. So a very naive solution is we just take a smart contract, buyer submits the coins, seller submits the money and then the contract verifies hash correct or hash incorrect. But this is actually really expensive when we talk about large files, about giga or megabytes. So we propose a new protocol called Fairswap where we encrypt the file and not send it to the contract, but directly send it to the buyer in the first message. This is happening directly between seller and buyer. So no on chain communications, the buyer cannot see the file at this point because it's encrypted and it's missing the key.
00:04:16.874 - 00:05:02.040, Speaker A: So it locks the coins which will make the seller submit the key. And then the buyer can decrypt the file, actually look into it and verify if it's correct or not correct. And in case it's not correct, it sends a proof of misbehavior to the smart contract, which the smart contract the judge in this case will verify. So the goal here is to keep this piece of information as small as possible, ideally independent from the size of the overall file. And how we did this is by splitting up the file in many small chunks. And the hash that verifies its correctness is actually a merkle hash. So the hash root of the merkle tree is used to verify if the file is correct or not correct.
00:05:02.040 - 00:05:49.206, Speaker A: So in this case, we have a very nice scenario because Alice and Bob, if they disagree about correctness of this, can actually limit the disagreement to a single element of this tree. So either the last element is wrong or a single evaluation of this hash tree is wrong. And in this case they only have to send a single element, a single chunk of the file which the jobs have then to verify. And this can be done really cheaply. We measured it around half a year ago where it was like $2 independent from the file size. So you could send an arbitrary large file and this complaint was taking a constant amount of fees. And we also evaluate the security.
00:05:49.206 - 00:06:31.000, Speaker A: This is something that we take a lot of effort in formally modeling and verifying security of our protocols. In this case, we ensure that it's fair. So atomic exchange of payment and files, we also want to make sure that it's sound. So the buyer has the guarantee that if he gets a wrong file, he can always generate a proof of misbehavior and it will always be accepted. And the unforgettability property is really important such that the buyer cannot come up with a wrong proof of misbehavior, claiming the buyer misbehaved even though he didn't. And we prove all of these properties formally in the paper. We also worked on some extensions of this.
00:06:31.000 - 00:07:09.866, Speaker A: The most important one is that I was basically only explaining one example with the file and the hash. This also works for generic witnesses and circuits. So it's very powerful, can use arbitrary programs or it can verify arbitrary programs. We also have an interactive and a non interactive version of this dispute of the proof of misbehavior. And the non interactive is nice because we have five interactions with the contract and that's it. And the interactive active dispute has many more interactions with the contract. But we have fee fairness.
00:07:09.866 - 00:08:15.910, Speaker A: So we have the guarantee that all of these transaction fees that have to be paid for the dispute will only be carried by the cheater, by the cheating party. So an honest party doesn't really care how long it takes or how expensive it is, it will always get reimbursed. Now to the last of three things that I wanted to present today, which is called Fastkitten. In Fastkitten we use a building block which is called a trusted execution environment tee or trusted hardware, where this piece of hardware is trusted to run the code we give it and no one can influence this execution. But of course, while this piece of hardware is trusted, the person that runs it is not trusted. So we have this operator who is in charge of feeding information to the te and forwarding its output. So it can stop the te, it can stop forwarding its messages, but it can never lie about the computation inside the tee and it cannot influence the computation.
00:08:15.910 - 00:09:12.680, Speaker A: So we use this building block, which is quite common now in cryptography, and try to run smart contracts inside this piece of hardware. And what we get from this is actually a really powerful protocol because we can run a contract independent of size off chain. We have very high guarantees we can protect against malicious parties and malicious operator. We can uniquely attribute faults in case someone misbehaves. And also this protocol is so simple that we can actually build it on bitcoin. Okay, so how does it work? We have this tee here and the operator and all of the parties, so they want to play a poker game now, which means we load a poker game into this piece of hardware. The parties attest this te so they know that this is actually trusted hardware and this is actually running the right code.
00:09:12.680 - 00:10:07.770, Speaker A: And then the operator deposits a security penalty deposit and all of the parties lock the coins for the game. Then we start. And at this point we don't need the blockchain, we just run everything off chain. So the parties send their inputs to the te, but they actually do it in an encrypted way so the operator cannot see the inputs and the te also sends an encrypted output back to the parties. So the operator has no idea of what's actually happening and also, the parties don't see each other's inputs. This is also a nice feature, which Ethereum doesn't have right now, and it's really hard to build in smart contracts, but it's given for free in this setup. So now the parties can actually see who won and get their money back from the tee, which means the te outputs a transaction, saying, okay, here Alice and Charlie get all their coins.
00:10:07.770 - 00:10:56.040, Speaker A: Of course, we still have to protect against all this power that the operator has, so in case it misbehaves, we actually have to wait for a certain timeout, and then the parties get refunded their money, but the operator lost his security deposit, which is, well, really painful for him. So, to summarize, over all of these three works is very interesting observation that smart contracts are really powerful tools that we can use to ensure security and that we can also use to build more scalable protocols. And our goal here is to really provide cryptographic models and proofs with all of these protocols and really show that they satisfy cryptographic security. So if you want to learn more about this, feel free to talk to me here at devcom. Thank you.
