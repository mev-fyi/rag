00:00:05.430 - 00:00:28.782, Speaker A: Thanks for having us. I'm Ricard. I work for runtime verification. I usually work on Kwasum. And I'm here with Shangwei from Ntu Singapore. And we want to tell you about K and how and why specifying solidity in K is a good idea. The K semantic framework is built on the idea that every programming lab, which should have a formal semantics.
00:00:28.782 - 00:00:58.620, Speaker A: So from a formal semantics, the K framework can automatically derive all the common software tools. This includes parsers, interpreters, but also more complex tools like compilers, model checkers, deductive verifiers and so on. So the complexity of work for generating ttools for L languages goes from T times L to T plus L. K is by no means a new technology. This framework has been developed for over 15 years. We use it heavily at runtime verification. There's lots of publications surrounding it.
00:00:58.620 - 00:01:31.298, Speaker A: It has also proven very language and blockchain agnostic. So the formalism works for high level languages like solidity, C, Java, low level languages like WASM and EVM. And we worked on different blockchains like Ethereum, Algorand, Tesos and so on. I just want to show you the formalism that K is based on. It's a rewriting formalism. So I'm going to give you a short example of what that looks like. The first thing you need to define is the state that the rewrites should act on, which we call the configuration.
00:01:31.298 - 00:01:51.274, Speaker A: It's built up of what we call cells. So here we have a configuration which contains the program to run in a cell that we name K. We have an environment for the current variables, which is a key value map. And we have a local memory storage and more cells we don't really care about.
00:01:51.312 - 00:02:03.440, Speaker B: Now, Ricard, I'm sorry to be interrupting, but the slides are kind of blurry. Is there an option that you either can share them with the audience or maybe Shang Wei could share his screen instead?
00:02:05.010 - 00:02:06.766, Speaker A: Sure. Let's see.
00:02:06.868 - 00:02:09.250, Speaker B: They are kind of hard to read right now.
00:02:09.400 - 00:02:14.210, Speaker C: Okay, I can share my screen, but does it affect Ricker's presentation?
00:02:17.430 - 00:02:25.526, Speaker A: So we have some transitions, but we should be. Okay, I'll just say next slide or something. Okay, let me turn off my.
00:02:25.628 - 00:02:27.400, Speaker C: Let me try as well.
00:02:29.290 - 00:02:31.774, Speaker B: That would be great. Sorry for the interruption.
00:02:31.922 - 00:02:44.170, Speaker D: Yeah. So that just means that people will have to select not the speaker's picture to see the slides, because the live stream follows the audio.
00:02:45.470 - 00:02:47.020, Speaker B: Yes. Okay.
00:02:49.730 - 00:02:54.030, Speaker C: So let me share with my slides.
00:02:54.610 - 00:03:04.086, Speaker A: Great. You can click through. There's a much better quality.
00:03:04.268 - 00:03:06.630, Speaker B: Yes, this is very sharp. Now thank you.
00:03:06.780 - 00:03:43.794, Speaker A: Okay, keep going. And yeah, here we come to syntax. So you write your syntax in typical eBNF form, but we have these handy annotations. For example, strict two means that the second argument here is strict, so the right hand side would be evaluated first. So you can add some semantic meaning to your syntax declarations if you go to the next slide. Here's an example of what a rewriting rule looks like, and I'll just show you how it acts over a specific configuration. So here we have a configuration with the identifier foo, and you assign three.
00:03:43.832 - 00:03:44.580, Speaker C: To it.
00:03:47.190 - 00:04:30.446, Speaker A: And you write your semantic rules with this rule keyword. Basically what we will do here is we will look in the current environment, find the pointer, and then go to the storage and modify the value at that pointer. Go back. Yeah, so it's a rule keyword. And you see these little rewrite arrows, those specify where the state is going to change the next slide. So first the assignment is going to match the rewriting rules just applies to any configuration that its left hand side unifies with. So in this case the configuration matches the rule.
00:04:30.446 - 00:05:08.910, Speaker A: The assignment in the rule matches Foo equals three, with Foo assigned to X and three assigned to y I. So actually this might be a little annoying to do in this way, so let's just skip over the rewriting part and I'm happy to explain this in detail to anyone later. Or you can just look at slides yourself. Let's go to formal verification. So basically, from a semantic written in this formalism, there's a straightforward way to reason about how program execution so click next. The K framework derives a prover for free, and the basic idea is this. You treat every rule as an axiom.
00:05:08.910 - 00:05:36.840, Speaker A: Next you can do next three times you write a claim as a rewrite rule. Then you start from the left hand side, apply all axioms that match branching whenever there's more than one thing that applies, and you just show that on every branch you always reach a state that matches the right hand side. So next slide. Let's see.
00:05:39.210 - 00:05:40.898, Speaker C: Maybe I shouldn't all.
00:05:41.084 - 00:06:28.680, Speaker A: Yeah, that's probably good. So basically, why should you bother making a formal specification or an executable formal specification? I'd say it's the best of both worlds. You get something that's readable and reasonably high level. If it's a case style, you can even write it in a literate style, inline it with your documentation. It's executable, obviously, so you get an always up to date correct by construction reference interpreter. Everyone working on the formal verification tool can now do so properly in quotation mark because you actually have a formal definition of the language. I'm very curious to see what's going on on the SNT end tomorrow regarding this, but yeah, having some formalism that describes the language is usually a good idea.
00:06:28.680 - 00:07:08.850, Speaker A: I also find that it's a good prototyping tool for trying out language changes, because once you've hacked away on a language change in the compiler, for example, you need to specify it in a way that is ruthlessly unambiguous, and at least with k the semantics are even composable. So you could write a separate semantics for, say, Yule and include that in the solidity semantics. And it actually shouldn't be that intimidating, because defining a semantics is sort of on par with writing an interpreter in terms of work. So with that I want to ask you to consider this statement that solidity should have an executable formal semantics.
00:07:11.110 - 00:07:11.522, Speaker C: And.
00:07:11.576 - 00:07:16.950, Speaker A: With that I just want to hand over to Shang Wei, who has been working on just such a specification.
00:07:18.810 - 00:08:11.398, Speaker C: Okay, thanks Rica for the introduction of the k framework. Then I'm going to take over to introduce how we define the formal semantics of k of solidity in the k framework. To do so, actually you need to define two components. The first component is the configuration, which indicates the status or state of smart contracts. If you look into the configuration file, actually you'll find that it has two main parts. The first part mark in the red color, which is for execution of a smart contract instance, while the second part mark in the blue color is for recording the whole blockchain network status. And let's zoom into the red part and you will see that we have a dedicated cell called execution engine for execution of smart contract instance.
00:08:11.398 - 00:09:11.450, Speaker C: And inside this cell we have several important cells. For example the call stack for function calls, either external or internal. We have call state, including the iD, which is the address of the current instance, the caller ID, call value, storage, local memory, et cetera. And if we look into the blue part, you can see that we have a sale account in which we store all the contra instances that have been deployed on blockchain, including its address, its contract name, its balance, its storage, et cetera. Now let's move on to the second component to define. That is a set of semantics rule indicating how each solicit statement behaves based on a current configuration, as well as how it updates the configuration. Let me use this statement as an example.
00:09:11.450 - 00:10:04.662, Speaker C: So here we have a statement to declare a variable of unsigned integer in storage whose initial value is three and how do we define a semantics of this statement? We need to write a semantics rule for that. For example, here in a case cell, we see this statement of this syntax. We know that it's a variable declaration, so we try to rewrite this statement to allocate term in K. It looks like this, and at the same time we need to look for necessary information and put it here. So for example, here we need to know what is the current account that we are going to declare this variable. So we need to look for its account ID. So we put it here together with the variable information, for example, the name of the variable, the expression, the value, the type, the location, et cetera.
00:10:04.662 - 00:10:56.974, Speaker C: And then we move on to this allocate term. So whenever we see this allocate term in a case cell, provided with the necessary information, then we are able to do the corresponding arrangement in this account, that is, to insert this variable record in this account cell. Here I omit the details, but to sum up, to develop a formal semantics of solidity in the k framework, we need to define first the configuration. Second a set of semantics rules like this for each statement. Now I'm going to talk about the challenges that we face during when we develop the semantics. The first challenge is that solicitity is actually changing very fast, either in syntax or semantics. Currently the latest version is 0.6,
00:10:56.974 - 00:11:54.318, Speaker C: but if you look into the version history in average, almost every month will have a version change, which is quite challenging for us to run after the frequent version changes. The second challenge is that the language description in the official document is not comprehensive. Usually complicated or corner cases are not mentioned. For example, if we are talking about function modifier, the following details are not mentioned. For example, what if the underscore statement is used for more than once? What if the modifier is inherited for more than once by a function, et cetera? And we need to figure this out by ourselves based on some experiments, which is quite time consuming and the current status of case solidity. The project started in the beginning of 2018, and until now we have two versions. Version one supports solidity 0.4
00:11:54.318 - 00:12:51.410, Speaker C: and this table summarizes what are the features supported by our semantics? And as you can see that almost every core feature is supported except those that we are not able to support. For example, this inline assembly. Basically this is EVM bytecode, and obviously it is out of the scope of solidity itself. And since solidity 0.5 was introduced, we plan to have a refactoring based on version one to version two to support solidity 0.5 and currently we have finished core expressions and statements, and we are still working on some advanced features, for example function modifiers, user defined types, inheritance, et cetera. And now you can find our version two implementation on GitHub now, and with version two actually you can do automatic testing or proving your smart contract.
00:12:51.410 - 00:13:59.366, Speaker C: Now I would like to share with you one of the interesting findings. When we developed the semantics and it was back to solidity 0.4 and here we have a very simple test case that we use to test our semantics, and you can see that it's a very simple contract test consisting of two state variables, a and b, with their initial values one and two respectively. And we have a function fool here in which we declare a local array d with two elements, and after that we try to assign seven and eight to the two elements respectively. Now the problem is, what are the values of a and b after we execute a function foo? Well, based on our semantics, a is still one, b still two, but the program stuck at this statement. And this is because when we declare d we don't specify the location. So by default it will be in storage, and based on the semantics it will be a reference to storage, but we don't have its initial value, meaning that we don't know where deep points to.
00:13:59.366 - 00:14:46.150, Speaker C: So whenever we want to execute this statement, we don't know where to store seven. However, if you try to execute this contra in the remix compiler, I mean 0.4 version, and you will find that the result would be a becomes zero and b becomes eight. And you may be surprised because you thought you are dealing with only local variables, but actually global variables are affected. And obviously something went wrong here. So we reported this findings in our technical report in 2018 on archive, and after our investigation we found that the solidity 0.4 compiler implemented some implicit behavior which is beyond developer's expectation.
00:14:46.150 - 00:15:28.082, Speaker C: And the problem comes from this statement. When we declare this array d, we don't specify the initial value, but for the compiler it assumes that the default value will be zero. So actually d points to slot zero in the storage. So that's why when we execute this statement, the content becomes like this, and when you execute the second assignment statement, the content becomes like this. So that's why a becomes zero and b becomes eight. And of course this behavior has been fixed since 630 0.5. Now you need to specify the initial reference for deep, otherwise the compiler will complain about that.
00:15:28.082 - 00:16:23.750, Speaker C: So from this example we can observe that the formal semantics of solidity is very important, especially for developers. Well now I would like to summarize this talk by introducing the possible application of case solidity. First of all, our semantics is fully executable, meaning that you can execute your smart contract based on our semantics and you will have an output configuration. Actually, you can have the output configuration after each statement, and you can do formal verification. You can have some assertions in your smart contract, and our tool can help you to do symbolic execution to check whether the assertion will fail or not. Or you can even try to prove that your smart contract are correct. But of course you need to specify the properties, and then you can even do compiler verification.
00:16:23.750 - 00:17:14.150, Speaker C: This is what you can do. For example, you have a smart contract, right? You can run your smart contract based on our semantics. Then you'll have an output configuration. In the other hand, you can compile your smart contract by a compiler, and you have your EVM bytecode, and you execute your bicode and you have your real output. And after that you can compare the two outputs to do course validation if they are not consistent, meaning that something's going wrong. And last but not least, you can even do semantics consistent checking. For example, how do you know that the behavior in a solidity level conforms to that in the EVM bico level? To do the consistent checking, actually you need the formal semantics of EVM, which is supported by another project, KeVM from runtime verification.
00:17:14.150 - 00:17:23.980, Speaker C: All right, I think that's pretty much I want to share with you today. I think Rico and I would be happy to take questions if we still have time.
00:17:25.870 - 00:17:40.400, Speaker B: Yes, you still have a couple of minutes, so feel free to ask questions in the solidity GitHub chat or right here in the room. Okay. Yeah, somebody's raising his hand. I see it already. La dio. Yes.
00:17:41.730 - 00:17:45.486, Speaker E: Hey guys, thanks for the talk. Wait, can you hear me?
00:17:45.668 - 00:17:46.302, Speaker C: Yes.
00:17:46.436 - 00:18:16.650, Speaker E: Okay, cool. Yeah, so this stack case loaded to KVM, of course, makes a lot of sense, and it's super nice. But suppose, let's assume that k ul exists. How much easier would caseloaded to Kul and Kul to KVM be if you want to verify the whole stack than sort of like the single large step from case liquidity to KVM.
00:18:18.670 - 00:18:20.700, Speaker C: Ricard, are you going to answer?
00:18:21.550 - 00:18:30.878, Speaker A: Yeah, sure. So you mean for compiler verification, like verifying it in intermediate steps, right, if.
00:18:30.884 - 00:18:35.680, Speaker E: You have the source code and then you have the compiled bytecode, then you want to check equivalents, for example.
00:18:38.050 - 00:19:15.070, Speaker A: Yeah, I mean, it would be the same thing in the sense that if you have a complete semantics of Yule you could symbolically execute your program and then you could check that. I mean, the tricky part is defining sort of equivalents, like figuring out, well, we expect this value to be output or stored somewhere, whereby EVM just correlating that to the corresponding part of the solidity configuration. It would be the same thing, I think, but it depends sort of on how the semantics are written. But in principle it should be the same or simpler.
00:19:15.410 - 00:19:56.194, Speaker C: Actually, I have something to add up. When we try to define the formal semantics of solidity, we try to keep the configuration as much the same as EVM as possible. For example, we still keep the gas transaction number, et cetera. We try to keep it as the same as possible. This is because we want to do the consistency checking, although some of the cells, we cannot use it. For example, the gas cell, actually in the solidity level, you don't know actually how each statement consumes how many gas. So we just put it there and have some estimation.
00:19:56.194 - 00:20:18.380, Speaker C: One way is to you compile your solidity contract into EVM and calculate gas and get back to solidity level and put into the gas cell. So I think if you want to do the consistent checking, that would be not difficult because 80% of the configuration are the same, all.
