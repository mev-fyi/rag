00:00:00.410 - 00:00:40.710, Speaker A: So this will, I will try to make it as technical as possible. So apologies if it sounds like too deep of a dive, but I want everybody, so, like, you have, I have 20 minutes. So in 20 minutes, you will learn what plasma cache is, how it works, where it works, where it doesn't, and why it's the most viable solution currently, at least at the current research levels, because all the other solutions, I'm of the personal opinion that they're quite, let's say, optimistic and ambitious, and it will take some time until we have them, like in production. So there's my slides. Yeah. So who knows here how plasma cache works. Like, has tried implementing it in a low level, essentially.
00:00:40.710 - 00:01:13.026, Speaker A: Oh, shit. Okay, so the point is that the other plasma constructions, the original plasma paper, it was very important because it gave the notion of what plasma is. It should be like the Satoshi's vision thing, Vitalik's vision, whatever you want to call it. However, it was totally unrealistic. It has this whole Mapreduce construction. It had a bunch of the dream of the tree of chains and everything communicating with each other like the supreme court. I'm not of the opinion that it works.
00:01:13.026 - 00:01:54.810, Speaker A: So this talk will be highly opinionated on what I'm thinking, how plasma is and works. So take this with a grain of salt. This is not expressing the general, let's say, opinions of the plasma community, I guess test, test one too. And the point is, okay, anyway, the thing is that the plasma, it works like with a classic side chains construction. You have like a main chain, the side chain. You deposit your funds, you do whatever you like on the side chain, you can take them out. But the thing is that in order to get scalability, we actually need a consensus mechanism that advances faster than the normal mechanism, than the base chain mechanism.
00:01:54.810 - 00:02:43.098, Speaker A: And you cannot do that, in my opinion, by definition, you need to make some compromise on either decentralization or the security aspect. And so what we're doing is that with plasma, you construct essentially a noncustodial side chain, because at any given point in time, if there's some invalid state transition, you can go through this exit game and you can just get your money out within a certain challenge period. Yeah, maybe. How do you handle this? I'm not exactly sure. I have a bunch of nice shapes and all that to explain. So the whole difference between plasma cash and the other variants is because the plasma cash, it's non fungible. It is in the family, let's say, of plasma protocols, that the security is enforced by the non fungibility of root chain deposits.
00:02:43.098 - 00:03:29.680, Speaker A: So each coin you deposit has a unique id, it's different from each other, and you can use it to have a sort of simple exit game where each coin is unique. You don't have to use the whole priority queue construction to go through your, what do you call it? To make multiple exits. There is no need for the mass exits construction, which is very important, because currently, all the other plasma, non plasma cache variants designs, they require mass exits. And I will make the claim that mass exits currently aren't viable due to how, let's say, primitive. Our signature aggregation works on the. We cannot verify enough. Even if you do a multi signature and you compress it and you do a threshold signature on all of them, you cannot actually verify the whole thing on the.
00:03:29.680 - 00:04:06.390, Speaker A: Okay, so Jeff just said, explain why starks are better than XT based checkpoints and whatever, or RSA accumulators. So, first of all, quantum resistance. Okay, so the argument is plasma cash has a very big, let's say, disadvantage, that whenever you're passing coins around, and as the side chain progresses, the coin history grows linearly. So I have ten blocks. I need to pass around ten blocks worth of proofs, and this sucks. So what we can do is, one, we can just pass around the proofs. Two, we can do checkpoints, which is a very brilliant transaction by Kelvin.
00:04:06.390 - 00:04:56.362, Speaker A: However, this thing, it requires so much social coordination. It's like on the level of the mass exits, and I'm not sure if it works. So, on the contrary, what you can do is that you can use the RSA accumulator. The RSA accumulator's recent construction, which you assign a unique prime number to each leaf, and you make some black magic on it, and you can somehow prove combatively that the coin's history is valid. And the final, the very sexy alternative is that you can just take the whole history, you make a stark proof, you put it on a black box without any trusted setup or anything that you don't like, and just have a compact proof that can be transmitted to your receiver. And actually, in these cases, we never need an on chain verifier to do that, because I want to prove, like, let's say to Jeff, I just want to tell him, know I have this coin, take it. And he proves it on his own.
00:04:56.362 - 00:05:18.990, Speaker A: And the verification is very fast. And, yeah, quantum resistance, because we need to be, like, anticipating the quantum computers, they're coming to get us. Where's my slides? Yeah. Q and a. Exactly. More questions, please. Actually, yeah, I'm pretty sure, I can answer any technical questions, so hit me with your best shot.
00:05:18.990 - 00:06:00.346, Speaker A: And if I don't answer? Yeah. Why do we need to worry about quantum resistance if we're not even sure if the systems work yet? We're going to iterate multiple times. Plasma cache is real. Is it? Because it's going to exist in perpetuity for a long period of time and then future quantum computer? I mean that generally we need to be looking ahead and protecting against. So to rephrase, if we can have a quantum resistance scheme in one year, I believe it's much better than investing six months in a non quantum resistance scheme. So I'll just chime in for a second. So I think the danger is if we encrypt all this data and we have our browser history encrypted, and then somebody gets a quantum computer, we're all screwed.
00:06:00.346 - 00:06:46.334, Speaker A: Right? Okay, so how do you get started? Firstly, Kelvin and friends have done like a great, great, amazing educational effort with a site called lepllasma.org, if I'm not mistaken. But I am of the opinion that. Where's the timer going if I don't have slides? But I am of the opinion that I literally cannot show you how one thing works. If I literally point you like to, if I give you ten links, it doesn't work that way. So I've been writing a plasma paper like, okay, I will talk about my work, right, I've been writing a sort of plasma paper that it's like a 20 pager that you read in maybe 2 hours, and you can understand everything about plasma, this variant that I'm working on. So you read it and basically you should be having a pretty good idea of what's going on.
00:06:46.334 - 00:07:32.442, Speaker A: And implementing a plasma contract isn't actually the hard thing. Implementing the client software is the hardest thing because the smart contract, you define it like you give it, like you need to do this for exit this, to withdraw this to deposit, that's all there is to it. And you add the submit block function to commit the merkle route, and that's it. But the client software, it needs to watch, it needs to cache state, because if you pull the medical proof, you need to save it, because if you don't and you restart your client, you don't have the proofs. You assume that whatever entity is providing you the data, they will provide you the data. And if you do that, why even bother with plasma? Which is, I'm pretty sure there are some plasma variants that assume some sort of data availability, and you shouldn't ever assume any kind of it. So, yeah, just read learn plasma.
00:07:32.442 - 00:07:59.666, Speaker A: I'll give a link to the paper at the end. Anything going on? More questions? Yeah, anything. Seriously? Yeah, Philip. MVP. And can we use MVP today? Is there like an open source? So I do not work on MVP, but again, my opinion, I do not think light client verification works on MVP. I'll put very contrary opinion. So always with a grain of salt.
00:07:59.666 - 00:08:40.226, Speaker A: So, MVP, it requires you to validate the side chain state, which by definition, it contradicts the scalability, because if you need to do full client validation on the light clients, you can never run like a secure plasma chain on your phone. You can never validate the Secure plasma chain on your phone. And you need to do that because otherwise you cannot be sure that the plasma chain is not the fractional reserve. Like if there is a withdrawal also from it and you didn't take note. So, yeah, that is why I'm very bullish on the plasma cash, because everything that happens on chain, you know, at that moment, okay, plasma cash, blah, blah, blah. Okay, so why is plasma, you have the main chain, the side chain. Like, you deposit some funds, you do the funds, whatever you like.
00:08:40.226 - 00:09:19.822, Speaker A: We talked about this already, so I will skip this through. The big details that we need to insist on is that each block must be submitted, and the gas costs for this, they kind of stack up. I actually really like this purple color. It's very satisfying. So you checkpoint each block, and the moment you consider transaction finalized, this is like a security property that you consider a transaction finalized once the block route has been committed and the witness data, the Merkel branch for that transaction that you're looking for, is made available to you. Because if that data is not made available to you, you literally cannot know if the transaction was included or it was answered. So just a moment to just say that plasma cache is real.
00:09:19.822 - 00:09:35.454, Speaker A: It's working right now. It's live right now. You can do NPM install like this thing. You can run this command. These are two real addresses, and you can connect to rinkab via infura or your own node. But nobody runs their own nodes, unfortunately. But, yeah, shout out bitcoin.
00:09:35.454 - 00:09:54.998, Speaker A: And this is like how the thing looks from the inside. You type help, you have a bunch of commands. The user needs to do the very minimal amount of things. Just need deposit, transfer, exit, withdraw. That's all you need to do. I'm of the opinion that you never should force the user to do anything regarding watching. It's all in the client software.
00:09:54.998 - 00:10:24.100, Speaker A: And yeah, whatever you can demo it if you want. I won't do a live demo because it's total hubris. It doesn't work. So, okay, I've written this thing, you should try to read it, give me feedback and so on. I'm basically trying to do what I said before. I'm trying to do a very concise overview of how plasma cache works and what's it about. And soon I will have some more formal notation of how the exit game and the finals and the state transitions work.
00:10:24.100 - 00:10:43.734, Speaker A: So, first of all, why it's real. We can do it in pretty realistic time frames. I believe that. I started working on it on May, and we had like an implementation within a month and a half. So it's real. We have low data requirements for the light clients. Like, okay, it's not really low, but it's lower than any other available solution.
00:10:43.734 - 00:11:28.598, Speaker A: So I will claim it's low. And you can have this modular architecture where if anything that you don't like, you just add the plugin. So this whole naming convention thing I'll talk about also. So I believe that this is a very good quality slide to get people to understand what are the difference of each variant. So the ones that we are working on, and much thanks to Ranji for maybe I said the name wrong for all the discussions for this, is that whenever you deposit the coin on this variance of plasma cash, each coin is unique. So this gives you a very simple exit game, and the security is tight, and what you can do is that, but it has some problems. It doesn't have fungible payments, and the history grows like hell.
00:11:28.598 - 00:12:34.110, Speaker A: So what you can do is that you can either use some magic, like RSA accumulator, zero knowledge proofs, to prove the coin's history in a more compact way. And the other thing is that if we want to do fungible payments with multiple ones, you can apply the other technique, that you break a coin down in 100 pieces and you have the user transferring the sub pieces of it. And whenever you're speaking about a coin, you're actually talking about a range of coins. Or just use state channels. Yeah, I'm a very big fan of state channels on plasma, but we'll talk about that later. So the other variants there are the plasma MVP ones, which I argued earlier that they require too much data, and they also require a sort of priority queue construction for exits, because if the operator, the operator is basically able to create a huge Utxo, which exits the whole chain, which would make it a fractional reserve, and you need a mass exit, which to my knowledge, there is no working mass exit scheme to date. And on top of it, you can add the more viable plasma, which Kelvin has thought of to make ux better and maybe most viable plasma one day, I don't know.
00:12:34.110 - 00:13:05.970, Speaker A: And yeah, you can use narcs to verify the state transitions from one thing to another. So currently what we have is that we do transaction routes. So anytime you submit a block, you don't actually submit the state route. So it's not the latest state. So you need to go literally through the whole block history. Well, in this case, you just have the state route, and it's like it's there. You know, it's there because you have this whatever black magic box that it proves your assumptions.
00:13:05.970 - 00:13:41.554, Speaker A: So I'm pretty sure there's a good taxonomy on which are the variants of plasma. And okay, to be fair, these are the variants that are based on payments, the variants that are based on smart contracts. I'm not well informed on them, but they're very fun. So to do like a quick technology primer. So, the main data structure that we use in plasma cache, it's a sparse merkel tree. It's basically a tree which has all the, it has like whatever leaf amount you want. It's all precomputed, so it's all like in the default values, it's the hash of zero or whatever null value you want.
00:13:41.554 - 00:14:20.234, Speaker A: And to prove the inclusion of an element, you do it in the classic way that you just provide the Merkel branch with the siblings and everything. I'm assuming that people know how a Merkel tree works. And the fun part is that you can actually prove non inclusion by giving n proof of inclusion of the zero hash of the hash of zero at this leaf. And this is very convenient, because this is what basically makes plasma hash work. And you can actually have some very nice optimizations on top of this. So, because all the values are pre computed, when I'm giving the miracle proof, I not need to give like 32 bytes every time. Whenever I want to give the default value for a sibling, I can just give a bit field, and it's literally one bit where it's 32 bytes.
00:14:20.234 - 00:14:53.686, Speaker A: And in this very simple example. So normally the Merkel path could have been hash of zero and the higher level one. So it's 64 bytes, while with the optimization for the bitmap, it's two bits. And much love to the wolf team for thinking this up and having a working implementation. So the usual suspects, Alice deposits five ether was like the actual flow. So Alice deposits, like, five ether to the smart contract. The smart contract emits some deposit event that the plasma chain listens.
00:14:53.686 - 00:15:20.686, Speaker A: The plasma chain is supposed to create a new block, one new block per deposit. This is not a security requirement, but it makes proving like it's an optimization, basically, this has been asked a number of times, just deposit the coin, and you get a new block. This isn't necessary, but it's better. And what it does is it creates a plasma block, and you get, literally a five ether bill, if you will. And the thing is that the transaction flow, it's like Utxo based, but it's one input. One output. I cannot break a coin.
00:15:20.686 - 00:15:34.054, Speaker A: I just say new owner. And that's a new owner. Just like cash. Yeah. So I'll just go through a simple example of how the transaction flow works. So, deposit Alice deposits the five ether. I like the five ether example.
00:15:34.054 - 00:16:25.026, Speaker A: So five ether, like, it just appears Alice gives the coin to Bob. But the thing is that at this moment, Bob must actually verify that the coin's history is valid. And now let's consider that there is a new block where Alice, where Bob, who is the latest valid owner of the coin, doesn't move the coin. And if Bob wants to give the coin to Charlie, Charlie must not only verify the inclusion block one and two, he must also verify the non inclusion in block three, which is why I spoke before about the non inclusion proofs in sparse mercury trees. And he needs to do that because considering the fact that there might have been a transfer from two to three, the two to three would make the two to four a double spend, and we don't want double spends. And he does that, and he exits by providing an ancestor. There has been some discussion lately that there might be a way to optimize this to not require an ancestor.
00:16:25.026 - 00:16:56.450, Speaker A: But I'm not sure about the safety of it. If you want to evaluate it, fine, but I haven't been able to evaluate it. But basically, the thing that we know that works currently is you give it a coin and the parent coin, and you use this to exit. And I will go over the exit game, the game that's played very soon. So the whole plasma constructions, they work based on a challenge period, like the classic dispute period, where I make a claim, I put up a bond, I wait some amount of time, and if nobody challenges, yeah, my claim must probably be right. It's all like crypto economics. I hate that word.
00:16:56.450 - 00:17:22.218, Speaker A: So the time currently and the bond amounts are totally arbitrary. I'm of the opinion that somebody just wrote the first MVP implementation. Maybe it was David. Actually, it just put like seven days for an exit period. And everybody said, that's it, the holy grail. Or maybe Vitalik said, I don't know. But the point is that currently there has been no game theoretic, like proper analysis on what the challenge period should be and what the bond amount should be.
00:17:22.218 - 00:17:50.062, Speaker A: And I'm very interested to that. So if you have any research on that, please speak to me. This is like a good takeaway from the presentation that we model each coin as its own state machine. So state machines, like it's. Yeah, we have the initial deposited state. And basically you define a transition function that whenever you want to go from one state to another, certain things need to happen. And what you do, it's simply like whenever you want to go from deposit to exiting, you start an exit and you put up a bond.
00:17:50.062 - 00:18:19.878, Speaker A: The start exit, you put whatever proofs you like, it doesn't matter. And there are two types of challenges. The one type of challenge is the interactive one, and the other is the non interactive. So I'll speak about the non interactive, which is simpler. So the non interactive challenge, it is essentially I see a claim and I instantly challenge it and the exit goes home like it never happened. Right? And it's a simple form of challenges. However, the interactive challenges, essentially, in order to finalize an exit, it mustn't have any pending challenges, any outstanding challenges.
00:18:19.878 - 00:18:44.770, Speaker A: So what you do is I start an exit, somebody else challenges my exit. And in order for me to be able to finalize my exit, the word exit has been said to many times. You need to actually respond to the exit. And like you have, let's say you have a counter, a challenge counter that goes up and down. And the only way to finalize it is when it's at zero. I hope this slide is clear, because it's like more or less the whole construction of how it works. And now I'll talk about the challenges.
00:18:44.770 - 00:19:12.946, Speaker A: So I'm hoping things are clear so far, because this way we're going to the examples. Let's say that Alice has a coin at block n, whatever you like, and Alice spends the coin. She gives it Bob or whoever else, and Bob maybe then gives it Charlie. So the thing is that Alice isn't forced to exit from the latest state. She can always go to a stale state and just say, I'll exit. So, yeah, she can do that. But the thing is that she needs to wait seven days or whatever to do the exit.
00:19:12.946 - 00:19:35.220, Speaker A: And at that point, another entity they can challenge by providing a spend. So Alice Ascendan makes the claim, I am the latest owner of the coin. And then the challenger comes and says, no, you're not. Basically, that's the whole thing that you need to know about it. And this is the one type of attack that you can do. And this shout out to Carl, because he did a very good specification which explained all that stuff. I used it, you should use it.
00:19:35.220 - 00:20:29.590, Speaker A: The other alternative is that you do a double spend. So the example I was talking about before, I was considering the fact that Charlie or Alice prime, not plasma prime, is actually like, it's not a colluding party. So what can happen in this case that Alice gives the coin to Bob, and Alice in collusion with the operator, they double spend the coin, so they give it themselves, some other friend of them, whatever. And what happens in this case? If Charlie wants to exit the coin, he needs to provide the parent, as I said, and the whole exit game here, it works that you need to provide the coin that is in between. And this actually proves the double spend because you say, no, I owned it before you did. And the final example of the exit game is that when you're exiting a coin, so when you're receiving a coin, you actually validate the whole coin's history. But what if you don't? So I want to stress that in this example, try to imagine that the Red Arrow doesn't exist.
00:20:29.590 - 00:21:13.070, Speaker A: It exists, but it's like the response state. So let's say that Alice has a coin and that the operator, they collude with some party to give a coin to Bob, so they make an invalid state transition. So to say in plasma MVP, if an invalid state transition happens, the whole chain has to leave, which isn't possible. Seriously. So what you do is that if somehow Alice, somehow there is a transaction that gives the coin to Bob, and Bob starts transacting with this coin, there's an invalid state. And if Bob, Charlie Dillon, aren't malicious parties, they will check the coin's history, but they're trying to steal the coin. So Dylan tries to exit, and at this point, at the seven day period, Alice can say, no, I am the latest of the owner of the coin.
00:21:13.070 - 00:21:49.786, Speaker A: In this example, what you can do is that you can actually respond to the exit. So this is the interactive challenge. The previous two, they were non interactive. In this one, when you make an exit, when you make a challenge, you leave also some amount of time to respond, because if Alice made an invalid exit, an invalid challenge, somebody should be able to respond. So that's where the red arrow comes in that you should be able to bridge. Essentially, you should prove that there is actually a spend from Alice to Bob, and it validates her challenge. And there can be a number of these, so you can have multiple challenges within valid histories.
00:21:49.786 - 00:22:36.222, Speaker A: And the final result is that you can only finalize the exit when it has zero challenges. So from my experience towards building a client, it has been a pain to actually keep on. The implementation part has been a pain to actually keep the plasma contract and the plasma chain in sync, because you have essentially cron job which submits block to the main chain and to the ethereum, whatever you want to call it. And the thing is that essentially you mustn't make any synchrony assumptions at any time. Like any state that is in chain, it must be checkpointed. But if there is a delay, or if for some reason the cron job submits a block twice, your chains are out of sync. So the main chain contact gets at block ten and the plasma chains at block nine.
00:22:36.222 - 00:23:14.086, Speaker A: So that's bad. And that also relates to the second bullet point, that whenever you're listening, so the plasma chain actually listens for main net events to actually modify the state. And you need to apply them in the right order, because if you don't, the state will be botched. And so it's a problem on the client side. So this was on the operator side, let's say, to have a correct, honest operator software on the client side, you need to also, like whenever you go offline, you need to save the block that you went offline. And when you go back online, you need to check everything that happened while you were offline. It sounds like bad, but it's actually what happened with full nodes.
00:23:14.086 - 00:23:41.762, Speaker A: But I guess it's our approach towards full nodes, but with very light clients. And yeah, I'm very much of the opinion that you need to keep the client light. If you need to store too much data on it, it's bad. But also you need to be able, like, yeah, just cache the data. So if you download some data, just keep it there and don't discard it. This may sound obvious, but yeah, so we should be able to do better. So currently this is like better is the enemy of good, good is good enough.
00:23:41.762 - 00:24:13.614, Speaker A: Currently it is workable, it is done, but we want to do better. We want to reduce the two main problems that we want to solve is reducing the coin history and making fungible payments. And this is pretty much what the plasma prime construction is. So I'll just give a brief overview of what happens. So the non fungible coins, it's a double edged sword, because it gives you this nice security provider, but you cannot make the payments that you like. So the one approach is that you have a chain provider. So I send Jeff like seven ether and gives two back to me.
00:24:13.614 - 00:25:02.294, Speaker A: But you need an atomic swap construction, which before plasma prime, plasma prime, the dream, it didn't exist. The other approach, it was the plasma debit by Dan, who I love Dan, but he's not here. Plasma debit, which basically, instead of a coin, like having a certain value, it can have any value between zero and that value. And you can think of it as a liquid, like a liquid that goes from zero to that to its max capacity. And essentially, if you're able to reduce the one like liquid by a certain amount and increase the other one by another amount, essentially you have simulated a transfer from these two. It's very neat because it also has the notion of transferable payment channels. Because if I have a coin, if I own a coin that is like, with some balance, and I transfer it to somebody else, it's essentially that guy who has, who has the payment channel now.
00:25:02.294 - 00:25:54.170, Speaker A: So it's very, very convenient. And the final approach, which is the cash flow defragmentation, prime, whatever, is that I deposit, like one ether, and instead of depositing one ether, I get 100 0.1 ether coins and I can move them around and so on. But the problem with that is that if I have, let's say like ten coins in a row, and I send the middle coin, suddenly I have two, like, I have two subtrees. And the whole technique, the efficiencies of this technique is that you can exit multiple coins by exiting a subtree, by proving it with whatever magic. And the other approach is like, how will we reduce the history? Right? So firstly, the checkpoints TLDR it's like you have a coin, and instead of validating from its deposit, which is like 10 million blocks ago, you validate up to the last checkpoint. So you pick the checkpoint range to be manageable.
00:25:54.170 - 00:26:56.078, Speaker A: However, I claim that this requires too much social coordination, because it involves the operator, advertising, it's complicated. And the other approach is that you can simply make less frequent commitments. But this hits on your throughput and your capacity, because you basically say that if I have like 1gb of history and they commit one time every 15 seconds, it makes sense to say that if I commit one time every minute, the coin history goes down by one fourth to the one fourth, the other approach, to use the probabilistic structure, which is the bloom filters. But if the bloom filter has false positives, and it was shown recently that you can actually pollute the bloom filter. Yeah. Another approach is the accumulators. So with the accumulators, what you do is that the goal with accumulators is that you succinctly prove the inclusion or non inclusion of something, and you use either RSI accumulator, which is the current approach that people like, or there's another alternative, which is paying based, which I would like to discuss at the plasma.
00:26:56.078 - 00:27:27.660, Speaker A: Call live later. And the final thing is that magic black box snark stark toolkit, which I was at the stark presentation yesterday, and I was informed that it is possible to actually do batched proofs and everything we need, like with starks, in a realistic timeframe. So that will be lovely if we can have. Okay, there is this other thing. So currently the UX sucks. You need to wait seven days to exit the coin. If you need to exit the coin, my opinion is that you don't need to exit the coin, but it must be there.
00:27:27.660 - 00:28:06.886, Speaker A: So what you can do is that you can literally tokenize the exit. So I make an exit, instead of owning the exit, I can get an ERC 71 or whatever, non fungible, and I can sell that around. And whoever owns that coin, it's like a coupon, and you can send it, and after the exit period has passed, you can withdraw it. And the whole construction is that this creates a whole market for exits, where instead of like if I'm exiting five etH, essentially, somebody else is probably willing to buy my coin for 4.95 eth, because they have a lower term preference. And this party, it makes sense to say that it will be the operator because they're running the chain and they don't care. And they also run a full node anyway, so they know what's valid and not.
00:28:06.886 - 00:28:50.410, Speaker A: And the second one is the optimistic exit. So when exiting, you need to provide mercury proof signatures. Whole lot of stuff. It's a lot of data, so that the gas can go from 100,000 to like 200,000 and maybe more, depending on your proof size. Alternatively, what you can do is that you can assume that the exit will be valid and add one more challenge, the crypto economic approach, which it's nice because you can essentially reduce the cost of an exit, like sixty k gas, like for two store operations. But you add another challenge. The final takeaway from this presentation, the technical stuff, it's solid.
00:28:50.410 - 00:29:19.854, Speaker A: You should look into it, it's not complicated. And talk to me for learning about it. Plasma doesn't improve finality. So this whole 1 million transaction per second dream, it's not real. What you do is that you increase the capacity that you can force per 15 seconds, because currently, if ethereum can handle, what is it, like 9 million gas per block or eight, what you do is that you can put the whole information that happened on the plasma chain in 32 bytes, installing 32 bytes. It's cheap. So if we had like multiple plasma chains, yeah, okay.
00:29:19.854 - 00:29:48.938, Speaker A: The scalability can be 1 million transactions per second, but it still settles every 15 seconds if the data is made available. And yeah, essentially, just think of it as a compression, literally. Maybe not because you assume a decompression mechanism, but the thing is that you just take everything, you put very little data on it, and if you follow some certain rules of the protocol, like watching, you're good. And yeah, it's a noncustodial side chain. Thank you very much. And these are the repositories. Go check them, break it if you can.
00:29:48.938 - 00:30:43.514, Speaker A: Yeah, and have it take any questions, maybe is there a microphone? Thank you for your talk. What's the problem with allowing atomic multiple transactions to be atomic within one plasma block? Because you cannot force the operator to include both. So what you can do is that you can construct a game where one transaction is dependent. What you want in atomic swaps is that atomic is a bad word actually. So like either both happen or non happen, right? So this matches your exchange use case, I guess. So the operator, you need to force them, if they include one transaction, that either they must include the other one, or if they include the one and they don't include the other one, that one is invalid. Right.
00:30:43.514 - 00:31:07.060, Speaker A: And you can do this by essentially like doing a two step game, similar in the classic atomic swap construction between chains. You commit to a pre image and you give the pre image to each other and you reveal. But yeah, maybe Carl is better to ask in depth on how the atomic swap works, because I haven't been looking the prime how it's been done. Okay, quick if it's quick.
00:31:07.670 - 00:31:19.686, Speaker B: So I'm from Doc, we are a data exchange protocol, and we were trying to enable micro payments using plasma cash and we did a poC, so we came up with the approach. But I want to know your thoughts. How do you think micro payments can be enabled using?
00:31:19.788 - 00:31:29.274, Speaker A: Why don't you want to use the payment channels is my question. You have the engineering toolkit and you need to use the right tool. I do not believe that plasma is the right tool. Okay.
00:31:29.312 - 00:31:34.906, Speaker B: Plasma cash. Okay, so you're saying using the state channels probably is a better way?
00:31:34.928 - 00:31:35.606, Speaker A: Payment channels.
00:31:35.638 - 00:31:36.634, Speaker B: Payment channels, yes.
00:31:36.752 - 00:31:42.630, Speaker A: I think Giorgios needs a lot more credit for actually implementing plasma cash, which is pretty amazing. So thank you, Giorgios.
