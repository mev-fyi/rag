00:00:14.250 - 00:01:05.940, Speaker A: I'm working on the Ethereum foundation, at the Ethereum foundation on the project Sourceify. And today I will be talking about how we can enable more human friendly contract interactions using Sourcefi. Wave patient I'll start with showing you guys something you're all familiar with. I would say if you're a Webtree user for a while, just a normal day in Webtree, and I guess this will be like something you see every day, and you see every day in Webtree. You see things like this and you basically have no idea you're not a machine, you don't understand what's going on. You're trying to make sense of it. Am I doing the right thing? Am I talking to the right contract? Is this doing actually what I want to do? And basically what you do is telling them to shut up and take your money like you have no idea what's going on, you're just giving out your money.
00:01:05.940 - 00:01:50.320, Speaker A: And we say today, a typical web3 interaction is still a Yolo signing nightmare. What we call Yolo signing. It's just they give you things to sign and you just sign and hope for the best. So at the end of the day, what we want to have is more to do something on the right hand side, from left hand side to right hand side. So I know this has changed actually for many wallets. So many wallets actually started to decode things like metamask, using truffle and decoding the API. But still, we have a long way to go and we have a lot of things that we can improve the user experience.
00:01:50.320 - 00:02:33.294, Speaker A: So what can you do to achieve this? There are two sides of this coin. So there are things you can do as the wallet developer, and there are things you can do as the smart contract developer. So let's dive in. What you can do as a smart contract developer, the first thing you can do is using the nut spec documentation and as well as doing the source code verification on sourceify. So what is nutspec documentation? Natspec documentation is what is called Ethereum natural language specification format. It's actually part of the solidity spec. And probably you have seen this, if you have seen a contract before, this is how it looks like.
00:02:33.294 - 00:03:29.946, Speaker A: You put the comments, the documentation above the function, and you have the developer documentation, you have the user documentation with the at notice field, and you have the documentation for the parameters. So another nice thing about Natspec is it has the specification for dynamic expression. So the fields you see here, the old owner and new owner parameters in back quotes, these actually can be filled dynamically with the value they are being called. So this replaces the owner, blah blah. The address gets filled, can get filled, and the new owner also get filled in the parameters. Okay, so you did your job. You made the user documentation, developer documentation.
00:03:29.946 - 00:04:06.358, Speaker A: So where do you find it then? Where can I find it is in the solidity contract metadata. So who actually knows what solidity contract metadata is? Anyone? Just a few people. Cool. That's why I'm here. So contract metadata is actually something introduced early on in 2016, in the earlier versions, but it was actually not really picked up by the community. It is actually a json file generated by the compiler itself. And it contains the metadata.
00:04:06.358 - 00:04:42.626, Speaker A: Okay, but what is metadata? It has the API, the user doc devdoc, as well as compilation info and source file info. So the first two fields actually is concerned with how to interact with the contract. So how to interface with the contract. And then the second two is about how to reproduce a contract compilation. So it embeds the information during the contract compilation so that it can be reproduced. The file looks like this. It's a json file.
00:04:42.626 - 00:05:20.980, Speaker A: It has as said, it has compiler language settings, source file information. And here for example, in the output you can see the user doc and Dev doc. And if we open those fields again, you have the methods. And with the methods for each method you have the notice field or the dev doc field. If there's a Dev doc and you have the, for example, in this case the replaces the new owner with the old owner with new owner. The comment we have seen before. You can get the metadata with the metadata flag on the compiler itself.
00:05:20.980 - 00:06:01.418, Speaker A: With the frameworks you can find it inside the build files. So trefl for example, puts this inside the build contracts, the contract name JSON. Under that you can find the metadata fields and the metadata is there. Hearthad also started to output metadata inside the build file. Again, you can find the metadata here. Yeah, you can also find the traces of the metadata inside the bytecode. So the bytecode, this is an example, contract bytecode.
00:06:01.418 - 00:06:44.640, Speaker A: And the bytecode has actually a special field at the end of the bytecode. It is appended by the compiler. Again, a question, who knows what this is? Okay, again, just a few people. And again, that's why I'm here. So this field, the compiler actually takes the ipfs hash of the metadata file, the file we saw, and it encodes the ipfs hash of that file here alongside some other information. Maybe I'll pull this as well alongside some other information. And yeah, you can see how this works in our playground playground, source five dev.
00:06:44.640 - 00:07:12.600, Speaker A: We basically show how the encoding is done, what the encoding contains. And we also try to metadata from IPFs. It's already there. So it's a nice tool. There are some example contracts you can click on or you can just provide us with the contract address or just paste the contract bytecode and we will try to visualize how this thing works. All right, let's go down to the second thing. Source code verification on source five.
00:07:12.600 - 00:08:13.318, Speaker A: But before, what is source code verification? So this is for all of you know, this is like, you probably have seen this. If you have seen a contract before and you see a green check mark, you're happy, you know of the contract, right? Okay, but how does this work? Maybe before that. The reason we need, why we need source code verification is that the contracts actually live on blockchain as bytecodes. We humans write code in human language, but the machines read it in bytes. So the code gets compiled and deployed to the blockchain and this information is lost in the process. So we need to somehow make sure just a random code you see is actually the code behind the contract. So that's the process of knowing this code is actually the one that is running the contract, is source code verification.
00:08:13.318 - 00:08:56.850, Speaker A: So how does this work? You have the contracts solidity files. In this case you have a target contract. You also have compilation settings like the version, the optimizer settings, the other things. And we feed those into a compiler and we recompile the contract. And remember, this is actually when the second part of the metadata data information comes in handy. So we use this compilation info to reproduce the compilation of the contract again. So we feed this to the compiler and the compiler gives us a bytecode and we also have the contract that we want to verify.
00:08:56.850 - 00:09:29.234, Speaker A: So we get the code of the contract from the blockchain. This will give us a bytecode. Then we'll see if these actually match. And in sourceify we also have two types of matches. We have the partial match when bytecodes match. And we have the full match when both the bytecode and the metadata field match. So right now, today when you are verifying on ether scan or any other verifier, they actually ignore this field.
00:09:29.234 - 00:10:02.030, Speaker A: Like they don't make use of this field, they just trim it out. And actually that, there have been cases that this was exploited. So it wasn't a serious thing. But this wasn't really doing, was being done properly. But yeah, with the full match you have a complete match of the bytecode. And here the metadata actually acts as a compilation fingerprint. So if you match the metadata as well, it means the compilation is exactly the same as the original as when the contract was deployed.
00:10:02.030 - 00:10:58.094, Speaker A: And the full matches actually cryptographically guarantee that the whole compilation is exactly the same, including the solidif files, comments, spaces, variable names, anything like even if you change a space, a variable name, it will break the match. So how does this work? Let's see how this actually works again. When you are compiling your contract, the compiler takes the hash of each file, each solidity file. Then the hashes of these files are actually embedded inside the metadata file, the metadata file that we saw as well as the other sources, not just one. Then as said, the compiler takes the IPFs hash of this whole file and then this ipfs hash is embedded at the end of the bytecode. And then we see if these match. If it's a full match, it's a match.
00:10:58.094 - 00:11:22.406, Speaker A: It's a full match if they match. And let's see what happens when you change something. When you make a slight change. Change a space, change a variable name, any comment. So we have my contract diff this time. So the hash of the file will change. Then the hash inside the metadata will change and in turn the hash of the metadata file itself will change.
00:11:22.406 - 00:11:46.666, Speaker A: So this field will be different this time. And that means this will not be a full match, but this will be a partial match. Assuming you didn't make a change, that will change the functionality of the contract. Just say comments or variable. Okay, but then how to verify. So you can use the Sourcefi Ui. You can give us the source code and the metadata file.
00:11:46.666 - 00:12:15.746, Speaker A: We need the metadata file to be able to verify either from your computer or etherscan remote GitHub however you like. Then you give us the contract address contract chain. We try to verify. You can use the API, we have an API endpoint and other several API endpoints as well. You can check them out in docs, sourceify dev. We have some detailed docs about this and we also have the tooling. So if you are using Hardat, there is a hardat deploy plugin.
00:12:15.746 - 00:12:45.150, Speaker A: And with the plugin after you deploy the contract you can just pass the network back and then say sourceify and easily verify your contract. We have the remix plugin. If you are using remix you can provide the contract address, the chain. Then we will verify. We recently have foundry support. So using foundry you can also easily verify your contracts. And we also have some automatic verification.
00:12:45.150 - 00:13:20.566, Speaker A: So what we call monitor. So we have a monitor running that is listening on several chains. We are right now listening to Ethereum mainnet testnets as well as some roll ups as far as I remember. So the monitor, what it does, it catches contract creations and then when it finds a contract creation it will fetch the metadata. As you remember, it's like ipfs hash is over there. So it will get the IPFs hash, try to fetch it from IPFs. And also the metadata file has the source hashes, source IPFs hashes.
00:13:20.566 - 00:14:00.540, Speaker A: It will try to get the source files from IPFs as well. If it finds them then it will automatically compile and try to verify the contract. So that means actually the second step here, the source code verification on sourceify has become publishing your metadata. So you don't even have to take the extra step and go to sourceify and verify your contract. If you just publish it and pin it on IPFs, we'll just do it for you. Yeah, so we have this contract repo of all verified contracts. It is served over HTP and IPFs under repo sourcefied dev.
00:14:00.540 - 00:14:37.640, Speaker A: So we pin the verified contract source file and the metadata so that they will be accessible by decoding the bytecode. So here, remember there is the ipfs hash here and anyone, if it's verified on source five, we will be pinning it. And there are other people pinning our repo as well. So they will be accessible by their ipfs hash. And yeah, we also served repo under an IPNs name, repo source by dev. So you can also see the contract repo and see the files, access all of them. Download the whole repo if you want.
00:14:37.640 - 00:15:21.380, Speaker A: Okay, so we have seen what you can do as a smart contract dev. Let's see what you can do as a wallet developer. So maybe a short recap what we are trying to do again, so we have a contract call, we are talking to a contract and instead of this byte string we want to show something more user friendly. So one thing to do is obviously to decode this call, this byte string call via the API jSon. You can show the function name, the variable names, et cetera. And then you want to show some human readable description of what the user is trying to do. If you have documented your code well.
00:15:21.380 - 00:16:00.574, Speaker A: So what you can do as a wallet developer, you go to sourceify your repo sourcefy dev. You get the chain ID, the contract and the metadata. No, please don't do that. You don't come to us because it's already on IPFs. And the neat thing is it's content addressed. So you know the file you're getting is actually the right file. So your wallet just gets the bytecode of the contract, decodes the ipfs hash here at the end of the bytecode, fetch the metadata that we pinned it for you.
00:16:00.574 - 00:16:43.866, Speaker A: And the metadata file has, as we have seen, the ABI and the documentation. Yeah, this is where the first two fields come in handy, how to interface with the contract and then decode the API and populate the nut spec comments of the contract. So hopefully at the end of the day we will have something more on the right rather than something on the left. But sourceify is actually not the only way for human friendliness. The idea behind sourceify is to have human readable descriptions via nutspec comments found in the metadata. There are other ways to achieve this as well. One is for example these two eips by Richard Moore and Nick Johnson.
00:16:43.866 - 00:17:26.182, Speaker A: So the idea there is to have an extra function, name an extra function, a describe function, so to say that will return the user something unreadable. So it can be anything, any custom string. And the contract will return the string to the user and continue executing the actual function. And here the nice thing is it can decode things like ens commits. That is, normally it's a hash commit and it doesn't have a meaning to the user. But you can add actually some more custom strings, custom messages to the user that they can make sense of it. But obviously this costs extra gas.
00:17:26.182 - 00:18:00.178, Speaker A: The other one is proposal by Dan Finley. There the idea is to give the user this information at the first point of contact. So say you want to do an exchange for the first time at uniswap. Uniswap app. Uniswap will give you the contract metadata. Your wallet will store it and then your wallet will have the ABI and the describers so that it can show you something more human readable. The advantage here is it's backwards compatible.
00:18:00.178 - 00:18:27.854, Speaker A: So we don't need to change the contracts. Right now most of the contracts don't have any documentation or anything or they are not actually documented with the human friendliness in mind. So this will be backwards compatible. But at the same time this means it's mutable so it can be changed. So it's a trade off. And also there are many ways to do better. UX so we can actually show the users many things.
00:18:27.854 - 00:19:22.970, Speaker A: So you can decode the contract call. You can warn if the user has never been talked to this contract, show the user if the contract is verified, block if it says scam, address many things as well as other types of things such as how many times this contract was interacted with, when was it deployed? Because a scam contract would be likely more recent and less interacted with. Is this contract audited, and is it audited by whom? So there are actually many ways we can do better. So as a recap, what is sourceify? Technically it is an open source automatic smart contract verification service. Our monitor. It's a user interface server API and tooling to verify contracts manually. It's a public decentralized content address storage of verified contracts, our repo and more generally.
00:19:22.970 - 00:19:58.218, Speaker A: We are a base layer and a public good for other tools to build on top of us. And we are an initiative to foster the use of solidity metadata, Natspec and full verification, and as well as we are an ongoing effort to improve smart contracts, UX safety and transparency. So thank you for listening. If you're interested you can find us in Twitter, join our matrix chats. Our code is also at here ethereum sourceify, visit our website and yeah, I'll be happy to take any other questions if you have. Thank you.
00:19:58.304 - 00:20:05.066, Speaker B: I'm wondering how well these solutions can handle translation and internationalizations to provide descriptions in multiple languages.
00:20:05.178 - 00:20:33.330, Speaker A: Yeah, that's also one consideration there. We have the idea of maybe having a custom natspec field for translations, and in that field you can actually link to another translations file. So that will be inside the metadata, for example, the translations file, and that will be another ipfs hash so that you can fetch it and you can have other languages and translations.
00:20:33.490 - 00:21:04.100, Speaker C: Are you thinking about UX regression testing automation somehow? Sorry, are you thinking about end to end regression testing automation with sourceify? So being able to include the DApps in the whole cycle of testing how things look like, what can daps do to make things easier for end users to.
00:21:04.870 - 00:21:13.460, Speaker A: I'm sorry, is it having the sourceify at the whole development pipeline, you mean? Or. I'm not sure if I get correct.
00:21:15.770 - 00:21:32.890, Speaker C: Currently, in order for a developer to somehow test the end to end user experience, it's nearly impossible to include the web app and the wallet interaction and the onchain interactions.
00:21:36.270 - 00:21:59.426, Speaker A: I'm not sure if I get the question correctly, but we are more like a, we just say people, here it is, here are the tools, here are the files, just please make use of it so we don't actively get involved in the UX contract interactions or that's not in the complete pipeline, I would.
00:21:59.448 - 00:22:25.450, Speaker D: Say, for user protection. Am I right in thinking that the reputational and statistical characteristics you mentioned are really important? Sorry, who's talking right here because I'm just thinking, and correct me if I'm wrong, but a malicious deployer could create a malicious contract, describe it in a malicious way with Natspec, and then take advantage of the user.
00:22:25.790 - 00:22:58.290, Speaker A: Yeah, I mean, obviously we have the assumption that the contract deployer is not malicious, so we verify the content of the contract. But as I said, there are other ways to do that. For example, audits scam lists. So this is another aspect. So we have like this neutral eye to what's inside the contract and it's up to the community and the other types of methods to actually see it's not a malicious contract.
00:22:58.450 - 00:23:17.020, Speaker B: Thanks for the talk. So, question I had was for contract coverage, is it limited to what's verified on ether scan or in terms of Abis that might not be fully complete? What does Sourcefi fully cover?
00:23:17.950 - 00:23:19.546, Speaker A: What do you mean by cover in.
00:23:19.568 - 00:23:30.026, Speaker B: Terms of contract coverage? Like if someone deploys a new contract, it's not verified on Etherscan. Then do you guys still provide the human readable aspect?
00:23:30.218 - 00:23:49.350, Speaker A: Yes, I mean, Sourcefy is a completely different thing than Etherscan. Etherscan is both a verification service and a block explorer. But Sourcefy is not a block explorer. We are just a contract verification service. And I would say we have different contract sets than scan. So you can actually import, but it's a different contract set.
00:23:49.420 - 00:23:55.778, Speaker B: So even for new contracts, you guys instantly get into the pipeline, verify it, and then make it readable.
00:23:55.874 - 00:23:59.458, Speaker A: Yeah, exactly. Got you. Any contract that is deployed, we can just verify.
00:23:59.554 - 00:24:00.074, Speaker B: I got you.
00:24:00.112 - 00:24:00.362, Speaker C: Okay.
00:24:00.416 - 00:24:18.782, Speaker A: And even also different chains. We have I think like 30 something EVM chains right now. So you can even verify contracts on other chains. But at the end of the day, actually we have support for different chains, but we actually want everyone at some point to run their own sourceify for their own chains. Cool.
00:24:18.836 - 00:24:20.000, Speaker B: Okay, thank you.
00:24:21.090 - 00:24:22.400, Speaker A: Maybe last question.
00:24:23.910 - 00:24:33.540, Speaker E: Is it in the scope of sourceify to maintain reputation of the comments or maybe even validate? The comments actually reflect the code.
00:24:34.390 - 00:24:37.094, Speaker A: What documents or sound here is not so good.
00:24:37.212 - 00:24:49.734, Speaker E: Is it in the scope of sourceify to maintain a reputation score for the comments or to validate? If the comments reflect the code the.
00:24:49.772 - 00:24:51.238, Speaker A: Application commits, you say?
00:24:51.324 - 00:24:53.430, Speaker E: Yeah, the comments comments.
00:24:53.930 - 00:25:13.550, Speaker A: I mean, no, as I said, we are a tool to achieve this and at the end of the day, the developers have to document and comment their code. So they have to keep in mind that this might be a user facing method and properly documented.
00:25:13.970 - 00:25:14.478, Speaker C: Thanks.
00:25:14.564 - 00:25:24.880, Speaker A: Yeah, I think we are out of time. Just find me after the talk. Or also you can find sourceify and reach us out there. Thank you.
