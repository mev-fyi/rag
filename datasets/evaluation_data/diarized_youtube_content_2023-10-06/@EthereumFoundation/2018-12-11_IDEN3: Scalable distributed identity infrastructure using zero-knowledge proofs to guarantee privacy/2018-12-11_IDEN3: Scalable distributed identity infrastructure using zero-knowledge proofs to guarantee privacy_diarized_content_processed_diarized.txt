00:00:00.570 - 00:00:58.560, Speaker A: You. We live in a world where there are very few certification authorities. Most of them are banks, governments, big corporations but we want that each of you, each of us can be a certification authority. That's the main goal of the Iron three project. We want to democratize the certification part, the claiming part. When we are doing a claim, not matter if it's done by a government or if it's done by your fake identity when they are doing a claim cryptographically, this claim is exactly the same. It's a claim that can be proof tomorrow or any day in the future.
00:00:58.560 - 00:01:27.090, Speaker A: Before going deep in what technically we were doing in Iron Three, I would like first to introduce three concepts. I want to introduce what we understand as an identity, what we understand as a claim and what we understand as a proof identity. I don't want to go deep, I don't want to enter in philosophical, philosophical.
00:01:27.170 - 00:01:28.598, Speaker B: Definitions and all that.
00:01:28.684 - 00:02:39.886, Speaker A: I will put you some examples. An identity can be a person but can be a company, can be an organization, can be a dow, can be a government or if you want even can be a sink, can be a microphone, or can be a chair, or can be this room have an identity or a bot. Okay? In our system when we talk about identity, mainly we refer to identities as accounts. We represent identities by accounts in general they are going to be smart contracts, okay? So the address of a smart contract is going to be our identifier of that identity. The next concept is about claim. Claim is an statement if you want an authorized statement, okay? So something that an identity is saying most of the times these stanments refer to other identities. For example, when a university is saying that this student make it mate a degree, this is a standman, this is a claim that the university is doing over that student.
00:02:39.886 - 00:04:07.190, Speaker A: But if you think a little bit you will see that almost anything that we are saying can be not rights, can be converted as a claim. Examples, an invoice that's making a company a like in a Facebook can be an endorsement to somebody else or if you want even a single message, a single email at the end is a claim that I'm doing. As you can see, there are claims that can be public but there are also claims that can be private. Claims is something that we are just saying, okay, and why we want to do claims, why we want to not write claims, mainly because we want to prove those claims sometime in the future. And here is these three actor parties we have the claimer, this can could be the university that's doing the claim over a student and then the student when goes for a job and is proving to the employee that he already had this degree and because there is this relationship, this truthness between the employee and the university. This proof is valid for him. Okay? These proofs can be many kind of proof.
00:04:07.190 - 00:04:10.998, Speaker A: We will talk a little bit later, but can be on chain proof.
00:04:11.094 - 00:04:12.266, Speaker B: If you want to prove to a.
00:04:12.288 - 00:05:03.674, Speaker A: Smart contract off chain proof, when you want to prove peer to peer public proof, when you want to prove to everybody there are many kind of proof but the system at the end works about we are talking about this kind of proofs in item three. What are the goals? What do we want? We want a system that first of all must be private by design and by default. Privacy is an important value of identity. We want self sovereign identity. We want to address the key management. We want to be accessible, usable, we want it to be scalable and we also want to be universal. That is interoperable between the systems.
00:05:03.674 - 00:05:36.840, Speaker A: Okay? Let's go step by step. First, self sovereign identity. What does it mean with that? That means that any of you can create as many identities as they want. And this should be I would say free. Creating an identity should be as easy as creating a normal account. It does not need to have any gas and ether or anything like that. And we say that self sovereign because you full control that.
00:05:36.840 - 00:06:29.930, Speaker A: And the same way that happened with when you hold a normal account in Bitcoin you need this responsibility of keeping the keys. If you lose the keys in some way you can lose the responsibility. The same way that in Bitcoin or in Ethereum, if you lose the keys you lose that. So because this responsibility we need to work a lot in the key management, okay? And this here we share a lot of the problems that any wallet have here. As you can imagine, the key should be revocable, recoverable. We are thinking that we don't want the keys to go around that leave the devices. We are sharing a lot of the concepts and we are fully aligned with I don't know if you saw yesterday the Alex Vandersar universal login.
00:06:29.930 - 00:07:14.690, Speaker A: We work in that direction, one key per application. So the key management is an important part of this project accessibility. I think we want to create a system that goes mainstream that everybody should be able to use it. So be easy to be easy for anybody to start working in the system. This is for example and I'm going starting entering a little bit technical how we are doing. We are using this. When you are creating an identity, mainly what you are doing is creating this contefual or this identity contract that you don't actually deploy when you are creating that identity.
00:07:14.690 - 00:07:52.660, Speaker A: But once you create this contract that's not deployed yet, they already have an address. So this already have an address. So this identity is created already. So the people can start doing claims on that and all that without the user having to do anything else that just running at the random dice at some point and creating that identity scalability. And here is where we are going to go deep. We want a system where everybody can create as many identities as they want. But we want a system also that anybody can create as many claims as they want.
00:07:52.660 - 00:08:41.154, Speaker A: And to scale that in a global basis so that there are millions of claims in the world. We need to apply some techniques that I'm going to describe next to explain that how we anchor the claims in the blockchain. What we are doing mainly is if I want to create many claims, I put all those claims in a database I take this database, I construct a merkel tree of that database and I just publish with a transaction the root of that merkel tree on chain. Every time that I have new claims, I have changes, I could change the.
00:08:41.192 - 00:08:45.890, Speaker B: Root, I would change the root of the database on chain.
00:08:45.970 - 00:10:15.534, Speaker A: As you can see this is scales very well for identities that makes a lot of claims example a government in a government there are many things that happen in a country. There is people that get born, people that die, people that get married. People that change their addresses. So the government just with a single transaction per day could update the full database if you want instead of one per day 1 /hour or one every five minutes but this is quite cheap for the government just to keep millions of claims database. Okay, but what happened when an individual user a normal user just wants to do one 2310 transactions per day. Should they do ten transactions if they want to make just ten claims? And here is when we introduce the indirect claims what's the indirect claims here we introduce a relay. So when a user wants to create a claim, let me for example, saying, okay, I like this picture, this is a claim that I want to do, but instead of creating a transaction updating my root of claims, what I do is I'm telling to a relayer let's think for a moment that this is a trusted relayer.
00:10:15.534 - 00:11:57.570, Speaker A: We'll see that that's not necessarily but if it's a trusted relayer, I'm telling to the relayer, hey, relayer, I want to say I want to claim that I like this picture. So the relayer what could say is say, oh, Jordy makes a claim that says Jordy's saying that he likes that picture, okay? This would be an indirect claim, but instead of doing claim by claim, what I'm really asking to the relayer is just to update my root of claims hey, relayer, please update my root of claims. So the relayer just take that root of claims and publish as a claim inside that and you see this merkel tree that depends on the other merkel tree, okay? But this system as you can imagine requires a truthness between the user and the relayer. So in order to solve that, what we are working is an a truthless relayer. So what's a trusted relayer? A truthless relayer is a relayer that cannot cheat. It's a relayer that I can tell to the relayer, and the relayer cannot publish anything in the on chain to ensure that the relayer is publishing. When the relayer is publishing that on chain, besides the root, it also adds a zero knowledge proof that guarantees that this claim or if you want all the claims that are updated in this change, follows specific rules.
00:11:57.570 - 00:12:50.414, Speaker A: So in this way the user has the warranty that the relayer will not shit, what do we mean with that? Of course the relayer can stop working. Maybe we have maybe or maybe you don't get any proof from the relayer. Of course, the users also can always can change of relayer and maybe change another trusted relayer. But if you get a proof from the relayer, you know that this proof is valid. Valid means that if this proof says that you claim it something, you can be sure that this user claimed something. Or the other way around, if the proof said that you didn't claim something, then you can be sure that the user didn't claim didn't claim that. Okay? And as I told you, to use that to work with that, we need to create this zero knowledge proof.
00:12:50.414 - 00:13:04.006, Speaker A: As you can imagine, if you want to scale that, we need to create this big constraint circuit to create as many claims per transactions. And this is where we are working. Later we'll explain a little bit the.
00:13:04.028 - 00:13:08.338, Speaker B: Update on the zero knowledge proof state zero proof status.
00:13:08.514 - 00:14:14.314, Speaker A: And let's go to the privacy part, because here we are also using zero knowledge proof. But this is just to prove things without revealing the full identity. Imagine for example, that I want to enter to a nightclub, I want to prove that I'm 18 years old, but I don't want to tell to the entry people who am I, where I live and all the information about that. So I can make a zero knowledge proof. That proof that I really hold a key that according to the government, I'm 18 years old, but without revealing anything else about my identity. The same thing happened, for example with anonymous voting. When I want to vote, I don't want to reveal my identity, I want to vote, but I need to ensure that I can vote, that I can vote that somebody claim it, that I can participate in that voting.
00:14:14.314 - 00:15:31.490, Speaker A: Okay? So this can be used for a voting system. Another example that implies, for example, a smart contract would be an ICO. Maybe an ICO requires that the people that participate in that ICO is authorized by a third party because some KYC, some legal stuff, I can create an ICO, a smart contract ICO that accepts zero knowledge proof that guarantees that the people that participate that it's okay, it's in the list. It's now to write this person, but without revealing exactly who am I or even how much money I spend on that. ICO another interesting things that we are doing is this concept of non reusable proofs. What's a non reusable proof? Imagine that I belongs to a political party according to the political party. So the political party maybe makes a private claim on me that I belong to political party.
00:15:31.490 - 00:16:35.290, Speaker A: I want to prove him that I am from that political party. But what happened if he just published this proof to everywhere in the world? Everybody would know that I am from that political party. A non reusable proof is a proof that I can send it to him and I have the warranty that if he published that, it will not prove nothing. Of course he can always say that I'm from that political party and it's information that he knows, but he will not be able to prove how we do that. Mainly is we are taking the proof I'm from that political party and I'm creating like another proof that says okay, I am proving to you that I am from that political party or I know your private key. Of course I don't know his private key. So he is sure that I am from that political party.
00:16:35.290 - 00:17:19.434, Speaker A: But what happened now when he published that to everywhere else, he's saying proof is saying jordy is from that political party or I know my private key because everybody knows that he knows the private key. It's obvious that he can generate as many proof of those faking even if I'm or I'm not from the political party. So this proof is not usable anymore. So here is more or less the technical details of what we are doing. Of course, identity systems like this are.
00:17:19.472 - 00:17:26.982, Speaker B: Required in, if not all, most of the applications in the space. There are many use cases from reputation.
00:17:27.046 - 00:17:38.446, Speaker A: Systems, directory systems, simple sign ons. I would say that almost any application that you think that there is like.
00:17:38.468 - 00:17:42.800, Speaker B: A login password will require an identity system like that.
00:17:45.190 - 00:17:53.266, Speaker A: What's the status of the project? Well, we have been working very hard for the last four, five months. So it's a very young project right now.
00:17:53.368 - 00:17:56.626, Speaker B: But what we have achieved right now.
00:17:56.648 - 00:18:00.050, Speaker A: We already have a fully functional wallet.
00:18:00.730 - 00:18:08.518, Speaker B: Wallet for identities where you can see, where you can create your identities. You can start doing claims, checking the.
00:18:08.524 - 00:18:15.626, Speaker A: Claims, proving the claims and so on. We have a relayer right now, it's still a trusted relayer and we have.
00:18:15.648 - 00:18:21.406, Speaker B: Been working also in the zero knowledge technology. For the zero knowledge technology, we right.
00:18:21.428 - 00:18:26.110, Speaker A: Now just created a couple of tools. One is a circuit compiler.
00:18:28.690 - 00:18:44.466, Speaker B: It's a language where you can create zero knowledge circuits. And then we have another tool that's called Snarkjs. That's just a simple JavaScript implementation of.
00:18:44.488 - 00:18:50.662, Speaker A: The Zitkas Narcs right now. Currently we are working hard in trying.
00:18:50.716 - 00:19:02.620, Speaker B: To scale the generation of Zikas Narcs proof. We are working with different people in the community and so on. Mainly the idea is to try to.
00:19:02.990 - 00:19:05.100, Speaker A: Our goal right now is to create.
00:19:05.790 - 00:19:21.418, Speaker B: 1 billion constraints in 10 seconds. That's our goal. And we are working with different technologies, GPU, FPGAs and different technologies and seeing and trying to check which one is the best one for that. And that's mainly my presentation.
00:19:21.514 - 00:19:35.038, Speaker A: Here are some takeaways self sovereign identity should be a scalable. Privacy by design. We have this wallet and this key management early version.
00:19:35.134 - 00:19:37.254, Speaker B: If any of you is interested in.
00:19:37.292 - 00:19:39.446, Speaker A: Checking and having a demo here, there.
00:19:39.468 - 00:19:48.130, Speaker B: Is a bunch of people with my shirt. They will be glad to explain it to you. And also focusing standardization.
00:19:48.210 - 00:19:51.274, Speaker A: Standardization is something that we have not talked very much.
00:19:51.392 - 00:19:55.690, Speaker B: But yeah, we believe that the system.
00:19:55.760 - 00:19:57.270, Speaker A: Should be very standardized.
00:19:57.350 - 00:20:03.694, Speaker B: That's why we are just an association. It's an open source project and we want to work and contribute as much.
00:20:03.732 - 00:20:06.494, Speaker A: As we can to a world where.
00:20:06.692 - 00:20:10.686, Speaker B: Everything is more or less standardized and the systems connect one each other.
00:20:10.788 - 00:20:12.122, Speaker A: And that's my presentation.
00:20:12.266 - 00:20:13.200, Speaker B: Thank you.
00:20:21.490 - 00:20:26.022, Speaker A: Yeah, thank it.
00:20:26.156 - 00:20:29.640, Speaker C: We have a fair amount of time for questions if anyone has any.
00:20:34.490 - 00:20:51.200, Speaker D: Yeah, I just came back from the Internet Identity Workshop in California and it was great. It seems like a lot of these conversations are happening around identity and the Internet right now. It's awesome. I was curious if Ident Three has a did method to be compatible with the did spec.
00:20:52.130 - 00:20:55.054, Speaker A: Yeah, did is just a standard for.
00:20:55.092 - 00:21:16.200, Speaker B: Referring to the identities. Of course it's absolutely compatible because even there are some specific standards for ethereum based identities. So yes, I would say that the current standards are applicable. The main problem of the current standards is that all this zero knowledge technology.
00:21:18.090 - 00:21:20.582, Speaker A: Is not very much on their main.
00:21:20.716 - 00:21:44.750, Speaker B: And for example, it makes no sense at all to put a JSON parser inside Zikas Narc circuit. So I would say that there are some modifications and some adoptions to those standards that would need to take in account in order to adapt to this new kind of identities.
00:21:48.370 - 00:21:54.370, Speaker E: So if we're application developers, what can we use now if we have a need for identity plugins?
00:21:54.870 - 00:22:39.840, Speaker B: Yeah, I think it's quite ready. But we are building mainly an SDK where all these basic functions of creating an identity, creating a claim, proving a claim, all that should be embed as a black box. So we are working in this library, in this SDK, where applications will be able to build on that. For example, the wallet application is just a reference application. We are working very much in the protocol in the standard, so that even if anybody wants to create an application that holds identities in that site, that should be perfectly possible.
00:22:42.530 - 00:22:58.030, Speaker F: Hi, I have a question over here in the back you mentioned the use of zkSNARKs to alleviate this sort of trusted relayer setup. ZK starks require the trusted setup. Is that a concern or is there anything like malicious you could do if there was an issue with the generation ceremony?
00:22:58.190 - 00:23:58.294, Speaker B: Yeah, Zkasnarks we all of us this is a concern, this is the big critique. I would say that Zikas nars are quite perfect except for that which is a huge issue. Trusted Seraphi is a problem that you have once we are thinking in of course it's something that we are thinking and seeing some solutions on that we have thinking, for example, in using, for example, some trusted hardware to do these ceremonies. Of course there is these multiparty computations on that we need to automate in some way or the other. But the nice thing of the trusted setup is that once you have done that and if everybody believes in that ceremony, it's valid, then the system is good forever. So yeah, we are just analyzing different options of that and yeah, that's one of the weak problems. There are also all these new technologies, STARx for example, that we are also.
00:23:58.332 - 00:24:00.626, Speaker A: Very interested on that that they don't.
00:24:00.658 - 00:24:35.140, Speaker B: Require these trusted ceremonies. And yeah, they are quite better except that when you want to go on chain no, they are huge. I think minimum was, I don't know, kilobytes of data and putting that on chain at least right now is quite a problem. So that's why we are sticking a lot in the snarks. But clearly Starks is a technology that we start looking at and it's another zero knowledge technologies that are coming from the research world.
00:24:39.830 - 00:24:43.000, Speaker C: There was someone had a question in the back who has a mic?
00:24:46.090 - 00:24:47.430, Speaker A: No, he skipped.
00:24:48.670 - 00:24:51.420, Speaker C: Oh, I thought you wanted it. Who got it?
00:24:56.750 - 00:25:21.326, Speaker G: Hi. Maybe this is a longer answer, but I was actually unsure how when the receiver of the identity he exposes the information his private keys you were saying if he publishes the identity that his private keys were exposed or you were saying the sender of the identity their private keys were exposed.
00:25:21.438 - 00:25:48.314, Speaker B: No, the private keys are not exposed and the private keys should not even leave the device. So private key is something that only you hold. And I would say that it's very important in any cryptographic system that private keys keep secret. The only thing that we are transferring from one side to the other mainly are proofs of if you want requests for proofs, hey, please prove me that you are 18 years old.
00:25:48.432 - 00:25:49.850, Speaker A: Here comes the proof.
00:25:50.210 - 00:26:14.958, Speaker B: Okay, so that's mainly what the data that's moving is about proofs. I want to mention something that's important. We have not talked about where all these merkel trees and all this data is stored. Each user should be responsible for their data.
00:26:15.064 - 00:26:17.446, Speaker A: So if I'm doing claims, all the.
00:26:17.468 - 00:26:37.466, Speaker B: Claims that I'm doing with all the merkel nodes all the nodes of the merkel tree. I should care about that data, I can store that data. Maybe there is some people that's comfortable in storing that in Google cloud. Maybe there are some governments that they.
00:26:37.488 - 00:26:38.710, Speaker A: Have their own premises.
00:26:38.870 - 00:27:20.940, Speaker B: Maybe there are solutions that people that want to store that data in an IPFS, in an encrypted way IPFS and maybe using new cipher just to access that data. So there are many options about where the user keeps that data. But in a self sovereign system, user has to take care of his data. Of course we can provide tools in order to help the users. But it's important that we understand that when you have a certain sovereign identity, you own your identity and that means you own your data.
00:27:23.470 - 00:27:32.390, Speaker H: Question so as a developer, obviously I'm very interested in what you're doing. I'm going to take a look at your library. I'm over here.
00:27:32.480 - 00:27:32.830, Speaker A: Okay.
00:27:32.900 - 00:27:58.520, Speaker H: I'm going to take a look at your GitHub libraries as well as your documentation. One thing just to help me when I start that journey is compared to what is being developed by uport in the ethereum space or Sovereign or hyperledger indy on their own chain. How would I think about this effort and this technology in comparison to those?
00:27:58.970 - 00:28:13.158, Speaker B: Yeah well we are different projects that maybe we have different views. We are all of us working together. We are connected one each other and we are just working, I would say more or less in the same direction.
00:28:13.254 - 00:28:15.446, Speaker A: But even if there are different projects.
00:28:15.478 - 00:28:28.030, Speaker B: That are trying to do a little bit the same at the end, the end users, the developers, the people will just be, they will say which is the one most useful to them.
00:28:28.100 - 00:28:33.090, Speaker H: Could you say what do you mean by connected though? Is there an interop layer that you're looking to do?
00:28:33.160 - 00:30:01.002, Speaker B: Oh no, just connected mean that I'm connected with most of the people that's developing and we are trying to, for example the ethereum machicians and in different environments there is to try to generate those standards and those standards that we are aligned on that and trying to get consensus in what are those protocols here. The main problem here is that the technology is not clear yet. So I would say first we need to develop the technology, develop some applications, see how the people is using that, how the system works. And once there is an adoption of those technologies we can start thinking very much in what are the best standards. If we define the standards prematurely it's possible that maybe the standards would not be working and maybe we will have having another de facto standards. So here the tempos are very important. I think it's important that there are many teams that are working in solutions like that or solutions similars to that and keep working and being aware of what all the other teams are doing, just being transparent and the nice thing of open source is that we don't have to hide anything, just talk.
00:30:01.002 - 00:30:11.818, Speaker B: And if there are better ideas as an example, alexander SAR is doing an incredible job in the login. We are just going in that direction.
00:30:11.994 - 00:30:14.574, Speaker A: Maybe there is some security issue that.
00:30:14.612 - 00:30:17.246, Speaker B: We are not what we don't see.
00:30:17.428 - 00:30:17.930, Speaker C: Tell it.
00:30:17.940 - 00:30:28.274, Speaker B: We will tell him, hey, what happened with this? And there will be a talk and there is feedback limitation between the teams. And if we work that way, I'm.
00:30:28.322 - 00:30:29.480, Speaker A: Sure that.
00:30:31.930 - 00:30:33.654, Speaker B: We can get a good consensus of that.
00:30:33.692 - 00:30:44.394, Speaker A: And if we don't get a consensus, maybe it's because there is two approaches that make sense and at the end, the people, the market, the community will.
00:30:44.432 - 00:30:46.762, Speaker B: Decide which one is the best.
00:30:46.816 - 00:30:49.500, Speaker C: One last question.
00:30:50.450 - 00:31:10.690, Speaker E: Hi Jordy. Thank you for work. Really appreciate it. Right here. I was hoping you'd indulge us a little more. I'm very curious about how you made it a one time use proof with a private key. Could you reiterate that one more time?
00:31:10.840 - 00:31:13.970, Speaker B: The one time proof or the proof that not reusable proof, you mean?
00:31:14.040 - 00:31:15.042, Speaker A: Yeah. Okay.
00:31:15.176 - 00:31:16.806, Speaker B: The idea is imagine that I want.
00:31:16.828 - 00:31:20.120, Speaker A: To prove that I am from a specific religion. Okay?
00:31:21.850 - 00:31:31.818, Speaker B: I don't want you just you understand that I don't want you that you are able to prove to everybody else that I am from that religion, but actually I want to prove you.
00:31:31.904 - 00:31:35.734, Speaker A: Okay? So the proof that I'm sending to you is a proof.
00:31:35.862 - 00:31:37.594, Speaker B: So I am proving to you that.
00:31:37.632 - 00:31:41.760, Speaker A: I either I'm from that religion or either.
00:31:43.650 - 00:31:45.454, Speaker B: I hold or I have your.
00:31:45.492 - 00:32:08.760, Speaker A: Private key, which I don't. Okay? So I will be able to create a valid proof if I have your private key or I'm from that religion, because I don't have your private key. The only way to generate a proof of that kind is by really.
00:32:11.050 - 00:32:11.462, Speaker B: Having.
00:32:11.516 - 00:33:01.282, Speaker A: The claim that says that I am from that religion. Okay? So when I send you that proof, you have the warranty that I am from that religion because I don't hold your private key. What happened when you take that proof outside? When you publish that proof, you are saying to the people, walt, Jordy is either from that religion or I hold my private key. So everybody knows that you hold your private key. So you can generate as many proofs as you want if I'm from that religion or not. So this proof to the people is not valid anymore. It's not a valid proof.
00:33:01.282 - 00:33:35.566, Speaker A: Other thing is that you can do a claim saying George is from that religion, but then it's according to you that I am from that religion, not according to the church that I am from that religion. That's the difference. Of course, when I proving something to you, I'm giving some piece of information, okay? But I'm giving to you I'm not giving a proof. So what I'm not giving is the capacity to prove that that information is valid, okay? And I think that's very tricky here.
00:33:35.588 - 00:33:41.694, Speaker B: I have to thank you a lot here to Vitalik, because the idea comes from him in some sense.
00:33:41.732 - 00:33:42.620, Speaker A: But I think it's a cool idea.
