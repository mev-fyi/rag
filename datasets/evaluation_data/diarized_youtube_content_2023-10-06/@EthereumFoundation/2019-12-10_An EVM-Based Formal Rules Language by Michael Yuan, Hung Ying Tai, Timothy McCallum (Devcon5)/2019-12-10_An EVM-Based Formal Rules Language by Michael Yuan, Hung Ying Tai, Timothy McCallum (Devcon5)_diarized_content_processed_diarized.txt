00:00:12.330 - 00:00:48.406, Speaker A: My name is Michael and Michael Jen. You can find me after that. And this is timing. So a little bit about ourselves. So we are a company called Second Estate and why Second State? People come and ask me about that class wise for state we have second why come to a class after that? And so we are open source, one contract technology company, meaning that we try to stay above the convention layer. So we don't want to do sharding and mining and all that. We want to focus on the distribution layer.
00:00:48.406 - 00:01:08.450, Speaker A: That's where our expertise comes from. Required middleware I know it's a data work. The middleware was smart contracting applications. Our focus has been developer tools. We have language compilers for different languages, front end and back end, next generation virtual machines and execution ideas, meaning.
00:01:10.870 - 00:01:11.234, Speaker B: And.
00:01:11.272 - 00:02:12.182, Speaker A: Auction data services, including the search engine, smart contract search engine and exploit and all those. We combine a single web based product for the builder idio, but it does a little bit like remix, but it doesn't require metamask, doesn't require wallets. And you can write your smart contracts, you can write your dash, you can write web stream and everything in single web interface and deploy it on public blockchains. You can do that in a couple of minutes. And people ask, how do you do that without water? Well, there's a way to do it that's something we'll demo today with all those languages standard and excuse you. So we are company in Zurm Classic Labs cohort too. So we are fortunate to be involved in this project.
00:02:12.182 - 00:02:20.790, Speaker A: We partner with other blockchains, cyber mouse and some other enterprise players.
00:02:23.130 - 00:02:23.880, Speaker B: So.
00:02:26.490 - 00:03:23.826, Speaker A: The three of us was involved in this book called Building Blockchain application published by Amazon website later this year, by the end of this year. And if you go to secondstay IO slash book, you can play a little game and do a little discovery on the Ethereum classic blockchain for this kind of. Okay, so to start off our talk, because we have a lot of content, I will set the overall plan or the overall theme of this talk between challenges for solidity. Why developers? We found where developers why developers find smart contracts so difficult to grasp and to write. The first is it's not only just solidity, but all the other smart contract languages currently available on the market. First is the language generic has to be compete. So that means difficult to optimize for domain specific applications.
00:03:23.826 - 00:04:16.474, Speaker A: We come from enterprise world, we know that DSL has always been one of the if you look at the platform maturity, we look at the business as DSL. Domain specific language is very important for real world enterprise use cases. And today in solidity, it's very generic, everything has to be proven complete, so there's no specific optimization for domains. And the second is the design of solidity and other smart contract language today must support both consensus and noncontentus mode. So we ask ourselves why it's so difficult to do string manipulation solidity. Why is that no random number in solidity? Why is that no JSON support in solidity? Because the solidity code has to be able to create transactions on the blockchain. If any of those goes in there, it either creates non deterministic behavior or it consumes too much gas.
00:04:16.474 - 00:05:04.720, Speaker A: However, if you look at from the application developer's point of view, you do need those features. Can we put those features in real functions or pure real functions for code that not participate in? So that separation is unfair in most of the smart contract languages today. So that's where we hope that our innovation should be able to help to try to create language exchanges to address those two problems. Because if you don't have content and non content separation, you are given the lowest common denominator. You have to have all the language features that can. That's not something we think would create good language design. So those are between challenges of solidarity or contract languages today, and those are things that don't address.
00:05:04.720 - 00:05:29.190, Speaker A: Okay, now I want to shift over to Haidai and to talk about how do we address the first challenge. The first is solidity is touring complete, and it's generic. There's no domain specific features in that language. How do we add domain statistic features into solidity?
00:05:30.490 - 00:05:38.920, Speaker B: Okay, let's talk about lazy rules engine. Okay.
00:05:42.650 - 00:05:43.386, Speaker A: I'll do this.
00:05:43.408 - 00:05:43.980, Speaker B: Sorry.
00:05:46.590 - 00:06:18.946, Speaker A: I wrote some of the. So first of all, why do we need a rules in a smart contract? A lot of people ask this question, what is smart contract? Automated scripts triggered by the end, resulting stage change according to redefined rules. So smart contract by their very definition. So it's a perfect match. Like I just said, rules must be transparent, rigid and immutable. Blockchain is the perfect platform to execute rules. Today, enterprise rules are executed inside databases.
00:06:18.946 - 00:06:51.338, Speaker A: And you could argue that's one of the things that blockchain can really change. When you try to make business decisions in an automated manner, you want those rules to be executed in a trusted platform. So blockchain is a perfect match for rules. And the rules engine is essentially a decision tree. Rules could be essentially implemented as a decision tree using different length statements. You can have a large list of different to implement any rules. However, the complexity grow exponentially as the rules increase.
00:06:51.338 - 00:07:37.150, Speaker A: So if you have multiple interacting rules trees that every single change on this side, say you have two trees each have, you have two decision trees and they interact on some leaves, everything that changed on this side have to resolve to a reevaluation of the entire numbers on the other side. So just imagine you have multiple trees like that. So that's why that gives rise to what the enterprise software guys call the rule setting, the business rule setting, Pr E. So the same set of rules might be evaluated again and again and very difficult to validate or make changes. So you might have a rule that gives you more money. It's extremely difficult to validate statement. And it's impossible for nonprofits that someone, a business person wants to change those rules is impossible.
00:07:37.150 - 00:07:53.010, Speaker A: So this is what I just said. So in the enterprise phase, I'm sure those are hundreds of millions of dollars. Some of the public companies, they do nothing but Rosie.
00:07:53.750 - 00:08:35.442, Speaker B: Okay, let's go to the demo section. And first of all, I want to introduce how we do the rules engine into the solidity plugin. As we know, if we want to add plugin, there must be add some new codes or some new instruction. But in our rules engine, we don't do that because we know half or carbon half, that's too many hardware, we don't want to do that. So we just separate that. We add a new grammar code rule and we just build a new parser for it. And new code gen also is compatible with the origin static one.
00:08:35.442 - 00:09:13.246, Speaker B: So if you go to our repository, you can find, we define some rules engine se. And when the parser go inside, oh, there's a rule for example when somebody is too old and they can get some money, for example. So when he goes touch to lures, he will into our culture session. And finally they will combine into one evm by code. So you don't even take care about. There will be two countries or three countries. No, it's just in one country.
00:09:13.428 - 00:09:14.062, Speaker C: Yes.
00:09:14.196 - 00:10:04.250, Speaker B: And the layout will look like that. The original solid country will just in original pass. And our rules will be a new section and we add a new rule engine handler. A new rule engine handler is just like your chrome. We just add rule engine handler into your smart contract. So when somebody execute the smart contract, our handler will try to find all the rules. And you must register some data, what kind of data you want to modify, because there are lots of variable, not every variable need to be modified.
00:10:04.250 - 00:10:34.280, Speaker B: So you want to address that. And our handler will take care of that and just filter out something like rules. So we just go into our demo and this is our website, you can go there and get more example. Yeah, so let me show our website. Okay.
00:10:36.170 - 00:10:39.160, Speaker C: It'S too launch, that's good.
00:10:41.370 - 00:11:36.326, Speaker B: Let me reset it and our first example should be, okay, good. Okay, our first sample is the edge pension that we define a person who has a number of edge and work edge, which means you had this work for a while and back edge for his money. And we define another data structure called baggage. It means the total baggage. We want to share some money to those person. And we have one list called the person list which will store all of the person and total bucket here. And we add a new variable called fact insert factor.
00:11:36.326 - 00:12:37.200, Speaker B: Insert is just like notify our handler, which variable should be monitored in this example that oh, the package will be monitored by our handler and we just say into 10,000 we go through the rule power first. You just write the rules in your contract. And it is like the ruleman, it can be blah blah stream more. It's just a name. And the when block will contain several conditions. You can see, you can say, oh, I want to filter that lot of person whose edge is greater or equal than 65 and work edge is greater than equal five. And also our baggage must have con greater than ten.
00:12:37.200 - 00:13:59.994, Speaker B: And if our handler find that any modifier object is in these conditions, then it will trigger these actions like we will add the person at $10 and just minus our total bucket, $10. And another one is how can we add a new person to here? We can see we have a list here and we create lots of person object and then factor insert to tell our handler to modify this object. And the last action is, we will call the function called the file rules. It will just emit all of the rules and just do these actions. So let me compare it. And before you, first of all, we add a person like, and there's 20, the first one, okay. And we can just check the first one, state up, 64, 21, okay.
00:13:59.994 - 00:14:55.526, Speaker B: And we add the second one is 65 and 22, second one. And the third one, because this work edge is large or equal to five. So we want to add here to just zero. Okay, now we have three person and three different taxes. Now we imitate the pay function and just check all of the person like the zero, but he didn't get any money because it's only 64 years. And the second one, yeah, he gets $10 and the third one, no, he doesn't get $10 yeah. And after all, we can just check the baggage.
00:14:55.526 - 00:15:19.022, Speaker B: It just spend $10. Okay, that's our demo for the rules engine. If you are interested, you can find more examples on our website. They are something nice like tax preparation or. Anymore. Yeah. Good in here?
00:15:19.076 - 00:15:49.450, Speaker A: Yes. Okay, so this retirement age, that was very interesting because I don't know if you guys read a lot about your times. There was a research coming out to say that the earlier you retire, the longer you live. Most people who retire like 15, they live to the 80s. If you retire at 65, you live until you're 67. So it's really important that the government has all these rules. Who gets what during retirement age.
00:15:49.450 - 00:15:53.760, Speaker A: So had I show up, can I get it open here? Sorry.
00:15:58.050 - 00:16:04.420, Speaker B: I can see the line number one. No, this is another example.
00:16:06.310 - 00:16:25.926, Speaker A: So you can see all this. This is actually regular solidity code. And by the way, this tool is builder secondplay IO. You can say build secondplay IO. That's why you don't have to imagine. So this is a development tool that we do. So our compiler is integrated in here.
00:16:25.926 - 00:17:00.740, Speaker A: You can do it on your phone right now. You don't need metamask or anything like that. So this compiles regular solidity code, but the rule setting stuff is added in text. Had I show up, you can see we added keywords like back insert, and the rule stuff is just added to solidity. So we embedded what we call domain specific language inside solidity. And then we have a compiler that compiles to EVM by code that can be deployed into any EVM, into any EVM compatible blockchain. That's just.
00:17:00.740 - 00:17:45.440, Speaker A: I know you guys might have questions. Let's talk afterwards because we have quite a few things in this session. Yes. So the next one I want to bring, and he's going to talk about how we solve the second review report. The first problem is no domain specific extensions for the language. The second problem really is no separation between consensus and non consensus. Can we find a way within EVM one or eks one point x to separate out consensus application and non consensus application?
00:17:48.050 - 00:18:28.714, Speaker C: So you're just talking through this smart contract search engine. So basically we could call this an auxiliary application. And what we mean by auxiliary application is an application that is really assisting the end user of a blockchain application, and it's essentially transforming full node data to make it available to the end user in a useful way. So this is not a second layer solution. It does not play a role in network consensus at all, and it doesn't play a role in updating the blockchain state. So you can consider it like a read. Only one auxiliary application example would be like a bitcoin core wallet.
00:18:28.714 - 00:19:07.974, Speaker C: So as we know, you have the Utxos in the system, the bitcoin states represented by a global collection of unspent transaction output. But the bitcoin blockchain doesn't actually hold the account balances. So a user's account balance in bitcoin notion that's put forward by an auxiliary application, I. E. The wallet. So there's a purpose for auxiliary applications, they are safe because they're really just a helper, right? So it's important to remember that an auxiliary application can't really make the blockchain do anything invalid. So an example is Alice here, she's got two bitcoin.
00:19:07.974 - 00:19:41.154, Speaker C: If she thinks that she's got three, for some reason she tries to execute a transaction that won't actually succeed. So it can't make the blockchain do anything that's not valid. So the smart contract search engine falls into this category of non consensus code. The search engine allows pure view functions to be executed off chain with arbitrary programming languages. And example. This we'll show you in a minute is it's reading the public data that exists. So for example, if there's a public variable, the compiler will create the getters and setters automatically.
00:19:41.154 - 00:20:29.334, Speaker C: It can go in and grab that information automatically. So here's a bit of an overview of the smart contract search engine. Is this component here, it is 100% free and open source in that it's just using basic apache, two analytics operating system already in HTML, JavaScript, and a bit of python using flask. The indexing at the moment we're using elasticsearch, and that's also 100% open source product as well. So the blockchain here reads in the data here and then there's multiple interfaces out to different services from there. So this is a smart contract search engine here, this is a DAP, this is a web browser search, and this is optional third party things like push notifications and so on. We'll get to this component in a little bit.
00:20:29.334 - 00:21:12.866, Speaker C: I'll talk about this. Okay, so the smart contract search engine sits between, sits between the full node and the DAP, and it's organizing raw smart contract data and other blockchain data like event logs and so on. And it's providing essentially like a search and discovery service for the decentralized application. Okay, so this demo, I'm just taking some screen captures. If you go to docs Technostate IO. There's a menu down the left hand side, you'll see this data driven daps here, this here with the first paragraph, it links off to some code in GitHub. And this is HTML, JavaScript and solidity smart contract code.
00:21:12.866 - 00:21:45.514, Speaker C: And as Michael just showed us, this is the build tool that we have. And so you put the solidity code in there, you hit compile and deploy this. So the argument for this constructor here is asking for an account name. So we put in five, underscore, double zero, one, deploy that to the chain. And then what we see in the build tool, when we click the play button in the DAP tab, it will actually deploy the front end of your DAP. So this is what the end user will see. And here we have this account, and I'll put a bally in of one, two, three and we update the balance.
00:21:45.514 - 00:21:52.478, Speaker C: And what it does, the smart contract search engine goes and finds smart contracts on the blockchain that match.
00:21:52.564 - 00:21:53.934, Speaker B: So what we do is we store.
00:21:53.972 - 00:22:34.622, Speaker C: The ABI and then we hash it. So we end up with a deterministic key per ABI. And so the smart contract search engine can go through the blockchain and find all of the contracts that match to that key. And so what it's essentially doing here is finding accounts of contract type x with different names and it's creating the sum total of their balance and then providing that. So a smart contract can't do that to another contract because they can't see each other's data, but the search engine can aggregate. So just move on to this part here, what we call ess. And again, please come and talk to me afterwards because there's too much to say in ten minutes.
00:22:34.622 - 00:23:13.206, Speaker C: So this is the easiest way to access all this if you don't install or do anything with any of the smart contract code or anything. If you just simply go to esss JS as an NPM package and you just install that and then you have instant access to blockchain data. So we're running Ethereum, Mainet, Ethereum, classic, cyber, Miles, Mainnet, cybermiles, Testnet, and then dev chain. So these are already set up. We have some specific premade functions here for your convenience. So for example, you just es search using address and that's the address and it'll return data. The next thing is specific things, search using keywords.
00:23:13.206 - 00:23:47.910, Speaker C: So in this case that variable name the account. We put that in as the data and returns valid jSon. So then your phone can pass this, right? So it's a really efficient way to call data blockchain data and get that back. So instead of your phone having to get 1000 records and loop through them all and do decision making, what you can do is quite a complex query where you can filter out. So like I want to see everything in the last hour from this address with an account name called Devton, and then you'll just get back one record. So it's really efficient. And then your phone only has to process one small piece of JSOn.
00:23:47.910 - 00:24:28.578, Speaker C: Okay, so one of the reasons why this is great is because it's separating out, it's very flexible, but it's separating out the components. So if you have a front end developer that's really different skill set, you can just say to them, Javascript and HTML and CSS. This is what I want my dap to do. From the user's perspective, you don't need to know when they push the button that's going to call smart contract functions and so on. Just don't worry about that. Just code up the front end, the HTML, Javascript and CSS. So it's enabling you to have teams work together similar to the rules engine allows like a business analyst to write rules in rules and hand that off.
00:24:28.578 - 00:24:57.222, Speaker C: They don't need to actually be able to contract the right smart contract code, but that same syntax will apply and just plug straight in and work. So there's a similar concept to that. You can create your own custom queries, you can extend on this to provide like custom push notifications, triggering when amounts go over or under certain values, et cetera. And I'll pull it up there. If you're interested in building your own or using ours, or deploying a DAP creating a product, please get in touch.
00:24:57.276 - 00:25:00.280, Speaker B: And we'll help you back over to.
00:25:11.810 - 00:26:07.540, Speaker A: We have discussed the two challenges and how we address those challenges. One is DSL and the second really is to add new stuff outside of the GBM so that the noncon Windows data can show objects instead of having to come together and be the common economy. However, the future from when we see eks 2.0 we see a really great opportunity to future proof all this because now we could have a unified solution that leverage things like LLVM and webassembly to build a new toolkit and new compilers and new virtual machines so that all this would no longer be a problem. And I'll hand back to Haidai to talk about the work that we do with VM and evadem. And this is a collaboration project between second stage and Plastic lab.
00:26:11.910 - 00:27:09.714, Speaker B: Okay, let's talk about the full benefit when we integrate LvN into our tooltrain. Why is the cars, and first of all, because LVN developed long, long ago, is just like your GCC compile. So if you can support like CPAs or ROS or blah blah blah, you can see that they all will have a front end layer. So we can support more programming language. If you are not interested with just solidity, you want to use your language? Yes, you can use LVN. And the other part is that with LBN, if you want to define a new target, what is new target? Just something like that. We have the EVM one, we have the evolution.
00:27:09.714 - 00:28:23.550, Speaker B: Maybe if one day happens, maybe there will be the evolution, or maybe it will be EVM three or four or five. So LVN provides mechanism that we can very easy to define a new target. And this is independent with your finance, so you don't need to have to translate your solidity directly to the new target. You can use the LBN, it has intermediate format called LBNIR. So every language will be transformed into a uniform language, and then use this language into the different targets. So this is second and surprise that we have lots of debuggers or linkers or power comes in tool chain for the LVN. So when we just integrate LVN into the tool chain, so the debuggers, we don't need to just redo it, we can leverage DB or something like that.
00:28:23.550 - 00:29:56.666, Speaker B: And the first part is, we want to talk about more after then with the LVM framework, we can define a new gas optimization skill that can be just like, because I have uniformat here, and so we can just modify each optimization path, what kind of apply can reduce the gas consumption, something like that. Okay, so the first part is like this, more programming language for evms, and all of those things will be translated. However, it's legit, or rifle, or rust, or debugs, or any front end language, they will be passed and constructed, the SDA constraints. And finally we generate the LVIr, and in the phase we call it optimizer, because we can add lots of optimization here, something like we can reduce the deco, or we can just simplify, lots of addition or multiplication, something like that. And finally, we have a lot of bags for here. And not only EVM one evolution, also we can generate this file into native environment. That's all possible.
00:29:56.666 - 00:31:22.054, Speaker B: Yeah. Okay, and the second part is, I mentioned before, we got a lot of debuggers advanced or something like that, and we can make the performance more higher. And this is our approach to detect the gas consumption and to reduce the gas consumption of the current historical application. Actually in these four charts, we only do one thing, that is we model the LBN IR with the native bicode, so we can know every instruction in high level, the cost is like 100, 200 or something like that. And we can apply lots of difference here, we mapping the assembly to the ewosn or EVM and back into the LBIR. So we have cost model here, and when we have a cost model here, we can apply the traditional energy consumption issue, the optimization of that into this model, and we can just apply those optimization gas into here. And we get more gas optimized by code here.
00:31:22.054 - 00:31:48.800, Speaker B: Okay, so let's go into the demo parts. I will show you how to use our compiler to compile your static code into LBIR and finally deploy into the ebol set. I think for the EvM part it's very quick. I think Adam will very quickly release the demo for us, for the evs market, right?
00:31:49.170 - 00:31:49.920, Speaker A: Yeah.
00:31:50.690 - 00:32:35.710, Speaker B: Okay, so first of all, you need to connect the metamask to the evolution testnet, just down like this. I don't know why, it's a certificate and we can build it once you can get going, yes, you can set the entry and MacBook, blah, blah blah, but detect lots of time. If you use this MacBook, it may detect 1 hour to building it. So I didn't too long. We have dark spot image, so you can just pull it, you can just run it and execution the command in our next slide. And to get micro. So I think I can do the demo.
00:32:35.710 - 00:33:22.080, Speaker B: Double check. Okay, so it's large enough. Okay, my number is back. Okay, now I run the dock image of the Sol demo. And first of all you need to create a contrast and. Well, minute, let me copy it here, I have another copy here. Okay, so just pass it.
00:33:22.080 - 00:34:07.740, Speaker B: As you can see, this is Ert 20 contract. And we have total supply, we have balances, and we have an event called transfer. And here is constructor, you can sell the total supply, you can sell the initialized balances, and also a function called balance off, you can query it. And finally, this is a transfer function. And if you want to add the Stepmax protection, you can just include library and use it, that's fine, but for the demo groups I just remove them. Yes, and when you use Sol, you can get the help menu like this. And no worries, we just will need to compare it.
00:34:07.740 - 00:35:07.114, Speaker B: Action plus it means lvm Sol. And when you cross press enter you get lots of lvir but don't worry about that. You don't need to modify any line of that. You just pipeline this output into a contract. And we have helper in the Sol and ufos and compile plus v and the input contra ll. Okay fo you can see that we use lot of like lb link lbn optimizer llbn compiler and what lb to create the Weber submitted part. And you will get two Whatsapp files.
00:35:07.114 - 00:36:03.102, Speaker B: One is the runtime file called contract WhatsApp. Another is the deploy file called contract deployment. And the final part you want to deploy that into the test center. What should we do? Just back here and you can find ewas and testnet and something like here and just submit transaction because I think that's the only way to deploy your answer there. And because you need to pass your old wash to here. So you need to code this binary file into a string we have provide the comment here. Just copy that and enter.
00:36:03.102 - 00:36:19.480, Speaker B: Okay, you got this lot of string. This is your contract because it's very large. So I need to just scroll down my terminal and what.
00:36:23.370 - 00:36:24.120, Speaker A: Ten.
00:36:27.390 - 00:36:50.960, Speaker B: Here, okay, here and add submit. Then metamask will ask you to confirm it. Just wait.
00:37:01.010 - 00:37:03.982, Speaker A: You bought some test masks return foundation required, right?
00:37:04.036 - 00:38:54.520, Speaker B: Yeah, it's. Don't worry, we have deployed another things before. So if you got the error, don't worry, you can retry it several times because I have no idea when I just retry it several times, there will always be one or two. Well that's weird, but I don't know why. After you deploy it, you can get your country here and this is your country address and you can find a west coal. If you want to know why is the inside of the what file you can see this tab and also if you want to see how the storage variables you can tell the storage tab and you can find this file and we just back here and this provider we can choose our metamask to connect to our URL testnet and just change it to the token and put half your address here and net and here is your token. Now you can get the balance and you will get your balance here and you can transfer your balance by so be addressed and a 100.
00:39:00.810 - 00:39:10.640, Speaker A: Which one is take.
00:39:13.010 - 00:39:19.662, Speaker B: Another 100,000. Yeah, let's go for demo.
00:39:19.796 - 00:39:21.600, Speaker A: But they don't know if they are.
00:39:26.130 - 00:39:26.926, Speaker B: Less.
00:39:27.108 - 00:39:49.300, Speaker A: All right, I think our time is up. I know we're anyone there's five days, five more days in conference if anyone wants to find out second state and we thank you very much.
