00:00:15.690 - 00:00:32.440, Speaker A: So a few quick disclaimers if you've come to see this talk, we really hope you have familiarity with your knowledge proofs homo market encryption command extensions, and we're really hoping to provide as unbiased of a discussion as possible here. You feel like we're not doing a good job of that, please feel free to call us out.
00:00:34.090 - 00:01:19.186, Speaker B: So what is a privacy preserving smart contract? There's a few different components and properties and privacy preserving smart contracts that we're going to go over and exactly what defines them. In our case, privacy is defined by two properties, confidentiality and anonymity. And what we define privacy as in this case, confidentiality is when we can hide the input and the output of that state machines program. So for example, like in a solidity smart contract, we all know that the inputs are not private. Everybody can see them as well as they are also not anonymous. The inputs are not confidential, and also they don't hide the users involved in that computation. So we have two properties that we're defining that is confidentiality.
00:01:19.186 - 00:02:01.998, Speaker B: So that's like the bare minimum, which is like just inputs are hidden, and then the anonymity would be like a more complete solution where it implies confidentiality. You're probably familiar with some of the use cases for smart contracts. In case you didn't know, smart contracts are also a form of private transactions. So like a bitcoin transaction is a smart contract to some extent. So in the case of private transactions, there are a few implementations of these. Dcash Monero are the two major ones. Private voting is another use case where people actually need to have some privacy, some degree of maybe even anonymity when they vote to cast ballots, as well as auctions.
00:02:01.998 - 00:02:48.900, Speaker B: There's a really big market for blind auctions and keeping who is paying for what and how much they're paying private. Moving on. So what are some considerations for privacy preserving smart contracts? In our talk, we're mainly going to focus on transaction privacy. And the reason why is because transaction privacy is a small subset problem of private transerving smart contracts. And the cool thing about transactions is that when you make them private, you can actually sometimes generalize these into more broad definitions of smart contracts. So we could actually make them do more computations that aren't just transactions, but maybe involve like whole state machines and whole execution. We'll be getting more into that later.
00:02:49.590 - 00:04:16.750, Speaker A: So we believe there are four main considerations that go into actually developing a privacy conserving smart contract. So we've separated these out into efficiency, privacy, security and functionality within each of these, there's a lot of complexities. So in efficiency you can ask yourself, how long does it take to actually generate a transaction? What about verifying a transaction? What is the actual communication complexity, setup string size, setup time, reference string size? What are the hardware resources required? Some zero knowledge proof systems do have a lot of hardware resources required, and they tend to gloss over that aspect. And how does it actually scale with privacy? As we've mentioned before, can we provide confidentiality or anonymity? And is the privacy based on cryptographic techniques? So, do we have some provable form of privacy, or are we using other techniques such as tumblrs for anonymity or stealth addresses? Security has similar considerations. Is the security based on cryptography? Do we have provable security, or is security based on non cryptographic techniques? We can look at trusted setup. We also have to consider nonstandard cryptographic assumptions, such as using the algebraic root model, knowledge of exponent, which are slightly nonstandard. And we have to consider what kind of adversary is our steam actually secure against.
00:04:16.750 - 00:05:10.974, Speaker A: A post quantum one, a semi malicious one? And then finally, and arguably to us, the most important consideration is functionality. When you're talking about developing a PPSC, can you actually adapt your scheme to new settings? Is it possible to really express any arbitrary computation with your scheme? And more importantly, is there support for stateful computations like Ethereum? So that leads us into what we believe are the four definitions for these policies. For efficiency, in the ideal world, it should be quick to generate and verify transactions. Setup should be fast, there should be a small communication cost, it should be efficient when scaling and minimal hardware resources are required. With privacy, we should be able to get anonymity, not just confidentiality. It should be based solely on cryptography. Security is similar.
00:05:10.974 - 00:05:43.690, Speaker A: It should be based solely on cryptography. We do not want to use the trusted setup both for security and functionality reasons, and it should be secure against strong adversaries. We've left this deliberately ambiguous because it depends what you can achieve in your scheme. And finally, for functionality, we should be able to check off all three boxes that we just saw. We want it to be easy to adapt to new settings. We should be able to express any kind of program with our scheme. And finally, it should support stateful computation.
00:05:43.690 - 00:06:35.738, Speaker A: So how do we actually achieve these four characteristics? We're going to focus exclusively on the cryptographic techniques because we believe in provable security and privacy. The first one we're going to look at is of course, zero knowledge proofs. And there are three main schemes that everyone's familiar with snarks, starks and bulletproofs. So for snarks they have trusted setups. However, that allows us to get the smallest proof sizes out of the three and the fastest verification possible. But they also use a slightly non standard cryptographic assumption, which is knowledge of exponent. Starks are arguably an improvement on snarks in that they have no trusted setup, and they use a much better understood hardness assumption of hash functions, but that comes at the cost of incredibly large proof sizes compared to the other two.
00:06:35.738 - 00:07:20.326, Speaker A: And some expensive hardware is needed in the form of extra RAM to actually get the efficiency they talk about. Finally, with bulletproofs, they fall somewhere in between the two. There is no trusted setup, which is fantastic. They have moderate proof sizes, but they have some of the worst verification times. However, they can be improved when batching them together, and they're based on well understood hardness assumptions using discrete locks. So if we look at the three and see how they compare in terms of the four qualities, we've ignored privacy because arguably all zero knowledge proof systems better provide confidentiality. In terms of efficiency, starks come out ahead with the smallest proof sizes and the fact verification.
00:07:20.326 - 00:07:49.234, Speaker A: However, due to their trusted setup, functionality is impacted a lot. It's very difficult to port the scheme into new settings. Starks have very poor efficiency, as you see, because they need additional hardware resources and they have absolutely giant proof sizes, but they do very well in security and functionality, as do bulletproofs. And bulletproofs fall somewhere in between the two. So that leads us into the next building block that Texas is going to tell us about.
00:07:49.352 - 00:08:59.240, Speaker B: So the next one, that is called multiparty computation, something I'm probably sure a lot of you are already familiar with in the form of secret sharing schemes such as Shamir secret sharing. So multi party computation is a type of privacy preserving computation technique which allows us to secure the inputs to some predetermined program, and we have multiple parties who collaborate together and work together to execute this program. And in the output, they should have a private output that only the person who requested that competition should know. Like I said, one of these examples should be a secret sharing, which you're all probably familiar with in the cases like wallets and how to split up your wallets and share. The most predominant issue that everybody should understand when we're talking about multiparty computation is how interactive it is. It is incredibly interactive, depending on the number of parties you have. So anything more than usually two or three participants, we start seeing some really massive problems, and for many other protocols, it requires something like zero knowledge proofs to keep the protocol actually fair.
00:08:59.240 - 00:09:53.014, Speaker B: So what that means, essentially, is we have complexity layers in our MPC protocol. Like the very first layer, we can imagine the network. So all of our participants have to communicate with each other, but we start having similar problems, like traffic. When you get in a traffic jam, the first person in the front of the traffic jam steps on the brakes, which causes everybody else to step on their brakes as well. So we start seeing network latency just filter through the entire and propagate through the entire network like that. And it causes massive problems, especially when a lot of communication is required for more complex things, like we can imagine for a privacy preserving smart contract. Another thing is that it has gates, theoretically, sometimes, where we may require an honest majority, and to keep things fair, we require another layer of complexity, like, that's what I was talking about, zero knowledge proofs, where we start having to integrate proofs to ensure that everybody is acting appropriately.
00:09:53.014 - 00:10:05.002, Speaker B: And if we start doing this now, we're talking about a very complex and long protocol. So in our next slide, we'll be talking about some implementations of privacy preserving smart contracts.
00:10:05.146 - 00:10:39.340, Speaker A: So, two of the most recent approaches that are based on Ethereum are aztec and Zether. Both of them allow us to perform confidential transactions on Ethereum. Aztec uses a Utxo model, whereas Zether uses an account based model. Both of them, in theory, are able to achieve anonymity. However, Aztec uses stealth addresses, which doesn't really satisfy the cryptographic definition of privacy we want. Zether does do ring signatures. However, it's too expensive to implement on Ethereum as is.
00:10:39.340 - 00:11:04.560, Speaker A: Zether is a lot more mathematically sophisticated. It comes from the same authors as bulletproofs and utilizes commitment schemes, eligible encryptions, and it actually combines bulletproofs and sigma protocols into something called sigma bullets. Aztec is significantly simpler, but they use a trusted setup. They are a lot more efficient than Zether, and they just rely exclusively on commitment themes and sigma protocols to achieve this.
00:11:06.290 - 00:12:16.534, Speaker B: So what do Zether and Aztec have in common? When we're talking about they both use alcohol encryption. What they're actually utilizing is a property called additively homomorphic encryption, or even commitment scheme. So what does it mean to be additively homomorphic? What we have, too. We'll talk about different types of homomorphisms, but in the case of additive homomorphism, we can imagine that we have an encryption of, of some a value A and an encryption of a value b. And if we take these two ciphertext and perform an addition operation on the two ciphertext we actually get the encryption of what would be the output if you had just added the two plain texts together, except they're now encrypted. So how this is built around to build actual confidential transactions is we have an encryption of amount, say the number three, and then we have an encryption of a transfer amount, say a number like negative two, you're sending two coins to somebody. So when you take your encrypted balance of three and your encrypted balance of negative encrypted transfer of negative two, and you add them together, you get one.
00:12:16.534 - 00:13:00.518, Speaker B: So that would be the encryption of the balance after that transaction in general. So essentially it lets you in additive homo orgism, it's simply a way to map between these two domains. We have the plain text domain where we are all familiar with just doing simple addition on things, and the encrypted ciphertext domain where we don't normally see what the value is underneath, but we know it's some value. The additive holomism is simply an operation, an addition operation that lets us calculate what that value would be in the plaintext space. So you can simply add Cytext together to get their plain text output. Yeah, that leads us into fully homomorphic encryption, which that's all I'll talk about.
00:13:00.604 - 00:14:00.662, Speaker A: As we just saw, some schemes do utilize homomorphic addition to perform consonantial transactions. If you actually extend that and consider homomorphic multiplication, which means that the encryption of a times, the encryption of b, is the same as first multiplying A and b together and then encrypting it. So what might happen if we were to create a PPS scheme that doesn't only just do homomorphic addition, but also does homomorphic multiplication? That would actually give us something that performs fully homomorphic encryption. There hasn't been any PPSB scheme that does fully homomorphic encryption so far, but it might be interesting to consider how much more power we would get from including this in such a scheme. We're going to quickly look at two non ethereum approaches. One is sexy, which uses Utxo like models. They use DK starks for performing confidential transactions, and they actually have an even stronger notion of privacy than the one you defined.
00:14:00.662 - 00:14:35.700, Speaker A: In addition to hiding the inputs and outputs of a function, they also discuss hiding the function itself. So what we can call function privacy. However, to achieve the efficiency that they're talking about, it's also an expensive scheme in the sense that you need hundreds of gigabytes of RAm to get the proving times you're talking about. And there's a second one from Oasis Labs. We don't actually know how to pronounce the name, so we're just going to refer to it as the project from Oasis Labs. They use trusted hardware, which does not satisfy our notions of security and privacy with cryptography. So we're just going to gloss over their work, but they're also in this space currently.
00:14:37.910 - 00:15:36.578, Speaker B: So briefly, we'll talk about some comparisons between the technologies. So it's really difficult to actually compare these technologies, because they all accomplish similar things with different techniques, and they're just not really that easy to compare together directly. But they do satisfy some properties we can discuss, such as performance privacy, the interactivity involved, and the cryptographic security used. So for fully homomorphic encryption, it is entirely compute bound. So the performance is basically built on the. Just depends on how well your computer can actually perform these really intense operations such as FFT. The privacy is also based on the encryption scheme, which if you're familiar with any cryptographic security assumptions, standards, we can say that usually just assume that it's CPA secure, it is non interactive, meaning that you don't have to interact with a bunch of people to perform this computation.
00:15:36.578 - 00:16:17.910, Speaker B: You only need to go to the computing party, encrypt some data, give them a key, and they can usually perform the computation on it. And it also satisfies cryptographic security as well. So we know that when we do fully homomorphic encryption, we know that it's going to satisfy a mathematically hard problem that's not easy to solve. Like I said, MPC is network bound, and it becomes an issue when you have more and more participants in it. It's based on an encryption scheme and non collusion of that for the privacy. So for Shmir secret sharing, you're pretty much assuming that your friends won't get together and try to screw you over. It is interactive, so it doesn't satisfy that.
00:16:17.910 - 00:16:58.270, Speaker B: And the cryptographic security is somewhat similar that it requires. Usually it has some fairness assumptions that requires usually some zero knowledge fruits to actually do it. Trust hardware is kind of bullshit, in my opinion. It's just based on hardware security, which, if you've been paying attention to the space recently, we have spec to spectre meltdown, speculative execution attacks. We've been trying for years to make secure processors, and they're not working out that well. So it's time. The advancements that it's going to take to make secure processors a real secure thing is much longer than it will be to take these theoretical advancements to approve either FH or MPC.
00:16:58.270 - 00:17:08.290, Speaker B: So let's just move on and do actual provable security and not just deal with the stuff that kind of but doesn't work. So I have a lot of feelings on trusted hardware.
00:17:09.990 - 00:17:53.090, Speaker A: So finally, to just look at some of the privacy observing smart contract approaches. So far we've already seen beeper, and it really optimizes for security in the provable sense. We've briefly seen aztec, but arguably they're not a ppsc scheme, they're just trying to perform confidential transactions. They really optimize for efficiency. Zexi does a fantastic job optimizing for privacy, and Haas, which we haven't really mentioned but is a lesser known project than Zcash, doesn't really do a good job of any of them. However, the most important thing to focus on is that none of the approaches so far has actually tried to optimize for functionality. So it might be interesting to consider what happens if we pick a ppsc scheme.
00:17:53.090 - 00:18:21.360, Speaker A: What happens if we pick a ppsc scheme that optimizes for security, privacy and functionality and gives a little for efficiency and compromises a little there instead? And for everyone else in the room that might not care so much about that, when you're developing your own PPSC, you should really look back at the chart and consider which of the four properties you think do you really want to optimize for. So that's it. Thank you so much.
00:18:29.090 - 00:18:35.540, Speaker B: We have roughly 30 seconds. Yeah. One question. Yes.
00:18:35.990 - 00:18:43.170, Speaker C: Could you explain why you consider bulletproof more secure than stars and stars more secure than snars?
00:18:43.830 - 00:19:35.502, Speaker A: So I don't believe I said that bulletproofs are more secure than starks. I don't really agree with trusted setups. Security can be compromised if the parties collude together. And I think knowledge of exponent is a non standard assumption that's not well understood. So I personally, as a cryptographer, wouldn't feel comfortable using it. Other people might feel differently, but according to my definition, I think snarks are a little less secure than starks and bulletproofs.
00:19:35.646 - 00:19:37.390, Speaker C: And why bulletproofs?
00:19:37.550 - 00:19:44.934, Speaker A: Bulletproofs are based on discrete log in the discrete log problem. And that's a very well understood cryptography assumption that's been around for a long time.
00:19:45.052 - 00:19:59.690, Speaker C: Yeah, but bullet proofs are based on discrete log only if you make them interactive, right? Make them non interactive. You require random Oracle the same as styles, right?
00:19:59.760 - 00:20:02.878, Speaker A: Yes. And the random Oracle is, I agree.
00:20:02.964 - 00:20:05.274, Speaker C: Security point of view equivalent to knowledge.
00:20:05.322 - 00:20:33.238, Speaker A: Of X. I don't know if that's true. I agree. Random Oracle is a slightly non standard cryptographic assumption, and a lot of things use that. If you want to ever turn proof non interactive, you almost always need the option here and you're going to get a random article out. So it depends person to person what you feel most comfortable with. I think this is just an opinion, and I understand that other people maybe don't feel so comfortable with random articles and don't want to use that in their own team.
00:20:33.404 - 00:21:08.986, Speaker B: For many cryptographic use cases, it would be better for us to utilize things. It's great that people want to utilize knowledge of exponents. It'll honestly help us find understanding more as people implement it. But for many use cases, when we want to build for the long term in the future, we want to use stuff that we know and understand very very well now which is the random oracle model, which is the discrete logarithm problem as well. I would also agree that knowledge of exponent is not very well, as well understood as either discrete log or random.
00:21:09.018 - 00:21:13.774, Speaker C: Oracle model, but it's been around the same time as discrete.
00:21:13.902 - 00:21:26.230, Speaker A: I don't think it's been as well. I would argue it's not been as well studied and used quite as much to have as good of an understanding. But I'm happy to talk to you about this afterwards if you're still interested.
00:21:26.300 - 00:21:32.790, Speaker B: And even setting aside the hardness metric, obviously the trust setup loses one of the doc.
00:21:35.550 - 00:21:36.790, Speaker C: Functionality.
00:21:36.950 - 00:21:41.260, Speaker A: That's also part of security. Okay, at least to us that's part of security.
00:21:42.990 - 00:22:16.760, Speaker D: But I think we can also argue that using chess and yarn on Google center underground is also kind of like a urine not very well booked. So you have protein comes on the system anyway, because here this is going to be used logarithmic number of rounds, which is you have a logarithmic number of interactions in the interactive protocol. If you make it more interactive you need to use sketch on here. But it's actually nothing. So people made it short, but I haven't seen any.
00:22:21.450 - 00:22:23.300, Speaker B: Cool. Thanks.
