00:00:14.730 - 00:00:45.660, Speaker A: I'm not sure. Can you? Yeah, you can hear me, right? And I hope this works as well. Okay, it does. Yes. Francis said, thank you for the intro, and I wanted to also make sure that a lot of this stuff is my opinion. It's not like the opinion of the team. I have been working on solidity since 2015, and in the past year I've been kind of like taking a break and did write a lot of code in solidity itself.
00:00:45.660 - 00:01:19.480, Speaker A: And I think some of this is like a culmination of my experience using the language, but I hope some of these things I'm mentioning may come to fruition. Okay, so Zero 817 is the latest release. It's 102nd release. We already had more than 100 releases. That is just insane. And we probably have more than like 1000 Nightlies, which is just crazy. Basically we had eight breaking releases, a bunch of feature releases, and sometimes we do have like Buck fix releases as well.
00:01:19.480 - 00:01:52.350, Speaker A: In some of the years we had releases every two weeks. I think lately it's more like monthly, and I hope that's going to continue. Maybe you're going to get back to biweekly releases, but at least monthly releases. And I'm saying this just to show that, how active the development of solidity is. I'm not going to go through all of these. You can find this really nice chart on the Solidlang.org website and it shows you all the interesting milestones we have accomplished since the beginning.
00:01:52.350 - 00:02:15.202, Speaker A: However, it doesn't show anything past 0.6 because we made this two years ago. But as you can see, it's a lot of stuff going on. And based on like having over 100 releases, you may ask the question, when do we actually get to 1.0? And you may not be alone asking that question. We do get that question super frequently. Last year there was like this big debate.
00:02:15.202 - 00:02:59.240, Speaker A: This particular issue I'm looking here, the issue is much longer, the description is maybe ten times as long. And the author of the issue provides a bunch of different reasons why he thinks solidity should be at 1.0. I summarized like three different discussion points we have been debating on this issue. The author said or had the opinion that the current scheme doesn't actually allow breaking releases, the separation of breaking release and non breaking releases. In his opinion, every single solid release is a breaking release. He also argued that the language is widely used, it has been for a couple of years, and so it should be a 1.0 because that signals that it is ready to be used.
00:02:59.240 - 00:03:14.940, Speaker A: In fact, when 1.0 was released. We never signaled 0.1 was released. We never signaled that it's ready for usage. But the nature of blockchain, people just started to use it and it's there. It's always going to be there.
00:03:14.940 - 00:03:42.062, Speaker A: But also the team had some concerns about this 1.0 stuff. Basically, we have the impression that 1.0 kind of implies that we have to have a long term maintenance of that version. We have to add new features, non breaking features, and all kind of changes. And if we still want to do breaking changes, that's going to be like 2.0. And then suddenly we have to maintain two versions or we're not going to make breaking releases.
00:03:42.062 - 00:04:11.360, Speaker A: So that is the reason we kind of wanted to avoid going to 1.0. I'm not sure how many of you actually know how the versioning system works. Do you want to give hands on? Are you a developer? First of all, so many of you are using solidity. Are you using anything but solidity? Not many. Any other language besides solidity. Nice. So I think you should be aware how this versioning system works.
00:04:11.360 - 00:04:47.094, Speaker A: We were under the impression that it is semantic versioning. Turned out it is not, because anything below the major one. So major zero is a breaking change. However, we did assume that the three numbers in the version is major minor patch, and we assume that if we bump the minor, that is a breaking release. If we bump the patch, that is a non breaking release. So it's not actually in conformance with semantic versioning, but it kind of works for us. Here's just an example how this would look like.
00:04:47.094 - 00:05:18.014, Speaker A: And now suddenly, once we know what 1.0 could mean, maybe we should talk about how could we get there. Here's an example contract with the latest release. This is actually the solidity socks contract, which is on Mainet. You can use it to mint socks, both the land and the right hand side. If you're lucky, you can mint both. And I think the socks are gone at this point, but you could have gotten them a physical version of the sock at the solidity stand, I think on the floor above.
00:05:18.014 - 00:05:45.740, Speaker A: I'm not sure. Now this is 817, it says 1.0. Do you see any change? Yeah, I kind of think that actually for the users, you're not going to see too many changes. At 1.0, we may actually have some changes. Okay, so that was the non changed version. Is it skipping on? Okay, this is the non changed version, and this has a few changes.
00:05:45.740 - 00:06:29.720, Speaker A: They're not important. Yeah. Where is it like this stuff? This stuff? None of this is agreed on, but there may be tiny changes, but I don't think they're going to be big changes. So no major differences if you're a user, but giant differences if you are writing a library. I listed a few things on what you would be able to expect in libraries. We should have like operators and literature, user defined types, standard library, generics, enum, data types. I just gave you a few examples now, but actually Daniel from the solidity team had an extremely good talk, which you should watch, and I'm going to share the QR code for the video as well.
00:06:29.720 - 00:07:21.770, Speaker A: So here's an example of user defined operators. I cannot say that I actually like the syntax, but the team kind of agreed on it. So without test you have to use the usual function chaining, but once you have user defined operators, what you can expect, you can just use them fairly easily. So I think the team kind of agreed that this is going to be a focus project, and I believe this is needed for like 1.0. Another major thing is the standard library, which we have been talking about for years, and the main goal of the standard library is to move out the majority of the compiler code into solidity itself. But it is also really good exercise doing it, because it shows us what kind of language features are missing. So here's one example.
00:07:21.770 - 00:07:53.300, Speaker A: This actually doesn't require anything major. The only thing it requires is this pragma standard lib. And what it does, it just disables the built in functions. Because if you don't have this pragma standard lib, this function definition is going to fail, because there's already a shad, two, five, six implicitly in the language. If you have this, it's not going to be there, so you can define it. This is the simplest example in the standard library, and this works. Doing anything more complicated going to require a lot of language changes.
00:07:53.300 - 00:08:28.446, Speaker A: Here's one example what we will require for the language changes, it is just generics. This is an extremely old example, and in fact I copied this example from my talk from two years ago, from the solidity summit. We were already saying the same things back then, so now I'm going to go any further. If you want to take a photo of the QR code, this is the talk from Danielle. It is a full 30 minutes talk, and he did a really good job at explaining the reasoning behind these features and how they're going to work. Now. Taking a tiny break.
00:08:28.446 - 00:09:14.560, Speaker A: These were the changes the team wants and the team agrees on. But I kind of want to ask you, all of you, to look at the repository. It's kind of hard to see, but these are all the issues. Tag language design and we have 237 issues open. Those are the issues people want as a feature, and I think many of them actually are kind of obsolete at this point. But I ask you to look at this repository, look at all of these issues or a tiny subset of them, find something what you like and leave a comment if you want to have it, or leave a comment if you think it is a bad idea. Besides these features that the team wants, I think it would be nice to know what you guys actually want.
00:09:14.560 - 00:09:45.334, Speaker A: So I think that's what 1.0 going to be like. Not many visible changes for the user side if you're just writing like a token contract, NFC contract, et cetera. But if you're writing libraries, it's going to be entirely different. Now what? 2.0? That is a crazy topic and we have been actually talking about this for a couple of months at this point, on and off. And actually 2.0
00:09:45.334 - 00:10:34.402, Speaker A: is two different things and it has been like super confusing and the team even talking about it because some people meant one or the other. And I just want to highlight it again, nothing is decided here. A lot of this is just my idea or what I want to have, but I hope some of this is going to happen. So first I'm going to talk about this compiler rewrite, which sounds crazy, right? How many of you actually know the compiler? How does the compiler work, or a compiler in general? Not many of you. Basically a compiler has multiple stages. We take like the source code, we process the source code into some internal representation. We do a lot of different analysis on that representation.
00:10:34.402 - 00:11:15.380, Speaker A: Once we are happy with the code, that it is sound, that it works, we are generating some kind of a next stage. In the first version of the compiler, this generation was directly into EVM. In the current stage we still have this, but we also have a second pipeline where instead of directly generating to EVM, we generate to Yule, which is our intermediate language. But you must be familiar with Yule because it is inline assembly basically. And then we take Yule and generate EVM bytecode. So that is the pipeline. And then these are the different libraries we have in the compiler itself.
00:11:15.380 - 00:11:50.190, Speaker A: So this one is just really tiny helpers. I'm going to move to the other side. So these are just helpers used by the others. The assembler is kind of separate, it's standalone, it takes in a data structure like a representation of the assembler source code you want to assemble. It generates evian bytecode, but it also has optimization steps. Then we have this separate helper for, it's called language utilities, but it's really just helpers for the parsers, because we have two different parsers. We have the solidity parser and the Yule.
00:11:50.190 - 00:12:21.306, Speaker A: So language is used by both of these. The lib Yule has a parser, has a code, Gen has another kind of optimizer. And lib solidity is a big one. It's a monster. It is a solidity parser, does all the analysis I mentioned, and does these two different pipelines for code generation. And then we have two smaller libraries. The SMT library is just for the SMT subsystem, but I think that is also split up.
00:12:21.306 - 00:12:50.914, Speaker A: So some of it is here, some of it is in this lip solidity directory. And lastly, the smallest one is Lipsolc, which is a tiny binding. That is the only library which is C, has a C API. Everything else is C. So this basically is the wrapper between C and C, and that is what is compiled through Mscript and into JavaScript. If you happen to use any kind of web app, that's how solidity would be used. I listed a few issues and maybe some benefits as well.
00:12:50.914 - 00:13:35.040, Speaker A: But one of the bigger problems we are getting into is these libraries. While physically separated into different directories, they may not be super well separated conceptually or even like interface wise. One example I can give, which is I kind of hate. It's not like a logical issue in there, it's more like just a source code issue. But we have a loop between lib, ulib, EVM, ASM, and the front end. They are interdependent on each other, which is kind of bad if you want to separate these things nicely. Major components, they do have some kind of a clear boundary, but everything is in C.
00:13:35.040 - 00:14:03.606, Speaker A: The clearest external boundary happens in two places. The assembler has a json import and export feature. The export feature has been there forever. The import feature is still not merged, but it kind of works. And then solidity itself has this json ASD import export. I think some tools like Scribble may be using it. Basically, you can skip the parser.
00:14:03.606 - 00:14:31.570, Speaker A: No, scribble uses a typescript parser. But yeah, some people, we wanted people to use it, some people use it, but they ended up not using it at the end. But the main issue I kind of see here, all of this is C plus plus, which is kind of hard to integrate with other kind of languages. It is hard to integrate with JavaScript. We have this M script and layer, and we have the C wrapper. It is hard to integrate with rust. You need a C layer as well.
00:14:31.570 - 00:15:03.920, Speaker A: Although rust does have like a C binding generator, it is not really stable. If you want to integrate this into go, it's the same case. All of the languages, they only work with C. They don't work with C. So I have a few ideas. How could we resolve this? And first of all, we want to just improve the separation of these libraries. We want to have clean interfaces between them and maybe reduce the number of C plus plus features that the interface they're using to make them more compatible with C.
00:15:03.920 - 00:15:53.870, Speaker A: Then parallel to this, because this can happen on the existing code base. Parallel to this, we could start working on components in rust, and we in fact already have components in rust. We have salsi rust, which is used by Faye actually, and I think at some point fandri used it, but they were annoyed by the size of the binary and compilation pipeline. They're not using it anymore. But we do have a bunch of U libraries in Rust, which is also used by Faye, and some people in the team now are working on some crazy features on top of it. The first useful step could be rewriting the assembler. And the reason behind this is the assembler is one of the oldest components we actually never changed.
00:15:53.870 - 00:16:35.670, Speaker A: The parser itself has been mostly rewritten, or at least significantly improved. I think the type system that is also kind of old, but it had more maintenance. But the assembler that is the oldest component, which has never been significantly improved on it would be a really good task to rewrite it. And by rewriting it, it may not even need to be rewritten by us, but we could use an existing assembler. And in fact etk, the EvM toolkit. EvM assembler toolkit I don't know what the acronym is for, but it is an assembler toolkit basically for EVM. It's written in rust.
00:16:35.670 - 00:17:17.334, Speaker A: We could just use that. In any case, once we have some of these components, we could think about creating a compiler skeleton. So basically just the driver which drives the compilation process. And this doesn't mean that we would need to rewrite a compiler. All we would need to do is provide trust bindings to some of those components and then have this driver which just uses those components. And once this work works, we could swap out parts of those components, for example the assembler, because they are just components. And once this would be working, the biggest change would be actually doing a major rewrite of the front end in rust and the front end.
00:17:17.334 - 00:17:57.746, Speaker A: By the front end I mean mostly the parser, the analysis, the type system, et cetera. And while the code generation as well. That is an insane project. And why would you want to do that? Well, you likely don't want to do it for 1.0, but you want to do it for something else. So what is the reasoning behind all of this? The main reason is that we kind of, or at least me, want to turn solidity, all this code, into a usable compiler framework. I want to make sure that all the optimization steps we have, all of these features, they're not just wasted, they're not just there for solidity, but they can be used by other languages.
00:17:57.746 - 00:18:56.034, Speaker A: Imagine if we would have had this compiler framework earlier on, akin to LLVM for EVM. How long would it have taken for Faye to come to fruition? Or like half for any of these other languages, if you could just use any of these components? I listed a bunch of different projects which are already in the EVM space working on rust compiler components. So of course we have Faye, we have the two other solidity compilers, parsers. So Solang is a full featured compiler from Solidity to webassembly targets. Well, actually llvm targets, they started with Webassembly, but they also support like BPF, like Solana, and a bunch of other targets. The one thing they don't support is EVM. And in fact, Solang, I believe is used by foundry for parsing solidity because it's in rust, so they're not using solidity.
00:18:56.034 - 00:19:42.550, Speaker A: Solidity slang is a project by hearthat. They're trying to write a compiler as well. The motivation is slightly different. They want to have a parser which is flexible and supports every single version of solidity, because they don't want to survive the compiler mid compilation. And that's a problem with the current compiler, it only supports a single version. So why would we want to do this? Because I want to attract more people to solid compiler development, and it seems like C plus plus is not like a language people like or people are interested in. It has been kind of hard to attract people to write C plus plus code, but it seems like rust is extremely thriving.
00:19:42.550 - 00:20:44.998, Speaker A: Every other project is in rust. I've been using rust for a long time, so I would be happy for this to happen. And if we do some kind of a rearchitecting like this, that would mean that we have an opportunity to actually improve the architecture of the compiler and maybe improve the language itself. So that is the next one I'm going to talk about is, what kind of language could we have here? You will be surprised or not, but fact is, we have been talking about like this rust inspired changes to the language since 2019, way before some of these other rust inspired EVM languages came about. It's actually another slide. I think the main motivations, the main reasons those discussions were started because there are a few issues in solidity itself, or at least a few issues I think should be addressed. One of them is really the storage, and the implementation itself is not really separated.
00:20:44.998 - 00:21:05.346, Speaker A: So the only thing we have right now is this contract construct. It can have storage defined anywhere. It can have functions defined anywhere. It can inherit other contracts which also define storage and functions anywhere. And you never know where storage is. It could be handled by any of these imported libraries. It would be nice to actually make this more clear.
00:21:05.346 - 00:21:40.666, Speaker A: The other thing would be nice to kind of make clear when state changes or state access can happen. We do have some of this in the language today. We have payable, we have view and pure functions, but that's about it. It would be nice to you to have more clarity, even within the functions. When is a state change taking place? Functions can be quite long. I think good code bases started to create small helpers and limit the scope of state changes to those smaller helpers. But it's still people can write no matter what you do.
00:21:40.666 - 00:22:34.046, Speaker A: People can write really bad code, but in solidity, especially, people can write like giant pieces of code. It would be nice to have clear view where is state access or state modification taking place. And lastly, if we take such a big step, we could even consider removing inheritance or looking at a different way of composing the source code. And in fact, if we have more clear control about the storage, maybe we also have more clear control of a storage layout, which has been like a really annoying question, and I know many of you have opened issues. How can we set slot numbers, et cetera? Some older contracts have these padding storage items. It's insane. Okay, now finally, what could it look like? So here's an example.
00:22:34.046 - 00:23:05.880, Speaker A: I'm not sure if any of you recognize this. It looks like rust, but more specifically, no, it's not Faye. It's Faye. This is actually Faye. And they started to basically do all these steps we were discussing, which means having a context, which is like a clear separation of state access. Okay, this is what's on the website. But yeah, this is another one, which is nice.
00:23:05.880 - 00:23:46.822, Speaker A: Not having special constructs rather have it tied into state access. And I think they're also like changing it from having a contract and all these things to having separate pieces. Now here's a real example of what is more like what we discussed under thrust solidity. Do you have like a separation of this could be contract, could be struct? People leaning towards struct. So this would be really just the data and then that would be the implementation. I mean, it's not too different to what Faye is trying to do now. And this is the stock contract I had as an example before.
00:23:46.822 - 00:23:50.440, Speaker A: Yeah, I mean, that's it really. I only have 10 seconds left.
00:23:57.450 - 00:24:05.900, Speaker B: Thank you. I guess we can take one question. If somebody has a question, please raise your hand so that the mic can find you.
00:24:06.430 - 00:24:18.346, Speaker C: Hey, Alex. So just a simple question. You're talking a lot about opt, but have you guys given a talk to carbon? That's like the new language that they are going to upgrade.
00:24:18.378 - 00:24:20.110, Speaker A: C. Which language?
00:24:20.450 - 00:24:24.494, Speaker C: Carbon. It's interruptable. So you guys could like.
00:24:24.692 - 00:24:27.214, Speaker A: Oh yeah, the new C, right?
00:24:27.252 - 00:24:32.640, Speaker C: Yeah. That's experimental yet. But guys would be able to use everything that's written so far.
00:24:33.090 - 00:24:42.918, Speaker A: I'm not sure what benefit that would bring. It's worth a think. We. I don't think we had a look, but we heard about it.
00:24:43.084 - 00:24:45.410, Speaker B: Unfortunately, time's up. But thank you so much, Alex.
