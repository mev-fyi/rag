00:00:19.130 - 00:01:50.414, Speaker A: So I guess we all agree that it's really, really hard to ride 100% a correct code, regardless of whether this is a smart contract or any other piece of code. But what does it actually mean to write correct code? What does the word correct mean? And I think that the best explanation is that code is correct when it does exactly the same thing as the programmer intended it to do. So the mental model of the programmer about smart contract or about the program is the same as what the actual machine does with the program. And for Ethereum, this extends even more, because we do not only want the expectations of the programmer to match the actual program, but we also want to match the expectations of the user to match the actual execution of the program. How do we get to that point? And there are of course, several well established techniques, and one of them is to write use testing unit tests. And that's quite easy to do. You just think about a certain input and make up your mind about what you're expected to happen, and then run the program and see whether that actually happened.
00:01:50.414 - 00:02:33.460, Speaker A: And that's good to check whether desired behavior is actually there. But it fails to show that undesired behavior is absent. So you cannot use unit testing to show that it's impossible to withdraw money from your smart contract by a malicious actor. And the reason is because you would have to check all possible ways to call the contract. And that's an infinite number. And yeah, testing can only do finitely many cases. Let's, let's.
00:02:33.460 - 00:03:37.096, Speaker A: So, yeah, and, but there's a solution to that, and it comes in the form of formal verification. And let's take a look at an example there. So this is an easy token contract, which has a balances mapping and a function that allows transferring balances from one account to the other account. There is a tiny error in there. Not sure if you see that, and I would argue that testing can detect that error, but most people probably won't think of this specific input that is required to trigger the test or trigger the failure. So yeah, what's the problem here? It looks correct, but it probably also will work correctly for most of the token contracts out there. But what it fails to test is whether there's an overflow in the two fields.
00:03:37.096 - 00:04:48.340, Speaker A: So if the amount you want to transfer and the amount that is already there in the target account count sums over two to the 256, then we get an overflow there. And the mechanics don't work correctly. Yes. Formal verification allows us to ask questions like, is the sum of all balances unchanged by the transfer function, considering all possible states of the contract and all possible inputs to the function. Next. So how does it work in general? So you provide formal statements, formal mathematical statements, about the behavior of a contract, and then you use mathematical proofs to show that the code satisfies these statements. You can do that manually, but since we live in 2016, there are of course, automated provers to help you there and find the mathematical proofs.
00:04:48.340 - 00:06:06.172, Speaker A: One thing I want to stress here is that formal verification is not a silver bullet. The reason is that the source code, so a programming language, is already a formal description of a program. And adding formal statements in another language, or completely formalizing the behavior of a smart contract, will not really help, because as I said in the beginning, it's all about the mental model of the humans. So the key goal in using formal verification is to reduce the complexity of the smart contract. We use source code to describe how an algorithm works and how a smart contract works, and then we use formal verification to describe what it does. And the idea is that this, what it does is easier to understand than how it does it. And another great thing about formal verification is that we can ask questions about the behavior of the program.
00:06:06.172 - 00:07:26.760, Speaker A: So it's not only about formalizing it in a kind of a specification, but we can also just add to that and ask questions like, is the sum of all balances fixed? And if there is some way to modify the balances so that the sum is not fixed between two calls, then the system will tell us. Or, yeah, we can also ask questions like, will a smart contract get stuck? So is there any way to send messages to the smart contract to call functions in a way that at some point it's not possible to move forward in the states of the smart contract, or it's not possible to get the money out at all anywhere? So yeah, formal verification is coming to ethereum. There are already a lot of research papers on that topic. And the reason for that is that blockchains are actually a paradise for formal verification, because the model is that simple. But Yuichi later will tell you more about that. Okay. And former verification tools also exist for kind of common languages like C and Java and Adder.
00:07:26.760 - 00:08:36.556, Speaker A: And the way it works for these tools, for pharmacy, for Krakato, and for Spark, is that you write your program in the ordinary language you're used to, like C, and then you annotate this source code with formal statements. So, like, sum of balances is fixed between two function calls. And then there are tools which compile both the source code and these annotations into a language that can work with the annotations. This is often y three, and more recently we have f star and then automated provers are used to verify these formal statement on the translation of the source code. Let's take a look at an example. So this is pharmacy, and you see that no pointer. So you see that at the top there is a block of comments with these formal statements.
00:08:36.556 - 00:09:13.880, Speaker A: And then at the bottom you have regular C code and you also have comments inside the C code where you can refer to the state of the program at that point. Yeah, let's not get into detail. Yeah. Now Yuichi will take over. Here it is. So Yuichi is a formal verification engineer who recently started at the Ethereum foundation, and he will focus on extending the formal verification features of solidity.
00:09:20.980 - 00:10:27.252, Speaker B: So Christian started this solidity to y three translator that's similar to pharmacy, but for our smart contract language solidity, I extended the framework so that it can deal with arrays and it can deal with a simple token contract with just one transfer function. The contract itself is easy. It has a transfer function. You can specify the from address to address and the value and some balances are changed. This is the same thing as Christian showed before. It has the same problem with the buffer over no integer overflow. The tool correctly complains if I don't specify that the total balance is less than a certain big number.
00:10:27.252 - 00:11:09.116, Speaker B: Otherwise the tool complains. Next slide please. When the smart contract has a problem, we see window like this. This is Y three gui. Y three is front end for dozens of automatic and manual CRM provers. And on the left side you see lots of conditions, desired conditions like no integer overflows, no buffalo buffdoes, and so on. You see many green ticks.
00:11:09.116 - 00:12:10.280, Speaker B: The green ticks are on the verified conditions, and y three can automatically verify most of the properties. But you also see some blue question marks. The blue question marks are on unverified conditions, wisely still doesn't know if these blue questioned properties hold or not. When you click on one of these question marks on the right pane, you see yellow highlight on the suspicious piece of code. The code is a translation of the solidity contract into y three YML language. That's the language for y three, and here the highlighted line is subtraction. So in this case this might underflow.
00:12:10.280 - 00:13:01.204, Speaker B: And when you see such a problem, you can either modify your program or annotate your program more and more. Annotation is like putting assertions in the program, and if you put enough assertions to satisfy the automatic provers. The automatic provers will say green tick, but in many cases you just find programs in your specification. So it's about adjusting your own mental model. Next slide please. So before finding SRM, I was looking for a place where formal verification actually makes sense. Before the university, I joined a research institute.
00:13:01.204 - 00:13:55.400, Speaker B: My job was to spread the formal methods into the industry, but I didn't have any access to any company's source code, so it was hard for me to do that. So I joined a company that hired former verification engineers. That was a US company. I had eight colleagues. Writing proofs were a wonderful environment, but I was not happy because our proofs were not about the VR thing. The fundamental problem is the VR CPUs come with documentation, 2000 pages dong, and nobody has ever translated the whole thing into any theorem provers. So that was a huge problem we couldn't solve.
00:13:55.400 - 00:14:56.392, Speaker B: I found Ethereum. I saw the Ethereum virtual machine, I saw the yellow paper, the specification, it has only 32 pages long. And I thought, I can actually translate this thing into a theorem proof and I can write proofs about smart contracts. I was doing that and I was posting the partial results on Reddit and Christian found me and I ended up here. So the Ethereum virtual machine is wonderful because it has a small specification and this small specification really matches the reality because all clients try really hard to match this specification. Otherwise one of these clients would behave differently from others and that's the worst thing they want. So they really want to be conformant to the specification.
00:14:56.392 - 00:15:58.444, Speaker B: And a small definition that matches reality is the fundamental necessity for former verification engineer. I found it in naturem. Next slide please. We have some future steps, so when I'm extending the solidity y three framework, there are some immediate problems, like we don't have the Quora instruction yet in the translation, or we cannot deal with mappings to mapping in Y three in short and elegant way. Because of this, we are thinking of moving to f star. F Star is something similar to y three, but it has more advanced features. I want to thank Microsoft for open sourcing f star and also g three smt solver.
00:15:58.444 - 00:17:01.252, Speaker B: We all extensively use it, thank you very much. But feature wise we have more problems to solve than just verifying one solidity contract. I think we are moving to many small contracts than one monolithic big contract. So we have to be able to reason about multiple cooperating condit contracts. And then just reasoning about solidity code is not enough because what runs on the blockchain is not a solidity code but a compiled bytecode, and sometimes the compiler has bugs. So somehow we have to know how the bytecode behaves, whether it's EVM or the EVM, the second one. So somehow we have to do that.
00:17:01.252 - 00:18:03.060, Speaker B: But that's easier than most CPU architectures out there. So I think this is a solvable problem. The next one is multitransaction conditions. So currently the precondition post condition invariants on the contract are just on one core. It can already deal with the reentrancy, but from the first core to the last return, and that's the range of verification we needed to extend that. And then yes, combination with off chain protocol. This is harder because the moment we get off the blockchain, people's behavior are not constrained by clear rules.
00:18:03.060 - 00:19:16.060, Speaker B: So what's good for people is not very well defined, but somehow we have to define a game where it's in the player's interest to coordinate with the rules. And the formal methods can help here, because it can explore all possibilities of interactions. The last point is rather practical. So you saw some blue question marks, but just a question mark is sometimes not enough for me to understand the problem. So it would help if we can see counterexamples, like with this input, with this state, this is broken, and then it's more easily understood. But I believe many more formal verification researchers are coming to the verification of Ethereum smart contracts because of the reason I mentioned. The Ethereum virtual machine is really a paradise for former verification engineer.
00:19:16.060 - 00:19:21.180, Speaker B: Thank you very much. Thank you, Yoichi.
