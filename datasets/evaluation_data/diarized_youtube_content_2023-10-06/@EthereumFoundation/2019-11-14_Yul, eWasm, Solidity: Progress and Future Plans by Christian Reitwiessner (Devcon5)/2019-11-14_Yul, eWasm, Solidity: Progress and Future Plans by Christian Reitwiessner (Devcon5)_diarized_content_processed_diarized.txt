00:00:20.570 - 00:01:45.982, Speaker A: Not yet. Now maybe team did about you in last year. If you can't properly see the screen, the URL here in the bottom. Wait, a little telegram, more or less a continuation of the talk I gave at Devon. Four less guests, more fun optimizing smart contracts. It's not a problem if you haven't seen that talk, just for context. In that talk I explained how we want to leverage an intermediate language for human so that compiler has better readable code generator and optimizer, and in general more flexibility towards which back end we compile this.
00:01:45.982 - 00:02:36.670, Speaker A: For example, Yule can be compiled to evm to ewasm EVm 1.5, or, I don't know, maybe LBM. And on the bottom here you can see some example ucode it's an allocation or it's a standard solidity allocator, memory allocator. And I think it's rather obvious what it does, and easy to know, at least if you know some of the all codes. Okay, what did we do? So this was basically the recap of the talk of last year. What happened after that? We started the rewrite of the solidity code generator to you halfway there. This will be the first third of the talk.
00:02:36.670 - 00:03:31.070, Speaker A: Then I will tell you how you can generate ewalkin code from solidity. And the last part will be about the code generator. We are actually quite far with that. We had to stop at some point because we want to release solidity 60 soon. With new features and breaking changes, it is possible to compile an ERC 20 contract. So general ERC 20 contract written solidity, including mappings, events require, and whatever is necessary. The new code generator has a breaking change, that is that it will automatically revert on arithmetic overflow.
00:03:31.070 - 00:04:28.814, Speaker A: The current code generator only reverts on division by zero and similar things, and the new code generator will also revert on multiplication and additional overflow. And the main reason why we didn't do that for the old code generator is because these checks will have branches and the old optimizer cannot really follow the code there. But the new optimizer will see in the third part. And it was also much easier to write using Yule, because might actually look like that. But Yule does not have the concept of stack, it only has local variables. And these are there's a rather direct translation from the local variables to a stack machine. But in general you do not need to worry about the stack layout.
00:04:28.814 - 00:05:44.774, Speaker A: So one of the most complex parts in the solidity code generator is external function calls. Because the call output has so many parameters. And it also depends whether you call library or a regular function, or whether you specify the gas or whether you specify the value and so on. So there is different ways to use the call op code, and all the time you have to keep track of where everything is on the stack in the old code generator and the new code generator just reference stuff by their name, so it's just gas as a variable. And another thing is that when the old code generator we forgot to or did not yet implement a certain feature, but by accident the stack layout is correct, then this will lead to code that is actually generated and will of course do something invalid. In the new code generator, sub expressions are always referenced by their identifier. And if the code generation of that sub expression is not implemented, then the identifier will just not exist.
00:05:44.774 - 00:06:53.730, Speaker A: In the Yule code you have an additional level of checks on the intermediate language and this will be detected. And how can you actually use it? I will only show you how to use it on the command line. The static JSON also works, but it's more complicated on the screen here, so will generate Yule code from the solidity code. And for safety reason we do not support a direct translation from solidity through Yule to EVM because it's still in an experimental stage. So you have to copy the output of the first stage and then rerun the solid decompiler in assembling mode and then transform the Unicode to EVM bytecode. Yeah, let's take a look at how that then looks in practice. So this is an example ERC 20 contract, or a part of an ERC 20 contract.
00:06:53.730 - 00:08:14.150, Speaker A: We have an event, we have the mapping of the balances total supply, and a mint function that generates tokens, which is called in the constructor. So the sender gets 20 points and the mint function starts with this require call. So the address to mint two cannot be the zero address, and then total supply balance is modified and the transfer event is limited. Now we compile that to Yule, and so this is not the code directly generated by the code generator, but this is the code after optimization. And I think it's really nice that this is still nicely readable, at least I would say let's get into this detail and then you will see, but you see that it still has expressions. You would even see the mint function call here and you would recognize the name mint. The issue here is just that the mint function in it context is only called once, and because of that it's of course inline.
00:08:14.150 - 00:08:52.230, Speaker A: And so the function is called, it starts with initializing the memory allocator. Then we have the call value check because the constructor is not tabled. And then the second thing here is the require that the address we mint to is not zero. And you actually see the error string here. ERC 20 mint to the zero address. So this block here is the required call. And then we update the total supply.
00:08:52.230 - 00:09:29.166, Speaker A: This is the comment I added manually. Yeah, you take the stuff that is, take the data that is currently at storage location two, you add 20 and you store it again. Now it calls a user defined function called checked add. This is the overflow check I was talking about earlier. And that is one of the two functions that is not visible on the screen here. And the rest of the code is all there is to the constructor. So this is the full constructor code missing two small functions.
00:09:29.166 - 00:10:00.458, Speaker A: And now we update the balances. This is still a kind of a problem. There is a function called mapping index access team mapping and so on. It's a little bit longer. So the reason is that the index access helper function for storage mapping and the name is generated from the type. And I think we still have to come up with a way to shorten it so it's better recoil. Yeah, and another issue here is, you see the mapping index axis, the function I was just talking about.
00:10:00.458 - 00:10:44.730, Speaker A: It's called here and it's also called here again with the same parameters. Usually the optimizer is able to combine that and call it only once. The problem here is that it calls the catch up function, which works on memory. Because of that, it has to access the memory and the optimizer cannot yet recognize that writing this stuff. So the stuff that is written in the first call and the stuff that is written in the second call, they do not conflict because it's exactly the same. So they write to the same memory location. Because of that, it can't really swap them, but it should detect that it's actually the same stuff that is written.
00:10:44.730 - 00:11:29.238, Speaker A: Okay, let me speed a little. Yeah, talking about bytecord size, I'm not sure if you can compare these numbers with the earlier talk because this is 256 bit eVM code. And I think it's also a lot more of ERC 20 than there was in the Webassembly challenge. But we can compare the compiler that goes via Yule and the compiler that does not go via Yule. So the current compiler takes 1747 bytes. That's a bit unfair, because it does not include overflow checks. If we add the overflow checks, it's 1805.
00:11:29.238 - 00:12:13.826, Speaker A: And if you do that via Yule, it's 2162. So it shows there's still some work to do. Actually, I did not yet find the time to see where it has these additional bytes. So it might be just a webassembly similar to sauce C minus minus ir. You can use sauce c minus minus ewasm. This will actually generate ewasm text representation in one run. The thing is, it's not tested at all and it cannot yet deploy contract.
00:12:13.826 - 00:13:08.460, Speaker A: It's not tested yet, all because we couldn't yet find a good execution environment. We can run it again and it cannot yet deploy contract. And the reason for that is that we have not implemented the transform from webassembly text representation to webassembly binary representation. And you need that for deploying, for actually deploying the contract because it needs to return the binary optimize binary representation. Okay, how does the compiler two e wasn't work. It takes the regular Evm Yule code. So it starts exactly at the point where the solidity to Yule to EVM compiler went.
00:13:08.460 - 00:14:24.980, Speaker A: You have to transform 256 bitcode to 64 bitcode. And this is done by splitting all the yule variables into four variables. And at that point we have some kind of a mix of webassembly dual dialect and EVM dual dialect because we still use the EVM opcodes, but we already use 64 bit variables. And then we add kind of a library code that implements all EVM opcodes as user defined functions using the EVM built in, built in functions. And at that point we have ewasm flavored view and we run the regular optimizer would also run on EBM Yule with slight modifications because we have different technologies. And yeah, it turns out that we are able to reuse almost all of the components of the EVM dual optimizer. And it generates kind of a pretty straightforward transformation, I would say.
00:14:24.980 - 00:14:53.750, Speaker A: Yeah. Let's take a look at a specific sub example. We just score the current block gas limit at position zero in memory. I have to warn you, because of the 256 bit, 64 bit thing, this will look a little bit complicated. Okay. What we do is gas limit returns a 256 bit value. So we have to split that into four variables.
00:14:53.750 - 00:15:47.610, Speaker A: And that's what is done here in the beginning. So we call gas limit and sign it to four variables and then we call end store. That is the kind of pseudo hybrid EVM ewasm function that takes eight parameters, so four for the address and four for the value. And then we add the implementations of the EVM of codes using webassembly built in. So gas limit for example just calls east gas block gas limit and then mstore. We need to perform NDM swapping because webassembly is a lit ending machine, but everything else is. This looks really complicated, but if you apply the optimizer, then it will of course inline the guest that we call here and also remove all the other variables we don't need anymore.
00:15:47.610 - 00:16:59.330, Speaker A: And also the m store, it has constants here, so it probably makes sense to also inside that and then it will look like this, only the end gets fault is left more or less. Okay, now, third part of the talk, what we did on the unit optimizer, we all components of the optimizer take dual code, transform it and output dual code again so it's no reduction or something like that. So all the modules are simple and can be combined in an arbitrary way. If all the modules are correct, then the whole optimizer is correct. It turned out that we need a little bit more modules than we initially thought. We currently have roughly 25, but most of the modules are really really tiny. And there are only two to three components that restore opaque data structures.
00:16:59.330 - 00:17:45.490, Speaker A: So for example, the conditional simplifier, which is for that module, it takes a look at branches. So for example, if C stop the body of this if always terminates. So after the body you know that C is false or snow. So the only thing that it does is injects assignments of this form after terminating branches. And other modules in the optimizer can pick that up and use that information. But the information is visible in the code, it's not stored in some data structure. You would have to look into some error.
00:17:45.490 - 00:18:29.566, Speaker A: Um, yeah, talk about the plans of the future. Memory types. We already saw that we have some problems with memory. This will hopefully be solved by adding memory chunks as a built in type into U. That way different memory stores to different data structure are fully independent because it uses kind of a different handle to access memory. Also, we are thinking about adding a super optimizer. So an optimizer that takes a really long time and tries to really crunch the numbers and find a good way to optimize the code.
00:18:29.566 - 00:19:10.222, Speaker A: And that can maybe have shortcuts if you want to recompile stuff, but it's faster. And we're thinking about adding a genetic algorithm to find a good order for applying the steps. So as I already said, each step individually should be correct. The order doesn't matter for correctness, but it matters for efficiency. And yeah, it's kind of hard to manually come up with a good order to apply them, so we want to find a generic way to come up with a good. Okay. I'm not sure if I still have time for questions.
00:19:10.222 - 00:19:11.790, Speaker A: Thanks for your attention.
