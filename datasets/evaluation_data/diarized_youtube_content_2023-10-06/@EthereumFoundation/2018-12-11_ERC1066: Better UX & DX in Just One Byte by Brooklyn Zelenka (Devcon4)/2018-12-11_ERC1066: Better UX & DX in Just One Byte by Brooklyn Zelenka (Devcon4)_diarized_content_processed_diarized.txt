00:00:00.570 - 00:00:31.400, Speaker A: My talk today is about the fission suite and how one byte can add a lot more context to all of our smart contracts. So, a little bit about me. I'm Brooklyn. Zelenka or xPeed? Basically everywhere on the Internet. I am the CEO and chief scientist of the Special Projects in Decentralized Engineering Company, or Spadeco. We are in the Tachyon cohort with Consensus to Find Fund specifically this work. We work entirely on open source and are grant based.
00:00:31.400 - 00:01:28.620, Speaker A: My main background is I'm a programming language theorist and correctness Nerd and was previously working on Security Tokens and a formally verified language at Thinhaven. I'm also the primary author of a couple ERCs, including 1066 ASCO, which is what we'll be talking about mostly today, and community stuff. If you ever happen to be around Vancouver, I'm the founder and organizer of the Functional programming meetup out there and run the Technical White Paper Club, which we are hoping to move online. So please watch for announcements on that and join us for the live stream. So Ethereum is in super early days, which means that there's a lot of pain points which broadly fall into three categories. End user feedback is almost nonexistent. You either get back that it succeeded or it failed, and that's pretty much it.
00:01:28.620 - 00:01:55.860, Speaker A: The developer experience leaves something to be desired. Debuggers are very low level. You just have a step through debugger, you get core dumps. That's pretty much it. You have almost no feedback. We're writing for the machine and not for humans. Code should be to, yes, communicate with a computer, but it's also for communicating with other developers so that when you leave the project, other people can understand what's happening.
00:01:55.860 - 00:02:34.190, Speaker A: And even when you're doing a pull request, you should understand everybody else's. Code and Solidity and other languages are still not mature yet. They're changing a lot, which means that we're getting new cool things that are making life better. But there's quite a bit more left to do. So just this year we got Constructor Syntax and Solidity revert with message and a bunch more changes. And then the third area is smart contracts. They should be these autonomous pieces of code that understand how to react autonomously with very little human involvement.
00:02:34.190 - 00:03:14.060, Speaker A: But we're not there yet. So I think I can sum this up by saying that lack of context is the mind killer. So a quick motivating example. A lot of this work comes out of the Security Token platform we were building at my previous employer, Finnhaven. So we needed to do a lot of authorization checking. So, bit of context first, this is what a validator looks like. You have a caller which might be a human, a smart contract or another validator that calls a check function and then returns a status back.
00:03:14.060 - 00:04:08.214, Speaker A: And then that's the actual code, obviously. Here's a quick reference implementation just to give you a sense of how this actually works. So this is just a bog standard ERC 20 token that we've added one line to this is okay, and then the validation call and the validate itself is just a helper function that calls into a validator and is okay. Checks if something is allowed, if it's true. Or in the later version, which you'll see in the later slide, if the status code is in the okay range. So here's the naive version, the first version that we had built. You have your token and it needs to talk to validator or guard and you say hey, am I allowed to do this? And it needs to talk to some others because you might have a whitelist that's maintained between several parties and you don't want to duplicate that data over and over and over again.
00:04:08.214 - 00:04:51.270, Speaker A: So you need to check with several several different organizations. Worst possible example, but to kind of give you a flavor is Equifax could maintain a whitelist of people that they've checked their ID and now you have your KYC done without you having to do that check yourself. So it delegates this call on and we get back a no, but it's not an actual exception, right? It's just a false. So don't explode, just say no, they're not on our list. So you go and you check some more and this one says yep. And then you have to also check everybody else too, because we just don't really have enough context. So we say ah, two out of three is probably good enough.
00:04:51.270 - 00:05:36.550, Speaker A: And we turn yep, you're allowed to do that thing great. There's this great Connor McBride quote about boolean blindness. Booleans are great, but they just don't give you enough context. You need to understand the exact situation in which the boolean was generated to know what it actually means. Hence ERC 1066 vision codes, which help us do smart contracts that look more like this. So it's something like Http status codes. It gives you something more than true, false or revert.
00:05:36.550 - 00:06:34.090, Speaker A: And a nice analogy for this is if you think of your smart contract as nodes in a graph of calls, this is the edges and the smart contracts are the nodes. So today typical flow is you take a bunch of open Zeppelin contracts, kind of snap them together to create one. We're saying that's great, fully compatible with that. But if you need to have two or three or four of those talk to each other, it would be good to have some more context about what's happening on those other nodes, much like you would have in say, a microservice architecture on the web. So this is a common vocabulary for smart contracts. It gives us richer context about what's happened on the other side of a function call. You can tag arguments or return data with some metadata about what it means and expose information about an internal machine state.
00:06:34.090 - 00:07:20.598, Speaker A: For example, this ICO is not open yet, but it will be later. And yes, similar to HTP status code, it's a different problem space. So we don't have 404 not found or 500 error with internal errors because it's a different platform with different needs. So a lot more information about this is at fission codes and this was previously titled Ethereum Status Codes. We'll talk about why we changed the name a little bit later. Acronyms are awesome. So this is the fluid interface for Scalable smart contract interoperable networks.
00:07:20.598 - 00:07:53.140, Speaker A: Not to be confused with the fluent interface. We have some organic traction, so it's already required by three ERCs nando 2414, 60, 214. Four is exploring it in their GitHub issue. We've been talking to a couple well known major players in the space. We're just waiting on the okay to make those announcements. So keep an eye on our website. And we are part of the Consensus Tachyon accelerator through the open source R D grant program.
00:07:53.140 - 00:08:26.602, Speaker A: We're working on integration with common tools. We have a forked version of MyCrypto that I'll be showing you some slides from later that we'll be pull requesting into them. And we're looking at integrating more broadly as well. And we've had a few bounties and more are coming. So what does this actually look like? So this is that slide I showed before. And we're saying that we can take these booleans and turn them into something with a little bit more context so that we can do things like skip checks. If, for example, this is an age range, we don't need to do this middle check anymore.
00:08:26.602 - 00:09:33.570, Speaker A: And we can also recontextualize responses back. So this bottom right image where we have the little graph saying this is in a certain range, the further down the call stack you get, you tend to lose context about the broad picture, right? You go from the forest to the trees and as that propagates back up, you may want to recontextualize with something that's more about your specific use case. So in this case we go from range logic to permission logic to something compatible with an ERC 20. We're very focused on developer experience design. We need to have a very low cognitive load, make this not hard for people to use and easy for developers to meet to communicate with each other. We do this by adding a lot of structure, which means that you have less memorization, fewer lookups, and your code can help you out a lot more because you can decompose what the code is and make smart decisions based on that. We have a human readable code helpers in the library.
00:09:33.570 - 00:10:14.078, Speaker A: It is compatible with existing patterns, is fully compatible with Revert, for example. So it's not an either or distinction. And let's talk a little bit about the structure and the layout. So a Nibble is a half byte because programmers in the 70s liked puns. So here's hex 41, breaks out like this. The upper Nibble is your category. So things like this is time based logic or authorization, et cetera.
00:10:14.078 - 00:11:06.508, Speaker A: The lower nibble is the reason which is, did this pass this fail? Are we waiting on somebody else? Is somebody waiting on you? Et cetera. And we get this extra nice property of the general category. Zero is the same thing as not having the upper nibble at all. It's just the same thing as the reason alone. So the code table, if you think of it as a two dimensional grid, is like this. The columns are categories and the reasons are rows. It makes it very easy to look up a code that you're looking for or to decompose a code that you've received.
00:11:06.508 - 00:11:58.424, Speaker A: So in this case we're awaiting and something with search or matching logic. Let's say in a Dex, you're waiting to be matched in the order book. That's two, three awaiting match. Here's examples of some of the helper helper code. So we have enums for category and reason ways to do inclusions. So to take two of these and stick them together, either the enum or just a raw number and you'll see the the third one there says app code. There is a way of if you structure your application specific enums in the same way as the reasons, then you can embed that in and automatically get a status code generated without having to say, this is an application specific code.
00:11:58.424 - 00:12:59.420, Speaker A: Use the a at the beginning, you just use the app code function. We have functions to pull apart status codes so to decompose them, to make smart decisions on things. So you can say, I'm only really concerned about authentication, everything else should be a fail and my reason should be in one through four range, let's say. And we're doing it playing around with masks, et cetera, just to keep things very efficient and again, totally compatible with require statements. So this is require, okay, which means that the code must end in a one, otherwise it reverts with a hard coded message. The reason that in the slide it says message and then a little star is the next phase of this project, which I'll be talking about in a moment. We can do automatic translations in any language with no extra code from the programmer.
00:12:59.420 - 00:13:31.586, Speaker A: So let's look at one example, code flow. So this is a Dex. You have a token, which is the little money bag, the exchange in the middle. And then the robot icon is a proxy for a person actually interacting with it. Let's say a wallet. And we say, I'd like to buy some of this token. And that goes through, says, hey, cashes that.
00:13:31.586 - 00:13:57.178, Speaker A: And says, hey, I'll call you back when I'm ready. Right, don't call us, we'll call you. And that gets propagated back up to the user and the Dex knows that it's waiting around. Some time goes by and the user is getting impatient. So it says, hey, is that done yet? We don't have to check the token. We can just automatically revert and say no, we'll call you back when we're ready. Later.
00:13:57.178 - 00:14:54.640, Speaker A: The token is now open for business. Somebody flips that bit that can now talk to the Dex and say hey, I'm ready. It can then say buy for all of these different users because it still hasn't heard a cancel order on them, says yes, cool, that's agreed and completed. Propagates that back to the user and the user can be alerted with a message directly in their wallet. So I've alluded to a few times now translations because we have one byte 256 codes, that is a reasonable number to translate and it so we have ethereum wide general purpose code to human translations in any language. Anybody can create a translation and you can use whichever translation you like. So this is a bring your own translation situation.
00:14:54.640 - 00:16:00.830, Speaker A: Or you can use one of the in big scare quotes, official ones that we're producing, create your own, share them with your friends, write list of curations, et cetera, make an emoji one. It's all in utf eight and we are standardizing on printf style template strings. Doing string interpolation on chain is very expensive, but the ERC 1444 specifies doing this in the client. So there's a standard way of returning up to the wallet or the client, the template string and the arguments and then you can do that all in the UI revert over the last year, the beginning of the year, you really just got an out of gas error which was not very helpful. Some time went on and we got revert with reason. So you can hard code a message, typically in English. I've also seen Chinese that in this case player doesn't exist.
00:16:00.830 - 00:17:02.246, Speaker A: That's great, but not everybody speaks English, especially if we want to make this a truly global system, usable for anyone, this needs to be localized, internationalized. So using this system and then an integration into a wallet, you can have something like this where it's not just that it's failed and doesn't just tell you why, it does it in whichever language and contextual to your specific use case. So how do we actually make that happen? This is the broad architecture. You have a requester which is either a person or a smart contract, a singleton localization preference instance on chain and then a number of localizations. So typical credentialation flow. Here we have a user looking to get something back in Japanese and they're talking to a smart contract and we have a wallet in the middle. So I'm going to be very clear we don't have a MetaMask integration yet.
00:17:02.246 - 00:17:38.014, Speaker A: We're going to be doing a pull request against them. But this isn't to imply that this exists with them today, it's just when we use the emoji, which is a little purse, people get confused. So you send a transaction over that makes a request into the smart contract and then we get back a status code which is not very human. Readable that part. If it's a Mutating request, then they've been charged gas. We don't want to incur a gas cost for doing translation, which is just purely a lookup. So we do a second request to that singleton.
00:17:38.014 - 00:18:33.650, Speaker A: It looks up the transaction origin, the user that's actually looking for this. It looks up what their translation preference is. So there's a proxy, forwards that onto the correct translation, returns the string and that bubbles back up to the user and then looks something like this, translating revert. So let's say you're doing development and you just want to get this directly in the console. It's pretty similar, right? Do the thing. Here's a transaction, then internally to the smart contract, it says Revert with this code. So it's going to look up the string, look at the originator of the transaction, grab the text and back up it goes in Revert.
00:18:33.650 - 00:19:51.200, Speaker A: So we have some further directions as well for the future, because this is fairly portable. What we have today is we have Ethereum, we have ERC, 1066 and 1444, which gives us translation and integrations with Wallets and DApps and so on, being one byte that runs on every computer ever. So we can do this interchange and do message passing across to, let's say, the Etc peace bridge or across to our chain, et cetera. And with the Web, because we can map 256 status codes into the 63 or so Http codes that there are, we can have automatic Http Ethereum to Http web bridge and sessions, pausable session or multi transaction sessions as well. So here's a list of links. Awesome. Thank you so much.
