00:00:01.260 - 00:00:48.316, Speaker A: You. So I think introductions are done. Me and Martin, from consensus diligence, will be talking for a brief 20 minutes today about visualization of large code bases, but also framing it as to why we've built the tools that we did and how they play a role in securing large code bases. Right. This is not only about visualization. This is about making your code secure when your code needs to be big, right. Because security, and oftentimes as the security team to many products, we advocate for small code, but sometimes it's just not possible.
00:00:48.316 - 00:00:58.530, Speaker A: Right. Some things need to be complex and need to be sizable. So that's why we're talking about this today.
00:00:58.980 - 00:01:58.390, Speaker B: Let us start, if I may add to that, we have this unique not problem, but challenge sometimes that new hires in your companies might have as well. So they get to see your code base and it's fairly large. And how do they start understanding the whole code base? And for us auditors, this is kind of like regular business. So with every new client, we get like a new, more or less complex copace. And we want to make sure that we spend as little time as possible in understanding the complete system and finding the red lines so that we can start auditing and finding any security issues in there. So that's why it's also an interesting take on what tools are available or how can we aid new hires that we want to have in this ecosystem to be able to quickly write up code and quickly understand existing code bases and kind of also in a secure manner. And that's what we are going to talk about.
00:02:01.640 - 00:03:50.324, Speaker A: So for the history of the tools, we'll give you a little bit of background on why things happen and what happened and at what time. So this whole thing started. Well, this whole thing, obviously, we have always been thinking about security, but this specific branch of our tooling started because of Aragon Os, right? Up until then, all the code bases that we had seen, or me specifically, had been related to tokens, simple implementation of VIPs, stuff like that, right? And then came Aragon Os. And it was a beast of a code base, right? And I'm not saying that it was not well written, which it was, and very well documented, too, right? Probably better than most of the projects that we have audited. But still, the sheer size of the system made it so that it's really hard for you to create mental models, right? Even with threat modeling exercises, you always end up to do some sort of visualization, right? Be UML diagrams or something that helps your brain come to terms with such a high level of modularity and composability. Right? So size is not the only factor that plays a big role in making a system complicated. Modularity too, right? And this is why Surya was born.
00:03:50.324 - 00:05:53.520, Speaker A: Surya is purely another abstraction on top of the ast that actually maps it out, right? It's a call graph printer, nothing fancy, that was worn out of necessity. The main drivers for Syria to be built the way it was were portability and low dependency trade, right? We wanted to make these tools so they could be run everywhere and anywhere and also have a small footprint so that we could run them everywhere and also be cross platform. We just want to make it easy to run these things, right? We don't want to deal with versioning, we don't want to do any of those things that end up complicating a tool like this. Because the tool's purpose to begin with was to make it easy for people to visualize and mental map something. So if we make it hard to run, then it's going backwards, right? So we went with Federico's awesome tools on the ANTLR for grammar and Parser that he had built for a long time already, and then came along the best part of the stack of this tooling branch, that Martin Road, which is the solidity visual auditor extension. I'm now looking at the name. In doing the presentation, I see how we could probably make it more receptive towards developers, because even though there's auditor in the name, it's not its only target audience for sure.
00:05:53.520 - 00:06:38.956, Speaker A: And again, going back to what I was saying before, if our goal is to make it as easy as possible for people to visualize and map out systems, then using cleat tools is not really the way to go, right? While you're developing, you don't want to interrupt flow by having to run a system on your terminal or in another terminal session if you use Vim, right, or just like even going through the trouble of visualizing those things in another window is already too much. And so Martin brought us this beauty here.
00:06:39.138 - 00:08:32.370, Speaker B: So basically, how this was born was I was new to solidity, but I didn't want to always have to keep everything in my mind about all the language specific things like what parts of the language are actually considered insecure or not as secure as they should be. Or if you write your code, for example, in visual studio code, which is the ID that I'm using, it wouldn't alert me on certain things that I would want to see from a security perspective, which is passive information about what functions are actually publicly accessible, what are public interfaces, what are only internal functions? Or when I'm pasting some piece of code from stack exchange because I want to do like a delegate call proxy and I'm totally unaware what this is actually doing. It's pretty easy to mess it up, right? And if you paste it into the ide and you have this extension enabled, it will throw a whole lot of red flags at you by highlighting the delegate call itself in plain bold red, so that, you know, like, oh, I should probably read up on that thing, what is it doing? They can even hover over that delegate call and we give you extra information about what the call is about and also what security concerns there might be around it. So it was initially geared towards allowing new developers to develop code by getting passive security information while they are writing code. So it was starting out as a syntax highlighting, as an extended syntax highlighting extension, but it got into that big beast of a lot of other nice tools that we kind of put into that at some point because they were always useful for us when we had to engage with new code bases. Hence the name for this talk.
00:08:33.540 - 00:09:25.252, Speaker A: Yeah, so you can see a little bit of it. We'll show the tools in a minute, but you can see a little bit of it, like the syntax highlighting under the pragma and under the state variables. Also, this is like an accompanying thing that Martin built, which is basically an SVG interactive graph for vs code, which is like the frosting on top of the cake. Honestly, what happened a little bit after, so probably when you're into development, is that we realized that we needed to own all of the dependencies for speed of development and support. Right. So we took them up recently and thank you so much. I thought I'd wink at the team and thank you guys for doing that.
00:09:25.252 - 00:10:11.650, Speaker A: We don't need to worry about the grammar anymore because the solidity team actually took it under their wings. So we're free of that now. Also with the whole corona thing. And our workload has been extreme these past few weeks. And so I know that there's another on GitHub solidity parser that started a new fork of the solidity parser that is more up to date than ours. We are very excited about contributing there, but thinking that we should probably still maintain our own in case in the future we need it again.
00:10:13.060 - 00:11:16.410, Speaker B: Yeah, this is also like a recommendation from our side. When you're developing a new language, always make sure that people have grammars easily available to their tools. The Antelr grammar is nice because we can use it in a fussy way. It doesn't need to be as strict as the compiler will be afterwards because we are mainly using it for visualizations, even though there can be some unsharpness in that case, but you have to be aware of that. But for most of the cases it's fine if we find all the functions, all the state variables and stuff, and we don't need to find like 100% of it all the time. But it's utterly important that if parsers are readily available, like generic ones, as the MTLR parser, then it's very easy to build a whole lot of tools or ide integrations for all kinds of platforms, and it makes it just easier for people to adapt the language. Thanks for taking that under your wings as well.
00:11:18.460 - 00:11:45.616, Speaker A: Yeah, and yeah, since then a lot more tools have been built by Martin, all again with the same goal of building passive security, as Martin has said. Right? This might mean syntax highlighting, this might mean more information about the code that you're writing and keeping yourself up to.
00:11:45.638 - 00:12:11.368, Speaker B: Date with it, including, as we just said, giving you tools that allow you to find that red line that is kind of like through a new code base quickly. And that's kind of what we're also showing in a few seconds. Then in a live example. Again, I have been talking about this.
00:12:11.454 - 00:13:17.276, Speaker A: Throughout the whole presentation, but the reason why we're building these tools is because of these three main factors, right? We understand that everybody has deadlines, and obviously this comes very much from an auditor's perspective. So this may be biased, but we try to put ourselves in the developer's shoes, right? And think what is important for them and what constraints they have, right, and what challenges they're facing. And we know that everybody has deadlines, right? Time passes. You don't have 200 years to write a code base. At most you have your whole lifetime, right? So good external support is important even when you have strict timelines. And you also should understand your code before anyone else, right? Then other people will need to understand it too, hopefully. But you should be the first person to understand your code.
00:13:17.276 - 00:14:13.730, Speaker A: Right? I can't remember who said this, but code is made to be read by humans and then incidentally by machines. So you should make sure that you understand your code even before someone else does. And when you're new to a language, you learn by making mistakes, right? And our tools can help flatten that curve and hopefully the mistakes associated with it. Right? Again, passive security. Okay? Yeah. And just again, borrowing very much from the preparedness mindset for an audit. And this is actually very specific to audits, right.
00:14:13.730 - 00:15:05.920, Speaker A: But we can also generalize it towards writing safe code. You should document your code, you should make it easy for everybody else to run, right. So understand it first, make everybody understand it and run it. After that, clean it up, run preliminary tools like linker, run proper analysis tools, and then release it to the world. As you might or might not know, we have a branch of toolings. The diligence team has also started a branch of toolings that is now an entity in its own right, Mithex, that does dynamic analysis. Right, like it's a concolic execution engine, static and fuzzer.
00:15:05.920 - 00:16:22.216, Speaker A: But this part that we're talking about today is made to tackle the second and third sections that you see here, right? So it basically helps you earlier in the develop lifecycle so that when you get to steps four and five, you already have both. Again, a good mental map of what's happening in your whole system. You have a good knowledge of where the danger areas lay in your code and hopefully just make everybody's job easier, right? Be developers, quality assurance, auditors, I don't know, whatever is there, what stakeholders are there in the middle. We just want to attack this problem super early in the development lifecycle so that everybody can have like a merrier life. So let's see the lead tools in action. Do you want to take on the screen, Martin, and share the. Let's do it.
00:16:22.318 - 00:16:32.860, Speaker B: We have a couple of minutes left, right? So let's quickly do that. So you should be able to see my wisher studio code instance.
00:16:36.550 - 00:16:39.010, Speaker A: And notice we're doing Aragon.
00:16:40.550 - 00:17:25.934, Speaker B: We're doing Aragon because it all started out with Aragon and Gonzalo trying to make sense of the code base, like years ago when he first had the glance on it. So this is visual studio code, basically. I tried a whole lot of ides, and this is the last thing that actually basically worked quite well. And it is quite extensible. So that's why most of the things I do are nowadays with vs code. In the middle, you see the code editor, there's no window open right now, and on the left side there's the code three or the file three, with all the files I'd like to show you. Like the metrics plugin first you install it from the extension marketplace.
00:17:25.934 - 00:17:55.366, Speaker B: It's all free, it's all open source. You can audit it and then just go ahead, click here. On any folder where you expect solidity files, click right, click solidity metrics. And it will take a few seconds, because it's now parsing, it's finding all the solidity files in there, and it's parsing all of them with the antilab parser in the end. And then we do some nice number crunching on it. So you see like this is the workspace name, table of contents. Let's skip to the scope.
00:17:55.366 - 00:18:51.162, Speaker B: You see what is in scope, what is out of scope, what code base we were using, and then you get that view. And this is quite nice. Like the first time I see a code base, I usually run this tool because it shows me how many solidity files are in the code base, how many contracts are in total in the code base. These are all the logic contracts, and there's nine interfaces in the contract as well. Then you will see for each file you see what type of contract it is, whether it's a library or just an ordinary contract, or even like an interface. From this icon you see the number of lines, normalized source code lines, which is like normalizing the function, signatures, comments that are in the file, which is a good indicator of whether you need to spend a little bit more time on documenting stuff. You get even a complexity score, which is not cyclomatic complexity, but something is much more simpler.
00:18:51.162 - 00:19:32.906, Speaker B: Basically, we find anything that is risky and add a score to it, even if it's a branch. Anything that adds complexity or security concern just adds something to this core. And the higher it is, the more likely, or like the higher should be probably your priority to look at things in here. And we also watch out for any patterns or calls that we know that should be investigated. For example, this file is using hash functions, basically catch up calculations. And this file is doing any assembly stuff. And then we have this file, which is, to be honest, I prepared this so that it does show up with a lot of things.
00:19:32.906 - 00:20:33.770, Speaker B: It's not really the Aragon code base that has all this stuff inside, but you see like there is payable function in there, the construct is destroyable, it's initiating e for transfers and stuff like that. And it's even creating stuff. So you get a nice overview on where might be some risky points in that 60 files of code bases. And it helps you to dissect the interfaces and stuff that you don't need to look at in the beginning. From the stuff that could be very critical in the code base, you get a summary review, you see everything that was excluded from it. We even have some experimental stuff in there, which is kind of like our take on a bit on the risk chart. This is something that we feel like should be presented to solidity developers so that they know the more often they use assembly code in there, the more complexity add to the system and the more time it will take to actually also review that and make sure it's secure.
00:20:33.770 - 00:21:06.120, Speaker B: You get another overview on what type of contracts are instantiated and what versions were observed, and also anything you might want to know from the inner workings of this extension. We just print it out just for fun because we have the data and you also get for everything, inheritance graphs and stuff. This is basically serial output. So this is the metrics plugin I think. Are we already time or do we have like two minutes or three minutes to also show up the auditor extension for a second?
00:21:08.090 - 00:21:12.650, Speaker C: You guys are overtime, but we are running into the break so it's okay.
00:21:12.800 - 00:21:58.220, Speaker B: Okay cool, go for it. So I tried to be fast. So you can also install the solidity visual auditor extension, which is basically this one. Once you install it, it will show up a new icon in the panel on the left side. You can click on it to get like a quick overview. You can also hide it if you don't want to have that because I know I don't want to see all the icons on the left side. So what you can do to explore the code base, for example, is we can click on this view and it should update the workspace Explorer view unless my machine is too slow today.
00:21:58.220 - 00:22:37.986, Speaker B: Let me just quickly try that again. It okay, so it's now searching for all the solidity files in the code base. The idea of this explorer is it should only show you anything related to solidity files. You don't want to see any JavaScript files or any other things so that you can specifically focus on solidity code. So you can browse around whatever you want to see in there. You can right click and even find top level contracts. This is kind of something that I usually do in the beginning when I am exploring new code bases.
00:22:37.986 - 00:23:33.920, Speaker B: I want to see what is the main interfaces to that contract system. So this list that is now populated here will show all the contracts that are the most derived, basically that are not inherited by any other contracts in the system anymore, and they are very likely to be deployed at the end for your smart contract system. You can also, from this view on, just flatten all the files if you want to flatten stuff, but you can also create graphs with basically Syria for certain folders or selected files or anything. So let's just try that. By the way, we always give you the source code so that you can modify stuff because you might want to use it in a different way. So this is basically what's going on in the whole Aragon OS system from Asuria's call graph view. And it's kind of a lot of things.
00:23:33.920 - 00:24:36.184, Speaker B: If we just boil it down to generating the graph for a couple of files, it might even be easier. All right, so that's the view just for the APM part. What you can now do, for example, is some simple taint analysis. If you want to see any calls that reach to root node, then you can even visually trace that path or do any other thing in the code base, however you want to use that. Also you can show the inheritance graph just for this part. Or what's also interesting, a lot of time is you want to see, for example, the UML chart for that file, and you can also just generate it. You can even do that for a flattened version of that file.
00:24:36.184 - 00:25:21.310, Speaker B: So if you click here, flatten that file, it will flatten it down and you can then just visualize that flattened file. This will take you a little bit more time, but it's worth the wait. So this is everything around the ACL flattened, and how the contracts are derived from each other. And we even parse out, which is kind of like an experimental feature a bit. We parse out potential actors in the system. So whenever we see any addresses in the system, we denote them as possible actors to the system. Yeah, so that's basically the graphing functionality that we have in here.
00:25:21.310 - 00:25:28.110, Speaker B: One thing that might also be interesting is let's just go back to for example, ACL for a second.
00:25:28.480 - 00:25:48.470, Speaker C: Just looking at the time, Martin, because we want to allow the people to have a little break at least. What I would like to do is already remind the people on the live stream, if you have questions, please put them in the chat now. And if you have questions in the room, please already raise your hand so that I can estimate whether we need to discuss stuff or whether Martin can go on.
00:25:49.000 - 00:26:20.764, Speaker B: All right, I will come to an end. So one interesting feature we were working on recently is context sensitive information. That's why we call that view a cockpit view. So if you click into a method here, you get like context specific information in these views on the side. This view just shows all the public state changing methods plus their modifiers. So you can see whether create permission has an authentication modifier on it. Just quickly check if any of these are like missing modifiers and stuff.
00:26:20.764 - 00:26:53.940, Speaker B: And the last feature I'm talking about is basically also from Syria, which is the call tracing function. So when you click into this method, for example, it will update the function call trace, which basically shows all the downstream calls that are happening within that method, or even like somewhere in the layer below. And something that we might also integrate in the future is this, into the other action so that you can find all the callers to that function and other things. All right, so that's basically it from the demo side. Bye.
