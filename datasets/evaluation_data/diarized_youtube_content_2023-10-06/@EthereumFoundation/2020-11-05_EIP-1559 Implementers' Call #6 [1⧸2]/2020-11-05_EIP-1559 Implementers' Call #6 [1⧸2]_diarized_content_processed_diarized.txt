00:00:00.570 - 00:00:28.950, Speaker A: It. We are recording. So hey everybody, welcome to 1569 implementers meeting number six. I just shared the agenda in the chat, a couple of people joined in since, so let me reshare it just in case. So first thing on the agenda was just client updates on the testnets. Maybe we can start with methamine. I know Thomas, you just posted an update on the discord.
00:00:30.810 - 00:01:01.854, Speaker B: Yeah, sure. So we're fully synced with validating blocks. So Abdul Hamid mentioned that there is some problem with filling the blocks. I believe at the moment the issue with synchronization that we've seen last week. So when I looked at it, it was very small thing. So I left the code that was comparing the available block space for both the old style transactions and the new style transactions. And since we merged them together in the transaction pool and in the blocks, it was no longer important.
00:01:01.854 - 00:01:15.620, Speaker B: So when the old style transactions appeared, we treated them as beyond the space in the block for them and we rejected the block. But after removing that code that checks, it's all fine.
00:01:16.650 - 00:01:23.080, Speaker A: Cool. Yeah. Abdel, do you want to give an update on the basic side?
00:01:24.090 - 00:02:08.600, Speaker C: Yeah, so nothing really new on the core Ethereum client, except some new fields added to some RPC endpoint, like the get block by number and get block by hash endpoints to basically return the base fee. So corresponding to the three EIP, I wrote about adding the EP 1559 fields to the existing RPC endpoints, for example for endpoints that return block fields. And yeah, we are working on the tooling but we have a specific item on the agenda about that. So I will talk about that later.
00:02:10.170 - 00:02:15.160, Speaker A: Cool. And Rick or Ramil, do you want to get an update from the get side?
00:02:16.170 - 00:02:42.670, Speaker D: Yeah, I can provide updates. So we completed updating get code to be aligned with latest version of AIP and also we tested synchronization gas to Geth and geth to be sue and it works well. And now we are working on testing Geth to Nethermind.
00:02:44.790 - 00:02:53.010, Speaker A: Got it. And when you say test, you ran your local network or have you been syncing on the network that we've been using with leathermind?
00:02:53.590 - 00:02:56.482, Speaker D: No, it's local network.
00:02:56.626 - 00:02:57.880, Speaker A: Okay, got it.
00:02:59.210 - 00:03:14.620, Speaker C: Yeah, I would suggest to skip that step and test directly on the testnet because we are in sync with netamine. So if that works with Bezos, that should also work with netamine. But it's up to you. Just saying.
00:03:16.030 - 00:03:24.734, Speaker D: Yeah, I have questions about test network. How can I join to that? Can I get.
00:03:24.932 - 00:03:29.214, Speaker C: Okay, so we can talk about that later because I have a point about.
00:03:29.252 - 00:03:30.638, Speaker E: That during the demo.
00:03:30.724 - 00:03:32.160, Speaker C: Yeah, sure.
00:03:38.350 - 00:03:57.200, Speaker B: One important thing is that most likely you'll have a person joining on the research press development side part time, specifically involved with EIP 1559, only for an end of mind. Most likely it's happening next week.
00:03:58.850 - 00:04:21.480, Speaker A: That's really good news. Cool. So yeah, I guess this is kind of from the client side, maybe. It makes sense. I know, Barnaba, you had a new notebook as well that you released this week or last week, I forget, do you want to give a quick update on that before we dig more into the Testnet stuff?
00:04:22.570 - 00:04:26.060, Speaker F: Sure, whatever you prefer. I can do it after the testnet as well.
00:04:26.990 - 00:04:30.860, Speaker A: I'm just concerned we end up getting bogged down in the testnets and we don't have time.
00:04:34.430 - 00:05:02.900, Speaker F: Wait. So I released this new notebook which looks at the combination between 1559 and the escalator. So this idea that you can have 1559 to have like a nice default market price for the transaction. And meanwhile, users can use this kind of incremental bid strategy to increase their bids over time. Let me just post the link here.
00:05:04.810 - 00:05:05.560, Speaker E: Right.
00:05:06.490 - 00:05:08.070, Speaker F: Should I share my screen?
00:05:08.220 - 00:05:11.720, Speaker A: Sure, yeah, go ahead, do that.
00:05:15.310 - 00:06:16.314, Speaker F: Right. So in one of my previous notebook, I kind of show that whenever demand is shifting quite fast and increasing, users have the incentive to become strategic and to kind of try and overbid each other, which is what we see currently in this first price auction mechanism that we currently live in. And so this idea of the escalator was coming to say, well, many people are doing this resubmission pattern on the wallet. So you send a transaction and you resend it, you bump your gas price a little bit to hope that now you are more competitive. And the idea of the escalator is to take that pattern and put it in the protocol and allow you to decide on how low your bid is starting from and how high you are willing your bid to go. And over time, your bid is just increasing between these two bounds. And it's kind of a neat idea.
00:06:16.314 - 00:07:07.530, Speaker F: But the main, let's say, problem was that it has a lot of parameters, like you have to decide your start bid, you have to decide how high you're willing to go, you have to decide how fast you want to go as well. And the nice thing about 1559 is that we actually get kind of this default price, which is you're being quoted this entry price to the transaction gas market. So the idea of combining the two is to at least remove at one parameter, which is how high you should start your bid, like you should start it at what the base fee is currently. And then in this notebook, I was trying to investigate, let's say, different strategies. So I look at two strategies. First, maybe I'll show, like, okay, this picture kind of shows you in blue. Here you have a base fee, which is moving around.
00:07:07.530 - 00:08:00.062, Speaker F: So here you assume that it's increasing, maybe because the demand is increasing, and you have two players, like Alice and Bob. And Alice is kind of in a more of a hurry than Bob is. So she would set her bid to rent faster than Bob does. And so what happens with this mechanism is you kind of track the base fee. So your bid looks like it's varying the way the base fee is, but over time, you keep adding a bit more to your bid, and you keep saying, hey, minor, my bid is getting higher and higher. So now maybe you want to include me. And so that may be helpful in these cases where the demand is increasing and users would rather try and compete against each other rather than take the base fee as a market price.
00:08:00.062 - 00:08:47.194, Speaker F: So really, like the escalator, it's more expressive than plain vanilla. 1559 is. But the question is, do we care about this expressiveness at all? What do we gain from having this more expressive bidding language? And so what I try to introduce in the notebook is this idea of efficiency, which is how we look at, let's say, the performance of a mechanism in game theory. So we really care that users which have very high value for their transactions, go in first or go in as fast as possible. And so I'm looking at these two different strategies. So this one is a strategy where I have, let's say, very high costs. I don't want to wait.
00:08:47.194 - 00:09:17.480, Speaker F: I'm trying to arbitrage this transaction, and so I want to get in as fast as possible. So I look at how much costs I have for waiting, and I set my escalator to ramp about as fast as my cost is. So the more it pains me to wait, the faster I'll get my escalator to increase, and maybe I'll let you read through it. I'm also planning to release videos, and I haven't gotten around to it, but I think it'd be nice to have a bit of an audio description as well.
00:09:18.250 - 00:09:18.774, Speaker B: All right.
00:09:18.812 - 00:10:11.160, Speaker F: No, I don't want to get into this. But the second strategy sort of encodes a different behavior, which is sometimes I don't really care that my transaction goes in as fast as possible. I just want it to go in at some point. So I'll just tell myself, okay, I'm willing to wait for ten blocks and I'll keep increasing my bid, escalate my bid over time until these ten blocks are done, and hopefully I get in by the time of these ten blocks. So the interesting thing is that when the users in your transaction market use these different strategies, you really see different, let's say, behavior of the market as a whole. So even visually, not going to go into the details, but visually you see that it's kind of very different. I picture users as dots, and the color of the dots is the wave of users that are progressively coming in.
00:10:11.160 - 00:10:45.940, Speaker F: And I think it kind of gives some intuition. It's definitely like an introductory work because there's a lot more work to do on, let's say, figuring out these strategies. In game theory, we like to know that, okay, is this an equilibrium or not? What should I do as a user? What is my best strategy? So yeah, this is kind of still on the roadmap to figure out something I actually hope to do with a team here in Singapore. So yeah, maybe more detail on this at a later point, but read through it and let me know if you have any questions or thoughts or if it's helpful at all.
00:10:51.750 - 00:11:08.380, Speaker A: Thanks. Does anyone on the call have any thoughts, questions? Okay, in that case, maybe Abdal, it makes sense for you to take also a couple of minutes to walk through some of the tooling you've been working on.
00:11:09.150 - 00:12:03.674, Speaker C: Yep, sure. So to give a bit of background so we can see that Ztip introduces a lot of breaking changes in term of UX and all of those stuff with the new block header field and the new transaction fields. So that impacts wallet providers, block explorers, so almost all the chain. So we decided to implement some tooling around EP 1559 to make it easier for users to interact with the testnet. Also for client implementers that will join after that will be easier for them to do their implementation than to validate it. So yeah, I will show you some of the tooling. Let me share my screen.
00:12:03.674 - 00:12:46.954, Speaker C: Okay, so first we have standard components that have a rest API. So we have open API documentation. So this is pretty standard documentation. So we have some not RPC. So we have some rest APIs to basically submit transaction using legacy style or the new format style. And yeah, another thing is likely we will have to change the format of the transaction again when we will use the type transaction envelope. So if we already have this tooling, we will change only one tool and that will be profitable for everyone.
00:12:46.954 - 00:13:51.210, Speaker C: So yeah, some API to play with transactions and some API to basically retrieve the basic because this is not yet integrated in the current RPC endpoint. So you can try directly using this interface. Yeah, I have to choose the right endpoint and yeah you can get the base. So if you don't specify the block number, it retrieves the base of the latest block and you can get the base at a given block. Here it is. This is a standalone HTTP service and on top of that we also built web interface to make even easier for users to play with it. So yeah, obviously there is an issue there because you have to specify the private key because metamask and all other wallet providers don't have the new format transaction.
00:13:51.210 - 00:14:46.398, Speaker C: So I'm planning to add a whitelist mechanism to accept only private keys from the genesis and this is already what I do in the web interface. For example, you can choose among a list of accounts that is loaded directly from the Genesis. So the UI provides some links to the specification work updates. Also we have a block explorer for the testnet and network status so we can see the three bezo nodes and the net and my node. So if anyone needs the credentials for the ED stats let us know in the Discord channel. And we started also to write a wiki guide basically to join the testnet. So this is why I'm gathering information from netamind and get as well about the branches to use.
00:14:46.398 - 00:15:38.702, Speaker C: I will need also the Genesis file and the configuration file and the scripts to launch the different clients. So if you need the Genesis you can click there and you will have the Bezo Genesis. That will be great. If you could provide me the term genesis and get Genesis as well. Same for the CLI option or config file will be even better. And yeah, basically let's do a quick demo so you can specify all the transaction fields. So I'm in legacy mode, so I have only the already existing fields I can set autonomous so it will retrieve the nons using the add transaction endpoint I can show the recipient the value, the unit gas limit and gas price.
00:15:38.702 - 00:16:19.578, Speaker C: So this will be a legacy transaction that will be automatically converted to an EP nine transaction. So you have the link to the Explorer, so the transaction has not been mined. Here it is. So you can see the information of the transaction. So we have not updated yet the Explorer to integrate E 1559 fields. So this is why you can see the gas price set to zero. And yeah if I switch to 1559 I can see two new fields and the gas price is not available anymore.
00:16:19.578 - 00:17:11.838, Speaker C: So the minor bribe and the fee cap so the minor bribe will be added on top of the base fee. I have a helper button estimate that basically take it sets the minor bribe to one way. The value is configurable for the settings and it also add a margin on top of that. And also it retrieves the latest basi. And there is an addition with all those three things to have a working fee cap. So obviously you can play with different settings, but this is just to have an easy to do settings and basically you can submit transaction the same way. Okay, it has been mined and yeah, that's it.
00:17:11.838 - 00:17:59.440, Speaker C: And about the tooling, we also have a tool that basically stress test the network and try to fill blocks. So let me show you one block for example that have been created 20 minutes ago. There is nearly 2000 transactions in that block for gas used, near 40 million. So we almost reached the maximum block elasticity. And this tool is a command line tool. So all those tools are open source. And I will provide the links of the repositories in the discord channel.
00:17:59.440 - 00:18:02.560, Speaker C: And yeah, that's pretty much it.
00:18:07.570 - 00:18:21.380, Speaker A: Cool. Thank you for the demo. Any other thoughts comments on it? Okay, sorry.
00:18:24.010 - 00:18:26.360, Speaker B: I say it's really cool. Great job.
00:18:27.850 - 00:18:28.600, Speaker C: Thanks.
00:18:32.810 - 00:18:33.346, Speaker B: Sweet.
00:18:33.378 - 00:19:09.298, Speaker A: So I guess the next kind of big thing to figure out is what are the next step for the testnets. So it seems like we have Basu and Nethermind kind of 95% there. Geth and Basu seems like it's pretty much there and we still need to see what Geth and entermind. How much more time do people think we need to spend on the POA network? And then is it worth starting to look at proof of work in parallel? What do people feel is like the best next step?
00:19:09.384 - 00:19:24.102, Speaker E: Here's nice to agree on if we're going to do 20 718 or not. So we can get that in mind.
00:19:24.156 - 00:19:42.670, Speaker A: Okay, yeah, maybe we can start there. My I guess opinion on 20 718 is I would implement it once. It's actually kind of scheduled for a hard fork block on main net. I'm just scared that, I don't know, it gets pulled out at the last minute or kind of changed or whatnot.
00:19:43.890 - 00:20:09.800, Speaker E: So even if it's not scheduled with 29 30, then it will be scheduled with 1559, I believe. I think the plan is that 20 718 will go out with the next new transaction type, whatever that is. If that's not 29 30 in Berlin, then 1559 is a good candidate for the next. I don't believe anyone really wants to release a new transaction type without it. It's the impression I've gotten at least.
00:20:15.050 - 00:20:32.446, Speaker A: I guess. Yeah. My only concern is it feels like it's not really a blocker to add 20 718 support. Right. Like we know we can do it and it's pretty straightforward and there's no kind of huge rush to do it as well because 1559, yes, it's not.
00:20:32.468 - 00:21:01.442, Speaker E: A long poll, certainly it's just one of those things that needs to be done sometime before 1559 launches. And if we are waiting for someone to implement, like if we wait to do 15 or 20 718 until later, then it means open Ethereum and Geth have to implement something and then change it. Whereas maybe it will encourage them to implement if they're implementing a more complete spec. One of the problems that I know we're having is trying to get other people to implement. Maybe that's contributing to their hesitation.
00:21:01.506 - 00:21:31.700, Speaker A: I think open Ethereum, my hunch is they probably won't implement anything until it's actually scheduled for. Mainnet turbo get said that they don't really have an issue with implementing 1559, but they're just not in a rush to do so. I personally would be a bit biased towards trying to test proof of work before just to make sure that there's no actual issues there. But yeah, I'm curious. I don't know. Thomas and Rick, do you have any strong opinions on that?
00:21:32.950 - 00:21:49.238, Speaker D: My opinion is not very strong, but my preference would be to implement 20 718. Is that what it is? To implement it sooner rather than later?
00:21:49.404 - 00:21:50.166, Speaker A: Okay.
00:21:50.348 - 00:22:26.210, Speaker D: I just don't see any. I mean, the work has to get done either way, and I'm not entirely clear where the total roadmap is. Frankly, I do believe the plan is to move to the single transaction type. And once we've done that, there's no two pools anymore, there's just one transaction type. Once that's done, is there anything else that needs to really be done besides the enormous amount of testing?
00:22:27.670 - 00:22:52.700, Speaker A: Yeah, no, I think 2000 and 718 is the last kind of major spec change. And after that, yeah, I think it's testing both proof of work and just like dealing with a large state, which is something we're starting to do on the basis side. But yeah, I think in terms of big changes to the actual EP itself, 20 718 would be the last one.
00:22:53.070 - 00:22:57.738, Speaker D: I'm sorry, when you said large state, you mean just the fact that the blocks are bigger, so there's more state?
00:22:57.904 - 00:23:26.440, Speaker A: No. So one thing we're trying to work on at Baseu is to see the performance impact of 1559 on a network that has kind of a state comparable with main net. So we're going to start building just local test nets at first to have 10,000 accounts, then 100,000, a million and whatnot, and see if there's any major performance impact of 1559 on those. But that is something we can do in parallel, and it'll probably take a couple of weeks at least to get going.
00:23:27.370 - 00:23:28.120, Speaker D: Okay.
00:23:28.490 - 00:23:29.238, Speaker A: Yeah.
00:23:29.404 - 00:23:46.730, Speaker B: Two questions for me. One, Rico is suggesting two pools, and we already have one pool only on EIP 1559, and there is no need for introducing two pools because the two transaction types, they very nicely convert.
00:23:47.550 - 00:23:49.030, Speaker D: We're already at one pool.
00:23:49.110 - 00:23:49.674, Speaker B: Okay, great.
00:23:49.712 - 00:23:53.360, Speaker D: That was the last major change I was aware of, but it's already been done.
00:23:53.810 - 00:24:12.850, Speaker B: Sorry then I misunderstood you, team. You say to check the state size, how would tip 1559 even affect the state? It doesn't really change the behavior of the existing system. So it feels like, okay, understand that the block size might be bigger, but it's only temporary.
00:24:15.990 - 00:24:17.322, Speaker A: Go ahead, Abdel.
00:24:17.486 - 00:24:39.820, Speaker C: Yeah, I just wanted to say this is because people are already worried about the actual state and the pace goes up and effectively 1559 won't because of the block elasticity. Some people are worried about the negative impact it can have.
00:24:40.430 - 00:24:42.780, Speaker B: Yeah, but how can you just.
00:24:44.610 - 00:24:44.986, Speaker A: What'S.
00:24:45.018 - 00:24:55.650, Speaker B: There to compare between the AIP 1559 and the existing state? The state will be growing potentially, like, I think 10% faster, but it's only temporary.
00:24:56.550 - 00:25:14.998, Speaker E: I believe the fear is there's some supra linear issue with gas per block and a single block that is twice as big. When interacting with a large state network like Mainnet could have superlinear costs that are not.
00:25:15.164 - 00:25:36.494, Speaker A: That's exactly it. So I think if we can at least run this, have a testnet which has 100 million accounts and a smart contract with 100 million storage slots, we can run it both on 1559 and not. And just see, is anything kind of much worse under the 1559 case where the blocks are twice as big, really.
00:25:36.532 - 00:25:54.566, Speaker E: The test we need could be done without 1559. Just having a 40 million gas block against a large state network. Like you could simply fork off a main net, set the block gas limit to 40 million, and then fill a bunch of blocks and see if anything crashes. I think that's what is desired here.
00:25:54.668 - 00:26:16.330, Speaker B: So team, instead, maybe instead of faking this network, big network, let's just fork Mainnet and that will be better test and faster achievement of just fork mainnet. For private testing, we can use any accounts that we want to create, disable signature checking.
00:26:20.130 - 00:26:24.270, Speaker A: Yeah, go ahead, Adele.
00:26:25.010 - 00:26:30.478, Speaker C: It will be harder to have accounts with large value of it.
00:26:30.644 - 00:26:34.114, Speaker A: Not really though. You can add that in the hard fork. Right, okay. Yeah.
00:26:34.152 - 00:26:34.740, Speaker B: Okay.
00:26:35.750 - 00:26:36.210, Speaker A: Yeah.
00:26:36.280 - 00:26:37.620, Speaker C: Okay. That makes sense.
00:26:38.390 - 00:26:50.840, Speaker E: You could just disable signature checking and then you could use any account you wanted as part of the fork. That way you could test with any account that has any arbitrary real world situation going on.
00:26:54.090 - 00:26:59.240, Speaker B: There is nothing like signature checking, it's just the extraction of the address. So this is a bit harder to do.
00:27:00.350 - 00:27:11.230, Speaker E: Have the signature like you just have the r value is just treated as an address. So you just say whatever the r value is, use that address as part of the fork if one wanted.
00:27:11.300 - 00:27:16.960, Speaker B: Could be, but then the format of transaction is different. So it seems like a bit more work.
00:27:17.650 - 00:27:23.498, Speaker A: Yeah. Than just adding your list of accounts, like adding your list of whales basically as part of the hard fork.
00:27:23.594 - 00:27:28.034, Speaker B: Yeah, this seems super simple. That's what I say, this seems simple. And the other one is requiring new.
00:27:28.072 - 00:27:38.134, Speaker A: Transaction format, which, and I guess I assume we can also change that in a hard fork, but we could change the hash rate as well. Right? Like just lower the hash rate back down to basically zero. Yeah.
00:27:38.172 - 00:28:12.590, Speaker E: You want to set the difficulty to zero, so that way you can mine on your three difficult laptops. Just as a slight side note, in general, I think that this being able to fork Mainnet and test would be very useful for many people in many situations. So if you guys do do this, add this feature into your clients, it'd be awesome if you kind of formalize it at least a little bit, just so someone can use a config file that does this in the future. I know, I've wanted it many times in the past during testing.
00:28:14.690 - 00:28:34.200, Speaker B: You can share the net of mind chain spec for such a chain and then you can sync to it. So if we launch a public testnet on it, then people will be able to start testing it. That will be great actually, because practically everyone who has the main net Eve can just use a different chain id for signing transaction and start experimenting on it.
00:28:35.550 - 00:28:39.046, Speaker E: Yeah. You're saying there's existing tools like that, Rick?
00:28:39.158 - 00:28:44.870, Speaker D: Yeah, like hard hat apparently claims to do that I haven't tested.
00:28:45.030 - 00:28:45.740, Speaker E: Nice.
00:28:46.270 - 00:28:52.830, Speaker D: It used to be called builder, but now it's called hard hat. Apparently it will fork from Mainnet.
00:28:55.410 - 00:28:59.470, Speaker A: Yeah. If you can share a link to that Rick in the discord that would be.
00:28:59.540 - 00:29:00.960, Speaker D: Yeah, yeah. Give me a.
00:29:04.130 - 00:29:20.520, Speaker A: So does, I guess just from a testnet perspective, does it make sense then to go from this proof of authority testnet we have now to that fork of Mainnet. Do we want like a smaller proof of work testnet in between or should we go just a forking main net?
00:29:22.170 - 00:29:23.670, Speaker B: Let's go to Mainnet.
00:29:25.530 - 00:29:29.510, Speaker A: Anyone feel like we shouldn't do that test and prod?
00:29:29.590 - 00:29:32.300, Speaker B: Basically no main net policy.
00:29:32.830 - 00:29:39.450, Speaker A: And I guess if we get 1000 bugs forking Mainnet, maybe we can try something easier.
00:29:40.510 - 00:29:55.300, Speaker B: I think will be very useful for the future as well. Just like main networking for testing different eips. Imagine for every single eip we'll be able to create a separate fork and people will be able to use their accounts that they are used to to check if their contracts work fine.
00:29:55.670 - 00:30:18.460, Speaker A: Yeah, I think that's a good idea. Okay. So I think it's still worth kind of just ironing out the details on the proof of authority testnet to make sure we're actually all kind of compatible with each other. Should we implement 20 718 before we fork Mainnet? So like when we do the fork of main net, should that be a new version of the 1559 spec?
00:30:19.390 - 00:30:21.100, Speaker B: I would prefer not to.
00:30:21.550 - 00:30:23.494, Speaker A: Okay, so just go to Mainnet AsAP.
00:30:23.542 - 00:30:24.860, Speaker C: Yeah, same.
00:30:27.810 - 00:30:39.920, Speaker A: Okay. And then once we've forked main net and we see that it generally works, then we can add the change for 20 718, right?
00:30:41.250 - 00:30:53.250, Speaker B: Yeah, we plan to have it for 29, 30 pretty soon. So I think there won't be big time difference, but just wouldn't like to say that we have to have 20 718 to just do the fork of this test.
00:30:53.400 - 00:30:55.522, Speaker A: Okay. Yeah.
00:30:55.576 - 00:30:57.540, Speaker E: And Abdel with your, let me know.
00:30:58.570 - 00:31:00.070, Speaker A: Sorry, go ahead, Micah.
00:31:00.970 - 00:31:14.906, Speaker E: Just let me know once you guys are ready to do 20 718 and I'll update EIP 1559 with it. I've been waiting until you guys are ready. I didn't want to have the AP once again out of sync with what's actually live since I had problems before.
00:31:15.088 - 00:31:55.480, Speaker A: Okay, so yeah, let's do that. Let's try and a finish the proof of authority work we have right now in parallel. I think know at the basic team we can start looking at just the hard fork for Mainnet and what that would look like and share that information. And so hopefully by the time that's done, we have everyone kind of agreeing on the spec on POA and then we can do the fork with multiple clients on the main net. And then after that, assuming everything goes smoothly, we can add the spec for 20 718 as part of it and we'll already have this main net size testnet. Does that generally make sense?
00:31:57.390 - 00:31:58.140, Speaker B: Yes.
00:32:00.270 - 00:32:32.882, Speaker A: Um, cool. Anything else on testnets? Or just next steps in terms of testing, if not. Just last thing I think I wanted to go over is just this main net readiness checklist to make sure it's still roughly up to date. Based on this conversation, I'll have to change it, but just also useful for people tuning in. It's kind of where we keep track of things that needs to be done. So the client teams have been changed, I guess. Never mind.
00:32:32.882 - 00:32:35.026, Speaker A: You did hire somebody so we can remove this?
00:32:35.128 - 00:32:38.390, Speaker B: Yeah, I cannot yet confirm it 100%, but mostly.
00:32:39.930 - 00:33:11.710, Speaker A: Okay. So I'll leave it up for now and pin me when you want it to remove. In terms of issues, dos risks, I mean, this is kind of separate from this EIP itself. So I don't think we can do much except kind of forking main net like we just talked about, and that maybe gives some interesting data. Transaction encoding, decoding. We'll wait for 20 718, but do that afterwards. Replace by fee, I think is the other thing we haven't fully sorted out, and it's kind of related to transaction pool sorting.
00:33:11.710 - 00:33:24.200, Speaker A: But how do we actually sort transactions and replace them in a transaction pool without creating denial of service risks? I know. Barnaby. Sorry, go ahead.
00:33:25.130 - 00:33:44.940, Speaker C: Yeah, I think we kind of assume that we would have to prioritize new format transaction because we have removed the migration period. So if we don't do that, there will be no incentive to use the new format. Right.
00:33:46.270 - 00:33:50.206, Speaker A: So the incentive to use the new format is you get a refund on your fee cap.
00:33:50.388 - 00:33:51.920, Speaker C: Oh, yeah, that's true.
00:33:52.690 - 00:33:55.550, Speaker D: We should probably prioritize the transactions.
00:33:57.010 - 00:34:04.530, Speaker A: So you're saying 1559 style transactions do what? In the transaction port or in the block? They get prioritized?
00:34:05.590 - 00:34:16.546, Speaker D: Both. They just get prior. Either. Well, if they're prioritized in the block, that's pretty much the same thing as saying they're prioritized in the pool.
00:34:16.738 - 00:34:22.360, Speaker A: Yeah, I guess it's a stricter prioritizing, right?
00:34:22.810 - 00:34:23.560, Speaker D: Yeah.
00:34:24.250 - 00:34:44.590, Speaker E: While I agree that altruistically prioritizing would be good, it's in a miner's interest to choose the one that's going to pay them the most, regardless of what we suggest they prioritize. And therefore, clients who want miners to use their clients will write code that miners like, which means pay them more. I don't think we can really enforce that.
00:34:44.740 - 00:34:51.550, Speaker D: I work with miners. I don't know that I necessarily buy that narrative. Miners.
00:34:54.450 - 00:35:02.174, Speaker E: You think they'll use whatever we write? Yeah. If those of us in this room agree to just write the same thing, then they'll just use that same thing as your theory.
00:35:02.302 - 00:35:44.180, Speaker D: Yeah. And I don't really see the downside if miners do choose to rewrite. I guess my thinking is the social consensus should be that we're all moving towards 1559 style transactions. We're kind of on this call trying to, through this bizarre process, figure out what the social consensus is. So I think we should be pretty assertive in actually we should assert that these new transaction types are the preferred type and we should do that by telling the clients to sort them, insert them first. And if someone wants to write their client, they can do that.
00:35:45.430 - 00:36:27.050, Speaker B: There's not only miners but also the users who may not have access to the tools for some of the operations that will be executing. So not all of the users will be able to switch quickly. And it doesn't feel like there is such a requirement to prioritize the new transactions very rapidly. So they will all work very nicely side by side. The pool works nicely side by side. We plan to prioritize based on the fee paid to miners as resulting from the discrepancy between the gas price, gas fee, max cap and so on. I think it would be risky to create two different markets without because we removed the transition.
00:36:27.050 - 00:36:43.170, Speaker B: But also if we started doing some kind of prioritizations, it will create two markets that would be competing, not on the same basis. And we don't have any analysis of the behavior of such market. And some users could be just removed from that market just because they cannot use some tooling.
00:36:44.410 - 00:36:49.270, Speaker D: So how do you expect people to stop using the traditional transactions?
00:36:51.130 - 00:37:09.654, Speaker B: More and more tools will be using them and they'll be like, if the ape 1559 is solid enough and if it sells for users, the predictability of the gas prices, as we all proved that it does via simulation, then users will be moving towards those better tools.
00:37:09.782 - 00:37:17.086, Speaker C: But in that case, maybe wallet providers won't do the implementation. If they can do, they will because.
00:37:17.108 - 00:37:24.740, Speaker B: They compete on the market to be the best tool available on the market for the users. They will want to have their users be able to use EF 1559.
00:37:25.830 - 00:38:01.040, Speaker D: So I mean, let's. No, I don't know that competition in the, I guess philosophically, philosophically that seems inconsistent to me. So either we are deciding what the new transaction type is or we're going to allow people to choose. I don't think we can split the difference.
00:38:01.810 - 00:38:16.020, Speaker A: I feel like the way we've been moving is though to allow people to choose. Right. Because by removing the transition period, we're basically saying, go ahead. Yeah.
00:38:18.390 - 00:38:20.354, Speaker E: I didn't mean to up. Sorry, I thought I heard a break.
00:38:20.392 - 00:38:22.180, Speaker A: No, yeah, go ahead.
00:38:23.430 - 00:38:34.840, Speaker E: So just to be clear, this prioritization will only come up in full blocks, right? So if our estimates are correct like 5% of the time, we'll actually have prioritization matter. Am I correct in that?
00:38:36.090 - 00:38:37.194, Speaker B: I don't think so.
00:38:37.312 - 00:38:44.780, Speaker A: I guess the time it will come up is like right after the hard fork. Right? But this is not like a huge deal.
00:38:46.590 - 00:39:11.300, Speaker E: For like 15 minutes. Yes, because we are expecting while we're ramping, but then after that, I believe the expectation is we should not see really prioritization have any effect except for in overfill blocks, meaning more than two x demand increase. So I think whichever route we choose probably doesn't matter too much because of that.
00:39:11.910 - 00:39:12.274, Speaker A: Yeah.
00:39:12.312 - 00:39:26.230, Speaker D: So my assumption is that no one is going to change with, I mean, the incentive as I understand it now, is that there's a discount on the 1559 transactions. How big is that discount?
00:39:28.490 - 00:40:09.238, Speaker E: I think the reason wallets will change. I actually have a blog post that I'm going to post probably tomorrow about this, but I think the reason wallets will change is because it solves a major support headache for them. Coinbase wallet is the kind of canonical example because they do not allow the user to set the gas price. They set it for them because they have determined that setting gas prices is too complicated for their users. And so the problem is that this works great, except for when there's increasing congestion, at which point Coinbase users all simultaneously suffer because all of them end up stuck as pending transactions. And those pending transactions compound these spells because the users don't know how to deal with it, and so they just send more transactions thinking, oh, that one didn't work. Let me just refresh the page and try again.
00:40:09.238 - 00:40:51.902, Speaker E: And then they end up with like 15 transactions stuck. And then they need to get specialized support to help them get out of that. The Coinbase wallet doesn't actually let you solve that problem yourself. You have to switch wallets to solve it. So you have to switch over to metamask or just wait. And so Coinbase, for example, I strongly suspect, and I haven't talked to them, but just based on having to support their users, they are bleeding users to metamask every single time congestion happens, because every support channel I'm in says to people, oh, stop using Coinbase wallet. Whereas with nine, they can just set the base fee to like two or three times the current base fee, and their users will basically never get pending transactions unless we have some crazy ramp up in gas prices.
00:40:51.902 - 00:41:04.294, Speaker E: And so I think for wallets, that's the big sell. This solves a major user UX problem that causes heavy support load. And then I think users will just follow their wallets. That's my theory. We of course can't know for sure.
00:41:04.332 - 00:41:51.318, Speaker B: Until we see if we look at the transactions, the way they are treated, they all become EIP 1559. They just come in more efficient or less efficient as the gas price is defined, either as a max fee and gas premium which actually can give you some discount, or as a gas price which always pays maximum potential gas premium. They all EIP 1559. We are totally free to support them indefinitely after transition to ep 1559. Ep 1559 by itself, it solves the problem. Whether you make everyone start using new transaction type or not. And the users will, because of how good it will be in simplifying their pricing mechanisms and saving them some of the gas fee, they will transition to the tools with e one five five.
00:41:51.404 - 00:42:23.454, Speaker D: So I think you're making. I agree with your argument, even though I don't think it's ontologically. Look, you're basically saying when you use users, you mean wallets. You're saying that wallets will. Because basically, if I use this other old wallet that doesn't update, my gas fees are going to be higher by using the old wallet. So the wallets will change. Because the whole problem here is the users don't have this.
00:42:23.454 - 00:42:47.530, Speaker D: We all know so much more about how this system works than a normal user. The users aren't going to know what's going on. All the user is going to see is that if they use wallet a, their fees are whatever percent cheaper than if they use wallet wallet B. So they're going to stop using wallet B. And that's a perfectly fine model. But then my question is, how big is that discount?
00:42:48.750 - 00:43:40.954, Speaker A: It depends. So I think the way to think about that discount is almost more in the engineer time you spend on your gas estimation algorithm. Because in theory, if you use the legacy transaction format and you estimated things just right where like your fee cap or, sorry, your gas price is equivalent to the base fee plus one guay and you get that estimate just right, your discount might actually be zero, right? Like you might be able to sneak in at the right 1559 price using your legacy transaction. But the challenge is like, that's just a hard estimation to do, whereas under 1559, it's kind of trivial. So I feel like the discount is more like the engineering effort you spend on your estimation algorithm, which will not be kind of perfect. Does that make sense? Yeah.
00:43:41.072 - 00:43:48.002, Speaker B: Problem that you are solving with vip 1559 is that people have trouble to actually calculate this perfect pricing.
00:43:48.166 - 00:43:48.880, Speaker A: Exactly.
00:43:49.490 - 00:44:26.230, Speaker B: The minimum discount will be zero, but you'll be never paying less with the all site transactions. When I say users, I don't mean only wallets. I mean also many users that build their custom tools, custom algo trading tools or whatever, that are actually generating transactions with their custom built solutions based on the client code. And there are probably plenty of users like this, and it might be a very big cost for them to have to transition to tools and some risk potentially, and we want to avoid that risk. I'm talking about users in general, whoever is signing transactions, generating transactions.
00:44:26.390 - 00:45:35.920, Speaker D: So by volume, which group do you think represents the majority of? I understand what you're saying there. I think that's a very different model for who the chain is for, right? If you are making millions of dollars a day running your Arp bots, then you can figure out how to patch your code, right? I'm not worried about those people. They're all very savvy and very capable. I'm more worried about the broader base of people that represent the larger numeric number of people, not the value on chain. Right? I mean, at some point it's like, why are we doing this? If we're doing it to facilitate arbitraging, then there's no point in even having this call. If we're trying to increase adoption and make more applications viable on Ethereum, then that's when these sorts of changes become important.
00:45:36.930 - 00:46:06.680, Speaker F: The broader base of user would be the one that is using the most common tools, and the most common tools would be the ones who would be implementing EIP 1559, like metamask or Coinbase wallet. So yeah, I think it's okay to think like this, but I do see that there is an incentive for, let's say, the major wallets that the non power users are using to shift to 1559.
00:46:08.670 - 00:46:52.450, Speaker E: So I think my opinion on the why switch is not for the fee saving. I don't think Coinbase wallet is going to add the code to save fees for their users. I don't think metamask is going to add the code save fees for their users. I really do think both of them will change because it improves the UX for their users pretty significantly in certain situations, and those situations are a support nightmare. I currently have a team running support in Uniswap, and the number one problem that Uniswap users have questions every single day. Scammers are number one. Number two is my transaction is stuck pending.
00:46:52.450 - 00:47:39.480, Speaker E: This is the support load for decentralized apps and decentralized end wallets. The number one question after I got scammed is why is my transaction pending? What is a gas fee? Why do I have 17 queued transactions? What happened? How do I fix this? This is where support comes, costs come from. And so I think 1559 makes it so. That should only happen incredibly rarely, like when you have six blocks in a row that are all double full, which we expect to be an incredibly rare event. And so I'm of the opinion that the gas savings, the fee savings is not the big deal. I agree with Rick that people will not switch for that gas savings because it's fairly minimal in the end. But I do think people will switch for that.
00:47:39.480 - 00:47:53.660, Speaker E: And I think that's where I disagree with Rick at least a little bit. It's just that I do think people will or wallets will voluntarily move, which will cause users to move because users will follow the wallets just because the support burden is so high for this issue.
00:47:55.550 - 00:48:21.380, Speaker A: I guess to take a step back about the transaction pool sorting, this is not something we can enforce in consensus without major changes to the spec. I personally would be pretty opposed to doing that just because this is already a hugely complex ep and trying to enforce ordering in every single block feels like you're adding another.
00:48:22.310 - 00:48:25.670, Speaker E: I don't think there's even a known solution to that problem right now.
00:48:25.820 - 00:49:07.060, Speaker A: Yeah, so in that case, basically the transaction pool is outlet consensus. We don't necessarily have to have a solution on that now, and it's also something we can update. We don't need a hard fork to update it, right? We can update it in biweekly release of guest or Basu or whatever if we see that there's an issue. Obviously that's not like 100% true because miners won't have to update their notes then, and they will at the hard fork. But I guess it feels like kind of a pretty big rabbit hole that we might not get resolution on right now and we can totally fix.
00:49:07.910 - 00:49:37.162, Speaker E: I agree we don't need to agree on it, but I do think there's value in making sure at least every client knows what they're going to do, make sure everybody has a plan and that we kind of talk to each other and share what our plans are. So that way no one's left having to solve this problem yet again while someone else has already solved it. And same thing with the replace by fee. Everybody has to solve the replace by fee problem. They can solve it differently, but it'd be nice to at least share our potential solutions with each other.
00:49:37.296 - 00:50:19.130, Speaker A: Yeah. And replace by fee, I guess to me is a bit different because we talked about it on the discord. I think it was like a month ago, and it seemed like there were a bunch of solutions that were vulnerable to potential denial of service risks. So I think this is something where maybe having a canonical formula that different clients all use that we know is somewhat safe, actually has a pretty big benefit rather than the ordering of 1559 versus non 1559 transactions. And obviously there's overlap. Right. Like the replacement by fee might change how you do the ordering, but yeah, I think that's one where having a common solution is higher in priority.
00:50:19.710 - 00:50:30.030, Speaker E: Yeah, I agree. We saw that recently with Geth where their semantics for transaction ordering resulted in some problems because they're the dominant.
00:50:33.090 - 00:50:43.860, Speaker A: Know, I don't know if I'm remembering this right, but I feel like, Barnabay, you had put together a formula or something for the replace by fee. That was decent. Is that correct?
00:50:45.430 - 00:51:29.150, Speaker F: Yeah, it was just a way to make sure that you never can replace for free, where by for free, I mean, you can do it indefinitely, just spamming the network, and you never get accountable for it. And the idea is just that you'd need to increase the minimum between the minor bribe. If I remember correctly, between the minor bribe and the fee cap. The minimum of the two has to increase with every replaced by fee. Probably has to increase by like 10% or something like this. But that's the only way that you don't get into edge cases where I'm resubmitting with a different minor bribe. But it doesn't really matter anyway because I'm maxed out on my fee cap or the other way around.
00:51:29.150 - 00:51:42.066, Speaker F: So, yeah, we've discussed it a bit. I don't think it was very optimal, but it seemed that there wasn't any other option that didn't protect you from spam, let's say.
00:51:42.248 - 00:51:53.074, Speaker A: Yeah, I don't know what's like the right place to just store that or save that so that there's like a proper discussion on it. Because. Yeah, I remember discord messages.
00:51:53.202 - 00:51:54.406, Speaker F: I'll write something.
00:51:54.588 - 00:52:06.778, Speaker A: Yeah. If you could write something be. That would be really valuable. And then all the client teams can kind of look at it and give feedback. And I think even getting Peter and Martin from guests to look at it could be really valuable. Awesome.
00:52:06.864 - 00:52:07.546, Speaker B: Yeah.
00:52:07.728 - 00:52:20.766, Speaker A: Cool. Okay. And so, yeah, I think, yeah, for the transaction pool sorting, we can just keep the conversation going and share as we make progress, but it feels like there's a lot of different options and we don't necessarily need to resolve it now.
00:52:20.948 - 00:52:40.840, Speaker D: Well, it sounds like they don't need to be sorted at all, right? I mean, am I missing something? I mean, basically, if the. If the. Yeah, it doesn't sound like you need to do any different sorting than what's already been done, because there's only one transaction type.
00:52:43.290 - 00:53:11.810, Speaker E: Effectively, depending on how you code it, you could have a flag on your transactions in memory, and then you say, this one was originally a legacy transaction. So we're going to deprioritize or prioritize. So it would be possible. But if you code it such that when the legacy transaction comes in, you basically do an in memory conversion, and then you drop it into a pool with everything else, you could very easily design it such that you forgot that it was a legacy transaction originally.
00:53:13.750 - 00:53:52.400, Speaker D: I'm sorry, I don't want to beat this dead horse, but I think for me, the issue is having these different code paths for something as used as broadly in the geth code base as transactions is a risk. But if other implementers or implementers are comfortable just absorbing that risk in perpetuity, that you'll have two transaction types with no cut off for when you'll support the old type, that's fine with me, but it just seems like it'd be better to plan that than not plan it.
00:53:53.170 - 00:54:38.782, Speaker E: I think the last we talked about this, the tentative plan for deprecation, if we decide to go forward with it, was to introduce a basically legacy transaction tax, that if you submitted a legacy transaction, you would be taxed a little bit, and that tax rate would increase over the span of like two years or something. The major counterargument against any kind of deprecation is people who have signed transactions from a paper wallet from three years ago that they cannot resign for whatever reason. We want to make sure their transactions will always be valid and submittable to the chain, even in ten years. I think that's the main contention that I've heard is do we deprecate it at all?
00:54:38.916 - 00:55:03.640, Speaker D: Yeah, that's a perfectly fine argument. I think that I met my experience in working with Geth, which is limited, but my experience in working with Geth is that's ultimately going to be some sort of recipe for an event in the future where things go sideways. But if that's the desired user experience, that's fine with me.
00:55:05.690 - 00:55:12.630, Speaker A: Is that worth maybe just adding as like a security consideration in the like. I don't know.
00:55:12.700 - 00:56:03.640, Speaker B: I think it's worth because what kind of risk you're suggesting that actually this sorting mechanism mean we still have to define how exactly this conversion is done. Right. Because the gas price to feed up conversion or like to premium conversion is different on different block. We are just discussing today in netamind that when you sort, historically you would sort and that sorting order would be unchanged from block to block. If you start sorting by gas price, including the legacy and Ep 1559 transactions, an EP 1559 change their gas premium based on the block by block because of the fee cap being there. So the sorting order may change even without new transactions arriving or not.
00:56:05.790 - 00:56:11.450, Speaker E: Sorry, I'm missing something. Why would the sort order change like certain transactions will no longer be eligible.
00:56:13.230 - 00:56:18.910, Speaker C: You cannot determine the actual value of the transaction because it depends on the block.
00:56:19.970 - 00:56:31.266, Speaker E: Because if your fee cap is reached, you may end up with a lower minor bribe than the previous block. Yeah, I see it.
00:56:31.288 - 00:56:31.860, Speaker A: Okay.
00:56:33.190 - 00:56:35.470, Speaker E: That's unfortunate. That sucks.
00:56:35.630 - 00:56:51.590, Speaker D: Yeah. So I think that when we talk, maybe we should just sort of change this bullet point to say, instead of transaction pool sorting. Transaction pool eviction. Right. If I'm understanding that is actually an issue. Is that what you were just saying, Thomas?
00:56:53.690 - 00:57:12.670, Speaker B: Both. I mean, it's good to keep the discussion and maybe write down how everyone decided to do that, because maybe we just assume that we'll do it the same way, but we won't. Definitely. I agree with your comment here, Rick, that it may go wrong if we at least don't describe it so everyone can read it and feel confident.
00:57:13.330 - 00:57:36.440, Speaker A: And I think the account abstraction EEp actually did that quite well. They posted in all core devs this week, and I was reading it, but as part of the EEP, they have suggested behaviors for the transaction pool. Right. And that's not obviously part of consensus, but they still specify it in the EEP and explain the rationale why. So I think that's probably something we'd want to do as well.
00:57:40.490 - 00:57:41.400, Speaker B: Go on.
00:57:42.810 - 00:58:15.410, Speaker E: There was some talk a while back and I just realized it's not on this agenda about actual eviction strategies. Again, not a consensus issue technically, but there was discussion of what if we just say your transaction is evicted if the base fee goes passes up your pCap like you just flat out get evicted. Need to resubmit. The idea being that we can keep the pending pool cleaner thinner. The disadvantage being that it could result in more gossip if the base fee is fluctuating heavily.
00:58:21.370 - 00:59:02.914, Speaker B: So we were thinking to keep even the negative. Sorry, I'm trying to find a. You call it minor bribe. Okay, negative minor bribe in the pool. If it's still in the top x transactions. If you assume that the pool holds 4000 transactions and some of them towards the bottom are actually having different negative values, we still want to keep them and drop them if better transactions arrive. The bigger question for us was, what if we drop transactions that actually, after the base fee falls, would become a bit more minor friendly afterwards? But we think that's not a very big issue.
00:59:02.914 - 00:59:05.300, Speaker B: But it might be. So I would prefer to have it on paper.
00:59:06.630 - 00:59:28.380, Speaker E: Yeah, there's an argument. I think Vitalik made it where there was some. I'm trying to remember. If someone else remembers, please jump in. There is some potential advantage we get by evicting people. Evicting transactions because it solves some kind of nuisance problem that we've had in the past. Anyone remember? If not, I'll bring it up later.
00:59:28.830 - 00:59:34.560, Speaker B: It was the idea that actually interesting scenario where users. Sorry, you're not very.
00:59:39.650 - 01:00:04.310, Speaker F: Okay. It was the idea that you could send your transaction with a fee that was too low, like let's say lower than base fee currently is, so that you just wait for it to be included when base fee becomes lower. And I think the argument was that you shouldn't be using the network as your transaction pending transaction queue. Your personal pending transaction queue.
01:00:06.490 - 01:00:22.410, Speaker E: Right? It was basically, peers should not accept transactions with base fees that wouldn't be included in the current block. Like, if you get someone gossips you something and it can't be included, you just reject it and you say, yeah, don't tell me about that please. It's a waste of gossip.
01:00:23.950 - 01:00:40.210, Speaker F: A software rule to say if your transaction is 10% below the current base feed, okay, then we accept. But if you're just sending it in the hope that base feed gets halifed at some point, then we shouldn't be looking at it because it's too much to handle.
01:00:41.030 - 01:00:52.390, Speaker E: Yeah, I'm a fan of that. It reduces the gossip of the network and like you said, it keeps people from using the network as their personal storage. Effectively.
01:00:52.890 - 01:01:17.440, Speaker B: Yes, I think intuitive and problematic for some of the wallet users, but I'm not very against it, but I think it's not necessary. We already have all the clients holding top x best transactions, and even with e 1559, we still be able to tell which transactions are best. So there is no need to specifically evict them. Different way.
01:01:18.850 - 01:01:55.926, Speaker E: I think the idea is with 1559, the pending pool actually should be empty most of the time, right? If we evict people's base fees too low, or if we don't accept people's base fees too low. So the whole idea of historically we've always had a pending pool that's always full. We're saying that, hey, we don't have to do that anymore. We can now run clients with basically empty pending pools almost always because your transaction either is included right away, like within a few blocks, or it's not going to be included at all. Those are the two scenarios. And so we don't need to have 50 megabyte pending pool anymore if we decide we don't want to gossip.
01:01:55.958 - 01:01:59.100, Speaker B: That stuff makes sense.
01:02:03.970 - 01:02:14.000, Speaker A: Okay, so does it make sense to keep discussing this, to discuss the different options in more details? I feel like personally, I just need to think through it more.
01:02:14.690 - 01:02:42.250, Speaker E: I do think there's value in discussing and at least having every client document what they do for replace by fee, what they do for eviction, what they do for accepting gossip of due transactions, and what they do for transaction pool sorting. I think knowing what each of the clients do for those four is valuable, and I suspect once each client gets to implementing it, it's going to come up as a question and they're going to ask, what are other clients doing? And so I think just having that documented and talking about it is valuable.
01:02:43.870 - 01:02:49.430, Speaker A: So replace eviction sorting. And what was the fourth?
01:02:49.590 - 01:03:11.682, Speaker E: And gossip acceptance. I don't know what the word for that. Yeah. What does your client accept as gossip? As valid transaction. And what do you not accept as gossip? And then also, this is actually very important. What will you kick people out of gossip for? Like if someone gossips you, something that you think is just outright wrong, you probably are going to blacklist them. And we want to make sure clients aren't blacklisting each other.
01:03:11.682 - 01:03:14.100, Speaker E: So we need to at least agree on that much.
01:03:14.950 - 01:03:24.630, Speaker A: And where's the best place to actually write that down? Probably not in the EEP itself, but it feels. I don't know. Does anyone have a suggestion?
01:03:25.130 - 01:03:26.760, Speaker E: I agree not to eat.
01:03:32.430 - 01:04:04.570, Speaker A: I can start a hackmd document. I'll link it in there. I'll link it in this page, and I'll just add a section for every client. And then people can just add their behavior. There's a chat. I'm not sure an informational. I wouldn't do an utter eep until we're actually settled on some best practices.
01:04:04.570 - 01:04:47.870, Speaker A: And maybe once we are settled on some best practices, we can add it out of. I don't know, like some appendix to this EEP or something, but just now. Okay, so testing, reference, consensus tests. I don't think we're quite there yet, especially given that the 20 718 change still hasn't been done. So this feels like it's probably a bit too early. Community testing. I think we're starting to to do this, and Abdel's tool can kind of help people interact with the network.
01:04:47.870 - 01:04:59.200, Speaker A: We'll keep improving on it. And then I think the public testnets that applications can use. This is basically our fork of mainnet that we discussed earlier, so it seems like it's going well in terms of test.
