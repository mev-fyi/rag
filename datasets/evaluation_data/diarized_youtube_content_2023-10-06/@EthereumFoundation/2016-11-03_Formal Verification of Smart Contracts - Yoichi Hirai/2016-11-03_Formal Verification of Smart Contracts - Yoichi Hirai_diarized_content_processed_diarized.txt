00:00:00.410 - 00:00:50.060, Speaker A: Hello. Now I talk about this scary topic of formal verification. When people say formal, people usually talk about former attire, formal speech, formal ceremony. But the formal, informal verification comes from formalized mathematics. Ah. In usual mathematics, something is written on paper and the mathematics can read it. And she gets an idea, some idea, and she can say perhaps correct, but boring informalized mathematics, something is written in computer files and the machine read it.
00:00:50.060 - 00:01:56.050, Speaker A: The machine has no idea, but it says correct by just looking at the form of what's written in it. And this form is what this formalized mathematics is about. This is great for smart contract verification, because usually when you try to prove smart contracts correct, it's a massive case analysis. If any data is sent from the quora, if any value is sent from the quora, if the tent data matches function signatures or not, what's in the storage, what's not in the storage. So it's massive case analysis and usual mathematics. Be unable to read it because it's boring. For this former something, you can access it on Twitter.
00:01:56.050 - 00:02:36.800, Speaker A: Today's vote is written IPC vote. You can send a message, you can tweet to it, you can send a formula, and it says provable or not provable. And when it's probable, it shows you some proof in a figure. Do you like it? The IPC code. A friend of mine. But this figures are already there in 1934. This is originally a german technology by the harp game.
00:02:36.800 - 00:03:33.074, Speaker A: Every mathematical position have made them. So there are rules like it's called introduction, because on the upper side there's no angle symbol. On the bottom side we have an angle symbol. And it's saying that if you have a proof of R, and if you have a proof of base, you can construct a proof of R. And this is. And you can remove this ampersand, and this is design given. So on the amper side you have on the bottom part, you don't have it.
00:03:33.074 - 00:04:15.280, Speaker A: And when you have a proof of R, you can have written contract approve of R if you wish, whichever you wish. And similarly, there's all the Einstein. When you have a proof of R, you can construct a proof of order base from it. So this guy is great, because Jameson created this system and this is still used today. This is the most common proof system used today. This is the basis of camera, almost all modern logic. No, I went back, sorry.
00:04:15.280 - 00:04:54.310, Speaker A: Yes. So there are good rules and bad rules. They are good rulers because they don't allow you to smuggle things into your proof. When you have a proof of R, when you have a proof of bed. You can get approved of bed, but the only thing you can do with it is to introduce base. And you already had it in the beginning, so nothing new happened here. But on the right hand side, right side there are bad roots.
00:04:54.310 - 00:05:47.354, Speaker A: It's called tonk. Tonk introduction is the same as or introduction. When you have a proof of A, you can have a proof of a tonk B, and tonk elimination is the same as Andre elimination. And when you have a tonk B you can get a proof of B. And these rules allow you to snug new propositions into your proof, and you can prove false from truth or something like that. And it's all about harmony of introduction and elimination. And then what would be the infinite rules for solidity programs? And here I meet a problem, because usually op people read the solidity code and get an idea and says this works or this doesn't work.
00:05:47.354 - 00:07:37.918, Speaker A: But who told you that solidity programs are executed from top to bottom? That solidity documentation does not fake might be bottom to top, maybe you say from experiences you tested, lots of solidity codes and so on, but then you are actually relying on the compiler. The problem here is when you read the solidity code, you might get a different idea from what happens actually when you compile and deploy the code. So I chose just to use the solidity compiler as my guidance. So the solidity compiler knows the meaning of authority code. I get an EVM bytecode, then I meet a similar problem. What inference rules for EDM bytecode, then actually I can answer the inference rules look like this. If you know if your EVM virtual machine is at the second position and the setup element is zero x 60, if you know this state does not go wrong, then from this you can imper that an EVM machine at the first position with the stack entity does not go wrong, because the only thing it can do is either go out of gas or go one step to the original, the second position I talked about.
00:07:37.918 - 00:08:53.320, Speaker A: So this kind of inference rules are good for the atrium virtual machine I treated a bit why did I treat solidity and the XRM virtual machine differently? And it's because just if there is a spec or not, and if the spec is written in a more machine readable way, it's better. Just one programming language authority is written for theorem provers. It's called KPM. That's the best language to prove program on. And then there are some programming languages called spec translated into proof text, c eleven, slightly old JavaScript. There are some languages with specs with mathematical definitions, maybe they are easier to translate into proof takers, and there are languages for English only specs and so on. And I found the EVM a little bit, maybe more easier to deal with.
00:08:53.320 - 00:10:02.320, Speaker A: Of course there are problems in the EVM specification in the yellow paper, so I've been opening some pull requests to the yellow paper repository. But this is manageable and this is manageable. I knew that because many ethereum client implementers already looked at it and found problems and the document is arrived. So I just had to implement another iterium butter machine in a term improver. It took like 50 pages type testing APO papers, but it's kind of easy to remove the top element of the stack and changes the stack at the bottom of that stack and form. And then when you want to verify a program, you have to paste your program in a proof checker. There's nothing deep in it, it's just huge.
00:10:02.320 - 00:11:07.666, Speaker A: You just have to copy and paste it. Actually, this caused some problems in the proof check is a bit of old because looking up an instruction from this disk took too much time, so I had to transform it into a binary tree. But it's just geography. And then this is the most important question when you want to do former verification, in the end, what do you want? You have to say what you want. And the first option is the account should do expected things, and for that I have to interview the people who wrote this and what do we expect? And this is not easy because the question is very informal, what do you want? But my requirement for the answer is very detailed. I have to type it into a proof checker. So I ask a very informal question and I expect a very detailed answer.
00:11:07.666 - 00:12:12.280, Speaker A: That's not easy to conduct. At least I have to show something working before I do something. So the second choice is the account shouldn't do things wrong. And usually for ATLM smart contract, the balance shouldn't decrease unless an authorized account is sold. And with this, a non authorized account cannot make itself authorized or make any embarrass authorized, because that kind of makes the first point meaningless. So I have to type these conditions in the project type. It's straightforward, the chapter small saying the storage index zero does not contain the forest address.
00:12:12.280 - 00:13:04.870, Speaker A: This part is for non authorized, the deed contract is still marked active and so on. Under these conditions the expectation is that the balance does not decrease. I tried to approve this balance and I failed because I forgot to say one condition in the precondition. So I forgot to say the account is still active. And then the proof fails, so I know that something is wrong. And then after typing in your requirement what you wish, you have to prove that thing yourself. This is just straightforward.
00:13:04.870 - 00:14:01.414, Speaker A: You have to type things on the upper pane, and the lower pane is just the machine's responses. And here the machine is responding some very dong proof goal. But I find a nick sentence in the middle of the goal saying, okay, well, now it wants to do data analysis on if the center data is empty or not empty. Actually, whenever you try to verify a smart contract generated by solidity, it's the first question if the core data is empty or not. So I tell it, do a case analysis on this, and it splits the cases. And then I have to prove two goals. If the tent data is empty, the requirements hold.
00:14:01.414 - 00:14:56.534, Speaker A: If the tent data is non empty, the requirements hold. And with this, with the usual infinite rules, I get the result. So I have to just repeat this case analysis until all cases finish, and then the post condition hold. And then after I finish this. Okay, now the machine is convinced that the theorem holds. There's still a question. Does this match the reality? The next thing I have to do is I have to test my own EVM implementation against the usual standard virtual machine test for which CPP client go, client and rust all variated.
00:14:56.534 - 00:15:33.220, Speaker A: So they were compared with standard test, and I have to use this virtual machine test to try my EVM implementation. In this theorem proverb, if this is wrong, this theorem is garbage because it's about some other machine. So I really have to do this. If you think you can do better, there will be a workshop about. Actually, this is not just about program verification. This is.
