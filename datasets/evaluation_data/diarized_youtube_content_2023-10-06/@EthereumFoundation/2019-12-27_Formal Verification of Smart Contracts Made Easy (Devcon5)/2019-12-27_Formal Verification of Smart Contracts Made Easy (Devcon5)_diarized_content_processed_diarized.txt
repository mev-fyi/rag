00:00:13.290 - 00:00:45.690, Speaker A: Everyone for coming. We have now a workshop on formal verification of smart contracts. And maybe before you interrupt on the topic, so how many people have done any form of indication of contract so far? Maybe let's raise the hands. So very few. So I guess all the remaining ones will attract it by the last part. That's supposed to be easy. And hopefully by the end of this workshop, everybody manages to have a hands on exercise, and everybody should be able to verify some form of properties on contracts.
00:00:45.690 - 00:01:24.230, Speaker A: So the people that will be doing the workshop, we have dimitar there. He's a PhD student teacher. If you are joining chain security now, background in formal verification and program analysis, then we have also Anton permanent, so he's the lead developer of the verifier that we'll be using today in the workshop. Also, Hubert, who is sitting back there, CTO of chain security, and myself. So who we are, we are chain security. We are a spinoff from ETH Zurich, ETH the university, not the foundation, based in Zurich, Switzerland. And we focus on blockchain security.
00:01:24.230 - 00:02:17.474, Speaker A: We have worked with many blockchain projects. So far, we have done over 80 audits, not only smart contract audits, but also protocol audits, platform audits, as well as a couple of very visible eips. I think many people recognize the chain security name from some of those eips that we have reviewed in the have. We're doing quite a few R d security projects with platforms such as Ethereum Foundation, Polkadot Zilica, and few other blockchains, where we focus on building security tools, tools for finding bugs, as well as formal verification tools for these platforms. All right, so to do our work, we have done quite a couple of systems so far. So I have listed some of them on this slide here. And so these systems aim to achieve different goals.
00:02:17.474 - 00:03:07.722, Speaker A: We typically combine techniques from various different domains, such as static analysis, dynamic analysis. We also use quite a lot of data driven techniques for machine learning to build these systems. So some of you are probably familiar with secureify. This was the first system that we built back in 2017. It's a system providing generic vulnerabilities in smart contracts that was basically addressing all these bugs that were popping up regularly every couple of weeks in 2017 in all these parity wallets and many other contracts. So this is what that system was addressing. And so this system, along with other system, I think they made a difference in the sense that 2018, we actually saw much fewer facts because of such.
00:03:07.776 - 00:03:11.030, Speaker B: Generic, really simple boxing contracts.
00:03:11.190 - 00:04:11.014, Speaker A: So another system we have built is we have a fuzzing system that addresses the problem of ensuring functional correctness. So we're going to talk a little bit more about what functional correctness actually means. And we have a fuzzing system that essentially generates transactions and tries to find violations of the specific security properties that we're trying to check for the smart contract. And the main system that we will be talking about today is the Verix system, which is the first automated verifier for verifying smart contracts. We have a demo on Verex Ch. We have set up a few other instances of this system that we will be using for the exercise later today, and for people that are interested really in depth on how that system works, what guarantees it provides. So we also have a research paper which will appear at the IEEE Symposium on Security and privacy.
00:04:11.014 - 00:04:16.602, Speaker A: So that's one of the main security conferences, one of the main academic security conferences.
00:04:16.666 - 00:04:18.634, Speaker B: So if you go on our webpage.
00:04:18.682 - 00:05:45.782, Speaker A: Chainsecurity.Com, and go to research, you can download the PDF and read all the details about the verification technique that is being used in that system. All right, so before we actually do go into the hands on exercises, it's important also to mention why are we actually doing this? And the main reason is that when I initially asked how many people have verified contracts, I think there were about two, three hands. And the reason this is that formal verification used to be this very difficult, time consuming task where you have to be really an expert in formal verification, have a PhD in logics and so on to prove that a contract is correct. And if we are to make formal verification mainstream, a lot of developers also adopting that approach, then we have to be building systems that allow people without this background to write functional specifications and prove the contract correct. And that's exactly what this verix verifier aims to do. So it eliminates this need to know in depth knowledge of form of verification, and takes down this reduces also significantly the verification time, because as you will see, it's really not a very hard task to verify contracts with such systems.
00:05:45.782 - 00:06:39.594, Speaker A: So with such a system, if you take something like a standard ERC 20 token, which will look in depth in the exercise, you can literally do a full formal verification for all the main properties. You would care about a token in a matter of a couple of hours and be done with the verification effort. So I have listed here some quantum that we have verified. We have more on our main web page, gentecuda.com audits, where you can find some of these reports, where we have done proper full verification on those all right. So the workshop will continue as follows. So we'll start with some very more high level introduction to what functional correctness means and why is it challenging to formally verify properties with functional properties? And what are different techniques that different tools that are introduced in that space, how they.
00:06:39.594 - 00:07:20.778, Speaker A: Different terms of guarantees then. So also we'll cover here, of course, the veric system. And then in the second half we'll switch to a hands on exercise where Zimeter will walk you through. How do we specify properties and verify them? With a verifier like Varix. And so we also have many other people from the chain security team back there, so they will be assisting you while doing this exercise. And then in the last part, depending on time, we'll try to get into some more detail about the actual verification methods and how this is being automated by the variant verifier. All right, so let's get started.
00:07:20.778 - 00:07:59.090, Speaker A: And functional correctness. So what is functional correctness? So usually when people think about security tools, there are these kind of tools where you just paste the codes and then they show you a bunch of vulnerabilities that are found. So this is not what we're talking about here. So we're not looking for generic vulnerabilities, we're talking about functional correctness. And what this means is that the problem of functional correctness has two parts. So one is you have the smart contract that you want to make sure it's correct. And then the second piece of information that you need is the functional specification of the smart contract.
00:07:59.090 - 00:08:08.246, Speaker A: So what the functional specification is that this is the thing that defines what is the intended correct behavior of that smart contract.
00:08:08.438 - 00:08:09.180, Speaker B: Okay?
00:08:09.630 - 00:08:18.470, Speaker A: So to make this a little bit more concrete, here on the left, imagine you have a smart contract, a typical year C 20 contract.
00:08:18.630 - 00:08:20.898, Speaker B: So you have all the standard skills.
00:08:20.934 - 00:08:35.630, Speaker A: Like balances, total supply owner, a couple of functions that would allow users to transact with the contract. And then the functional specification typically consists of requirements such as the sum of all balances equal the total supply.
00:08:36.130 - 00:08:36.494, Speaker B: Okay?
00:08:36.532 - 00:08:44.210, Speaker A: So this specification says that all the tokens are assigned to users. Somehow there are no missing tokens.
00:08:46.630 - 00:08:46.994, Speaker B: Not.
00:08:47.032 - 00:09:05.942, Speaker A: Assigned to any user. Another common example is that often tokens are mintable, meaning that you can increase issue more tokens. And often you want to ensure that only certain users can exercise this functionality. And you want to make sure that if the total supply increases, then that was triggered by a transaction issued by the owner of the contract.
00:09:06.086 - 00:09:06.442, Speaker B: Okay?
00:09:06.496 - 00:10:00.486, Speaker A: And then typically you would have a huge list of those requirements that you would have to check that whatever the implementation of these functions is, it is correct with respect to these functional requirements. Okay, so technically, how do we actually check that the code is correct? And they're, roughly speaking, two steps. So the first step is, well, to essentially transform this english description of correct behavior into something that's to take them down to specify them at the level of the source code. Okay, so for instance, if we take the first requirement that says that the sum of balances has to be equal to the total supply, then this is written in the specification language that we'll be using later in the exercise of the very specification language. And this is how it would look in the actual specification language. So, fairly intuitive. There's some keywords point to the mapping.
00:10:00.518 - 00:10:01.990, Speaker B: That we're trying to sell, and then.
00:10:02.080 - 00:10:31.222, Speaker A: We have equality with the total supply. Okay, so that's step number one. It's inevitable. You have to be able to formally state what the property means. And once we have formalized it, then if we have a particular state of the smart contract, then we can check whether this property holds or not. All right, so for instance, if we look at a state where we have two users having balance 50 each, and we have total supply of 100, then the property holds. That's what it says.
00:10:31.222 - 00:10:39.678, Speaker A: And here would be an example where the property doesn't hold because the sum of these two balances actually exceeds the total balance specified in the contract.
00:10:39.794 - 00:10:41.098, Speaker B: Okay, is this clear?
00:10:41.264 - 00:11:14.270, Speaker A: So that's step number one, define the property. Step number two is to actually check that this property holds for all possible states that your contract could reach. Okay, now what does this again technically mean? Well, once you deploy the smart contracts on the blockchain, it is always initialized by the deployment script, so it would end up in being some specific initial state. So that's what this state is. And you would have to make sure that the property falls there. So for instance, you deploy, and then for that initial state, the sum of balances will have to be equal to total supply.
00:11:14.430 - 00:11:15.362, Speaker B: Okay, that's one.
00:11:15.416 - 00:12:26.150, Speaker A: Then the next thing is that once deployed, the users would send a transaction to that smart contract, and each transaction would modify the state of the smart contract so they can, for example, submit a min transaction with different values as arguments and so on. And let's be a little bit more precise, what these arrows and boxes here represents. So what these boxes represent is the actual state of the contract, and the arrows are the transitions that are triggered by the transactions submitted by the users. And how are these transitions defined? This is defined by the implementation of the functions in the contract. So for example, if we have here, we start from a state where total supply is 100. We have an owner user with address extend, and then we have two users with balance at 50 tokens each. And then mint function is defined such that it would increment the total supply by the number of tokens we want to mint, and then it would assign the new tokens to the owner of the contract.
00:12:26.150 - 00:13:19.820, Speaker A: So here if we have this mint, 100 tokens issued by the user, basically the total supply would be incremented as defined by the function. And then the balance of the owner who has address zero x ten would be incremented from 50 to also 100 because that's how many additional tokens were issued. Okay, so that's what this arrow here means. All right, so here comes immediately. The first immediate challenge when we talk about functional correctness is that even if we want to consider whether the property would hold after one single transaction, after the first transaction sent to the contract, that already gives you so many different transactions that would have to be accounted for, that it becomes infeasible to brute force. So it's not possible to enumerate these transactions and to actually check that in all these states, the property will always hold. So that's challenge number one.
00:13:19.820 - 00:14:06.646, Speaker A: And we cannot stop here because after the first transactions, the user would submit 2nd, third, and so on transactions. And in fact, there's not a predefined bounds on how many transactions this contract would process in its lifetime. So we would have to consider an unbounded number of transactions if we are to formally verify that this property would always hold. Okay, so there are two fundamental challenges here. All right, so let's very quickly go over what are different techniques that could be used to address this problem of checking these formal properties and how they differ in terms of guarantees. I ordered a basic on reliability. So starting from least reliable, going towards more reliable techniques.
00:14:06.646 - 00:14:35.018, Speaker A: Well, the bottom, we have the manual review. So always a human can look at the codes, understand what it does and try to find violations. So this is basically statute penetration testing. We have the property and try to try to hack the contract. And the disadvantages here are fairly well known. So this is a time consuming problem. Even if you have, especially if you have big contracts, that would take a while for the security expert to understand exactly how these things, how the functionality.
00:14:35.054 - 00:14:36.280, Speaker B: Of the contract is.
00:14:37.050 - 00:15:06.670, Speaker A: Then let's move over to more automated techniques. So next level would be to do some form of automated testing. And they're primarily in general for software, but also in the space of contract. Two techniques for testing contracts. So one is based on fuzzing. And second major technique is tools based on symbolic execution. So let's briefly see what these techniques would do to this problem of checking functional correctness.
00:15:06.670 - 00:15:27.806, Speaker A: And so, starting with fuzzing, here's basically what's happening. So fuzzing is a testing technique where a fuzzer would generate random transactions, and then it would execute the transactions on the contract. And by doing so, the fuzzer would observe different states of the smart contract.
00:15:27.998 - 00:15:28.822, Speaker B: All right?
00:15:28.956 - 00:15:50.486, Speaker A: And by doing so, we can, for all the states that have been observed, after processing these transactions that we generate, we could check whether the property is violated or not. If it happens that we reach a state where you get a violation, then the father could also return that sequence of transaction that triggered the violation, and the developer could see reproduce the bug.
00:15:50.518 - 00:15:51.820, Speaker B: And try to fix it.
00:15:52.430 - 00:16:15.778, Speaker A: There are many, many fuzzer that have been deployed that are available online that do exactly this thing. The challenge here typically is how to generate transactions in a smart way. So you get very high coverage over at least a very high code coverage over the contract, which is already pretty challenging in contracts which tend to be very stateful, have complex preconditions on the transactions and so on. So what fuzzing will not give you.
00:16:15.784 - 00:16:17.178, Speaker B: It will not give you this full guarantee.
00:16:17.214 - 00:17:16.386, Speaker A: That's why it's a testing technique, because inevitably there will be some states that you would not observe simply because the fuzzer did not generate that specific sequence of transaction that would transition the contract to that state. So it's a testing technique essentially. Now, symbolic execution does something different, symbolic techniques that it is based on this symbolic execution technique, it simply would not scale to reason about such depth of transaction. So typically, if you use a symbolic, symbolic tool, you would give it a timeout. So it would run for maybe 30 minutes, 1 hour, and then you would stop, and then it would reach certain depth. So it is better at this kind of breadth exploration. But if the bugs are hidden deeper, like after 510 transactions, it could happen even in simple contracts like crowdfls, where you have to transition to, for example, to some refund phase, where you could exercise the refund functionality.
00:17:16.386 - 00:18:01.750, Speaker A: So these typically tend to be somewhere lower that are harder to explore with symbolic tools. So I have listed here some of the open tools that are available to do this. Okay, is this clear so far? If there are any questions, just raise your hand and then we can also go into a bit more detail. All right, so that's testing. And then the highest level would be to formal verification what this workshop would be about. And this is really the point where you have a flip from testing to full verification, meaning that you could actually prove that this property, for whatever sequence of transactions the user would make, it would always hold, no matter what. Okay, it's a major flip that happens.
00:18:01.900 - 00:18:06.630, Speaker B: At that point right now.
00:18:06.700 - 00:18:53.346, Speaker A: So just visually, what this means is that you would cover all possible states, essentially, and if you would check all of them, and if you check mark all of them, you have this full guarantee. So that's what the Barrett system does, and you will be using it soon. And the input to that system is, as we saw, the smart contract as well as the specification, because we're dealing with functional correctness here. And the main thing that Veric does is it fully automates the process of verifying in the sense that if it successfully verifies the property, it guarantees that it is fully verified. And if it fails to verify the property, then it doesn't give a guarantee.
00:18:53.378 - 00:18:54.790, Speaker B: Whether the property doesn't.
00:18:55.450 - 00:19:54.810, Speaker A: So it could be that you have to help a little bit of tool to actually verify the property, or it could be that the property is violated and then you have to fix the contract. So we'll see some examples during the technical exercise later. All right, so to give you a bit of something that we actually spent quite some time is to ensure that Verex has a very intuitive and easy to use specification language, because that typically is one of the bottleneck when we talk about functional correctness. Because again, to use functional correctness in addition to the contract, you have to write down what the contract is supposed to do. And if this is very hard and tedious to specify, you would end up not really using the system. So I will give few examples of specifications that we have seen to very frequently appear in real world smart contracts. So this is something we just observed during audits and verifying contracts.
00:19:54.810 - 00:20:53.050, Speaker A: And so this is literally what the specifications are, so you don't have to write some elaborate scripts or something very complicated to formally state a property. So common properties are things like access control, where you want to ensure that certain functions can be invoked by particular users. For instance, you're saying that always in the contract, if there was a transaction to deposit, then that transaction was made by the owner of the contract. Another common pattern that we observe is that very often it's not about who is sending a transaction, but it's in what state the contract is. So for instance, here we say that if the current time exceeds the refund time by a week, then users are no longer allowed to submit refund transactions. Yes, state machine properties as well. So again, contracts are very stateful.
00:20:53.050 - 00:21:39.938, Speaker A: There's explicit state variables that define how the contract can transition into different states. So you have to make sure that these transitions are encoded that are implemented correctly in the contract. We saw that example earlier as well. So we have some of our, basically, aggregations over mappings and arrays also tend to be pretty common. So we have added these explicit keywords in the language to allow users to write these properties. And another common pattern is that. So typically, if you have a project, you don't implement the full product in a one contract, but in several contracts, and often there are certain invariants that sometrode dependencies that exist between the contracts, and there are properties that capture these dependencies.
00:21:39.938 - 00:22:04.814, Speaker A: So you have to verify that they are implemented correctly in the contract. Okay, so again, you will be writing some of these specifications soon, a bit more technically for people interested in logic. So the specification language is actually based on something, on a fragment of temporal logic, which is very well studied specification language.
00:22:04.862 - 00:22:07.798, Speaker B: It goes back decades of research in.
00:22:07.804 - 00:23:10.070, Speaker A: This, so it has very well understood complexities and explicitity and so on. All right, so I will not go into depth on how the verifier actually works, but intuitively, it combines two techniques. One technique is it does use this symbolic execution technique, which is very good at handling, dealing with many different concrete values that you could submit in transactions. And then to deal with the unbounded depth that users would submit, it uses something called predicate abstraction that allows it to fully capture all the possible, like this very large unbounded tree, to capture it with some finite tree presentation. So depending on time, we may get into more details about that technique. All right, so that was the high level intro, and now we're going to transition into the actual exercise on how to use varics and to specify these properties. So I'll hand over to Mitko, who introduce the examples.
00:23:10.810 - 00:23:34.610, Speaker B: Yes. Okay. Hi, I'm Mitko. Yes. And now we continue with the kind of small exercise how to use varics. By the way, if you have any questions at any time, just raise your hand, just speak, and we can answer the questions. The goal here is to make the exercise more interactive and not so kind of formal.
00:23:34.610 - 00:24:24.350, Speaker B: Okay, so the first step in any kind of formal verification is to actually specify the properties informally. This means that you specify them in natural language, whether it's english or some other language. You just need to have some clarity over what this smart contract wants to do. Right. And in this exercise we will look at two main conflicts. One is ERC 20 token, and the other is kind of standard crowd sale, of course simplified because we don't have too much time. Okay, so first we'll go over specifying functional requirements, informal, right, and this is kind of fragmented of ERC 20 interface.
00:24:24.350 - 00:25:16.158, Speaker B: And for those who kind of are not so familiar with it, the contract has, let's say three main functions. One is total supply, how many tokens are in circulation. The other is balance of. You can query how much tokens given address or account heads. And the actual main function here is the transfer function where the sender of the transaction can transfer some tokens from its own account to the recipient. So we have dollars of this recipient's account and some amount of ether or any tokens, sorry, not ether, but just tokens that you want to transfer. Right? And now whenever we are specifying behavior of contracts, we do it over the contract and not over the interface.
00:25:16.158 - 00:26:16.040, Speaker B: So here are the relevant parts of the actual contract, right? So the functions, we have the balance, the total supply and balance become fields of the contract, right? So these are now private fields. We have total supply and mapping, which says for every address or account, how many tokens this address or account possesses. Right? So this one is just an integer and this is a mapping from addresses to integers. Right? And here we have some specification function transfer. Now when we're thinking about the contract or just specifying its correctness, at least as a principle, when I'm doing these things, I never look into the implementation, right? So for me the contract is a black box. And that's why I specifically omitted the body of the transfer function. So now the goal is to just come up with a couple of properties, hopefully full set of properties that specify the whole behavior of the one.
00:26:16.040 - 00:26:56.882, Speaker B: Okay, good. So let's do this a little bit more interactive. First property is on me, right? So we already saw it actually. And it says, just informally in English, total supply always equals decimal balance. Right? So this kind of specifies an invariant. Invariant, meaning that it holds at all states of your conflict, something that you'd like to hold. Right? And now we need to specify invariance about the transfer function, right, so suppose you start the transaction with a given transfer function.
00:26:56.882 - 00:27:06.982, Speaker B: You have a specific recipient and a specific amount. And what would be the usual case of transfer? So how it will look like?
00:27:07.036 - 00:27:21.386, Speaker A: Yes, I would say the amount of the sender needs to decrease, the amount of the recipients needs to increase by the amount. The balance of the recipient needs to increase amount and the total supply is not allowed to change.
00:27:21.568 - 00:27:45.940, Speaker B: The total supply is not allowed to change, yes, you're right. Yes. So this is a very good requirement. We can elaborate a little bit more. So, just to repeat, right, you decrease the sender's account by the given amount, you increase the recipient's account by the given amount, and total supply should remain the same. Right. But one thing, for example, that we omitted is that.
00:27:45.940 - 00:28:27.966, Speaker B: So we said the total supply should be the same, but this transfer could have transferred tokens from another account. Right? So we didn't specify this. So what we did is a partial specification. Right? So in addition to that, we need to specify that all other accounts remain unchanged. Right? It's not just the total supply, and as a consequence, the total supply will also remain unchanged. Right? Okay, so we also do this in the case the sender's account has sufficient funds, right? Sufficient amount of tokens, if it doesn't have the function, should not do anything.
00:28:28.068 - 00:28:28.478, Speaker A: Right?
00:28:28.564 - 00:29:20.254, Speaker B: So the first case, a little bit more elaborately, is if the message sender is not equal to the recipient, right. Otherwise you don't have anything to do, and there is sufficient amount of tokens in the balance of the message sender, then the message sender's account or balance should be decreased amount. The balance of the recipient should be increased by the given amount, and all remaining balances should remain unchanged. This is kind of a fairly straightforward informal specification. So what would be the remaining case? So we have one more case to do here. Any good number of balances should be the same as number of addresses. Number of balances, yes, you're correct.
00:29:20.254 - 00:29:47.802, Speaker B: Number of balances should be the same as number of addresses. This is kind of implicitly assumed. So if we go back a little, this is kind of implicitly assumed. We have this mapping, you can think of it containing account for everybody, every possible address in the world. It's very large amount, all the possible addresses. The Ethereum kind of language, security language takes care of this. But this is a correct thing.
00:29:47.802 - 00:29:48.314, Speaker B: Yes.
00:29:48.432 - 00:29:57.610, Speaker C: Then just the negation of the condition. So message sender is recipient or negation. That's what the merit balances.
00:29:58.510 - 00:30:27.654, Speaker B: Exactly, yes. So what we do is we consider the alternative case, right? So we have this if here alternative is to logically negate the condition. Indeed. Which means that if the message sender is the recipient or the balances are not sufficient. Right. All balances should remain unmodified, right? Yes. You're not taking into account overflow at this point? I'm not taking into account overflow at this point.
00:30:27.654 - 00:30:58.880, Speaker B: Yes, you are absolutely right. So when you're doing specification, it's very easy to miss something. Well, also the same way as you program something, for example here, it could happen that these conditions here are satisfied when overhaul flow happens. Because we have modular arithmetic here, we're dealing only with addition and subtraction. Everything works fine even if you overhaul something. And the problem is when you overhaul something, the actual amount is not the amount you want.
00:30:59.730 - 00:31:03.294, Speaker C: Is that in general you don't take into account overflow or just in this example.
00:31:03.492 - 00:31:43.086, Speaker B: So in this example, I don't take it into account. So what you can do with Varx is depending on your property, you can specify in such a way that it would automatically fail to verify if overalls happen. Right? But what we currently do with Varx is that we don't explicitly check for our vaults. Right. You need to write your property in such a way that it fails even if there is no. Okay, and the other thing is, you can think of the specification at the informal level as referring to actual integers where there is no overflow. Right.
00:31:43.086 - 00:33:16.220, Speaker B: This is kind of just the informal part, but when you go to actual formal verification, you cannot think of it this way. Right? Okay, so this is informal requirements for ESC 20. Okay, now let's go to something slightly more relevant. So we have a crowd sale, and the crowd sale has couple fields. So a crowd sale contract, the amount of etter which is raised, the goal of etter which you want to raise, and the closing time of the crowd sale, and the behavior of the contract is that whenever somebody sends money through the invest function, right, this is a payable function, the crowd sale contract will deposit this money into the escrow, right? And when somebody invokes close, and it's about time to get closed, right after the toll's time has passed, then depending on this, we have two options. Either the goal was raised, in which case the beneficiary of the crowd sale can withdraw the money from the escrow, or the goal was not raised, in which case the investors can claim refund for their actor, which put inside, and this logic should be realized in the escrow method. So here what you do have is mapping of deposits, how much etter each address deposited into the escrow, and the beneficiary who in case of success, will receive all the money.
00:33:16.220 - 00:33:56.326, Speaker B: So let's try to specify this again informally. Again, let's do the first one. So the goal and close time always remain the same. So this might look like a stupid informal requirement, but in insulinity, these things can change. Right? The skills of your contract, these are stored in the storage. Potentially they can change. So because of this, we need to be explicit about which things need to remain constant or which things can change.
00:33:56.326 - 00:34:24.786, Speaker B: Right. So this is a requirement that is all open, missed, and people kind of. Okay, other suggestions? You just to implement kind of the logic that we informally describe now in informal language. No need to be very precise. Yes. Close only works if you pass time. Sorry.
00:34:24.786 - 00:34:47.538, Speaker B: Close only will only work if you pass close time. Close will only work if you pass the closed time. Yes. So what does this mean? Close will only work if you pass the closed time. So if now is larger than closed time, if now is less than closed.
00:34:47.554 - 00:34:50.978, Speaker C: Time, call close must be unsuccessful.
00:34:51.154 - 00:35:05.114, Speaker B: Must be unsuccessful. Yes. So you can specify this. This is one option. Let me see what the next property I specified here is. Because process. But maybe it's something along the lines of clause.
00:35:05.114 - 00:35:48.300, Speaker B: So what does it say? No, it's something else here, just for the sake of the workshop. I have the properties fixed, so you are welcome to say properties. I will not add them to the slides here. We'll just work with some fixed as the properties. And property B here says similar investor deposits equals the enter in escrow unless crowd sale is successful. Right? So this means that you cannot withdraw or change money from escrow unless crowd sale is successful. Right? Okay, so let's see something more.
00:35:48.300 - 00:36:18.050, Speaker B: Escrow never allows both withdrawing and claiming the refunds. So this was one of the requirements we wanted to specify. And yes, investors cannot claim refunds after crowd sale goal is reached. And maybe you can figure out what would be the complement to this. Not complement, the complementary for the extra property needed to counterpart this behavior.
00:36:18.130 - 00:36:22.114, Speaker A: Yes, beneficiary can withdraw after crowd serve.
00:36:22.162 - 00:36:24.850, Speaker C: Beneficiary can only withdraw after crowd servo is reached.
00:36:24.930 - 00:36:52.902, Speaker B: Yes. Beneficiary can only withdraw unless crowd servo is reached. I just had the flip of that. You can say something in many ways, yes, but it's the same. So beneficiary cannot withdraw before crowd cell go is reached. So we have these five kind of properties. Now, this is most likely incomplete specification, the behavior of the culture.
00:36:52.902 - 00:37:25.020, Speaker B: So providing a full, complete specification is kind of difficult exercise. And whenever you're verifying your contracts, you don't need to do it. Right, but this means that you should always keep in mind the possibility that you need something. So now we have a bunch of properties, and what we can do is we can just attempt to formalize them and specify them in the variation specification. Language and try to verify. Okay, any questions?
00:37:27.150 - 00:38:17.766, Speaker D: One question is, as you're going through the requirements, you saw that if you go back to the specificated interface for the contract, the crowd sale, there are three states, open, success, and refuzz. Yes, but there, isn't there another state where you've reached the goal? It's closed, but the beneficiary hasn't gotten around to claiming the thing, so it's kind of pending. My question is, with regard to the interaction between this code and the specification. Do you go back and forth and change this code based on your understanding of the specification?
00:38:17.878 - 00:38:43.570, Speaker B: So if you're to develop the contract together with the specification, yes, this is how it's going to happen. You do back and forth. Right. You write your requirements. If you see that you missed something, you change the code. And maybe on the other hand, you did something in the specification which is wrong and the code reflects it correctly. So you need to change the specification.
00:38:43.570 - 00:38:50.040, Speaker B: So this process, you can be something for sure.
00:38:51.450 - 00:38:55.110, Speaker D: Yeah, because it seems like here there would be some kind of limbo state.
00:38:55.180 - 00:39:12.254, Speaker B: Where there will be a limbo state. Yes, absolutely, there will be a limbo state. Once the close tank has reached and this closed method was not called. Right. The escrow will still be in an open state and you cannot do anything. Basically, this is the limbo state because.
00:39:12.292 - 00:39:20.590, Speaker D: Maybe the beneficiary never gets around. Maybe they got vaporized. So it remains the limbo state forever.
00:39:21.170 - 00:39:44.322, Speaker B: Okay, so then you need to make a requirement that you can escape the limbal state. Right. You need to make an extra requirement, as I said, specification with incomplete. So there is something else I need to tell. So what you said you can escape the limbus state. This is called the liveness property. And Varx actually cannot verify liveness properties.
00:39:44.322 - 00:40:12.186, Speaker B: They require different techniques. And what we focus are properties of this kind which are called safety properties. Yes, but I will not get into much detail about this. Okay, yes, but this is kind of a reverse. Shouldn't you have informal requirement first before you write a contract? Depends on your style, how develop the code. Right. So some people prefer to write the code so they understand the problem domain better and then develop the specification.
00:40:12.186 - 00:40:15.860, Speaker B: Some people try to develop the specification before they understand it.
00:40:17.030 - 00:40:22.174, Speaker D: Also, if you're providing an audit service, you're not writing the code you're hired to audit.
00:40:22.222 - 00:40:40.300, Speaker B: Yes, to write the spec. Exactly. This is what people in Chainsaw do. Yes. They don't touch the code or they give suggestions about the code change. But in general, yes, we do write specifications sometimes based on the code, sometimes based on requirements given by the clients. Yes.
00:40:40.300 - 00:40:45.594, Speaker B: What about investment function invest? Yes.
00:40:45.712 - 00:40:49.660, Speaker A: After the goal is reached, should that be possible?
00:40:51.010 - 00:41:28.700, Speaker B: Whether you can invest after the goal is reached? It should not be possible. It should not be possible to invest once the crowd sale ended in some way? Yes, absolutely. I said the specification is incomplete, right. So ideally you'll get a complete specification. But this is kind of open ended process, requires some creativity. Okay, good. The whole point of this is to emphasize that before you start with formal specification, it's good to have informal one, just to have a clue what you want to do.
00:41:28.700 - 00:42:03.726, Speaker B: Good. Okay, let's move on verifying things with varix. We'll try to formalize these properties in the specification language that varix supports and see whether they verify or not. Okay, so how things get into the specification language and verity is based on something called linear temporal logic. So this might sound scary, but it's something very natural. So let me try to just give a brief explanation. So maybe most of you are familiar with classical logic.
00:42:03.726 - 00:42:34.942, Speaker B: This is our everyday logic that we use, and you can express formalized properties. For example, the age of Alice with the h of both is even, right. So classical logic defines the relations between individuals. In this case, the relation is that the sum of the two ages is even. Right. How would you write this? Formally, in classical logic, you say there is some integer such that age of Alice with the age of Bob is twice this integer. So kind of to say the things are even.
00:42:34.942 - 00:43:50.280, Speaker B: This is classical logic. And temporal logic adds another dimension to this, which is time. So things are not just statically laid out in a perfect ideal world, but we also have progress of time. And temporal logic allows us to define relations across states. So you have usually initial state in time zero, then you have time zero, one, you have another state, and so on, and so on and so on. And now you can define a relation between those states. And here example situation says it's always the case that ag of values h of o is even, right? So we just change the property very slightly by adding the always kind of temporal operator to express this relation, which is across time, not just within a single state, right? So you see that this relation is not fault in the real world, right? It cannot be always the cases are even and somebody the same increments age one guy increments age the same will become old, right? So this is an example of property that is not called because it's not always the case.
00:43:50.280 - 00:44:37.574, Speaker B: Sorry. Yes, I forgot about, yes, I absolutely forgot about this one. So yes, there are cases where this can be true. Yes. Okay, so just to say what you are specifying with temporal logic, what you do have is this model, kind of, you specify properties of traces formally and each trace is a sequence of states, right. The index of the sequence gives you kind of discrete time. So time progresses from zero to infinity, going increments at one, right? So for example, this could be the zero state, or some people like to come from one.
00:44:37.574 - 00:45:25.254, Speaker B: We've got the first state and this is the second state, this is the third state. So this is kind of what you're specifying in temporal logic. And each state we can kind of divide two worlds or two parts. There are the constants inside the states and the variables inside the states. And as an example, Alice as a person is a constant, which means that this object does not change across time. Alice remains Alice in all time points, right? The same goes with numbers, possible ages, like 27, 38, whatnot, right? So these things are constant, they never change across time. And the other part of the state are variables, in this example is h.
00:45:25.254 - 00:46:00.638, Speaker B: So variables can change across time. This is briefly kind of what the state contains, contains constants, right. And now when we write a formula, we want to interpret some statement about time. It's good to say what the mental model is and how you evaluate those things. So here is a different example. We have temperature, right? So we have states and our state contains constant is some temperature. And the variable is the temperature in this state.
00:46:00.638 - 00:46:26.726, Speaker B: Right? So time could be days in this case. So we did not specify in what units the time is measured. It's a discrete unit. We want to kind of see is this property here which says eventually always the temperature is at least eleven degrees. So we have some property. And in order to see whether this is true for these trace. So this is a trace, right.
00:46:26.726 - 00:47:16.840, Speaker B: We need to see whether this is true. What we do, we start evaluating the truths of the sub formulas for the parts of this sentence across the states. And for example, the kind of the innermost part is temperature is at least eleven degrees, right? So now we just see at which states this statement is true. Right. Within each statement we are kind of almost like a classical logic, but not real, right? And here we can see the temperature is eleven degrees in the first state, in the third state, and the last two states here. So time can continue on forever. Assume the temperature remains at least eleven degrees forward, right? So this is where this part of our statement holds true.
00:47:16.840 - 00:47:52.914, Speaker B: Now, in order to see in which states the always at least eleven degrees holds true. We need to look at the sub formula and see whether it always holds. Right. So always means that maybe better term for this is transport. Right. So we can ask the question, is it always the case that temperature is at least eleven degrees in the initial state and it's not true because in the subsequent state the temperature is ten degrees, it's no longer at least eleven. Right.
00:47:52.914 - 00:49:07.638, Speaker B: So it's not always the case that the temperature is at least eleven degrees in the initial state. It's also not always the case that it's in all these states until the temperature stabilizes or let's say goes below eleven degrees forever. So from this point onwards, this part of the formula will evaluate to true. Right? So basically it's always the case the temperature is eleven degrees. And now the final kind of temporal operator we are looking at here is eventually the case. Always the temperature is at least eleven degrees and eventually is true in a given state, if there is a future state where the sub sentence that you're evaluating is true. Right? So in which state is the full sentence true? Can somebody use guess every state? Everything? Yes, because no matter which state I evaluate this formula here, there is always a future state where it's always the case that the temperature is at least eleven degrees.
00:49:07.638 - 00:49:15.440, Speaker B: And this yellow line tells you in which states the former is it's all this.
00:49:16.370 - 00:49:27.860, Speaker D: I guess I don't understand the meaning of that future state because how do you know if it's true or not? Because there's the heat death of the universe where the temperature will not be.
00:49:30.150 - 00:49:35.150, Speaker B: So this is just an example. It's an example where there is no feed that time consume.
00:49:35.310 - 00:49:38.374, Speaker D: We don't know if there's going to be a heat death or not.
00:49:38.572 - 00:50:08.270, Speaker B: Okay, you're absolutely correct. So for this sentence, as humans we cannot evaluate, but avoiding liveness properties verification problem is different. Yes, more questions. Okay, good. So let's do a small quiz just to see how this temporal logic works. Right? And here, this is very unfortunate because this should be a circle. I don't know why this is square.
00:50:08.270 - 00:50:35.414, Speaker B: So we have two squares, which is very unfortunate. It's non printable character. Yes. These phones don't have it anyway. It's the bolt square, right? So we use the small square to say always, how do you say the diamond to say eventually and the bolt square to use next. Something is doing the next step. So what does this sentence say? Right.
00:50:35.414 - 00:50:58.254, Speaker B: You have two formulas or two predicates, P and Q. And this thing says p invited eventually q. Right. This is what it says. So how do you interpret this informally? What do you understand from this? Okay, let me help you.
00:50:58.452 - 00:51:02.142, Speaker D: If there's p, there will eventually Q will happen.
00:51:02.276 - 00:51:21.926, Speaker B: If there's p. Yes. I put this example just to emphasize something. When we are evaluating a formula, we are evaluating it always in the initial state. Right. So there is a slide something in subscript written diagram. We are always evaluating a formal initial state.
00:51:21.926 - 00:51:23.000, Speaker B: So you're almost.
00:51:25.530 - 00:51:26.230, Speaker A: Right.
00:51:26.380 - 00:51:44.400, Speaker B: We evaluate this initial state. If initially p is true, then in some future moments or the current moment. Actually, eventually, it's not strict. Or the current moment q holds. And what you said we can formalize with. It's always the case. If p holds, eventually q will hold.
00:51:44.400 - 00:52:15.186, Speaker B: So no matter whether it's initial state or no initial state, for every state, if this holds. Right. Okay, so what about this one? Always eventually p. Let me just get some alternative description of this formula. Yes, it's impossible for p to never happen. Yes. You can play with the Morgan's laws.
00:52:15.186 - 00:52:16.946, Speaker B: Yes. This is alternative description.
00:52:16.978 - 00:52:17.558, Speaker A: This value.
00:52:17.644 - 00:52:39.182, Speaker B: Another one. Can you come up with another one? Yes. P is true infinitely often. Exactly, yes. So you can interpret this because we have kind of time running to infinity. You say p is true infinitely often, meaning that it's always the case that eventually p holds. But if p eventually does not hold in some future state, it also must eventually hold.
00:52:39.182 - 00:52:53.810, Speaker B: So this will repeat infinity offer. Right. And what about this one? If we swap eventually, always pickles. Yes.
00:52:53.960 - 00:52:55.700, Speaker C: Well, yeah, what you just said.
00:52:58.390 - 00:53:16.620, Speaker B: Okay, I just want to tell more about the description. Absolutely. If you just read page out. Page, spell out what is written, what it is. This basically says that eventually peace stabilizes, kind of. From certain moment onwards, p will always go. This is how it says.
00:53:16.620 - 00:53:26.894, Speaker B: Well, we have three more. So we got into this one. So what does it say? Yes.
00:53:27.012 - 00:53:31.742, Speaker C: From any state that p is true, q is true. That state in every state after.
00:53:31.876 - 00:53:37.778, Speaker B: In every state after. And why is this the case? This is true. You're correct. Yes.
00:53:37.864 - 00:53:39.554, Speaker C: Because the always q on the right.
00:53:39.592 - 00:53:57.000, Speaker B: Hand side of the. This is the bold square, which is next. Sorry, we have technique with the. But it's true actually what you said. Right. So if you interpret this next as next. Right.
00:53:57.000 - 00:54:09.114, Speaker B: It's always the case. Right. That if p holds, then in the next case q will hold. Right. Never P. Sorry.
00:54:09.312 - 00:54:11.040, Speaker A: P will never be true.
00:54:11.810 - 00:54:13.230, Speaker B: Why p will never be true.
00:54:13.300 - 00:54:16.286, Speaker A: Because then the next state would be Q.
00:54:16.388 - 00:54:21.998, Speaker B: And they are not mutually exclusive. They're not mutually exclusive. They're not.
00:54:22.164 - 00:54:23.922, Speaker C: P is always followed by q.
00:54:23.976 - 00:54:41.030, Speaker B: Yes. P is always followed by q basically. Right. And now you have what you said, right, is if P folds afterwards onwards until infinity q would fall. Good. So these are the more simple ones. One last and we move on.
00:54:41.030 - 00:55:05.680, Speaker B: I don't know why I put so many, but. Okay, so this one is more complex. It says it's always the case. There is some constant n such that in this case the clock equals n. And in the next case, clock equals n plus one. Yes, the clock always has a value and the next step can increment by one. Yes, the clock always increments by one.
00:55:05.680 - 00:55:42.282, Speaker B: This is all these property sets. So this is kind of full temporal logic, right. You can write many complex formulas and statements in full temporal logic. Code always clicks or ticks by one increment because the clock actually time. Yes, the clock depends on computer clock, if it counts time, digital clock or some Unix timestamp or whatever it is. Depends on the. Yeah, it doesn't wrap around.
00:55:42.282 - 00:56:16.818, Speaker B: Sorry. For standard clock, it doesn't work. Okay. Yes. Okay, good. So now how all this applies to smart contracts, right? So what we do here, we need to fix what time means first and foremost. And what we do is we do the point we have world states and the world states are the states of the whole blockchain in between transactions, right? So whenever you register things on blockchain, you always run the thing inside the transaction and our state will be the world state of the blockchain.
00:56:16.818 - 00:56:35.820, Speaker B: And time increment means the execution of a single transaction. Right. This is what we do. And we don't support the full temporal logic. We support just a fragment of it, which is called canonical safety fragment. But I'll not go in details. And roughly it looks like this.
00:56:35.820 - 00:57:08.422, Speaker B: Your formulas look of this form always p, where p is some formula of the following shape. So you have logical conjunctions, p and q, you have disjunction p or q. You have implication, p implies q. You have this very interesting operator, which is temporal operator. Once p, which means that once in the past p was holding. This is the time reversal of the eventually operator. So we had eventually meaning in future moment, p will hold.
00:57:08.422 - 00:57:25.242, Speaker B: This means that in the past p was holding or the current state. Yes, at least once. At least once. At least once, exactly. So it's not exactly once, but at least once. So in some past state p was holding. This is what we do.
00:57:25.242 - 00:58:17.690, Speaker B: And finally, whenever you have some expression, you can refer to the previous value of this expression. So this is similar to the next operator. So in the previous state the value of this expression was something, right? So we will refer to the previous value of the expression. These are the basic things. By the way, what happens in the initial state when there is no previous state? What do you think? So when there was no initial state, just for simplicity, we take the previous value with the current value in the usual state. Just remember this, sometimes it's not exactly okay, and now we have some ethereum specific things, because we are, after all, doing things on ethereum. So one thing is we support sum of mappings, right? So imbalances is a mapping.
00:58:17.690 - 00:58:39.970, Speaker B: Inside the token contract, we can refer to the sum of all these things. Function returns the name of the function which is called in this transaction, the top level function. Right. So we have nested calls. We kind of abstract these nested calls away. We can refer only to the top level transaction. The function is the top level transaction.
00:58:39.970 - 00:59:04.122, Speaker B: We can refer to function names. So this is the syntax for referring to a function name, and we can also refer to arguments of functions. So syntax is a little bit improvised. We are going to improve it in the future. So this is the zeroed argument, the claim refer function. And here what you do is you do canonical name of the function. So this is the name of the contract name of the function.
00:59:04.122 - 00:59:44.898, Speaker B: And here you need to put the signature of the function with addresses. Right. And this is what happens. Yes. Can you shout, can you shout out, specify loop invariance? So we don't support specification of loop invariance. So all we do, we specify, let's call it transaction invariance, something that falls across transactions. What if we have non trivial loops in the contract? So in some cases we can rewrite them without loops.
00:59:44.898 - 01:00:09.630, Speaker B: But if you have non tivial loops, we unfortunately don't support it. Yes, I forgot it. Yes, there is also negation. Sorry, yes, I forgot the negation. Yes. So maybe I missed this, but you said earlier that you evaluate a formula always in the initial state in classical temporal. Yes.
01:00:09.630 - 01:00:32.920, Speaker B: So is the semantics different now? And we. No, it's the same. It's just that we support formulas of the shape always p. Right. For the operators once and previous if we're always evaluating in the initial state. So you evaluate the top level of the formula in the initial state. Right.
01:00:32.920 - 01:01:04.850, Speaker B: But it could happen that when you say always, this means that the inner part of the formula needs to be evaluated in all states. Right. This is the semantics of the always operator. So from formula to sub formula, you change the point at which you evaluate. Right. Depending on the semantics of the temporal operators, you change the point at what at which you evaluate the sub formula, right? So always changes the point at which you evaluate. You evaluate in all points from the current point onwards.
01:01:04.850 - 01:01:24.838, Speaker B: That's the idea. So a variety formulas, always in all states. Okay, good. So now let's move on to that small quick question. Next.
01:01:24.924 - 01:01:29.866, Speaker D: On that box on the left, you have once the previous. There's no next.
01:01:30.048 - 01:01:47.120, Speaker B: There is no next. We don't support it. Yes, we are somewhat limited, but many things that you can express with next. Actually, you can express in this way. Just. You need to massage your formula. Not everything.
01:01:47.810 - 01:01:50.334, Speaker D: Okay, but you have negation there.
01:01:50.372 - 01:01:59.154, Speaker B: That was just. I forgot. Yes, there is negation. Yes. We don't rob people of negation. Yes. If you have negation and always, don't you also have.
01:01:59.154 - 01:02:03.570, Speaker B: Eventually we require always to be the top level. Right.
01:02:03.720 - 01:02:04.322, Speaker D: Never again.
01:02:04.376 - 01:02:11.394, Speaker B: Yes. You cannot negate. Never again. This is always P. And P is given by this index. Plus negation.
01:02:11.522 - 01:02:12.614, Speaker C: You always have to have.
01:02:12.652 - 01:02:17.074, Speaker B: Always. You always have to have. Always write it down in the formula.
01:02:17.122 - 01:02:18.422, Speaker C: Or is it implicit?
01:02:18.486 - 01:02:18.858, Speaker B: Sorry?
01:02:18.944 - 01:02:19.834, Speaker C: Do you even write it down?
01:02:19.872 - 01:02:34.370, Speaker B: Yes, we even write it down in the formula. So it's explicit. Basically what you can specify is contract invariance. Contract invariance, exactly. You can say it this way. Yes. But you also can refer to the positive.
01:02:34.370 - 01:02:36.800, Speaker B: So that's the kind of cool thing.
01:02:38.130 - 01:02:49.614, Speaker D: I'm just curious, why not next? I'm not familiar with the verification technology, so is there a technical reason why next is more difficult than previous?
01:02:49.742 - 01:03:08.038, Speaker B: So for verification, it's slightly more difficult. You need to do some gymnastics. Okay. And when you add, eventually it becomes more difficult. Way more difficult. Because once you always look finite number of steps. In the past, because in the past, time is limited, it's bound.
01:03:08.038 - 01:03:39.294, Speaker B: But in the future, it's unbounded. When you add, eventually things become very infinite. Good. 25 minutes. Okay, so maybe we just go quickly over the exercises. So now it's time to formalize what we did. And just to load balance our verifier, we have two servers on which you can run varx.
01:03:39.294 - 01:04:13.740, Speaker B: There is graphic using interface. Let's say this part of the room uses Varx one and the other part of the room uses Varx two. Can we do it like this? Because the servers are powerful, but verification is difficult. Okay, I forgot the docs actually just reflections. So this is the online.
01:04:16.590 - 01:04:19.778, Speaker C: Sorry, just is verixon online too lonely.
01:04:19.814 - 01:04:20.954, Speaker A: Or is it downloadable?
01:04:21.082 - 01:05:15.198, Speaker B: At the moment it's online tool only. We hope to open source it in the future. Okay, so there are two servers left. Part of the room and for barrack syntax you can click this link and check out the. Yes, yes. Okay, so if you open the links, you'll see this kind of interface to barracks on the left. What you have is a list of contracts plus specifications.
01:05:15.198 - 01:05:53.180, Speaker B: So we preloaded barracks with couple contracts and currently we focus on the ERC 20 and crowd sales. Right. So we have two contracts which we focus on and the entries suffix with solution are the solutions to those exercises. We have three extra exercises which you can do, but maybe not, maybe there will be no time for this today. They have no solutions. So you need to kind of think a little bit more on that about. Okay, good.
01:05:53.180 - 01:05:54.540, Speaker B: Yes.
01:05:59.090 - 01:06:06.610, Speaker C: I'm wondering how do you do these state predicates? Is how like the state predicates, can I define one as a user for instance?
01:06:07.430 - 01:06:50.378, Speaker B: Okay, let me, maybe, yes, no, let me use, sorry. So you give a list of formulas. Later we'll talk about the remaining formulas. But what's important in the first formula. So the first formula gives your property and it has this form always and then some form. So whenever you are specifying something and then you have a table which gives you more details, the syntax. And for example you can refer to contract fields using contract dot fields.
01:06:50.378 - 01:07:14.854, Speaker B: So you can refer to the contract state this way I forgot some of the syntax details. Right. Also you can refer to message sender, you can refer to the current time, the time this world. I forgot the block. Sure, yeah.
01:07:14.892 - 01:07:16.360, Speaker C: So I guess I don't see.
01:07:18.730 - 01:07:35.070, Speaker B: State predicates. It's like it will try, it's double equality. Yes. Languages.
01:07:35.730 - 01:07:44.750, Speaker C: Yeah, you had an example with like success or refund? Success state prem and refund in your spot.
01:07:45.330 - 01:08:27.790, Speaker B: Yes. Well great economic, show them. Yes. Okay, let me just give you a short demonstration about the first property. Like total supply always equals the same amount. So yeah, okay, so, yes, better, we will write the price problem. This one is simple.
01:08:27.790 - 01:09:11.610, Speaker B: One say always token underscore balances. So is the case that the sum of balances equals the total supply. And if you go scroll down there is a verify button. Verify verification takes some time. You see that the property, the first one is queued which means it's a pending state. It's not known whether it verifies or not, and the other property is failed to verify.
01:09:16.450 - 01:09:18.880, Speaker C: I guess you just make a solidity function.
01:09:22.130 - 01:09:38.070, Speaker B: So you need to, verification takes some time. So you cannot, it's not how to say a tool where you get immediate feedback. It's just verification takes some time. Servers.
01:09:38.410 - 01:09:45.640, Speaker A: Yeah, I don't know about.
01:09:51.130 - 01:09:51.654, Speaker D: Why does.
01:09:51.692 - 01:09:52.760, Speaker A: It take so long.
01:09:53.210 - 01:10:13.994, Speaker B: It takes so long because we analyze it at the bytecode level. You're absolutely right. And the very short tool that you heard about yesterday, does it very solve? Very. So it's a tool from Microsoft. It verifies it on the faster syntax, which is kind of the high level semantics. And then it can be faster.
01:10:14.042 - 01:10:14.640, Speaker D: Absolutely.
01:10:15.570 - 01:10:28.166, Speaker C: So you said you support some. Does that just mean some opcodes aren't supported? Or what does that mean somewhere before, well, maybe it was in your paper. I was reading it.
01:10:28.188 - 01:10:40.900, Speaker B: But delegate, for example, is some offcodes, some of those, like when you have delegate pro, it's very easy to break any property, would you say does not.
