00:00:00.330 - 00:00:41.946, Speaker A: Yeah, let's see, Maurice more or less tricked me into this, came to me, hey, we're having tweet app, do you have something to talk about? And I said yeah, no, but we could make a Q and A. Yeah, so we wanted to release 00:50 in May or something like that, but then some things came up and some other things came up, but he finally released it some weeks ago and we even released zero five one in the meantime. So we're making progress. I don't know, are there already some questions? Otherwise? Maybe not, I don't need the mic for that.
00:00:41.968 - 00:00:49.660, Speaker B: But I was saying maybe you should. For those who were not in Devcon, maybe you should summarize what is new in 5.0.
00:00:51.170 - 00:02:14.470, Speaker A: Yeah, so most of the changes were already part of the previous releases. And you could, I mean, 00:50 is mostly just enforcing you to be more strict, more explicit about things. And most of these things you could already activate in older versions with the pragma. Among these are explicit visibility for functions, a special keyword for the constructor, a special keyword to emit events, forcing you to provide the data location of variables. So either storage memory or call data, because that was always a little bit confusing because the default was different depending on the context of the variable. What else do we have? I mean, Abi encode and ABI decode, that's more like features. So you can now get access to the ABI coder from within your code, so you can turn a byte array into structured data and back scope scope.
00:02:14.470 - 00:02:26.462, Speaker A: Yeah, we have C 99 scoping for variables now and not the weird JavaScript scoping anymore. Yeah, but I think there was a question.
00:02:26.596 - 00:02:27.280, Speaker C: Yes.
00:02:30.530 - 00:03:07.450, Speaker D: So I tested 0.50 and I really like the features. The only thing I hate is the address payable because I tried to port my project to 0.5 and there were some weird addresses that came up and why am I not allowed as a developer to cast an address to address payable? But yeah, it's not allowed to the casting from address to address payable.
00:03:07.870 - 00:04:37.938, Speaker A: So address payable was something that was not part of the previous releases. And the reason we added it was because contract types, they have fallback functions, and the fallback functions can be payable or they cannot be payable, and depending on that property you can send ether to the contract or not. So the send or the transfer function is only available on contracts that have a payable fallback function. And one change we did is we removed all the address members from the contract member from the contract type, because they would just, I mean, you might have a function that is called transfer on your contract, and that would conflict with the function that is part of the address type if you want to use transfer. This needs a little bit working out, so, and now this fact of whether the follower function is payable or not, that is lost. So remove the members from the contract type. So you had to convert the contract to address first to use the transfer function.
00:04:37.938 - 00:05:16.560, Speaker A: But if you convert it to address, then the fact whether you have a payable fallback function or not is lost. And because of that we introduced the address payable type. And so contracts with a payable fallback function can be converted to address. Payable contracts without a payable fallback function can be converted to address. Okay. That's the reason why we introduced it and we did some testing. So we run the compiler against quite a lot of existing projects, and we needed to make these changes to the existing products before we could run the compiler against it.
00:05:16.560 - 00:05:57.920, Speaker A: And while updating these contracts, we noticed that there's not too much you have to change. And the reason is that usually you use the transfer function. For example, if you use the withdraw button, then you call the transfer function not on an address that is stored in stores somewhere, but you call it an msg sender. And Msg sender is payable by default. And if you really want. So you can convert address to address payable when you go through an integer type.
00:05:58.690 - 00:05:59.870, Speaker D: Yes, I did.
00:06:00.020 - 00:06:09.022, Speaker A: Okay, my question would be what are the situations which you need a conversion?
00:06:09.086 - 00:06:56.240, Speaker D: I inherit a contract from some other source, some library or some, let's say open zeppelin or anything. And there the address specified as address, not as address table. But I have one specific use case where I need to pay something to this address that was specified in the library. There was one thing where I wanted to self destruct something to the owner, and I imported ownable. And in ownable there is in ownable, it's an address. And I had some part of the code where it says self destruct to owner, and that wasn't possible.
00:06:57.730 - 00:07:01.710, Speaker A: And why do you know whether the owner can accept ethnic?
00:07:04.470 - 00:07:21.270, Speaker D: Actually, I didn't even care because there shouldn't be any money on the contract anyway. But I needed to provide some address to the self destruct function. Yeah, but anyway, this is a very.
00:07:21.340 - 00:07:31.414, Speaker A: Fringe situation, but yeah. Do you need to make lots of changes there or conversions?
00:07:31.462 - 00:07:39.920, Speaker D: No, this was the only scenario where there were some problems with the table, with the address table function.
00:07:40.850 - 00:07:41.840, Speaker E: Okay, thanks.
00:07:42.930 - 00:08:34.080, Speaker A: So in general, you probably know that, okay, most people who write compilers write them in a self hosted manner, which means that the compiler is written in its own language. So in the language the compiler is to compile. This creates tons of problems. But anyway, even without these problems we can't do it because running the solidity compiler inside the EVM would be kind of weird. And this leads to a situation that we as compiler engineers don't really use the language a lot, and because of that we always are happy about any feedback that we get from the people that actually use it. I think I talked too much. Right? There was another question.
00:08:34.080 - 00:08:36.942, Speaker A: Was there or not?
00:08:36.996 - 00:08:38.160, Speaker F: Do you have a question?
00:08:39.670 - 00:08:41.490, Speaker A: I think I saw a hand somewhere.
00:08:43.430 - 00:08:44.450, Speaker C: Closer.
00:08:48.470 - 00:08:49.940, Speaker F: Walk, first of guys.
00:08:55.210 - 00:09:02.150, Speaker B: All right, just a quick question. Could you explain the point of Yule?
00:09:02.970 - 00:09:03.638, Speaker C: The what?
00:09:03.724 - 00:09:05.880, Speaker A: Yule. What about it?
00:09:07.370 - 00:09:08.940, Speaker B: What's the point, really?
00:09:12.750 - 00:10:09.630, Speaker A: So that's something I noticed in your talk. Yeah, okay. You were saying something like perhaps I got it wrong, but it's something like we still need the EVM and solidity due to some reasons and webassembly will not destroy it. And the thing is, the reason for Yule is to be able to compile solidity to webassembly. Right. Okay, we're preparing for already over a year now to compile solidity to webassembly and Yule is the intermediate step to go there. And yeah, I mean if you say Yule and you mean solidity inline assembly, then this is another use for it which allows you to write more low level stuff that is not part not available in the language.
00:10:09.630 - 00:11:19.854, Speaker A: Yeah, and the other use of Yule is as an intermediate language inside the compiler. And the cool thing is with getting back to on topic with 00:50 we disallowed the so called loose dialect of inline assembly or of Yule and the strict version. So the difference between loose and strict is that in the loose version you have direct access to the stack, you can run, can use opcodes that manipulate the stack, and in the strict version you only have variables and function calls essentially. And this fully abstract away whether or not there actually is a stack. And webassembly does have an expression stack, but it's different than it also has native function calls. And because that stack is different from the one that is used in EBM. And if we introduce Yule as an intermediate language then everything will compile to Yule.
00:11:19.854 - 00:11:35.260, Speaker A: And there we don't use any features of the EVM and it's just that you don't use the stack. And because of that we can easily compile to both webassembly. And does that answer your question? Yes.
00:11:40.670 - 00:11:42.620, Speaker F: Do we have some more questions?
00:11:47.790 - 00:11:48.650, Speaker C: It's.
00:11:51.010 - 00:12:05.810, Speaker G: Yeah, I just want to ask if you have any information. 0.5 is going to replace 0.4 points, whatever, or are they going to get along together or 0.5 was going to take over 0.5 and let it plane.
00:12:07.030 - 00:12:16.280, Speaker A: So we have no plan to maintain older releases. I'm not sure I understand your question.
00:12:17.610 - 00:12:20.838, Speaker G: So 0.4 is over. So there is not going to be.
00:12:20.924 - 00:12:26.278, Speaker A: Any, there won't be any patch releases for zero four X.
00:12:26.444 - 00:12:26.870, Speaker C: Okay.
00:12:26.940 - 00:12:29.240, Speaker G: Because so far it's like the real.
00:12:33.180 - 00:12:44.888, Speaker A: I mean, we had no release for six months, and that was because we were preparing for the breaking change. There was one intermediate buff fix release, but that was just to fix a very important bug.
00:12:44.984 - 00:12:45.630, Speaker C: Okay.
00:12:49.270 - 00:12:50.500, Speaker F: Some more questions.
00:12:57.050 - 00:13:40.370, Speaker D: So can you say something? How the inheritance structure works? Because this changed quite dramatically in 0.5, I saw that you're now able to inherit automatically generated getter function in 0.5. So it used to be that automatically generated getters don't comply to the interface they inherit. But what I also didn't see is that you can inherit interfaces from other interfaces.
00:13:41.110 - 00:14:23.650, Speaker A: We didn't make too many changes to inheritance, actually. So the getter functions might have been one of the smaller changes. And actually in 00:51 we added another change that allowed more function overwriting. I think the main reason that allowed getter functions to overwrite interfaces was that interfaces are now required. So interface functions now have to be external and cannot be public anymore. And we allowed public functions to override external functions. But that's only.
00:14:23.650 - 00:14:25.940, Speaker A: I thought that was only part of zero five one.
00:14:27.270 - 00:14:28.020, Speaker C: Okay.
00:14:36.160 - 00:14:41.870, Speaker F: Do we have some more questions? Maybe one last question.
00:14:44.000 - 00:15:35.230, Speaker A: Perhaps one word on inheritance in general. So we plan to do an overhaul of inheritance at 60, and the idea there is not to change the inheritance model itself too much. So we will still keep Python c three linearization multiple inheritance model. It's more likely will be more restrictive, especially when it comes to overwriting. So you can't just have two functions incoming from two different base contracts, two functions, the same name, and you will have to explicitly state whether you want a function to be overridable or not, and things like that.
00:15:41.210 - 00:16:16.226, Speaker H: I just want to ask a hi to a question. I'm not a developer, and most of what you just said I didn't understand. So what is the state or what's going to happen with webassembly? I mean, I heard in a podcast that there was some plans that in the end, we'll have different charts on Ethereum and some will run on the EVM and some will run wasm because I guess converting solidity contracts into WASm is not really an option. So I just would like to know how that will all work out, like the coexistence.
00:16:16.338 - 00:16:43.440, Speaker A: So on the solidity side, the plan for next year is to be able to compile to ewasm. So that's not a problem on the chain side. I mean, the compiler just will generate some bytecode and you can use it on every chain and on every side chain. Whatever you want. Yeah, I can't really say much about the adoption of webassembly in Ethereum, mainet or Ethereum 2.0.
00:16:45.650 - 00:16:46.254, Speaker C: Okay.
00:16:46.372 - 00:17:08.760, Speaker A: Yeah. I'm personally a bit worried about claims about performance because that hasn't been really vetted yet, but it will probably be faster due to it having native functions and it having 64 bit types. Yeah, we have to see.
00:17:11.700 - 00:17:14.850, Speaker F: All right, do we have maybe another question?
00:17:17.800 - 00:17:18.404, Speaker D: No.
00:17:18.522 - 00:17:19.750, Speaker A: Well, I have one.
00:17:21.640 - 00:17:23.508, Speaker F: Are you taking one more question?
00:17:23.594 - 00:17:24.470, Speaker A: Yeah, sure.
00:17:24.840 - 00:17:26.790, Speaker B: But I'm out of smart questions.
00:17:29.080 - 00:17:29.444, Speaker A: Yeah.
00:17:29.482 - 00:17:52.270, Speaker B: So it's not really a technical question, but you said like yes, from four to five. There's quite a lot of changes in the language. And I would be interested if you had a couple of words of wisdom on how you handle potentially compatibility breaking changes. How did you handle that? How did you manage that?
00:17:56.240 - 00:18:27.204, Speaker A: I don't know. I'm not sure if I really understand the question. But I can say something about breaking changes. Sure, there are different types of breaking changes. There is the one breaking change which just makes a contract that compiled before does not compile anymore. That's an easy breaking change. But there are some breaking changes also between four and five where the contract compiled before and it still compiles.
00:18:27.204 - 00:18:43.516, Speaker A: But it's behavior changes and these are tricky and they should be kept to a very, very basic minimum, and everyone using language has to know about them. I hope that's the case. Yeah. Was that basically your question? Yeah, it's more or less like, did.
00:18:43.538 - 00:18:47.104, Speaker B: You document those changes, for example, those second case changes?
00:18:47.142 - 00:19:17.770, Speaker A: So we have a dedicated page in the documentation that says these are the changes and this is what you have to do to your source code to update it to be compatible with. So I hope that documentation is enough for everyone. If not, then please talk to us. We didn't get too much feedback on that yet, so not sure if that's a good or bad sign.
00:19:20.860 - 00:19:21.610, Speaker C: Okay.
00:19:22.880 - 00:19:57.430, Speaker A: Perhaps also some meter information that came out of the audit. We had made whatever that was made. They said we should make breaking changes more often. And we don't have a specific plan yet, but we're thinking about perhaps every two to four or six months. Yeah, let's see how that will work out. Great.
00:19:58.360 - 00:20:02.900, Speaker E: So the definition of a breaking change is that contracts need to be rewritten.
00:20:04.920 - 00:20:12.056, Speaker A: There is at least one contract that does not compile anymore, or at least one contract whose semantics change.
00:20:12.238 - 00:20:19.020, Speaker E: Okay, so what happens during the release? Do this contract go blind?
00:20:20.560 - 00:20:35.660, Speaker A: It's just about the source code. So if they have been deployed then it's not source code anymore, it's bytecode. And there a breaking change is a hard fork basically. So that's out of the scope compiler.
00:20:37.120 - 00:20:39.344, Speaker E: Otherwise it a break in the runtime.
00:20:39.472 - 00:20:40.150, Speaker A: Yeah.
00:20:48.050 - 00:20:59.350, Speaker F: Do we have another question? Okay, I think the question answer session is over for now. Thank you so much, Christian.
