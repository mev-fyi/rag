00:00:16.970 - 00:01:26.850, Speaker A: Good morning so, Swarm City so just as many other Ethereum projects we are trying to is this on? Thank you. This is our vision just like many other Ethereum projects, we want to enable humans to transact, create and share value without a middleman or a third party on a global scale, generating contextual reputation our mission is to do this in a way where normal people like our parents actually understand what we are doing. So we don't want to have people experience the blockchain. Basically, we want to really make it really easy to use today we want to discuss two topics we are trying to solve Ethereum byte problems that we encounter in creating an app that is consumer facing. So the first thing we want to talk about is the IPFS Consortium the second one is the gas station. So the first thing IPFS consortium. So if you want to create an app like we do, that's totally decentralized, you still need storage.
00:01:26.850 - 00:02:15.110, Speaker A: We needed to find a way to have data persistence so even if you do it on IPFS, you have to make sure that your data is persisted over time. The way we came up with that solution is really interesting because the way we came up with solution actually is kind of the solution it's collaboration because it's key in the blockchain world. So we sat together with Giffet in Barcelona and many other people and after a night of brainstorming, we came up with this really simple solution I'll pin your data. If you pin mine for an in depth or a more in depth technical overview of that solution, I'll hand it over to Spanad.
00:02:16.570 - 00:03:17.610, Speaker B: Okay? Good morning, everybody. So the solution we came up with for the Ipvest Consortium is actually that we created smart contracts. So by the way, this works on top of another persistency consortium project by Piper Marion so we tried to extend it a little bit and make it more general that everybody could use it in a more flexible way. So we created a smart contract, the IPVs proxy contract and this contract will just emit events so we have two events like hash added so even IPFS hash gets added or needs to be added to the consortium it has a time to live, for example, and then the IPFS hash itself and the hash removed function. So if you don't need the data anymore and you want it out of the consortium so it's not pinned anymore, you can do that. Then in the smart contract itself, we implement the two functions, add hash and remove hash, which basically just emit these two events. So it's very low on gas to actually call these two functions.
00:03:17.610 - 00:04:06.918, Speaker B: Then all these members in the IPFS Persistence Consortium, they will install a script on their respective IPFS nodes, which is a proxy listener, which is just a script that goes and listen to these events on that IPFS proxy contract. So that's a general setup. Now, there are a few more things there. For example, the IPFS proxy contract contains a list, sort of a whitelist with all the members of the IPFS Consortium members. So that means that all their public keys are in there. So it can actually verify if they call the contract so that only IPFS member hashes are pinned in the IPVs nodes itself. So there are different ways of adding your hashes to the IPVs Consortium.
00:04:06.918 - 00:05:09.402, Speaker B: So first of all, if you have a DAP or a script which wants to pin content, you can just call the function, add hash or remove hash. So that's the way from doing it from your DAP itself for the front end. But we also exposed these IPFS events as a separate solidity file which you can just include in your own smart contract. So if the logic of your DAP actually needs to store IPVs content from on chain, basically they can just create your contracts by implementing these IPFS events. And then the consortium members can add their contracts to the IPFS proxy so it has a second list in there. And if they add it to the IPFS proxy contracts, then these proxy listener scripts will also start to listen to these same events in all the specific smart contracts that they use. Now, concerning the governance of the IPVs Consortium, so we don't want one single owner to manage the consortium.
00:05:09.402 - 00:06:00.682, Speaker B: So that's why we added multi members. So that's basically the multi code to vote on adding or removing members. All the members, they pledge to persist each other's data and they allocate an equal amount of disk space or they sort of donate all an equal amount of disk space in the Consortium. So it's interesting to notice that we can deploy one of these contracts which has a certain quotum and all the members there, they say okay, we are going to do this like for example with a quotum of 10GB. But it's very easy to deploy a second contract which then has like for example, a Quotium of 50GB. So you can just choose to set up new of these contracts. Some of the future enhancements that we want to bring is that we can also do pinning via Whisper.
00:06:00.682 - 00:07:00.594, Speaker B: So the idea is that you would just call or create a data payload in Whisper which has the same command. So add hash and remove hash which is the IPFS hash itself and the time to live. You will create a hash and you will actually sign with an elliptic curve signature this payload and you can just send it to a Whisper channel and we can have then the script listen to this Whisper channel and just pick these things up. So to give a roundup on the Ipves Consortium, so we have the possibility to do on chain pinning by a smart contract, we can do off chain pinning by the DAP or the scripts which then performs a transaction, we can then using the whisper solution also do off chain pinning without a transaction. So just by signing it with your own key, we have the multi member voting to add and remove participants the data quotum. But on top of that, we also support that the network is permissionless and maybe I'll give it back to King, Florida to explain that.
00:07:00.632 - 00:07:50.210, Speaker A: So that's a really interesting case. So anyone can run this proxy script at home on their own computers. And like we saw in Barcelona a couple of weeks ago, when the Spanish government tries to block IPFS host names, we think it can be powerful that many people can actually have a voice and run this software just on their own computers. Currently the IPFS consortium is of course in kind of prototype. We proved that it works. But of course we are inviting everybody to join us and to make sure that we can have data persistence in a decentral way. So the second thing we want to talk about is the gas station.
00:07:50.210 - 00:08:45.220, Speaker A: So what we do if we want people to onboard our project, of course we send them some smart city tokens. But then we always have to see and you need a little bit of Ether to actually do something with it because every transaction and then you have to tell a whole story about gas, right? So for a lot of people, like my dad, for instance, he was like, why do I need two coins now? Or two tokens? So our ideal solution will be that it is a one click solution in the front end in the app where people can actually exchange a little bit of their tokens for gas. Our design process is kind of funny, I think, because we always use the metaphor of a city. So if you drive around the city, you of course need gas. And what do you do then? You go to a gas station. Oh, I'm going to hand it over to Spunett for this.
00:08:46.070 - 00:09:35.246, Speaker B: Thank you. So the way many of the existing Ethereum projects solve it currently is by just giving away some free gas. So just sending some gas to a certain address which was created in a wallet in the hope that they will actually use that gas to perform transactions in their ecosystem or to use their app. But most of the time you can't be sure if they will actually use the gas for that or they just do some sort of civil attack and just try to collect as much free gas as possible. Another problem is also that if your app becomes very successful, you have to have a lot of eater somewhere just to provide everybody with some free gas to get started. So we tried to come up with a solution where you can actually just do the exchange. We have like a durable solution that people just are able to pay with our tokens for getting the initial gas.
00:09:35.246 - 00:10:07.146, Speaker B: So it's also a two part solution. So first of all, there's an API which needs to run, which is the gas station service. And next to that, we have a gas station contract that's deployed in lockstep with that, so people can actually just run it themselves. So first of all, you decide which ERC 20 token you would like to support. So in our case, it's Swarm City token. And then you send some initial eater. That changes one eater because it's just about providing initial gas.
00:10:07.146 - 00:10:55.274, Speaker B: So it doesn't need a big amount of eater. You send it to the gas station. So you sort of fill it up with eater. So that's the setup if you then have a DAP. So the use case here is that you have like a new user who someone just sent a couple of these Swarm city tokens, but he doesn't have any gas, so he can't do any transaction yet. So the thing he can calculate is how much Whey he will actually need to perform the first transactions that he wants to do to get started. So we will ask to the gas station service, what is your price for this amount of Whey that I will need the gas station? He will consult a public price API to see what the current exchange rate is for Ether to Swarm City tokens.
00:10:55.274 - 00:11:47.086, Speaker B: And it will reply to say, okay, this many way would cost you that many Swarm City tokens. The next thing that happens is that the device itself or the DAP will sign an allowance, which is an ERC 20 function to the gas station contract for that amount of Swarm City tokens. And on top of that, it will create an elliptic curve signature for all these parameters. So the amount of Swarm city dogs he's going to give and all that. We're going to adapt a little on one of the next slides. So he will send this signed transaction back to the gas station service, and then the gas station service will verify that transaction. So we'll decode it and if it all fits all the prerequisites, it will actually send gas to that address.
00:11:47.086 - 00:12:25.722, Speaker B: So the address of the DAP to execute the allowance call. When he sees that that gas has arrived, he will execute the allowance transaction by just putting it into the transaction pool. And when that transaction is mined, the gas station service will call a function in the gas station, which we call push fill. So let me quickly show how it begins. It's not a complete function, but just to give you an idea about how it works. So what does it give with push fill? So it provides a token address, which is the ERC 20 token that you support or you want to exchange. It gives you a validity date which is expressed in a block number.
00:12:25.722 - 00:13:13.718, Speaker B: So this sort of personal exchange rate is valid as a validity period. We add a random number to create some entropy on the but that will come later. Also you will say how many of these swarms tokens you can take from him in exchange for how many way in ether you will give them. Then you also provide the gas tank client which is the address of the DAP. So the wallet address from the DAP and then the signature. So the thing that the contract will do, he will actually recreate that same hash with all these parameters and here he will verify if the signature of all these parameters are actually match up to the address of the Gaston client. If so, he does the actual exchange.
00:13:13.718 - 00:14:17.498, Speaker B: So the code is not here and he will mark that specific, let's say contracts or that specific configuration to be executed so he can't repeat it twice. Concerning risk mitigation, there is one problem because you have to trust the gas station service that he will actually also perform the second transaction. If you give him the allowance transaction you must be sure that he actually does that push field thing. So to mitigate that. So I told you before that the API service responds with so many way would cause that many swarm tokens but actually he's also going to give a LICT picker signature on these parameters with his key because it also has a wallet, obviously. And then we create the second function which is called pull fill and it will verify the same parameters but will actually just verify if these parameters were signed by the owner. And this function can be called by the gas station sorry, by the client who uses the gas station.
00:14:17.498 - 00:14:51.830, Speaker B: So he has a certitude that if they do the exchange they sort of mutually give the allowance to do exactly that transaction. So why would you participate or why would you run a gas station? Because we can define or you can define an uplift for the price you sell your eater for. So it means if you would for example say 10% uplift if your gas station sells out because the amount of heater decreases, the amount of swarm tokens increases, you will end up with when you sell all your eater with an amount of swarm city tokens which equals like 1.1 eater.
00:14:55.630 - 00:15:29.874, Speaker A: So the result of that is that anybody can just download that API script, deploy its own contract, prime it, we call it with eater, then configure it like what? ERC 20 tokens do you want to accept in your gas station? Then tell it how much eater markup you want to sell it for and just start it. You can find everything we are doing on these GitHub links and also on this is swarmcity. You will find more information on everything we do.
00:15:29.912 - 00:16:15.134, Speaker B: But there is of course one more thing that we created. So as you see the gas station it's at a certain time it needs some maintenance because it needs to be refilled because the eater gets depleted in the end. We also tried to solve that and we have like prototype code of that, which you can also find on our GitHub. So we created an integration with Eater Delta. So the thing is that the gas station service itself, it contains a wallet. So when it has a certain amount of Swarm City tokens and it's almost depleted of Ether, the gas station service can actually look into the Ether Delta and try to find a buy order for Swarm City tokens for Ether. So when he finds one, he will actually purchase it because it's like anonymous.
00:16:15.134 - 00:16:48.942, Speaker B: I mean, you don't need an account or registration or whatsoever. So we just created like a machine to machine trading that actually buys Ether in exchange for your Swarm tokens. So the thing is, you can actually refill or automatically refill your gas station with Ether to start again and closing that loop. And so this can be fully automated. So you don't actually need to manage the gas station anymore. You just can have it run. When it does the exchange, you will actually end up with more eater than you started with.
00:16:48.942 - 00:16:54.730, Speaker B: So you will end up in this situation with like 1.1 eater instead of one eater.
00:16:54.890 - 00:17:04.860, Speaker A: So, yeah, we thought it was appropriate to call that the gift that keeps on give a thing. So basically that is thank you. Thank.
