00:00:14.250 - 00:00:24.670, Speaker A: So hi everyone, my name is Rita Trinkler. I'm the chairman and co founder, together with Mona Lisa of Mellonport and Marlin, advisor to the web3 foundation.
00:00:25.370 - 00:00:26.920, Speaker B: It so.
00:00:30.730 - 00:00:31.142, Speaker C: Great.
00:00:31.196 - 00:00:54.350, Speaker A: So let's start with formal verification. So, formal verification is the act of proving or disproving an algorithm with respect to an intended underlying algorithm. So this algorithm is specified in a formal specification. So I'd like to ask all of you, what makes a good specification?
00:00:57.430 - 00:01:00.610, Speaker D: What makes a good specification?
00:01:02.630 - 00:01:39.120, Speaker E: What makes a good specification? That's a good question. So I think theoretically the answer is that the specification accurately captures the intent of the developer who wrote it. Making sure that's the case is obviously very difficult. So I think a lot of that depends on sort of your tooling and the feedback that it provides when you're writing the specification. But in general, I'd say a good specification accurately reflects the intent of the developer and also encodes sort of all of the assumptions that the smart contract makes very explicitly and very clearly so that if someone were to update the smart contract later or something, they would all be very nicely in the same place.
00:01:40.130 - 00:01:54.980, Speaker F: I just want to add a little bit more. I think a good specification should be easy to understand and should be easy for other to read and build test case later on. And it's great if it follows some standard as well.
00:01:56.570 - 00:02:17.130, Speaker D: I think in general, any specification is better than what most people do, which is no specification. So that's probably a good place to start. Ideally, you'd write a specification and then argue over that for a few days at least, and then write your tests and then begin coding. But a lot of people kind of do it, maybe in the reverse order or something like that, or maybe they never even write a specification.
00:02:20.290 - 00:02:51.720, Speaker C: Phil's answer captures it. But maybe a good specification should put contract in bigger picture, what kind of game people can play on it, what would be the best strategy for rational players, and so on. If specification fits into this crypto economic mechanic game? Theoretic reasoning that something nice, but this depends on the application.
00:02:53.610 - 00:02:54.310, Speaker B: Thanks.
00:02:54.460 - 00:03:20.510, Speaker A: So what is your take on a specification specified kind of abstractly from a method of mathematics versus specification implemented? For example in one is kind of like a reference implementation in Haskell, and the other is just kind of abstract, like purely theoretical?
00:03:21.410 - 00:04:00.954, Speaker D: Well, I think that a reference implementation in Haskell is a perfectly fine specification. Honestly, I think a lot of people, when they think of a specification, think of kind of just an english language document or something like that. But at least in our group, we focus a lot on executable specifications. So I think a Haskell implementation, that's a whole hell of a lot better than no specification once again. And at least you can test it, right? You can run tests against your specification even before you go to implementing the final thing. So that's already a huge advantage over an english language specification, for example. But certainly english language specifications are easier to write.
00:04:00.954 - 00:04:04.160, Speaker D: So maybe start with that and then do the haskell or something like that.
00:04:05.490 - 00:04:34.200, Speaker E: Yeah, I totally agree with everything that was just said. And I sort of want to add that you can have good or bad specifications in any format. So absolutely. While it's nice to have a specification be testable and clear and readable, you can have really, really good Haskell language specifications, or you can have pretty bad Haskell specifications, and I've even seen English language specifications that are not entirely bad. So sort of goes more to the expertise of whoever's implementing it, I think.
00:04:34.730 - 00:04:35.480, Speaker B: Great.
00:04:40.730 - 00:05:09.380, Speaker A: So could you maybe share a bit about what is like new and unique about formally verifying smart contracts, blockchains kind of compared to safety critical hardware verification? And what are the corresponding opportunities of it? Kind of what is new and unique about formally verifying smart contracts or blockchains compared to like for example, verifying hardware? And what are the opportunities of it?
00:05:11.030 - 00:05:41.950, Speaker F: I guess smart contract has a new sort of semantic right. So we have the concept of transaction have the concept of gas and token and ether, which doesn't exist in existing system like critical hardware or software system. So when you formally verify it, I think you need to define new property that you want to verify that only exists in smart contract and also ethereum.
00:05:43.730 - 00:06:22.700, Speaker E: There's definitely some really nice things about smart contracts. They're bounded in terms of their execution time. They're generally very small, simple programs, at least compared to something you'd see in a safety critical system, a car or an airplane or something like that. And they directly handle large quantities of money. So actually I'm really excited, I think that I said this last year, and I still strongly believe it, that as a space we have an opportunity to set standards for how software is developed, even beyond blockchains and smart contracts, because I think the users of smart contracts and blockchains have a much stronger understanding and demand for this kind of technology than the users of a car or something like that.
00:06:24.670 - 00:07:03.350, Speaker C: So ethereum virtual machine has no non determined behaviors, no non defined behaviors, because that means consensus folks. So this possibility of different clients following different folks is a huge problem. But it's really a blessing for us. On top of the virtual machine, because that means the specification is really always deterministic. That's a huge improvement of proving anything over intel chips or armchips.
00:07:05.290 - 00:07:06.040, Speaker B: Thanks.
00:07:07.290 - 00:07:30.026, Speaker D: Yeah, Joanna, pretty much agree with what people said. The nondeterminism makes it easy. The bounded gas makes it kind of nice, although sometimes it's hard to reason about exactly how much gas a contract will use. And basically what's making the most driving force behind this is the amount of money being at stake, essentially, as opposed to just normal programs in other settings.
00:07:30.218 - 00:07:38.260, Speaker C: Let me move over, because the echoes make it really hard for me to understand the question.
00:07:40.550 - 00:08:01.210, Speaker E: Yeah, it's kind of interesting how people care a little bit more about money than their lives, right? You have someone lose their 50,000 in Dow tokens and they're clamoring for formal verification. But then Toyota has an issue in their ECUs that kills 20 people, and Toyota customers could not care less about the software in their car. So I just think that's kind of an interesting observation on humanity.
00:08:01.710 - 00:08:03.580, Speaker A: It is kind of interesting, yeah.
00:08:04.990 - 00:08:05.450, Speaker C: Great.
00:08:05.520 - 00:08:19.760, Speaker A: So could you maybe talk a bit about the limitations and challenges of formal verification and maybe also introduce the project that you're involved with and how your project kind of tries to make things easier or better?
00:08:24.880 - 00:09:16.910, Speaker C: My background interactive theorem proving is not user friendly. So take class of computer science students of 30 people, maybe a couple of them are willing to use interactive theorem provers. Maybe only one of them can finish verifying a program of like 2030 lines in a month or so. So it's kind of challenging. Actually verifying software using these interactive theorem provers is so challenging that I don't see many successful applications. But for the reasons described before, I believe in Ethereum it might still make sense.
00:09:19.520 - 00:10:30.800, Speaker F: I guess it's really hard to formally prove existing smart contract, especially the complicated one, because first of all, you need to represent them in some mathematical model that you can easily prove some property later on. But it's really hard to convert or transfer or interpret the program into the new language or the new model because of the compatibility issues. Right? And also, sometimes you cannot even explore all the possible outcomes or properties of the program. And most of the formal verification tool requires strong background and human involved, right? And most of the project and companies do not have these people, really. We need some sort of user friendly developer tool so that you can just run the tool with some existing smart contract and it will produce other headphone output for the developers.
00:10:31.620 - 00:10:32.370, Speaker B: Thanks.
00:10:32.820 - 00:11:30.292, Speaker E: Yeah, so I work on sort of a number of projects in the correctness space. One of them is I'm advising this sort of heavier weight formal verification project called KVM. I'll let Everett describe that, since he's actually the lead. But to speak to the broader point, I think there's like a very wide range of correctness techniques that we have here, both formal, informal, and semi formal. And another one of the projects I'm on, Hydra, is sort of a lighter weight approach to this, where you abandon full formal guarantees for sort of low cost and easy startup, which I think is a very valuable thing to a lot of companies who aren't going to be able to, as Lloyd said, hire the right people or have the right expertise. At the end of the day, formal verification is still super expensive, it's still hard to do, and it still doesn't give you perfect guarantees. So it's understandable why, for a lot of people, especially now that the tools are not totally mature, the business case sort of isn't there.
00:11:30.292 - 00:11:44.040, Speaker E: So I think we need to develop a range of techniques and ask ourselves what are really our high assurance contracts here to use our full fledged techniques, and how can we get the other ones to a better level of security with the lower hanging fruit techniques?
00:11:45.260 - 00:12:59.172, Speaker D: Yeah, I think I agree pretty much with what Phil's saying here. And actually, it makes me really happy that I see so many people just emphasizing the importance of testing and of writing specifications, because just those two steps alone force you to first clarify in your head what is it I'm trying to do, which so many people don't even do? They just sit down and start kind of plonking away at code, and then second to kind of concretize that by writing some tests and then say, like, is what I did actually implementing these tests? So the tests kind of serve as a semi specification, if you will, or a concretization of the specification. Regarding the KVM project that Phil mentioned, I think it helps with the entire. There's the entire range of verification that you can go through, right? You can start at testing and you can move up to some sort of runtime verification or runtime model checking, up to model checking, which is where you explore the whole state space of a program, and then up to theorem proving, where you use more advanced techniques to prove that a program is behaving correctly. And K gives you tools for all of those things, actually. So I think Kavm can be a useful tool in that space. It doesn't have quite a nice user interface, unfortunately, so it suffers from that.
00:12:59.172 - 00:13:02.980, Speaker D: But I think it can help a lot in all those areas.
00:13:04.920 - 00:13:05.670, Speaker B: Thanks.
00:13:06.200 - 00:13:21.000, Speaker A: So it seems like a common theme. Seems to be, it's like too complicated. How can we make tools? Or how can we develop approaches that are more accessible to the end user?
00:13:22.700 - 00:14:05.130, Speaker C: I think in the end, it's not reasonable to expect the end users or users to read logical formulas, or maybe K configurations are more accessible, but it's hard. So at the end, what we want is tool that can synthesize an advisory based on the unproven goals. Well, this scenario can happen and it can play it on web browser. Maybe not an animation, but it should look like somebody attacking your contract. That would make the problem much more easier to understand.
00:14:07.660 - 00:14:36.770, Speaker F: So I guess usability is always a hard problem, right? And that's also one of the motivation that why we built o nt, the smart contract analyzer based on symbolic execution. So the idea here is that user, they do not need to understand how o t works, they only need to paste their smart contract into o nt or into their web browser, and they click analyze, and we can just show all the possible vulnerabilities that ont can figure out.
00:14:38.580 - 00:15:30.372, Speaker E: I personally think demand sort of breeds progress in this direction. And we're sitting in a room of some extremely smart and talented people, and we've seen some projects that really push the envelope in a number of spaces. And while the tools are hard to use, and there certainly could be improvements made, there, nothing here is sort of magic or anything like that. So I think sufficiently motivated developers who are incentivized by the market to develop these tools is really what we need to push the envelope here. Another thing that I think is really helpful, and I'd like to especially congratulate Mellamport for taking this approach, is to take these things out of academia and into industry and use them on real contracts with real developers who are working on the ground in solidity. I think just that step could do a lot for usability. And academics are not really the greatest at writing super usable systems sometimes.
00:15:30.372 - 00:15:34.390, Speaker E: So more broad participation would definitely help.
00:15:36.520 - 00:16:13.760, Speaker D: Yeah, thirding that, he just said he seconds it, but yeah, definitely the approach that Mel import is taking seems to be the correct one. Just make the tools usable and make them check for some specific properties automatically. Certainly all the verification tools can be instantiated to do those sorts of things, but it takes effort and takes developer time, and it takes people who know the tools to do that instantiation, and that's not going to happen overnight. So these lighter weight methods like Phil's Hydra stuff, that's really going to be the stop gap until we can have better tooling for all these high assurance tools.
00:16:15.780 - 00:16:42.440, Speaker A: Thanks very much. So the last question from me and then opening it up to the audience is essentially a shout out from you guys. So what would you like to see? Kind of from different ecosystem players. So from the users, the developers, the investors, the project leads and the researchers to make formal verification mainstream.
00:16:45.040 - 00:17:50.850, Speaker C: In the current ecosystem, I think it's still the user's responsibility to make sure that they understand the contract they are interacting with. People are proposing markets for audits and so on, but these are not working yet. So actually, I have to repeat mean, it's hard to say this, but you have to read the bytecode, run the EVM in order to make sure that you are interacting with reasonable thing. It's hard to say this, but it's something like that currently. And then yes, something like audit market with reputation system or something like that, very gradually may improve the situation. But now due diligence is required for all parties, I believe.
00:17:54.740 - 00:18:19.992, Speaker E: So. I see there as sort of being two pushes that need to happen. One of them is bottom up. The users need to really start demanding that if there are techniques available to ensure the correctness of their contracts, they're either used or a good justification is provided for why they're not used. We certainly have a few tools right now. We've seen presentations today about quite a few of them. So users really need to start being more selective about where they put their money.
00:18:19.992 - 00:18:49.520, Speaker E: And while sure it's tempting to sort of buy into every single ICO and flip it for two X or whatever, that's not the kind of space that sort of incentivizes and fosters rigorous proper software development. And so I think users and investors need to become more selective and developers need to sort of enable them to do that by really going through the processes in a way that's serious and in a way that they put in a concerted effort to get the maximum assurance out of their contracts.
00:18:50.580 - 00:18:51.280, Speaker B: Thanks.
00:18:51.430 - 00:19:27.200, Speaker D: Yeah, kind of echoing what Yuichi said a little bit. No amount of money is a substitute for just understanding. Right. So at some point you just have to read and understand the bytecode and understand how EVM works and understand how solidity compiles to EVM, or whatever tool it is, whatever high level programming language you're using, how it compiles to EVM, and what the implications for security are in that setting. And the people doing security audits, they understand this really well. And like they were saying earlier, they just read the code and read it again and read it again and read it again. There's no substitute for just putting time and effort into high assurance software.
00:19:31.700 - 00:19:56.680, Speaker F: Well, I guess in order to make formal verification popular, I think we need to adopt it first. Right. So I hope that we can have some sort of ERC that allows people to put, maybe orientate tag, hydra tag, or KevM tag into every single smart contract that has been deployed in the Ethereum blockchain.
00:19:58.780 - 00:19:59.530, Speaker B: Thanks.
00:20:01.100 - 00:20:03.640, Speaker A: So anyone from the audience would like to ask some questions.
00:20:03.710 - 00:20:04.330, Speaker B: Yes.
00:20:10.240 - 00:20:14.990, Speaker C: Maybe it's better if people with questions should come to the front.
00:20:15.760 - 00:20:38.756, Speaker G: That's probably a good idea for the next person. So from an auditor standpoint, how would you like to see people who provide smart contract audits either contributing to your projects or using your projects? I assume it's sort of maybe one or the other, but maybe there's both for us right now. Does that make sense?
00:20:38.938 - 00:21:30.528, Speaker E: Yeah, I do do some smart contract audits. And I would say ideally the role of these kinds of tools in the long run would be to sort of put most of that business right now out of business to an extent. Like, at least that's my personal goal with it in all my audits, I always make recommendations to the team about which tools are state of the art and what they should be running on their contracts. Certainly auditors can run these tools on the contracts as well. But at the end of the day, my personal opinion is that it's the responsibility of the team and the team to sort of seek help when they're not able to do something like this. Especially because most teams would not be willing to sort of pay the hourly for an auditor to run secureify on their code or whatever, when they could do the same thing themselves. So I think the role of auditors, to answer your question, is to sort of inform the team about what's available and what they think could be useful for the contract.
00:21:30.528 - 00:21:35.190, Speaker E: And then it's absolutely the team's responsibility to follow up on that and put the time in.
00:21:35.800 - 00:22:08.690, Speaker D: Yeah, often I think the hardest part is just the spin up time. Right. So you have some new tool that you're trying to bring into your tool chain, and then it maybe takes a week or something to get it fully integrated and get it to be seamless. But once you have that spin up time taken care of, then you can kind of begin to make incremental progress. So what I would like to see is people taking the k semantics and making extensions of it. So we have already several extensions. One is a small gas analysis tool that's not very featureful or very complete or sound, it just kind of gives a rough estimate, but it would be nice to kind of tighten the screws on that.
00:22:08.690 - 00:22:36.010, Speaker D: And then there's another tool called EVM prime, which is just a small extension of the EVM semantics to a higher level language, and if people wanted to hack on that, that would be really cool. I'm answering specifically for KVM because that's the project I'm working on, but there's all sorts of other analysis tools you can write directly in K itself as an extension of language, and the hard part is the spin up time on K, of course, but there's no avoiding that with a project like that.
00:22:36.460 - 00:22:44.940, Speaker E: Yeah, just to butt in just for 1 second. It would be really nice also if these auditors and these teams sort of complained a lot more about the tools.
00:22:48.980 - 00:23:20.970, Speaker H: So so far most of the research focused around either Tolkien or Crowdsell, which are relatively smaller size, and also it's quite similar. But as more companies start delivering the product, which they promise to do based on the funding, that size is going to be a lot bigger and the product will be quite diverse. What would be the challenge when it comes to verifying these actual product, rather than talking in the ground sales.
00:23:22.700 - 00:23:23.160, Speaker B: Please.
00:23:23.230 - 00:23:25.070, Speaker A: Quick answer, because we need to.
00:23:29.280 - 00:23:40.700, Speaker E: Sorry. The question was what are the challenges for these teams that are using these tools? Mostly it's better without the mic actually. I think when it comes to verifying.
00:23:40.780 - 00:23:53.924, Speaker H: Just token or crowd sales because most of research industry is more heavy. But now once people start putting more real products, they are bigger and they are not alike. So I just wonder.
00:23:54.122 - 00:24:27.010, Speaker E: Yeah, that's a great question. So the question was about most of the verification right now is tokens or crowd sales because that's sort of what everyone's doing and it's all the same. But what about when we get more complicated contracts? I personally think people are always going to sort of push the envelope and do things that are more complicated than we actually can verify. And I think that's really cool to sort of feedback in. But the more complicated, the more experimental your contract is, the more time you're going to have to take, and the more you're going to have to consult experts who really know how to write new specifications and not just reuse those same old building blocks in the old ones.
00:24:27.780 - 00:25:18.700, Speaker C: I think auditing or finding bugs in the contract is a bad game to play because you have to beat the best attackers in the world. So going forward, if you try one more complicated stuff, you will need much stronger, usable tools. Otherwise the game is not fair. You have to find all faults. And a very good attacker should find only one fault, critical vulnerability. So it's a very skewed game. So maybe a good tooling or maybe a good game like Hydra is necessary.
00:25:18.700 - 00:25:23.740, Speaker C: But I think we are kind of ready to take the challenge.
00:25:24.960 - 00:25:25.420, Speaker B: Great.
00:25:25.490 - 00:25:36.610, Speaker A: Thanks very much. That concludes the panel. Like to thank all the panelists. It's a huge honor to share the stage with some of the best researchers in the field. Thanks very much.
