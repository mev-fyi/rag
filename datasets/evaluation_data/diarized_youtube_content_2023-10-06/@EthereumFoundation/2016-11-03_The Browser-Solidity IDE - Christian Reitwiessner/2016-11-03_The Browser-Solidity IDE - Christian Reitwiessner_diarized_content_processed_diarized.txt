00:00:01.850 - 00:01:47.790, Speaker A: This is a thing we call browser solidity, and it's a fully functional IDE which does not require you to install anything. It runs directly from the browser. It is even able to run an offline context, so it does not have to load stuff from the Internet. And you can find it at the following URL. That's actually not the URL, that's the offline version I saved. Okay, it's divided into two parts. On the left side you see the editor with multiple tabs, and on the right side you see the currently loaded compiler which is 00:44 using this drop down you can change it to an older compiler version.
00:01:47.790 - 00:02:26.982, Speaker A: This goes back? Yes. So for zero one one, we don't even have a date. It's a bit confusing because that is not the active version. If you want to see the current version, you have to look here. And if autocompile is clicked here, then it automatically compiles with every keystroke. Basically if you disable that, then you can click the button to compile and the compilation result here is an entry for each contract. You get information about the bytecode.
00:02:26.982 - 00:03:10.700, Speaker A: You can copy that. That's the JSON API interface that you can use that if you want to interface with your contract using web3 js. And then here's a JavaScript snippet you can paste into the Go Ethereum console to deploy the contract. And that's another snippet that is useful in other contexts. You can even get a lot more details by clicking this button here. It gives you a list of functions and their signatures, or their identifiers, the hashes of their signatures. What is very important is you also get gas estimations here.
00:03:10.700 - 00:04:00.600, Speaker A: So creation costs 57 gas plus 30,601 of them is the gas required to run the constructor function. And the other one is the gas required to deploy the code. Yes, and then gas estimates for all the functions. These are upper bounds, which means that they are not always accurate. And especially if you put a loop inside a function or something which is a bit more complex, then you will get infinity as an upper bound. Another thing I have to say here is that these gas estimates do not reflect the recent hard fork gas changes. So we still have to update those.
00:04:00.600 - 00:04:42.626, Speaker A: Yeah, and then runtime bytecode is the bytecode that will be deployed in the blockchain. Then the full code is a list of opcodes and the full code as assembly, which is sometimes also quite useful, especially because you have the on the right hand side, on the left hand side there's always the instructions. And on the right hand side you see the part of the source this instruction was generated from. K, let's untuckle the details.
00:04:42.818 - 00:04:43.126, Speaker B: Yeah.
00:04:43.148 - 00:05:20.814, Speaker A: And then also very important, below the compilation results you have a list of errors and warnings. If I put garbage inside here, then I will get a compiler error. And we should actually respect that warning. It says we do not specify the version of the compiler required. Let's add that here. Now it's so there's no warning. You should always try to create source code without warning, because most of the warning.
00:05:20.814 - 00:06:30.474, Speaker A: So we try to generate as few warnings as possible. And if there is a warning, then it's usually quite severe. And any warning that is generated by the compiler can be silenced by some way. So as an example, if you use the send function, but it just sends one way to the address zero, and there will be a warning that we ignore the return value of this function. And if you really know, yes, I really want to ignore the return value, then you could do something like this. And then the warning silence. Okay, that was the compiler part of the ide, but that's only one tiny aspect of it.
00:06:30.474 - 00:07:34.954, Speaker A: And much more interesting is the kind of the blockchain simulator that is part of the IDE. And you can click this red create button to create the contract which does not work. Now let's see it. Let's try an older compiler. It, as I said. Yeah, that looks better. This creates the contract at this address in memory, which means it's just a simulated blockchain.
00:07:34.954 - 00:08:29.854, Speaker A: And you have buttons for all the functions in the contract, functions that are constant, which means that do not have side effects are evaluated immediately and you get the result here. So that's the value of the x variable. You get statistics about the actual transaction cost of this specific invocation and not the upper bound and a decoded result. And then you can invoke functions that make changes the state. Okay, so I called f with 34. The result is the empty string, which is fine because it doesn't return anything. And yeah, we have the guess codes here again.
00:08:29.854 - 00:09:47.154, Speaker A: And now we can click the x button again to check the updated value and it correctly results in 34. Okay, one thing to consider or to remember is that the input boxes here always require proper Json, which means if you have a large number here, then this won't work. But what you can do is you can basically hex encode them, for example, and then it will work and you have to put quotes around it. So this is basically, the stuff you enter here is directly forwarded into the web3 js encoder. Okay, what else do we have? There are some tabs here which I want to explain quickly. Here you can change the transaction origin. If you want to test a contract that has to be invoked from different addresses, then you get five preset addresses.
00:09:47.154 - 00:10:35.080, Speaker A: Here you can modify the gas limit and you can send ether together with a function call. So if you set it here, then it will be valid until you change it again. And you can also use browser solidity to interface with other blockchains than the simulated. And that's done using the third tab here. If you load browser solidity from within mist, for example, then you can click on injected web3 and you get the web3 js that is available inside mist. So you directly interface with the attached node. Or you can use web3 provider, which means that it tries to connect to this address using JSON RPC and it doesn't work because I don't have a node running here.
00:10:35.080 - 00:11:38.890, Speaker A: Oh yeah, one important thing here, if you load the website from htps over SSL from GitHub, then this doesn't work because browsers do not allow non encrypted requests from encrypted websites. So you have to load it from non Ssl GitHub. Okay. Then on this tab you can publish the source code you have here on GitHub, or you can copy it over to another instance of the IDE. And on this tab you get an interface to the debugger which Jan will talk about later. And we have another tab which allows formal verification of contracts. Yuichi will give a talk about formal verification, but it will be about bytecode level formal verification, whereas this module here is used for source code level verification.
00:11:38.890 - 00:11:57.790, Speaker A: And then a question mark here takes you to the solidity documentation. Okay, that's all I wanted to talk about, the IDE. If there are any short questions, I can take them. Otherwise I think Jan could show the debugger.
00:11:58.770 - 00:12:03.730, Speaker B: Not a question, just a compliment, because I've been using that a lot in the last two, three months and it's really great.
00:12:03.880 - 00:12:37.900, Speaker A: Thank you. I think last week or two weeks ago we added actual browser unit testing purple request, which will result in this website breaking much less. So it's quite complicated to do browser testing because it has to load the compiler, which is an 80 megabyte file. Unusual. So these hosted services for testing can't really cope with that. Okay.
