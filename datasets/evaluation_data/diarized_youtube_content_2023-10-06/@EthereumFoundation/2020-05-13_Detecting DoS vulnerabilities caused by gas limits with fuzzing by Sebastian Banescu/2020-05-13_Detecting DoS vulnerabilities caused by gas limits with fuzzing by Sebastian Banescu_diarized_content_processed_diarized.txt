00:00:04.360 - 00:01:20.336, Speaker A: So hello everyone, my name is Sebastian, and today I'm going to be presenting this topic about detecting denial of service vulnerabilities caused by gas limits using fuzzing and other techniques. But we're not just going to stop at detecting, we're also going to be looking into how to generate exploits and fixes for these vulnerabilities. This is joint work together with Professor Vijay Ganesh from the University of Waterloo, as well as the group of his PhD students working on smart contract security. So probably most of you already know this, but I created the presentation for general public, so not assuming that everyone knows about smart contracts, they're just programs executed on a virtual machine. The Ethereum virtual machine and calling a function in the smart contract changes the state of the EVM, and these state changes often involve transfers of funds and so on. Programs, of course, might contain bugs, any type of program. So therefore smart contracts also contain probably bugs.
00:01:20.336 - 00:02:13.060, Speaker A: And exploiting these bugs in smart contract can lead to stolen or frozen funds, as we've seen many times in the past. On the other hand, there's the notion of gas. The EVM has this gas mechanism which charges the function caller. So the transaction senders and execution fee, which is computed using gas price times gas consumed. And there is a block gas limit for each block that is mined, and the gas consumed by any function call in a transaction cannot surpass this block gas limit. If it does, the transaction is reverted. And this is meant to prevent resource abuse and denial of service attacks on the Ethereum network.
00:02:13.060 - 00:03:46.016, Speaker A: However, it can cause denial of service attacks at the smart contract level by not allowing a user to call the function and fully execute it. So this could lead to frozen funds, and frozen funds are basically lost funds. Here's a toy example, and this is something which you could naively implement if you're not familiar with solidity or gas issues in Ethereum. Basically you want to reward all the users of a CErtain bank, let's say, and you want to push out interest payments every month or every year. And to do that, you basically iterate over all users, and you do some computation based on how much balance or how much deposit they have and how much time they have kept their deposit there, and you basically send them this interest. Now, you notice that this users length is controlled or influenced by users joining this bank, right? So the more users you have, the more iterations this for Loop is going to have. And if it gets out of like, if it at some point passes the block gas limit, it's going to cause the transaction to revert.
00:03:46.016 - 00:04:22.160, Speaker A: And if there's no other way to push out interests, it basically is going to lead to a lot of unhappy users of this bank and other problems. So that's the basic idea. More famous example. Are you still with me?
00:04:22.690 - 00:04:24.240, Speaker B: Oh, you broke up.
00:04:25.090 - 00:04:25.598, Speaker A: Okay.
00:04:25.684 - 00:04:29.874, Speaker B: And you seem to be frozen, so I can still see your screen.
00:04:30.072 - 00:04:32.980, Speaker A: Okay, where did you lose me?
00:04:35.430 - 00:04:43.720, Speaker B: Yes, exactly. Now I can see the screen again. Perfect. Okay, so, yeah, that was the slide. And you said a more famous example.
00:04:44.570 - 00:05:56.400, Speaker A: Okay, so more famous example is this project called governmental, and it's from 2016, and they suffered for some time due to this kind of Blockcast limit. So there was a denial of service for the payout of the jackpot, which was 1100 e, because the payout mechanism was using too much gas. And as part of this payout mechanism, the contract was clearing internal storage using these instructions. And this was compiling to something that iterates over storage locations and deletes them one by one. And because the list was too long, it reached the block s limit at that point in time, and that led to frozen funds. So this is the source where I took this information from this Reddit post. And of course, like, back in 2016, the block S limit was quite lower than it is today, so it was under 5 million, and today it's 10 million.
00:05:56.400 - 00:06:57.126, Speaker A: As we see, it keeps evolving, it keeps growing. With some exceptions, most of the time, the block gas limit is increased at a certain hard fork. And the motivation for this work that we're doing and trying to detect and exploit this automatically is because there's simply too many accounts and also smart contracts on the ethereum network to try to do this manually and find this out. So basically, during our audits, even today, we're seeing a lot of gas usage issues in the smart contracts. And using state of the art tools like slither or MyFril, you can detect these issues. It's pretty easy to detect. You basically look for loops and some computations or function calls in those loops.
00:06:57.126 - 00:08:35.230, Speaker A: And there's many tools freely available that find this issue. However, what do you do once you detect them? Right, one thing you can do is try to remove the loops and redesign your code such that you completely avoid loops. And you just try to accumulate values, as other functions are called. However, if that's not an option, you can just maybe do a gas analysis, determine when exactly the error, the out of gas error occurs, and you can add something like a required statement or an assert statement to basically prevent the revert from happening and prevent the waste of gas. And this is currently a manual, potentially lengthy and tedious process. So the solution which we propose in this work is to automatically generate these kind of denial of service exploits that lead to out of gas at smart contract level, there's several challenges. The first one is like how do you determine the exact gas usage during execution? Second one is how do you search through the large search space of possible inputs to functions? There could be functions that have several parameters, or even like there could be multiple functions that need to be called in order to reach a state where this kind of dos or out of gas error is reached.
00:08:35.230 - 00:09:23.710, Speaker A: So the first challenge is actually easy to solve due to web three and solidity features. In our approach, we use the gas left function from solidity and we basically simulate everything on top of the Ganachi network. I mean the Ganachi tool. And the second challenge is more, I'm going to talk more about that one. So fuzzing a large number of inputs is more tricky. There's several possible fuzzing heuristics. For instance, you can brute force every possible input, and that's very slow.
00:09:23.710 - 00:10:16.990, Speaker A: You can do a divide and conquer approach, which is faster, but it's not always applicable if you don't have certain rules like integer intervals and so on, that you can easily divide into partitions. Basically, for our approach we're using reinforcement learning, which is also fast and is more generally applicable. And we'll see in a second why there's also possible, other possible heuristics. Not saying this is the best one, but this is the one we chose for our project. So the reinforcement learning approach looks like this. We basically model the problem as a markup decision process where we say that the set of states s is all of the states of the EVM. Basically a state is a state of the EVM.
00:10:16.990 - 00:11:28.610, Speaker A: The possible set of actions is calling smart contract function with some randomly chosen inputs, or also more carefully chosen inputs, increasing those inputs, decreasing them, and so on. So these are like the actions that the agents, the reinforcement learning agent can take. The probability of transitioning from one state to another when basically, when executing a given action is always 100% because the EVM is deterministic. And the interesting part is the reward function. Basically, the reward that the agent gets when he transitions to a state s is one minus the division between the gas left and the block gas limit. And this is because we're rewarding actions that are going to consume more gas. So if the transaction that led to the state s used more gas, we're going to give a higher reward because we want to reach an out of gas error.
00:11:28.610 - 00:12:33.740, Speaker A: So this is pretty intuitive. Here's a simple example of a pure function that just receives value as input, an integral value as an input, and iterates over all integral values from zero to that number, sums them up and returns the sum. The goal of the reinforcement learning agent would be here to find the right value for n, which leads to this kind of out of gas error. And we're going to see later how this code is fixed. Another example is maybe a slightly different function, still pure function that has two parameters. You can even think about more parameters, but basically you do some computations with these parameters and they don't always influence the result or like the gas usage in the same way. So here you can see that we're dividing n by m.
00:12:33.740 - 00:13:20.346, Speaker A: So the goal of the reinforcement learning agent is to find a large value for n and a small value for m. But m should not be zero because otherwise it leads to a division by zero. And what are the right values for this? Or maybe something else we're going to see later. What's the right way to fix this? Here's another example where there's a small contract that is vulnerable. It has several entries, integral entries in them in it, and it has several functions. And the first function just adds an entry in the list. I saw typo there.
00:13:20.346 - 00:14:22.718, Speaker A: The second function gets the entry at a certain location. And the third function sums up the list of entries, basically returning the sum. So here you can see that the goal is to find a trace of function calls like this, basically adding several entries up to n and summing them up. And the question is, what's the value of n such that when you call some entries, it leads to an out of gas error. So the challenge is how to determine. First you need to determine which functions affect basically the loop bounds because as we saw before, there was also a function called getentry. And the reinforcement agent should not be calling that.
00:14:22.718 - 00:15:54.010, Speaker A: It would be just wasting sort of time calling that one because it's not going to affect the loop bounds inside of some entries. And the solution to detect which functions affect the loop bounds that we are taking is to do reverse taint analysis and then forward taint analysis. So for those of you who are not familiar, taint analysis is a form of information flow analysis where you first taint or tag a memory location, for example a variable x. Then you trace the flow of that tainted value through the execution of your smart contract functions and you determine which instructions or which other memory values are affected by that tainted part. The information flow may be explicit where you have a direct assignment memory transfer, and it could also be implicit where different values in memory depend indirectly on your tainted value. For instance, if you have a branch condition like this, if x greater than zero, and inside of the if and else branches, you have other values like other variables like a and b, those variables will be implicitly tainted by x. So then we do the reverse taint analysis on that function.
00:15:54.010 - 00:16:08.400, Speaker A: We slightly modified the function some entries to also include an implicit taint example here. Can you still hear me?
00:16:09.270 - 00:16:12.066, Speaker B: You were breaking up, but now you're back.
00:16:12.248 - 00:17:11.538, Speaker A: Okay, so here we modified some entries function a bit in order to show that. Can you still hear me? Okay, to show that there is a possibility of an implicit taint, we start from the loop at the close to the bottom and we taint the bound variable. And we go up, we go in the reverse and we see that first the variable n is tainted by bound because there's an explicit assignment. And also the length of the entries list is also tainted explicitly. And we also have an implicit tainting of those variables, but since they're already explicitly tainted, then basically they're tainted. We also have a taint of the constant zero. So that instruction is also tainted where bound is assigned a zero value.
00:17:11.538 - 00:18:20.250, Speaker A: And based on this analysis, we can say that, okay, the input of the function sum entries is tainted and also the state variable entries is tainted. That is, the length of this state variable is tainted. So once we determine this, we can do a forward taint analysis where we just taint the entries length and we start executing each function to see which instructions in which function may affect the entries length. And we see that only the add entry function affects the length of the entries list. The get entries functions does not. Therefore, the reinforcement learning agent can just try to call this function before it tries to see if it ran out of gas using that sum entries function, which is not shown here due to lack of space. So the question here towards the end is like, okay, we took this approach, we did all this stuff.
00:18:20.250 - 00:19:32.260, Speaker A: We ran the reinforcement learning agent. So what do we do once we know where the out of gas error occurs? I already hinted towards the answer. We basically fix the code and fixing could look something like this. If removing the loop is not an option, you could have a require statement close to the beginning of the code, which basically signals that the parameter or the parameters that you provided will lead to an out of gas error. The second example which I showed you could also go for fixing actually after you've done all the computations, you can add this require statement, which is easier than checking values for different inputs. And the third example is also interesting because we're not placing the require statement inside of the function which has the loop, like not inside of some entries, but we're placing it inside of the function that affects the length of the loop. So inside of the add entry function.
00:19:32.260 - 00:20:45.900, Speaker A: And of course these values are just like preliminary values. They're just mocks. You can also not just hard code the values in there, but you can also let it be settable by the contract owner, such that if there's a fork or the gas limit is increased, they can adapt this. Or if the cost of the opcodes changes, these values can be changed as well. In conclusion, just want to say that probably know loops cause out of gas errors in smart contracts, and these can lead to frozen and hence lost funds. Detecting such problems is quite easy with state of the art tools, however, determining exactly when they would occur with which inputs is harder. And we're taking the approach of fuzzing with reinforcement learning and taint analysis to generate the inputs needed for an out of gas error faster and in a more general way.
00:20:45.900 - 00:20:56.700, Speaker A: And yeah, we're using taint analysis to guide fuzzing. That's it from my side. Thank you very much. Any questions?
00:20:57.870 - 00:21:27.080, Speaker B: Thank you so much. Yeah. So now, first to the people in the room, if you have any questions for Sebastian, use the raise your hand feature so that I can see that you would like to ask something. And to the people in the live stream, we know you're lagging behind, so we will wait for you for 1 minute and you can put your question in the GitHub chat. Yes, Jocelyn.
00:21:28.860 - 00:21:30.808, Speaker C: Hi, Sylvester. Nice talk.
00:21:30.974 - 00:21:32.170, Speaker A: Hi. Thank you.
00:21:32.860 - 00:21:34.410, Speaker C: What tool are you?
00:21:38.380 - 00:21:41.916, Speaker A: This? You mean for reinforcement learning or which part?
00:21:42.018 - 00:21:43.420, Speaker C: For the wall approach?
00:21:46.400 - 00:21:48.830, Speaker A: We're building a custom tool for this.
00:21:49.840 - 00:21:52.030, Speaker C: It's everything built into us.
00:21:52.960 - 00:22:04.610, Speaker A: Well, it's going to be published, but it's basically the joint effort between the university and Quantstamp, and we're going to release the the code once the paper is accepted. Okay.
