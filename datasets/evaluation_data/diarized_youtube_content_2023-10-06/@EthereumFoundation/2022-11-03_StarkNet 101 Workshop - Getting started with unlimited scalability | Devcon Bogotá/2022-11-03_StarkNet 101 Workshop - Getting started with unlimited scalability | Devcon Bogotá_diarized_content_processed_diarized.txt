00:00:12.810 - 00:00:45.290, Speaker A: Audience. So no problem. We're going to be talking in English and if you don't understand anything on the slides, please let me know. No problem, but just focus on me. So on the layer one, we had amazing applications. We got a lot of applications, very interesting. For example, amms that could let you transact with different tokens, but these were very expensive, right? We also had oracles that allow us to introduce data off chain into on chain, right? But it was also very expensive.
00:00:45.290 - 00:01:20.818, Speaker A: Moving data on chain is expensive. We also had gaming where you can have nfts, very cute nfts. You can have your sword for your game, your gun and so on. You can maybe move it to another game. But still the game was directed by a single entity that had the control over the game. So the game logistics, the game logic was not on chain, it was not auto regulated. Yes, because this is very expensive, right? Also we have voting apps, but also, again, writing in the storage, writing to the blockchain is very expensive.
00:01:20.818 - 00:02:19.990, Speaker A: So voting was also really expensive on layer one. So this is very interesting application that we have in the layer one bot that introduces problems when we are talking about cost. So we know the state, the current state of things is either we have a huge machine that is processing everything, we know this, for example, banks, core APIs, companies, startups and so on, very huge machines, they can process a lot of transactions very quickly. And now we're looking at the blue part, where we are trying to create a decentralized system, which is when a lot of persons can verify the integrity of the system, right? This is what we're trying to do. The problem is that this is very slow and this is very expensive, and the computation repeaters itself various times at different points, so it's not optimal for scalability. Of course, this was a choice when we decided to create Ethereum, we wanted decentralization, we wanted security. It was a choice to sacrifice at that moment, scalability.
00:02:19.990 - 00:03:00.070, Speaker A: But now we know better and we can do better stuff. So the question is, can we get decentralization, security and also scaling? Yes, we can do with zero knowledge rollups. And we are here today to talk about Starnet. So we're talking about a platform, a L2, that is secure by Ethereum. It allows you to create smart contracts, general smart contracts. It's touring complete, the cost of execution is much lower, and you can create amazing things that are not possible, even imaginable in the layer one. So we can get much more for each piece of gas.
00:03:00.070 - 00:03:50.580, Speaker A: So this is a quote from eleven Sasson our founder at Banglas in the 29 July, he's talking about the objective of Starnet, which is creating a solution for scaling that is focused only on scaling Ethereum and this is called Cairo. So at Star wars there are experts on both the Ethereum virtual machine and also in creating stark systems. And there was a conscious choice not to use the EVM to scale. We created a new virtual machine called Cairo. This was a conscious choice because we believe this is the way to achieve the biggest scaling. And this scaling is going to come from smart contracts written in Cairo. In Cairo is a virtual machine, but also a language we have.
00:03:50.580 - 00:04:51.458, Speaker A: So what is Cairo? Cairo is a true incomplete language programming language that allows you to create probable programs, in this case in Spanish, paramas and most travelers. You can execute your Cairo program and then you can prove a smart contract on the layer one on Ethereum that this transaction was correct. This allows us to have much more, much cheaper transactions cost. And because when the smart contract on the layer one validates that this proof is correct, it's much cheaper than running the transaction itself. So this allows us to create, to get much more scalable solutions using the L2, in this case with Chiron, Starnet. So this is our solution, the zero knowledge roll ups, specifically talking about Cairo and Starnet. You can get extremely cheap computation thanks to Cairo.
00:04:51.458 - 00:05:30.350, Speaker A: And we can create, and this is key, we can create interesting applications that could only be made using the L2. It's impossible, practically impossible to do on the layer one. This is an interesting data that we got during the last week. Starkx blocks Starnet. So Star wars, the company has different solutions. One of them is Starkx and the other one is Starnet that we're talking about right now. And both together had more transactions since July than bitcoin lining and other L2s.
00:05:30.350 - 00:06:18.046, Speaker A: This is something that is not very well known, but as you can see coming from July, the blue line is the Stargx plus starnet. Down is bitcoin in orange and under that are other L2 solutions. So as you can see Stark is an externet is currently being very very used and we have been live in Mainet since June, yes June 2020. So we are not new at this, we know how to do it. The star solutions is very good and as you can see it's been very used and very interestingly also is that 70% of that comes from nfts. It's very interesting, for example with immutable, with sorare, interesting. So now, thank you very much for coming.
00:06:18.046 - 00:06:42.706, Speaker A: Now we know, that stunt has a lot of potential. You can create needs whenever you want. You can deploy it currently and actually today we'll be creating a boating application that we're going to be trying on Starnet. You can use it. Cairo is a different language, we know it, but it's also a language that everybody can use. It's not hard at all. So my name is Omar Spehel.
00:06:42.706 - 00:07:21.734, Speaker A: I'm a developer advocate at Star wars and thank you very much for coming today. The goal of today is for you to get the resources to start studying Cairo if you want to go into Starnet and also make a small example of a boring application. So now we talk a little bit about what is being done in layer one that is very costly and we can improve. Now let's talk about what can we do with all this power that cheap computation can provide us. For example, we have a solution called Ckex. It's a company that is offering high frequency trading. This of course is impossible in the layer one.
00:07:21.734 - 00:07:55.870, Speaker A: Imagine having micro positions and trading with them. I don't know, it would be impossible because of the cost in the layer one makes no sense. We talked before about voting. Voting is very expensive too. So there are also solutions, for example Snapshot X, that allow us to vote much more cheaply. Yes, so there are a lot of applications that have been already developed since I started that using all this power. Another one for example is the government of Buenos Aires created an application that allow you to have an identity on the blockchain as a user, as a citizen.
00:07:55.870 - 00:08:44.400, Speaker A: They chose starnet because it's very secure, it's highly, highly secure and also it's very scalable and very quick. So these are only some examples, but ecosystem is growing by the day. For example, we have tools, amazing tooling, for example, coming from hardhead, Opensepalim, Chainlink, soon Alchemy. Those are well known companies. But we also, and maybe more interesting, we have different applications on the top, as you can see, that are being created originally on the L2. So this is very interesting because, and this is my opinion, it's not for the company overall, but it is interesting when a company comes from layer one and then puts its applications in L2, it's great. They are using the lower fees and that kind of stuff.
00:08:44.400 - 00:09:43.218, Speaker A: However, I believe that the real power is being used by those that are created natively on Cairo in the L2. Yes, it's a little bit like for example, when you have windows in your computer, Windows 98 for example, and you get these nice acute games and then comes for example Windows XP, it's more powerful, you can do much more stuff and these games can be passed into XP. Okay, so these old games can be passed into the new software and they run well, it's okay, they maybe could leverage some of the power of the new operating system, but the real power comes from that, that is being built on top of XP. That could not be done in the previous operating system. Right, that's what we're talking about here, something that is completely different and out of the leak of the layer one, we can create something very very interesting that is impossible to create. For example, we were talking about the games that they didn't have the logic on chain. This is now possible.
00:09:43.218 - 00:09:59.010, Speaker A: So imagine that you can do operations, summations, multiplications, divisions, whatever, you can do that because the gas is much much cheaper. So a company, I don't remember, I know the number. What is the name of the project that was creating this on chain reality?
00:09:59.170 - 00:09:59.906, Speaker B: Topology.
00:10:00.018 - 00:10:43.158, Speaker A: Topology. So topology created a game on chain and it's auto regulated. Okay? So you don't need a central entity to decide if you are allowed to play it or not. So it will stay forever as long as ethereum exists. This is something that is again impossible, layer one. And for me the power is going to come from that part. So now the question is, what can you create that is completely different from what has been created in the layer one using all these new power, all this new potential that you can find in the L2 that is completely different, never done before.
00:10:43.158 - 00:11:24.270, Speaker A: Imagine you can do for example machine learning on chain, you can train models on chain, you can create any kind of mathematical operations on chain. It's completely different. And what we need is people that start building these applications that are eye opening. So for the beginning you will need to start installing Cairo starnet. Of course I don't expect you to do it right now, but you can follow these QR codes for some instructions on how to install Cairo and Starnet so you can get going. It's not difficult at all. And while you scanned it, we also have a report that is called starnet.edu
00:11:24.270 - 00:11:58.270, Speaker A: where you can find a lot of educational material. I will show you the link in a couple moments. And inside started.edu. You can find a lot of tutorials on different stuff. For example, you can know how the Kyle syntax look. We're going to look at it in a moment. You can for example create a token, an ERC 20, you can create your NFT ERC 721 tutorials even more interesting how you can create your own bridge from layer one and L2, a trustless bridge.
00:11:58.270 - 00:12:53.830, Speaker A: And for example, how can you create your own wallets? So if you can scan this QR code, you will find all that material inside and you can get going by yourself without any problem. Those tutorials are amazing and they have onboarded a lot of people into the ecosystem. Also, we have a newsletter that is very nice, and you will have a lot of educational material there too. And also some interesting projects happening on the ecosystem. It's also there you can subscribe. It's a substac newsletter. And finally, what we're going to be doing today is a bolting application that will allow a person to either vote for one or zero, one for yes, for example, zero for no, and deploy it on the testnets.
00:12:53.830 - 00:13:18.830, Speaker A: If you have any question until now, you can tell me, this is the repo that we're going to be using. So if you want to have the repo, you want to clone it, you want to copy the code or just look at it. Feel free to scan these QR codes. Any questions, comments while we start with the coding part? No?
00:13:18.920 - 00:13:21.158, Speaker C: Okay, I have a question, actually.
00:13:21.244 - 00:13:30.282, Speaker B: How many of you know how to code in solidity? Can you raise your hand? How many of you have ever coded in Cairo? A few of you.
00:13:30.336 - 00:14:08.832, Speaker A: Cool. Coming from solidity into Cairo is very, really simple and it's great that you're already working with solidity. Perfect. You want to go to the testnet and see already and interact with this contract. Feel free also to scan this QR code. Is the testnet already working with these bolting contracts? I deployed a couple of minutes ago. So in this table is the Star wars team.
00:14:08.832 - 00:14:57.722, Speaker A: We have some swag in here if you want to come also, and I don't know, guys, do you want to add something else before we start coding? Perfect. Okay. Do you need another QR code? Do you have already the one with the contract where we're going to use is this one, remember, please. So let's go to the code. So this is our boat inning contract. Again, the goal is to create a contract that allow certain predefined addresses. For example, me as the admin of the boat, I can tell.
00:14:57.722 - 00:15:22.680, Speaker A: Okay, this address can vote. This other address can vote. This address can vote because we don't want everybody to be able to vote. Only certain participants of a project, I don't know. And they will be able to vote yes or no? Yes with one, no with zero, and yes. That will be all. So for this, let's review the structure and how Cairo looks.
00:15:22.680 - 00:16:06.882, Speaker A: This. Here we are importing our packages, very similar to how it looks in Python as you can see it. Then we define structs as you would for example in rust. First we're creating a boat counting struct where you will be able to store the boats with yes or no. So for example, we will have ten boats with yes, zero boats with no, something like that, the counting of the boat. Secondly, we have boulder info where we store information about the border. In this case, I only very simply allowed, I simply added an allowed member that it will have a one if it's allowed to vote, or zero if not.
00:16:06.882 - 00:16:41.642, Speaker A: If this person has already voted, it will have a zero. Now, coming to the storage, the storage variables allow you, if you know solidity already, these are very similar to you. They allow you to map from one expression to the other. In this case, for example, the first one. Now let's go to the third one. Here I am able to map an address to is register variable. That in this case is a felt.
00:16:41.642 - 00:17:26.526, Speaker A: So Cairo is type, it's a type language. Now you might ask yourself, what is a felt? Felt is beneath Cairo, everything is a felt. Inside Cairo converts into felt. And basically for our purpose right now, if you want, we can get a little bit deeper in a moment, but for now, in order to make the most of the time, a felt is like a big interior number, a huge interior number. Okay, so in this case, as you can see, the address has not an address type as in solidity, it's a felt. So we're mapping an address that is a felt to a felt called is register that will have a one or zero or wherever. We haven't defined it yet.
00:17:26.526 - 00:18:05.610, Speaker A: And on the other ones we are mapping other information. And interestingly, in the first one we are mapping nothing, yes, nothing to a structure about counting. So this allow us to read or write into the memory. That's as simple as that. I can read this or I can write into the memory using these ones. So using the storage variable, both in status if we read it, and if I will go right now to the deploy contract. So this is the deploy contract I'm using right now, Boyanger, which is a block explorer for Starnet.
00:18:05.610 - 00:18:47.622, Speaker A: If I go to the read part of the contract, I can see what voting status is doing using a getter function that we will see in a moment. We can see the status of the voting right now because nobody has voted yet. We have zero vote with yes, zero votes with no. We are reading right now this storage variable with a getter function that we will get to that in a moment, and also we have the boring info and it's the same. I won't go into this, but basically we're storing information into the storage of the blockchain. Now let's go to the constructor. Looks very similar.
00:18:47.622 - 00:19:40.066, Speaker A: You know, when you initialize your contract, when you deploy it, you have to define certain inputs, as in solidity, exactly the same name. So this constructor will ask for three different input variables, as you can see. Now we can view how a function looks into Cairo. It's very simple, very similar also to python. And what is important here is this part. These are the inputs, the explicit inputs to this function, in this case the inputs for the constructor that we have to provide it when we deploy this contract. So I'm asking for an admin address, the person that's going to be able to manage this contract with a felt again, then the number of addresses that will be able to vote, and finally the disappointer.
00:19:40.066 - 00:20:40.430, Speaker A: So it's important to know that Cairo is a low level language. So here we can manage the memory, we have to manage it. So the register addresses is basically a vector with the different addresses that are able to vote. I can add 5678 whatever, and this pointer felt points to the start of that vector, but you won't even notice that the logic behind it is that this is pointing to the start of this array of different addresses. But you won't notice that, as you will see then we're basically using a contract because we have opensepling on top also of starnet, so you are able to use very secure contracts thanks to OpenSeplin. And here we're using the ownable contract from Openseplin before I imported them here. So I imported the ownable contract and the possible contract libraries from Openseplin.
00:20:40.430 - 00:21:10.020, Speaker A: Ownable basically defines who the owner is of something and possible. It allows you to post a contract in case of an emergency. Say that for example, my application is being hacked, so I can post it. As simple as that. But also we have ERC 721 logics and ERC 20, so you can use it with open seplum. That's very useful. Any question? Until now we have seen the constructor, we have seen the storage variables, structs, how to import.
00:21:10.020 - 00:22:19.770, Speaker A: How are you finding Cairo? Too difficult or is it nice? Any questions? Yes, hello, you. Sorry, what was the question? Yes, for example, you have in this case we will be using addresses that are in an exadecimal format, right. It will simply be converted to a field behind it. We will actually deploy right now our contract using hexadecimal values, and you won't have to convert it to a felt, but you also could compare it to a felt and also deploy with that, no problem. Right now we can think of it like big integers and we can get deeper into that. Any other question? Right now we have seen constructors, storage variables, structs well, perfect. Okay, so we have our constructor and with this we can deploy our contract.
00:22:19.770 - 00:22:42.260, Speaker A: Also, as you can see, the structure of the contract is very similar to solidity. We're trying to follow the guidelines of smart contract and solidity. You have getters, you have the constructor, and the format is very similar. Also you go to this contract, it's very well commented, so you can know what is happening.
00:22:42.790 - 00:22:48.802, Speaker B: So it doesn't have inheritance, we give.
00:22:48.856 - 00:23:06.170, Speaker A: The owner book contract explicitly the admin asset, which is not like. So the question is if we have inheritance in Cairo, I think you guys can.
00:23:06.320 - 00:23:45.510, Speaker B: Sure, so there's no inheritance in Cairo, you don't inherit your contract. What you do is you import your function. So if you're looking at the top of the contract up there, here he's importing a template developed by Openzappen. So he's importing the full contract, which is called honeybolt. So it means that he imports all the functions that are inside of this contract. And inside of this contract it creates a few variables that can be initialized, and one of them is called the initializer, which is supposed to be called during this constructor. Does that make sense? Yeah, I was just curious because usually.
00:23:45.580 - 00:24:32.598, Speaker C: That'S so it's not automatically initialized because the contract is not ownable. It imports some function and it has no way to know that this is the specific context of the constructor. So you need to initialize it explicitly. Regarding the question on felt earlier, I'm not sure what confuses you, but when you're looking at variables in solidity, at the bottom of it, at the end of the day it's a number. And Cairo is a fairly new language. It will get better in the next few months, but right now it treats everything as a number. So if you want to perform actions when you need strings, you basically need to assume that you receive them as numbers, you convert them, you do your operations, and you do all this kind of stuff.
00:24:32.598 - 00:24:35.160, Speaker C: Makes sense sort of.
00:24:38.570 - 00:24:40.550, Speaker B: When you do operations on felt.
00:24:44.010 - 00:25:16.900, Speaker C: Yeah. So a felt is, as you mentioned earlier, I think I heard you say it, it's a field element. So Cairo is like a felt. You can think of it as a big int, but it's basically a number over a big field that is a prime, that does indeed field integral mathematics and arithmetics, does that make sense? So you can treat it as modular operations. The only time where it gets weird is for divisions. Division sucks. I don't like them.
00:25:17.990 - 00:25:35.350, Speaker A: They're handable. No problem with that. So for example, we were talking about the ownable contract. This is the one that we're importing. So we have it here locally and we're importing from it. This is the ownable, which comes in a namespace. So we're importing these functions.
00:25:35.350 - 00:26:09.140, Speaker A: Yes, no problem. There are no inheritance in Cairo. Perfect. So going back to our contract, let's go to. So we import these functions, ownable and possible, from functions inside the ownable namespace. And inside the possible namespace you can. Yeah, there's a question there.
00:26:09.140 - 00:26:13.094, Speaker A: Every contract that you, for example, a.
00:26:13.132 - 00:26:24.170, Speaker B: New kind of contract from open 101, for example, if I wanted to import.
00:26:24.240 - 00:26:24.860, Speaker A: This.
00:26:26.670 - 00:26:29.500, Speaker B: Create Cairo version of this.
00:26:32.910 - 00:26:48.698, Speaker A: The solidity. No, you cannot import it right now. In soliti, these contracts that we're showing from Opensplane are written in Cairo, are native in Cairo. I think there are plans to have more contracts on open zeppelin.
00:26:48.874 - 00:27:08.838, Speaker C: Yes, Openzeppelin is working to create the standard implementation. So any kind of contract you have on solidity you're used to have. That is done by Openzeppen. We're working towards having that. That being said, I mean, it takes time to develop contracts that are secure and everything. So if you want to develop them, you should. It's worth it, it's fun.
00:27:08.838 - 00:27:12.760, Speaker C: And you may develop stuff that gets used by other people, which is great.
00:27:13.610 - 00:27:20.522, Speaker A: Actually opens up the contracts in Cairo by opencipline. They have a lot of contributions from people outside the community, so that would be great.
00:27:20.576 - 00:27:31.790, Speaker C: Also, if somebody manages to write a Cairo contract that is the equivalent to the staking contract in synthetics, which is used by everyone. I'll buy you a beer.
00:27:33.170 - 00:28:26.330, Speaker A: More than a beer, it will eventually happen. It's one of you. Okay, so we go our constructor, and then we can get to the, here we're using the initializer function inside the onable namespace, and then we go to the getters. It's very simple. Functions, by definition in Cairo are private, not like solidity. So here, if we want to have getters functions to read information, we have to explicitly tell that they are getters. And something that I forgot to mention before, but this is the way like very similar to how you do it in python, how you define that this has a particular set of properties.
00:28:26.330 - 00:29:09.918, Speaker A: This function that is coming this case with view, we are defining getter functions. Functions where you can read from. So right now we are creating this admin function that as you can see is exactly the same format as it comes in open sepul, for example in ERc 20 or ERc 721, simply reading who the owner of the contract is. So for example, if I go again back to the contract, deploy contract here, I can read who the admin is. As you can see, this is a felt, but I converted to hex. This is the owner of the contract, that is myself is this same direction. So talking about wallets, it's a good opportunity.
00:29:09.918 - 00:29:43.930, Speaker A: Right now you can use right now Argentx, which is this one, and also Bravos, that is this other one. Very recommended. You can use the starnet faucets. You can simply put in Google starnet faucets and you will be able to send yourself some fake it. So you can start making some interesting things using Garly. Or more interestingly, you can also bridge your own it from the girl testnet in the layer one into the L2 of the starnet. For example, here we're using paradigm.
00:29:43.930 - 00:30:30.520, Speaker A: I can ask for some fake eats, send it to my metamask for example. And then using the bridge, I can connect my metamask, which is currently my wallet in layer one, and connect for example rnx here as my wallet in L2. And I can reach these fake it from Garly layer one to L2. So this is also very interesting. It's the same thing as asking for it in the faucets. So coming back to the contract, we have an organ function here. It's also a very typical open setting style function where we are posting, we're asking, we're reading if this contract is currently post.
00:30:30.520 - 00:30:56.750, Speaker A: Very simple. And then more interestingly here we have a view function. To know the voting status is the one that I showed you before. It will let us know how many people voted yes, how many people voted no. As simple as that. Again, you can see in this function that we have an explicit argument. And by now you are already asking yourself, what is this? What is this? Inside these keys, these are implicit arguments.
00:30:56.750 - 00:31:22.086, Speaker A: This is something that is different from other languages. You might not seen that before, but basically these repeat themselves all the time. Cisco pointer, person pointer and rich check pointer. We're interacting with the memory here. So we are talking that these are pointers actually to a felt and to a structure called hash built in. No problem. No, we don't need to get that.
00:31:22.086 - 00:31:38.006, Speaker A: That is something that we're repeating in each function. It doesn't matter. The real use is here. So we're asking here for an explicit argument. That is the boat counting. Sorry, we are asking for nothing here. It's empty.
00:31:38.006 - 00:32:03.874, Speaker A: The inputs and the output. Is this a status, a variable called status? That is the boat counting structure that we saw before. Again, Kairi's type is a type language. This helps for security. Any question until now for this function, for example. Yes, again, you can read it. You can read from the gates voting status.
00:32:03.874 - 00:32:22.858, Speaker A: This is the one that I was showing before. And currently the votes are yes or no. This is practically the structure we have undefined here. This one votes yes, votes no. It's exactly the same here. Okay, sure.
00:32:22.944 - 00:32:24.300, Speaker B: Can I call another.
00:32:26.850 - 00:32:43.940, Speaker A: Contract using cisco? Can I use it to. You can call, of course, these functions from another contract. You can call them and we'll go to the external functions that also allow you to write.
00:32:45.590 - 00:32:46.146, Speaker C: Perfect.
00:32:46.248 - 00:32:48.290, Speaker A: Okay. Yes.
00:32:48.440 - 00:32:58.100, Speaker B: So instead of write 99, what is 96, 97 and eight, why?
00:33:00.090 - 00:33:39.218, Speaker A: That is what I was telling for. That is the implicit arguments. These are arguments that are passed without you explicitly telling these functions that you have passed them. So for example, when we are reading from the storage, you have to provide these functions, sorry, the pencer pointer and the cisco pointer, you have to provide them and they go into the read function. So inside here are the implicit function, implicit arguments. You don't see it because they are implicit, but yes, exactly. These implicit functions, if I take them off, they will have an error in the code.
00:33:39.218 - 00:34:06.854, Speaker A: No problem. It's not hard to get used to them. And also, as you can see, each function that I add in here has them repeated. So no problem with that. Okay. Also we have an overview function where we are getting the status of a voter. And yes, in here we're simply reading into the voter info, a storage variable that we have before using the argument read.
00:34:06.854 - 00:34:45.060, Speaker A: So now going deeper into this, you can read and write from this storage function. In this case we are reading. And as you remember, this storage function asks us for a user address that was precisely a felt. So if we provided a felt, then it will return us. Let's see, what does it return? Yes, if we provided an address, it will return us a border info structure. Okay, so here I'm reading from it and then we're returning it simply as that status equals status. Because the name of the variable here is status.
00:34:45.060 - 00:35:17.616, Speaker A: And to see an example of how to write, this is exactly the same storage variable that we saw before voter info. We were able to read from it. If we are imputing with the address and we now know that it returns an struct. Okay, so now we can write using the argument write. We can write on it. So we are writing on the storage of our contract. And right now this is basically an address.
00:35:17.616 - 00:35:51.064, Speaker A: We will go deeper in a moment over it. But this is an address and we're telling it for this address. Please map this struct. Okay, very similar to how you look at it in solidity. Yes. Message sender is, I think I have it here, get caller address. With this you are getting the address of the contract that is calling this contract.
00:35:51.064 - 00:36:34.520, Speaker A: So for example, in this case, this is the most important function is the boat function. So what it does is simply it's getting the address of the caller, it's storing it, and then we're reviewing the information of this person to see if this person has already bought or not, because we can only allow them if they have voted. And just in a moment we will go into that when we talk about Msp setup, if I'm not mistaken, msg value. Could you repeat the question a little bit louder please? How do you handle a payable, a variable msg value, for example, like an address, you mean?
00:36:34.590 - 00:36:49.790, Speaker C: There's no notion of msg value in starknet because there's no native currency. Everything's in ERC 20. So there is no value attached to a call and there's no payable function. Did I answer your question?
00:36:52.800 - 00:37:32.350, Speaker A: Okay, so let's go quickly into the most important function. The two most important functions, the register voters. And this will help me to talk a little bit more about recursion that we use in Cairo. So again, as you can see, we have the implicit arguments, as always, and then we are asking for two explicit arguments, the register address length. This is the length of an array, and the second value is the array itself. So first argument is the length of this array. The second argument is the array by itself.
00:37:32.350 - 00:38:26.986, Speaker A: Then what we're doing here is, and again, you can see all this contract in the repo I showed you before is in start, and in case you want to follow it closer in your houses. And then what we're doing here is simply, and this is a classic function of Cairo that is using recursion. So right now we don't have force in Cairo, you have to use recursion. And this is a classic function for it. What we're reviewing here is that it is the end of the recursion. So if we have already passed to each of these different members of the array, that is, if the length is zero, then we can return and the recursion is finished. Then here we're creating a small struct, the boater info.
00:38:26.986 - 00:39:08.106, Speaker A: You remember, we defined the struct called boater info. Here we are creating this botante info, where we have this new boater info. So I'm saying here that allow is equal one, it could be zero, for example. So this function, what it's doing is that each of the address that I'm providing, it will register them as voters and will tell us that they are allowed to vote. Okay, and then continuing a little bit with the recursion, what we're doing here is writing into storage, into the storage variable register. Bolter. Yes.
00:39:08.106 - 00:39:40.790, Speaker A: This one we're mapping, as you remember before, we're mapping an address to a number. So this is an address. What we have here is this is the array, very similar as you would do it in python, for example, and other languages, you have the array and you can index through it using the square brackets. Okay, so I am indexing inside this array. This could be a number, like one or two or five. Depends on the number of address that we are adding. And then will we say that the value for that address is one.
00:39:40.790 - 00:40:18.354, Speaker A: We are simply mapping here, and then comes the recursion part. Here we are reading again the same function and providing the length, but this is a lower length, as you can see. If we have, for example, five different voters, now we are providing it with four, and we are sending it with the register address. And then it will repeat, it will repeat until it passes through each of the different addresses. And it is starting from the last one up to the first ones. I know this looks a little bit crazy using recursion, but it's no problem. You can get used to it.
00:40:18.354 - 00:40:36.200, Speaker A: And I think that this will improve in the, in the near future, right? Yes, that's a good question. The question is that what happens if you get into an infinite recursion?
00:40:39.260 - 00:41:06.180, Speaker C: Okay, so there's an answer for today and an answer for tomorrow. But basically there's a form of gas metering in Starknet, just like in Ethereum. And if you reach a maximum number of steps, the sequencer will reject your transaction. Today you don't pay for these kind of transactions. They're just rejected. Tomorrow it will be like a failed transaction on Ethereum. You will pay fees for the execution that led nowhere.
00:41:10.600 - 00:41:36.474, Speaker A: Perfect. Any other questions for the moment? Okay, so simply we have a recursion function here. Again, it's not that hard and it will improve. We're talking that Cairo is a low level language and we have to be very honest and conscious about that. And finally, let's go to the last function that is the boating function. This will allow us to call a function. As you can see here, it's an external function.
00:41:36.474 - 00:42:05.234, Speaker A: External function simply means that we can write on the storage using it. Okay, not only read, but we can here write into the storage. Again, we have our implicit arguments. We have an explicit argument called bolt. And here, don't mind this part. It's simply telling the memory that we will be using the compiler that will be using local variables. We don't need to go through that.
00:42:05.234 - 00:42:27.900, Speaker A: We're calling the possible function from open sepling contracts, specifically the function called assert not pause. It checks that if this contract is pause or not. If it pause, this person cannot vote, as simple as that. Then it get the caller address. This was a question from before. With this function we can get the address of this caller. We are storing it inside a caller function.
00:42:27.900 - 00:43:11.414, Speaker A: Then we can read the information of this color of this address using the read argument from this storage variable, storing it in info. And then we are simply reviewing if this person can vote or not. If they have allowed zero, then they cannot vote. Then we're creating a new border info struct that it says that this person has already bought because we don't want them to vote. Again, we are writing on a storage here. Everything here we already know that. And finally we are updating the status of the vote with the vote of this person.
00:43:11.414 - 00:44:00.114, Speaker A: If this person voted yes or zero in this case, then it will update that with zero, the count with zero, and if they voted yes in this case one, for example, then the count will be updated with a sum that we have here. And finally we are updating the final status of our update, sorry, of our voting and storing it into the storage. As you can see, this function is key and if we go to the deploy contract, we go to the right contract and then I can vote in this case. This is the function. I don't remember what address I added. I think so. I will go to my bravo's wallet in here.
00:44:00.114 - 00:44:45.158, Speaker A: I was in my arian before and let's see if it allows me to vote. So I will vote with one and I will be able to sign this transaction because this address is registered to vote. I did when I deployed it and right now this is the transaction hash, and we have to wait for a tester to process this, and we will have our boat. Now, how can you deploy these contracts? You can deploy it using the command line tools by Starnet or also, and my preferred way is to use Protostar. Protostar is a tool created in the image of foundry. It has the best practices from foundry and also some from Harcat, sorry, from truffle. So it's very interesting.
00:44:45.158 - 00:45:30.770, Speaker A: It helps us to test, but also to deploy. So if I go right now to my command line, this is how deploying this contract looks like. So basically intelligent protostar deploy this contract that is already compiled by this moment. And what I want you to notice here is the part of the inputs we talked before about the constructor as setting three different inputs. First, one is the owner, the admin of this voting. Second is the number of persons of register addresses that can vote. And finally the actual addresses.
00:45:30.770 - 00:45:59.706, Speaker A: So this is how they look. This one, as you can see, is a hexa value, and this is the address that is the owner of this contract. Then only one person or one address can vote. This one and we can simply deploy it running like this. Protostar is very good, it's very usable, it has amazing testing functionalities. But you can also deploy your contracts, and that is simply the contract that we deploy here. And as we can see, we already voted.
00:45:59.706 - 00:46:53.538, Speaker A: If I go to read contracts, we should get a voting status where we had a vote with yes, number one, it updated, and zero is still no, I could not vote again, because theoretically I should not be able to vote again. Let's see what happens. It should be issued for now, but let's wait for it. So that will be the main part of the workshop. We have three minutes, two more questions. Yes, the implicit right now here, I don't have any, but they can change depending on what you're building. Can you think of a scenario when.
00:46:53.624 - 00:47:07.320, Speaker C: Do implicit arguments change every time they are used? Basically it's a bit of a deep question. The workshop is about to finish. If you want, let's meet outside and we'll give you a more definitive answer.
00:47:09.130 - 00:47:18.490, Speaker A: Yes, I think I have an error message here. While I look for it, any other question?
00:47:18.560 - 00:47:28.030, Speaker C: In the meantime, I have a question for the audience. Before we wrap the workshop up, can we just get a quick show of hand? Who learned something during the workshop?
00:47:29.010 - 00:47:29.566, Speaker A: Cool.
00:47:29.668 - 00:47:58.854, Speaker C: Who thought this was too difficult? Who thought this was too easy? Okay, fine, so it's great. This means this was spot on. Those of you still are hungry? Don't hesitate, ask us question. Come on. Our discord, go on. Our resources, look at what we do. As Omar mentioned, most of these things, the paradigm you're used to, that you're used to how you write smart contracts, how you deal with callers and stuff like that.
00:47:58.854 - 00:48:23.134, Speaker C: The syntax is a bit different, the tooling is a bit different, but you can and will master Cairo. It's just a matter of just like trying. And this tool will give you extreme power in your blockchain applications. So if you're looking to do more and go beyond what you can do with the EVM, I invite you, do take a look. It really is powerful and will let you build super cool stuff.
00:48:23.252 - 00:48:47.190, Speaker A: And again, this is the QR to the educational resources. If you want to go look at them. We will have boots on Thursday and Friday. You can ask any question. Come with us. And finally, regarding the question, the error messages, this is how they look. So if this assertion, true or false, fails, then it will print this mistake booter info.
00:48:47.190 - 00:48:50.134, Speaker A: Thank you. Thank you very much.
00:48:50.252 - 00:48:53.030, Speaker B: What does it look like from the browser?
00:48:55.710 - 00:49:02.170, Speaker A: Well, it depends on the wallet. Let's see, for example, this case, third allowance.
00:49:03.950 - 00:49:40.360, Speaker C: So your question is, what does an error message look like from the browser perspective? Essentially, you'll get a failed transaction like you do on Ethereum. And the trace, like the way it shows up, is kind of ugly, to be honest. It's still very rough around the edges. There's a lot of info that is not necessarily relevant to you, but the error message will appear somewhere and you'll be able to know where the error is from. In general, this thing works and this thing scales. Ethereum right now, it's a bit rough around the edges, meaning that it's not all pretty. There's a lot of info, or not enough, but it works and it's cool.
00:49:42.090 - 00:49:57.440, Speaker A: This is how the error looks like. As you can see, that's the message that we saw before in the error. Yes, boring info. Your address is not allowed to boot. Again, we will have a boot. Please feel free to ask any questions, and thank you much for coming.
