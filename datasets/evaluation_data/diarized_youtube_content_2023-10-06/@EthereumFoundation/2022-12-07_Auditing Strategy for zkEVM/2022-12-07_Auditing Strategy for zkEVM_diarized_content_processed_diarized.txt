00:00:11.930 - 00:01:18.790, Speaker A: So, the topic of today's panel is ZKAvM security, and how can we be convinced that the ZkAvM implementations that we're all working on are secure? So today I'm joined by Chen, who works with Scroll Tech and has been leading engineering there about implementing the ZKVM with Jordy Belina, who's part of the Polygon Hermes team and has been leading engineering there. One thing that strikes me about the organizations of Polygon and Scroll is that their willingness to collaborate. They've both been big collaborators in Xeroxpark, and I'm now exploring how to secure CKVMS together. I'm also joined by David, who's on the Ethereum foundation security team and has a traditional background in security and audits and things like that. So I hope that today we can have a nice kind of exploration of how we're going to be able to make the ZKvms that we've been working on secure. So that's my first question. How can we secure the ZKVM? How can we secure the ZKEvM?
00:01:19.130 - 00:02:23.178, Speaker B: Yeah, so, hello, everyone, I'm hai chin. So I think the ZKMMA is a very complicated circuit. So I think to make sure the ZKMA is secure, we definitely need to go through all thorough auditing, having auditors to look at the circuits and probably, I think, maybe not even one single team of auditors, maybe having multiple teams look at that again, and then we can find some bugs and then we can fix that. And then after that, I think we also should do unparalleled, can do some bug bounty program which have the more community members who are interested to look into this stuff and then find any bugs or attack those things. That's, I think, to have it more secure. And then last, I think maybe a little bit like to say, have some more advanced techniques like the veradice people and other people like they describe, have some more formal verification tools and frameworks, do like a model checking those kind of stuff. Although I think initially maybe it's not scalable to a very large circuit, but I think we can eventually get you there.
00:02:23.178 - 00:02:25.002, Speaker B: Yeah, that's like my.
00:02:25.136 - 00:03:10.742, Speaker C: Maybe just to complement that. First of all, open source, that's probably the first step in securing something. Cryptography, biofushation, or just private cryptography. The humanity already has been tested that this doesn't work. We have experience, Microsoft, Google, IBM. So big corporations that just pay a lot of money just building private cryptography systems. We know that this is not the way to go we need as many a's as possible, of all kinds, to take a look at the code, at the protocols, and that's why it's the first.
00:03:10.742 - 00:04:21.440, Speaker C: So the first must, this is not enough, but the first is that this needs to be open source, and the people, and especially the users, have to have access to this code. This is the first step. And from now on, let's start. As you said, it's a complex system. So the first problem that we are challenging is that who can review that? Because it's something that's new, it didn't exist before. We are creating a lot of primitives, a lot of meditation, because we're doing a lot of tricks and a lot of things, and there is no experience on that side. So the first thing is, who's going to review that? Who's going to take a look? Who has the capacity to look at that? So, first step, and this is where we have started partnering here together, that is to somehow start teaching, start explaining to the auditors, explaining to the community, explaining to anybody that's interested in the system.
00:04:21.440 - 00:05:35.654, Speaker C: This is for sure is the first step, because we need to open. And even if it's open source, if nobody can understand what's in that repo, it's like being closed source. So we need this to open and to explain, to teach, to spread where we are working and publishing that. And this is the next step after that. So when we have this, let's say, critical mass of auditors and so on, next step is, okay, here is how we organize, this is how we organize the auditing, because we need to be here, we need to talk about procedures, and we need to talk about how we specifications, how we write the good specifications, how we can split these specifications and have them in the procedures, how can we clean the code, how can we go. And this is going to be probably the next step. And once we have this clear, we have this specification phase quite clear that the things is quite clear, then it's a matter of just taking a look.
00:05:35.654 - 00:06:12.610, Speaker C: And even that we will never have the warranty, like any cryptographic system, we will never have the warranty that the system is going to be 100% safe. Here we have the responsibility projects to invest as much as possible in resources, at least in the Polygon side. I'm sure that in most of the other projects, too, they will not launch anything until they feel comfortable enough that the system is reasonably safe.
00:06:14.630 - 00:06:19.540, Speaker A: Okay, thank you, Jordy. Sorry to interrupt you. David, do you have any comments with.
00:06:20.150 - 00:06:53.214, Speaker D: I think so. I think open source multiple audits. I think education is important for me, coming from a traditional security research background, I think we have very strong software security research capabilities in the community. I think that there's multiple components here. There's like the l one verifying contracts. And as you've seen in previous talks three or four years ago, we just knew what reentrancy was because the big Dow hack, now we have like 101 best practices for solidity coding. So we have these different components, pillars to stand on.
00:06:53.214 - 00:07:29.458, Speaker D: Unfortunately, with security, it's kind of the weakest link issue here. So we've got a great bug tracker for ZK stuff. But where I see a large gap is that we have a lot of academics that come from a formal verification or like a mathematical background and then we have these people that understand implementation. So it's great to want multiple audits, but we don't really have multiple firms that know how to audit. So the education stuff is critical here. Some of the tooling stuff is reusable with formal verification. But I think over time it's going to be about this collaboration.
00:07:29.458 - 00:08:25.262, Speaker D: I think that this is critical. I think you can look at some of these things and say like, hey, all these l two s are competing and I work for the EF and I care about systemic things. So I'm not like on an l two S team here. But in the long run you could say, oh yeah, it's a zero sum game for these l two s, but if something catastrophic happens to any of them, I guarantee you it's a positive sum in the negative direction for everyone. Nobody is going to trust billions of dollars on TbL here and they're all just going to go to optimistic roll ups, right? So I think this approach here, I see Polygon Zkevm folks in the crowd, I see all these people working together and zero x park kind of like hosting this community where academics can come together. I think that this is kind of the only path forward because it's the only missing thing that we have here, that we don't have some tried and true testing methodology. And so I don't think this is anything new for the blockchain community.
00:08:25.262 - 00:08:48.680, Speaker D: The prerequisites to understand smart contract security require you to understand decentralization. Things like Oracle's, all these new primitives. And so we've had this already. We've seen people tackle things where you have to not just be an expert in one domain, like software security. You have to understand economic security and all these things or the whole system falls apart. So I think this is just going to be an evolution, and I think that we're on the correct path forward.
00:08:50.410 - 00:09:05.500, Speaker A: Thank you. Thank you, David. So the ZkvM is a very complicated piece of software. It has many components, and those components interact with each other. And my next question is, what components are you all specifically worried about? What keeps you up at night?
00:09:06.190 - 00:09:52.714, Speaker B: Yeah, I think there are multiple pieces in the ZK, even circuits. Our architecture is not only one single circuit, it's actually a set of circuits that connect with each other and then work together to soundly verify the EVM behaviors correctly that the trace is correct. So I think first of all, the most important piece is the original EVM circuits, which is the most essential piece. It's kind of like you model the EVM of codes and then other state transactions correctly. So those kind of things. I think the people usually know how to do integers, like big integer multiplications and then integer additions. But if you need to be true, all of the constraint is very true to what EVM specs it does.
00:09:52.714 - 00:10:19.326, Speaker B: Like the ECM yellow paper defines how EVM works. There's lots of corner cases if you look into the details. So those are corner cases that usually will be easily overlooked. So I think that's the one thing very important to check. And then the second thing is that the circuits need to work together. They need to connect through some lookup tables to be sure. And then certain things like maybe checking one circuit and certain property will be guaranteed by another circuit.
00:10:19.326 - 00:10:39.682, Speaker B: Then how can we guarantee that the combination of all the circuits is a sound and a complete one to check everything that you have inside the EVM to fully guarantee the ZKVM is correct? I think this is the kind of two biggest things. I think it would be important to audit the ZK event.
00:10:39.836 - 00:10:47.446, Speaker A: So like you're saying that the two big issues are the corner cases and the interfaces between the different components.
00:10:47.558 - 00:10:48.074, Speaker B: Yeah.
00:10:48.192 - 00:10:49.642, Speaker A: Nice. Okay. Yeah, I agree.
00:10:49.696 - 00:10:50.442, Speaker B: I think that makes sense.
00:10:50.496 - 00:10:50.950, Speaker A: Jordy.
00:10:51.030 - 00:11:26.630, Speaker C: We have maybe a different architecture on that. So probably the pieces are different on that side here. I would say two parts. One is what we call it, the ROM, or if you want, is the code that actually implements the EVM itself. There is a lot of lines of code, and it's like writing a smart contract at the end. Single mistake in one of the lines can screw up everything. Well, this is concerning because it's critical code.
00:11:26.630 - 00:11:56.100, Speaker C: And if you see the number of lines that are in, there are a lot actually. You can imagine gas but brightening assembly. It's complex code there. So this is probably my biggest concern at this point. And then there is the immediation. In our case, the imitation is probably much more simple because at the end we have just kind of a processor there. So all the logics is more in the wrong part.
00:11:56.100 - 00:12:37.278, Speaker C: But it's a very new language, it's a very new thing. It's something that we don't have experience designing identity polynomial identities on that side. And it's very easy to miss something or don't take in account something and so on. So probably these are the two things that are more concerned. But I cannot forget even the smart contracts that are in there and more things that are more basic if you want, but they need to be safe too, right?
00:12:37.364 - 00:12:50.034, Speaker A: I find that there's this misunderstanding in the space where people equivocate like l one to l one bridges with l one to l two bridges. And I think that the problem is.
00:12:50.072 - 00:13:17.302, Speaker C: That they call it even breaches. I would like to go back to the double pegging for chain to chain. Maybe it's a breach, but it's truthless. It's just a smart contract. It's a mechanism to move in funds. But it's not what we understand as a classical breach of just kind of a multistic. Where you need to trust some party.
00:13:17.366 - 00:13:24.990, Speaker A: Yeah, absolutely. So to be clear, l two bridges are much more secure than l one bridges, hopefully.
00:13:27.410 - 00:13:27.774, Speaker B: Yeah.
00:13:27.812 - 00:14:17.646, Speaker D: So I think this kind of just points to a lack of true terminology. Everybody's marketing right now. So I would say like l two bridges, I would call them fast bridges, where there's like a third party and they're taking the risk. So if there's a double spend on one of these bridges, like the person that's getting the 1% fee for transferring off of an optimistic roll up and letting you not take the seven day wait period, or between two zkevms or whatever, they get a yield and they take the risk, and they're the ones that's out of luck. If something happens for me, I'm not sitting here thinking, what's the worst doomsday scenario for my zkevm? I'm thinking, like, what happens to eth when something bad happens to zkevm? And I hate to say it, but something bad is going to happen. We've seen double spin bugs in Aztec, we've seen them in Zcash. These things are a big deal.
00:14:17.646 - 00:15:00.314, Speaker D: The one thing that's like the saving grace for Ethereum here is that we have a native non privacy token standard at the base layer. And the reason this is important is because you can see when there's insolvency in a contract, whereas if you just had the ZK roll up and this is your entire ecosystem and everything is either private or it's using ZK to scale, you might not know that somebody's printed infinity tokens or that some of their wallet has negative tokens. And that's like, how your constraints add up. And so for me, it's like this lack of transparency here. I think that there's some traditional security philosophy that we can apply here. You can do things like have buckets. And I understand if you're trying to do something like scale, this isn't that big of a deal.
00:15:00.314 - 00:16:04.634, Speaker D: If you're trying to do something like staying private, having buckets for your zero knowledge cache type transfers, like you can think of, like tornado cash, that reduces the anonymity set. So there are some issues here, but there are also things that we're starting to see now where you might have a withdrawal. Like, we do see these chain to chain bridges that aren't really bridges. They maybe can have a floodgate mechanism, like if somebody is going to drain the entire contract, that's probably not normal when there's 100,000 users that are using your l two. So if 10% of the contract exits in a 24 hours period, maybe having these kill switches will be good. And then you can do things like have guarantees where if there is an issue, everybody takes a 10% or a 20% haircut on their Tbl and nobody's left holding the complete lost bag. I do think, though, that if there is something systemic and a multibillion dollar Zke EVM gets basically drained and this is a problem, then at least the base layer of Ethereum is still there, and we can still make those trust and rebuild.
00:16:04.634 - 00:16:35.254, Speaker D: And so, for me, the scariest part here is the new technology. I mean, people are afraid. People don't really understand the zero spin problem until they see that bitcoin has gone up over time. And like, well, yeah, there's nothing behind it. There's all this stuff, but there's somebody willing to buy it from you right now for $20,000. Right? And so, over time, people start to trust these things. And I think of, like, if you guys have seen the Indiana Jones, where he's, like, stepping on the different pieces and one of them falls through, or like, if you're crossing a creek, you kind of want to feel the rock that you're going to put all your weight on.
00:16:35.254 - 00:17:09.458, Speaker D: Before you go, I think that that's going to be the same thing here. We're going to have to have people start to trust the cryptography that they don't understand yet. This is all moon math to the average person, right? Even advanced security engineers don't understand any of this stuff. And so there's this gap between the understanding of this high level multidimensional matrix math that you guys all understand, and then the people that know what a traditional software bug looks like. And so that gap right there is the scariest thing. And the lack of transparency if something goes wrong, is also scary to me. But you can mitigate some of that risk by bucketizing.
00:17:09.458 - 00:17:10.840, Speaker D: And these other things I've mentioned.
00:17:11.930 - 00:17:51.300, Speaker A: I think that what resonates with me about what you were saying was how it's really nice to have this l, this roll up centric roadmap so that we're able to experiment with these new things and we're able to build systems that, with time, can get the kind of trust that we need. Cool. So my next question is, so when I do audits, what I normally do is I try to find things that people don't know or that the developer didn't know when they were writing the code. So what are some of the things that people don't know about your code or things that could be interesting for people to pay attention to?
00:17:53.110 - 00:18:43.198, Speaker B: Yeah, I think that's a good question. I'm not sure you hear audits, what audits does when they do auditing, but I think there'll be things like, I think behind the file port approving system, whether those interfaces that you use is correct, or even behind there's some repository dependency you use on top of that. Whether that's secure, I think that's one thing. And then I think another piece is there's a lot of optimization tricks, and then that could make the circuits less readable, which I think auditors may find. Like, that's very hard to understand, certain part of the logic of the circuits. So I think that seems like we should explain those kind of things to the auditors. And I think in addition, there are some certain assumptions we make in certain part of gadgets or part of the circuits.
00:18:43.198 - 00:19:00.920, Speaker B: You make certain assumptions, and I think those things, like, are very important. Maybe only the developers who develop those circuits knows about that, but I think those are things, like, important to put down into specs so that the audience can know why you are doing certain things and why you are not doing certain things. Yeah.
00:19:02.650 - 00:19:36.766, Speaker C: There are many things, but one that's important in the concern is that from what we have in the program, it's a nondeterministic. So it's a nondeterministic circuit. It's not deterministic means that, for example, you want to do a division. Actually, what you do is you put the result and then you check the multiplication and tricks like that. Well, there are many, for example, where we are scanning transactions. Actually, what we are doing is we are hashing all the transactions, but we are putting all the data. All this data is we call it free input.
00:19:36.766 - 00:20:09.678, Speaker C: And then we have a constraint that calculates the hash somehow, and then the hash is the public operator that probably needs to be matched. But you can put anything in there. It's okay because you have to hash. But this is something that, for a normal programmer, for a normal programmer, is something extra strange. It's something that's not used to, it's something that's different. And this needs to be explained very well. This we have seen, for example, internally in the team.
00:20:09.678 - 00:20:44.700, Speaker C: In the team, maybe it's just the people that just learn things. It's people that, they come from other backgrounds. And it's natural that when you first write these programs and you do a lot of mistakes, because you need to absorb this concept. Of course, you repeat that, you do it again, and then the people is getting. But it's something that needs to be explained very well, because I think this could be one of the big sources of problems.
00:20:49.070 - 00:20:54.014, Speaker D: I actually don't have any real good input for this question, so leave it there.
00:20:54.212 - 00:21:01.870, Speaker A: Thank you. My next question is, how can traditional tools help us when we're trying to secure CKVM?
00:21:02.530 - 00:21:29.718, Speaker B: Yeah, let me just start with one most simple thing, since setting everything to zero. See if I can pass. That's like, in a lot of cases, you can pass, which is not correct in your circuit. So that's one simple thing. And another thing, some basic things like a fuzzing. So I think in a zero noise circuit, I think the fuzzing could be slightly different. You know, like fuzzing arbitrary data that's putting inside your circuit witness.
00:21:29.718 - 00:22:13.746, Speaker B: But it's very easy. It won't pass the proof because there's lots of constraint checks. You need to be very careful to make some countercases to make sure there's some invalid things that you put into the circuit, but then can pass that. But I think in the context of the Eke EVM is that you can generate arbitrary trace, you can fuss the trace from the EVM, and then see if that can pass. I think that's what Meridax was just talking about. Those fuzzing will be very helpful to generate some valid trace and some invalid trace. And then you can tweak a little certain small amount of things like inside the trace to make things like that should not be passed.
00:22:13.746 - 00:22:16.760, Speaker B: But if they pass the circuit, then there's some bugs inside that.
00:22:17.630 - 00:23:01.414, Speaker C: In general, all these formal verification tools, maybe with some adoption, with some adoption specifics, but can be used at least to understand better some parts of the circuit maybe not like everything, but there are specific pieces that are quite clear and that work very well or that can work very well with this tooling. I'm thinking, for example, the arithmetic state machine. In our case, this is very clear. It's arithmetic. This must be a multiplication and cannot do anything else. This is something that formal verification people love to see, these clear patterns in there. So I'm sure that some work can be done there.
00:23:01.414 - 00:23:43.314, Speaker C: If you go to the main processor that is not that mathematically well defined, maybe there they have more problems. And then here is where fully physiologic make more sense. But yeah, definitely can help. And here maybe it's a call for people that's expert in some it's good to understand and to see how this thing works, because I'm sure that there is a lot of tooling and a lot of these things that can be very helpful, and we don't even know that those tools exist. So here it's important for the community to be proactive. Here the zero x park people is doing a great job on that. And there is people that's already looking at that.
00:23:43.314 - 00:24:01.020, Speaker C: And there are some ideas that things can be done in there that's important. Again, just explaining, because when you really understand the circuits, when you really see whoever this is, you can find people that's expert in that material, that can see ways that can help a lot.
00:24:04.270 - 00:24:38.002, Speaker D: Formal verification has been mentioned. Formal verification can only do so much in a regular security testing. And so it just so happens that there's so much math in these circuits here that it just lends really well to this. So I'm really excited about that. First of all, it's like the first time I think I've seen it applied in a way where I'm like, well, this is going to be a big part of my life. I need to go read, brush the dust off of all the textbooks. Another thing is that there's a lot of traditional things with security audits that actually lend well to these also, and a good example would be like typing.
00:24:38.002 - 00:25:05.738, Speaker D: Like strong typing is serious. In regular security, you have integer underflows, you have integer overflows, you have casting errors. Things can flip negative. And you see this in these circuits. But you also see like there's sometimes optimizations and developers do this stuff naturally. A good example is like the Aztec 2.0 maybe was not ever exploited, but what was reported there was like an input that was 128 bits or 64 bits, and the actual constraint was only 32 bits.
00:25:05.738 - 00:25:42.220, Speaker D: So you could actually provide multiple nullifiers that pass all the constraints, which means you could potentially withdraw from zcash type thing more than once, even though you only deposited once. And that is something that is queryable. And you can just have a strong typing system. So a correct static analysis tool that could have been applied to that and just said, hey, error manual review required. This input over here is a different type than the way it's used and casted over here. So anytime there's like a casting error, you can have this. I think there's going to be plenty of other queryable examples like this where we can apply traditional security tools towards this.
00:25:44.110 - 00:25:57.786, Speaker A: Cool. So where do we need to make new tools? Like Lucas talked earlier about his exploration of trying to make a polynomial solver and there seems like there's a lot of scope for us to explore. Where would you like to see new tools?
00:25:57.978 - 00:26:46.590, Speaker B: Yeah, a lot of tools, like I mentioned, from traditional formal verification, they are not very ready, I think for proving the ZK like the circuits. So I think those things will be very good to have. And then I think not only some tools for auditing, I think there's more tools will be very useful from the proof system side. They can provide you a very easy to use interface to generate some arbitrary, like the error cases like you can inside the circuit, and also have a very bug reporting. For example, where does the circuits fail? Those kind of bug reporting will be also very potent tools as they can auxiliary make the auditing and then make the testing more easier and then easier to find some bugs.
00:26:47.890 - 00:27:25.770, Speaker C: Yeah, clearly this bug reporting, we launched the Testnet, the public testnet, on Monday. We already got a report of an error, was nothing crazy, but it was already a bug that we already fixed it. And that was because we published that and somebody just test that and just put something there. So this is the importance of testing the things. And I agree, the back reporting, when you see something that goes wrong, you need to investigate until the last and fully understand the, because you probably have something that can be getting worse.
00:27:28.110 - 00:28:12.706, Speaker D: I think a formal specification for differential fuzzing would be really cool. I think that there's like a value add when you could take like ten different Zke evms and you could potentially throw a test case at each of them, and then you can compare the output states afterwards. I think the value add here is that everybody wants to be part of it, because you're going to know that you're conforming to the spec if your output matches everyone else's. This has been incredibly fruitful with our consensus layer clients and ethereum for the beacon chains. We have five clients. There's certain things that are in the spec, like processing an epoch transition, and so we can hand it like it's a specified beacon block object and we can run it through every one of them and we can diff all the outputs afterwards. And that's like incredibly valuable, right? That's uncovered multiple bugs.
00:28:12.706 - 00:28:43.118, Speaker D: That would be like chain splitting bugs. And these types of bugs like in the l two world, would mean that you'd have a state diff between the l one and the l two, which means double spins. It means all kinds of other horrible things can happen. Another thing that I think is really important is zoomed out from the ZK EvM. It's more like about l one contracts in general, and that's an open security standard of ahead of time. Hey, if you're a white hat and you find a bug, please report it to us. Obviously we'll resolve it privately.
00:28:43.118 - 00:29:33.054, Speaker D: But there are some cases in the security world where a vulnerability primitive drops and everybody hears about it at the exact same freaking time. And when that happens, you've actually seen this be fruitful, where white hats will front run black hats, they'll steal all the money out of the contract and then they'll return it and maybe get a bounty or whatever. And so having a previous specified like hey, on your bug bounty page, have a little thing down there that's like, yo, if you guys drain a billion dollars of TVL from my contract, this is how much the white hat bounty is. And we're legally saying you're off the hook ahead of time. If you return it all and you do all this kind of stuff, and we are seeing some of this stuff kind of come out and flush out in the defi ecosystem. There's going to be like a spec that's being worked on right now with the open security standard or alliance or something like that. I think there will be more information about this in a few months.
00:29:33.054 - 00:29:58.090, Speaker D: I think this is all just kind of, like, in the community right now. But I think that that's going to be huge, because if you know, ahead of time, I know a lot of white hats, that they just don't want to touch stuff like this. So there was like, I think it was like, the Nomad hack. A bunch of people were able to just replace the public key to receive funds and replay the attacker's original exploit. And a bunch of white hats stepped up and started draining this contract. And it was weird. You could only drain, like, a little bit at a time.
00:29:58.090 - 00:30:17.620, Speaker D: So they were able to actually recover a certain amount of the funds. And it sounds weird to say, like, hey, we're going to give you a white hat bounty if you hack our contract and steal all of our crap. But this is, like, a phenomenon that keeps reappearing, where everybody hears about the vulnerability at the same time. And we do need people to drain these contracts ahead of time. So that's one example of something like that.
00:30:18.630 - 00:30:33.350, Speaker A: Thank you, David. Sorry to interrupt. So my next question is a harder one. So when would you all feel comfortable to put all of Ethereum's assets inside your ZKVM?
00:30:33.930 - 00:30:44.600, Speaker B: Yeah, that's a tricky one. When we launch the main net, I think assume, like, that's audited, and I'll be very happy to do that myself.
00:30:47.050 - 00:31:37.238, Speaker C: We have the experience of Hermes one and other real production life. And, yeah, it's a hard decision. General. I look at the ace of the people that audit that, and it's who audited that? And I'm talking the specific guy. I don't care about the brand, and it's just the guy. Even the kind of questions that the auditor made, how deep they went, and the experience that this person have when you put all these pieces together. But you need to know personally, like, each of the auditors, each of the internal and external auditors, and each person of the people, you just check to all the places.
00:31:37.238 - 00:32:18.066, Speaker C: And here is just a feeling. It's a feeling that, okay, this should be reasonable, safe. That's a feeling. It's difficult to put a parameter, because what you say, you say, oh, we need two audits, we need three outdits, we need four persons. Three persons is really hard, because these persons, I seen audits, I paid audits that I'm sure that the guys that made the audit, they didn't check the smart contract at all. And I've seen that, okay, we have two audits. I'm not going to trust, depending on who made the audit.
00:32:18.066 - 00:32:34.640, Speaker C: So it's more personal thing. Personal people who made what the questions they did, what scanned it, where they went. And this is when I would feel comfortable. But it's a very personal decision. It's a very feeling decision. So it's hard.
00:32:36.770 - 00:33:02.822, Speaker D: To the answer all of Ethereum's assets. I say never. I think the Zkevm for l one will be good for having statelessness and being able to sync a light client instantly without having to download all the transaction history. I think there's value there, but I think just like everything else here, time is the thing that makes you trust it. People trust uniswap because Uniswap has a natural bug bounty of billions of dollars sitting in it right now. Anyone can go after it. So time will tell.
00:33:02.822 - 00:33:26.014, Speaker D: The analogy of kind of stepping and feeling the rock, I think that's important, but I think that bounties are a big deal and these things naturally have bounties. Open source is important. You need lots of eyes. But shell shock and heartbleed were in the Linux kernel. For how long? I mean, for ten years, every single, like 75% of the Computers connected. The Internet had an arbitrary kernel read and nobody knew about it, right. Somebody was probably using that the whole time.
00:33:26.014 - 00:34:02.186, Speaker D: So for me, this stuff is very new. ECDSA tried and true. Sure, BLS, we can do this because we want to aggregate signatures and the trade off was important, but we're not putting ZK in the consensus layer right now for a reason. And this is like, I mean, I sat in a backyard with Vitalik and Dan Bennet, and this guy's been doing ZK stuff since the 70s when nobody cared about it. And now we're in a golden age of cryptography and we're implementing it. And he was like, I wouldn't put it in the consensus layer. So we're taking baby steps in the consensus layer, SSLE, so that we can prevent privacy about who's proposing next.
00:34:02.186 - 00:34:42.834, Speaker D: So they can't ddos like targeted ddos, our proposers and proof of stake. That's like the only place we're taking a tiny little baby step of ZK. I think beyond that, everything else is there's a reason you have there's no privacy and ZK scaling in the layer one. And I talked a little bit about contract solvency. I think that my golden future for Ethereum is that all nation states are issuing their cbdcs and they have their privacy, they have their KYC, all these things in their ZK roll up. And then we can all say like, yep, the US government actually has something to back up their reserves, right, which is something that's a benefit it on our current system. If we didn't see the m one and m two money chart, and if we even trust that we don't actually know how many dollars are out there because nothing's backed by gold anymore.
00:34:42.834 - 00:35:12.298, Speaker D: So I think there's always a trade off. I think anytime you take a bridge, whether it's ZK or it's an optimistic roll up, you end up inheriting the risk of all of the pieces there, whether it's the fraud proofing or anything. And I think that people will do things like have their large company or their large corporation or their large government having their financial reserves being completely visible on the l one contract. And then all the fun, scalable private stuff we can do with ZK, we do on top of that. And we take the risk trade offs the same way that you have a bank account and you have the cash in your wallet.
00:35:12.474 - 00:35:20.930, Speaker A: Thank you, David. I think I only have time for one more question. So my last question, and hopefully we can go through this quickly, is what's your favorite security bug?
00:35:22.230 - 00:35:47.306, Speaker B: Yeah, my favorite security bug is like, I think previously for the Zcash. They have a trusted setup and then they put one extra additional points to there which allow people to do infinite counterfeit, some zcash tokens on top of that. And then that was fun for many years until area found out. I think that's a very epic one.
00:35:47.488 - 00:36:35.466, Speaker C: Security bug in general or specific to the ABM that we are building in general, I can tell you the internal one. No, but I think it's a good example of this is a pack that we actually found. But this is a good example that it's okay, we found this pack, but we couldn't phone for sure. I tell you, it's like in the sparse Merkel tree, there is a condition. At some point there is a condition that you need to check that when you are deleting the key, you need to check that the key that's not the same key. So there is a check that you need to do that. The first implementation, that check was not there.
00:36:35.466 - 00:36:56.666, Speaker C: And when I saw that is, it's so easy to forget that check. It's so easy. That's when you realize how complex this is. And this was found by the person that was documenting this part of the storage.
00:36:56.858 - 00:36:57.600, Speaker B: But.
00:36:59.330 - 00:37:08.390, Speaker C: If it exists, this, what else can be in there? And this is the concern and the learnings.
00:37:11.290 - 00:37:57.286, Speaker D: I have like a million favorite bugs, so I'll say the ZK specific ones. I think that the lack of auditability because of the privacy that ZK inherits here is just really cool. I mean, you see these l one contracts get hacked, and Twitter is excellent at broadcasting information in this distributed network way where if you follow somebody infosec, Twitter, I know about bugs before, potentially the developers do, because it just gets spread so fast. And you cannot see a DFI protocol get hacked now and not know in like 30 minutes if you're keyed into crypto and infosec, Twitter. I think it's really cool that a hacker could basically steal all the funds, slide out the back door, and nobody would know for years, potentially because of the ZK. I think that's just really cool, but cool.
00:37:57.388 - 00:37:59.430, Speaker A: Thank you, everyone. Thanks for taking the time.
00:37:59.500 - 00:37:59.942, Speaker D: Thank you.
00:37:59.996 - 00:38:00.840, Speaker B: Thank you.
