00:00:12.890 - 00:01:15.154, Speaker A: Welcome to better solidity support and vs code by hearthat we're going to be covering this is going to be like a jaunt, quite an easy jaunt through the different visual studio code extensions for solidity. There will be shilling of the extension I work on, but then, more interestingly, we'll move on to a couple of the technical blockers that are holding us back from giving you the solidity experience you all deserve, and then a plan for getting around those blockers. So my name is John Kane. I'm from the nomic foundation. You probably know us as the hard Hat people. Nomic is a not for profit foundation, paid for by donations with a remit to improve the Ethereum developer experience. Hard Hat's a big part of that, but the remit's general and we've identified a gap in editor tooling, and that's why we have built and released a vs code extension called Solidity by Nomic foundation, of which I'm the team lead.
00:01:15.154 - 00:01:59.230, Speaker A: So you can find me on GitHub or hang around our discord server, particularly the hard Hat vs. Code channel. So if you want to come and chat or suggest some features, or you've got a really detailed bug report and a matching PR come chat, come chat editor tooling, let's kick off by addressing the Microsoft branded elephant in the room, right? Why are we focused on vs. Code? And the reason is we have good reasons to believe that vs. Code is the main way that suddenly is getting developed today. So if we take a look at the most recent solidity developer survey, you can see that vs. Code is dominant, right? In fact, the 60 visual studio people we suspect actually meant visual studio code rather than the venerable.
00:01:59.230 - 00:02:28.310, Speaker A: Net ide. Similarly, the remix, that's an online solidity editor, but pulls in key components from vs. Code, right? So you're actually down at them before you're not talking about vs. Code or vs. Code adjacent. And we suspect that the solidity developer survey skews towards those who are deep in the ecosystem, right? Those who are on crypto, Twitter and click on the survey link when it goes out. Put another way, it's overrepresenting this long tail.
00:02:28.310 - 00:03:09.378, Speaker A: It's overrepresenting the shadowy supercoders who are doing their development in Vim, in a team up session over a VPN to a military satellite that they repurpose for the day. Actually, let's just test, right? Hands up anyone who, when they do do solid development, they do it in vs. Code. And hands up, if you're a shadowy supercoder who is doing it in Vin. See, that's a trick no shadowy supercoder would admit, right? And actually hands up if any of the two emacs users are in the room, because I'll buy them a drink. I'm having my doubts. I've created the wrong incentives here, and I'm not immediately going to reneg on that promise.
00:03:09.378 - 00:03:29.102, Speaker A: That'd be a lesson on soft promises and the value of escrow. Right, so by Preto analysis vs code is where we should put in the effort. I'm in vs codes. I want to do solidity development. I'm looking in the marketplace, what should I do? And I would say that there are three options. If you have a different setup, get in touch. I want to hear it.
00:03:29.102 - 00:03:58.262, Speaker A: But those would go down as solidity by Juan Blanco, solidity by dynamic foundation and truffle for Vs code. And we're going to cycle through all three of them quickly. And if we were doing it by installs, we would start with solicitity by Juan Blanco. But as I work on this one, and it's my talk, we'll start with mate. As I'm a coward, I'm not going to do a lot of coding. So here is earlier, John, to run you through the feature set.
00:03:58.396 - 00:04:52.570, Speaker B: So if we jump into our sad city contract as you can see, we have table stakes, so syntax highlighting. We also have diagnostics or otherwise known as inline warnings and errors. You can hover over variables or functions to get useful information. Note that currently we're not showing documentation, though I will come back to that. We have code completion on local variables or more sophisticated examples where type information is required. Completions work inside of import statements as well, both at the file system level, but also direct imports. So in Hardhat's case, that's looking inside of NPM modules.
00:04:52.570 - 00:06:21.400, Speaker B: In terms of navigation, we can find usages similarly, we can jump to definition, and this is working across the different packages of monoreal refactoring includes rename, which obviously you shouldn't use to do any evil. Though we have implemented undo, we have a set of quick fixes which appear in response to salt sea warnings and errors. You can find them under the bulb icon, so let's bring back public visibility and similarly making sure that we set the override specifier. These are small annoyances with function signatures, but we have more complicated quick fixes. For instance, if we have a contract that needs to implement an interface or multiple interfaces, we can leverage the admissing functions from interfaces quick fix and this will do some of the heavy lifting for us. It is scanned through the inheritance hierarchy of interfaces and base contracts and figured out what the smallest set of functions that needs to be stopped for salt sea to stop shouting at you.
00:06:26.250 - 00:06:44.394, Speaker A: Someone to add throw? No, if I push play, this is going to play again. Good, they figured by it. I want to add three caveats to that video. Caveat number one, like any suitably advanced technology, is indistinguishable from a rigged tech demo.
00:06:44.512 - 00:06:44.842, Speaker C: Right?
00:06:44.896 - 00:06:52.474, Speaker A: And what you just saw was a rigged take demo. You didn't see all of the places where jump to definition doesn't work or you're aiming for completions.
00:06:52.522 - 00:06:55.882, Speaker B: We didn't resolve the fault set of completions.
00:06:56.026 - 00:07:04.418, Speaker A: Caveat number two, I want to just reemphasize that the documentation against the function wasn't appearing on hovers, and there's a technical block to that that I want to come back to.
00:07:04.504 - 00:07:05.042, Speaker C: Right?
00:07:05.176 - 00:07:39.386, Speaker A: And three is the biggest caveat, which is there's key features in there, actually, like diagnostics and quick fixes to only work inside of a hard hat project. Right, and that's a problem that I want to come back to again. But let's take a look at the other extensions quickly. Solidity y one Blanco this is the Og. It's been the workhorse of solidity development for years, with over 800,000 downloads relative to ours. Let's just say we know how Vin feels. It provides syntax highlighting, integrated formatting.
00:07:39.386 - 00:08:44.366, Speaker A: It has navigation and diagnostics. The default structure assumes that you're organizing your contracts under source and lib, so setting it up for hard hat is difficult, but it's going to work better if you're doing foundry or daptools or brownie. Next we have truffle for vs code. This leverages solidity by one Blanco for the syntax highlighting diagnostics, et cetera, but adds a layer of UI integrations into the truffle tool suite so that you can run compile through the UI through the task subsystem in vs code, for example. And that's great for onboarding if you're new to truffle or you prefer the UI to the CLI. One other really cool feature is integration with the truffle debugger. I just wanted to mention as well, this isn't from general development, but the diligence team at consensus has a set or suite of extensions that are security centric, so they're going to give you analysis and visualizations when you're doing that smart audit.
00:08:44.366 - 00:09:01.222, Speaker A: Plenty of options for solidity, then lots of great programmers pushing the ecosystem forward, but I don't think any of us would claim that we're yet in the same league of editor support as other language ecosystems like Net or rust or typescript.
00:09:01.286 - 00:09:01.514, Speaker C: Right?
00:09:01.552 - 00:09:09.414, Speaker A: So how do we move from where we are now to that best in class experience? And one of the answers is just time and resources.
00:09:09.462 - 00:09:09.962, Speaker C: Right?
00:09:10.096 - 00:09:37.266, Speaker A: But there are a few technical blockers. I'm going to spend the rest of this talk digging into those. First off, feature fragmentation. So we have features which are siloed by editor and also siloed by development framework. The other is feature brutalness, right? Can you rely on a feature to always be there and to do the right thing for fragmentation? Clearly extensions we have built in vs codes. Maybe the lack of support in them is why there isn't as many people using them.
00:09:37.288 - 00:09:37.438, Speaker C: Right.
00:09:37.464 - 00:10:17.182, Speaker A: If they had those advanced features in film, they would be using them. So that's one form of fragmentation. The other form of fragmentation, though, is in developer framework. Not all of the features that were listed there work for all development frameworks. If you're working on a truffle code base, you're probably using truffle for vs code. And if you're in a hard hat code base, hopefully you'll use the nomic extension. And if you're in foundry, you're likely using one Blanco's extension, right, and that makes sense for some development specific features, but there are core editor features which you just work across all of them, right? You're going to want rename in foundry just as much as you're going to want it in Hardapp, but currently it's siloed in hardaps.
00:10:17.246 - 00:10:17.810, Speaker C: Right?
00:10:17.960 - 00:11:16.862, Speaker A: How are we going to get around this? Sorry, there are multiple reasons for that. One of the reasons is just Conway's law. So if you've got four teams working in compiler, then you're going to end up with a four phase compiler. The code structure matches the communication structure of the teams, right? And the development teams that are writing editor support, it's easier for them to add it for their own development framework. It's easier for me to harangue the other hard hat devs or cajole them or convince them or go crying to the CTO to try and get changed than it is for me to convince the entire ecosystem to just do with IEC. But there's another aspect that's part of solidity, which is that solidity doesn't specify how import loading works or doesn't specify that part. It leaves it up to the development framework right, so we've got an import statement here pulling in other solidity codes.
00:11:16.862 - 00:12:01.406, Speaker A: Salt C requires a custom loader to actually resolve that, and it has to be provided by the development framework. And if it's a relative path, the development framework is probably going to do that as relative on the file system, right, from the current file. But if it's a direct import, then there's multiple different interpretations which make sense, right? In hard hat we would interpret this as look inside of node modules and then find open Zeppelin, resolve the rest of the path, read the IRC 20 solve file, and that makes sense. Hardhat leverages JS, including node modules, but that doesn't make sense for foundry, right? It's going to resolve this based on remappings in either the foundry Tomo or remappings TXT, right? And that has profound implications for editor tooling.
00:12:01.438 - 00:12:01.682, Speaker C: Right?
00:12:01.736 - 00:13:16.826, Speaker A: So say you're on IRC 20, this token here, and you want to do jump to definition. The editor can only resolve that if it understands this at Open Zeppelin import line, right? That implies the editor has to understand the import loading logic of the development framework that this file has been dealt with under. Okay, so how are we going to work around these fragmentations and different editors and fragmentation across development framework? I'm going to do in two steps. First, we're going to use a language server, which is language server is a technology that came out of, yes, code, but tries to deal with the fragmentation you get across editors, right? So instead of each editor implementing language features for each language, we gather up the language features under a daemon and we have the editor boot that daemon up. Ask which features it provides, turn those features on in its UI, and whenever those are requested by the user, it delegates them off to the daemon. And the communication between the editor and the demon is covered by a clearly specified protocol, the language server protocol. And that's what we're doing in the nomic extension today, right? There is a language server which is encoding all of the completions diagnostics, hovers that we provide today, and that is embedded in vs code.
00:13:16.826 - 00:13:38.702, Speaker A: But there's nothing stopping us from exposing that out so that other editors say them could take advantage of it. But what about the important or more difficult form of fragmentation between developer frameworks? If you have a language server in the nomic extension already, why is it that I don't have advanced completions in foundry?
00:13:38.846 - 00:13:39.442, Speaker C: Right?
00:13:39.576 - 00:14:05.242, Speaker A: And the reason because that is because currently the language server is really a hard hat language server rather than a solidity language server. We are all through the code base encoding hard hat assumptions to deal with things like the import loading that we saw earlier. Right, and the reason that we've done that is we use bits of the hard hat code base, right, which allowed us to get up and running quickly. We could make hard hat dance, right, and subtraction is hard.
00:14:05.376 - 00:14:05.962, Speaker C: Right.
00:14:06.096 - 00:14:25.438, Speaker A: But we are looking now to refactor the language server to isolate out these hard hat particular points, the development framework, particular parts behind an adapter interface. We'll have a hard hat adapter, but we also can then have implementations for foundry, truffle brownie.
00:14:25.534 - 00:14:25.938, Speaker C: Right.
00:14:26.024 - 00:15:21.550, Speaker A: And in that way we can add the feature once and have it available across the ecosystem. One other point I just wanted to mention. Recent versions of Sol C have a language server built in, so why don't we leverage that? And we're big fans of language servers to the northern merrier, but the Sol C language server is embedded in a particular version of Solve C, right? And hard hack code bases can have versions that are older than the ones that provide the language server. And similarly we have many complex code bases and hard act code bases which have multiple salt C versions, and we need the language features to just work across those versions. So that's why. But just to summarize, the nomic extension has an in language server that we are making developer framework agnostic and that we're going to make standalone so it can be used in other editors. And that's how we can build a feature once and leverage it across the ecosystem.
00:15:21.550 - 00:16:44.830, Speaker A: Feature brittleness, right? This is about quality, the editor just doing the right thing. So when you do jump to definition, you can do jump to definition of the places you expect and actually goes to the right place. Anomic extension has blind spots, right? There are lots of places where features don't quite work as we would like, and there are several areas that we need to work on this, but I just wanted to focus down on one in particular today, right. And that is that we are not giving the best experience when people are annoyingly trying to use the editor to make edits walk through. So you're bopping about inside of the, you're bopping about inside of the editor, you're doing navigations, you're exploring the code base, you jump back again, and then you start making an edit and you remove a semicolon, right? Shame on you. Shame on you. But suddenly jump to definition doesn't work, right? And why is that? So the video just showed you a change in the document, and that change doc gets passed to the language server, right? And the language server does a parse and it builds an abstract syntax stream, right? And that's a data structure which represents the syntactic elements in the code.
00:16:44.830 - 00:18:31.338, Speaker A: The code might represent a function and then sub nodes would represent substructures like the function name, the parameter list, the function body, and note as well that the parse produces an abstract syntax tree, right? So some trivia is thrown away, stuff that isn't strictly necessary, like white space, like comments, right, because they are not typically used in later phases by, for instance the parser, right? And that's why when we do hovers, we don't show the documentation, the abstract syntax tree, it's abstract because it's thrown those elements away and because the ast doesn't have it, we don't have it, so we can't provide it in a hover. The language server takes the ast and it combines that ast with the asts of all the other code files, right? And then we do a further analysis stage. We overlay it with type information. We also scan through the nodes and we find definition nodes and usage nodes, right? So definition node might be a function declaration and a usage node might be a function invocation, right? And we layer on top of the ast that extra information, these extra links, so that you can see which node is connected to which other node. And so I change so that when the user requests a jump to definition, the language server receives that request, including the cursor position. It looks up the node underneath that particular, underneath the cursor and finds, say, a function invocation, right? It then looks up that precalculated link to find the definition node, and we return that location, right, in terms of its file line column, actually both the start and the end and vs codes then jumps to that location. Next, the user makes an edit and introduces a syntactic error.
00:18:31.338 - 00:18:34.910, Speaker A: The change comes through, we do a parse and it fails.
00:18:35.070 - 00:18:35.586, Speaker C: Right?
00:18:35.688 - 00:19:09.590, Speaker A: And why did the parse fail? Well, we, like other projects in the ecosystem, leverage solidity parser for parsing. But solidity parser is a GS library, and it's designed to give binary answers to the question of is this syntactically valid? If it's syntactically valid, we produce an ast. Otherwise, here's a list of errors, and that makes sense, right? Most use cases of a parser stop. If there's a syntax error, you don't proceed onto compilation or generation steps if there is a syntax error.
00:19:09.670 - 00:19:10.300, Speaker C: Right?
00:19:10.690 - 00:19:22.042, Speaker A: Editors have other needs, right, in the editor's case, we want both the list of errors, but also the syntax tree.
00:19:22.106 - 00:19:22.478, Speaker C: Right?
00:19:22.564 - 00:19:25.726, Speaker A: Or as much of the syntax tree as possible at the same time.
00:19:25.828 - 00:19:26.106, Speaker C: Right?
00:19:26.148 - 00:20:02.454, Speaker A: And that's not what a standard parser is designed for. The way that we get around this in other languages is by building specialist parsers that are more tolerant and they're designed specifically for that editor use case. And that's what we are building now at nomic through our slang project. The slang parser, one of the components of that project, looks to leverage best practices from other languages, from Roslyn, from rust. Right, things like red green trees. And the goal is to always produce, and always to produce a syntax tree. Right, even in the presence of errors.
00:20:02.454 - 00:20:18.382, Speaker A: It's just that sometimes the syntax tree will be valid and other times it will not. But hopefully slang's error recovery will mean that a missing semicolon in one function doesn't mean we don't get the syntactic structures in all of the other functions so that we can take advantage of those in editor features.
00:20:18.446 - 00:20:19.154, Speaker C: Right.
00:20:19.352 - 00:20:33.922, Speaker A: One of the other advantages of building a parser specifically for the editor is that you can include that trivia that's normally missed out the white space. Right, the comments, so that we can show the comments in hovers, for instance.
00:20:33.986 - 00:20:34.406, Speaker C: Right?
00:20:34.508 - 00:20:38.962, Speaker A: Or we can do advanced formatting, sorry, refactorings.
00:20:39.026 - 00:20:39.542, Speaker C: Right.
00:20:39.676 - 00:20:47.734, Speaker A: Right. Now we're blocked in refactorings because developers probably wouldn't be too happy if on doing a refactoring we stripped out all of the comments in the file.
00:20:47.782 - 00:20:47.946, Speaker C: Right.
00:20:47.968 - 00:21:28.390, Speaker A: That's probably unacceptable. But if a parser designed for the purpose, we have that information and we can make sure it's there. So what we're doing here is swapping out an excellent but general purpose component with a component specifically designed for the editor. And that's how we drive up feature quality. To summarize, if you're using Hardat and you're using vs code, we think you should give solidity by nomic go. And we think it represents an excellent set of features. And you've just heard how we're driving up the quality of those features by building editor specific components and swapping out the general components that we have.
00:21:28.390 - 00:21:33.446, Speaker A: And we are looking to make those features available across other development frameworks.
00:21:33.478 - 00:21:33.722, Speaker C: Right.
00:21:33.776 - 00:22:09.640, Speaker A: We want a credibly neutral language server, and we're doing the refactoring and putting in the work, or putting in the work for subtraction to support that. We also want it to be a standalone language server, so we want to pull it out for being embedded in VS codes, it's going to need to do a small amount of cleanup. This is actually one of the easier things we need to do. But hopefully sometime soon shadowy super coder will be able to hack away in solidity to the heart's content. Okay. So that's how we're going to improve the solidity developer experience for everyone. Thank you very much.
00:22:09.640 - 00:22:17.320, Speaker A: Are there any questions for John before you? Sure.
00:22:18.030 - 00:22:29.530, Speaker D: Are there any analysis tools that can benefit from this improved, more robust abstract syntax tree?
00:22:30.190 - 00:22:49.790, Speaker A: Sorry, yes, sorry. So the question is, are there any other tools that can take advantage of this? We would hope, definitely, yes. The slang parser. We're building a component that could be used in devtooling across the ecosystem, right. And it's going to give more detailed information and work across different solidity versions.
00:22:49.870 - 00:22:50.114, Speaker C: Right?
00:22:50.152 - 00:23:08.070, Speaker A: So it should be giving you rich information, cross versions. Other parts of the solidity project also intend to add other components to write even more information. So usage and definition would be the next one that we're looking to tackle. So yes, hopefully lots of analysis tools will be able to leverage these components.
00:23:08.410 - 00:23:14.120, Speaker D: Hey, thank you very much. This is awesome. So two questions real quick.
00:23:14.490 - 00:23:15.282, Speaker A: Go for it.
00:23:15.356 - 00:23:30.714, Speaker D: It wasn't clear to me at least, if this lank parser is being used right now by the extension. And the second question is, is there any intention from you guys to support cock nBeam?
00:23:30.842 - 00:24:17.582, Speaker A: Which is like so right now we do not have the slang parser. We're using the solidity parser and we are looking to dog food the slang parser within the VS code extension. I'm not giving out estimates, mainly because it's not up to me, but yes, we're hoping to pull in the slang parser in the near future. In terms of Vimcoc, that's part of making the language server standalone, and Vimcoc would be the first target for making it work with that. And that's something that is within just the PSP team's remit. So hopefully that should be in the near future when the slang parser comes out. Do we need to install it or is it already built in? How can we get access to it? It will be available.
00:24:17.582 - 00:24:27.740, Speaker A: It's a separate library. I believe it's written rust, but we will make it available in node and JavaScript as well. Thank you.
