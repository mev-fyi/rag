00:00:13.610 - 00:00:59.006, Speaker A: Workshops from Metrolab. Even while we need open source and everything, we will not show a lot of pieces of the code because it's not that interesting. We will try to explain software work for those who were not on television blockchain week, where the starter had their workshop. Yeah, we'll briefly explain. You need it for recording. I can just speak more loud. So first, for those who was not on the television blockchain week, we'll use the short review how starts work and where you should pay attention so you don't make the system unsound when you make code.
00:00:59.006 - 00:01:47.390, Speaker A: We will focus mostly on the most powerful committee for start, which is fry interactive oracle proof of proximity. And instead of showing the code, we wanted to show some applications to start. Initially we wanted to showcase capability to start, which is unfortunately not the start without a huge modification. And also when they include it here, we can quickly discuss application for BDF, how we can use starks for bdfs in terms of application start. But at the end of the presentation, we will also show the transparency scheme, which you can make out of pride and potential improvements to it and difficulties. Why you cannot just naively make it so. The level will be quite intense.
00:01:47.390 - 00:02:03.220, Speaker A: So just be prepared for it and be worried. Can something believe the presentation? Maybe I will answer the questions if something happens. The format is if you don't understand something, like you really want to ask a question, you should raise your hand and we should stop and answer your question.
00:02:07.530 - 00:03:00.122, Speaker B: Okay. Thank you for coming. As Alex told, we won't speak about our implementation of tax code holder. Because of recent appearance of new proof systems such as plonk. And because of our work on commitment schemes, we decided to give the motivation of our work and cause it has its roots in stocks. I will start from the definition of stocks, show how they will work. And then I will try to show how some components of chalk, mainly the final step the fry can be combined with, for example, plonk to achieve fully transparent and succinct snack the roma with the following reminder of jugs.
00:03:00.122 - 00:03:41.490, Speaker B: I will briefly describe all the steps. The first arithmetization called air and the second and the fry itself. Then I will speak about what eplenomal commitment scheme is Kate commitment, which is mostly used now. And how we can build new commitment scheme from Fry. And then I will try to speak about possible applications of our commitment scheme to make food transparent snacks. Okay, so let me in. This is the formal definition of algebraic intermediate representation.
00:03:41.490 - 00:04:54.730, Speaker B: It may look quite weird, but I will just explain on the board what does it exactly mean? And you will see that it's pretty simple. Okay, air is just kind of register machine. So you choose your parameters. F, which is just a finest field, which should be a residue field, so a prime field, in other words. And w is your number of registers, just fix them and then double them. And t is just the length of your trace, the number of steps that your program just executes. And at every step you just modify the contents of every register.
00:04:54.730 - 00:06:12.690, Speaker B: In fact, your program is encoded as a matrix of size t cross w. But the question is, what are the possible ways to modify the content? And in fact, this is how the stack works. There is some kind of restrictions on how to modify the values. On each step we should apply the same set of polynomial functions. Let them call the trace constraints, let me call them p one, p two up to pk, and they should be applied at every step. Every such polynomial is a function in two w variable. The first w part of variables is just the oldest state of registers, and the next one is the new state of registers.
00:06:12.690 - 00:06:50.154, Speaker B: And the most simple example, I think many of you have shown it many times, Fibonacci sequence. So the first register is just one, one two, and the second is one, two, three and so on. So, the new value of second register is just the sum of the values in previous registers. And the function in two w variables.
00:06:50.202 - 00:06:50.800, Speaker A: Is.
00:06:55.570 - 00:08:13.500, Speaker B: How x one plus x two minus is equal to zero. What is x plus Y-X-I call the old value of projects to be x and the new value of project to be y. So I think this is x and this is y x one x two y one y two. So just apply the sum function and the new value of y is just the previous value of x. And the same set of functions is applied at every step show in real applications, for example, x, the previous value and y is the new value and the same set of functions applied at every step. And of course, just here we have just my new functions. But in reality, if you try to encode some weird circuits, you will have polynomial relations, which can be cubic quadratics, it doesn't really matter.
00:08:13.500 - 00:09:08.810, Speaker B: And you can mix the x and y variables as you wish. And the main thing here I want to stress is the difference from run band constraint system. When you try to encode some gadget in the run one contain system, for example hash function. And then when you try to use it in your circuit several times, you will need to pay every time you use your hash function. So if your circuit contains three instances of the same path of the same hash function, then you will have a triple number of gates. And the difference in this situation with tax is quite different because you encode your gadget only once and then you may use it repeatedly. But you need to have some pattern of repeatance.
00:09:08.810 - 00:09:38.820, Speaker B: So the same test constraint should be applied at every pair of steps, or for example at every the distance between the steps. The steps should be at one or two, but this would be some kind of repeatable pattern. How many of you are familiar with rank one constraint system? Okay. Less than a half. Yeah. Doesn't make any sense.
00:09:39.670 - 00:09:39.986, Speaker A: Yeah.
00:09:40.008 - 00:10:15.282, Speaker B: And the witness is just the particular instance of metrics. The values of the metrics are just taken so that those relations will hold. That's it. By the way, I have only spoken of trace constraints. Another thing is how to embed public inputs. And this is done by boundary constraints. They are just tuples of coordinates and value.
00:10:15.282 - 00:10:43.260, Speaker B: The first coordinate is just the step at which to apply this boundary constraint. The next coordinate is the number of registers and the value alpha. So the boundary constraints just says that the value of this self matrix is alpha. This is quite simple. I think the next one. Can you go back? What was the last line?
00:10:44.190 - 00:10:46.060, Speaker A: No, this is the next one.
00:10:47.630 - 00:11:18.930, Speaker B: Can you go back? Yeah, just take a sentence. You need all your constraints. Constraints should be satisfied. And p is a function. Every element of p is a function in two double variables. And the third half of variables is the previous row of magics. And the next one is the next row.
00:11:18.930 - 00:12:08.040, Speaker B: This is what is written on the last line. Any questions? Now? Okay, the next one. As we know, the best way to encode any proof systems is to reduce them, to reduce even the witness to paranormals. Now we have just the boundary constraints and the trace and the trace constraint represented in form of polynomials. But our witness is just. Well, it's just matrix. And then we need to somehow transform our air representation into the form which is most table to just itself.
00:12:08.040 - 00:13:06.434, Speaker B: And we need the kind of routing, the routing means that we want to place the values of our magic which is our witness into encoded into a polynomial. Again, this is just the definition. Again, it looks weird. And now I will explain what can be done in the simplest case. In reality there are some difficulties, but nevertheless the main thing is the following. We choose two groups. We have just our find field and we take two groups, g one and g two, inside the multiplicative subgroup.
00:13:06.434 - 00:14:02.780, Speaker B: Multiplicative subgroup of our field. And the first one should be of size t and the second one should be of size w. So in practice, we want our field to have a largeity so that its multiplicative group, the order of multiplicative group is divided by large power of two and our trace length and the number of our registers to be power of two. So if it is not the case, we can just simply extend both parameters. There is no problem with it. Then let d one be the generator of the first group and.
00:14:07.550 - 00:14:07.978, Speaker A: G is.
00:14:07.984 - 00:15:42.780, Speaker B: The generator of the first group, and new is the generator of the second group. And we just renumerate the cell of our matrix with elements generated by these two groups. This cell will be just g one raised to two, and so on. And this will just use the repo. The cell with index I j will be rated with gi minus one. Now that's, you catch the idea. And then I will take the function f on the domain g one, cross g two to have these values in f, and the value on g I minus one, new g minus one will be just the value of this.
00:15:42.780 - 00:15:51.082, Speaker B: Then we'll see how to. And this will be our witness.
00:15:51.226 - 00:16:33.478, Speaker A: Yeah, this is a very formal definition for those who would want to do the practical application of this and just understand how this works. Its formal definition just says, take every row, concatenate them altogether, and do the interpolation over the multiplication subgroup in a prime file. It's just very simple. Well, you can see the same structure in many systems where you want to encode your witness as a polynomial. So you literally place your witness values. You say, there exists a witness polynomial. And I want to require values of this witness polynomial on certain points to be equal to my witness values.
00:16:33.478 - 00:17:02.930, Speaker A: Here, you do the same. You just take every road, you concatenate them altogether. You get the polynomial, which you get a set of values which is size t by w. So you just need the subgroup which is t by w size, and you do a simple interpolation, which is just a fast for your transformation. It forms the practical perspective and less the formal definition. Even this one doesn't show the full essence. Well, this one is too complicated explanation of actually how it works.
00:17:02.930 - 00:17:32.806, Speaker A: The simplest one is you just do interpolation. You can treat them all as points. You treat them all as like values, as a point. This is a point. And while the previous matrix contains a value at this point, this is your requirement for polynomial. And you strictly define the polynomial of degree t by w minus one by t by w one. In optimized applications, you don't think you can contain it altogether, because this is going to be a large single t.
00:17:32.806 - 00:18:11.942, Speaker A: You can say, I will have not one but w witness polynomials. It doesn't change the essence of the start and you'd say my witness polynomial number one is just for register number one. So you do larger number of interpolations, but each of those is going to be much smaller size. This is a solid optimization which is used everywhere, which is used by stackbar bias, by direct guys like this is an efficient way to have to implement it. But here we don't talk too much about the optimizations because there are too many of them. Literally, we just try to explain the essence of historic. It's not the essence of a stark itself.
00:18:11.942 - 00:18:21.958, Speaker A: It's as common technique to encode the weakness as a polynomial and then have relationships about the polynomial instead of relationship about the values. Kenseth will explain the next step for this.
00:18:21.984 - 00:20:27.638, Speaker B: Explain how the last loan equation comes from. Why do encode this way? Remember that every trip polynomial is applied to every pair of constraints. Then just what will happen if we'll take our math to be just the consecutive values of the group of the second group, I'll just write it down. F new one x five x up to the last one. F new x the previous set of registers. And the new values are f new one to one x one squared X-F-X it. Okay, so the first polynomial is in two double variables, the first set of values that we just put in our polynomials, f, the categorative values of the elements of the second group multiplied by x.
00:20:27.638 - 00:21:08.274, Speaker B: And next, we just take the same function and multiply not only the elements of our third group, but also by the generator of the third group. Then what will happen? If we take x to be just unity, then to be what? To be just unity. Unity. Just as I mentioned, the field one. Then these values will be the first row of our matrix. This will be the second row of our matrix. So we take x to be one.
00:21:08.274 - 00:21:58.718, Speaker B: Then we just encode our constraint on that first pair of rows. If we take x to be generated of the first group, g, then we encode the second pair. And then if we take the rate to square and this way will be encoded the third pair of rows, and so on. So this equation will hold for all elements of our first group. Then just return back our mask. Our set of mask is just those parameters. Our constant polynomial is the same, is the same polynomial taken from representation.
00:21:58.718 - 00:22:44.260, Speaker B: And our domain is just the setup elements of the first group. It. And so our domain polynomial Q will be just the project x minus minus every element. And it. And we know that this element formats like a group. So this will be written in a simple form, x t minus one. And this is very important.
00:22:44.260 - 00:22:56.366, Speaker B: This is very important text that our group has such. That our polynomial has such a complex representation for it to be calculated efficiently.
00:22:56.478 - 00:22:57.042, Speaker A: Yeah.
00:22:57.176 - 00:22:58.834, Speaker B: So we exploit the structure of our.
00:22:58.872 - 00:23:03.880, Speaker A: Group, with one exception here. This polynomial will solve every.
00:23:04.730 - 00:23:06.022, Speaker B: Except the last one. Yeah.
00:23:06.076 - 00:23:22.598, Speaker A: Enumerated from here. So it's just virtually. I also hold on this one, but there is nothing after. But we're in a cyclic group, so we would literally link the last row to the first one where relationship doesn't hold. So you have to cut one route out of there, but it's still efficiently calculatable.
00:23:22.694 - 00:23:25.354, Speaker B: Or another possibility is to extend your traits.
00:23:25.482 - 00:24:11.726, Speaker A: Yeah, but this gives you computational technical detail. Yeah, well, this is strict definition. It works just for intuition. The same trick was used by Zachary and Ariel Gibizon in their plumb proof system, that you can multiply the argument of the polynomial by the generator in certain cases. And this gives you a displacement, a time displacement, or just in ratio displacement. Let's go back to Fibonacci example with 1123. I will only work on this part, on these two rows, just for now, by the definition of the weakness polynomial over x.
00:24:11.726 - 00:24:24.260, Speaker A: And let's say I use omega as the generator. Omega four is equal to one, because I have four elements here. By definition, this one would be this cell.
00:24:27.510 - 00:24:34.770, Speaker B: One would be this one's.
00:24:39.050 - 00:25:10.206, Speaker A: Another one. Well, not representative, but here. And this one is two. So I just enumerated them one by one. By why it's called roding, because it allows you to navigate in space by number of selecting the register and time by selecting the timestamp. Even when as a real application, will have separate witnesses for separate registers will not need to navigate in space, they'll need to navigate in time. So this is the definition of function over x.
00:25:10.206 - 00:25:40.550, Speaker A: What happens if I look at the function of x multiplied by omega squared? X will actually give me, let's say, like this. Keep it formal. Omega is zero. So it's one, one here. Omega squared, it will give me one. It will give me the solve. If I take my multiplied function as omega negative, first power, give me two.
00:25:40.550 - 00:26:02.782, Speaker A: So I literally displace my time by one step. That's why it's called the rotor. Even I choose, not the easiest example to see too many ones here. But if you do the same for next periphery process will be much more representative. So this just allows you to navigate. That's why it's called the rotating. Yes.
00:26:02.782 - 00:26:23.910, Speaker A: And for this, everything you want from practical perspective, well, you can transform polynomial in this form over x into polynomial displaced one by very simple and efficiently parallelized polyformation, which takes a linear number of multiplications. This is alteration.
00:26:25.530 - 00:26:26.280, Speaker B: Okay.
00:26:27.690 - 00:26:48.026, Speaker A: Yeah. So this what you would have in the practical implementation. With auto optimization, you don't need to navigate in space, even while in the original papers, everywhere you say you take all your witness, put it all together, use one witness, polynomial, you never do it in practice, so you only need to navigate the space, everything else false.
00:26:48.138 - 00:26:55.250, Speaker B: To be precise, it is not from the original paper, but by the next one, which is called the deep techniques.
00:26:55.990 - 00:27:22.460, Speaker A: Well, it sounds applicable for each one. Just a question about. So here, when you say for only in f, so f, here is the field that you work over only the subgroup. Oh, no, it's for all x for which the other main polynomial is equal to zero. So where you have the money, but I mean, it's a part of the next.
00:27:25.550 - 00:28:25.690, Speaker B: Sorry, it's not precise allied. There are some technicalities just second out of domain, which I don't want to speak about, just. Sorry, from chakra, but what's going on? Remember from the previous slide, the previous slide, that if x is a root of dimensional normal, then should be the root of these large construction. And here, this large construction is taken as a numerator. And so on, every such, on every x from our domain, which is just the elements of the first group, this fraction should be eplinomial. Yeah, and we just take random conditions from the verifier in order to combine all those functions into one. Just technique.
00:28:31.090 - 00:29:29.134, Speaker A: What do you mean by fraction here, just to explain, less convenient to this, do you see that cup polynomial is one issue? Yeah, but if your constraint holds on this contraction. So, I mean, literally, this contraction means that your constraint hold for a width. So it means that for every x for which we showed the simple example, e is equal to zero and cup polynomial is equal to zero. So you can divide one over another because they have the same root. Literally, at this point, it means that if you do this division, then this construction is not a rational function, but this is polynomial of the degree which you can predict by constructing a system. Yeah, just for those, for a technical perspective, you want to have this constraint to below degree. So this polynomial, which will be part of the price, will not grow to very large degree.
00:29:29.134 - 00:29:43.154, Speaker A: So if you have few constraints, or like small number of constraints to large degree, you would rather prefer to break in constraints, which are degree two. Well, three is not good because you always work with multiples.
00:29:43.202 - 00:29:43.622, Speaker B: Of two.
00:29:43.676 - 00:30:29.490, Speaker A: So like two or four, but not larger. From optimization perspective. Here's just an explanation why you can divide. This operation will give you a polynomial, which is important for next step of the price, but not some function, because you can define it as a function, but you will then g of x will not be a polynomial. Can you remind p is in polynomial? Now, you just not take x y as doing x test, but you say, well, I replaced my x one by taking the business polynomial, which is properly masked. Q is just a one nation polynomial. It just defines you where your constraint holds.
00:30:29.490 - 00:30:42.940, Speaker A: If you want to hold on every row except the last one, it will have this one. Yeah, this is the definition of binary polynomial. The king is used everywhere, even in the graphics team. For those who are much, I think much more.
00:30:43.310 - 00:31:27.720, Speaker B: And once again, I want to stress that it is not the last protocol, as it is written in the paper, but it's nevertheless the main idea. So, our problem we produced to the following. We want to show that a function gx is not a rational function, but a polynomial, a polynomial of degree, which is the same that the order of the first group. And we need some tool to check this efficiently, the next one. And the problem which we're trying to solve is proximity testing. We just have some access to function f. I mean, oracle access.
00:31:27.720 - 00:31:50.270, Speaker B: That means that you may only query some values. So just the verifier asks some values from the function, and the proof just gets the ablation at some points. And the verifier wants to know that this function is indeed a low degree polynomial.
00:31:54.630 - 00:31:56.094, Speaker A: Just for definition of oracle.
00:31:56.142 - 00:32:00.210, Speaker B: Yeah, at least in the rough.
00:32:02.390 - 00:32:39.162, Speaker A: Let'S talk about efficiency. You could have this way solved. Well, you can prove that geofac is a low degree polaroid, but for example, using the gate remittance, because it actually gives you degree bound. But we are not here for this. What you want at the end of the day is efficiency, between communication, between proverb and the breakfire. And to check this relationship everywhere, you need all the values and do like linear number of characters. This is why it's called oracle.
00:32:39.162 - 00:33:38.050, Speaker A: Actually, first of all, your proverb tells, I know some set of values and I commit to them. So imagine it's just set of numbers, which you break apart number by number and give it to someone. You can ask for those numbers one by one, and those will not be changed. In principle, you can ask for all of them, but then you do the work, which is enormous, but you can pick one by one, and the small number of values, which you will pick from this trusted source. And in reality, this trusted source is a mercury. Those set of values will be enough for you to say, well, whether all of those values came from some polynomial. All of those values, together with some proof, which you will get will come from the word from the polynomial, which was small degree or unlikely to be small degree.
00:33:38.050 - 00:33:43.140, Speaker A: Yeah, we will proceed with. The formal part is an informal part.
00:33:44.230 - 00:34:07.766, Speaker B: Doesn't make any sense. Yeah, there's no need to explain. In other words. Okay, next one. So the answer was that is told to query all the values of our function domain d. But the domain is really large. It will be enormous number of queries.
00:34:07.766 - 00:34:51.526, Speaker B: And this is the thing we were trying to avoid. And the question is, next one. Can this be achieved with logarithmic number of queries where ge, as you remember, is the degree of our witness f? The answer is yes. This is really ingenious protocol. The formal definition of the problem we're trying to solve. We're working in interactive oracle proof model. Anybody familiar with interactive oracle proof model? Okay, then I will try to explain interactive proofs.
00:34:51.526 - 00:35:34.002, Speaker B: I think everybody knows. PCP model, the proof of data. The proven data is not sent just as little pieces of information. They are sent in terms of oracles or large tables. And the verifier, when he received this table, large table, he can only query a small number of points. This is called PCB model and interactive oracle proof model. It just combines those two votes.
00:35:34.002 - 00:36:15.700, Speaker B: This is an interactive protocol from which every message from the prover is a kind of oracle or like table from which the verify the queries. Only small amount of beats send some response. And the next answer from prover is a gainer table. And when we speak about interactive oracle proof of activity, the first format should be our oracle to the function f, of which you want to prove that it is a polynomial power degree. And in fact, every other oracle will also be ablation of some function. When speaking case of right.
00:36:21.670 - 00:36:24.166, Speaker A: Here you.
00:36:24.188 - 00:36:47.946, Speaker B: Have domain d. You have two functions, f and g. Any functions, not polynomials. And they have some values. And then just count the number of points in which they are different. Here, for example, is two. And I just take the relative time distance.
00:36:47.946 - 00:37:00.734, Speaker B: Or just divide this number by the set of domain so that my metric will be between zero and one. And this is just a metric. It has all proxies of metrics. Symmetry, the triangle inequality.
00:37:00.862 - 00:37:03.810, Speaker A: So you're basically talking about Brixelomon.
00:37:04.790 - 00:37:30.650, Speaker B: Yeah. Fry. Fry workshop with m. I think the next one. These are the parameters of Fry. And it just exactly takes logarithmic number of queries. But what I want to stress here is the soundness sourness uses some parameter delta.
00:37:30.650 - 00:38:08.890, Speaker B: Our initial function. Our initial function, which we provide oracle for. It may not be a polynomial. It might be some function, some function, f, which has some distance from the space of Ritzelman codes. And Fry is unable to distinguish precisely the functions which are exact polynomials and the functions which have some distance from the space. Or read someone codes.
00:38:10.430 - 00:38:35.378, Speaker A: I think here we will do just another solid example. Initially, problem. We have a polynomial. Let's just say we have a polynomial with an oracle axis. We get it somehow from the proverb. So for capital, it will be a polynomial. API knows that this is a polynomial, just to show you how the fib works.
00:38:35.378 - 00:38:53.320, Speaker A: And we get it. So from domain, we get the relation. So, let's say our domain is small. It's just four elements. So one, two, three, and four. And then I have a function.
00:38:57.130 - 00:38:57.990, Speaker B: Um.
00:38:59.070 - 00:39:45.602, Speaker A: For a small letter, it's just some function for this, well, 1234 wasn't the widest twisted. Okay, and I'll say I know that degree of this polynomial, let's say, is equal to zero. So I will just have this, a lot of ones, and it have an oracle Accessory list, too. Let's say this is different. Like this, it's no longer a polynomial. Tick, we want it polynomial. Those are my, in principle, oracle accesses.
00:39:45.602 - 00:40:04.160, Speaker A: I would kind of simulate them as a table where I can create value. So what would I do? And what would I get? As a result of the prior protocol, I cannot read all the values at once, because if I would, I would just interpolate this locally by myself trusted source, and get an answer whether.
00:40:07.650 - 00:40:07.966, Speaker B: The.
00:40:07.988 - 00:40:35.506, Speaker A: Values I got were from low degree polynomial, just from some function. So, if I would get this in full, I would interpolate this and see, well, this is indeed a polynomial degree zero. Just again, for this one, I would do the same work, and I would get degree, which is more of this than zero. But I cannot have an axis everything. So I can hope to get the strict answer. So I can only get answer with some probability, which is foundance. And for delta parameter.
00:40:35.506 - 00:41:16.434, Speaker A: Delta parameters, delta parameter will tell me in how many points. I want to be sure that this polynomial doesn't deviate from sample, not just from exact one, but from sample of degree zero under the same oracle. So these two evaluations, or two oracles, they deviate in one point. So in this case, my delta in one force. So let's say I want to distinguish between two cases where it's exactly the polynomial of certain degree up to a certain degree, or when it's one fourth close. So it's only different than one point. And why is this okay, but not further, so not in two points.
00:41:16.434 - 00:41:57.154, Speaker A: I am okay with one and not more for this. So I fixed my parameter delta, which will tell me how many steps of the prior protocol I have to run, which at the end of the day, from practical perspective will tell you what is your process at the end of the day. Let's say I want to do less than. So I'm okay with delta being one cuff. So I will allow someone to give me values not exactly from the polynomial, but from some function to give it in two cells here. Then my delta is larger and the property of the primers are up to sodium conditions, which we'll not talk here. It will give you larger sound.
00:41:57.154 - 00:42:41.498, Speaker A: So your proof size will potentially be smaller. Again, if I want to be sure that this is only different in one cell with let's say 100 bits of security, my proof is going to be larger than indicate if I want to be sure that it's different, not in one, but at maximum, at two cells with the same bits of security. That set of delta parameters is important. We will show why it's important until later steps. But all the improvements of the fry protocols, at least for now there were two, improves the soundness. So we improved the second term in this minimal function. And also say what is your delta up to which you can even use the frame.
00:42:41.498 - 00:42:44.158, Speaker A: But we will not touch this in too much details.
00:42:44.174 - 00:42:45.378, Speaker B: Yeah, I have a question.
00:42:45.464 - 00:42:48.546, Speaker A: So how you map the number of.
00:42:48.568 - 00:42:52.340, Speaker B: Points that these polynomials deviate to the bit of security?
00:42:53.510 - 00:42:58.710, Speaker A: Well, I mean this is a sound error. It basically tells you what is the chances you were cheated.
00:42:59.130 - 00:44:11.310, Speaker B: If you want to explain all the parameters here, only thing that is important and the thing that the care of this parameter delta. We decide how much according to this parameter delta. Alex told it means how much euro we can take. So this is the space of islamic codes. And this is just the delta blow in this space, the circle of radio delta. And this is a function which is just in those delta blowing for this function with parameter delta will pass, right? Of course it doesn't mean that this function is so normal. But I want to stress nothing why this is not important for stacks.
00:44:11.310 - 00:45:07.760, Speaker B: As I have said, we need to show that some function, some with this function is a polynomial. But if normal deltas, the prover is able to pass fry, then this means that he knows some function which is in this delta radus. But this is not a polynomial. And the only honest witness for stocks is a polynomial. But doesn't matter, because we have decoding algorithms, such as Sudan decoding algorithm or Walsh Berkamp algorithm, which just gives us the proof of knowledge. They are just very efficient, normal. And what they may say, if just prove, who knows not only oracle, but the function itself.
00:45:07.760 - 00:45:28.286, Speaker B: If he's able to provide any function which is close, then he will just use those algorithm of decoding, and he will get the polynomial, which will satisfy all the conditions. This is the trick, actually, the essence.
00:45:28.318 - 00:45:59.146, Speaker A: Of at least deeply protocol. Here, everything we're taking before was about the polynomial. I mean, we assumed that proverb was honest, but we just encode the original problem. The end of the day, this is a publicity problem. So, what we want to say is, let's say the verifier is satisfied with all of the conditions and all the checks we put here. It means that certain values from the oracle. And in principle, prover knows oracle.
00:45:59.146 - 00:46:46.458, Speaker A: And we assume that the prover knows the oracle in full. So he has access to all the values locally, he can do whatever he wants with it, and he satisfies the ring fire. Even if the oracle was not exactly the values of the polynomial, but they were just closed. And there is an algorithm for the proverb himself, to take those values, decode a polynomial from them. And this polynomial will be the true witness. So the polynomial, even if the proverb didn't know the witness, but he passed all the checks, with all the enormous number of bits of security, he in principle would be able to take all those values and find the true business easily in a polynomial type. So, in principle, this is a proof of knowledge.
00:46:46.458 - 00:46:56.340, Speaker A: And if Proverb has satisfied the ray far, then he can get the knowledge of the true business. This is not very intuitive, but in difficult.
00:46:57.110 - 00:47:32.146, Speaker B: I think we need to speed up. So just limitations, which is quite common used, I think, as most of you, to run one contract system. And there are many tools, libraries to encode programs in run one country systems. And there are not so many tools to encode in star. So I think this is just limitation, as I have told the property of air. So that star is just boxed. Well, only for pitukitations.
00:47:32.146 - 00:48:27.358, Speaker B: And the proof size is large, especially when we compare it to snacks, where the proof is constant size. But the final part of Chucks is really ingenious. And maybe we can apply some other primitives, because mainly next one, what fry shows us is that some function is a polynomial. Maybe we're able to apply the strong properties of fry to other crypto related problems. And we try to do this with polynomial commitment. This is the form definition. And what is going on? Proverb has polynomial, but he doesn't show this polynomial to us.
00:48:27.358 - 00:49:11.094, Speaker B: He just opens. He just gets the commitment to this polynomial. So we, as verify, may be sure that later this polynomial won't be changed. When verifier sees the commitments, he only knows that the proverb has some polynomial in mind. And moreover, the polynomial is of fixed degree. The degree of polynomial is bounded by some parameter taken in the top phase. Then, at related steps of protocol, we ask the proverb to open the committed polynomial at some point and debrify just open the evolution of the polynomial.
00:49:11.094 - 00:49:33.422, Speaker B: And he also sent us some proof of correctness, so that relator may check that this open is related to the committed polynomial cells. So it's quite simple. Next one. Yeah. What's this? Right in a commit?
00:49:33.486 - 00:49:40.118, Speaker A: In a sense. Oh, phi is just polynomial itself.
00:49:40.204 - 00:50:19.306, Speaker B: Yeah, we were speaking about polynomials of some fields. I think we don't have enough time to call a key commitments, which are just the main polynomial commitment schemes used in using all protocols. But what is the main point here? First of all, we're using some kind of fraction, and the fraction is the main thing that fry works with, which shows that this function is not really a rational.
00:50:19.498 - 00:51:17.474, Speaker A: You cannot just skip this part. This is the same technique which was applied in a fry, which basically tells, let's say you have the polynomial feed, and if d of I is the true value of this polynomial at this point, and this, well, if you subtract it, then you will get a zero at this point. And if it's a root, if this numerator has a root at this point, then you can divide it and get another polynomial, which is just taking less. This is a relation exploited by case commitment, and also because as a setup space, you kind of limit to what is the degree of deployment you can commit to. You can be quite sure that your initial commitment was actually polymer up to a certain degree. And after you do the division, you cannot commit to the racial function. Unless you broken some elliptical crypto, you could not do this.
00:51:17.474 - 00:51:36.250, Speaker A: And it means that later, at the opening space, you could also not face the proof and say, this is my commitment, this is my some value, this is my proof. If everything passes, and with the high probability, it was the true value of this polynomial for which you committed at this point. Otherwise, you have broken.
00:51:38.510 - 00:52:41.482, Speaker B: Property. Yeah. So the main thing that this parameter offer should not be known neither for commit to approval nor for verifier. And there are many zero note schemes such as blanc or sonic. The only one thing, the only one reason they require the trusted setup ceremony is because they are based on kit commitment. And so if we're able to replace kit commitments with something that requires only a transparent setup or any setup, then those commitment schemes, those zero schemes will be transparent by design. Okay, this is just the main protocol of pride based commitment.
00:52:41.482 - 00:53:37.006, Speaker B: I just want to explain what is going on. First, the commitment you at commit phase. We want to be sure we, as a verify, want to be sure that the function under commitment is a polnomial and not some just random set of values. And the commitment here is again oracle, as in Fry. And so we run one instance of Fry at commit phase to be sure that the function under commitment is a polynomial. And then we run another instance of Fry at open phase. But this time with respect to the fraction.
00:53:37.006 - 00:54:34.078, Speaker B: And again we are trying to show that this is phenomenon. I think we'll skip the proof. This is the main idea why this will work. But there is one important thing between the case commitment and the fry based commitment schemes. As I have told some minutes ago, Fry is unable to distinguish between polynomials and functions which are closed to them with respect to having matrix. So if we are not sure that our function can be state is not even a polynomial, which function will open later. And the thing is, this is our space of resolving codes or just low degree polynomials.
00:54:34.078 - 00:55:54.190, Speaker B: This is our function for which the grower gives normal access to this is just a circle of our function f. And let them intersect. A sample anomals the fact this our commitment scheme will only show that the opening. The opening which will be done at the open phase will be the value of one of these polynomials at the intersection. And there is one special case when delta is chosen to be the unique decoding radius parameter. In this case, if there are any intersection between our function and the space of polynomial degree, the intersection will contain only one point. In this particular case, we might think that the initial commitment of the proverb, but not to the function, but to that one point of intersection.
00:55:54.190 - 00:56:44.618, Speaker B: But when we're trying to apply our commitment schemes to real protocols, such as blonde, for example, we apply them to witness polynomials in blonde scheme. The verifier asks the proverb to open the value of witness polynomial. And we may think that any of the points of intersection our witness polynomials, it doesn't really matter. But there is one important thing. The next one. This is the proof, I think we'll skip it for now. This is the relaxed version.
00:56:44.618 - 00:57:35.390, Speaker B: The first proof was for unique division radius. And the relaxed version where the intersection contain more than one point. And here we want to show that the opening is related to the one of polynomials in the intersection. And another thing in plong, the kids commitment is not used only to open the values of witness polynomials. There the commitment is also used for speed up calculation of conceptual normals. What do I mean about the constraint polynomial concept? Polynomial encourage our problem. This is a polynomial that is known for both the approver and the verifier, but it is of very less degree.
00:57:35.390 - 00:58:58.002, Speaker B: And then the verifier asked the approver to send, to send the opening of this contract paranormal at some point, because he doesn't want to do a huge amount of late for normal flight degree. And when we speak about case commitment, we know that if commitment is received, then the opening of the commitment of the commitment is specifically normal. And we might just check that the commitment just is related to the contain polynomial. But in this case, there are several other polynomials to which the opens may be provided. And when we speak about contrast poles, this means that the proverb may send the opening to another constraint poll, which means that he sent the answer to another constraint system to another problem. This is the difference between weakness per normals and contain per normals. And so we call this problem evaluation problem, because there is no secret secret polynomial.
00:58:58.002 - 00:59:32.100, Speaker B: This is polynomial which is known for both sides and for which the verifier wants to get the opening, just to speed up, to reduce his complexity and so on. And the solution to the problem is the following. Okay, this is our space again with some more codes. Now we just. This is the top polynomial. It is a relative polynomial. So this is inside our space.
00:59:32.100 - 01:00:43.420, Speaker B: Then we take the parameter delta, and there are some other polynomials within delta registers, but delta is fixed at the surface. The polynomial is also known for both parts of the set of protocol. And so all other polynomials, or the points in the circle are known to both sides in advance. So we just take some point e, one with such property that the value of our fixed polynomial is different from the values of other polynomials in this circle f. And this will be f zero. Our construct will normal and always be just f one, f two, f n and e I. One is such a point such as f zero of I one is not equal to f five of I, one for every y greater equal than one.
01:00:43.420 - 01:01:19.010, Speaker B: That makes sense. And this is the replacement of the search of such a value z sorry, some kind of transparency task. This list may be huge. Decoding of all those polymers may take a large amount of time. The search at this point is also some work. But this is setup, which should be done only once. And this is fully transparent setup.
01:01:19.010 - 01:02:27.078, Speaker B: And there is no need for some secret parameters done in Kate commitment. And here in previous protocol, which is just opening schemes, we divide by just one line function. And here I one is just the point we took at the top phase. And I two is just the point which the verifier is asked to open the value edge and uxux is a function that is just interpolation. Lagrand interpolation function of those points with respect to values z one and z two. Once again, the tough place, the value of f zero at the one, the point which we try to open, and the value, the provided value of opening. And this is the only difference from polynomial committee scheme.
01:02:27.078 - 01:02:28.060, Speaker B: Any questions?
01:02:29.710 - 01:02:58.454, Speaker A: I think here I actually summarize it a little bit different than what I said. So it all comes to the problem about the polynomial relationship. Everyone knows the Schwartzbel, which tells you that if you want to satisfy, if you have the polynomial of certain degree, and at the random point, and this is very important, at the random point, the probability is that it will have the root is negligible in a large enough field, as you can see.
01:02:58.492 - 01:03:01.942, Speaker B: By the way, it's just deep root, because this point will be.
01:03:02.076 - 01:03:04.774, Speaker A: Yeah, well, in principle, if we go.
01:03:04.812 - 01:03:05.560, Speaker B: Back to.
01:03:08.730 - 01:03:57.954, Speaker A: Go all the way back to the start, in principle, let's say we have a way, this is deeper light protocol, which we didn't cover. But there is a way how we can. You can make the check with enormous soundness at a very useful price, if you do it as a round of points and fill, and you can do this. The problem is, as Kostia says, we work with in the price. If handle is the parameter delta, and if your delta is small, your proof size is large. If your delta is larger for the same sum, your proof size is smaller. So you really want to work with a large delta.
01:03:57.954 - 01:04:45.826, Speaker A: In Starks, it's not the problem if you take a large delta. There are some limitations actually, but let's skip it. You take a large delta, so you have this intersection. So in principle, as a random point, you can actually take any of those polynomials and pull the value for this one of those at the random point. And you can do it for everything which comes into this equation well, up to some certain extent. And the best case, how you can satisfy this equation as a random point is well, for one polynomial, you have this option as a random point. For another one, you have this option like this set of options, and you can pretty simply get some scare.
01:04:45.826 - 01:05:43.110, Speaker A: For this case, it will depend on the average size for each polynomial, like how many valid you can keep from these intersections, and the number of polynomials divided by field size. This is very simple, but in stark it doesn't matter, because even while you pull all those values, you actually satisfy every constraint, because constraints are known to the verifier as a setup space. So in stark verifier, you literally check every constraint. But this is quite hard. Limitations why? You have to optimize your constraints, you have to have them efficiently computable. In narcs, which don't work with layered circuits like Ros 16, everything which is r one cs plunk with another optimization sonic, with another recognization, they work with arbitrary circuits. So you have to encode your problems somehow to have the verifier.
01:05:43.110 - 01:06:37.420, Speaker A: Otherwise verifier will do the same, like apply every constraint which is linear work, or just relate some large degree polynomial, which is still linear work. But if we do it naively, we cannot use this, just naively use this case for constraint polynomials, because they're different, they're important. And if you allow this case in principle, let's say one of those points is your constraint polynomial. But nothing stops the proverb, the malicious proverb, from computing all other constraint polynomials. And maybe for one of those actual witness or a solution is trivial, it just sets of zero. So you cannot stop that, you cannot predict it up front. So in naive commitment scheme, you can only allow this case because you cannot allow the approver to cheat with just not picking from some set of values, but actually to picking another problem.
01:06:37.420 - 01:06:50.160, Speaker A: So for commitment scheme naively applied, you would have to limit the delta to this case, and this delta is equal to roughly one half minus something. This is not too large, but.
01:06:52.130 - 01:06:52.494, Speaker B: Some.
01:06:52.532 - 01:07:42.160, Speaker A: Certain town of heaprocytes would be larger than if you would allow this case. So now we have to eliminate, well, now we want to try to increase the delta. So let's say we work with this case, we need some kind of second chapter. In this case we say that go back to this equation. Well, in this case, what we have to do is we need to second boundary. So we do the second boundary as the setup as set in principle, since the problem is going to both proverbs the waifier, we can either do this trick with computing all of those polynomials which are at the intersection and like picking the value in a field where they are all different. So we can use this.
01:07:42.160 - 01:08:20.938, Speaker A: In reality we will not do this, we'll pick the random point. This is small number compared to the field itself. So the chances of any of those two have the same value as the rundown point is still negligible. So we can be quite sure that we picked well and prover cannot now change the problem. And after this we are okay with it. Well, back to this case because we know the problem now. So our constraints are fixed at the setup space where we came with proverb having some freedom of choice from set of values at the random point.
01:08:20.938 - 01:08:58.418, Speaker A: But still at the end of the day you will not be able to satisfy some linear relationship. Well similar to stars, but in plunk it's different, it's much simpler. At the end of the day you still will be limited by spartan program. Now since this part is no longer a problem, we actually got to the optimum. We got to the optimal for the soundless earth protocol for which we optimized initially. So now we can have the larger delta, potentially up to the limit on the right part. And this will give you the smaller proof for a safe found which you pick up.
01:08:58.418 - 01:09:08.170, Speaker A: This allows you to have full benefits of the price. But for every proof system we just use and depends on polynomial commitment.
01:09:14.690 - 01:11:18.950, Speaker B: The last thing now we have just Alex said the permanent commission scheme for witness for witness polynomials, the evaluation scheme with transparency chart for contractible normals and it can be applied for some zero knowledge schemes which encode both their witness polynomials and their contract polynomial and their witnesses and constraints polynomials and then just query their values at some point and check some polynomial relation between them. Just use Schwarz Zebel this is just exactly plonk where are you familiar with for example the constraint polynomials for Blanca, those selector polynomials q left, q right, multiplication, so on. And here just sending random values for simulation of interaction. But the final step of pond protocol is to check some relation between polynomials f one, f n which are constraint polynomials and fixed at the top phase which encode our just problem. And with this polynomial, for example, for simplicity, our constraint will be just the other product in some sense. And here at finite ten we use vardy klemma. If this relation holds, if it doesn't hold at one point, then with overwhelming probability it doesn't hold at the space.
01:11:18.950 - 01:12:00.046, Speaker B: So we just need to check this relation at one point. And for this we use the commitment scheme to open the values of witness polynomials at some point z of our choice and use the relation scheme to open the values of classical normals at the same point z. Just speed up the calculation of f from the preface point of view. And then you just check the relation. And that's it. It seems like to be the last one. It seems like we achieved our goal, which is system, which is full transparent.
01:12:00.046 - 01:12:28.300, Speaker B: Okay. The top is large, but we search for the point d, but nevertheless, it's transparent. It's succeed, because the clone itself is succeed. And as we replace our commitment scheme by fry, which works in interactive oracle proof model, which uses just hashes and some theoretical information constructions. It is quantum resistance. It has quantum resistance. So that's it.
01:12:28.300 - 01:12:30.006, Speaker B: Any questions?
01:12:30.128 - 01:12:34.702, Speaker A: Yeah, you forget to mention that there's principle recursive. Yes.
01:12:34.756 - 01:12:47.694, Speaker B: And then when we are not bound by any parameters entrusted up. So we may take as many levels, levels of recursion as we need for.
01:12:47.732 - 01:12:48.750, Speaker A: Our aids.
01:12:51.810 - 01:13:12.460, Speaker B: For our purposes. You it. I didn't get the last thing. And how does it differ from the problem?
01:13:14.430 - 01:13:36.570, Speaker A: It's not a proof system. First of all, we don't try to make a proof system. It can be used for any proof system, which depends on colonial commitment. Okay. It just allows you to take any proof system, which depends on polynomial commitments and which helps encode constraints or the problem itself as a polynomial, and allows to apply this technique.
01:13:36.730 - 01:13:43.018, Speaker B: Okay, so tell me for the implementation. For the implementation. Well, you can build it transparent.
01:13:43.194 - 01:13:55.718, Speaker A: Yeah, you can take it longer. The. Well, it's a proof system. It tells you invitation and it just is based on the fact that you can commit to the polynomial and open it as a random point. Especially at the random point.
01:13:55.804 - 01:14:10.578, Speaker B: It's our reference system we have in mind when we're trying to apply for the take long and to replace the kid commitment, which requires trust by new commitment and evaluation. How does it impact that runtime?
01:14:10.774 - 01:14:50.934, Speaker A: We need to verification time is even below parent. I mean, should be. What do you mean for runtime verification? Approving both for now. For incomplete proverb, I think. Zach, I'm just twice slower than yours, but should be optimized to the same level. Yeah, it should be the same speed. Because here for Fry protocol, you have to do lowest degree extensions of the polynomial, which means that you just take the degree n and you have to calculate f of t of the size, like 16 n, which is a large share.
01:14:50.934 - 01:15:12.010, Speaker A: But it's only like now it's already less than 50% of the work. The rest of the work is just actually a lot of hashing. Hashing is still not free. It's fast that it's still not free. So yeah, it should be on par. And for verification, we will see what will be the master smart. Now it's also freedom of choice.
01:15:12.010 - 01:16:03.390, Speaker A: If you want to be transparent plus recursive, you can use this if you don't need recursion, and I mean, if you already have the trusted setup in terms of powers of tau for case commitments, you can just take those and if it's good for your problem, you can use it. It's now a freedom of choice. I'm not even talking about exotic instructions where you can use the transparent part of the transparent one as bottom levels of recursion, and then you can do the final one with kit commitment, because now you don't have a problem with curve cycles for snarks, that's parent curves, because here everything wants the field, and the only requirement for filled is high two, etc. Which is already a requirement for kind of everything for polynomial relationship and with approved systems over parent transcripts.
01:16:05.990 - 01:16:08.130, Speaker B: What do you mean a transparent?
01:16:08.710 - 01:16:37.420, Speaker A: Transparent means you don't have any trust set up for case commitment public. Yeah, well, case commitment, those values also should be unknown, so we can treat it as unknown variable. So you have to produce those somehow. Now we know there are ways and efficiency monitor. You can produce it and it's still universal. It's not for a circuit process, because it's only commitment. Commitment is universal, but still, it just requires you to cut out.
01:16:38.430 - 01:16:57.390, Speaker B: It also limits you to a certain size of the circuit. The case setup is linear in the size of the circuit. So if you want to do a really huge circuit like, you need to score all of these parameters, which the constant size setup.
01:16:57.810 - 01:17:29.066, Speaker A: Yeah, well, just for example. Well, now you have a freedom of choice of the field, so you can get your multiplicated domain of the enormous size up to some limit, of course. But here there is, well, certainly the practical limit on the size of the k commitment for polynomial, to which you can commit both in terms of the storage of the parameters, and if you're in a framework of some polynomial relationships, usually you are also bounded by the multiplicative subgroup size, like for a number.
01:17:29.088 - 01:17:29.814, Speaker B: Of fruits of unity.
01:17:29.862 - 01:17:30.902, Speaker A: So fulfilled.
01:17:31.046 - 01:17:40.160, Speaker B: Final remark, by the way, you may replace Kate commitment in Poland like systems by dark commitment. Yeah, pretty much the same thing.
01:17:40.850 - 01:18:02.840, Speaker A: Yeah, because it's commitment scheme and plonk only depends on the commitment scheme. If you take one and it relates with another, it's just a freedom of trade now it just should be succeed. If you want to work at least with a serial smart contract as a verifier yeah, thank you.
01:18:03.770 - 01:18:07.880, Speaker B: Just give us an idea of what the proof sizes would look like.
01:18:08.650 - 01:18:57.058, Speaker A: Yeah. For original commitment scheme, where we wouldn't allow, where we would require the uniqueness, I think I estimated for 228 colonial percent, like 68 kb, without some strong optimization. For reliable, for unique decoding radius restrictions should be 68. In a kind of worst case, without optimization. I cannot give a number with optimization, because I have to try two in a 28. Yeah, in the case, if we can use this trick with evaluation scheme for set up loan normals, it should be reduced like five to six times. It should be 20 kb limit, without optimization.
01:18:57.154 - 01:19:09.930, Speaker B: And by the way, maybe there is even no need to find such a point z for ablation keys. Maybe we may just say that this is kind of schwantzel.
01:19:10.590 - 01:19:12.102, Speaker A: So it's the setup of the safe.
01:19:12.166 - 01:19:18.558, Speaker B: Probability argument here on this side is.
01:19:18.564 - 01:20:00.700, Speaker A: What allows you to do recursion, right. For recursion, the only thing that matters is the circuit size of your last verifier, because it's the only step which will be publicly verified. For everything else, you kind your proof sizes in a private liquid. So, while the verifier circuit will depend on the use of the hash function, or like how you make a transcript for the full procedure. But I estimated like 223 to four polynomial maximum. So it should be a little smaller. Well, recursion gives you the trade off between the size and like how much part you want.
01:20:00.700 - 01:20:11.580, Speaker A: Okay, I think it's just time, because it was a long session, you should have a larger break. But yeah, thank you.
