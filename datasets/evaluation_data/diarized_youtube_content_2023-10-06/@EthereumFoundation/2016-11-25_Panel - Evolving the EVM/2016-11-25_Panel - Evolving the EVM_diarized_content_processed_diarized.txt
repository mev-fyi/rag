00:00:18.410 - 00:00:32.600, Speaker A: So I am Greg Covid. I work mainly on the C plus plus EvM. Louder. I work mainly on the C evm. This is my friend Martin, if you want to introduce yourself.
00:00:33.690 - 00:00:42.570, Speaker B: Hi, I'm Martin Bizzi. I'm working on prototyping ewasm, and I also work on Ethereum js.
00:00:47.230 - 00:01:04.990, Speaker C: Hi, I'm Pavo and I'm working on a small project called evmjit. It's kind of just in time compiler that translates EVM bytecode into machine codes using LlvM projects.
00:01:06.050 - 00:01:18.070, Speaker D: Hey, I'm Christian Reitwisner. I'm the team leader of the c implementation, and I'm also working on solidity, which is basically the main user of the Ethereum virtual machine.
00:01:19.050 - 00:01:32.390, Speaker E: Hello, my name is Alex Brexassi and I work with Martin on Ewasm as well as with Christian on solidity. And I'm really interested to improve both Evm one and the replacement of it called ewasm.
00:01:34.110 - 00:02:05.330, Speaker A: So what I wanted to do this morning is everybody got working so fast, approaching the conference, getting things done, to talk about that, I could no longer keep track of anything but my own work. So I would sort of like to just hear from people what they've been doing the last few months and what direction they intend for that to be heading in. Shall we start with Martin?
00:02:05.750 - 00:02:25.980, Speaker B: Yeah, sure. So the last couple of months I've been working on something called EVM to WASM, which takes EVM code and transcompiles it to webassembly. And we are now passing all the virtual machine tests and the official test repository. And we also have an online demo if you want to check it out.
00:02:27.870 - 00:02:30.090, Speaker A: What is a transpiler?
00:02:30.990 - 00:02:55.650, Speaker B: It's a good point. So we have two types of bytecode. We start out with ethereum virtual machine bytecode. And we want to transform it to a new type of bytecode, webassembly. So the trans compiler, you can think in math terms as a function that maps this one input evm to a new output, webassembly.
00:02:57.030 - 00:02:59.410, Speaker A: And why webassembly?
00:03:00.470 - 00:03:47.640, Speaker B: The interesting. Okay, so webassembly is a new binary format that's designed and be targeted for the web browser. The interesting properties that has no ever interested in it is it's very fast and efficient, it's portable, it's size efficiency, so easy to compress, easy to load. And it also has most importantly built in. It's designed to run the web, so designed to run in untrusted environments, and that masks closely to what we're doing.
00:03:52.410 - 00:03:53.480, Speaker A: Who next?
00:03:54.810 - 00:05:03.006, Speaker C: I can be next. So the EVM Jit, that ethereum virtual machine implementation I'm curing of. It's fully compliant with the EVM from the launch of the Ethereum. But the problem I was trying to solve for about a couple of months is how to bring this implementation to other clients. So what I was working on is a new C language interface for Ethereum virtual machine in general, what we call EVMc. And it's like quite simple C interface. Then you can pack your VM implementation with and bring it to other projects that might be interested in.
00:05:03.006 - 00:05:29.350, Speaker C: So just before the conference I was able to plug evmjit to Python client. It's still syncing the blockchain, but I hope it can finish during this conference. And yeah, so I'm not focusing on optimizing the execution time, but mostly to bringing my project to other projects.
00:05:30.730 - 00:05:41.706, Speaker A: So we now have a plug and play interface for both the C execution engine and a Python execution engine.
00:05:41.808 - 00:05:59.310, Speaker C: Yeah, that's right. So the C client and Python client are able to use the same interface for evmjit to be operational on the blockchain. So it's still experimental, but it's very promising.
00:05:59.730 - 00:06:01.120, Speaker A: That's really cool.
00:06:03.090 - 00:06:30.890, Speaker D: So basically the idea is to have a common interface between the client and the virtual machine, and in the end be able to swap different virtual machines. And we're also planning to refactor the C plus plus interpreter to use exactly the same interface. So you could seamlessly swap between just in time compiler and the interpreter. And you can use the interpreter with all client implementations that support that interface.
00:06:33.650 - 00:06:35.760, Speaker A: Very nice, very nice.
00:06:37.970 - 00:06:39.040, Speaker C: Like this.
00:06:43.810 - 00:06:59.362, Speaker A: Whoo. Rock and roll. That will be at the party later. I have to go buy a guitar, if anybody knows a good place. What else?
00:06:59.416 - 00:07:01.754, Speaker C: Here. Alex?
00:07:01.822 - 00:07:41.540, Speaker E: Is it me? All right. Yeah. You will learn about ewasm later on. It will be the first presentation today after lunch, and I invite everyone to listen to it because it will be very interesting. But I can tell you upfront a few details which connects to this panel that mostly we have been working on two different things. First of all, as Martin has mentioned, WASM is a different bytecode. So we need multiple languages to compile code to this bytecode because you don't want to write bytecode by hand, and secondly, you want to run this bytecode on something.
00:07:41.540 - 00:08:11.710, Speaker E: On the language side, we have been working on getting C and solidity ready, and we have written a lot of contracts in these languages already for Wasm and on the VM side, actually, we are really grateful to Pavel and his work on EVMC, because we have implemented a Vm on EvMC, and that means Ewasm can be used with Cpluxus Ethereum without any major changes. Thank you. Pavel.
00:08:13.090 - 00:08:16.400, Speaker A: Why would you want to write contracts in C?
00:08:17.650 - 00:09:06.734, Speaker E: You don't really want to write contracts as an end user in C, but there are certain contracts which probably make sense to be written in C, and I don't really want to go into a lot of detail. You will see a bit more in the presentation. But just think about the precompies. We already have the four precompies like ShA two, five, six, ripe MD 160, and easy recovery. You want those to be written in a highly efficient way, and those should be included by all the vms, and you don't really want to have them as a pre compile anymore in the future. So those are written in C right now, and they are limited set of code which you can much easily verify. I wouldn't advise anyone to write like a really complex contract in C unless they know what they're doing.
00:09:06.932 - 00:09:09.920, Speaker A: The solidity is hard enough, it turns out.
00:09:11.010 - 00:09:11.710, Speaker E: Yeah.
00:09:11.860 - 00:09:24.920, Speaker D: The thing is also that a lot of code already exists in C, especially cryptographic libraries. They are already in C, they have been tested, they are working, and if we can just take them without modification, that's great.
00:09:25.370 - 00:09:31.910, Speaker A: Bobs of crypto code is written in C and well long since well tested.
00:09:33.290 - 00:09:37.850, Speaker E: That's the assumption. That's the assumption that they're well tested.
00:09:41.310 - 00:10:38.540, Speaker A: It's not always a good assumption when people complain about solidity being too hard, though. I point out that most of the world's most reliable software has been engineered in c. Most of your paychecks probably come out of an oracle system which was written in c, so that in the end it comes down to engineering discipline more than anything. So I really think the eVMC interface is really a powerful idea that's going to help us quite a lot in pulling together the different work, providing the diversity we've talked about without.
00:10:40.370 - 00:10:41.642, Speaker E: Speak up, Greg.
00:10:41.786 - 00:10:55.540, Speaker A: Without balkanizing the work. We can have a diverse number of implementations of Ethereum without them being in separate silos that can't run together, that can't talk to each other.
00:10:57.350 - 00:11:23.850, Speaker C: So I think you can even do more about that, like having multiple implementations of VM itself. You can build quite complex strategy of that. I mean, you can decide upfront which implementation you want to use for this particular code, or just select them randomly to avoid any crashing.
00:11:25.150 - 00:11:26.220, Speaker A: How's that?
00:11:27.070 - 00:11:34.960, Speaker C: You can implement like some kind of vm that actually composites other VM behind it.
00:11:36.450 - 00:11:46.718, Speaker A: So is it going to be part of DVMC interface or at a higher level that you do things like start out with an interpreter?
00:11:46.814 - 00:12:00.390, Speaker C: No, you can use the same interface for higher level. Like you can write a vm that compose other vms but still exports the same interface. Evmc.
00:12:01.130 - 00:12:24.080, Speaker A: No, I mean like typically you start out running an interpreter, you notice the hotspots, you hand those off to a jit for faster execution. You may do the compilation on a separate thread because it could take a while. Is that part of the interface or will that be a level up?
00:12:24.450 - 00:12:28.190, Speaker C: It's all possible with this eVMC interface.
00:12:29.170 - 00:12:49.814, Speaker E: Okay, so basically the interface only defines the entry points and the way the vms can ask for data from the blockchain. And that's very generic, and it only gives you the bare minimum you need. Because of that, you can compose multiple levels if you wanted.
00:12:50.012 - 00:12:59.114, Speaker A: So the composition would be at another level. If we wanted to. We could abstract that, but we haven't yet.
00:12:59.232 - 00:13:12.062, Speaker E: No, it works on the same, it works on the same level because basically you just get in the contract to execute and then you can initially run it as an interpreter if you wanted, and you can change it over.
00:13:12.196 - 00:13:22.050, Speaker A: Right. So what's the timing on this? I'm always asking, and it's always fuzzy and changing.
00:13:22.630 - 00:14:16.350, Speaker B: Yeah. So for Webassembly specifically, it depends on the WC three working group, but as it stands now, it's implemented in all the major browsers, and it's on the twelveth revision of prototype. So I think it's getting pretty close. I would expect it in 2017 to finalize the spec. After that, then we can move on to finalizing our EEP. As we stand with the prototype, we have most of the major components implemented. Next big thing we're going to be pushing out is a test network, once again brought to us by, facilitated by EVMC, since we can just drop the wasm jit earner interpreter into all the other clients.
00:14:16.350 - 00:14:18.660, Speaker B: So that's pretty cool.
00:14:19.190 - 00:14:28.310, Speaker A: That's great fun. Have we used up our 20 minutes yet? You have six minutes left. We have six whole minutes.
00:14:28.460 - 00:14:29.526, Speaker D: I have a question.
00:14:29.708 - 00:14:35.320, Speaker A: I cannot see anything but the most blinding white lights I've ever seen in my life.
00:14:37.130 - 00:14:40.390, Speaker B: Did you want. We'll let you know about security, Christian.
00:14:40.830 - 00:14:58.766, Speaker D: So the original EVM was designed from the ground up to have fixed bounds on resource consumption, and these bounds should coincide with the gas usage. What do we know about existing ewasm implementations in that regard?
00:14:58.948 - 00:15:57.810, Speaker B: Okay, so regarding security in the virtual machine, I think the number one biggest security issue though is the trusted computing base, and that's continually expanding with every pre compiled that we add. So the point of webassembly from a security perspective, and it is from security perspective, is to minimize the overall trust in computing base. Now security from the metering perspective is done by EVM to wasm or sorry, it's done by metering injection. So we can do static analysis on the code to find. It's very well delineated in Webassembly flow control. So it's easy to do static analysis on the flow control and inject metering statements at the beginning of each possible branch condition that will meter it. The same applies to memory usage.
00:15:57.810 - 00:16:55.650, Speaker B: The gas model and the memory model as far as metering is going to work the same way with the added benefit that it's decoupled from the EVM by default. So we have a nice separation of concerns there. And I think that also provides extra security because we can think about these two components separately. Now we can think about, okay, here is our metering injection algorithm. We can examine that and then we have a separate team or separate module altogether, examining and looking at our trusted computing base, which would be the Wasmvn. So twofolds there, minimizing the trusted computing base I think is the biggest, lowest hanging fruit, most bang for the buck, right, as far as increasing security in our network.
00:16:57.030 - 00:17:04.390, Speaker D: But do we know whether, for example, memory will probably be paid with regard.
00:17:04.460 - 00:17:05.080, Speaker C: To.
00:17:07.210 - 00:17:23.438, Speaker D: The virtual memory of the virtual machine and not with regards to the memory of the actual physical implementation? I mean, it's easy for memory because it probably won't scale quadratically, but there could be some other edge cases that could hurt us at some point.
00:17:23.524 - 00:17:54.418, Speaker B: So yeah, the memory is very explicitly allocated with webassembly. You use expand memory and there's initial memory allocation. So the program declares up front in the binary format. Okay, we're starting with this amount of memory. Here's what we're going to have in memory. So it's actually kind of like an elf format if you're familiar with how l format initializes programs. And then whenever you need more memory there is an opcode, expand memory.
00:17:54.418 - 00:18:02.250, Speaker B: So it's very clear where all the memory expansions can happen. And yeah, that's where we inject our metering.
00:18:05.150 - 00:18:09.210, Speaker A: Opcode. Like the s break, an old Unix.
00:18:09.650 - 00:18:12.974, Speaker B: I'm not familiar with that. Yeah, you have to tell me about that.
00:18:13.012 - 00:18:50.666, Speaker E: It is similar to that. Okay, Sbrk, just a quick note on the metering part. So it's entirely decoupled. From the execution time, we have the input bytecode, which doesn't have metering because we don't trust the input compilers. So anyone who compiles ewasm, we don't really want to trust them to include metering in a correct way. So when it gets to the execution time, we will inject these metering statements into the right places in the bytecode. And during runtime, there's no need to do anything special.
00:18:50.666 - 00:19:07.470, Speaker E: All those metering statements are just calls to a specific function. So this kind of works like how a Jit works, like the LLvm Jit we have for EVM, but we do this upfront before execution, so it should be much faster.
00:19:08.210 - 00:19:15.106, Speaker B: And another interesting point, Greg. So you were thinking about doing the metering in another thread, correct? Right.
00:19:15.208 - 00:19:21.054, Speaker A: Yeah, I don't think that's going to work. Well, it would work, but I don't think it's going to be any faster.
00:19:21.182 - 00:19:21.860, Speaker B: Okay.
00:19:24.410 - 00:19:57.360, Speaker A: That is, it would save time on the very most expensive instructions, which cost enough that it's not worth saving time. And on long runs of just doing addition and multiplication and arithmetic, you're not going to save enough to bother, especially if you're going to push all of that to the end of a basic block. But like doing a call cost enough, that's saving a bit of time. Doing the metering on the call.
00:20:01.410 - 00:20:22.500, Speaker B: I just going to say we sort of can do that now. It's a little bit hacky, but we sort of get the separation concerns for free, because whenever we call out to the interface to do the metering, that's going to be possibly running on a separate thread. But I don't know how much that's improving our performance either.
00:20:22.870 - 00:20:24.690, Speaker A: How cheap are your threads?
00:20:25.510 - 00:20:36.794, Speaker B: Right now we're using v eight to prototype, so we get eight threads by default and they're allocated when it starts up. So they're fairly cheap. Very cheap, actually.
00:20:36.992 - 00:20:42.794, Speaker A: Thanks, guys. Thank you very much. Thank you all. Thank you very much.
00:20:42.912 - 00:20:43.320, Speaker E: Thank you.
