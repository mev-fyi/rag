00:00:05.480 - 00:00:25.820, Speaker A: I'm Chris. I work for Tenement Research, and I'm going to talk a bit about and I'll explain what the terms mean. Don't worry. Inter, blockchain communication, and the topology of the interchain. The polycentric interchain is already here. Let's unpack this. In the past few years, we've seen what I like to call a Cambrian Explosion of blockchains.
00:00:25.820 - 00:01:18.580, Speaker A: It's continuing even more. Several new protocols were announced at this event. One hypothesis says that these blockchains will be selected out and slowly converged to a few single ledgers which handle all of the state transitions, all of the currency transactions, all of the future complex decentralized financial protocols, et cetera. Perhaps. But another hypothesis says that the interchange will continue to branch outwards, that new protocols will continue to be built which can specialize on different sorts of use cases, that new assets will continue to come into existence, that assets and protocols will perhaps dissociate somewhat where an asset can retain its logical identity while living on a different and perhaps improved protocol. That's what I mean by the interchange. This set of ledgers fulfilling a set of different use cases.
00:01:18.580 - 00:02:31.160, Speaker A: Why might we want this? There are a lot of advantages to having separate blockchains as opposed to a few single ones. One advantage is versatility. Different protocols can focus on different use cases. They can optimize their state machines, optimize their educational materials, focus their community, focus their onboarding focus their user experience on solving certain specific problems really well, as opposed to solving a lot of problems not so great. This applies not only to the case of simply building a protocol, but also to the case of governing it over time. If a single protocol has to cater to a wide diversity of use cases, all of the interests of different users who probably want different things and for whom the protocol moving in different directions would be better or worse at different times, have a hard time agreeing on how to change a protocol over time. That becomes much easier if a use case is more focused, if they can choose to focus their particular protocol on solving one particular problem, and if they need a new problem, build a new protocol.
00:02:31.160 - 00:03:23.284, Speaker A: Another thing which I think is really important and sometimes underemphasized, is minimizing exit costs of distributed ledgers. Right now, many of us, I think, would consider the exit costs of centralized platforms, particularly those which control information, to be too high. But one of the reason the exit costs of Facebook or Twitter or Google suite are so high is that there's no possible interoperability. If someone builds a web client which allows you to access your Gmail data, google will sue them or shut it down or prevent API access. I think we should have the same concern and the same desire to minimize exit costs for ledgers. And that means continued asset interoperability. So hard forks can be contentious when they necessarily diverge, when it's not possible for users to continue to use both protocols at once.
00:03:23.284 - 00:04:25.228, Speaker A: But if hard forks could instead be reconstrued under a new mechanism where two different versions of a protocol can continue over time, then people could use one version, retain their asset. Other people could choose to switch the new version and retain the same logical continuity, moving their assets to and from the original protocol. But in order to do all of this, we need a way for these different blockchains in the interchange to talk to one another. This way, or a way that we've been developing, is IBC InterBlockchain communication. IBC is a messaging protocol for the interchain, a general messaging protocol. Let's go back in time a few decades to the early Internet, when some similar problems were being solved. Different machines, and often different sort of localized clusters of machines existed in different places around the world, particularly in ARPANET, around CERN, in universities in the United States and in Europe, and later across the world.
00:04:25.228 - 00:04:54.296, Speaker A: And those computers needed a way to talk to each other. This was obvious. Many people built protocols to allow these computers to talk to each other. And some of them I listed on this slide. So we'll have a quick quiz. Raise your hand and keep it up. If you've heard of XNS, not too many AppleTalk, a few Chaos Net, IPX, SPX IP should be just about everyone.
00:04:54.296 - 00:05:25.276, Speaker A: If you came to this conference, you bought a ticket using the Internet Protocol. Almost certainly. Why? Why were what four of these protocols, and there were tons more, which I didn't bother to list. Why were four of these protocols unsuccessful in connecting all of the computers while one was? I think there are a few reasons. One is that the Internet Protocol was quite general. It wasn't specific to a manufacturer or specific to somewhat closed hardware like AppleTalk. It didn't rely on particular network cards.
00:05:25.276 - 00:05:58.232, Speaker A: It wasn't encumbered by patents. It was something where anyone could read the open source protocol standard, or what was open sourced in that time and implement their own hardware which supported it. Protocols like some of these, and especially IP, are non contentious. The Internet Protocol has a monopoly. There are no other Internet protocols. But it's a beneficial monopoly or a benevolent monopoly, because using the Internet Protocol doesn't prevent anyone from supporting other protocols. It doesn't lock them into a particular token, a particular infrastructure.
00:05:58.232 - 00:06:41.032, Speaker A: They just speak this particular language at the edge where they connect to other computers. We need something similar for blockchains. What does this mean in the context of blockchain interoperability? How do we build this kind of protocol which can fulfill this non contentious global standard? Requirement one, it needs to be modular. This communications protocol needs to abstract over the different methods for verifying state of other blockchains. It needs to enable needs to create a standard such that blockchains can check the other blockchains sent messages. Two, it needs to be local. This stands in contrast to a lot of Sharding protocols, which are interesting.
00:06:41.032 - 00:07:20.528, Speaker A: They solve a different problem. But Sharding protocols tend to require a global topological view. They require that one entity in the set of chains, usually a root chain, a root Shard, it's called different things. But one entity in the set of chains has a view at all times of what the other shards are, what they're doing. It knows some sort of assignment, and it can reason about the security properties of that system because it knows what the topology is. For IBC, we don't want to require this. We want to allow the topology to exist amorphously as something that no chain in the system, no chain in the interchain has to know or reason about in order to use the protocol safely.
00:07:20.528 - 00:08:00.752, Speaker A: That's what we mean by locality. And finally, this messaging protocol that we create needs to be composable. People need to be able to reason about the security properties of simply sending messages and receiving messages, just like you could reason about how you send and receive in TCP IP. And then using those properties, they need to be able to reason about the distalt properties of complex systems which use those simple components. That's what we mean by composability. To do this, we've built a layered protocol similar to the OSI model of IP. The first set of layers is called the Tau, or I like to call it the Tau of IBC transport, authentication and ordering.
00:08:00.752 - 00:08:53.696, Speaker A: The Tau of IBC handles getting data physically using off chain processes we call relayers from one blockchain to another, or one ledger to another. It handles authentication, creating a standard for how different ledgers can authenticate summaries of each other's consensus processes and use those summaries to check that particular packets were sent or received or not. And it handles ordering, getting packets when desired to the destination in order and exactly in order. I'll have to summarize briefly over this protocol stack, so I think I will just use a picture. Consider an IBC packet between two chains in the protocol as written. At the moment, we have this entity called a module, which you can understand as being an independent unit of execution running on a ledger. So this will map to different particular abstractions and different blockchains.
00:08:53.696 - 00:09:21.564, Speaker A: In the case of ethereum, it will map to a smart contract. In the case of the Cosmos SDK, we call it just a module. In the case of substrate, I think it's also called modules or packages or something, but the concept is the same. So a module on blockchain A will send an IBC packet. That's number one. It will head to number two, the IBC module, which will interpret that packet, determine how to route it. The IBC module will then store it in state, the consensus algorithm of blockchain A.
00:09:21.564 - 00:10:28.130, Speaker A: That's three will then commit that transaction, commit to a state route a relayer that's number five will watch Blockchain A, figure out that an outgoing packet has been sent, then send it onwards in an incoming transaction to Blockchain B. When the transaction is accepted on blockchain B, that's number seven, the packet will be routed to the IBC module number eight, on Blockchain B, and the IBC module on Blockchain B will parse that packet, decipher it, determine where it needs to go and send it on to Module B. So all of the packet send, packet receive timeout handling, all of the basic primitives we build in IBC follow this structure. And the key part that I would emphasize is that it's quite generic. The blockchains and Modules need to have the ability to verify each other's state, but otherwise the trust model between these two modules, module A and Module B, is similar to the trust model between two Ethereum smart contracts. Module A doesn't need to reason about any of the other Modules running on Blockchain A. Module B doesn't need to reason about any of the other Modules running on Blockchain B or Blockchain A.
00:10:28.130 - 00:11:38.344, Speaker A: They can simply, once they establish this secure communications channel between each other, send and receive packets and reason about this local system. Everything contained on this diagram is sufficient, the understanding of it is sufficient to reason about the security of IBC. What needs to come next, we're calling the application layer. This is a little analogous to ERC standards in Ethereum standards for Call Data, we've built IBC to be payload agnostic, such that when packets are relayed, sent around, verified, handled in timeouts by the protocol, the protocol implementations don't need to understand what the data in those packets mean. That only needs to be understood at the edges, needs to be understood by the module sending or receiving these packets, dealing with how they should be interpreted and what the semantics of particular packet data are. In order to standardize this across the ecosystem again in a non contentious fashion, we will need a set of application layer, packet encoding and semantic standards. Some of these can probably build off.
00:11:38.344 - 00:12:28.472, Speaker A: Some of the work with Ethereum is done with ERC standards for call data. Between contracts, we hope to collaborate as much as possible. Some of them will probably be different, opening up different use cases in things like cross chain account abstraction, which someone recently submitted a pull request for to the IBC spec repository, which allows an account on one chain to control the actions to send transactions on behalf of an account on another chain through IBC. Simple packets, of course, like token transfer, similar to ERC 20. The semantics are a little bit different because you're actually transferring tokens between two blockchains, so you need to account for supply. But Call data is similar. More complex use cases we expect will emerge over time, including things that look like sharding but are architecturally a little different.
00:12:28.472 - 00:12:59.200, Speaker A: If you have mutually comprehensible VMs on two different chains, you can relay code between them through IBC. And you could use this alongside an algorithm for determining how to relay code over time. Maybe some sort of load balancing. You could use this to create protocols which look like Sharding, but they still have this local security reasoning. You only need to reason about the blockchains you're directly talking to over IBC. No one needs to reason about the topology of the whole network. All of this work is online.
00:12:59.200 - 00:13:20.464, Speaker A: You can find it@github.com. Cosmo ICS. We recently released released candidate four of the IBC spec. I would stress that it's not done. We are waiting on a few auditors to get back to us. And of course, welcome any feedback or questions. Trying to test with several possible blockchains which aim to utilize IBC.
00:13:20.464 - 00:13:41.710, Speaker A: But it is definitely in a state where you can read it and understand what we're trying to achieve with this protocol, why it fulfills the design criteria of modularity locality and composability and how you can get involved and help. So please do. You found a star. Thank you.
