00:00:19.290 - 00:00:44.874, Speaker A: Awesome. All right. Because maybe some of you saw my talk yesterday. Today we will kind of make the next step. And for this, it's a good thing that we're not too many because I would love this to be a little bit of a seminar. If you have questions, chime right in. You feel like anything was glossed over too fast.
00:00:44.874 - 00:02:21.094, Speaker A: Happy to step back and explain this because in the end, we want to try to make forward in the development of the whole thing together so that I'm not just going to be reporting on where we are, but hopefully trying to find out what might make sense for the next step. However, getting started, I would like to, just for the benefit of those haven't been there yet today or have never heard of the project before, like to start at the top, give you a little bit of a presentation, walk you through what excellence and what the vision behind the whole thing. Um, basically, yeah, we have, we have a situation right now where we're at the phase where Dahu even said that smart contracts are not necessarily meant to be confident. They have a different focus, or at least that was the focus of the beginning that he had. And now that we're coming to a point where we are in a more mature environment than we had before, we should also be exact about what smart contracts, what smart contracts actually are, what they should use. And we have Vitalix on record who's basically saying, well, I kind of regret I haven't called the smart contracts. Maybe we should have just called them store procedures, something like that.
00:02:21.094 - 00:04:15.710, Speaker A: And blood actually signed it. I'm actually happy to take out the mantle that they are dropping where they're saying, okay, maybe smart contract was not such a good name for it and explore what is possible actually with programs that are running on the blockchain and have certain features and get into the mood and hopefully switch, notoriously difficult to switch out of these presentations. I'm sorry, what to start out, what I think is a bigger discussion here than maybe even discussion on blockchain and smart contract. And to set the tone a little bit, I would like to try to give you a it sounds in here, but we'll do for you because we don't have sound. Maybe I don't think to it, but I can explain a little bit what it's about. Obviously, human brain, we have 16 billion cores and they're all working in pro, right. So what we have now, even if you look at, depending on how you count how many nodes, how many full nodes there actually are, blockchain world out in Ethereum out in bitcoin.
00:04:15.710 - 00:04:59.420, Speaker A: It's something that, of course, has nothing to do in scale with what is going on in the real world. The biggest computers at this point have 10 million, and that's actually only. Hey, hello. Come in, come in, guys. That's fine. That's the most advanced 10 billion for 16 billion in every single brain on the planet, 7 billion times. So we have to ask how much power we want to decide what we can expect from intelligence program or whatever it is.
00:04:59.420 - 00:06:03.154, Speaker A: The more so, the more we allow them to start becoming forces that rule our life, at least become a pretty big part of what our lives are. And of course, we have to ask whether. Hey, hello. Thank you guys. Good to see you guys. So I think where this actually is going is this tool that has its start, no doubt, on the blockchain might be the tool that we will need, particularly the robotic world everybody knows from animals, where we will have to find a way as a society to talk about and then also to make laws about what robots, specifically autonomous robots, should be allowed to do. And this is something that also, if we go beyond the bubble that we are all in here, right? And it's wonderful to see all these familiar faces and so on.
00:06:03.154 - 00:07:05.602, Speaker A: But a lot of people who care about things, and they do care about these kinds of things now that were not maybe on the forefront of everybody's thinking when Ethereum started. But meanwhile, Facebook is not really considered a force for good anymore. Nobody's laughing anymore. When Google says do no evil, you remember what's the matter, right? But this awesome conversation yesterday about the difference and what is going on in the, and how important it might be to have illegal concepts and forces in the blockchain world. And I was finding that actually it's perpendicular. It's not really the same dimension that we're talking about. Nexon is not really about trying to be an alternative or do something else, or Nexon is just proposing something else.
00:07:05.602 - 00:07:48.000, Speaker A: But here's something I learned when I was in the army. The rules are actually protecting the wheat. And the more you might feel like you don't need no rules, you're just being hampered by rules. Well, maybe it just means you're pretty strong. But I think my favorite is that when we talk about society, I don't see a 1% problem, I see 10% problem. And that is the 10% that most of the folks are in who don't have too much contact with 9%, who are not as privileged as we are. And that probably means that we can present in this world.
00:07:48.000 - 00:08:22.310, Speaker A: So, yeah, coded law, maybe the powerful are laughing about it, right. It's becoming interesting nuances in that. Interesting thing with the DAO was actually, it was coded law. And then the code had a bug. And then all of a sudden, you didn't only have code. Code is law, the spirit of law, the spirit of a contract. But all of a sudden you had the spirit of the code because that was what the TaO was actually meant to do, but didn't.
00:08:22.310 - 00:09:09.610, Speaker A: But everybody understood what that was. And so the decision was about, okay, do we now try to define what the spirit of the code has been? And yes, obviously that happened. Right? So it was hard for to make the bug go away and make the spirit of the code ease a code, which is an interesting way of talking about mushrooms into a more and more complex way to look at the whole problem of hard to read or hard to debug smart contracts. Well, the problems for Lex, obviously, was that, well, we don't do accounting like with bits and bytes, right? Just because the computer knows only bits and bites. That's not how we do accounting because we know it's physical. You can't have a bug in that. And so we have created languages and we have created programs that can do better.
00:09:09.610 - 00:09:48.358, Speaker A: And so this Lexon, now, this is a program. And that's the point. It has actually gone further than I thought in the beginning possible, because I thought you will always have to make some compromises. You will have to explain people that a colon has a very specific meaning in this context. But actually it's been Brian Fox who pushed me into optimizing it on the readability side. And now I would say to me, this is like really zero learning curve. And this is where we are right now, where you can say, okay, anybody can read this and understand what this is supposed to mean.
00:09:48.358 - 00:11:07.166, Speaker A: And that is the point because you can also compile it, put it on the blockchain, and in a smart context, and it runs and took a bit to get there. It also is not quite clear how far it will actually get, but there's still research going on, long road to understand how lawyers really need it, how they want it, what makes this be a contract to them? Although there are others that were naively looking at this, people who are not in the legal profession might doubt whether this is actually a contract. But lawyers will usually tell, yeah, definitely a contract because it's not about the beauty of the language for something to be a contract. But a contract is not thrown out because it's not grammatically 100% correct for stuff like this. Right? And what I would like to get at today is this could work, right? Because why stop with English? Like Sunday was doing exercise in democratization and I'm really trying to target this intermediate programmer. Every good engineer does that, trying to make himself conclude. And Vitalik has actually told me explicit that he wanted to empower the programmers.
00:11:07.166 - 00:11:36.970, Speaker A: That was the objective for Ethereum. And I'm curious how far we can push this and how far beyond being a school programmer. But I'm also curious how far we can push it, how far beyond English we can face it. And I hope to go away here with a learning about how, if it's possible at all. Right. And what the challenges are, particularly japanese law. Japanese.
00:11:36.970 - 00:12:17.526, Speaker A: So on the side, I guess, you know, you can also play around online right now and I'm going to give you a live presentation because that's usually giving a good impression of what you're talking about here. What you can do is get a feel for that. You can also go there. The newest version actually is point to speed, excellent tech. I have no idea. We have programs till the last minute, literally to get everything up to date and as possible as possible. I cannot show everything a bit.
00:12:17.526 - 00:13:07.174, Speaker A: What is going on there is basically on the left hand side, you see Lexon, you see the code, the human readable code while you're writing it. On the right hand side you can get solidity or actually that's validity. We also have a tab now for Sophia, which is another blockchain fraternity, very good technology in my view, who are also going to be a target platform for next. And as you can see, so that there's a lot of work cut out for us in the moment. We're trying a lot of things to understand what the focus is going to be going forward. I would just like to, without further ado, try to lose the focus again. Yeah.
00:13:07.174 - 00:15:18.580, Speaker A: I don't know if anyone has a tip for me how you can switch back out of full, clean presentation to other stuff without embarrassing yourself might be teaching. Yeah, it just takes a minute and I think so, yeah. She keynote. Um. So what I'm doing now on the right hand side, you're going to see some solicitors popping up and I'm going to explain a little bit on the slide how a Lexan contract works. So it always starts with the keyword Lex. And also that is part of the debate about what it actually.
00:15:18.580 - 00:15:50.682, Speaker A: So isn't that worth a discussion? Make something that is going to be acceptable to judges in the end. That works for noise and attorneys for now that's you like, it always starts and then it has a name. And this name is basically there for managing the blockchain. You have a pointer to what actually you're jumping that you want to get it when you actually want to interact with that contract.
00:15:50.826 - 00:15:54.270, Speaker B: Can you blow up the view? Can you blow up the contract?
00:15:56.450 - 00:16:39.654, Speaker A: Excellent. Thank you. Thank you. So then I have something that is actually something wiser used to. You have our contract very often section that is explaining very much individual name and the contact means and what, I'm sorry. And what you see on the right hand side is how basically it's building on the fly, building validity. And for the technical, this is webassembly running in the browser.
00:16:39.654 - 00:17:12.086, Speaker A: So the compiler itself, it's also pointing towards what else it's going to do. There are blockchains out there like infinity or popular touched it. That is going to be a web assembly play where of course we're talking about having a touch with blockchain, virtual machine learning electrons programming. So that's where we are with that. So now we have definitions up there. We have the tab, we have the definitions and these definitions also. We're talking about how this can be done in a way.
00:17:12.086 - 00:17:55.394, Speaker A: So it's more like a template than Lloyds actually. For now, this is how it works. Now we say in this example, we have the payer setting everything up. And the logic is that if they're just not going to play, all right, they're just not going to enter. So the payer basically, first payer say something a is an amount is to an S appoint the officer, also appoints the PE. And this is how I like to observe. And this is really already where a smart contract is more powerful than a situation as we're used to how it's done.
00:17:55.394 - 00:18:32.346, Speaker A: Because this means nobody can run away with the money, right? Money because of how we will program. The rest is just going to be going to the payer payee, but never to the arbiter. So the arbiter is not going to be able to just run away and also fix the search. And this is basically. So this sets up the situation. This is what happens when the contract actually is set in motion when it comes to a contract. Because what we're doing here obviously is a cookie cutter for a lot of different contracts that you could imagine where you have different carriers and so on, but always on, this contract becomes an actual contract.
00:18:32.346 - 00:19:25.514, Speaker A: This is the first thing that happens on the blockchain. But also let's say, in a real world. And now the main functionality of this contract is basically a payout, right? So we want to be able to say that the arbiter is the one who also earned the fee. So Andrew. And now you're done, right? And I will not go into this now, but we can now deploy blockchain using that button down there. We'll go to Ethereum. Robson on the back end, we're compiling the solidity we compiled.
00:19:25.514 - 00:20:21.122, Speaker A: We it put it on blockchain using metamask. And so you basically have control over who is going to be allowed to do what. The very powerful thing that we have here is that we can parse because we have the information that is happening during the translation process. We can use that and create the interface how to interact with this contract so that we can have an interface where basically we're using the information that the arbiter may do something and nobody else may do something to know that the button that is going to be created for the payout functionality should only be shown when it's the arbiter who's locked in. Right. And this goes on. You can take the entire clause of the auditor of the payout as a description for that button because the source code is like the perfectly self commenting source code doesn't go beyond that.
00:20:21.122 - 00:21:26.274, Speaker A: Right. The command and source is the same thing. So what you end up, you have a lot of more powerful way to create a generic interface to actually then interact with these contracts. And that is all because the entire process of translating electron contracts, of compiling it into solidity, is happening on a higher level than what usual programming does. I've written about this, there's a paper I have to share that is arguing that because Lexan stays on a higher level, like closer to human language, it has a structure like subject objects and verbs, which is a really different concern in those structures that are used to translate that into something else than what you usually have in a program language. Usually in a program language you have a tree that has the logic of, as you can see on the right hand side, actually message sender. So you have message and sender and then dot operator dereference.
00:21:26.274 - 00:21:48.246, Speaker A: We cannot message as an object and sender is an element in an object and so on. And that's what internally a compiler is concerned with. That translates well, compiler that's concerned with translating, Exxon actually is talking about the payer pays an amount. And that is actually what the business logic, what we think about. Please.
00:21:48.368 - 00:22:05.490, Speaker B: So is there a reason why you wrote the arbiter may pay from an escrow without including the, if some condition happens, the conditional, because it's starting to create a conditional, I think, but you don't actually have it specified. Would you have to then later on add a conditional of when it would execute?
00:22:06.170 - 00:23:13.094, Speaker A: Okay, thank you for that question. Because to clarify, these are the resizer, are you programmer? So they're basically the constructor, right? They are what is executed the moment that you say, okay, now I want to make this a real contract. Now I'm going to say, who is this here? What's the name? What's the street address? What's the blockchain address? So it becomes R1 instance of one contract. And in that moment, the recitals are being, basically being executed. And that is that line, which means like I wish I, which means that you basically can, when you want, you can use that for other contracts too, because it might be a very generic code that you have created, but the recitals are basically what has to happen the moment that it becomes one concrete contract. And this is why it's not really if part of it, okay, if you want to make this a real contract, do this. But that's outside the realm of programming or a contract.
00:23:13.094 - 00:24:04.730, Speaker A: It's just a contract that happens. Yeah, we know we enter into that contract, but then to enter this contract, what has to happen is this. So the may though in the payout, that is much more of a condition. And what it actually is, is a condition for access control, basically. Right. Who's allowed to even go and ever execute this function from the vantage point of the smart contract program, but also, who is even having this option, like on the legal side, when you look at it as a legal contract. And that's something actually we have discussed a lot of discussions about because it's different.
00:24:04.730 - 00:24:50.620, Speaker A: Right. Smart contract works with incentives. Smart contract cannot go beyond the blockchain and try to enforce something that didn't happen just because you wrote in the contract. Somebody tells must or should. So to really articulate contracts that make sense to put on the blockchain, you would pretty often try to reverse the logic of a normal legal company that would usually just say, okay, you have to must do this for that. Or given the business fulfillment and this should happen. In this case, you just give the option and hopefully the fee was high enough that the arbiter is feeling incentivized to actually do what they may do.
00:24:50.620 - 00:25:21.940, Speaker A: But if they don't, then this contract actually is not saying that the operator is not going to jail ever being punished, but it's just nothing's going to happen. And that is also how a blockchain contract works. Of course, you can now create a stake, right? You could create a version of this contract where you say, okay, the architecture first has to pay in the stake to be assure that they're going to lose money if they don't act. We want them to act. Right. So it's a whole different deal. And yes, of course you could totally do it.
00:25:21.940 - 00:26:03.910, Speaker A: Good example for next step. What is the Lexon manager? So, yeah, that's where I wanted to. Let me real quick, go one step back and then go one step forward. So I wanted to show that it's pretty easy to go and extend Lexan programs. Right. Using Lexan and practice was going to be a lot about having templates and learning from those templates to extend them and to adapt them to what you really want. There's an exercise if somebody feels courageous, I just copy pasted.
00:26:03.910 - 00:26:52.800, Speaker A: Obviously compiler doesn't like it. What would I have to change now in this second clause where it says payout again, to make this, well, basically an opportunity for the archer to also decide to give the money back to the payer because let's say in the real world the business didn't happen as it was spent. So nobody, few people in this room ever programmed Nexon. But I'm sure you can still tell me just intuitively what I have to change. And it's really just common sense, right. So what's wrong there? You just think English, what has to change in the second thought, what's your equivalent to a boolean? We need to declare some sort of boolean and then say dependence on that. While listening to you, you sound a lot like a program or maybe you think like a volleyball or.
00:26:55.250 - 00:26:56.960, Speaker B: Change the name to pay back.
00:26:57.590 - 00:26:59.620, Speaker A: Take that. We have a different name.
00:27:00.630 - 00:27:04.450, Speaker B: Instead of being to themselves, it would be to the payer.
00:27:08.650 - 00:27:30.638, Speaker A: Like this may pay for much growth into pay. Yeah, I think that one. Oh, okay. Right. So that's all it takes. Whatever. It's pretty much based on common sense.
00:27:30.638 - 00:28:10.282, Speaker A: And thank you guys for basically demonstrating that excellent is not easy for programmers. I would say I do that now, but neither Lloyd nor programmers really does it. I'm pretty happy that somebody very early on of a very well known law firm in the blockchain space told me, yeah, alloys don't like it, but their bosses are going to make a new. And likewise, it's programmers. Programmers think it's verbose, complicated. We're quite happy with our curly braces and colons and semicolons and so on. Right.
00:28:10.282 - 00:29:04.054, Speaker A: Makes sense to us that by definition not really a need for a language for non programmers, for programmers, I was just thinking, is there a way or an idea to do it the other way around? From solidity to election? Yeah. Thank you. That's a very interesting question. And this question comes up because a lot of people have a lot of investment in solidity contracts and it makes a lot of sense to think about that. But it does highlight what the difference is between Lexan and solidity. The thing is that upon all the information that you have on the left hand side is on the right hand side compound, but it has been baked down to a level that mixtures other stuff that is part of. You also have to do invalidity.
00:29:04.054 - 00:29:43.942, Speaker A: So for external, right or. Yeah. Address bracket list, closing bracket balance if you want to, that money that is there in that contract. Right. You can't just write escrow or something there and you write and it's fine. That's intuitive. However, you would be hard pressed to find a way to what the actual requirements that the language just asks for you because it just has to be up until you're able to get it or know it.
00:29:43.942 - 00:30:35.560, Speaker A: In the translation process through solidity is this higher level clarity of the higher level of the information that I was referring to that Lexan is dealing in objects and subjects and verbs, actually. Really? And to get that back out of solidity, you'd have a very hard time. I'm guessing it would be possible, it would be easier to just write, rewrite, something that also actually is sometimes happening when I make mistakes. When writing a lex on contract, people catch me because every mistake I usually do. I don't like manipulation, so I'm not really good at faking it. But sometimes I write this, right? I wrote person three times, so I write either person. And of course the audience always catches me.
00:30:35.560 - 00:31:18.326, Speaker A: And last time I did it, they actually proposed I should write them out. So they even guess the language right, because it's so simple. But what I found interesting as a programmer is that actually people now can catch errors in the program using their normal language testing. If it doesn't read, write in English, it's probably a bug. That's pretty powerful because even as programmers, our language center, we use that all the time, right? So that's really jumps at you. You don't think about language or about English or anything. You just have a feel, oh, it doesn't read right.
00:31:18.326 - 00:32:55.280, Speaker A: And on the right hand side, if I would, whatever it is, I'm going to see if I write amount back here on the right hand side, un, that's exactly the stuff you have to look out. If as a programmer you know a lot of different languages because that's slightly different every next language, sometimes the uN, sometimes it doesn't even exist. You know exactly what it is. This has different names and you cannot as a layman criticize or jump in and say, oh, that's probably a mistake. If I write something else other than you win, or if I write you in, you have no opinion about whether that's right or wrong. So that's a very interesting study, certainly not intended, but this kind of stuff keeps coming up a different way of running programs. So going, oh, I wanted to, don't know what happens because I just changed the program on the water, floating or not.
00:32:55.280 - 00:34:26.366, Speaker A: I would like to use our time. Yeah, basically rushing through a number of, in the beginning, basically my first idea was really like if smart contract has a magical new feature that they can transfer money, that's really new programmer a lot of ways that you have a magic feeling before the stuff that you create, but actually now all of a sudden you can't transfer money, that's a really new thing, right? So the idea was to quite some degree is now programs can shift possession, you can still sue them. And if a business is asked to bank on smart contract and use smart contracts as something serious, they will ask that question and they do like what happens? I get sued over the smart contract because somebody doesn't agree with what it does. So the idea is simply, okay, if the smart contract agrees like a contract and I can show it to a judge, then I take out the incentive for anybody to sue me because hopefully that contract is going to say exactly what happens on the blockchain and then the judge is just going to scrub the shoulders and say people will not use those reports. And that actually just makes contract more powerful. And there it goes kind of back full circle in a way where it's not so much about illegal or not or legal. This is also in a way making contracts more powerful.
00:34:26.366 - 00:35:41.206, Speaker A: And on the side, as I'm with you in a second, on the side, it's also making possible to within a company to have this verification process, to have business people wanted something, contracting with another company and then lawyers wanted to see something. So the whole thing is compliant and really in the interest of the company. They all can verify now they all can chime in on what's happening. And it also ropes in the users or small businesses that might not have a blockchain department, they can read those smart contracts themselves. So in the end it's also taking on a current way that business models work in the blockchain world where basically a startup is formed around a complex smart contract that is very generic and it's going to supposed to work in very different situations. And then basically the startup is a provider of a service that is created around a smart contract. Lexon is very much the market has that too, in the sense that hopefully writing election contract, writing a postponed election contract that does exactly what you want, becomes so easy that you will not these new startups.
00:35:41.206 - 00:36:20.950, Speaker A: Right. So that's another, I think important. What's the motivation behind that? You had a question? Yeah. So obviously smart contract is just sitting on the blockchain. Anyone can interact with it through gap or whatever. How is one put on notice that they are dealing with the smart contract that came from a Lexon legal contract such that their interaction with the smart contract is basically indicating their consent to be bound by that legal contract. That's a very good question.
00:36:20.950 - 00:37:10.514, Speaker A: Thank you. So the situation back is right now. Usually you do not even have a chance to understand what the source code was compare back. So that points towards at some point I think it's going to be very important to have a virtual machine of Lexon where one of the attributes is that you can compile Lexon code onto the blockchain, but you can also decompile it back out. So there cannot be the situation that somebody is asked to direct to this contract but doesn't have any way of knowing. Blockchain Explorer for this kind of virtual machine would have the ability to just press on button, say yeah, this is actually the code. This is one of the aspects.
00:37:10.514 - 00:37:45.120, Speaker A: Why the way that we show it now where we pilot solidity and compile it on Ethereum is not the last part works now very well make people understand that it actually has the full art. But this is one of the, and there's other stuff like reversibility of individual contracts without doing your work because judges can change history. They can just say, well yeah, actually this contract should have never been done or well, let's try this out as if it has never happened. Right. And then what do you do?
00:37:45.590 - 00:38:04.598, Speaker B: Yeah, so I did notice there's certain rules that you're following when you're writing the Lexon thing. Like every sentence is ending with a period, right? When you're defining variables, it's in quotation marks. So there's certain lexicon that's required in order for it to be able to convert. Does it flag like you forgot your period for an average person?
00:38:04.764 - 00:38:29.646, Speaker A: Yeah, actually it did that on the side. Right. It's not good yet, but we're working to make the compiler be as hustle as possible. Now this is a big topic in programming, right. The rust compiler really is very advanced in this. It really almost tells you what you should have programmed instead of what you tried to write. There are other compilers of a phase of even C plus plus also has a problem solution behind it.
00:38:29.646 - 00:39:32.434, Speaker A: And this is definitely something from day one that was very important to me to have error messages that are good possible. It's a little bit something of a luxury thing in the sense that there are a lot of stuff that we have to test out that we have to cure first, whether actually works. And if it works, then you can be pretty sure that works. You will also have this kind of help. But we want to have a lot such as complex help like program Java and auto completion. Yes. When you talk about parsing complexity, do you have long term vision? How would you like to direct the evolution of the lexum? Natural languages have this contextuality that is backwards and forward in the parsing, what makes it almost impossible task to implement the proper way of sending them.
00:39:32.434 - 00:40:51.798, Speaker A: So do you like to bring maybe the feature of the language that when I have a sentence it carries on the context from the previous sentences, but maybe you decide to drop on a feature to refer to the future sentences because of some way, or you just leave it now on the side because you would like to focus now on the basic use cases and see how it will evolve. I'm curious where you stand and what's the current state and what are the next steps. Yeah, so the basic premise of what we're doing here is called controlled language. The idea has been around quite a while actually, and there are even papers that are basically pointing out that this should be possible. We are doing very normal compiler work on the basis of not going forward and proposing a new grammar, but instead going back using an existing grammar, English in that case, and paring it down to a degree where we can actually target and create an ast out of it, an abstract syntax tree, and then do other stuff on it, for example, creating solidity, RFP and so on. For this we can, and that's the major premise, basically. We can basically pare down the possibilities of English to something that still sounds English enough, right.
00:40:51.798 - 00:42:16.040, Speaker A: But will not allow you to just go overboard and create arbitrarily complex sentences or even sentences where you decide to arrange words in a very different order than normal stuff because we have to. And I actually managed to get lost in this switching again. But actually, in the presentation, I have a grammar section where I'm just showing how this looks, how this action file looks, that for us as programmers, that contains the information that is going eventually being, so to say, blueprint of how the computer understands language and what it is looking for, what keywords it's looking for, what kind of patterns it is looking for, to be able to then construct out of that a structure that allows you to really have an understanding within the computer, so to say, of what the language could have. And with this, you. I'm skipping over this here in the interest of time. Yeah, this is the graph, actually. So this is files scrolling it through.
00:42:16.040 - 00:42:48.740, Speaker A: It's not too long, but this is how you articulate what you actually want. So, for example, we have statements, right? There's a number of statements, and that's the list of statements. Then you have the definition, that clause that you see there. There are certain keywords that you see and close. And that's actually the keyword that I understand. Right. And that's exactly what I want to close with an open discussion about.
00:42:48.740 - 00:44:13.406, Speaker A: Is this thinkable for Japanese? Is this something where japanese grammar is giving you obstacles that you will probably not be able to go through? Or is it worth giving a step to also create a lexum that is based on the japanese angle? So what I was showing earlier, could this work? This is what I'm really stoked about. And I would like those who say that they can speak Japanese to chime in and educate us if they feel that what we do here with English is something that could also work with Japanese. There's no right or wrong. I'm happy to give opinions and reasons why or why not. Hi. I was thinking because you talked about control language. So, a couple of things.
00:44:13.406 - 00:44:57.622, Speaker A: One is that, did you think about IBM? Easy. English, like, things like that for technical specifications, which are used. And the other thing is the problems that happen with control language. And this is matter of debate and linguistics, which is because it is a natural language, control language. If there is a later dispute, can you not go back and claim, it's not my fault if the language is like that? I thought I meant it this way, but it was not like that. And because you cannot do as saying some of the nuances of a natural language, would it not limit the kind of contracts you can write in it? Well, let me restate my question. What we do with English.
00:44:57.622 - 00:46:19.960, Speaker A: Do you think we can do this with Japanese? What do you think? Yeah, I think very much so. What do you think? What do you feel the challenges would be in Japanese to satisfy using very much that you should learn? That is something I'm familiar in Germans too. Right? It's not as nice as English, but words, all of a sudden, at a certain point in the sentence, have to have a certain ending. So this is the major challenge that you will see where you would have more difficult project Japanese. You are able to make it then say that smart contract that you are displaying the other opinions there.
00:46:22.650 - 00:46:57.454, Speaker B: Grammatically, Japanese is actually relatively easy. Grammatically, it has very few irregulars. It follows a particular structure. They have these articles like you have the Wa there before the comma. So you can basically kind of use those as anchor points to figure out what the code is going to be. In fact, this has even more specificity than. Remember my question earlier about may can be permission, but it could also mean the conditional, which is, for me, first thing that came to mind was conditional rather than the permission.
00:46:57.454 - 00:46:58.850, Speaker B: This is very clear.
00:46:58.920 - 00:46:59.710, Speaker A: The permission.
00:46:59.790 - 00:47:16.006, Speaker B: The japanese itself, that you're used here, Shihara kotogatikimas, that specific Japanese is talking about, they have the right to do something. And so that level of specificity, as long as the person writing it knows what the rule is that you have to use this.
00:47:16.028 - 00:47:17.806, Speaker A: Kotoka dekimas.
00:47:17.938 - 00:47:21.500, Speaker B: As long as you're using that, then it could very easily be read in.
00:47:22.830 - 00:48:02.114, Speaker A: Thank you. So eventually, one language can be the shading point of all legal coding. Instead of English, everybody calls in Japanese. Actually, if I remember right, the american experience was there was a lot of French used in America because people thought it was less ambiguous. And you get better quality law by articulating it in French. So, yes, you can end up finding that languages are better than others to articulate law. But that's a huge right.
00:48:02.114 - 00:48:18.410, Speaker A: Nobody will tell you, no language has to be ambiguous. It has to be ambiguous law. While Nixava is going to tell you, well, that's actually why I invented this term, because smart contract was the whole point about it was less than bigger contract.
00:48:21.010 - 00:49:00.314, Speaker B: So the only challenge, like, for example, this shiharao togatikimas, that could be written as shiharaimas with kind of a shorthand version. And so the person who's writing it needs to know they have to adhere to certain things rather than using shorthands. And Japanese also has sometimes combination of two characters, which could be replaced with one character with a longer thing, like Guxu suru versus narao. So narao means to learn, guxu means to study. But they both fundamentally mean like the same thing in English. But one is a pairing of two words together. The other one is one separate word with more hiragana with it.
00:49:00.314 - 00:49:13.598, Speaker B: So as long as the person typing it knows the rules, you could actually easily convert. But there's two ways of writing verbs. Centakusuru versus erabu. To choose something.
00:49:13.764 - 00:49:14.286, Speaker A: Right?
00:49:14.388 - 00:49:23.418, Speaker B: But as long as you know, you should combine it with the two verbs plus something else, then I think it's very easily convertible.
00:49:23.594 - 00:50:39.080, Speaker A: Okay, so this super interesting, helpful. I would like to invite everybody to join us on Friday, where we are actually going to have from two to seven that's also on eventbrite with the off desk on event. At the moment it's not waiting list, but please sign up. At any rate, if you should have time on Friday to continue that phase. And I'd be very interested to find out whether the possibilities that we're hearing about here, what the challenges might actually be going forward, and going from there towards maybe even get into the point where you can start having some modest stuff like the project that I just wrote there and I was just wrote there translated yet. But it could be a great starting point. While I'm having trouble convincing my computer doing what it should do, I would like to say thank you everybody, for coming here.
00:50:39.080 - 00:51:00.860, Speaker A: If there are any questions, I can be here for another five minutes, I think. Very interesting to hear that. Actually, not completely unlikely. Thank you very much.
