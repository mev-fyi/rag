00:00:15.450 - 00:00:45.674, Speaker A: Hey, everyone, I'm Sina. This is going to be a workshop, so I will be working with the terminal. I will show you some code and show you how to use gas, like guest tracing feature. That's why we specifically needed my laptop. So, yeah, sorry for having to wait. Also because I will be showing code. It would be great if you guys could come forward if you want to see what's happening, because I imagine the fonts will be small.
00:00:45.674 - 00:01:23.602, Speaker A: So, yeah, I'm going to give you a bit of time to come forward. And while you're doing that, I want to talk something a bit personal. So I come from Iran. I don't know if you heard, but there's some stuff happening there. I just wanted to give a quick shout out to the people who are going to the streets. There they are protesting for their civil liberties, for freedom of speech. So, yeah, there's been three weeks of protest.
00:01:23.602 - 00:02:02.270, Speaker A: Now. Internet has been disconnected. And it all started when the girl on the left, who is 22 years old, was in custody because of showing a bit of hair, and she somehow happened to die in custody. And this outraged people who went on the streets. And during these protests, close to 200 people have died. Among them, Nika, who was 16 years old. And when running away from the police, she also died.
00:02:02.270 - 00:02:40.474, Speaker A: So, yeah, just want to give a quick shout out to them. They're risking their lives asking for their rights and for freedom. But this is a technical topic and I don't want to waste your time anymore. So let's get straight to it. So what is tracing? Why would you need tracing? I just want to show you an example of. This is ether scan. Everybody knows ether scan, right? And the internal transaction section of Ether scan is basically a trace of that transaction.
00:02:40.474 - 00:03:23.600, Speaker A: It shows you what happened within that transaction, every call that happened there, who called who and so on. And this was actually probably not from a guest node, but I'm guessing from open Ethereum or Aragon. But we have a similar feature to this. And this is not the only use case. There's many of them, just to name a few. Just before coming here, I was talking to somebody who's developing a Zke EVM who are also heavily dependent on the tracing feature of gas. I've seen talks about from mev searchers who are using the tracing features and many more.
00:03:23.600 - 00:04:01.670, Speaker A: Yeah. This is also another tab in the ether scan details where it shows you the state, like the state difference. As you will see later. This is also something that you can get from Geth. So before we get to actually, we get into tracing. You know that you can use gas to execute a call on top of a given state. So you probably know ETh call, you give it a set of parameters, like as if you want to send a transaction to the network.
00:04:01.670 - 00:04:31.346, Speaker A: But this is actually not sent to the network, it's just executed locally and you see the result. It's a simulation actually. You have to give me a bit of time because I had to restart my laptop and I lost all my setup. I have to bring up the terminal because I wanted to show you how this actually goes. So yeah, I have a girly node on my machine that is kind of synced to the network. Okay. Yeah.
00:04:31.346 - 00:05:01.614, Speaker A: Is it behind me? Maybe I move it here. All right, so let's do call. I have them all stored in a file so I don't have to type it out, because anyway, I'm losing too much time on this, so I'm just going to go. I already lost a lot of time. You all know how Eth call goes. Okay, let's move on to the next one. I'm just going to explain to you.
00:05:01.614 - 00:05:40.422, Speaker A: So basically I'm simulating a call to the wrapped ETH contract on Gurley to get the balance of an account of account zero. Right. This will only give you the result, like in this case the result is zero. It shouldn't be. I have to figure this out. I think I have the wrong address here. The zero address should have some balance.
00:05:40.422 - 00:06:13.746, Speaker A: But anyway, what I wanted to show is that when you do an ETh call, you only get the execution result, what is returned from the contract back. But this is oftentimes not enough information. We want usually more information. We want to see what happened inside the transaction. Right. And that you can do by doing the same thing, but using a debug method, trace call, which will simulate the call for you and trace it at the same time. It would give you more information.
00:06:13.746 - 00:07:32.010, Speaker A: So if I were to run this now, this is the main net contract I was going to present with mainnet node, but then I found out the wifi here is not so good. So I can't ssh to my server here. We can already see that there is a lot more information as it basically shows you all the steps that happen during the execution of this transaction. Yeah, there is going to be a lot of steps. I'm not going to go to show you all of them, but basically you will see, okay, what is the first upcode? What is the programming counter at that point which upcode was executed, how much gas do we have at this point, what is the storage at this point, and so on. So it will give you almost the full information that the EVM has when it runs through the transaction. You can ask questions.
00:07:32.010 - 00:08:04.210, Speaker A: Sure. The stack is before the instruction. Yeah. So all of these information are from before we execute the opcode here. I showed you in this example, I showed you tracing a call of my own craft. Like basically I said okay, I want to do from to input and so on. But of course guest supports tracing existing transactions, the one that were already mined on the chain.
00:08:04.210 - 00:08:44.430, Speaker A: So historical transactions, so to say those you can do via these endpoints, you have a debug trace transaction that traces a historical transaction. You just give it a TX hash. You can also do it at the block level. You can trace a block by using twice block by number or hash. Or you can do even a whole range of blocks by using trace chain. But trace chain, mind you, is a bit different. It's not using the simple JSON RPC request.
00:08:44.430 - 00:09:34.682, Speaker A: It's based on the subscription API, so you have to use Websocket for it. So the usage of it is a bit different. I'm not going to show you here, but yeah, it's cool for when you need to run over a range of blocks. What we saw in the previous trace was the default tracer. It's basically the opcode tracer, like it shows you every step. But sometimes you need information at a different abstraction level. Like for example as we saw in the ether scan screenshot, you want to see what calls happened or you want to get different information and get has a bunch of built in tracers that you can just call them by name and get the information you want.
00:09:34.682 - 00:10:48.450, Speaker A: So here in this section, I want to show you three of them, the first one being the one that we saw in this table. You will see all the information that you will get from the opcode tracer, which is, yeah, I'm going to give you a second if you want to see what's in there. But yeah, basically you get the opcode information, all the gas related information, like how much this upcode costs to execute or will cost to execute, how much gas there is left. The whole memory snapshot of that transaction, the stack return data of the last call. Like when a call finishes in the next step you will get the return data for it, storages for the storage slots, for the contract, depth of the execution refund, and if there was any error. But please note that if you want to use this tracer, there are some things to note as I said memory stack storage and return data. These are dynamic values and they can grow large, especially memory.
00:10:48.450 - 00:11:42.182, Speaker A: You have to watch out for memory because mainet transaction these days are very heavy. So if you have memory enabled, it can kill the node. Basically one of our users reported that they tried to trace a block on a server with 64gb of memory and it crashed basically. But because of this, the tracer accepts options to disable all these features. So all of the ones that you will see in this list, they can be disabled. Some of them are enabled by default, some are not, but they're all like you can toggle all of them. Also, if you really need to trace, you need a memory, let's say, and JSON RPC is not sufficient for it, and you control the node.
00:11:42.182 - 00:12:33.194, Speaker A: Then there's an endpoint standard trace block to file, which will trace a block and save it on a file alongside the node that you can easily access. So it's not like a JSON RPC request. The next one is the call tracer. This is arguably one of the more most interesting tracers. It will basically give you all the call information, like all the internal calls that happened during the execution. I'm going to show you in the previous example, basically when we call wrapped ether, balance off what information we will get in return. So you can see that balance off is a simple call.
00:12:33.194 - 00:13:18.770, Speaker A: It's not going to call anything else. And there's one call, it shows you who is the sender, who is the recipient, who's the contract, is it call or is it create? Was there any value transfer? And what was the call data, what was the input? But yeah, this is a more boring example. I hope these transaction hashes are okay. I feel like the file wasn't saved. Yeah, okay, it works. So I'm just going to run it show you guys. So here I'm not doing trace call, but I'm using historical transaction that was mined on Gurley.
00:13:18.770 - 00:13:50.766, Speaker A: So I'm using trace transaction endpoints. This is the transaction hash. And here as an option you can specify which tracer you want to use. So if you don't provide anything then it will default to the opcode tracer. But you can say I want to use the call tracer as we did here, and you will get a bunch of information. This is going to be the main call. And notice that we can already see this call error, it reverted.
00:13:50.766 - 00:14:46.606, Speaker A: We can also see from since recently we can see the revert reason, which is system time outdated. This is the solidity revert error that was returned the input output. And then here from here we have the nested calls. So basically the main contract did some called another one that we can see here which also reverted. And up there you can see there's more nested calls that it's not being displayed here, but you can get that information also. So yeah, call tracer you would use when you need information about the internal calls since recently it accepts a nifty option. So I'm going to provide here you can basically configure the tracers.
00:14:46.606 - 00:15:33.970, Speaker A: You can say I want only top call. This is useful if you need only the top call information. Like only if you want to know. Okay, why did this transaction revert then? I don't need to see all the nested call information, I just get the top call and I check the revert reason and I know, okay, there was a time outdated or something. This one is the preset tracer. It has two modes of execution by default. When you just say I want to trace this with the preset tracer, then it will give you all the accounts that are needed to execute the call or the transaction.
00:15:33.970 - 00:16:43.062, Speaker A: You can think of it something similar to access list or witnesses. So if you somehow need to simulate a transaction and don't store the whole state, you can get the state via the prestate tracer and then you can execute your transaction locally. And in the second mode you can see all the state modifications that happen during the transaction. Basically you can see, okay, the balance of this account increased to such value, the storage slots changed such and such if we were to see it live. It's this one. So here I need to change the address. I'm going to execute the same wrapped ether balance of call and pass to see the prestate.
00:16:43.062 - 00:17:29.980, Speaker A: And yeah, as you can see the zero address shows the balance of the zero address. This is the contract itself has a balance. The code nons and all the storage slots that were needed to execute these transactions. These are not all the storage slots of this contract, but only those that were required here. And let's say you wanted to see the diff, you just pass a parameter diff mode and yeah, basically we can see the biggest change here is that the non. So you have like a pre and post state and you have to compare them. So you can see here we have the zero address.
00:17:29.980 - 00:18:13.602, Speaker A: The nonce is omitted because it's zero. So nonce was zero and now it's one. So this is the only change that happened in the state during this transaction. But of course if we were to run it with a more complicated transaction. You would see, yeah, you would see like there's going to be much more stuff. And this is what parts of the state that changed during this particular transaction. Like here we had also balance updates nons and balance both changed and balance of zero account changed.
00:18:13.602 - 00:19:08.550, Speaker A: And here we have like the format works as follows. Basically, whenever something is created, let's say a contract is created, it will not show up in the pre object, it will only show in the post object. And whenever something is deleted, it will only show up in the pre object, but not in the post object. So by comparing these two objects, you can see how the state was modified. So now I want to talk a bit about how geth stores state, because it is very relevant when you're doing tracing. Like if you've been tracing, you probably saw this error required historical state unavailable. Specifically when you want to trace a historical transaction, one that was mined.
00:19:08.550 - 00:20:26.690, Speaker A: Now why is this? So first of all, how do we prepare the state for simulating a transaction or rerunning a transaction? It's basically like we have to find, okay, the transaction in block n. So we will fetch the state for block n minus one, the post state of block n minus one, and start executing all of the transactions within the target block until we reach the transaction that we want. At this point we have the transaction, we have the state, the prestate basically for our transaction, and we can execute it. But what happens if the state for this block n minus one is not available in the database? Basically that's hint. That's when you get this error. So now comes the question, the state for which blocks are actually persisted. Let's get the archive node out of the picture, because it's the easiest.
00:20:26.690 - 00:21:21.410, Speaker A: So for archive node, you have all the states. Next one is full sync. By full sync, I specifically mean that you start executing all of the blocks from Genesis up until the head here. It's worth to note that always guest stores the latest 128 blocks, the state for them in memory. So you always have, like while your node is syncing, you always have the state for the last 128 blocks. Now anything beyond that is persisted to disk only periodically, and that is roughly every 2 hours. So every 2 hours the state for a block will be persisted to disk.
00:21:21.410 - 00:22:31.146, Speaker A: And because we synced from Genesis, that means we have the state of a block roughly every 2 hours from Genesis on until the more recent ones. And the difference between full sync and snapsync is that in snapsync you won't actually execute the transaction, you won't actually execute the blocks from the beginning, but from some pivot point. So let's say here is the point, when you start like you fetch the state from the network and you start executing transactions. So that's why we only have the checkpoints from this point on. Basically we cannot execute any transaction that happened before we did the snap sync. So it's important to know based on your use case which sync mode you should go for. And now we can complete the picture again.
00:22:31.146 - 00:24:01.810, Speaker A: So how do we prepare the state for executing a transaction? We fetch the state of the parent block from the database. If it's not available, what do we do? Guest will go back in the blocks for a number of blocks and check if it has a state available for any of them on disk. And if so then it will basically reexecute all of those blocks and prepare the state for your transaction. So here you can see in the error, we have the error and we have some more information like Reexec equals 128. This means that guest tried went 128 blocks backwards to find some state on disk that it could use to go forward, but it didn't find any. And this is a parameter that you can give. So basically when you do trace transaction you can provide this Reexec parameter and say okay, I'm willing to go back 2000 or 2 million blocks to find a state that I can use to execute this transaction.
00:24:01.810 - 00:24:53.942, Speaker A: But of course the more you go back the longer it's going to take because all of those blocks have to be re executed to compute the state. There's a method that you can use to see states for which blocks are actually stored on disk and that's debugget accessible state. So let's say I want to see 5000 blocks behind ahead. Do I have any state there computing no state found. So I don't have anything between the last 5004 thousand blocks. Okay, I can try again or I can enlargen the search parameters. It's probably also going to say no, actually no, it found it.
00:24:53.942 - 00:25:40.070, Speaker A: So here it says there's this block that I have the state for. So I know that block number. Yeah, so I know that I have the state for like 8000 blocks ago, basically. So yeah, this is a nifty method for finding which states you have on your disk. And then when you know this then you can set the reexec parameter accordingly. And sometimes there is a range of blocks that you care about a lot, like you need a lot. So you want to store the whole state for that.
00:25:40.070 - 00:27:00.606, Speaker A: What you can do is basically stop Geth, add this parameter GC mode archive and run for as long as you need and then stop it again and take it off because when this flag is there then Geth will store every state like the state for every block on disk. We went over some of the tracers that come as in stock gas but that's not your only option. You can write a custom tracer. There is some hooks that you can use to collect the relevant information for your use case and only that you don't have to rely on the tracers that we provide. And here I want to show you an example. During Devconnect in Amsterdam I met this guy who was an MEV searcher and he was telling me that he found the tracing feature of gaff extremely useful. And later on I saw his talk and he was talking about this.
00:27:00.606 - 00:28:11.960, Speaker A: So apparently there are some poisonous tokens out there or they used to be at some points that wrecked basically searchers like the automatic bots and one of those tokens kind of looks like this. I think this is a simple one, it's not a real one but basically it just checks to see if you are in a development environment then it does the actual transfer of value. Let's say you simulate that on hard hat and you see like yeah I got some money but when you run it on mainnet then you actually don't get money and you probably lose some. So that's the gist of the token. And he wrote demonstrated a simple tracer that can detect this. And I'm going to show you that this is how a custom Javascript tracer looks like. It's a very simple one.
00:28:11.960 - 00:29:39.860, Speaker A: You have a few methods that you can implement in a JavaScript object and you will pass this object to get when you invoke the API. In this case we implement the step method which is run for every step of the execution and we implement also the results function which is executed once at the end of the transaction. So basically the idea of the detection algorithm is that token transfer shouldn't use any of the following opcodes coinbase number, difficulty, origin. These are all block metadata, right? When you're doing a ERC 20 transfer why would you need any of these opcodes? So this is like a very simple detection thing. So what I'm doing is basically like I have a global variable called fishy and as I'm going through the steps I check that if any of these opcodes appear then I'm going to say okay, there's more coming out of this. I don't want to do this trade. So I just set that variable to true and return it.
00:29:39.860 - 00:31:13.098, Speaker A: And now here is my, you can't see that, but basically the result is true. I ran that tracer over a contract and the result was true. But this is probably the most interesting part of the there is a few things here, right? So I'm simulating a call from and to an address, but note that this address is actually not empty. There's no contract deployed on Gurley for this address. So I'm going to introduce to you a very nifty feature, and that's called state overrides, right. Basically when you simulate a call using east call or debug trace call, you can give a bunch of state modifications to guests like temporary, and you say okay, apply these state overrides temporarily for simulating this transaction. So here what I did was I have the bytecode of the contract, the poisonous token.
00:31:13.098 - 00:32:13.620, Speaker A: This is a bytecode, and here I say okay, state Override. In this address please put this contract code. So this contract code will not be deployed anywhere, but only when I'm simulating this transaction it will be as if this address has this code. So this is very useful, like if you're simulating stuff, the tracer object I'm passing also separately here. So what happens is basically there is a call to transfer to this contract, and my custom tracer detects like says that it's a phishy call because it uses the Coinbase opcode. Now the Javascript tracer is what most of people know about, but it's not the only option for writing a custom tracer since a while ago. We also have another option, namely you can write your tracers in go.
00:32:13.620 - 00:32:58.066, Speaker A: This is especially relevant if performance is a concern to you. The Go Javascript overhead is a lot, so when you want to do tracing over a long range of blocks, it just takes a long time. But now you can actually write your tracers in go. And it's pretty simple how it works. I have one here that I'm going to walk through a bit, but I just want to show you how you can. First I want to show you how you can write one. So basically you write your tracer, you add this, this is a very important part.
00:32:58.066 - 00:33:42.666, Speaker A: This is how guests will know that there is a tracer here to be found. And you drop this file in a directory in guest. So we have, this directory is tracers native, you simply have to drop your go file here, do the registration and you're good to go. And of course your struct has to adhere to an interface, and this is the interface that you will see. So the methods are capture start. This is at the beginning of the execution. You have capture state, which is run for every step of execution.
00:33:42.666 - 00:34:06.710, Speaker A: You have enter. We didn't see this before. Enter is basically a hook that is called every time we enter a new call frame. So when there's a call or a create, we enter a new call frame. This one is called. And exit is when we leave the call frame. And you have fault.
00:34:06.710 - 00:35:00.250, Speaker A: And the result, so the result is when basically what you return and what the tracer will return when you call the method. Yeah, it's a bit tight time words, but I'm just going to give a short overview. So what this tracer does is that it will tell me the method signature for all of the functions that were called. So as you probably know, solidity functions like when you hash their signatures, the four bytes, that's how you actually invoke them at the EVM level. Right. And I want to just collect these four bytes, basically the signature of the methods that were called. So this is the gist of the logic.
00:35:00.250 - 00:35:34.180, Speaker A: I check that we're entering a new call frame. I check that it has to be a call or a delegate call or a static call, some kind of call. Otherwise just return. That's not important. Also we don't want to collect pre compiled information, so they're also returned. Otherwise take the first four bytes of the call data and this will be my signature. And these are stored in some object here.
00:35:34.180 - 00:36:01.814, Speaker A: Yeah, I don't have more time to go through this. So that's how you write a go tracer. And I want to quickly mention what's coming next on this front. So you saw the trace call method. I'm planning to work on the trace multicall. This is when you will have a list of call objects. They will be executed sequentially, maintaining the intermediate state as they go to the next call.
00:36:01.814 - 00:36:20.660, Speaker A: And the other thing is the trace namespace, or as other people refer to it, as parity tracing. So these are the things on the roadmap that are being worked on right now. And on the last seconds, that was it basically. Thank you guys.
00:36:22.710 - 00:36:31.270, Speaker B: Hi. Most of these will probably be available in the docs, but does trace to file exist for transactions only rather than just blocks?
00:36:31.610 - 00:36:35.046, Speaker A: No, I think what we have is only for blocks now.
00:36:35.148 - 00:36:39.906, Speaker B: Got it. Is Reexec available via JSON RPC?
00:36:40.018 - 00:36:48.838, Speaker A: Yeah, so I didn't show it, but basically when you do trace transaction in the same object that you provide the tracer name you specify. Rexec.
00:36:48.934 - 00:36:56.170, Speaker B: Got it. And does get accessible state return only the highest block number that has state or all block.
00:36:56.250 - 00:37:01.754, Speaker A: It will return like in the range that you specify. It will return the first state that it finds.
00:37:01.882 - 00:37:03.982, Speaker B: The first. So the early one.
00:37:04.116 - 00:37:10.180, Speaker A: So if you want to get all of them, then you have to iterate. You have to narrow your range as you go.
00:37:10.870 - 00:37:13.202, Speaker B: So if I did Genesis to now.
00:37:13.336 - 00:37:22.790, Speaker A: If you need Genesis to now, then it will give you the first one, like let's say it's block ten, and then you do another call from block ten until now and so on.
00:37:22.860 - 00:37:45.342, Speaker C: Hey, quick question on the state diff tracer. So does it provide kind of, if there are multiple state changes in a transaction, like at the call level, do you provide all of those state changes or is it just from the beginning to the end of the transaction? What is the state diff? I may have missed this.
00:37:45.476 - 00:37:51.646, Speaker A: Yeah, it's only from basically throughout the whole transaction. Okay, you mean for call level?
00:37:51.748 - 00:37:52.158, Speaker C: Yes.
00:37:52.244 - 00:37:57.434, Speaker A: You want the site diff for code? No, it's all for whole transaction.
00:37:57.482 - 00:38:00.314, Speaker C: But this is something, a custom tracer.
00:38:00.362 - 00:38:12.360, Speaker A: But yeah, you can definitely do that. Yeah, you can just check the code for the prestrace tracer. It's in the same directory that I showed. I don't think it will be very hard to do, but thanks so much. Thank you.
