00:00:25.170 - 00:00:53.914, Speaker A: Signatures. It's a scheme for public signature aggregation. And it's something that is quite used in around two because of a specific property, which is it can be aggregated. It means that you have two signatures, you aggregate them, you got a single signature. You have 1000 signatures, you aggregate them, you got a single signature. Okay, isolation, there's a drawback. The verification is quite slow.
00:00:53.914 - 00:01:41.580, Speaker A: It's a few milliseconds thousand times lower than many verifications. So we got this in the term two and by simplifying a little the white shoes in the term two, you've got validators, they sign attestations. You've got thousands of validators, they sign thousands of attestations. But when you're going to check us attestations, when you're receiving a block, you won't have to check all the signatures, you would get actually all the signatures because a block proposal with someone in the middle will aggregate them. And what you will have in the block is an aggregated signature and not the whole block. So it means that it's much smaller. And even if one verification is slow, you're saving thousands of verifications, so you're quite happy.
00:01:41.580 - 00:02:30.090, Speaker A: More details on what it means to aggregate an aggregation is both commutative and associative, which means that you can do that in any order. Okay, that's very good for parallelization. You can have one set of signatures aggregated by someone, another set aggregated by someone else. And then you take this, you aggregate and you're done. Except that this small point, which means two sets, the same signatures. When you aggregate, you will have something bad which is basically twice the signature, which is a little bit complicated to verify. So if we simplify when you aggregate signatures, you don't want to aggregate twice the same signature.
00:02:30.090 - 00:03:29.920, Speaker A: The fact that you can aggregate them means that oh, there are aggregation protocols around, just use one of them and I will be there. And there are, I will not say thousands, but dozens of Abrogation protocols. But none of them is bionte tolerant and fast. Some of them are bionte tolerant, some of them are fast, but none of them is close. So if I ask what ondal is about, you can guess that it's aggregating the signatures being fast and we say fast. It's thousands of signatures aggregated in seconds. Bison Internal so you're going to aggregate between thousands of nodes and some of these nodes will try to put the protocol down by timing, definition, by zone, they can do whatever they want.
00:03:29.920 - 00:04:43.414, Speaker A: And in real life what you will have nodes that are just dead and not responding. And we want something to be versatile. I mean by this, that in a network you will have thousands of nodes with different capacities, some of them very fast, some of them are very slow and with different network capacities. Some of them will be really well interconnected. There will be some wax, of course, very well connected wipes and lodge will be somewhere in the middle of nowhere. So we want to I guess with all this and what does it mean for ETRM? A possible plan to use Android in Ethereum could be visual if we look at the specification a week ago, what we add is basically in a shard we target to have a committee size of 100, but we can have up to $4,000. So the idea here is, okay, if you can agree quickly, we don't really care about the size of a committee in this one, it will be basically 1 second of the time as well.
00:04:43.414 - 00:05:29.150, Speaker A: In the theorem you become shame committee. So there is basically everybody and you try to aggregate from the become shame. And at this point what you want to have is safety. A possible way to do things is let's select a subset of the nodes from both committees, 16, and let's ask them to do the aggregation for the bigger. And you will have at this point an aggregation between 16,000 nodes. And you want this to be fast because the plan is if we can be very fast around one or 2 seconds for this whole application to happen, it means that in two blocks you've got your finality. So that's what we want to do.
00:05:29.150 - 00:06:04.690, Speaker A: And we said that it doesn't exist today, we don't have such protocols. So how do we do that? So when you have such a problem, basically you're looking at complexity. You're going to look at time complexity and message complexity and you will start more or less on this side if you can, and you don't want to be on this side of this part. Okay? And we will see that some protocols as JLS signatures are quite easy to aggregate. It's very easy to parabolate. So time complexity is easy to get. However, message complexity is much more difficult to have and it can become totally very unique.
00:06:04.690 - 00:06:57.710, Speaker A: So the first things to look at is just a simple gossiping solution. By simple gossiping you just fluid basic gossiping stuff. You're just sending your signature to everybody. Everybody does that and at the end someone like my guess, okay, and it's not that bad actually. So it has very simple and it's not absolutely bad. You will have this time complexity in lock N basically because it's a peer to peer network and you expect that some interconnection. So the time complexity is good in joy and the message complexity, if all the nodes in the network want to send one signature pitch and to receive all the signatures, it's going to be N square minimum depending with a floating protocol it will be more, but the complexity will be N two, but with a constant.
00:06:57.710 - 00:07:54.130, Speaker A: And then you get some optimization with some protocol. And alterance went this way for example, and they aggregate with 2000 nodes. It's a fixed size much less than what we do. And they're around 12 seconds, which is an order of magnitude slow at one node. And they are quite clear that take eight years, which is not, especially if there are some bad nodes in this. And they clearly say, okay, guys, that is future work and we tried this, okay, we've got this issue with too many usages and so on. So what we try at the beginning is, okay, can we continue on the gossiping network, but can we kind of compressing things like if we can aggregate so as a bill, if we receive a signature, if we can aggregate, we will, and instead of sending our signature, we will send something aggregated.
00:07:54.130 - 00:08:51.190, Speaker A: It implies that you verify at this point, because if someone sends you a bad signature and you aggregate without verification, then your own signature will be bad. So when you start to do this, you have to verify what you're doing, the aggregation that you're receiving, and you really want not to overlap, because if you're sending something that is aggregated and someone else has aggregated and there's an overlap, you're dead, you can't okay, so you need to solve this. So what we did at this point, okay, actually we know all the signers, there's a known list in this committee. So we can give them an ID just by using the public key that we know, we just service and the position in the oil will be their ID. So we know that we've got now a set of nodes with no holes. That's perfect. So here in this example, that's eight nodes ID zero, one and so on.
00:08:51.190 - 00:09:50.890, Speaker A: And we are kind of organizing the aggregation by saying okay, but node zero will aggregate the signature from node one and that's it. So if you receive a signature from node one, it aggregates, if not, sign for node two and three, four and five and so on, and you can go then to the next level if you have aggregated zero and one and now you receive two and three, well aggregate, okay? So that's the strategy. It's nice, it's nice, but the problem is the more it goes, the less difficult, the less possibility to aggregate. Basically, what you will receive is something difficult to aggregate. So you start to tune things saying okay, we'll wait a little bit longer and so on. So you can do things, but you feel quickly that it's not going to fly very long, so you need to do something better. And at this point we introduce a set of techniques.
00:09:50.890 - 00:11:05.620, Speaker A: So actually, there's someone worked on this in a non Python context ten years ago, and it's as if it's some logic of, okay, you know what? We're going out, and you're going instead of kind of hoping that you will get the signature from one at the point you're just organizing things, and Zero is going to send its signatures to one because it knows that one will emulate it. Okay? So there's a kind of first form, first level, and at this level zero sends its signatures to one, one to zero, two to free, we do two, four, okay? And then we can aggregate. So it's aggregated and it means that at the next level, when zero and one we exchange this aggregate signature with two and three. The aggregation will always succeed because the tree and there's no overlap by definition. And then you go to the next level and so on and so on. So basically you got log N levels, which is good for time complexity if one node is down. So care this level migration is just zero and we will aggregate with two and three and that's it.
00:11:05.620 - 00:11:54.506, Speaker A: And if we got more nodes down, it was something. Nothing will happen at the first two levels and it will happen later. There's still a little bit issue when I say it how do I know what to notice down? Do I have to wait forever? And actually, I don't know what to notice sound by definition in the distributed system I can see that I won't receive anything, or that it does not reply, but I don't know. And it's worse because it's a bionic context. So it can pretend to be there, but not really be there, can send out a signature or third of the signature, whatever. Okay, so the way we do that, first, we push the information, we're not querying someone to send us something, we just say here is our signature aggregate. And second, everything happens in parallel.
00:11:54.506 - 00:13:23.920, Speaker A: So we're not waiting for an answer from node one, or we're not waiting for a signature from node one to start the so zero at the beginning is going to communicate with node one, but as well with node two and three. Of course at this point it doesn't have a signature from one and in this case it is never right, but it's okay, it starts so zero will say okay, you can aggregate my signature. So at this point maybe two will have zero to three and if we look at the others to do the same thing, they will start to negative and then they will have updates potentially that will give them the full data so can represent it like this communication all over the place, in parallel, whatever. So it's organized but you communicate with everybody without waiting, which is obviously an issue, you have thousands of nodes because what I'm saying is let's communicate with everybody white but if I don't want to kill the network, I have to organize things a little. And the way it works, we basically have the dissemination period, which is 20 milliseconds and every 20 milliseconds we contact a new set of nodes and we progress in the levels. So for each level we contact a new node and so on and so on. So at the point it will reach a threshold, we just don't go well but we continue every 20 milliseconds to contact another.
00:13:23.920 - 00:13:58.310, Speaker A: So does that have assumption that le nodes have other nodes here. Yes, very good point. Yes. You know the difference between the pure sipping and this one is this one. You know where is or not? I will have a lot of slides at the end of the fact that you know where it's or not. So you know it's ipomas. So you know all of so in Ethereum, you know the list of members of the committee, but in the it actually has a limitation of the nodes.
00:13:58.310 - 00:14:36.674, Speaker A: So the way it could work is at the beginning when you're a member of a committee, you say oh, actually as an aggregator, I will speak at this address. And then you're not doing Gossiping Connection, you're doing a direct TCP connection with P, two P. But it's a UDP message or a quick message. Actually we try to return UDP. I will have a lot of slides on this, but you understood correctly. Basically you're doing, if I simplify, you're sending a UDP message. Zero knows the UDP address of this one and this one, this one.
00:14:36.674 - 00:15:25.394, Speaker A: But all the UDP addresses are known and zero is sending a message directly to this one. It's a full direct communication. I will have more details on that. So if we do that, basically we will have a login each steps for sending login messages and I will have some slides. So the part is, okay, how do you know that you're not going to contact all the nodes that it's going to finish? There are some maths on that. So there's a test that I will present and as well there's a proof that it actually works and that you need to send login message to reach the threshold. Just random stuff.
00:15:25.394 - 00:16:18.742, Speaker A: And from a mathematical point of view it's based on concentration inequality to be sure that you won't have a set of nodes that won't reach it. The question is, are we sure that we won't have a subset of nodes that will be very unlucky? And the question is to validate that if you're very unlucky, you still have and everything is harder for people to just to say that it's complicated. It's not that complicated. And the last thing that I'm going to present is this ranking and indoor. So the point is we said we want to support very different kind of nodes. So some nodes can be very slow and we said that the VLS signature verification was very expensive and we said as well that when you aggregate you need to check that it's correct. If not, you're just going to create a mess.
00:16:18.742 - 00:17:42.314, Speaker A: So because of this, some nodes won't be able to catch up with the number of verifications that they receive and they may shake signature that are not very interesting while you've got some aggregate signatures that are much more complete because they received it later. Okay, so because of it you just have a scoring mechanism which is how much are you improving the signature that I have already. So we've got a scope. When you have a scope in the binary context you can have binance inverts that will say oh, here's a grant signature, verify it and actually the signature is invalid so you will have wasted five milliseconds of your verification time, which can be a lot. So the idea here is to have a working of the nodes and this work allows us to say okay, at this point we should be contacted by those nodes and we've got a window that seems more or less logic. So we look into this logic into this window and we take the best part inside this window and if it seems that people are nice here, we increase the window size and if people, if we see that some signature are failing, we say oh, someone is likely trying to play with us. So we reduce the cycle and that's basically the main mechanism surrender this fact that we're contacting the notoriety.
00:17:42.314 - 00:18:22.030, Speaker A: We've got a tree based organization, so we are sure that we don't have any overlaps in our aggregation. We do verify our signatures plus coordinating. Now if we take this we don't have any sponsorship for Amazon but that's where we get it. So we run it on ten different regions in Amazon. So some of them you can see that it's quite fast. If you want to go from Frankfurt to Dublin, likely it's twelve milliseconds. But if you want to go from Frankfurt to Sydney it's 282 milliseconds.
00:18:22.030 - 00:19:37.718, Speaker A: And so we took this terra. Jones we used the small node from Amazon so it's a one curve and 1GB of memory and we wanted 2000 of them. And we put two nodes on each, 200 nodes on each Amazon node. Okay, so you basically have two process running this aggregation of each node. So obviously when you do that you're fighting our resources because with a single core for sure, but when verifying signatures the one is verifying and the other one is waiting for the others. So we consider that it's a more critical context than the real one but that's the advantage of being much cheaper to tell than using 2000. And we compare with okay, so we just send the signature to everybody and we add basically what was expected is a lot of data and a lot of time because you start to lose messages compared to and, which is for 4000 nodes, a full signature, 99% actually in a little bit less than 1 second.
00:19:37.718 - 00:20:50.054, Speaker A: Same for this month terms of data. We can see that we have 50 data exchange for our balance, seven megabytes, but fair enough. And we tried on Amazon if some nodes are not responding and so we compare the time to reach the agreements depending on how many nodes you have available. So if you try to reach 40, 51% threshold while all the nodes are there, it's obviously quite fast, around 600 milliseconds and it's getting a little bit slower. You're missing some nodes because basically at this point you want all the nodes to answer and you're around 8 seconds. So we tried on simulations, more complexity, things like attacks. So for example, this one is the case of you've got bagnant nodes sending you while you're trying to project with test signature with 90% of the nodes being bagnanting.
00:20:50.054 - 00:21:42.480, Speaker A: So quite a lot, it's a logatic scale so it's still around 10 seconds in this context, which is reasonably of course in this context you just want to have a 10% threshold. So that's in the paper now, the point that you are mentioning, the fact that it's a direct connection, that's an interesting point. Let's try this idea of an IP address. So if you have a gossiping network, you do have IP addresses and they're actually you can get an access to them but it's a little bit hidden. You can pretend that you're not known on the network and nobody knows that you're actually participating. It's alive because it's quite easy to find who is actually on the gossiping network but it's a little bit hidden while air is not hidden at all, it's entirely visible. So a lot of points on this.
00:21:42.480 - 00:22:36.080, Speaker A: And for example, Dos, there's a key point which adds a little bit of complexity under, but the fact that you're pushing the information and you don't do queries. Okay? So we don't have to answer, like, a TCP query or something. We're just pushing things, which means that if we manage to have a single packet to go doubt, we're happy. So we think that because of this an attack is still possible clearly, but it requires some hard work. Big question anonymity we know the contributors, we know their IP address and we know their wallet because they're stakers so we can do the link IP address wallet. That's bad. That's pretty bad.
00:22:36.080 - 00:23:51.878, Speaker A: It's pretty bad. But don't forget that even in the best network you can actually guess who is who because Validators will move from one committee to another. So you just have to follow which IP address have in which committee, look at what are the wallet speeds supposed to be participating and after 1 hour or two you'll be quite sure that you will have to want to have any advice. So it's a real issue but it's not purely specific and we can actually we pushed a proposal to a few weeks ago to remove this link by adding a set in the middle and this set allows us to say okay, we are known as a Validator but you don't know which Validator we are. So it's basically on the GKP playing with I'm a member of a group but I know one of the private keys, but I won't tell you who I am, but I can't do this twice. So it works as well. Anyway, for gossiping it's nearly independent and then you've got the issues of this IP address stuff and I don't think that's any miracle but it's how to add your IP address.
00:23:51.878 - 00:24:30.850, Speaker A: The well known solution is an onion like protocol like Tor. The problem in this is okay, it's going to be more expensive because Tor is adding onion protocol is adding loops in the middle. So we can't really try it. Because if we try to this we will write Tor. But we tried in the simulator to look at what it means if some nodes, 20% of the nodes are behind have an expalitancy of 1 second. And what we see is we're still agile and we still raise the business with 20% of nodes behind. That's a simulation conclusion.
00:24:30.850 - 00:25:03.822, Speaker A: The idea really is if you can aggregate very quickly, you can get finality very quickly. In our opinion it's something with three different components and I would say well defined. There's one component in charge of aggregation. There's one component in charge of having this cryptographic anonymity. We don't follow your publicity and there's a network anonymity, which is okay. You need an onion based system that doesn't exist today or not exactly, but could be done. And it's new way.
00:25:03.822 - 00:26:26.760, Speaker A: Any network system got this issue today. We've got a paper. The path that we use for the implementation is available and what we use for the simulation is available as well. And time is up. So I'm just take a question, you want that question? So is there these two categories that you want to handle? On which part of the Vegan node would it be for the engine application pool? So actually it's funny because the Atemis client is going to implement it and the way it's going to be implemented is by putting it on a separate node spirit process and setting it to aggregate. You will have one under process pair validator even if you know that we can share sometimes by default the ideas have something really decentralized so the fact that it can work with your small computers helps the decentralization. You don't need to have one big node that do a pre aggregation of 1000 signature for you.
00:26:26.760 - 00:27:39.322, Speaker A: So that's the main thing that even if we know that people will sometimes be passive is it crucial convergence you need to assume that the IDs around it but we shuffle them. You need to assume that you need to shuffle them. Exactly, we need to shuffle them, good point as well. Yes, we rely on a shared source of randomness to do this which is I haven't determined because it's not new in that error. We already have this in the future work we could prove that we don't even too much on randomness. But we haven't done this part yet because even if you don't have randomness, it means that you can choose your position in the tree and for example, you can say oh, I don't like this guy there. So all the biontinars will go next to him and will refuse to participate in the irrigation.
00:27:39.322 - 00:28:28.890, Speaker A: They will become two or whatever. However, if they do that, it means that they are not in another part of the network. So there's a dependency on the analysis and randomness. I'm not sure that in real life we depend so much on the randomness you can see. So it's finished. All right. It's finished.
