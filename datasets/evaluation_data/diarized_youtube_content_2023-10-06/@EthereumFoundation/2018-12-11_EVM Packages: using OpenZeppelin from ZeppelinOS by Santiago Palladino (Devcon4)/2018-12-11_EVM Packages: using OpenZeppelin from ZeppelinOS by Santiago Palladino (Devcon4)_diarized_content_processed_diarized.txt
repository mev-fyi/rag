00:00:00.650 - 00:00:42.442, Speaker A: Okay, folks, thanks everyone for being here, especially being the last of the lightning talks. Well, my name is Antiago, I work at Zeppelin. And today we're going to discuss a bit about EVM packages and how to reuse code directly on chain. But before we move into that, we should talk a little bit about proxies and the proxy pattern and how we use it at Zeppelin OS. Basically, the idea for the proxy patterns is to decouple the execution code and the storage layer when we work with a particular contract. So we end up having what we are calling the logic contract, which actually holds the code to be executed. And we have a proxy that actually keeps the storage and the state of the contract we're interacting with.
00:00:42.442 - 00:01:24.440, Speaker A: We call it typically the upgradable contract instance. So any client typically just interacts with the proxy without even knowing it's a proxy. This contract keeps track of all the state that we're interested in and simply delegates all the logic back to the logic contract. So for instance, let's say we have a typical ERC 20, which implants a transfer function. The proxy just keeps track of the implementation address of this logic contract. So whenever there is a transfer call, let's say it's simply delegated to the ERC 20 contract. For those of you who know about this little opcode, this basically allows us to execute code from here while retaining the state and the context from here.
00:01:24.440 - 00:02:10.390, Speaker A: Okay, so a nice benefit of this, besides the gas savings, for instance, is that this allows us to update to a different implementation. So let's say we find a bug or want to improve or whatever it is on the rc 20 contract, we simply deploy a new logic contract. We update the implementation address on the proxy contract. So all subsequent calls are delegated to the new implementation while retaining the state here and retaining the address that all of our clients are interacting with. Okay, so now let's move into EVM packages. So going back to the example we had just a couple of seconds ago, let's say we have an ERC 20, and let's say we want to actually deploy more than a single proxy. We want to have multiple tokens.
00:02:10.390 - 00:02:48.146, Speaker A: Okay? Thing is, we don't need to deploy more than one logic contract. We only need one copy of the code that's actually going to be executed. This allows us to spin up multiple proxies, each of these representing a different token, all of which will be delegating to the single implementation contract. Moreover, all the proxies can actually belong to different projects. They can be managed by entirely different development teams. And they all can rely on the same single implementation contract deployed on the same network. And furthermore the implementation contract can even manage by a fourth by a different team.
00:02:48.146 - 00:03:36.958, Speaker A: So we could have a team that works just deploying implementation contracts for standards such as ERC 20, C 21, whatever you prefer. And then you have the users or the clients of this code that can be completely different teams that will just deploy their new tokens pointing to this particular implementation. Mind you that while these contracts are upgradable, this one is immutable, this one is fixed. So this means that if any project wants to work with a new version, they simply need to point to a new one. So basically what we are doing is we are standardizing this concept into EVM packages. EVM packages are a collection of related contracts that are deployed on chain for other projects to connect to and reuse directly on chain. So this is basically a form of code sharing entirely on chain.
00:03:36.958 - 00:04:38.994, Speaker A: So in case the owner, the developer of this particular EVM package, again finds a bug, an improvement, or whatever it is on ERC 20, they only need to deploy a new version. And then it's up to the project, to the users, to the clients of these logic contracts to decide whether they want to upgrade to opt in to this new version that is being deployed. So one of the first EVM packages that we are pushing is open Zeppelin eth. This is basically a fork of open zeppelin solidity that's billed as an EVM package. For those of you who don't know, open Zeppelin is a set of reusable smart contracts. We have implementations for some of the most common standards such as ERC 21 and a handful of utilities as well. So what we are offering right now, pun not intended, is basically an implementation on chain already for ERC 20, cent 21, and also a couple of goodies for token vesting and splitting payments.
00:04:38.994 - 00:05:38.098, Speaker A: All these contracts are already deployed on chain. If you go to Mainnet or to any testnet where it's Robstand, Rinkabi, Cobank, whatever it is, you can link to these contracts, you can spin up new proxies pointing to these implementations, and you don't need to redeploy the code for your c 20 or cent 21 every time you want to deploy a new token. You basically delegate the development of these standards to the development team behind open Zeppelin, and you just act as clients of that code directly on chain. Of course, this package also has all the contracts from opens Uplin, you know and love and already set up to be used in an upgradable context. And yes, these are really all the contracts within Opensupply. So how do you actually use this from a user perspective? This is where Zeppelin OS comes in. Zeppelin OS basically leverages the proxy pattern for providing upgradability and also code sharing using the EVM packages pattern.
00:05:38.098 - 00:06:39.862, Speaker A: So Zeppelin OS provides a handy CLI in which you can specify which EVM packages you want to use as dependencies. You use the link command for specifying that, and this is basically going to gather the information for opencept and allow you to create new operatable instances or proxies directly from the command line, specifying whichever initialization arguments you are interested in. For instance, here we're creating an ERC 20 instance named my token with egg decimals and giving this address 100 tokens to begin with. There are other ways for interacting with zappolinos. We are providing JavaScript libraries as well if you don't want to play around with the CLI, but this is by far the easiest way to integrate with. Okay, so to recap, EVM packages basically is a new standard that allows us to share code directly at the bytecode level by having the code already deployed and having the users just link to it. This allows for Gasco savings because you don't need to redeploy the implementation contracts every time and make it easy for upgrades into a new version.
00:06:39.862 - 00:07:13.990, Speaker A: You just delegate to the developer for the package and you choose when you want to work with a new one. And we're providing zeppelin OS as an easy way to both publish and consume these EVM packages. And one of the interesting things is that opens up ETH is not the only VM package going around. We have a lot of very wonderful teams also working on their own EVM packages. Some of these are already available on Mainnet. We have packages for oracles, for tcrs, for multisigs, for a handful of things. We'll be releasing even more and partnering with more teams as time goes by.
00:07:13.990 - 00:07:29.766, Speaker A: So thank you all. Hope you enjoyed the talk. And sorry I have to say this, we are hiring look for us, any of us, with a zeppelin t shirt. We are a distribute team. We are growing. Please, if you're interested in this, let us know. We'll be happy to have you on our team.
00:07:29.766 - 00:07:30.140, Speaker A: Thank you.
