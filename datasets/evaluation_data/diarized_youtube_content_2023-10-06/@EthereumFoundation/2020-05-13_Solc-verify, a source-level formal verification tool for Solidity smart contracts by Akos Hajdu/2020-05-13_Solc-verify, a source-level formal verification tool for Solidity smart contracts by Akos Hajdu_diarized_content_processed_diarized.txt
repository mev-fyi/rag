00:00:04.330 - 00:01:28.498, Speaker A: So today I'm going to present you SOLC verify, which is a source level formal verification tool for solidity. I'm actually a PhD student at the Budapest University of Technology and Economics, but this is a work that I've been doing together with some people from SRI International. So coming back to verification, there's a wide selection of verification tools available for solidity and Ethereum smart contracts ranging from testing tools and fuzzers all the way to static analyzers, symbolic executors, and also formal verification tools like you've seen case solidity. There's also going to be some more talks on this topic later, and these are all pretty good tools, I would say, and they all have their strengths and application areas. And with today's talk, I would like to convince you that our tool saucy verify also has its place in this landscape, and it can also provide you some useful features that other tools might not. So let me start right away with a quick demo on what you should expect. So here's a really basic contract.
00:01:28.498 - 00:02:24.122, Speaker A: It has two state variables, x and y, which should always be the same. The constructor sets them to a starting value, and then there's an add function which will just increment both of them with the same value. So basically, when you say that these two values should always be the same, except of course during some intermediate steps within a transaction, basically by this statement you are formulating a so called invariant over the contract, and invariants basically must hold before and after every transaction. So roughly speaking, before and after the execution of every public function. Now, with Saucy verify, you can actually express this as in code annotation. You can say we use this special notice doc tag. You can say invariant x equals to Y.
00:02:24.122 - 00:03:18.246, Speaker A: So then you can just run saucy verify on this example, and it will tell you that we found no errors. Both the constructor and both ed satisfy the specs. But for example, if you mess something up, you forget to initialize value, or you do some wrong arithmetic operations. Then we can report that there are errors. Your invariant is not satisfied by, for example, the constructor, or for example, by this add function. So. So, as you've seen, saucy verify takes smart contract annotated with these specification exceptions, for example, invariants.
00:03:18.246 - 00:04:18.090, Speaker A: But I will also show you many more in today's talk. And we are using our extended version of the compiler from which we reuse parsing, reference, resolving, and type checking in order to build an ast. And then we traverse this ast and translate it into a boogie program which has formal semantics. And basically by doing this translation, this is how we give a formal meaning to the solidity language on which we actually spent a lot of time. As also highlighted by the previous talks, there are many corner cases and interesting stuff, especially going around with the storage and memory and reference types and things like that. I will have some links at the end of my presentation to some of these papers. So then this boogie program can be passed to the Boogie verifier, which is a modular program verifier.
00:04:18.090 - 00:05:35.506, Speaker A: It was originally built for object oriented programs, but since smart contracts are somewhat similar to classes, boogie is also a good match for smart contracts. And what boogie does is it checks the program by discharging these verification conditions to logic solvers, SMT solvers which have a sound mathematical basis, and they support various theories such as arithmetic arrays, data types and so on. And these solvers can return proofs or refutations. So boogie can tell if the boogie program is correct or not. And of course, in order to be useful for the developers, we back annotate these results to the original contract, as you've seen it in my demo. So when we say we perform formal verification, it is important to note that we prove functional correctness with respect to the specification that you wrote. So if you don't have any specs or you have some problems in your specs, of course, then the results of the formal verification cannot be trusted.
00:05:35.506 - 00:06:48.350, Speaker A: But that is how these things usually work in common, and we are also not targeting these common vulnerability patterns. Besides some examples that I will present you like overflows and reinterrency, there are many other tools for that. Our focus is really on these functional specifications, and these specifications can be implicit coming from the code, like for example checking for failing assertions or checking for overflows. But as I presented you, our main goal is to provide explicit annotation possibilities, like for example invariants and the other ones that I will present you in a moment. And basically SoC verify performs modular verification, which means that functions are verified independently from each other to give a better performance and scalability. And basically each function will have a precondition and a post condition which might come of course from invariants. Like for example, in the example we have a precondition that x should be equal to y and then we execute the body and the post condition should hold.
00:06:48.350 - 00:08:10.522, Speaker A: So basically this is what we want to check given the precondition, does executing the body guarantee the post condition? And this can be done, or this is done by translating the specs and the function to SMT formulas by boogie and feeding it to two solvers. This is what boogie does in the background. So if we start with the same x and y, and then we increment both of them with one, then can we prove that they are afterwards the same end? This is what Smt solvers can basically prove. And if, interestingly, if there are other functions that call each other, like for example, here's a function g which has its own pre and post conditions, and it will call f. Then in order to be scalable and efficient, basically we substitute the call with the specs, which basically act like a summary of what the function is doing. So just speaking a little bit about these implicit and explicit annotations, you can see a similar contract here which has x and y, and there's a function to add some integer which will just call another function to add it to x, and then in a loop it will increment y. Just for illustrative purposes, it does some of this stuff.
00:08:10.522 - 00:08:51.266, Speaker A: And solidity provides some of these implicit specs. Like for example, you can write, require, and assert statements. But in order to give more flexibility, we developed our annotation language to explicitly provide specs. And I will tell you or introduce you all these in a demo. For now, I just want to quickly summarize, what are the possibilities? So of course we support pre and post conditions. You already saw contract level invariants like X should always be equal to Y. We also support loop invariance.
00:08:51.266 - 00:09:29.026, Speaker A: This is required because of this modular and efficient reasoning. These are basically formulas that should hold on entry and on every iteration and on exit for the loop. But we also support fine grained access control. We can, for example, specify that the function should only modify state variable x if a given condition holds. We are also working on specifying events. If I have some time and you're interested, I can show you some examples. And these annotations are essentially side effect free solidity expressions that are given in code.
00:09:29.026 - 00:10:04.894, Speaker A: So this way you don't have to learn a new language to write specs. And also the specs are not separated from the code, they are strongly tied together. And we also have some extra elements to be more flexible. For example, we can express the sum of the collections. I will show you some examples. You can refer to previous values of variables. And we are also experimenting with using quantifiers with which you can express properties like every element of an array is non negative, or for example, this array is sorted and this kind of stuff.
00:10:04.894 - 00:10:28.146, Speaker A: So let me get back now to my demo to illustrate these features. Also. In the meantime, if you have questions, feel free to ask. I will provide link also to these examples and to the slides. So let's see now a little bit more complex example. This is a typical token. It's a fixed cap token.
00:10:28.146 - 00:11:13.438, Speaker A: It has some total amount, and it has a mapping that keeps track of the balance of each user by mapping the address of the user to his or her balance, which is an integer. There's a constructor which will just set, which will just put all the tokens to the creator. And there's a typical transfer function which does some checks to make sure that the transfer can happen, and then it does the transfer by changing these values. So for these kind of tokens, it's pretty obvious that you would like to have some high level functional properties. For example, with the fixed cap tokens, it makes sense to specify that the total amount equals to the sum of individual balances. This is actually an invariant. It must always hold for the token.
00:11:13.438 - 00:11:55.742, Speaker A: And you can express it in a way that saying an invariant, the total should be equal to verifier sum. You int this is a bit ugly. It's something that we are working on it, but for now you can express it with this special function so that we don't have any collisions with other already existing functions. Balances. So the total amount should be equal to the balances. So now you can run saucy verify on this example, and it will tell you that yes, your contract is correct. But for example, if you mess up something, it can tell you that the invariant is broken.
00:11:55.742 - 00:13:01.764, Speaker A: However, this is alone not enough. Like for example, I can just swap the minus and the plus so the transfer still takes place. And actually the sum of the tokens will stay constant. So the verifier will say that this is correct, modulo the specs that you wrote, because it still holds. In order to verify these kind of properties, we have to give some extra conditions. We actually have to state what a transfer does. And what the transfer does is basically you want to make sure that you have a post condition that after the transfer, the balance of the message sender should be equal to the old value of the sender minus the amount that was transferred, right? And the same or similar should hold for the receiver.
00:13:01.764 - 00:13:36.964, Speaker A: Let me just cheat with that. So the balance of the receiver equals to the old balance plus the amount. So now if you run the tool on this example, which is still swept, so it's wrong. Now it will, I made a typo. It's not balance, but balances. This is the benefit of reusing the compiler, and I guess I also have to fix it here. But now saucy verify will basically report that this condition does not hold.
00:13:36.964 - 00:14:29.408, Speaker A: So then if you actually fix it, you make the transfer in the correct direction. Then we will be able to prove that your specs hold. Okay, so this is one example on why these specs are important. So let me show you again a little bit more complex example. This is the same token. It's just that now I'm using this batch transfer function, which can transfer some amount of, some value of tokens to an array of receivers. It does some checks on the length of the receivers, it calculates the total amount, it checks that the sender has this amount, and then it subtracts this amount from the sender.
00:14:29.408 - 00:15:43.740, Speaker A: Then it uses a loop to transfer this amount to each receiver step by step. And for most of the operations it is actually using this safe math library, like for example, the subtraction and for the addition. But there was this famous bug where developers forget to use it for multiplication, which could result in a potential overflow and basically a generation of tokens out of thin air. So if you run saucy verify on this example, maybe I will just move it a little bit so that it's visible. You have to turn on overflow checking that you can do with the special flag, and it will tell you that there's a potential overflow. But if you fix it, you are using multiple from safe math. Then it's no longer reporting any false overflow alarms, which many of the tools actually tend to do.
00:15:43.740 - 00:16:32.616, Speaker A: But just because there's no overflow, it does not necessarily mean that the functional properties are met. So now we can, for example, just put back our invariant that the total number of tokens should be equal to the sum of the individual balances. And we might want to try to prove that this will fail because we have a loop. And in this case, the verifier actually needs some loop invariant that must hold for the loop. This is required because of this verification approach. And one invariant that we need is that the loop counter is always less than equal to the receiver's length, which it can be equal, because when it exits the loop, it's equal. And we need also the contract level invariant, but a slightly generalized version.
00:16:32.616 - 00:17:14.708, Speaker A: So when we are doing the loop, the total amount of tokens equals to the sum of the balances. But since we first subtracted the amount, and we have not made all transfers yet, we have to add those transfers that we have not made yet. So we still have length minus I transfers to make. So this should be added. And with this invariant, now we can verify this example. And this is an interesting example, because it's pretty complex from a verification point of view. There's reasoning going on over like bit, precise reasoning going on over 256 bits.
00:17:14.708 - 00:17:49.780, Speaker A: There's invariant. There's also some nonlinearity. So this is a pretty nice example of what we can achieve in terms of performance. Let me show you another classic example during intransing here. Yes, sure. Does it also work if you use the symbolic multiplication instead of the safe mass multiplication? So does it find the error? Rephrase. So does it find the error? If you use the asterisk for multiplication, but do not turn on overflow checking.
00:17:49.780 - 00:18:30.960, Speaker A: So this is a good question. If you do not turn on overflow checking, then it will not find the issue. Because essentially in this case, your spec holds. Because if there's an overflow in the balances, then basically there will also be an overflow in the sum of the balances. And because we have this symmetry, there are two overflows, they will cancel each other. So, yes, really good question. And this also highlights why you should pay attention on what you are actually verifying and what are your specs and what's your configuration.
00:18:30.960 - 00:18:32.530, Speaker A: Thanks.
00:18:33.300 - 00:18:35.730, Speaker B: Can I also ask some stuff?
00:18:36.740 - 00:18:37.890, Speaker A: Yeah, sure.
00:18:38.660 - 00:19:02.350, Speaker B: Okay. Yeah, thanks for showing this. Also verified is really nice. And I think we're doing very similar things as everybody talks with Taeyeon. So I have actually multiple questions, so maybe we take them offline. But one question that I wanted to ask now is for the loop invariant, and also maybe for the contract invariant, do you try to verify them as well, or.
00:19:04.160 - 00:19:16.370, Speaker A: Do you assume them to hold the invariants? We are verifying them, so you have to manually write them. But if you write them, then basically we are essentially verifying them.
00:19:17.300 - 00:19:18.828, Speaker B: Also the loop invariance.
00:19:18.924 - 00:19:54.750, Speaker A: Yes, also for the loop invariance. So basically we will check whether it holds on entry, and then we will use an inductive proof which says that, okay, if it holds on entry, then let's check if for every iteration, if we assume them before the iteration, and then we execute one step, can we prove that it will also hold after the iteration? So it's basically an inductive proof. For the contract level invariance, we do the same. We prove that the constructor ensures it, and afterwards, for every function, we will assume in the beginning and assert in the end. Basically, that's the main idea.
00:19:56.160 - 00:20:19.380, Speaker B: And for these functions that you call like underscore, underscore verify something, because they didn't want to potentially have conflict. One thing that I've been doing to get an interpret function is basically to write an extra interface with names of functions, like with unimplemented functions that I want to use as an interpret functions.
00:20:20.040 - 00:20:20.790, Speaker A: Yes.
00:20:21.240 - 00:20:27.370, Speaker B: If you do that, you can also get like an ist for the function and the function call.
00:20:28.300 - 00:21:14.980, Speaker A: Yes, that's a good point. I've also seen other verifiers doing that. But I think our main decision, I mean, we were considering this method, but our argument against that was that. So in that case, I think you will have to include some other source file in your contract. So you have to actually modify your source code a little bit. And what we wanted to actually do is to have the original source code completely unmodified and just include everything in comments. So basically, when you would compile this contract with the original compiler, it would still compile and produce the same binary or ast output without these verification specifications.
00:21:14.980 - 00:21:20.040, Speaker A: So I guess both methods have their advantage and drawback.
00:21:20.860 - 00:21:26.810, Speaker B: Yeah, I can pause now if people have more questions, but otherwise I still have more questions.
00:21:27.820 - 00:21:36.156, Speaker A: Okay, maybe I will just continue for a while, and then in the end we can discuss, or we can also create a breakout room and take some of this stuff.
00:21:36.178 - 00:21:39.676, Speaker C: Also, just a heads up, we have like seven to eight minutes left.
00:21:39.858 - 00:22:27.336, Speaker A: Okay, yeah, that's perfect. Okay, so let me just get back to this other classic example, the reintrancy, which is usually illustrated by this simple wallet where you keep track of balances in terms of ether, and you have some deposit function which is payable so that users can deposit. You memorize their balance, and then you have a withdraw function where the users can specify some amount to be withdrawn. You do some checks, and then you use this call function to make the transfer. If it fails, you revert, otherwise you deduct the amount. And this is a well known bug, like for example, from the DaO for re entrance. And many of the tools actually, like even the linter from vs code will tell you that you should not use this call because it's dangerous.
00:22:27.336 - 00:23:08.760, Speaker A: And here we also have an invariant which says that the sum of the balances should be less than equal to the balance of the contract. It's less than equal because on self destruct, this contract can receive some fund. So it's a slightly generalized invariant. But also in this case, if you run Solc verify, it can tell you that, yes, this is dangerous. There are errors, because when you are making this external call, your invariant does not hold. Your contract is in an inconsistent state. However, what many of the tools tend to do is just like if you have a call function, then that's dangerous and you should not use it at all.
00:23:08.760 - 00:24:07.772, Speaker A: But for example here, if you actually fix the contract and you first make the deduction, and then you do the transfer, then if there's even a reentrancy, it's not an issue anymore because the check will not succeed. So this is actually safe to do. And in this case, if you run the verifier, it will tell you that yes, basically your contract is fine, modulo, of course, your specs. So it can check whether, when you make the external call, whether your contract is in a safe state to make this external call. Okay, so just because that there's an external call, it does not necessarily have to be dangerous. And let me just get back to a final example for this fine grained access control. So here's a contract which implements a simple storage users can store some data, and for illustrative purposes, let's assume that it is now just a simple integer, and we have a flag that indicates whether this data has been set or not.
00:24:07.772 - 00:24:54.460, Speaker A: So we have a mapping for entries. We have an owner who will have some special permissions, we have a constructor to set up the owner, and we have some other functions. So let's first start with a function for changing the owner. And here what you want to really make sure is that it will first of all not modify any of the data. And then it can only modify the owner if it was called by the actual previous owner. And you can specify it with the following tag which says modifies owner if the message sender is the owner. So you can only modify the owner if it is indeed the old owner.
00:24:54.460 - 00:25:40.216, Speaker A: Here, just for illustrative purposes, I introduced the set data private helper function, which will take an entry in storage as a storage pointer and some data. And it will set this data, and it will also set the flag. So since this is a storage pointer, it can basically modify any of the entries. So we just specify that it can modify the entries. Now you have the add function where a user can set some data by first checking that the data has not yet been set. Then it takes the pointer and calls the set data. So now you can specify it that it modifies entries, but only at the address of message sender.
00:25:40.216 - 00:26:37.780, Speaker A: So you are not allowed to modify someone else's entry if, and only if this has not yet been set, then you are allowed to do this modification and you can do similarly for update and so on. Since I'm running out of time, I will not show you that. But what's interesting is that, for example, if you specify update, it will call this set data, which modifies both the set and the data. There's syntactic assignments going on, but since the update will require the entry to be already set, you can specify that it will not actually modify this set field. Because it's true, it should be true. And when you make the call, you set it to become true. So just because there's some syntactic assignment going on, we can still prove that it's not a real modification.
00:26:37.780 - 00:27:22.284, Speaker A: But I guess I'm not going to finish this example. Let me just go back to my slides and wrap things up. You can find these examples in a complete form in the demo, in the demo repository. You can try them out. So, to summarize, I presented saucy verify, a source level formal verification tool for checking high level functional properties within code annotations. We have lots of supported annotations and we are using boogie modular verification and SMT solvers to achieve this task. And you can find it online on GitHub, it's open source.
00:27:22.284 - 00:27:56.664, Speaker A: We also have a docker image. You can also take a look at my website or my Twitter and you can find these examples and some papers. So I guess I'll finish now and let me know if it's still time for a few questions. Or we can also discuss online. I've seen in the GitHub that there's some discussion going on with tags right now. We use this notice because it was the easiest, so we could not really introduce our own one. Like we could not write, for example, at invariant or at precondition.
00:27:56.664 - 00:28:07.810, Speaker A: But if there will be some support for custom tags as discussion is going on, we could also switch to that. So that would be something interesting for us as well.
00:28:09.220 - 00:28:18.900, Speaker C: Okay, thank you so much for your talk. I think we would have time for one more question, if there is any more questions in the room. Ricard.
00:28:20.200 - 00:28:27.572, Speaker D: Yeah, so it looked like when you didn't have the loop invariant, for example, that salsi verifier reported an error.
00:28:27.636 - 00:28:27.960, Speaker A: Right.
00:28:28.030 - 00:28:40.830, Speaker D: But I would assume that the SMT server in that case would have run up in an unknown. So it didn't really disprove the claim, it just didn't manage to prove it.
00:28:41.440 - 00:29:07.380, Speaker A: Yes. Well, in this case, I think the actual report that we are getting back from boogie is that because there's a loop, the loop will basically have all the variables. So in the end, because of the loop, the conditions will not hold. But I think we could possibly detect that there's a loop going on without some invariants. So we could give some hints to the user that, okay, we are reporting an error, but it might be because there are some loops which are not annotated.
00:29:08.040 - 00:29:16.708, Speaker D: Yeah, because it would be interesting to see when you get an error. I guess what you want is a counterexample. Here's something that violates.
00:29:16.804 - 00:29:17.450, Speaker A: Right.
00:29:20.140 - 00:29:24.090, Speaker D: And when it's an unknown, it's an unknown. We couldn't prove it. So you need to hint more.
00:29:25.420 - 00:29:26.036, Speaker A: Yes.
00:29:26.158 - 00:29:27.710, Speaker D: Boogie doesn't support that.
00:29:29.280 - 00:30:05.770, Speaker A: Boogie has some limited support for generating error traces, but there's actually a different verifier called Corel. It consumes the same boogie language, and that's basically a bounded model checker. So I think what we could essentially do is to first run boogie to say, to check if it reports an error, or it can prove the property. And if there's an error, then we could do a second run with Corel, which will perform a bounded model checking. But since we already know that there should be an error, it will find a trace, or if it does not find a trace, then we know that the original error should just be like an unknown result.
00:30:06.940 - 00:30:07.912, Speaker D: Okay, thanks.
00:30:08.046 - 00:30:11.380, Speaker A: Yes, but, yeah, thanks for the question. Bye.
