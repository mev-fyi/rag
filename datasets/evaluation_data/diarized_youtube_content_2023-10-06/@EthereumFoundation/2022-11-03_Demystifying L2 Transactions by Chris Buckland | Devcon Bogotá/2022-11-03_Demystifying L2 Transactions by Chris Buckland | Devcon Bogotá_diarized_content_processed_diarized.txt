00:00:12.090 - 00:00:50.720, Speaker A: So welcome to the workshop. It's going to be quite hands on, so I was wondering how many people have laptops and are kind of ready to follow along. Yeah, okay, so maybe I'll do live as well. And if you want to follow along, that'll be great and do it yourself, that'll be good. So the topic of the talk is to look into what an L2 transaction is in the context of Arbitrum. So there are a range of different L2 S, but the one we'll use today is Arbitrum and L2. Transactions will differ between those, but some of the concepts will be passed between them.
00:00:50.720 - 00:01:31.320, Speaker A: So, yeah, there's some differences, some similarities. We'll go into some of those and I'll first give a bit of an introduction about what a roll up is. And that's what I mean by L2 in this context. And then we'll go into the workshop itself. Okay, so at a very high level, a roll up is a side chain. It's another blockchain, but it's connected to some sort of base chain by a validating bridge. And if you want to read more about this, there's a paper by Paddy who sat in the back of a room over there, so you can get more information there.
00:01:31.320 - 00:02:04.414, Speaker A: And this is a kind of rough overview of how it works. So you've got one blockchain at the top, which is the roll up. You've got the main blockchain at the bottom, which in this case would be Ethereum. And they're both progressing via state transitions. New blocks are being made. There's a bridge contract on the base chain on Ethereum, and periodically an operator will take the state of the roll up chain and they'll paste it into that bridge contract. Once it's in that bridge contract, it can be checked.
00:02:04.414 - 00:02:51.022, Speaker A: So in an optimistic roll up case, there's a fraud proofs that are used for checking that state. And in the case of a ZK roll up, it's just a ZK proof. But the other crucial thing is that green blob that I've put inside the bridge contract and that's data that's associated with the state transition on the roll up, you need a minimum amount of data to be able to recompute the state transitions that are occurring on the roll up. So in the case of optimistic roll ups, that's going to be the transaction data itself. And yeah, it just continues in the same way. And this would be the case where some data is put on chain, the fraud proof is checked and it's found to be invalid. So this is a kind of rough lifecycle of an L2 transaction.
00:02:51.022 - 00:03:35.046, Speaker A: So a user would create a transaction, they'd submit it to a sequencer who would then be collecting these transactions into a batch. When the sequencer has got enough transactions, they'll compress this batch using some standard compression algorithm. In Arbitrum's case, this is broadly and then they submit the batch to ethereum. So this green Blob is that batch there? Yeah. And another kind of difference between L One and L2 transactions is gas. So as I've mentioned, l Two transactions need to be submitted at some point to the L One, and someone's got to pay for that. So eventually that's going to be the user.
00:03:35.046 - 00:04:07.130, Speaker A: And that cost is associated with the call data that is required that is consumed by the transaction on L One and is priced at the price of L One gas. Then there's L2 gas, which is basically the same as L One gas, the same gas that you know on Ethereum, but it's at the price of L2. Right. So this is just the execution of the transaction that's occurring on L2. So you pay first to put the transaction on L One and then to execute it on L2. So there's these two different costs. And we'll kind of go into that in this workshop.
00:04:07.130 - 00:04:35.640, Speaker A: Yeah. So this is the URL. So if you go to this GitHub repo and you can start following down the set of instructions. So there's a set of prerequisites that include tools like Foundry, JQ, and Brotly itself. And you can start following the steps yourself, or you can watch me do it as go. Yeah. Okay.
00:04:35.640 - 00:05:24.690, Speaker A: Yeah. So I've included some useful links. At the top, there's some RPCs there to connect to both Arbitrum and to Ethereum, and just some other stuff, some general information if you want to read more about, like L One, L2 Gas, and some of the ways in which Arbitrum works that are relevant to this talk. Yeah, so these are the prerequisites. Git is just there so that you can clone this repo itself. We've got Curl for making some requests, foundry for using Cast. Cast is a kind of tool for helping you format Abi style functions, for calling the JSON RPC, JQ, just for formatting some JSON and Brotly, which is the compression algorithm that's used in Arbitrum.
00:05:24.690 - 00:06:05.374, Speaker A: Yeah. So there's a quick setup stage. I've already done this. I'll paste this in. Just check those are there. Okay, so the first step is we're going to send a transaction on L2. So I've already sent a transaction which you can use if you want in your example, or feel free to use your own MetaMask, connect to Arbitrum and send a transaction on main.
00:06:05.374 - 00:06:46.314, Speaker A: Net. At the moment, they're reasonably cheap, I think, so should cost you only a few cents to do that if you want to. But this transaction hash, if we look at it on Arbiscan, this is a USDC transfer, basically. So this is just transferring some tokens. And this is what we'll look into today. So I'll set that environment variable. And also feel free to like if you've got any questions at any stages.
00:06:46.314 - 00:07:14.658, Speaker A: As I'm walking through this, just stop me. Put your hand up. We don't have to get through all of this today. So just let's talk about it. And if you got questions, just put your hand up at any time. So first we'll kind of grab a transaction receipt for that. And there's two interesting things in this transaction receipt that you might not be used to when looking at L two compared with l one transactions.
00:07:14.658 - 00:07:52.270, Speaker A: So there's this l one block number, which is the block number that the l two sees of l one. So it's a kind of like the l one is it's reading the state from the l one occasionally. And one of those bits of state is the l one block number. You can access this as part of the Arbitrum EBM. And then the other thing is this gas that it used for l One, and that's what we're going to look into. So this is the amount of gas that was spent to send this transaction and get it recorded on l One. So we're going to store that in a variable.
00:07:54.610 - 00:07:56.120, Speaker B: And it.
00:08:08.490 - 00:08:52.470, Speaker A: And I'll just echo that out so you can see roughly what it is. So it's like 236,000 gas. So that seems like a lot when you think about just what it's doing. It's storing just a bit of data on the L one. But the reason why it seems like a lot is because this is in units of l two gas. So this has been scaled for what it would be if it was on L2, and that's just to make the accounting a little bit easier inside the inside of Arbitrum. So this amount, we need to find out what the ratio between the l two gas and the L one gas was at the time this transaction was sent to, then try and really figure out how much L one gas was used.
00:08:52.470 - 00:09:04.760, Speaker A: And from there, we can start to figure out as well, like, how many bytes of data it might have consumed. Yeah, so I'll store some of these variables as well.
00:09:09.530 - 00:09:10.640, Speaker B: It it.
00:09:31.410 - 00:10:20.866, Speaker A: Okay. Yeah. So as I mentioned, we need to find out this ratio of l two L one gas. So the roll up is estimating at any point in time what it thinks the l one gas price is. And it's a little bit more complicated than just reading the l one base fee because there's a time lag between when the sequencer processes the transaction and when it submits it onto the l one. So it does some kind of estimating and it moves its price up and down depending on how accurate it's been in the past to try and make sure that it keeps even. And so there's this get l one base fee function, which is what is really used by the Arbitrum virtual machine by Arbitrum sorry.
00:10:20.866 - 00:11:23.910, Speaker A: To figure out what L one gas prices it should charge. And there's a bit more docs here if you're interested in reading about exactly how that works. Yeah, and maybe we should go a bit more into that because I realized we were running quite quickly on time because I guess I thought everybody would be following along and there'd be lots of problems. But I'm a skilled pro at this, so it's going quite quickly. Yeah. So one interesting thing that happens with that estimation is that because the sequencer is having to try and figure out what the price will be when it submits to L2, it ends up wanting to overcharge, to not get out of pocket itself. So Arbitrum has a slightly different mechanism there where the sequencer is rewarded later for exactly how much they spent.
00:11:23.910 - 00:12:12.040, Speaker A: And there's a kind of a pool that sits on L2, and the pool starts quite full, and then the difference between what it was awarded and what it estimated in the first place is then reduced from the pool or added to the pool if it overcharged. And then this difference between what the pool target should be and what it actually is is taken as a factor into the future estimate of what the L One gas price should be. So the sequencer never ends up out of pocket. They always get exactly what they paid. But there is some mild fluctuation between what users pay now and what users pay in the future. So some users now might receive slightly less than what they get, a slightly better gas price than what they expected. Some might get a slightly worse one, but overall, it's quite close to the average, quite close to what you should be getting.
00:12:12.040 - 00:12:39.120, Speaker A: Yeah. Okay, so we'll call that pre compile at the block height. For this, we need an archive node, and we're going to call the pre compile at the block height when this transaction was sent on L2, and then we'll see what the estimate was at that time. Yeah, absolutely.
00:12:44.850 - 00:12:47.530, Speaker B: Long, like transaction.
00:12:47.690 - 00:13:10.778, Speaker A: So you, you want to know what the, what the estimate was at the time that the transaction was sent. So you need to know what the state of the node was at that time. And for that you need an archive node. A full node wouldn't be able to do this. Yeah. Say again? Exactly. Yeah.
00:13:10.778 - 00:13:37.870, Speaker A: I think full nodes do keep some recent historical states. I can't remember exactly how, but probably not a week's worth. Yeah. So to do this kind of thing that we're doing now, you would need an archive node, but this isn't something that you might normally want to do. This is just kind of like, let's go look at some of the analytics. It's not part of like, you don't need it to send transactions or things like that. And there are ways to get estimates for what these values are before you send your transaction as well.
00:13:37.870 - 00:13:59.974, Speaker A: So you know what you're going to spend. You don't have to wait and inspect it afterwards if you want to. Yeah, I think there was someone 1000. Yeah. Okay, thanks.
00:14:00.172 - 00:14:00.920, Speaker B: Yeah.
00:14:03.930 - 00:14:26.180, Speaker A: It'S not it's not a snapshot. It's just well, yeah. Okay. You need to know what the state was at that time, because this is stored in state, this L one base fee estimate. So at a different block height, the L one base fee estimate will be different. And we want to know what it was when this transaction was sent. Yeah.
00:14:30.630 - 00:14:32.740, Speaker B: What we are trying to do right now is.
00:14:39.590 - 00:14:59.610, Speaker A: So the the sequencer has to pay some cost to put this data on chain, and it wants to get refunded for that. So this estimate is in the system, you might say it's under consensus of the Al two, and the sequencer is forced to use this value in its estimate. Yeah.
00:14:59.760 - 00:15:00.860, Speaker B: Account for.
00:15:05.630 - 00:15:18.180, Speaker A: Well, the the currencies are the same, so it's both e is the unit of accounts yeah. On on both of them. Yeah. But the gas prices are different and they're moving, and this is just a wave to try and estimate that movement of gas on L one.
00:15:25.290 - 00:15:25.702, Speaker B: Okay.
00:15:25.756 - 00:15:28.440, Speaker A: So let's make this call.
00:15:34.250 - 00:15:34.614, Speaker B: Yeah.
00:15:34.652 - 00:16:25.122, Speaker A: So this was an estimate of the base fee at the time, the old one base fee estimate, which is about eight guay, it looks like. So that's what it thinks it was at the time. And we'll store that in a variable. So, as I mentioned, we want to work out this ratio so that we can scale the L one gas used from L two gas units into L one gas units so that it starts to make sense to us again. So we also need to know what the L two base fee was at that time. And this we can do by just fetching the block at that height and looking at the base fee in it, which is 0.1 guay.
00:16:25.122 - 00:17:06.850, Speaker A: So Arbitrum has, like, a minimum L two gas price, which is 0.1 guay. If congestion happens, then it will go above that, but generally it just sits here if it's not being used heavily at the time. Okay, so we'll store that as well. And now that we have these two ratios, these two gas prices, we can use them to calculate the ratio. So have I stored this already? Yeah, that was above.
00:17:11.190 - 00:17:12.050, Speaker B: Oops.
00:17:14.650 - 00:17:33.646, Speaker A: So there's the actual amount of L one gas that we used at the time, which is a bit more what we kind of expected. And if we divide, why did we expect that? No, a bit more like not more than it's like what we expect.
00:17:33.748 - 00:17:34.400, Speaker B: Yeah.
00:17:35.570 - 00:17:36.320, Speaker A: Yes.
00:17:36.690 - 00:17:56.790, Speaker B: I understand that. Compress transaction compression go over each transaction, or does it go over all estimate compression?
00:18:01.130 - 00:18:46.294, Speaker A: Yeah, it's a really great question. So we do compression over a full batch rather than individual transactions, which does leave you with this problem. Right. How do I know how many bytes it will use in the compressed batch rather than in the other amount? So what we do is it's very hard to figure that out and do it fairly because it also depends on ordering and things like this. So what we do is we compress your individual transaction when we give you an estimate for it. And so if your individual transaction is more compressible, you'll get a better estimate for it, and you'll be charged less. But that still isn't quite the perfect scenario, but that's the kind of, like, halfway house that we've arrived at.
00:18:46.294 - 00:19:55.740, Speaker A: Yeah. Okay. And so each byte of data on L One consumes around consumes 16 gas if it's a non zero byte. So as an estimate, we can say that this consumed around, like, 180 bytes of data. So we can then actually go and take a look and see if that's kind of what it did consume. So to do that, we'll RLP encode the transaction, which it's got I've got an error in my script there. I think this AABCC doesn't look right.
00:19:55.740 - 00:20:31.080, Speaker A: Yeah, I was doing a bit of debugging. What it does at a high level is just it requests transaction receipts, takes the bits out of it, which are important for an actual transaction, RLP encodes it and just spits out the result with the two prefix, which is type two transaction. So if we do that again.
00:20:35.450 - 00:20:35.814, Speaker B: Not.
00:20:35.852 - 00:20:56.990, Speaker A: Sure why that's oh, yeah. Thanks. There we go. Thanks for geisha. Okay. And if we count those bytes.
00:21:00.450 - 00:21:00.718, Speaker B: Then.
00:21:00.724 - 00:21:36.406, Speaker A: We see it's about the same. So we spoke before about yep. Say that again. I'm sorry, I couldn't quite hear. Yep. So RLP is just the format of the transaction that Ethereum accepts, and then we'll include RLP encoded transactions into a big batch, and the batch will then be compressed with a compression algorithm. So RLP isn't compression.
00:21:36.406 - 00:21:37.770, Speaker A: It's just serialization.
00:21:40.110 - 00:21:44.240, Speaker B: If you wanted to access this, is there a way?
00:21:46.450 - 00:22:21.706, Speaker A: You don't need to. Yeah, because what what you so what runs under the state transition is the full decompression. So when you run the fraud proof, you're bisecting on the parts of the state transition. So if the decompression is within that state transition, then yeah, you'll be able to decompress. You don't need an implementation of the decompression on L One. You need it on L two, and you need to include it in the state transition. Yeah.
00:22:21.706 - 00:23:16.170, Speaker A: So let's try and explore the batch. There's a function on another one of the pre compiles that you can find on Arbitrum to find the batch containing a specific block, which is this one. So we stored the block number earlier, and we'll use that to look up the batch. These pre compiles, by the way, they're kind of like the way in which Arbitrum customizes itself compared to Ethereum. So it needs to do some special things like this, and they've been added as pre compiles so they can be found at different addresses that you can find at the top of the files. So we use cast. Again, this is a little bit longer.
00:23:16.170 - 00:23:48.066, Speaker A: Wait a minute. Oh, yeah, there it is. So 974 was the batch number. I don't know why it printed some rubbish, but oh, yeah, it's because I copied the there we go. Yeah, it takes a little bit longer, that one, because we're doing oh, no, that one's, not the longer one. Okay, this one might be a bit longer. So given the batch number, we need to find the transaction that submitted it, and we need to look at the call data that was in that transaction, because that will be the batch.
00:23:48.066 - 00:24:33.246, Speaker A: So we need to find the transaction. And we do this just by looking up the logs that emitted this specific batch number. So this is the transaction ID. So if we go to ether scan, this is an L One transaction ID. This is the batch itself. And if we scroll down and look at so it calls this function add sequencer l two batch from origin. And if we look at the original, this is all the batch data.
00:24:33.246 - 00:25:21.070, Speaker A: So it's a large amount of data submitted in one go. Yeah, we can even look at this function in the code. So this is the contract, which is called the sequencer inbox. And it's where this sequencer submits these batches. And this is the batch data itself. So we're going to try and grab that data and decode it. The way that variable size arguments in the EVM are encoded is at the end as a placeholder for them inserted at this point.
00:25:21.070 - 00:26:14.366, Speaker A: So we'll find this data at the end of the arguments, list it, and given these all fixed size arguments, we can know the exact position in that input, which is well, first we'll download it, actually, which is 458 is the is the position, and we'll put it into a file. So if we open it so this is the raw batch data that we downloaded. Raw is compressed, exactly. Yeah. This is pulled straight out of the call data. And this is what the sequencer inputted.
00:26:14.398 - 00:26:15.490, Speaker B: So it's compressed?
00:26:19.930 - 00:26:21.080, Speaker A: Yes, exactly.
00:26:24.650 - 00:26:28.440, Speaker B: Like 1000 by l two.
00:26:32.430 - 00:27:03.202, Speaker A: Great question. And we'll explore that in step five. So if we open the file, we can see that it begins with this zero zero at the start. And this is not part of the compression. This is just a type of the data. So there are some different instantiations of Arbitrum. One is called Arbitrum One and another is called Arbitrum Nova, and they handle data in different ways.
00:27:03.202 - 00:27:24.474, Speaker A: So arbitram one does this compression. It stores all the data on ethereum. Arbitrum Nova. Doesn't. It stores its data with an external party. Those external parties sign that they've received it, and they put that signature, along with a commitment to that data, on chain. And this here just tells us that the type of this data is roll up data.
00:27:24.474 - 00:28:00.550, Speaker A: It's arbitram one. Data. So we want to remove that before we do the compression, do the decompression sorry. So we take those off and put it into another file, and then we just remove those front two zeros. And then this is the commands to decompress the batch. So first I'm going to convert it from Hex into binary. Then I'm going to use sprottley decompression, and then I'm going to convert it back into Hex and put it in a file.
00:28:00.550 - 00:29:01.300, Speaker A: Yeah. And it outputs this warning because there's some zero bytes at the end which aren't actually relevant to the compression, but get added because of 256 byte words. So if we look at that, this is the actual batch data, and we can look at the size differences now between the compressed and the decompressed. Make that a bit bigger. So we've got this one, which is the wait, what was it? Which one compressed, which is 198 bytes. And then we've got the decompressed one, which is 715. So you can see the difference in the ratio there and the effectiveness of the compression.
00:29:04.840 - 00:29:10.390, Speaker B: Now, you are of course, there is a minimum price.
00:29:15.820 - 00:29:25.484, Speaker A: Yes, exactly. Yeah. If the shared structure between different transactions, then they're going to be included into this compression and improve it.
00:29:25.522 - 00:29:26.110, Speaker B: Yeah.
00:29:30.000 - 00:30:02.890, Speaker A: The compression isn't actually this good because if we look at this batch data, it includes a lot of zeros, and zeros are charged at a different amount in gas. In the EVM, they're charged at, I think, four bytes, four gas per byte rather than 16 for non zero bytes. And the compressed batch will be almost no zeros in it. It'll be much more like a 10th of them are zeros. Right. Rather than 16th. Sorry.
00:30:02.890 - 00:30:32.880, Speaker A: Yeah. So it's not quite as good as it's showing here, but it's still quite good. You can work it out by doing some more complex analysis, but we won't do that here. Yes, we've compared those. And then the last thing to do is that our transaction should be in that uncompressed batch. So we'll go and try and find that. So if we echo the RLP.
00:30:37.380 - 00:30:37.696, Speaker B: I.
00:30:37.718 - 00:31:21.200, Speaker A: Think I had it in Raw, maybe. Let's see where I had it. Oh, yeah, I did have it in RLP. Oh, TLP, I've written So this is our transaction if we go into the batch, and there it is. So along with a load of other transactions.
00:31:24.340 - 00:31:24.704, Speaker B: Yeah.
00:31:24.742 - 00:32:19.750, Speaker A: And that's basically it for the workshop. So if you've got any more questions yeah, yeah. You can do that yourself as a developer. So on Arbitrum, there's a registry where you can register address against an index, and then you can substitute them, and Arbitrum will know that you've done that, and it will then switch them back out when it comes to execute. And in that way, the sequence will charge you less for your gas. Yeah. Because when you're compressing the addresses in a batch, then it does a lot of that for you anyway.
00:32:19.750 - 00:33:10.710, Speaker A: One was like a legacy system where we would allow users to do this themselves, and now the whole holistic batch way achieves a better result. Do you have a second question? Yeah. Can everybody hear the questions, by the way, or should I repeat them? Yeah, sorry. No, there's not. So, like, optimism used Zedlib, I think, and we went for broadly. The reason was because we did some analysis of different compression algorithms, and we found that broadly performed best, and I guess they did a similar sort of thing and chose Zedlib for their own reasons. Yeah.
00:33:10.710 - 00:33:41.580, Speaker A: I don't know how important it is to standardize this specific part of the roll ups because it's something that users shouldn't really be interacting with generally. And I think that's the most important part to standardize. But yeah, it would be interesting to see why they chose that as well. Sorry, I didn't repeat the question. He asked if there's any efforts to standardize this compression algorithm across different L2 S. Yeah.
00:33:41.730 - 00:33:49.900, Speaker B: You mentioned earlier that they can use it. Compression.
00:33:51.140 - 00:35:14.148, Speaker A: Yes. So there's an address registry that you can use. You register an address against an index, and then that will be used when, upon execution, you substitute your indexes into your transaction, and then they will be desubstituted from the registry upon execution to reduce the amount of call data that even goes into the batch itself. Bomb. It should be. So we used to have it in our docs. We've just recently rebamped them, and I'm struggling to find it, but we did used to have it there.
00:35:14.148 - 00:35:26.270, Speaker A: Do you know where it might be? Dragish or Fredress Registry. So we've got ARB address table here, which is the.
00:35:34.900 - 00:35:35.264, Speaker B: Yeah.
00:35:35.302 - 00:35:47.510, Speaker A: So this is like a bit of documentation, but I'm sure we had some more documentation about actually how to use this contract in pre compile than we okay, maybe we can do this afterwards as well. Yeah.
00:35:50.600 - 00:35:53.960, Speaker B: Like legacy behavior and operations.
00:35:59.580 - 00:36:04.072, Speaker A: Yeah. So the compression the broadly compression was part of Nitro. Exactly.
00:36:04.206 - 00:36:04.564, Speaker B: Yeah.
00:36:04.622 - 00:36:15.070, Speaker A: It was one of the major parts that reduced the cost previously. We didn't compress. Yeah.
00:36:16.500 - 00:36:20.912, Speaker B: I was curious why the hard coded minimum base fee. Yes.
00:36:20.966 - 00:36:43.412, Speaker A: The question was why the hard coded minimum base fee? And I think that's partly just to avoid us getting loads of state bloat early on for very cheap price. Given that we may expect users to come on board onto the platform and the gas price not to always sit there, it would be good to not the future, not to be burdened by that kind of legacy behavior.
00:36:43.476 - 00:36:44.090, Speaker B: Yeah.
00:36:52.940 - 00:37:17.264, Speaker A: So the question was, the execution occurs on layer two. So what's happening on layer one? What are we putting there? Yeah, you just store the data such that there's enough data there so that anyone who's observing Ethereum can recompute the same state transitions that are occurring on L two. And that's important. So that anybody can take part in a fraud proof game.
00:37:17.382 - 00:37:32.490, Speaker B: Yeah. Simply putting that.
00:37:33.500 - 00:38:28.410, Speaker A: Yeah. We have two ways of doing it. So I'll open up that contract. Again, the question was, in the contract, do you need to emit all of the data, the batch data, in an event, or can it just be in the call data of the transaction? So we have two functions for that. One is submitting it from origin, and in this case, we know that it's being sent from the transaction origin, and therefore we know that the call data is going to look like this. So if we know that, then the l Two can reliably grab data out of the call data. If the sequencer is going via some other contract or it's not coming from the transaction origin, then we emit the full batch data in an event.
00:38:28.410 - 00:38:41.950, Speaker A: So this is here, if it were needed, but in production, it's way more expensive, so it's never used. Why do we not need what? Sorry.
00:38:44.000 - 00:38:49.832, Speaker B: I missed what you said. Why do you not need to submit?
00:38:49.896 - 00:39:15.080, Speaker A: Yeah. So to clarify on what we're doing here, we're emitting a sequence number. And what the l two node will do is it will say, okay, I've got a new sequence number. I'll go look up the transaction related to that sequence number. I'll look inside the call data. I'll find the batch basically the same process as we've just done. And all of that all doing all of that is part of that state transition function.
00:39:15.080 - 00:39:16.890, Speaker A: So it's all yeah.
00:39:21.020 - 00:39:28.204, Speaker B: So verify my understanding happens on layer two, right?
00:39:28.322 - 00:39:30.284, Speaker A: Yes. Execution happens on layer two.
00:39:30.322 - 00:39:30.910, Speaker B: Yes.
00:39:32.400 - 00:39:34.156, Speaker A: And state is on layer two as well.
00:39:34.178 - 00:39:47.632, Speaker B: Yes. So data layer one transaction or sorry.
00:39:47.686 - 00:40:14.090, Speaker A: I missed a bit. You said there was yeah, no, so the question is, does the execution also take place on layer one as well as on layer two? And no, it doesn't. We just put enough data such that anyone who's reading the ethereum can then go away and recompute themselves what would have happened and take part in this fraud proof game.
00:40:15.820 - 00:40:21.788, Speaker B: If somebody wants to want replay a.
00:40:21.794 - 00:40:27.004, Speaker A: Lot of blocks, correct? Exactly.
00:40:27.122 - 00:40:27.790, Speaker B: Yeah.
00:40:29.440 - 00:40:38.130, Speaker A: If you want to know what the state of the l Two chain is, you need to replay the history of the chain in the same way that you would replay the history of l One to figure out what the state of l One is.
00:40:38.660 - 00:40:56.776, Speaker B: Is there a way to ask? Everyone may have blocks some transactions for this address or I have to pass all your moderate transactions. Yeah.
00:40:56.798 - 00:41:08.876, Speaker A: So the question is, can I find out states about a specific address without recomputing the full state on l Two? And the answer is no. So the state only exists on l Two, and that's only where you can make questions about the state.
00:41:09.058 - 00:41:15.710, Speaker B: Yeah. Modify state.
00:41:21.060 - 00:41:21.712, Speaker A: Yeah.
00:41:21.846 - 00:41:30.480, Speaker B: I have another have a question about that filling.
00:41:31.140 - 00:41:33.120, Speaker A: Yeah. Buffer.
00:41:42.060 - 00:41:45.530, Speaker B: Time. Wait for that.
00:41:49.980 - 00:42:08.050, Speaker A: Yeah. So the question is, can you sort of game the system, take advantage of this. Minor fluctuations in l two gas price to try and achieve a better price for yourself? And the answer is yes. Yeah, you can. Yeah.
00:42:10.100 - 00:42:34.024, Speaker B: How do you achieve better cash price at the end? What? We do some old data based on that we pay some gas, but this actually runs. Yeah.
00:42:34.062 - 00:43:38.968, Speaker A: So I think the question there comes down to a little bit around your security assumptions. So in order for you to be confident of ethereum state, you want a wide range of people to run full nodes such that if an invalid state transition occurs, a large number of people can get together and form consensus that that was an invalid state transition. That should be a rejected fork and we shouldn't ignore it. But with roll up there's a slightly different safety assumption, which is that if any single one person notices that there's an invalid state transition, then that one person can enforce that the state transition is corrected. So you don't need a large number of people necessarily. It's a kind of one of N security assumption rather than like an N of M. And so this means that maybe you can afford to have less people actually running the l two nodes have maybe slightly more beefy machines.
00:43:39.064 - 00:44:04.690, Speaker B: Yeah. Yes. I know this is outside of commercial, but are you making, say, someone actually never happened? Actually, what would be what would they yeah.
00:44:09.140 - 00:44:15.290, Speaker A: Yeah, we can go into it. Yeah, sure. So the question is how in practice do fraud proofs work?
00:44:20.220 - 00:44:20.680, Speaker B: Okay.
00:44:20.750 - 00:45:01.510, Speaker A: Yeah. So two parties take place in a fraud proof game to figure out which of them has chosen the correct state and then one of them wins, which is what you're asking about. And at that point the losing state is rejected. More people can challenge the winning state if they want to, but the losing state is rejected. Whoever chose to take part to defend that side of the state will lose some stake because you have to put at stake to defend a state. And if no one comes to challenge the winning state, then that will be accepted as the correct state. And you'll go on from there.
00:45:01.510 - 00:45:52.472, Speaker A: No. If you're running an l two node, if you think about a fork occurring on ethereum, you've got some people that choose different rules for their node. That doesn't mean that you need to stop running your node with what you see as the correct rules. And the same kind of happens on l two. I can run my node and I can see which of those two is going to win the challenge because only one of them is correct and I know which one of them is correct. So I can continue to accept transactions, validate them, and we can continue to process them in that time. What you can't do during that period is withdraw funds from the system so withdrawals are paused whilst this fraud proof game is taking place because ethereum itself doesn't know which of those two states is going to be correct.
00:45:52.472 - 00:45:58.548, Speaker A: So the funds stay in the system while it's happening, but we can still progress the state as an as an external viewer.
00:45:58.644 - 00:46:12.440, Speaker B: Yeah. Does this take place? Starting function have to start applying?
00:46:15.740 - 00:46:18.464, Speaker A: Um, I'm not sure I fully understand the question.
00:46:18.582 - 00:46:19.250, Speaker B: Yeah.
00:46:29.140 - 00:46:47.012, Speaker A: So the question is it's like if two two states are in violation of each other, there's people defending either side. What are we actually challenging? What's the state transition that we're challenging? Is it from the previous state to the current state, or is it further back? And the answer is it's just the previous assertion.
00:46:47.076 - 00:46:55.790, Speaker B: Yeah. All these things.
00:46:58.480 - 00:47:41.720, Speaker A: So the question is, do the fraud proofs take place in the solidity contract? And yes, they do. But the way they work is that there is a bisection game that the two parties play. We don't want to execute the full state transition again, so instead we try to decide which part of the state transition we disagree on. So we take the state transition, we bisect it into many parts. We allow the other person to choose which part they disagree with and which part they agree with. And so you're reducing the size of the state transition, always keeping a point that you both agree on and always keeping a point that you both disagree on, and making that smaller and smaller and smaller until you get down to a single opcode. And then you execute that single opcode.
00:47:42.540 - 00:47:51.500, Speaker B: Yes. Would they have to make separate thoughts?
00:47:54.720 - 00:48:21.430, Speaker A: Is the question that within a single state transition, they disagree about multiple things, or is it that there are multiple people disagreeing about one? Okay, so if there's two parties but they disagree about multiple things, then it'll just be the first disagreement that matters, because that's all you need to slash the person out of the system and remove their state from the system. Yes.
00:48:23.880 - 00:48:43.300, Speaker B: Transactions, I have transition and a transition. If someone opposes that transition and we revert it, does the legal parties get replayed?
00:48:43.460 - 00:49:29.550, Speaker A: So I think your question, I think, is what happens if someone includes an invalid transaction in the batch so the Arbitrage virtual machine will know what to do? If someone gives in an invalid transaction, it will ignore it, basically. So you can then choose to run a different Arbitrum virtual machine that would do something weird with that. And then we would end up at different states and we would challenge each other over the result of that. But just including an invalid transaction in the batch isn't enough to confuse an honest validator that something weird has happened or that they've got the wrong state or anything like that. There are rules about what to do for every byte that you see in that batch. Yeah, I think sorry, there's one at the back first. Sorry.
00:49:29.550 - 00:49:41.376, Speaker A: How long do we have left? These are great questions, though. Yeah.
00:49:41.478 - 00:49:54.370, Speaker B: About not being able to with a very cheap attack by causing challenges for a long time.
00:49:56.920 - 00:50:51.572, Speaker A: So the question is sorry. Yeah. So the question is given that during a fraud proof game withdrawals are paused, isn't there an attack you can do on the system to delay and cause problems for everyone else by just creating a challenge? And what is the cost of that, of creating that challenge? And the answer is dependent upon how high the stake is set. If you have a very high amount of stake then it becomes very costly for you to cause this delay. Pardon? The amount of stake is set by the system. So for in order for you to take part in a challenge, you need to put up a certain amount of stake. So at the moment the validator list is whitelisted, so it's not open to the public.
00:50:51.572 - 00:51:05.150, Speaker A: So whatever mallet value in there is not really meaningful. But we're working quite hard on trying to make that open and when it is open I can say that it will be quite expensive. Yes.
00:51:07.040 - 00:51:37.350, Speaker B: Previous question, I run node and I notice that sequencer for me to prompt now I now I challenge it, now I will become challenged now the sequence on chain is broken sequence had a bug or was a malicious I could prove that I was correct.
00:51:39.080 - 00:52:45.020, Speaker A: So the question is what if the sequencer is malicious tries to cause an invalid state transition, is that right? And what happens when someone challenges? So there's a separation in the system between sequencing transactions and generate executing those transactions to create a state, to update state. So the sequencer has no power over what state will be updated, what the state will be based on, what it puts there, the node software does. So if the sequencer puts rubbish there, the node software, like honest node software will recognize it as rubbish. If the sequencer puts valid stuff there, then they will process it as valid stuff but the sequencer is all it's doing is putting data onto the chain. They don't enforce in any way what the state should be that's a result of that data. Those are the validator nodes that decide that. So given just some data that arrives, people running validator nodes need to decide what the result of that data would be.
00:52:45.170 - 00:52:45.724, Speaker B: Yeah.
00:52:45.842 - 00:52:47.550, Speaker A: Does that kind of answer the question?
00:52:50.640 - 00:53:00.610, Speaker B: Yes. So the only thing that frequently can do is put yeah.
00:53:01.940 - 00:53:47.170, Speaker A: And the nodes will know what to do when they receive that. So there'll be strict rules about everything that the batch contains. Exactly. So the question is what powers does the sequencer have in the system? And the sequencer can choose ordering of things inside that batch but they can't manipulate what the output of those transactions will be. So you don't trust them in any way for the security of the system, the sequencer is necessary for liveness of the system to get transactions moving. Fred's like waving his hand over there.
00:53:48.420 - 00:53:56.530, Speaker B: Are there any checks on the sequencer by the validators? Like validators will recognize rubbish, but what can they do?
00:53:57.620 - 00:54:35.596, Speaker A: Yeah, so at the moment there aren't. Right? So the moment we trust the sequencer to behave well, if they don't, then we won't be able to use the system properly. The funds will still be safe that are in there. And there's a secondary backup system which normal users can use. So you don't have to go via the sequencer if you don't want to. You don't get the benefits of compression, but you can send your transaction yourself or you can find someone willing to compress stuff for you and put it into the system for you. But fundamentally, the sequencer is the one who chooses the ordering and you won't be able to do that.
00:54:35.596 - 00:55:15.870, Speaker A: We have like a time period where if the sequencer is not actually doing its job at all, if it's not updating things, or it's not including these, what we call delayed messages, which are user sent messages via the L one, then after a time period, you can force those through regardless of the sequencer. So that's the kind of backstop if you need to exit the system. And the sequencer is not allowing you to send transactions, but it's not really the validators that are involved in that. It's more the users who say, okay, I don't like the system anymore, it's not working for me and I want to just force my way out of it. Yes.
00:55:18.160 - 00:55:24.270, Speaker B: We have the possibility of what is the.
00:55:26.560 - 00:56:07.550, Speaker A: Yeah. So that that comes back to your note software. Right. So if you can see that this state is correct, then sorry. Yeah. So the question was, how does finality work in the system, given that after a fraud proof a certain state will be rejected? So the answer is, if you are following that invalid state, then you will basically see a reorg, probably quite a deep reorg, but if you were running honest software, you won't see any problems. Basically you won't see any difference, there'll be no change.
00:56:07.550 - 00:56:30.630, Speaker A: But that does bring into question what the finality of a transaction is in there. And as you pointed out, you could get this deep reorg. So it depends whether you're running software it depends whether you're running node software or not. You might want to wait just until that week period is off, all challenges are over, and then just be like, okay, now it's definitely fine.
00:56:33.240 - 00:56:33.604, Speaker B: Yeah.
00:56:33.642 - 00:56:59.790, Speaker A: Any more questions? The question is, is there an easy API that I can use to see if there are if the challenges are complete? And the answer is that you can look in the smart contracts. So the smart contracts are created and destroyed when challenges exist. So you can see in the smart contracts all the challenges that are taking place at any one time. Yes.
00:57:04.560 - 00:57:06.430, Speaker B: We start building off of that.
00:57:09.460 - 00:57:56.972, Speaker A: Yes, it will if you think that if your if your Node software has a bug in it or you've done something malicious with your Node software, then you'll be following what will not be the canonical chain eventually. And so you'll see results that will not never happen or may happen in a different way. The transactions will still be replayed. So all the transactions are on L One. So anyone who wants to run honest software can know what the final state will be. But if you're running some sort of, like, mutated software or something like that, then, yeah, after one week's time, you may find that all of that state that you thought existed didn't, and you're actually on this other chain.
00:57:57.036 - 00:58:05.650, Speaker B: My question is, like, how do you get out of that situation? I don't know exactly.
00:58:06.980 - 00:58:22.468, Speaker A: The question is, like, what? The question is, what happens to me when that challenge ends and I realized that I was following the wrong chain? Is that the question?
00:58:22.554 - 00:58:25.270, Speaker B: Yeah. Okay.
00:58:27.900 - 00:58:46.470, Speaker A: Yeah. The challenge ends. No one decides to dispute this state transition. Basically, everyone in the world is agreeing on this state transition at this point. If they didn't, and they would start challenging it. Okay, I've got to wrap up now, but thanks very much for the great questions and yeah, thank.
