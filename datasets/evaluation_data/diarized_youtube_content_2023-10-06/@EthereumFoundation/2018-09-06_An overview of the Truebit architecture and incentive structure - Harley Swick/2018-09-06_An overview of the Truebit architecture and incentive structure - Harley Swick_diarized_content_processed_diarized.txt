00:00:04.570 - 00:00:21.230, Speaker A: Hi. Hi, everyone. I'm Harley. I came all the way here from Dallas, Texas, actually. So pretty far. Jason, the original speaker, also our other original speaker was not here as well, so there's been some changes. So I am the one speaking.
00:00:21.230 - 00:00:45.880, Speaker A: I am a core developer for Truebit. I've been working on Truebit for, for about six months now, so it's been a while. We have a lot of pretty exciting things. Oh, how do I change the slides up here? Okay, perfect. I can do that. So, clicker. Yeah.
00:00:45.880 - 00:01:21.544, Speaker A: Which one it working? Oh, that one. Perfect. I was just shooting laser beams at everyone. Oh, the pointer or. I thought this changed the slides. Yeah. Which one? The lower one.
00:01:21.544 - 00:02:03.952, Speaker A: That's the other one I didn't try. All right. Okay, so let me start with what truebit is. Truebit is a platform for running decentralized computation that typically doesn't fit within the gas limit. So that is a big limitation of computation with Ethereum, is that this gas limit, which is there for a very good reason, but not all applications can really fit in that, and you still want to be able to. Mostly what you use tribut for is for checking for whether or not people are doing the correct computation, which is typically what you use a blockchain for. The problem is that decentralized computation is expensive.
00:02:03.952 - 00:02:36.252, Speaker A: Like we talked about or I mentioned earlier, you have the gas limit. You also just have to run stuff with Ethereum and pay for gas. The other thing is that decentralized computation is bounded by the gas limit. So, like I said, web 3.0. It can't quite happen because we need to really scale up the level of computation that we can do. So this is a pretty simple diagram for how it works. So we have a tip simple Dap user right here, and they sort of have a contract that's running a computation.
00:02:36.252 - 00:03:16.444, Speaker A: So one example might be livefare, actually. So they're our first milestone for an application. So maybe it's the live here transcoders or other users, and they're triggering something here, and then it will go and call Truebitcontract and have them sort of create a task. And it's pretty simple API. And what will happen is that there are these truebit miners who are running computation off chain, and they will be executing this task. And here is where it gets a little bit more complicated. So here is our c plus plus code.
00:03:16.444 - 00:04:33.424, Speaker A: So in the case of live fear, they have things like ff probe or ffmpeg, and we can actually compile that down to WASM, and I'll just share a little quick thing. Why we're targeting WASM. The reason why we're targeting WASM is that it's supported by all browsers, and it's a computation platform that a lot of different languages can target and use. So we want to target wasm because it's sort of like a good base layer for computation, and there's projects like ewasm and stuff like that. So the c plus plus code gets compiled into webassembly, WaSM, whatever you want to call it, via mscriptin, and we have software related to that, then creates the task, and the different troubit miners will run that webassembly code using our off chain interpreter, which is written in ocaml. And there's a bunch of different steps that go on with that, but eventually the different data or whatever can get uploaded to the blockchain, or it could be ipfs, et cetera. We also have the WASm task, so it doesn't just get solved, but obviously it's the blockchain.
00:04:33.424 - 00:05:20.736, Speaker A: So there's like money related to this. And the way it works is that the task giver will give a reward and a minimum deposit. And so there's different staking. So if at any point someone doesn't follow our protocol and it can be proven, then those people will be slashed. And that is all handled in our incentive layer. The cool thing about truebit is that if someone does the computation, and what if they don't do it right? Well, the way it works is that you can run pretty much 99% of the code off chain, and then you can use sort of our on chain stepper, what we also call dispute resolution layer, to actually prove fraud. And then those people will get slashed.
00:05:20.736 - 00:05:58.256, Speaker A: And so those are some of the related inputs and outputs. So I already discussed about webassembly, so I won't go into that too much. So, truebit is, I like to think of it as a very elegantly simple system. The verification game is pretty simple. It was actually created by Christian over here, related to solving the doge Ethereum bridge. But there are obviously, with any programming or software, there are interesting design challenges, and this is a very new space. So one issue is floating point.
00:05:58.256 - 00:06:45.390, Speaker A: And the reason why floating point is an issue is because for webassembly, it's an issue because the webassembly spec doesn't specify how it's supposed to happen because they want it to be optimized by certain hardware. Well, obviously, if you're hashing different floating point numbers, no matter even if they're very similar, they're going to give different hashes, so you don't have determinate computation. And Sammy, actually our other developer has developed some interesting floating point emulation, and there's different ways to sort of solve this problem. The other thing is determining the task reward. So this is kind of related to how do you know up front how much to pay someone for these different things? Because we don't exactly have ethereum. You can kind of get estimates for gas. So it's a similar issue.
00:06:45.390 - 00:07:35.056, Speaker A: You know how many steps it's going to cost, but sometimes you don't know how much gas is going to cost and things like that. So that's an interesting problem that we've been working on. Another, probably the biggest limitation for us is because obviously we want to do big computations, which usually requires big data. The biggest issue is having this data availability problem, and this is a really tough problem that everyone, I think, in this space is sort of facing. And so we're definitely looking into different ways to solve that, and other people, how they're solving it. So other issues are around token mechanics. How do you relate token mechanics to all these different computations? So, like you're pricing the computation, but if your token is deflating and things like that.
00:07:35.056 - 00:08:42.896, Speaker A: So there's all these crazy variables that go into this exchange rates, like how much if you're exchanging Ethereum into a truebit token or whatever, how do you know how that's related to the computation? So these are interesting problems. The other thing is what's called the dandelion attack, and it's a pretty interesting one. So let's say you're a live fear task giver, and then some malicious person like Sammy over here says that every time that live fear submits a task, I'm going to challenge it, and even though I'm going to lose, it's still going to delay what you're doing. And so that's kind of a problem, and that will kind of disincentivize people from submitting tasks if you know that some not nice person is going to challenge you just for. No, we, if anyone's familiar with truebit, we sort of colloquially refer what was written in the truebit white paper as trubit classic. So that involves four stairs and a jackpot. And the way that works is that whenever someone at a probabilistic rate, when someone submits a solution, they also submit a fake solution.
00:08:42.896 - 00:09:18.748, Speaker A: And this is to check if verifiers are actually checking or not. And so if verifiers are incentivized to challenge or to least check because they want to get this jackpot related to the forced error. But this is an interesting way. And we've actually been discussing another model which we call truebit beta, where task giver gives you a test. So like I said earlier, submit solution. That's fine. Yeah, so this is pretty basic, but the idea is that truebit beta doesn't give a force error.
00:09:18.748 - 00:10:25.616, Speaker A: And the reason why that's difficult and not yet implemented is because the forced error is really key for incentivizing verifiers. And we really want verifiers to check stuff because that's how you get security. So how do you incentivize verifiers without sort of this interesting forced error jackpot mechanism that has its own sort of related problems? And there's some extra stuff that jason would have been much better at explaining than. So that's it. Any questions? Oh, I can talk about it if you want, but do I have to? Oh, I guess I could talk about something else. So the thing I've been working on is Truebit OS. It's kind of a buzwordy calling stuff Os, but the idea is that we have a, so the truebit nodes will have clients that are running off chain, but there's like different versions of Truebit out there and there's all these different pieces.
00:10:25.616 - 00:10:51.950, Speaker A: And so the idea was we could build this system called Truebit OS, where you can actually compose different modules together to build the sort of truebit client that you want for your specific problem. And actually it's pretty close to being done, and we'll be using it for the live fear integration. So anyone wants to check that out on our GitHub? Yeah, so that's actually it.
00:10:53.760 - 00:11:06.624, Speaker B: I'm just trying to understand what the verifier is verified like if it's a live peer and the decoding happens, how the verifiers are checking that this video is correct.
00:11:06.822 - 00:11:51.120, Speaker A: Yeah. So the way that live here works is that someone will submit the code that they were running. So with live fear, people will actually already have submitted their solutions. And the idea is that truebit will then rerun that computation and then a solver will run that and run it again, and then a verifier will check that solver. But live here is an interesting case because you can kind of think as the original solver, as the person checking the original live peer people as well. So that's kind of how that example works. What they would be doing is they would simply just be checking that the solution that the original that came from live care was actually correct.
00:11:51.120 - 00:12:22.410, Speaker A: And so that way, because the live care contracts themselves can't check these video transcodings because it doesn't fit within solidity. So they would use truebit to sort of offload that and then get the correct solution. But then how do you know if Truebit did the right thing? So that's why Truebit has sort of like the extra level of security. Hopefully that answers question you in the back. Which one? Tell me when to stop.
00:12:25.580 - 00:12:39.090, Speaker C: Is it just anything in the binding like assembly? I was hoping all languages that can compile to webassembly or anything special that.
00:12:40.340 - 00:13:07.012, Speaker A: No, that's a great question, actually. So you could use different languages like Rust. So one thing is that webassembly doesn't support garbage collection. So that is an interesting detail. So that's why other languages may not exactly be supported. However, it is certainly possible, and people have compiled different languages like Python or C sharp to webassembly, so that could be possible. I don't see any reason why we can't support those languages.
00:13:07.012 - 00:13:14.540, Speaker A: But at the moment, the best languages to sort of target would be c and C plus plus or rust or any sort of non garbage collected language.
00:13:17.920 - 00:13:28.910, Speaker C: It's possible and possible. What is the current state of different language chains for doing it? Is there existing libraries for rust, et cetera, to work with?
00:13:29.540 - 00:13:46.900, Speaker A: So rust is an interesting case because they're trying to be sort of like the language for Webassembly. So there's some sort of native rust compilation where you can compile rust into Webassembly, but mscript is sort of like the main tool for compiling different languages into Webassembly.
00:13:49.740 - 00:13:55.050, Speaker C: So do you guys have a roadmap? How is development going?
00:13:55.820 - 00:14:25.040, Speaker A: I would say development is going pretty well. I guess it depends on who you ask. But, yeah, we don't have a really specific roadmap. But the biggest milestone that we're sort of targeting right now is the live peer integration. And so once we kind of have that, then we'll be ready to sort of support other teams. And we've had a bunch of other projects like Ocean Protocol and Aragon who've also wanted to build on it. So we'll pretty much just be, as we're developing it, we'll also be trying to sort of onboard these other teams to use our tools.
00:14:25.620 - 00:14:27.330, Speaker C: Can you give us any date?
00:14:27.960 - 00:14:28.710, Speaker A: No.
00:14:31.880 - 00:14:40.950, Speaker B: Small follow up on this question. Do you actually instrument and instrument in Webassembly or can I just throw any old webassembly binary at the system and it will work?
00:14:44.520 - 00:15:09.810, Speaker A: So it depends because with the mscript and module Wrapper, we are doing some extra stuff in there. Mscripted, we have our own wrapper around that. So there's some extra stuff. However, you can do really simple wASM tests, and I think you can run just pretty basic webassembly stuff that you haven't sort of like preprocessed, but anything sort of more complex, you sort of need to do this preprocessing step.
00:15:10.580 - 00:15:18.290, Speaker B: Can you go back a bit and explain the difference between a solver and a terracotta change between the white paper and now?
00:15:18.740 - 00:15:51.740, Speaker A: Yeah. So in the white paper it hasn't changed too much, but yeah. So a solver is just someone who is waiting for a task to be created. They commit to solving that task, they're given a time frame to do it, and they run the computation and they submit the solution. And in the most normal cases of truebit, no one will challenge, and then they get their money and they go on their way. Now in the case where a verifier, so what they'll be doing is they'll be watching for solutions to be submitted. So there's some event, right? And so they will then go and get the code, they'll download it, they'll check it themselves.
00:15:51.740 - 00:16:03.548, Speaker A: And if they're like, hey, you didn't do this, isn't correct, and then they'll go and challenge it. The verifier is sort of the other party in the verification game as opposed to the solver.
00:16:03.724 - 00:16:14.676, Speaker B: Wouldn't it be realistic that since both of them are solving it, wouldn't you always be the solver and then if you disagree with someone else's solution, you would become a verifier. Is that how it is, or is.
00:16:14.698 - 00:16:48.210, Speaker A: It these jump rules? Yeah, you are right. So it's pretty much the same code, but in terms of just who is sort of playing the game, we sort of use these terms to. It would probably be on the same machine. So you'd be running solvers and verifiers on the same machine. But we use the terminology solver and verifier to more make the distinctions when we're developing the code. And also in the white paper, because the code is very similar but slightly different in terms of what methods they call.
00:16:48.820 - 00:16:53.884, Speaker B: Is there an incentive difference? Is it like preferable fee solver or preferable verifier?
00:16:54.012 - 00:17:20.552, Speaker A: Yeah, so that's what the white paper goes in. So the white paper, the forced errors and the jackpots is really meant for incentivizing verifiers, because incentivizing solvers is pretty easy. Like, I can just submit a task and you're the solver, and I pay you to solve a task. Right, but you're sort of not incentivized to really give me the right answer. You're kind of incentivized to give me 42 every single time, unless someone's actually checking you. Right. Because you don't want to waste your computational resources if no one's going to catch you.
00:17:20.606 - 00:17:22.628, Speaker B: There is a single winner for these solvers.
00:17:22.804 - 00:17:24.696, Speaker A: A single winner takes all.
00:17:24.718 - 00:17:36.284, Speaker B: The first one to come up with the answer and gets the full bounty. Or is it like, hey, there's three people that happen to solve this problem. They might agree on the correct answer, or one might submit 42 and stand out.
00:17:36.402 - 00:17:59.510, Speaker A: Yeah. So in tribute beta, I think we were playing around with multiple solvers. But in tribute classic, the way it works is that the miners choose. So it's really just whoever calls register for task or first, and whoever gets through through the Ethereum and then anyone else who tried to call that method, it'll just revert on them, and they could become verifiers if they wanted to. Yeah.
00:18:04.380 - 00:18:17.736, Speaker C: One question right now, it works with the Ethereum main net, I guess. But is it also possible to hook up other EvM based blockchains or then use the same pool of verifiers with solvers?
00:18:17.928 - 00:18:39.550, Speaker A: I don't see why not. I guess it depends on how the smart contracts work. I haven't really looked into how other EvM based languages work, but I don't see any reason why not. Yeah, ready? All great questions. The what?
00:18:39.620 - 00:18:40.730, Speaker B: The litecoin bridge.
00:18:40.810 - 00:19:20.910, Speaker A: Oh, the doge bridge. Yeah, it's coming along. We've been a little busy with other stuff, but it'll happen. There's an art project, too, related to it, so that's been making a lot of progress. All righty. I think it's Christian CeRn now, please. It.
00:19:25.280 - 00:19:25.788, Speaker C: Phone here.
00:19:25.794 - 00:19:27.324, Speaker B: Is it interference or.
00:19:27.362 - 00:19:30.090, Speaker A: I don't know. Yeah, maybe. Thank.
