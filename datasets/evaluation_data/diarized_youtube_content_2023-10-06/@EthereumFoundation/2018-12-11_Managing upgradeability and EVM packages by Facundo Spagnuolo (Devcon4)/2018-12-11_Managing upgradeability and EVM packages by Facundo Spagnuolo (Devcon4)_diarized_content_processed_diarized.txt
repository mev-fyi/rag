00:00:00.570 - 00:00:40.246, Speaker A: Okay. Hello guys. Well, first of all, thank you for being here today, and also thanks to the organizer for taking care of such an amazing event. So today we're going to talk about upgradability and evm packages, and the idea is to learn some things about these concepts and of course to see how we can leverage these concepts using subway NOS. But before we begin, I would like to talk a little bit about us. We are sapling and at Seplin we build key technology and infrastructure to build, develop and manage smart contract systems. My name is Fabos Panolo.
00:00:40.246 - 00:01:12.660, Speaker A: I'm a core developer and security researcher at Sepllim and currently I'm leading the efforts of Sublime OS. Maybe some of you may know us because of open Sublim. Open Sublim is a community driven open source framework of reusable modules of smart contracts that you can install and start using directly in your own projects. You also do security audits. A few weeks ago we finished the audit for the solidity compiler. We received a grant from the Ethereum foundation. It was really great.
00:01:12.660 - 00:01:53.982, Speaker A: And well, as I said before, we're here today to talk a little bit about Subliminal OS. Subliminos is an open source platform to help you building, develop and manage smart contract systems. So let's begin with the first topic, upgradability. So of course that immutability is one of the main features of Ethereum. However, software qualities really much depends on a development that needs to be iterative and incremental. And this means that we need to have the chance to update or patch our code if we need to. And we are not just talking about bugs, we may need to optimize our solutions.
00:01:53.982 - 00:02:49.390, Speaker A: We may need to provide new functionality because the community is requiring it or whatever. And the thing is that we've seen many other projects building their own implementations of upgradability, and Subliminal s is providing a standard and really flexible way to do this. So I would like to introduce an example of how we can easily have available smart contracts in our projects using Subliminos. So the first thing we'll need to do is to install sublime OS. In this case, we're using NPM, and Sublink OS comes with a command line tool, and in this case, for example, we have a knit command that we can use to start a new project. Just passing the name of our project and let's say that we start writing our first smart contract, in this case a wallet. As you can see, it has an owner.
00:02:49.390 - 00:03:31.838, Speaker A: It has an initialization function where it receives the owner in order to set the owner of the contract, it has a withdrawal function in order to withdraw some funds from the contract and so on. So let's see how we can deploy an agreeable instance of this smart contract using sublime OS. So the command line tool has some commands that are pretty much similar to the ones we use in git. So I think it will sound familiar to you. In this case, we're running the first command, the add command. It's the way we tell Seplinos in order to add a new smart contract in our project. In this case, we're telling selenium Os that we want to add the my wallet contract that we wrote before.
00:03:31.838 - 00:04:03.606, Speaker A: And the second step is the push command. This is how we upload the bytecode of our contract to the network. In this case, for example, we're pushing the source code of the my wallet contract to the Robson network. And finally we have the create command. The create command will create an upgradable instance of the my wallet contract. And the address that we receive there is the new instance that we have just created. And maybe some of you may be wondering why do we need to run these three steps in order to create an upgradable instance.
00:04:03.606 - 00:04:38.246, Speaker A: Well, the thing is that this is not a regular instance. Obviously this is an upgradable instance. And the thing is that we can run the create command as many times as we want and we'll be always reusing the same logic that we uploaded just once. So this is great. And let's say that after we created the first instance available instance of my wallet contract, we found the back. As you can see, the need wallet function can be called by anyone. And this means that for example, an attacker can call the need wallet function to withdraw some funds from it.
00:04:38.246 - 00:05:12.430, Speaker A: Any resemblance with reality here is per coincidence. And let's say that we want to fix this bag. So let's see how we can do this with subliminal. As I promise it's really simple. So the first thing we'll need to do is just to edit the source code of our contracts. For example, in this case we're adding an only owner modifier in order to restrict the person that can call this function. And once again, as we did it before, we just need to run the add command to tell Subliminos to add the new fixed my wallet contract.
00:05:12.430 - 00:05:31.858, Speaker A: We're pushing that fix to the network. And finally we're running a new command here. The update command is the way to tell subliminal OS to upgrade the available instance that we created before. And it will be as simple as that. As you can see, an attacker cannot call anymore. They need wallet function. And our bug has been fixed.
00:05:31.858 - 00:06:00.846, Speaker A: So it was pretty simple. We didn't have to modify our source code in order to make our contracts upgradable. As you can see, we're using the same address. It was an upgrade per se. We didn't have to migrate data from the previous wallet contract to the new one. We're really upgrading it. So how was that possible? I think that many of you may know already this, but we're using proxies in order to make it happen.
00:06:00.846 - 00:06:56.420, Speaker A: And the way a proxy works is it's a particular contract that basically delegates every call it receives to another contract that is called logic contract. And the thing is that the address of the logic contract can be changed. And this is how upgradability works. As you can see, the storage layer, layer is always kept in the proxy contract. And this is why we don't need to migrate or pay any expensive migrations of data when we want to do an upgrade of a contract. We're not going to much deep in the proxy stuff, but you can read more about it in our documentation if you want. So summing things up, Sublin Os provides a standard way in order to have upgradable smart contracts in your projects that will basically allow you to fix bugs or add functionality, for example.
00:06:56.420 - 00:07:30.326, Speaker A: So let's move to the second topic. EVM packages. EVM packages. This is a new concept we introduced some weeks ago. EVM packages are upgradable on chain packages of smart contracts code. And this means code that is already on chain deployed by another developer team that is being maintained by another developer team, that then any application can link directly through your own projects in order to reuse it directly on chain. And it comes of course with opt in upgrades.
00:07:30.326 - 00:08:25.438, Speaker A: And this means that if that developer team that is developing an EVM package comes with a new version of the EVM package, you can decide where to upgrade your code to use the new version that they are providing or not. So why do we need EVM packages? We do think that this is a way in order to encourage modular development, you can start focusing on what you do best and start reusing the work that your colleagues has done. We just don't need to build everything. If we want to build something, we can start reusing some code that is already deployed on chain. And as I said before, EVM packages are upgradable by definition. And this means that their developers can provide new versions of those EVM packages and you can opt in decide whether you want those upgrades in your projects or not. It's like any other dependency management system.
00:08:25.438 - 00:09:19.930, Speaker A: And of course we're saving a lot of gas costs because we're reusing some logic that is already deployed on chain by those developer teams. And we don't have to redeploy that logic every time if we want to reuse it. Let's take a look at another example. Let's say that we have a deck contract in our project, and as you can see, it has an ERC 721 dependency. It has an initialized function in order to receive the ERC 721 dependency, and it has another function called pick that will basically allow any users to pick cards from the contract. And you will be minting new ERC 721 tokens every time a user picks a new card. So how we can create an upgradable instance of this contract reusing an EVM package for the USC turn 21 dependency using sublime os.
00:09:19.930 - 00:10:04.046, Speaker A: So it will be really simple. Once again, the first thing we should do is, and here is when it comes to the new part, the link command will allow you to link to any other EVM package that is already deployed on chain. In this case, we're linking our projects to the open sublime ETH EVM package. And this package is the EVM package that the open Sublink team has provided on chain. In this case, we're linking to the 20 version and as we did before, we just need to push those changes to the network. And finally we can run the create command. And as you can see here, we are creating an instance reusing the logic of the ERC 721 that has been already deployed by the open subpling team.
00:10:04.046 - 00:10:55.322, Speaker A: We haven't added that contract in our projects. We are reusing the same logic that the open Sublim team has provided on chain for us. And we'll receive of course the address of our upgradable instance of the ERC 721 there. So let's use this new ERC 721 instance in order to create an instance of our contract, the deck contract, as we did before. In this case we do need to add the deck contract. So we're running there the add command, then we're pushing the source code of the deck contract to the network. And finally we are running the create command in order to create a new instance of the deck contract and passing here the address of the USC 721 instance that we created before, and we will receive there the address of our aggregable instance of the deck contract.
00:10:55.322 - 00:11:21.030, Speaker A: So as you can see, we can start reusing the deck contract. We can start picking cards. We will be minting ERC 721 tokens. It will be as simple as that. So this is amazing. We didn't have to deploy an ERC 77 21 contract in order to reuse it. We're just reusing the one that the open supplement team has provided for us.
00:11:21.030 - 00:11:46.080, Speaker A: And this is really cool. So I said before that EVM packages are upgradable by definition. And let's see an example of what does it mean. Let's say that the Opensupplane team comes with a new version of their EVM package, in this case the open sublimin eth, as I said before. And let's say that we want to use it in our project. And as you can see, this is an opt in decision. I said before.
00:11:46.080 - 00:12:32.220, Speaker A: So in order to tell Saplingos that we want to use that upgrade, that new version in our project, we need to tell Sabinos that we want to link our project to the new version. As you can see here, we're linking our project to the 2.1 version of the open EVM package. Once again, we're pushing those changes to the network. And finally we can run, in this case the update command in order to update the upgradable instance that we created before of the ERC 721 contract. And as you can see, we'll be picking new cards again with the same deck contract that we created before. The address of the deck contract hasn't changed, and we'll be using this new version of the yearc 721.
00:12:32.220 - 00:13:14.058, Speaker A: It will be as simple as that once again. And as you can see, we didn't have to update our deck contract. We just need to update the dependency that we're using in our project, in this case, the ERC 721. So, summing things up, EVM packages allows us to reuse code that is already deployed on chain, that we don't have to redeploy it every time we want to use it. And of course, as we saw before, we can opt in update our dependencies if the developers of those EVM packages that we're linking to provide new versions. So this is really good. And let's go a little bit further on the EVM packages thing.
00:13:14.058 - 00:14:03.398, Speaker A: Maybe some of you may be wondering how we can actually make sure that the code, what we're sharing and reusing on chain directly is actually safe, how we can trust the code that is already deployed on chain. So before we answer that, let's think how we probably do this. These days. We may, for example, hire an auditor in order to audit that code that was deployed on chain, and the auditor may raise some findings on that code. And we will tell the developer team in order to fix those bags or to improve the things that we found there. It will be kind of expensive in order to hire an audisor to do that every time we want to use a new dependency. And that's why we decided to start working on the vouching system of sublime OS.
00:14:03.398 - 00:14:54.630, Speaker A: This is a way to decentralize those decisions. And this is our first step towards the Toco mechanics that we've been announcing since we started this project, the first implementation of the vouching system. We're really happy to announce that it's already included in the second version of Subliminal OS we launched this week. So let's see, what do we have to say about this. So the vouching system basically allows users to back the quality of an EVM package that is already deployed. As you can see, this is something complementary to the EVM packages thing. It doesn't mean that you need to use the vouching system in order to create an EVM package, but this is the way that you can use in order to signal the security of an EVM package that is already deployed.
00:14:54.630 - 00:15:36.198, Speaker A: As you can see, this is our first step towards a gradle list of secured EVM packages. And let's see a quick example of the things that we can do with the vouching system. For example, raising here a way to register a new EVM package on the vouching system of sublime OS. It's pretty much really simple. You just need to pass the name of your EVM package and the address where it's deployed and it will be as simple as that. And of course that you can also start vouching some amounts for EVM package that are already registered in the vouching system. And the amounts that we are vouching here are not just numbers.
00:15:36.198 - 00:16:36.346, Speaker A: And this is where the SEP token is born. The SEP token is the native token of the vouching system, and it's basically what allows us to align the incentives in order to create a healthy ecosystem of secure smart contracts projects. And it was also launched with a second version of sublime OS along with the vouching system. And one more thing, we're not alone. There's a lot of amazing projects that already decided to start building their own EVM packages, and many of them are already on chain, they're already on the main net, so you can start reusing their code in your own projects through sublime OS, and you can be one of them too. So that's why we decided to start a private beta period. This is a way that we decided to gather a small group of people in order to validate all these ideas, and all the partners that all the projects that I mentioned before are going to receive some Sep tokens in order to start testing the vouching system.
00:16:36.346 - 00:17:21.298, Speaker A: And you can be one of them too. Just a quick clarification here. This doesn't mean that OS is not available for everyone. Os, as I said before, is open source, and you can use it right now if you want. It just means that the beta participants are the only ones that are going to be allowed to start testing the vouching system. Those are the ones that will receive some SEp tokens, the ones that can start vouching for some EVM packages that are already deployed, the ones that will be allowed to register EVM packages on our patching system, and so on. And you can follow this link where you will find a registration form in order to sign up for the beta period.
00:17:21.298 - 00:17:37.100, Speaker A: As I said before, it's open for everyone, so feel free to apply and we hope you do. And the registration is are finishing by mid November, so please come and join us. Thank you so much guys for hearing me today.
