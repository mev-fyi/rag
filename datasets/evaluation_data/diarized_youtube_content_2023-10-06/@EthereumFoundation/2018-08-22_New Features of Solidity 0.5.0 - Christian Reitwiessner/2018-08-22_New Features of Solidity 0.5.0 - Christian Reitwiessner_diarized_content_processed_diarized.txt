00:00:03.050 - 00:00:27.080, Speaker A: Like that. Cool. Wonderful. Yeah, thanks for coming on this day. Actually, I expected perhaps two or three people to turn up here. The rest is at the lake or in a cocktail bar or whatever things you usually should do on such dates. So thanks for coming.
00:00:27.080 - 00:01:41.048, Speaker A: Yeah, so in this talk I try to explain some new features of Solidity 50. This is special because we follow the samware versioning scheme, and this means 50 is a breaking change. And the last breaking change was, I think in something around October 2016. So quite some things happened since then. I will mostly talk about the actual breaking chains and not the actual braking changes and not the features that happened in the, I think, 25 releases we've had since then. So yeah, for the breaking changes of 00:50 we mostly focused on safety. So we noticed that it's often better to force the user to be much more explicit about some things.
00:01:41.048 - 00:02:29.668, Speaker A: We will see examples later, and we will also remove some things which can be interpreted in different ways. So we'd like to everyone be clear about the semantics of the language, and we will also add some more runtime checks. Adding rungtime checks is always tricky because the more checks you do, the more expensive the operations will be. And you kind of fight with users who want their smart contracts to be cheap, and then you fight with other users who want their smart contracts to be safe. And yeah, you always have to find a middle ground there. Okay, let's go through some of the changes. We start with visibility, constructors and events.
00:02:29.668 - 00:03:39.680, Speaker A: So these are things which you might have noticed already in the recent non breaking versions, because most of the changes we gradually introduced by the way of adding warnings if you still use the old non recommended way. So this is a simple smart contract in the 40 syntax, and if you know the language a little, then you notice at least one bug. And the bug is that this initialize function is meant to initialize the smart contract, so it should only be called from the constructor, only from a privileged user. And the reason is it sets the owner. But since there is no visibility specifier here, it's publicly visible, can be called by anyone. So anyone can change the owner of this contract. And yeah, most of you perhaps know that this is something that actually happened, and because of that we now require visibility to be specified explicitly.
00:03:39.680 - 00:04:35.250, Speaker A: And yeah, in current versions the compiler produces a warning from 00:50 on it will be an error. So now this bug is fixed. And something that also happened is that the constructor is defined by defining a function with the same name as the contract. And now of course over the course of development, you might change your mind about the name of the contract, and you change the name of the contract, but you forget to change the name of the constructor. Because of that, we now force the constructor to be specified in this new syntax where you don't use the function keyword, but a special constructor keyword. And now you can change the name of the smart contract without having to change the name of the constructor, and then events. So here we call an event.
00:04:35.250 - 00:05:19.970, Speaker A: It looks very similar to a function call, but events are rather different. They don't actually execute any code, they just log information. And because of that, to make it explicit, we require an emit keyword to be used together with events. That's not a big security thing, but it's just nice to have, I think. Good. Then the next thing is to force users to more explicitly mention the types they want to use. And yeah, here, this is also something that actually happened.
00:05:19.970 - 00:06:27.092, Speaker A: The VAR keyword can be used to declare a variable when you do not want to specify the type explicitly. And the compiler tries to deduce the type, and it does that from the first assignment that is done to the variable. And here in this case, the variable is assigned from zero. And now what is the type of the zero literal constant. So literal constants always have the smallest possible type where the constant constant fits inside. And because of that, this is an unsigned iter with eight bits. And now of course, the problem is when you pass an array which has more than 255, 56, whatever elements, then this loop will not terminate because I is always smaller than length length, because the largest value it can hold is 255, and we do not have overflow checks here.
00:06:27.092 - 00:07:06.080, Speaker A: So even if we had overflow checks, this is not the behavior you would want, because you would not be able to pass in an array with more than 256 elements. Okay, long introduction. No, the easy thing here is just disallow VAR. So we had a warning for exactly this case because that happened a lot. So when you have a for loop and do not declare the type here. We already had a warning for a long time, but now we said, yeah, I mean, just force users to specify types explicitly. That is also a rule we follow, or we more or less follow inside the compiler itself.
00:07:06.080 - 00:08:11.848, Speaker A: So I think that's good to have. Some people complain that in some cases this results in quite verbus code, but we're trying to introduce alliances or type definitions that might help in these cases. Then another thing, which is perhaps not too visible here, but in other cases a is a reference type a is an array, a reference type, which so a itself points somewhere and it can point either to memory or to storage or to call data. And in many situations I always fall into this trap from time to time. In many situations you make the wrong assumptions about where it actually points. And because of that we force the memory keyword to be used always when you declare, or when you use a type for when you declare a variable. Yeah.
00:08:11.848 - 00:09:30.396, Speaker A: So then the next thing, storage pointer. So this is something that is also a bit improved with having to specify the data locations. So the local variable p here is of this struct type, and by default it points to storage. Now, since we force a data location specifier here, this doesn't happen too often because people then think oh yeah, it's memory. So you put memory here and yeah, perhaps I should not go too much into detail here. So storage is statically allocated, so it's impossible to create new storage variables, storage objects in a certain way, and this leads to this variable actually having an invalid value, so it has to be initialized with something, but there's actually nothing the compiler could initialize it with to be valid. And because of that we now force the user to always assign something to p when it is declared.
00:09:30.396 - 00:10:26.080, Speaker A: Okay. And because of that it's better to completely rewrite this thing. So you see p is defined here and it has to be directly assigned from somewhere. Yeah, and this way it's much safer because there's no way for a storage pointer to be invalid, unless, yeah, there are some cases you might find out, but it's much harder to get it to such a point. Good, that's storage pointers. Now, something that was also requested quite often is changing a change in the scoping rules. Some of you probably don't even know, but solidity inherited its scoping rules from JavaScript, and JavaScript scoping rules are really, really weird.
00:10:26.080 - 00:11:22.340, Speaker A: The thing is, JavaScript scopes are always functions. So usually. So when you declare a variable here, in most languages it can only be used inside this block, which is delimited by curly braces. But in JavaScript a variable that is declared somewhere is always visible in the whole function, and moreover it is also visible before it was even declared and even visible outside of whatever. So this is valid solidity code, and a version of it would also be valid JavaScript. It returns three, yeah, with 50 this is not possible anymore. And we have regular block scope variables, as you would expect from something like C plus plus or Java.
00:11:22.340 - 00:11:59.996, Speaker A: So even this code is valid. This cannot be done in because you would declare a variable here whose scope is the full function. You declare a variable with the same name here which has the same scope, so you have a clash of variables. It doesn't work. But this is of course very idiomatic code to write a for loop. And with the new roles, this code compiles and works correctly. Okay, block scope means, as I said, variables are visible inside of the curly braces block.
00:11:59.996 - 00:13:01.380, Speaker A: They were declared in with the single exception that if you have a for loop and declare the variable in this first initializer block, it is visible in the for loop, but not after it. And another advantage of block scoped variables, especially in solidity, is that it helps a little improving this at most. 16 variables per function limitation because variables can be removed from the stack when their scope ends. Previously the scope was the full function, so you couldn't really remove it. And now you can remove functions when their scope ends. So you can actually have more than 16 variables in a single function, as long as you don't have 16 variables, more than 16 variables visible at the same time. Okay, so if we already have 15 functions in this 15 variables in this function, declaring this I variable twice doesn't hurt because they are unrelated.
00:13:01.380 - 00:13:46.080, Speaker A: Good, we're almost done. We also have some functionality improvements. There is now a way to remove the last element of a storage array very efficiently and idiomatically. Then we exposed the API encoding functions. So there's Abi encode, which does regular Abi encoding and returns a byte array, Abi encode packed, which does packed encoding. That's the encoding that is used by the hash functions, for example. And there is also encode with selector and encode with signature.
00:13:46.080 - 00:14:37.336, Speaker A: Those can be used to create. So Abi encode just creates the byte array that follows the four byte function selector. Am I talking crap here or are you following? So this is really, really deeply technical. So I'm really sorry about people who are already asleep. So Abi encode just returns the actual AbI encoded payload data. And if you want to use that with a raw function call, you have to prefix that with four bytes that tell which function to actually execute. So prefixing data onto byte arrays is kind of weird.
00:14:37.336 - 00:15:22.450, Speaker A: So we have two additional functions that can do that in one run. So the first argument is this four byte function selector, and then the actual data arguments follow. We'll also support enums instruction interfaces that will request it quite often, because that actually allows you to define interfaces for smart contracts or for classes of smart contracts in a useful way. These were three functionality changes. We have tons more. Most of them were introduced already earlier, so you might already know about that. Then some minor safety changes.
00:15:22.450 - 00:16:06.256, Speaker A: So call the call function. So address call has always been a very weird thing with weird behavior most people didn't know about. And that's why we decided to simplify it. It now only takes a single bytes parameter, so just raw bytes, and these are forwarded and that's it previously. So if the first argument was a bytes four had bytes four type, then it would encode differently. And also the encoding of call was very weird. It was neither ABI encoding nor packed API encoding, but something else and whatever.
00:16:06.256 - 00:16:51.484, Speaker A: So now you can use call and you would use these ABI encoding functions to create the data for call. And then just this of course applies to delegate call and all the others. Also the hash functions only take a single bytes parameter. If you want to get the old behavior, you use sha three of ABI encode packed off, and then the actual data wildcard tuple assignments are removed. This is when a function returns multiple values, but you are only interested in the first. You could do a comma equals function call, and because that was easy to get wrong. Now the left hand side has to have the same number of components as the right hand side.
00:16:51.484 - 00:18:15.730, Speaker A: So you would do a comma comma comma equals f. Interface functions have to be external. That's the only reasonable way for interface functions because, and then the next thing is also interesting. So the bytes types are byte arrays of up to 32 bytes, and they are very similar to the unsigned integer types, which also come in various flavors up to 32 bytes. The main difference is that byte arrays are left aligned in the word, and integers are right aligned in the world. Now if you convert between byte arrays and integers of the same size, what would you expect to happen? How does it convert? So convert the number eight, which is a u and eight, to a bytes one. So a byte array of length one, what happens? Can you say it again?
00:18:18.360 - 00:18:23.030, Speaker B: If the integer is an eight, then it will be all zero, one and zero. Zero.
00:18:23.960 - 00:18:25.540, Speaker A: How many zeros in the beginning?
00:18:27.080 - 00:18:27.830, Speaker B: Five.
00:18:32.380 - 00:19:12.260, Speaker A: In hex or in binary? Yeah, right. So it takes the single byte which was right aligned and just shifts it to the left. Exactly. I hope this is what everyone would expect. And it gets tricky if you convert between these two when the number of bytes are different, because, okay, if you convert between u and eight and u and 16, then you would expect nothing to happen. It's just the range is increased. And if you convert between bytes one and bytes two, it would just add a zero byte.
00:19:12.260 - 00:20:20.248, Speaker A: Now the question is, what happens when you convert between u and eight and bytes two? Does it go through u in 16, or does it go through u in eight? So does it first, where does it add the zero? On the left or on the right? Right. That's the tricky part, and that's why we disallow that. And you still of course can get exactly the same behavior by just having two conversions. But you explicitly specify in which order you convert, and so it should be visible what happens. Right. Shift unsigned integers. This is actually my mistake, I thought, oh yeah, shifts are just divisions by powers of two or multiplications by powers of two, which is of course incorrect for signed integers, and with five serial fixit, this is only right shifts on signed integers, which probably nobody actually uses, since it's not just a division by a power of two.
00:20:20.248 - 00:21:10.040, Speaker A: It's a little bit more expensive because the EVM does not have native shift operations. But I think that's fine if nobody uses it anyway. Yeah, and then constant state variables were very weird because they were kind of usable as macros. So state variables are these variables which are declared at contract level, and if they are constant, they don't have to be constant in, but instead you would assign them from an expression. And then this expression is copied everywhere where this variable is used. And if it's not constant, then it results in a different value, which of course defies the purpose of a constant. And now we've forced it to be pure, which means compile time constant, and thus it is still.
00:21:10.040 - 00:22:06.136, Speaker A: So the way the code is generated is still the same. The expression is copied everywhere, but at least the value would be always the same. Good. Then the major safety changes view. And so since bizantium we have the static call upcode, which enforces at the level of the EVM that you cannot change the state of the blockchain and view and pure functions are disallowed to make any modifications to the state. View can read from the state, but pure functions cannot even read from the state, and we cannot enforce. So at the level of the eVm, we cannot enforce the difference between view and pure, but we can enforce the difference between regular functions and view or pure functions.
00:22:06.136 - 00:23:09.170, Speaker A: And that is why we use steady call. It might happen that you compile code, solidity code, and then run it on a virtual machine which does not implement static call, sometimes testnets. If you run a client in testnet mode, then sometimes it uses the very old frontier release, and in that case you have to manually set your EVM to the right version to Byzantium to do that, if it's impossible to set it to Byzantium, then you can specify. So in a compiler setting you can say this is the target EVM version I want to compile for, and then it would not use. So this is also something that happened. I think it was an exchange implemented the ABI encoder incorrectly. This is again this bytes alignment thing.
00:23:09.170 - 00:24:04.880, Speaker A: So what happened was that you specify an address to send your money to, and if the address has leading zeros, then this encoding library would just shift it to the left, so it would not right align it, but it would left align it. And that of course results in the money ending up on the wrong address. But the good thing is that the way that was implemented was that it actually did not write padded with zeros, but the data was just one byte short. And yeah, I'm really going into details there, but eyes are still open. That's good. So when you read from call data, then everything is zero padded. So the data that is passed on to a smart contract actually ends in an infinite number of zeros.
00:24:04.880 - 00:24:50.720, Speaker A: And because of that it still worked. So if you call a smart contract and give it not enough data, then it still works because it just fills with zeros. But this is most 99% of all cases not desired, I would say. And because of that we now check whether the data that is supplied to the smart contract is long enough to hold, actually to be decoded, to be decodable. This might cause some calls to fail if you do low level stuff, proxy contracts or something like that. So please take care there. And then inline assembly.
00:24:50.720 - 00:25:52.230, Speaker A: In the very beginning you were able to do a lot of things, almost all things that is possible with bytecode. And due to several reasons we want to restrict that. One reason is because we want to compile to webassembly and not only to EVM, and for that we disallow basically everything that messes with the stack or messes with the program counter. This means explicit jumps are disallowed. You have to use the control flow statements we offer. So switch if four, and also direct access to the stack is disallowed. And this actually turns inline assembly into a language that does not really assume that there is a stack, or that is, they are just variables, and you can call functions and assign to variables and that's it.
00:25:52.230 - 00:26:30.184, Speaker A: Good. Yeah, and then there's another weird thing which is different in other languages, which perhaps I'm also to blame because I didn't find it in the review. So do while. So the do while loop is basically similar to a while loop. So the control for enters here and then runs this. And the difference to the while loop is that the condition is checked at the end. And if the condition is true, it jumps back to the beginning, runs it again and checks the condition again.
00:26:30.184 - 00:27:19.690, Speaker A: And if the condition is false, then it exits the loop here. Now there are these statements called continue and break. Continue just skips the rest of the loop and continues with the next iteration. And break exits the, the whole loop exits the loop completely. And yeah, somehow insulinity continue was implemented in a way that if you have continue here, it jumps to the beginning of the loop and skips checking the condition because I mean, the condition is at the end. That's of course not very useful and not the way do while is implemented in other languages. So now continue does not jump to the beginning of the loop, but to the beginning of the check.
00:27:19.690 - 00:28:16.196, Speaker A: Okay, that's about it. Do you still have questions? Yeah, you said something about the encoding instruction, et cetera, in the costing editor. That's no out. I didn't mention that because it's not finished for 00:50 actually, are you talking about this new ABI decoder? Yeah, that's still experimental. And the reason it's still experimental is because we wrote it in a way which is extremely modular. So every tiny little function, yeah, every tiny little thing that is to be done inside this decoder encoder has its own function. And most of the time these functions only consist of a single opcode, or sometimes they even do nothing, they just return their input.
00:28:16.196 - 00:28:58.310, Speaker A: And the idea was that it's much easier to implement it in the correct way because you implement every single thing only just once and then call it from everywhere. But it will of course result in very inefficient code because you have tons of function calls and jumps. And because of that we implemented an optimizer, a new optimizer just for Yule, just for inline assembly, and we're not yet confident in that optimizer, and that's the reason. So if you use Abi encoder V two, now the optimizer is switched off so you can use it, but it will be much more expensive probably.
00:29:06.010 - 00:29:08.258, Speaker C: Tell me more about what that one will do.
00:29:08.364 - 00:29:35.460, Speaker A: So it's basically the same as ABi encode. Okay, so there's encode with signature and encode with selector. The difference is that one of them, I think it's selector, one of them takes a bytes four which is just the hash, the beginning of the hash of the function signature, and the other one takes the signature itself and then hashes it.
00:29:39.590 - 00:29:41.650, Speaker C: To create a signature out of the string.
00:29:41.810 - 00:29:52.390, Speaker A: Yes. So for the one you would pass f opening parentheses, closing parentheses in a string, and the other would get four hex bytes.
00:29:56.270 - 00:30:21.140, Speaker B: Yeah. You mentioned that the generation of the assembly has changed. There are some contracts, especially the upgradable contracts, rely on the fact how internally, for example, solidity compiler like storage is an extendable. So basically if you are adding something in storage, when you are upgrading the contract to these objects, after this change, it is going to be.
00:30:25.000 - 00:30:30.084, Speaker A: So we did not change anything in the storage layout. What are you referring to?
00:30:30.202 - 00:30:47.398, Speaker B: What did I say? In general, like a proxy contract also, which is kind of rely on the fact. Can it be that after this change, upgrade will be broken?
00:30:47.494 - 00:31:28.990, Speaker A: Yeah, hopefully not because of the storage layout. So storage layout is something that is very critical, and if we change it at some point there will be big, big warning signs and perhaps even a runtime check or something like that. The reason it is critical is because through libraries can access storage of other contracts. And of course you can link against the library that was compiled with a different compiler version. Because of that we actually cannot ever change storage layout.
00:31:30.770 - 00:31:33.290, Speaker C: Similarly for memory layout.
00:31:33.450 - 00:32:11.100, Speaker A: Yeah, memory layout is different. So memory layout is changed all the time. Actually we did change. So there is this. So at the position zero x 40, there is a special value that points to the first free space in memory. So if you want to write something into memory without overwriting something, then you would write it there and then increment or increase this pointer. And what we changed was not the location of this pointer, but its initial value.
00:32:11.100 - 00:32:18.000, Speaker A: And this was done in a non breaking change because I hope it didn't break anything.
00:32:19.250 - 00:32:47.702, Speaker C: Quite a few libraries that depend on a 32 byte length to strings and lines and arrays that use assembly to for example do some simple string manipulations. In order to do that, they would expect a layout where you have, where the memory string memory value is a pointer in memory that starts with a 32 byte length prefix and then the contents of the string.
00:32:47.766 - 00:33:31.000, Speaker A: Yes, sure. I mean we're aware that assembly or there are libraries that use inline assembly. That's also how it should be, of course. And if we ever change that, then there will also be big warning signs. Okay, so memory layout itself was not changed with just this change where the free memory starts. So we changed it from, so its initial value was zero 60, so right after the pointer itself, and now it points to 80. And the reason is there is, in this gap, it's a single, is it a single 32 byte gap? And we assume this gap to be always zero.
00:33:31.000 - 00:34:26.790, Speaker A: And we use this assumption to have more efficient initial values for dynamic memory arrays. Previously, if you declare a variable of memory type with a dynamic array, it would create a new memory array of length zero, which occupies 32 bytes in memory for this length prefix, and the length prefix is zero. So what we now do is we just initialize it with a pointer pointing to this gap. And because we know, or we hope, that the value in this gap will always be zero, all memory arrays actually point at the same value and it's zero. So the length of the array is zero, so there's no data that has to fall.
00:34:28.600 - 00:34:35.588, Speaker C: I can imagine that you might want to have some scratch based reserved in memory that you can use in assembly, for example, spillings, textbooks.
00:34:35.684 - 00:35:06.950, Speaker A: There is scratch based space and scratch space, and that's the first 64 bytes. Okay, so this can always be used unless you're inside of the expression somewhere. And of course you can also use the point where the free memory pointer points as scratch space, because you don't have to increment it if you don't want this data to live on. Exactly.
00:35:07.480 - 00:35:11.700, Speaker C: Is this sort of internal memory mechanism documented?
00:35:12.840 - 00:35:46.220, Speaker A: Yes, we have. I think all of what I just said is documented. Perhaps not the part that you can expect the free memory point to point to zero filled memory. So it's internals of the compiler somewhere in the, in the solidity documentation at the very end of the in depth part. Any more questions? Yeah.
00:35:50.030 - 00:35:51.980, Speaker B: Response data from.
00:35:53.710 - 00:35:55.020, Speaker A: Sorry, can you say it again?
00:35:55.790 - 00:36:13.440, Speaker B: Nowadays if you do call, then you just get calling external contract through interface. Because of course you don't know anything about data type data. Would it be considered to allow users to somehow handle these things?
00:36:14.470 - 00:37:09.780, Speaker A: Yeah, there's a plan to make it return two values, a Boolean success value and a memory byte array with the return data. And the reason we didn't include it now was because it's not really useful because we don't have ABI decoding functions. So since we don't have ABI decoding functions, you have to resort to inline assembly anyway, and then you can just do the call with inline assembly to begin with. And the reason we don't have ABI decoding functions is mainly because we don't have a nice syntax. So the difference between ABI decoding and encoding functions is that in both of them you need to specify the types somehow you want to decode but for encode you just take the types of the arguments you put into that. And for decode, that doesn't really work. So you can look at the types you want to pull out.
00:37:09.780 - 00:38:03.962, Speaker A: And the syntax of solidity doesn't really allow for a way to specify the types in a nice way. So we thought about using, I don't know, perhaps, how do you call it, angle brackets. But the parser doesn't really support that yet. So it will be in zero 60 at the earliest, I guess. More questions? Yeah, could you expand on the. I'm not sure seeing any runtime checks as you mentioned in the beginning, what are the runtime checks that are coming? So one of them is the call data size check. Another one is add mod and mul mod.
00:38:03.962 - 00:38:49.174, Speaker A: These are, these are built in functions that take three parameters and do modular addition and multiplication. And they check for the third parameter to be zero. This is probably not something you would encounter, but yeah, is there another one? So something we already added and was perhaps not such a good idea to add it already now was check the size of the return data when you call a function. And that caused some tokens that claim to be ERC 20 tokens to break. That's another runtime check. We're currently also experimenting on overflow checks. But what I said in the beginning.
00:38:49.174 - 00:39:12.260, Speaker A: So if overflow checks are nice to have, but they will be more expensive. So we're currently evaluating how expensive they will be. And regardless there will be a keyword to mark an area to be unchecked. So I think that's also something, let's see, sharp has where these overflow checks would be switched off.
00:39:17.190 - 00:39:36.530, Speaker B: In this current release. Can we assume that moving into more like a typified, like type conversion giving an error, or like you try to assign a flow to the integer and not type integer.
00:39:37.530 - 00:39:40.086, Speaker A: I didn't get that moving into what?
00:39:40.268 - 00:39:48.440, Speaker B: Moving a varm explicitly giving a type makes the language more like a typical. There is no like a type deduction like.
00:39:52.400 - 00:39:58.880, Speaker A: I mean, it didn't really have type deduction anyway. It just took the type of the value. I'm not sure if you could call it type deduction.
00:40:01.220 - 00:40:25.180, Speaker B: Can you see like giving warnings and error like comparing if you are doing some cutting type changing, which are not like a good idea, let us know. An assigned integer which can bring the upcoming in this release or in.
00:40:27.810 - 00:41:29.982, Speaker A: Explicit type conversions are something you shouldn't need to do anyway unless you do some lower level bit fit link. So yeah, we try to kind of make that bit more visible that these explicit type conversions. So when people try to do that, but I haven't decided to do anything about it yet. If you have some examples to share then please contact me. But yeah, implicit type conversions are always possible when the value range grows or is the same. And you don't need to do a conversion there, you just assign it to the value and it implicitly converts if you change. Yeah, so if you, for example, as we had earlier u and eight to bytes one, that has to be an explicit conversion, even though the value range doesn't really increase.
00:41:29.982 - 00:42:08.750, Speaker A: So you won't notice the difference. Okay, but that's disallowed anyway. Now you won't notice the difference between converting from un eight to bytes one and converting from un 16 to un eight, for example. So the second actually truncates data, and the first does not truncate data, it just changes the alignment. So having a more fine grained distinction between those could be something we should add. But again, it's not clear how to do that in a syntax. Which syntax to use for this distinction?
00:42:17.110 - 00:42:23.590, Speaker C: Yeah, what are your top three upcoming versions? What would it take to deliver?
00:42:25.610 - 00:43:09.934, Speaker A: Yeah, I hope that the film switch to the new intermediate language Yule will be something I can focus on soon. And the optimizer that comes with it, not sure how to get that faster. And this is also something the user won't really notice. So it's always hard to justify working on that. But in the end we have to do it because I think we have to move to something like webassembly or also get kind of safer code generation because it's much harder to make mistakes in this intermediate language. And also the optimizer might do much more things that were impossible before. And then of course the SMT component.
00:43:09.934 - 00:44:06.550, Speaker A: So the static SMT based analyzer formal verification component, we're pretty far there already. So it now accepts storage, so it can handle storage variables. It even handles branches and recombines the control for branches later on. The main thing we will have to add there next is handling modifiers, and when we're at that stage I think we can have a proof of concept release of that component. Yeah, that's something I want to avoid because you can't rely on SMT checkers or I don't want to rely on them. There are some things that the optimizer can do, but we have to be really careful. I mean, the SMT checker is just a black box.
00:44:06.550 - 00:44:38.182, Speaker A: Anything can happen inside there, anything can change between version changes. And so on. No, it's just something like, yeah, someone else is doing it, and you don't know how stable it is. I mean, usually they don't have bugs. They only have bugs and components which were recently added, but, yeah. Okay, then. Thanks a lot for coming.
00:44:38.236 - 00:44:38.840, Speaker B: And.
00:44:41.370 - 00:44:49.180, Speaker A: Thank Maurice. Do you want to say something about the next meetup or.
