00:00:13.050 - 00:00:58.510, Speaker A: Hello everyone. Welcome to this lightning talk about the unspecified evaluation order in solidity, or how our colleague Tinan Richards, who unfortunately couldn't make it to Bogota, won the underhanded solidity contest test. The goal of the underhanded solicitity contest is to write harmless or unsuspicious looking, smart contracts with hidden bugs or pitfalls, thereby exposing weird behavior and solidity in a fun way. Let's jump right in. Here's an excerpt from the solidity docs. What it's basically saying is the evaluation order of expressions is not specified. If function f takes two arguments, which are further function calls to functions g and h, it's unclear in which order they are evaluated.
00:00:58.510 - 00:01:35.702, Speaker A: Either function g is evaluated first, or function h is evaluated first, but we can never be sure which one. Obviously, function f is evaluated last because it depends on the result of the other functions. Let's consider this example. Let's say we call a function with an argument of two. What's the correct result here? Is it four or five? Well, it depends on the evaluation order, and it's not really specified. For the solidity compiler, this is not unique to solidity. Insufficient specification of expected behavior can be found in all kinds of different programming languages.
00:01:35.702 - 00:02:31.390, Speaker A: A big headache for everyone involved. Does this matter in practice? Yes, of course it does, as it can lead to unexpected behavior results. By analyzing the code generator of the solidity compiler, our colleague Tinan found three cases of unusual evaluation orders which this talk is about. Yes, most of the time, evaluation order is as expected from left of right, but not always. First two examples are the opcodes, Admod and mulmod. Here the evaluation order, surprisingly, is from right to left. So if we evaluate f of two, it first evaluates a, increments it by one, and only later evaluates the first argument, which results in admod with argument free two instead of two two, as you might have expected.
00:02:31.390 - 00:03:17.162, Speaker A: Interestingly, this is actually documented in the solidity, however, not where you expect. In solidity, there are currently two ways on how code can be compiled, the default code generation and the new code generation via the Yule IR pipeline. In the documentation describing the Yule pipeline, it's actually documented that here the evaluation order will no longer be from right to left, but also left to right. The most interesting one is the order of evaluation inside events. This one is really special. The parameters are evaluated in a bizarre order. First the indexed parameters are evaluated from right to left.
00:03:17.162 - 00:04:03.434, Speaker A: Then the remaining parameters are evaluated from left to right. Wow, who knew that which solidity dev has this in mind when coding no one, right? This can lead to really strange or unexpected behavior. And this is what Tinan leveraged and used for his submission to the underhanded solidity contest 2022. He wrote a simple decentralized exchange where liquidity providers and the admin shared the collected fees in a legitimate decks. The admin shouldn't be able to screw over the liquidity providers by changing the fees afterwards. This is the heart of tenant submission. Looks legit, right? What's wrong here? Let's see.
00:04:03.434 - 00:05:06.798, Speaker A: So the admin calls functions change admin fees once he wants to update the fee it looks like function retire old admin fee is called first, which executes claim fee and distributes the fees based on the old fee amount to the liquidity provider before calling set new admin fee, which updates the admin fee to the new admin fee. But remember what we just learned before indexed events are evaluated from right to left. So actually set admin fee is evaluated first so the fee is updated and only afterwards retire old admin fee distributes the liquidity fee to the liquidity providers based on the new fee. Really surprising. So one important thing to mention here. The solidity compiler asset has two ways to compile code, the default way and the new way, using the Yule IR pipeline. In the Yule IR pipeline, this is no longer true.
00:05:06.798 - 00:05:23.980, Speaker A: There. The function evaluation order is strictly from left to right. However, per default, the solidity compiler uses the old code generation, but this may change at any time in the future. Thanks a lot. Happy to take any question. 1 minute left.
