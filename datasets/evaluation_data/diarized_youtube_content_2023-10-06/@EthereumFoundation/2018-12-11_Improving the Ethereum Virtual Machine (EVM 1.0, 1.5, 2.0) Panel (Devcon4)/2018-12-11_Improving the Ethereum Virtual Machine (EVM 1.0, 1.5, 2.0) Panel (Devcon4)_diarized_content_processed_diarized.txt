00:00:00.650 - 00:00:35.974, Speaker A: Up next, we have a panel on EVM, which is the Ethereum virtual machine. There's obviously some overlap here with the ewasm topic, including those of us on the stage. Unfortunately, we had a couple of other non ewasm panelists who were not able to make it. But we do have Greg with us. I'm thrilled to have him join us for this part. And just to be clear, the topic is EVM, as I said, and we may touch upon some UWaSm stuff, but we'll be focusing more upon the Ethereum virtual machine, what it looks like today, the road forward challenges, that kind of stuff. So cool.
00:00:35.974 - 00:00:39.706, Speaker A: I'll moderate, but why don't we kick off with introductions? Greg, do you want to start?
00:00:39.888 - 00:01:24.774, Speaker B: Yeah, I put a lot of work into what's now called Aleph, is it EVM 1.0? And put a lot of work into specification for making fairly quickly some improvements to get better performance, better formal tractability for the EVM that could get into place much more quickly than the full EWAS and development. Those got sort of set aside for the last year. I don't know why, but they did.
00:01:24.972 - 00:01:28.102, Speaker A: Greg, that's a really interesting topic. We'll come back to that in just a second.
00:01:28.156 - 00:01:28.934, Speaker B: Come back to that.
00:01:28.972 - 00:01:31.260, Speaker A: We'll just do quick intros and then we can start with that.
00:01:31.710 - 00:01:32.970, Speaker B: We're just doing an intro.
00:01:33.040 - 00:01:33.322, Speaker A: Yeah.
00:01:33.376 - 00:01:53.906, Speaker B: Okay. So that's what I did, and I'm working on plans to get that going again quickly and well integrated with EVMC work and ewasm work. So we can sort of front run on that and get people going. And off we go.
00:01:54.008 - 00:02:53.860, Speaker C: Thanks, Greg Pavel hi, I'm Pavel and I'm working for Ethereum for some time, and I was mostly interested in EVM long time ago. I even created projects to compile EVM code to machine code, some kind of JIt solution. And that also inspired some small but important changes in EVM spec before Ethereum even launched. And now I'm trying to bring some cooperation to EVM related software by introducing this EVMC project to allow quickly swap VM implementations. And I am also cooperating with team.
00:02:57.050 - 00:03:32.270, Speaker D: I'm Casey. I really got my start as a core developer on Ethereum Js, the Javascript client, well, virtual machine back in 2017 for Byzantium. And I also try to help with security and testing, fuzz testing, finding consensus bugs, and I try to help out with contribute to research on DRM 2.0. Sharding.
00:03:33.730 - 00:04:15.790, Speaker E: My name is Alex. I started off at three mjs as well, working mostly on the VM in JavaScript, but at the same time started to work on solidity, trying to fix bugs and then actually adding features. So that result in a lot of EVM works like both of these, and ended up contributing to EVMC and ended up contributing to ewasm in the end. But I'm still also very interested in improving the EVM. So actually with Pavel, we submitted a couple of eips which are accepted to Constantinople, and Pavel also submitted his own eips. And I was really excited of the EiPs Greg was doing regarding EVM 1.5, but they are much bigger eips than what we have submitted.
00:04:15.790 - 00:04:22.302, Speaker E: So that's basically about me interested in EVM as well, not just ewasm. Cool.
00:04:22.356 - 00:05:00.074, Speaker A: I'm Lane, I'm also on the EWASM team, been a member of that team since the beginning of this year, and I think my interest in things like instruction sets and eWASm and EVM comes from just a deep curiosity of starting at the very bottom of a system and kind of working my way up. There's a lot of amazing work being done at higher layers, layer two, layer three, et cetera, but really understanding this virtual machine, this Ethereum machine that we're building from the bottom to start. Cool. So let me actually, I'll come back to EVM 1.5 stuff in just a sec, I promise. I just want to kick off with an introductory question, which is maybe, Alex, you could take this one. Just what is EVM? How did this thing come into existence? What is it supposed to be?
00:05:00.112 - 00:05:05.840, Speaker E: Or do I may want to pass in there if someone else want to talk to that.
00:05:08.530 - 00:05:57.134, Speaker B: I mean, it started from the beginning. There's a section of the yellow paper which describes the EVM. It's an essential part of even the concept of Ethereum. We have smart contracts, and that's what initially distinguished Ethereum from others. And the EVM is what did it. And not to be too nasty, but part of my job is to be a nasty old man and grouch at people, because I've been in the industry a long time, and the EVM we have was designed by cryptographers, not by virtual machine experts. So it has certain problems, which I ran into when I went into it when I got here and said that this thing needs to be a lot better.
00:05:57.134 - 00:07:06.966, Speaker B: Some of the problems affect performance. Even worse, some of the problems make it very difficult to formally analyze the code. And that's something that's important to me. I sneered at formal analysis my whole career because I didn't see that taking 10,000 or 10,0000 line program and then writing a million line proof was going to help anything. Now we're looking at programs which are even smaller than what we used to write for our Apple two s smaller than the 64k segments on MS dos that we used to have to write in. I remember squeezing a relational database into a 64k segment. It suddenly starts to make sense when you've got an awful lot of money hanging on twenty four k of code to spend a lot of money doing anything you can to prove it right.
00:07:06.966 - 00:07:35.662, Speaker B: And the current VM makes that very difficult. Wasm makes it a lot easier. But when I arrived, wasm was not yet a thing. It was a dream. I don't know exactly where it was in the roadmap, but there was no spec for it. That was finished. It was not minimal, viable product was not even there.
00:07:35.662 - 00:08:47.190, Speaker B: So I set out to say, well, I don't want to wait that long, and I'm getting back to doing that. But that's basically what the EVM is right now and part of the troubles we're running into it. And what I joke here's the t shirt from Cancun, day of the dead. It's a day after Halloween now, there was an accident with laundry bleach, so it's been to hell and back. And I never again want to be awakened on a caribbean beach during a vacation to discover that yet another million eth has fallen down a rat hole because there was a one line bug in her. So that's my goal right now. So I'm just trying to get together some people and some money to pursue that in parallel and trying to get in coordination with the WASM team so we can get that done more quickly onto the main chain.
00:08:47.190 - 00:09:08.730, Speaker B: And we're going to be able to compile that code to ASM code so there's not going to be any real conflict or trouble for customers. As we move into WASM. I sort of see wasm as becoming the assembly language of Ethereum.
00:09:10.450 - 00:09:30.580, Speaker E: I think just halfway your interesting line, I kind of felt like that you're saying that wasm is ready now, we don't need EvM. But then you iterated on it. And I think it was really interesting what you said in general, I want to hear a bit more about that at some point.
00:09:31.190 - 00:09:53.754, Speaker A: Let me just add a tiny bit more color to the introducing EVM idea. As you said, greg. Right. EVM is sort of the implementation of the yellow paper, right. It's the state transition machine in the yellow paper. And it's a really interesting, unique, really well designed virtual machine. Hold on.
00:09:53.754 - 00:10:26.514, Speaker A: Wait till I share the second half of my thought. I'm paraphrasing Nick Johnson here. It's well designed. However, it's a theoretical sort of virtual machine, right? So you get these interesting things, like these 256 bit words. So even if you want to do very simple integer math, it's very inefficient, right? Because you have all these kind of wasted bits, and it doesn't resemble anything like an actual hardware instruction set. Whereas in contrast to something like webassembly, webassembly is very close to actual hardware. Does that sort of address your concern, Boris, or do you still think it's okay, cool.
00:10:26.632 - 00:10:34.182, Speaker F: I believe what I have heard said from other people who are experts in the space is that it is an excellent VM using theories from the.
00:10:34.236 - 00:10:35.400, Speaker A: Exactly. Okay.
00:10:36.570 - 00:10:44.314, Speaker F: And that we could use techniques that are more modern to make a much, much better VM. Nothing is blocking us from making it better.
00:10:44.432 - 00:11:00.000, Speaker A: Okay, so just to restate what Boris said for, I guess, recording and Internet peoples, the EVM is a very well designed VM using technology that sort of comes from the 1960s, and that we could develop a much better vm today using modern technology.
00:11:00.370 - 00:11:19.842, Speaker B: It also has a very clever feature called the dynamic jump, which back in I think actually 50s Fortran had, it was called a computed go to, in which you can do some sort of arithmetic that says where you want to jump and then you jump.
00:11:19.906 - 00:11:21.240, Speaker A: Why is that a bad thing?
00:11:21.610 - 00:12:28.774, Speaker B: Because when you're doing formal analysis, you get to that point in the code, and you want to say, well, where's this jump go? And the answer is, it can go anywhere in the program. And I'd done one round of optimization, I think, about doubled the speed of the interpreter. And then I wanted to do the next round to apply some techniques that I'd invented in optimizing the interpreter in the Oracle kernel, and came around and went, uh oh. And I showed it to Christian, and he said, well, of course, because of the dynamic jump, you don't know what level of the stack you're at. I'm going, shoot. And stronger words than that. And then I started going, okay, how do I fix this? And discovered it like, there's no basic subroutine, just a sub instruction.
00:12:28.774 - 00:12:55.940, Speaker B: And even in the. Even in the 50s, most computer architectures had some sort of instruction for making subroutines. And the idea was, well, you can make those out of dynamic jumps, and if you ever look at the code that solidity generates for calling a function. It's pretty.
00:12:57.110 - 00:12:57.726, Speaker A: Next.
00:12:57.848 - 00:13:15.226, Speaker D: Sorry, I got a follow up question. Pavel, you said earlier that you suggested some small but important changes to the EVM before Genesis launched in 2015. Was the dynamic jump on your radar at that time?
00:13:15.248 - 00:13:46.360, Speaker C: Yeah, that was the problem. So even before, the situation was much worse, because now at least you have specify what are possible destinations for jump. So you have special jump desk instruction. So these are valid places where you can jump to. Before that there was no such thing. So you can jump anywhere, including data from push. Even so you can execute code in push data.
00:13:46.360 - 00:14:50.700, Speaker C: Before it was impossible to have any other further translation of EVM bytecode. So that at least allows some way of compiling EVM bytecode to machine code because on this machine code level you are not allowed to do. I mean, there's a new way, but that would be horrible. So yeah, that was the change. I joined quite late during the process and also I didn't know much as I know now, and didn't have courage to change it to something like better or behaving, although we had like JVM example, when it's fixed, what the stack height can be when you enter the function. This is missing. Definitely.
00:14:51.710 - 00:15:00.378, Speaker B: We're getting deeply technical here. I don't know, some people are probably excited and some people are just, we.
00:15:00.384 - 00:15:04.366, Speaker A: Have at least one nerd in the room. We'll save tons of time for audience questions.
00:15:04.468 - 00:15:54.302, Speaker B: Another problem is that you can optimize this. The compiler can look and go, well yes, you're using 256 bit registers, but there's instructions like add mod and mul mod. So you can say that really I'm operating, I'm only using 64 of these bits. The compiler can generate 64 bit code, but tough. We're still going to charge you gas as if you were working with 256 bits. I think only in the last month I think I figured out a way to fix that. Looking at the work that's being done on the iel virtual machine through Gagor and other people at runtime verification have been working on, but I haven't had time to talk to anyone and write any ip on that.
00:15:54.302 - 00:16:24.520, Speaker B: But basically to charge the gas based on how wide you actually know, what you can tell is the maximum width of register you need. So there's basically things that can be fixed and we think Boris, who just spoke up there and I don't know if Brooke is still around or not, she's an amazing formalist. She's going to be humble there.
00:16:25.450 - 00:17:06.558, Speaker E: Greg, before you go any further? Just wanted to reflect on one part. You said that maybe specify the actual width of the data you want to apply the computation on. There's just one thing worth mentioning here. Currently the instruction set looks like as there's a single instruction which can have an immediate value, and that is the push instruction. No other instruction can have immediate values. Every single other instruction is just operating on the stack. And there were a couple of different proposals to augment other instructions to have immediate values or have like multibyte codes, opcodes to encode different behaviors.
00:17:06.558 - 00:17:39.760, Speaker E: And there was a big resistance to do that. And one of the reasons people said that it's going to make the current verification tools have to be changed and we cannot afford that. So there was a real big pushback. And what you suggest, I think I would imagine it to be implemented if say like the addition opcode would have an immediate value specifying the bit it's operating on, or you would have a multiple bytecode upcode. But we have this pushback that people don't want to have changes there.
00:17:40.690 - 00:17:47.570, Speaker B: You can simply call mod after you've pulled that data in, because you know you only need so many bits.
00:17:50.710 - 00:17:58.182, Speaker E: And you want to detect patterns in the VM that there's like a mod before and then there's a calculation and you charge less.
00:17:58.236 - 00:18:10.220, Speaker B: Yeah, if some data came in and then you mod, you've just thrown away all those bits. And it means a compiler like solidity will have to generate code to take advantage of that.
00:18:13.070 - 00:18:24.240, Speaker E: Solidity is actually today generating code like that if you're using smaller data types. But since gas is charged for even the mod instruction, it is more expensive so people don't use it.
00:18:24.690 - 00:18:31.120, Speaker B: So we have to change the gas model so that that actually helps in the way that it was intended to help.
00:18:33.010 - 00:18:49.400, Speaker A: So we talked about one thing that we kind of have consensus that we could or should and maybe will change, which is removing dynamic jumps. I'm curious, what other things? If you could change one thing besides that in EVM, what would you change? Maybe we could just, I don't know if you guys all have an answer.
00:18:52.250 - 00:19:30.658, Speaker E: I guess we have overlapping answers. The big one is to remove dynamic jumps, have call frames, and this will give a couple of different benefits, a lot of those Greg explained. But another immediate benefit people actually going to feel is you can address the arguments to the function much more easily than right now. And it also makes compiler code generation phase easier. People have a lot of pain with solidity giving this random awkward error message stack too deep. And it is giving it in various different ways, various different locations. And it's just a lot of work to work around that with the current EVM model.
00:19:30.658 - 00:19:36.950, Speaker E: So I think this is the core which is blocking so many things. So that would be my number one.
00:19:37.100 - 00:19:38.520, Speaker A: Casey, do you have one?
00:19:39.530 - 00:19:43.270, Speaker D: No, I'd rather just switch to webassembly.
00:19:44.250 - 00:20:16.462, Speaker C: Pavel for me would be all of this, let's say soft errors that you can get. I mean, when you divide by zero, you get zero. It doesn't make sense. When you access data that isn't there, you get zero. And for first it makes verification harder, not easier. Although some people said, now it's defined what's going to happen, but mathematically it doesn't make sense. And it's also very dangerous.
00:20:16.462 - 00:20:32.600, Speaker C: And we have examples of this being broken in deployed production ready smart contracts. So yeah, that would be my change. So I would just terminate execution if something like that happened.
00:20:34.090 - 00:20:37.720, Speaker A: Greg, up to you, and feel free to use this as an opportunity to introduce to your.
00:20:38.670 - 00:20:50.300, Speaker B: And I'm with Casey and it's part of why I asked the question on scheduling, because I know that I can much more rapidly implement EIp six one five.
00:20:51.170 - 00:20:52.720, Speaker A: Which one is six one five?
00:20:54.130 - 00:21:39.740, Speaker B: That's the proposal to get rid of dynamic jump, introduce subroutines and a few other opcodes to clean that up. It would be a separate. There are separate things you could do, like what Pavel mentioned. Those might be work you don't want to do. There's a VIP 6116 to put in. Cindy, it's not clear if we want to do that or just wait for wasm. For me, I'm working with Boris and Brooke to just raise the money and put the plan together to do that just because for personal reasons, I decided I didn't want to do it under contract with the foundation directly, but wanted to have more control over the project myself.
00:21:40.590 - 00:21:44.860, Speaker A: And this is EVM 1.5, what you referred to, collection of these two.
00:21:45.250 - 00:22:19.820, Speaker B: And I guess Boris is telling me, getting out, talking to some fair number of butter clients are going, if we can quickly get this stuff, we'd really like it. And EVMC means if we wrap it up that way, they can get it, they can plug it in, they can use it, and then when wasm is available, they can get it, they can plug it in, they can use it, and just try and get past this problem much more quickly.
00:22:22.190 - 00:22:51.890, Speaker A: So there's kind of two schools of thought right now about the state execution engine in Ethereum. One is we should focus all of our resources on UASM, and sort of, as Casey alluded to, like that should be the emphasis right now. But there's clearly another side, another way of looking at this, which is that we should not try to deprecate EVM, and we should accept that it's going to be with us for a while, and we should be investing more in it. I'm just wondering, Greg, maybe you want to make the case for why that's worth doing, even in light of evasm.
00:22:53.510 - 00:23:36.740, Speaker B: I haven't counted, but how many EVM contracts are on the blockchain now? What rate is it growing at? Is it quadratic or exponential? If it's exponential, however long it takes to get ewasm out, how many more Evm will be out there? How many existing tools exist for analyzing EVM? One code? How many new languages are being created? Basically, there's already an ecosystem growing up around that. And so it doesn't help the community to just say, well, don't bother, because at some point in the future, we're going to throw that away.
00:23:39.190 - 00:23:46.600, Speaker F: If we start announcing ewasm and everybody stops building smart contracts for a year, that's a problem.
00:23:47.610 - 00:23:53.000, Speaker A: The sync layer issue, like both ewasm and EVM 1.5.
00:23:53.530 - 00:23:57.122, Speaker E: I'm curious, what are the backwards compatibility.
00:23:57.186 - 00:23:59.930, Speaker D: Concerns with, say, removing dynamic jumps?
00:24:00.830 - 00:24:05.994, Speaker E: I know with ewasm there's various proposals to add backwards compatibility, which might help.
00:24:06.032 - 00:24:12.526, Speaker D: Alleviate the Sinclair issue that Boris and Boris mentioned.
00:24:12.708 - 00:24:18.480, Speaker E: So I'm curious if you guys could maybe fill me in on that, and then we can.
00:24:19.810 - 00:24:41.720, Speaker C: Well, for EVM 1.5, there was simple idea to do some preprocessing on the deployment time. So we don't allow dynamic jumps anymore. I mean, we don't allow to deploy, let's say, EVM 1.0 contract at some point, but the ones that are there, they will be there all the time.
00:24:42.650 - 00:25:26.914, Speaker E: I have an addition to this, so we have these two translation tools originally named EVM to WASM, but now we have a new version called YEVM, which compiles EVM bytecode to wasm bytecode. Now, it is not really optimal because of the very same reason, but would EVM 1.5 be implemented, then we would have a much more optimized compiler. So I think there's like an overlap between these things. I'm not fully personally not fully sold on the 6116 EIP, which is the SIMD. Not either, but six one five, I think it's a low hanging fruit. And if you combine it together with what Pavel said, that, okay, we disable the 1.0
00:25:26.914 - 00:25:51.194, Speaker E: deployments and it's only just this 1.5 which is the six one five. It's so many numbers. Anyway, it's just about the removing dynamic jumps. So if we enable that forcefully and disable deploying old contracts, the solid compiler already supports it. I think there was an implementation you made in Alice. It's likely it's a low hanging fruit, which I think could be.
00:25:51.194 - 00:26:05.602, Speaker E: I mean, I would be really optimistic to even have it after Constantinople, but just. Right. People have to be convinced. But definitely this single step does help the transition to ewasm as well if you want to keep backwards compatibility between the two.
00:26:05.736 - 00:26:15.006, Speaker B: Yeah, the code is in there. I think last time I looked you'd moved it to the side, but it's still there.
00:26:15.128 - 00:26:16.710, Speaker E: I think it's not there anymore.
00:26:18.010 - 00:26:55.730, Speaker B: Over. Didn't you have your legacy? Anyway, it's jit. It's somewhere down in there somewhere. It can be pulled back out. It was implemented, some testing needs to be done, but I can work alone for six months and have something and we'll need some more help on some other stuff, but it's just not that hard to get that going. And depending on scheduling I think it can be done more quickly than ewasm can be delivered.
00:26:58.630 - 00:27:08.966, Speaker A: So related but slightly higher level question, why do you guys think EVM has been so slow to evolve? Is it technical? Is it political? Is it something else?
00:27:09.148 - 00:27:11.960, Speaker B: Because no resources were put into it?
00:27:17.630 - 00:28:04.994, Speaker F: I think one of the issues that we have is we look at a couple of things. I see a split between researchers, implementers and people who are attempting to ship bug free production code on top of the world computer. All of which that are happening at the same time and again. Always a hard call to say when you should ditch old and go to new and everything else like that. But if the people who do research never have to do production implementation. The same issue between DevOps and developers. If you never actually have to maintain stuff in production, a research engine needs to be built differently rather than optimizing for people who actually have to shift code in production.
00:28:04.994 - 00:28:30.430, Speaker F: And it feels like there was a large movement, for whatever reason, to new new, and we should not be afraid to keep fixing old stuff. Maybe there was another perception that fixing a VM was hard, but if you just bring in people with VM expertise, it's not that hard. My opinion.
00:28:32.530 - 00:28:35.460, Speaker A: We have a late addition to the panel. Everett, do you want to introduce yourself?
00:28:38.310 - 00:28:54.038, Speaker G: I'm Everett Hildenbrandt. I've been working on formalization of vms and stuff like that. I had some meetings before this, but one thing I've worked on formalizing is the WaSM VM, but not as much recently because I've been busy with things.
00:28:54.124 - 00:28:58.274, Speaker E: Hang on to that microphone, but don't be shy. You also did KevM.
00:28:58.402 - 00:28:59.720, Speaker G: Oh yeah, that's true.
00:29:00.330 - 00:29:11.290, Speaker A: One topic. Can you speak about ieli a tiny little bit? You feel confident to do that? One thing that came up was this other virtual machine. Would you mind taking 60 seconds to tell us what that is and how it's similar or different to EVM in wasm?
00:29:11.450 - 00:29:12.160, Speaker D: Sure.
00:29:12.850 - 00:30:01.754, Speaker G: So Yelle is a VM that we designed for we being runtime verification designed for the Cardano network. And it has a lot of similarities to LLVM. We had some LLVM experts kind of on our team who helped us design it, and we mostly tried to avoid building in anything that would make verification difficult to the VM. So things like mstore eight or other issues with the EVM, we kind of tried to avoid. It's a registered based machine, so people have different opinions on that. I don't really care either way. And it supports out of the box unbounded integer arithmetic, so you can just use a proper Int type in the VM.
00:30:01.754 - 00:30:06.720, Speaker G: But then we have kind of a more complicated gas model to account for that.
00:30:09.810 - 00:30:50.810, Speaker E: Cool. Just want to reiterate the question, because you were late. The question was, why didn't EVM improve over time? And Boris explained a couple of reasons. I wanted to add a single reason, which also Greg mentioned that lack of resources, a lot of resources were shifted to ewaSm, and there weren't many resources left on EVM. And then at the same time, the research team also shifted their focus and they weren't really interested in getting anything done in EVM. So there was nobody to propose, except Greg to propose ideas, and then there was nobody execute those ideas. It's really hard to work alone on improving the EVM.
00:30:51.470 - 00:31:13.426, Speaker A: So there's been some conversations, even here at Devcon the past couple of days, that maybe while we wait for Shastra. Sorry, Vitalik serenity to become a thing and be alive, that there is value in reinvesting in Ethereum 1.0 or 1.5 or Ethereum next generation, or whatever you want to call it. Could this be part of that conversation? Improving EVM? And if so, what would that look like?
00:31:13.448 - 00:32:10.430, Speaker E: Maybe I can add one side to that. I think the say Ethereum 1.5 Berlin plan. Ethereum. No regrets. Ethereum ng. All these different names refer to the same thing and that was not really about the VM, but other parts of the network which may just make sense to do them separately because they're not that interconnected at least at this level of this stage of where the discussions are it wasn't the VM execution time which was the bound or the reason we need to make those changes so I think we can keep them separate and that's what Greg kicked off with his EVM one five proposal and if you keep them separate, you can also do them in parallel and maybe get them in more quickly but that's just my addition to it, maybe Casey, you want to put your.
00:32:10.600 - 00:33:15.334, Speaker G: I have a comment, actually about why it's difficult to update the EVM and I think it's actually just because you start with something that's EVM, which was kind of designed ad hoc ish it wasn't like they took some existing vm and then made it blockchain capable it was just designed from the start and then as the hard fork started piling on, the logic behind various different parts of the VM got more complicated so the recent Constantinople hard fork, the rules for storage allocation just literally tripled in length how many different cases we have to handle and it's like different depending on which fork you're on and it's a major pain. So I think part of the problem with evolving the EVM is kind of maintaining backwards compatibility so having the ability to support the new EVM execution model and the old EVM execution model is just going to complicate the clients to the point where working on them to update them for future hard forks is going to get more difficult over time. So I think that can be a major barrier as well basically the backwards.
00:33:15.382 - 00:34:00.460, Speaker B: Compatibility issue, can that be avoided at all? You moved ewasm, but we still got all this weird stuff. It gets moved up to your environment interface and even with the current, even with the old vm I would love to take a whole lot of those opcodes which really aren't. They really have nothing to do with the virtual machine and I could easily, as the evolution goes, say, okay, let's pull all of that out of the vm, deprecate it, and move it up to the environment interface because the functionality is there, we've got to deal with it.
00:34:02.110 - 00:34:47.414, Speaker E: One note on the backwards compatibility and EVM itself that promise actually was broken, I believe with spurious dragon or tangerine whistle, whatever the code name was, back like two years ago where gas costs were increased and before that, I think it was never explicitly said that gas cost cannot be increased. But a lot of contracts assume that. And once you increase the gas cost. So one example, when a contract makes a call to another contract, previously they made like a fixed calculation in the contract in many cases, and once you bumped up the cost, in some cases they just failed. I tried and they were done. So we broke that backwards compatibility promise at that point. But all the proposals since then just reduced the cost.
00:34:47.414 - 00:35:28.310, Speaker E: So like this s door change, you mentioned that reduced the cost, but I think because we broke that promise and a lot of the two languages, they take that into consideration, I think it would be possible to do like a cleanup of the gas rules. In some cases that may result in increased cost for a given contract or a decreased cost, but it shouldn't break contracts entirely. But it is a political question at that point if a contract is increased so much in cost that it kind of breaks the user experience and it's an important contract.
00:35:30.970 - 00:36:12.290, Speaker G: Even if we just ignore the complexity of the gas model, which is arguably where a lot of the complexity in this happens, there's still complexity. If we want to, say, deprecate old opcodes or something like that. And at that point, what do you tell the owners of contracts who use those opcodes if you want to deprecate it and say we want to remove this, that we can start to evolve it to something that's a little saner or a little more modular or is more compatible with other vms, who knows? But there's not something built into the system that says we're going to at some point be able to say, no, your contract is no longer going to be able to execute on them. That wasn't what people signed up for when they signed up for Ethereum initially.
00:36:14.230 - 00:36:37.740, Speaker B: There's a joke that goes, intel. We put the backwards in backwards compatibility and we're stuck with that. Any contract that works, that got put on the chain has to keep working forever. Well, it has to keep working forever. It has an address it can be called.
00:36:39.710 - 00:37:06.440, Speaker E: Okay, can I just mention a strange example to this? The call code upcode, which was quickly fixed by introducing a new upcode called Delegate Call just right, two months after launching Ethereum, because Callcode was supposed to do what delegate call is doing, but it wasn't yet we still kept it and nothing is using it because it's useless. Yet we still have it, how can we remove it?
00:37:10.010 - 00:37:27.050, Speaker B: The best we can do for any vm when you deprecate it, is you have to keep supporting it in all code. But if they try and put a new contract on the blockchain that uses a deprecated feature, they can't put it on the blockchain anymore.
00:37:28.750 - 00:38:25.360, Speaker D: Yeah, deprecating stuff is definitely hard. But about Everett's comment that adding new features or new opcodes or changing the way existing opcodes work increases the complexity of the code base because the code has to support the old fork rules and then the next fork rules and the next one, and you get all these conditionals. You can actually get rid of that by just only supporting the new fork rules and resetting essentially like resetting the Genesis block. At a more recent snapshot, I'm not sure why so many clients and users are obsessed with being able to process all the way from the Genesis block and then through all the cork rules and then currently. But.
00:38:28.130 - 00:38:42.770, Speaker G: What do you do about contracts that have some logic about how their funds are supposed to be paid out? What about a contract that has some logic about how their funds are supposed to be paid out? You reset your Genesis block, you essentially forget their code structure or something like that. And then what happens to those funds?
00:38:43.590 - 00:38:55.282, Speaker D: I'm saying you start at the snapshot of the current of a state after the fork, right? Then that client syncs starting from that snapshot, and it only has to support the new fork rules.
00:38:55.346 - 00:39:10.330, Speaker G: But if you call from that point, at that point you call into a contract that was created before that on a previous fork, right. Its logic is broken on the new fork, potentially. Well, so maybe you've locked up someone's funds.
00:39:13.070 - 00:39:22.640, Speaker D: Yeah, so I said, you really can't deprecate stuff or it's really hard to. You can only change things again.
00:39:24.850 - 00:39:50.860, Speaker B: The intel chip started out as a hand calculator and that code still runs. It doesn't run very well. Those opcodes have actually become pretty slow and there's a good reason not to use them anymore. But that hand calculator is still in there, and to some extent we sit here bitching about it and it's just tough shit. Suck it up.
00:39:51.310 - 00:40:01.098, Speaker A: I want to save some time for audience questions. Maybe ten minutes left for that. Let's go ahead and do that. Anyone have a question or comment complaint? Any of the above?
00:40:01.274 - 00:40:03.230, Speaker B: Boris. Always Boris.
00:40:05.410 - 00:40:25.414, Speaker F: So one of the things I want us to think about is I'm starting to think about the different components of what is Ethereum, just as we're maybe thinking about what is web three and how much we're integrating and eeps and other stuff like that with ipfs and so on. The EVM goes beyond Ethereum public main.
00:40:25.452 - 00:40:25.942, Speaker E: Net.
00:40:26.076 - 00:41:04.020, Speaker F: So today Microsoft released a new EVM, the EEVM, written in c without gas calculations, that is designed for private networks. So how much from the perspective of an EVM specification do we broaden to support and work with other chains? Like the way I see it, we might have a very large EVM community that might want to work together and fix some of the resources issue. So just some thoughts that I'd love to hear the panel's ideas on.
00:41:09.750 - 00:41:18.260, Speaker B: I'd actually like to ask you a question, because nobody wants to ask Boris question.
00:41:18.730 - 00:41:19.830, Speaker A: Sorry, Boris.
00:41:20.730 - 00:41:47.920, Speaker G: Yeah, can you clarify? 1 second, can you clarify? Are you asking specifically about are we going to support the other. I don't know. We can certainly build formal models of those other ones, and then we can look at them and see, okay, can we apply those changes that they make to our EVM as well?
00:41:49.250 - 00:42:03.890, Speaker F: Okay, so maybe this is not relevant, and in fact, various things called EVM are going to live in their own worlds. It just feels like it might be a way to actually broaden our community and get high quality code together. Just an idea.
00:42:03.960 - 00:42:08.994, Speaker A: So from my perspective, that's one of the main goals of ewaSm, is that we're stepping into a much broader community.
00:42:09.112 - 00:42:12.578, Speaker F: So the other evms should all die?
00:42:12.754 - 00:42:17.800, Speaker A: No, I didn't say that, but I'm saying if that's our goal, I think that ewasm largely serves that goal. That's all I'm saying.
00:42:18.570 - 00:43:02.760, Speaker E: In evms over the years, there have been a couple of other chains using it, and most of those chains have made additions to it in forms of new upcodes to access data. So one example I think is rootstock. They had like six upcodes. There were a couple of others I cannot recall right now, but all of these, maybe for the lack of the platform to communicate these ideas, they are forks, they're not compatible. And when they made these changes, they also had to change the languages supporting EVM, which at the time was religious solidity. So they forked solidity to support those things. And I don't really see any communication between any of these other forks or users of EVM at the moment.
00:43:02.760 - 00:43:29.680, Speaker E: I think we have to overcome that issue first, get a discussion flowing between the different EVM forks, between the main net in form of eips, and as well as the language designers, compiler authors in the Ethereum space. And once that is solved, you can then consider how to make bigger changes and get those changes down to them. But we have those channels closed for some reason.
00:43:32.130 - 00:44:02.970, Speaker C: Yeah. So for me, from my perspective it's mostly communication issue. I mean it's so easy to fork and then never go back for the apps to project whatever direction the communication should. So like everyone is having own EIP repo with eips with different names. Even coven network has what I find out last week. There's like coven network improvement proposals, something. So this information is not exchanged.
00:44:02.970 - 00:44:35.090, Speaker C: I don't know how to fix it. Maybe you have some ideas, but yeah, definitely to having some platform to communicate, that would be great. I personally hope we can get EVMC in Sputnik VM, which is by Ethereum classic. I haven't checked the details what changes they have, they support all of that, but seems quite close to our needs. So that would be interesting to try it on Ethereum network.
00:44:36.490 - 00:44:38.790, Speaker A: Any other questions? Yep, we have another one. Jared.
00:44:45.450 - 00:45:10.880, Speaker E: I wanted to clarify that Microsoft's EVM implementation is for SGX environment, so basically the gas calculation doesn't make sense there. Basically they want to enable it on Azure and you can just send code and get the verified computation off chain, which is pretty interesting. But I guess the gas calculation doesn't make sense there.
00:45:12.130 - 00:45:16.674, Speaker A: Thank you for the clarification. Greg, did you have a follow up question here?
00:45:16.872 - 00:46:12.580, Speaker B: You did the KVM work? I've had some conversations and work with Seed, whoever he is. There's a man whose jitter tag is seed. I don't know who he actually is, but we've had a lot of communication. He's working on a lamb formalization forked off of uhe's formalization, and we've talked a bit about where the current EVM gets in the way of that kind of thing, and how my proposals are intended to help. Seed was quite excited, contacted me. It's like, when did these go in? They would help so much. But I'm wondering as a formalist, what your opinion is of how much would it help and how bad is it right now?
00:46:14.070 - 00:47:22.118, Speaker G: Well, nothing's crashing and burning, so I think it's not too bad. But it's quite a pain to update KVM, especially anything regarding the gas calculations, because you have to do things in a very specific order and it's kind of annoying that you have to do that. I don't know. For reference, maybe I can say how long it took to formalize EVM versus how long it took to formalize the fragment of WASM, which is most of the execution, but just not the modules and EVM took, I want to say. I mean, depending on how you count between eight and 14 months and Wasm was closer to the six month mark, maybe. So I think that just that alone and the wasm definition is just shorter and it's cleaner and it just makes more sense and it just feels more coherent. It all kind of presents itself nicely together instead of feeling scatterbrained.
00:47:22.294 - 00:47:24.166, Speaker D: Proposal to band dynamic.
00:47:24.198 - 00:47:56.374, Speaker G: Jumps to band dynamic. Oh, that one specifically, how much does that proposal help? Oh my gosh, that would help so much. Oh my gosh. That is a single. Like when we made our own EVM one five, I called it EVM prime as a kind of just a toy. Like, how would I change the EVM type of thing? And that was the very first thing I did, was just, okay, all jumps are actually labeled and you only can jump to the jump labels or something like that. And then on top of that we put structured control flow, like if and while and stuff like that.
00:47:56.374 - 00:48:10.490, Speaker G: And it makes static analysis tools way more effective, like worlds and worlds more effective. And then it makes verification efforts a lot easier as well. Dynamic jumps are terrible.
00:48:11.150 - 00:48:20.714, Speaker A: Can we hire you for what we can do? One last question. Do we have one last more audience question?
00:48:20.832 - 00:48:22.330, Speaker E: Can I have a question to Greg?
00:48:22.410 - 00:48:24.414, Speaker A: Oh, sure. All right, never mind.
00:48:24.452 - 00:48:45.894, Speaker E: Sorry, audience, I'm going to be quick. Greg, you mentioned that at some point that EVM might be the general description of the contract itself, but it's not the way it is executed. It's just translated to something else. Maybe I got it wrong, but that's what you mentioned, like in the first five minutes, that maybe you would translate it to wasm at some point.
00:48:45.932 - 00:49:42.310, Speaker B: Instead, I'm saying we can do the work now to get a better EVM ready and going on the main chain, because sharding all of that's also somewhere way out in the future. We don't know where it is. And then When WASM is on the main chain, soliD, formalized, rEADy to GO, aNd your compiler to compile from EDM to ASM is ready to go, there's not any big problem to migrate code. There is no migration. That's just the way that it gets executed. Right. No one cares whether you compile it to ASM and then compile to ASM to machine code or interpret it or compile it right to machine code.
00:49:42.310 - 00:50:27.570, Speaker B: The user doesn't care about that as long as it gets executed correctly. But short term, we want to just get it working and a little bit longer term. Whoa, excuse me, just a little longer term. We now have a formally verified subset of C. We've got, I don't know is it a subset or all? But LlvM has been formally verified, so we can have a formally verified EVM 1.5 execution specifications.
00:50:28.090 - 00:50:32.466, Speaker G: We can have specifications, but I wouldn't say it's verified, it's just a specification.
00:50:32.578 - 00:50:39.370, Speaker B: Okay, so as usual, Grigor is promising a little bit more than exists.
00:50:39.870 - 00:51:15.262, Speaker E: But I want to put in another just question and we shouldn't answer it right now, just leave it hanging. Just culminating all these discussions we had. If we keep adding these changes to EVM yet, we have to keep backwards compatibility to a certain extent, or there are different ways to do it, and then we still plan to switch to ewasm. Does that leave us with more legacy we have to keep because all of this stuff is on the main net or is it a better position? But I don't think we should answer this right now. We should just think about this a bit more. Did we have time for one more question from the audience?
00:51:15.326 - 00:51:25.062, Speaker B: Okay, a two second answer is just as Wasm gets more stable. You cap off EVM one and say.
00:51:25.116 - 00:51:28.086, Speaker E: It'S still on the main chain, you have to support it.
00:51:28.268 - 00:51:39.590, Speaker B: It has to be supported forever. I'm saying it can be supported with the compiler and you stop evolving it so you don't keep creating backwards compality category.
00:51:39.970 - 00:51:41.614, Speaker E: We have a next panel at some point.
00:51:41.652 - 00:51:44.650, Speaker A: Yeah, all right, we're going to stop there. Thank you guys very much. Thanks for listening.
