00:00:18.890 - 00:00:58.426, Speaker A: Right. So I'm Joey Krug from Auger. We're prediction market on Ethereum, and I'm just going to talk about a few kind of weird things that we do that's maybe different than other contracts on Ethereum and kind of why we do them. And I'll keep it short so maybe we can get back on schedule. So when you're updating contracts, there's a few things you have to decide. One is like how do you decide whether to update a contract? You could say you can have one private key which basically says this private key is going to be the one that updates the contract. You can have m of n in the sub like multi signature where you say three out of five of these keys have to agree and if so, we'll update the contract.
00:00:58.426 - 00:02:03.298, Speaker A: You can do other things like in Auger for instance. The way we're going to decide updates is we'll have the reporters vote on it. But I decided it didn't make sense to talk about that too much because having something like reporters in your system may not be too relevant. So the other problem you have to solve when updating a contract is basically how do you actually do it without losing your data or paying a ton of money to transfer your data? So the simplest way to do things is you basically just set up a contract. It has basically your data in, it has functions, and all the functions do is basically forward the call to another contract which has your business logic, which actually modifies your functions. So an example would be like you have a contract that has some money in it or something, and you want to be able to update your send function. And so what you do is you write another contract, and the first contract always forwards the calls to the new one, and your first contract keeps the second contract's address.
00:02:03.298 - 00:02:34.814, Speaker A: So if you want to update the contract, all you do is change the address. The problem with that is you basically cannot really change the parameters that send uses. You cannot make an entirely different function. So it's kind of limited in how you can upgrade things. Another thing you can do is there's this thing called Callcode, which is an opcode which allows you to basically run other code from another contract as if it was in your contract. It's similar to delegate call. The only difference is call code.
00:02:34.814 - 00:03:23.194, Speaker A: You can't have state in the second contract, which isn't really super relevant to this talk. The problem with doing that though, is you can't really change what's called the ABI in any easy way. Every contract has this thing called the ABI. And basically all it is is the data that tells you what functions your contract has, what parameters your functions have in them. And so if you want to be able to update your contracts and change the ABI using delegate calls on a super good way to do it, there's one kind of hacky way you can do it where you say, well, if we pass the message data to the contract we're calling, then we can basically set it up so that you can call any sort of generic function on any contract you want, provided that the user inputs the proper data. The problem with that is, one, it's very confusing for people trying to audit your code or read your code. Try to understand it.
00:03:23.194 - 00:04:14.426, Speaker A: It's very confusing from someone trying to interact with your code, because it's just this generic function that's like pass the message data to whatever contract we want. So the way we actually do updates for contracts is we separate the data and we separate the business logic. So all the data is stored in separate contracts with getters and setters and all the business logic. So stuff that modifies it are all in separate contracts as well. Then what we do is we say, okay, in the data contracts we'll have a whitelist which allows these business logic contracts to modify it. And so what that allows you to do is it allows you to update your functions that are actually modifying state in a relatively easy way, and it allows you to add new functions, allows you to change the parameters, allows you to do basically almost anything you'd want to do when you're updating something without many limitations. And if you want to add new data, you can basically just create another data contract.
00:04:14.426 - 00:04:47.960, Speaker A: So that's kind of the way we update things as opposed to using the more traditional recommended way of delegate call. Another interesting thing is we use serpent as opposed to solidity. The reason we use serpent is because it's stupidly simple. If you look at solidity, it has quite a few complicated features in it. There's a lot you can do with it, actually. Serpent is really basic, and so it makes it kind of easier to find flaws when you're looking at serpent code as opposed to solidity code. The other reason is when we started, solidity didn't exist, which is a good reason.
00:04:47.960 - 00:05:54.702, Speaker A: But one thing I'm really interested in is when you look at how we're trying to approach formal verification and things like that for improving security of smart contracts, we're really kind of almost starting from scratch. We're building on top of solidity things like that they're using like y three, which is good because it's building off of existing work. But what I think would be really cool is if you were able to write smart contracts in Ada, basically. So I made a tweet about this kind of as a joke, but then I looked into it more and it actually seems very interesting. Once the EVM supports Webassembly, you'll be able to take Ada code, compile it to using the LLVM, and then compile that to webassembly, which means you can write smart contracts in Ada, which is very interesting because that's the language that the DoD, NASA, all these super mission critical systems use. And the interesting thing about it is they spent tens of hundreds of millions of dollars into writing suites of software that allow you to do formal verification in it very easily. So if you write a program in Ada, it allows you to do tons of formal verification stuff automatically for one, without you even having to do anything.
00:05:54.702 - 00:06:37.434, Speaker A: And then if you write assertions and things, it'll also automatically prove things for you very easily. So what I think would be really cool, people started writing contracts in Ada. So if you look at the Ethereum Webassembly GitHub page, they have plans to make it. So there's a library for C and a library for rust and instructions on how to kind of use Ethereum, write Ethereum programs in those languages. And it could be cool if they have one for Ada. So what we'd like to do is basically announce basically a $10,000 bounty where if someone does that for Ada, you get ten k in bitcoin or ether or whatever you want. And basically not super relevant right now because the webassembly stuff is not that far along.
00:06:37.434 - 00:07:14.902, Speaker A: But in a few months, once they start doing it for C and Rust shouldn't be too hard to do. You'd basically just look at what they're doing, what things they're adding, and write a library for Ada that allows you to write ethereum contracts in Ada. So that'd be very cool because you wouldn't actually prove quite a bit more about your contracts in Ada than you can in any other language. The only other thing I have is where people ask me all the time about what we're doing with Rep. When's the rep launch? So basically, bunch of people mess up their ethereum buy ins. So we're going to do another test run this week, and then after that launch, like in a week. And that's the idea.
00:07:14.902 - 00:07:15.300, Speaker A: That's it.
