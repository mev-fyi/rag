00:00:00.720 - 00:00:46.254, Speaker A: So welcome back. Today we're gonna take on a relatively ambitious project. We're gonna implement TCP. For those of you aren't aware, TCP is basically one of the fundamental protocols of the Internet. It's the way that basically enables two different hosts on the Internet to talk to one another in a reliable way so that you can send data in such a way that you're guaranteed to not lose anything that you send, and that the receiver receives things in the same order you sent them. The Internet does not generally guarantee this, and so TCP is a protocol that basically sequences data across the network and make sure to do things like retransmissions if packets are lost. There have been a couple of questions in chat just before we started about how much of TCP are we trying to implement.
00:00:46.254 - 00:01:26.550, Speaker A: The goal is to implement basically something that can talk to a real server. Now, how we defined real server we'll get to in a while. But the idea is that we want the ability to talk to a real host on the Internet, so talk to some TCP implementation that is not our own. This means that we're not going to implement any of the sort of advanced extensions to TCP or any of the sort of any of the advanced congestion control algorithms. For example, we're just going to implement sort of the basic, probably new reno. And so what we're going to be working for is RFC 793, if I remember correctly. This one, I guess.
00:01:26.550 - 00:02:14.200, Speaker A: Actually I want this one. So this one is the RFC for TCP, the transmission control protocol, as you saw from Twitter, I think I posted out here. There are a couple of other rfcs that are handy to follow. In particular, why is this being weird? No, in particular there's sort of this tutorial, I'm not going to read through it. This is just good background for people who want to understand how TCP works. I'll give a very brief overview, drawing some figures and such, but I'm sort of assuming that you roughly know what TCP is. I don't expect you to know the protocol by heart or what all the headers are, but you sort of know what it's doing.
00:02:14.200 - 00:02:43.888, Speaker A: So I will not go through this particular RFC. This document we're probably going to refer to a lot. So RFC 7414 is basically a list of other rfcs you probably need to implement. We're not going to implement anywhere near all of them. In particular, we're going to focus on the things that are listed as core functionality, which basically thinks that you must implement to be a TCP. Host on the Internet. And that is basically 793, which is the core TCP protocol.
00:02:43.888 - 00:03:37.550, Speaker A: Um, 1122 defines um, a couple of other things like additional extensions you need to support and uh, from memory, some like initial values you need to set for different bits. Um, we're going to ignore this because we're not going to support IPV six. This I think is basically possible to ignore, and this one is basic control, congestion control. So we need to set up like basically Reno, which is pretty much slow start would be my guess. And there's some stuff on retransmission timers and segment sizes. So these things down here will be relatively short extensions to the core thing which we're going to do in 793. So my guess is that for this particular stream, our hope is to get somewhere decently far with 793, and whether we actually get there or nothing we'll have to see.
00:03:37.550 - 00:04:26.050, Speaker A: But the hope is that we get 793 and then we can do all the extensions maybe in the next stream, and then hopefully at that point we can talk to other hosts. So hopefully that gives you some rough idea. There's also RFC 23 98, so 23 98 gives a bunch of tools for testing TCP implementations. My hope is that we'll get to try some of these after a while, but that's sufficiently far down the line that I'm just going to close it for now because it's not terribly important. Important. This RFC 25 25 is just a really handy way to debug TCP implementations because it gives a number of sort of known problems with past implementations and what the problem probably is if you experience one of these particular issues. So we might end up referring back to this.
00:04:26.050 - 00:05:01.424, Speaker A: So I'll keep it open, although the core thing is going to be 793. Before we dive into that, there are a couple of small things I want to talk about. So first there's the live coding voting site. So this is how we ended up doing implement TCP this time. There are a bunch of other proposals too for upcoming streams. So here if you go to the site, you just put in a unique username and then you just drag these ideas according to which one you would rather like to see me do. And it basically runs a, it runs a.
00:05:01.424 - 00:05:40.920, Speaker A: Ah, now I can't even remember what it's called. Rank choice voting to determine which one is the next upcoming stream, and then also to figure out things like runner ups so that we can keep running, running basically elections even if people only vote once. Why is this not following the chat? Okay, so that's the live coding stream voting site. The other thing I want to mention is the last sequence of streams we did was porting flame graph to rust. And so we ended up with this tool called Inferno. And Inferno has actually been doing really well. There have been a bunch of people contributing.
00:05:40.920 - 00:06:13.008, Speaker A: We now have full color support. And so if you look here, we already have nine different people contributing. So we have. Jason has been doing a lot of work for doing things like supporting additional features like name attributes and stuff. BC Myers has been doing some work on adding sort of cleaning up the interfaces, some performance hacking. Jordy has been doing a bunch of work in coloring. And so this has just been a really cool project and there are still lots of open issues.
00:06:13.008 - 00:06:55.656, Speaker A: So if you want to try to contribute to something that is sort of simpler than what we're going to be working on today, then Inferno is a really good place to start. And all the past streams are of course up on YouTube, as always. All right, so let's get started with TCP. In the tweets where I announced this, I announced we were going to use this crate. So peanut is basically a way to do low level networking. So normally I don't do any research before I do my streams. In this particular case, I knew that there were some weird things we were going to have to run into when we start dealing with low level networking.
00:06:55.656 - 00:07:58.890, Speaker A: In particular, once you want to do things like implement tcp yourself, you run into the issue of the kernel already implements TCP and you sort of need to steal packets from the kernel, but the kernel needs to know which packets you're going to steal from it so that you end up in this sort of weird position where the packets sort of go to the kernel and to you and it's just a little bit of a pain. And so we're actually not going to use Libpnet because it uses, as far as I can tell, it uses raw sockets and raw sockets are nice if you're implementing your own protocols, but not so great if you're implementing TCP because the kernel is still going to send, basically the kernel is still going to run its own TCP stack and that might interfere with the things that we're trying to do. So instead we're going to use this Linux feature. Actually, let's put this here. This Linux feature called ton tap. So tuntap are basically user space. So not in the kernel, but in the user space, a way to write what essentially looks like a network to the kernel.
00:07:58.890 - 00:08:46.904, Speaker A: And so what you're going to do is you construct, you tell the kernel to create a network interface for you. Actually, let me draw this. It's going to be easier. And if you have any questions at any point during this, the getting sort of the basics of this is pretty important. So if you feel like there's something you're stuck on, then like just give me a shout. Okay, so in normal applications what we usually do is we draw the kernel as a thing down here and then user space sort of on top of the kernel. Wow, this one is not great for writing.
00:08:46.904 - 00:09:25.400, Speaker A: Let's do pen. And then you can imagine down here is the big scary Internet and there are going to be a bunch of packets and they sort of arrive down here at a thing called Nic. A network interface provided the link to that kernel patch. Sorry, it's not a kernel patch actually, it's a, it's just a description of tuntap. So if you search for just tuntap text, you should find it. But I can post it to chat as well. I guess it is.
00:09:25.400 - 00:10:07.596, Speaker A: My chat is on a different machine over there, so I can't put anything there. That one. So I don't know if you got that, but let's go back to this. So there's sort of a network interface and that receives all the packets that come from the network. And the kernel sort of internally has a bunch of data structures that it uses to run things like TCP, and it's going to send responses here. If user space wants to talk over the network, they create socket by calling into the kernel. The kernel allocates some kernel memory for that socket that represents that TCP connection.
00:10:07.596 - 00:10:54.168, Speaker A: And then the user space thing is really just a pointer to the thing in the kernel. And so this is how normal networking works. That if you want to say read or write from a network connection, then you just give this identifier that the kernel gave you that's normally just a number like a file descriptor. And you say like write these bytes to that file descriptor that goes to the kernel. The kernel then knows how to talk TCP and send stuff back on the, on the interface card. So what's going to happen in our case is that we still have this sort of user space and kernel divide, like so. And what we're going to do is we're going to have the kernel create what is basically a virtual interface for us.
00:10:54.168 - 00:11:30.836, Speaker A: I'm going to draw that here. So this is a ton interface and it's going to treat that as if it's its own network card. So it's going to treat anything that comes out of this as something that sort of came from the network. Right. It's going to treat this as a nic, as a network interface. However any it basically is going to consider this sort of the wire of that network. So any time it tries to send on this network interface, that's really just going to appear out of here into the user space program.
00:11:30.836 - 00:12:12.196, Speaker A: So the user has like a process running here. And basically any send the kernel does turns into a receive in the user space program. And similarly, anytime the user space program writes something that's going to sort of go through that and appear to the kernel as though that was a packet that came from the network. This basically lets us emulate a network inside of user space. So that's what a ton device does. And effectively what it gives you is. So there's the command IP that lists all the interfaces on your machine IP, if we create a ton interface is going to show that there's an additional interface like ton zero that has some ip.
00:12:12.196 - 00:13:05.370, Speaker A: Who knows what it's going to be unlike a bunch of other information. And if we try to send something on this, what's going to happen is that the kernel is going to look up which, which process owns this tunnel or this ton and then it's going to take whatever the kernel wrote into this interface. Whatever raw bits of a packet it wrote into here, those are going to be redirected into user space. And whatever user space writes back is going to be treated as if it came back onto this network socket. And this allows us to implement TCP pretty nicely. Right? Because we on here, all we have to do is just implement our TCP stack. And if we receive a packet, then what really happened was the kernel sent a packet to this address and we're just going to interpret it as a TCP packet and we're going to send responses back to the kernel and the kernel is going to think it's talking to some host on the Internet.
00:13:05.370 - 00:13:57.350, Speaker A: Why is this not following chat? Okay, so does that roughly make sense? We're going to get into a lot more detail about how exactly we end up using ton. But does the rough idea make sense that the ton that we create is basically a user space network? Yeah, the link posted by Wilkins is basically the same document. Okay. And that means that instead of using the Pneut package, we're actually going to use this tun tap crate. So luckily there's a rust crate for this. Hello. So luckily there's a crate for this.
00:13:57.350 - 00:14:35.448, Speaker A: And it's pretty straightforward, right? What you do is you have a tuntap interface ignore tap for now and you can create a new one. You can give it a name or you give it a name, it can be empty and then the kernel just generates one for you. You can choose the mode for it, and we're going to ignore mode for now. And that gives you an interface. And once you have an interface, you can call receive to receive a message and you can call send to send a message. Right, which is sort of what you want. Why is this not following chat? I have to scroll down anytime someone sends a message, which is not ideal.
00:14:35.448 - 00:15:21.700, Speaker A: Let's try that instead. Yeah, so all this gives us is a receive and a send. And what these receives and sends are basically IP packets. So anytime we receive, any time the kernel sends an IP packet to us. So anytime the kernel basically sets network traffic our way, the receive is going to give us back those, the bytes contained in that packet, and similarly we can send bytes out and the kernel is going to receive those as an IP packet. What this means, unfortunately, is that we also need to implement the IP protocol because we need to be able to send packets to the Internet. Luckily the IP protocol is, is a little bit simpler.
00:15:21.700 - 00:16:03.340, Speaker A: It's basically just you name the remote machine. Don't you risk freezing the entire system if you mess something up? Ask him. Because I would like to follow along without my PC crashing every attempt at running the thing. It's unlikely that the entire system is going to freeze the kernel. You're not going to crash the kernel using a ton interface. However, what you might do if you screw things up is you might set up the routing tables on your host machine so that you can't talk to the Internet anymore. Usually all you have to do in that case is reboot or restart your network interface.
00:16:03.340 - 00:16:45.416, Speaker A: I'm hoping that this will not happen to me because then the stream will be cut off. But in theory at least we should be fine. But the biggest concern is that your network traffic can no longer be routed. Imagine that all of basically if your entire network connection started going over the ton interface, then nothing is going to go to the Internet. Every packet you send is just going to go to the, it's just going to go directly to the process you're writing, which doesn't know how to talk to the Internet. It might be better to work in a VM, although again, I don't think you can really break anything this way. And I don't particularly want to work on a VM, but I agree you totally could.
00:16:45.416 - 00:17:10.670, Speaker A: And it might be better. I just don't want to. So this gives us basically the interface we need. There's one thing that's missing and that is the RFC for the IP protocol, which is 791. And luckily the IP protocol is very, very straightforward. I don't need all the description. Basically when you send an IP protocol message, it looks like this.
00:17:10.670 - 00:17:59.668, Speaker A: So there's like a bunch of fields that we basically can ignore. Well, we're gonna have to set them, but they're, they mostly have constants and then there's a source address and a destination address. The source address is gonna be the IP address of sort of us as in who we're pretending to be on the user network that we're creating. And the destination address is going to be the remote host that we're talking to. I don't think we're going to need any options. And then following this header is just going to be the contents of the packet. Do you need to be root? So generally you need to be root to create these things.
00:17:59.668 - 00:18:45.712, Speaker A: But there is a capability, specifically capnet admin that you can see this is a, basically the thing you can tell the kernel to give a particular process or binary. You can say that when this program runs, it's going to have this capability, which means it's going to be able to do these things without having to be root. So we should not need to be root for this. You do have to be root to grant this capability. Okay, so let's get started, I think is the way to go. I think step one of this is going to be just being able, making sure that we're able to send and receive packets at all. And so as before, we're going to go into streams and we're going to cargo.
00:18:45.712 - 00:19:52.750, Speaker A: New lib, actually, is it going to be a lib or a bin? Let's make it a bin for now. Start simple. We're going to call it, what are we going to call it? Thanks. What are we going to call this user space TCP thing? It's going to be, it's going to be trust TCP rust. All right. And we're of course going to depend on the tunt up crate zero one two and source main is going to do an extern crate on top. And then I guess what we're going to do here is something like tun tap.
00:19:52.750 - 00:20:22.000, Speaker A: This is just to see that we can get anything working. Mode. What's the, we specifically want ton mode. Don't worry too much about the difference between ton and tap. I mean, I can explain it if you want to, but I don't think it's relevant. Fail to actually. Now main is allowed to return a result, right? I think that's true.
00:20:22.000 - 00:20:54.250, Speaker A: And Thunder is pretty funny actually. Although. Oh, you're sorry, you're right. I don't need extra. And crate. Thanks. I like thunder.
00:20:54.250 - 00:21:28.762, Speaker A: Wait, that's a great name, actually. I agree. Let's switch it to thunder. Well, so the reason trust is nice is because TcP, basically it doesn't actually establish trust, but it does mean that you can trust that what you send is what the other person receives. Actually, let's keep it thrust for now and then we can, we can figure that out later. I was planning on using stable, although who knows? I don't remember what my default is. My default is beta.
00:21:28.762 - 00:22:16.900, Speaker A: So we're on beta. Okay, so we're gonna do, we're gonna create a new interface and then we are going to do. Buff is going to be a 1500 and I'll explain why soon. Actually, I don't think, I think we need packet info. Yeah, let's do without packet info. No, this is your new fine for now. Zero u eight.
00:22:16.900 - 00:23:11.020, Speaker A: Oh, it's the other way around, right. U eight this and then we're going to do Nick dot receive into buff and we're gonna do red. This many actually, yeah. And then I guess we're gonna x this. How many bytes we read. I guess this is n bytes and this is going to be buff and bytes. Let's just like see whether that works at all.
00:23:11.020 - 00:23:41.190, Speaker A: Just so we have a place to start. In fact, it almost guaranteed will not. Ooh, tun tap not found. Oh, it's. Oh, they've done it properly. Nice. Oh, yeah, tsunami was great.
00:23:41.190 - 00:24:30.170, Speaker A: It was a good crate name too. Oh, I faced. And what else we missing? What's I guess like this. Oh, don't need both. And then because we're going to be able, we're going to be doing like networking things. We're also going to do sudo set captain. What was it? Capability called capnet admin on target dare release trust.
00:24:30.170 - 00:25:53.080, Speaker A: You don't need a use statement because all with uniform paths, any identifiers identified to the left of all the colons is considered. Considers anything that is in scope and all external crates. So why can't I do this? Set cap h r. What help man set, Captain. Hmm. Oh, is it like has to be lowercase or something. Cap net admin.
00:25:53.080 - 00:27:07.220, Speaker A: What? Apparently not equals Eip. What is the equals for man cap from text. Oh, each clause consists of a list of comma, separate capability names and actions consist of. Okay, what do the flags mean? Sequent flags indicate the list of capabilities requirements were such a reraised. For example, XP means lower every capability, effective and inheritable. Oh, we just want to set them for all of them. Sure.
00:27:07.220 - 00:27:30.410, Speaker A: Equals eip. Great. And now I think in theory we should be able to run this thing. Okay, it didn't error. So let's look at what IP addresses we have. Okay, so we now have a ton zero interface. It doesn't have an address or anything, so we don't actually know how to send anything to it yet.
00:27:30.410 - 00:28:25.630, Speaker A: So let's do IP adder set 6800 124 dev 100. Oh, add. All right, so this still hasn't received anything, at least as far as we can tell. But now and then also set link setup dev ton zero. Great. So here it got a packet. I have no idea what packet this is, but this is indeed a packet that it got.
00:28:25.630 - 00:29:06.320, Speaker A: One thing we're gonna. So as you notice, this just got a bunch of bits now, right? So clearly it is receiving some stuff. Like when we brought this link up, it received an IP packet of some kind. I don't know what kind of IP packet, maybe a ping packet or something, but it did receive an IP packet. And so it suggests that our sort of, our basic setup is working. And now you see Tanzir is gone, right. What we're probably going to want, because building, running this thing is a little annoying, is we're going to want to do something like have this in a script, and that's going to do cargo be release.
00:29:06.320 - 00:30:22.590, Speaker A: It's going to do that. Then it's going to do what we did over here and also what we did up here to set the address. This is basically so that we don't have to run this every time. Is it just waitpid? I think it's waitpidae. Oh, maybe it's just wait. Yeah, it's just wait. So what the script is doing is it's building, setting the capability, running the binary in the background, keeping the process id of that around, setting up the network, and then waiting on that process to finish, which in this case is going to read the 52 bytes.
00:30:22.590 - 00:30:58.380, Speaker A: As you've observed, though, like, this is a little weird in the sense that we don't know what these bits are. So we're going to want some kind of tool that can help us interpret what these are. And we will probably want our program to not just exit to right, something like loop. So now if we do run sh then. Now it's going to continue. So now the ip, this is still up. And now let's try to do something like pingdong on interface ton zero.
00:30:58.380 - 00:31:27.924, Speaker A: We're going to ping some address on that subnet. So this now received a bunch of more bytes. In fact, if we, you'll notice that it keeps receiving bytes and these are in this case ping packets. Right. And so now we're going to have to interpret these in our program so that we can like parse them as TCP packets, for example. And so what we're going to do is use, there are a bunch of tools you can use here. I'm going to use one called tshark.
00:31:27.924 - 00:32:01.720, Speaker A: So this is a terminal version of Wireshark. And notice that it gets to sort of watch this interface and see what's going on. And specifically see this 2052 bytes thing was a IPv six router solicitation. That sounds like something we should ignore. And then all of the other ones are requests. And of course there are no responses because our program isn't doing anything. It's not responding to anything.
00:32:01.720 - 00:32:36.960, Speaker A: Okay, so what we're going to want is basically our program needs to sort of parse out the packets and know what to look for. So we're going to kill that program for a second. And so this means we're going to have to figure out how to parse these bits. If we go back to this, you'll notice that what receive says is you get the MTU, which is basically just the packet size in your network. We're going to assume it's 1500 and you get plus four for a header. That packet info is prepended. So this is what the difference between new and without packet info is.
00:32:36.960 - 00:33:27.530, Speaker A: Specifically in this case, there's a description somewhere here. The frame format that you get is you get two bytes of flags, two bytes of protocol, and then you get the raw frame. So if we look at the bytes that we received, there's going to be like flags. This, see, we can probably do. Flags is actually, ooh, probably one byte order here. But isn't there a. Didn't we recently get like Reed big Endian or something in rust? Might not have landed.
00:33:27.530 - 00:34:07.270, Speaker A: It might not only be nightly. This is gonna be very handy regardless. Be. Yeah, I from B. So we're going to have a U 16 from ne. U 16 from ne bytes. Sorry, give me a second.
00:34:07.270 - 00:34:30.870, Speaker A: I just need to make sure the chat doesn't turn off. There you go. Yeah. So this lets us basically parse out a U 16 from bytes in native endedness. That's not what I want. I want le because network. What is network? I can never remember.
00:34:30.870 - 00:35:12.860, Speaker A: Bigendian is network. Okay, great. So what we want is from be bytes. So flags is going to be a, is going to be U 16 from be bytes. This is on beta, probably isn't, is it? Oh yes, from b bytes. And this is going to be above zero, buff one. And then what was the next thing here? Proto.
00:35:12.860 - 00:36:21.372, Speaker A: This is going to be two and three, and this is going to be four and onwards. Oh, all right, we need to do some cleanup here. What's the bash term? The inline warnings is something that recently landed in rust in the Neovim language client. It's actually a little bit annoying because the default styling is pretty terrible. Capture term, capture kill signal trap. That's what I want specifically I want trapd. I basically want the, I wanted to terminate the program.
00:36:21.372 - 00:37:17.950, Speaker A: Normally when you do a control, c can never remember what the syntax is for this. It's gonna be kill Pita and we're gonna kill this. So it tears down this and then we're gonna run it again. Ooh, invalid signal specification. That's interesting. Oh, that's right. Oh man, didn't tear it down.
00:37:17.950 - 00:38:06.032, Speaker A: Hmm. Well, that's obviously not working. Isn't there a way to like do nicer traps? I can never remember how this actually works. Is Sigterm. I thought it was just kill Pid. I thought that was all you needed. Oh, maybe I need this needs to be bashed, doesn't it? Yeah.
00:38:06.032 - 00:38:56.460, Speaker A: Okay, great. Okay, so now runsh is going to, when we kill it, it's also going to kill the underlying program. And crucially in theory, now we're going to get, we're going to parse out flags in proto and we're going to print them here. Flags proto. Okay, so proto, 86 DD. So I guess we're gonna have to figure out what these different protocols are. Where is the proto? That's unhelpful.
00:38:56.460 - 00:39:50.872, Speaker A: I think it's from the IP frame. IP protocol numbers. Hmm. What did we get? Protos 86 DD ether type. So eight six DD is an ipv six packet, right. And my guess is if we start doing pings then now we're getting things that have protocol zero. This is 0800, and 0800 is IPV four.
00:39:50.872 - 00:40:31.640, Speaker A: And so the first thing we're going to do is ignore any packet that is not an ipv four packet. Right. So that's going to just tidy up our stream a little. So if proto not equal to this. Continue. So at this point now, notice there's nothing printed when we first started because those packets went away. And indeed if we now start pinging, those packets do in fact show up.
00:40:31.640 - 00:41:25.636, Speaker A: Okay, so now we've parsed out the beginnings and what now follows is an IPV four header. And so what we're going to do is we basically have to encode this structure, the IPv four header, in our rust code. Somehow. I wonder if someone has already done this just to save us the work. IPv four network structs seems great. IPv four header great. That seems fine.
00:41:25.636 - 00:42:10.570, Speaker A: Let's use that. The reason I'm using a package for parsing IP is because it's not really what we're focusing on. So there's no reason for us to really redo that work. Ether parse is zero eight, and in main here we're going to do. This is going to be ether parse IPv four header, slice from slice, buff four to n bytes. And if this errors in some way, then we don't really care, right. That just means we're going to skip the packet.
00:42:10.570 - 00:43:15.878, Speaker A: And so we're going to do a match on this and if it's a packet then we do whatever we want with the packet. And if it's an error then we're just going to ignore that packet. Ignoring packet, weird packet. And then here what we're going to do is print out the packet instead of the buffer. And now let's see what that gives us. All right, let's see what now happens if we do some pinging. Okay, so now we're getting, oh, I guess the slice isn't really helpful, but at least it parsed it correctly.
00:43:15.878 - 00:44:11.540, Speaker A: Right. So that's pretty promising. So let's now have it. Instead of just do that, let's try to actually print out some stuff. Particular what we probably care about from the IP packet are things like the total length of the payload. So instead of all of the stuff we've done so far, we're going to do got IPV four packet bytes of IPV four packet payload and that's going to be what p payload len, what else do we want? I think we're probably going to ignore all these other fields, but protocol we're going to care about. We're probably also going to care about source and destination.
00:44:11.540 - 00:45:09.136, Speaker A: So we're going to do source is going to be p dot source adder and destination is going to p destination adder. And what else do we have? Protocol. And notice that this this protocol is different from the other protocol. So the protocol we get up here, these are for the Ethernet frame that we got. And so this is sort of set by the, the link level protocol and that we're not really going to care about down here. Oops, what do you do? This on the other end is the IP level protocol which should be set to TCP. So let, in fact, let's print this out in a similar format to this.
00:45:09.136 - 00:46:05.540, Speaker A: Right, just so we, so this is going to be the source, the destination, the protocol. So I guess this is going to be bytes of protocol. This is going to be source destination proto and that. So let's see what this gives us. Is there a way to debounce that Nivim plugin so it isn't checking out for every new character? I don't know. I really want that and I haven't looked into it enough. It's a fairly new feature, but it's really annoying.
00:46:05.540 - 00:46:41.150, Speaker A: You probably need time to live. Eh, I'm just gonna assume that it's fine. Like there are things that we should do that we're not going to do. Yeah, it's really, really distracting. While typing the Mac address we don't actually need because we're at the data link layer, the IP layer. So we don't need anything like Ethernet frames. All we need to know is where to respond to the packets.
00:46:41.150 - 00:47:10.548, Speaker A: This is failing for some reason though. Why is it failing? I don't think it should be failing. Great, so now if we ping, what's it going to do? Great, so we got one byte of protocol 64. Okay, so time to look up the protocol. So 64. Oh, that doesn't look right. Protocol.
00:47:10.548 - 00:47:50.718, Speaker A: Oh, are we printing this in Hex? We're not printing this in Hex. How about we print it in hex instead? Also, let's get rid of these warnings. Don't need this and don't need this. Protocol zero x 40. So IP protocols. Oh, am I printing these in reverse order? Oh, you're right. Wow.
00:47:50.718 - 00:48:04.050, Speaker A: Yes. That is the payload length. This is the protocol. Okay, better. So now if you ping protocol one and protocol one is indeed the ping protocol. Okay, great. Thanks for catching that.
00:48:04.050 - 00:48:45.760, Speaker A: Yeah, so now at least we know that we're getting our IP packets and we know that whatever is left is sort of TCP. So the question now is what happens if I try to connect using a TCP client to whatever port is not important. So I'm going to try to do that. Okay, so it got 40 bytes of protocol six. Protocol six is TCP okay, so we got a TCP packet of some kind and we got 40 bytes of it. So this is where we really need to start getting into what are we going to do at this level. One thing we also have to decide is whether we are going to implement the, the packet parsing ourselves or whether we're not.
00:48:45.760 - 00:50:52.600, Speaker A: So this is actually sort of up to you. There's a lot of stuff in TCP and most of it is not about parsing. Right? Like parsing the TCP header is not particularly, is not the core part of the TCP protocol, but it is a bunch of like bit fiddling ether. I think the ether parse thing also supports TCP headers, so we can use this to do the parsing for us. That way we don't have to spend a bunch of time doing the bit fiddling, but I'm also happy to do that. So would you prefer to see me start working on the TCP protocol side, or do you want to also do the TCP header parsing? What would you prefer to see? To give you an idea, if I stop this for a second, if proto not equal to zero x zero six, just while you're thinking, I'll write up the one that uses ether parts. Is there a hedgerow? I wondered.
00:50:52.600 - 00:52:13.400, Speaker A: So this parsing is just the same as the IP parsing I did above, I guess port this, and I guess that's going to be p. Is there a way for me to get the length from this, I wondered. Huh, that's interesting. I guess it's going to be p slice len and p destination, destination port. Let's see. Protocol. I think I prefer to not see parsing.
00:52:13.400 - 00:52:26.672, Speaker A: Just a protocol parse. Protocol. Protocol skip parsing. Parsing might be interesting. Protocol skip parsing. Okay, so it sounds like protocol then. Great.
00:52:26.672 - 00:52:50.242, Speaker A: So we'll just do the protocol. So I've now done the parsing. This is why the parsing is nice to skip. Basically because ether parse does the parsing for you. If you're curious about like low level parsing, I would look at the source of ether parse. It's mostly just like reading out. So you have a, you have a byte string, right? And then you do things like this sort of U 16 from b bytes, you ate from b bytes.
00:52:50.242 - 00:53:28.520, Speaker A: You just like read out the different fields according to what the specification says that the header formatting is. You get out the fields and then you sort of parse them in the appropriate way. And my guess is if you read the etherpart source code, that is all it does when you use this from slice business. Why is this stopped following? It's very annoying. See if this gets better. All right, so if I now run this, what happens? I need to type my password. Apparently.
00:53:28.520 - 00:53:52.336, Speaker A: It's fine. All right, so now this is running. Oh, eventually we're going to need all the fields of the TCP header. I just didn't particularly care about printing it right now. So let's now try to, first, let's try to ping. You'll notice that nothing gets printed because we notice that it's not a TCP packet. And then if we try to send a TCP connection, you'll say we get 40 bytes of TCP to port 80.
00:53:52.336 - 00:54:40.290, Speaker A: Right. If I stop this and say 443 instead, it's going to say 40 bytes of TCP to port 443. Okay, so at this point we are receiving TCP packets. And so now the question is, what do we do with them? Right, so at this point, now we sort of know that there's some, there's something going on here. And so now we need to figure out what we're going to do sort of in order to implement the protocol. The thing to keep in mind is that in TCP, a connection is Orlando in? Well, everywhere. A connection is basically a quad of source IP, source port, destination IP, and destination port.
00:54:40.290 - 00:55:32.630, Speaker A: Oh man, these warnings are so annoying. What's the thing for turning them on again? Sorry, I just need to. Didn't I fix this at some point? Thought I did. Apparently not. All right, well, Neovim language client, I could write it as comments. I just don't want this feature to be on, like, ever. It's far too annoying the way it currently is.
00:55:32.630 - 00:56:09.076, Speaker A: Virtual text this. How do I turn this off? This. Excellent. It's gone. Beautiful. I can still put in a comment, though. So we basically want this quad like this.
00:56:09.076 - 00:57:07.160, Speaker A: This identifies a single connection. And anytime you run sort of the TCP protocol, you basically want to run it on this quad. Like all the state is associated with that quad. And so what we're, what we sort of need is almost like a map from this quad to the state for that connection. Right? So we're going to end up constructing something like TCP state, and that's going to contain a bunch of fields, and then we're going to have something like connections, which is going to be a hash map. Well, actually, let's make it. This is going to be a hash map from a quad to a TCP state, and a quad is going to be a source IP.
00:57:07.160 - 00:57:42.630, Speaker A: I guess actually we could. Oh, I will. I'm not going to, I don't think you should generally use this for anything. No, this is building more because it's interesting, not because we're going to use it for anything. So the source is going to be a, I guess this, at this point we need to figure out what this return type is for the, it's a TC. It's what, where's the source adder? IPv four adder, which comes from standard. Net.
00:57:42.630 - 00:58:12.620, Speaker A: So we're going to use standard. Net IPv four adder, IPv four adder and a U 16. Right. So this is source IP and destiny and portland and destination IP. Import this. Of course we're going to derive like all the things for. So the hash e, impartial e and probably also debug and probably also clone and copy.
00:58:12.620 - 00:59:10.350, Speaker A: Right. So we're going to keep this sort of connection state and that's going to be from one of these to whatever we end up putting in the, in the TCP state. And just to make our lives easier, we're probably going to do a mod TCP, TCP rs and that's going to have this. So this is going to be a TCP state. And so the question is what do we do when we get a TCP packet? Well, in all likelihood what we're going to do is we're going to do connections entry quad, right. Which is going to be the source is going to be the source address and the p source port. And the destination is going to be the destination address and the destination port.
00:59:10.350 - 01:00:11.800, Speaker A: And the question is what do we do if there is no connection? Well, we probably want or default. Like there's gonna be some, it's gonna be some default state that every connection starts up in. And then what this. So the dot entry API is really nice because what it will do is basically if there's already something with that quad, it's gonna give us a reference to that thing, to the corresponding state. And if not it's gonna create one for us and then give us a reference to that. So what we end up with after this or default is basically a always what we end up with as a mutable reference to a state. And so at this point we're going to say something like on packet and we're going to give it the P and we're going to give it.
01:00:11.800 - 01:00:56.030, Speaker A: Actually that's a good question. Why is there no way for me on this to get out? Right. Data offset is the one. So P is the header and then in addition, we want. Where does the data start? Well, the data starts at four plus how far the number of 32 bit words in the TCP header. Right? So actually that's not even true. So the IP header size is p slice len.
01:00:56.030 - 01:01:50.320, Speaker A: Ooh, actually this slice, that's even better. So the data starts at the IP header size plus the TCP header size. Right. TCP header size is that last value. Actually. How about we don't overwrite these and say this is IP, this is the IP header and this we can just inline just to make the code easier to read that way. Here we can use IPh dot slice, dot len.
01:01:50.320 - 01:02:31.696, Speaker A: IPH slice dot len. This is going to give us a TCP header instead of just p. TCP header, TCP header. It should just portend. All right, so on packet we're going to give it the IP header, the TCP header, and also the, the slice of the payload, which in our case is then buff from. Let's give this a helpful name. Data I from data I to the rest of buff.
01:02:31.696 - 01:03:00.776, Speaker A: Right. So from the point where the headers stop and the rest of the buffer is the contents of the packet and that's sort of the end of what main has to do. Right. There's going to be, there's going to have to be some way to like send responses and who knows how that's going to work. There's going to be timers and stuff involved. But at sort of the heart of it, this is the way packets get into the TCP state. Okay, so now we need to actually implement that, right.
01:03:00.776 - 01:04:08.410, Speaker A: So we're going to have to implement default for state. We don't quite know what that looks like yet. We're also going to have to impulse state and have something like a on packet that takes a, an IP header which is going to be. Was it ether parse IPv four header, a TCP header which is going to be an ether parse TCP. These are actually, this is IPv four header, slice. This is TCP header, slice and data, which is going to be just a bunch of bytes and we don't really know what we're going to do in there, but for the time being we're sort of just gonna print this out. I ph dot source adder, IPH destination Adder.
01:04:08.410 - 01:06:15.880, Speaker A: Now we're gonna, I guess just show the ports numbers directly in here and it's going to be source adder, then TCP header, source port and then the same but destination. And then finally we're going to give data len this is mostly just to tidy up our interface, right? I probably did something stupid. An inner attribute. Oh, I have messed up, don't I? This should not be that and this should be pub. Well, crate, but I, whatever, they're the same. Actually, I also want my run script to, if compilation fails, I don't want it to run anything. What? Why does compiling this makes no sense? Oh, that's not what I wanted.
01:06:15.880 - 01:06:49.058, Speaker A: This is what I wanted. Great. All right, let's see what else. No method on packet. That's because this has to take mute self. Right. And the, the lifetime tick a here is the lifetime of the busy of the packet itself, which is basically the lifetime of this buffer.
01:06:49.058 - 01:07:18.980, Speaker A: Right. All right, so now this runs, and again, if we ping, nothing shows up because we're filtering those. If we try to connect to a given port, it's going to say ooh, we got a bunch. Ooh, that looks wrong. No, actually that might be right. So this is saying that the body of that request is 1740 bytes. That doesn't seem right.
01:07:18.980 - 01:07:52.116, Speaker A: Oh, the data is until n bytes. Of course this also is n bytes because remember, when we fill up buff, we only actually like buff is this long, but we only read this many bytes, so we should only be looking at that many bytes. So let's try that again. Now if we do this, zero bytes, right. So the first packet we get is basically a header only packet. It contains no payload. Great.
01:07:52.116 - 01:08:38.260, Speaker A: But this at least means that the math sort of worked out. So what this first packet is, in fact, if we, let's start this again, if we start our t shark and then do this, you'll notice that that message kill them again is. And let's also kill this. And also kill this. This packet that got sent is a syn packet and it has a bunch of like header fields. And so the question is what do we do in response to that? Well, this is basically the first part of the TCP handshake and there's a pretty decent description of that in don't want this, don't want this, don't want this. These go away, this goes away.
01:08:38.260 - 01:09:23.603, Speaker A: So this is when it starts to be time for the RFC. There's a operation. Is that what they do it diagram somewhere in this document, but I can never remember where it is. I think it's down here, maybe arguably I could just scroll through. Yeah, so this is the stuff that we no longer have to parse because etherparse does it for you. But where's the thing that shows the state? Oh yeah, there's a. There's a lot of stuff we're gonna have to get to here.
01:09:23.603 - 01:09:53.886, Speaker A: Okay, so this is the diagram I'm thinking about. So this is the TCP connection state diagram, as we're basically gonna have to implement all of these states initially when you start out a new. Well, so there are two states. A socket can sort of, or a TCP connection can start out it. It can even start in the here. I think they specify it further up too. Yeah.
01:09:53.886 - 01:10:29.450, Speaker A: So there are a bunch of different states that a connection can be in. There are these states and TCP here is sort of the TCP state. And so that is, there is no connection currently. So that's what this closed here is. And so the idea here is that if you're closed, so if you're not expecting to get any connections, like there's no state for a given connection, then like, even if someone tries to connect to you, you're not going to reply. Right. If you're not listening on a given port, you're not going to reply.
01:10:29.450 - 01:11:07.248, Speaker A: Whereas if you're in a listen state and someone tries to connect you, then you are going to reply. So what we're doing here, actually, if you look at the, the code up here, this sort of on packet here, we're saying that if someone senses a packet, if we haven't talked to them before, we're just always going to answer them. Right? Or we're always going to deal with that packet. Now, that might not be the thing that we want to do. In particular, this means that basically every port is listening. This might not be reasonable going down the line, but for now, let's just like stick with this. Like if someone tries to connect to us, we're just going to respond, yep, we're here.
01:11:07.248 - 01:11:42.936, Speaker A: And so we're going to ignore this closed state and basically assume that every, every port is going to be listening. So if you notice that, listen, there are a couple of different things we can do. We can either receive a sin if we. So this is, you should read this as if this happens, then we do this. So if we receive a sin. So as soon as this is the first part of the handshake, then what we send is an ack, which is an acknowledgement of the sin and a sin because we want to establish a connection the other way. So the handshake establishes a two way connection in TCP.
01:11:42.936 - 01:12:19.770, Speaker A: So this is the other person reaching out saying, hey, I want to talk to you. Do you want to talk to me? And this is saying, yes, I want to talk to you? Do you want to talk to me? At this point, we sort of note that we're in the state of, we have received the sin from the other side. And at this .1 of two things can happen. Either the connection can be closed, in which case we just like terminate the connection, or we receive a no here, or we receive an ack of the sin that we sent, in which case we don't send anything. But now the connection has been established. So this is sort of the initial TCP handshake.
01:12:19.770 - 01:12:49.120, Speaker A: And so getting through the flow from here to here to here is basically how you do a server. Right. So this is how you receive connections. On the other hand, if we wanted our library to establish a connection, it would start out enclosed and then it would do an open, which creates the state for the connection, and then it sends us in. Right. So this is sort of the, the opposite end of this. Receiving a sin confession is fun.
01:12:49.120 - 01:13:20.352, Speaker A: Yeah. So, so if you're a client, you're going to go through this path of sending us in to the server and then being in the state send. At that point, hopefully you're going to. So if you receive a sin from the server, it means the server was trying to connect to you at the same time, in which case you can just act and then everything proceeds as normal. But in the common case, you send a syn and you receive a syn ack. This is the syn ack that the server sent here. At that point, you're going to send an act to the server saying, yes, I do indeed want to talk to you, at which point the connection is established.
01:13:20.352 - 01:14:02.786, Speaker A: You might wonder why you need this, like two way acknowledgement, and there are many reasons for that. The primary one is to make sure that the hosts are actually talking to one another, that there's not sort of some other host in between that's trying to do weird things. We're not going to get too much into the weeds of exactly why the protocol works the way we are. We're sort of going to naively implement this as if it were the, what, 1981 sound good? We're going to assume that the Internet is a safe place. And so as you can see, there are sort of two different paths here for whether you're a server or a client. But as far as TCP is concerned, it doesn't really matter. All that matters is how you end up using that state.
01:14:02.786 - 01:14:55.532, Speaker A: So I think what we're going to do is we're going to do the sort of TCP server part first, and then we can implement the client part later. The client part is what we're going to end up using for talking to other servers online. What happens if the final act from the client is dropped somewhere? Ah, so there are all sorts of ways for this protocol to be weird. Basically there are a lot of timeouts in this protocol of things like you try to resend if you don't hear back. We'll get into all of that sort of dealing with retransmissions as we get later. But in general, TCP assumes that either you will receive an ack eventually or the connection is eventually going to time out and close or just stays open forever. Okay, so in this case, all we're doing is receiving a packet.
01:14:55.532 - 01:15:35.610, Speaker A: And this diagram gives us a pretty good idea of what we probably want to do. Specifically what we probably want to do is have this be an enum, right. We sort of want to encode the state diagram and the default state is going to be closed. Now this does mean that we're still going to sort of create an entry here for things that are closed. And we might want to sort of prune those. Like there's no reason to keep this around if it's closed, but it's, it's a good way to start to approximate the diagram. When we're closed, we're also going to be able to go into listen mode and in fact what we're going to do for the time being.
01:15:35.610 - 01:16:31.000, Speaker A: So this is going to be state closed. But starting out, we're going to say that we're always going to listen on all ports. The other things we're going to need are syn received, I guess name these the same as in there. And we're also going to need established and let's just like stick with those for now. There's a bunch of state we're going to have to keep for these two. But let's sort of start out in the very simple case of if we receive a packet, if it sort of depends what state we're in. So if we are in state closed, then all we're going to do is return.
01:16:31.000 - 01:17:15.580, Speaker A: There's nothing more for us to do. If we're in state listen, then the only packets we expect to get in state listen is a packet that has a syn set, right? That is the only thing we're expecting to get. And so if TCPH dot sin. So if the sin bit is set, sorry. Or the other way around, if sin is not set, then I guess here we could do some logging and stuff, but here got unexpected sin only expected syn packet. So in this case two we just return. Right.
01:17:15.580 - 01:18:04.734, Speaker A: Otherwise though if we go down here we got a sin and now we need to start establishing a connection. And so what that means is we're going to have to parse out the stuff from that syn packet and then we're going to have to send this syn acknowled. Okay, so we need to cook up a message. That's going to be the response we send. And here too, like we're basically cooking up a TCP header. And so for that we can, we might as well just sort of reuse this, the ether parts because they also have sort of the opposite of a TCP header. Now here it's a little awkward.
01:18:04.734 - 01:18:32.120, Speaker A: This is gonna need some way to send a message. So I think on packet there's gonna be, have to be some way for it to know how to send packets again. But let's just construct the packet in the first place. Okay, so we're gonna have to create one of these. So we're gonna send a syn ack and in order to do that we're gonna have to set all of these. Question is how can we create one new. Great.
01:18:32.120 - 01:19:05.210, Speaker A: So we're going to do new and it's going to go in the opposite direction. Right. So we received a syn ack from someone else and now we need to respond to them. So when it says source port that's going to be the destination port of the packet we received. Right. That's where we're sending from. The destination port is going to be the source port of the packet we received.
01:19:05.210 - 01:19:36.470, Speaker A: The sequence number we don't know yet. And the window size we don't know yet. We'll have to figure out what those are. Then we're going to have to specifically, again we're going to read the RFC more closely. But specifically when I have to set sin and set act. Right because we're sin is going to be true and ack is going to be true. Right.
01:19:36.470 - 01:20:32.850, Speaker A: So we're acting their sin and we're also sending our own sin and then we're going to have to wrap that in IP packet because we're sending it back to them. Right. And so in order to do that we're going to end up creating an IPV four header. So it's going to be ether parse IPV four header, new payload. Len is going to be syn Ack slice Lenore, time to live 64 protocol. It's going to be TCP. What else do we need? Source and destination.
01:20:32.850 - 01:21:38.444, Speaker A: Okay, so the source is going to be the IPH destination, right? So we're responding, so we have to invert them. So if we're giving source, then that has to be destination address and similarly the destination is going to be the source address, sourceadder. And then ultimately we're going to have to send these packets out. Ooh, that's a lot of things. Shouldn't it be one for syn ack? Yeah, so, okay, so there are a couple of questions in chat. The first one is, shouldn't it be one? Oh yeah. These parameters are going to be set to something.
01:21:38.444 - 01:22:09.780, Speaker A: They're not just going to be zero. I just haven't done it yet. And it is totally true that as you've already observed, we're keeping state for every connection. And so in theory you can make the server do a lot of work with doing very little work yourself. And this is often known as a syn flood attack. And it's something that modern kernels are actually pretty defended against because what they'll do is they won't actually set up any state locally. They won't allocate any state locally until the connection is actually established.
01:22:09.780 - 01:23:08.194, Speaker A: And so there are defenses against this. We're just not going to care about them right now because they complicate the implementation. So you're totally right that this is a problem in real implementations. Okay, so we've constructed this packet. There are still some things we don't know. What is this going to be? What is this going to be? And also, how are we going to write out this packet? Right? Like there has to be some way for us to sort of send a reply here. Where this is going to get particularly tricky is when it comes to being able to send, being able to send packets, like if there's a timeout, for example, that we're waiting for, and I don't have a good idea for how to do that.
01:23:08.194 - 01:24:14.126, Speaker A: I think what we're going to do for the time being is just to give this guy a writer specifically. It's going to end up with something like an ifaceous. Now, of course, this is its own kind of stupid because ultimately we're going to want to, for example, have, we're going to want to be able to send packets even if this is not active. But let's just, for now, we're just going to give it a mutable reference to the ifase, which we're going to call Nick. And what this means that is that we can send packets ourselves, right? Just by writing out this nick buff is going to be a 1500 u eight, I guess zero u eight buff. Now this is also not what is referred to as zero copy. Often you want the kernel to not, you don't want to not have to write things into memory more than once.
01:24:14.126 - 01:25:00.870, Speaker A: We're going to ignore that as a concern. So this will not be highly performant, but it should be fine. So at this point what we want to do is sort of write in the IP header, then the TCP header, and then any payload that we have. I guess here we're going to do something like let me written zero. So we're going to do ip write. Ooh, what's the difference between right and right raw, I wonder? Interesting. I think write is what we want.
01:25:00.870 - 01:26:30.000, Speaker A: What is it that implements write again for like things that are slices, for mutable references to u eight. The writing updates is nice to point to the yet unwritten part. Yeah. So here we're going to have, hmm, unwritten is going to be a mewtwo buff to the entire buff and then we're going to write into unwritten. And then. Yeah, and then also the syn ack is going to be written to unwritten and the payload is going to be empty. And then at this point we're going to write out the actual packet using send.
01:26:30.000 - 01:27:25.590, Speaker A: Right. So we're going to do Nick dot send and that takes basically a buffer. And that buffer is going to be buff. Oh, I don't know how that's going to work. It's going to have to be this. I think written is going to be, let's see, how much have we written? We've written. Well, unwritten is going to be this and so we're going to write up until unwritten.
01:27:25.590 - 01:28:16.940, Speaker A: Right. So this might seem a little weird, but we construct the headers, then we write those headers into buff. And what this trick is going to do is basically we create a slice that point to the entire buffer and every time the header gets written, the start of that buffer gets moved. And so this line down here is how much is remaining in that buffer, how much space is remaining, and however much space is remaining is how much we haven't written. Right. Which means that the stuff we have written is everything up to that point, which is what this is doing. And I guess this means that on packet is going to have to return an IO results, I guess maybe use size, unclear that it matters.
01:28:16.940 - 01:29:15.840, Speaker A: And I guess we're going to have to use standard IO. Let's see whether this makes any sense. We're going to need prelude, probably ir is not implemented for u eight. Where is it saying that? Okay, there are a couple of issues. First, this expects a u eight of size four, which is not what we're giving it. I guess this is gonna have to be destination and this is gonna have to be source. It's probably still gonna complain about that.
01:29:15.840 - 01:30:24.110, Speaker A: Specifically. I wonder whether we're gonna have to do like this, which is a little awkward, but maybe. And this is going to be source, source, source. Nothing found for IPV four header. This we're going to have to use total len. Alright, what else was complaining about this and also this. Now what is complaining about? About.
01:30:24.110 - 01:30:59.320, Speaker A: I was complaining in main about this. That's fine. It's now a question mark. It takes four parameters, but three were supplied. That's because we also need to give it now the network interface so that it can send additional things. Okay, what else do we have? Expected mutable reference. Oh, this should come first.
01:30:59.320 - 01:31:52.660, Speaker A: You could use iter chunks to get that slice from destination source. Is that true? Oh, because there's like a fixed size chunks thing now. Huh? Chunks. Chunks exact I think is the one. But I don't know if it gives you that. I think it just gives you an iterator. Where's the implementation of, implementation of iter? Yeah, it still gives you a slice so it doesn't give you a u four, which is what we need.
01:31:52.660 - 01:32:30.670, Speaker A: TCP line 29. Oh, this is okay zero. This is okay zero. No total len found for TCP header. It's because it's just header len is what we want. Because there's no payload. What else is it complaining about? The size for values of type U eight cannot be found.
01:32:30.670 - 01:33:10.560, Speaker A: Maybe it's this. We don't need these. We haven't done anything with yet. So they're unused. Alright, so now we have something that's sort of running and in theory it's gonna write back the appropriate acknowled. So let's start up our t shark and then let's try to connect on a port and see what happens. Well, something crashed.
01:33:10.560 - 01:33:27.188, Speaker A: Not yet. Oh, it's because it's not terribly surprising. Okay, so we haven't actually figured out what we want to set these for. This is why unimplemented is nice. So when we try to create this we need to set a sequence number. We need to set a window size. In order to understand what these are, we need to actually read the RFC.
01:33:27.188 - 01:34:04.078, Speaker A: See? So the place to start for this is. Where do we want to start for this? No no no, no. Here. Okay. So header format, that's fine. Here is where we're going to need to actually start reading and talk about what some of these fields mean. Just give me a second.
01:34:04.078 - 01:35:02.640, Speaker A: I need to get some water. Okay, so let's look at what actually is in a TCP header. This is a source and destination port that we've already talked about. And there's a sequence number and acknowledgement number. And there's a bunch of stuff down here. Let's talk about these two, because they're relatively important for how the protocol works, and the protocol is pretty good at describing how they work. So the sequence number is the first data octet in this segment.
01:35:02.640 - 01:35:44.268, Speaker A: So specifically it is sort of the index in the data stream of the first data part of that segment. And you can sort of think of a sin as a byte of its own. Right? So if sin is present, the sequence number is the initial sequence number which we're going to get back to. And the first data octet is one beyond that. So the sin sort of counts as the first byte. And the ack, the acknowledgement number is the value of the next sequence number that the sender is expecting to receive. Right.
01:35:44.268 - 01:36:27.374, Speaker A: So there's a diagram further down that makes this a little bit easier to follow. Where is it here? Yes. So this statement is basically entirely correct. In order to understand TCP, you just need to understand sequence numbers. Acknowledgement, there are, there are a bunch of variables that need to be stored, and they're sort of stored almost no matter what state you're in. And so what we're going to probably have to do is basically have a struct TCB. So this is what they call the transmission control block.
01:36:27.374 - 01:37:17.360, Speaker A: This is the state that has to be kept for every connection. And a TCB is going to contain the fields that we give down here. And my guess is that we actually want, here's probably what we want state that's going to have to contain these fields. And in addition it's going to contain something like, well, I sort of want to call it state, but let's make this connection. So instead of calling the state, it's gonna be connection. And this is gonna hold a state. So this is the state that that connection is in.
01:37:17.360 - 01:38:08.798, Speaker A: So this is gonna be, for now, we're just keeping that. But let's look at what is in the TCP. Among them are things like socket numbers. We can ignore that. Precedence and security we can ignore for now and then pointers to receive buffers we don't particularly care about yet retransmit queues on the current segment. This basically has to do with TCP is intended to provide reliable transports or reliable sends and receives across an unreliable connection. So the Internet is prone to just like randomly dropping your packets or rearranging them, which means that sometimes TCP is told like, hey, I never received that packet, and it needs to send them again.
01:38:08.798 - 01:38:58.238, Speaker A: Which means that TCP actually needs to keep a queue of things that it has tried to send in the past so that it can remember to send them again. And this is what's known as the TCP. Ooh, this is what's known as the TCP retransmit queue. And so the, the way to sort of think about this is we're going to keep all the bytes that the user wants us to write, and then we're sort of going to remove them as needed. So we're sort of going to keep a buffer of everything we've tried to write. In addition, there are a bunch of variables that are related to the send and receive sequence numbers that are stored in the TCP. So there's a diagram down here that we're probably going to spend a bunch of time looking at.
01:38:58.238 - 01:39:54.822, Speaker A: So it's useful to spend some time. The send sequence space is basically the bytes of data that we have sentence, and there are a couple of points in that data stream. So send Una is what we have sent, but that has not been acknowledged. Send next is where we're going to send from the next time we send send window is how much we're allowed to send. So TCP has this notion of, as a receiver, you can sort of limit how much your sender is allowed to send so they don't overwhelm you with traffic. And so how much we're allowed to send is the last point that was acknowledged, plus the size of that window. So send next can never go beyond, sorry, we can never send bytes beyond this boundary.
01:39:54.822 - 01:40:54.200, Speaker A: Even though we might have them locally, we're not allowed to send them yet. And these are used for updating windows, which are going to change in all sorts of ways. There's also a notion of an initial sequence number. The initial sequence number is what we choose when we started the connection that doesn't have to be zero. So basically you can think of this as we don't have to name the very first byte as one, right? Like, we don't have to start counting at one as long as both sides of the stream know what we call zero, right? And similarly, we keep a similar sort of values for the receive buffer. Specifically, we keep track of where, what we are expecting to be the next byte we receive and the window for receiving. And also the, the sequence number that the other side has counting as zero.
01:40:54.200 - 01:41:21.210, Speaker A: Right. So this is why these segments are labeled. So everything that's in one. So everything before this line is data that has old sequence numbers that have been acknowledged. Two is sequence numbers that we have sent, but that the other side is not yet said that they have three is. So everything between here and here is sequence numbers that we're allowed to use in some sense. Right.
01:41:21.210 - 01:41:44.950, Speaker A: Because this is the first bit of data we haven't sent and we're allowed to send up to this much. Right. Like a window more than where we got acknowledged. And so all of this we're allowed to send if we, if the user gives us data. And four is stuff we're not yet allowed to send. And so three is referred to as the send window. This is where we're allowed to send.
01:41:44.950 - 01:42:26.042, Speaker A: And the receive space is sort of similar in that everything before received next is stuff that we have received from the other side. And we, like, we're sort of done with that. We've passed it to the user space, hopefully, or we're about to, but there's like nothing. This is just data that we have received. Two is sequence numbers that the other side is still allowed to send us. So it's within the window that we have announced to them. And three is stuff that they're not allowed to use those sequence numbers yet, as we're going to have to keep all of this state for every, for every connection.
01:42:26.042 - 01:43:29.970, Speaker A: And so we might as well just sort of keep it already. So we're going to have a struct, which is going to be a send sequence, and that's going to have this, which I guess is going to be a use size next, which is going to be a use window, which is going to be a use size urgent pointer, which I think is like a boom. I think the urgent pointer has even been deprecated. So I think we can probably just ignore it, but let's keep it just in conformist with the spec w one. In fact, let's also, just for our own sake, do this. I like it when documentation, like, keeps data, keeps comments from the protocol specs, because it makes it really easy to refer back and forth to them, to someone trying to read the code and trying to understand it later. And in fact, for own sake.
01:43:29.970 - 01:44:52.160, Speaker A: So this is a usize. This is going to be a usize, and ISS is going to be a use. And then in fact this is probably useful to include as documentation on this structured. So this is something like state of the send sequence space. And then I guess we can also refer to 3.2. This is RFC 793, section 3.2. And just for our own sanity, we probably don't need this to be like so and this is figure four.
01:44:52.160 - 01:45:50.350, Speaker A: So this might help us later when we're like looking back at documentation things. In fact, these can arguably be proper documentation, so to speak. And similarly we're going to have a receive sequence actually we could maybe call this send sequence space and this is the receive sequence space. And the received sequence space is a little simpler. It's next which is EU size window which is EU size up which is a bool and Ir's which is EU size. And here too we'll sort of keep the docs. One reason this is nice is because it means that we're gonna have to switch back and forth a little less, at least one might hope.
01:45:50.350 - 01:47:11.670, Speaker A: So this is the receive sequence space, so we'll do the same here. This is RFC seven hundred ninety three s thirty two, figure five. And similarly here we don't need that. This can be this and this will be this. Okay, so now we have those set up and in addition there are a bunch of variables that are, that are used sort of as we discuss the protocol further down. They talk about segments and we'll get back to that later. So the idea basically for us as sort of a TCP client is that we're going to make sure that, or we're going to want acknowledgements for these.
01:47:11.670 - 01:48:14.716, Speaker A: So these are things that we have sent but have not been acknowledged and if we have to send more data we're going to use this space of sequence numbers, right? So now the question becomes like what are going to be defaults for these, right? So a connection is certainly going to have a send sequence space and a receive sequence space, but we don't really know what's going to go in them. And so down here I guess we have the diagram. And so this is where it goes into sort of discussion of the sequence numbers. And this is also something we sort of need to walk through. So every octet, so every byte of data that's been sent has a sequence number. And because we want to make sure that the receiver receives all of them in the right order, because every byte is sequenced, every one of them sort of can be and should be acknowledged. And the idea is that it's cumulative.
01:48:14.716 - 01:48:59.440, Speaker A: So if I say if, basically, if I send you an ack eight, it means I have received all the bytes up to eight. And notice that it's not inclusive. Right. So if I say if I ack eight, it means everything up to but not including eight has been received. The sort of the first numbered bytes numbering within a segment as the first data octet immediately following the header is the lowest numbered. Yeah. So if you receive a packet that has a bunch of bytes in them, then the first byte after the packet has the sequence number of that packet.
01:48:59.440 - 01:49:37.090, Speaker A: So this is when they talk about segment. The segment is basically just one packet. So this is the sequence number from the header of a packet that we received. And that gives the sequence number of the first byte of the data in that packet. And the sequence number space is finite, which is important to remember. So specifically, it's 32 bits long. And this means that the sequence numbers are going to wrap around if you send enough data.
01:49:37.090 - 01:50:31.012, Speaker A: Okay. Fact, in response to sending data, the TCP will receive acknowledgments. The following comparisons are needed to process the acknowledgement. Let's see. Yeah, so the idea is that we, as a sender, we're going to send data to the other side and it's going to send us axe back. And in order to do that. Yeah.
01:50:31.012 - 01:51:00.844, Speaker A: So this is going to be the last sequence number we have sent, but that has not been acknowledged. Right. So this is the values from before. This is the acknowledgement field in the header when we get a packet from the other side. Yeah. So this is the. So again, this is up to but not including.
01:51:00.844 - 01:51:32.890, Speaker A: Right. So they are expecting to get something with the sequence number next. And this, this is, these are on segments. Right. So these are headers of the current packet. So this is saying that the first byte of the current packet has the sequence number and Len is the number of bytes contained within this packet. And so necessarily the, if you add these two and subtract one, that is the sequence number of the last byte in a packet.
01:51:32.890 - 01:52:07.752, Speaker A: And so here they sort of define this notion of what an acceptable ac is. And if you look at it, it's actually not that surprising. Right. It's saying that if the, as long as the value they are acknowledging is one that we're expecting an acknowledgement from. Right. So we believe we have not received an acknowledgement, yet we receive an acknowledgement, and that acknowledgement is something that we have actually sent. Right.
01:52:07.752 - 01:52:55.048, Speaker A: So next is what we're gonna. The sequence number we're gonna assign to the next byte we send, which means that if they try to act something that is greater than this, it means they're trying to act a bite we haven't sent. If they try to act something that is before, before this, it means we've already received an acknowledgement for it, so we don't really care about it. And if you have a packet that's like on the retransmission queue. So something you might have to say again, you should consider it acknowledged if basically, if the last byte, the sequence number of the last byte in that packet has been acknowledged. Yeah. So these, these sort of checks here are things we're going to have to add later.
01:52:55.048 - 01:53:37.440, Speaker A: They're not important for the setup, but they are important to do. So we're going to end up having to look at these. I'm going to ignore them for now. So, because the very first thing we have to do is the handshake, which is this part, so. Sorry. Yeah, so part of the problem is that TCP allows you to like establish many connections, right? So we have these quads and there's nothing stopping you from like starting another connection with the same quad. But TCP sort of has to detect this has happened.
01:53:37.440 - 01:54:27.000, Speaker A: And the way it does that is by basically randomizing what you call the first byte of a stream. Because that means that if someone, because you randomize it every time when you start randomly, you're unlikely to start on something that's valid for the other, for some connection the other side is still remembering from before. Right? Like they're remembering this part of the sort of sequence number space you pick randomly. You're going to pick like somewhere out here because it's a very large space and that is far outside their window. So they're just going to go, no, this is not a part of my stream. And they're sort of going to detect that something went wrong and probably terminate the connection. Specifically, they want to assure this even if TCP crashes and loses all knowledge of sequence numbers.
01:54:27.000 - 01:55:30.830, Speaker A: And so this is why when you create a new connection, you choose a random initial sequence number and imagine that it's just like actually random. In reality. They sort of want it to be not quite just random, but so that it increases over time to makes it sort of maximally unlikely that you end up in the same sequence space as someone else. There's a bunch of assumptions here that probably they're unclear whether, hold on the Internet today, but we're just going to start with this being, I think actually random is probably what the current recommendation is, but it's not important yeah. So there's the initial send sequence number that's chosen by the sender and the initial receive sequence number which is learned during connection establishment. So this is going to be in our case because we're first implementing the server, we're going to receive a sequence number from the other side. This is the sequence number of their syn packet.
01:55:30.830 - 01:56:14.330, Speaker A: So that is going to be where they're going to start transmitting. Right. And in response we have to send them a sequence number, which is the sequence number that we are going to start transmitting from. So at the beginning, the two TCP hosts are going to have to synchronize and this is done in the, the sort of handshake protocol that uses syn for synchronize and that includes the initial sequence numbers. Right. So this is the, this is the actual handshake protocol. And so a tells b that they started this and then b responds, okay, I got your message like I got your sin.
01:56:14.330 - 01:56:56.560, Speaker A: And then it sends my, I'm starting at this location and a says, okay, I've heard that. And these two can be combined because they're both being sent from b to a and that's how you end up with this handshake. Right, so this is the three way handshake. So now that we have that, before we start digging into sort of actually sending data, let's try to now figure out how you're going to start a connection. Feel like these, we sort of want to be. We're going to have to figure out what to do about this on D. I don't think this can be default, but let's figure that out a little bit later.
01:56:56.560 - 01:57:18.308, Speaker A: Let's not do this highlighting. So the question then becomes what goes in this unimplemented part? Right, so this is where we're writing a TCP header. We need to give the sequence number and the window size. Well, the sequence number. So because we're receiving a sin and sending a syn ack. Right. So the sequence number we choose really just has to be random.
01:57:18.308 - 01:57:40.490, Speaker A: Right. We have to pick some number, which is where we're going to start transmitting from. And that number we have to give to the other side. So we're going to match on self dot state, I guess, and zero is random. So we're going to start at zero. Ultimately we're going to change this value to be something that is actually random, the way the spec says. But for now we're just going to say zero.
01:57:40.490 - 01:58:14.220, Speaker A: This other thing is the window size. Right. And this is how many bytes are we allowed to have outstanding. And if we look further down, quiet time. There's a lot of stuff in TCP. Yeah. Where's the, there's like a suggested window size somewhere, but I don't remember.
01:58:14.220 - 01:59:27.780, Speaker A: So the TCP spec is actually pretty easy to read if you sit down and read through it. And it is pretty interesting. They talk about a lot of different interesting challenges that can come up. Where's the place where it says window size? Window management suggestions. All right, let's start with a window size of ten seems fine. Again, there are protocols that basically determine how you're supposed to set this, but for us it doesn't really matter in this initial setup phase. This is more for us to understand what's going on.
01:59:27.780 - 01:59:56.202, Speaker A: What we could do here is something like have a function that determines where to start. Now the other thing is keep in mind that they just sent, the other sides just sent us a sin that we're acting, right. Which means that we need to acknowledge their sin. And the way we're going to do that is by setting the acknowledgement number. Right. And remember that the acknowledgement number is the next byte we are expecting to get from them. Right.
01:59:56.202 - 02:00:42.340, Speaker A: And so that's going to be where's the sequence number? So the sequence number they sent us is the sequence number of the sin. We have now received the sin. And so therefore the next thing we're expecting is the next byte. So that's the next thing we're expecting. In addition, oops. The other thing we're going to have to do is set the, what's it called? So our sequence number we already set to zero above, but now we're going to have to establish a bunch of state for ourselves. So specifically for the send state we're going to have to set a bunch of stuff.
02:00:42.340 - 02:01:19.316, Speaker A: And for the receive stuff we're going to set a bunch of stuff. So first we need to keep track of sender info. So this is the receive window the, the other side sent. So in this case let's call us the server and then the client. The client sent us information about their sequence number and like their initial sequence number and also sent us stuff about their window size. And we need to keep track of that in order to keep track of their window. Right.
02:01:19.316 - 02:01:54.958, Speaker A: So in self dot receive we have a receive sequence space. So that's next window, this urgent pointer and IR's. And so the IR's is just the sequence number that they just sent us, right. Because that is the sequence number of the sin, which is the first thing they sent us. The other thing is the next byte we're expecting from them. Well, I guess let's do these in order. The next byte we're expecting from them is the ph dot sequence number plus one, right.
02:01:54.958 - 02:02:32.506, Speaker A: Because we've received the sin, the window. Window. Well, window size and the window octaves beginning with the one indicating the acknowledgement field which the sender is willing to accept. Right. So that is their window size. The origin pointer we don't actually care about. Which means that here we have all of this sender info, right? So this is all the stuff that they sent us that we need to keep track of.
02:02:32.506 - 02:03:20.934, Speaker A: And now of course you'll notice that the acknowledgement number is really just the next. Right? So in fact we can just do this. In fact we can, we can take advantage of this further, further down in the protocol in that it will always be the case that the acknowledgement number is just the next thing we're expecting to get from them. And so this might be something we could sort of factor out later on. In addition, we need to decide on stuff we're sending them, right? So we have to establish our send sequence space, right. In particular, we're going to have to do something like the last thing we sent them then is unacknowledged is whatever the sequence number we choose for our sin is. Right.
02:03:20.934 - 02:03:43.800, Speaker A: That is the thing that we've sent them that they have not acknowledged. The next one we should send. Oops. The next sequence number we should use is this one, right? So is one. Pass this in. The window size we're going to use is, I guess, ten. Right? That's what we chose.
02:03:43.800 - 02:04:18.440, Speaker A: Further down, the origin pointer. We don't care about the WL1. I don't know what we initialize to. It's used to basically compute how aggressive we should be about sending things. So I think we're just going to not set it for now. And the ISS is zero. So the reason I said ISS here first is because the ISS is the sequence number of the sin.
02:04:18.440 - 02:05:09.580, Speaker A: Right? So this is why arguably this should go here as well. And so now of course we can use here, the sequence number here is going to be the ISS and then ten. This is going to be our window size. And at this point we now sort of have, ooh, these are in, these are in send. Alright, what am I missing? Sequence number is probably a function. No field receive on state. Oh, right.
02:05:09.580 - 02:05:46.174, Speaker A: This should all be on connection. The sequence number. Let's do as you size. Well, it's going to be all sorts of painful. All right, let's stick to the types they use, which is the sequence numbers are U. Windows are U 16s. So this is U 30.
02:05:46.174 - 02:06:11.200, Speaker A: This is U 32. This is U 32. This is U 16. This is U 332. The reason I use you size is because they're TCP extensions that basically increase the size of these values to accommodate for having more data in flight, but probably not something we care about right now. Self, dot, send. Oops.
02:06:11.200 - 02:06:29.220, Speaker A: Send. This is send. And this is Send. Dot. All right. How's that? Right. So this is for the defaults.
02:06:29.220 - 02:07:21.442, Speaker A: Yeah. So this is why it's a little weird actually to set up a connection in the first place. Yeah. Specifically what makes this weird is if a connection is closed. So here's where this is weird. If we're in the closed state, we have no state for any connection. If we're in the.
02:07:21.442 - 02:08:42.790, Speaker A: Listen. State, we also don't have any state for a connection. All that means is that we're sort of willing to accept connections, which means that connection doesn't really have a default, because if you're not, if you're listening, you don't have a connection. A little weird for this to even have a default, which is why I wonder whether we should not have default and instead have something like accept, which gives you a self. And what that will do is actually this. So we're going to have an accept, which is how you accept new connections. So that assumes that you have no current state is going to produce a state, right? I guess maybe option.
02:08:42.790 - 02:09:23.200, Speaker A: So this is going to be okay. None. So here we're going to create a new connection. Its state is going to be, well, presumably we received a sin. So according to the diagram, we're going to be in the sin received state. Sin receive. Receive is going to be receive save sequence space.
02:09:23.200 - 02:10:40.596, Speaker A: And send is going to be a send sequence space. Yeah, this is actually probably nicer. Like, so what else do we want? Great. So that then gives an okay some c. What am I missing? So send has some other fields, specifically up Wul one and wl two. So I guess up is false. Wl one is zero.
02:10:40.596 - 02:11:18.724, Speaker A: Wl two is zero. I don't actually know what these should be. And what is receive sequence space have, which is false. So let ISS is zero. Beautiful. And this is a comma. Right.
02:11:18.724 - 02:12:02.090, Speaker A: So this is here we're creating the entire state for a new connection because we received the sin. Right, which is represented by the state. And then we send the acknowled. All right, let's see. So in main now this changes the setup a little. Basically what we're going to do is we're going to match on entry. So I guess here we're going to use collections hash map entry and if we get an entry occupied then that is an existing connection.
02:12:02.090 - 02:13:10.960, Speaker A: And if we get an vacant then we do something, right. So if we get an occupied one then we call on packet. If we get a vacant one then we're going to do if let some connection is equal to TCP connection except Nick IPh these things. And if that is some then we gonna insert that connection. So we still want an on packet, right? Because there are going to be cases where we actually receive a packet and we have some current state, in which case this will probably do something like usize. Actually it probably won't even do that. I'll return nothing.
02:13:10.960 - 02:14:29.770, Speaker A: And currently that function does nothing unimplemented. What this means is that initially if we get a connection for if we get a connection from a quad that we don't yet know about, then we try to accept that connection. Wouldn't random but decreasing be better though as the sequence numbers increases as you send bytes. So this part of the RFC for choosing initial sequence numbers has been obsoleted by later rfcs. So I would just sort of ignore what it says because if you look at the 7414, some of the other things, I think it's 1112. 1122 already goes into a bunch of details of like all of the ways in which that is broken and what you should do instead. See get mute all packet.
02:14:29.770 - 02:15:04.510, Speaker A: This has to be mute. This probably also has to be mute. All right, all right, let's see what happens now. Send a packet. Well that doesn't look great. So the packet went to us and we sent something in response. Not entirely clear what.
02:15:04.510 - 02:16:12.160, Speaker A: And then we panicked at not yet implemented at 140, at 149. Okay, so I think what that means is we got the first packet and then it tried to connect to us again and then we crashed. But this though is not very promising. That suggests that whatever it is we're writing back is not correct. Also how is it 1456 and something is not right here. Let's take a look at what the responding with these bytes buff unwritten. So it's responding with a ton of bytes at least.
02:16:12.160 - 02:16:45.940, Speaker A: Why are they weird? Let's look at, so what we're supposed to respond with is an IP header. So the IP RFC, it's like RFC 791. Yeah, let's do this one. Let's see. Header format version. Actually that's another good question. Let's compare that to what we received.
02:16:45.940 - 02:17:59.220, Speaker A: So up here, let's do got header cent header just so we can sort of compare the stuff we got in and what we sent out. So this is going to be IPh and I p. Oh, is there even a way to get this out? Probably not. So let's just do that. Oops, what I do TCP header. What is it complaining about? I don't think it's complaining about anything good. Oh, TCPH.
02:17:59.220 - 02:18:36.540, Speaker A: All right, so let's see what happens now. So what it got in for the IP header was 450 zero. And then, so the question becomes what are these bytes back to this. So these bytes are, version is the first. So version is four, which is what we also, what we respond with. So four five is correct. Then it's zero, zero.
02:18:36.540 - 02:19:06.010, Speaker A: And then this is length. So that's fine. Identification is 24. What is identification? Okay, that's fine. It's fine for that to not be helpful. Flags. We are not setting any flags, are we? Total length.
02:19:06.010 - 02:19:36.930, Speaker A: Okay, so this is this then total length is the next. Oh man, the scrolling is gonna be annoying. Is zero, zero, three c and we give zero. 00:28 so that's fine. Identification is next. So this is, oh man. 24 Cd and we give nothing.
02:19:36.930 - 02:20:14.427, Speaker A: So what are the flags? Flags down here. Okay, that's fine. Time to live. And protocol. Flags and fragment offset time to live. We do set specifically, I think we set it to what was already there. Protocol follows that.
02:20:14.427 - 02:21:03.092, Speaker A: So protocol. So they send 400. Okay, 400. That doesn't seem right. Let's try it again. 45000, zero three c, 24 CD 400. So there we give it the same.
02:21:03.092 - 02:21:32.992, Speaker A: And then their header checks them as 90 49 b and ours b 97 c. The checksum is sort of unimportant source address. So we're setting our source address. We're not reversing them. Or maybe we are. So their source address is these four bytes. Our source address is these four bytes.
02:21:32.992 - 02:21:46.020, Speaker A: Okay so we are reversing them. Right. So ours is zero two. There's a zero one. So that's inverted. So that looks like the IPV four header is correct. So I wonder why.
02:21:46.020 - 02:22:31.410, Speaker A: I wonder why that's not looking right. Huh. Let's see what this says for send. On successful send, the number of bytes sent in the packet is returned. Huh. Okay, what about our TCP header? Ours start with zero one. That seems maybe problematic.
02:22:31.410 - 02:23:32.360, Speaker A: But the weird thing is this couldn't even parse out the IP addresses. It's saying raw packet data which is a little odd. Also, we're sending an awful lot of zeros, which doesn't seem right. Oh wait, this isn't right. This is how many bytes we didn't write, which is, this is not what we want. We want buff Len unwritten, I think. I mean, it still crashes, but at least now we're writing it out.
02:23:32.360 - 02:24:07.522, Speaker A: Fewer bytes. So the first part we still have. Right, so that goes up to there. And then we're sending, this looks like an extra 01001. This is the end of the IP packet. And then we're sending zero, one bb, and then Ba 86. So we're inverting these values.
02:24:07.522 - 02:24:49.720, Speaker A: Oh, so these are the TCP ports. Okay, so that is correct. We are supposed to invert the TCP ports. Then we're sending all zeros, which is our sequence number. Is that right? Which is our sequence number. Yeah. So our sequence number is all zeros.
02:24:49.720 - 02:25:48.414, Speaker A: And then we send our acknowledgement number, which is this part. I don't want it to scroll. So starting at zero f, which should be the same thing as they sent us their sequence number. Right, and what they sent us is their sequence number was this value zero f 60 d. Right, so plus one. So that's correct. There's a bunch of other stuff that shouldn't matter and I think our length is the same as theirs, although they're also.
02:25:48.414 - 02:26:19.538, Speaker A: Oh, I see. And then checksum and urgent pointer. It's like the last bit that they're including here, specifically following the. So they sent that, then the acknowledgement number, which is all zeros. Then 1234 bytes of stuff where the last one is their window. Right. So these are their window.
02:26:19.538 - 02:26:58.780, Speaker A: Faf zero. Then checksum, an urgent pointer. So the urgent pointer, zero. And they're sending a bunch of TCP headers. So why is ours differing from that? So we're sending, this is the sequence number then. No, this is the acknowledgement number, then these are the data officers reserved. This is the window.
02:26:58.780 - 02:27:43.720, Speaker A: So zero a there is our ten. And then we send checksum. And then we say an urgent pointer. That checksum is wrong, though. I don't think we're allowed to send a checksum of zero, certainly. I think it's, I think it's not true that the checksum is zero, more importantly. Oh, interesting.
02:27:43.720 - 02:28:49.568, Speaker A: Okay, so I think we, yeah, we need to manually compute this. Checksum is my guess as well. So specifically down here we're gonna have to do. Checksum is going to be that syn ack dot calculate checksum for IPV four. We're going to give the IP header, the one we're using to send, and the payload is going to be empty. And that should give us fail to compute checksum. Okay, so that should give us the checksum which should be set on the syn ack checksum.
02:28:49.568 - 02:29:22.910, Speaker A: It's gonna be equal to that. Let's see if that makes a difference. Ooh, what's going on here? What did I miss? Oh, this should be a semicolon. Great. Now shark. And then try again. Raw packet data is still what it says.
02:29:22.910 - 02:30:22.070, Speaker A: Actually, let's have it stop trying to crash here because it's a little annoying. Interesting. Why does it just say raw packet data though? This packet looks entirely fine. Specifically, why does it not think it's a valid ip? One send must be a valid representation of a packet. I wonder whether there's a here time tap text. Maybe we need to include these as well. Actually that's probably true.
02:30:22.070 - 02:30:51.840, Speaker A: So we need to set flags and proto. And I think what we're going to do there is. Yes. Remember that what we get in here. Oh, I wonder whether I can just turn that off. No, I don't really want to do that. Hmm.
02:30:51.840 - 02:31:55.136, Speaker A: Specifically there's this like if no PI, which the question is whether we have to put those four headers at the beginning when we send as well. Yeah, I don't think we care about that. Okay, so let's make this. Let's make this without packet info. And now these are gonna go away. There's no longer gonna be these four bytes at the beginning. And in theory we shouldn't have to write them when we write back either, ignoring weird packet iP.
02:31:55.136 - 02:32:39.000, Speaker A: Okay, that's fine. And now if I do this, what's it going to do? Ooh, how about that? Okay, so now look what happened. So our client. Yeah, so it's basically, why not model? This is a state machine with transition between states. So the, okay, so that's how I started it out, right? With connection being an enum. The reason I didn't do it this way was because there's a bunch of state that's shared between almost all of the states. In fact, the things related to sequence numbers and acknowledgement are actually associated with all of the states where there is a connection.
02:32:39.000 - 02:33:05.290, Speaker A: And so that's why we have the state enum. But there are some fields that are not a part of that enum because they would be in every variant. So we will still use an enum for the actual state machine. Yeah. So here what happened was this program. Okay, so for what it's worth Netcat is a program that just like connects to here. And then just whatever bytes you give it to Stdin, it's going to send over the network.
02:33:05.290 - 02:33:24.060, Speaker A: And so it's connecting to zero two. And indeed we see that connection here. And then we see that we sent a response here. Right? And it looks to be sent to the right port. Right, so this was the source port. This is the destination port. It has syn ack, it has a sequence of zero.
02:33:24.060 - 02:34:10.670, Speaker A: It has an ack of one, which is correct because the sequence number they used was also zero. And we have a window of ten, they have a window of 64,000 and a len of zero because we're sending no bytes. And then they sent us an ack. So this ack is supposed to be, well, basically this act is saying, I got your sin, and at that point the connection is established. So that is the next packet we now have to handle. Right. So this means that now actually our, our initial part of the handshake worked out correctly.
02:34:10.670 - 02:34:59.340, Speaker A: I suspect that we might not even need this. I think the kernel does this for us, but let's double check. Yeah, the kernel does that for us. Kernel is nice and does this for us. Now we don't actually need to print these bytes anymore, which is going to be make the stream a little nicer. Let's also do, let's also do this because we don't care about it. All right? So now at this point we're going to do c dot state.
02:34:59.340 - 02:35:44.000, Speaker A: Oh, we already set the c state, right. So down here, this is where the state machine comes to play into play. We're going to match on self dot state. And if the state is also, let's just imagine that state closed doesn't exist. Right? If it's closed, then, like, we have no state, listen as well, is a little weird because if you're in the listening state, you also don't have any state, right? You don't have any connection yet. And so in some sense it's a little weird to think of it as a state that you can be in. So let's ignore that and rather think about established, because in theory what we're going to do is move from this to this.
02:35:44.000 - 02:36:54.810, Speaker A: So if we're in sin received, that's where we're sort of expecting to be right now. How do you feel about the rust mascot? I like the crab. If we're established, then this is something that we haven't, we don't know what to do with yet. But if we're in sin received, now the question becomes now what do we do? Well, it will tell us so specifically if we're in the received, if we're in this state, expect to get an acknowled for our sin. Right? That's what we're expecting right now. I think one thing we're gonna want here is almost to keep track of this IP header. Just we don't have to repeat it every time.
02:36:54.810 - 02:38:38.516, Speaker A: Yeah, I wonder whether this is something we actually want to stick into the, into the state of the connection. Well, actually I guess here there's going to be an ether parse ipv four header that we're just gonna keep around there in such a way that here, because we're gonna be using basically the same IP header every time, there's no reason for us to, there's no reason for us to have to go through the steps of like parsing out the source and destination fields each time. The one thing we will have to be careful about though is IP. What's that field? The payload len. How do we set payload len to be syn ack dot. What do we have it set to header Len plus zero bytes for the data on receiving. You stripped the first byte from the ton slice.
02:38:38.516 - 02:39:25.956, Speaker A: You need to pull them back. Yeah. So we no longer need to do that now because I added this without packet info. Because we're now constructing with, without packet info we don't have those four bytes anymore. If no also include onsen. So because we're ignoring the packet info we don't have to do that. Right.
02:39:25.956 - 02:40:00.930, Speaker A: So we need to set the payload len of the IP every time we're going to use it. But apart from that we're probably fine. There are probably some other things like we could have a convenient method on here on connection. That's something like send that does this trick down here for us. But we're probably not going to be able to actually use this most of the time because the retransmit queue is going to. Well, the retransmit queue means that we might have to send things later. So we actually have to keep track of the bytes.
02:40:00.930 - 02:41:17.096, Speaker A: C ip and this is also C ip. What is he complaining about now? Expected usize found U 16. All right, so what do we do when we get a syn ack? Well if the. So here there are a couple of things we need to do, right, so if you remember from the RFC they talked about this. Where is it? Down here somewhere. This acceptable ack check, right, which we basically have to do for any packet we receive check, which is to make sure that this is an AC that we shouldn't be ignoring because it sort of is something that's unrelated to us or was sent incorrectly by the sender. And so we need to do that basically regardless of what state we're in.
02:41:17.096 - 02:42:28.030, Speaker A: So we're going to do if TCPH acknowledgement number. So here, one thing that's tricky is all of this is wrapping. It's wrapping arithmetic. So specifically if TCP acknowledgement number is right. So remember that because we can wrap around, right, this is 32 bits, it doesn't really help to just do this sort of stupidly, right, of self dot send dot on a minus this and tcp h dot ac number less than or equal to self dot send dot. Next. If we did this, this would not actually do what you want.
02:42:28.030 - 02:43:40.430, Speaker A: Wait, what? What's it complaining about? Oh wait, what am I missing? Why is this not happy with me? Oh, double exclamation mark. So this check, writing it out like this will not actually work because of wrapping arithmetic, right? Both of these need to consider wrapping. So the check really is that this is between those when considering wrapping arithmetic. I'm not creating a socket server per se. This is implementing TCP. It might let you write sockets, but it's not a socket server. I don't really know what you mean by socket server.
02:43:40.430 - 02:44:48.950, Speaker A: This is implementing the ways that sockets work sort of under the hood in some sense. And so really what we want here is sort of a comparison that checks. Let's see if so there. Let's first do AKN is TCPH acknowledgement number. Just because if Akn is more than self send una. But remember wrapping, ok, so if Akin is more than una, then we require that it is less than or equal to next. Or rather, actually if it's less than una, it might still be fine, right? Because how do I even visualize this? Let's try it here.
02:44:48.950 - 02:45:46.030, Speaker A: So we have this space where there's, there's una, right? And then there's the ack we got. And then there's next, right? And we want to check that ack is greater than Una and that it's less than or equal to next. It's very unimplemented. Yeah. Um, but of course, because, because the 32 bit space wraps around, um, so at some point, like imagine that this is zero. It sort of goes like this way and then comes back around here. So this is also a very large number.
02:45:46.030 - 02:46:23.810, Speaker A: So imagine that there are a couple of cases that we sort of need to think about. Um, so for example, we might have that, like. So the simple case is that you have this u a n. Right. This case is simple because you can just do straight comparisons. Where it gets harder is when you have something like, here is you. Here is a.
02:46:23.810 - 02:46:39.526, Speaker A: And. Oh, that was a stupid example. I should have done wrapping the other way. Let me. Oh, man. Erasing in this program is really annoying. But I think there's a.
02:46:39.526 - 02:47:21.992, Speaker A: Yeah, no, erase. That's awful. Can I get a bigger thing, like brush? But this. Yeah. All right. Penniless. So let's draw that again, shall we? So zero is here, and then the numbers go this way.
02:47:21.992 - 02:47:51.140, Speaker A: But here, of course, we wrap around to zero. So now the simple case is you have u, you have n, you have a. You compare them straight, everything is fine. Where it gets weird is if you have una. Ah, man. This should be. Sorry.
02:47:51.140 - 02:48:28.306, Speaker A: Should be. Let me clarify. I wrote the letters in the wrong order. So, specifically, give me back my thing. So if this is a and this is n, similarly, this is a and this is n, right? So the red case is trivial. The green case is harder. Because here, if you just compared Una, you're.
02:48:28.306 - 02:48:44.150, Speaker A: That's not good enough. Right? Because U is greater than a, which is not what this requires. Right. This requires that U is less than a. But in a wrapping space, they are. And the same. You have the same problem, of course, between.
02:48:44.150 - 02:49:19.970, Speaker A: Between here. Right? Like, if there's a wrap between here, then you would have the same problem with that comparison. And so this is the trick that we're going to have to overcome for this check. That this check is not just going to be. This check is not just going to be a straight comparison. Specifically, I think the trick here is going to be to compare them pair wise. So, specifically, if Una is less than ACN, right? If.
02:49:19.970 - 02:49:53.230, Speaker A: So, if u is less than a, then either we're in this case or we're in this case or there's an error. Right? So here, if. Sorry. It means we can't be in this wrapping case correctly because U is greater than a. So for this to now be correct, we now need to do the comparison of a to n. So if Akn is less than self. Dot, send, dot.
02:49:53.230 - 02:50:19.600, Speaker A: Next. Less than or equal. Right? So this is. This first case is the trivial case. No wrapping, right? So we're all good. So it's u less than a, less than or equal to n. So all good.
02:50:19.600 - 02:51:51.410, Speaker A: In this case, we have u is less than a and a is greater than n. So can that happen with wrapping? Well, u. So let's think about it, u is less than a, so we have ua and a is greater than n. So n is somewhere over here. Well, that's fine as long, actually. Is that always fine? Isn't this check just broken? So specifically, when would this ever not be true? Right? Like I'm imagining here, for example, like you. So currently we have u is less than a, right? Isn't this true for any n? Like if n is here, then n is greater than or equal to both of them.
02:51:51.410 - 02:53:13.214, Speaker A: I think the requirement is that n is less than, uh, right? I think the requirement is that a is between u and n and u and n are not overlapping. Right? Because if n was here, that just seems wrong, right? I think specifically the case we're looking for is we want a to be between u and nde, which means we can't do all the way around the wrapping. So I think what we want to do is this, right? That is the case we're trying to guard against. We're trying to do the knot of this, right? No wrapping. So in this case, n may have wrapped, check that, right? So in this case, u is less than a. And we now need to make sure that n isn't between a and u, right? Looking at our picture here, we have that useless a. So what we're really checking is that n isn't between these two.
02:53:13.214 - 02:54:34.938, Speaker A: As long as that's not the case, then everything is fine. So actually, we can write this as check is violated if and only if n is between you and a. So if self send next is greater than self dot send dot una and self dot send dot, next is less than akn. And we're specifically allowing, we're specifically allowing act to be equal to next, right? So a is allowed to be equal to next. So if n is here, then we're all good. If n is here, then that's obviously. Oh, actually, is that fine? I don't know.
02:54:34.938 - 02:55:03.996, Speaker A: That needs to be strictly greater. We need next to be. This is an error. Even if next is equal to una. Great. If you compare u to n, don't you know if you are wrapping or not? The problem is you can have wrapping in both directions. You can have wrapping between u and a.
02:55:03.996 - 02:55:50.530, Speaker A: You can also have wrapping between a and n, right? And so specifically, what we're dividing this into is two cases. Either if u is less than a, then the if u is less than a, right, then the invariant is violated if and only if n is between the two of them, right? If n is anywhere else, either to the right or to the left. Then it's fine, because if it's to the right, then it's more than a. Yeah, and if it's to the left, it's just wrapped around and is more than a, so that part is fine. Promoting to a bigger type wouldn't help because you still, you can't do the unwrapping. Right is the problem in this case. So let's draw this other case out.
02:55:50.530 - 02:56:51.990, Speaker A: Why don't I put my pen there? So let's draw the other case out with pretty blue colors. So this other case is that we have, we have a and u, right? A is less than u, right? That was, this is if u is less than u is less than a, right. So this is a is less than u, or they're equal. This check is violated if and only if n is in between here. No, this is okay only if n is between here. Otherwise it's not okay. Right? If n was here.
02:56:51.990 - 02:57:54.662, Speaker A: If this was n. If this was n, then we would have a problem, right? Because now a is not between you and n. So if a is less than u, this is a problem if n is between a and u, okay? If check is okay if and only if n is between you and a. So that is a nice symmetry to it. Again. And self, dot send dot next is less than this else. And for the equalities, the requirement is that next is allowed to be equal.
02:57:54.662 - 02:58:13.740, Speaker A: So the check is okay if n is equal to a. So self, dot next is greater than or equal to a. That's fine. And it has to be strictly less than. Uh, which this check is here. As long as those two are both true, then we're fine. So we're not returning.
02:58:13.740 - 02:59:04.778, Speaker A: Otherwise we are returning. Okay, so when we get to this point, we now know that we have, what we have is an acceptable act. Whoo, great. This is for, this is when you receive data, which we're not really doing. Well, I guess technically we've received data. When data is received, the following comparisons are needed. Oh, this is for.
02:59:04.778 - 02:59:48.150, Speaker A: Right, so this was checking the act, and now check that. So this is the valid segment check, right. This is to check that the bytes that are in this packet, including the sin, the sin counts as a byte. To check that those are within the range of things we're willing to accept. So I guess let's actually give a 3.3 reference in here. First, check that sequence numbers are valid.
02:59:48.150 - 03:00:44.820, Speaker A: 3.3 so this is RFC 793, three section 3.3, right? So the valid segment check is similar, right? It's very similar. To what we did above specifically. It's that, that's not what this is. So going back to our picture here, they're really just swapping out these values for instead of una, it's going to be. They want next.
03:00:44.820 - 03:01:28.740, Speaker A: Oh, why is this pen different? Ooh, pen. They want next to be less than or equal to the sequence number from the packet, which should be less than. So this is next in case that was unclear. Next plus window. So what we could probably do is just have a function that does this kind of wrap wrapping arithmetic. Right. Because we're going to need this check in multiple places because the check is pretty much the same.
03:01:28.740 - 03:02:30.900, Speaker A: So let's down here do, do something like fn is between wrapped. So we're going to have a use size, b use size, c use size. And this is going to be start. It's going to be end is going to be x and it's going to return a boolean. And we sort of want this to be. So the question is, should this be inclusive or not inclusive? Let's write it as non inclusive. Okay.
03:02:30.900 - 03:03:09.390, Speaker A: So we can read this as if the start is less than x, if end is between start and x. So I think this is going to actually make this a lot clearer. Right. So if we. Because these cases are sort of weird, we're just going to call this start, this end and this x, right. So now it becomes a lot more intuitive. So if we find that the start is less than x, then it's wrong if the end is between them.
03:03:09.390 - 03:03:38.320, Speaker A: Otherwise, if we find that the start is after x, then it's correct if the end is between them. Right. So you see how this is. I've just relabeled the markers, but now it's a lot clearer why this is correct. So this is end. This is start. This is end.
03:03:38.320 - 03:04:18.900, Speaker A: This is x. So if the. There's probably a. Like a way you could do this without all this branching, but I find this easier to reason about. Yeah. So if start is x, then it's violated if and only if the end is between start and x. And specifically if we want this to be non inclusive for both sides of, then we require, in this case we require that n is not in between here.
03:04:18.900 - 03:05:33.472, Speaker A: And is it allowed to be equal to start. So what we're doing is s less than x, less than eternity. I'm not sure. If start in less than x and we're doing non inclusive, then n has to be greater than x, which means that it's not okay for it to be equal to x, yes, it's not okay for it to be equal to x. Great. And that's indeed what we have here. Similarly, if the end, so we want this to be true.
03:05:33.472 - 03:06:56.650, Speaker A: We know that this is less if x was. I don't think the comparison with start matters. Actually, I think all that matters is the comparison with end, although it might matter for this case. So if the start, we want to check this, right? So we're writing the non inclusive version. If it is the case is start is less than x, then we require that. But are we, then I think it should fail even if the end is equal to start, right? Because if the end is equal to start, then this is not true. Yes, if the end is equal to start, this is not true.
03:06:56.650 - 03:07:49.818, Speaker A: So if the end is equal to start, yeah. So if the end is here or up to but not including x, then we're going to say that x is not between start and end. If end is equal to x. No, that's also not okay. Yeah, so these are both equal. So if n, if the end has any of these values, including start and end, then it's not okay. Otherwise it is so if end is here, then we're fine.
03:07:49.818 - 03:08:37.380, Speaker A: Right. Start is there, e is here, x is here, and so x is indeed between start and end. If end is here, then we're also okay, because x is indeed between start and end. If end is here, he is not between start and end, and if he's here, it's not between. Okay. Otherwise, so this is if start is greater than or equal to x. So this is this case, right? I guess this is going to be if start is equal to xdev, then we give false right.
03:08:37.380 - 03:09:28.348, Speaker A: If we could even here do match start compare. The thing that gives me an ordering is what I want. Great. So match comparex. That way we don't have to do it multiple times. So we're going to use compare or ordering. If we get ordering equal, then false right.
03:09:28.348 - 03:11:14.870, Speaker A: If start is equal to x, there is no way in which x lies between start and end. If start is less than x, then this, if start is greater than xdev than this case, and otherwise. Okay, so let's look at the greater case. It might actually help for us to draw this out. Here we have, okay, so we have some timeline, timeline, number line, where start is somewhere and x is there. If, let's see, x is between s and e if and only if end. If it's not the case that this holds.
03:11:14.870 - 03:12:14.410, Speaker A: Oh, I don't need a word. Yeah, you're probably right. Right. So I think this drawing makes a lot of sense in the sense that in these cases, let's make it really explicit for ourselves. So that's fine. This is also fine, but not in these cases. That's funny.
03:12:14.410 - 03:13:42.910, Speaker A: I don't know how to mark this now. I guess this is gonna be like x plus ethereum. Or in other words, great. So comments help. Hopefully these diagrams explain a little better what's going on. We have, so in this case we have the opposite of above. So I guess here we want wrap, oops, wrap around.
03:13:42.910 - 03:15:31.610, Speaker A: I sort of want this to say zero. So here we have this where we have x and this is s. X is between sne in these cases, right? So here we have x s and ethereum. And in fact, it's only between them in those, only in this case. But not in these cases. I guess that would be this case, for example, or. Right, because then in this case, oh, did I remove the case? That was kind of stupid.
03:15:31.610 - 03:16:14.830, Speaker A: Where did I put there? X is between us and e only in this case, right? Not if e is more than s, not if e is less than sde than x. Right. Then x is not in between. And if x and e are both there, or is sneaker both there, then it's also not the case that x is between sne. Or in other words, if and only if this. I don't think that's right. Yes.
03:16:14.830 - 03:17:22.766, Speaker A: Or in other words, if and only is if this case, sorry. So next was end start. Uh, no, this is x. This is end. This is start. Or in other words, if so only in the case where end is less than start and end is greater than x. Great.
03:17:22.766 - 03:18:08.230, Speaker A: And now we can use this up here specifically. If not is between wrapped self una send una self ac self dot send dot next. And we want this to be inclusive. So this is wrapping sub wrapping add one. Right, because if we, if we want it to be is between, but you're, it's allowed to be equal to the end. We're just going to increment the end by one. And it needs to be wrapping because we want it to go around.
03:18:08.230 - 03:19:14.880, Speaker A: So it's not between. Then we're going to return. Okay, the valid segment check, which we can now do the valid segment check is this. So we're going to do the same thing. Let sec n is tcph dot sequence number. And if receive dot next dot wrapping sub because we want to allow equality seek n to self receive next wrapping add self receive window. If it's not between those, then we have a problem expected Su 32.
03:19:14.880 - 03:20:03.500, Speaker A: Whoo. Great. And also, or what does this mean? Why did they give this. Oh, I see. So this one's kind of tricky. Okay. If it acts at least one byte, which means that at least one of the following is true.
03:20:03.500 - 03:21:39.310, Speaker A: Specifically, notice that the reason that we use these both checks is we're basically checking the first byte of the segment and the last byte of the segment. And if, if any of, like, if, if one of them contains something that we, that was within the window, we want to accept those bytes so the sender doesn't have to send them again. So in this case, this is still wrapping sub. This is going to be not second, but, well, second plus tcph dot. What was the name of the TCP header? Payload length again. Oh, man. Really? Oh, it's just data len minus one window end is going to be that.
03:21:39.310 - 03:22:21.810, Speaker A: So that's going to be this. Why is this not formatting my file? Oh, I did something stupid. 196. Oh, expected u size. Found U 32. Oh, yeah, these have to be U 32, of course, because that's what we're operating on. Um, cannot add 32, I guess.
03:22:21.810 - 03:23:09.430, Speaker A: All right, so now that we've made both of those checks in accordance with this. Yeah, exactly. Due to zero windows length signals, we have four cases. Oh, man. So there's actually more than this. It's also for the accessibility. Hmm.
03:23:09.430 - 03:24:41.080, Speaker A: What is the receive window here? Hmm, I see. So there's basically special rules for. Oh, mandy. If both of these are for if data dot Len is zero and not TCPH ack sin and not TCPH fin, because these also counted as bytes, zero length segment has its own rule, has separate rules for acceptance. Yeah, exactly. So this is acceptable if sec n is equal to self dot received dot. Next, if self dot receive.
03:24:41.080 - 03:26:09.740, Speaker A: Actually, this is if it's like, okay, is equal to this. But so it's, if the receive window is equal to zero, then if sec n is not equal to self dot received dot next, then it's not acceptable. Else, then it's this check, which is basically just this check. So we still want this up here. Else if self dot received dot window is equal to zero, then it's never acceptable according to the spec. Else this business. And of course, this can become an elsif and this can become an elseif.
03:26:09.740 - 03:27:05.942, Speaker A: All right. And now I have a syntax error somewhere there and also there. Okay, so we did the thing. This is also not true because the seg len also counts in and fin. So let s len is data dot len. If tcphin, then sln plus equals one. And.
03:27:05.942 - 03:27:51.010, Speaker A: Oops. And if it has a syn, then slend plus equals one. And now anything that looks at that, this is a u 32. Whoo. If s len is equal to zero. Great. Okay, so now, so this was just the check we have to do for whether or not we are even willing to look at this packet.
03:27:51.010 - 03:28:13.280, Speaker A: So to take a step back from. For how we got here, this is. We have the other set plays. The other host sent us a sin. We accepted it. That was the function we wrote before. And in response, we sent it an ack for the thing that it sent us and a sin for it to send its part of the handshake.
03:28:13.280 - 03:28:50.954, Speaker A: And now. And now what we want to do is take the ack that it sends to arson and parse that. And hopefully, hopefully we should get into here. So at this point, hopefully we should now be receiving a. Yeah, I'm gonna ignore all of this for now. Establishing a connection. Right.
03:28:50.954 - 03:29:05.922, Speaker A: So we are at the point where. So we're basically b in this case. Right. We were in. Listen, we got a sin. So we entered sin received, we sent this. And now we're about to receive this packet.
03:29:05.922 - 03:30:36.870, Speaker A: And now if all the checks work out in theory. Well, so first of all, we should check that TCPH ack is set. If that's not true, then, like, something was weird. We didn't get an act or sin, so that doesn't really help as much. Yeah, this seems like a really weird packet to get. Okay, so if this is an ack packet, it must have act at least one unacked byte, which means that this must have act our sin because it's the only thing that we have sent. And so therefore, we're going to say that our state is now established must have, must have act our sin since we detected at least one act byte and we have only sent one byte, the sin.
03:30:36.870 - 03:31:01.982, Speaker A: So at this point, we're in the established stage. And at this point, in theory, we can start sending and receiving data instead. What we're going to do is we're just going to immediately try to terminate the connection. Now let's terminate the connection. Right. So TCP has a field returning. Okay.
03:31:01.982 - 03:31:19.410, Speaker A: When something is wrong. I agree. Although in this case, it's like a little weird to return an error, too. The reason for that, though, is the way that main is written. Right. If it errors, it's just going to error out entirely. Although like, maybe we actually do want to do that.
03:31:19.410 - 03:32:47.832, Speaker A: But this is like, these errors are like the client sent us something weird. But yeah, I guess you are right. I mean, we could do like IO error, new IO error kind. This is like, well, there are many reasons, but I guess what do we even want to give here? It's like, okay, let's do broken pipe and call this ack had tried to ack unsent byte. Okay, so the reason it's a little weird to error here too, is that this could just be like a delayed act. So just because it doesn't delay any relevant bytes doesn't really mean there was an error. It just means that the act was delayed for a bunch of time and so there's nothing useful for us to do with it.
03:32:47.832 - 03:33:18.462, Speaker A: It might be an error too, but it's more likely that it's just not something that's worthwhile for us to deal with. It is a little weird to return an error. Yeah, exactly. It's like we're accepting that the client did something wrong, but it's not really bad for us. So, yeah, I think we're gonna, I think we should keep that as. Okay, I agree with you, though. It is a little weird in some sense.
03:33:18.462 - 03:34:29.916, Speaker A: Like what we should probably do there is like log that something went wrong. So down here right now, we're in the established phase, and the client, the other side, is also gonna know that we're in the, in that phase at least once they get our ack. They might send us an additional syn ack, though. But we're just going to ignore that case for now. Okay, so at this point, what we're going to do is just tear down the connection again for now. The one thing that's weird here is we sort of want to. Yeah, there's certainly a lot more stuff to do with timers here that we're going to have to come back to.
03:34:29.916 - 03:35:28.098, Speaker A: Like for example. Well, well, actually, no, this is fine. Okay, so we're going to terminate the connection. And so what we're going to look at then is down here somewhere. Half of my connections reset generation. Yeah, so this is where, so to get to your point, where about, like, what do we do in these cases? This is where you're supposed to generate a reset whenever a segment arrives that is not intended for the current connection. And that is, so this, of course, in the closed case where we're not listening.
03:35:28.098 - 03:36:38.090, Speaker A: So that doesn't matter to us if we're in a non synchronized state. So if we're in one of these initial stages and it tries to acknowledge something not yet. Sentence. So that would be up here. Let's add here to impulse. State is non synchronized. And that's going to be true for state syn received is non synchronized and state established is actually, I guess this is synchronized is nicer.
03:36:38.090 - 03:37:18.864, Speaker A: False. True. Because that way down here we can say if not self dot, state dot is synchronized. If we're not synchronized, then according to reset generation, send a reset. So specifically this case. So it acknowledges something that has not yet been sent. Right.
03:37:18.864 - 03:38:06.600, Speaker A: That's when this check fails on a security level, a compartment which is not. No, I don't know what these compartments are. Then we should send a reset if we're sin. Okay, so in this case we should send out a reset packet. Send reset. That's gonna be, it's really just gonna be the nick. So we're gonna have this sort of helper function that is gonna send a reset packet.
03:38:06.600 - 03:39:38.488, Speaker A: Actually, I think we want to buffer a tcp header here too, because like, the port numbers aren't going to change either. Right. So wherever we made this. Yes, indeed. So this is going to be iss and this is going to be window. So now we're going to be able to in send reset, we're going to do self TCP set. Oh, it's another good.
03:39:38.488 - 03:40:25.230, Speaker A: I think it's just rst is true. And what else? Like, there's probably some, like some rules for what these should be. Like, these should probably all be zeros. Oh, you're right. Send reset does not need a lifetime parameter set. Payload len. It's going to be self tcp this.
03:40:25.230 - 03:41:18.600, Speaker A: And then we're gonna have, actually, here's what we probably want. We're gonna have something like ascend, which is in fact gonna take a lifetime. It's gonna take a nick. Actually, it doesn't need a lifetime. That's fine. It's going to take a payload of bytes and that's going to do specifically self TCP sequence number. So the sequence number is going to be self dot, send, dot next.
03:41:18.600 - 03:42:56.646, Speaker A: The acknowledgement number is going to be self dot received, dot next. And the ipset payload len is going to be self TCP header Len plus payload. Is there anything else it needs to set? I don't think so. This is as us and then it's going to do this. And I guess whenever you call send, we sort of want this and we're going to do use because we're going to tell you how much we wrote. So specifically send. I guess this is really.
03:42:56.646 - 03:43:16.620, Speaker A: Right. This is really we're implementing. Right. It's a little sad that this buffer has to be separate. Basically, this is where our program is no longer zero copy. Right. Because what we're going to do is.
03:43:16.620 - 03:44:18.880, Speaker A: Wait, didn't we change this? I feel like we ended up changing this. Didn't we find that this was wrong, that it wasn't unwritten, but it was buff Len minus that changed. Like, get lost somewhere. So this is gonna sort of send the, the things we're always going to have to send whenever we send data. And then it's going to create. This isn't right. This will be self iP, self TCP, and then self buff.
03:44:18.880 - 03:45:47.984, Speaker A: No. And I guess this will be unwritten write. I don't know if that's going to work, but write payload. So let's see, we're writing out the headers and then we're writing out as much of the payload as we can into buff. That might not be all of the payload. And then unwritten is going to be unwritten Lenta. And then what we're going to send out is however much we did do.
03:45:47.984 - 03:46:47.390, Speaker A: Yes, I think that's about right. And now up here, this no longer needs to do that. And self dot send dot next is already the ISS. Yes. Actually that's not quite right. We haven't written the syn byte yet. Yeah.
03:46:47.390 - 03:48:00.228, Speaker A: And then the hope, of course, is that this is now going to be just c dot write to the NIC with no extra bytes. And then this is going to be. There's one thing that's missing here. And this is we're missing the incrementing our sequence number. So self dot send dot next is now going to be plus equals payload bytes. And if TCP dot ack, if I self TCP act no dot syn, then we also have to add one. And fin.
03:48:00.228 - 03:48:55.540, Speaker A: We also have to add one. This should be question mark, though. I don't see how it would ever fail. I guess these should also be question mark. It's like ether parse writer. It's not really what I want this to be, but no, we're just gonna do that and then just ignore this for now as U 32. And this is gonna have to be a wrapping add.
03:48:55.540 - 03:49:53.374, Speaker A: Same with this and same with this. I feel like this has bitten me in the past that that does not assign. So in other words here. Yeah, great. And if this is the case, then self TCP syn is going to be false and fin is going to be false. And ack is basically always true. Wrapping at is really convenient.
03:49:53.374 - 03:51:06.314, Speaker A: It's true. Okay, so now we have write, which means that send reset can probably also do that. Specifically, it just sets these, does not have to set payload anymore probably. Oh, this is kind of awkward. We don't know how much of that we can fit. Actually, we do fit is self size is going to be TCP header len, plus IP header len is going to be standard min of buff. And this plus this plus payload len, because we can't write out more than the size of the buffer.
03:51:06.314 - 03:52:09.260, Speaker A: Basically compare minte u 16 plus u size. So that's going to be the size that's going to write however much it can. That's gonna be. Yep. And this of course is just gonna call self dot write with nothing and then. Okay. Oh, and with nick, I guess.
03:52:09.260 - 03:52:52.390, Speaker A: So now we have a function for just sending data out. Self TCP, TCP for sending just data out. We have one for sending resets. And in this case we have to send a reset before we return. There's also some like precedence level stuff. If the incoming segment has an ack field, the reset takes its sequence number. From the ack field of the segment is TCPH acknumber.
03:52:52.390 - 03:53:46.740, Speaker A: Otherwise the resource sequence number zero takes its sequence number, which is really just self send. Next is equal to this. No, actually that's not what we want. This get sending. This gets really quite weird. It's gonna be some to do fix sequence numbers here because we already have, right. Already uses like the state of the connection to fill in that, which is not what we want.
03:53:46.740 - 03:55:07.902, Speaker A: So let's just leave this as a note for ourselves for the future, any unacceptable segment. So this is something that we're going to have to deal with down here, probably. This is going to be another to do handle synchronized reset, which is going to be this business, which I'm also going to leave for later because. So resets are basically, resets are basically for, if something goes wrong and we're going to just assume that it does not go wrong. Unwritten is not the same as buff. Unwritten is a mutable slice pointer to all of buff. This means that when you write into it, it shrinks, it removes stuff from the start so that the next write will only write to parts that we haven't written to yet.
03:55:07.902 - 03:55:42.720, Speaker A: Yet. So it's actually not the same. Okay, this should be state closing a connection, right. So this is what we want to do now. We want to close the operation, close the connection to the, to the other side, which is basically saying like, I have nothing more to send. If you close the connection, you might still receive more data, but you just can't send any more data. Yep.
03:55:42.720 - 03:56:42.910, Speaker A: Yeah, so close is simplex as opposed to duplex. Okay, so also keep in mind currently we're not dealing with retransmissions at all. Like retransmissions is something that will also have to be done here, but currently we're not doing them in the slightest. So specifically because we want to terminate the connection, what we do is we send a packet that has a fin segment. So just has the fin bit set and we enter fin weight. Okay, so that's going to be self dot TCP. Dot fin is true.
03:56:42.910 - 03:57:57.130, Speaker A: We're probably having, so what? We're currently sort of abusing the stored TCP header here a little bit because it also stores information about like whether we're in a fin state. Bullets, I guess todo needs to be stored in the retransmission queue. The reason why this is important is imagine that we have a bunch of data that we haven't sent yet. When you send that data, the fin bit should not be set. It should only be set for the very last data packet you're sending out. Whereas here we're just like setting it on the header for all tc, all subsequent TCP packets, which is not okay. And then we want to write to the NiC, no bytes, and then self dot state is going to become fin weight one, which is a synchronized state.
03:57:57.130 - 03:58:28.130, Speaker A: Of course, currently this looks a little stupid, right. We're setting established and then immediately moving on. But that's still what we like. Normally you would not do this, right? Normally this operation to close would be user triggered. It's just that in this case we're choosing to trigger it immediately. All sigma's proceeding and including fin will be retransmitted. Yep.
03:58:28.130 - 03:59:41.276, Speaker A: There's also a question of what happens if we receive a fin. So this is sort of, in the established case, if not TCPH finna, then unimplemented or TCPH, I guess, actually, or data dot or. So if there's any data in the packet and it's not a final packet, we're just going to throw up our hands and go ahhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh. So if we, an unsolicited fin arrives, then what that means is that we want to, basically we want to act their fin and then we want to terminate ourselves. But we've already sent a fin, so like this is unlikely to happen. Right. This is going to end up being a simultaneous close, but in either case, if so, I guess in this case this is the same as state being fin being fin rate one.
03:59:41.276 - 04:00:14.526, Speaker A: Okay. But in this case, we receive that, we can act it until the user connection is closing. Okay, so we're going to do self dot write to the nick. So this is going to act that. Act that Finna. Right. Receiving a fin will act.
04:00:14.526 - 04:01:03.130, Speaker A: Yeah. The user will respond with a close upon which the Tcp can send a fin to the other. Okay, so in this case, all we really do is we just, like, act that they wanted to fin. So the question is, what happens here? Okay, so in this case, we're b. Ooh, what's close weight, though? So this doesn't mention that, but it looks like if you receive a fin, you should enter close weight. Oh, this is RLS. RlS works totally fine for me.
04:01:03.130 - 04:01:50.230, Speaker A: Sometimes a little slow, but that's about it. Okay, so in this case, we do want to go state is close weight. Okay, so close weight is another state, and it is also synchronite. So this is going to be state close weight. And in this case. Oh, I see. See, this is where we're sort of hijacking the, the setup a little.
04:01:50.230 - 04:02:24.670, Speaker A: Specifically. We're sort of, we're cheating a little here. Right? Because, because of this, you're gonna enter. We know that you'll be in fin weight. Like, this cannot happen because you must, you must get this first to get the connection to be established. So we're just going to do this and say this is unimplemented, because currently it can't happen. And then if we're in fin weight one.
04:02:24.670 - 04:02:50.870, Speaker A: And so that's this case, we close. We're in fin weight one. We send, we send our finnish. And now we're waiting for them to act. And at some point, they're going to ack our fin, and we're not going to let them send us any data. That's not something we support. Yet.
04:02:50.870 - 04:03:36.616, Speaker A: When we eventually get that, then we enter closing. Okay, so we're going to ignore close weight, but we are going to have closing. So this is, so here, sequence number 100. Sorry, sequence number 300 is where we sent our fin, which means that our fin is 301, because the fin is its own byte. So when they hear act 301, that means that now we know that we should be closing. Right? So down here, actually, this should be closing. So down here, when we get fin weight.
04:03:36.616 - 04:04:23.980, Speaker A: And this turned out to if this check was true, that means that the only thing they can possibly have act is our fin. Right. Because there's no other data, they. Okay, this is the same argument as here, that they must have act. Our fin says we detected at least one act byte, and we've only sent one byte, which is the fin. Let's make these wrap the same. How did I double exclamation mark this again? And so in this case, what are we supposed to do? We're supposed to ack their finnish, which we do with this.
04:04:23.980 - 04:05:05.310, Speaker A: Do we include fin in that? We're not supposed to include fin in that. That's gonna be awkward. I guess that means self TCP fin is false. And now we enter. Closing. And now what is this, though? Why are we receiving anything here? Like, why are they. What is this act at the end that seems really odd.
04:05:05.310 - 04:05:44.970, Speaker A: Close. And which we can send a fin to the other TCP. The TCP then waits until its own fin is acknowledged, where opponents deletes the connection. Okay, so at this point, we now enter time. Wait, so there's also not a closing. That's just a lie. Well, I guess, sort of.
04:05:44.970 - 04:06:23.256, Speaker A: It's like if is closing even in the diagram. The, like, giant diagram. Yeah. Then you send an ack, and if you receive anything, you go to time. Wait, I see. So if we're in closing, uh, how did this work? So we were in established. We sent a fin, and then we entered fin weight one.
04:06:23.256 - 04:06:39.430, Speaker A: Yes, yes. In fin weight one, we receive an ack of finnae. Yep. So it has fin set. Right. Otherwise unimplemented. And it is hacking at least one byte because of our checkup there.
04:06:39.430 - 04:07:05.560, Speaker A: Ah, then I see. That's if we receive a fin, which is not. We're gonna receive. We're gonna enter, then. I see. So in this case, we're gonna go self dot. State is fin.
04:07:05.560 - 04:07:55.650, Speaker A: Fin weight two. These are excellently named, but that's what they're called in the specs. So, you know, state fin weight two. Okay, so all we really do is when we get that axis, we go to finway two, and then if we're in finway two, then at some point, we're gonna receive a fin from them. Oh, I see. I don't think this check necessarily means that they must have act at least one bit bite. I think it means that they act a valid bite.
04:07:55.650 - 04:09:12.840, Speaker A: They could still. Ah, no, if they act no bytes, we would not get here. I think that's true, but that makes it a little weird, because it means that that fin that we get here is not going to act anything that we have sent. So it's not going to acknowledge bytes. So let's think about this, right? So if what are we requiring up here? We're requiring that they act. Yeah, they have to be acting at least one byte because of this check also doesn't write have to increment that. Oh, I see.
04:09:12.840 - 04:09:59.280, Speaker A: So here, we should also update. Does it say in right here that how we update these? Uh huh. That's fine. That's fine. Yeah. So my guess is they go through this in more detail here. Once the connection is established, data is communicated by the exchange of segments, retransmissions.
04:09:59.280 - 04:10:58.976, Speaker A: Sender data keeps track of the next sequence number to use in the variable send next. Yes, we already have that in our write function. That makes sure to modify send next. The receiver of data keeps track of the next sequence number to expect in the variable received next. Okay, so here we're gonna do something like, what's that even gonna be? Self receive next is gonna be, I think, w end. No, that's the end of the window. It's going to be seek and.
04:10:58.976 - 04:11:45.874, Speaker A: Oh, I see an error. This should be wrapping at of that. And I think, in fact, this is what the next, this is the next. So if we get through this check, that means that we received at least one byte, and now the next thing we're expecting to receive is whatever follows that. Right. So the sequence number of the first byte plus the length of the segment, which is going to be the first index that we have instead. Okay, so that's this sentence.
04:11:45.874 - 04:12:43.990, Speaker A: The sender of data keeps track of the oldest unacknowledged sequence number. Right. So up here at this point, we know that something got acknowledged, and so therefore our unacknowledged is going to be, again, if the data flow is momentarily idle and all the data sent has been acknowledged and the three variables will be equal. That's probably true. Okay, so is this true? So the ack value is the, the next byte they're expecting, which means it's the first byte that is unacknowledged. Yes. So this is true.
04:12:43.990 - 04:13:25.576, Speaker A: All right. When the sender creates a segment and transmits it, the sender advances send next. Yep. So that's here. When the receiver accepts a segment, it advances receive next. That's here. And sends an acknowledgement.
04:13:25.576 - 04:13:58.980, Speaker A: Right. So in theory here, we should also acknowledge that. Right. But we don't currently have a process for sending data or for doing things like timeouts. Like, we don't know that we need to act this, but we happen to act it because we write right here. So I guess, like here, make sure this gets hacked. When the data sender receives an acknowledgement, it advances Una.
04:13:58.980 - 04:14:32.330, Speaker A: Yup. Differs a measure of delay. The amount by which the variables are advanced is the length of the data in the segment. Sure. Okay. So retransmissions, communication of urgent managing the window is not currently something we're doing at all. That's fine.
04:14:32.330 - 04:15:08.004, Speaker A: Interfaces we're going to ignore for now, that's fine. It's talking about how send, receive and close should work. So that's something we'll have end up implementing as a sort of higher level interface after a while. Event processing. Yeah. So this is like a possible way to structure your implementation of TCP. That's fine.
04:15:08.004 - 04:15:49.606, Speaker A: This doesn't seem particularly important. I mean, this is probably useful, but it's just nothing what we want. So this, this does give us all of the, all of the state transitions are explained here, right. Like if you are given an open call and you're in the closed state, then do the following, which is pretty nice. And so in our case here, we're in, we're in these, like accept, I guess. But if receive in this, that's fine. This is not what I want.
04:15:49.606 - 04:16:23.830, Speaker A: In fact, what is it we want? What are we missing here? Finway two. I think that's the last part we were at. So where's our big diagram of all the things here? So fin weight two here. At this point, we now have to make sure that our fin has been act. No, sorry, Fin. Wait. One, as we wait for a fin to be act.
04:16:23.830 - 04:17:00.950, Speaker A: And so the observation is that we will never get to here, because up here we're gonna get a message that isn't acking anything, which is a little weird. Wait, if ack is send next. No, that's fine. Yes. It's not necessarily acknowledging. Okay. It's not necessarily acknowledging a byte because it's allowed to be equal to next.
04:17:00.950 - 04:17:58.910, Speaker A: But what if these values are equal? They can't be. I see. They're going to be acting. This is weird. Okay, so what I'm trying to figure out is, in this case, what we want is for if we get an ack, it should be acceptable for that act to not be acking any data because we might not have sent any data. Right. Which I think this check allows for, assuming that unacknowledged is always less than next.
04:17:58.910 - 04:19:32.020, Speaker A: Because if unacknowledged is equal to next, then there's no value you can give to ack. That would be okay, because it wouldn't be greater than unacknowledged. So the question becomes, what is unacknowledged set to if all your bytes are acknowledged? Acknowledged the oldest unacknowledged sequence number. Actually, maybe this specifies what we should do. So specifically, I want what happens on segment arrives if the state is. Listen sin. That's fine.
04:19:32.020 - 04:20:10.840, Speaker A: Yeah, so this is all the stuff that should be happening in our except. Okay, so this is actually kind of handy to read through set. Okay, so this is someone who's trying to connect to us. Basically set receive next to be the sequence number plus one. That's what we have. Ir's is it to seq. That's what we have.
04:20:10.840 - 04:21:16.574, Speaker A: Any other controller text should be queued for browsing later. ISS should be selected and a syn segment should be sent of the form. Sec is Iss, Ack is received next, which our write takes care of. Sequence number should be ISS, which is our sequence number is set to send next. And send next is sent to ISS and we set both syn and ack in the fields. Then send next is set plus equals one, which will be true for us because the payload is zero bytes and syn is set. So we add one una to iss and then, okay, so self dot send dot Una is already set up here for the sender to ISS.
04:21:16.574 - 04:21:45.984, Speaker A: Great. Connection state should be seen received. Great. So now we are receiving stuff in the syn received state. First check sequence number. Okay. Oh, interesting.
04:21:45.984 - 04:22:36.996, Speaker A: First check the sequence number. So not check acts first, even though the acceptable act check comes first. Initial test. On an arrival, there are four cases for acceptability. Okay, so this is okay if. Yeah, it's fine. So I think what we really need to do is just move this check down.
04:22:36.996 - 04:23:17.610, Speaker A: So the first thing that should happen is do a sequence number check. So that's the check we already have. That should happen before the act check. If an incoming segment is not acceptable, an acknowledgement should be sent in response. Oh, that's interesting. So to do, if not acceptable, send ack. All right.
04:23:17.610 - 04:23:46.860, Speaker A: After send the act, drop it and return. Simmons, idealize segment pinion. Next does not exceed the window. That's fine. Second, check the reset bit that we, or it's not set, then secured in presence, which we ignore, then check the syn bit. Oh, interesting. So the order here is really weird.
04:23:46.860 - 04:24:25.784, Speaker A: Yeah, that's an error. Fine. So now check the ack field. If the AC bit is off, drop the segment and return. How do you look for that bit even? Oh, I see. So down here we're going to do according to this. If not TCPH acknowled, then return.
04:24:25.784 - 04:24:50.390, Speaker A: Okay. Otherwise if we're in sin received. So this check is not even gonna happen. Hmm. Yeah, see here. So these states don't check for the, don't do the acknumber check. That's what I thought.
04:24:50.390 - 04:25:31.150, Speaker A: Sneaky. Okay, so if we're in sin received. So this is going to be, if let this or state established is self dot state, then we're going to run the act check, right. Because this is done for both of these. Oh, and soon received the check is actually different. Interesting. Okay, fine.
04:25:31.150 - 04:26:21.980, Speaker A: So in soon received we're going to do this. If not is between here. We're going to allow this to be wrapping sub one. If let this self dot state. So if this, then this. Great. Okay.
04:26:21.980 - 04:27:11.840, Speaker A: The segment is not acceptable. Form a reset else to do reset. All right. So that means this check is actually just like not what we should do. All right. So we'll leave that up there. And now continue processing.
04:27:11.840 - 04:27:54.930, Speaker A: Okay, what does continue processing mean though? I guess here. So now we're going to match on self dot state and if we're in state established. Right. Great. So that means that this, let's deal with this a little bit later. So this is the part where we want to close the connection. Right.
04:27:54.930 - 04:28:35.140, Speaker A: Specifically this means that here it shouldn't be possible for us to be in the state. If we're in established. Then we're going to make sure that this was a valid thing for us to get act. And then we're going to set that equal to akin. Great. And then there's a bunch of stuff we have to do here that we're not going to do for now. Except we are going to assert that data is empty.
04:28:35.140 - 04:29:37.820, Speaker A: Send windows an offset. Yeah. So this is recomputing the window sizes. And I guess actually here is what, where we want to do this. Then we're going to fin and enter fin weight if we're in fin weight in addition to the processing for the established state. Oh, interesting. Okay, so this, so I guess this is actually just if let.
04:29:37.820 - 04:30:36.584, Speaker A: Huh. It's interesting that these are actually sequential as opposed to, as opposed to doing all of them at once. Okay. And now we're gonna match self dot state if we're in fin one for fin is now acknowledged. So if self dot send, dot an a is equal to self send iss plus two. Yeah. So the reason this check has to be like this is we want to check that we have an acknowledgement for both the sin that we initially sent and the fin that we sent following it.
04:30:36.584 - 04:31:52.878, Speaker A: Right. Which means that the unacknowledged should be the byte following that our fin has been act. And in that case this is also if lethe, this is equal to self dot state, then self dot state is state fin weight two. And then up here it's if finway two. Oh, weird. Then in this state, if the retransmission queue is empty, the user's close can be acknowledged, but do not delete the tcp. Okay, that's fine.
04:31:52.878 - 04:33:02.860, Speaker A: So we won't actually do anything in the, in this case, what we will look for is presumably down here. Yeah, process, segment, text. So somewhere down here it's going to be like if tCPh fin, then here it really depends on self dot state. We're only going to deal with the case where state is finway two. And in that case we're done with the connection. Decent theory. And we shouldn't need a, to send anything more.
04:33:02.860 - 04:34:02.806, Speaker A: There is a question, though, of when we send our axe, which I think is going to be basically on timeout. Instead, I think we're going to eagerly ack that right here by doing this. Where's our right, this resets fin. Great. So this is going to put us into time. Wait, which is a thing that we don't have yet. Okay, so in theory, we now have like a full, I think we have a full circle now of being able to basically set up and tear down a connection.
04:34:02.806 - 04:34:43.404, Speaker A: There's no data being sent, but it does do the entire sort of handshake protocol, including both setup and close. So let's see what happens if we try to, oh, that's not too bad. Compare, wait. Oh, 286. Anything else we're gonna say is unimplemented. Ooh. I mean, I have no idea whether this actually works, but let's see what happens if we try to start this.
04:34:43.404 - 04:35:34.280, Speaker A: This. Huh. Okay, so we're gonna need some logging here, but it did get the syn ack. Oh, interesting. Why is it resending the sinhouse? That's very interesting. That makes it seem as though we're, like, doing something wrong. Specifically.
04:35:34.280 - 04:36:28.718, Speaker A: I wonder whether the, I'm pretty sure that act should be one. That's interesting. I wonder if we should try to fire up wireshark here, see what it gives us. So if we start this up on ton zero. Okay. And see what this gives us. So, GCP.
04:36:28.718 - 04:36:54.750, Speaker A: Aha. Sequence number zero. Acknowledgement number zero. Ipv four. Total length exceeds packet length. Oh, okay. Well, that's the first mistake.
04:36:54.750 - 04:37:28.014, Speaker A: It looks like the pay. Oh. The payload size should not include the IP header. That is totally true. Huh. But it sort of has, that's awkward. Minus self IP header.
04:37:28.014 - 04:38:06.740, Speaker A: Len as us. So the reason this is awkward is the size of the packages cannot exceed buff, including the IP header. But when we set how large the payload of the IP is, we should obviously not include the header. That's fine. So let's run that again and then restart this. Oh, why does wireshark not let me? Ah, no, this. No, I think it's confused.
04:38:06.740 - 04:38:39.610, Speaker A: Not what I wanted it to do. Well, apparently that's a not helpful. Huh. That is very weird. Why is. Why does starting Wireshark bring me to this? Wireshark is not running here. Very weird.
04:38:39.610 - 04:39:26.559, Speaker A: Okay, let's try that again. So, starting this watch ton zero. And then send a packet and then kill this. Okay, so now, this is right. And here, this sent sequence number zero, act number zero. Here we act number one and send number zero with our sin. Huh.
04:39:26.559 - 04:40:41.390, Speaker A: It could be the window is too small, but this is an act of the segment in frame two. Yeah. So that makes it seem like this act is correct. But why is it not acting back? Let's see. Oh, we have might be that this document can help us here. No, no, that doesn't seem helpful. Hmm.
04:40:41.390 - 04:42:01.210, Speaker A: All the values seem right to. I mean, I guess it could be that the window is just, like, too small, but I don't think that should make a difference. Hmm. Also, why is our program not responding to that? Like, when it gets the syn retransmission, I think it should really just respond to that, which it's not. So that suggests that in here. Here, let's do good old print debugging. Wait, what? So it never gets there.
04:42:01.210 - 04:42:35.070, Speaker A: So when we get a packet. Oh, we probably throw it away because we think it's. Yeah. Okay. So we throw it away. So, this is the case where if it's not acceptable when the word is supposed to act. So here, I guess what we could do is what we really want is let.
04:42:35.070 - 04:42:59.940, Speaker A: Okay. Is true. No, false. This is false. This is false. This is false. This is true, and this is true.
04:42:59.940 - 04:43:38.410, Speaker A: This can probably be simplified. This is more because I want to see what happens here. If not, okay, then we want to ack, and then we want to return. What do we want to do here? We want to do send. Next. C. Next.
04:43:38.410 - 04:44:39.904, Speaker A: So, I think this is just a write. What did I do? Right, so, let's see if we now start sending those acts. Yeah. Like it's even recognized them as duplicate axe. So why is it not accepting our. Is there, like, a d message for this? I don't think so. Huh? I don't know what's going on.
04:44:39.904 - 04:45:41.640, Speaker A: I don't know why it's doing that? I don't know why it's doing that either. Hmm. It's a very good question. Like actually let's do, let's try this first. Instead of doing this, do like that's gonna do loopback l 8000. That seems fine. And now we're gonna do this to 8000 on one hundred and twenty seven, zero, zero, one.
04:45:41.640 - 04:46:41.238, Speaker A: Let's look what that looks like. Okay, so that's what it looks like when you have a real one. And this is what it looks like when you're trying to do it to us. So what's the difference between these here? Oh, it's the sequence number of the I. That's what's wrong. Right. Like this needs to point to the first byte that we are sending and the sequence number of the first byte we are sending.
04:46:41.238 - 04:47:31.590, Speaker A: Why is that not zero though? Oh, the first bite in the payload. Oh, that's awful. So that doesn't include the sin. I see. So that's where we're wrong. So specifically what should happen is when we initially do this, the sequence number we should include is actually this plus one. So next up here is this plus one.
04:47:31.590 - 04:48:00.640, Speaker A: Yeah, let's try that. Oh man. Let's try that again. So watch that. And then this. No? Okay. How's it different this time? Seek is still zero.
04:48:00.640 - 04:49:39.396, Speaker A: Did I like not save the file? The sequence number is sent to self, dot send, dot next. Self, send next. Iss plus one. What am I missing? Hmm. Why is that still zero? Self Tcp sequencenumber is equal to self, dot, send, dot next. Please check that again. Also, why is there seq zero? Like why up here? Oh wait, no, no.
04:49:39.396 - 04:50:44.232, Speaker A: Even in the loopback case it's 0011. So the old behavior was the correct one. Question is just like, why is this not working? I wonder if this is like the Linux kernel. Because we are interacting with Linux here, right? Like the, the kernel is probably like requiring you to include some of this business. And because we're not specifically, it's this like secret value, whatever the secret value is. Ah, apparently nothing. Yeah, there's something, something weird going on here.
04:50:44.232 - 04:51:31.320, Speaker A: What we're comparing is like this packet, which is what the real server sends to all this packet number two. So of course there's a bunch of like more tcp headers that are being set in the other one. But the fundamentals seem to be right. Specifically, we replied to the correct port, to the correct IP address. We set seek equals zero, ac equals one. We set our own window length is zero. So what are we missing? Like there are other values here, but they shouldn't matter.
04:51:31.320 - 04:53:32.654, Speaker A: Hmm. Oh, it's window scaling. Like almost positive it's window scaling specifically just thinking back to this, right, which says things you must implement. RFC 1122 talks about where is it? IP transport protocols TCP unknown ports push window size urgent pointer TCP options must implement both sending and receiving. The maximum segment option should send a nemesis segment, must implement both sending and receiving. Yeah. Oh, interesting.
04:53:32.654 - 04:54:22.510, Speaker A: There are also errors in the state diagram. Yes, this is indeed using RLS, closing your connection, data communication. This is like congestion control stuff. Retransmissions, managing the window. Okay, that's fine. Okay, that's probing. This is all, none of this is stuff that matters.
04:54:22.510 - 04:55:47.240, Speaker A: Okay, so it seems like the only thing we're not supporting that this says that we must support is maximum segment sizes. Okay, there's an alternative explanation here, which is very stupid, which is that we need to compute this. I don't think that's the case. I mean, if that were all, that'd be great, but I don't think that's enough. That was all what? Why did this not give me an error saying the checksum doesn't match? Okay, so in theory, oh, I forgot to we start the server, we monitor it, we send this, and now, okay, now we correctly get the act. So we act them. They ack us.
04:55:47.240 - 04:57:22.690, Speaker A: We send a fin act. No, they send a finak. Oh, interesting. Why did they send a finak? Why aren't we the ones sending the finak? Oh wait, no, this just means that did we send it first? I thought we sent it first. They send an ack and they send a finack. Okay, so that's not actually something that we implemented, which is specifically if we are in the established state and they send a fin, were established and got stuff, and then I sort of want to do something like debug self TCP fin and probably also TCPh fin. So we never get to that.
04:57:22.690 - 04:58:47.930, Speaker A: Huh? Why do we not get to that? Wait, this shouldn't be a yes, this shouldn't be a no. That's why, great, try that again. Okay, so if we try to listen again now what? So, oh, okay, they sent a syn, to connect. We sent a syn ack. They sent an ack, we sent a fin and an ack of nothing. They ack our Finnish, they ak our fin, and in theory, wait, why is this, why is anything running on that right now? Let's try that again. They send us in, we send a syn ack, they send an ack now the handshake is done.
04:58:47.930 - 04:59:35.630, Speaker A: We send a fin acknowled. They send an ack, and then they send a fin ack that, in theory, we should respond to, but it looks like we do not. Or we probably just don't print anything, actually, is what's going on. Specifically in this case, we enter fin weight. And in this case here, they've closed. No, they've act our fin. And this is they finned.
04:59:35.630 - 05:00:08.190, Speaker A: Let's help ourselves with a little bit of stuff. Okay, let's see what happens. Establishing got stuff. So there's something still something we're missing. Specifically, we're not handling their fin. Right. So here is where we end.
05:00:08.190 - 05:01:31.552, Speaker A: Here is where they act that we finished. Here's where they tell us that they have finished, and now we're supposed to act them, and yet we're not. So the question is, why nothing got? So we do get a packet there. Are we just, like, throwing it away? That would be unfortunate. We're not throwing it away. This is the good old print debugging. Right? Okay, so we got packet, and then we did five.
05:01:31.552 - 05:02:24.360, Speaker A: Once we did 12345. So the question is, do we go in here? Well, we didn't do this. So this suggests that fin is not set in the packet we got from them. Although that seems odd, because wasn't that the whole point? Oh, that's that AK. Oh, I see. This is just dealing with their ack. But then the question is, why are we not getting.
05:02:24.360 - 05:03:53.030, Speaker A: Why are we not getting this fin? In fact, isn't this wrong? Why shouldn't they be acknowledging two? But regardless, why aren't we seeing the packet, I wonder? Because we're also not crashing. So. So what's going on here? Oh. Huh. Okay, so here, I just turned off here. I just, like, terminated the sender. And then we did indeed get true.
05:03:53.030 - 05:05:17.474, Speaker A: And then we panicked at 315 because we weren't in fin weight two. How are we not in finway two, though? I sort of want to compare this and this, because it seems like we're not doing that correctly. Hot packet with false. So if we do this, what do we get? We get. We basically only receive two packets. Okay, so what are those two packets? Okay, the first packet we got was this one. No, I don't think that's.
05:05:17.474 - 05:05:40.082, Speaker A: Wait, that's here. It's just confused. Let's try that again. Okay, so we got two packets. We got this packet and this packet. Both of them do not have fin. So the first packet is this one.
05:05:40.082 - 05:07:26.560, Speaker A: The second packet is this one. And it's true that this is not acking our fin, but why are we not receiving this packet? When we send this, we should still be receiving that, but it's as if we just never get that packet and in fact it's sent again later and we still don't receive it. Yeah, I don't know why we don't receive that one. I mean, the only thing I can think of is that main is dropping it. But like, I mean we could try. Seems a little odd. See, there's no packet that's being ignored and so we're just not getting, we're not getting this packet and I don't know why.
05:07:26.560 - 05:08:02.372, Speaker A: Like we're not receiving it all. After we send this, we don't receive anything. Hmm. There's no error either. What does work though is if I, if I connect and then I sort of terminate that connection intentionally, then, then we get a packet with. True. Hmm.
05:08:02.372 - 05:08:35.270, Speaker A: That's very weird. I don't have a good answer for that. Here. We do get a fin packet though. Okay, so here what I'm doing is I'm starting it and then I'm pressing ctrl d which immediately terminates the input. And so at this point you'll see what. Wait, did I not start that? I thought I did.
05:08:35.270 - 05:09:36.440, Speaker A: So if I do this, it's gonna do a bunch of stuff. Terminate that and then it crashes. This ak we don't get and the finak we don't get, or rather, yeah, we don't get either of those. See, we get one, we get one, two, we get two packets before this unexpected one, which is the version six packet. And then we get one packet which means we get one two, and then we don't get either of these. But then we get this one. I don't know why we're not getting these in between.
05:09:36.440 - 05:10:33.884, Speaker A: Oh. To 8000. So that's an old one, huh? Oh, I wonder whether this is just like old leftover stuff. Like if I now do like 9001 just to show the ports are different. If I do this, wait for one of those and then exit this. No, there's still, this packet really should be getting through, although it does, it does sort of go through here, I guess, but I don't know if that's the same. Let's print out what it is.
05:10:33.884 - 05:11:34.060, Speaker A: The ax, this TCPH sequence number. No, that's sicken. Ax TCPH acknowledgement number. Yeah. So we're expecting to see three packets, one, two, three with seq 11011 and ack twelve. What does it actually get? It gets. That's not a sequence number of zero.
05:11:34.060 - 05:12:06.030, Speaker A: I think this is like adjusting sequence numbers, which is not. Okay. This acts two. So that acts are sin no, axe one. Axe our sin. Axe two. Chidak or Finn.
05:12:06.030 - 05:13:11.480, Speaker A: So this seems like down here established, then una should be set to two at that point. So why is it not? We're establishing. Got stuff that x one. So the question is, this packet. This packet right here. Axe two. We're never keeping track of the fact that we act that packet, even though we should be in the established state.
05:13:11.480 - 05:14:03.940, Speaker A: Oh, I know why. It's because we. It's because we immediately try to terminate the connection right down here. We're immediately changing away from the established phase, and we're not doing this processing, even if you are in the finalized stage. So this should be state fin weight one or state fin weight two. And then we sort of only want this if let state a stab this self dot state, because this is sort of hacky, this part down here. All right, try this on for size.
05:14:03.940 - 05:14:26.600, Speaker A: Great. So now we realize that they've act our fin. And so now when this terminates, they've act our fin. Okay. We didn't crash, so that's good. What happened here? We sent the fin ack. They act that.
05:14:26.600 - 05:15:03.702, Speaker A: Then they sent us a fin act, which we eventually act. Nice. So, now that connection has gone away and we've gone full circle, sort of fully established a connection and torn it down. Right. Like, there's no. There's a TCP retransmission in here, which I don't know why. Things like, for whatever reason, we didn't act the first one now.
05:15:03.702 - 05:16:08.166, Speaker A: Okay, so I think we're gonna stop there for today. Let me get rid of these, like, eprints and stuff. It's still a question of why we never got there, but. Okay, I think we're going to stop there, because now we have a thing that can talk to a TCP client. It doesn't actually exchange any data yet, which I assume then is going to be what we'll cover in the next stream. Because then we'll need to deal with retransmit queues and timeouts for sending axe. We'll need to deal with congestion control and window sizing.
05:16:08.166 - 05:17:32.880, Speaker A: But at least now we have sort of the basic setup working where we can at least talk the protocol and handle the appropriate messages and send the appropriate messages and sort of see that everything goes through. I guess I'll push this. There's no reason, really, not to. Let's do TCP. A learning experience in implementing TCP and rust. Great, like so. And then we'll do, I guess we will do so.
05:17:32.880 - 05:18:43.160, Speaker A: Remote at origin this nice. Okay, so in theory all the code should be up there if you want to take a look. Okay, so what we're going to do is end the stream here because it's sort of a good breaking point where we have, we have sort of one cycle of a TCP connection working and then we can cover sort of data management and congestion control and all of that stuff in the next stream. I think the next stream will be in about maybe in about three weeks. It's a little hard to say, but the plan is to keep going on this, as you can see from implementing as well. There's a lot of stuff to cover here and a TCP stack is a non trivial effort that we're doing. So my guess is this will end up being three streams before we get to something.
05:18:43.160 - 05:19:34.740, Speaker A: I already have the key ssh added, but I have it auto expire. I don't like having key material in my memory. Yeah, there's a lot of COVID So my guess is that we'll go through probably three streams on this, unless either we get really far the next stream or people complain they don't want to see any more about it. But in either case my guess would be about three streams. And as always, if you want to vote on upcoming stream ideas, there's a site where you can vote. This is how we ended up doing TCP in the first place. Currently the next comer is to do another open source contribution stream, which was really fun, but that will then be not for quite some time because we still want to make some more headway on implementing TCP before we sort of leave that behind.
05:19:34.740 - 05:19:46.840, Speaker A: So in that case, I guess thanks for watching everyone, and I will see you next time. Bye everyone, thanks for watching. Bye.
