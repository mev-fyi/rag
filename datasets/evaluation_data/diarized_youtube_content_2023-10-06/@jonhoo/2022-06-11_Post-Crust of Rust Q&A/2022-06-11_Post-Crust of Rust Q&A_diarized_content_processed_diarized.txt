00:00:00.280 - 00:00:26.857, Speaker A: This is the Q and A following the sentence sync video. So if you're watching this afterwards, this will be a separate video. So I'll link to the sentence in video here just in case there are questions that come up that are related to that. But otherwise I figured I would just do a sort of general Q and A. If you have questions, then ask me questions. You should now be seeing my face. I think just this is for chat.
00:00:26.857 - 00:01:19.635, Speaker A: If you're watching this video on demand, it must be very weird, me just going, you should see my face now, because obviously you're seeing my face. So yeah, I figured I would take, you know, some time to chat about Rust more broadly about. About the book, about, you know, anything you want, really. I have a struct with an arc string and a constant pointer in it. Is that sender sync or if not, how can I make it? No, if it has a raw pointer in there, then it is not send, it is not sync. So you would have to write the unsafe impulse of send and sync for that type. Do you plan to do a stream only about your current setup? I really hope so.
00:01:19.635 - 00:01:53.353, Speaker A: I probably will. I've gotten a decent number of requests for this. I do have a video about my current setup, but it's like a year and a half old now, so it doesn't really match my current setup anymore. My config files on GitHub are still up to date. Like I still push there whenever I make changes, so those are still up to date. The biggest changes I've made is I use a different window manager now. So instead of X monad, I use the binary space partitioning window manager bspwm.
00:01:53.353 - 00:02:29.669, Speaker A: I'm very happy with that one actually. It's very simple. It tries to not have features, which I kind of like. And I use the native neovim LSP with Rust Analyzer. I'm not using the COC plugin anymore. Apart from that, my setup is still very similar to what it was. Have you heard of the work on Safe Transmute? Yeah, I'm very excited about Safe Transmute.
00:02:29.669 - 00:03:18.989, Speaker A: There are definitely places where this comes up, especially in things like parsing or. I have also seen it in places where I want transparent new types where those represent particular guarantees being held and then I want to be able to transmute them out to the type without the constraint. Like, I don't just want to deref to the inner type, I want to actually give away the inner type, which like, you can do. There are other ways to do this, but the transmute would Be nice for certain cases of that too, But I don't know how far along that work is. The map behind me is of Spain. It is a map of the. Let me see.
00:03:18.989 - 00:04:03.415, Speaker A: I think it's the. It's a topographical map of Spain from like 1882 or something. 1879. It is specifically this map. I'll put it in chat. How do you spend time outside of work? You know, it's, it's. It's been tricky over the past couple of years because, you know, Covid makes things meant that there was a lot of stuff I couldn't really do outside of work in terms of like actually going places and seeing people.
00:04:03.415 - 00:04:46.815, Speaker A: I did start trying to learn to play the piano. I wouldn't say I've made a lot of progress, but it's been really fun and a little bit humbling. I'm also really excited to get to pick back up. So I've helped partially develop and a lot of playtesting, primarily for this social deduction board game called Blood on the Clock Tower. And I used to run a lot of games like that in Boston where I would sort of go to gaming meetups and stuff and run the game. And that was a lot of fun and I'm really excited to get to pick that back up again. I've had some people reach out to me in LA and sort of the areas around wanting me to come run games for them, and I'm very excited to start doing that.
00:04:46.815 - 00:05:44.825, Speaker A: Same with Rust conferences starting up again, I'm hoping the Rust meetup in LA is also going to pick up Steam again and go in person in not too long. I think that would be really fun too. For me, it's weird, you know, like, outside of work, I like doing programming, teaching and Rust, which means it ends up being somewhat similar to what I do at work. But it's because I enjoy it. Right. Do you feel like you've learned a lot about Rust, the language and the ecosystem since joining AWS and the Rust team there? Do you have any examples? So the answer to that is a little mixed. The reason being that my position at AWS is more around enabling other people to use Rust and making that experience be as pleasant as it can be.
00:05:44.825 - 00:06:37.869, Speaker A: My sort of goal is to make the experience of using Rust internally at AWS as good or better than the experience of using Rust outside of aws. And there are a lot of constraints to internal development that make that difficult. And I don't think we're there yet. What I've learned a lot about is more about the tooling, like how Rust itself is bootstrapped, how Cargo does version resolution and configuration, how Rust up is configured, those low level bits that aren't really about Rust itself, but about the tooling around it. Because that ends up being a big part of my job. I don't know that I've learned that much about Rust the language from being at aws. Some maybe, but not so much.
00:06:37.869 - 00:07:19.845, Speaker A: By virtue of my position, I've certainly learned a lot more about the ecosystem or about the infrastructure that makes Rust work and that's been really fun. Most recommended Rust GUI library I don't really have one. I've done basically no GUI programming in Rust. I've heard good things about egui and I've heard really good things about Bevy, although it's more of a game engine, but I don't really have good recommendations there. I know there was a. There was an interview recently with the maintainer of EGI on the Rostation Station podcast, so maybe give that a listen. That might give you some good pointers.
00:07:19.845 - 00:08:10.155, Speaker A: Where would be a good starting point adding support for a new OS to Rust? That's a good question. I think where you would start is assuming that your target architecture is already supported. What I would look at is the path that was taken by Redox because Redox was also an OS written from scratch and they had to introduce that into the operating system. Sorry, into Rust. And so you might actually want to start with find the PR that first added Redox support to Rust and see what they did and then try to mirror that. That's what I would do. Is there a way to use COW like strings for data shared between threads? COW like strings? I mean you could just use arc.
00:08:10.155 - 00:09:22.355, Speaker A: I might be misunderstanding the question, but my take here is use arc. My color theme is called Groove Box. What kind of work are you doing right now and is your team hiring? Yeah, so as I mentioned, my work currently is on making the internal Rust developer experience as good as it can be, which spans everything from internal education and documentation to improving Cargo itself. So that build issues that people run into internally, we can actually fix upstream and then bring those in internally to figuring out how to make all of the internal configuration and tooling interoperate nicely with all the expectations that all the Rust code out in the wild there has to figuring out how do we keep track of changes to crates, IO and mirror those internally. There's all sorts of that kind of work. We were hiring very recently, but I think now we got the people we need. I'm really excited to see how that team is growing.
00:09:22.355 - 00:10:21.069, Speaker A: Like the moment we're hiring again, I will make sure to, you know, tweet widely about it again. Conversation came up today. Is it safe to cast a pointer to a usize and then cast the usage back to the pointer and then read the pointer? No operations performed on the usize and the value itself is not moved. So this is the question really about pointer provenance, and pointer provenance is complicated. The basic answer is no, but it's not no for the reason you think it is probably going to be okay, but you should probably avoid doing it. And the reason is because of optimization passes the compiler might make and assumptions it might make about that pointer after it's been turned into usize. Specifically, the way in which it might not be okay is you might end up seeing your code be less optimized because you did that.
00:10:21.069 - 00:11:19.453, Speaker A: It's less likely you'll run into undefined behavior. Although it's a hairy topic, what I will do is send you Let me find the tracking issue. I would start reading over here and in particular read Ralph Jung's article on provenance and that gives you some idea of where this gets complicated. But I think what I would say is you're going to be better off not doing that or doing that in a more supported way than just doing the casts. Good work on the book. It's really good. Thank you.
00:11:19.453 - 00:11:58.975, Speaker A: It was. It was a lot of work, but I think I'm excited about where it landed and it seems to be helping people. Oh, is my setup video 3 1/2 years old? I thought it was just like a year and a half or something, but yeah, I guess it's been a while. All right, I'll do a new one. I need to do that. Did you follow the discussion about Rustus? Hard from hear a lot that lately happened and the following blog point entries so I saw the article. I didn't read it very thoroughly.
00:11:58.975 - 00:13:07.205, Speaker A: Arguably I should, but I've had other things to read. So the high level argument I make here is that there are some things that are really annoying to do in Rust because of the combination of a strict and complex type system and the fact that it's a young language. One challenge you have when you have a complex type system is that it puts much more stress on the compiler to handle many more combinations of factors and give good errors in those cases and handle all the edge cases. Right. And Rust is fairly young still, and so there are a decent number of those edge cases that we just don't handle well or don't have good constructs for. And that is painful, there's no doubt. But I don't think the answer is give up on the strong typing and the complexity that that brings, but also the value that that brings.
00:13:07.205 - 00:14:13.535, Speaker A: But that's a very general answer to your question. I don't have specific for those articles. Why was scope threads removed from the standard library? Scope threads were removed from the standard library because it turned out that it wasn't safe. And I think the reason stem down to the fact that in Rust it is safe to forget a value from memory. Scoped threads relied effectively relied on the fact that the destructor would be run which would like block the calling thread. But that doesn't work if if you just forget the guard that you get back from the scoped spawn. The way that this is fixed in the new iteration of the scope thread API, I believe is that you pass in a closure and you can only spawn scoped threads in the context of that closure and therefore there's no value to forget.
00:14:13.535 - 00:15:37.655, Speaker A: It's just when the closure returns then all the scope threads will have exited and therefore that the closure to that, the closure you pass to the scope thread is allowed to borrow from the surrounding scope. Sort of the basic idea for the design is there support for debugger breakpoints and asic rust functions. If so, I'm probably going something wrong. So debugging async rust is a little weird because the way that execution of these things work is that they're executor threads that run the future until it yields and then picks up something else. So if you try to put a breakpoint in a future, it will work in that the breakpoint will be hit when an executor picks up that future, but it becomes sort of useless because if you continue through the execution of that, the moment it yields, your debugger is going to continue not from the next time that future gets picked up, but it's going to continue with the executors main loop which is going to be sort of moving into executing some other future. So it's sort of complicated in that breakpoints do work, they just don't really do what you would expect them to do. We don't have a great solution for this at the moment.
00:15:37.655 - 00:16:41.749, Speaker A: It would require a debugger that either knows to follow the execution chain of a future as opposed to the execution chain of the thread, which works better in a language that has a runtime that can actually manage that for you than in a language that doesn't have a runtime like Rust. There are also efforts like the Tokyo console, which aims to give you more insight about how your code is executing, but it doesn't give you interactive debugging. So there's definitely a hole missing there, so you're not sort of going wrong there. But breakpoints should work, right? Like, one thing you could do is you can set a breakpoint in your async function and then set a break point immediately after its next await before you continue. And that way when you continue, it'll keep running through that future, then go back and do all the other executor thread stuff. But when any executor picks up the next the future after the await point, you'll get another break point again. It's, you know, it's a little annoying, but.
00:16:41.749 - 00:17:29.755, Speaker A: But it is doable if you really need to do you plan to write more books about intermediate or advanced Rust? I don't have any immediate plans to do so. It was a lot of work and it's also I have to feel like I have enough to say on the topic. I do think that, you know, realistically there are going to be revisions of Rust forestations. You know, things like if new features are added to the standard library that are particularly relevant and need to be added. Or I could totally imagine there being a chapter on something like WASM down the line or Inline assembly because those weren't stable at the time. Or Assembly Inline assembly wasn't stable at the time. And WASM I didn't know enough about at the time to really write a chapter about.
00:17:29.755 - 00:18:43.885, Speaker A: If I ever wrote another like full book, I I think it might be on developing documentation, but I don't feel like I have enough answers to actually write a book about it. Is Rust becoming niche only in the crypto field? No, I think Rust in crypto is a particularly loud field, but it's not the main field for Rust. Is there a trait that describes when a type owns all of it data, all of its data, I.e. it contains no references and none of the members contain references? No. The question is why you care. So the closest you get to something like this is if a type is tick static, then you know that you will be able to keep using it no matter how much you move it around. So that's sort of the closest you kind of get, like maybe tick static plus unpin or something.
00:18:43.885 - 00:19:37.985, Speaker A: But in general I urge you to not so much think about whether something is owned as what do you want to do with the value, because that's the property that you should express in your trait bounds rather than some abstract notion of I want to own the value. Are you going to submit a talk to Ruskonf? It's too late to do so, but no. There is a talk that I'm sort of noodling over that I might want to give on. And I tweeted about this the other day about good reasons to avoid Rust. I don't know whether that is going to be the exact title, but it's not intended to be a clickbaity title, even though it does sort of sound that way. I actually want to give a talk where that is the content is. These are actually good reasons to avoid Rust.
00:19:37.985 - 00:20:33.895, Speaker A: Avoid might be the wrong word. I haven't quite decided yet. But the basic premise of the talk is that I think there are two groups that I want to address with the talk. One is people who are thinking about choosing Rust and might find themselves with problems they didn't anticipate because they didn't know enough about the trade offs involved and the sort of drawbacks that Rust does have in certain areas. And so they sort of choose Rust and then are unhappy about it. And I want to talk to those people and give them, make sure that they go into it sort of eyes wide open. The other group are people who choose to not use Rust or choose to not consider Rust, but they do so for the wrong reasons, right? Like the reasons why they don't pick up Rust are either not applicable anymore, easy to work around, or not quite as severe as they thought.
00:20:33.895 - 00:21:42.721, Speaker A: So I want to make sure that the people who choose not to use Rust choose not to use Rust for the right reasons. And consequently, you know, this does end up being a sort of talk of you should choose Rust for many things, but it does so by saying these are the sort of only reasons why you should be hesitant. If there are other reasons you're hesitant, they are probably not as important as you might think. Of course it's tricky to give such a talk because like, who am I to say that the, the problems you thought about are not valid? But I do think it's valuable to say, you know, here are, you know, the, the real deep trade offs you're making that, that are harder to reverse decisions on the Redox route is quite the rabbit hole. Be warned. I, I think adding any OS support to Rust is a bunch of work. I guess Redox was in a weird place because the OS itself evolved over time.
00:21:42.721 - 00:22:39.965, Speaker A: But I think adding anything that's not like one of the existing oss is a, is a pain. You know, like adding something that's Linux like is not that painful. Adding something that's Windows like is not that painful. Adding something that's completely different is going to require you to basically write all the glue to, you know, translate between what, how the Rust standard library represents types and how your operating system internally works. I know that, you know, for the Rust standard library, one of the places where we ran into this was the standard library is kind of unixy. It's not as unixy as you sometimes see in other languages, but it is kind of unixy. And so the Windows standard library implementation is more convoluted, I think, in general than the Linux standard library implementation, because there's a slightly worse fit that you need to work around.
00:22:39.965 - 00:23:34.985, Speaker A: Do you think that Rust will be as capable as other languages like Java for web development at some point? When would you say it could be ready? I think it's ready now. I think the biggest reason to hesitate for Rust for web development is more around the fact that Java. I don't know if Java is the best example here, actually. I don't think Java is great for web development either. But there's a lot more infrastructure and tooling and sort of ecosystem bits that surround Java that have built up over the years and we have relatively less of that in Rust. Um, but I like, I think Rust works pretty well for web development, to be honest. Um, so I, I don't think there's a reason to sort of avoid it right now.
00:23:34.985 - 00:24:15.655, Speaker A: Um, how'd you get Rust Analyzer not to swallow all your ram? I haven't looked at my memory use in years, so I haven't had a problem with it, I guess. Um, part of this is also I run a fairly minimal os, right. I don't run any Electron apps, which tend to eat up a lot of things. I use Firefox, not Chrome, which tends to be slightly less memory heavy and so. And my editor is Vim, so it doesn't really use memory either. So Rust Analyzer has a lot of memory it can eat through, so maybe that's the real answer. But yeah, I haven't really had a problem there, so I'm slowly catching up to chat.
00:24:15.655 - 00:24:54.235, Speaker A: Are there good neovim tutorials you can recommend to get productive with this editor? Not really. There are some really good VIM tutorials. Like there's one that's called Vim Adventure or something. I've never played the full thing, but it is, it is A game that you play using the VIM key bindings. I don't know how much you know that that actually sticks in your head over time. But, you know, I've. I think the way that I ended up learning them was start with an empty config.
00:24:54.235 - 00:25:27.865, Speaker A: You'll see a lot of like, oh, here's my thousand line config. Start from there. Or like this installs all the things you need. Start with an empty one and then work your way up for, you know, the essentials that you need. For me, that's things like, well, actually the first thing I did was I disabled the arrow keys in vim, so I cannot use the arrow keys in my VIM setups. And that forced me to start learning key bindings. You could also disable mouse support.
00:25:27.865 - 00:25:52.805, Speaker A: That tends to help too. And then you start adding, okay, I need a plugin for language server integration. And then you follow the instructions for that. Maybe you need something for syntax highlighting and so you add that. But in general you don't need that much stuff. If you look at my VIM config, there's a bunch of stuff there, but it's all stuff that's been added incrementally. Don't try to adopt it all at once.
00:25:52.805 - 00:26:46.045, Speaker A: Why is Forget safe? Okay, so this was a big discussion prior to 1.0. The reason forget is safe is because you can implement forget using entirely safe code. Specifically, what you do is use RC to create a cycle of reference counted things and then you drop your last reference to it. But they both have references to each other, so neither of them get dropped and there's no unsafe code involved. So forget must be unsafe. Forget must be safe because you can express the operation it does using only safe logic. What is idiomatic way to communicate between two processes that are written in Rust and one was spawned by the other? I'm finding using standard in to do it a little awkward.
00:26:46.045 - 00:27:25.515, Speaker A: The best way I know of for this, I mean, this is a more general question about OS primitives on Linux. The way you would normally do this is using either a pipe where you hand off the read the. So when you create a pipe, you get two file descriptors, one as the in and one as the out, and you can dupe that as many times as you want. You give away one of the file descriptors to the process you spawned. You keep one in the one that is the parent process, and then they communicate over that. That way both processes still have, you know, independent standard instances and such. The other way you could do it is setting up shared memory.
00:27:25.515 - 00:28:24.825, Speaker A: You know, use the shared memory primitive of the operating system and then you need some way to safely interact with that shared memory because they both have mutable references to it. But those are sort of the primary ways. I don't know that there's sort of a one idiomatic way to do it. Do you think it's better or wasting time to learn C before Rust? I think that's a waste of time. I think it's actually only going to confuse you because if you learn C first and then try to pick up Rust, you're going to try to map C concepts onto Rust and it doesn't really work that way. Some things in particular look similar, but aren't, and then they're going to come back to haunt you and you're going to end up having to unlearn some of the things you learned. I don't think there's an advantage to doing it that way unless you specifically need to know C for something.
00:28:24.825 - 00:28:56.237, Speaker A: But even then I think I would actually learn Rust first and then learn C, because chances are you're going to end up writing better C. That way NLL is going to be completely stable recently. Will this change the Rust programming experience much? It shouldn't change it at all. There might be some diagnostics. You see change a little bit as the borrow checker doesn't fall back to the legacy one. But in general you shouldn't notice any difference. We've been using NLL for a while.
00:28:56.237 - 00:30:05.965, Speaker A: It's just been possible to sort of opt in and out of certain aspects of it, but in general you shouldn't notice. This isn't like, you know, the move to Polonius, which has something that's been on the books for a long time but, you know, is still far off. It's not that kind of, you know, major transition or like when we initially get and got nll, this is almost more of an internal implementation detail changing. What country would you choose to live in if you went back to Europe? I mean, this is a. It's a timely question because I think realistically I'm probably going to move to Europe in a couple of years. I'm not generally like a huge fan of living in the us. I've also lived here for a long time now and I want to go elsewhere, but I do find that I miss Europe a decent amount.
00:30:05.965 - 00:30:37.605, Speaker A: I think for me, the top contenders are Norway and England. Norway, because I'm from there, but also I like Norway. Like, there are a lot of things about Norway as a. As a country to live and work in, that. That I appreciate England because I really like London as a city. It. It's a big city, but it also feels small and local and that that combination appeals to me.
00:30:37.605 - 00:31:08.981, Speaker A: Brexit made the desire to go to England lower and make that journey a little harder, but it's very much on my radar and it could very much be that I end up moving there. That said, there. There are a bunch of countries in Europe that I really enjoy being in. I don't know whether I necessarily would move there, but, you know, never say never. I like Spain a lot. I've been a lot to Spain. I like Greece a lot, especially, you know, out on the islands.
00:31:08.981 - 00:31:43.485, Speaker A: Like, I could totally see just living on an island outside of Greece and just, you know, programming on like a terrace overlooking the Mediterranean. That sounds pretty nice. I like Germany actually as well, although I. I've only been there for shorter stints of time, so it's hard to say that it's a place I would like settle without more of an experience. Same with Scotland, actually. So Scotland. I think the biggest problem with Scotland for me is it's a little too small.
00:31:43.485 - 00:32:29.125, Speaker A: I like cities. I like being in larger cities with more people. And, you know, Scotland doesn't. Doesn't really have that. I've heard good things about Finland, but I've never been. But yeah, I think realistically, probably Norway or England, it's safe to concurrently mutate disjoint parts of an array because you never actually touch the same memory locations. Is there a safe way to write that code without using unsafe? Yeah, in the standard library on slices, there is a split at mute method which lets you do exactly that.
00:32:29.125 - 00:33:33.675, Speaker A: You give it an index and it gives you a mutable slice to everything before the index and immutable slice of everything following the index that are separate boroughs but into the same array. Any updates on the hazard pointer series? So the hazard pointer library now is basically done like it's on crates. I know now there are certainly things that could be improved. Like I still think the documentation could do some improvement. I've done a lot of tweaking to the API, so I think it is a lot nicer or more ergonomic to use now. There are a couple of things I still want there that, you know, who knows when I'll get around to it or it's a great opportunity for someone else to try is I want to port over many more of the tests and the benchmarks from Flurry to build a Little more confidence in its correctness and the performance of it. But in general, like it should work pretty well.
00:33:33.675 - 00:34:17.575, Speaker A: And please do try it. Move to Switzerland. I have been to Switzerland actually. I, I like Switzerland too, as a German cannot recommend Germany. The Netherlands too. Oh yeah, the Netherlands is a good point. I have thought a lot about that too.
00:34:17.575 - 00:35:07.612, Speaker A: I think I could really like it there. It's. It's sort of similar to Norway in many ways in terms of the sort of attitude of the, the country towards many aspects of society. So maybe quite possibly someone's in chat is complaining about the Internet in Germany being bad. And let me tell you about the us. It is awful because there's no, there's basically no provider choice here and all the providers are cable companies that charge insane amounts of money for garbage connectivity. Like, okay, I currently pay $80 a month for.
00:35:07.612 - 00:35:50.693, Speaker A: I think it's, it's either 50 or 75 down and one up and goes out all the time. It's unreliable. The latency spikes every now and again. Suddenly I just get a bunch of packe us. It's just abysmal and you know, compared to other parts of the civilized world, like that's not good. The Internet in the UK is horrible outside of London. Oh yeah, I believe that.
00:35:50.693 - 00:36:11.013, Speaker A: I mean that's also why I would live in London. I wouldn't like. I like the countryside in the UK too, but that's not, I don't think where I want to live. If I wanted to live like on the countryside, I would just move to Norway. Yeah, one up is awful and it's awful because I do streaming. But there's no option for me to get more upload speed. There just isn't any.
00:36:11.013 - 00:36:45.241, Speaker A: And it's garbage. Yeah, see, Â£40amonth for one gigabyte, both directions. That's what I want. What I really want is there's a provider in the US now called Starry. They use like point to point antennas on roofs to give connectivity and they give like much better connectivity at lower prices and I really want them. But they're not here. They're in the area I live.
00:36:45.241 - 00:37:33.257, Speaker A: They're just not in my house. So I can't get it yet. And this has been the case for like the two years I've been here. Makes me real sad. Do you see yourself getting bored with rust and using another language and if so, which one? It hasn't happened since I started rust. I started picking up rust in early 2015 and so it's been a fair few years now and I'M still not bored. I think there's a chance that I'll start exploring other languages to sort of learn from them and just fiddle with it again.
00:37:33.257 - 00:38:26.115, Speaker A: I do enjoy language development. I haven't seen any that are particularly compelling to me. I think the ones I would probably look at are like, I think Zig is worth taking a look at. I want to experiment with D and I also want to try my hands as something that's more, you know, formal, verification oriented. Something like Daphne or COC or F Star. But you know, I don't really have a good use case as part of my problem that I could make up a project to try to implement in them. But why? The reason I started fiddling with Rust was because I was like, I like writing concurrent data structures and Rust seems like it's going to be better for that, so therefore I want to try it.
00:38:26.115 - 00:39:13.455, Speaker A: I don't have a similar motivating example for trying out these other languages. Beyond it's fun to try languages, but that's not a very strong motivator for me. It used to be, but less so now. How do I come up with cool, challenging project ideas? As a beginner in Rust, figure out things that you want. Like, think about your normal workflow and be like, hey, what am I missing? What do I. What do I lack? Or what is broken? Start from there. Always start from your own needs, because that's going to give you much more motivation than just trying to come up with something random.
00:39:13.455 - 00:39:46.565, Speaker A: And you know, it can be stupid. It can feel like, oh, I just want this stupid thing. I want a library that does this. Or let me see if I can figure out how to do this. Even if there already exists a library or a tool for what you want, try to write it yourself and you'll find that like, every problem ends up being challenging at some point, especially for a new tool. Language Language. What do you think of C now? Do you think the language has a future in the long term? I don't think C and C are going anywhere.
00:39:46.565 - 00:40:35.943, Speaker A: I don't think the goal of rust is like 100% adoption. I don't think there are perfect languages in that regard. Like, there's a reason I want to give a talk on good reasons to avoid Rust, right? It's because I believe there are some. I don't think there are compelling reasons to start a new project in C, with the exception of you need to interact with an existing C API that is large and complicated because there, you know, the interrupt story is just not there. You can do things like use the CXX crate to get a safe interface between the two, but it requires a bunch of work on that. That interface part, you know, you can. Some of it you can express through pure C ABI and then FFI works pretty well and bind gen works pretty well.
00:40:35.943 - 00:41:07.051, Speaker A: But, you know, it's. It's gonna be a. There's gonna be friction in that interface. And you know, if. If what you're building is fundamentally you're building against a large C code base, you're gonna want to do it in C. But that's not really, you know, a redeeming quality for the language as much as it is like a. The reality of writing software is that sometimes you have to be pragmatic rather than choose what is the better choice.
00:41:07.051 - 00:41:50.125, Speaker A: Right. Do you have plans to visit Brazil? So I really want to go to the next Rust Latam, but I don't know when it's going to happen. I don't have any specific plans to visit Brazil, although South America is one of the places where. One of the continents that I haven't been on. And so I do really want to go, but I don't have any concrete plans. No. How'd you get confident in teaching? It's a very good question.
00:41:50.125 - 00:42:34.741, Speaker A: I don't actually know. I think for me, the maybe where it comes from is like, I'm fine with being wrong combined with just doing it over and over. Like, I think it's very easy to be scared of making mistakes when you're trying to teach right. And I think you need to shed a little bit of that fear both because if you know the stuff well, you're not going to make that many mistakes. But also if you make mistakes, it's okay. Just make sure you have a process for it. Acknowledge your mistakes after the fact.
00:42:34.741 - 00:43:13.025, Speaker A: Make sure you point out that you're not a perfect human being either. Or in my case, for some of the streams. There are times when we implement things and I just get stuck in a rabbit hole because I made some silly fundamental mistake. And that's okay. That's, you know, part of the experience. Or, you know, if you, if you don't do it live, like, arguably I'm stupid for doing it live because it means that I don't get to edit out all the parts where I look stupid. But I've tried to adopt that as a positive in terms of, you know, this is.
00:43:13.025 - 00:44:10.147, Speaker A: I think you can learn from people making mistakes too. And I don't want to hide the fact that I make mistakes because I think it's a valuable almost life lesson that, you know, even though you might see a lot of people who seemingly do things perfect the first time, very often there's all this complication behind there that you don't see of practicing, making mistakes, doing it over and over again. And teaching is the same thing. Have you decided the topic for the next live stream? How about unwind safety? Unwind safety is pretty niche, but it is interesting. I think realistically the next one is probably going to be on build scripts and outbound ffi. Like I did a Twitter poll of, you know, the. And that's how the votes panned out.
00:44:10.147 - 00:45:06.049, Speaker A: And I think that matches, you know, the level of importance I would assign to these. I would also, I think after that maybe do something on the collection types. And the reason I thought of the collection types in the first place is because it's kind of obvious once you've worked with Rust for a while that you're going to reach for different collection types and you sort of know about these crates in the ecosystem that might fix your problem. But I think when you're in your starting phases or even if you're coming to Rust from another language and you have a bunch of experience, you might not know that all of these exist. You might not know to look for them. You might not know quite how they differ in their APIs and their expectations and what they allow you to do and so. And some of the tricks for using them.
00:45:06.049 - 00:46:22.671, Speaker A: Like, you know, what's an example of this? Like the standard collection heap is a max heap, but if you want a min heap, you can wrap all your values in the reverse type and the reverse type from the standard compare module will is a new type transparent wrapper where all it does is invert the meaning of the or trait. And like, stuff like that is, you know, I know it because I've painstakingly found out. But it's not obvious when you start out and I think it would be useful to cover some of those, you know, neat things are Async Rust. I wanted to ask about whether async runtimes are a better abstraction for concurrency or do you think threads are still the best? They're different. I don't think there's like one that's better than the other. I do think that the sort of green threading model is. Is better for composability.
00:46:22.671 - 00:47:08.405, Speaker A: Like, I think the big thing it buys you is that it becomes a lot easier to interleave computation and to interleave IO and to do things like programs often need to do of thinking about multiple things at once. Things like, you know, I want to wait for either the network to do something or the user to press enter. Like those kinds of things are kind of fundamental to many, but not all programs. But when you have ones that match that, then Async excels at that. And doing it with threads is really annoying. That said, there are cases where you don't really need that. Like you don't really have a need for concurrency, you only have a need for parallelism, in which case threads are a great choice.
00:47:08.405 - 00:48:18.235, Speaker A: Like, they are a simpler conceptual model. I think where people sometimes run into traps is you start out with what seems like a simple problem, and so you go, all I need here is threads. And then over time you discover that, oh, I actually need to also do this thing. I need to also have control over shutdown, I need to also handle timeouts, I need to also handle signals, I need to also, you know, block on user input. Or I need to also handle key presses, or I need to also issue all of these requests and wait for them all at the same time. And you start layering all these addition all this additional complexity on top of the threads that you have responding new threads for all of them. And it's not clear that that sort of tower of custom complexity is better than what you would get with the more complex, fundamentally, but also more principled and battle tested that you get with something like an Async runtime.
00:48:18.235 - 00:49:30.289, Speaker A: And it's very hard to know in advance whether you're going to end up with a system that requires the complexity of Async, or whether you're always going to be simple enough, that threads are going to be good enough might be a vague question, but what do you think of Rust's role in cybersecurity? Do you think programs inherently become more robust and secure if written in Rust? I do. I do think that Rust, you know, this is the sort of classic argument for Rust, is that memory safety by construction, by construction is arguably false here. But the fact that Rust gives you memory safety for free in so many more situations is a very good property for security. It defaults to giving you more memory safety and more thread safety. That doesn't mean that Rust is secure. Like if you wrote it in Rust, it is secure or is safe or is correct. But it does mean that there are fewer common gotchas you need to know about.
00:49:30.289 - 00:50:17.679, Speaker A: Like, it eliminates more things on your behalf than in, you know, if you wrote it in some other languages where you would have to think about all of these problems yourself. You get to offload some of the safety thinking to the compiler, to the type system. So I do think it meaningfully sort of raises the bar on security and safety and correctness. But I don't think it's by any means a sort of perfect tool. And I think it's important to not think of it as a perfect tool because then you might become sort of overly lax about how you think about the security of your programs and just go, oh, I'm using Rust, so it's fine. And like, that's not true either. It just tips the scales more in your favor.
00:50:17.679 - 00:50:48.661, Speaker A: More so than you know. You don't have to think about it at all. Where do we drop stream ideas? 1 on Rust C development would be amazing. The best place to do it is actually just to tweet them at me or mastodon them at me. Like, if I. If I see stream ideas, I will generally write them down. I have a little doc of, of, like, all the various stream ideas I have, so I would just add them to that.
00:50:48.661 - 00:51:37.185, Speaker A: I used to have this, like, voting site, and I do still have the data from it. One problem that came out of that was some of the ideas end up being a little too large. Sometimes the ones that were highly voted were not necessarily the ones I wanted to do or were that I was passionate about doing or that I felt would do the greatest amount of good teaching. And so I sort of discarded that idea of having it be an entirely democratic process. But I do, like, read all the tweets that come my way or the YouTube comments and whatnot, even though I don't necessarily respond to all of them. And, and then sort of keep internal track. I'm just, I'm scanning through chat, so if I missed your question, I apologize.
00:51:37.185 - 00:52:25.211, Speaker A: You should also do some talks related to distributed systems. So distributed systems is tricky as a topic because you can pretty easily teach the theory of distributed systems, but actually doing the implementation work is really hairy. And that could be fun. I mean, we could do a stream on implementing raft, for example, or Paxos, and maybe that would be fun. It's challenging because it's such a. It's like a primitive that usually you would build in the context of a particular use case, as opposed to just like building it abstractly. But maybe it could be fun.
00:52:25.211 - 00:52:52.035, Speaker A: Maybe that's a. Maybe that's a good stream idea. It sort of has a similar flavor, arguably as doing a data structure, except that it's. It's an algorithm As a library, maybe that's what we should try. It's a good idea. I have never heard of tari. I mean, I've heard of TARI as in the meaning of Earth, but no.
00:52:52.035 - 00:53:28.315, Speaker A: What's my keyboard? My keyboard at the moment is a Mistel MD600. It's a split mechanical keyboard like this. So it splits apart and I'm very happy with it. It's got brown switches, which are. I don't know that I love the browns, although I've had them for a while and like, they don't bother me. But there's something like they're not quite clicky enough, but they're also not quite soft. So I think for my next one I probably wouldn't choose browns, but I like the keyboard well enough.
00:53:28.315 - 00:54:23.083, Speaker A: It's one thing that's nice about it is it has programmable keys and programmable sub layers. So, like, I have arrow keys in this, like by holding down a modifier key and then using letters for arrow directions, which means I can move my hands less, which is nice. And I can like, natively remap things like caps lock to control rather than having it be a mapping that's done in the operating system, which is nice. Have you done any scientific computing in Rust? I really like Rust as language, but it sometimes feels like the tools aren't really there yet. I haven't. I. I have used Rust a little bit for like, churning through large amounts of like, analysis data to aggregate them down, but I don't usually use it for the actual analytics afterwards, like things like statistical analysis or plotting or anything like that.
00:54:23.083 - 00:55:03.205, Speaker A: Usually for that I'll drop the data into a file and then read them back into R. Like, ggplot2 is fantastic for plotting in R, and R is generally great for statistical analysis too. But, and I agree Rust isn't really there yet. Although I haven't tried for a long time to do that stuff in Russell. Maybe it's gotten better, but I can't really point you at anything. Like there's like the plotting library or the plotting crate, but I don't think it's anywhere near something like ggplot2. I wonder why distributed systems are so hairy to implement.
00:55:03.205 - 00:55:32.115, Speaker A: Maybe it's because historically we've lacked proper abstractions. No, it's not really because of lacking proper abstractions. It's more because there are so many edge cases in distributed systems. Like you're. You're dealing with multiple computers doing things simultaneously and an unreliable delayed network. And it's just there are just A lot of thorny edge cases you need to deal with. If you want anything that.
00:55:32.115 - 00:56:01.249, Speaker A: Any kind of semblance of correctness or consistency on top of it. Like, arguably we. We do have some abstractions we can use in distributed system settings, but implementing them is hard. And I don't know that there's a lot of good work on composing those abstractions either. So, you know, if you have one distributed system over here that provides some guarantees and one that. That's over here that provides some different guarantees, if you try to make them work together, it's not clear that the output is like the. The sum of the.
00:56:01.249 - 00:56:43.729, Speaker A: Of the parts, so to speak. It might be you get worse consistency when combining the systems. I've never tried Topra switches. I've heard of them, but I've never tried them. Best luxury item you've ever purchased. Like, what do you derive the most joy from? O It depends how you define luxury item. Like, arguably, my phone is a luxury item.
00:56:43.729 - 00:57:01.355, Speaker A: I don't have a fancy phone, right. I have a Pixel 5e. But arguably it's a luxury item. Like, I could have gotten a much cheaper one. And. But it does bring me a lot of joy and a lot of frustration. But, you know, but.
00:57:01.355 - 00:57:52.295, Speaker A: And same like I could say, you know, board games, there are certainly some of them, they're way more expensive than they need to be. And arguably those are luxury items too. But in terms of something that would actually be called a luxury item, like, same thing with like a big TV or a big computer monitor. Like, those make a huge difference in my life to actually get, you know, one that's good and large. Is it a luxury item? I mean, yes, but I don't think it's what you're really asking for because they all, you know, they all have practical value as well, which I think, like, I think that alone appeals to me. I don't really get a lot of, you know, actual luxury items. I feel like if I, if I splurge, I splurge on something that I feel is practical.
00:57:52.295 - 00:58:39.503, Speaker A: So I don't think I have a good answer to your question if it excludes things that are for practical use. Any public transportation in la? No, public transportation in LA is terrible. So I live near Westwood and so we also don't have access to the metro here. I think they're building a station here, but it's not going to come for like years and years. So I don't really. Do we have a car? We use it very rarely. We don't really go many places which, you know, is sad, but it's also.
00:58:39.503 - 00:59:21.787, Speaker A: I don't want to get stuck in traffic. It's not too bad to walk near here, but this is one of the many reasons why I miss Europe is like good public transportation and also living in an actual city rather than just a collection of suburbs and being able to walk places. Like, I could do this in Boston too, right? I could just like walk to the movie theater. I could walk to anything. And it was all pretty close. 4K display. I mean, 4K display is certainly a part of this.
00:59:21.787 - 00:59:54.493, Speaker A: Like the monitor I'm using right now has a 4K display. And I don't think I would go back. Is it a luxury item or is it a practical purchase? It's hard for me to distinguish the two. What's your favorite board game? And have you played Mysterium? Okay, so a little bit of background. So I actually ran the weekly board game nights at MIT for many years or specifically in the computer science department at mit. And so I've. I've.
00:59:54.493 - 01:00:16.395, Speaker A: I have a lot of board games I like. I do think my favorite is Blood on the Clock Tower. It's a game that the Kickstarter just shipped and starting to get, like, delivered to people. It was a. It was a long journey, but it's out now. I've been a part of playtesting it for many years, and I did that as part of the MIT gaming group as well. And it's a game that just.
01:00:16.395 - 01:00:36.813, Speaker A: I. It's so much fun. It's a very social game. It's a social deduction deception game. Sort of like, you know, Mafia, Werewolf, Resistance, Avalon. And it's just. It's a big group game, but it has one person who's sort of the storyteller or the moderator who's also actively involved in the game.
01:00:36.813 - 01:00:54.855, Speaker A: Sort of like a. Kind of like a DM from D& D. And so I like storytelling that game, like running the game. Like that is probably one of my, like, favorite game experiences. I also really like D and D I DM a fair amount. I think that's really fun. It's fun to be a player too.
01:00:54.855 - 01:01:13.275, Speaker A: Although the DMing role is. Is more. More up my alley. I have played Mysterium. I do like Mysterium a fair amount, I think in terms of other games that I really like. I have a board game geek where I think I've ranked all of them. I wonder if I can.
01:01:13.275 - 01:01:51.237, Speaker A: I wonder if I can find what even is my. It's a very good question what my password Even is here. I think that's my password. Aha. Geek list maybe. So where I can find all my games? Collection summary. Here we go.
01:01:51.237 - 01:02:11.141, Speaker A: All. Yeah, I'll send it in chat. I'll put it in the video description too. So if I sort these by my rating then yeah, yeah. Okay. So Hanabi, I think is a great game. Hanabi is a lot of fun.
01:02:11.141 - 01:02:40.531, Speaker A: It's a. It's a card game. It's a cooperative card game where you can't see your own cards but everyone else can see them. And you basically are trying to put down cards in a particular order by giving very limited clues to one another. It's great. Captain Sonar is a real time team game where you're basically playing like real time Battleship. It's fantastic.
01:02:40.531 - 01:03:13.451, Speaker A: It's very hectic, but it's real fun. Clock Tower, of course, and Resistance and Avalon are the big games that I played a lot before I started playing Clock Tower. Mage Knight is a tabletop RPG that also has like card drafting and you can play it cooperatively, which is really fun. It's a fairly long game. You play it, but. But I think it's a lot of fun. The Pandemic games, like the Pandemic Legacy games I thought were really fun to sort of play with a group.
01:03:13.451 - 01:04:19.601, Speaker A: Same thing goes for Gloomhaven. Magic Maze is another real time cooperative game where you're playing a group of Vikings trying to escape from a shopping mall where they've stolen things. It's. The premise is very weird, but the fun thing about the game is there are like a bunch of pieces on the board and every player can move every piece and it's real time and you can't talk, but every player can only move pieces in a particular direction or do particular actions. But again, you can't talk and it's a lot of fun. I think those are sort of my top listings. You prefer competitive or cooperative games? I like cooperative games, although I think I prefer games that are both.
01:04:19.601 - 01:04:49.531, Speaker A: So games where you have to cooperate with a team but you're competitive with other teams. Like essentially team sports I think is really fun. Or like even Magic Maze, which is cooperative. It feels competitive. Like it feels like you're competing with the other players even though you're working with them. I also like when the cooperation is hidden. So I mean Clock Tower and Avalon and Resistance are all like this.
01:04:49.531 - 01:05:39.885, Speaker A: But also if you think of games like there's a. I think it's originally German card game. It's like played with a not quite regular deck of cards. Called Doppelkopf, which is a trick taking game for four players where in general you have. You're playing on teams with one of the other players, but you don't know which one. So the game is set up so that you use two decks of cards, use the top half of both decks. So there are two of every card from nine and above, and the two players who have a queen of clubs in their hand are at the start of the game are on the same team and the two players who do not are on the same team, but you don't know who has the other queen of clubs or the other one who doesn't.
01:05:39.885 - 01:06:22.983, Speaker A: And so you need to figure that out over the course of the game. And that's really fun. A luxury purchase of something you'd be using all the time anyway isn't a luxury purchase. Yeah, that's. That was sort of my point, right? Like. Like I don't feel like I buy a lot of things that I don't buy in order to use. I think maybe the best example I can think of is not a specific thing, but more how I buy things, which is I tend to try to buy for the longer term.
01:06:22.983 - 01:07:34.513, Speaker A: Like when I try to figure out which X to buy whatever X is, I try to get the best X, not the most expensive X, but the best X given all the properties involved in the evaluation, including, including the sort of value per price. And that means that I do end up buying better things than I might need. But it also means that I'm more usually happy with the things I bought, right? So an example is this microphone, right? Where I don't need a microphone that's as fancy. Like, realistically, you probably wouldn't hear the difference, but I was like, you know, if I'm going to use this to produce a lot of content, I just want to get a good one that I know will be a good purchase and will continue to be a good purchase for a long time. It's not clear that it's worth it, right? I don't think it would make any material difference if I got a microphone that was half the price. Same with my headphones. Like, I have headphones that are arguably fancier than what I need, but I do really like them.
01:07:34.513 - 01:08:55.575, Speaker A: Like, I'm very happy with them. So that might be like a general trend in my life that I probably buy nicer versions of things than are strictly necessary. So that's my approximate answer for your luxury question. How are the cats? Let's see, are there any cats in here? Right? Now let me see if I can get you some cats. All right, this cat number one, this is Chai. Chai, do you want to say hi? You sniffing the microphone? What's going on? Why are you trying to get away? It's approaching her play and feed time, so she's not very happy being picked up and moved around. Hi.
01:08:55.575 - 01:09:22.117, Speaker A: You're very cute. All right, all right, I'll put you down. Hey, Miso, do you want to come say hi, too? Yeah. And Miso prefers being carried like a baby. That's a microphone. Yeah. I'm sorry.
01:09:22.117 - 01:09:51.527, Speaker A: Do you want to get down? All right, all right, all right. There you go. They're both very feisty right now. They want to play, and they've also learned that word, so I can't say it too much because then they start getting wild. Oh, yeah. I got Pandemic Legacy for my mom and stepdad, but I don't think they've actually opened it. I think they would really enjoy it, but they're not.
01:09:51.527 - 01:10:25.573, Speaker A: They're not like, they're used to board games like Clue and Monopoly. And so I think they're like, why would we play board games? But I don't think they quite realize just how much there is to board games beyond what they're used to. My current hobby project is a chat bot for YouTube and Discord, somewhat similar to the Restream bot. That's a great idea for a project. I love writing bots. I wrote a Slack bot for playing Hanabi over dms, and it's fantastic. It was so much fun.
01:10:25.573 - 01:10:53.645, Speaker A: We had ongoing Hanabi games in my lab for years, just over Slack, and it was using, like, emojis to show you what you knew about other people's hands and stuff. It was great. And writing. It was a lot of fun, too. It was like, a fun learning experience. And I also got to write a game, which is fun. Any TV shows you like to watch? Yeah, we've been watching a bunch of stuff.
01:10:53.645 - 01:11:19.315, Speaker A: Ted Lasso was pretty great. Trying to think, like, things we've been watching recently. We just finished a new season of Stranger Things. I was pretty good. We're currently making our way through the Simpsons, which is a lot of episodes. We've been watching Taskmaster, which is fantastic. If you haven't watched it, it's such a fun show.
01:11:19.315 - 01:12:00.355, Speaker A: We also watched what's that Japanese game show Old Enough, which is all about kids, like, young kids being sent to go errands. And it's very, very adorable. Is the mascot a llama or an alpaca That's a good question. It's, it's the mystery of J. Is Jay a llama or an alpaca? You gotta figure it out. I'm not gonna tell you the answer. That's no fun.
01:12:00.355 - 01:12:52.259, Speaker A: A J would tell you, but Jay can't. How easily does wordplay come to you? Are you happy with how you name things? Projects, not cats? I've always liked playing with words. Like that's always been a thing that I think is interesting. So, yeah, I guess it does come kind of easy to me. I also try to always pick creative names, which not everyone appreciates, especially for things like rust crates and stuff. I know this is a thing in the rust ecosystem more broadly of let's name things with cutesy names. And I definitely lean into that.
01:12:52.259 - 01:13:26.585, Speaker A: And I know that not everyone is a fan of that being the pattern in the ecosystem because it sometimes makes it harder to find libraries. What does a library call, you know, bystander actually do? But I, I don't know. I, I like the. It's not even an intellectual exercise in finding a good name. But I, I think it's fun to try to name things cats do, to be honest. Is English your first language? No, it's not. Norwegian is my first language.
01:13:26.585 - 01:14:09.915, Speaker A: Although in Norway we start learning English fairly early on. Like, I forget when it enters, enters the curriculum. I think it's like the fifth grade or something. And I've also lived in English speaking countries now for years and years and years. So, you know, I've, I've had the, I've had the indoctrination. I think at this point I'm probably more comfortable with English than Norwegian in terms of the, like, breadth of my vocabulary. Like, I think, I think I can probably express myself better in English now than in Norwegian because I, I have more of the sort of depth of the language than I do in Norwegian.
01:14:09.915 - 01:15:03.875, Speaker A: All right, I think we're reaching the end of the questions, but I'll, I'll, I'll leave a couple of more minutes just to see if there's anything at the tail end here. Are you going to Shucks in September? I'm not going to Shucks. Probably it would be really fun to go, but I am going to Rosconf, which I'm very, very, very excited for. So I'll be in, I will be at Rustconf. I don't yet know whether I'll be at Rustlab in Italy in October. It would be really fun. But it's a lot of long distance travel which we'll see.
01:15:03.875 - 01:15:39.945, Speaker A: I name things by hitting the keyboard with my head. Nice. The result is always unique. I have thought, actually, whether. I mean, both the YouTube and Twitch channels I have are very. I mean, they're obviously programming heavy, right? Like, they're all Rust streams. But I have thought about whether I should do, you know, a stream where I talk about board games or a stream where I, like, run Clock Tower, or a stream where I, like, play video games.
01:15:39.945 - 01:16:09.295, Speaker A: Like, I do play video games, and it might be fun to do that too, but it appeals to a very different audience. And I don't even know whether it would be interesting to watch or fun to watch because, you know, it's a completely different thing. But it is something. Every now and again, I'll idly think about whether I should try. I don't know the meaning of life. I only know the meaning of life, the universe and everything. And that is 42 to.
01:16:09.295 - 01:16:57.163, Speaker A: Was there any technical concept that was hard for you to grasp? Oh, there are lots of technical concepts that are hard for me to grasp. I don't know that I can name them, but I feel like almost everything takes me a while to like. It's not as though I just magically know everything, right? Like, I have to learn just like everyone else. I think variance took a while to digest for me. Certainly, like, that's. That's one that I remember, you know, not too long ago. Another is formal verification is.
01:16:57.163 - 01:17:52.471, Speaker A: Is tricky for me sometimes. It is one of the reasons why I want to explore that space more, because I think it's. I think if it clicks for you, how to sort of reason about programs in a more abstract and formal way, I think much like learning Rust or absorbing some of the Borrow Checker into your head can make you better at other languages. Learning the. The formality of formal methods can also make you a better programmer outside of those tools. But it's something that, you know, I have a cursory understanding of, but I don't feel like it's something I've absorbed and it definitely eludes me a lot of the time. Oh, there are a lot of fun video games I've been playing too.
01:17:52.471 - 01:18:10.151, Speaker A: I recently played Outer Wilds, which is great. I recently finished Deathloop, which was really fun. I'm currently playing Valorant. Valorant. Valorant. I. So the backstory there is.
01:18:10.151 - 01:18:52.561, Speaker A: I actually used to play a lot of Counter Strike and I used to host, like, Counter Strike competitions and stuff. That's a lot of years ago, and a friend of mine reached out and I Was like, hey, we're like a group of people that play Valorant every now and again. Do you want to try out? And I was like, sure, I'll play a shooting game again. And it's really fun. I've definitely, I think, lost a lot of my skills since back then, but it's still fun. I'm trying to get back to the point where I'm okay again, and it's a slow and humbling journey. Play Rust on stream.
01:18:52.561 - 01:19:24.099, Speaker A: That would be really fun to run. Do the inverse, what we usually do of like, no, this is not the channel for the rest of the game. And be like, no, no, this is not for Rust the programming language. This is Rust the game. I could do a second channel. I don't know that I care enough to stream this stuff because I never understood why people watch streamers, but I feel like they watch streamers because the streamer themselves are, you know, fun on stream. I don't know that I would be fun on stream for a video game.
01:19:24.099 - 01:19:56.813, Speaker A: Maybe I have. I have no idea. If we have an idea for a live stream, where would one put it to increase the chances of having you consider it? All you need to do is tweet it at me. I like. I read basically every mention I get. So that will get it in front of me, and then I'll put it in my list. And if I decide to do it, I decide to do it.
01:19:56.813 - 01:20:44.507, Speaker A: There isn't really a way for you to boost the likelihood of it beyond that, except make a compelling argument for why it's an important thing to teach, a possible thing to teach in the format that I do, why it's more important than other things to teach, and why I should be the one to teach it. If you sort of nail all those four, then I'll do it. I know Counter Strike is still very popular, but I don't know. I don't know. I. I did try to pick it up a few years ago, and, you know, I think part of it is it's more fun to play when you know other people who are currently playing it, because then you could play with them. And so that, I think, is why I didn't end up picking Counter Strike back up.
01:20:44.507 - 01:21:05.103, Speaker A: But Valerant is one that I'm, you know, slowly picking. I don't know how long. I'll stick with it, but, you know, it's a place to start. I play both console npc. I'm not a. I'm not a purist. I think your brain is a different kind of fun but you'd be the only videos game streamer I'd watch.
01:21:05.103 - 01:21:34.585, Speaker A: That's very funny. It would certainly be a different experience I think than a lot of the other streamers. Maybe I'll just maybe we'll do. We'll play and I'll when when I miss things I'll just be like ah, that seems like a programming mistake right there. I think they're off by one. All right I think we're tailing off here so I'm going to round it off. Thank you everyone for joining.
01:21:34.585 - 01:22:02.575, Speaker A: If you were here for both parts then thank you for joining both parts and I'll see you all next time. I'm hoping it'll be shorter until the next stream probably I'm guessing within a month is my hope for the next coast of rust. Although I think I said that at the end of last stream and it was three months so who knows. But thank you all and I'll see you around some other time. Bye.
