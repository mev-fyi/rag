00:00:01.280 - 00:01:04.091, Speaker A: Welcome back, everyone. It's been a while since the last stream, which I feel like at this point I now say basically every stream, which is a little unfortunate, but somehow life tends to get in the way. This is one that I've been promising for a while. So this is going to be a crust of rust on build scripts and ffi, so foreign function interfaces, which is basically the way that you get Rust code to interact with code written in other languages. And we'll talk some more about what that actually means. The reason this came about is because build scripts are decently well documented actually in the cargo manual, but they're a very general mechanism so it can be hard to wrap your brain around why they're useful, what they should be used for, what they should not be used for, what their limitations are, the patterns that usually apply when you do use them. And for ffi, you know, there aren't great resources just talking about in general, what's going on.
00:01:04.091 - 00:01:45.343, Speaker A: There are some, like the Nomicon has a pretty good chapter on, you know, the basics of ffi. The Rust reference is pretty decent, talking about like the extern keyword, but sometimes as you know, is sort of the standard for crust of rust. It's useful to really just dig into an actual real example to see how the pieces fit together. Now because this is a crust of rust, it's going to be, you know, on the shorter side as far as it goes for my streams. So I'm guessing about two hours. And in two hours it's kind of limited how much we can actually do in terms of implementing something that uses real ffi. So I won't get too much into reverse ffi.
00:01:45.343 - 00:02:26.235, Speaker A: So that is for other languages to call Rust, like to generate C compatible bindings from Rust code. I'll talk a little bit about it, but not too much. And I also primarily be focusing on linking against C. The mechanisms that we're going to talk about do apply to linking against other languages as well, like anything that is a C compatible abi, including things like C. But there are a lot of nuances to bridging the gap from the C ABI to the other language as well. And that part is related to Rust. And in some cases it's pretty important what those distinctions are, but we're not going to dig too much into that.
00:02:26.235 - 00:03:05.647, Speaker A: I'll point at some crates that might be useful, but that's sort of the extent of it. There's also a. Yeah, so someone mentioned in chat, Ryan Levick has a great video about FFI and Rust, which is also worth checking out. I'll link it up here somewhere in the. In the recorded version. So I will talk a little bit about bindgen when it's appropriate to use, when it's not appropriate to use. I'll talk a little bit about cbindgen and in particular, the plan here is to right bindings to Lib sodium.
00:03:05.647 - 00:03:48.645, Speaker A: Now, Lib sodium, if you're not already aware. Let me see if I can make this dark. For those of you who are averse to light, which I know is, as many of you, apparently, I cannot. That's fine. Yeah. So Libsodium is a cryptography library written in C that is fairly widely. Both widely used, but also widely known to be a very sane implementation of many of these cryptographic primitives.
00:03:48.645 - 00:04:15.785, Speaker A: And in particular, it aims to be implementations that are hard to misuse and relatively low in configuration. Like, it's really just you want to encrypt a thing. We have. This is the way you encrypt a thing. You want a random key to use for your encryption, we generate one for you in the appropriate way. So it's intended to be sort of foolproof. And the other thing that's nice is it's written entirely in C, so the API is decently easy to bind to.
00:04:15.785 - 00:04:55.065, Speaker A: And, you know, it's a real library. It's not something that. Where I just hack together a little C file, because that way we'll get a feel from some of the subtleties that are involved. Okay, let's start from a little bit before we get to Libsodium and the action bindings and talk about what build scripts are. So build scripts are effectively a program that gets to run before your crate is compiled. So the way this is structured in Rust is that. And it's a property of Cargo, it's not a property of Rust the language, it's entirely a cargo constructs.
00:04:55.065 - 00:06:04.475, Speaker A: And the idea is that if you have a file in the root of your cargo project called Build rs, the root of your cargo package, technically called Build rs, then Cargo will compile that file, run that file, and then build your crate. And it will do so even if your crate is being consumed by some other crate like Build RS runs in the context of whenever your crate is compiled. And because Rust always does the transitive compile, the build script that you run on your local computer, the output of it is not included in Cargo publish, the build script is, but not its output, which means that the build script has to be written in such a way that it's going to run on other people's computers. And that's part of where it gets really tricky to get bind script or sorry build scripts to always do the right thing. It can be fairly convoluted to handle all the possible ways in which your consumers build environments are set up. And we'll talk a little bit about that and look at some build scripts from other existing libraries as well. That might be interesting.
00:06:04.475 - 00:06:47.395, Speaker A: Now, as I mentioned, the build script is essentially just a program. Like it defines a main function that's really the main entry point to a build script. It doesn't have to be called build rs. You can also in your cargo toml set like build equals and the name of path and it'll compile that instead. And you can use like a build main RS and then have modules and whatnot. We'll see some crates that do that as well if you end up with a very convoluted build process. Now, when that program runs, it doesn't really have any special integration with the crate that is actually being compiled.
00:06:47.395 - 00:07:22.635, Speaker A: The way that these two communicate is primarily through environment variables and the out directory. So when a build script runs. Let me see if I can go down here. So when the build script runs, it gets to emit. It gets access to a couple of things. It get access to the outdoor environment variable. And the outdoor environment variable is a subdirectory of target sort of transitively like deep inside the target out build output directory that is writable by the build script.
00:07:22.635 - 00:08:04.561, Speaker A: And when your crate is compiled after running the build script, the outdir environment variable will be set for it as well to that same directory. The idea being here that the build script can like generate rust files, for example, put them in outdoor and then the. Your rust code can include things from under outdoor and things and get access to that generated source code. So let's just sort of see what that actually looks like. So let me do. We'll do a bin and we'll say build and ffi. Very boring crate name.
00:08:04.561 - 00:08:52.781, Speaker A: I know. So if I here make a build rs, I give an fn main and then I do standard and var outdoor and then I do cargo run. So you'll see what it does is I get a warning. First of all, this was just I haven't changed my source library.rs. at all. The build RS does not generate any code, nothing like that. But you see that when I now run cargo run, I get a warning from the build script and that's cargo deciding to build my build script and then it runs the build script and then it compiles my crate, and then it runs my crate.
00:08:52.781 - 00:09:31.503, Speaker A: And you might have noticed you don't actually see the output from that build script. That might strike you as strange, because in the build script we did a print like Debug basically does a print. And the reason for this is because build script output is not printed to the terminal unless the build script fails. So we can see this. If I here stick in a panic and then do cargo run, then you'll see that. Now here you see it prints the standard error of the build script when it ran, but it does not do that if the build script succeeds. And the reasoning behind this is that build script tends to.
00:09:31.503 - 00:09:58.855, Speaker A: They tend to produce a bunch of output. And we'll see a little bit about why they do that. And part of it has to do with the fact that in their output they can issue special instructions to cargo that allow it to change the link search path and those kinds of things, set environment variables. And so the standard output is going to be fairly large. And so therefore cargo just eliminates it by default. Now, it is possible to get at this output even if it doesn't fail. So let's remove the panic again.
00:09:58.855 - 00:11:01.325, Speaker A: Oh, I have that set, don't I? Let me just see if I can. Yeah, So I have the cargo target dir environment variable set so that all of my cargo projects across my host use a single target directory rather than having one per project, which tends to save disk space and save on compile time sometimes, but it's a little inconvenient in this particular case. So I'm going to unset cargo target dir, and then I'm going to run cargo run again. And now you'll see I have a target directory in the current directory. And if we now look into target and debug and depths, not depths, build. So inside of target debug build, it could be release. If you're doing a release build, you'll see that there's a sub directory for.
00:11:01.325 - 00:11:28.157, Speaker A: You'll see there's one for every crate. And in this case there are actually two for this crate. And the reason for that is one is the build script and one is the crate itself. So if we do, you'll see that one here, this is. This is the build script being run. This is the build script being built. So this one here is.
00:11:28.157 - 00:12:29.345, Speaker A: This is the result of compiling our build script. So this is sort of the crate that is the build script, and this is the crate that is the real crate and included in there is the output and the standard error of its build script. So if we do cat target debug, build nfi, AFC output, standard output is empty, which is fine, right? We didn't print any to standard out because the debug macro prints the standard error. But if we cat standard error, you see there is the output from that debug. And if you do a build where you take a dependency on OpenSSL, for example, the OpenSSL crate takes a dependency on a crate called OpenSSL SYS, which has a build script that does lots of things with OpenSSL. And so if you build something that depends on it, you can use this to look at the output of the OpenSSL sys build script. Even if it's deep in your dependency graph, it'll always end up at this kind of path.
00:12:29.345 - 00:13:37.571, Speaker A: And so this is really, really useful for trying to figure out if the build script did something weird, what did it do and why. It's a little hard to discover, but it is really useful to know about. You're going to run into these kinds of things. Okay, so the outdoor environment variable when our build script ran, you'll notice was this path. And you'll see that under the target directory, under debug, under build, and under this, this subdirectory of build, that is the same one as unsurprisingly, where the output of the build script ends up, there's an out directory, and this out directory happens to or not happens to. This is entirely on purpose. If I here do instead of hello world, I'm going to print out config outdoor and I'll talk a little bit about not configuration, and I'll explain why I'm using the env macro here and not standard ENV in a second.
00:13:37.571 - 00:14:42.337, Speaker A: So if I now do cargo run, you'll notice that and I need to do it with env, you'll see that this path here is the same path as this path here. And that's entirely intentional, right? The idea is that this is a shared directory between the build script, so where it can put RS files or any other kind of file, and the crate that's being built that it can pull those generated sources from. Now, the reason why this is env as in a macro rather than standard n var is because the ENV macro reads environment variables as set at compile time, not at runtime. So remember, for our main RS here, there are two steps. One is you compile main RS into a binary, and the second one is run that binary. And so this Outdir is only set at compile time. Cargo has no way of setting it at runtime because you could imagine you build your binary, you copy it to another system and you run it.
00:14:42.337 - 00:15:19.857, Speaker A: There's no cargo involved. So this is only set at compile time. And so we access it using env here. And you might wonder, okay, well, how do I actually use this? The way you use this in practice is you do something like, you know, standard FS write to join hello.rs and what are we going to write into that file? We're going to write pubfen foo. Sure, Pub off enfu. That's fine.
00:15:19.857 - 00:15:45.215, Speaker A: It doesn't need to do anything special. We can unwrap in this build script. That's fine. This is going to be standard path. And it gets sad because this and this. So what I'm doing here is I'm creating a file inside of the out directory called hello.rs I guess let's call it foo rs maybe.
00:15:45.215 - 00:16:25.351, Speaker A: And it has a single function that does nothing. It's just called foo. So if I now do my, you know, same thing here and then I LS what's in that out directory, you'll see that there's now a foo.rs file in there. And what I can do in my source main is I can do something like, you know, mod foo include. So the include macro takes a path and at compile time substitutes the call of the macro with the contents of the file. So this is it's not eval, right? It's a copy paste that file into here and then treat it as rust source.
00:16:25.351 - 00:17:08.455, Speaker A: So we can do outdoor foo r us. And at least now in theory we should be able to call foo foo. And indeed we can. Right. This compiled. And the reason being maybe if I have do I have cargo install CargoExpand because otherwise I want CargoExpand. So CargoExpand is a really handy tool for expanding macros and showing the result after macro expansion.
00:17:08.455 - 00:17:55.075, Speaker A: And so that should show us that the actual code that gets compiled here after expanding the macros includes that inline source file that we just generated. Does that make sense so far? Like what the connection here is between the build scripts and not if I do expand. You'll see here the mod foo now just contains pubfn foo. This is the result of running cargo expand. And so our call here now ends up being valid by the time this actually gets called. Include is kind of like include in C. Yeah, it's more or less the same thing.
00:17:55.075 - 00:18:36.215, Speaker A: Yeah, yeah, they're basically the Same. Okay, so now we understand sort of how these connect together. And as I mentioned earlier, the outdoor is one of the ways that the build script can communicate with a crate being compiled. There are others. So one is a way for build scripts to communicate with cargo, which is not really about the crate being built, but rather telling cargo. I have discovered a thing that cargo needs to deal with, and these are all by printing to standard out something that begins with cargo colon. And there are a lot of these.
00:18:36.215 - 00:19:16.979, Speaker A: So there's cargo rerun, if we'll talk about those in a second. There's cargo, rust C, various args. This is usually used for things like imagine you have a build script and it's looking for a particular shared library file and it discovers that it's not in a standard system path, like it's not in user lib, for example. It's somewhere else. The build script can tell cargo, hey, when you go to link to the final binary, also look in this directory for a particular library. And so you can use the use using rusty link arg, which is to pass additional flags to the linker. They don't have to be a path necessarily.
00:19:16.979 - 00:20:12.433, Speaker A: They can be any linker flag or only pass this additional linker argument when building binaries or tests or examples or benchmarks. Or you can set rusty link search, which is specifically for setting a search path. So it's sort of equivalent to dash capital L for regular linkers. You can also pass rusty link lib, which is telling cargo when you link, also link this library. And this is very often at least part of the job for a syscrate is that the build script is going to say which shared library to link against, which is does by emitting rusty link lib. This is equivalent to dash lowercase l if you're familiar with linker syntax. And also where to find where to search for that library, which is the rusty link search, which just gives a path separately from linking.
00:20:12.433 - 00:20:59.139, Speaker A: The other thing that you can instruct cargo to do is to pass additional flags to rust C itself. So that could be trivial things like, you know, changing the optimization level or something. But very often what this is used for is in the context of rusty config. So what this will do, and you can see this too, if I do something like, oh, it's a good example of this config. Hello. Right. So the config macro and this config macro is sort of similar to if you write this syntax, right, that they both end up evaluating in sort of the name same namespace config is used for compile time properties, and these can be used for all sorts of things.
00:20:59.139 - 00:22:15.405, Speaker A: But they're basically a way to say, you know, is this thing available or not? Is this feat? So it's used for features, right? So you've all seen feature equals foo. So what this means is when Cargo builds your crate, it looks at what features are enabled and it passes to Rust C. Config equals feature equals foo, if the foo feature is enabled, and that in turn enables this Rust language feature. So this is no longer related to Cargo, that allows you to do conditional compilation based on what these flags are passed in. So if you use this Rust C config, then that means, you know, pass additional config flags. Like, let's say, you know, one thing that the OpenSSL library does, for example, is pass in OpenSSL 110, which indicates, you know, it's an OpenSSL is at least at version 1.1.0. And what that allows is that the OpenSSL crate can then do things like config openssl 110 to say, only compile, you know, this, this function if OpenSSL is at least that version.
00:22:15.405 - 00:23:09.699, Speaker A: So it's a way for the build script to inform the crate about conditional compilation options it might need to enable or disable. All right, does that make sense? The config aspect of this makes sense and what these sort of cargo options do. We'll look at some examples of this later as we look at real build scripts. One thing that's interesting here that people don't think about very often is the distinction here between cargo things and Rust C things. So config is a Rust C like, it's a. It's a language feature of just saying you can be. You can conditionally compile based on properties that are passed to the compiler.
00:23:09.699 - 00:23:41.855, Speaker A: And this is sort of similar to like in C, where you can do like a dash D define and then you can conditionally compile based on that. It has nothing to do with Cargo. And then there are cargo features, right, which you set in your cargo toml. And what cargo does is it turns features into rusty config flags, which you can then use to do conditional compilation. But the two are sort of disconnected. Config is like if def and end if. Yeah, and you can also access them through a macro like this.
00:23:41.855 - 00:24:24.815, Speaker A: So you can say, you know, config openssl110 in this case, for example. Okay, so that's the other way that we can communicate between build scripts and Cargo and ultimately the crate itself. There are two more here that I want to touch on. One is cargo warning. This is, you know, I mentioned that in general, the output from build scripts does not get printed when they're run unless the build script fails. Cargo warning is the exception. So if a build script writes to standard out a line that starts with cargo colon warning equals, then the remainder of that message does get printed to like when cargo runs.
00:24:24.815 - 00:25:18.005, Speaker A: And we could try this, right? So if we go to our build RS and we do print line, cargo warning equals generating food R. And in general, these are intended for warnings, they're not intended for like logging. But if I now run cargo R, you see that I get this warning saying generating foo rs. It's worth noting that these kind of warnings from the build script are only generated if you are working on that crate if you have a path dependency on them. They're not generated if you have a transitive dependency on them. So, for example, if the OpenSSL SysCrate build script generates these kind of warnings, you will not generally see them when you do a build if you just happen to have a dependency on it. You'll only see it if you have a path dependency on open SSL or if you are specifically building open manually.
00:25:18.005 - 00:26:30.935, Speaker A: And the other one is cargo colon key equals value. So this is metadata that essentially turns into environment variables. And there's a lot more discussion of this in the cargo book and the cargo reference. But basically, if you emit something that starts with cargo colon and is not one of the known properties, like let's say, I say here, include equals foo cargo colon include is not a special value in that list. But what this does if we then change search main RS is it declares a dep. Oh, it might only work if I have a links which I haven't set up. That's a good question.
00:26:30.935 - 00:27:17.145, Speaker A: Build and FFY include. Let's see if that's true. Of course not. Okay, so the intention here is that you can emit additional information for your dependents that actually contain values. So config is for conditional compilation. But sometimes you want your build script to do things like figure out where the include directory for like a C dependency, for example, is, and communicate that path to the downstream crate that builds. Because it might be useful for it to like, you know, pick up a particular C header file or something.
00:27:17.145 - 00:28:14.001, Speaker A: And you can do that by using the cargo colon key equals value syntax. And it will declare environment variables for those that those downstream builds can consume. But the name of the environment variable is dep underscore the links Attribute, which we haven't talked about yet. But it's basically the library that the package links against underscore and then the key and then the value out. And there's an example in here, we're not going to look at it because it's a little, little separate, which in fact is a good reason to talk about links. So in general, this is not a requirement. This is worth pointing out, but in general, if you have a crate that links against a particular shared library, you're supposed to declare links equal in the name of the shared library in that crate's cargo.
00:28:14.001 - 00:29:31.105, Speaker A: Toml this doesn't do anything magical as far as linking is concerned. You're still expected to use things like rusty link lib to tell cargo to also link against that library. You might still need to set the search path and everything. But what it does is it allows cargo to check that only one crate in the entire dependency graph links against the shared library. And this is useful because if you have multiple crates that try to link against the same library, you can get into really weird cases where they link against slightly different versions or they both statically link against something and therefore you get duplicate symbols and then you get like weird linker failures. So doing this allows cargo to basically do a sanity check of the build that there's actually only one crate that binds again and again and against any given shared library, or static library for that matter. Now the there are some interesting implications here, which is because cargo checks that only in exactly one crate, or at most one crate, I should say, links against any given, you know, library name.
00:29:31.105 - 00:30:14.665, Speaker A: You don't want to end up with an ecosystem where you have lots of crates that provide bindings to the same thing. In general, the way that we approach this in the Rust world is that for most shared libraries, we try to have a single crate called dash sys. So this would be, you know, for lib sodium, it would be called libsodium dash sys, that crate. The only thing it does is bind against the shared library and expose the sort of raw FFI methods to that library. It is not supposed to do any kind of like safe wrapping or providing an ergonomic interface. None of that. It is a pure binding to the library.
00:30:14.665 - 00:31:10.985, Speaker A: And then you can have lots of different libraries that all use that sys library and generate nice bindings on top of it. But the idea being that because you only have a single syscrate that does the binding, that one has the links keyword. And that way it just sort of works out that you only link against it in one place. This also has some implications for semantic versioning. So if you have such a syscrate, one of the things that you want to do is try to avoid doing major version bumps to it, because if you do a major version bump, what will happen is that it will be impossible to use that. Use two different major versions of that sys crate at the same time in the dependency graph, because two major versions are considered two different crates. And if two different crates both have the links keyword for the same name, Cargo will complain.
00:31:10.985 - 00:31:51.335, Speaker A: It won't build. So generally, if you cut a breaking release to sys, you're going to want to make every consumer of that syscrate also bump to that new version sort of at the same time. Yeah, so I haven't gone into how you generate a syscrate yet. You know, you can write manually, you can use bind gen. We'll talk about that in a second. Okay, so there is. Yeah, so it talks a little bit about this in the, in the cargo manual as well, about sys packages.
00:31:51.335 - 00:32:22.315, Speaker A: And it has some other nice properties, like you can override particular properties of links. There's one more thing I wanted to talk about, which is two, actually. Yeah. So you can set in these sort of cargo output things from build script. You can also set arbitrary environment variables. This is sometimes useful. But one key thing that you said with build scripts is rerun if changed.
00:32:22.315 - 00:33:18.615, Speaker A: By default, if a crate has a build script, the build script gets rerun every single time that crate is built. Even if there have been no changes to anything, it gets rerun because cargo doesn't know the conditions under which it should rerun. Right. Who knows? That build script might fetch something from the Internet that needs to be done every time. So the expectation from Cargo is that every build script, if it knows it only needs to run in certain circumstances, should emit either the rerun if changed or rerun if envchanged, or both. You can emit multiple of them to say, run me if these files or these environment variables have changed, not otherwise. So very commonly you'll see things like rerun if ENV changed for something like, you know, openssl libdir, which the openssl syscrate uses to locate openssl.
00:33:18.615 - 00:34:07.845, Speaker A: Well, if the path environment variable that the user uses to locate OpenSSL is changed, the build script should be rerun. And so therefore that build script emits rerun if envchanged openssl libdir rerun if changed is usually used for things like, you know, if Your build script compiles a little C program into, let's say, a shared library file or a static library or whatever that your crate then links against. Well, if the C file changes, the build script should get rerun. And so you can use this first stanza to do that. Okay, I think that's all I wanted to talk about for build script. Sort of. Generally, we're going to dig into some and actually look at what they do and why.
00:34:07.845 - 00:34:54.383, Speaker A: One thing to keep in mind with build scripts is that, at least at the moment, they're very blunt tools in maybe not blunt tools, but they are. In fact, I'm going to say the exact opposite. They're very sharp tools and you can easily hurt yourself with them because build scripts are not really sandboxed in any meaningful way, at least not at the moment. They can go talk to a database, they can connect to the Internet, they can read arbitrary files, they can write arbitrary files, whatever the current user has access to. We should already be setting off alarm bells. Things like reproducible builds go out the window. If a build script does something weird.
00:34:54.383 - 00:35:46.285, Speaker A: It might just overwrite the files in source and now you've lost changes that you had pending in Git. It might read your. Read all your documents from your home directory and upload them to the Internet. Build scripts are very sharp tools, and they're sort of implicitly trusted because they're automatically built and run for all your dependencies, which is worrying. And this is an example of with great power comes great responsibility. But also they're very troubling because you don't really control what build scripts your dependencies have, and you were probably not auditing all of them. There is a bunch of work in here that in the sort of ecosystem of trying to figure out how can we sandbox build scripts in meaningful ways.
00:35:46.285 - 00:36:17.915, Speaker A: And one way to do that would be to do something like compile and build them in WASM so that they have a very constrained API to the rest of the system for what they can do. But this is like. It's concerning and it's worth knowing about. Build scripts. Okay, with that out of the way, let's actually look at the build scripts for some very common crates. And I forgot to change my GitHub to dark mode, so give me one second. I'm sorry to burn all of your eyes.
00:36:17.915 - 00:37:04.759, Speaker A: It'll be over in a second, I promise. You can just close your eyes in the meantime. There we go. Okay, you can open your eyes again. If you have an aversion to the light, we'll talk about bind gen a little bit later and C bind gen a little bit later. So the first thing we're going to look at is there's a crate called Git 2 and it binds against Libgit 2, which is a bindings to the git C library, but not the real git git C library, but a re implementation of git in C. And it's a great little library.
00:37:04.759 - 00:37:41.339, Speaker A: You'll see that in its cargo Toml it takes a dependency on Libgit 2 sys, which is a path dependency here. So there's one repository that contains both git2 and libgit2 sys. If you look at lib. So this is the pattern that we talked about, right, of having a separate crate that does the actual linking. So let's look at Libgit 2 sys and it's cargo toml. You'll see it declares build equals build RS, which is not necessary if as long as your build script is called build rs, Cargo will pick it up automatically. But it doesn't hurt to declare it.
00:37:41.339 - 00:38:23.203, Speaker A: This just allows you to name it something else. You'll see it Declares Links equals get 2 like we talked about, and it has a bunch of features and whatnot. Let's look at that build rs. Let me increase the size of this a little bit. So very often the pattern you'll see for these kind of syscrates is very similar. In general, what they do is they first try to locate the library in question on the standard system paths. If they can't locate it in the standard system paths, it looks for, well, actually change that slightly.
00:38:23.203 - 00:39:12.769, Speaker A: It first looks at whether there are environment variables telling it where to look. If there aren't, it uses the system paths. Then it looks to see whether it can find the library it needs in that path and whether those are at the right version. And if it does, then it just generates the bindings and tells cargo to links against it. Otherwise it will often build that dependency from source. This is known as vendoring, right? So the package contains the source code of the shared library it links against and will build it for you into outdoor and then link against it. And then usually, you know, however it ended up with the shared library, it'll also then use something like bindgen to generate rust bindings to that shared library.
00:39:12.769 - 00:40:03.875, Speaker A: And we'll look a little bit about what those bindings look like because that's when we get into more of the FFI space here. So in the case of git2, you'll see it reads out a bunch of environment variables, and I have some opinions on these environment variables that we can talk about after we've looked at a couple of these. One thing that's pretty common is to have a feature that says whether or not to vendor the creating question, which you can set to one if you wanted to always vendor. Like never use the one from the system, even if it's available, always build it from source. Or you can set it to zero if you want to say never build it from source. And some crates will also have it as a feature. I forget whether Libgit 2 does.
00:40:03.875 - 00:41:14.259, Speaker A: Yeah, so it has a feature called vendored that carries the same property of saying if this feature is enabled for this crate, then build from source. Of course, the challenge with features is that they can get enabled anywhere in the dependency graph and then they get enabled for all consumers of because cargo will only build a given package once or given crate version once. So let's say you're a crate. Down here you take a dependency on git2 and you don't set the vendored flag, but you also take a dependency on foo, create foo and create foo also takes a dependency on git2, but with the vendored flag then you will get it vendored because cargo takes the union of all feature flags set across the dependency closure. So if you go back to the build rs, you'll see that first it looks at whether it's allowed to look for the system provided version of the library. So that is if it's not explicitly asked a vendor, then it will look. It uses this crate called package config and this is one that you'll see used a lot in these kind of contexts.
00:41:14.259 - 00:42:30.225, Speaker A: So the package config crate is a relatively thin wrapper around a command that ships on most Unix system called package configuration and we can look at package config pretty easily. So what package config does is you give it the name of a library and you say what information about that library would you like? In this case we want libs, so we want the link properties used to get this library. And in this case for lib sodium I just get l sodium and that's because libsodium is on my standard system path, so no L is needed, so it can just be linked directly. With lsodium, it has other properties too, like C flags, which is additional flags you have to pass to a C compiler if you want to compile this library. Libs will often include L if it's in some other system path. This is A very standard way of locating shared libraries. And that's why you'll generally see that these syscrates will be using packet package config to locate the shared libraries rather than like implement their own mechanism for searching through user lib and the like.
00:42:30.225 - 00:43:08.595, Speaker A: And the other thing that's nice about package config is it lets you do things like version requirements. So you can say, you know, at least version or max version. You can say things like I want to link against this statically. So you'll see here with libs I can also pass static to package config. And I'll say if you want to link statically, then you also have to pass pthread. Don't know why, but that's the rule for libsodium. And so package config just gives you the linker flags you're going to emit.
00:43:08.595 - 00:44:07.375, Speaker A: And furthermore it actually prints. Let me see if I can find here. After running package config, all appropriate cargo metadata will be printed on standard out if the search was successful. So what this is saying is as long as you use this crate, not only will it tell you whether a given library was available, but it'll also output all of the necessary of these cargo standard out instructions for a build script to do things like set the link search path and the linker args and stuff. So it's a really convenient way to do these kind of bindings. Oh yeah, I can show the path. So the way package config knows whether or not a library is available, where it's available, what version is it uses these package config files which.
00:44:07.375 - 00:45:05.539, Speaker A: So there's a package configuration, path, environment variables you can set to tell package config to also look in other places. But if we look at one of these files, it really just says where the thing is located, where its lib directory is, where its include directory is the name of the library, the version and additional link properties, link arguments that might be useful. So it's a very straightforward syntax for declaring these. So you'll see back to libgit2sys. If it's allowed to use the system version of libgit2, then it creates a package config. It uses that to scan for a range of versions that it knows that it can bind against it probes for Libgit 2 and if it finds it, then it also walks the include paths. I don't know why it emits this.
00:45:05.539 - 00:45:48.775, Speaker A: This is probably so that when building the crate itself it has access to. It knows where the include files are. I'm not sure why it does that, but it does. This is just the cargo colon key equals value like root doesn't have any special meaning as far as build scripts do. So this is just to communicate information about where the include directories are to the downstream builds. And then you say it returns like if it finds it this way, there's nothing more to do. The build script here is done and we'll talk about how the rust side of the bindings actually get produced in a second.
00:45:48.775 - 00:46:51.245, Speaker A: If it doesn't find it on the system path, though, you'll see it emits this rusty config saying lib get two vendored. The reason it does this is because that means you can now do conditional compilation on whether or not you built Libgit 2 from source, right? Using, you know, using config lib get to vendored. I don't know whether they use this anywhere, but at least now this means that they can. And then it does in order to build from source. So in order to vendor, it needs to have the source for the library that it's going to build. And the way it does that is it has Libgit 2 checked out as a sub module. But because when you git clone a repository, it doesn't include submodules by default they have this extra stanza that if the sub module hasn't been checked out, then run submodule update initial so that you get access to the sub module.
00:46:51.245 - 00:47:48.285, Speaker A: This of course won't work if the build is sandboxed, for example, because you wouldn't be able to run git commands because they need to access the Internet. But this is more of a convenience thing where if someone wants to build libgit 2 sys, you want it to just be they can just run cargo run and it works. And so that's why you have these kinds of additional stances when you run cargo publish, what happens is and we'll see if they did anything special with it in cargo toml. So you see they have an X. So cargo toml by or cargo when you run cargo publish by default will include anything that's not ignored by gitignore. So if they haven't git ignored libgit2, all of libgit2 is going to include it as well. So basically the Libgit 2 Syscrate source tarball on crates IO includes the source code for Libgit 2.
00:47:48.285 - 00:49:04.325, Speaker A: And you'll see this is one of the reasons why the version for Libgit 2 sys includes this plus here includes which version of Libgit 2 itself is vendored and bundled with that version of Libgit 2. And you see they have an exclude stanza in here to say don't include all these other files when you do a publish, because they're just irrelevant and large. And so in the builder rs, once they've made sure that they have the sub module, then what follows is basically all of the steps needed to build libgit 2 from source. So it uses outdoor to figure out where to build it, like what the scratch directory is essentially for building the artifacts. And then it's all the traditional things of figure out what target you're compiling for. They use the CC crate, which is a really nice crate. That's the wrapper around a standard C compiler that knows about all of the standard environment variables like CC&AR and LD and LD flags and C flags and CXX flags and CXXX, all of those things that the C world have accepted as things we use for compiling C code.
00:49:04.325 - 00:50:43.203, Speaker A: So you can just do CC build new and then set things like additional include paths, where to build, whether warnings are enabled. And you see all of this is just someone had to figure out all the steps that are required to build Libgit 2 from source. You see there are all these defines and then ultimately somewhere down here, so you see there are a lot of steps and so down here ultimately it calls config, which is still the CC builder compile, which is going to actually invoke the compiler and linker and stuff. And at least as long as that succeeds, it's going to then emit all of the necessary rusty links properties are needed, which the CC crate also takes care of emitting. It just emits some extra ones for Windows and Apple devices, and then it emits some additional rerun if properties here to make sure that if the vendored source changes, we rerun the build script. Ok, so that's the entirety of the build RS here. Any questions about all the stuff that this build RS is doing before we dig into how the Rust bindings of this come up? Oh, someone asked why the API for package config uses the name static with a K instead of C.
00:50:43.203 - 00:51:58.125, Speaker A: This is because static with a C is a keyboard in Rust, so you're not allowed to use it for function names. For example, you can. There's like, is it R? Which lets you. Yeah, so you can use this to declare that the name of a function is specifically intended to not be interpreted as its keyword, but it means calling the function is a little annoying too. So most people just use like the standard is, you know, instead of static, you use static, static instead of class, instead of crate, use crate, and so on. Does the user have to build the C library on their machines or can we publish a pre built so? So? Cargo doesn't prevent you from including a SO in your build artifact. And in very rare cases it's a good idea.
00:51:58.125 - 00:52:53.471, Speaker A: Usually not sos, but you'll see this with like more like OS or as usually for embedded platforms where it's really annoying to build the the hardware bindings for that device and so they'll just bundle it with it. The problem with doing that is those artifacts are tied to your build and execution environment. So imagine for example, that you're building on. To take a stupid example, you're building on 64 bit Linux and someone else is trying to run on 32 bit Linux. Your SO will not work on their machine. That particular example is outdated. But any kind of difference in target, difference in versions of libraries can come into play here.
00:52:53.471 - 00:54:08.225, Speaker A: In general, it's safer for you to use whatever they have on their machine or build on their machine than trying to build the sos. For any possible consumer, it's not impossible, but usually you want to avoid it. Okay, so all of the stuff that we've seen in Build RS right here, all it does is tell Cargo how to link against Libgit 2, right? Which is either just l get 2 if it's already on the system or built from source L to something that's in the outdoor. But that doesn't explain how do we actually call into these functions, right? Like ultimately that just means that the symbols are available in the binary. But how do we call them from rust? There are many ways to do this. If we here go to librs, you'll see that it actually has lots and lots of code in this librs that has this extern C keyword on it. You know, they declare lots of types, structs with repr C, all of this stuff.
00:54:08.225 - 00:54:58.955, Speaker A: And that is one way to do it. And it's actually a fairly common one for very stable libraries. So this is, you know, probably a. I'm gonna guess that this was generated by bindgen and then manually changed to be better. So this is a good time to talk about bindgen. Bindgen is a tool that, as it says, automatically generates Rust FFI bindings to C libraries. The idea here being if you have a C header file that contains, you know, the C function definitions and type definitions for an interface, you can call bindgen on it and it'll generate a Rust file that has the equivalent Rust types and extern events.
00:54:58.955 - 00:55:44.155, Speaker A: So if we went to. I wonder if I can pull this up easily. So this is the git to source code. And if I go to include git2h and I guess any arbitrary file in here, let's do something like commit H. This is just from the actual c library git2's header files. One of the things that it declares is git commit lookup. If we go in librs, you see there's far down the file.
00:55:44.155 - 00:56:19.585, Speaker A: I'm guessing this is oh Lord. Down here you see, they have a giant extern C block that just has lots of function definitions. And one of them is git commit lookup. And here they have the Rust equivalent types for all of the arguments. This takes a pointer to a pointer to a git commit, a pointer to git repository, and a pointer to a git oid. And these are the Rust equivalents of those arguments. And this is also how you do FFI in general is that you declare so extern.
00:56:19.585 - 00:57:01.741, Speaker A: How do I want to describe this? In the best way, the extern keyword, all it really does is it changes the calling convention used for that function. It says that, you know, in order to. If you call this git commit LookUp. There are two things that are different with extern. One is you don't give a body for the function, which is to say this function is not defined here. This is a declaration of the function, but it's not the definition of the function, or I get that backwards, it doesn't contain the body of the function. Basically, extern is saying this is defined elsewhere.
00:57:01.741 - 00:57:43.245, Speaker A: So just look in the symbol table of the binary and if you see a call to this, actually call that. And then it changes the calling convention to say if you just write extern. So extern fn, or in this case an extern block with an fn inside of it. What it's saying is use the C calling convention for this function. Don't use the rust calling convention, use the C1, which is what you would expect. And for anything that is extern C, you have to make sure that all of the arguments are, you know, the valid C equivalent arguments. So basically any struct here has to be repr C so that it can actually be used over that kind of call.
00:57:43.245 - 00:58:22.333, Speaker A: And so if we went here and looked for, you know, struct git commit. Oh, pub enumerated. Ah, so this is another pattern you'll see sometimes in FFI pub enum with an empty value. What this is saying is git commit is an opaque type to us. So in a bunch of places in the code we're going to pass around, you know, star, mute, git commit. And what we're saying is we don't want to try to turn git commit into a rust struct. Like git commit is defined somewhere in the git to library, but we don't like its internals are none of our business.
00:58:22.333 - 00:59:05.155, Speaker A: We're only ever going to pass around pointers to it and then use methods to get access to inner fields. Like if we want to look at the author of a git commit, we're going to call like git commit author and pass in that same pointer. So this is a way to say this type is really just an opaque type that we're only ever going to handle through pointers. And you'll see this is the case for a lot of these types. There are some that's not true for. So git revspec, for example, you see, we actually have a struct defined for with repr c with fields. And here the assumption is that git revspec is defined here to be the equivalent of how it's defined in Libgit 2.
00:59:05.155 - 00:59:46.709, Speaker A: And in this case, they've written all of these out manually. And there are some upsides and downsides to this. The upside of this is you can control the exact layout for all these types, not just the layout in sort of a memory sense, but you can control, like the naming of every field. You can control the exact, you know, there's some type definitions that are equivalent but are different ergonomically. You can, you know, add accessors, you can implement clone as you want. Like you have more control over exactly what the bindings are. And over time they're not.
00:59:46.709 - 01:00:21.603, Speaker A: They're stable. Like you implemented these and then you can just keep using them forever. You know that, you know the definition of git revspec here is not going to change under you because you wrote the definition. It does, however, mean that if the underlying library, like if libgit2 changed in some way and it matters for the bindings that you wrote, you're going to have to change those bindings bindings. The alternative to that is to use something like bindgen. So what bindgen does is it takes the C header files and generates a file like this for you. So no longer do you write this by hand.
01:00:21.603 - 01:01:06.565, Speaker A: It gets generated for you by a program, but that also means you have less control. Like bindgen is going to generate sometimes some very convoluted bindings that are going to be hard to sit down and manually read. They're going to be fairly unergonomic, but they are in general going to be correct sometimes. There's some really subtle things about making sure the memory layout is exactly the same between the Rust type and the C type that bindgen will know about. And if you hand write these bindings, you're going to have to know about them. The problem with using something like bindgen of automatically generating the Rust bindings here is that they might not be stable over time. So if bindgen changes, it might start generating different Rust code for the same C code.
01:01:06.565 - 01:01:47.855, Speaker A: And so this can be a backwards compatibility hazard for syscrates. Imagine that your syscrate just calls bindgen in build rs. And this is a fairly common pattern by the way. In fact, we can show how that works. So if I pull up the bindgen docs library usage tutorial. Yeah, so you add a build dependency on by gen oops. So build dependencies are dependencies of your build script.
01:01:47.855 - 01:02:50.405, Speaker A: Then you create a wrapper H and in our case that's going to include sodium and in your build rs. I guess we can just copy paste this whole thing actually and we'll see what the contents actually are. But we don't need extern crate here you see it. This assumes that you already have the necessary link stuff. So this is where you would use something like package config. In our case we can probably just do link to sodium rerun. If wrapper H changes and we say bindgen generate based on what's in wrapper H and write the bindings out to outdoor bindings rs.
01:02:50.405 - 01:03:41.415, Speaker A: So if I now run cargo R, it'll build bindgen. Oh, so before I go into this, someone asked why? Why are these empty enums rather than just being unit structs? The reason is because you don't want someone to be able to construct an instance of it. Because you're saying this type is entirely managed by that library. You don't want someone to be able to construct a pointer to one out of nowhere. And an empty enum is impossible to initialize. In Rust you can't create a git commit because there are no valid variants. And so this is a way to truly declare this type is opaque.
01:03:41.415 - 01:04:38.855, Speaker A: As far as the Rust side here is concerned, if it was a pub struct git commit semicolon, you could just Construct it by saying git commit. And we don't want people to be allowed to construct. Right. Our source main is going to have to change because now let's name this FFI and this is now going to be bindings.rs. all right, so now if we go into bill, no target debug build, no build build nfi. Ooh, let's actually print out. It doesn't want to let me do that.
01:04:38.855 - 01:05:17.315, Speaker A: Yes, you were getting lots. In fact, this already prints the path. What am I talking about? You see we get lots and lots of warnings now. And so if I open this file, which is going to be giant, you see this is in the out directory of the build script bindings rs and you see it says automatically generated by rust binden. And you see this is taking the Sodium.h header file, which is the main header definition file for all of lib sodium and generating the equivalent rust bindings for everything in there. Like every type, every function now gets a generated thing.
01:05:17.315 - 01:06:16.865, Speaker A: But of course this is huge. Like this is lots of stuff and everything is marked pub, which means that if I publish this as a syscrate and then bind gen changed, usually it ends up being a major version change. But even so, if I try to upgrade bind gen, I have to make sure that my public API did not change at all in backwards incompatible ways. Because if it did, I would have to do a new major release of my syscrate, which as we talked about, because there can only be one crate with links for a given library, I would also have to make everyone who uses my syscrate also bump there. So it ends up being this like giant explosion of things that have to change. Usually you can draw the boundaries at the crates that use the syscrate because their API can usually stay stable. But it's still a major undertaking if you have these syscrates, just use whatever bind gem produces directly.
01:06:16.865 - 01:07:19.995, Speaker A: But it is also really convenient because it means you don't have to hand write these bindings. There are a couple of ways around this. So for example, you can have a private module that includes the bindings and then you can have a, you know, pub use FFI the specific things you want to expose from there so that you don't expose the whole thing. You can also, you can also in your build rs and we'll do this once we actually start writing these bindings for real. You can do things like blacklist function blacklist functions or types to say any type that contains foo bar don't include in the bindings or you can even do this the other way around, where you can do whitelists only include things that include an encrypt box. And that way you're limiting what bindgen will actually generate bindings for. We'll take a look at that when we actually look into the Libsodium API.
01:07:19.995 - 01:08:20.585, Speaker A: So in general, for syscrates, you want to find ways to ensure that your public interface is at least somewhat stable. And for Libgit 2, the way they did this was just check in the binding whether they're auto generated and then tuned, or they were entirely auto generated and just checked in, or they were handwritten, check them in so that you don't generate them automatically on every build. And in fact, this is one of the reasons why the bindgen crate comes with a command line tool as well that you can use to generate the bindings just as a once off. Okay, so that's what bindgen does. That's the sort of step for generating these bindings that Libgit 2 does not make use of. It just handwrites these instead. Before we get to lib sodium, I want to continue walking through some the build scripts of some existing crates that do this, just because it's useful to see a little bit of variety here.
01:08:20.585 - 01:09:00.835, Speaker A: So this is the SSH2 crate, which generates bindings to the libssh2c library. It also has, you know, a workspace with two crates, one called SSH2 and one called libssh2sys. If we look at it, you're going to be unsurprised to see that its cargo Toml says that it links against SSH2 and it has a build script. And if we now go to its build rs. In fact, let's look at its lib RS first. You see it too has manually written bindings for the same reason. It wants to be able to control its stability over time.
01:09:00.835 - 01:09:41.385, Speaker A: But you recognize a lot of the patterns, right? So you see these pub const. If we look at the generate bindings here, you see bindgen also generated a bunch of pub const, right? And I bet you there's if we go down a little bit. So you see it generates a lot of pub type which are going to be type aliases for types that are used elsewhere in the definitions. And some of these we don't really want it to be using. It shouldn't need to generate bindings for maxalignty. So some of these we would allow list or block list. But I want to see if I can find some non trivial types here.
01:09:41.385 - 01:10:48.755, Speaker A: So here, for example, you know, there's a type crypto state. This is an example of something that should probably just be an opaque type, right? Like we shouldn't be knowing about the field called opaque here. So this is something that we might, you know, in manual bindings turn into one of these, because we know it should never be constructed in the first place. So those are examples of patterns that bind gen doesn't know that we want to treat that type that. And if we look at the bindgen documentation for builder, you'll see that it actually has a lot of configuration options. You can say things like how do we want it to generate the equivalent rust code for cenums? And there are a bunch of different options. If I minimize this, you'll see you can say things like whether to generate comments, which things to allow list and block list.
01:10:48.755 - 01:11:46.675, Speaker A: You can inject arbitrary rust code or C code. You can mark a type as opaque. So this is the example of it's going to generate, you know, an empty enum instead of actually trying to traverse into the fields. And so we'll end up using a bunch of this when we work with Libsodium typealiases whether to derive different traits, like sometimes for FFI types, maybe you don't want to derive any of them and implement them all manually. You can control that here, whether to support namespacing, what to do with callbacks. There's lots and lots of stuff you can do in Bindgen here. So back to SSH2, let's look at its build script and this is going to look pretty familiar, right? It's going to down here.
01:11:46.675 - 01:12:37.041, Speaker A: So lib ssh2 is a little weird. By default it doesn't use package config, it requires you specifically opt into it. And there's some debate about whether that should be the case or not. But if it's allowed to use package configuration to discover the system one, then it will use package config like we talked about, and use find library for libssh2, which, you know, automatically emits the necessary buildrscargo instructions. It also sets the include path, which might be convenient for downstream libraries, and then it returns. So this is the same structure as we saw for Libgit 2. You'll notice that this doesn't set any version required requirements for the library at all, which if you can avoid it, is nice because it means that in more cases you can avoid building from source and you see it does the same.
01:12:37.041 - 01:13:47.445, Speaker A: You know, lib ssh2 is checked out as a sub module make sure you actually check out that sub module so that you can build it and then go and try to build that entire C library from source so it creates a where is the config CC build into outdoor and this will look familiar. You know, it does all these other things it might need to do to set the include paths. And in fact, here, you know, this is depth z include. This is an example of one of those cargo instructions using just key equals value. So this means that there's a. The lib Z syscrate emits a, you know, cargo colon include equals of its include path for the Z library, the compression library. And we consume that here so that we can tell our build of libss2 to also discover the include path for the compression library by using this, this environment variable, the cargo automatically set that's based on cargo key equals value.
01:13:47.445 - 01:14:49.557, Speaker A: And you see, if we consume an environment variable, we also tell cargo about it so that we get rerun if it changes and it does some stuff to parse out which version of libss2 we actually used, store that in a file and then builds SSH2 and then it's done. You'll see the mention of this VC package as well. This is if you're on Windows using msvc, then you can't use package config because it's Windows, so you have to use VC package instead. So nothing terribly surprising here either. You'll see it makes slightly different decisions about whether to use things from the system or not. And there are other examples here. So the OpenSSL crate is a little bit of a beast because there are so many different versions of OpenSSL and different variants like this LibreSSL as well.
01:14:49.557 - 01:15:30.715, Speaker A: You'll see if we go to the it actually has a subdirectory for its build script. So it's build main RS because they have all these other things to use. If we look at the main RS here, it looks somewhat familiar. So it finds OpenSSL links against. It tries to find the version by looking at the include directories. Determine mode is it tries to figure out whether you want to build against OpenSSL statically or as a shared library. And if we look down here at determine mode, it's down here somewhere, I think.
01:15:30.715 - 01:16:18.505, Speaker A: So it reads this environment variable called OpenSSL static. This is also a pretty common pattern in syscrates where there's an environment variable called the name of the library underscore static. And if it's set to zero, then we don't statically link. If it's set to anything else, then we do statically link and if it's unset, then we just we use whether or not a A and a so exist to decide what to do. So if only the a exists, then we statically link. If only the so exists, then we dynamically link and if it contains both, then we do a dynamic linking. So this is like, you know, the OpenSSL1 has taken a lot of care to try to make sure that every possible combination of flags work.
01:16:18.505 - 01:17:49.043, Speaker A: And I don't think we're going to dig into too much of all the details of what it does, but if we go down here a little bit further in main, you'll see it does findopen SSL which calls this function findopen SSL which if the vendored feature is enabled and we haven't explicitly through an environment variable said don't vendor then use this findvendor module to get open a cell and you know findvendor is going to check out the source, do a build and then link against it. And otherwise that means if the feature isn't set, or the feature is set but the environment variable to not vendor is set, then find it from the system paths which is going to use package config. Okay, so this is a very long procedure of steps, but you'll see that they're fairly similar between these different libraries. The general pattern is if you can use it from the system, then use it from the system, otherwise build it from source. What I would recommend is if you're doing this yourself for some library, think really hard about whether it's worth vendoring. Vendoring is convenient for consumers because it means that if they don't have the library installed locally, you just build it for them and it works. But the chances that building it from source is extremely complicated and error prone is pretty high.
01:17:49.043 - 01:18:25.277, Speaker A: And so there's a decent argument for if you can't find it in the system, you should just error and tell the user to install this library instead. Like in the case of Libsodium, if someone doesn't have libsodium installed, I don't want to have to build libsodium from source. So instead our build script can just issue an error saying install lib sodium and then try again. And that's what we're going to do as well. We're not going to try to figure out how to build it from source through CC in Rust. I don't think it's worth it. The other thing is how you decide whether or not to vendor it's also Somewhat convoluted.
01:18:25.277 - 01:19:27.775, Speaker A: It seems like the general best practice that's emerged is you have a feature that lets people opt into vendoring if they specifically need vendoring. I don't know why that is, but if you specifically need vendoring and then you have an environment variable that overrides the feature saying never vendor. And the reason this is useful is because there are some users who have very strict requirements about how source code is brought into their builds. If they're trying to do hermetic builds, for example, or if you're at a company and you want to make sure every source that's brought in has been checked in all sorts of ways, you generally don't want any vendoring. You want to make sure that everything is provided by your build system. Like imagine if you're in something like Buck or Bazel or whatever you want it to error if OpenSSL wasn't available, because that means it hasn't been declared in the standard build environment. You don't want most of your application to use one OpenSSL, but your Rust parts use a different OpenSSL, usually not what you want.
01:19:27.775 - 01:20:09.791, Speaker A: And so in general you want to provide this kind of override mechanism to say if you can't vendor, if you can't, sorry, if you can't find it in the system, then I just want an error. I don't want you to build it yourself. Okay, so now we've looked at a bunch of these other libraries and how they do their bindings. So let's now talk about Libsodium. So, so Libsodium, I'm not going to go through all of what it does. That's not really important for what we're looking at here. Also, Libsodium does have Rust bindings, so there's a crate called Libsodium Systable which does basically everything that we're going to do today and more.
01:20:09.791 - 01:21:01.603, Speaker A: You'll see it has a build rs and that build RS you're going to be unsurprised to learn uses package config and to find the library. If it doesn't, it vendors it by building it from source, like all of the stuff that we just saw. And it too has, you know, in its source it has sodium bindings which have all of these auto generated things from bindgen. It has a script that calls bindgen to regenerate that file, but that way it's not automatically run so they can choose when they read regenerate the bindings. And then it has a lib.rs which just pub uses everything from the generated bindings. So what we're building today is not intended to be like published as this is the thing to use, use the one that already exists.
01:21:01.603 - 01:21:42.525, Speaker A: In fact, there are even like, you know, nice ergonomic wrappers around the FFI stuff, which is usually how you want to structure this, right? You want the syscrate to just be the FFI bindings and then you write another crate that provides like safe wrappers and ergonomic wrappers about every around everything. Vendoring usually means built from source. Yeah. Okay, so let's now figure out what to do about Libsodium. So the place we're going to start here is installation. I've already installed Libsodium. I installed it just on my system.
01:21:42.525 - 01:22:47.399, Speaker A: So let's now go over here and I actually want to exit from that and I want to do cargo new lib and we're going to call it Lib sodium sys. And in our cargo tunnel we're going to say lynx equals sodium. And in our build dependencies we're going to steal that from over here and then we're going to do exactly what they tell us to do, which is wrapper H, which doesn't include sodium H. So this is basically copying over what we had elsewhere. We're going to copy the build rs. So in this case I'm not going to be too concerned with. Oh, not going to be too concerned with API stability for this one test.
01:22:47.399 - 01:23:46.463, Speaker A: I guess that's fine as I'm not going to be concerned with API stability. So I'm just going to run bindgen at build time and we can do a little bit better here. Like here we could use package config. So if we do docst, we just do in our cargo toml, we're going to say another build dependency is package config equals 0.3. And so up here we're going to say, and you see here in the docs for packaging figures as not recommended to have no version requirements. And the reason for this is because it's unlikely that your bindings truly are not. Do not have a version requirement.
01:23:46.463 - 01:24:28.635, Speaker A: Right. When you generate the bindings, you're generating them from a particular version of the C header files and that means they're going to include, you know, functions that exist in that version but not earlier ones. So you do generally want to include like an at least version. So we'll, we'll do that too. Like so probe sodium. And you know, if you're curious about what version Lib sodium Is we can do that with. So you can provide version requirements to package config 2.
01:24:28.635 - 01:25:08.797, Speaker A: You'll say here I just put in a version that I happen to know works. It says dependency requirement. Lib sodium greater than 1018 could not be satisfied because Libsodium has version 10 which suggests that that's where we should start. Right? We're generating bindings based on 1018, so that's what we're going to use. And package config is going to generate the link search and the link lib for us. So those we can just remove. We do want to make sure that if the wrapper that we had changes, then we rerun the build script and this bind gen config, we're almost certainly going to have some things to change.
01:25:08.797 - 01:26:06.911, Speaker A: And in fact if we go back to the bind gen docs, go to the builder allow list function, we want to do dot allow list function. So if we go back to lib sodium we need to start somewhere, right? So quick start. That's a lot of stuff I want to see. I want usage or quick start maybe. Ah, quick start. Okay, There's a function called sodium in it. I just want to check that like the F of I bit works.
01:26:06.911 - 01:27:01.345, Speaker A: So for now what we're going to do is we're going to only allow list that function and then we're going to generate the bindings based on that. Why does it not? Am I blind? Oh, it's because there's a newer version of the tutorial is wrong. That's why the package convig command line tool is a Linux tool. It's unrelated to the or it is not provided by a Rust package. Okay, so it says package configuration could not find system library sodium. Oh, that's because it is not called that. It is called lib sodium.
01:27:01.345 - 01:27:57.067, Speaker A: Great. So if we try to do something like build with verbose touchwrapper.h which is going to redo a bunch of the things. What we'll see here is at the build at the end you'll see it includes dash l sodium which comes from package config. You'll also see it does this dash capital L. So search path user lib this is. I'm going to go with a bug in package config which is that it will emit the cargo instruction for setting the dynamic library search path, even if that search path is the standard location for search paths for shared libraries.
01:27:57.067 - 01:29:13.555, Speaker A: And so we want to opt out of that because that's just wrong and it causes them really Hard to debug problems sometimes. So I want print system libs false. So if I now run this, you'll see it just does dash l sodium, which works because lib sodium is in user lib for me. Okay, so now we have, at least in theory, our build RS is going to generate the bindings for us and hopefully it just generated the sodium init function. And our lib RS currently doesn't really source liberals currently doesn't do anything. So what we want here is something like mod FFI include concate ENV outer bindings rs and I forget whether there's a. What does bindgen tell me to do here? Yeah, great.
01:29:13.555 - 01:30:01.035, Speaker A: And they say to allow these things. So what we'll do is we'll actually allow them on just that module. And so in theory here we should now be able to do pub use FFI sodium in it. You see I got auto completion here. It's because the build script was run and so this include actually, you know, it's just a regular macro that includes that file which exists. So if I here do you know, ffi colon colon pub use ffi colon colon I actually get what's in there. And you can see here the signature the bindgen generated for sodium init is it's an unsafe FN that returns an i32.
01:30:01.035 - 01:30:48.725, Speaker A: And in fact, you know, if we, if we go to definition on this, it's not going to let me do that. That's fine, show me. I want that file. It's going to be target debug build. Yeah, so if you see if I LS there, you see it generates directories for all sorts of the dependencies that are built. In our case, what we want is lib sodium sys, which has a bunch of different files. And the one in particular we want now is anything that's slash out bindings rs.
01:30:48.725 - 01:31:20.371, Speaker A: Why there are two of it, I'm not sure, but let's go look at this file. See, this is what bindgen generated. This is an extern C block which says for these. These are defined elsewhere and they use the C calling convention. It's a pubfn. Every extern function is inherently unsafe because we don't know whether the signature even matches what the real function does, much less what that function does in the first place. So there's no need to write unsafe here.
01:31:20.371 - 01:31:49.781, Speaker A: It just is unsafe. Sodium in it takes no arguments, which makes it really easy to generate. And the return value is a cint. Great, so far so good. And if we go back now to libsodium you'll see here that they also recommend using package config to link against it. They say that in in int main all you have to do is run sodium init and if returns minus one then it's an error. Otherwise use the library.
01:31:49.781 - 01:32:34.915, Speaker A: In fact, sodium init initializes the library and should therefore be called before any function provided. Lib sodium it's safe to call this function more than once and from different threads subsequent calls won't have any effects. Okay, so this is pretty common in C libraries that you have like an initialize function you have to call like for gtk this is the same. There are ways in Rust to like run a function at load time. So there's a crate called ctor that lets you annotate a function with ctor and it'll run before main as long as your crate is actually included. And we could do this. We could have a CTOR for our library that runs sodium in it and then everything else just uses it.
01:32:34.915 - 01:33:26.957, Speaker A: Now the downside of using something like CTOR is that if there's an error, there's no good way to report it to the user. And my guess in fact is that over here and it might stall. That's fine. I wonder if it tells us anything about the sodium init function must be called before any other function. It's safe to call sodium init multiple times or from different threads. It will immediately return -1 if it's already been initialized. Yeah, so what we probably want here is actually something more like, you know, here I'm both doing the F bindings and the nice thing around it in the syscrate, which is sort of a no, no.
01:33:26.957 - 01:34:49.385, Speaker A: But this is to demonstrate what's going on. So if we now do, you know, pub, we declare a pub struct sodium. We're going to mark it non exhaustive because we want people to not be able to construct this type without explicitly calling our constructor. But we're going to say it's clone and it's debug and then we're going to do impul sodium and this is going to return, you know, a result of self or we don't really know yet. And what that's going to do is unsafe FFI sodium in and if this is less than zero then error. And this is going to be a pub fm. So the intention here being that, you know, any other function that we want to declare that uses Libsodium is going to be like, I don't know, I don't have A good example.
01:34:49.385 - 01:35:46.731, Speaker A: Bindings for other languages. Quick start in FAQ I want to write bindings for my favorite language. Where should I start? Start with the cryptogeneric hash API. Great. So that's probably the function we want to start with. So you know there's going to be a function like this and by doing this I don't know what it's going to return yet. What we're basically guaranteeing is that the user will have called like we will have satisfied the library invariant that sodium in it has been called first by virtue of calling by virtue of having a sodium which they can only get by calling new.
01:35:46.731 - 01:37:22.895, Speaker A: There are other ways to do this too, right? So you can have an init and you could have like a static has been init which starts out to be. In fact this could be something like a one cell a bool that starts out as being one cell new false and then we could have init instead. Do you know if basically if it hasn't already been inited then initially and that way you don't need to actually keep around self, you could just have every function down here like assert has been in it. The problem with doing it that way is that you're going to enforce this at runtime rather than compile time. If you have an API like the one we originally started with, you're going to guarantee at compile time that init has been called non exhaustive on a struct mostly has the effect that you can't that external users as in users of this crates library API cannot construct one of these or destruct one of these. They have to use our constructors. So it works for basically this has the same effect as giving this type a a non public field.
01:37:22.895 - 01:38:25.755, Speaker A: Same effect but without needing the extra field. Okay, so this now does FFI like if we now do here, you know it works. We should be able to do sodium sodium new and unwrap sodium from cargo test. Okay, so this, this now called sodium in it, right? We know that it works because sodium new calls this which calls sodium in it and it should return an error if that returns a value that's less than zero. But it returned okay, because the unwrapped didn't fail. So we are now doing FFI right where we saw that it links against libsodium. This test actually calls that method and so it works like we now have FFI working.
01:38:25.755 - 01:39:53.025, Speaker A: Okay, before we continue from here, is there anything in the path to where we are right now that doesn't make sense or that you'd like me to talk more about, like, separately from. My words are escaping me. Does any of this not make sense? Is there anything you'd like me to go into in more detail? Is there anything that you think would be useful to get a second explanation of to talk at me? I always wanted to port or write a wrapper for a simple C library for learning purposes, but every time I try to tackle that, it becomes very complicated to understand the C code. So usually you shouldn't need to understand the C code as much as you need to understand the C API. And with something like bindgen you might not even need to do that because it'll generate the equivalent rust types for you. And all you need to figure out is what are the semantics of these methods. Basically, how do you turn this direct unsafe C API into a nice ergonomic interface? And that can definitely be some work, like we did with sodium new just now.
01:39:53.025 - 01:40:55.435, Speaker A: And I mean, we'll try to do crypt generic hash too, just to see whether we can get it to work work. But most of the time you shouldn't need to dig deep into like the C code itself. Okay, so let's see if we can't get cryptogeneric hash to work as well. So we're now going to go back to our build RS and we're going to say in addition to allow listing that function, we're going to allow list cryptogeneric hash. Great. And let's see what that generates. So if I now go back to my lib sh and in fact we can get rid of the pub use here of the FFI again, remember, we should probably have the FFI binding be in a separate syscrate and the ergonomic interface should not be in that syscrate.
01:40:55.435 - 01:41:44.525, Speaker A: And then the reason here being you're more likely to make breaking changes to the wrapping API and you don't want to have to do breaking changes to the syscrate because those are really annoying. But for now, just for exposition, let's pretend that FFI here is a separate crate. This is a little easier to set up. So let's look at what the binding that we got here was. There's something weird about my. All right, so cryptogenery cache does this aha. Cryptogenetic hash function puts a fingerprint of the message in whose length is inland bytes into out.
01:41:44.525 - 01:42:44.095, Speaker A: The output size can be chosen by the application. The minimum recommended output size is this. Okay, so there's a constant here that we also want allowlist var and we probably also want. In fact, we probably want anything that starts with this because there's a constant for the minimum and the maximum and for the recommended bytes. And so here they're basically giving the invariants that this API tries to enforce and these are things that we should turn into basically invariants in our rust code that we assert and panic on if they're wrong. Why do the bindings use cint? So CINT is not quite. They're not necessarily the same as U32.
01:42:44.095 - 01:43:56.035, Speaker A: Sometimes the C ones are platform dependent, for example and we want to capture that in the generated bindings, which is why we use the CINT instead. Ok so so this suggests that there's going to be a. There's an out which is going to be mute U8 there's. And in fact, you know, here we could use. Because we don't require this to be initialized already we could hear say what's the rust completely spacing on the init. Maybe on init that's what it's called. So we can say here maybe on initial.
01:43:56.035 - 01:45:34.955, Speaker A: So we're going to take, you know, the input which is going to be a U8 an output or a key I suppose and an output and you know, there's an argument here for instead of having the call to provide the output, we could allocate a vector internally, for example and do the right thing. But now if we now go to generic cache, let's go back to the definition of it. We want to assert that the output size is at least this. So we want to assert that out dot len is greater than or equal to this expected usize found u32 that's interesting. I wonder why. Let's go look at the bindings again. I don't actually want it to.
01:45:34.955 - 01:46:12.097, Speaker A: I just wanted to regenerate the bindings. Target debug build lib sodium sys star out bindings RS and I want to look at this one. Yeah, so you see it actually did bring in all of these con. This. These consts. Now I wonder why they're defined as U32s. You see it did bring in exactly the two ones we wanted and then all of the consts.
01:46:12.097 - 01:47:26.533, Speaker A: So this is one way to just build up the bindings in a useful way is to just allow this specifically the things that you're like ready to handle. Okay, so what this means is as you size and in fact here we can do this is what Clippy would also yell at us for this to ensure that if the type of this ever changed in the future we could. We would get an error saying that it might not fit in usize usize from U32 is not defined. What else did they require? Minimum required output size. Oh, minimum recommended. Okay, so we know it has to be more than min, we know it has to be less than or equal to max and we're not actually going to deal with the recommended one because it's not something we have to enforce in the API. It's up to the user to try to fit that key can be null.
01:47:26.533 - 01:49:01.085, Speaker A: Okay, so you don't have to provide a key recommended key size but the key is going to be the same. Right? Let's go to our build rs so we should still get yeah, key bytes min and key bytes max so we're going to do the same thing here where if let some key is key then we're going to assert that the key length is key bytes key bytes okay and then we should be able to do, you know, out.s as mute pointer.len in.as pointer this is input, this is input len key is. So let's do key and key len is if let some key equals key then key.as pointer and key.len
01:49:01.085 - 01:51:24.265, Speaker A: otherwise it's going to be pointer null and zero didn't like that. Did I do something foolish? So here we're going to do. So the out is a maybe on init and the reason for this is because we know it's going to be overwritten by the, by the generic hash method and so we can just. We're totally fine with this being uninitialized memory that we get in because we know we're going to be overwriting it and so here in fact what we can do is we can set that returns a mutuate but in order to do that we need to, you know, we need to turn it into the appropriate type when we pass it in here and that's going to be taking that and turning it into one of these. Why is this? That's fine. And this is going to be out as U64, as U64 and as U64 go to definition doesn't work here because the definition is the include which is a little sad actually. Like if I do this it just takes me there and I, and if I go to definition on that I get the include There might be a way to like go to implementation but I can't find that now this operation is unsafe.
01:51:24.265 - 01:52:44.577, Speaker A: That's fine. And so here we, you know, we can say safety We've checked the requirements of the function min max and the Presence of self means that INIT has been called. And so here, I don't know what the result here is. What does it return? Why does it not say what the return value? In doesn't actually say what the return value is? That's unhelpful. I'm guessing it's just success. Like, if. So we're going to do, you know, we probably want a real error value here, but it sounds like a lot of them just use like a generic failure error.
01:52:44.577 - 01:54:12.047, Speaker A: So in this case we're just going to use unit. And so we're going to say, you know, if res is less than zero, so this is the same as what we did for init, right? Then we're going to return error otherwise. And we could do this if we want. Otherwise we need to turn this into the appropriate thing, which is we know the cryptogeneric hash has overwritten the contents of out. And so what we'll do here is maybe an init and it's like assume it's array, assume init slice, slice as slice, assume init mute about. And I think this one actually has a maybe an INIT slice as mute pointer, which is what we actually want here. And these are of course, unstable library features.
01:54:12.047 - 01:55:50.305, Speaker A: Because why would anything be on fine, fine, fine, fine, fine, set nightly, that's fine. So we want to feature maybe on INIT Slice, maybe on INIT Slice. This is also pretty common, right, where you're converting between the types that the C API expects, which is usually the pointer to the first element of a slice, and the real rust slice types. So in our case, when we call into C, we turn them into raw pointers and then coming back, we need to then do the checking that we might need to do and then basically assume that the C library did what it proposed or what it promised rather, and that now out contains the appropriate bytes. So here we can do this and say safety cryptogeneric hash writes to and thus initializes all the bytes of out. Yeah. So the question here then becomes what does generic hash actually promise? Does it promise that it writes to all the bytes of out? And I don't know whether it says.
01:55:50.305 - 01:56:42.577, Speaker A: Yeah, it doesn't actually say that it does, but it says the output size can be chosen by the application. Someone is saying is chat that generic cache. And Blake 2b, which is what generic cache uses, guarantees that it writes the number of bytes you dictate, which is what we're. What we're going for, as long as it's less than max, which we check is the Case up here. And so as long as that is true, this is fine. So now the question becomes, you know, can this actually hash something? So if I now do it, you know, hashes I do sodium new unwrap and then I do. And in fact sodium here can be copied too.
01:56:42.577 - 01:57:14.021, Speaker A: All that matters is the new has been called at least once just to make it a little more convenient to use. And because it can be copied, this can just take self so it hashes. We should be able to do call s cryptogeneric hash of. I don't know what the input should be here. I wonder if they have like an example that'd be useful if there was like a test we could do. Aha, nice. Let's use this one.
01:57:14.021 - 01:58:14.059, Speaker A: So we're going to say input is going to be arbitrary data to hash. The B prefix here is saying treat this as a byte string rather than a UTF 8 string. Let bytes equals this the key. We're going to say we don't have a key and the out. It's a little annoying that we have to have an out here. One of the things that we could actually do here is with a slightly fancier const generics we could make this generic over the length of output and key and then put restrictions on it to say, you know, this must be an array that's short, that's longer than mine and shorter than max but sort of out of scope for this particular implementation here. I just want to see that it works.
01:58:14.059 - 01:59:03.515, Speaker A: So what we'll do is we'll do let mute out. And what do they use for out here they do this. Yeah, so we're going to do let mute out equals. I wonder if I can. I wish there was a sort of alloc here, but. Oh, maybe there is actually. So we can do maybe of FFI cryptogeneric hash bytes as usize.
01:59:03.515 - 02:00:09.665, Speaker A: And then here we can do mute out. And now these bytes should be the hash of this. So if I now do, you know, let me bring in dev dependencies, something like the hex crate 043 and I want to print line hex encode of bytes. And now if I do cargo test here. Okay, so both the test passed. That doesn't really help us here. Oh, we probably want to say that it's okay for the.
02:00:09.665 - 02:00:45.513, Speaker A: We're okay for dead code in here too. There's like a bunch of like never used for the constants. But what I want here is it hashes and I want to see its output. Okay, so prints a hash. The hash is the Same every time. That seems promising. And if I change the input arbitrary data to hash in Rust and then run it, I get a different hash.
02:00:45.513 - 02:01:40.135, Speaker A: So this seems like it hashes. It seems like we have the hashing API working and that's sort of all there is to this part of the ffi, right? Like you make sure that you get the sort of raw definitions working the raw externs and the wrong types, not wrong raw types which bind gen can really be helpful with. And then you write wrappers that, you know, make the assertions that are needed by the real the APIs and variants, structure it with more ergonomic Rust types and then you have a safe API that implements that's implemented on top of the raw API. Check it against B2Sum. Do I have B2Sum? I do have B2Sum. That's a good point. I wonder if that will work actually.
02:01:40.135 - 02:02:38.631, Speaker A: Yeah, fine. That's unhelpful. Can I set the output size here? Length, length. I need to know what this length is. 32. So if I do L32, 32 times 8, 256 and this is going to be different because it includes a new line. And hey, we get the same hash.
02:02:38.631 - 02:03:14.437, Speaker A: So this hash that we got from doing the FFI is the same as this hash, which is what we get from the real. Blake2 Nice. Great. So now we have, you know, working FFI in this direction. Now you might wonder, well, what about going the other way? Like, what if the C code wants to call Rust code and the process is exactly the same? Right? So. So, well, mostly so what you would do is let's say that the C API expects a function pointer of some kind. Kind.
02:03:14.437 - 02:04:29.817, Speaker A: Well, you can just declare extern fn. This is rust. And you have to make sure that, you know, the, the arguments are, you know, valid C types. What is the actual definition of this? I thought I could just cheat here, but I guess not. So you declare a function like this and then, you know, let's say that there was some FFI function that required a function pointer to this. You can actually just do, you know, you can just pass this is Rust as I think you have to cast it specifically as like a star FN type thing. But that's all you really need to do.
02:04:29.817 - 02:05:12.231, Speaker A: And then the, the C code can treat this just like it would any other function pointer in C itself. It just happens to be calling a Rust function. Usually the thing you want to do here is you got to make sure that the type is extern. You got to make sure that all the arguments and all the return types are valid at representation in C and match what the C code expects to be calling. And the other thing you want to be careful about is memory allocation. So in general, if you allocate memory in Rust, you'll want to make sure it gets freed and dropped in Rust. If you.
02:05:12.231 - 02:06:02.455, Speaker A: If it gets allocated in C, you want to make sure it gets deallocated in C as well. Where things gets weird is, you know, if imagine there's a C function that expects to call, you know, some callback, you provide it and it's going to return memory like it calls a Rust function that returns like a vector or something, but cast into the appropriate array pointer for C. If C then tries to free it, you're going to be in for a bad time. So you want to keep track about where the allocations and deallocations happens. And usually it's best if it all happens either in the C code or it all happens in the Rust code, rather than try to mix and match and remember. The other thing that's worth knowing about is nomangle. So no mangle you can put on a function so that its name actually ends up exactly like this in the final binary symbol table.
02:06:02.455 - 02:06:41.205, Speaker A: If you don't do this, what's going to happen is the compiler is going to still compile this function, but it's going to be. It's going to have a sort of auto generated name, which isn't a problem if you only ever pass pointers to it. But it can be a problem if you actually want to name this function from C. Like imagine that in the C code, you know, let's. Let's pretend that this is C. You know, in C you're going to have something like this is rust int externs car. Like imagine you have this definition in C.
02:06:41.205 - 02:07:14.365, Speaker A: Then it expects that the final symbol table of the binary has a function called this is Rust. So there's no function pointer being passed here. It's just the C implementation is expecting this function to exist under that name. So in that case you actually have to declare this as no mangle to ensure it gets included in the final binary. Right? So like it's basically it's pub. And also. And also that it retains its name so that it actually ends up under the name that the C implementation expects.
02:07:14.365 - 02:07:59.947, Speaker A: But that's all there is. Like there's nothing more special about the FFI going the other way. It just makes sure that you match the calling convention and the types and the representations and then you're kind of good. Are you duplicating the out reference? Is that allowed? I'm not duplicating the out reference I'm given because what I'm saying here is that the return type here is tied to the same lifetime as this. So if someone gives me a mutable borrow of this, the mutable borrow I give them back. Depends on this borrow. So they're not allowed to then continue using this mutably as long as this value still lives.
02:07:59.947 - 02:08:40.645, Speaker A: Which we can test in the, in the test here. Like if I here try to. Then do you know bytes here is referring into out, right? And this is therefore also referring into out. So I should be, I should not be allowed to do something like out zero equals one or even this. And indeed I get the error. Cannot use out because it was mutually be borrowed up here. One thing I could do here, right, is I could restrict this a little bit and say that the thing you get back is expected to be read only.
02:08:40.645 - 02:09:18.725, Speaker A: There's no real reason to do that, but we can if we want to. Okay. I think that's actually all I wanted to cover in this. We've talked about build scripts in a lot of depth. We've talked about FFI in both directions bindings. We did a basic binding to Lib Sodium which we've tested, actually works. Is there anything else I want to talk about here? Let's see.
02:09:18.725 - 02:10:05.889, Speaker A: So, yeah, so Cargo gives example of like what you use build scripts for bundled C libraries, finding C libraries, generating Rust modules, platform specific configuration. Yeah, so there's one last that I wanted to talk about, which is so there's a crate called autoconfig and autoconfig captures. Actually there are two things I want to talk about, but let's do auto config first. AutoConfig tries to do something that a bunch of different crates were previously using. Build RS4 and they were sort of doing it in ad hoc ways. And it's doing basically compiler feature detection. So the idea here is that sometimes you want your code to be compatible with old versions of Rust, but on newer versions of Rust you want to take advantage of newer features.
02:10:05.889 - 02:11:03.855, Speaker A: And auto config can let you do this because what it basically does is it can test compile a program and emit a config that you can do conditional compilation based on based on whether or not a given program compiles. So for example, you know, it can say declare a config if the compiler has this type or if it supports nightly features. Or if it has a given type available. There's a lot of stuff you can use this for. Very commonly it's used for detection on whether you can use a particular nightly feature, detecting whether a given type is available, getting the sysroot from Rust C in case you need that somewhere else in your binary. Check whether a trait exists, check whether a constant exists. Basically all of these things that you can do detection of in build RS to figure out which conditional compilation properties you can make use of.
02:11:03.855 - 02:12:13.755, Speaker A: Auto Configure is a very light dependency, like it has no transitive dependencies and it's intended entirely to be used in build rs and it's used by things like, I think anyhow uses it to figure out whether it can use nightly features to do things like make backtraces nicer. And so that's one way to have your. Your crate optimistically or conditionally use nightly features rather than making the whole crate nightly only. There is some work on config accessible, so this is also a cool feature that we don't have yet. But config accessible is something that they're working on adding to the language. There's another one which is config version, I think, and both of these are going to let you do conditional compilation based on whether a given path so like a type trait constant is available in the current version of Rust being used. And this is going to basically mean that you can do this without needing autoconfig for a lot of it.
02:12:13.755 - 02:13:11.395, Speaker A: The other thing I wanted to talk about was. So we talked about bindgen which lets you generate Rust bindings for based on C header files. There's also a tool called C Bind Gen, which is the inverse. It takes a Rust API and it generates C header files that then let you call the Rust code from C. And this is useful if you say, have a Rust library that you build as a shared library and you want to be able to use it from Python or Node JS or just C or C, where those languages know nothing about Rust. They also expect to use the C abi and so you generate a C header file that they can then use basically their equivalent of bindgen to get bindings into their language and thus call you Rust code through the cabi if you happen to be talking between Rust and C. Bindgen doesn't work that well for C header files.
02:13:11.395 - 02:14:09.025, Speaker A: And calling Rust APIs from C when you're constrained to the C API is a little limiting. So there's a great crate called cxx which tries to allow you to build a better, a more ergonomic interface between specifically Rust and C. It does require that you make some changes on both sides of the interface so you have to be able to control the C code and the Rust code. But if you do, you can basically use this little thing like this crate, which lets you basically define the bridge between these two languages and have it generate bindings that are much nicer for each language. So if you happen to be in that situation, I recommend giving CXX a look. Okay, I think that's where I want to end. I don't think there's anything else I wanted to talk about.
02:14:09.025 - 02:14:49.195, Speaker A: There are examples of a lot of the things that I talked about today in the cargo book under Build script examples. So definitely give that a look too if you want to refresh some of this after the fact. Any questions at the tail end here before we end for the day? I think two hours is a pretty good estimate. Happy with that. I don't know when the next stream is going to be. I've given up on trying to promise. I've gotten some good suggestions for more crust of Rust I could do.
02:14:49.195 - 02:15:23.613, Speaker A: I do have some longer implementation streams I want to do, but I'm not going to promise when I'm going to do them. All right, in that case, thank you for coming out everyone. Hopefully this was interesting and I'll see you all next time. Whenever next time ends up being. If you want to keep an eye out for when I stream, you can follow me on Twitter. I am generally pretty good about mostly tweeting things that are related to my streams or at least related to Rust. There's also a discord.
02:15:23.613 - 02:15:39.885, Speaker A: I'll put the link in the video description for Rustation Station for the podcast that also has sub channels for streams and so you can also keep an eye out there. All right, so long. Farewell, Avidir Sen. Goodbye.
