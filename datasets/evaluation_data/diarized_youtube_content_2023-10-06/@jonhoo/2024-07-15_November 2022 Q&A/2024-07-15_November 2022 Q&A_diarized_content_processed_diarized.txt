00:00:01.840 - 00:00:40.715, Speaker A: Hello everyone. Welcome back to another stream. This time it's another one of those Q and A's which I'm always. I always find it weird to do a Q and A because I'm like, why would I have answers to any questions? Like who am I to try to give answers? But people keep asking for it, so I figured why not do one. I shared a link to a page that has where you can like ask questions and vote on questions. And so I've been keeping track of those over the past, you know, week or so. And my plan here is really just to go through the questions from most voted on to least voted on and just have a bit of a chat about each one.
00:00:40.715 - 00:01:09.115, Speaker A: One thing I'll mention, just because of all the mayhem that's currently going on in Twitter is that I am on other platforms too. Although I need to get better at actually maintaining them in particular. Let's see how well this works if I do this. So I'm also on co host.co host.org John who I'm also on Fostodon. Let's see if I can actually figure out how to open that one.
00:01:09.115 - 00:01:33.715, Speaker A: Aha. Which is just fostodon.org on who. Fostodon has gotten some a bit of a bad rep recently because apparently they have some blocking set up against the Macedon service in Japan, which is not great. Hopefully that's something that can be undone and repaired. Oh no, the Q and A link stopped working. That's unfortunate.
00:01:33.715 - 00:02:03.609, Speaker A: Let's see. I think it's back up now. At least it's back up for me. The way this QA and A is going to work is I'm just going to do the questions top to bottom by most voted on to least voted on. And if you think of other questions as you go, just put them in the Q and A site. Other people will vote on them. I'll mark things as answered as we go, so you'll see which ones are still the candidates for being answered.
00:02:03.609 - 00:02:43.305, Speaker A: I'm guessing we'll probably go for a couple hours, which is pretty wild, but we'll see how long we go and when the questions start to dry up, I'll try to keep an eye on chat as well as I go. Let me switch back to this, you know, in case there are smaller follow up questions and such. But for anything that's sort of a change in topic, I'm going to use the Q and A list instead. Oh yeah, interesting. I think this website is struggling under the load, but at least it looks like I generally have access to the question. So we'll see how it goes. All right, first question.
00:02:43.305 - 00:03:33.271, Speaker A: How do you manage your time for work, open source, personal projects and life? So this is one that I get a fair amount, not just in public, but privately too, from people that I mentor, for example, of how do you find the time to do basically more than one thing? And I don't think there's a great answer to this. One of the challenges with having side projects is that you only have a finite amount of time. The I think there are two pieces of advice maybe that I would give here. The first one is you will never find time. You have to make time. That, that applies to me just as much as anyone else for things like streams. It's not as though I just magically have like a five hour gap in my calendar to do an implementation stream.
00:03:33.271 - 00:04:24.131, Speaker A: It doesn't work that way. It is, I have to like allocate that, you know, two weeks from now I'm going to do a five hour stream on Saturday so that I don't have any other plans that time. And the second observation I would make is that make sure that you do things that you find to be interesting. It's pretty easy to make the time for things that are fun. But if you have side projects that you're not as enthusiastic about as, as the other projects, you end up just not spending time on them. That's in practice what happens. And so it's important to sort of evaluate your side projects and figure out which ones are actually worthwhile spending your time on.
00:04:24.131 - 00:05:27.265, Speaker A: Which ones are you finding joy in, so to speak? Like, I know for me, I've accumulated a lot of side projects that are hard for me to put aside. And it's not necessarily that I still care about them, but it's. I feel an obligation to continue to maintaining this, that this happens for things like open source projects a lot where, you know, it's something that I built 10 years ago and I no longer need that particular thing, I no longer use that particular thing. But I am still the owner and I feel a responsibility to continue to maintain them. And finding times for those is pretty hard. And one of the things that I've been thinking a lot about is how can I offload some of that work, be it just market as abandoned or try to actively solicit new maintainers. It's difficult in terms of managing time more broadly.
00:05:27.265 - 00:05:51.495, Speaker A: I don't really use a, a system. Arguably I should. I've. I've found though that if I sort of look at My schedule. I, it's not as though I have, like, if I filled my calendar, I wouldn't have lots of things to put in the calendar. It's not as though I have, you know, tons of meetings. Let's ignore work, like, just assume work is one chunk, like one unit chunk of my calendar.
00:05:51.495 - 00:06:39.565, Speaker A: But for all the other stuff, it's more that just things come up or I discover things I want to spend time on. So it's not really things that I can plan, plan out in advance. I do try to plan for open source work. So in general, I now do open source work like sort of every weekend. Like I let it build up over the course of the week because after I get home from work at the end of the day, I don't, I often don't want to sit down and do more programming, even though I really enjoy programming. But, but I end up, you know, feeling as though I've, I've expended some of that creative energy. And then when I get to the weekend, I then catch up on my GitHub notifications, like some of the streams that I've done on a day in the life of open source maintenance, it's that kind of stuff.
00:06:39.565 - 00:07:42.695, Speaker A: And so I do end up sort of dedicating time to it. But it's not as though, like It's Saturdays from 1 to 4, it's more. I know that on Saturdays I tend to do catch up on, you know, email and open source and even that was a struggle actually to say, you know, I'm going to not respond to things immediately. It was a, there was a lot of, I don't know, resistance in me towards making that trade off because I feel a, I don't know, a sense of responsibility or something where I want to address things straight away. If I, you know, if I'm just sitting on the couch and watching TV or something, I feel bad about not responding to, you know, an open PR or an issue or whatever. But at the same time I know that if I tried to respond to everything, if I tried to address everything quickly, then it would be counterproductive because effectively what would happen is I would burn out. I wouldn't have enough downtime.
00:07:42.695 - 00:09:35.265, Speaker A: And I think managing your own sanity in that sense and recognizing that, like you need to have time that isn't set up to do something productive as well, otherwise you go insane. All right, I'm going to consider that one answered, even though it's a big complicated topic, but I think it's hard to give a complete answer to It. All right, next question. When picking third party libraries for your Rust projects, what design architectural, technical attributes makes you use one library over another? Are there any red flags that you pay attention to? This is a difficult question and I don't mean that just personally, but I think professionally as well, it's a difficult question for anyone who's looking to adopt Rust and any programming language. To be frank, this all ties back to effectively supply chain security, or in this case it's more like supply chain sustainability. Maybe of not just do I, do I trust this project? Like in the sense of do I trust that they're responsible maintainers and they're not going to publish anything malicious, but beyond that, right. I want to take dependencies where I think they're being responsibly maintained in the sense of do I think maintainers are going to stick around or is this going to be abandoned at some point? Do I think that the developers have a sufficient commitment to things like backwards compatibility? Do I think that they generally address feedback, performance issues, PRs in a timely manner, or are they very hands off in terms of maintaining this project, which I'm guilty of in some of my projects too often to tie this back to projects that I built a long time ago and no longer actually use myself.
00:09:35.265 - 00:11:06.473, Speaker A: And I don't think there's a right answer for how to evaluate whether a given library is a sustainable dependency to take. I think there are some indicators though, right? So I had a Twitter thread on this a while back. There's also something known as the OSSF scorecard, the Open Source Software foundation scorecard, which has these scoring metrics for how good or bad a project is, how, how responsibly maintained it is along various different axes. It, you know, I don't know that it has a complete set of the kind of things I would evaluate. There are some things there that I don't really care about, but the kind of things that are on that scorecard are things like do they have CI setup? Do they have. Is their CI setup relatively secure? Do they have fuzzing in place? Do they have tests in place? How many open PRs do they have? How many open issues do they have? What's the ratio between open and closed? I think for me there are some other aspects that come into this that end up being more social libraries that are developed by maintainers that I've had good experiences with work pretty well. Basically, anything built by David Tolnay, anything built by burnt Sushi, like those are.
00:11:06.473 - 00:12:57.941, Speaker A: Those are strong indicators of quality and not Just that it's currently high quality, but also that it will continue to be a thing that's worth depending on. Other factors I look at are things like when they respond to PRs, when they respond to issues, how do they respond? First of all, when do they respond? But also do they respond in a fashion that I think encourages people to contribute, to take ownership of that project and actually help out long term, or is it much more of a sort of brush things off? Other thing that matters are, do they have decent testing infrastructure? I think that matters a lot. Do they have a decently constrained list of dependencies? I'm not quite on the extreme side of your dependency list needs to be zero, but rather I do think that you should have some amount of discerning taste over which dependencies you choose to take or when you choose to take a dependency and not. But ultimately it ends up being a very subjective evaluation, which I think is unfortunate. At the same time, I don't really know what a better alternative is. So there have been proposals for things like either a sort of blessed set of crates for the Rust ecosystem, or even trying to build the sort of batteries included version of the standard library that has many of these crates in there like Regex and SERDE and such. And I don't know that I love proposals like that either because you end up essentially cementing the status quo, right? You end up making it not necessarily harder to develop a competitor.
00:12:57.941 - 00:14:02.645, Speaker A: And I don't mean competitor in a, in a commercial sense, I just mean in the sense of, you know, another crate that tries to achieve the same thing and ends up doing it better. And you just make it harder for people to adopt those because it's so easy to just use the ones that are on the list that they get so much credence by virtue of being on the list. And if you have something like a blessed crate list, you do have to make somewhat difficult decisions, right? You, you want to. You probably don't want multiple crates that do the same thing, but that then also means that you can't really swap out one for the other because that's sort of a breaking change in your suggested list of crates. So it just becomes a really hard evaluation. And I think we have good examples of where it would have been a problem if such a blessed crate list existed or an extended standard library existed. You can think of things like, you know, before we have had serde, we had Rust Serialize, which I'm glad we have SERDE over Rust Serialize, but Rust Serialize was used Everywhere until SERDE came along.
00:14:02.645 - 00:15:19.835, Speaker A: And so, you know, if we at the time had blessed crates, SERDE might not never come around. And I think we have the same potential for SERDE going forward. Right? It could be that SERDE is not the be all and end all either. Maybe we come up with a better design for how serializers and deserializers should work. And if so, if SERDE is one of the blessed crates, then how do we even make it possible for such a thing to be built and gain traction and get adopted and be moved to. Another instance of this is lacy static, where these days in general you'll want to use one cell instead of lazystatic, but it similarly was used and is used everywhere. So it's tricky and I don't know that we can codify the attributes that matter because there's this problem too of if you make a metric your goal, and I think there's a well known way to phrase this, but basically if you make your metrics your goal, then people are going to start to essentially gamify this and try to figure out ways to beat the system to get good at the metrics because they are the things that people look at without necessarily actually making the project better.
00:15:19.835 - 00:16:39.641, Speaker A: You can imagine someone writing an extensive test suite that basically doesn't test things very well, but ends up scoring well on the metrics around testing. And I don't think we necessarily want that kind of gamification either. The same thing applies for trying to come up with objective scoring for Is this a sustainable dependency? Is this a risky dependency? It's difficult because not just are there a lot of metrics that go into such a score, but also what things you weigh heavily for your project might be different from what I weigh heavily in my project. And navigating those nuances is if all we assign is one or two scores is difficult. Once you start assigning semi arbitrary numbers to things, a lot of nuance tends to get lost. Oh, why one cell rather than lacy static? There are a couple of reasons for this. I think the big one, I forget all the details, but one of the big ones was that with lacy static, your initializer for the lacy static happens sort of at a special time in the library.
00:16:39.641 - 00:17:38.935, Speaker A: It happens in a sort of magical early function that gets called when your library is loaded and that means it's harder to do things like handle errors. You don't really, in some sense your program. The lazy statics get initialized before your program gets to run, so they can't really do anything like Handling failure gracefully with one cell. It takes a different approach of saying, when you access the thing, you also give the initializer. And that way the value gets initialized during your program execution, which means that you also have a way to propagate errors. And so that ends up being slightly more reliable way of doing initialization, or not necessarily reliable, but more flexible, more powerful perhaps. All right, let's mark that as answered.
00:17:38.935 - 00:18:51.309, Speaker A: Okay, so this next question is, how can you morally justify working for Amazon, especially in light of Amazon's anti unionisms? This is a question I struggle with a lot. And obviously this is where I give the caveat of this is my personal opinion. This is not the opinion of Amazon or whatnot. But I struggle with this because the way the question is framed, it ends up being a very black and white question of Amazon bad, therefore why you work for Amazon. And I do understand the framing of the question, but I take some issue with it, which is that it assumes that things are always right or wrong. And I don't mean that in the sense of like, the particular actions are being called out, like anti unionism is, at least in my opinion, just bad. But it's more a question of my decision to work there ends up being a multifaceted decision where what I have to trade off is the benefits of working there versus the drawbacks of working there.
00:18:51.309 - 00:19:31.977, Speaker A: And in the. In the drawbacks buckets are things like, there are many things that the company does that I don't like and that I want to distance myself from. But at the same time, there are things that I'm enabled to do by virtue of working for this company, in particular, in the role that I have that I see as significant advantages that I think would be very difficult to get anywhere else. And so ultimately it ends up being this kind of trade off of, you know, I can get benefit. I can. And when I say I can get benefits, it's not necessarily about me. It's more about the impact I feel I can have on the world where there are good things I can do by virtue of being in this role.
00:19:31.977 - 00:20:30.851, Speaker A: But there are also bad things that this company does. And how do I trade these off? How do I weigh them relative to each other? And at least for the time being, the balance for me comes out to I think I can do more good than the bad that results from me being there. And so some of the examples here for me is stuff like I end up having a decent amount of. What's the right word here? Impact on the adoption of Rust at Amazon you know, a lot of my work is essentially enabling more and more teams, more and more developers to make use of Rust. That in turn has a, a positive effect on Rust as a programming language, Rust as an ecosystem. And what we can argue about, you know, is companies using a language, a good thing. But I think in general it means that, you know, there are more jobs created using this language in general.
00:20:30.851 - 00:21:13.125, Speaker A: Right. It becomes a better known language. The fact that a large company adopts it widely is a signal to other companies that they should start adopting too. So it creates jobs not just there, but elsewhere as well. Using this language, it, at least the way I tried to push, means that more resources end up being funneled into the Rust ecosystem beyond just the company. And I think if I wasn't there, it's not as though Amazon would stop doing things with Rust, but I do think it gives me an ability to steer the direction that, that involvement takes. And I, I don't think there are many other places I could do that at the moment.
00:21:13.125 - 00:21:35.405, Speaker A: Someone mentioned the chat. Thanks for even considering to answer this question. I thought about it a lot, actually. I saw this question come up and I was like, not surprised. Right. This is a very obvious question to ask, but it's also a thorny question. It's a difficult question to answer and it's one that I struggle with myself.
00:21:35.405 - 00:22:21.945, Speaker A: I don't, I can't claim that I have the right answer here. All I can claim is I've tried to balance this in my head and I've come out on the side of, for now, this is still the right thing for me. Yeah, and someone also makes the argument in chat here that if all the good people avoid working at Amazon, then Amazon never gets better, which applies to any company. Right. That argument only goes so far where it assumes that given a sufficient number of good people, the company changes for good. And that's not always true. I do think it's true in Amazon's case, but that becomes entirely speculation.
00:22:21.945 - 00:23:22.955, Speaker A: Right. Following on that thread, what would it take for you to take a similar step as Faster than Lime? Yeah, so Amos path here is an interesting one that I've thought about doing myself too. So Amos Faster than Lime recently announced that they were going to start doing open source full time, open source, writing, teaching. And I've considered doing the same thing myself for a long time. One of the reasons why I didn't was because, um, in it's hard for me to do that in the US because I'm on a visa and in particular I'm on an employer sponsored Visa. And so that means that I can't, I can't do work that isn't associated with an employer and self employment is real tricky. And so I can't have a Patreon or GitHub sponsorships on the side because it's condition, it's considered work from elsewhere than my primary employer which is not permitted.
00:23:22.955 - 00:24:19.415, Speaker A: And I couldn't do full time work on Patreon GitHub sponsors because they aren't full time employers. They wouldn't sponsor my Visa. It is something that I've considered more in terms of when I do eventually leave the US that might become more tenable. But as Amos pointed out in the article they wrote as well, it is a scary step because suddenly your livelihood ends up being shifted to depend on a lot of people who all contribute a little, which is difficult, right. It ends up being a pretty significant change in risk. It's harder for you to lose all your income, but it's also much harder to achieve a livable income on something like that. There, there are relatively few people who can sustain themselves only on that kind of work.
00:24:19.415 - 00:25:43.401, Speaker A: And I think, you know, a related problem here is that, and I think about this a lot too, that let's say I started a Patreon today or a GitHub sponsorship or both today I would feel bad about people sponsoring me with large amounts of money, you know, the large, relatively speaking here because at the moment my salary is pretty good. And so that would be a sort of wealth shift in the wrong direction, if you will. But at the same time, if people don't contribute much because they see that I don't really need it or I say that I don't really need it, which then is true, it means that it's a more difficult choice for me to choose to leave the sort of relative comfort of my current job for that because I don't see what the actual payout would be and I would have to sort of take the leap and gamble on the fact that people would increase their contributions when they see that I no longer work for a big company. So you know, it's a scary step and I'm very curious to see how it ends up going for Amos. And I really hope it goes well because it's a path that I would love to take as well. I think for me it would take a, maybe a slightly different path in that I think I would focus a little bit more on teaching. Right.
00:25:43.401 - 00:26:30.361, Speaker A: So I would continue to do my open source stuff. I would continue to do things like streams, probably much more regularly. But also I might do things like offer maybe some kind of class, maybe some kind of workshop, maybe even, you know, pay this amount of money and I'll come teach the engineers at your company about Rust. You know, I think I would have to find some of those kinds of opportunities to make it sustainable, but it would be really fun. It's something I think would be great. How does part time interact with that? Yeah, I've wanted to be part time for a long time, but again, US visa doesn't really let me do that. It is something I could potentially do in Europe, right.
00:26:30.361 - 00:27:35.625, Speaker A: I could, I work part time and then do Patreon GitHub sponsors as a part time thing for a while and the sort of transition slowly as I see it become possible very much also a path I've thought about. It is a little harder to land part time work, but I think it might be doable. This all becomes. It's something I can't really do at the moment, so I haven't looked enough into it to know whether it's a tenable thing for me to do in the future. All right, next question. Would you recommend any beginner friendly open source Rust projects? This one's tricky because as I evidently say for basically every question, I think that the best beginner friendly open source projects are the ones that you start yourself. Because trying to learn someone else's code is a lot of work and not always worth it.
00:27:35.625 - 00:28:15.763, Speaker A: It could be that you start learning a thing and you don't really care about the project. You just want to have an ability to contribute and to learn from a big code base and that's not a great environment to learn in. Whereas if you're building something that you need you deeply care about, you're going to be much more enthusiastic about building it. And if you started from scratch, then you don't have to also try to learn, in addition to learning the language, have to learn someone else's code base and learn the problem domain that you're not familiar with. And so I actually think that I would recommend starting things from scratch. There's an exception. There are two exceptions to this.
00:28:15.763 - 00:29:24.213, Speaker A: One of them is if there is an existing project that you find really interesting or cool, right? It's something that you have use for or you have an interest in, or ideally both, where you know, you feel a passion and enthusiasm and excitement for learning how it works, then I think that those are great projects to start with. And you know, when it says beginner friendly people put different meanings into that description. Right. So beginner friendly could be things like mentors are available or there are issues that are beginner friendly you could start tackling. I don't that helps. But for me, beginner friendly is a weird term because it assumes that beginners are not slow to learn, but it assumes the beginners can't handle complex problems, which I don't think it's true, it takes them longer. But that's where it ties back to if you have the enthusiasm, the excitement, then even if there's a complex problem to solve, you might have the energy, the drive, the motivation to really dig into them and understand them.
00:29:24.213 - 00:30:49.573, Speaker A: So I would caution against recommending don't touch any particularly complicated problems if you're new and instead say, tackle the problems you think are interesting to work on because they're the ones you're likely to be most productive in and feel like you're making the most out of. My traction on the other exception here is there are some projects that are very good at bringing people into the fold. And so here I'm thinking of projects like Bevy have been pretty good at this, Clippy has been pretty good at this, the Rust project itself has been pretty good at this. And so there are some where, you know, there are enough resources, enough people who care about onboarding around to, you know, make the project relatively smooth for people who are inexperienced to get onto. But at the same time, I don't think that means that you should start working on them if you don't care about the problem domain. Right? Like if you don't care about working on a compiler, then you shouldn't start contributing to Rust C. Or when I say compiler here, the compiler is pretty large, it has diagnostics, there's a lot of type theory in there, there's also lexing, parsing, there's performance.
00:30:49.573 - 00:31:40.603, Speaker A: There are a lot of interesting components of a compiler, but if you don't care about that domain of things, then even though it's a beginner friendly project, it's not one I would recommend you start working on. So. But it can be a good candidate if you find some of those problem domains interesting. Yeah, and another good recommendation here in chat is to do something where you have relatively fast feedback loops. So in general with like human learning, we learn by getting feedback. And so if the distance between or the time between you submitting something to getting feedback on it is very long, that's going to be much harder of an environment for you to grow in. Now, the feedback doesn't necessarily have to be human feedback.
00:31:40.603 - 00:32:36.197, Speaker A: It could be something like if you're doing performance optimization, then how quickly can you get results on your iterations and your improvements? But sometimes human involvement is important here too. If ultimately your goal is to contribute back, then you know, if you ultimately submit a PR and you don't hear back from for a year, your learning sort of stops there. And so this, this comes back to. It's worth looking at whether the project is basically dead or whether there are people who, who seem like they might be willing to help someone get, get started and at least, you know, contribute feedback, if not mentoring instructions. Let's see. Okay, I think, I think that's about the end. I'm just scanning chat for whether there are follow up questions to this one.
00:32:36.197 - 00:33:36.777, Speaker A: If you have questions that are on different topics, then just submit them to the question site because that's the thing I'm going through for getting new questions as I go. I'll put the link in chat again. What are your thoughts on webassembly? I think webassembly is really cool. I love the fact that Rust has sort of leaned into becoming a pretty strong player in that ecosystem. I think Rust is a good fit for compiling to webassembly as well. Unfortunately, I haven't done much webassembly myself, but it is something that I want to do more of, if only because I see it as being a pretty exciting path forward. You know, we were stuck in this, in this, I don't want to say rut, but we were stuck in this world where you could only use JavaScript for front end development for a long time.
00:33:36.777 - 00:34:27.243, Speaker A: And the fact that that's changing I think is pretty cool. The other thing that I like about it is that webassembly is becoming a sort of interoperability language or interface maybe between different programming languages that is not just the C abi. And I wonder with things like WASI whether that's going to make a huge difference to how we do things like develop, you know, correlated binaries. Think of things like plugins and extensions. Right. Where maybe instead of trying to link with the C abi, you do interfacing through webassembly interfaces. That'd be really cool, but because I haven't used it that much myself, I'm hesitant to, you know, get.
00:34:27.243 - 00:35:13.431, Speaker A: Try to claim that I have any right answers in that domain. Yeah, the website seems to struggle under load. If you refresh it all, the event, the Q and A site comes back again every now and again. Yeah. What I'll probably Do actually is after the stream, reach out to the maintainers of the site and be like, hey, it looks like you struggle a little under load. All right, what would it take to drop Vim and adopt another editor like Helix? It would take a lot for me because I don't really have any problems with Vim. When I say Vim, I mean Neo Vim.
00:35:13.431 - 00:36:13.575, Speaker A: Although Vim itself has gotten pretty good too now. But like, why would I switch? I genuinely just don't have complaints about any of him. I and I also, you know, I exclusively use my editor in my terminal. I love the fact that I can, you know, SSH into a machine and have the exact same editor experience as I do elsewhere. So, you know, while I think it's really cool that people are developing new editors and I understand the appeal, I understand the excitement, I don't need what they bring. You know, neovim has a lot of plugins, it's extremely customizable, it has key bindings that by now I'm extremely used to it or Vim. You can get everywhere, it runs everywhere, the key bindings you can find for basically every editor.
00:36:13.575 - 00:36:54.555, Speaker A: So I just don't really see a strong selling point for switching editors at this point. I think there are some arguments for things like if you build things in, you can make them faster. I'm thinking of things like syntax highlighting or language support more broadly like autocompletion. And that is true. But at the same time this becomes the monolith argument of you can build better things if you co build everything together. But at the same time you end up with a more strongly connected and strongly coupled design. That makes it harder when, you know, something like LSP comes along.
00:36:54.555 - 00:37:38.785, Speaker A: You know, if you built an editor before the world of LSP and you weren't leaning into having everything be supported by plugins, then it becomes harder to move to something like that. I don't know, I just. I don't really have a desire to move away and that's maybe where the challenge comes from. And yeah, I know that there have been a bunch of people asking me to do another stream on my desktop and editor and hardware setup. And I know I've promised this for a while. I will do one. One of the reasons why, and I've said this in the past too, why I haven't done one yet is because I don't feel like my neovim setup is stable.
00:37:38.785 - 00:38:28.091, Speaker A: I still think things are sort of shaking out in terms of how you should configure LSP, for example, with NeoVim, and I feel like if I did a video on it, the chances that it gets outdated in 6 to 12 months is decently high. And that's unfortunate. But maybe that just says I should do a new one every 12 months to update people on my setup. It could be my configs are already on GitHub, so someone pointed out that they've been using Helix for about a year and that they're lazy and don't want to keep maintaining a large config. And it's interesting because I don't actually feel as though my vim config requires me to do maintenance on it every now and again. I do. Every now and again.
00:38:28.091 - 00:39:13.827, Speaker A: There'll be changes to one of the plugins I use, for example, or we'll move away from one plugin to another and I have to do some work. But I found it to be relatively rare in general. It kind of just keeps working, and then for me, the tiebreaker often ends up being that I want it to work in a terminal, and most editors just do not work in a terminal. You can't run Sublime in a terminal, you can't run VS code in a terminal. You can't run IntelliJ in a terminal. So I don't even want to consider those editors. And you know, there's the flip side argument of, well, those editors have plugins that let you interact with something that runs on a remote system.
00:39:13.827 - 00:40:12.547, Speaker A: To which my answer is yes, that's true, but I would rather just SSH there and use the editor locally. The editor is so close to the developer experience that, you know, if I'm going to want a terminal there anyway, why not just use the editor there? But I do. At the same time, I recognize that there are limitations to what you can do in a terminal environment, and having a fully graphical editor does give you some abilities to play with more interesting designs for things like code suggestions and autocompletions and stuff that are hard to pull off in a terminal. I appreciate that argument. I haven't seen anything that's compelling enough for me to move away from the the setup that I already use. Have you tried to pre configure neovim setup like Astrovim? Nope. Again, I don't really know why I would.
00:40:12.547 - 00:40:48.315, Speaker A: I'm pretty happy with my setup, and I feel like I would rather keep adding things until I have only what I need. Then I would have take a giant dependency and then remove things or disable things until I get to what I want. Debugging from other IDs debugging is when I hear a decent amount. Right. If people want these sort of native debugging experience, you get in a more graphical ide. I understand that. I just haven't found the need for that.
00:40:48.315 - 00:41:53.545, Speaker A: Like, for me, I get very far with just like print line debugging and gdb. And it is true the experience is nicer in an ide, but it's not a compelling feature for me. And maybe that's because the development that I do it ends up that I do less of that debugging. I'm not sure. But that's just never really been that much of a pain point for me. Okay, I'm going to consider that one answered. Next one is what features would you remove or rework from Rust? I get this question every now and again and I always find it tough because I don't really have a sort of hobby horse of or I don't have a backlog of things where I'm like Russ did this wrong.
00:41:53.545 - 00:42:41.017, Speaker A: I think there are some smaller things. Like one thing that's pretty frustrating is around things that stabilized in the standard library before we had capabilities that we have today. And what got standardized could have been better if it wasn't standardized that way. But that would be a sort of 2.0 kind of discussion. It's not really something that's broken with Rust as much as it's, you know, a result of a language growing over time. An example of this would be something like boxed errors.
00:42:41.017 - 00:43:38.681, Speaker A: So if you have a box din, you know, error plus static plus send plus sink, that type does not itself implement error the error trait. And that makes it really annoying to work with in some, some cases, especially when you're using something like anyhow, like the two aren't. You have to play tricks to get them to cooperate. And it can be pretty frustrating. So there are some of those kinds of like pain points things I'd remove. There's been a lot of discussion about whether the pin trait should have been unsafe or the unpin trait rather, which, you know, I see the argument for why it is correct for it to be safe, but I also see the argument for why it would have been nice if it was unsafe because there are so many foot guns. But these are all fairly minor.
00:43:38.681 - 00:44:22.737, Speaker A: Like, I don't think I really have a sort of this whole thing is broken. I have things that I. I wish Rust had, but they're not really things that are there that I would change as much as they are things I think are worth fixing up. So These are things like custom testing frameworks would be really nice to have currently. The fact that Rust has a built in notion of unit and integration tests is really nice. Arguably Cargo has a built in notion of them less so. But I really wish we could see innovation in how to develop testing infrastructure.
00:44:22.737 - 00:45:04.587, Speaker A: I think it'd be cool to see what kind of things we can get there. Cargo next test is a test runner, but it doesn't really give you mechanisms for doing test setup and teardown and output reporting change and that kind of stuff that I would love to see innovation on. And currently we don't really have a good framework for doing so. I don't, I don't really think I have other things I would remove. I think I'm relatively happy with where we've landed and, and the things that I see coming down the pike. All right. Oh yeah, Cargo Bench is another one.
00:45:04.587 - 00:46:21.717, Speaker A: Although there too, I think custom test frameworks are arguably the answer rather than standardizing how to do benchmarks. All right. Do you think Rust is on its way to become the next C due to the complexity of the language? That question did not go where I thought it was going to go. So I think this is asking, are you worried that Rust is becoming as complex as C is I. So yes and no. Rust is certainly growing more features, and that does mean that you have more tools in the language and that does make the language potentially more complex. At the same time, a lot of the things that we've gotten in Rust recently, I'm thinking of things like generic associated traits are, at least in my mind, not really making the language more complex as much as it is filling in feature gaps.
00:46:21.717 - 00:47:03.555, Speaker A: Right. So if you think about Rust in a sort of abstract sense, not in terms of what the language currently supports, but just like what the language is about, you think of, you know, trait bounds and lifetimes and those kind of things, generic associated types seem obvious. They seem like a thing you should just be able to do. And the fact that that wasn't possible was a limitation of the implementation of the language. And making that possible, at least in my mind, arguably makes the language less complex because there are fewer rules for things that won't work. Now, of course, it does mean that things like trait bounds can now grow more complicated. Right.
00:47:03.555 - 00:48:51.615, Speaker A: So there's sort of the difference between the complexity of the language and the complexity of what you can build in the language, the complexity of the abstractions. And so I think it actually makes the language simpler, but it makes it possible for abstractions to be more complex, and I think that's generally the right trade off. Like, I do think that you want a language that feels relatively complete, or rather feels like it doesn't have obvious holes, because holes are a terrible thing to try to understand when you're learning the language of like. But why can't I put a lifetime parameter here that makes no sense? Why can't I put it like in these places, but not those places? I think we know that another candidate for this is typealias impul trait. So existential type aliases where it's something I think folks learning the language probably expect to be able to do, but they just can't. Inferred bounds might be another example where why doesn't this just work? Why does the compiler require me to either not do this or do it a different way, or spell things out when the compiler should just know that it's true? Borrow checker bugs have a similar flavor, right? There's one long standing bug in the borrow checker where if you return early from a function and you borrow something in the return, like the return value borrows something that's also used in the remainder of the function after the early return, the borrow checker can't reason about that and ends up just refusing to build your program. Like the borrow check fails and you can have entirely correct code that just gets rejected.
00:48:51.615 - 00:50:16.313, Speaker A: And it's a terrible beginner experience if you run into this because your mental model is correct but the compiler is telling you you're wrong and that's a bad mismatch in some sense. I think this question is really Rust is Rust's theoretical capabilities is Rust's type system, let's call it too advanced, too sophisticated, to the point where it allows abstractions that are so hard to reason about that the experience of using the language becomes painful. And I think there's a similar question to be asked about something like Haskell, or if you go even further into formal verification where you have languages that allow you to arguably state anything like your bounds are very complicated because they're essentially proofs those things are. They are harder to work or harder to reason about, but at the same time they provide immense value. Being able to have the compiler check things for you, I think is worth the cost of the added complexity that's required because we basically need to state more facts about the code that we write. That's effectively what trait Bounds ends up being. And I think that's worthwhile complexity.
00:50:16.313 - 00:51:01.551, Speaker A: And I think that that complexity is slightly different from C's complexity. I Think C's complexity comes more from the language and the syntax than from the sort of theoretical type theory complexity. Let's see. C gross features. With compromises, Rust can grow. With lesser compromises, maybe. There are certainly compromises in Rust too, although I do think that we have been fairly good at trying to develop or trying to land features that have a decent amount of cohesion with the language that exists already.
00:51:01.551 - 00:51:37.033, Speaker A: And there's a little bit less design by committee. Yeah. So another thing that comes up in chat is whether Rust and C end up being bloated languages. And bloated here too has multiple different meanings, and it depends on which meaning you use. Like the Rust standard library is definitely not bloated. It's a very narrow standard library. It's very deep but narrow.
00:51:37.033 - 00:52:19.879, Speaker A: So option, for example, has tons of methods on it, but we don't have things like an HTTP server or a client or anything like that. So we cover less ground, but we cover it very well. Is that bloat? I don't think it is same for syntax. I don't know that. You know, when, when Rust introduces new syntax, I think it's usually for a good reason. I think we're decently good at only introducing it when needed. That said, Rust does have a lot of syntax, but I think that ties back to the fact that as I talked about a moment ago, you know, Rust has a type system, a sort of theoretical underpinnings that.
00:52:19.879 - 00:53:36.635, Speaker A: That are more powerful in a sense than some of these other languages, and therefore needs to have more syntax to be able to represent the fact that it has more concepts in the first place. That too is a trade off. But I do think there's a reasonably good argument for why Rust does need to have some of that extra syntax. Okay, let's see. Next question is, do you like Copilot? Okay, so my hot take here is that I think things are. I think copilot and similar kind of endeavors are problematic in the short to medium term. And the reason I say that is because the number of times I have accidentally introduced bugs, because I've not necessarily copy pasted code, but just assumed that code did the right thing and not read it carefully is pretty high.
00:53:36.635 - 00:54:25.075, Speaker A: And I worry that that only happens more if your editor gets just put in code for you. I think what happens is it puts in a bunch of code for you and you start relying on the fact that it's mostly right and it might even be right for the cases for like the main execution cases. The challenge is all the corner Case behaviors. And that means you start relying more on your tests unless you actually go back and read the code that was auto generated. And if you go back and read the code that was auto generated, it has saved you relatively less. It is true that it can save you from things like, you know, looking up a bunch of API documentation, for example. It might allow you to get close to the correct solution faster.
00:54:25.075 - 00:55:25.707, Speaker A: And I think there's value in that. But I worry that developers will lean on it too heavily and then get bit by all of those subtle bugs in or subtle mismatches between what the generated code tries to do and what you actually wanted it to do, that you end up not really auditing that generated code well enough. That said, I think we won't get to something that you can actually rely upon without going through the process, the learning process of, you know, going, using and then iterating on something like copilot, like something that works less well or less perfectly. Like. I guess this comes down to. I'm unsure about whether imperfect cogeneration is worthwhile. I think perfect code generation is worthwhile.
00:55:25.707 - 00:56:40.135, Speaker A: I don't know whether it's achievable. Yeah, all these libraries have the same bug. Any thoughts on possible license problems? Yeah, so I mean, this is a whole different rats nests or Pandora's box maybe of when you generate code from, that's ultimately sourced from many different places, you know, who, who owns the code where. And not just owns, but even for things like things that are actually open source, you know, many license, many open source licenses require attribution. But if the code that you got is built based on, you know, scanning hundreds of thousands of code bases, what does the attribution look like? You could imagine you just put attribution for all of the works that you scan. But then attribution becomes meaningless because it's just a list of every software project because you scanned all of them. So I think we have both technical problems here, but also social problems around attribution, licensing, ownership.
00:56:40.135 - 00:58:25.575, Speaker A: And I'm not going to claim I have the answers here, but I struggle to see how we get to perfect code generation or code generation where, you know, you don't have to audit it and it's a responsible way to use other people's code. What's interesting here, especially about that, first about technical questions or technical imperfections in the generated code, is that a stronger type system might actually help you here because it might be that the generated code, if it doesn't do exactly what you wanted, then it won't Type check. This is the goal of getting more into formal methods where maybe we could have it so that you use code generation only in contexts where you can prove that it generated the right code, which is an intriguing possibility, but I don't know of any efforts in that particular direction. Yeah, and there's also the question of like, okay, what if you had bad programmers? Is it better to use auto generated code that's imperfect, or is it better to let a not very good programmer just write the code themselves? I don't have a great answer to that either, but the auto generator, I think you don't want to use either of those code bases. Even if a bad programmer reviews the autogenerated code, I wouldn't trust them to do it properly. I don't know. It's a very difficult question.
00:58:25.575 - 00:59:43.965, Speaker A: What is the difference between a human learning from thousands of open source projects and using what they have learned to write code without attribution and a bot doing the same? I think that's, you know, certainly at the core of the question is to what extent is a human just regurgitating like things that they've seen in the past and to what extent is, you know, an AI code generator doing the same thing? You know, it could be that you can make the argument that really what a, what AI code generation is doing is creativity. It's not just copy pasting lots of small bits from everywhere. It's actually generating, you know, new ideas or new combinations, in which case it is much closer to a programmer just saying, I'm just applying what I've learned. But even there, you know, that doesn't get you into a free for all situation. It's not as though that absolves you of all, all responsibility. If you as a human programmer read the source code that someone else wrote and then write it from memory, then it's still not okay for you to not do attribution depending on how close the thing you wrote as the thing you read. This is why companies often do clean room implementations, so that they can't be liable where you're not allowed to look at any of the source material.
00:59:43.965 - 01:00:23.267, Speaker A: So they can't be liable for being accused of copying things. So the answer is. I have no answer. But I agree that it's a difficult question. All right, what do you think about Rust finding its way to the Linux kernel and the approach they have taken in doing so? I think it's really cool. I think it's fantastic to see Rust get into the Linux kernel. I also think it is a very Good input channel into Rust's development.
01:00:23.267 - 01:01:27.305, Speaker A: Right. So the kernel has some really weird, not weird reason, really niche requirements of the languages that they build on top of the ecosystems they build with the builds themselves. And you know that I think many of those niche requirements are only the Linux kernel needs that exact configuration of niche things. But each niche things might be needed by many other projects. And the fact that the kernel is picking up the language means that those niche things are more likely to get addressed. I'm thinking of things like one of the big things that came up in Linux adopting the kernel, Linux adopting Rust in the kernel is what do we do about allocators in the Linux kernel? You want to be able to guarantee that certain code paths do not allocate or only allocate in known ways. And Rust doesn't really have a mechanism for doing that, especially once you take third party dependencies.
01:01:27.305 - 01:03:02.735, Speaker A: And I think this has really pushed forward the question of, well, how do we as how does, how does Rust implement such a feature? Is there even a way to do so? And that has generated a lot of interesting discussion that, you know, probably wouldn't happen with the same amount of depth or weight without the kernel picking up Rust in the first place. I also think it's a strong indicator that Rust is sort of here to stay and has merit, that this is sort of a stamp of approval maybe that I think ultimately matters a lot in the world of programming languages. So you need to be able to point to other successful adoptions of the language for the more hesitant players to pick up the language. But I don't think I have much more to to contribute there. What are your opinions on management consulting? Interesting. I don't know that I have strong opinions on management consulting. Trying to think if I do or if there's a variant of this question that I have opinions, certainly consulting more broadly I think is actually a fairly good idea, mostly because it means that you can.
01:03:02.735 - 01:03:56.471, Speaker A: Companies can avoid having to become experts in everything that they need. You know, think of things like security work. If you required every company to have, you know, their own, you know, internal pen testers, that doesn't scale, right? Because for most companies you ignore the very large ones, right? For most companies, they don't do enough security work that it's worth having people work full time on security. They just, that's not their business model, that's not what they do. And they wouldn't really do a very good job even of hiring a security professional or retaining them or giving them the tools that they need. And those are the kind of situations where consulting works really well. And I also think it's really great for someone to be able to work as a consultant.
01:03:56.471 - 01:04:44.851, Speaker A: Like I've thought of this myself, right. Of trying to be essentially a Rust consultant that gets hired into, whether that's to develop a crate or help design an API or clean up some Rust code, or help with, you know, designing software built in Rust. Like that would be really, really fun. And it would be, it would allow me to, you know, apply my expertise very broadly while still getting lots of new challenges every day and new ways, new problems to look at. And that'd be really fun. Yeah. So when it comes to, you know, actually management consulting, like, you know, McKinsey and BCG and stuff, I don't really have a problem with them.
01:04:44.851 - 01:05:33.965, Speaker A: I think in some sense they provide a needed service. I think there's a question of like, you know, you can apply some amount of ethics evaluation here of to what extent should they be more picky about what projects they agree to work on and such. But I think in general the idea of consulting makes a lot of sense to me. Okay. Have you tried Nixos? No. I've been told so many times I need to, but so far I've. I've resisted the, I don't know if urge or urgings, like urge being self imposed and urging being from other people.
01:05:33.965 - 01:06:15.213, Speaker A: I think this comes back to the same argument I have for editors, which is I haven't had a need. I've felt more of a need since I started working at Amazon. Because I can't run, it's much harder for me to run Arch Linux there, but everywhere else I run Arch and I'm very happy with it. So I don't really have a need for NICs there. That said, it could be an example of, well, you don't know what you're missing out on. So certainly one of the things that appeals to me is the ability to very easily get a new system set up with a similar configuration to the what I have elsewhere. But at the same time that happens pretty rarely.
01:06:15.213 - 01:07:10.685, Speaker A: And when I do that, I actually really appreciate setting it up from scratch because it means that I get to revisit the decisions that I made when I set up my last system system. And very often I find that something changes, like I decide to change something about my setup when I set it up again, whether that's because, you know, System D has gotten a new feature that I want to make use of or, you know, there's a better package to provide this or I want to switch my Window manager or all those things that are really annoying to change in an existing setup. But when you get to start afresh, it's much easier to just like make different decisions. And so yeah, I guess this comes back to. I don't. I don't have a compelling, compelling case for moving. Yeah, I've also heard someone mention chat that the Nick's language is pretty cryptic and hard to get into.
01:07:10.685 - 01:07:39.055, Speaker A: But like, you know, I think one of the arguments is with nix you can easily roll back and I don't know, I can pretty easily roll back on Arch too. I don't. That's not really a problem that I have. But maybe this is somewhat unique to me running Arch. I'm not sure. Maybe the sort of distance from Arch to next is smaller than someone who's used to macOS or used to Ubuntu for that matter. I'm not sure.
01:07:39.055 - 01:08:45.687, Speaker A: Okay, do you use any software or plugins for NVIM for writing down notes? Nope, I do not. I'm terrible at keeping notes. I have. I have a giant to do file in my home directory which is written in markdown and my terminal config prints it whenever I start a new shell. That is the extent to which I have a writing down notes and todos and it doesn't really work really well either because the to do document that gets auto printed is longer than the height of my terminal now, so I don't really even see everything that's on there. And in addition I use my phone to keep track of things that I like have to do. And not just, you know, I need to get eggs, but also like I should do a stream on this topic or here's an idea for a crate or I found this bug in the standard library.
01:08:45.687 - 01:09:55.737, Speaker A: Like I the way I do this for myself, and it's stupid, is I set an alarm with the thing that I'm reminding myself in the alarm text. And the reason I do this is because it forces me to look at it later because if I have it in a to do list, it's like pull versus push, right? I don't go read the to do list very often, but if it gets pushed to me because my alarm goes off, I will at least look at it. So I have some alarms that actually go off every week to just remind me about the idea and think about it some more. And then inevitably what happens is when they go off, I snooze them or I let them go until next week or I transfer them into that to do document, which is at this point basically append only. And it's not an ideal setup, but I haven't really found a better way to go about it. And I've tried using to do apps and stuff and it ends up being the same thing. I think maybe the problem for me is so many of my to dos are long term to dos.
01:09:55.737 - 01:10:34.675, Speaker A: They're not, you know, a thing that I can just do in 30 minutes or at least that's somewhat rare. Like let me see if I can pull up my to do here. I don't actually want to print my whole to do because there's some stuff in there. But like, all right, let me read, read some stuff from my to do list here. I want to add Miri strict provenance checking to haphazard flurry and left right. I want to do a follow up stream to the wait free algorithms. I want to do a stream on using cargo as a library.
01:10:34.675 - 01:11:18.895, Speaker A: I want to do an unsafe chronicles and pointer provenance. I want to port more tests from folly into haphazard. I want to find new maintainers for a couple of the crates that I maintain. I want to write a long form blog post on why we shouldn't be doing interviewing based on data structures and algorithms. I want to design a D and D campaign again. I want to add a lint to Clippy or the standard library to deny Boolean arguments. I want to design a crate that does open loop workload generation.
01:11:18.895 - 01:11:49.327, Speaker A: I have some errata. I need to add interest for restations. I want to do a director's commentary video of Rust for restations. All of these things are things on my to do list that I can't just do, right? Like these aren't a couple of hour projects. These are. I need to like schedule a block of time for them over long periods of time. And so they just end up going on the to do list.
01:11:49.327 - 01:12:55.065, Speaker A: Like they don't really work really well on like if I have a to do app, the to do list is just going to be a ton of things that are very long term things and then you know, one or two things that I'm going to do next week. And then when it comes to like writing down notes, which is what the question was originally about, you know, notes more broadly of keeping track of things that I learn I'm terrible at. And I, I used to be better at this and then I realized I just never consult the notes, so why am I taking them? Which I think the number of times where it would have Been useful for me to have kept notes is relatively low and therefore I never. I never learned to be better. Yeah, I've heard Obsidian can be pretty good because it lets you create like knowledge graphs, but there too, like, I just, I just don't keep notes about things that I learn. And arguably I should, but I just. I just, I just don't.
01:12:55.065 - 01:13:31.985, Speaker A: Yeah, well, one thing that is a problem with my current setup is that it doesn't really do synchronization. So I have this one to do file that I use on my laptop and my desktop and I just SCP it between them. And it's not a great way to sync. It's a great way to lose data. At least it should be in git, but it's not. It's just a text file. I don't have access to it on my phone, which is why I sometimes set alarms to remind myself to move things from alarms on my phone into the to do file.
01:13:31.985 - 01:14:21.265, Speaker A: And it's a mess. And like, you know, arguably one of my to do items is figure out a better way to manage to dos. But the last time I did that, the improvement was have a to do file. I think at one point I had 30 alarms set on my phone for various random times, some of which were on and some were off. The other thing is just like, you know, the. I have open tabs on my phone for things that I to do. And at the moment I have so many open tabs that why does it not that my Firefox on my phone just chose see if I can get it to focus there.
01:14:21.265 - 01:14:55.835, Speaker A: The number of tabs open is just an infinity symbol because I have so many tabs open and it's not good. But I just haven't found a solution to this problem. And that's not like I also have Pocket, right? So I have lots of articles that are also added on Pocket. So these are all the things that aren't articles. It's a mess. The answer here is don't follow in my footsteps. Don't do what I do because I don't have anything good to say.
01:14:55.835 - 01:15:39.875, Speaker A: Oh, lots of people are asking questions now about things on my to do list. Okay, so denying Boolean arguments. This was. I forget where I came across it. I think this was like I ran into a bug where the reason why my thing was broken was because in my head I had reversed the order of two Boolean arguments to a function. And I spent like three hours tracking down why my thing wasn't doing the right thing. And it was One of those points where I was like, okay, I think I'm ready now to say we should just not have Boolean arguments if you have more than one.
01:15:39.875 - 01:16:06.457, Speaker A: And so I came to this conclusion that it would be nice to have a lint that's probably like a pedantic clippy lint that's just deny Boolean arguments altogether. Maybe you could say only deny if there's more than one. But I'm actually thinking just deny all Boolean arguments. Like basically remove the Boolean type from being allowed to be named. It should not appear in structs. It should not. Well, structs might be okay.
01:16:06.457 - 01:16:33.595, Speaker A: Unclear, but maybe. But for function arguments, no, they should all require to be enums and then which just make it easier for people to have Boolean enums. So like you could imagine a. Maybe this crate already exists. I don't know, I haven't looked into it. It's on my to do list is to have a crate that makes it easier to create enums that are interchangeable with Booleans to make them nicer to work with. And then just deny Booleans throughout your code base.
01:16:33.595 - 01:17:02.995, Speaker A: Yeah, I mean these are more projects than tasks. And I think the answer here is that or the observation is I don't really have that many tasks, but I have a lot of projects or projects that I would like to do. Yeah, designing a D and D campaign takes forever. It's really fun. Like I have a lot of thoughts for what I would want to put into this campaign, but I don't have the time. Or rather I haven't made the time. And you know, it's because I make time for other things instead.
01:17:02.995 - 01:17:46.815, Speaker A: It is true that long term to DOS should really be split completely. And I think I don't really have that many short term to dos. Or maybe I should get better at keeping two lists and moving things between the lists as appropriate. I don't know if there's a tool that lets you do that, that lets you keep basically a sort of two tier list, but I don't know. Unclear. Director's commentary for the book would be pretty fun. I think that might be something that I would do as a.
01:17:46.815 - 01:18:46.687, Speaker A: Maybe as a paid thing like this might be a good candidate for Patreon, for example, right. Of saying, you know, if, if you donate more than X amount, then I'm going to do, you know, live streams where I read through the chapters or something. I don't know yet, but I think it could be really fun. I have considered actually opening a bug tracker for myself and basically use like GitHub issues or something and use that as the way to keep track of my to dos. But that feels too, feels too heavy duty. Like these projects, many of these project things are just like one line things that I think ultimately what I need to do is I need to take a sabbatical for like a year and just do these things. Alternatively, instead of taking a sabbatical, what I would do is just do open source and teaching for a year and then maybe I'll actually have time to get to all of these things.
01:18:46.687 - 01:19:39.859, Speaker A: And like many of these I could just stream. Right? Like strict provenance checking, for example. I think it would be a great stream to like a useful stream to show how you add that kind of checking to, you know, highly concurrent libraries. So there's a lot of meat here for potential teaching opportunities. It's just that I don't at the moment, I don't have the time. And this is one of those places where, you know, I really think that if I didn't have a full time job, I would be able to do way more of these things and turn them into teaching. And the question is just, is that something I could live off of? How would you interview instead of data structures and algorithms? I think testing problem solving ability is way more important than asking knowledge and memorization based questions.
01:19:39.859 - 01:20:29.129, Speaker A: I agree. I think data structures and algorithms are knowledge and memorization based questions. Problem solving has nothing to do with data structures and algorithms. That's sort of where the core of my disagreement with data structures and algorithms comes from. I think when you want to get to actually asking questions that are problem solving, I think you want to ask questions where there aren't right answers, where you have ambiguous problems and data searches and algorithms very often do not. For example, you know, one interview questions I like a decent amount is something like write to the scheduler for the elevator system in a building. That's the entirety of the prompt.
01:20:29.129 - 01:22:03.765, Speaker A: And then part of the, part of the, part of the interview process is which questions does the candidate ask? And then we explore the problem space together. So you might ask, well, how many elevators are there? How many people are there? How many floors are there? You know, what is the, what is the general pattern of when people come in and when people leave? You know, are there restrictions on what kind of controls we can have for these elevators? You know, what's the size of the elevators? What country is this in? Because that might change how people want to have the elevator experience. Experience be. And then you might also like ideally, you also get to writing code, right? So you actually write an elevator schedule and you try to come up, well, what is a good. If you were to write a crate that implements the elevator schedule, what should the API look like? Why do you make the decisions that you do? And maybe part of that is you have to choose to use the data structure and some part of it, but it's much more of an organic choice than it is. How do you rotate a red black tree? Let's see, let's see. I'm just scanning through the chat here to see if there are more follow up questions to this Trello Kanban.
01:22:03.765 - 01:22:46.115, Speaker A: Yeah, I mean there are a bunch of, you know, mechanisms for this, but part of the, part of the challenge I have, right. Is that all of these projects are. I. I think of them as a bucket, where sometimes I have the spare capacity to reach into the bucket and grab a thing as opposed to. I'm working on all of these things in parallel, so I don't really need planning for them as much as I just want to make sure that I don't lose track of them. And then sometimes I'm working on some of them. But that means that really it is just a sort of flat list, sort of a set bucket.
01:22:46.115 - 01:23:29.235, Speaker A: Get Morgan Freeman to read through the rest of her station chapters. That's pretty funny. Okay, yeah, so. So someone pointed out in chat that Clippy does have a link for excessive bulls. That's not what I want. It's close, but I think I actually want deny bulls and I think I wanted to go as far as denying bools in tuple structs as well. Tuples? Tuple structs.
01:23:29.235 - 01:24:00.521, Speaker A: Function arguments. Return values. Maybe not return values. Unclear. But I want it to be even more pedantic than just you have many bools as arguments to this function. Full time job gets in the way of doing really interesting things. Yeah, I mean I would love to just full time do these projects.
01:24:00.521 - 01:24:49.045, Speaker A: I. I think, you know, it would be an immense privilege if I could, but maybe one day for the Boolean thing. I think one thing that might be needed is actually language improvements to Rust to make it possible to have a Boolean like Enum that actually you can use as a boolean. That would be really cool not just into bool but actually have like a. You know, currently the Rust conditionals all only take expressions that evaluate to a bool type. I wonder if there's a way to have them take expressions that evaluate to an enum type that has a particular attribute that Makes them act like bools. That could be really cool.
01:24:49.045 - 01:25:32.125, Speaker A: Okay, I think it's time to move to the next question. How's piano going? Okay. Not as well as I would have hoped. I haven't abandoned it. Like, the piano is still in my living room. Every now and again, I'll go play on it. And every time that I do, I'm very happy that I do, but I'm not doing it regularly enough to remember the progress.
01:25:32.125 - 01:26:08.965, Speaker A: So I feel like every time I regress a little bit and then I make up for the regression, but don't do it again until I've regressed sufficiently to be where I was, which is really unfortunate. I think this is another one of those make time problems where really I should just say every Thursday afternoon I play the piano. And that would be an immense leap from where I am right now. You know, I think ideally, if you actually want to get, let's. Let's say capable at doing this, I would have to do it more often than that. And I think that might be worthwhile. Oh, cameras shaking.
01:26:08.965 - 01:26:37.699, Speaker A: But I. Yeah, I. This question makes me realize that I really need to just set a day, a week where I play the piano because I really do want to learn it. I. I enjoy it a lot when I play other. I'm not. So I am roughly able to play with both hands, but.
01:26:37.699 - 01:27:01.665, Speaker A: And I'm using this. It's a piece of software called Flow Key, where you hook up the. So I have like an electric keyboard. You hook it up to like an iPad. You run the app on there and then you connect your headphones and it can tell whether you're pressing the right keys. You can do it without the cable, I think too. And it just uses like audio recognition.
01:27:01.665 - 01:27:48.315, Speaker A: And so it's pretty cool that, you know, it can. It can tell whether you're playing the right things. The problem is I don't have the beat well enough in my finger, or rather I take too long to find the key I have to press so I can't play it to rhythm or to beat. And so I just play the same song over and over and over again on the sort of move when I've pressed the right keys mode until I know the song or I know the moves well enough that I can play it in real time mode. But trying to get to the point where I can get a song and I can just play it by watching in real time or even in slowed down real time at beat is. I can't currently do like trying to. For example, one thing that, you know, I think would be great is the ability to play.
01:27:48.315 - 01:28:19.497, Speaker A: If I have the ability to, you know, get a sheet music and let's say simple sheet music and play it at half speed but at the correct half beat, and I'm nowhere near there. Set an alarm to play piano. You're not wrong. I. I have a piano for baking bread. I have piano. I have an alarm set for baking bread.
01:28:19.497 - 01:28:43.389, Speaker A: I end up baking bread now almost like every week and a half, maybe week and a half to two weeks. And that's also really fun. I. I'm very happy I started doing that. Very hard to find good bread in the US and it's a very peaceful way to play. Oh, that's funny. When I retired, I was going to do all the side projects I didn't have time for.
01:28:43.389 - 01:29:14.065, Speaker A: Yeah. But my concern is that I'm going to end up with a similar kind of thing of, oh, I'll do them all when I retire. But first of all, that's a very long time for now. And second of all, I think by the time I get there, I'll have accumulated so many things that there's no way I get to even a small fraction of them in, you know, whatever time I have left. So I really think I just need to. I need to find a way to start doing them. And I think the way to do that is not work full time, which is easier said than done.
01:29:14.065 - 01:29:35.391, Speaker A: At the moment, I'm playing all sorts of things. I'm basically just, you know, Flow Key has a list of songs that. That you can attempt to play. And I've. The latest one I practice on was Happy Birthday. Because it's. It's actually you can play it at various difficulties.
01:29:35.391 - 01:29:55.031, Speaker A: So you can play it in a very simple mode and you can play it in a very complicated mode where there's all sorts of, like, when it, like, flourishes. And so it's a. It's an. It's an interesting one to, like, build up your expertise on. It's immediately useful. And it's a song that I. I know the beat of so well.
01:29:55.031 - 01:30:28.681, Speaker A: Like, I know how it's supposed to sound. So when I play, I can more easily recognize whether I'm doing the right thing or the wrong thing. It's not a very interesting song. So, you know, I'm gonna graduate from that one at some point. But. But that's. Where can you play and sing at the same time? That's a good question.
01:30:28.681 - 01:31:03.335, Speaker A: I think I probably could if I've gotten to the point where I, you know, I've practiced a song long enough that my fingers sort of move on their own. But I. I don't think I'm at the point where I can do a performance for Stream yet. I used to have a guitar many years ago and I. My dating profile used to say that my guitar skills were at like 2.71% or something. Like, I used E to like six significant digits as the percentage that I knew how to play the guitar.
01:31:03.335 - 01:31:30.889, Speaker A: And that was a great way to signal how much of a nerd I am. I don't know that it was true. I think I knew less than E percent. But even so, it was a fun little tidbit. And yeah, the bread I bake is soured out. I have a yeast that I made from nothing. From air.
01:31:30.889 - 01:32:26.373, Speaker A: From thin air. Let's see. All right, let's move to the next one. What is your advice for an undergrad student of computer science? Like working on resume and stuff to get admission from institutes like mit? What do universities focus on in the application process? Okay, so given that you are currently an undergrad, this suggests that you're applying for grad school. And I think I have. Let's go with three pieces of advice. My partner recently noticed that I do this a lot, where I explain how many enumerations there are or facets there are to my answer and then I enumerate them and I have started noticing that I do this way more.
01:32:26.373 - 01:32:59.461, Speaker A: Like there are three things first. And I'm going to do the same thing here. The first thing I would say is think really hard about whether you want to get into grad school. I don't think it's a bad choice, but I do think grad school is a big commitment. It's a big opportunity cost and it has the potential to be miserable. It also has the potential to be great. But.
01:32:59.461 - 01:33:54.403, Speaker A: But it really depends on whether you find or whether you have an area that you truly care about enough that you can dedicate, you know, X years of your life to and do very little else. You know, you're going to be burned out at the end about the thing that you ended up working on. And you know that there are many alternate avenues to going into grad school. And you know, the opportunity cost is not just the cost of university, at least in the U.S. it's also that you're not working in industry. So you're not, you know, making the salary of working in industry, but you're also not building up industry experience, which means that when you start work you know, X years down the line, you'll be at a relative disadvantage because academic experience doesn't really count as much in industry. So.
01:33:54.403 - 01:35:40.465, Speaker A: Yeah, so first bit here is, do you actually want to go to grad school? Second one is the more prestige universities, at least my impression is, care a lot about recommendation letters. And in particular they care about what the recommendation says about you. And I don't mean that in the sense of what words are on the page, but what information about you can they extract from that recommendation? And a big part of that is who wrote the recommendation? Is this a person that they know? Is it a person they know of? Is it a person that, if they look them up, they understand that this person has, let's say, some amount of integrity or understanding or knowledge that's relevant to what they're writing. And the reason I say this is because is partially from, you know, just conversations with professors over the years, but it's also my own experience because I applied to MIT several times, both for undergrad and grad school. And the time I got in was when my recommendation letters were from professors that were relatively well known. And I don't mean that in the sense of famous, but just in the sense of like, you know, they were professors at an established university in the uk, you know, they had published papers in conferences that are well known within the systems field. And so in general, when they give a recommendation, it carries some amount of weight and trustworthiness.
01:35:40.465 - 01:37:03.885, Speaker A: So I think even if someone else, someone entirely unknown, wrote the exact same words, it wouldn't have the same impact. And I think having solid recommendations, reliable recommendations, is very valuable. It's more valuable than your sort of grades, your extracurriculars, like, ultimately, that's a big part of it. And then the third thing is this depends a lot from university to university, and it is a little different depending on the country you study in as well. But at least in the us very often, you know, you're working with the professor or in some cases with multiple professors, although that, that is a little bit of a luxury. But, you know, you're, you should make sure that you can find a professor that you align with. So if you can find a professor or a research lab where you think what they're working on is really interesting, you think it is like you have a passion for it, you have a drive for it, you have an interest in it, then try to reach out to them, try to see if they can recommend ways to get more familiar with their work.
01:37:03.885 - 01:37:54.935, Speaker A: And I say that because it means that you can write a more compelling personal statement for why you want to get into this university, why you want to get into that lab. If you can point to like this professor, these papers, this lab, I want to do what they are doing. Like I have followed their work, like, this is the kind of stuff that I'm interested in. These are the kind of ideas I have for graduate projects. That makes for a much more compelling story in your personal statement, in your application letter than if you just write, you know, I really like computers or I want to work in distributed systems. If you have more concrete stuff you can talk about that matters. It's not so much develop a relationship with a professor that might help, but it's also much harder to do.
01:37:54.935 - 01:40:05.355, Speaker A: It is unlikely to yield any particularly meaningful results because very often you're applying to the university first and then to the lab, but getting in touch with them or at least looking up the kind of work that they do and, and familiarizing yourself with that is going to help you in writing a better application. Other follow up questions on this one, otherwise I'll move on. All right, next question. Is Rust language adoption pace slowing, staying the same or accelerating in the enterprise currently? Do you foresee any changes in this pace given the current Rust Lang roadmap? I think Rust adoption is accelerating and I do note the difference here between accelerating and momentum, that it's not just that Rust has a certain amount of momentum and therefore it's growing, but I think the rate of adoption is also going up. And the reason I say that is because I think a lot of companies are, have been hesitant to pick up Rust because it doesn't have a, a track record of successes. And I think what we've seen is that that track record, track record is starting to become more established. More companies are announcing that they're using Rust, more companies are announcing gains from using Rust or switching to Rust.
01:40:05.355 - 01:41:03.195, Speaker A: More companies are investing in Rust and doing so publicly. That in turn builds confidence that Rust is around to stay, which reduces the perceived risk of the language, which means more companies are willing to step up and try it for themselves. I don't know how long we're going to see that rate increase go, but that's certainly the impression that I have from the industry as a whole that I think the rate of adoption is going up. And to be clear, I don't actually think that the goal here should be, you know, rust adoption at 100%. I don't think Rust should be used for everything or everywhere. I don't think everything should, should be rewritten in Rust. So the goal isn't to get to 100% saturation and I don't think we would ever get there either.
01:41:03.195 - 01:41:58.957, Speaker A: But I do think what we're seeing is also a recognition that there are a lot of domains where Rust can do really well and is actually a good long term choice. And so we're seeing it being branched out into several industries. Right. So in the early days there was more, you know, it came into high performance settings, low level system stuff, embedded devices, but we're seeing much more now development into, you know, cryptocurrencies. Of course that's been happening for a while, game development, we're seeing it being used more for its cross platform capabilities. Rust is a pretty solid story for developing for macOS and Windows as well. And so you see it being used for building less so GUIs, although that is changing.
01:41:58.957 - 01:43:17.995, Speaker A: But even command line applications you want to run on multiple platforms, Rust is a pretty good candidate language for now. I think we're seeing this with adoption into Android, I think is also something that might see a decent amount of growth. I think adoption into the Linux kernel ends up being another one of those sort of stamps of approval that makes more companies willing to consider doing it themselves. I think this acceleration is probably going to slow, so I think it's accelerating right now, but I think we're going to end up slowing that acceleration but keeping the velocity probably and not too long. Like I think the, the higher, the, the rate increase is probably going to stop in let's say, you know, a year from now or something. I think it's a result of the times, like a result of all of the public endorsement of Russ, the language over the past. Can you talk about Rust adoption at aws? This gets into, I don't want to say murky waters, but it gets into like me having to make a judgment call about what things I am.
01:43:17.995 - 01:43:48.085, Speaker A: And I'm not allowed to say that Amazon is doing. So I'm not going to go too deep into that. What I will say is like, you know, my job at Amazon is encouraging Rust adoption. Not, you know, at all cost, but just advocating for where appropriate and also making the Rust experience the best that it can be internally. And that's going very well. In general. I think the Rust experience at Amazon is a, is a very good one.
01:43:48.085 - 01:45:03.735, Speaker A: And you know, the fact that there's been this investment in making the experience of using Rust a good one is indicative that the company certainly believes in the language. Right. Like that's What I take from that decision to invest in the developer experience. All right, would you rather fly in a plane written with Rust software in it versus, let's say, ADA software or Lisp like language like Clojure? What I'll say here is Rust is still a young language, so I don't think it has quite the safety posture of a language like ada, which, you know, has been dedicated to this from arguably the start and for a very long time. I, I think Rust could get there. But I do think there are some things that we still want to see there. Things like, you know, long term stability of Rust, of, you know, supporting older versions that, where things are known to be stable.
01:45:03.735 - 01:45:59.565, Speaker A: Whereas, you know, if you're building airplane software using Rust nightly, that seems unfortunate. But the likelihood of you having to do so is also higher than it is with Ada, where you're not going to be using something that's equivalent to Nightly. Same applies to the ecosystem around it. The testing. I know that Rust has gone through a lot of testing, but I don't know that it's gone through the same kind of formal testing and formal testing over time like ADA has. So I think my vote here would be I would go with Ada for now, but I think Rust has the potential to be a good candidate here. Would you deliver packages with drones running firmware written in Rust? I mean, I think it's the same kind of argument, right, of I would rather it be written in Rust than in C.
01:45:59.565 - 01:46:53.187, Speaker A: I would. If it was already written in Ada, I would continue to use the ones written in Ada. But I think for a, you know, greenfield project, you're relatively unlikely to use Ada. You might choose between Rust and C, and there I think the choice is pretty obvious. What are your favorite podcasts? Oh, let's see. Let me open my, my podcast app here. I'm current.
01:46:53.187 - 01:47:22.359, Speaker A: Oh. I recently listened to a podcast called Hot Money from the Financial Times, which I thought was really interesting. It's a documentary podcast about the finance behind the porn industry. I thought it was a really interesting thing to listen to. I think there was a lot of stuff I didn't know and thought was fascinating. Freakonomics Radio is fantastic. I think I've listened to every episode.
01:47:22.359 - 01:47:50.517, Speaker A: It's great. If you haven't listened to it, there's a podcast called you are not so Smart. So to explain what Freakonomics is first before I move on, Freakonomics is. So there's a book called Freakonomics, which was about. I don't know how best to describe it. The implications and nuances of the economic system in a way that's understandable to people who aren't economists. And there's a podcast now that I think their tagline is.
01:47:50.517 - 01:48:37.495, Speaker A: Explores the hidden side of everything. And it's essentially, you know, they go into really interesting questions like, you know, how do we measure whether working from home works well or not? Or whether. Let's see what some of their most recent episodes are. Has globalization failed? Nuclear power isn't perfect? Is it good enough? Should public transit be free? And they explore it from the side of economics. And I think it's a really interesting lens through which to analyze these questions through. You are not so smart as a podcast about social psychology. And it's sort of taking.
01:48:37.495 - 01:49:42.345, Speaker A: I really like the format where the person who runs the podcast basically interviews experts in different fields of social psychology and tries to get at not just what are these phenomena that we have observed in humans and human behaviors and human thinking, but also what implications do they have for how you live your life and for how we interact with people in our lives. Stuff you should know is a very widely known. So I'm gonna skip over talking about that too much. Let's see, what else do I have? There was a podcast called Constitutional, which I thought was really interesting. It was sort of single season podcast on the First Amendment in the US and related topics that I thought was. It's great, it's from the Washington Post. I think similarly there's also.
01:49:42.345 - 01:50:11.219, Speaker A: Oh no, sorry, it's about. That one is about the. About the Constitution. There's one called make no Law which is about the First Amendment and some of the implications and non. Implications of the First Amendment, which is from the legal talk network. It's a podcast that sadly stopped now. At least they haven't published episodes in a long time called Playing for Fun, which was two people talking about like they're.
01:50:11.219 - 01:50:40.109, Speaker A: They're not really video game reviews as much as they are. Let's talk about all the things that we're excited about in video games. Let's not talk about all the things that they do poorly, but things that make us happy, make us feel engaged by video games. And I really hope they come back and make more. I think those are some of the top contenders. Not another D and D podcast is also great. I particularly like the first campaign they've done.
01:50:40.109 - 01:50:59.743, Speaker A: I think they're on campaign three now and for me nothing beats the first campaign. But it's a. It's a really fun podcast to listen to. It's a. It's it's similar to other, you know, narrative D and D podcasts where they sort of play live, like critical role and such. But I like this one a lot. I've also found Intelligence Squared pretty interesting.
01:50:59.743 - 01:51:57.955, Speaker A: They do a lot of debates on all sorts of political, social, economic questions. And it's fascinating to hear, you know, actual debate, like debate format debates as well on these topics. I'll stop there and I'll also, of course, shout out Roastation Station, which is. Which is also fun. Let's see, what is your podcast app? Oh, I use one called Pocket Casts, which I've been super happy with. I've used it for years. Let's see.
01:51:57.955 - 01:52:38.557, Speaker A: Okay, I think that's a good place to move on to next. Let me also put the Q and A link in chat again in case you want to put more. I see there's more questions in chat that should go there. Anything that's a different topic than what I'm currently talking about, I'll put in there. So that I try to give everyone a fair, fair chance to get their question answered. You mentioned you don't enjoy LA and that you'd like to move in a couple of years. What stops you from moving now? Nothing really stops me from moving now anymore.
01:52:38.557 - 01:53:34.039, Speaker A: In fact, my plan is to probably move next year. I don't know exactly when. I think it's relatively likely that I'll end up moving to Norway with my partner probably towards the summer of next year. It's not set in stone yet, but that's sort of what we're currently thinking. I think for me, the big question is going to be whether I find Oslo in particular an interesting place to live. Like, one of the reasons why I left Norway in the first place was because it felt a little too small, maybe, maybe uninteresting, maybe, you know, a lack of, not necessarily diversity, but diversification. And, you know, over the past 10 years, Oslo has changed a lot.
01:53:34.039 - 01:54:00.343, Speaker A: Uh, there's a lot. There's been a lot more, you know, influx of people from all over doing many interesting things. A lot of more businesses that have popped up. The city has grown a fair amount. And so I'm excited to see whether now it is a place where I will find that I have an interesting life. And I'm also curious to see whether my partner, who's from the U.S. whether she will, you know, enjoy living in Norway.
01:54:00.343 - 01:54:26.437, Speaker A: It's, you know, it's not for everyone. It is colder during the winter, there's less light during the winter, but it's Also, you know, a country that is a very pleasant place to live. And, you know, summers are very nice there, and then you have, you know, daylight throughout part of the night. Winters are cold. Yes, but they're also very cozy. And so, you know, I'm. I'm hoping that we both end up enjoying it.
01:54:26.437 - 01:55:12.679, Speaker A: If we don't, you know, if we, if we stay there for a year and then decide that, you know, this is not for us, we're gonna, we want to try somewhere else. We would probably go to London and try that for, you know, a year and see whether that's a better candidate. We've both lived in London a little bit before and enjoyed it immensely. But, you know, since Brexit, it's become a much less attractive place to move. So, you know, the list of good options is not as long as I would like it to be. There are other places in the, in Europe too, that I've considered. It's a little, you know, it depends on our tolerance for moving somewhere where English is not the primary language.
01:55:12.679 - 01:56:08.475, Speaker A: Or, you know, Norwegian, because I know Norwegian, but like, the Netherlands is a place that I've looked at a bunch before. Germany, Spain, you know, I think there, there are other candidates, but, but certainly, I think for us, Norway and the UK are pretty high on that list. And there's a question here of, are you going to continue working from aws, from Norway? I. I think so. I have been thinking about whether, you know, when I move, is that a good time to, let's say, reevaluate my options? Right. Because when I was initially looking for work after I graduated, first of all, I was in a different place in life. But also there were a lot of companies that I couldn't work for because they were based in Europe and couldn't sponsor a visa in the US So now if I move to Europe again, suddenly there are a lot more candidates for companies that I could work for.
01:56:08.475 - 01:56:49.465, Speaker A: At the same time, it's not ideal to do such a long move and also be switching your job at the same time. So I'll see what I do. But I think there's a decent chance that I'll continue working for AWS as I move, and then I'll see down the line whether there's then a better chance to make a change or even to try full time for teaching in open source. We'll see. I don't really have an answer there. Yeah, I've had, I've had people recommend that I move to, to Madrid, to Barcelona. That would be pretty Fun, too.
01:56:49.465 - 01:57:12.453, Speaker A: What are your problems with la? Oh, I. I despise la. Let's see if I can. If I can summarize the top three, first of all is the desert. It's dry, it's always sunny, and it's always warm. And I'm used to cold. I like seasons.
01:57:12.453 - 01:57:26.505, Speaker A: I want there to be snow and rain. That makes me happy. I like darkness sometimes. Like, I. I want clouds. Like, I miss. I miss not being in this climate.
01:57:26.505 - 01:57:42.175, Speaker A: You know, everything here is dry. There aren't really forests there. There's not water. There's not really mountains. I know you can drive to those things, but that's different. Second part is related to that, which is. Nothing is made for walking.
01:57:42.175 - 01:58:28.673, Speaker A: It's a place where you have to have a car, more or less, and everywhere is a drive, which also means everywhere is traffic because everyone has to drive everywhere. It's not really a place where, you know, you can just go. Walk to, you know, the store, or you can just walk to a friend's house or to an event. And this ties into the fact that public transport is not very good here, as opposed to, you know, in Europe, where it's actually really good, at least certainly in. In Oslo. And that makes me sad. And the third part is LA is in the US and there are a lot of things that I don't like about the US And I don't necessarily want to enumerate all of them, because there are a lot.
01:58:28.673 - 01:58:49.851, Speaker A: But. But just I. I don't like how. How Americans see their government, and I don't look like how the government sees the people. And I don't know how. I don't love how companies see people. And it just means that it's not a pleasant place.
01:58:49.851 - 01:59:16.125, Speaker A: Like, it's not a good place to be human, you know, and this ties into health, the way the health care system works. It ties into how lobbying works. It ties into, you know, immigration. It ties into employment rights. It ties into unionization. It ties into. I just.
01:59:16.125 - 01:59:50.293, Speaker A: It's not. What's the right word here? I don't know. I just. I want to be in a place where people have. People have more rights. It's the best way I can summarize it. And, you know, I mean, there are upsides to the US too, but there are upsides that I think I'm willing to compromise on.
01:59:50.293 - 02:00:13.145, Speaker A: Right. So the upsides are things like, you know, wages are certainly in. You know, in my sector, wages are much higher here. Like, I think the pay cut to move into the. To Europe would probably be, you know, closer to 50%. Like it's pretty bizarre how much the pay cut would be. It varies by level, varies by industry, but like it's a pretty significant cut.
02:00:13.145 - 02:00:52.553, Speaker A: You, there's a lot of tech companies here. Like, if, you know, given that that's the sector I'm in, working here means that you get a lot of the big opportunities, like this is where they happen. And if you're not here, you're going to be more distance from them. You're going to have less of an opportunity to be involved in, in those, in those opportunities. But I, I don't think those are, are worth it for me. Come back to Australia. I, I really like Australia actually.
02:00:52.553 - 02:01:21.475, Speaker A: The, and, and I think I would really like New Zealand too. The, the big problem for me is they're too far away. I don't think it's, I think it's too costly to live that far away socially, not, not economically. See. Okay, so someone put in chat. Sadly, governments suck. And I don't agree with that.
02:01:21.475 - 02:02:01.807, Speaker A: Some governments suck. And I think, you know, in the US there's a lot of evidence that the government sucks at many things, but that doesn't have to be the case. But the US has gotten itself into this unfortunate spiral of people don't trust the government. When I say that, I mean trust in multiple ways. Like they don't trust them to make the right choices, they don't trust them to execute on things well. They don't trust them to be responsible. But as a result, the government ends up having both a low bar and low investment and few resources, which in turn means they can't do those things well.
02:02:01.807 - 02:02:26.057, Speaker A: And so people lose further trust. And that's the case in the U.S. but that's not the case everywhere else. So I think it's unfortunate that the US has gotten into that situation. I think it's hard to get out of. What's your opinion on the visa restrictions on non immigrant workers? It's awful. Living on a visa is abysmal.
02:02:26.057 - 02:03:21.675, Speaker A: Okay, abysmal is maybe extreme, but like, it means that there's so many things that I cannot do, right? Whether that is, you know, have a Patreon or sponsorships inside of my work. It means that, you know, if I were to try to write a second book, for example, it's unclear that I'm allowed to do that here because it would count as work for the publisher. I'm not allowed to do any work that's not tied to my primary employer. You know, your healthcare is tied to employment. It's not really visa related, but it means that you have such a strong dependence on your employer that you have to be much more willing to compromise with them because you can't. Like, first of all, they can fire you on the day, in which case you also lose your health insurance on the day. But because they are your visa sponsor, it also means that you need to get a job very quickly after or you have to leave the country.
02:03:21.675 - 02:03:58.025, Speaker A: And like picking up and leaving is not trivial. So it's not a good situation to be in. And you know, this is going to be the case. Other places in the world too, like the UK has somewhat similar limitations, although I think there, I think there are some exceptions that maybe I could make use of. But in general, working on a visa is not nice. One thing I do want to point out, so some people in chat is like, yeah, there are things that aren't nice about the U.S. to be clear, I'm very happy I came to the us.
02:03:58.025 - 02:04:32.131, Speaker A: It's not as though I think it's not worth, worth being here. It's more that this is not where I want to live long term. I think having the experience of having been here and like, you know, going to the university I went to there aren't good, how to phrase this. The US has some really good universities, some of the best in the world and getting to go to them is worth it. Right. So I wouldn't take that back. Same as I'm very glad I got the opportunity to, you know, work for Amazon, for example.
02:04:32.131 - 02:05:24.755, Speaker A: Like, I think it's been a really interesting, unique position that I've gotten to be in and work within and I don't know that that would have happened if I hadn't been here. But and same with like, you know, the ability to have, you know, the kind of salary that I've had has also been very liberating. Right. It's not that I necessarily have, you know, lots of expenses, but rather it allows me to save much more so that when I move I have more of a buffer, more of a Runway to try other things myself. And you know, I think that's a, an immense upside to coming here. It's more that it's just not, it's not for me a long term place to make your life be rooted. I have heard good things about Canada too.
02:05:24.755 - 02:06:56.635, Speaker A: I'm not opposed to Canada. At the same time, you know, I really like Europe. Like being able to so easily travel to many very different countries has a lot of appeal to me and you don't really get the same with Canada. Won't your partner face the same challenges in Europe if she's from the US So she would be on a visa. Although Europe in general, this is not true for all countries in Europe, but many countries in Europe have, it's called like the love clause or something where she can actually be on a like basically a partner visa because we've lived together for at least two years and she's, she's not married to someone else and I'm not married to someone else. But basically if you can prove that you are essentially life partners, then that is sufficient for her to be on a visa that's similar to as if we were married. And that makes it much, much easier because then, I mean it is true that she would then be on a visa that's dependent on me, but that's a better position than being in one that's tied to an employer and it has much fewer restrictions as well, as far as I'm aware, precisely because it's not tied to employer sponsorship.
02:06:56.635 - 02:07:39.075, Speaker A: So that would be easier. Whereas in the US there's no such clause. So it would be better if like if we got married then the visa situation would be different. But you know, I don't really want to marry for a visa either. I want to marry for the right reasons. All right, let's see. Ah, I didn't want the question.
02:07:39.075 - 02:08:14.645, Speaker A: The question has gone so far down the list I can't mark it as answered. Where did it even go? You voted on all these other questions. So now. All right, fine, I'll just, I'll just ignore it. Do you read non tech related books as well? Any recommendations? I do. So I recently reread the Wheel of Time series and I just love those books. I think the series that's come out now is fine, it seems okay, but the books just, I love them.
02:08:14.645 - 02:09:13.725, Speaker A: I read them once when I was much younger and recently reread the whole series or I listened to much of it on audiobook and read some of it on paper and just, I love it. I've also been reading Harry Potter and the Methods of Rationality, which is a fantastic read. It's both very funny. Like I, I actually laugh out loud while reading, but it's also just a really good, I don't know how to describe it, like exploration of rationality that actually I think teaches you some, some good ways to think. It's, it's, it's really good. It's really good. What else have I been reading recently? You know, Wheel of Time has taken up so much of my time that it's been a while since I read anything else that was non fiction.
02:09:13.725 - 02:09:39.515, Speaker A: I did read shortly before I started Wheel of Time again. I read the Stormlight Archives. I read Mistborn, I read. Oh, what's it called? The King Killer Chronicles. So there's been a lot in that kind of vein for me recently. And those are. I would recommend all of them.
02:09:39.515 - 02:10:04.545, Speaker A: They're all really fun reads. What else have I read that's non fiction recently? Let's see if I have anything here. Oh, yeah, the what if books are also great. Unclear whether they're nonfiction. Wait, hang on. Non fiction. I've inverted the question in my head.
02:10:04.545 - 02:10:35.825, Speaker A: No, okay. The question was non tech great and I turned it into nonfiction in my head. Non tech, yes. So the what if books are also non tech. The what if books, if you're not aware of them, is they're written by the author of xkcd and they're basically like explorations of the realities of theoretical questions. Like if you managed to hit a baseball at the speed of light, what would happen? And it's really cool. It's really, really cool.
02:10:35.825 - 02:11:45.493, Speaker A: I think that's. I think those are the recommendations I have. Can you talk about different allocator options and choices in Rust? I don't have a lot to say here. So the allocators are generally available to you are the system Allocator, gemmalloc and Mimalloc. And there's also stuff like Bumpalo, like allocators that are more like arena allocators. I remember when I worked on Noria the I actually found a decent amount of speed up from using the system allocator instead of jmallock, and I'm trying to remember why. I think jmallock struggled a lot more with many small allocations.
02:11:45.493 - 02:12:49.139, Speaker A: It's intended to be better for concurrent allocations, but I think my experience was that it actually worked less well when you had many, many small allocations, which Nori ended up doing a lot of. But that's ages ago and I haven't really experimented much with it afterwards. I think it's one of those things where, like, use benchmarks to convince me why you want to switch away from the default. Right. Like the system allocator is generally what you should use unless you have solid benchmarks with real world workloads that demonstrate a measurable, reliable, stable, significant impact on your benchmark outputs. And if you can't, then don't do it. It's just not worth the Additional complexity, the annoyances and debugging just use the standard arena allocators, I think are, are a more clear win choice for the use cases where they're convenient.
02:12:49.139 - 02:13:47.103, Speaker A: Right. So for things like, you know, game programming, for example, where you would do, you know, a lot of allocations for one frame and then you're going to deallocate all of them at once, then having the ability to just, you know, do a huge set of allocations and then just deallocate them all at once is pretty valuable. It does assume a little bit that you, you don't have to run destructors and stuff. So there is some complexity there, but. But it's not something I know I can speak to in a lot of, you know, significant. Let's see. Soon.
02:13:47.103 - 02:15:12.625, Speaker A: Starting my first software engineering job and feeling kind of anxious, nervous about it. Any tips for the first weeks or months? Oh, this is hard to say without knowing the company because different companies have very different, shall we say, expectations for people who start. My first bit of advice would be don't be nervous. And it sounds silly, right? But at least, and at least at Amazon, my experience has been that you're not really expected to be productive for a while in the beginning because there is so much to get to grips with that's internal stuff, like, not stuff you could have already known, but just, you have to understand how the internal infrastructure works, how the internal code works, how to even write code internally and get everything set up. And so you have a fair amount of time for that soft onboarding ramp where you get to get used to what it's like internally. And so I wouldn't be too worried if your concern is, you know, how, like, how will I perform as well as they expect. When I first join, I think there's a separate nervousness around, you know, this is my, this is my first job.
02:15:12.625 - 02:15:59.517, Speaker A: This is my first engineering job. I have no idea whether I can, you know, program to the standards that people expect. And that one's harder to address. Like, I still think the answer is don't be nervous. But I think, you know, that the imposter syndrome is a very real thing. And I think if you're a new engineer, it's even more likely to, you're even more likely to feel it because you don't have the experience that tells you that you're doing well at your job. What I would say though is that don't focus too much on whether other people think you're doing a good job.
02:15:59.517 - 02:16:54.125, Speaker A: That does matter to some extent, right? Like Your performance evaluations and such like are going to depend to some extent on what other people think of your work. But it's a terrible benchmark to use for yourself because you won't know what other people think and instead focus on making sure you think you do a good job and also focus on what you think is the right thing for you to work on. Like, if you get into a job and you feel yourself procrastinating all the time, that's an indicator that you're not working on the right thing. And that might be you're in the wrong job, but it doesn't mean that you're a bad engineer. Right. It doesn't mean that you're bad at writing software. It might just be that this isn't the right position for you.
02:16:54.125 - 02:17:55.093, Speaker A: And, you know, I think there's a real concern when you're first starting out, and I think this applies equally well later on in your career, that you end up under counting your own contributions or setting too high of a bar for yourself. And as a result, you overwork because you feel like you have to compensate, even though no one actually told you that you had to compensate. But you, you feel that way maybe because you aren't that interested in the works. You feel like you're slacking off, but then you feel like you have to catch up because you feel like you were slacking off. And it's just, it's this vicious cycle where you burn out, you feel unproductive, you feel like you're not doing well, even though there isn't actually any evidence to demonstrate that that is the case. And so I think, you know, be very mindful of the fact that you, your job is a job. It is not you.
02:17:55.093 - 02:18:23.535, Speaker A: It's not your personality, it's not your value as a human. Right. It is a job. But also try to find a job that you enjoy because then much of that nervousness is going to go away because you, as you start working on it, you feel that you're working on things that you enjoy doing. And if that's the case, you worry much less about, you know, whether I'm engineering. Good. A little bit of a rambling answer, but.
02:18:23.535 - 02:19:00.724, Speaker A: But the. I think overall, like, in general, most of the pressure you feel is probably going to come from yourself. If it's coming a lot from other people. That indicates a different problem. That might indicate that there's a sort of management problem, essentially. It might indicate that there's a mismatch between how you want to work and how the company wants you to work, which might indicate that this is not the right position for you. But it should be a pretty.
02:19:00.724 - 02:19:39.575, Speaker A: It should take a lot of evidence for you to actually be like concluding that you're not doing a good job as an engineer. Like, focus on what measurable evidence you have for that being the case. And in general that won't be the situation. There'll be something else that the problem is. Oh, funny bots. All right, block. Nice.
02:19:39.575 - 02:19:51.954, Speaker A: And another one. Block. I love blocking bots. Bye. Bye. Okay. Mmm.
02:19:51.954 - 02:20:17.045, Speaker A: Let's see. I hope that answered the question. I mean, I know it's, it's really terrifying to start your first programming job. Like for me it was similar when I started Amazon, right. Because all my background, or very much of my background was in, in academia. And so suddenly being like, I'm going to be at a company now is weird. But it wasn't a problem.
02:20:17.045 - 02:20:59.925, Speaker A: I think partially for me, I, I sort of went into it with the mindset of I know what I'm doing and that helped a lot. And you. Maybe it's. Maybe I was sort of self delusion, but I think it is, it does help to go into the mindset of no one else is nervous about you joining the company, right. You got hired, so no one else is nervous. So why are you nervous? Okay, let's see. I think I'm gonna keep going.
02:20:59.925 - 02:21:36.027, Speaker A: I'm just. Okay. So slight aside, I was, you know, the setup for the stream was that I wanted to, that I got a new camera setup and one of the things I wanted to do was compare the two cameras side by side, but I realized I'm missing a cable. So the camera needs a micro HDMI cable and I only had one, which is the one I used for the other camera. So I ordered one and it got delayed. So it's arriving today instead of yesterday. I tried to get one before I started streaming today and the place I went to was closed and all the other ones opened after the stream was supposed to start.
02:21:36.027 - 02:22:32.101, Speaker A: But I think the cable is about to be delivered. So if it is delivered during the stream, I'll hook up the second camera and we can do a comparison. So I'm just keeping an eye for if it gets delivered. What would you want to be if you weren't a software engineer? I think it's a close race between a teacher and a, like working in, working with kids. Whether it be at a, sort of like a kindergarten or like an activity center or something. You know, I've, I've worked at a, an activity camp for kids for many, many years. And I love doing that.
02:22:32.101 - 02:22:48.857, Speaker A: And it's, it's totally something I could do full time. It's. I don't know that there are ways in which you could do it full time. But I love working with kids. It's a lot of fun. But I also really love teaching. And you know, there's an argument of, well, maybe you should just be a teacher because you get to work with kids.
02:22:48.857 - 02:23:43.325, Speaker A: And that's true. But it's different if you're a teacher in, you know, middle school or high school or primary school for that matter. You have a different relationship with the kids because they have to be there and your job is to teach them. And it's true that you can develop, you know, a good social connection with the people you teach. But at least I've. My, I don't know, expectation is that if you are like a camp counselor, for example, it's a very different experience because you get to know the kids in a, in a context where you are, you're not really, you know, trying to lead them to water, but instead you're there to enable them to have fun. And I love being in that setting too.
02:23:43.325 - 02:24:16.585, Speaker A: Maybe I would do both. Maybe I would sort of time switch between them, I don't know. But I think realistically that's the best alternative I see for myself. Yeah, someone in chat knows the name of the camp I work at. It's great. It's been so much fun. I think I would work there for the rest of my life if the kids wouldn't find it super weird for like a, you know, if I'm 60 years old and still, you know, working at an activity camp for 8 to 15 year olds.
02:24:16.585 - 02:25:05.497, Speaker A: All right, let's see. What do you think about ensemble mob pair programming versus alone programming with code reviews? I think they both have a really good place. I, I wouldn't want to do just one or the other. I don't really do, you know, more than one programming very much at work. It happens every now and again where, you know, especially if a, if I or a colleague have run into just some hairy bug or something where we're just like burnt out trying to figure out why something isn't working. And we're just like, okay, let's just tag team this together. We're going to go on a video call, share screen and just work this out.
02:25:05.497 - 02:25:47.673, Speaker A: And sometimes that ends up being like a two hour session where we're really just heads down in the problem together. That can be really, really useful. But that's the extent to which I do it at work. I don't have regularly set up sessions where I do that, but I do get a lot of experience that actually with the streams that I do, which are a little different, right? Because I'm not on a video call with anyone. But it feels like ensemble programming, kind of. Or mob programming when I'm working with chat, right. Because for the implementation, not so much for Crust of Rust, because that's more teaching, but for the implementation streams, we're really building and designing an implementation together.
02:25:47.673 - 02:26:44.901, Speaker A: And I found that so much fun, but also really useful to have that ongoing interaction with other people who are looking at reading, thinking about the same problem, the same code as me. That said, it is slower. Maybe I don't know if slower is the right word, but I can get a lot more work done if I work alone because I don't have to voice my thoughts. And I think that the trade off here is that sometimes voicing your thoughts is necessary to get to the best solution or even to a solution, but oftentimes it's not. Oftentimes I can solve the problem on my own and then it's more efficient for me to do so. And so then I would rather work alone and then submit a code review for, you know, the things I might have missed. So I think they both have a place.
02:26:44.901 - 02:27:53.265, Speaker A: I think my default is to assume that I can do things on my own and then to engage in programming in pairs, in ensembles, when there's a compelling reason to do so. Like when me working on my own either gets me stuck or where I'm actively trying to convey something to other people, like if I had a colleague, for example, who's trying to understand a code base, say because they're a new engineer, I'd be happy to do a sort of pair programming session with them in order for them to learn. Because if I told them we'll just submit a CR and submit a PR and I'll give you code reviews on it, they wouldn't learn as well from that. So I think for teaching purposes, pair programming works really well. For getting unstuck, it works really well. But for everyday programming, I like working alone. Which debugger do you use for Rust and does it have a working break on Panic functionality? I very rarely use a debugger for my Rust code and I don't know why this is.
02:27:53.265 - 02:29:12.195, Speaker A: It's fascinating to me and I don't have a great answer, but it seems like, you know, a lot of developers really want a Debugger and I just very rarely reach for one. It happens, right? Well, I'll basically use GDB to set breakpoints and work through some code, but it's pretty rare. Usually print debugging works really well. I set up decently good trace logging and I just enabled verbose logging and run the thing and it becomes somewhat clear what's going on fairly quickly and I can iterate on that pretty quickly. It could be that I just, you know, haven't had. I haven't experienced the just how good it can be, how tight you can get the cycle with, with breakpoint debugging, but it's just not really been an area where I felt a lot of need and I think, you know, chat observed the same thing where I think it heavily depends on the context in which you're doing programming. Where, you know, maybe it's the, the problem areas that I work in where debugging wouldn't really help me.
02:29:12.195 - 02:30:40.335, Speaker A: Whereas maybe if, you know, if you're, if you're developing, I don't know, if you're doing algorithmic development, maybe like you're actually implementing an algorithm and you really need to trace through the individual steps and see how values change over time. Or maybe if you have a particularly complex service stack where it's like there's a bunch of code that you don't control and so you can't really instrument it with print lines and stuff very easily, but that's where the bugs are, so you need GDB to get into there. It is totally true that in those cases you're more likely to need a real debugger experience than in the context I work where very often I control a decent amount of the stack, but even there I will often then just patch in the dependency and just modify the source of it directly. And that works pretty well as well. I think my answer here is I don't really use a debugger and therefore I don't have a great answer. But at the same time I've found the GDB works pretty well when I do have to reach for it. But that's not a great answer just because it could be that the times when I have to reach for a debugger, or rather the times when I don't reach for a debugger but other people want to use a debugger, the use case is there, GDB is worse at and that that would be a blind spot for me.
02:30:40.335 - 02:32:10.675, Speaker A: It could also be that it's a matter of like that how deep in the stack you work Right. Like if you're, let's say, relatively speaking, an engineer that works higher up in the stack so that you have a lot of abstractions under you between you and the actual execution, then gdb, or let's say like a debugger would actually be more useful to you than if you're working lower in the stack and so you have a decent mental model of the entirety of execution, then the debugger might actually not help you that much compared to being able to actually step down through the stack if you're working at a very high level. But it's hard for me to say game engine deep programming makes a lot of sense. Another place where your use for a debugger might be much higher because things like print debugging just won't work. There'll be, there'll be too much output, it'll be too hard to parse through. I do remember that, you know, when working on Noria, which was a very high performance, low latency system, it was certainly true that there I used to debugger much more than I do now because it had, you know, there were some just execution loops where I just couldn't do print debugging or, or where the bug would disappear if I did print debugging. And so I needed to do, you know, watchers and breakpoints and whatnot.
02:32:10.675 - 02:33:30.265, Speaker A: After you finish your undergraduate degree, why did you go for the academic path? What is your thinking behind that? You know, I don't know that it was quite that intentional. I think what happened was I finished my bachelor's and I was like, well, I want to study more. Like, I just wanted to, I wanted to learn more things. And I think partially, you know, my undergrad was very general computer science and I felt like there were a lot of, I felt like there were a lot of technical things that I still wanted to learn that were more technical in nature than like, you know, general purpose programming. And so that's why I applied to a master's program was like, well, I applied partially because I didn't get into mit and so I wanted to find a master's program to do so I could apply again. But, but that desire to ultimately go to MIT as well was, was driven by, I think, the desire to really specialize and learn. I don't know, I wanted to learn everything there was to learn.
02:33:30.265 - 02:34:15.659, Speaker A: Like, I think, I think I have a real hunger for learning. And you know, academia is sort of designed for that. And so it felt like a very natural actual course, just keep on going in the in the track that I was in, and I didn't really feel a strong pull towards working in industry. It just didn't. That didn't seem like a particularly compelling path to me. I think that changed over the course of the PhD, just because I felt like, okay, I really have learned a lot of specialization now, and now I want to see the, the practical applications of that work. Because during your PhD you do end up with a very academic focus.
02:34:15.659 - 02:35:16.367, Speaker A: And for me, at least that was frustrating because I felt like, you know, there's a lot of cool research here, but it doesn't matter if it's not practical. And therefore I wanted to. I felt more of that need, that drive, that desire to go into industry and work more on the practical applications of that kind of work. I think one thing the academic track gave me a lot of, which I think is, which I appreciated a lot, was the freedom to choose what you work on. Like in industry, you're very constrained, right? You need to work on things that matter to the business, and there can be a decent amount of freedom in that too. A lot of things might matter to the business, but, you know, during the PhD program especially, I had so much freedom to just work on things I thought were interesting things, I thought had the opportunity to have interesting questions in them. I got to do a lot of work in open source.
02:35:16.367 - 02:36:35.957, Speaker A: That's when I got to start doing streams, because I had the time, frankly, and the lack of constraints on what I could spend my work day on. And, and so I, I think a lot of my, my set of side projects essentially came from being in academia and therefore having that leeway that time, that, that flexibility to, to branch out. Are PhDs funded in the US or did you need to pay for it? It varies heavily from university to university. At mit, it was paid for. So the paid for is with a bunch of asterisks. Basically every semester you can either be a research assistant for a professor or a lab, and then they basically pay you a stipend, or you can work as a teaching assistant for a class and MIT pays you the same stipend amount, or you can be on a scholarship from one of the science foundations, for example, in the U.S. for me, it worked out pretty well.
02:36:35.957 - 02:38:04.715, Speaker A: I was a teaching assistant for many semesters, many more than are required, because I think it's really fun to teach. But there were also several semesters where I was just a research assistant for the professor who was my advisor, and the research I was doing was my own work. So it just worked out really well, but that's not the case for every PhD program in the US or I think globally, where it can be pretty hard to gather the funds to get that flexibility in the first place because you're basically accumulating debt while working this up. Is a little different in Europe, in many European countries, for example, where you know that education is free. My sense though is that the PhD programs and Europe in particular are a little bit different than the ones in the US where they're more focused on, you know, a set track. Whereas the PhD program in the US is very often just you need to turn in a thesis at some point and maybe there's a mandatory classes, but there's a lot of, let's say, choose your own adventure, right? Like there's a lot of just you figure out what you should work on and how to be disciplined about your own time. And so even though it is free in Europe or can be free in Europe, it might also be a different experience than what I had here.
02:38:04.715 - 02:39:03.383, Speaker A: How do you compare self study versus study in an academic setting? So at least during the MIT PhD you have to do relatively little studying. I think I had. I forget what the exact requirements is, but I think I took six classes at mit. I might be off by one or two, but there are not a lot of mandatory units you have to take over the course of like six years. I think I took classes for the first year and a half or two years and the rest of it I didn't take classes. I was a teaching assistant for many of those semesters, but I didn't take any classes because that wasn't required. You can but so really a lot of it was, you know, figuring out what should I be working on, what should I be learning and going to learn those things on your own.
02:39:03.383 - 02:39:32.879, Speaker A: So there's a lot of self study, but that varies from university to university too. I think at Berkeley, for example, you take a lot more classes that are, you know, required as a, as a. Or you need to take them in order to graduate. And you know, I like the freedom that I got but. But it also requires a lot, a lot more self discipline so that you don't end up just not doing work. And so it takes forever you to graduate. You're still working on the topics related to your PhD research.
02:39:32.879 - 02:40:01.789, Speaker A: No, I'm not. In fact, the work at Amazon that I do is completely unrelated to my, to my PhD work. It's like my PhD work was on a fast database and my work now is on developer experience tooling it's very, very different. I did co found a company called Ready Set that is basically building a commercial version of Noria of the. Of my PhD thesis work. But it's a. But I'm only involved in that company and in that I was a co founder on it.
02:40:01.789 - 02:40:52.545, Speaker A: I don't work for the company. Yeah. So the UK I think is quite similar to the US in that you have a decent amount of flexibility in terms of choosing what you work on. It's, it's, it's fairly free form. Although you do have a decent amount of guidance from an advisor for example, to, to guide you through that work all. What are your thoughts on parasocial relationships? Like if I met you somewhere I would feel like I knew you while you would have no idea who I was. It's a great question.
02:40:52.545 - 02:41:57.885, Speaker A: It's been a very bizarre experience actually to go to like Rust conferences for example, where you know, at this point I'm a decent number of people in the Rust ecosystem know or Rust community, rather know who I am either either through my streams or through my book or through rostation station. And it means that when I go to these conferences suddenly like people recognize me, people know things about me or what I've done. And it's, it's a, it's a pretty bizarre experience because I, I mean as the question says, like I have no idea who they are and yet they come up to me as though they know me and in some sense they do. And to be clear, I think that's great. I think it's a fun experience, but it is very bizarre and I don't always know how to react to it. That said, I think I've always been a. That's not true.
02:41:57.885 - 02:42:40.715, Speaker A: I have become a fairly social person. Like I'm pretty good at just picking up with someone as if I've known them for a long time. Probably, you know, almost to the point where it's a little. I almost said too much. But it depends on the culture you're in. But certainly like I have very few barriers on what I will talk to people about. And so if people like I will just not have filters on what topics are appropriate for conversation necessarily.
02:42:40.715 - 02:44:13.365, Speaker A: And in this particular case that actually ends up being pretty useful because it means that when people approach me as though they know me, I'll just sort of respond in kind because that is generally how I interact with people. But yeah, it has been a very weird experience of that kind of starting from different points in the relationship in the conversation. What concepts do you suggest to learn or understand before someone should be looking for a Rust job. So for example, people coming from more high level languages or even dynamic languages like Python or JavaScript, I think you, I think I don't know that there are specific things necessarily that I would recommend that like you need to learn this thing in order to take a Rust job. Instead, what I would advise is write something in Rust, like write a semi non trivial command line tool, for example, or like library is a little harder. But like build some kind of tool in Rust that does something that might be useful to you because it's going to force you to learn a lot of things. And once you've learned them, you're a significant step up from having come from another language, like a dynamically programmed, dynamically interpreted language, for example, dynamically typed.
02:44:13.365 - 02:45:14.225, Speaker A: And while you're building that program in Rust, try to make sure that you understand all the pieces of it. It's very easy to do things like, oh, I need to do this thing, I'm going to use a crate, I'm going to copy this paste from this code from Stack Overflow where someone told me how to do it and then be like, okay, I managed to build a binary that does the thing that I want. It's, it's tempting to do that and it's easy to do that. But I think if your goal is to become more comfor comfortable with Rust so that you can use it in a professional setting, then you want to dig one level deeper and be like, do I actually understand all of the code that's in this program I just wrote? And if you, if you take that extra step and you really dig into learning those pieces, I think you're in a pretty good position. You're going to be, you know, junior level in terms of your Rust knowledge. But even so, that, that's often enough to get started. If I have to give, if I had to give one recommendation for a thing you should invest in understanding in Rust, I think it's trade bounds.
02:45:14.225 - 02:46:19.207, Speaker A: I think a lot of people who work with Rust have a sort of cursory knowledge of trade bounds. Like I kind of sort of know what's going on and really digging in and understanding the type system and in particular how trait bounds work out in Rust is it gives some pretty hard to measure rewards. You're going to find that there's a barrier that's suddenly gone in. Trying to understand what a library does or a function signature or you know, why the compiler is yelling at you when certain trait binds aren't aren't applied. I think that's one of the like worth investing time in understanding properly. So that maybe would be my recommendation but, but primary recommendation is write something real in Rust and make sure you really understand it. What made you choose mit? This one is, is, is funny because I think I chose MIT when I was like a child.
02:46:19.207 - 02:47:43.345, Speaker A: Like I think when I was 13, 14 maybe I decided that I wanted to go to MIT. And you know, as a, as like a kid in Norway, I had no idea what the implications of such a statement was because I didn't know that that was difficult. I didn't know that MIT was going to be both hard to get into but also you know, demanding to be in. I just, I just saw that a lot of the cool things that I saw and read about and learned came out of MIT and was like I want to be there. And, and so that became my sort of long term goal semi accidentally and without understanding that that was a long road to start down. And you know, as I got closer to making that goal a reality which was really, you know when, when I ultimately got accepted to mit it was after finishing my master's degree in the UK and at that point I got into mit, Berkeley, Stanford, Harvard and University of Washington. And at that point the, the choice became very real.
02:47:43.345 - 02:48:46.653, Speaker A: I think maybe almost for the first time where oh, I actually have to choose between these that are, you know, all very high quality choices. And like when the question says what made you choose mit? It's more of a, like it depends where in the process you ask. Because early on it was MIT does really cool, interesting work. I want to be in that environment. Later on it was why do I choose MIT compared to other similar alternatives. And there the choice for me came down to, I think ultimately I came down to University of Washington, Berkeley or mit. I eliminated University of Washington at the time because their computer science department was still relatively small and I wasn't confident enough in which topic I cared the most about that I like, I wasn't confident enough that I wouldn't change my mind about which subfield I wanted to be in.
02:48:46.653 - 02:50:09.423, Speaker A: And because the UW computer science department was relatively small, they had really good experts in certain things. But I was worried that even though they had experts in the things I was currently super interested in, if my interest changed there might not be experts in the adjacent fields I eliminated. And then it came down to Berkeley and mit and for me that became a choice apparently or seemingly between Berkeley being more social perhaps and MIT having technical ideas that resonated more with me, seemed like more interesting technical topics for me. And between those two, I figured, you know, I'm going to work on this for six years. It's more important to me that the technical problems are interesting and then I can always make the social stuff work out than the other way around. And so therefore I went with mit. Let's see, what do you think of Elon Musk? Do you plan on quitting Twitter? Okay, I.
02:50:09.423 - 02:51:01.335, Speaker A: I think Elon Musk is an ass. I also think he's a smart ass. I'm unsure whether he's smart. I think that's my summary assessment of Elon Musk in terms of planning to quit Twitter. That's tougher because I think Twitter does give me a lot of value, not just in terms of a lot of people are on there. So it's easy to reach many people and it's a format that I like decently well, but also because there are many people there. Over the years I've accumulated, I think, a pretty good set of people that I follow so that I get a lot of value out of reading my Twitter timeline stream.
02:51:01.335 - 02:51:43.681, Speaker A: And it's hard to replicate that elsewhere. But at the same time, I don't think it's. I don't know how long Twitter is going to remain a good place to be. So one of the things I've thought about is to make Twitter sort of read only for me. So move to another platform in terms of where I would post things, where I would write and then still consume things from Twitter. But that raises other questions. Like, you know, it feels unnatural to see a tweet and want to respond to it, but respond on a different platform because then the author of that thing won't see the thing I post.
02:51:43.681 - 02:52:38.791, Speaker A: I can post a link to it on there, but then that gets weird too, because what if they reply to the link or if I see something interesting on Twitter, do I share the link to it on this other platform? And then have people like that means that I'm no longer signal boosting in quite the same way, right? Ideally, I want to give attribution to the author and have the author get likes and retweets and follows and whatnot. But if they're on a different platform, that gets a little weird. Whereas if I retweet it, it directly gets the attribution of the author. So there are a bunch of open questions there and even things like which alternative platform is the one that I would want to switch to? I've been on Mastodon for a while. And I keep forgetting that I have one. I keep forgetting to put things there. And multiposting is really inconvenient.
02:52:38.791 - 02:53:31.755, Speaker A: And not just, you know, I could automate it, but it's also just, it means that I have to monitor multiple places where replies come back. It means that I have to cater to multiple different limitations on, you know, how long can a tweet be? What, how is it presented? It's, it's awkward to post to many places. And so then the question becomes, should I just pick one? And like if, whether that be, you know, Mastodon or co host or something else, like if I'm just on one platform, that, that might help with that problem. But suddenly that means, you know, anyone who's on the other platforms is now not connected. They're not, they would have to move to that platform to, to get what I write. But it would solve the problem of having to split my attention too many ways. I don't have an answer.
02:53:31.755 - 02:54:13.853, Speaker A: I think quitting Twitter right now is not something I'm going to do, but I do think that I will sort of soft move to something and I'd have to figure out what that transition plan looks like. And it's also the question of I would want to make sure that the thing I move to is more sustainable. There's an argument to like, Patreon could be that thing. Right. I could move to a platform that is also the place where people, where I would post, you know, content that is limited to people who pay, for example. But I don't love that model either. Patreon is also not a great social platform, so I don't know where I would go instead is sort of part of the question here.
02:54:13.853 - 02:55:49.447, Speaker A: Right. So I, I don't, I don't know what the alternative is, but I, I, I am looking at alternatives. Oh, was my thing delivered? Was cable delivered? It's outside right now as I might be able to, that means I might be able to show the second camera before I end the stream because I think we're getting towards the end here. What are the biggest challenges in developer experience and tooling and Rust at Amazon and in general or in software in general? It's a very broad question. I think the challenge of the developer experience at companies, and this is not just Amazon, I suspect this is the case at other companies as well, is that for internal development you have a bunch of additional restrictions, you have a bunch of additional rules you have to follow, you have a bunch of different integration requirements for internal systems that do provenance tracking or reporting or compliance or whatnot that your developer tooling needs to integrate with. And trying to bridge that gap between it has to do these things, but also people expect it to work in this way. Bridging that gap is really hard.
02:55:49.447 - 02:56:58.135, Speaker A: So one of the things that I try to do in my work is build developer tooling internally. That makes it feel as though you're having the same experience as you do externally, but it conforms to all the internal stuff and basically hiding the internal complexity as best as possible. And that is very, very difficult to do. You end up with sometimes leaky abstractions, sometimes with, you know, developer tooling that mostly feels similar, but there are like sharp edges if you hold it wrong. And so you can mostly, like in the Rust case in particular, it mostly feels like you're using cargo, but sometimes things don't work because it's not normal cargo. It's a weird configuration of it. And so very much of what my work ends up being is sort of trying to find the right way to expose the external build system Internet internally and to make the internal experience as idiomatic as possible.
02:56:58.135 - 02:57:51.669, Speaker A: More broadly, I think one challenge with developer experience is actually around testing. And again, this is not an Amazon specific problem. But if you're trying to build developer tooling, one challenge you're going to have is that developers have a very diverse set of environments in which they use that tooling. And you don't have a great way of testing against all those environments. Right, like as, as a trivial example, you know, if, if you're building tooling that you expect to work on Windows and macOS and Linux and whatnot, then okay, you might have CI that can run your test suite, you might have CI that can, you know, check that it compiles on all those platforms. But do you have CI that will. Or do you have, I guess CI is the appropriate term here.
02:57:51.669 - 02:59:11.205, Speaker A: Do you have CI that checks that the tool you work, you built, works even if executed within an embedded terminal inside of Intellij? And sometimes that won't be the case. Or, you know, do you have tooling that allows you to test whether this also works when used in the context of the Windows subsystem for Linux? Those are testing your tooling in the way that will actually be used by the developers you're building for in such a way that you ensure that you don't have regressions, for example, is really, really difficult. And you almost need like a CI setup for every possible development developer environment, which becomes impossible. Like, how do you Ensure that your tooling still works if executed in the context of nix. And I don't think we have a good story for testing developer tooling. And that's really hard because it means that it is very easy to introduce regressions in developer tooling that you develop because you don't have as constrained of an environment for usage. So that's, I think, the best answer I can give to that question.
02:59:11.205 - 03:00:30.291, Speaker A: What are some problems you find interesting in the database community? It's been a while now since I worked on databases, but one thing that I certainly spend a lot of time thinking about is indexing, which is in particular the question of how do you. Why do we require humans to choose what indexes to add to their database? Doesn't the database know better? Right? Like it knows the. At least over time, it knows the usage patterns of access to the database and it knows the distribution of the data in the database. And therefore, in theory, it should be able to deduce what the right indexes are. And I know there's been some research on how can we do automatic index selection and that kind of stuff. But that was the question that fascinated me a lot, where I think you could do pretty significant leaps in the experience of using databases and making them faster and better if you could just take away the necessity of defining these indexes. Because I think a lot of developers get them wrong.
03:00:30.291 - 03:02:03.155, Speaker A: They add indexes that have implications that they didn't expect or that weren't needed and just add space and complexity and performance overhead. Or they don't realize that they should be adding indexes and that's the reason why their application is slow, or they didn't need indexes, but now their database has grown large enough or their access frequent enough that now they are needed. And I think there's some really interesting questions there in not just how can the database infer these automatically, but also how can it surface these decisions in a way where they don't surprise developers when suddenly your database is slower because an index got automatically added? I think there's some developer experience questions there too that are. That are really interesting. Let's see, how do you choose between shared memory and the actor pattern for concurrency? So. So one challenge that actors has is that you need to have operations that make sense to do in a relatively single threaded context. And oftentimes that's true, right? Often you can say it makes sense to have an actor to represent, for example, a physical device in a system or a connection to a particular machine, because it's not clear that you can have a lot of concurrency within the actor.
03:02:03.155 - 03:02:57.185, Speaker A: So in an actor system, you often at least end up with having your concurrency happen because you have many actors and the actors can act independently. And that's where your parallelism comes from. Whereas there are some cases where that doesn't really work so well. So for example, let's take merge sort. So if you're trying to do a multithreaded merge sort, it's a little weird to have an actor for each sub bucket that you're sorting. It's possible, right? You can structure it that way. But it's, it's perhaps more natural to just have, you know, threads that operate on shared memory, maybe even like a worker pool where you grab the next slice that hasn't been sorted yet, rather than, you know, spinning up an actor for each sub slice that you end up doing sorting on.
03:02:57.185 - 03:04:11.545, Speaker A: So I usually think of this in terms of I use an actor, I don't choose between shared memory and actors, but rather things that make sense as a, what's the right word for this? As a like single threaded owner of a resource, for example, I turn into actors and then I use shared memory for things where they're, where we're actually doing shared ownership. And that's how you get the parallelism. Like if you have many things that want to share ownership of something and it's not, it doesn't make sense to have it to be a single threaded owner, then you would use shared memory. Do you think there's value in doing a PhD for six plus years if your goal is to join industry? I see a lot of PhD students drop out with an Ms. After spending 3 plus years hence. I was curious to know, if your goal is to go into industry, you should not do a PhD. There are some sectors in industry where there are exceptions to this, but broadly speaking, I would say no.
03:04:11.545 - 03:05:15.931, Speaker A: It's not worthwhile to do a PhD in order to do well in industry. And if you are in the exception cases in general, you will know this pretty quickly. Like you'll basically look at the job postings for jobs that you might be interested in and see whether they require a PhD and it's going to be very rare. So the PhD is, as I mentioned earlier, a pretty big opportunity cost and it's not clear that you recover any of that cost later on. I do think that, you know, there's a lot of value in the freedom that you get by doing a PhD and you get to branch out, learn more about what things you care about and that might change which industry you go into in the first place or what kind of job you look for. For. But if you have a particular goal of going into this part of industry, then a Ph.D.
03:05:15.931 - 03:05:38.637, Speaker A: i don't think is the path to get there. And certainly if industry appeals to you. Oh, thanks. If industry appeals to you, then you might not like the PhD life either. You might not like the PhD work. It might not be like. It's just going to be painful to you.
03:05:38.637 - 03:06:09.125, Speaker A: And I think that's one of the reasons why people end up leaving early is exactly because it doesn't match the things that they enjoy doing. So, general answer, no. All right, let me see if I can plug in this camera, have it work. I got the cable. It's very exciting. Hopefully it's the right cable. Let's see here.
03:06:09.125 - 03:07:11.215, Speaker A: It is the right cable. Let's see here. So one of the reasons why I switched cameras was because the old one does not have autofocus. And so I need to use a long stick to sit back and then point it at the shutter button and hold it down a little so that it will focus. It's real stupid. All right, let's see here. Let's see if this will work.
03:07:11.215 - 03:07:39.065, Speaker A: So I go over here, and then if I now do this. Aha. Oh, is one of them flipped but not the other? No, I think they're. Let's see. Yeah, they both. They're both the same. Okay, so here's old and new, and I guess they're not quite aligned.
03:07:39.065 - 03:08:02.713, Speaker A: I think this needs to go. Okay, so, yeah, you can see this. That's the old camera, that's the new camera. And it's interesting. I'm looking at it now myself, too. And these are also. Another thing worth pointing out is they're also using different capture cards.
03:08:02.713 - 03:08:32.025, Speaker A: So one of them is using the Elgato cam link. That's the one used for the old one. And the new one is using a PCIe card that's P link 5. P shouldn't make a difference for the actual signal. So now the question is which of these are better? Yeah, the loop. So the Lumix is grainier. Let me see if that's because I've set some weird settings on it or whether it actually just is.
03:08:32.025 - 03:08:58.373, Speaker A: Let me try to make the contrast the same here. Ah, it froze. That's not good. This is one of the reasons why I got really frustrated with the. The Elgato because it kept freezing like that. Let's see. I forget what I do to reset it.
03:08:58.373 - 03:09:41.085, Speaker A: I think I do. No, no, it's still unhappy with me. Let's see. Yes. The other thing that's really frustrating about the old one is it's really hard to get it to reset if it breaks. There we go. Okay.
03:09:41.085 - 03:10:14.055, Speaker A: Yes. You see how much grainier the old one is. And also remember, no autofocus versus this one does. I think the old one also the saturation is too high. Let me see if. Yeah, let me try one. OBS really does not like me changing these settings on the fly.
03:10:14.055 - 03:10:55.315, Speaker A: See if I can convince it. No, now the new one stopped. It's a mess. What if I do this and then that? No. Oh, I wonder what if I do this? It's not easy. It's not easy. Come on, come back online.
03:10:55.315 - 03:11:24.425, Speaker A: Well, so much for that. Now it's just. Now it's just me looking very confused in one of the frames. That's right. It's a. It's actually a 3D stream. Let's see.
03:11:24.425 - 03:11:51.375, Speaker A: There's no light in front of me. Actually, there's. It. This is just natural light from Windows. Oh, let me try to unplug it, see if that does the thing. No, I think, I think it just. I think that one's just died now.
03:11:51.375 - 03:12:20.515, Speaker A: I. It's very problematic to try to do anything with these cameras while OBS is trying to capture from them. There might be a Linux thing too where it just gets sad. Well, all right. In that case, I think this is then a good place to stop because otherwise I'm just not going to have video for the. Not have moving video on the main webcam screen. And now you'll just see my old one.
03:12:20.515 - 03:12:54.465, Speaker A: I'll see if I can post a video that just shows the comparison between these more directly. You can see now actually now that I adjusted the saturation as well, so now they have the same contrast and saturation set. If I make the similar kind of. First, they're actually pretty similar in terms of the color definition. It's a little more color in the. In the old one, but it is also a fair amount grainier. It's interesting.
03:12:54.465 - 03:13:25.445, Speaker A: Yeah. The new one has a better. The depth of field is a little different too. So the new camera is a prime lens. So in particular it is. See if I can. Yeah, so the, the new one is a prime 35 millimeter, and this one is a zoom 18 to 35, but with a slightly different crop factor.
03:13:25.445 - 03:14:01.725, Speaker A: So I think like they're. They're not too far apart, but the lower graininess and more importantly the autofocus makes a huge difference. All right, I think that's where I'm going to stop for today, but looks like there are a bunch more questions, so maybe I'll do another Q and A and in not too long. Next. But thank you all for coming out. I hope that was useful, and I will see you next time. So long, everyone.
03:14:01.725 - 03:14:02.125, Speaker A: Bye.
