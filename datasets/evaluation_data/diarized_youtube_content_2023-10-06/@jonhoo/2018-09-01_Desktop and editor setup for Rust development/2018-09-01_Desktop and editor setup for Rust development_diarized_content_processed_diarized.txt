00:00:01.240 - 00:00:29.405, Speaker A: All right. Hello, everyone. Welcome back again. I should probably welcome myself back, I guess, but I've been offline for like, three weeks. It's been fantastic. But now I'm ready to do some streaming again. I figured we'd start with something that I've gotten a request for basically every stream and, like, YouTube comments or Twitter comments or on Patreon, where people have been asking me, like, what is your setup? This seems to be something that a lot of people want to.
00:00:29.405 - 00:01:11.375, Speaker A: Sorry, I just need to do this so my chat doesn't turn off. A lot of people have been asking what my setup is, in part because they want to replicate it or just because they're curious, like, how do you have Firefox but with the tabs on the bottom? And instead of answering everyone individually, I figured I'd do a stream just to get us started on, like, what is my desktop setup? What is my editor setup? What kind of Rust tools do I use commonly? That kind of stuff. For those of you who are new to the streams and have just watched the live video. Sorry, the past streams. I do live streams mostly of Rust coding, although this one is slightly different. And I've done a lot of them. They're all archived on YouTube, so you can watch the past ones.
00:01:11.375 - 00:01:42.015, Speaker A: We've done a lot of different kinds of development on asynchronous IO. We've done some on EC2 orchestration. We've done some on data structures. I have a Patreon page where I post whenever there are upcoming streams, and also where you can support me if you're able to do that. You can also just follow me on Twitter where I announce whenever there are upcoming streams. If you have any ideas for streams you'd like to see, then please let me know, either on Patreon Twitter or just send me an email and I'm happy to look at those. I want to keep doing this for as long as I can.
00:01:42.015 - 00:02:30.515, Speaker A: And of course, hopefully there are more interesting things that you want to see that were both I can learn and you can learn today. I'm going to go through a lot of my setup and there's a GitHub repo that has all my config files, or at least should have all my config files. You can follow along there or copy things from there if you're interested. I should probably do some cleanup of this, which I haven't done in a long time, but at least most of the files are here. If at any point during the stream you have questions whether they're about my setup, whether they're about writing Rust code, about programming in general, about streaming, anything at all, we should use the stream to sort of as an opportunity for you to ask questions like that as well. So if you have any questions at all, feel free to fire away at the chat. I'll monitor it as well and try to answer things as we go.
00:02:30.515 - 00:03:01.315, Speaker A: So now that that repository is out of the way, my. I'm using. I'm running Linux and my setup is just using a tiling window manager. So in particular I'm using xmonet. Although considering switching, I just don't have anything good to switch to yet. A tiling window manager has the ability of doing this. So whenever you open additional windows, they sort of tile nicely and you can change the size of the different tiles, you can move different tiles around.
00:03:01.315 - 00:03:29.267, Speaker A: It's just really convenient for if you don't want to use your mouse all the time because you don't have windows you need to drag around. I've been really happy with xmonad. It's a little bit awkward that all the configuration is in Haskell, but it seems to work all fine. And there's basically no configuration of windows. Like as you can see, I don't have any title bars or anything. So it just. It just ends up with giving you a very seamless interface and I kind of like that.
00:03:29.267 - 00:03:52.887, Speaker A: There's a tiling rust window manager that is kind of cool. This one that I really want to start using at some point. Last time I looked at it, it wasn't quite mature enough to use, but that might have changed. It might now be good enough. It also used to. Oh, that seems to have changed. Okay, yeah, so this is something that I might consider switching to.
00:03:52.887 - 00:04:24.357, Speaker A: I have not given it a chance yet, but it looks pretty neat. As I said, the exact window manager isn't terribly important as long as you able to set up your hotkeys correctly. The bar at the bottom I get a lot of questions about. So at the very bottom here like this, the very bottom here I have a bar that shows you like, which workspace I'm on, what windows open, and the system title bar. Now that is a program called polybar. I recently switched to it and I'm really happy about it. It's very configurable.
00:04:24.357 - 00:04:52.835, Speaker A: So they have a lot of plugins like for example, if I have GitHub notifications, they show up with a little GitHub icon down here. All of this is really convenient and you can use Unicode emojis down here too. So that's how I have an icon here. That's why the GitHub notification icon is an icon. It's really easy to get set up. It's really easy to make it look nice. And it integrates with basically any window manager that you have and produces a really nice layout.
00:04:52.835 - 00:05:09.293, Speaker A: So I can highly recommend polybar. And then my terminal is actually written in Rust. My terminal is Alacrity. It is a terminal manager that was written by. What's his name? Jay Willem. I don't remember his actual name. His actual name is Joe.
00:05:09.293 - 00:05:47.479, Speaker A: Nice. Joe Willem. Well, Joe decided to start writing a terminal manager that was supposed to be fast, right? Like, the goal was to use the GPU to speed up and accelerate the display of the mana, the terminal, because it's something that you open and close and do things and so often that you really want it to be fast. And I think he succeeded. Like, I think Alacrity at this point is really nice to use. It also has a config file that is in YAML, so it's pretty easy to get set up with. I'm using the Noto font and I think together these work just really well.
00:05:47.479 - 00:06:22.053, Speaker A: It ends up looking really nice. And I'm using the. So I'm a big fan of the base 16 themes. So base 16 is this tool that Chris Kempson wrote that basically it is not in and of itself a theme, but it's a way of taking color files and sort of templates for how to set up style sheets or themes for different programs. And then it generates all of the color schemes for all of the programs. So for example, the one I'm using. I don't know if this is listed here anywhere.
00:06:22.053 - 00:06:38.705, Speaker A: Repository. Yeah. So there are a bunch of templates for different programs. Oh, I didn't know this in one. Great. So for all of these programs, there are all of these themes, right? So it cross generates all of them. So I'm using a theme called Atlier Dune.
00:06:38.705 - 00:07:09.687, Speaker A: See if we can actually find this. And I use it in everywhere. Like I use it in Vim, I use it in my terminal, I use it in Phish, I use it everywhere I can find it. It's really nice, both for code and for general terminal setup. And so it's something I can highly recommend doing. But in general, Alacrity just. It's a very minimal terminal emulator, but one that provides basically everything you need.
00:07:09.687 - 00:07:42.549, Speaker A: So I've been really happy with that. My shell is fish, so I'm a big fan of fish. I found it many Years ago. I love the title that Fish is a command line shell for the 90s with the claim that bash and the other sort of non fish shells are from the 80s or even earlier. And so it has various kind of 90s features, which I just appreciate a lot. It just. It's not great for scripting, but it is great for just like general terminal features.
00:07:42.549 - 00:08:09.951, Speaker A: So you have autocomplete. It parses man pages to look for what options are available for a given command. So if I do this right, like it will autocomplete what are the possible sub commands for git, and it does so by parsing the man pages. It has really nice support for history. So history, as opposed to having to press like control R or something like you do in bash to search. Everything is always a search. So if I do this, it will autocomplete with saying git push, because that's the last git command I wrote.
00:08:09.951 - 00:08:55.109, Speaker A: I can also just press arrow up to go back through the ones I've used in the past. The other thing that's nice about Fish is it's pretty easy to write simple commands. Like if you want to run a command multiple times. If you were to do that in Bash, you would do something like for I in Sec 1:10, do echo I, semicolon done, right? So this is how you do it in bash in Fish, it's much simpler. At least I think it's much simpler. Not in the sense that there are fewer commands or anything. It's just that you don't have to remember all the bashes, right? So you don't have to remember that sub commands are in a dollar.
00:08:55.109 - 00:09:24.701, Speaker A: You don't have to remember the do keyword. Everything is ended with end as opposed to in bash, where it's like fi ends, ifs, esac ends, case done ends for. You don't have to think about all of these things. It's just nicer to type simple commands in. So I've been pretty happy with that at this point. There are autocomplete files for Fish for basically every program as well. So that's pretty cool.
00:09:24.701 - 00:10:01.345, Speaker A: Then I use TMUX to do terminal multiplexing. So if you notice when my terminal is open here, notice down at the bottom here it says zero fish. I can rename that to like stream. So what TMUX lets me do is I can press the tmux command key, which is usually Control B. I've remapped it to control A control ac and that creates a second terminal tab, if you will. So it's basically a way to give you tabs in your terminal without having your terminal actually support tabs. I'm a big fan of having things be.
00:10:01.345 - 00:10:20.615, Speaker A: Just use keyboard shortcuts. And that is essentially what this gives me. Because prefix P switches to the previous tab, prefix N switches to the next tab. And you can keep doing this. The other thing that's really nice is if I now close this window entirely. I can do. I just opened a.
00:10:20.615 - 00:10:41.703, Speaker A: Sorry. What I did was just open a terminal window that does not have. That is not running tmux. And here I can run TMUX ls and you see there's still a terminal session open here. So tmux, even if your terminal crashes, TMUX will keep running and keep all your sessions alive. So I can do tmux attach T0. And now I'm back to the one that I had.
00:10:41.703 - 00:11:06.845, Speaker A: I can close it again. Open a new TMUX session here as well. Now there are two sessions. One that's the currently active one and one that is the one that's still running in the background. You could have multiple terminals attached to the same thing. So now if I do tmux attach T4, notice how if I type in one, it appears in the other. So you have multi attachment, which is really nice.
00:11:06.845 - 00:11:41.163, Speaker A: Now, of course, close this old one because I don't need it anymore. And we'll get back to a terminal over here. So TMUX is really nice for multiplexing onto a single terminal window. I sometimes still end up having multiple terminals open, so I might have one to look at a man page and the other where I have code or some command I'm typing that might have multiple tabs. So TMUX does take a little bit of getting used to in the very beginning, but it's just. It's so handy. There are some other ones, so screen is a very common one.
00:11:41.163 - 00:12:08.671, Speaker A: I like TMUX a little bit better. The customization is a little bit better. It also supports a few more things. Like you can. You can do things like this to open another terminal split and you can split the other way as well. So you can do this and it just like there. These are these small things that just make it easier to work.
00:12:08.671 - 00:12:45.325, Speaker A: If your life is primarily operated in a terminal, then you really want keyboard shortcuts for these kind of things. My editor is neovim, which is really cool. I found it a few years ago when they were still just starting out. And it's basically they started with Vim and then they decided to get Rid of all the old stuff, like actually rip out all of the code that was no longer necessary, that was supporting old platforms and such, and just implement the newer. Like implement a nicer protocol for integrating with Vim. So basically Vim is at this point a library for neovim. Sort of.
00:12:45.325 - 00:13:19.149, Speaker A: They have then multiple front ends for it. You can write now extensions and plugins in lots of different languages and there's a JSON RPC protocol between the editor and the extension. This also means that you can have asynchronous behavior of extensions, which now has landed at Vim 8 but was not usually the case in Vim. It also means you can write extensions in other languages than VIM script, which VIM script is a painful language to work with. So like it's just a. I find it to be a better editor. Although VIM is catching up now.
00:13:19.149 - 00:13:44.215, Speaker A: But it's unclear why you would not just use neovim. In part because it's basically backwards compatible. So extensions that work with vim also work with neovim. All the commands are the same, the key bindings are all the same. It just has more things that are nice. In fact, for me, I have the same config file symlinked for both of them. That's how similar they are.
00:13:44.215 - 00:14:25.107, Speaker A: If you look at the vimrc, I have a fairly extensive vimrc that just like has sort of accumulated over the years. Some of it is related to Rust, so let's take a quick look through. So the things that I would say are useful to have are I'm using VIM Plugged, which is a plugin manager for Vim, which is really nice. So if you want to add some kind of VIM extension, you just type Plug and then the username slash repository name from GitHub and it will automatically pull everything down. So this is type this command. Yeah, except not sudo. And if you're using bash, you don't need the N shell part.
00:14:25.107 - 00:14:51.745, Speaker A: And this just updates and installs any plugins you've listed, deletes old ones. All of it handled just really nicely. I'm using lightline, which is this bar down here that tells you what mode you're in and such. I don't know that I really need it anymore, but it does add a certain visual flair to the editor that I kind of like. I'm also using Ale. So Ale is actually really nice. Vim Ale.
00:14:51.745 - 00:15:41.857, Speaker A: So Ale is sort of similar to Syntastic, if any of you use that for older versions of Vim. So it basically gives you a gutter in your editor that gives you things like syntax errors, compilation errors. If you integrate some kind of grammar tool, then it will also point out poor phrasing if you're writing documents in latex or in markdown or whatever. And the nice thing about this compared to syntactic, although syntactic might have changed since, is it's also fully asynchronous. And so it's not like your editor has to wait for the linting or compilation to finish before it can show anything. It actually progresses while you type, and you can keep typing while it's operating. It also supports so many languages and it's fantastic.
00:15:41.857 - 00:16:17.061, Speaker A: The other thing that's nice is for each language it also has multiple implementations. So for Rust, for example, it uses Cargo, rls, Rusty and Rust format and can give you messages from all of them. And I find that really useful. You can also mix and match them. So for example, I have turned on grammar checks for comments in Rust code, which is just really nice to have. So I'm a big fan of Ale highlighted Yank is sort of nice. So it's if you mark multiple lines or if you say that you want to like yank or copy in vim terms the next three lines.
00:16:17.061 - 00:16:49.055, Speaker A: So 3yy, it highlights the things that you copied. Vim router is kind of nice, especially for Rust projects. So what vim router does is if you open a file in vim, it will CD to the root of the nearest git repository. This means that now if you try to open a file, it will open relative to the current directory. It's especially nice in combination with so physic. If you haven't heard of it, I don't actually know how you pronounce. This is a fuzzy finder that integrates really nicely with just like everything.
00:16:49.055 - 00:17:40.973, Speaker A: It basically takes a list of files or a list of just lines of text and lets you do fuzzy search on it. So if I'm in a given repository, so let's go to Tokyo. So if I'm in Tokyo, I can type my shortcut for open a file with visif. And now I have fuzzy search for files. So I can go, let's say I want to look at something in current thread, I want mod rs, right? And then notice how this just gave me a fuzzy search across that entire repository. And because of the because of vim router, it searches from the root. So if I cd, let's say I'm inside Tokyo codec and I'm editing like source lib Source lib in here and now I want to go out to current thread.
00:17:40.973 - 00:18:29.915, Speaker A: I can still just search current and because router put me in the root, I can now search the entire Tokyo repo. It also has things like you can fuzzy search across currently open buffers. So let's see if I open codec, readme, codec toml and codec license, I can now fuzzy search among the open buffers. This is also another binding you can set up. This is really convenient if you're frequently switching between three or four different files. The other binding I have in Vim that I've been really happy with is Vim has notion of a leader character that is sort of like the thing you press before command keys. I've set that to space and then I have leader leader mapped to switch to the buffer I was just in.
00:18:29.915 - 00:19:13.185, Speaker A: So I can really switch really quickly switch between two files. This just speeds up development so much when you're in the terminal because it's so often, especially in Rust code, where you're modifying two files because one is calling the other or something like that, and quick switching is really handy. Let's see, what else do we have? Language Client neovim so this is the thing you need to install in order to use RLS. With NeoVim, it also integrates with ALE really nicely. There's some talk about integrating Language client directly into neovim, but that work hasn't landed yet. But when that lands, hopefully this plugin will go away. Even though it works pretty well.
00:19:13.185 - 00:19:46.167, Speaker A: NCM2 is what gives you autocomplete. Ooh, this one. So it was called the NVM Completion Manager and now it's just ncm. Whenever you're writing code, it gives you autocomplete for using whatever source you have for autocompletion. So in my case this would be using RLS, for example. And so it gives you really nice autocomplete for css. It gives you autocomplete for like keywords and values, which is really nice for Rust code.
00:19:46.167 - 00:20:35.571, Speaker A: It gives you any kind of autocomplete that RLS RLS gives you. It gives you like Python and JavaScript completion, just all kinds of completion and just works really well. Like I basically have no problems with ncm. The one thing that's worth pointing out is in Vim, the default autocomplete behavior is a little bit weird, so you need to explicitly say what tab and enter should do. And so it's taken me a little while to set up these exactly the way I expect it to work like basically this is saying that if the. So for if I press tab if the. If the autocomplete popup is open and an element has not been selected, then then select one.
00:20:35.571 - 00:21:29.431, Speaker A: If it has been selected, choose it otherwise insert a tab right? So these are. This is just my preference and there's a default that they given here that you should probably just use and then see whether it works for you. But one thing that is nice is you can change these as you see fit. What else do I have some plugins for NCM, Echo Doc, although that's not terribly important anymore. The Rust plugin, although that's also not terribly important and support for Fish also not important. What else here is relevant? So here you see there's still a basic Steam theme I'm using rg so riprep, the Rust searching tool that's sort of like grep or the Silver Searcher or any of these those written by Burnt Sushi. It's really fast and really nice to use.
00:21:29.431 - 00:22:34.705, Speaker A: So I'm using that for all kind of vim search internally. So there's colon RG where you can search through like it basically searches from the current directory recursively down and takes into account any gitignore files. So this is a really handy search and because of the vim router plugin it will actually search your entire project. So let's say that I'm in Tokyo again and I search for handle right now it gives you all results for handle and it gives you fuzzy search over the results, right? So it's just these things all just integrate really nicely and these are the kind of things that you sort of really want to have if you want your an editor like them to sort of have all the conveniences of an id. Can you post your vimrc? Yeah, so my vimrc is all of the config files I have are in this repository. They should all be up to date, but you should double check notice. Also now I have a GitHub notification and there's a notification icon here.
00:22:34.705 - 00:22:56.655, Speaker A: It's really nice. Yeah, so all the config files are here. Learning Rust is pointless without knowing C and systems programming. I tried and felt like I would not reach the kind of understanding that I want. I actually think it's the other way around. I think at this point you might as well learn Rust straight away. I don't think there's an advantage to learning C first.
00:22:56.655 - 00:23:48.025, Speaker A: Learning C first might actually just confuse you, but it sort of depends what research you're using and what you're planning to use Rust and or C for. Like if you're going to do a bunch of embedded programming, it's true that it might be easier to start with C. If you're doing operating systems programming, then maybe it's easier to start with C, but I think in general you might as well just start straight with Rust and then expand your knowledge based on like read tutorials on advanced Rust, for example, a snippet engine. No, I do not use snippet engine. I have never found the use for one. In general it's very rare that I have to write boilerplate code. I think like my typing speed is not generally the bottleneck and so I don't find that snippets really help me.
00:23:48.025 - 00:24:39.395, Speaker A: It is quite the opposite for me. I'm assuming you're referring to Rust versus C, so I'll leave that discussion to the chat. Let's see where we're yeah, so FSF is also really nice because it also works for file search on the command line. I haven't set that up, but I've heard it's nice. Let's see, what else do we have here? So various ALE setups for doing cargo check. Yeah, so I have Control P set up for open a file in this project and that's the one that will also use FSF for autocomplete. And then there's leader semicolon, which is what I use for search for open buffers.
00:24:39.395 - 00:25:18.555, Speaker A: I also have leader W for save the file various things for inspecting things with language client. So gd, for example, goes to the definition of a function for me in Rust code or in any other language that has language client support. What else do I have? Rust format is set up. Of course these aren't terribly important. I should probably document why I have each of these settings. Most of them are there for a good reason. Many of them are there because of things that older versions of Vim did.
00:25:18.555 - 00:26:12.385, Speaker A: Strangely, scroll off is kind of nice actually, but I want that to be too. Come to think of it, what else do I have? Oh yeah, this is a nice thing to set. Undo dir an undo file. What this does is normally if you open vim, do some changes, you can press U to undo, but if you close the file and open it again, you can no longer undo. If you set undo dir and undo file you get undo. Even if you close vim and open the same file again later, you can undo past when you close the editor, which I found so useful because it means you can pop in and out of Vim without losing your undo history. It also means that if you edit, say system configuration file, you can make changes and then like a week later open the same file and undo it again, whatever change you made a week ago.
00:26:12.385 - 00:26:43.343, Speaker A: So that's that. I'm a big fan of what is your keyboard. So I'm currently using a Philco Majesto Touch. Philco Majesto Touch Ninja, this one. And I'm really happy with it. It has the keycaps on the front, which is actually kind of cool. It also just has a good feel.
00:26:43.343 - 00:27:21.059, Speaker A: I'm just really happy with it. At work. I have the Microsoft ergonomic keyboard, but not the new one, but the old one. This one? No, that is the new one. That's terrible. But I've actually been really happy with that because so I do a lot of programming and if you do programming for a long time, like if you're young, it doesn't matter, but after a while you like feel that you're moving your wrist more. And it's nice to have a keyboard that's made to have your wrists in a more neutral position.
00:27:21.059 - 00:28:00.247, Speaker A: So I've been pretty happy with that. But at home I have the Majesto touch and I'm really happy with that too. Let's see. So Pavel, the one thing you might want to look at is what is name this guy. So if you look up Philip Opperman's blog, he has a sequence of posts on implementing an operating system in Rust from scratch. And that covers a lot of the topics that you're talking about. And so you might want to look at that.
00:28:00.247 - 00:29:02.305, Speaker A: It doesn't really talk about like very low level things like how like how compilers worked, but it is a really nice guide just for understanding operating system primitives and in general virtual memory, memory mapping, how monitors work, those kind of things. Let's see, what else do we have here? These not terribly important, kind of neat. One thing you'll find is the more you use. Sorry, the more you use Vim, you start just automatically doing things that people look at and go, what? So ZZ will center the current line in the editor. ZT will put that line at the top of the editor and ZB will put it at the bottom. This is really handy if you're moving around files. Just something to like get used to.
00:29:02.305 - 00:29:31.495, Speaker A: What else do I have? Oh, Control J as Escape is fantastic. So Escape is really far away and it's kind of annoying. Control J is sort of on the home row of the keyboard. So it's really quick to type instead of escape all the time. What else do I. These are for keyboard. Sorry, Clipboard integration.
00:29:31.495 - 00:30:00.795, Speaker A: Like X clipboard integration. It's kind of nice. Not terribly important. One thing you should definitely do in vim, disable the arrow keys immediately. It forces you to learn to use the home row to navigate and it's so much faster. The sculpt ergonomic, uh, Sculptor Gnome. Is that the one? I mean, I think that's the even newer one.
00:30:00.795 - 00:30:50.275, Speaker A: Uh, ooh, this one does not. So I Generally browse with JavaScript disabled and it makes a lot of pages really sad. Also yes, that is the one I have and I'm pretty happy with. It works pretty well. These are handy for working through errors, but it's not terribly important. Yeah, I think that's basically it for neovim. And then you may have noticed that if I list files, so I type ls but it becomes exa.
00:30:50.275 - 00:31:20.097, Speaker A: So this is one thing that if you look at the fish config, fish has a thing called fish user abbreviations where you can set up that a given command is really a different command. So here you'll notice that I've set L to be exa, LS to be exa. LL to be exa L. So basically I've remapped using. Whenever I type L, it just becomes exa. If I type ls, it becomes exa. EXA is a LS replacement written in rust.
00:31:20.097 - 00:31:39.405, Speaker A: And it's really nice. Like it gives you color coding, human readable sizes. It does nicer like tree listings. It's like a better version of LS that I've been really happy with. So just something to like look out for if you're. If you want to use more rust things too. But it's just really nice.
00:31:39.405 - 00:32:02.927, Speaker A: I've been really happy with exa. It gives this kind of output as opposed to the LS output. It also integrates with things like git, like git. So you can. If you pass git, you also get information about the git status of the different files that are listed. For email, I use mut. Ooh, do I want to open my mail right now? That's a good question.
00:32:02.927 - 00:32:26.593, Speaker A: Let me. Give me a second. No, I do not think I want to do that. That's kind of stupid. Well, in any case, Mutt is a command line email client. It's something that I'm going to go with. Most people probably don't want to use.
00:32:26.593 - 00:32:57.895, Speaker A: I just, I live in the terminal and I don't really Want to open more things, Keep more things open in the browser. I am using Fast Mail as my mail provider, and I've been really happy with them. I've used them for many, many years and I've never had any issues. I have basically never used their web client, so I have no idea if it's any good. But they're really good about supporting, like, IMAP and SMTP standards as. So I've never had any integration problems whatsoever. Very little spam, too, so I've been pretty happy with that.
00:32:57.895 - 00:33:37.517, Speaker A: So I use Mutt for that. I also use Buzz, which is a tool I wrote a while ago for, also written in Rust, for notifying me about email. So it comes up with this. Let's see, do I want to run Bus now? Probably. So Buzz is this little tool where all it really does is it puts a little icon in your toolbar that shows you whether or not you have email. It integrates with you just put in essentially the connection details for various IMAP servers. And then when you click it, it runs some customizable command.
00:33:37.517 - 00:34:02.575, Speaker A: And whenever you get new emails, you get a little notification like you saw on the top there. And so that's just a handy. A handy thing to have when you're using Mutt, because otherwise you don't get any kind of notifications from Mud. Right. Mutt does not run in the background. It just. You open it whenever you know that you have email rls.
00:34:02.575 - 00:34:17.745, Speaker A: Right. My guess is most of you have probably seen RLS already. Anyway. Can you link Buzz here? Yes, I can. It's also just on my GitHub. So if you go to GitHub, John who buzz. It's this one.
00:34:17.745 - 00:34:33.357, Speaker A: Escape to Capstock. No, actually, that's another good point. Oh, you can't see notifications in the top. Sorry. The notification looks like this. It's just in the top right corner. You can also customize how it looks.
00:34:33.357 - 00:34:59.831, Speaker A: It just uses the. The default notification daemon. So usually that's notified osd. But yeah, this is all the Buzz does, is it's either an icon like this or an icon like that to show that you have email. And it shows you a notification using whatever notification system that's currently set up on your machine. Usually there's one that comes with every desktop environment. Yeah, so sorry, David.
00:34:59.831 - 00:35:40.131, Speaker A: So I have not mapped Escape to CAPS Lock. I have mapped CAPS Lock to Control. So if I press CAPS Lock, that is really Control and it has just changed my life because it means that Control J for Escape is CAPS Lock J, which is just Perfect home row, new tab control T also just perfect home row. Basically Control C just. There's so many things to do with control, and having that on your little finger is just really handy. So I've actually been happier having that to control than to escape. Tinkering with Vim and tooling can be a deep rabbit hole.
00:35:40.131 - 00:36:17.385, Speaker A: Oh, that's definitely true. That is definitely true that you can spend a lot of time. What I did with Vim is basically I started out with a fairly basic setup, and then over the years, as I found more things that I would enjoy having, I've added that number config. But it's true that you can spend a lot of time on doing it, but at the same time you often end up with a really nice working environment. Like, I spend most of my days in Vim or in my terminal, and so optimizing that actually has major implications on, like my life. Right. And so it's actually worth it.
00:36:17.385 - 00:36:40.887, Speaker A: No more questions about that, I think. All right. Yeah. So rls, most of you are probably aware if you've been using Rust for a while. If not, it's basically a tool that integrates with the Rust compiler that runs. Usually it's run by your editor and runs on the background. Integrates with the compiler and gives your editor information about.
00:36:40.887 - 00:37:17.905, Speaker A: Especially about types. But in general, it gives the editor information about your code base. So you can do things like pull up the documentation for the current function, look up the list of arguments and their types, look up the type of the thing that's currently under the cursor, look up the. Go to the definition of a function that you're currently implementing. It's just a really nice tool for having your editor integrate with the language. It uses the language client protocol, which is a. Which is supported by most editors at this point, some of them just through an extension.
00:37:17.905 - 00:37:51.153, Speaker A: But if you haven't installed rls, I highly recommend you do. It's pretty straightforward. Now, if you're using rustop, you just add these components and then there are instructions here for how to integrate it with various kind of editors. If you look at neovim language client, I think they even explicitly have an example for the RLS somewhere. Yeah, here. Right. So the example configuration is server commands for Rust.
00:37:51.153 - 00:38:15.505, Speaker A: Run Rust up, run stable rls. That's basically all you need. And then it just works. RLS does have to. It does compile your code in the background as you're typing, and so that can call cause some more strain on system resources. But it's usually not that bad. So it uses incremental compilation, and because it integrates with the compiler, it usually doesn't do much more work than is necessary.
00:38:15.505 - 00:39:02.541, Speaker A: But if you're working on very large projects, you may want to turn it off, at least for the time being. It has gotten a lot better, but for example, I have one project I'm working on that's like a 50,000 line code base, and running RLS on that all the time is not always great. Depends a little bit what files you change. I also have a bunch of cargo extensions installed. So if you type Cargo install and then there are a bunch of different cargo utilities, like the one that most of you have probably heard about is Rust Format. So that installs a tool called Cargo Dash format. The way this works is just the cargo tool.
00:39:02.541 - 00:39:44.195, Speaker A: If you type like foobar here, what that really does is it looks on your system for a binary called cargo foobar and then runs it. And so Cargo format, for example, integrates with Rust format, so you can type Cargo format to format your current cargo project. But there are a lot of other neat cargo extensions or cargo utilities that I have installed. The first one of them is Cargo Outdated. So Cargo Outdated. What will you be building today? So today I'm actually not building anything. Today I'm just going through my desktop and editor setup because we're still trying to figure out what the next thing we build should be.
00:39:44.195 - 00:40:40.647, Speaker A: But I've gotten so many questions about what my setup is that I figured I'd do a stream on it. But if you have questions, then feel free to fire away and I'll try to answer them as we go, even if they're not about my setup, but about roster coding in general. So Cargo Outdated is a really nice tool that you can run, and it will tell you so here's an example. It will tell you for each of your dependencies, what is the latest upstream version or released version that is compatible with the one you've listed in your cargo tunnel? And what is the actual latest version of that project that you that might be a major version bump, but something you would have to do some manual work to upgrade to. And it does so even for transitive dependencies. So this is a really nice way to get an overview of are there dependencies that you should be updating but haven't? So for example, if we go to Tokyo, actually Tokyo is set up a little bit weirdly. Let's go to Tokyo.
00:40:40.647 - 00:40:58.159, Speaker A: Suit keeper. Why not? So if we run Cargo Outdated here, what it does is essentially sort of compile to your crate and then looks at all the dependencies and sees which of them are out of date. So we'll see what this comes up with. There'll probably be some things throughoutdated. I'll just. Yeah, here. So here.
00:40:58.159 - 00:41:42.835, Speaker A: That's a lot of things in fact. So you can see Bytes order, for example, is not up to date. Failure is not up to date. Although most of these things you'll notice are only minor updates. So if I do Cargo update and then run Cargo outdated again now nothing is out of date. So what this really means is my cargo toml is fine. Like there haven't been any major releases to any of these, but my cargo lock was set to older versions some ideas for GitHub audits PRs so far I came up with about 20 features that audits Rust PR specifically, you mean? Oh for like repositories in general, you could probably do that.
00:41:42.835 - 00:42:50.695, Speaker A: The part of the problem with GitHub bots is that they're a little bit hard to discover, but it might just be fine Do I have thoughts on X11 versus Wayland? Yeah, I really want to switch to Wayland actually, but there are a bunch of things that are preventing me from doing so. So the login manager I use does not support Wayland yet and I quite like it. Firefox only has sort of partial Wayland support. I haven't found a good a good window manager for Wayland yet. There's this thing called Way Cooler, which is also a tiling window manager written in Rust that is for Wayland, but it seems to not have seen updates for a while. It may have gotten better. It's just like I don't think Wayland is quite like I don't think the applications and the environments for Wayland are quite there yet, but then again won't get anywhere if no one uses it.
00:42:50.695 - 00:43:28.465, Speaker A: But so I want to. I just haven't yet. I think I saw Sway at some point. Yeah, I mean this seems pretty similar to they all oh, they also maintain WS roots. That's pretty. Yeah, I mean I look at Wayland every now and again. I subscribe for example to the Firefox bug tracker for the Wayland issue and it still hasn't been resolved because there's so many sub issues.
00:43:28.465 - 00:44:06.155, Speaker A: It's a little annoying. What else does Cargo outdated work with Windows? It should in theory you should just be able to run like Cargo install Cargo outdated. Does that not work for you? Oh yeah. Neovim works great with Rust. I've had no Issues with that, really. Sway is about to release a new major version. It seems nice.
00:44:06.155 - 00:44:40.967, Speaker A: Yeah Ask you about lock and login with xmonad. So for locking, in fact I can just show you my Xmodad config. So let's look at some Haskell code. So for the key bindings for Xmonad, I have a bunch of things set up. The most important one for that is I have. So mod 4 is the windows key plus L is lock. I'm using S lock.
00:44:40.967 - 00:45:09.305, Speaker A: I don't think it matters terribly much. With screen lock you use. I've been pretty happy with S lock. All it really does is it blanks your screen entirely and then if you type, the screen turns blue. If you press enter and the password is incorrect, it turns red and then it stays red until you unlock. So this means that if you can visually tell if someone tried to unlock your computer while you were away from it. This hasn't happened to me yet, but it's a feature that the system has, so I've been pretty happy with that.
00:45:09.305 - 00:45:47.679, Speaker A: For login, I use SDDM this thing and I've actually been really happy with it. It looks quite pretty. It's. It works even with multi monitor just like overall pretty, pretty nice and integrates nicely with systemd. Yeah, I mean I wish there was something simpler like ideally I want something that just like has minimal configuration, which STDM does not do. Like it uses qt. It has a bunch of dependencies, but it works pretty well.
00:45:47.679 - 00:46:13.785, Speaker A: It also now supports Wayland, although the I think the support is still somewhat finicky. But I works pretty well. I just ran Cargo install Cargo outdate and came up with that issue. Yeah, that seems weird. I think you should probably. You should probably report that upstream. That seems like a bug surprise at the rewrites, new Utils and Rust.
00:46:13.785 - 00:46:48.895, Speaker A: Oh yeah, I've seen that. Don't remember what it's called at the moment, but that is really neat. The other thing that is kind of cool is Rust gimli. So Gimli is a parser for debug info for files. What's particularly cool is there's also addertoline. So I was part of writing the implementation for this and it's really neat. It's basically a reimplementation of Adder 2 line from bin Utils that is written in Rust and is faster and also kind of nicer.
00:46:48.895 - 00:47:11.175, Speaker A: So that's also a fun thing to look at if you're interested about those kind of things. Redox the Rust operating system is also really neat. I don't know how far they've gotten at this point. That's a good question. I think you can boot it on a decent amount of hardware. I don't know that there's a good reason to. Except that it's kind of fun.
00:47:11.175 - 00:47:29.723, Speaker A: Yeah. Includes common UNIX commands. Kind of neat. Maybe I'll try it sometime. Like there's just such a high barrier to like using a different operating system that. Or especially using a new operating system. But it could be pretty cool.
00:47:29.723 - 00:47:47.453, Speaker A: I think at this point they've gotten pretty far. What distro to use? I use Arch Linux. Sorry. Yeah, no, you're right. I did not mention this. I've used Arch for many, many, many years and I'm a huge fan. I really like the fact that it's rolling release, that I basically always have up to date versions of things.
00:47:47.453 - 00:48:15.057, Speaker A: It doesn't mean that every now and again something breaks, but it's actually really rare. I rarely have any problems with this. I run it on servers too, without any issue. If you're running some kind of serious production system, you probably shouldn't do it. But for anything that I run, I've been really happy with it. Part of what I like about is the aur, the user repository has packages for basically everything you can imagine. And it's just really easy to write your own packages.
00:48:15.057 - 00:48:50.739, Speaker A: So packages. If we take some silly one, like that's a good example, like oh yeah, that's right. I wrote the package build for rustup. I forgot about that. So you write a file that's just basically a bash file where you declare various things. There's a build function where you build the thing and there's a package where you pick which file should be included in the final package. And that's all there is to writing a package in Arch.
00:48:50.739 - 00:49:18.625, Speaker A: And it's just so easy to get started with. It's so easy to just package random things where normally you just like download it and extract it somewhere. You might as well just write a package around it and then you get all the niceties of it being managed by the package manager. I've just been really happy with Arch. I've had. I have no complaints. You're on Nightly.
00:49:18.625 - 00:49:39.789, Speaker A: I'm also on Nightly. Cargo outdated. Should compile just fine. I would say. I would say file an issue you could try doing. Oh, this is something that a lot of people actually don't know. So say that you want to run some Cargo command like install cargo outdated and you default to Nightly.
00:49:39.789 - 00:50:00.725, Speaker A: If you want to run With Stable you can just do this. That will tell Rust up to use the Stable version of Cargo for this particular command. So you could try running that and see if that works out. You can boot Redux on a vm. That's true. That's also really neat. Oh yeah, Pac man is fantastic.
00:50:00.725 - 00:50:43.185, Speaker A: I also just love the name. So Pac man is the Arch package manager. I use Aur man now, which is a wrapper around Pac man that also integrates with Aur, which is really nice. It's one of those things where you really should know how the packaging system works and how the AUR works before you start using an AUR package manager. Because there are a lot of risks involved in just like building random code that other people upload. But Aur Mon is pretty good about warning you when things are wrong or when things move, things are signed and you're not trusting the key. I've just been really happy with it.
00:50:43.185 - 00:51:16.749, Speaker A: So Arch is one of those things where you should install it if your goal is to learn Linux. If you just want to run Linux because it's convenient for many other things, Arch is probably not the right choice for you. You should just go, go with Ubuntu and be happy. Or like one of the, like Linux Mint or something like that that's just built to be really user friendly. Arch is great because it forces you to learn Linux. Things like they just drop you into a terminal and you have to install the system yourself. And I think that's fantastic.
00:51:16.749 - 00:51:49.809, Speaker A: But it does require that you're willing to learn. Let's see, where were you? So that was Cargo outdated. The other one is Cargo Tree, which is sort of similar. Similar. It tells you for each, for the current package, all of the dependencies, the dependencies, dependencies, etc. The stars are packages that are listed more than once and you can also like show additional features. It's just a nice way to list all dependencies.
00:51:49.809 - 00:52:27.711, Speaker A: But the crucial feature that I use it for is this inverted. Inverted tree. So you can do Dash I which lists for each dependency, why it's there. So let's go to this large project I have. So here if I run what is the cargo tree? What do I not have cargo tree on this machine? Yeah. So Dash I will take each dependency and list where it comes from. Which is really useful for detecting.
00:52:27.711 - 00:52:55.403, Speaker A: If you have multiple instances of the same dependency but with different versions, you can see why the different versions are installed. Right. It might tell you the. Like you have 0 to 4 because of Postgres and you have 023 because of some outdated version of Serdi. And now you know that you should probably bump one of them. And that could get rid of an entire dependency from your compilation process, which just speeds up dependencies a lot. There's a flag for also only including things through duplicates.
00:52:55.403 - 00:53:31.237, Speaker A: I've been really, really happy with that. This has been fixed on latest nightly. I should run Rust up. How do you get started with Tokyo? So I work on a. So I'm a grad student at mit. I do research on distributed systems and systems in general, and I'm working on a new type of database. And when building this database, one of the things we're doing is we need to do a lot of IO and we need to do it really efficiently.
00:53:31.237 - 00:54:17.953, Speaker A: And we used to have lots of threads spinning around, but it turns out that you really, at some point, you just don't want to spin up that many threads. And so we had a thread pool that we built ourselves that like multiplex connections and used E Poll. But then you get to the point where, like, you want to make sure that you don't accidentally block some part of your execution. And it was sort of natural to move to the world of Async IO, at which point Tokyo is the obvious contender in Rust space. And so it actually started out with me writing what did I call it, my pool, which is sort of us. Basically, it's starting to do Async IO but without using any of the Tokyo stuff. And then at some point we realized we should just use Tokyo.
00:54:17.953 - 00:54:37.867, Speaker A: So I've chatted a lot to Car Lech, the maintainer. Car Lurke. I don't know how to pronounce his name either. Yeah, Carl Lurker. I don't know how to pronounce his name. Anyway, I chatted a lot to him about the fact that we have this large project we want to work on. They've been interested in using that as a benchmark for Tokyo as well.
00:54:37.867 - 00:55:17.145, Speaker A: And so that's just gotten me more and more involved with Tokyo. Because when we've been running this large piece of software using Tokyo, we've also discovered bugs, performance regressions, places where Tokyo adds a bunch of overhead, especially when you get to very large deployments. And so we've started debugging some of those and improving Tokyo from the inside. And once you start getting familiar with sort of the guts of something, it's really easy to then start making changes as we go. Right. And so it's been just a really fruitful relationship between the team working on this new database and the Tokyo team Cargo plus Stable fails with the same. Yeah, that's definitely an issue.
00:55:17.145 - 00:55:45.811, Speaker A: It took me about an hour the first time I installed Arch. Yeah, that sounds about right. Although the installation guide, the beginner's installation guide is actually pretty helpful now. I think the biggest issue it has is there are a bunch of places where it goes now you should install time synchronization. Here are 14 different ways you could do that. Arch really doesn't want to choose which one they're going to recommend, so they just tell you about all of them. And I don't think that's always the right strategy, but I just wrote a very simple proxy server in Tokyo.
00:55:45.811 - 00:56:06.563, Speaker A: Yeah, Tokyo is getting really nice. Tokyo at this point is just. It's just great. It's just great. It's also pretty easy to work with. For those of you who are new to Tokyo or to Futures, I recommend looking at some of the earlier streams. There's a lot of subtlety in dealing with Tokyo, but it.
00:56:06.563 - 00:56:38.789, Speaker A: It does work really nice when it works, especially now that there's support for this experimental support for Async Await. So Carl just released Tokyo Async Await. This one. Where is it there. So this thing, which is a preview of how Async and Await are going to work with Tokyo, it integrates quite nicely. I think that's going to help a lot. If.
00:56:38.789 - 00:57:25.009, Speaker A: If you remember back to our EC2 streams, in the easy two streams, there were a bunch of cases where we move things to be asynchronous and then there were just like nested function upon nested function upon nested functions of and thens Async Await is going to make all that so much nicer. And that's pretty exciting. Let's see. So the thing I wanted to show here was you can do Cargo Tree D, which is duplicate, so it shows only dependencies that are where there are multiple versions and in the inverse. So if I run this, that'll probably take a little while, but we'll let that run. I like how you can just combine everything and compose and stuff. Oh, in Tokyo.
00:57:25.009 - 00:57:48.265, Speaker A: Yeah. So Tokyo's. And I think this is in big part because of Carl is really set up to deal with combinators and that makes it a very modular thing to work with. And that's really nice. Like you can take some futures that come from this library and some futures that come from this library and you can just combine them. That's also because that's how futures were designed. So big props there as well.
00:57:48.265 - 00:58:07.755, Speaker A: Nice videos on arch installations. Oh yeah. I believe it. Before your previous streams. It just takes practice to get it. That's definitely true. I think Futures and Tokyo in particular is one of those things where there are a lot of subtle details in exactly how it's implemented and how it works.
00:58:07.755 - 00:58:47.075, Speaker A: And it takes a little while just to get into the mental model of how futures execute because it's sort of weird, right? Like your program no longer really executes top to bottom. You have to think of them in terms of. There is this event loop somewhere that's like polling all of the futures are running at a given point in time. And I think one of the things, if you want to challenge yourself. Futures unordered. If you want to challenge yourself, you should. I think it's here somewhere.
00:58:47.075 - 00:59:14.905, Speaker A: Let me do some digging. Unordered. This. This combinator is fairly complicated. Although the API it provides is really simple. You give it a bunch of futures and it will pull all of them. And when you pull it, it.
00:59:14.905 - 00:59:55.615, Speaker A: It will tell you that one of them finished. You should read the source code for this particular combinator and it will tell you a lot about how futures are executed, how they're scheduled, and it's pretty neat. There's also a stream version here that I ported a while ago. But I recommend if you want a challenge for yourself in understanding how Tokyo and Futures work, take a look at this one. A good thought or brain exercise. So future 0.2 I think you should basically ignore because 0.1
00:59:55.615 - 01:00:17.179, Speaker A: is the thing that's supported by Tokyo. So it's basically what you'll find everywhere. 02 is backwards compatible, sort of like it forward exports the interfaces and zero point is the one that's going to be integrated with the Rust standard library. And so that's actually the one that everyone will move to. So 0.2 is basically not going to be used. The move to Tokyo 0.1
01:00:17.179 - 01:00:44.385, Speaker A: though is something that had a lot of impact and something that does require a bunch of crates to change. We haven't done anything. Yeah, we've done something on Tokyo 0.1. It's much nicer to work with. I don't think there's any reason to. To deal with the old Tokyo core stuff anymore, especially now that Hyper has moved along. There's a reason for the way the Tokyo is set up as opposed to the event loop of js.
01:00:44.385 - 01:01:33.945, Speaker A: I'm not entirely sure I understand the question. So Java, the JavaScript event loop is a little bit special in that the language doesn't have Threads like everything is implicitly asynchronous and that changes the language. That's a language feature saying that only one thing will execute at once. In Rust, that is not the case. They don't want to change the Rust language. Tokyo is just a library. And that's part of the reason why they have this notion of execution computers and futures, because all of the asynchronous stuff has to be explicitly asynchronous, as opposed to just everything implicitly being asynchronous the way it is in JavaScript.
01:01:33.945 - 01:02:24.195, Speaker A: All right, so here is this place where we ran Cargo Tree D Notice that this project has a lot of dependencies, but crucially here, look at this, for example. So crossbeam DQ, we depend on version 0.2 because of of rayon 102 and then we depend on crossbeamdque 03 because of Tokyo thread pool. And so this means that ideally we'd want Rayon to bump their dependency on CrossBeamdQueue, and that way we'd only need to compile one instance of it rather than two. Similarly, there are a bunch of others for MemCarProc macros and quote, which is for the same reason. And so this is one way that you can look through your projects. Here's the bump from Rand04 to Ran05.
01:02:24.195 - 01:03:18.145, Speaker A: This is a great way to try to prune out unnecessary dependencies from your projects or even just to figure out like if you want to write pull requests for existing projects. One way to do that is if you detect that they're using an old version of a dependency, you could bump that dependencies major version and implement the necessary changes, which are usually fairly few and sort of do the ecosystem a great favor. The way you work with the event loop in JavaScript is through callbacks. That is the case in Tokyo too, right? So in Tokyo or in futures, I should really say in futures you work through futures and on futures you have all these. No, this is 0.2, I don't want that. So here, when you're working with future, you have a bunch of things and in particular you have.
01:03:18.145 - 01:03:51.703, Speaker A: And then, right? So and then is do this thing and then when it resolves, do this other thing, which is basically like a callback, you're saying call this closure when this future resolves. Right? And this is. This is not something that immediately resolves. Like this is a promise, if you will, in JavaScript land, that eventually it will become the value that came out of here. So in that sense they're actually pretty similar. Wish There was a tool that translated code to pleasant music. You can actually interpret while shopping and understand the code.
01:03:51.703 - 01:04:29.949, Speaker A: It's a nice thought. I had that thought a long time ago of trying to write something that takes ASCII text and produces music. It's just really hard to make it sound good. If a crate uses Nightly only features, can you still use that crate on Stable? I believe so. I believe you can compile the tool using Stable and still use it to interpret Nightly packages. Basically what Cargo Tree and Cargo outdated both do is they sort of link with car. So they basically have they integrate with Cargo and use Cargo to extract that information.
01:04:29.949 - 01:05:30.021, Speaker A: And Cargo, of course, can operate on Stable or Nightly packages, so it should work fine. Is there a way to discover unused tables and columns in postgres? What do you mean, unused tables and columns? There are ways you can inspect the entire schema. Like if you do backslash dt, it lists all the tables, for example. But that seems somewhat unrelated to all of this Cargo readme is another really useful extension to Cargo. So I use this for most of my crates, actually. So let's look at Minion, which we wrote a while ago. So if you look at source library, remember how we wrote a bunch of documentation for the crate in the Source Lib and it's really annoying to replicate all of this code in a readme file, right? If I had to rewrite all of that in ReadMe, just.
01:05:30.021 - 01:06:03.765, Speaker A: Just annoying. And it's also error prone. And in particular because often you want some example code like this readme has example code, and I want to make sure that if I change the library, this example's code remains valid. So I really want it to be a doc test. The way you do that is using Cargo readme. So what cargo readme does is you create this readme template file and that has. It basically is markdown, but it has a couple of special keywords like readme, which gets filled in with the parse documentation output of your source crate.
01:06:03.765 - 01:06:45.575, Speaker A: So readme here gets replaced when you run Cargo readme, this readme gets replaced with the markdown parsed version of what's in Source lib. So if I change this code and then run Cargo readme, my readme file will be updated. And this basically guarantees that the code that's here will also always compile because it's run as a doc test, because it's really in Source Lib. So I've been really, really happy with this one. I use cargo readme a lot for basically every project. The one thing that's a little bit sad about it is you have to remember to run this command anytime you change source lib. And that's surprisingly hard to remember, but something that's, that's worth doing.
01:06:45.575 - 01:07:55.993, Speaker A: And the final cargo plugin I've used is Cargo Bench Compare. Now this is something that might change a lot in not too long because the way the use so in Rust you can have on nightly you can write benchmarks directly as unit tests, which is just really handy especially for doing smaller benchmarks. And what CargoBench Compare does is you run CargoBench on the old version of your code. Then you run CargoBench after you make some performance improvement and then you give both of the output files to CargoBench Compare and it gives you a table like this view image of this is the performance of it before the change. This is the performance after the change for each benchmark and here's how much of the results changed. And so it's just a really nice way to side by side compare. How big is the improvement that you measured in terms of your cargo benchmark results? Yeah, it's just a really nice tool for seeing whether changes actually make difference.
01:07:55.993 - 01:08:52.509, Speaker A: So I use this for example for. Yeah, so here for example, this is a an optimized version of doing search for the largest value that is less than a given value in a list. And this is comparing it to searching with binary search and sorted vector and comparing it to a B tree set. And it shows you like for each of these different benchmarks what is the speed up or slow down? This is a handy tool to have in your toolbox. Futures makes more sense to me now new question. What's the difference between then and and then? I mean I can show you, but basically the difference between then and and then is and then is. You can think of this in terms of result as well.
01:08:52.509 - 01:09:30.425, Speaker A: It's very similar. So and then is map but the asynchronous version it is if this thing resolved to okay, then map the OK value into some other future. Then is once this future has resolved, give me the result and I will give you a future. This might be clearer if we look at the signatures. Then so then and then both take a function. They both return something that's a future. But look at the signature of the function.
01:09:30.425 - 01:10:07.257, Speaker A: Then is given a result that is the item or the error of the resolved future. And then just takes an item. So and then is if it resolved correctly, call disclosure as in if it resolved with item instead of error. Then is when it resolved. Give me what it resolved into and both of them return a future that you should then continue processing. So if the thing you got was an error and then would not be called, but then would. There might be an issue with some Cargo tools for Windows.
01:10:07.257 - 01:10:39.035, Speaker A: Cargo Tree also failed to install. Oh, that's interesting, huh? It almost sounds like Cargo doesn't build. No, it's very weird. I don't know what to tell you. All right. I think the last thing I sort of had planned, although there may be other things you're curious about, is this browser window that I have set up. So actually, Firefox Multi Account containers I should also talk about.
01:10:39.035 - 01:11:00.289, Speaker A: The first thing is I'm running Firefox. I'm running Firefox Developer Edition, which is sort of like Firefox Nightly, except it's not quite nightly. It's like a little bit more than beta. It's just weird in between. It's kind of nice. I like it. But normally in Firefox, the tabs are at the top, and I like having my tabs at the bottom.
01:11:00.289 - 01:11:40.077, Speaker A: It doesn't matter too much on this particular setup that I have right now, because I have a normal, like. Like a landscape setup. But at work I have a. I have my monitor standing, so in portrait mode, because it's much nicer when you're reading large pieces of code or some long blog posts or something, which is most of what I spend my time doing. Should I do it here too? But I currently haven't. And then the top of your screen is actually really far up, so you'd be sitting like this all the time to look at your tabs, whereas the bottom is just really easy to look at. And so I wanted to move my tabs to the bottom, but that's something that hasn't been supported since way earlier Firefox versions, before they changed the whole plugin system.
01:11:40.077 - 01:12:30.469, Speaker A: But the cool thing about Firefox is the entire UI can be styled with css. So there's this file called userchromecss in Firefox, this file, it's in your profile directory, and it basically lets you change or apply CSS to the browser Chrome itself. And so what this does is it basically the style file that I wrote, it just reorders the UI so that the entire tab bar ends up at the bottom. Mostly it works pretty well. There's some. Some things that are kind of weird, like menus sometimes still go down, although these are now currently all going up, but sometimes they go down because why not? And then they sort of disappear through the bottom of your screen. And that's a little bit sad.
01:12:30.469 - 01:13:00.271, Speaker A: The same thing. This, the URL thing. Notice how it's supposed. If it's at the top, it sort of falls down naturally from the URL bar here. Here I've had to basically set it to be in the middle of the screen. So if you look here, the pop up autocomplete is set to just like roughly here on the screen to just start there. So if I start typing something, notice it starts up here and then sort of ends somewhere down here depending on how many results there are.
01:13:00.271 - 01:13:35.635, Speaker A: Because you can't. There isn't an easy way to reorder it, to have it flow bottom to top. So that's like one of the things that's a little bit sad about this setup. But apart from that I've been pretty happy with it. It's something that I think I'm one of the few people who wants my tabs on the bottom, but it's kind of neat. The other thing I have, some of you may have noticed this work thing here is using something called Firefox Multi account containers that are fantastic. They were added as a sort of prototype feature that never quite made it into the browser.
01:13:35.635 - 01:14:02.961, Speaker A: But it's now a separate extension. I don't know whether it's really being maintained anymore. It's just really nice. Basically what it does is it gives you multiple browser sessions in a single browser window. So down here I have multiple different tabs or, sorry, multiple different containers. And the different containers have completely segregated local storage caches, like cookies. Everything is just segregated between them.
01:14:02.961 - 01:14:43.527, Speaker A: So for example, I have GitHub opening my work container. But if I were to open like Amazon.com it will open in my shopping container. The reason for this is if something, if like someone hacks Amazon and puts something that steals my cookies or whatever on here, they wouldn't be able to get at my GitHub stuff. Similarly, normally I browse outside of any container, which is also sort of a separate container. So if I go to like Reddit or something or like some site where there's likely to be lots of crap, then if they try to steal my cookies, they also can't get to my GitHub cookies and they can't get to my Amazon cookies. They're all entirely segregated.
01:14:43.527 - 01:15:07.155, Speaker A: So it's a nice way to just like partition your entire like online life so that the. You're compartmentalizing your secrets, right? So I've been really happy with that. Let's see. I think that's all I wanted to cover. Oh, here's another thing I get a bunch of questions for. So my. My terminal.
01:15:07.155 - 01:15:29.605, Speaker A: My terminal setup. So my terminal greeting is kind of funky. So it's not all that fancy. Like it just runs about of bash commands, but people are pretty curious about it. It basically here just runs like uname, uptime hostname. It runs the DF command. So DF will list how much space is available on various disks.
01:15:29.605 - 01:16:15.807, Speaker A: Similarly, it runs IP adder to give me all the IP addresses for the current machine. These are just things that are nice to have at a glance when you open a new terminal because you may or may not find them useful. And then I also just manage my to DOS directly in my. In my fish greeting. And what I've set it up to do is I have sort of like multiple different categories of things in different colors and the lower priority categories are shown randomly less often. So if I open a new terminal, it will always show the things that are red, so they are urgent. It will show the things that are yellow half the time, things that are green a quarter of the time, and things that are like cyan much less often.
01:16:15.807 - 01:16:33.671, Speaker A: So you see, I open a bunch of them, most of the time it's just red. Sometimes it shows more. See if we can get it to show the cyan ones. And this is just because some things matter a lot. There we go. Right? So this shows. This now also shows those.
01:16:33.671 - 01:17:19.201, Speaker A: It's just a nice way to manage your to do list. It's not synchronized anywhere, but it's just really nice if I have. So for this database project, for example, I have a bunch of things I know I need to do and I can just prioritize them here and I'll be reminded of them sort of at appropriate intervals of when I should be thinking about them. So that's worked pretty well. Now of course, we're just set to bogus things. What else is there? I don't think any of this is particularly relevant. Oh, auto jump.
01:17:19.201 - 01:17:45.547, Speaker A: Yeah, auto jump. So for those of you who don't know about auto jump, I only found out about it like a few months ago. Auto jump is fantastic. So auto jump is. It's usually just a command J and it's basically a really efficient CD. So what it does is whenever you CD into a directory, it remembers that you've CD'd into it. And then it gives you fuzzy jump too.
01:17:45.547 - 01:18:13.221, Speaker A: So here now I'm in the root of my project if I want to go to. Remember we went to Minion earlier I can just do J Minion and it will go to the appropriate directory, right? If I. If I CD back, let's say I jump to Tokyo. So it goes to Tokyo Zookeeper. Let's say I actually met the real Tokyo. I'll just jump Tokyo again. And then it goes to some other thing that also completes Tokyo.
01:18:13.221 - 01:18:48.155, Speaker A: And over time it learns what directories you have gone to most frequently when you search for a given thing and it will start to go to that one instead first. There are also some other variations like JC to jump to a child, JO to open and a bunch of these kind of things. But this is just like so efficient. If you're moving around a lot on the command line, it's a great way to move around efficiently. There's so much useful information. I'm glad. Yes, I will.
01:18:48.155 - 01:19:16.045, Speaker A: So I will upload YouTube is a little bit weird because YouTube Live records the video, but then doesn't let you edit it in various weird ways. So I will upload the recording that I have. I think I'm recording. Yeah, I will upload the recording of this to YouTube as well and I'll tweet out the link and everything. So all of this will be online. And then I'll try to categorize. I'll try to in the description, put links to the various points in time where I start discussing different things.
01:19:16.045 - 01:19:47.325, Speaker A: So it should all be online. If you're doing dialogue, Windows and X Monad, they go full screen. Oh yeah. This is one of the reason why tiling window managers are a pain. You basically need this thing. So you need a manage hook and you write it to match on different types of windows and set them to be floating as appropriate. So for example, I think the one that's like most important is you need to set.
01:19:47.325 - 01:20:52.025, Speaker A: Which one is it? Oh, maybe it's. Maybe I don't have a binding for this anymore. Certainly one of the things that's important to use, and this took me a long time to realize, is you need to use desktop config as the base xmonad setup because otherwise events don't work and integration with Polybar doesn't work and Windows spawn in weird places. You need to make sure you do that and then you set set up a manage hook. And I thought I match on dialogues here. Certainly I match on the GTG file chooser because I want that to be full screen. I think the other thing is like make sure that I think desktop window is the one.
01:20:52.025 - 01:22:01.949, Speaker A: In any case, you. You just like find the appropriate thing to Match on and you set it to be float. The way to figure out what a given window is is you use ooh, do I not have it here? Is it X Event? No. Xev X Find Window Information. There's like, I think it's this one. What is the name of it? Inspect Window Information. It's like one of the X tools that lets you click a window and get information about it.
01:22:01.949 - 01:22:58.337, Speaker A: I thought it was Xebe, but maybe it's not X Tools. Well that's sort of unhelpful. I thought it was Xorg Utils. Maybe I'm wrong. Xorg Utils? What? That's really strange. Well, it's one of them, I think it's X win info where you just like run the command and you click a window and it will tell you like so notice here I'm matching on the class name of the window or the resource or one of the string properties. So you would just for the dialogue that you're having problems with, you would just use X win info or whatever.
01:22:58.337 - 01:23:43.165, Speaker A: The thing is, look at the properties for that window, find a thing to match against, put it in the list of rules for your manage hook and set it to be do float and that should resolve your issues. I'm running a Tokyo version of the Beanstalk. Oh yeah, I saw that on. Oh, are you the person who's writing on Discord and I'm following the Tokyo Zookeeper stream. Is there another seem you recommend to have a look at some more background on working with Tokyo? That's a good question. Let's take a look. Let's see what we have.
01:23:43.165 - 01:24:47.701, Speaker A: Rust Live coding. So the Zookeeper ones I think are probably the best ones for working with modern Tokyo stuff. The asynchronous SSH one is like fairly advanced Async in Tokyo stuff, in part because we're working with an existing crate and then trying to wrap things around it, and that crate was written a while ago and hasn't been updated, so that was a bit of a pain. But I think that gives you a very deep dive into Tokyo and Async stuff. Yeah, I would say the Zookeeper ones are the best in part because they also deal with things like parsing network protocols and such, which you'll have to do with Beanstalk. It might be that we want to do a less advanced Tokyo thing, just because I've gotten this question before. So if any of you have ideas for something you'd like to see us build in Tokyo, like some kind of protocol that's less advanced than Zookeeper the.
01:24:47.701 - 01:25:13.525, Speaker A: That we could use as sort of an intro to Futures in Tokyo. Shoot me like a Twitter message or something afterwards. I don't have XProp. XProp is the name of it. Nice. See, this is why it's great to have other people watching. Yeah, Xorg Xprop, that's the one I want.
01:25:13.525 - 01:25:40.693, Speaker A: So xprop you. It gives you a crosshair. You click a window and it gives you information about the window. That's the one I was after. But yeah, if you have ideas for things we should cover in Tokyo or Futures, just like send me something on Twitter to remind me and then I'll try to do that at some point. I have this major conference deadline coming up for. For this conference.
01:25:40.693 - 01:26:14.347, Speaker A: And so when is the next deadline? Program, participate, call for papers. So we have a paper that got accepted, but here. So September 27th. Until then I will be very busy, but I will try to maybe do another stream before then. And it would be really cool to do a more basic Tokyo infusion space stream. What keyboard am I using? I am using the Philco Majesto Touch Ninja. It's really cool.
01:26:14.347 - 01:26:43.785, Speaker A: Use a file manager. Do everything on the command line. I just do everything on the command line. There is one exception to this, which is I have installed a program called Mirage. So Mirage is like I use it just for directories that have a bunch of photos. Then I will open it with Mirage because it gives me previews of the photos, which is the one thing I don't really get in the terminal. But apart from that, I just use the command line for everything.
01:26:43.785 - 01:27:25.035, Speaker A: It's very rare that I actually need to look at the icons for files, in part because Excel is pretty good about this. It highlights different file types and different colors as well. Usually there's no need. What a shame. Oh, is Bang keyboard like a YouTube command? That's weird. How do you come up with an idea for a new tool or project? Sorry, I'm just like working my way through the backlog. Do you come up with an idea for a new tool or project? So usually it's actually based on a need that I have.
01:27:25.035 - 01:28:13.845, Speaker A: So if you have some larger project you're working on, a lot of the time you just like discover that you need to solve the sub problem and you're like, I should just write that as a library. I think this is something more people should do is take small parts of their current projects and make them into libraries that might be useful to other people. So if you look at the various repositories that I Have most of them have come up because I've been using them for something else, right? Like ARC C string, for example, is like a reference count, atomically reference counted string type for C like strings. And I just like needed that in a project. I could have just like implemented directly in my project, but instead I was like, let's release that as a library. And I think that's the way the ecosystem grows. And that also lets you build a lot more interesting things.
01:28:13.845 - 01:28:50.485, Speaker A: And it means that you end up with a list of crates that just like grows very quickly to having lots of things implemented. So that's kind of cool. Sometimes you just look at things that are interesting. Like here I implemented the MySQL binary protocol so you can write a Rust server that looks like it's MySQL and that was more like. That seemed like fun, so I did it. Sometimes I think this is one of the things that easily happens, is you sort of get nerd sniped and it's fantastic. I love when someone presents me with something that's interesting and I just have to do it.
01:28:50.485 - 01:29:19.605, Speaker A: Export for the win. Yeah, indeed. You can get previous with Ranger and fe. I have used FE a bunch. I used Geeky for a while, was pretty, pretty happy with that. But Mirage works pretty well. Where does the Zookeeper crate fit in? So the Zookeeper crate fits in because for one of the things I've been doing for this database is, as I mentioned, we've moved a lot more to Asyncio.
01:29:19.605 - 01:29:56.567, Speaker A: And one of the things that's still synchronous in here is talking to Zookeeper, because we've been using the Rust Zookeeper crate, which is synchronous. But it's sort of weird to have a code base where some things are synchronous and some things are asynchronous. And so I wanted the Zookeeper integration to also move to be asynchronous so it integrates more nicely with the rest of the code base. But there is no asynchronous Zookeeper bindings. And so I had to implement Async Zookeeper. I use a file manager to see PDF thumbnails. I never actually need the thumbnails for a PDF.
01:29:56.567 - 01:30:35.465, Speaker A: I usually just need the name of the file. But for opening one I use Mute PDF, which I've been also really happy with. So do I have a paper here that's useful? Actually, no, I don't have any papers here. These are all pretty uninteresting, but sure. Oops. Oh. Apparently I have not even Set up my PDF binding on this machine.
01:30:35.465 - 01:31:33.665, Speaker A: Well, I definitely did not want to open it in GIP XDGD what's the thing? MIME default New PDF Application PDF. That's weird. What if we have new PDF installed? That's strange. Oh, I'll set this up later, but I guess I can just so Mood PDF is a very straightforward PDF reader, but it has all the things you need. Like it has full screen, you can rotate documents if you need to. There's like fit to width, fit to height, fit to window. Just like a really nice and simple PDF viewer.
01:31:33.665 - 01:32:29.915, Speaker A: Another one here. How do you come up with for the large project itself? So coming up with ideas for large projects, it's like its own kind of issue. This is so I'm doing a PhD, and when you're doing a PhD you sort of need to find a large project, but it's one of those things where you just need to set a lofty goal right of here's something that doesn't exist that I feel like should exist. And then you realize that's a fairly big task and while working on it, the thing you're building just becomes larger and larger and larger to try to tackle that problem. In general, it is much better if the thing you're working on is goal driven, especially if there's some need that you have that you feel is not being satisfied. Then you should build something that addresses a need that you have because you'll be more excited to work on it as well. Interested in too many things.
01:32:29.915 - 01:33:16.457, Speaker A: I start one project, find another one more interesting in swap. Yeah, I do the same thing all the time. This is part of the reason why I have so many repositories at this point. Although I try, I try to maintain all of them, but most of the things I write, I try to write them in such a way that they end up in a usable in like a usable form so that I don't really need to do that much maintenance on this. And most of the things I start, I try to not start things that are large. I try to only start things that are small and only have one or maybe two large things at once because you just don't have enough resources to handle lots of large things, whereas small things you can finish. And then the second thing is make sure you document them well because that way they sort of live on their own.
01:33:16.457 - 01:34:10.685, Speaker A: So every now and again I'll find that there's a pull request for something I wrote a while ago, like for stream cancel. There's another thing I wrote as a library for something I needed in this large crate and I could have just implemented it directly, but instead I chose to publish it. And then suddenly someone submitted a pull request and was like, hey, this panics unnecessarily. I was like, well, okay, great, now that's fixed. And so as long as you make sure to document both your code and the implementation, well, you don't really need to do that much maintenance and it's actually possible to finish. What switch are you using with your keyboard? Well, so that's a good question. I think it always comes with browns, but it could be wrong.
01:34:10.685 - 01:34:54.069, Speaker A: Fairly short browns, but Filco Majesto Touch Ninja 2 switch. For some reason I get a memory management bzhud whenever I use Google Chrome. That seems unfortunate. That seems like something you should fix. But yeah, it's Zathura. What is Zathura? Oh, maybe it's red switches. Actually, I don't know.
01:34:54.069 - 01:35:17.289, Speaker A: I don't know. I haven't looked at it in a while. Zathur GitHub, a document viewer. Oh yeah, I use this a while ago. I don't remember why I stopped using it, but Mood PDF is just really nice. It's very simple. Yeah, there's definitely.
01:35:17.289 - 01:35:45.913, Speaker A: There's a bump. They're not continuous. I really like these. Wish there was a way to monetize personal open source projects. Yeah, I wish there was too. So this is something that is really hard in the open source community is to try to get paid by companies for open source projects. Although what I've heard is that a bunch of people working for companies want to do this.
01:35:45.913 - 01:36:23.097, Speaker A: The problem is they can't do donations on behalf of the company. They have to actually be paying for something in order to get it reimbursed. And so I know that what a lot of people do is they set up or some open source projects do is they set up some like advanced version that doesn't really give you anything meaningful extra. Like it's not something anyone ever would ever want. But it means that companies can buy your open source project and pay for it if they want to give you money. But in general they can't give you money just as donations. I don't know to what extent this is true for companies in general, but I know that there are certainly instances where the company just has to have some excuse to pay you and then it's fine.
01:36:23.097 - 01:36:49.699, Speaker A: You can also do this for support. So for example, this is something I think Mike Perham has done pretty well for. So he's building this New thing called Factory. So Factory is basically a replacement for Sidekick. It's a job management server. I wrote the Rust bindings for this. It's entirely open source, but he wants to write a.
01:36:49.699 - 01:37:13.659, Speaker A: Essentially make a Pro version of A2 that you can buy and everything works in the non pro version. But the pro version has some additional like support and some additional enterprise features. And so that's one good way. But of course that requires so much more work. And now do you want to devote that much effort into your open source projects? It's unclear. The Patreon for me is like it's on. I don't really do it for the money.
01:37:13.659 - 01:37:37.795, Speaker A: It's more. I think it's. I think it's a good way to showcase the work. But I agree it would be really nice if there was some way for companies to like show that they're using something. Oh yeah. I don't know why the key gaps are so important. Where is my thing? I have a thing.
01:37:37.795 - 01:37:54.245, Speaker A: Give me a second. Let's see. Let's answer this question once and for all. Alright. Control key. Come here. They are browns.
01:37:54.245 - 01:38:42.485, Speaker A: It has been answered. They're browns. Do you have a setup for writing papers in neovim? I don't know what you mean about setup, but I write all my papers in vim. I usually write them in Latex and so it's just source code anyway. I do have some things set up for it though. So in particular, where is it? That's not the one I want. Where is it? Where's the ALE setup for? So this is really cool python tool.
01:38:42.485 - 01:39:37.045, Speaker A: It looks like I haven't set it up on this machine, which is a little bit sad. Script? No. Autoload Plug? No. File type? Apparently not. So this is a python tool called Linked. That's unhelpful. What is it called? Proslint I think is the name of it.
01:39:37.045 - 01:40:08.255, Speaker A: So Proslint is really cool. It is a command line utility that also integrates with Ale, for example, to give you grammar suggestions while you type. And then you have that and a spell checker and you get really far. Like you can write paper in latex in Vim without any problems. It depends how visual you are. Like in general I want Latex to deal with all the layout for me and so I don't actually micro optimize too much. But if you need the visuals then of course it's not great for you.
01:40:08.255 - 01:40:56.111, Speaker A: Goyo. What is Goyo? Oh, this is the thing that just like erases everything around it. I don't find that so remember my setup if I'm in vim is this. And so it's already distraction free editing. Like I don't know what more it gives me. Vim text. What is vim tax? I mean, I'm sure there, there are things that like make it easier to manage writing latex files.
01:40:56.111 - 01:41:21.535, Speaker A: I just like haven't really had a problem with it. Like generally if I'm writing in latex, I'm writing text. And so it's not like I'm writing a lot of fancy latex. I'm just writing text and that's basically sufficient. I guess better syntax highlighting might be nice, but I just haven't found it to be that much of a problem. Latex run is really nice. It's actually written by someone who used to be in my lab at mit.
01:41:21.535 - 01:42:04.657, Speaker A: I usually still just end up writing a makefile, but should probably just use the tech run live compilation. I mean maybe. So usually I solve this a different way, which is I have bound capital M to make. So I have a make file that builds my paper and when I want to read the paper I just press shift M and then I just open. I switch to the thing where I have the paper open or I just switch to that window, press R for refresh in and then I have the new paper. So I don't actually want it to live compile. I save my files a lot and I don't want it to be compiling all the time because it's annoying.
01:42:04.657 - 01:42:40.335, Speaker A: So I prefer being able to tell it to compile. Now this is the same way I've set up cargo check in my Rust projects. I don't have it do it automatically on save. Instead I have shift, I have capital L map to run the linter because I don't want it to just do things every time I save in general, like I will save partway through having written a function and so I know it doesn't type check yet and so I want to finish writing the thing before I run the checker. Shorter lines are easier to read. That is definitely true. But that's why you set up text wrapping.
01:42:40.335 - 01:43:30.855, Speaker A: I guess the one thing it gives you is it centers your text like here centered. But I agree with you, like maybe there's a. Maybe there's a reason to add it. In general, what I've done with my vim config so far is I try to only add things I need or that like actually help a lot. In the majority of cases where I use vim, I don't add Things that are like I use once in a blue moon, right? Definitely a matter of taste. Have you experienced that there's way too many mappings in VIM with all these plugins? No, not really. I think most of the most of the keyboard shortcuts I have I've set up myself.
01:43:30.855 - 01:44:39.501, Speaker A: One thing that's nice, that sort of change in the VIM ecosystem, I don't know if it's recently, but it has changed, is that plugins don't generally map things anymore. They give you a bunch of commands and then they tell you how to map them and what mapping they recommend. Recommend. So for the VIM autocomplete stuff, for example, they never actually hijack your tab or enter, but they give you like here are the auto commands you should set up if you want it to work this way. Which just means that like in general I have all the base VIM bindings, so the ones that come with vim and then I have all the ones that I've defined and there are no others. Noob Question with regards to Tokyo, how do you use the connect method on a TCP stream? How can I store the stream object which is resolved in a struct? So you mean Tokyo Net TCP stream. So TCP Stream Connect gives you a future that resolves into a TCP stream.
01:44:39.501 - 01:45:41.655, Speaker A: So if you look at this, it's a future whose item is an actual TCP stream, and that is the thing you'd want to store. You could of course store the future, but then it's not connected yet. So in general you would do connect and then you would either wait on this future to get the TCP stream or you would run it through some kind of runtime and then the resulting TCP stream is what you would store somewhere. Any tips or suggestions on how to get a better grasp on borrowing in Rust? I mean, apart from reading the Rust book? So in general, like I think this chapter is pretty good. If you feel like this is not quite quite enough. It's gotten longer since last time I looked at it. Good.
01:45:41.655 - 01:46:20.715, Speaker A: The learning Rust, with entirely too many linked lists is also pretty good. It doesn't explicitly deal with borrowing, but it does give you some more intuition for how the memory model works. So that might also help. I think the biggest way to go about this is just to write Rust code and you'll develop more of an intuition for it. But in general, this chapter is pretty good and a good place to start. Yeah, you know, the borrow checker is really weird. It does take a while to get Used to.
01:46:20.715 - 01:46:55.571, Speaker A: How can I summarize borrows in the easiest way? So you should think of owned values as a value in memory. Like just think of owned values as just any variable if you borrow that value. So if you borrow a variable, you get a reference. You can borrow things in one of two ways. You can borrow them immutably or mutably. If you borrow them mutably, then you get a mutable reference. If immutably you get an immutable or just a regular reference.
01:46:55.571 - 01:47:57.475, Speaker A: You can only have a single mutable reference at a time. And the compiler, basically the only thing the compiler does or the borrow checker does is it ensures that you cannot have a reference to a variable that is no longer there. So if the variable gets moved somewhere, like it gets returned from a function, it gets passed to a different function without borrowing, or it just gets dropped, or it gets moved into a closure or anything like that, then the variable is moved and so the reference is invalid. So all the borrow checker does is make sure that if you have borrowed something, you sort of give it back or you give it up before you ever give back. Oh, lifetimes. So lifetimes are actually very related. So lifetimes you should think of as if you borrow something, a lifetime is how long that the resulting reference is valid for.
01:47:57.475 - 01:49:05.735, Speaker A: So if you have a lifetime of tick a, so you have some reference with lifetime tick A, what that means is you know that that reference will be valid until till tick A ends. In general, any tick, any tick a, any lifetime is a sequence of lines in your program is probably the easiest way to think about them. So a tick A refers to this lib. This is valid for these lines. If you're generic over a ticket, it means that I accept. So if you have here, let's open file one of these like so, so this is a. Let's make that a little bit larger.
01:49:05.735 - 01:49:40.839, Speaker A: So what this is saying is that. Why is this. No, for some reason the terminal wanted to be unhappy with me. So this struct is generating generic over some lifetime. Take. What that means is if you have a foo, that foo is associated with some sequence of lines in your program. In this case it is the sequence of lines named A.
01:49:40.839 - 01:51:22.879, Speaker A: Or let's see, we make a main. We do create a new scope. Then we do. So let me just set this up and then, okay, so here we create an X which is a string. Here we borrow X and put it inside foo, and the borrow of X starts a new lifetime. Sorry, it starts here, technically starts a new lifetime of A that is we're borrowing X here, and that borrow of X can only be alive for as long as X is alive. If we moved X or X gets dropped, then tick A is immediately terminated, right? So here, if we drop X, that means we're terminating tick A here.
01:51:22.879 - 01:51:50.501, Speaker A: But because foo still lives, right, Foo is still here with a lifetime of tick A. This is illegal. The compiler looks at this and goes, there's a foo with a lifetime of tick A, but tick A has ended, therefore the foo is invalid. It is not legal. And that is why if you try to draw pegs here, the compiler would yell at you. On the other hand, if you drop F first, then at this point there is no longer a foo tick A. So no one is using tick A anymore.
01:51:50.501 - 01:52:34.165, Speaker A: And so dropping X now is fine, because there is no outstanding reference to foobar and therefore tick A can be terminated safely because no one is currently borrowing. That's sort of the most straightforward explanation I can give. Of course, there are a lot more advanced scenarios where you have like multiple lifetimes for a given thing. I think you just need to write more code that uses lifetimes in order to get a handle of it. Just don't be afraid of the lifetimes is the biggest thing I would say. Like, I think a bunch of people end up giving up on lifetimes and just go, I'm just gonna make everything arc or everything arc Mutex or something so I don't have to think about it or clone everywhere. Try to force yourself to figure it out and you will develop the mental model pretty quickly.
01:52:34.165 - 01:53:18.375, Speaker A: The rustbook felt way too wordy, but it really does explain things in the simplest way. Yeah, the Rust book is a little bit weird because the goal is to explain things even to people who aren't programmers, and that means that they have to spend some more time. It's also because one of the reasons it's hard to teach people lifetimes is because they don't fully understand borrows and references. And so the book spends a bunch of time on explaining borrows and references for a good reason. And that is because people don't actually understand how they work. And so they're trying to encourage you to actually read it and understand it, which requires a bunch more words. But then people don't read it because it's too much text, so it's a hard trade off.
01:53:18.375 - 01:53:50.395, Speaker A: Lifetime explication is simpler, more intuitive than the first version book for my taste, sort of. So I think, I think that the first book used fewer words and that helps to some extent. But it depends how comfortable you are with the concept of things like pointers. From the beginning. It's just like lifetimes are sort of weird and they're only going to get weirder with nll. So it's a hard thing to explain. Don't have a good answer for you.
01:53:50.395 - 01:54:35.551, Speaker A: I think it really is one of those things where you just need to write a bunch of Rust code to develop the intuition. And hopefully we're slowly gravitating towards a good resource where people can learn about them, which is probably going to end up being the Rust book. One thing that's neat that they've done about the Rust book recently is if you go to Doc Rlo book, it brings you to this page where they have the first edition, the second edition and the live edition. And the live edition is one that will keep getting updated. And so this is probably the one you want to monitor because here as we find better ways to explain things, this is also where you see that they read the source of the standard library. Oh yes, reading the library. The.
01:54:35.551 - 01:55:23.445, Speaker A: The standard library is fantastic. I think this is something that I have done more for Rust than for any other language. One of the reasons why this is really rewarding is what do we want to look at? I find that I do this a bunch for things like Iterators where like I want to know exactly what let's say cycle does, right? So cycle, if you have an iterator and you call cycle, it just means that it keeps rotating around the iterator. So when it comes to the end, it goes to the beginning again. So cycle. And let's say I want to know how this works internally. The neat thing is you can just where's the source link? Source.
01:55:23.445 - 01:56:06.265, Speaker A: You can just click source and then you actually get to the source file in the standard library. The def finds all of them and I can search for a cycle and then now I can search for, I guess struct cycle. Really? That's interesting. It's from Super. Yeah, this is where it gets annoying. I really wish that the Rust file browser had an up button so you could go to one like so you could actually browse the file and not just look at a single one. But in general, the links from the documentation directly to the source is one really good way to try to explore the standard library.
01:56:06.265 - 01:56:36.853, Speaker A: So for TCP Stream, for example, I do this a bunch too. Where you're looking at what does read to end do. Click source and then you get to the implementation and that's really handy. I think Exploring the standard library is a really, really helpful way to understand how many of these things work. And it's often easier to explore it just directly through the Rust repository. So you go to Source and then lib STD down here, and then here you. It's pretty easy to browse to whatever thing you want to look at.
01:56:36.853 - 01:57:13.975, Speaker A: Like if we go to IO, cursor, whatever, and then you have the implementation, implementation of cursor. All the tests, they're usually pretty well documented too. So following it is not that bad. All right. I think. I think unless there are more questions, that that's as far as we're going to go today. As I mentioned, I want to do some more streams on Tokyo and concurrency, probably on something slightly simpler than Sukeeper because.
01:57:13.975 - 01:58:05.671, Speaker A: Because I think some people fell off just because the protocol is complicated. And I'm worried that some people will think that Tokyo and Futures are more complicated than they really are just because what they saw implemented was itself complicated. Is that something I'd like to rectify? I also have noticed that a bunch of people have watched the linked hash map in Rust video, which is sort of a more introductory level video on implementing a data structure in Rust. And so we might want to do some more of that. So if you have an interesting data structure that you think would be interesting for newcomers to the language to also see, like not something that's a super advanced data structure, but something that is like an interesting thing, like a Mutex, for example, Ideally something that's already in the standard library, so we can compare them. Then let me know on Twitter or Patreon or something and we'll dig into that. I'm hoping I'll get to do another stream in two weeks.
01:58:05.671 - 01:58:36.945, Speaker A: Not entirely sure. It depends a little bit on this upcoming deadline. But yeah, I think we'll. Yeah, vecdqueue is a good idea, actually. What do you mean by Data frame and what do you mean by vect? Oh, as in like vector. We could probably do vector. Vector is a little weird because vector is basically just contiguous memory.
01:58:36.945 - 01:59:01.595, Speaker A: Like it's not so much a data structure as it is a primitive. But we totally could. It would include a bunch of unsafe code because you need to deal with alloc. But maybe that's interesting in and of itself. VEC DQ is a good idea. It's vector. Like basically a ring buffer, I think.
01:59:01.595 - 01:59:24.049, Speaker A: Oh, like pandas. You could probably do Data Frame, although I think Data Frame is actually a fairly large thing. Like it's not a very complicated data structure. There's Just a lot of APIs around it. Pin and Unpin and Async and Await. Yeah, I want to do something on that. I want it to shake out a little bit more.
01:59:24.049 - 01:59:58.785, Speaker A: So there's still a lot of velocity going on there. They've like merged the rfc, but I think it's still. There's still a lot of. Still a lot of motion going on and I think a lot of things may change going up, exactly how the implementation details work. So I wanted to settle a bit more before I deal with it, including the Tokyo bindings. I'd also like to see stabilize a bit more Go style channels and Rust. What do you mean by Go style? So there's crossbeam channel, which is a really good implementation of channels in Rust that also performs really well.
01:59:58.785 - 02:00:37.145, Speaker A: So maybe that's what you mean. I don't have headphones, but happy to watch. Nice. But yeah, that would be so. Channels are a lot more work, but they also have some interesting concurrency questions. All right, well, I'll give it a think and try to see what might be a good fit. I want to find something that is also interesting and understandable for people who are newer to Rust.
02:00:37.145 - 02:01:00.375, Speaker A: All right, I'll give it a think, but thanks for the suggestions, they're all great. Alright, I think that's it for today. Thanks for watching and feel free to reach out on Twitter, on Patreon if you have other ideas for things to do. And I will see you hopefully in two weeks, maybe sooner. Bye everyone. Thanks for joining.
