00:00:01.320 - 00:00:27.545, Speaker A: All right everyone, it looks like we've got some people here already. That's great. This is the first time I'm trying to do this sort of multi stream business. In theory, it seems to be working like I think people on all three channels can both see me, hear me, and I can see your chats and you can see each other's chats. If things start going wonky, then just let me know and I'll try to find some other way of doing things. In case this is the first time you're joining me live. I'm John.
00:00:27.545 - 00:01:28.675, Speaker A: I do a bunch of this sort of open source streams and particularly in Rust, I have a Patreon page and also a Twitter page that might be where you found me. If you want to hear about upcoming streams or discussions about streams I'm considering doing, or even just to find videos I've done in the past, then feel free to follow me on Patreon or on Twitter and you'll get all those announcements. I also have one thing to point out from last time. Stream. So part one of the stream we did Tokyo Zookeeper and we did sort of the async primitives and the future primitives that were needed. And after the stream Someone opened this GitHub issue that I only saw earlier today that pointed out that if you remember, back in our stream, we wrote this sort of wrapper for turning the RAW socket that we have the async read and async write into a sync in a stream so that we could send things back and forth. And it turns out there's actually an official sort of Tokyo crate for this and that's called Tokyo Codec.
00:01:28.675 - 00:02:28.835, Speaker A: And if you read Tokyo Codec, it basically is an adapter to go from a stream of bytes into frame streams implementing sync and stream, which is basically exactly what we ended up implementing ourselves. Now that said, I think it was actually a good idea for us to implement the primitives ourselves just to see how they work, because I think that's more something to learn from. But just so you know this going forward, if you have to implement this yourselves, and also if you want to try something, you could try to implement sort of change over the implementation we wrote, turn it into something that uses Tokyo Codec and I'd be happy to merge it. I might get some time to write this myself, but at least now you know that there exists a less low level way of doing these things. If you have a question, feel free to just ask it and I will try to monitor the chat and answer whenever I Can so Zookeeper. So hopefully most of you have seen part one of the stream. Even if you haven't, though, I think it should be possible to follow along.
00:02:28.835 - 00:03:24.015, Speaker A: So in part one of the stream, we built the core code that's needed to communicate with Zookeeper. So the serialization and deserialization, how do you do that in an asynchronous way? Tokyo Iople. Oh yeah, Tokyo Iople was pretty cool. So this is a small aside, but I wrote a Might as well discuss this here. Why not? I wrote this thing called the Tokyo IO pool, which is basically. So Tokyo is great, right? It lets you do asynchronous thing and have a pool of threads that operate on them. But it has this one limitation currently, that is all of the IO goes through a single thread, so all the futures execute on different threads and there's work stealing and it's very, very fancy and efficient, but all the IO goes through one thread, which means that if you have a program that is syscall bound or it's very I O heavy, you're going to end up seeing that one thread become a bottleneck.
00:03:24.015 - 00:04:02.125, Speaker A: And so Tokyo I O pool is a slightly different setup for Tokyo, where you run many threads that each run their own single threaded Tokyo runtime with their own IO reactor. So the reactor is what Tokyo calls the thing that does syscalls for you, essentially. And it just runs a pool of things, each with their own. And then when you spawn a future onto that pool, the future is sent to one of the threads and then executes on that thread forever more. And this means that you now get to have all the threads do IO in parallel. And so if you have an I O heavy application, you might want to look into this. It still does have some shortcomings, such as there's no work stealing.
00:04:02.125 - 00:04:37.985, Speaker A: There's also. I'm chatting to Carl, the maintainer of Tokyo, to see if we can merge it into upstream Tokyo, which would be really cool. But for now, this is something that may be interesting to look out for. What do I think of the now stable SIMD modules? I haven't had a chance to look much at the now stable SIMD stuff. I know that SIMD is really cool. You can do some really efficient things for it, but it's mostly if you're doing like data analysis or math, machine learning maybe. For the kind of stuff I do, it's likely less relevant.
00:04:37.985 - 00:05:29.525, Speaker A: So my current research project is working on building a new type of database and it's a little unclear how we would optimize that with simd, because we don't do like matrix multiplications or the kind of operations where you very clearly benefit from simd. Rustman, is that me? I'm going to assume that's me. How do you think of Haskell and Monads and also the relationship with Rust? I mean, I think Haskell is an interesting language. I think it can. My limited experience with Haskell has been that it can be tricky to build things that operate with the real world. Like if you're building something that needs to talk to network drivers, or you're implementing, I don't know, things that have to interact with the user. Haskell is really good for things like parsing for compilers to some extent, although Camel has an advantage there too.
00:05:29.525 - 00:06:10.683, Speaker A: It's like Haskell has its niches where it's really cool and it has a really good type system, arguably one that's better than Rust in many ways. But I also like the low level memory control that Rust gives you, and Haskell does not give you that at all. If you need to do performance debugging in Haskell, for example, you have to go through a lot of pain. Monads, I don't know exactly how to compare with Rust because monads are programming concept, they're not so much a language. There's been some discussion about whether you can implement monads in Rust, and I think the consensus is not quite yet, but you can get quite far. All right, let's dive into what we're doing today. So we're looking at Zookeeper and what we built.
00:06:10.683 - 00:06:46.335, Speaker A: As I mentioned last time, we built sort of the core infrastructure for talking to Zookeeper, but we didn't actually implement any of the higher level Zookeeper primitives. If you remember, pull up the code here. So the only thing we implemented on Zookeeper was the Exists method and nothing else. And we tested that it in fact works. The Exist method will talk to the server, ask for a given key, and then we'll be told back whether or not that key exists. And we found that that indeed works correctly and it returns you some statistics about that entry. Of course, there are a lot more things that you might want to do with Zookeeper.
00:06:46.335 - 00:07:14.267, Speaker A: So one of the things we might look want to look at here is the Zookeeper crate that already exists. That is synchronous. But if you look at Zookeeper here, you'll notice that there are a bunch of other methods that we probably want to implement. I think we'll probably start with Create. Create adds a bunch of things like ACLs creation modes and those kind of things. And then once we have created Create then we can test exist easily. Then we'll probably want delete.
00:07:14.267 - 00:07:55.005, Speaker A: And once we have that sort of trifecta then we can now write fully self contained tests which would be really nice. Then once we have those I think we want to move on to the watchers. So Watchers, I recommend that if you haven't already, you take a look at the Zookeepers programming guide. Oh yeah, that's true. So when we get higher kind of type then we have full monads but it'll take a little while before we get that There are a lot of complications with higher kind of types. I recommend that you take a look at the Zookeepers programming guide they have. It's pretty long but also quite readable.
00:07:55.005 - 00:08:46.105, Speaker A: The thing I'm talking about mostly is the Zookeeper watches. So the idea of a watcher is that you can tell Zookeeper, give me the value for this thing and notify me when it changes. So imagine that you try to read who is the current leader in a cluster, for example, and you will be notified, you will be told who the current leader is and you will receive a notification whenever that changes. So imagine that server goes down, for example. This interacts well with things like ephemeral nodes in Zookeeper, which we'll also get into. But so having some general idea of the Zookeeper data model is going to be useful. We're going to start though with just create and delete.
00:08:46.105 - 00:09:40.819, Speaker A: I think that's a reasonable place to start. As always, if you have questions, post them in the chat and I'll try to monitor that on the side with most of these I'm also just doing this on the fly. So if you feel like you see something underway where you're like hey, that's probably wrong, or you feel like you're wondering why I'm doing something in a particular thing you should ask. And then it might be that it turns out that it's a stupid way of doing it and I'll do it differently. So let's do a quick sort of recap of the internals that we have. So if you remember, the way we set things up was that we have this packetizer thing and the packetizer is a future that we spawned onto the pool that just runs forever. And what the packetizer does is it manages all the packets that we send and receive from Zookeeper.
00:09:40.819 - 00:10:37.763, Speaker A: So we open a single connection to Zookeeper and we spawn this packetizer that's always running that has an incoming channel for requests and then responds on that channel with a channel of its own that it will respond with the answer on. So it's a slightly convoluted explanation, but let's look at it here. So the packetizer that we have, let's see, where's my enqueue method? Yeah, so when you create a new packetizer, what it does is it spawns the packetizer and then it returns this enqueuer thing. And an enqueuer is basically just a channel. What is that channel? Well, that channel is one of these. It's a sender of a request. This is a zookeeper request and a channel on which to send the response.
00:10:37.763 - 00:11:38.093, Speaker A: So remember that the zookeeper protocol is sort of asynchronous. You can send a request and then you might receive a response much, much later, and there may be other responses in between. And so this packetizer operates as sort of a multiplexer where it gets lots of requests in, it serializes them, sends them over the wire, and when the responses come back, it sends them, it forwards them back along some response channel. And so the way we can see this being used is in exists, for example, it does enqueue and enqueue down here creates a new one shot channel, sends the request and the sender on that one shot channel to the to the multiplexer, and then gives you back the receive end, which is where the response will eventually be sent. So for exist, what we do is we enqueue an exists request and then what we get back is a future that will resolve to the response. And whenever we get the response we just parse out whatever we want. Distro and WM.
00:11:38.093 - 00:12:42.397, Speaker A: I've answered this, I think in one of the YouTube comments for another video, but very, very briefly, I'm running arch. This is Xmonad, although it's just a tiling window manager, so it's not terribly important. The bar at the bottom is polybar and all my config files are here, so you can go there and look at them. And if you have questions or whatever, you can also post issues here. If you feel like there's something you're wondering, why is there? It's probably just like old garbage that I haven't cleaned up. Yeah, so that's sort of the infrastructure that if you ever want to make any API call, you sort of send a request to the multiplexer, the multiplexer does some serialization, does some other stuff, eventually gets a response, deserializes it and sends it back along a channel which resolves the future that we got back from enqueue and so if we now want to implement, say delete, then we'll give some future. It's a little unclear actually what delete should return here.
00:12:42.397 - 00:13:12.473, Speaker A: It returns nothing. So let's make it return nothing. And error is going to be failure error. Actually here, let's do it returns a bool. So it returns true if the thing was indeed deleted and false if it did not exist. And it's going to look very similar. The reason I do delete first is because deletion is very straightforward version.
00:13:12.473 - 00:14:09.425, Speaker A: I don't know what version does, but I assume we're going to need it. So the reason I do deletion first is because if you look at create, it takes all these other arguments, we're then going to know how to serialize and deserialize. And so I just want to do the easier one first, just to re familiarize ourselves with the setup of this. So we're going to enqueue a proto request delete. And the question then is what goes inside of a delete? Well, so if you remember from last time, what we did last time as well was we sort of salvage, if you will, code from the serialization of Rust Zookeeper. So of the synchronous implementation proto, I think it was so here, if I remember correctly. Yeah, so in the old.
00:14:09.425 - 00:14:37.835, Speaker A: The old Zookeeper crate has a separate struct for every type of request. I've opted to make it an enum. It might be something that I come to regret, but I think for now it's going to be fine. And if we decide to change it, then we decide to change it. Proto request. So we're going to add a new type of request and that is going to be a delete request. Delete.
00:14:37.835 - 00:15:08.775, Speaker A: They do not need to be published. Aha. So that's where the version comes in. Great. And then of course we're going to have to implement serialize into. So this is, if you have one of these requests, how do you turn it into bytes? And so for most of these, the implementation is pretty straightforward. It's going to take a path and a version and it's going to write out.
00:15:08.775 - 00:16:07.881, Speaker A: So here we can also take inspiration from the original implementation here, which says that you write out the path and then you write out the version as an i32 Bigendian. Yeah, so we first have to write the opcode. So this is just a general protocol for Zookeeper that any request we send, we first have to send the code for what request we're making. So in this case that will be a delete. We'll then write out the path and then we'll write the i32 as a big endian write i32 bigendian version. So path write to works because we've implemented this write to trait, which is basically how do you serialize one of these? And we implemented it for strings. And basically the encoding is as, this is very common in binary protocols.
00:16:07.881 - 00:16:48.895, Speaker A: You print out the length of the string and then you just write out the bytes of the string. And so that's the same thing we're going to do. And that's how to serialize a delete. Of course, one difference here, that's a good question. So if you remember from here, delete in the original zookeeper takes an option I32. It's a good question, why does it take an option if the protocol dictates an i32 unwrap or minus one? Ah, so the version is. Oh, interesting.
00:16:48.895 - 00:17:15.865, Speaker A: Yeah. So this is where we're going to want structured return types. So notice that if you call delete, there are multiple possible error situations. It's the thing you tried to delete does not exist. Or the thing that you tried to delete has a. Does not have the version that you passed in. Or if you look here, if the node has children.
00:17:15.865 - 00:18:14.465, Speaker A: So in Zookeeper, all nodes can have data and can have children, and you're not allowed to delete node that has children. And so here, if it has children, it will return this not empty business. And so this suggests to me that we actually need a structured return type for delete, which is a little awkward, but I guess we can do it. So error RS use failure. So what we're going to do here is we're going to return not just a failure error, but a, let's see, mod error. And then I guess pub use error or no, just pubmoderror. And this is going to return not a failure error, but a error delete and a deletion error.
00:18:14.465 - 00:18:52.231, Speaker A: So here, if you remember, we're using the failure crate for writing out errors and the failure create has this. Really convenient. Where's my homepage? Here we go. So the idea is that you can derive fail for an enum and then it implements various traits that are required to use it as an error. And then we can do this. So we use fail to implement display for each of them. In our case, we have no node which contains no information, if I remember correctly.
00:18:52.231 - 00:20:00.243, Speaker A: So this is what should we call it? Target Target node does not exist. We could also return bad version and my. I assume that it will tell us what version it is. It Might not, but BadVersion i32 display target node has different version has than expected. And so here I guess we can be even more helpful and say expected is I32 and got as I32. And then the really neat thing with failure is that you can also use syntax here to write out fields from the struct in its display. The failure code is just really convenient for creating these errors that are then nice to work with.
00:20:00.243 - 00:20:31.555, Speaker A: No, no display text Target node does not exist. Thank you. Thank you. Yeah, so in our case, what we want to do is we want to say different version than expected and then we want to use got and expected like so. And it can also return what was the other one we saw like has children. Yeah, so that is not empty. It's nice here to use the same same.
00:20:31.555 - 00:21:28.995, Speaker A: The same error types zookeeper has. So I'm trying to see if we Apache zookeeper error. So this is. We're now looking for the original Zookeeper source and if I remember correctly, there's a list of all the error types. Main Apache zookeeper util maybe no client no zoo defs. Okay, so that has all the opcodes permissions, IDs. ZooKeeper Java assume not.
00:21:28.995 - 00:22:22.607, Speaker A: Where does it import errors from? Op result maybe or proto aw, no op results. I specifically want to find the definitions of all the errors because I want to use the same name for the errors as is used in the Java types. Because when you have these kind of cross language implementations where all the libraries are implemented differently, it's really nice if there's at least some similarity between them. So that if you search for an error that occurs in one language, you can sort of apply it to a different language as well. And that's sort of what I want to see here. Zookeeper. It's unhelpful.
00:22:22.607 - 00:23:11.555, Speaker A: Let's search for node. Well, it seems like a promising search. The question is, wait, where is it defined really? I guess bad version. Maybe there's a keeper exception. That could be it. Yeah, so I have that. Where did we put that proto error? Yeah, I'm just trying to find where I got this from.
00:23:11.555 - 00:23:36.689, Speaker A: Don't actually remember. I think I see the. I have this, but I think I copied this from the Rust implementation and I just want to confirm that that is indeed what they're called in here. No node exception. Yeah, that. That is in fact what they're called upstream as well. I assume that the same, but yeah, exactly.
00:23:36.689 - 00:24:00.987, Speaker A: So this is where all the zookeeper things are raised and so no node. That seems right. And this is just called bad version. So the question is, where is bad version? Bad version exception. Great. Okay, so the it's just called straightforwardly and it's also not see code bad version. That's interesting.
00:24:00.987 - 00:24:24.757, Speaker A: So there's a code somewhere here, maybe mapper. Yeah. So it seems like these are the kind of responses that can be given. Exactly. So keeper exceptions happen internally in zookeeper, whereas these are the status codes that the zookeeper server can give back. So here we see no node which gives not found. Bad version.
00:24:24.757 - 00:24:48.225, Speaker A: Yeah, perfect. Okay, so it is indeed bad version. And then I assume this is called not empty. Yeah. Okay, perfect. So for not empty here we say target node has children and cannot be deleted. Now some of you may wonder like why don't I just make this have the error be.
00:24:48.225 - 00:25:32.365, Speaker A: What was it? Proto error zkerror. So zkerror is this whole list of all the possible zookeeper exceptions. The reason I don't want to do that is because this list has more errors than you should expect if you do a delete. Right. So if you do a delete, you shouldn't expect to get invalid ACL and you shouldn't have to check for it. We sort of want to be able to take advantage of match and so there are a couple of ways we could do this. We could either say that the item is a result bool this sorry, this delete.
00:25:32.365 - 00:26:07.495, Speaker A: And then the error is that there's a protocol error. So if you can think of this as either there's a protocol error or you get an OK or a zookeeper result. So it's sort of like a nested error case. I think what we're going to do instead is to let this be error, error, delete and then the caller would have to match on it. In our case, if we look back at error, not empty does not take any parameters. But there's also one more here which is like protocol error. Right.
00:26:07.495 - 00:26:46.235, Speaker A: And here failure has this really neat thing called cause. Where is the cause documentation somewhere deriving fail deriving display strings tuples in a. Where is. Here we go. Cause. Yeah, this thing. So you can also do this and then say that deeper down there's a failure error and then you can mark it with a cause.
00:26:46.235 - 00:27:27.125, Speaker A: Now I don't really want this in theory, I don't want this to be failure error. I want this to be whatever the enqueue gives back. So let's look at Our proto mod, where is the enqueue that gives a failure error? Why does it give a failure error? What do we get back on the send? We get a ZK error. Right? So, hmm, yeah. So we could make this return a zkerror. So when you accuse enqueue something. No, no, no, the item.
00:27:27.125 - 00:28:01.865, Speaker A: Oh I see. So here we did the double layered error case of what you get back when the enqueue succeeds is either an okay or ZK error. Okay, so that does actually capture this. So maybe we should just continue using that then. So this would return a result. This error is failure. Right, so the explanation here is because enqueue already gives us this kind of wrapping, we might as well continue it.
00:28:01.865 - 00:29:04.183, Speaker A: And so here the way to think about this is we're going to take and then actually we'll take a. Yeah, we'll take an and then so this is going to be what we get back from enqueue. So if you remember here, enqueue gives you back a result, respond a result if it resolves correctly or an error if there was a protocol error. So in our case the protocol error will already be propagated and then we're saying when we get this result back, what we really want to do is match on R because R can either be proto response exists sorry delete which, whatever. We don't actually know what's in a delete response yet. We'll have to deal with that. Or it could be an error zkerror no node and if we get one of these, what we want to return is an okay and then error delete no note.
00:29:04.183 - 00:30:25.095, Speaker A: Right, so notice here, sorry, error. Well, it's an OK error. This is going to end up returning an OK OK and then whatever value we end up putting in here, not empty is going to be transferred to a not empty and bad version is going to end up being converted into a bad version. Right, so what we're really doing here is we're converting the things that we know we could get back from delete and turning them into something the user can match on. And then we see if we get any other error then we want to just return it as a. As a failure of the protocol because it's not a response that we expected. What about using bit flags for errors? What were you thinking about using? How would you use bit flags for errors in this case? So remember that the error codes are dictated by zookeeper already and we want an enum of the error because it might also contain data in this particular case it doesn't because it looks like bad version does not come with data, although we could imagine that it did in fact.
00:30:25.095 - 00:30:43.245, Speaker A: So I think we're out. It's too bad. Bad. Let's keep this around just in case. There's a way for us to get the versions eventually. I guess at the very least we can include expected. That's not how expected is spelled.
00:30:43.245 - 00:31:28.631, Speaker A: So we expected I32 and we at least can print what we expected, but we may not know what the code of it actually is. Yeah, and so what we're saying here is if we get an okay, everything is fine. If we. If we get a no node, then we propagate that as a. There wasn't a protocol error, but there was an error to your request. Similarly, for not empty and bad version and any other kind of error that we got from Zookeeper, we turn into a protocol error. Missing fields, path and version.
00:31:28.631 - 00:31:52.695, Speaker A: Right. So we need to give it path is going to be path, I guess, to own. And I think in this case here we're taking a string. We could be nicer here and say we take any type that can be turned into a string. I think this is fine for now. We can call this tostring. Hello.
00:31:52.695 - 00:32:36.101, Speaker A: And then for version, remember from the Zookeeper crate, it says where is that code here they're unwrapping it or turning it to minus one. So my guess is that minus one is some kind of special value. It looks like the response is actually empty to it delete. So that's going to be useful to know too. So here in fact, no node you won't get known. Well, so here we also need to decide whether we want. If you try to delete something that's not there, is it an error? That's a very good question.
00:32:36.101 - 00:33:16.395, Speaker A: So this will be an empty response because there is no delete doesn't have any content. And so basically what we're deciding is whether we want this to be this. So this is a totally valid way to expose delete, but this is also a valid way to expose delete. Right. Do we want. Do we want trying to delete something that's not there to be an error or to just return false? I think we might want it to be an error just for consistency. Yeah, let's do that.
00:33:16.395 - 00:33:37.929, Speaker A: Okay. So in that case, the result you get back as an item resolves into nothing. So if we get a. If we don't get any kind of error, then we succeeded. If we get no node not empty or bad version, we did not succeed. Yeah, I think that Makes sense. Now, let's see.
00:33:37.929 - 00:34:08.225, Speaker A: So version is going to be version dot, unwrap or minus one. My guess is that minus one is a special value that indicates you don't care what version it is. In fact, this is one of the things that bothers me a little about Zookeeper is that the protocol is extremely poorly documented. Let's see if we can find the docs for the Java implementation API. Docs. Oh, I hate these kind of docs. Zookeeper client.
00:34:08.225 - 00:34:33.555, Speaker A: No Zookeeper. Zookeeper methods. Delete. Aha. Yeah. So they've opted to make no node B an error, which is basically the same thing. If the given version is minus 1, it matches any node's versions.
00:34:33.555 - 00:35:04.684, Speaker A: Okay. Actually we should probably. At some point, what we should do is take all the documentation that's from here and stick it into our library to make sure that we sort of expose the fact that. Or expose any of these kind of things. Right. Like the Java API is documented to say what happens when you do various things. But let's not deal with that for now.
00:35:04.684 - 00:35:23.603, Speaker A: Why is it complaining? That's the real question. All right, so we're going to. The things we're going to have to do is we already said how to serialize delete. We're going to know how to. Going to have to know how to deserialize an empty response. So the response to delete is just you didn't get an error. Right.
00:35:23.603 - 00:36:10.605, Speaker A: So in our case, and my guess is this will, there will be other Zookeeper commands that also have the similar kind of mechanic where you just get an empty response back if there wasn't error. So here empty. And do we have any of these? Right. So if you get a delete and you get an OK response empty. So this is saying if you sent a. Let's see. Yeah, if you sent a delete, then the response we parse out is we just don't parse anything more.
00:36:10.605 - 00:36:45.959, Speaker A: One question here is whether we'll still get errors. I think so. So let's remind ourselves what we actually do in the packetizer when we pull read, we read some stuff in. Oh, that should probably go away. We read some stuff from the underlying thing. We read the length here. We look at the first thing, right? So we look at.
00:36:45.959 - 00:37:29.885, Speaker A: Oh, that's right. We read out the header from the. So if you were. If you recall from the last stream, the response we get from Zookeeper includes this, like, header that contains the ID of the request that's being responded to the Zookeeper version id, which, which we'll come back to a lot later the error code, if any, and then followed by the body of the response. And so really all we're doing here is we're checking what the error code is and then there will be no bytes left. So here, when we decode the response to a delete, we know that there are no more bytes to read, and so we know that the response is empty. In theory we could do something like assert that the response is empty, but let's just not do that for now.
00:37:29.885 - 00:37:53.781, Speaker A: Also, let's. I guess we can keep these eprints in. They might come in handy. We probably have some bugs still. Why? So what are you building right now? A Zookeeper client in Rust? Yes. So I'm building an asynchronous Zookeeper client in Rust. So I recommend that you watch if you're interested in sort of the asynchronous parts of.
00:37:53.781 - 00:38:31.051, Speaker A: I recommend that you watch part one. So part one was very focused on the low level primitives, and now we're building an asynchronous API on top of that to match the features that Zookeeper has. But part one was a lot more async oriented. So it depends whether you're more interested in Zookeeper or more interested in Async. Although this part will also be a lot about Async. Why should deleting what doesn't exist be an error at all? So it depends a little bit on your application. If you expected that thing to be there so you could delete it, you really want to know that your deletion failed, because that's actually a bug in your programming logic somewhere, right? But you're totally right.
00:38:31.051 - 00:39:06.779, Speaker A: There could be some cases where you delete something just to make sure it's not there, in which case you don't care about the result. But it's important that we provide some mechanism to figure out whether or not your deletion succeeded, because some applications care and some do not. The ones that don't care should just ignore the error if one occurs. Right? And now we give them sort of a complete mechanism for determining this. You do the delete. If it results in a protocol error, then your connection might have gone away, in which case you'll have to do something. If you get an ok, then you know that you deleted it.
00:39:06.779 - 00:40:05.007, Speaker A: And if you get an error, you can choose what to do in response to that. Like, for example, you might ignore if there's no node, but if it's not empty or bad version, then in all of these cases the node was not deleted and that might be information that's useful to the to the programmer. Let's see, what is it complaining about? Type mismatch. Right, See that's a little frustrating. I think we are going to have to use then here. So and then is take the successful response and turn it into a future. Actually no, and then should be fine, turn it into a future whose OK value is whatever you want and whose error value matches the previous error.
00:40:05.007 - 00:40:55.075, Speaker A: So this means that if what came in here was an error E of some type E then and then has to return something where the error is where the error type of the future is E. And what the compiler is complaining about here is the E that we get back here. So the error we get back from enqueue is a ZK error. So E here is of type proto error zkerror but the E that we return has to be of type failure error and so that's what the compiler is complaining about and it's totally right. There are a couple of ways we could do this. What do we do here right in exists we just bail. Which is probably what we can do here too, to be honest.
00:40:55.075 - 00:41:38.351, Speaker A: Although might as well be format error. I don't know why we made it fail, because in this case we just want to propagate back the error. So we want to say delete call failed with the error. Now again here we could do slightly better by using context and sort of wrapping up a failure. And this is probably what we'll end up doing later. To make this API nicer in a sense is to take the errors as they occur on lower levels of the stack and keep wrapping them in more context. So that at the time you get up here and there was a protocol error, you can actually figure out exactly where that error came from.
00:41:38.351 - 00:42:21.687, Speaker A: But for now let's just use format error, which is expressive enough for what we need. Bad version, right? So bad version. We also wanted to include expected which is going to be version. So here let's do version is version unwrap or minus one. That way that type is now copy and we can move the type into here match arms. All right, this has to be an error request line 117. Oh right.
00:42:21.687 - 00:43:08.343, Speaker A: The OP code of a delete request is opcode delete. This is why pattern matching is fantastic, because it told me I forgot to implement that and then 81 it's saying the other patterns are not. Oh yeah. So this is the. This is one of the things that's a little bit annoying with our current API and that is the. Because the response is an enum, we have to be prepared here to handle any other kind of response type. And this is probably going to end up being really annoying.
00:43:08.343 - 00:43:58.623, Speaker A: Like we know that there's just no way you can get back like a exist response to a delete. It certainly should never happen. So I mean we could do this non empty response to delete. Ideally we would want to fix this, but it's actually a little bit tricky because we could give like a T to N Q. But keep in mind that the. Where's the here the sender that the cure has is just send a request, right? This is not generic over T and sort of can't be because you would need one channel for every type of request, which is not what we want to do. And so it would mean the enqueuer would have to like take a T where T is something like into request and then it would res.
00:43:58.623 - 00:44:31.405, Speaker A: The result would be something like T. I guess it would also be generic over R where R is the response type and this is an R. And now the problem is what you get back on the channel, of course is also not generic, it's an enum. And so it basically would mean that the matching gets moved into enqueue. Because this would have to take your request, wrap it in an enum and then unwrap it in the response. Though maybe that is what we want. It's just a little bit sad.
00:44:31.405 - 00:45:14.505, Speaker A: Hmm. Basically the question we're making is do we want to keep tagging things as unreachable in the callers to enqueue, or do we want to wrap up the logic of enum wrapping and unwrapping inside of nq. And I'm not actually sure which is better what double dots means where. Oh, if you're. This you're talking about somewhere up here, right. I don't think I have a double dot here anywhere. But I think what you were talking about is if you do something like response delete this, the double dot, that's the there.
00:45:14.505 - 00:45:39.081, Speaker A: This means match. If match this. If it is this variant, ignore all the fields. Similarly, you could for example, bind only one field and not the others. Dot dot is like ignore the other ones. You can think of it as underscore but for more than one field. All right.
00:45:39.081 - 00:46:11.575, Speaker A: So in theory, I think that should mean that we have delete. So this is. I don't know if you remember, but at the end of the. Of the last. The last stream we talked about how now that we have the infrastructure in Place in theory, adding all these additional APIs on top should be very straightforward because we have a very nice mechanism for sending requests and getting responses. And if you look at our implementation of Delete here, there's very little there that is not related to delete. And so we've managed to sort of encapsulate the protocol quite nicely.
00:46:11.575 - 00:47:19.875, Speaker A: And so of course, the way we're going to test this is that we will have something here like we're going to connect, then we're going to exist and then ignore the response and do. No, actually this gives us. What is that right? Then we want a zk.delete foo with none and then delete and then exist again. Oh yes. And then underscore actually here, this is just empty. So this will just be deleted.
00:47:19.875 - 00:47:59.735, Speaker A: And then here we're going to do ZK exists. So this is basically currently, this isn't even really a test. All it's doing is it's doing exists, then deleting, then doing exists again. So let's start Zookeeper and now let's do Cargo T. So this is more for our own sanity to see that the basics of this at least works. Oh yeah. So this is one of the things that's a little bit annoying with futurists is like threading along zk.
00:47:59.735 - 00:48:45.245, Speaker A: So we have a couple of options here, because remember, Zookeeper up here, in theory at least, is clone. We could make more of the Zookeeper thing. And so we could totally allow you to do something like let ZK is ZK clone or ZK like one and then we could move ZK one into here and then we could also make a ZK two and then we could move and then ZK two into here. So this would totally work, at least in theory. Direct Home and Cure is already clone. Right. So it doesn't complain about this.
00:48:45.245 - 00:49:45.609, Speaker A: And so that's all totally fine. This is a little bit annoying though, of course, because you have to clone it for each thing you're going to need. The way many libraries get around this is that you have all of your futures resolved to the instance that you were using followed by the response. Right? So this would be the stat would be the second thing and the zookeeper would be the first or vice versa. So you can see this a lot in things like futures. If you look at futures sync, NPSC sender, sender, so that sync is not sync where this is done this. Yeah.
00:49:45.609 - 00:50:21.915, Speaker A: So if you have a sync, so any kind of channel, for example, it gives you back a future called Ascend and if you look at send, its item is S, which is the sync. So if you do some channel dot send foo, then when that send resolves, it gives you back the channel again so that you can send more stuff. And that's basically the thing we could do here. Of course it means that you have to keep matching over. I think we'll still want to do this. I don't have a better pattern for it, which is a little sad here. We don't care about either here.
00:50:21.915 - 00:50:57.485, Speaker A: We want to get the ZK back and now this cloning can go away and we don't need to move. Does this make sense? So maybe it'll be easier to show it up here. So what we're basically saying is that the item that you get back is always going to be a self. And one of these. Now we could of course make it consume self, but there's no good reason. Similarly, down here, the item you get back is going to be a self. And that.
00:50:57.485 - 00:51:18.495, Speaker A: And so now what we're going to do here is.in theory, you should also then return with the error, which gets annoying. But I think we're just going to map. Maybe I have to clone in here. I don't want to do that. Actually, I take it back. Keep it the way it was.
00:51:18.495 - 00:52:00.397, Speaker A: So we still want Zookeeper to be clonable. It's a little unclear actually, which API we think is nicer. This cloning is really annoying. The reason I don't want to do it the other way is otherwise if you call exist, we would have to clone self regardless, so that we could give it back. Because we get self by reference and then we have to give it back at the end. The alternative of course would be to say that exist consumes self and returns self when the future resolves. But now, like if there's an error, then that gets sad.
00:52:00.397 - 00:52:37.207, Speaker A: Although errors are protocol errors. So maybe it's okay. That's a good question. I think like the most future like way is to do this because it's what channels do, but it is a little sad. Dot map, move bar self. Right? So basically that's all we're changing into. Like so and now down here we don't need the clones.
00:52:37.207 - 00:53:18.405, Speaker A: ZK is consumed by calling exists and is then passed back when it resolves. This ignores all its arguments. This gets the zk, this uses ZK and. And this looks at the stat we get back. And now of course. Wait, what is that drop map zk. Nothing to zk.
00:53:18.405 - 00:54:02.913, Speaker A: What I mean is deleting a Non existent entry is basically no op success. On the other hand, checking existence by deletion is kind of awkward code path. So this is why we were discussing whether it could be that we should have this return Sorry, return a bool and then have no node not be an error, but just return false. We do. There does have to be a way for you to check whether the delete succeeded or not. So it has to be one or the other. We couldn't just silently treat the case of node because there are applications where if there wasn't a file there before but you expected there to be, that's an application error and you want to handle that.
00:54:02.913 - 00:54:31.195, Speaker A: So we do need to expose it in some way. The question is what is the best way to expose it? I suspect that in general, if you try to delete something, you're expecting it to exist, but I am not sure. Therefore, given that I don't have a strong preference, I would like to keep it the same way. The Java API is just for consistency. For people who are familiar with both, that might not make sense, but it's my inclination. I don't think it particularly matters. The implementation is pretty trivial to change one way or the other.
00:54:31.195 - 00:55:16.835, Speaker A: One thing you could look at is so think of file APIs. So if you look at file in the standard library, we could try to be consistent with that. And if you call file, where's the. Oh, I guess it's just an fs probably remove file. Yeah, so remove file returns a result where the success is nothing and return an error. If that's unhelpful, it doesn't actually say source unlink. Okay, so just calls unlink.
00:55:16.835 - 00:55:51.781, Speaker A: That's unhelpful. Let's do remove dir. It's a little surprising that this is not. Oh yeah, here. So if you look at remove dir removes an existing empty directory. So the implication of remove is that the thing has to exist and then this return type sort of tells us that if it does not exist, you're going to get an IO error. And in particular, if you look at it, IO error has this thing where is error kind error kind called not found, which is basically the same thing as what we're seeing in Zookeeper.
00:55:51.781 - 00:56:23.143, Speaker A: If you try to delete something that's not there, you get a not found exception or error. And so I think we want to preserve that similar semantics. Okay, so our test succeeded, although it's not particularly helpful. Let's zkly and then this is just connecting to my local zookeeper. I'm trying to what Is it create foo. Create foo data. Great.
00:56:23.143 - 00:56:41.765, Speaker A: So now we created a node foo. It contains the data. Data. And now if we run Cargo T. Oh, did I do something weird? Oh, right. I was just doing that demo. If we now know run Cargo T, what we should see is that the first exist call should get that there's a file there.
00:56:41.765 - 00:57:12.015, Speaker A: Then the delete should succeed. And then we should get the second exist call Return does not exist. So let's see, reading through all this, we got the connection, so that's fine. Then we get the request exists, we get some response, and so exists returns sum and a stat which contains the information about the file. Now exist doesn't actually give you the contents of the file, but it does say over here data length 4, which is the length of data. Indeed. And then we do the delete request.
00:57:12.015 - 00:57:44.013, Speaker A: It handles a response. We see the deleted message, which is what we print when a delete succeeds right down here. Then we just print out deleted, which is indeed what happens here. We print out deleted, then we get the exists and the response to exists is none. Perfect. So this means that both the original exists and the deletion and the second exists work correctly. So we now have almost all we need to have a self contained test.
00:57:44.013 - 00:58:15.143, Speaker A: The only problem is I currently still have to run this create food data myself to set up the node. And so let's go ahead and implement create as well. We already have a structured error type here, actually in the sense of option, because for exist, the only thing you can get back is either the node exists or it does not. Anything else is a protocol error. So we now want create. Create is also going to take a self. It's going to take a path.
00:58:15.143 - 00:59:01.195, Speaker A: And we know from looking at the existing implementation that there's also going to be some other arguments, but let's ignore those for now. It's going to return self and then something here that we don't quite know what is yet. And it can also produce protocol errors like so. And we already know that the setup is going to be very similar to delete and all the other, all the other things that we've seen. And so create here, start there. Actually, let me check something. When we send out a packet, what do we do? Oh, that's not fine, sorry, I'll get back to what that was later.
00:59:01.195 - 00:59:45.915, Speaker A: All right, so now let's look at what create does. So it's probably going to be somewhere here. Create, Create, Create Create this thing. And let's see also what the Rust version does. So the Rust version Of create here takes a path. It also takes a bunch of other things, right? So because we're creating something, we obviously also need to give some data, that data. Oh, that's a good question.
00:59:45.915 - 01:00:40.655, Speaker A: It's going to have to be owned because we're going to have to. It's going to have to be static, so we'll have to send it somewhere. So there are a couple of ways we could do this. I'm a little bit tempted to make this a COW static. So imagine that you wanted to do something like ZK create and you want to create foo and then you want to create it with some static string like hello world, this has type static ua, right? And it's totally fine for you to pass that as the argument. However, if we here take a vacuate like so then now if you wanted to call it with a static string, you would have to do this. You would have to do something like vec from this or something which ends up copying all the bytes.
01:00:40.655 - 01:01:50.379, Speaker A: It would be nice if both. Like if we take the alternative of having a vec, it would be nice if these top two both just worked out of the box and it turns out there's actually a way you can do this. And the way is to take a D where D implements into cow static U8. So a cow is a copy on write data structure that holds either owned data or a reference to that data that can be turned into an owned one. So in this case, what we're saying is either give me something that holds a static reference to a list of U8s or give me whatever that can be turned into an owned version as. And in this case there's the rust cow. So cow operates on the to owned trait.
01:01:50.379 - 01:02:52.235, Speaker A: So if you look at to owned, you see that there's an implementation of two owned for slices and that gives you a vec. And so in our case, VEC implements this because you can just make an owned cow directly here you would just have an owned vecuate and static strings, sorry, static byte strings would also implement into cow because of where is it here? Any T that can be implemented as ASREF implements into cow. So in this case this would just be turned into a cow borrowed with a static lifetime slice to a ua. So both of these are fine. So this data is going to be anything that takes a D. What am I, what is it complaining about? Why am I. I have a syntax error somewhere.
01:02:52.235 - 01:03:29.967, Speaker A: Where's my syntax error? Ample future where. There we go. And of course these have to go away. Perfect and we're gonna have to use cow use. I think it's in Borrow California. We ACL we're going to need and mode we're going to need. But for now let's just say that we're going to make a create request.
01:03:29.967 - 01:04:10.045, Speaker A: It's going to take a path. We could do a similar thing with strings and say that we want anything that implements COW string. Actually, come to think of it, that might be what we want to do. It depends how much we want to cater to static things. Because you could totally imagine that static things are not usually that long and so therefore it probably doesn't matter copying them. The reason I did it for data and not for path is because a path is just like not going to be long. But you could in theory imagine that someone like does include string or something to include all the contents of a file and tries to write that into a node and that we don't really want to copy.
01:04:10.045 - 01:04:41.693, Speaker A: This is definitely mostly a performance optimization, although it does also make the API a little bit nicer because as you saw, it means you don't have to explicitly do this vec from business. So we may want to do it for paths at some point too. We're going to have to use cal. That's true. It's pretty funny. Okay, so our creation is going to take a path, it's going to take a data, where that's going to be a data, just going to take data. It's also going to take this ACL and mode.
01:04:41.693 - 01:05:18.645, Speaker A: And if we go back and look at them, where is this? So we're going to need ACL and mode. So an ACL just has a bunch of permissions. Create mode is just how do we want this node to work? So here we need to know a little bit about the zookeeper node types. So a persistent node that's created if the client goes away, that node still is there, so it's not deleted when the client goes away. As opposed to an ephemeral one. An ephemeral node, when you create it goes away. Persistent sequential and ephemeral sequential are sort of like the two above.
01:05:18.645 - 01:06:06.745, Speaker A: A sequential node has a sequential number appended to it automatically by zookeeper. So the name, if you create like foo and you create it with either of these sequences, sequential nodes, it would be created as foo1 and then if someone else tried to create a foo, it would be created as foo2 and then etc. And the reason you want this is to implement things like queues container. I don't actually know what is. Oh, interesting, huh? Well, I mean, I guess we might as well implement all of these. There's a question of whether we want these to be different enum types. Or you could imagine persistent having a boolean inside it, or a field called sequential.
01:06:06.745 - 01:06:39.063, Speaker A: Or you could imagine that you had sequential be A container doesn't apply. I think we're just going to stick with the same thing that is done for Create mode. And so here, create. Ooh, really? Source. Give me the source. Right, right, right. So create mode here there's a proto.
01:06:39.063 - 01:07:07.005, Speaker A: I sort of want. I guess it could be a request. See. So create mode can be one of these guys, and they clearly have like predefined values that we're gonna end up using in the protocol. So that's all fine. And I guess we could say that this probably has. I guess it has a repr of i32, but let's double check.
01:07:07.005 - 01:07:52.835, Speaker A: So in zookeeper, remember how there's this jute file that defines all here, defines the entire network protocol. So let's see if we do a create request. Where's create request? Create request. So there's a path, it's a buffer of data ACLs, and then flags. And flags is an int, which is an i32. So what we're going to do is we're going to do the same thing as we did up here and say here, reprieve 32. This means that all these will already be in i32 and we can cast from create modes to i32s just by casting.
01:07:52.835 - 01:08:39.855, Speaker A: Oh, I see. So if you, if you look carefully here, what is really happening is that this is really just a flag. So if you think of this in terms of binary flags, you could actually use bit flags for this in theory. Although this sort of, this implies that you can't have an ephemeral container, which it's actually unclear whether you can. But if you think about this as a bit string of three bits. So the first bit, so this bit, is it a container? Right. So remember that these correspond to 4, 2 and 1.
01:08:39.855 - 01:09:09.704, Speaker A: This bit is it sequential. And this bit. So the low bit is. Is it ephemeral? Ephemeral, right. So if you, if you look at the integer values that have been given here, zero is. All of them are zero. So it's not a container, it's not sequential, it's not ephemeral, which makes it persistent.
01:09:09.704 - 01:09:24.945, Speaker A: This has one. So it's ephemeral, but not sequential or container. Let's go to this one, for example. This one has both one and two set, which means that it is ephemeral, it is sequential. Sequential, but it's not a container. And this is four. So it's just a container and not the other things.
01:09:24.945 - 01:10:03.044, Speaker A: It is pretty tempting to make this a bit flags, actually. So for those of you not familiar with bit flags, Bit flags is a neat crate that basically lets you define different flags and then people have a bunch of operations they can do on them. It's a little bit tempting. I think it's mostly an aptitude API optimization. There aren't that many flags at the moment and it's not even clear that it's a full flags. Because I don't know if you can create a container that is ephemeral, for example, or a container that is sequential. I suspect you probably can, but it just doesn't make that much sense.
01:10:03.044 - 01:10:21.375, Speaker A: But that's why I think we should just stick with this being an enum for now and then we could optimize that later if we wanted to. So here. Create. Create mode. So here we're going to do pub use. Oh, there's a types. That's probably where I want this to go.
01:10:21.375 - 01:10:45.505, Speaker A: 30 DB source types. Yeah, perfect. So we're going to use types stat and create mode. Okay, so that deals with created mode. There's gonna be a mode. I guess we can. We might as well go to request here and add the.
01:10:45.505 - 01:11:22.295, Speaker A: I want to move this up a little. So we now also have a create request to something that can be made. The path is a string again here we could use cows to prevent some copying, but paths are probably short anyway and we want to use borrow cow. And it's going to take a data which is going to be a cow static U8. So any static. Anything that can be turned into a. Or sort of turned into a static reference to a list of U8.
01:11:22.295 - 01:12:01.503, Speaker A: We also have what else was there Mode which is going to. I guess here we're going to use Create mode. So we're going to have. This is going to be a create mode and we're also going to have an ACL in here which is going to be this vec of ACLs that. We haven't quite figured out what that type is yet. My guess is we're going to have to use it. All right, so we got to figure out what this ACL business is.
01:12:01.503 - 01:12:22.469, Speaker A: My guess is just a list of fairly straightforward permissions. Look at it here. Yeah, so we give a. Right. So create takes a list of ACLs and the ACLs just have a permission. Whatever permission is scheme and ID. So you should think of this as Z.
01:12:22.469 - 01:13:04.767, Speaker A: Zookeeper has really weird authentication. Like you can say only a machine with this IP is allowed to do this thing. So scheme here is something like IP or I think they have a bunch of other things like username, password. I think there's like everyone and then ID is sort of the value for that scheme. So if the scheme is ip, then ID would be the IP address Here we could do something really fancy like we could have an enum to sort of expose the different kinds of Zookeeper schemes that are supported. I think that is making the API nicer, but it's not something we're going to do now, but probably something we'll want to do. So we'll leave A to do there.
01:13:04.767 - 01:13:34.605, Speaker A: And then Perm said, if you match this, then what permissions do you have? And you see here permissions. This looks, looks an awful lot like bit flags. And so we may end up making this. In fact, it might already be a bit flags. No, they've implemented themselves. But if you look at this right, this is totally a bit flags. So we'll probably use bit flags for this.
01:13:34.605 - 01:14:14.247, Speaker A: All right, so we're going to need these types. Oh, they've got some other things too. Oh, I see. There's like a convenient method for making. Why is this unsafe? Oh, I see the unsafe in the sense of if you set this acl, everyone has permissions. You just prefer explicit name value. So you're totally right that I.
01:14:14.247 - 01:15:27.283, Speaker A: In fact you will see that once this code actually compiles, I think my Rust format will actually simplify this for me. The reason I start doing this is because every now and again I find that I have to add an into or I have to do some other trivial transformation on it, in which case if I just had this, I then have to erase it and do data dot INTO So I like to start out with it just being pairs until I know that it's right and then I simplify and usually Rust format will do that for me. Like in this case, expected cow found cow seems unlikely yet. We'll deal with that in a second. Alright, so I think we're just gonna. Huh? I think we're just gonna stick as close as possible to the Rust Zookeeper API for now and then we'll see whether we start. Whether we start modifying it to like use bit flags, for example.
01:15:27.283 - 01:16:22.327, Speaker A: So I think we'll just like take this entire file which contains all the ACL stuff. We're going to make their source types and we're going to get move source types RS to source types modrs. This is no longer necessary in the new edition, but until we get the path change we're going to have to do it. Types mod now has these things which will probably let stay there for now and then pub use ACL and now ACL rs, all of this stuff. We also know that a permission. Oh I see. Permission will probably should turn into a bit flags but it's more work to turn it into a bit flags and so therefore I won't do it.
01:16:22.327 - 01:17:07.775, Speaker A: Now there are a lot of these kind of changes that I want to get all the stuff working first and then we can start building nicer APIs around them. So now that should give us ACL once we do this. And now the question is wait, why does he complaining about this cannot find acl. That is not true. No cargo check. Did I like misspell ACL somewhere here? Oops. Oh, this is really.
01:17:07.775 - 01:18:12.075, Speaker A: I mean, I guess am I doing something really silly? Oh yeah, it's this. This is also something that will be fixed with with the new path changes that if you want to use something then it can't be from a module unless you explicitly say self. Like if I do this, what it thinks I mean is take a top level crate called ACL and extract this type which is just not what I meant and that now ACL is in scope here and so now we can just use ACL because now this use brings ACL into scope so that gives us those things. Oh, I guess we need lazy static. Lazy static. I think lazy static is 1.0. I think that's reasonable.
01:18:12.075 - 01:18:59.353, Speaker A: Right? And macro use xtray lacy static. I don't think we should actually need lacy static for this. I think you can. I think we could make the new for ACL be const and that would make this problem go away. I also think that for ACL specifically we might also want to use cows because you could totally imagine that the user has some list of ACLs that's static. So I think we actually want a. This is a.
01:18:59.353 - 01:19:45.227, Speaker A: We play the same trick except it's going to be static over acls. And now of course proto request. This is now going to be a cow static of acl. List of ACL like so complains about not finding acl. That should no longer be true. I think that's not true. All right, how's that looking? Expected cow found type parameter right? Yeah.
01:19:45.227 - 01:20:18.955, Speaker A: So this is the place where we need the intos as we discussed earlier with using the Initialization because we say the DNA have to implement into cow because otherwise the user would have to type like cow borrowed or cow owned, which is really annoying. But that means that D and A are not of type cow, they can just be converted into it. And so that's why we have to use the into and then we can't use the. What do you call it? Epo. Eponymous. Never heard that word before. Learn as long as you live.
01:20:18.955 - 01:20:43.385, Speaker A: All right, that's getting pretty close. 81. Right. So this is. There's no longer a bad version. So the question now is what kind of responses can we get to a creator create and that this will tell us Keeper exception. Of course, invalid ACL is the only thing you can get back which is a little odd.
01:20:43.385 - 01:21:22.935, Speaker A: Yeah, that's a lie. Okay, so you can get node exists. Why is this throws wrong? So you can get node exists. You can get node. You can get no children for ephemerals, something about size and something about invalid acl. So this means that result will indeed return a result. So we're playing the same trick as with delete, where there are a bunch of different delete specific errors.
01:21:22.935 - 01:22:03.803, Speaker A: You can get where the There was no protocol error, but some operation you did failed. And so we're going to play the same trick here of if it indeed finished correctly, what does it return? The actual path of the created node. So it says actual path. Because imagine you're creating something that's sequential, then you need to know what integers it added to the end. And then this is going to return an error create which we have yet to define. I think realistically we're not actually going to get this. So a create can either give you.
01:22:03.803 - 01:22:42.965, Speaker A: What did I say? Node exists. Target node already exists. It can give you a no node, which is also a little bit weird. Parent node did not exist. In theory, we could store here what the parent path is to, but I think we'll just not Parent node of target does not exist. Eponymous having the same name. I guess that makes sense.
01:22:42.965 - 01:23:35.435, Speaker A: Thanks. Learned something new? No children for ephemerals, which is a terrible variant name, but okay. And what this is saying parent node is ephemeral and cannot have children. There's something about size. So I guess here we're gonna look over at our proto error, not empty system error. Okay, so those. It doesn't seem like there's a well defined one for this invalid acl.
01:23:35.435 - 01:24:16.145, Speaker A: So that's the other one we could get invalid acl. The given ACL is invalid. I think one question I Have is. Is there no way for zookeeper to give more information about the like if the ACL is invalid, does it not give you an error message? That seems really odd. I feel like that's not true. I wonder. I have a very strong suspicion that whatever.
01:24:16.145 - 01:24:41.765, Speaker A: Whatever is left of the message you get back is the error. But sadly, this is not really well documented. Let's see if we can tease it out from here. So in proto, read from yes, Empty response does not read anything. In this implementation, the question is in. I guess it's in I.O. maybe.
01:24:41.765 - 01:25:17.465, Speaker A: What do they do when they get an error handle response? Okay, so let's look at handle response. This is pretty familiar code at the moment, right? So this is like make sure you have four bytes, because until we have that, we can't really do anything. And then to just handle chunk. Oh, bytes dot freeze. They're doing something funky. What is bytes? I feel like bytes is something that we might want to. Might want to use here somewhere.
01:25:17.465 - 01:25:57.275, Speaker A: Oh, I've heard of this crate, but I've never actually ended up using it. Ooh, wait, this seems fantastic. This might be something we want to use instead of. I don't know if you recall, but we do this trick where we keep track of how far through a vector we've read. It might be that we can use this instead. But let's put that on hold for a second. So if it does handle chunk and we're not in connecting, it reads the hair, the header, and that should all be fine.
01:25:57.275 - 01:26:34.905, Speaker A: Now if the X ID closed session. No, it's not. That's a client. Where does it handle? Right, so a RAW response is what we want to know. Send response. Probably also not what we want. So there's a zookeeper RAW response.
01:26:34.905 - 01:27:10.435, Speaker A: Let's see what it does with that. So it's a reply header. That's fine. Where does it actually get its errors from? So request creates a RAW request, gets back a RAW response Match response header error. And there's a zkerror from. Because it seems like it doesn't. The Rust implementation certainly does not read out the data from an error.
01:27:10.435 - 01:27:35.345, Speaker A: I find that really hard to believe. There's no extra message Z error. There's definitely a message being written out here in the issue logic. Question is where does it go? Request header. Maybe here. So let's see. What is the.
01:27:35.345 - 01:28:17.335, Speaker A: Is there an error response here? Set ACL response just returns a stat error response. Really? It's just an IND error? Well, I guess there's no additional message. Does the. If you Get a keeper exception. Keeper exception. Does it include more info like what's the invalid ACL exception? Is there really no additional information? No, apparently not. That seems like bad design, but okay.
01:28:17.335 - 01:28:38.509, Speaker A: The given ACL is invalid. Was invalid. I guess it's invalid. All right. So those are the kind of errors you can get with a create. And so that's the kind of error you can get back. So what we will do is now do the same thing as we did for exist.
01:28:38.509 - 01:29:22.665, Speaker A: We map all the different responses. What is the actual response to a create I guess is what we need to figure out. So let's see. FN create. So create is a create response. What is the create response? It is a just contains a path, right? So the thing we read back is really just a string. If you look at it, all we do when serializing response to a create is just we read a string and so this will actually be a string.
01:29:22.665 - 01:30:15.385, Speaker A: S. I'm going to assume that there are also other methods that return strings. So if we go to our why is there a file called tick that seems wrong in so many ways. So if we now go to our response, we're going to have this sort of general. Just like we had empty, we will also have string and I think we already have that set up because that's going to be a string reader. So if you get a create request and it's going to be a string which is going to be a reader read string. Perfect.
01:30:15.385 - 01:30:53.365, Speaker A: So if we get a string, then we're all good. If we get something else non string response to create, which again should be unreachable. And now we need to of course map the errors into the different create errors. So there's node which gives you node. There's not empty, but there is node exists which returns node exists. There is also invalid ACL which gives you an invalid acl and then anything else is a protocol error. Is that right? No children for ephemerals.
01:30:53.365 - 01:31:08.725, Speaker A: No children for ephemerals. Same thing here. Let's see the check in the error. You forgot a comma. Nice. Good catch. You are indeed correct, Sir.
01:31:08.725 - 01:32:01.505, Speaker A: Variant invalid ACL not found here. Uh, ACL technically string s not found in scope. In response 1319 oh, holds a string. That's a little awkward, but I think that should work. Now in request on line 92 serialize into right. So the question is how do we serialize a create? Well, we have a path, we have a mode, we have a data. I guess we just have refs to all of them.
01:32:01.505 - 01:32:46.145, Speaker A: Mode is probably Copy would be. My guess is ACL copy. Wait, where is acl? Ac? Why are the test? That's weird. Ah, ACL is only clone, that's fine. But mode should be copy, right? That's not true. Copy and stat is probably also copy actually. So we take a mode, we take ref to the ACL and we take a.
01:32:46.145 - 01:33:25.915, Speaker A: I think that's all. And the question is how do we serialize it? And it's basically we do the same thing as we have done all along. We don't forget that. So we write out the opcode of CR create. Could there be no additional information on ACL for security reasons? That's a good question. Well, so remember it says Invalid ACL and it sends that response only to the person who tried to create the acl. So I'm more thinking things like if you try to use a an ACL scheme that does not exist, it seems reasonable that you should get an error that that scheme is incorrect.
01:33:25.915 - 01:34:12.893, Speaker A: Whereas like if you get no information back, you don't know whether you like mistyped an IP address, you don't actually know what the error was. That's a little awkward. Right, so let's see, what do we have here? The path, the data, the ACL and the flags. Okay, so writing out the the mode is pretty straightforward because all we're really doing is writing it as an i32 writing out the path we already know how to do. Let's do this. Writing out the data I think is basically the same. That's a good question actually.
01:34:12.893 - 01:35:20.273, Speaker A: Data here stores a vacuate. How is a vacuate serialized? Write 2 for VEC is basically the same as writing out a string. I mean they are basically the same. Yep, they're the same. I don't know whether we have this right to though we have it for slices, which is basically the same. Which I think means that this implementation for string can really just be writer dot write to self as bytes should be the same, although it's a little bit less sufficient. So this one's going to write each byte on its own.
01:35:20.273 - 01:36:00.605, Speaker A: This one is going to write. This was going to do a single sequential write of all the bytes. This one's going to call right to for each byte individually, which is actually really not what we want to do for data. So I think what we'll do is implement right to for. See, I don't think I'm allowed to do this sadly, because these two implementations are in conflict. I think with specialization it should sort of be okay. But I don't have a way to specify that.
01:36:00.605 - 01:37:13.645, Speaker A: The alternative, of course, would be to not have this generic implementation. Here's what we'll do. We'll have a generic write list which takes this and returns you an IO result. And its implementation is. I guess it needs to take a writer as well. In fact, this could even be generic over W and it is going to do this and it's going to be TS because now you can always opt into the slow one, but the default will be fast, which I think is more along what we want. Let's see how it likes that.
01:37:13.645 - 01:37:59.585, Speaker A: Because then we'll use write list for writing out the list of ACLs, for example, where we would need to serialize each element independently anyway. But for things like U8 actually maybe it is only U8s for even for like an i32 you would have to do endianness. But I think it's important enough because data is the thing that would be the largest, if anything. And the zookeeper things are generally not very large. And so what we'll do is we'll have a fast path for U8s. We could flip this around and say that we have a specialized function for writing out U8s and you call the method for non U8s. But given how slow this could be, I think we want to do it this way around so you don't accidentally do that.
01:37:59.585 - 01:38:40.780, Speaker A: Because in here we'll do write list, mute buffer acl. I guess this will be something like. Because no, it should be just this. I think that should be all we needed.139 fails because try adding a semicolon or removing the line altogether missing where t is right 2 oh, did I? You're probably right. Yeah. Thanks.
01:38:40.780 - 01:39:14.975, Speaker A: 139 expected. I32 okay, so mode. This is why we put repr i32 on it because it means that this conversion is fine. ACL does not implement. That is totally true. That's why we need to find the write to implementation AMPL write to for acl. Great.
01:39:14.975 - 01:39:58.622, Speaker A: It is so handy to have an existing implementation to start from. Alright, so implement write 2 for ACL and it will perms code. I find that very hard to believe that that should be necessary permissions. Oh, it's because it's fine. All right. Yep, that all seems fine. What else? 63 what? Oh, right.
01:39:58.622 - 01:40:35.423, Speaker A: This returns an IO results. What else do we have? 98 something something Iter this is now a slice so we don't need this anymore. Self value is only available. It's not self it is T. Yes. 99. Wait, why is this written this way? If res is error, then return res.
01:40:35.423 - 01:41:11.305, Speaker A: So this can just be this. I think I expected mutable reference. That's just right to. Yeah. The question is whether we want dynamic dispatch here or not. Probably doesn't matter terribly much. I think technically the way to do this is this.
01:41:11.305 - 01:41:52.755, Speaker A: And then we change all of these to do this and then this. Oh, 68. Where did I do something silly? Oh, all of these need to be. That's unfortunate. Like so patterns aren't allowed in methods without bodies. That's fine. Let's get rid of this source error failure business.
01:41:52.755 - 01:42:19.239, Speaker A: All right. Request 151. Right. If you get a create request, then its opcode is create 143. Right. All of these now have to. So it used to be that it took a mutable reference to anything that implements the write trait.
01:42:19.239 - 01:42:54.655, Speaker A: It means that the implementations are no longer generic. So they do dynamic dispatch on the so it would do dynamic dispatch on the underlying writer, which is just unnecessary. But now that we made a W, we don't want to pass in the buffer because that would be giving away ownership of the buffer. You just want to give in immutable reference to it. So that's going to change this. This. I think that's all142 consider changing this to mute buffer.
01:42:54.655 - 01:44:01.795, Speaker A: Oh, that's weird. Wait, so in theory I should be able to do this, so why is it not letting me? Because buffer is already a mutable reference, right? So what this method is given is a mutable reference to evacuate. Yeah, exactly. And so therefore it shouldn't actually take ownership of it when I call. Oh, I need to reborrow. This is. So there's this notion of reborrowing, which is basically I'm doing this, which is a no op really, but it means that I'm creating a new borrow instead of giving away the one that I currently have.
01:44:01.795 - 01:44:55.815, Speaker A: And so now I think the compiler should be happy with me. It mostly was, except for here. Great. 97 variable does not. We don't even need rest anymore because this just returns an okay nothing 96 result that must be used. That is true. How's that? Great.
01:44:55.815 - 01:45:38.445, Speaker A: All right, let's see if all this actually worked out. So what we should do now is we know that we ran the test before. So in theory foo should not exist. And so we will do ZK create foo with some data that's going to be here, we can test out our new thing. Hello world and create mode persistent. And what is The I don't like the ACL coming first, but ACL open unsafe. So like so.
01:45:38.445 - 01:46:27.211, Speaker A: And then we want to inspect it, which is going to give a path and we're going to assert equal. That path is equal to. I guess this has to be probably ref path. We're going to assert that the path is equal to foo and then ZK Then we're going to check that it exists and we're going to assert not equals stat none. Right? So we're. Because we created it, we know it should not be empty. In fact, we can make an even better assertion here.
01:46:27.211 - 01:47:12.551, Speaker A: Now we can actually write it as a test, right? Because now we know that it'll pass or should pass every time. We can do even better here and say stat dot unwrap, which basically. So unwrap is basically an assertion that it is some unwrap dot. Data length is equal to hello world len and then we delete it. And here we just assert. We just assert true. Well, I guess here what we really want to do is we know there shouldn't be an error.
01:47:12.551 - 01:47:53.655, Speaker A: So we don't even need to inspect here. Because the error if this. If this delete produce an error, then we would get and hit this unwrap because the operation actually failed and then exists is going to do basically the opposite because we now delete it. Right? So we should assume assert that stat is none and then we're gonna map out the ZK. Perfect. Let's see how that fares. Not so much can't compare.
01:47:53.655 - 01:48:44.095, Speaker A: Oh right, because this path is technically like so these remember that delete. There's delete error and debug errors. Sorry delete and creation errors and those we actually do have to compare partial eek and eek and we do the same for this. So we actually want to check that the create there was not a protocol error and also the creation actually successful succeeded. And so that will be the same for delete. We do actually want to inspect it. Specifically we want to assert egress.
01:48:44.095 - 01:49:00.533, Speaker A: Okay. Right. Because there could be that there's a deletion error and we're not expecting a deletion error. In theory, I guess we could map here, but do it that way. First someone should make a super fancy assert macro so you can type assert equals. Equals. Yeah, would be pretty nice.
01:49:00.533 - 01:49:58.405, Speaker A: I agree. There's also a really nice thing called rust assert deep equals pretty like pretty asserts or something. I think it's this one. So pretty assertions gives you full diffs of structured output. Really quite nice. So that's something to keep in mind. 155 I messed up, didn't I? Where did I mess up really? Oh, this and somewhere else here and somewhere else.
01:49:58.405 - 01:51:05.453, Speaker A: In fact I messed this up even worse than I thought. Like this. There we go. Can't compare Compare Ooh. Can't compare results String create with results stir Fine. Well I guess we could I could technically map this into string Asterisk accepted signature found signature mismatch type on 154 expected I32 found us there's a lisp stream now. I don't think you'd even need a proc macro for that.
01:51:05.453 - 01:52:08.375, Speaker A: Oh, you're meaning. You mean for oh for doing assert double equals yeah, the double equals inside assert I think you can etherily in theory do you would have to parse the token stream I guess you could just. If you. If you can't figure out that it's a well recognized pattern then you just don't rewrite it I guess is the way to get around it. The problem with the language name oh yeah there's a lot of rust is hard to search for. The trick is to search for rustlang similar to for go you do go lang and that way you get basically the same results because usually the search engines are smart enough to deal with this. Convert from 144 oh, that's interesting.
01:52:08.375 - 01:53:57.633, Speaker A: A reference to a vec does not implement into cow that seems wrong. Specifically it seems like there's no implementation in the standard library for implt into cow T for what is this for tick a vector this should definitely be in the Senate library but apparently is not because this should then be cowborrowed. This implementation should be in the standard library and it's not. That's. That's pretty unfortunate because it means that we can't so opal open unsafe returns vector Although it doesn't have to anymore. Where's our acl? So where's our lazy static this no longer needs to be that this can now be a I think in fact I'm fairly sure this can be constefn if oh no because it makes strings that's awkward. Yeah.
01:53:57.633 - 01:55:11.915, Speaker A: I think in theory you could do this and then this would return a if in fact even if we kept it the way it was but we should be able to do this. Yeah botching my writing like so like so could be lacy static Complaints about that though. Really. Oh right one found type ACL open unsafe or really this maybe makes me a little sad that that has to be I guess the ACL also doesn't need to contain strings. It could contain cows, but then it gets a little bit annoying. But that seemed to have worked. Let's go back to our lib.
01:55:11.915 - 01:55:51.265, Speaker A: Thanks, I appreciate it.159 it's saying that it can't compare a stat because stats aren't comparable. Ooh, that's a good question. I think stat should be comparable. There's no reason for us to not do that. So let's do partial eek and eek. Well now it's saying it can't compare.
01:55:51.265 - 01:56:17.955, Speaker A: Oh. Because one is a reference and the other is not. So we need to do this. 157 can't compare. And that's the same issue. 144 run that. Oh, that's really sad.
01:56:17.955 - 01:56:48.695, Speaker A: So the issue is this is actually an array of length 11. It is not a static slice. So we do need to do this. It's still less to write than cowborrowed or vec O. Oh, the ACL has some doc test somewhere. Let's get rid of that. And is there any here? No.
01:56:48.695 - 01:57:39.315, Speaker A: Let's try that again. Well that seems to have worked. So there's the create, there's the exists, there's the delete and there's the last exist and the unwrap did not fail. Let me just. It's pretty neat if that just worked on the first try. But yeah, that gets a zookeeper, which we are fine dropping. Let me just so that I don't get confused by this later.
01:57:39.315 - 01:58:09.969, Speaker A: Well that seems to have worked actually. So now we can create, we can check exists, we can delete, we can check exists again. And we have all the create modes. And it seems like the length was right too because otherwise that assert would have failed. So I think we actually now have all of those basic implementations that we wanted. Right? We have create, exist and delete. I think then it's time for us to move to Watchers because that's where things start to get a little bit hairy.
01:58:09.969 - 01:58:48.505, Speaker A: There are some other things that we have not yet implemented that we will need to. In particular, where's the proto mod packetizer? In particular. So remember how zookeeper have these ephemeral nodes? All right? Commit. Yeah, sure, that's a good point. Create, delete. I normally write better commit messages, but on a stream it's not worth it. So many keys.
01:58:48.505 - 01:59:14.593, Speaker A: It's been pushed. It is alive. Right? Isn't that nice? We have a fully self contained test. Yeah. So remember how there are ephemeral nodes in Zookeeper? So ephemeral nodes. The idea is that once the client goes away, the node is automatically deleted by Zookeeper. But this relies on Zookeeper being able to node that the client has not gone away.
01:59:14.593 - 01:59:52.975, Speaker A: And you can imagine that you have a client that creates some node and then it doesn't really do anything for a while. And so Zookeeper actually requires that we do Heartbeats. And that is not something we've currently implemented. And it's going to have to go somewhere around here, specifically in. Actually, it'll go here. So this is going to be. Actually, I think it's going to be down here.
01:59:52.975 - 02:00:39.745, Speaker A: If it returns not ready down here to do send Heartbeat. Actually, it's not even here because this implies that. Yeah, it's actually not even here. I think we're just gonna have to here add another pole Heartbeat. And so we need to make sure that we're gonna have to spin up some kind of Tokyo timer. And then whenever the timer expires, we have to make sure that we send a heartbeat. And we can also reset the timer whenever we do an actual request, because then Zookeeper knows that we are still alive.
02:00:39.745 - 02:01:07.405, Speaker A: I think this is a pretty low priority thing. We can decide whether we want to do Heartbeats first, which is sort of slightly lower level. So it goes back to some of the stuff that we wrote in Part one, or whether we want to do Watchers first and then come back to Heartbeats later. I'm fine doing either. So it's sort of up to what you want to see first. I think we'll probably have time to do both. It's only two.
02:01:07.405 - 02:02:59.645, Speaker A: I will go pee, though, and then I'll be back. I vote for Heartbeat. I vote for Watchers. This is the first time. So you're excited. Great. So we have one vote for each and one person excited.
02:02:59.645 - 02:03:25.175, Speaker A: All right, let's do. Let's do Heartbeats first, because otherwise I'm going to forget to come back to it because it seems so trivial. But it's something that just like if you don't have that, your client is wrong. Whereas Watchers is a feature. So let's do it quickly. And then, Adler, I'll have to. I'll have to make it up to you by getting to Watchers quickly.
02:03:25.175 - 02:03:59.851, Speaker A: All right. That's all right. We're just trying to decide which feature to do next, or whether to fix a bug or whether to add a feature, I think is really the way to phrase it. All right. In theory, this should be very straightforward. So the idea is that we want to make sure that at least at every so and so interval we send basically a ping to the server like a heartbeat request to let it know that we're still alive. We have this packetizer which is the core, the core future that we're polling.
02:03:59.851 - 02:04:34.709, Speaker A: And basically the way we're going to implement this is that future is also going to contain a timer future that we're also going to pull every time we go through. And if that future has expired, then we know we have to send a hard to so packetizer. Where you at here? So that's the stream. And then we're also going to have Heartbeat timer. Tokyo has a built in timer module. In this case what we want is Tokyo Timer. It basically re exports.
02:04:34.709 - 02:05:02.195, Speaker A: I guess technically we should use the documentation from here. I think the goal is eventually for Tokyo to move to not re including everything here. So have you include all the. All the crates separately so that they don't have to do a Tokyo release in order to release changes to the subcrates. But for now let's deal with this. What we want is interval and I think if I remember correctly, that interval also has a reset. It does not do this as a new.
02:05:02.195 - 02:05:42.175, Speaker A: I guess we can do delay instead. Now let's do delay delay. Great. And so when we create the packetizer somewhere down here. So we're going to do the connect and where's our pull? Enqueue is setting up in queues. Write is when we write stuff out. Read is basically where we want to see down here.
02:05:42.175 - 02:06:47.537, Speaker A: Where's the part where we get a connect? So remember initially, so we're going back to here somewhere. Connect response. So a connect response contains the timeout and the timeout is what tells us how long to wait until we issue the next heartbeat after every request. So if we look here in the Zookeeper docs, somewhere around here, nodes and ephemeral nodes, it's not here. Maybe Zookeeper sessions. So they have this terrible, terrible diagram. But the basic idea is when you connect then it doesn't even say in here where's the heartbeat here? Yeah.
02:06:47.537 - 02:07:39.835, Speaker A: So session expiration is managed by the cluster. It provides a timeout that is used to determine when it expires. So we need to make sure that we get back to it within that heartbeat. So this is another thing that we're actually missing that could be interesting to implement is that Zookeeper has this notion of if you get disconnected from a server, either because your session expired or because the server went away, the library has enough state to reestablish a new connection. To a different server or to the same server and continue with the same consistency model that it had by sending along some special values. And that reestablishment of connections is not something we've implemented yet, but it's totally something that we should implement. In fact, the BASIC library does.
02:07:39.835 - 02:08:20.135, Speaker A: And so that is something that we will have to add at some point. It could be that we add this as a part of Heartbeats, but we can probably deal with them separate separately. Thanks, have fun. Thanks for coming. Let's see. But so the idea is we don't actually know the timeout until we hear we get the first connection response. And so what we do want to do here is actually if let response Connection.
02:08:20.135 - 02:08:59.895, Speaker A: Yeah, connect. We want to sort of fish out the timeout here. So if we got a connect response, then we know that we now need to set this delay. So now we can do self timer is equal to or dot reset to. It's sort of like time instant now plus timeout. It doesn't actually say what the timeout is in, which is a little awkward, I guess. We search for timeout.
02:08:59.895 - 02:09:22.425, Speaker A: That's fine. That's fine. Reads in i32. That's fine. Well, that's unhelpful. I assume that it's in seconds, but it doesn't actually. It might be milliseconds.
02:09:22.425 - 02:09:57.995, Speaker A: New connect request. Okay, so the question is what does it send in its connect request? So the connect request. Well, that's sort of unhelpful. Con resp. Where is conresp? Initial timeout Milliseconds. It sounds a lot like it's in milliseconds. Connect response.
02:09:57.995 - 02:10:39.915, Speaker A: So this is a response to the connection request. The timeout is zero. That means it expired. So we haven't dealt with session expiration yet. This is one of the cases where we need to reconnect. But generally what is this two thirds of the time? I think I read somewhere that is already set pretty conservatively. But I may be misremembering this ping not only allows it to do.
02:10:39.915 - 02:11:21.259, Speaker A: The timing of the ping is conservative enough to ensure reasonable time to detect a dead connection. So the question is like how close to the heartbeat ratio do we want to be? I think again, we'll stick close to this implementation just because it's one that we know works. This is like you can be in read only mode, which is not something we currently support, but it's also something we'll have to deal with. But it certainly seems like the value is in milliseconds. So it's going to be time duration from milliseconds, which is now the standard library, which makes me very happy. Oh, can I. That's a good question.
02:11:21.259 - 02:12:19.719, Speaker A: We'll need to know what the, what the timeout actually is. So we'll have to store that somewhere too. Timeout is going to be a time duration. So the here we're going to do self dot timeout is time duration from milliseconds timeout and it's going to be two times that divided by three. And then this is going to be self timeout and then we're going to forward the responses we used to. And now what we're going to change down here is I think we're going to have to. So the tricky part here is actually that whenever you do a write to the server, we sort of want to reset this timer.
02:12:19.719 - 02:13:11.485, Speaker A: Right? Because this is the server needs to get a heart or a ping from us if it doesn't hear from us. Otherwise what this means is if we're already writing stuff to the server, we don't have to send pings. And so the way we'll do this is every time we successfully write out, we can reset this. So I guess wrote is false. Wrote is true. If wrote, remember that poly write gets called every time even if there's nothing in our buffers. So if we wrote something up out then we reset the timer for I guess we could call this heartbeat timer.
02:13:11.485 - 02:14:03.865, Speaker A: And then what we want to do is where we call all the poll methods, which is down here, we're going to do poly polling, Q poll read poll write and then we will do self.pol timer which is really just timer poll. And what we're going to do is we're going to match on it. Yeah, we're going to match on the timer. Write is wrote wrote. Ah, nice. Thanks.
02:14:03.865 - 02:14:56.971, Speaker A: This is why I want the rainbow colored variable names that there's like a plugin that does this which is sometimes very handy and sometimes just really annoying. Too many colors on screen. We actually have a little bit of a challenge here because okay, let's say that this comes back with async ready. So async ready means that the timer is expired and we need to do some stuff. If this comes back that way, then what we really need to do is we need to queue some stuff to be written. So what do we do in poll in queue again we just add to the outbox, right? Yes. So we'll do self.outbox.extend
02:14:56.971 - 02:16:10.545, Speaker A: and then we'll write whatever the byte value for whatever the byte value for a ping is we'll probably construct it and what whatnot. This is more I'm just walking through what we'll do however I guess we'll do question mark however we then need to pull right again because otherwise we don't know that the underlying stream or we wouldn't be notified again. So imagine that we go through these and there's nothing to read or write and then the poll expires so we extend the outbox and then we return from the future we return from poll but there's nothing that causes us to be notified again so that we actually write out these bytes that we enqueued here. So we actually have to do poll write again which is a little odd. I think this is why I sort of want to do it before poll right. But then we have a race with the timer actually let's do that. Let's do this.
02:16:10.545 - 02:17:19.893, Speaker A: It's a little bit easier to think about and I guess we don't really care if we get not ready if let this is equal to that. Right. So the idea is we check whether the timer has expired and if it does we add a ping to the outbox and then we pull right? We have to pull right regardless because there may be other things in the outbox or if there's nothing else in the outbox I guess here we could even if self outbox is empty, we only need to add to it if it's currently empty empty because if it's not currently empty there are going to be bytes that we're going to write out regardless. There's no need to add a ping because there's already a request in flight so we can do that here. Request in flight. So no need to also send heartbeat. The other thing we'll have to do of course is we'll have to reset the timer because we want to keep sending heartbeats.
02:17:19.893 - 02:18:06.981, Speaker A: Right, let's see. So the question now is how do we send a ping? My guess is that pings are pretty straightforward. If you look at our poll enqueue what we can basically do is write out a very simplified version of this code. It is simplified because all we really need to do is because we know the length of it. So if you look at a ping proto there is no other ping in this file so it's in IO then I guess. Yeah. So here you see he's just hard coded what that looks like it is sending an X ID of minus 2.
02:18:06.981 - 02:18:33.635, Speaker A: Why minus 2? It's quite odd, but sure. Oh, it's because he just has. It's so that there's some ID that you can scan for that you can ignore. I assume he does the same for connect. That connect is like minus one or something. But it was the reason to do this is when we get a response here. If the x ID is minus 2, we know we can just ignore it.
02:18:33.635 - 02:19:24.621, Speaker A: So here if self xid equals minus 2, it is a response to heartbeat and so we continue, I guess. Is that right? Continue? Yep. Right. And so really. And we also know the length of this. So the length of this will just be the length of a header which if you recall is just eight bytes, right? So the header is just the XID in the opcode. The xid is an i32 the opcode is an i32.
02:19:24.621 - 02:20:01.917, Speaker A: So we'll do. See, right. So self outbox write minus 2 and then the type is going to be outbox write. So if we remember from sending out requests, the thing we do is always write out the i32 of the opcode first. So in this case we will do the same thing. We will do self outbox byte i32 and this is going to be opcode ping. And that is totally right.
02:20:01.917 - 02:20:27.595, Speaker A: This should not fail opcode and there's basically nothing else to write out. However, we do have to write out the length and the length is known for pings. Specifically it is. This is an i32. So this is four bytes. This is another i32. So this is another four bytes.
02:20:27.595 - 02:21:02.853, Speaker A: So eight bytes total. This can go away. This can go away and that can go away. So this is send a ping, Right? Does that make sense? So every time the timer expires, we reset it and we also send a ping if there's nothing else to write. In theory, this shouldn't affect our implementation at all. Didn't like that at all. Request opcode.
02:21:02.853 - 02:21:46.033, Speaker A: Is that right? No, here. Request missing timeout and timer. Oh, that's right. When we start it, we don't know what the timeout is. We also don't know what the timer is. So this is going to be time duration, something like new zero and the timer is going to be Tokyo timer delay new and it's going to be something like time instant now plus. Actually that's a good question.
02:21:46.033 - 02:22:32.669, Speaker A: Is there an instant like forever into the future? I doubt, but yeah. So it's now plus time duration from. What kind of durations do we have now from I guess from sex. And we will make it 86, 400 which is one day, right? Messing up my 24 times 60 times 60. Yep. So we're basically setting a timer that will not expire. We could set it way harder, higher if we wanted to.
02:22:32.669 - 02:23:10.677, Speaker A: And then we're setting a timeout to zero. Because the timer will never expire. The timeout will never be used until we set it when we get the response to the connect unused module time. That is entirely true. We need time and expected two parameters new. That's fine. And 259 function or associated item not finding duration.
02:23:10.677 - 02:23:41.545, Speaker A: Oh, Millis Millis. U64 found. I32 sure. U64 from that. Really? Oh, because it can be negative. We happen to know that it's not negative. I think time timeout is greater than or equal to zero.
02:23:41.545 - 02:24:16.815, Speaker A: Timeout as UCC 4. Ooh, failed. That's interesting. Unwrap none somewhere at Protomod 250. Oh, not self xid. Xid. Surprised that even worked.
02:24:16.815 - 02:24:53.677, Speaker A: Why is there even. Oh, next XID to issue. Yeah, that makes no sense. Okay, well, that seems to be stuck in some kind of endless loop. Length is 16 for a very long time, apparently. Why is the length 16? That's a pretty long way back to go. That's.
02:24:53.677 - 02:25:31.565, Speaker A: That's a lot of lines. Aha. God. Request create. What Is this? Length is 16 where we print that. Hmm. Well, that's kind of interesting.
02:25:31.565 - 02:26:15.023, Speaker A: Handling response to create session. Read more bytes so that since the timer. Huh. That's a very good question. So this suggests that we're not getting a full response to something. Hey, why are we not getting a full response? It's a very good question. Length is 16.
02:26:15.023 - 02:26:53.395, Speaker A: Let's see what those 16 bytes are, shall we? This is gonna. It's gonna spam my terminal so much. Self inbox self instart plus four to self inst. 255. 255. 255. 254.
02:26:53.395 - 02:27:28.805, Speaker A: That doesn't look right at all. I'm gonna think what's the first xid is the first thing we get back. So my guess is that is an X ID of minus 2. So E print line. Oh, yeah, yeah, yeah, yeah. No, you're totally right. Does the continue in the pink case? Because it doesn't get to continue without also incrementing in start.
02:27:28.805 - 02:28:26.595, Speaker A: What is this loop? Is it a loop? Oh, yeah. Okay, first of all, this should go here. Second of all, no, I think that's right. And then we do do an else instead to here. Because I also want this to get executed if we get an xid response. Response to user requests. Good catch.
02:28:26.595 - 02:28:59.041, Speaker A: Perfect. Packages are exiting reactor. Gone. That seems all fine. Beautiful. Right? So in theory, we now have pings. So the way we can observe whether this is in fact the case is we go down to our test and then here we do something like timer, thread, thread sleep Ms.
02:28:59.041 - 02:29:17.175, Speaker A: Oh, I guess we don't actually know what the timeout is. It's a little awkward. I should probably have figured all that out. Oh, wait, no. We set one when we connect. Right? What did we set it to? Timeout zero. So we let the server choose.
02:29:17.175 - 02:30:05.599, Speaker A: So if I like sleep for time duration from sex, like 10 seconds, guess I should probably print out what the true timeout is. Where should we set it? Here. Timeout is this many Ms. So the timeout is how much? Timeout is 4000 milliseconds. Okay, so in theory. Yeah. So here we're seeing pings, right? So this is after the test is finished.
02:30:05.599 - 02:30:20.115, Speaker A: And that's a ping. Two, three. I guess I am bad at counting. Finish. One, two, three. That seems like about four seconds. Great.
02:30:20.115 - 02:30:41.295, Speaker A: All right, so those are in fact heartbeats. Beautiful. So we now have heartbeats. Good job, team. Get diff. I guess I don't actually want to leave the sleep in there, but apart from that, we are all good. Send heartbeats.
02:30:41.295 - 02:31:14.577, Speaker A: Oh, thanks. Yeah, the dot files are in GitHub over here and in particular VMRC. So this is the from base. I'm using the base 16 themes, and in particular I'm using the one called Atelier Dune. So this team. That's pretty nice. Oh, sorry.
02:31:14.577 - 02:31:26.415, Speaker A: You're totally right. Yeah. It's 2/3 of 4 seconds. So that's why it's not actually 4. So maybe my counting to 4 is actually exactly precise. I'm gonna. I'm gonna go with that even though it's probably not true.
02:31:26.415 - 02:32:00.235, Speaker A: Okay, so watchers. So much signing. Okay, so watchers are a little bit finicky. They're. They're pretty straightforward in the sense that they're just a way for us to get notified when something happens. So the basic idea of it is something like. In fact, maybe we should implement this with gets first, given that we don't have get yet.
02:32:00.235 - 02:32:34.713, Speaker A: That's funny. So there's get data, right? So if you notice the signature of get data in the original library, if you ignore the watch for a second, get data takes self. Takes a path and returns you a stat of that thing and it's the data it contains. So far, so good. This is watch parameter two. What watch does? It says whether if this changes, you should be notified. And the way you're notified is through a watcher.
02:32:34.713 - 02:33:22.105, Speaker A: The easiest way to understand this is to first look at the get data W method, where you pass in a watcher. And a watcher is basically just anything that implements something that can handle a watched event. And watched events are things like a node went away, a node was added, data change, those kind of things. If you use this method and just say watch true, then the way that works, the watch, it doesn't actually say here, but you can add a listener, and that listener is the thing that will be notified somewhere up here. Yeah. So when you connect, you set a watcher, and that watcher is the one that will be notified if you pass true. So you don't pass an explicit watcher, you just pass through.
02:33:22.105 - 02:34:25.115, Speaker A: So this is what's known as the default watcher for Zookeeper. So the default watcher is always notified of things like you got disconnected, you got reconnected, those kind of events. But we'll also get any of the other events if such things occur in the Async world, we have the advantage that we can use streams for this. The question is just when will we return the stream? I think the idea is going to be that when you connect, you'll get back a zookeeper and you'll get back a stream that will be the default watcher. This is sort of dictated by Zookeeper that you have to have one, because you need to notify them when connection events or disconnection events happen. We could alternatively have Zookeeper itself implement stream, but then it couldn't be clone, and I think we want it to be cloned. Hmm.
02:34:25.115 - 02:34:59.481, Speaker A: So the basic idea is this is going to be. Going to be Futures npsc. In fact, this is a single channel, but there's no such thing in futures at the moment. And so the receiver isn't cloned. So if we stick one in Zookeeper, Zookeeper wouldn't be cloned. So that's why I'm thinking we might just want to return return two things, like when you connect, you get back the default watcher and zookeeper. And then the zookeeper remains cloned because it's the thing you use to execute additional methods.
02:34:59.481 - 02:35:40.661, Speaker A: But the watcher, there's only one of. And you can't clone it. Yeah, I think that's the thing to do. So connect will now resolve into both a self and a. I don't know if I'm allowed to put stream here. Don't actually remember. So the item is going to be A what's this watched event again? We'll stick to trying to use mostly the types from here.
02:35:40.661 - 02:36:17.295, Speaker A: In fact one thing we could do is exactly reuse the types. But I don't think there's an advantage to this has so much stuff in it. But keeper state to pass the z node. Yeah, I guess we'll let this stick around. So this watch type, this keeper state, this keeper state, it's presumably further down. Well, let's stick with this and then we can. We can simplify if we want.
02:36:17.295 - 02:37:04.775, Speaker A: So this will return a watched event and the error on that will be. In fact it will never error but let's just say that it's failure for now. In fact I think this will just never occur. But I don't think we have a way of saying that. Right. And then we'll do something like types watch RS that contains all this stuff and there's a keeper state defined from consts. Oh, what's watch type? I don't actually need watch type, do I? Why are those defined in a different file? That seems just odd.
02:37:04.775 - 02:37:47.301, Speaker A: Right, so they have a source consts which includes then keeper state and watched event type. And these are all just straightforward. My guess is they're all i32s, but let's double check. So keeper state. That's gonna be unfortunate. Watcher event state of the keeper client runtime. So this is definitely a wrapper.
02:37:47.301 - 02:38:15.795, Speaker A: I32 I don't think we have that. Yeah, we don't. So that's an i32. It is also copy. There's maybe a path and there's a type and that type is also an int. So this is also repr.i32 there's also copyright and we don't have this even though maybe we should.
02:38:15.795 - 02:39:21.735, Speaker A: So now when we have a lib we're gonna out of here use watch event types watch no types mod. It's also gonna bring in mod watch pub use self watch star and I think we'll also have to at least for the time being this will include watch to when event keeper state and watched event type. That way we can return that in the stream. Which means this is now going to return a this. I think Russ might yell at me here. I don't think you're allowed to use infiltrate inside of an infiltrate. But I could be wrong.
02:39:21.735 - 02:40:47.725, Speaker A: In fact we don't even need to. We could just create the stream out here. So I mean because we know what this is going to be. It's just going to be a future synth unbounded Probably. And then this is just going to need the. The transmit end and that way we can map this. So when we get back the Zookeeper connection, we map it into a ZK and an RX Right? Because now this takes the TX for the watcher, this default watcher and that is a Futures Sync NPSC unbounded sender of watched event and now packetizer new is given that default watcher and now Protomod down here somewhere.
02:40:47.725 - 02:41:45.875, Speaker A: So this is going to be given that same default watcher down here. We're going to have to stick that somewhere so that we can send on it whenever there's some watched event that occurs. Watcher to send watch events to. Pretty terrible documentation, but it is true. This is going to have to use watched event. This now just takes the default watcher, which is great. And now of course the question is, whenever we get a watched event, we need to make sure that we send it the way that Zookeeper communicates.
02:41:45.875 - 02:42:22.457, Speaker A: Watched events. We can take some inspiration here from Source IO So if you look at it here, watched event, it's somewhere down here. Let's see if it's readable. Handle response handle chunk. Yeah. So xid minus one is an event. I think, if I remember correctly, I guess we can search for -1 and see if it pops out anywhere else.
02:42:22.457 - 02:43:33.035, Speaker A: Yeah, I don't think so. So the idea is that because any response you get that is that is a watched event doesn't really have an associated request with it, right? It could, but it does not necessarily have one because it could be just like you got reconnected or the server is now in read only mode or any such thing. So what we want to do is down in poll read. So remember we had this X equals 2 for the heartbeat we're going to have. If it's minus 1 then we got a watch event. And now the question of course is here it seems like it just like wraps up the raw response, but I think we want to parse it out here probably. So what is watchmessage Watch watch message.
02:43:33.035 - 02:43:58.481, Speaker A: I just want to see what the. I guess we could also check the jute file. It seems like watcher event does not. All right, that's curious. So if you look at this, it still has a header, which means that it has an X ID and an op code. Ah, no. Right.
02:43:58.481 - 02:44:33.315, Speaker A: So this is a response header. So response headers have xid. The Zookeeper ID that is used to keep track of how many is essentially a way to guarantee consistency. We haven't really seen it in play yet it'll come back a little bit bit later potentially when we do reconnects and an error code and in our case the minus one is the X ID and we can ignore all the other values. The question is how do we parse what follows? And we parse what follows as a. Where was it? Watch event, Watcher event. Right.
02:44:33.315 - 02:45:56.327, Speaker A: So it's just one of these things. So. So the question is what do we do here? And I think the answer is simply that we just parse out a watcher event which we could do in a couple of different ways. I think what I actually want to do here is impl. Read from for watch watch event Right, because we have this now watched event thing and we want to construct one of these essentially by reading out what's in what's on the wire and we have the setup from here specifically we know that we here we know that we first read out the type. So the type is going to be a read read I32 we know that all of these things are big endian I guess I can't use type it's going to be W type for watch type. We also have a state which is the state of the keeper client runtime so really know what that translates to.
02:45:56.327 - 02:46:58.295, Speaker A: I guess it's. I guess we could look at this here. Oh, this is. What does the server think that the state of the client is? So for example it might know that we have been disconnected and then what was the last thing was a ustring and a ustring is the same as we do use for paths and so that is really just a length and then bytes so we will just do read buffer I think path is. I guess if. Do we have a read string? We do, right? Yeah, read string and then we can return a watched event because the. The watched event remember has an event that has these fields so and now we have all the things we need.
02:46:58.295 - 02:47:47.795, Speaker A: We have a watched event type which is the W type as this we have a keeper state which is the state as this. Because remember the repr for watched event type is I32 and same for state as I30 and this is. Oh, that's a good question. How do we know whether there's anything there? I guess we need to find out how it parses a watch message. So a watch message is an event and it gets parsed looks at the error if there's no error. This is a watched event read from. So that's in proto.
02:47:47.795 - 02:48:15.593, Speaker A: I've seen proto before. Yes, this is basically the code that we wrote. Right. It looks like here it's always some. That doesn't seem right. Why would it always be sum cut chroot? That seems very odd. What does this do? Oh, right.
02:48:15.593 - 02:49:05.245, Speaker A: So in Zookeeper, when you connect to Zookeeper initially, you can set the starting path you want to operate. So that path essentially gets prepended to every request you send to the server. And what this is doing is if you get an event back, you get the full path from Zookeeper and this cuts off that from the beginning so that your response is sort of consistent with you having connected at that path. I don't think we particularly care about that. I do really wonder why or how path can ever be none given the code as written here. It's always some, which seems weird. It's a good question.
02:49:05.245 - 02:49:38.015, Speaker A: Find watches. What does the protocol say? It doesn't really say anything. That's a little awkward. And there's no keeper exception for this. That helps as much. Hmm. Well, this will be none for session related triggers.
02:49:38.015 - 02:50:05.429, Speaker A: Session related triggers. Oh, so they probably manually constructed these in certain places. That would be my guess. So like if you. If you get disconnected, for example, then the library will just construct a watched event for you. Apparently not there proto maybe. No, that's just that const.
02:50:05.429 - 02:50:37.725, Speaker A: We know it's not IO. It could be. Yeah. So here for example, notice that there's like we need to remember to send a watched event if we got disconnected and then reconnected. But it seems like that's not actually used here everywhere. It could be that we just make this. Yeah, let's just have this not be an option for now and just have it really just be pathetic.
02:50:37.725 - 02:51:28.785, Speaker A: Those will go away and then this we will make a comment for now because currently it really is always just a string. Oh, did I not? Huh? Oh. In response. Right. So the this is going to be keeper state and watched event type. Oh, that's awkward. Am I not allowed to cast these even though I know the ripper is the same? That's really annoying.
02:51:28.785 - 02:52:18.425, Speaker A: So I know that there are crates that provide this. So this is what the one of the derives we got rid of in the original code basically did for you. Does Rust really not have this? So repr. Rust Repper autoconvert. I guess that's not helpful. I32 for example. And cast is what I want.
02:52:18.425 - 02:52:54.553, Speaker A: Okay, well that's mostly unhelpful. It could be the namicon has something. So the namicon is really a really handy thing for. Well, that's basically the same. It's really handy for when you need to do unsafe stuff. But apparently other wrappers repr fieldless Enum without a wrapper is still native. Any repr cost to be.
02:52:54.553 - 02:53:43.685, Speaker A: Yeah, but apparently it doesn't give us conversions. This sounds like something. Someone should submit a PR to Rust to like deal with this because what we're going to have to do is impul from I32 for keeper state from I guess this can be code. This should be because we're going to have to do it unsafe. We're going to have to do code as keeperstate. I don't even know if I'm allowed to do that. But keeperstate is an i32.
02:53:43.685 - 02:54:11.419, Speaker A: Hmm. I really don't want to enumerate all the possible codes, I guess. Okay, so I guess the reason they can't implement this from is because it's not technically true. Then you could give it a value like so for keeper state. If you gave it the value seven, there's no Enum variant that corresponds to that. So that's got to be why they do it. All right, fine.
02:54:11.419 - 02:55:10.105, Speaker A: So we'll have to match on the code and we will basically take all of these, put them down here, remove all the comments and then we will do qa. Actually, no, I will. Yeah, sure. This, this, this. Sorry, I'm not doing some vim magic. What? Why doesn't it let me do that? That should be a totally legal macro. Okay, so what I'm doing is recording a vim macro which are really handy for these kind of mechanical conversions, but for some reason it is not wanting to let me do that.
02:55:10.105 - 02:55:55.325, Speaker A: There we go, man. I guess these are all also. That did not what I wanted it to do. Not stick with the minus. This is minus 112 and this is going to be self. Self. How about now? What? Oh, I guess N underscore is unreachable Unknown keeper state this, whatever the code is.
02:55:55.325 - 02:56:24.205, Speaker A: And I wanted to print it in hex variant SASL authenticated not found. Oh, is this. Can you not name variants through self? Oh, there's an rfc but it hasn't been done yet. That's why I think I have to do this. Yep. And now we're gonna have to do the same for watcher event type. I guess I can copy most of this.
02:56:24.205 - 02:57:52.045, Speaker A: Is Rust hard to learn? That is a good question. I would say that if Rust is your first language, it is probably not that hard Hard if it's your second language, it is probably much harder because there are a bunch of things you sort of have to forget from the stuff you did before specifically things you think are okay that Rust will not let you do. And so in that sense it is harder. But I don't But I think you end up spending more time fighting with the compiler in Rust whereas in other languages you're going to run your code and then have it be wrong and then have to debug it. And so it's a very different way of developing. And that's why I think it feels very difficult for people who are new to the language sorry for people who have experience in other languages and are new to the language and then type code and then we're going to take all of this, delete these, delete these and then we'll do qa. Ah, that's not gonna work.
02:57:52.045 - 02:58:52.467, Speaker A: These are all different. This, this. Oh and I guess this has to be watched Event type this. I want to learn Rust to help developing a game. Well, it depends whether you have any experience with programming from before. I think learning to program is going to be is sort of a challenge no matter what language you choose. I think Rust is probably not the most beginner friendly language, but I also don't think it's very hostile to new developers.
02:58:52.467 - 02:59:37.505, Speaker A: You have to think about things like types which you don't have to quite as much in languages like JavaScript or Python. So in that sense those are easier to learn. But it sort of depends what you're trying to use it for. So the second question here is for what development purposes would you use Rust? And I think for me at this point I use Rust for everything. There's something to be said for use the right language for the job. I have generally found that for the kind of things that I do Rust works really well in part because it gives me I often want low level control for performance and I don't really worry about having that low level control. But in part that's because I'm so comfortable with the primitives.
02:59:37.505 - 03:00:33.271, Speaker A: I do think that for it is probably still not quite there for things like if you just want to code something up quickly. I don't know if the Rust is the right tool for you, but at the same time it saves you a lot in debugging. I think the language still is quite verbose for things like Async programming, but that is something that's changing with with Async Await. There are still some things that don't perform quite as well, but it's a lot rarer now because LLVM is the same optimizer that is Used for C code often. I don't know. I think there are some very specialized use cases like parsers where Haskell is really good compiler development, where Camel is really good. Websites where dynamic languages are often considered very good.
03:00:33.271 - 03:01:34.101, Speaker A: Although I think there's some advantage to static typing there as well. So I think in general, like Rust has pretty broad applicability actually, but it is I think a bit more of a pain to learn than other languages, in part because of this notion of ownership which means you sort of need to. You need to understand at least a little bit of the underlying memory model. This gives us a watcher which we ignore now and protomod this need to use future self. Oh, I guess this can now use where's our NPSC channel? This. All right, let's see how that works. So we currently send nothing on the default watcher.
03:01:34.101 - 03:02:28.697, Speaker A: That's fine because we're not actually getting any watched events. But at least now in theory we have the watcher. I guess we don't send anything on it yet because we don't parse out what the watched event is. But we should be able to do that now, right? So we should be able to take watched event. What's the implementation we have for it? Response. So read from is what we want read from. So we're going to use self I guess use request read from and we're going to read from the buffer that we have buff and then we will do self default watcher.
03:02:28.697 - 03:03:21.475, Speaker A: So here maybe send to the right to non default watcher. So if the users registered additional watchers we want to make sure to send to Those instead. Rust 2018 edition will be an improvement for learning. I think that's true especially things like changes to the module system, non lexical lifetimes being on by default. I think it deals with a lot of those issues that you will run into very quickly and just makes them easier to deal with. I think that's probably true. Unbounded send and we want to ignore the error here because the user may not care about events.
03:03:21.475 - 03:04:08.255, Speaker A: So if the user drops the watcher we don't really care. We still want to try to send it. If it fails then that's still fine. Use proto response Read from Isn't that what I did here? Oh yeah, right. Like things like this will be fixed in the 2018 edition that you don't have to put self everywhere and this is no read from in oh, response types, different mutability read from buff. I think that's fine. We just do this.
03:04:08.255 - 03:04:58.905, Speaker A: Great. So now we have the stuff that's going to tell people about watched events, except there are currently no watched events. So let's do a diff and dot and then send, receive and send watched events and notify about watched events. So now we have the basic mechanism for dealing with these watched events. And then I think the next thing we want to do, of course, is have the user be able to issue a request and say that they want to watch it. Right. So there are a couple of these in particular what we could do is we could add this for exists.
03:04:58.905 - 03:05:32.151, Speaker A: We could say watch. I'm not sure that's the nicest API, but I guess we can deal with it. So watch is. Ooh, that's a good question. So xist takes a watch, which I assume is 0 or 1. Let's check that exist request string and bool request. Yep, indeed.
03:05:32.151 - 03:06:13.415, Speaker A: So this is gonna be if watch then 1L0. Right. So this is a pretty straightforward change to exist. Just saying that whether we want to set a watch or not. And the idea is that if you set a watch, all that really does is say that if the condition for this exists changes, then you will send on the default watcher. Apart from that, the API will not change. And so the way we'll do deal with this is this will be false, this will be true.
03:06:13.415 - 03:07:20.405, Speaker A: In fact, we could even do, we could even do true and true. And what we should see is that the watcher should get two events, it should get one event for it should get one event for this exist suddenly turning false once the delete happens. And then one for this exists. That will become true once the or that it does no longer exist when the delete happens. Actually no, this won't trigger. This will be false. But we can do ZK exists first up here ZK exists.
03:07:20.405 - 03:08:01.773, Speaker A: So we'll do one of these first and assert that it does not exist. But set a watch and then we'll do a zk. Ignore the stat to do this, like so, right? So first we check whether exists and it should not. And we set a watcher saying if it ever does exist, let us know. Then we create it and this should cause a send on the watcher. But we haven't checked that watcher yet. Then we check exists after it has been created and tell it to set a watcher.
03:08:01.773 - 03:08:41.765, Speaker A: Then when it gets deleted, it goes away. So that watcher is triggered again. And then WeChat exists, but this has nothing to watch. I guess we, we could set true, but we would never be notified. And so now we then do and then I guess, yeah, zk. So here what we're going to do is we're going to basically assert that we got the same number of things that we expect on our watcher. Why is drop called on zk? Yeah, so the reason it's called here is because the reactor would not become idle.
03:08:41.765 - 03:09:20.545, Speaker A: So if the ZK is open, that means that we could still send more zookeeper requests and therefore the packetizer won't shut down because it knows that it could receive more requests. So it's only once the last handle to the packetizer is dropped that it exits and becomes idle. And so this shutdown on idle, if we reverse the. Or in that case got rid of this. This would never finish because the packetizer would never finish because it's. Because it is idle and therefore it doesn't shut down. So that's why we need to drop it, I guess make packetizer idle.
03:09:20.545 - 03:09:44.235, Speaker A: Just to make that clearer here what we want to do is we want to take W and we sort of want to. We want to receive twice. Great. I'm glad. There are a couple of ways that we could do this. Features 0.1 if we find where stream.
03:09:44.235 - 03:10:23.659, Speaker A: So there are a lot of methods on stream we could just collect it. The problem is it won't be done. So I think what we want to do is. That's a good question. What's the best way to check this is the right thing? I think what we want to do is call. Yeah, here's what we want to do. We're actually going to take out the.
03:10:23.659 - 03:11:03.417, Speaker A: We're going to get the watcher back as well. And then down here when we drop the ZK and then shut down on idle, we're still here going to do. We're then going to do w.wait.count and we're going to assert that there are no more events at the end right during we know that in fact we could move this further up if we wanted to. So maybe that's what we should do. Well, that should be a little bit tricky. Yeah.
03:11:03.417 - 03:12:01.345, Speaker A: So down here what we want to do is sort of into future and then I guess map X zkx so we carry ZK along. And then here we're going to get something like ZK and into future gives us a stream future which is just a future that gives both the item from the stream and the S. So in this case this will be event and. And the watcher that we get back and we here want to assert equals event. Some I don't remember what the type is for watched event. But this is basically to check that we got the right watched event. I guess we can do a map and then we give back CK&W.
03:12:01.345 - 03:12:43.325, Speaker A: Actually we could do here and then again because we want to then take the read a second element because we know we should get an event from the first, right? So when we initially we call exist and we watch. So we get one event when we created and then we get one event here because we watch and then delete. So we should get a second event down here and that event is going to be also a watch event of some kind. And then we will just do. This will just be a map. We'll map this back to ZKW so that we can extract the watcher. I had to run off for an hour.
03:12:43.325 - 03:13:22.495, Speaker A: Is it sentient yet? Almost. Almost. We're almost there. And then it can. Ooh, not found. 175 oh, into future gives a stream error, doesn't it? That's annoying. I think we're just going to ignore that because it's a test.
03:13:22.495 - 03:14:17.485, Speaker A: I'm just going to say that. All right. Because the reason this gets complicated is because if you call into future on a stream, what it gives you back is a future where it either resolves into the item that was y yielded and the stream and the error is the error that was yielded and the stream so that you can keep operating on it. And so here we want to map out the error, we want to ignore the stream if an error happens and instead just give out the error. That's the same thing we'll do here. Let's make this an inspect because we only really care about the event. And I guess we could do this here and then map it to this.
03:14:17.485 - 03:15:06.247, Speaker A: This is actually given zknw, no method map error for that thing. Because this has to be here. Yeah, it's a very dotted code. It's true. It's really annoying because testing future space code so often turns into this because you have to like do this, then do this, then do this, then do this. This is where like having monadic syntax would be really nice. Like if you could do use do notation here or something.
03:15:06.247 - 03:16:02.695, Speaker A: And that is basically what we're going to get with Async and await, right? Then this would be something like let stat is await this. Right? We could write this as synchronous code and then this would all look so much nicer. So with await this will become better. But for now we're gonna have to deal with this. Sadly 175 expected empty found failure error. I feel like that's probably not true. Oh, right.
03:16:02.695 - 03:17:01.295, Speaker A: Actually, right. This has to be a failure error stream error. E setting the watcher that's going to yield twice. And you're also setting the same watch a second time. So. So watchers in zookeeper are triggered only once. So here, for example, this watcher will not trigger again if food changes again.
03:17:01.295 - 03:17:32.485, Speaker A: Watchers are always single shot in zookeeper. And so this create will trigger this watch. This. Sorry, this delete will trigger this watch. And nothing will trigger this watch. Therefore there should only be two inspect exists. But, but, but, but, but, BUT.
03:17:32.485 - 03:17:53.523, Speaker A: 178 oh, zero. Oh, right. Zero. And then into future. Yeah, I know. You end up with futures. You end up with a lot of this like sci fi, like speak.
03:17:53.523 - 03:18:48.035, Speaker A: It's pretty great. This is not okay, because it requires the output is an error. What expected result failure. It shouldn't matter. But something is fishy. This writing, like really combinator combinator heavy futures code is not nice. It's basically complaining that I'm sort of no longer a future here for whatever reason.
03:18:48.035 - 03:19:30.375, Speaker A: Oh no, it's still that. Although I guess technically this could now just be this. But it's complaining that this does not give me a result. So this futures item is not a result. That is true. This futures item is. Ooh, is that because I misread this somehow? No, it's item is an option item and the stream itself.
03:19:30.375 - 03:20:13.515, Speaker A: Right. So this is a like an event and W which is all I'm mapping it to. Right. Those are the same. So what is it complaining about? Weird. And then it's complaining that I can't use inspect because whatever comes back from this is not a future, which is just not true because StreamFuture, which is what I get from into future. Hmm.
03:20:13.515 - 03:21:09.715, Speaker A: So the W we get from up there for whatever reason, it's complaining about the closure. Right? The closure takes nothing and a stream. This that. It's saying that the output of this needs to be a failure error. Expected result found failure error. I think it's complaining here. Oh yeah.
03:21:09.715 - 03:21:31.525, Speaker A: Bail returns a result. Failure error, not a failure error. There we go. It is arguing with the compiler. Yeah, it's basically what we cover in all these streams is arguing with the compiler. It's actually just one long stream that is all about argument with the compiler. Although the compiler is right here.
03:21:31.525 - 03:22:09.215, Speaker A: Like the bail macro actually returns. It's like return error, format error, but map error should not return and it should not wrap it in a Result it should just return the inner thing. And so that's why this has to be format error, not bail. And the compiler was correctly pointing that out just in a really unhelpful way. In particular, because like the error is on this line. It's complaining about the return type here, which is because that's where the this return type is not illegal, but this return time is. It would be useful if it could like point me inside and see this is where that result came from.
03:22:09.215 - 03:22:39.585, Speaker A: But I guess not. That is true. This we knew would happen because this is going to be a watched event. And so the question is, what kind of watched event are we expecting here? Let's see. Types watch. So I think the event type is going to be watched event type. We're expecting to first get a node created, right.
03:22:39.585 - 03:23:35.563, Speaker A: And with keeperstate as keeperstate, I guess sync connected, probably sync connected is just like everything is okay connected and the server is connected. Yeah, and we're expecting it to have a path and that path should be foo. So that's the event we're expecting to see. Let's see if we indeed see it. And down here we're expecting to see node deleted. And it's saying can't do that because it is so annoying that you cannot compare the a reference to a T with a T. It.
03:23:35.563 - 03:24:32.255, Speaker A: If T implements partial eek, it's entirely unnecessary. Oh, did I not derive partial eek here? Partial eek and also probably eek partially this as well. Partial. In theory we could implement hash here as well, but I don't think that's particularly important. All right, let's see what happens. Well, it crashed, but got okay. What backtrace? Where? Protomod 203.
03:24:32.255 - 03:25:46.029, Speaker A: Well, that's interesting. I don't think the reactor should be allowed to disappear because the threads are still running. Also, one thing that I just realized that's sort of stupid with Async test is we don't know that it's doing any of this because it could totally be that it just like doesn't execute any of those futures and we never check that we actually get to the end. Oh, I guess we do. Because otherwise this block on unwrap would fail. So I guess that's true. Well, I mean, it's not terribly surprising actually.
03:25:46.029 - 03:26:32.747, Speaker A: So remember, if you look at the top here, see that the stack backtrace comes from packetizer exiting. Right. And that I think we've seen in the past too. If we scroll up to where things worked last time, maybe not there, but I feel like we run it and have this happen before. Maybe I'm wrong because I'm fairly sure that the reactor should not exit. Where is it that we have? That's right. You read code for the watched event is wrong.
03:26:32.747 - 03:28:10.815, Speaker A: You read code for the watched event in response. Why do you think it's wrong? Because I think that's right. Because a watcher event is a type a state and a path where these are I32s type state path I32 I32 not in the response. So in like proto somewhere like here, most of meant read from buff. That should also be fine. Unbounded send E. No, I think this is right.
03:28:10.815 - 03:29:02.281, Speaker A: What makes you think that it's wrong? Sorry, what I was going to say was there's here, there's a packetizer exiting is a code that we deal with. Like if the spawn. If we run the packetizer and it exits with an error, then we print out that error. And specifically what this is saying is the packetizer future resolved with an error saying reactor gone. Right. And that is coming from Paul Reed specifically online. What was it, 203? Yeah.
03:29:02.281 - 03:29:33.343, Speaker A: So here. So when it tries to read from the underlying stream, the reactor has gone away. The question is how can the reactor go away? Because the underlying reaction actor shuts down on idle. But it's not idle because this should still be running. So that is pretty weird. I had that thought in the back of my head for too long. I forgot why.
03:29:33.343 - 03:30:21.485, Speaker A: Exactly. See, if the XID is minus one and there was no error because that would have been labeled up here. Then we parse out the watch to win from the buf and the BUF is all of the bytes for that request, which seems fine. And then we send the event we parsed out to the default watcher. And clearly the default watcher is receiving those events and they're correct because otherwise this assert would not work correctly. Right. So all of the things that have to do with the watches seem to be right.
03:30:21.485 - 03:31:29.683, Speaker A: The question is why does the reactor crash? Or crucially, why does the reactor exit? I guess we should just for just so that we can convince ourselves that this actually does what we want we could do while we're printing stuff anyway. Godwatcher event. Actually let's run this with no capture. I don't think it should matter, but okay, so we connect, then we call exists and then we call create. Then we get the watcher event saying node created sync connected foo. So that's right. We call exist again we do the delete.
03:31:29.683 - 03:32:06.037, Speaker A: Then we got a node Deleted sync connected. So all this seems to be right. It's just that when the at the very end the poll read fails with reactor gone. Oh, I wonder. No, no, because it's not. It's still not idle. Let's see.
03:32:06.037 - 03:32:56.365, Speaker A: So let's try to instrument this a little dropping ZK waiting for idle shutdown just to sort of see where. Yeah. So notice here that the where is it waiting for idle happens up here. Right. And then it takes a little while before it shuts down specifically. So this is where it fails. So it does fail after we call shutdown on idle.
03:32:56.365 - 03:33:50.755, Speaker A: But why is that a failure? Try to set watch to false in the last exists here. Nope. In theory. All that should mean is that we'll get another response. I don't think shutdown on idle should close any ongoing connections. That seems really odd. Okay, so here's what I'm going to do for now.
03:33:50.755 - 03:34:57.065, Speaker A: Packet exiting. If E kind is IO kind. Wait, isn't it IO do we not have IO IO error kind Other rust IO let's see. Give me IO error here somewhere. So IO error. So kind gives me the error kind which just should be other. The question is, how do I pronounce? How do I easily get at the kind other error? I want to get at the error.
03:34:57.065 - 03:35:54.975, Speaker A: Okay, so if it's this, then let's do E into inner. That's really unhelpful. I don't really want to format this. I guess I could, but it's a little silly. This is a just error sentencing. Hmm. So I mean, the really silly way to do this is if format this is equal to this.
03:35:54.975 - 03:36:45.915, Speaker A: Or I guess even worse is equal to this. Right. So this is one way of doing it where? If not that, then this. So that way, it's basically a way to make it be quiet in theory. Except it apparently didn't work. That's so weird. Well, that's what I get for trying to be clever.
03:36:45.915 - 03:37:10.665, Speaker A: So it is interesting because the is deeper format guaranteed to stay safe. Not at all. You should never do what I just tried to do, ever. It's a really bad idea. This was more. I'm trying to find a way to just quiet that particular error about the reactor going away. Although the reactor just really should never go away until we disconnect.
03:37:10.665 - 03:37:59.415, Speaker A: Oh, is that what happened? I don't think so. Because, like, why would the reactor. Oh, it does enter that side, though. So to be clear, what we're doing here is we're matching over our poll read and our poll write. We're Trying to figure out whether we should exit. And in this case, this is saying that poll right has exited. So we've been told to exit, and the right socket has been closed down.
03:37:59.415 - 03:39:15.113, Speaker A: At that point, there really is nothing else for us to do but exit. And what this is saying for. For whatever reason, even though we return not ready, huh? Even though we're turning not ready, the Tokyo decides to shut down the runtime, which seems like it's wrong. It is totally true, though, that in this case there is no reason for us to continue because the right socket has been closed. Actually, no, that's not true. It just means that we've written out everything that's in our buffers, nothing more to write, and no more requests. So the question here is, what do we do? In this case, we certainly can't send.
03:39:15.113 - 03:40:21.865, Speaker A: That's. This is not true. The observation is that it could be that there's more data that the Zookeeper servers tried to send to us. I guess the question here is, are we shutting down the outgoing connection? Because this. Yeah, so. So this does not actually mean that the connection has been shut down. All it means is that we've flushed our outgoing buffer and we know that there are no more incoming requests because the incoming channel has been close to us.
03:40:21.865 - 03:41:09.395, Speaker A: And so here we could totally be nice and send to the server, like, look, I want to close my session, but we don't technically need to. It's fine for us to just shut down the channel altogether, but in theory we should finish reading from the client too. So I guess we implement closed session. Shouldn't be too hard. Where's my proto here? Close session. Really? Not here, but here. Close session, please.
03:41:09.395 - 03:42:04.135, Speaker A: Yeah, so this is a very similar thing to what we had with Delete, where there's no response. So I think all we want to do here, it's sort of like a ping almost, actually, except we might want to do it in a slightly more rigorous way. Yeah, let's just do it with requests. There's going to be an empty request here. I guess this is just going to be close session and trying to write out a click. Close session request. Close session.
03:42:04.135 - 03:42:36.025, Speaker A: All that really does is it writes out the opcode Close, I think, and nothing else. Empty body. I don't know what the 0 here is. Fn request. 0 is the X ID and watch, which is going to be none. So that's all fine. So if we send a closed session, all we really do is here.
03:42:36.025 - 03:43:19.805, Speaker A: Close session. Just one of these. So here, I guess we will do. Oh, I See that's why we don't actually need this. The reason is that because the incoming channel has been closed, we're not going to send a request in this way anyway. We're really just going to send this opcode and so this will be very similar to sending our ping in that we do this send close session. So we're going to do this, I'm gonna send a closed session.
03:43:19.805 - 03:44:14.935, Speaker A: So like so basically what we're trying to do, we're gonna do all of this and then we're going to shut down the outgoing channel so that the read so that the server will eventually shut down the client to us so that we'll get ready from read. I guess the alternative here is that we make. Once we get the response we're fine. Okay, so this will be x id 0 the length will be the same. No xid should be 0 here. Minus 1 is for watch events, minus 2 is for for pings. The reason I picked 0 is just because that's what was used here.
03:44:14.935 - 03:44:43.988, Speaker A: Empty request. So if you see this is in rust zookeeper at least they use x id 0 for closing the session. It might not matter. I think we already started one if I remember correctly. We do not. Okay fine. So I mean I guess we could set this to 1.
03:44:43.988 - 03:45:11.195, Speaker A: Well we used ah we use 0 for the connect so we might as well use 0 for the close as well. Right. Once you get a response I think you're allowed to reuse the the id. I don't think they have to be unique. Right. So all we're really doing is doing that and then we'll send not ready. In fact then we will.
03:45:11.195 - 03:46:53.185, Speaker A: This is where I want tail recursion but I think we have to call self poll and the reason we have to do this is because we need to go through this process of writes again. This what we wanted to avoid with pings right Is that at this point we. Oh actually no, this is not where we should do this. We should do this the moment we get exiting this stuff self exiting here. So this is the thing that just pulls the enqueue until we get no more things and once we know that then we know that we might as well send close session right. And this happens before pull right so that means we don't have to do this like self poll trick and then pull right Will make sure that we get notified again right and now in pull right we know that here if self exiting and we have written out our entire buffer and we've flown flushed it then we know that there's nothing more to send. And so therefore we can do self stream shutdown, which is Docs rs Tokyo.
03:46:53.185 - 03:47:46.165, Speaker A: Ooh, we might actually not have a way to shut down. I think we do. I think for Async, right? There's a great dot shutdown. Like. So I guess this is really a try ready probably. And so this means that eventually we're going to. Oh, I guess this might end up shutting down multiple times, which is not ideal.
03:47:46.165 - 03:48:25.535, Speaker A: So we're gonna have something like. We're gonna need something like a. How are we even gonna do that? Sh. So the issue here is imagine that shutdown fails. Or like shutdown is not ready, it's not able to shut down the stream. Then we would end up with the packetizer being pulled again. And when it gets pulled again, it calls poll right again and then pull call right.
03:48:25.535 - 03:49:23.825, Speaker A: Actually, I guess because the shutdown didn't succeed, it's fine for us to try to call flush again. It just means that we do a bunch extra system calls that are sort of unnecessary. So let's leave this as it is. That should be fine. And now in theory, at least up here, If Xid equals 0 and not self first, then this is shutdown. And I guess I don't actually know what the server responds to a shutdown close. Oh, it's just an empty response, right? So there is nothing really to do.
03:49:23.825 - 03:50:17.345, Speaker A: So the idea is that at least in theory. In theory, server should now shut down receive end, right? That's the observation that we send a closed session and then we shut down the right end of the channel. And now in theory, the server should send the final response and then close the connection as well. Do you really need to self poll in the case where write equals ready plus exiting? Oh, sorry. No, no, no. This was supposed to. This is async not ready.
03:50:17.345 - 03:50:58.477, Speaker A: Oops. And the reason this is not ready is because we're not actually ready until we hear the response from the server. The reason this matters is there may still be outstanding watcher events that the server wants to notify us about. And we should be nice and wait for that. Expected async. All right. Async ready 190What? Expected async found item.
03:50:58.477 - 03:52:05.645, Speaker A: Oh, right. Ready is a thing that holds a thing. Huh? So this is going to be shutting down send. So this is shutting down writer. I'm just adding some debug statements for us here so that we'll be able to see what's going on. Where's the here response to close session? And then I guess also down here, God responds to heartbeat. Can you combine the last two match arms? I could.
03:52:05.645 - 03:53:06.093, Speaker A: I sort of want to keep this one explicit just because I wanted. I wanted to add a comment to it and did not we have written out. Actually no, you're right. My response to this timeline 8 we don't need that anymore. Still failing. That's because the reactor is disappearing. Why on earth is the reactor disappearing? So one sort of silly thing we could try here is thread sleep time duration 6, 5 just to see whether it eventually tidies up.
03:53:06.093 - 03:54:35.735, Speaker A: Ooh, connection closed with four bytes left in buffer. Really? And poll read what got response to close session shutting down Writer pull read read more bytes. So somehow everything works correctly except that we get. We get more byte. What? So it's telling me that I get 4 bytes after I get the response to the closed session. I want to know what those bytes are because I think that sounds really weird self.inbox in fact I want that out in hex.
03:54:35.735 - 03:55:35.105, Speaker A: Really? Really this way. Fine. I get four zeros at the end. The length of closed session is that long, right? So an empty response, if I haven't. If I've been paying attention then empty response just reads nothing. Which in theory should mean that it reads. It should mean that it reads out the xid, the zxid, the error code, the length of the beginning which is 16 bytes.
03:55:35.105 - 03:56:26.845, Speaker A: Then it gets. That's when it prints the response and then it's going back around and saying that it has another four zeros. Now the acknowledgement of the session close we already got. So see how if you look here we get this got response to close session and that is printed here when we get a response that has XID0 and so that's already happening, I guess. Actually one thing that's worth pointing out here is that this is currently going to drop error if there's an error. I think this is gonna. I don't really want it to search.
03:56:26.845 - 03:57:24.169, Speaker A: I think I want if let if some error then bail failed to close session. Bad response to ping just to see if that's what's going on. That is true. Doesn't look like we get an error, right? It says got response to the closed session. So that is the length of 16. Wait, length is 16. Length is 16.
03:57:24.169 - 03:58:39.735, Speaker A: Why would the length be 16? There are only three fields of oh, the ZX ID is 64. Okay, so that is 16 bytes. Cut the responds Read more bytes have zero pull write packetizer pulled pull read read more bytes have Ah, wait a second. So we go through this, we need four bytes. We pull read, we get zero. It's saying inland is not equal to zero. So what is the length here? That means that we got a length field, and that length field is zero.
03:58:39.735 - 03:59:46.875, Speaker A: So I guess maybe just like null terminates its entire session. I guess I could be. That's so strange. Server normally sends four at the end, so yes, that worked. And then the packager exits without an error code. I guess this Might as well print out the. Print out the bytes that are left.
03:59:46.875 - 04:00:46.415, Speaker A: Just double check that those are actually left in the buffer. Yeah. Okay, so let's leave that at 4. And now this should work just fine. The question is, does it still shut down the reactor? If I don't sleep here, what happens? Apparently it's so weird. I have no idea why it would do that. Yeah, it still shuts down the reactor after that exists, which is quite odd really, because this happens got through all futures.
04:00:46.415 - 04:01:03.647, Speaker A: I just. Yeah, I should check that. It's also zeros. You're right. Shutting down writer got through all future. Okay, so it does do that. So weird.
04:01:03.647 - 04:01:20.205, Speaker A: You're right. If. If it is equal to zero and. And. Okay, fine. Let left. Is this.
04:01:20.205 - 04:02:12.795, Speaker A: If left Len is 4 and left is equal to. I think I have to do this should be the same. Yep. But for whatever reason, the reactor is gone. But as far as I understand shutdown on idle. It should not shut down the reactor until all the spawned futures have exited. And they clearly have not.
04:02:12.795 - 04:02:54.905, Speaker A: So I think this is a bug in Tokyo. I guess. Let's check exactly what the docs say for shutdown on idle. Runtime Runtime protocol spec for zookeeper. No, it's awful. Does it may have to do with the W dot Wait at the end? It never gets there. Well, I mean, it.
04:02:54.905 - 04:03:10.245, Speaker A: It does, but I don't think that should matter. I can try it. I don't think it matters. I think it crashes before that. What? Oops. That was not the command I wanted to do. But luckily that didn't delete anything.
04:03:10.245 - 04:03:58.595, Speaker A: What? Why is that even relevant? Also notice that it's not closing correctly here now. Yeah, but the futures haven't all returned Async ready. Because the. Because the packetizer is not returned yet. And like the very first thing we do in the packetizer is we spawn the packetizer. Right? So the packetizer is still running and should continue to be polled. Because it hasn't exited yet.
04:03:58.595 - 04:04:22.871, Speaker A: Right. It only returns async ready if it prints packetizer done. And it never prints packetizer done. Oh no. Okay, so the reason why this works is just because. Just because the main thread exits too quickly. Yeah.
04:04:22.871 - 04:04:50.885, Speaker A: So you see here, if I wait at the end, then I get to see it crash. If I do this, the program exits too quickly for us to observe the crash. It does not actually fix the issue. Yeah. So the observation is that the. Yeah, great. This should not be necessary.
04:04:50.885 - 04:05:26.895, Speaker A: So the question is, what does shutdown and idle actually do once it becomes idle? Oh, I'm being stupid. Shutdown on idle returns a future that you have to wait for. It is not a blocking call, because futures aren't blocking calls. Hey. Okay, so we now have exist with watchers. Create and delete. Heartbeats are working.
04:05:26.895 - 04:06:14.701, Speaker A: So the, the question now is whether we add get data, which currently there's no way of reading data, or whether we try to add reconnection. Reconnection will get into things like ZX IDs because you need to negotiate with a new server that you're connecting to what version to start reading from. And get data is more for completeness, but it will let us return data through these channels. Or we could try to start tidying up the API. I think get data is probably a useful thing to add. Great. Yeah.
04:06:14.701 - 04:07:07.957, Speaker A: So I guess it's really up to you whether you want to see get data or reconnection. Reconnection is probably going to be harder, but get data is more useful for X and inputted code return success. Nice, isn't it? What is it? Step three? Profit. Yeah, I think we'll probably just have time for one more because the stream is already going pretty long. Yeah. So what do you think? Should we add data retrieval or should we add automatic reconnection? I think those are the most feasible and useful options. One other thing I'd like to point out while you have you all here, is that this crate, as you, as you observe, there are.
04:07:07.957 - 04:07:26.175, Speaker A: There are a lot of just like functionality missing. That's not as you. As you can see from when we implemented Delete, for example. Right. And create. For that matter, it's actually pretty easy to add methods like that to add additional API operations. So if you want to try your hand at this, because I'll push all the code, right.
04:07:26.175 - 04:07:55.535, Speaker A: You should try to submit a pull request where you add. If you look at the Zookeeper API for the original crate, right. There's things like set data. If you look at the Java API, there's a bunch more operations. Operations, right. So there's get acl, get children, get data, get various session state multi operations, setting the ACL on existing node set data. Ooh, transaction.
04:07:55.535 - 04:08:52.543, Speaker A: I feel like this multi thing is something we'll want to take a look at, but so if you want to try adding some of these, then you absolutely should. The other thing we really want to add is add all of the documentation from the Java code into our crate so that the crate is actually fully self documented. What are you actually working on like outside of this or what is this? Auto Reconnect get data. Apparently the two of you highly disagree. So Zookeeper is a. You can think of it sort of as a key value store, except its goal is not so much to store data as to store metadata and it aims to keep that data very highly consistent. So if you have many clients that are all doing many operations at the same time, it guarantees an order of operations between them and lets them detect if there are conflicts.
04:08:52.543 - 04:09:35.655, Speaker A: And also you can have many servers that are running and sort of presenting a single key value store even though they're distributed across many servers. And it does the right thing even when servers fail or clients fail. And those kind of things get children into cow into future. Yeah, that's nice. Yeah, I mean savam, I suggest that you watch part one before you watch this because this is starting pretty deep into it. You could also watch some of the other streams I've done and then you redis for metadata sort of. Although you should think of it as high consensus or sorry, high consistency for the data.
04:09:35.655 - 04:10:30.495, Speaker A: Let's see. Are you a Russian hacker? No, but then again, wouldn't I say that if I were a Russian hacker? But yeah, I would watch some of the previous streams and some of those might actually give you ideas for small contributions you can try to make just to get yourself familiar with it with a code base you already know something about. Let's see. All right, I think that Such a good question. So Get Data will be fairly straightforward. So let's start autoconnect because that way one of you can hopefully maybe add get data. So let's do Auto Connect, which is going to be a little bit interesting, but we'll see how that works out.
04:10:30.495 - 04:11:49.225, Speaker A: So first, if so. Okay, so one thing that's really neat is because we have this, this sort of single packetizer business, we can have all reconnects handled through that. So to give you some idea, there's. Where is this? Over here somewhere. Okay, so this text is sort of important. Let's make this bigger because I hate websites that do this. Don't mess with my line height.
04:11:49.225 - 04:12:08.479, Speaker A: Don't mess with my Font. Don't mess with my font size. Do any of those things. Thanks. Much better. See how much better that is. Right.
04:12:08.479 - 04:12:32.037, Speaker A: So the, this is sort of the crucial pine port that we're doing now. Personally learning was because. Oh yeah, I've gotten a lot of questions about act exposed web. We might try to do something on that. That host name. Oh yeah, I'm pretty happy with my hostname. Yeah.
04:12:32.037 - 04:13:34.209, Speaker A: So the idea is that when you initially create a Zookeeper session, you get a 64 bit number that's sort of your session ID that is given. So if you look at our response, the connect response, it has a session ID and it also has this password. And the idea is that if you ever have to reestablish a connection with a new server, you send along both the session ID and the password to prove that you are that same client. And so we're going to need at the very least this and this. There's also this read only flag that we're going to ignore for now. But the basic idea is if you're talking to a Zookeeper server that has lost its connection to other Zookeeper servers, it's not able to do writes because it has a guarantee consistency. And this, it places the client in a read only mode where if you try to do a write, it's not going to succeed because I can't communicate them further.
04:13:34.209 - 04:14:26.575, Speaker A: And so it will just return errors and then it places you in a read only session so that you're aware of this fact. And here you can use things like Watchers to realize that you are now in a read only mode. We're just going to leave that aside for now and look at this session reestablishment. So we'll need session ID and password from the connection response. And so the idea is that when you get disconnected, then you try to connect to one of the other Zookeeper servers. So remember how in our source lib currently we just take a single socket adder? But in reality what you should do with Zookeeper is there will be a deployment of many servers. If you lose a connection to a server, you try to reconnect some random other server and you keep retrying until you reach a server that you can actually connect to.
04:14:26.575 - 04:15:20.877, Speaker A: And then once you connect to some server, then you either transition to the connected state, so you reconnect, send it to your session ID and your password and then it responds back, okay, your session is good again or the server will respond saying your session is expired. And at that point, Right. So the idea is that the, the idea is that if our session expires, we're just going to try to connect to a new server and establish a new session and we'll do that. This is saying that this should happen internally in the library and maybe that is true. They say they have some like heuristics to make it more efficient. We probably won't implement those. We'll just say that if we, if we are told that our session is expired, we'll just return an error to the client.
04:15:20.877 - 04:16:17.975, Speaker A: Saying we tried and failed, I think is basically the idea that if at that point we tried to reestablish the session and we couldn't reestablish it quickly enough so our session expired, then good luck, you got to connect again. We might end up making it fit more with this text later, but for now let's leave that. The other note that's important here is that we don't deal with such an expiration. It's not like we start a timer and after certain amount of time it is considered expired. It's we try to connect and then the clusters or the Zookeeper servers, they are going to decide that we have expired and then do all deletion of all ephemeral nodes and such. And then once it reestablishes contact, that's when it's told that its session has expired. So let's see.
04:16:17.975 - 04:16:44.305, Speaker A: So connected partition, then we're disconnected. After a while we connect and we're told that we have expired. Yep, these are pings. We've already dealt with that. Perfect. All right. Ooh, session moved.
04:16:44.305 - 04:17:27.535, Speaker A: Yeah, I mean, we don't really care about that for now. So the first thing, let's just for now stick with the case of there's only one Zookeeper server. So we're just gonna try to do this in terms of reconnecting to the same server. And then we can expand it to having a list where we just like try the round robin or something later just to avoid shaking up the API too much. So what this really means is we're gonna have to handle connection errors. So the way we're gonna do this is. Huh, That's a very good question.
04:17:27.535 - 04:18:15.463, Speaker A: We sort of want to be able to continue to use the question mark operator in here. So I think what we're going to do is we're going to use the new do catch notation. Actually, we could have inner pole instead. Maybe that's nicer. A little unclear actually. No, let's put it here. That's fine.
04:18:15.463 - 04:19:21.305, Speaker A: So we're gonna have no not that, but a pole inner, which is basically just going to be our current poll return. An async item is nothing and a failure error. And that is going to be this entire function, like so. And then what we're going to have poll do is it's going to call self pollinator and it's going to match on that. If we get any kind of OK value, then we just return okv. If we get an error, then we need to be a little bit more careful because we basically want to see if the error we get is a disconnect. Then we sort of want to purge state and reconnect.
04:19:21.305 - 04:19:56.575, Speaker A: Might not even want to purge the state. It's a little unclear because we might want to. In a sense, what we want to do is any outstanding operations, we need to decide what we want to do with them. We could cancel them. That might be the right thing to do. Yeah, I think that's the thing to do. Like if we.
04:19:56.575 - 04:20:58.705, Speaker A: If someone does a. Someone does a create and it's asynchronous, right? So we send the create and then we're notified that the server went away before we even write that request to the wire. So it's still sitting in our buffers and then we get disconnected, we reconnect to another server. Do we then send it the create that was sent sort of to the previous server, it just never got sent? Or do we just prune that, give an error to the user and the user has to retry? I'm not entirely sure. This is one of the things that gets a little bit tricky in the asynchronous case. And I think they say this here too, that request received on a connection for a session which has been reestablished. I don't think this is too much of an issue.
04:20:58.705 - 04:21:45.543, Speaker A: Well, let's just write it up in the most straightforward way first and send errors to the client and then over time we can make the retry happen internally, potentially. So the question is, how do we learn that the error was a disconnect? Request goes through and gets disconnected and the server responds to the request after reconnection. So that is one of the things that Zookeeper deals with. You might not hear the response. Actually, that's a good question. I think what happens is you would get the response from the server you connect to. So this is one of the reasons why we have this ZXID value.
04:21:45.543 - 04:22:35.415, Speaker A: So if you look at request in Connecticut, this is last ZXID scene. So every time we get a response from the server, it includes a zxid when you reconnect, you tell the server what the last zxid you got from the previous server was and then it will send you anything that you have missed, like anything that's been recorded of something that's happened you haven't, you clearly have not seen. And so that's how you would hear the response. Nonetheless, the response would be resent to you if your original request in fact actually went through. What keyboard are you using? This is a Philco Majesto Touch Ninja. It's pretty nice. It has the keycaps on the bottom.
04:22:35.415 - 04:23:53.625, Speaker A: So. Right, so, so that is why. That is why you're guaranteed to still see those responses later on. The question is, how are we going to even detect that there's been a disconnect? Here's one of the problems of using failure, right? Like we don't know where that error is. So let's see, a disconnect would only be if it's poll read or poll write and poll read and poll write, all use. So there's a bail here. But that is if the server actually even in this case, we sort of want to reconnect, right? It could be that we just want to deal with any error like this.
04:23:53.625 - 04:25:00.117, Speaker A: But that would mean that even parse error, we would start over, which doesn't seem quite right. I think we'll start with the simplified version, which is if there is an error, we're going to reconnect because it lets us start from a clean session regardless. Yeah, so this is one of the things that Zookeeper is cool about is the ZXID basically allows you to give clients a very strongly consistent view of the world. And there's some rule for like when ZXIDs expire. So this is the idea of session expiration, right? Like, you know that if a client session has expired, then you can remove any state that you would have sent to that client, because when they connect, you're just going to tell them, look, your state is gone. Try again, like establish a new session. So that's the way to deal with it.
04:25:00.117 - 04:26:22.735, Speaker A: So you can think of it as. It has to keep all ZX ID replies within the client session expiration time. Now assume all error r disconnect. Right? So the question then is, what are we going to do? Like what is the. What is the protocol for doing a reconnection? This makes me think that we should put handshake inside of zk, but let's put it here for now. So certainly we'll have to remember the address. So that's going to be one thing we're going to do like let adder is equal to something we don't quite know what yet Then we're going to connect to that actually I think we're going to end up making packetizer have a state that's going to be an enum of either the thing it's going to call pole inner on which is the way it progresses or if it's disconnected it's just going to poll on itself connecting.
04:26:22.735 - 04:29:02.047, Speaker A: So what we're going to do here is basically construct a future that when it resolves will become the new inner state. Think of this as where is it here State is going to be packetizer state and we're going to have an enum packetizer state s which is going to contain the street stream all of this stuff in fact and this stuff and I think it's mostly those current state and then we're going to basically implement spacketizer state s and we're going to implement something that's sort of like poll so that's basically going to be this. Most of these methods actually are going to be on packetizer state instead. So let's go ahead and do that. So here this is going to be connected it's going to be this stroke active packetizer going to be one of these and then the alternative is that we're reconnecting those are the two states we can be in import same as import no, import is not the same as import. Impl is a way to say that these are methods on this type. So for example here if I implue nq that means that if you have an enquiry you can do like dot enqueue to call the method enqueue1x right.
04:29:02.047 - 04:30:46.915, Speaker A: So this is going to have some kind of future for reconnecting that I don't quite know what's going to be yet and then we're going to implement future for packetizer state. See roughly where this is going. So the idea is that you're always going to be pulling whatever is in inside and whatever is inside is going to depend a little bit by where did I put this? I think this needs to go further down 39 so packetizer here. So if you have an active packetizer then the way to drive that forward is just to keep doing all the things. If you have a reconnecting packetizer the future driving forward is to reconnect and so this is why a packetizer state implementing pull for that is going to be basically matching on self and if you are actually let's make this a box future. I haven't quite decided what this will be, but I think this will be an active packetizer S and the error will be a failure error. So if you are connected then you have a active packetizer and you will just call AP poll and if you are reconnecting then you will do this.
04:30:46.915 - 04:32:14.151, Speaker A: You will do try ready AP pol. And then here we're going to do something like set self to be connected. So the idea is that if you're in the connected state, then when you call poll on the packetizer state you just drive forward like you read more from the stream, you write more responses, you send replies, those kind of things. Whereas if you're in the reconnecting state, you're just going to be polling your reconnect and then when it finishes you're going to change your own state to be connected. And this of course means that this is not going to be on packetizer state but on ActivePacketizer it's going to have all these methods. Pol enqueue is the one thing it will not have because that has to happen further up. That has to happen all the way up at the packetizer level, which is actually a little awkward.
04:32:14.151 - 04:33:32.769, Speaker A: And then what this thing is going to do, pull inner right? So let's see. So we're now implementing limiting future for packetizer state and the packetizer has one, right? So if you poll a packetizer now what's going to happen? It's going to do self state poll. In fact it will first do self poll enqueue. So we'll first do that to try to get any additional connections which I think currently is being called up here somewhere, right? That's going to go away. So remember, recall that what's now left in this. So this is what we do when we pull, when we pull an active packetizer what we do is we just pull the reader, pull the writer and pull for completion of things. So we're sort of building a hierarchy.
04:33:32.769 - 04:34:46.885, Speaker A: Let me try to start this from higher up so it's easier to follow. What's going to happen is when you pull the packetizer it will first try to see if there are more requests to get and then we'll pull its interstate. The inner state is sort of a second level future that is either that we are connected and we need to drive the requests that we have outstanding forward or we're in the reconnecting state in which case we need to continue trying to reconnect. And so this is Sort of the top level. So implementing future for packetizer what that will do is if we're not exiting it will try to get more requests. This is going to have to do something slightly funky which I don't know how to do yet. So this is going to be a to do and then so first we're looking for more data and then in fact pull inner right and then we will pull the current state and if that resolves then we just give whatever result it gave and if that errors out then that is the case where the current connection has failed and we need to retry it.
04:34:46.885 - 04:36:06.245, Speaker A: So let's see, let's deal with the retry case a little bit later. I want to clean up some of the more stuff further up. So the packetizer is going to have to have some way to enqueue stuff. That's a good question. I think this has to be. There's no reason for us to pull the enqueue thread if we're currently not connected. So I think what this is going to be is if let packetizer state connected is self state only then will we pull the enqueue and in particular because then we can add things to the outbox and pull enqueue will take an AP pull enqueue will take an active packetizer S and that way we have a way to modify the outbox which is what we want to do.
04:36:06.245 - 04:36:46.051, Speaker A: We still want to use unique xids. Those are not, those are not per connection, they are global state. The reply is we're going to cancel all the replies if we fail to disconnect if, if we fail to. If the connection goes away all of this just writes to the outbox so that's all fine. Great. So if we pull the packetizer we're not exiting and we're in the connected state then we're going to try to see if there are more requests from us. Otherwise we're just going to pull the underlying state and return whatever it returns.
04:36:46.051 - 04:37:48.545, Speaker A: If it returns an error then we try to reconnect. This is going to do things like self I guess we can't actually do this yet but we will. So it's going to take all the replies channels and clear them and send errors on all of them. When we pull the underlying future then if what we hit packetizer state down here then when we pull that that's either going to pull the current state which is just what used to be there so it's going to do reads and writes or we're in the process of trying to Reconnect. In which case if we succeed at reconnecting, then we do memory. What O this is gonna. It's probably gonna come back to bite me, I think.
04:37:48.545 - 04:39:01.571, Speaker A: No, that'll be fine. Like so then we are now connected. So then we swap self with a archetype connected AP and then we call self poll. I think we need to call self poll because otherwise when we create, there's nothing that will notify the AP that it needs to be the connection that we just created needs to start doing reads and writes. Otherwise it will never be polled again. So the question is this, I guess we still need to deal with. We haven't actually written what the reconnect stuff will be, but connected is basically the old.
04:39:01.571 - 04:39:29.305, Speaker A: The old packetizer. Right. So that's activepacketizer and all that really does. I guess active packetizer is going to have to implement future if we can find it. Actually it's a little bit worse than that and know you'll see why in a second. The memswap is pretty great actually. It's not a memswap, it's a mem replace.
04:39:29.305 - 04:40:16.245, Speaker A: I'm gonna give you credit for catching that. So let's see. These things actually have to have access to exiting and they have to have access to the. Where is it? Down here somewhere to the default watcher. And neither of those are inside an active packetizer. Those are all in packetizer. So we need to have a way to communicate down that into the active packetizer.
04:40:16.245 - 04:41:05.745, Speaker A: Yeah. So I think we're gonna call this thing poll and that is going to be given a exiting, which is a bool because I'm pretty sure this just reads execution sitting and does not write it. I'd be very surprised if it did. And it will take a default watcher or I guess watcher which is going to be a mute. Default watcher. Mute one of these. Guess we'll call it default watcher.
04:41:05.745 - 04:41:33.435, Speaker A: So now where is it? Self. Default watcher. This is just going to use that. Self exiting. This is just going to be using exiting like so. And then similarly packetizer state is not actually going to implement future. Instead it's just going to be an impl.
04:41:33.435 - 04:42:07.041, Speaker A: Yes. Because it needs to pass along this exiting and default watcher and same here. Exiting. Yeah, MEM Swap and memory Place are pretty. Pretty magical. All right. This is probably going to yell at me for all sorts of reasons.
04:42:07.041 - 04:42:49.095, Speaker A: Probably mostly because of this reconnect business. So I'm going to just comment that out and see how much it yells at me. A bunch. 334 it's yelling at me because this needs one of these. So I'm guessing it's also yelling at me here because this needs one of these. Where else is it yelling at me? All right. We need standard MEM for our MEM replace trick.
04:42:49.095 - 04:44:07.545, Speaker A: It's telling me that default watcher is not in scope. Okay so that's been fixed. Pull right is using exiting so that needs to be communicated there. It's going to be pull read is going to be given the default watcher. Pull right is going to be given exiting. That's so many errors. 339 this is going to be packetizer state this 340 that's just the same error more times 72 stream write so this is going to be state so here's an opportunity for us to fix that.
04:44:07.545 - 04:44:40.935, Speaker A: But I'm just going to not deal with this for now and say that this is going to be packetizer state connected with an active packetizer with stream timer out bar these things. Reply. I think those are all the things. Oh I did not like me doing that. There we go. That's much fewer errors. Better.
04:44:40.935 - 04:45:30.375, Speaker A: 70 ooh. Apparently it doesn't like that at all. Yeah. All my configs are on GitHub. If you go to GitHub.comjohnwho/configs right there. Why is it not send? Oh it's because of our box future which we haven't send first.
04:45:30.375 - 04:46:12.695, Speaker A: Ah. It also needs to know whether it's first. First can also be. I think that can be here. So where is our first? Somewhere up here. Packetizer first is also part of an active packetizer for the time being. Basically whether we've heard the first response from this particular machine that we're connected to.
04:46:12.695 - 04:46:34.935, Speaker A: I have Sauron. It's. Wait. It's escaping your thing weirdly. So you're saying this is turbofish then this. Yeah. I mean this is the.
04:46:34.935 - 04:46:56.555, Speaker A: That is the turbofish. This is the. I guess fat turbofish Seems. Seems legit. Async read is not implemented for S. Oh right. I'm missing a where S which is going to be hidden somewhere far down here.
04:46:56.555 - 04:48:03.777, Speaker A: This guy. 346 what? Reconnecting 410 Pole Expected Active Packetizer pulling Q is given a mutable reference to that. It's not given one. 436 My guesses of the escapes are because of the. Because of the bridge that's being set up. Maybe because Restream is doing this like synchronization of Chat across all the different rooms takes two parameters. That is true.
04:48:03.777 - 04:48:29.275, Speaker A: It takes self exiting and mute self default watcher. Now what mismatch types? Ooh. Yes indeed. This is supposed to return. What? Just make this return A error E because I haven't. All right. So in theory I don't think I've broken anything.
04:48:29.275 - 04:49:35.781, Speaker A: Although I probably have. Oh balls. Now to move this into pole and queue. I guess while let that is this then do that and I guess this should basically never happen. Oh then sure. Async not ready. So this is what should we return if we try to pull NK but we're not connected.
04:49:35.781 - 04:50:11.887, Speaker A: And I think the answer is just. It's just not ready. So that's fine. Whoa. 428 AP not found. Well, that's a little unclear. I think it's gonna have to be this because we basically the issue with like dealing with reconnections is there's so many cases where you could not be connected anymore.
04:50:11.887 - 04:51:09.515, Speaker A: Like here. I think we're guaranteed that this match must work because pole NQ can't change our state and it will always return not. Okay, not ready if pole NQ will never return error if not connected because it will only read from the incoming channel if it is connected and it will only return error if it reads from channel and gets an error. And so therefore this can never happen. Yep, still working on the Zookeeper library. It's true async stuff. So we're building an asynchronous Zookeeper library in rust for 10.
04:51:09.515 - 04:51:52.985, Speaker A: This will now let me do this. And this doesn't take this anymore. This is going to be AP 379. What do we think? Hey, it works great. So we've now just like shifted a bunch of code around to the point where we can now. We can in theory now have the packetizer be in a state where it is not connected. Which is all we really wanted to begin with.
04:51:52.985 - 04:52:51.821, Speaker A: Right. So now I guess we can do here something like place ourselves in reconnecting and then I will do 39. So this is prepare for reconnecting state. So. So what do we do if we try to poll and we get an error? Well, we want to send errors to all in flight requests. Right. So that's going to be not quite clear.
04:52:51.821 - 04:53:41.751, Speaker A: But something like for what is replay again? It's a hash map of things. It's going to be for TX in reply values I guess drain. So for all those we're going to do something to indicate to them that their thing got canceled. In fact Maybe what we want to do is just self state reply clear. Now this won't work because state is an enum. But let's deal with that later. That sends cals into the future.
04:53:41.751 - 04:54:21.659, Speaker A: That's right. Clearing this will cause all the receivers to get a channel disconnect, which means that they will know what in fact happened that their inflight request got cancelled. So let's see, we're gonna dis. We're gonna start a new connection. Once we get that stream, we're gonna do some stuff. We're not gonna do this map and we're going to here. We're gonna basically make the stream.
04:54:21.659 - 04:55:14.165, Speaker A: That's all fine. And then we're gonna mem replace our favorite function self dot state with. In fact this won't even be needed. Overwriting or dropping the old state will also cancel inflight requests. So we're going to replace that with a packetizer state reconnecting box new let retry. So retry is going to be a future, right? And that future is a eventually going to yield our new connection. So we're just going to box that up and set that.
04:55:14.165 - 04:55:58.919, Speaker A: That's now our state of self. And we know that we're going to keep pulling it because now whenever we call self poll, it'll call self state poll which will pull this future. So we know that it will continue to be resolved. So now the question is just what goes in here? And I think the answer is basically this. So now this is going to be okay async not. And then this is going to be self poll. I think you're thinking the other way around.
04:55:58.919 - 04:56:19.241, Speaker A: That ES6 looks a lot like rust. You boxed future instead of reply. Yes, I did indeed. Good catch. Let's see. So here there are a couple of things we need to make sure. So this is where the ZXID is going to come in.
04:56:19.241 - 04:57:10.975, Speaker A: So remember how we somewhere here we like decode the zxid and this we're actually going to have to keep around somewhere. The problem is that's hidden all the way inside the active packetizer. So I guess last ZXID scene is going to be here in i64 we're going to do self last ZXID. This is going to be i64 max of self CXID and this I think it has to be max. It's actually unclear. I think the server guarantees that it sends them in order. So I think it's just this.
04:57:10.975 - 04:58:29.615, Speaker A: Let's. Just to make sure say let's ZXID is this. Assert that ZXID is greater than self last zxid and then that is zxid. Great. So down here now when we're reconnecting then we're going to have to I guess up here we're going to have to do something like if let actually here packet connected active packetizer and then we're going to have to extract the ZX ID from there is self state, then we're going to do all these things. And in fact if that is not the case, if it's not in the connected state, then we just got to return the E because this means that there's an error that occurred while we're trying to connect. Error while connecting.
04:58:29.615 - 04:59:24.155, Speaker A: Don't recurse for now. All right, so now we have the I guess this is last ZXID scene. So now we know that we can pass that in here. We also need to extract out the password that we got from that server. So the packetizer down here it's going to have password which I think we're guaranteed is always a vec. Yeah, password vec u8. So we're also going to do here first.
04:59:24.155 - 05:00:23.989, Speaker A: So down here this is also going to have ref new password and we're going to do self. Password is equal to password. Actually we're just going to do mem replace. No, we're going to do mem swap. Yeah, Self password with password. So what we're doing here is when we get a response to the connect, then we take the password out of that connect response which is going to get sent back. Why is it even sent back? What does it do with the response to that? I think we basically ignore that response.
05:00:23.989 - 05:00:53.755, Speaker A: Yeah. So that response we're going to extract the password from it and stick it in self. So that down here we can also do is here. Ideally we would do a memory place but we can just do a. Don't really want to do that. Sure. A ref password come back to bite me.
05:00:53.755 - 05:01:31.805, Speaker A: Password is password split off. You're going to need NLL for this. Which is a little sad because the issue here is that the I'm now borrowing into self state which means that I won't be allowed to mem replace self state down here. NL would realize that this is okay, but it's not okay. Similarities. Oh I see. Don't worry about it.
05:01:31.805 - 05:02:30.615, Speaker A: We all say things that we afterwards believe were silly. Okay. So password gets passed along here. I guess we also need the session ID which is also here fields for re authentication or reconnection. This is going to be session ID which is also an i64. And so down here when we get the connect response we also get a session ID and we say self session ID session ID for consistent reconnect. So down here we're also going to extract out the session ID from the old connection that we had.
05:02:30.615 - 05:03:28.535, Speaker A: We're going to reuse it for the new one. In theory we could set some timeout. I think for now we're just going to leave the timeout to zero so that it's auto negotiated with the server and then when this eventually comes back, I guess that's the question. We want to make a new packetizer, but we want to make a new active packetizer which I think we. Yeah, we want to make one of these guys which should arguably now be a new. Could wrap this in a new probably. I'm gonna not do that for now just because I am being lazy.
05:03:28.535 - 05:03:55.261, Speaker A: Right. So this will now be something that resolves into an active packetizer. I guess these are all fine. They all start out empty. Okay, fine. I guess we'll add an active packetizer. Where is it? Active packetizer.
05:03:55.261 - 05:04:54.761, Speaker A: Down here we'll add a FNU versus self. So these fields will be set last ZXID scene is going to be zero. Session ID is going to be zero. Password is going to be vec. I guess it's going to be vec new. The only thing that needs to be given is a stream of S and now active packetizer so this can be replaced with new stream. So and same with this guy.
05:04:54.761 - 05:05:20.627, Speaker A: No this guy. It's gonna be new stream that so in theory misled you into writing reply instead of retry. No, you did it again. Retry. That's right. Yeah. I'm not gonna, I'm gonna try to avoid to write that.
05:05:20.627 - 05:05:47.811, Speaker A: Give no guarantees. Okay, so what we've done now is we've constructed a future that will eventually resolve into an active packetizer. Just like what we had when you initially construct a new packetizer. Where's our other new. This thing? Right. So this thing just really constructed a new packetizer and we're reusing the same packetizer. None of that changes.
05:05:47.811 - 05:06:30.415, Speaker A: We're just swapping. The connection that's inside is arguably we could instead of calling it active packager we could call like connection because that is really what it is. It's a single connection with a single zookeeper server that is currently active. But active packetizer seems fine. So this is going to do a TCP connect. It is then going to try to connect to the active pack or try to connect and when it does create a new active packetizer and then I guess it will also have to somehow send in this connection request. I don't entirely know how it's going to do that because it doesn't have an enquiry and that's what makes it a little bit odd.
05:06:30.415 - 05:07:53.165, Speaker A: And it sort of needs to put it at the front too. I think we need to do something like enqueue all right. It's basically we're doing whatever this is doing. In reality though, I think all of this stuff we could really stick into, stick into active packetizer. It's really where it belongs. So this is going to be a FN&Q takes a mute self and a request item which is a request and returns probably nothing. Returns nothing.
05:07:53.165 - 05:09:17.785, Speaker A: So this is going to now be all this stuff is going to be self self. It will however need to know the X ID which is an i32 this is going to be self. It's going to return a. Oh, it does have to return a one shot sender thingy. So basically what I'm trying to achieve is that this will just call ap.enqueue like so xid item and I guess it does have to give the TX because then all of this can go away from packetizer and the TX here of course is a, is a one shot sender. Oops, does not get to return one.
05:09:17.785 - 05:10:06.005, Speaker A: It's going to be given one which is going to be a one shot sender of whatever. These are this thing and these are all going to be self. Now these go away, this becomes itself. Right. So now this thing we can just enqueue directly. We're going to have give it an X ID and that's going to be zero because we're just connecting. I guess it can be self.xid
05:10:06.005 - 05:11:29.635, Speaker A: actually we could even do this now self xid and then we're going to increment it by one. We'll do the same thing here. Self xid plus equals one and then I guess here the main question now is whether we should wait to make the active packetizer active until it has fully done the handshake. I don't think that matters. Yeah, I mean we're basically just implementing a fancier hash table. So what we're doing here is we're connecting, setting up the packetizer, giving it the first request which is going to be the connection request. And the question is are we going to, are we going to say that the connection is ready yet? I don't think so.
05:11:29.635 - 05:12:28.917, Speaker A: I think we oh, we sort of have to because we have to pull it. That's a little weird. Not gonna lie. Alright, let me explain why this is a little weird. My concern is here we're constructing a connection to the to the server and the first thing we're in queuing is the connection request, which is the right thing to do. And then the connection request is asynchronous. Right.
05:12:28.917 - 05:13:16.437, Speaker A: So we don't necessarily know when the response to it comes back from the server. Once we switch over to. Once this future resolves, we're going to switch over to being in the connected state which means we're going to start pulling requests from the client, from the user again. Once we start pulling those again and start sending them to the server. The server, I guess the server is guaranteed to receive them in order, but in theory might respond to them in different orders. I don't know whether that matters. So I'm worried whether we need to like wait for the connection request to be responded to before we make it the active packetizer or mark ourselves as connected.
05:13:16.437 - 05:13:44.265, Speaker A: I don't think we do. We do however need to give a response channel here for enqueue. Right. So the enqueue that we have also takes a TX for where it should send. The receiver responds to the connected to the request we're making. And in this case I think we can just make one that we never read from. Pretty sure.
05:13:44.265 - 05:14:40.767, Speaker A: Because if we send the TX here then we're going to drop RX don't care. I guess we could spawn RX.then r reconnection response because we don't really care what's in the response because most of that is handled internally. Right? So I think all we really. We just like set up the receiver. We could even just drop it if we wanted to but we set it up at least so that we get to see the response and that way it's. I think this is fine.
05:14:40.767 - 05:15:11.045, Speaker A: Like the response will just be dropped and ignored. Let's see. Oh yeah, these. The streams end up being pretty long just because there's a lot to cover. Like I was sort of hoping that we might finish Tokyo Zookeeper today, but there's just too much stuff. It's just. It's weird how there are just so many things that you end up having to deal with and the hours just start to go by.
05:15:11.045 - 05:15:55.625, Speaker A: I think we will probably like once this compiles, I think we'll probably end it off just because it's a lot of hours and I need to like eat and stuff. How do I become interested in async networking. So the interesting thing is I'm not. I. I think there are a lot of interesting programming challenges in asynchronous programming, but it's not like I really care about async networking specifically. The reason I started doing these streams were more because I wanted to show more advanced or intermediate Rust code being written so that you could get experience with writing more advanced code without necessarily having that experience yourself. And so I'm sort of trying to help bootstrap people's experience in that regard.
05:15:55.625 - 05:16:38.405, Speaker A: And I think async networking is one of those things that a lot of people are interested in and don't really know how work. And so it's a good way to get a very deep dive into this. And it's totally true that this is a very deep dive. Like most of the times if you're building things in Rust, you will not have to deal with these things. But the goal here was to expose like really meaty programming stuff where you're just. Basically the idea is you get to watch me fail and then see how I respond to having to debug my code. Because I think that's some of the stuff that's the most useful if you're trying to learn a new language or just trying to learn programming in general, is to see that other people also get stuck and then sort of observe how they get unstuck.
05:16:38.405 - 05:17:12.595, Speaker A: It's true. As well as Stanislav says, you sort of need things to be async. And you see this in the Rust world too. Like Tokyo is just everywhere now. And it's because, and I mentioned this somewhat in my much earlier streams on building Ecuador EC2 orchestration, you run into this problem where, say that you're setting up like a cluster of 100 machines. You can set up all those hundred machines with a single thread because most of what you're doing is you're sending a request to the server somewhere. It's going to do a lot of work and then get back to you.
05:17:12.595 - 05:17:45.837, Speaker A: And you don't want the thread that's doing that work to sit just like hang around and do nothing. It might as well do other useful work in the meantime. And that's when you get into Async. All right, let's see where we were. Proto 482 is just going to be request, I think. Yep. 315 Connect does not have field password.
05:17:45.837 - 05:18:59.827, Speaker A: That is true. Active Packet Dicer does. Wait, what password? None of this semi password business. Stop at that. Oh yeah, I Don't think you generally want to read Async Rust code if you're tipsy. Just a pro tip 419. 419 where async read and async write 42.
05:18:59.827 - 05:19:58.353, Speaker A: Oh, right. We need an address. I guess packetizer is going to have to have zookeeper. Adder is going to be a socket adder, and I guess we're going to have to include that. So. And then in theory, down here, this is going to be self adder. Yeah, I think that's right.
05:19:58.353 - 05:20:38.302, Speaker A: I think synchronous is not really how the world works at this point. Adder is adder dot clone. This move that. This. Sorry, this is just. We're just threading things through to make the compiler happy. 5, 10.
05:20:38.302 - 05:21:11.479, Speaker A: What is it complaining about now? Expected i32 oh, request 492 future is not implement. Oh, that's right. This is a map 516. Expected mute. That is true. Did expect mute. Future is not implemented.
05:21:11.479 - 05:22:03.565, Speaker A: Minute for that. That is fine because we changed it. Type mismatch. Oh, yeah, that's awkward. So I don't know if you saw what happened here, but the problem here is we're establishing a new TCP connection. But packetizer is generic over S, whereas TCP connections are not nes. It has some specific S.
05:22:03.565 - 05:23:26.315, Speaker A: It's pretty awkward. I don't know if we have a good way around that. Actually. I don't really want to make this not generic. Hmm, that's a good question. It's sort of like I want. I want to take any S where I can establish a new one, but that's not trivial either.
05:23:26.315 - 05:24:02.345, Speaker A: So I mean, the. The one way we could do this, of course, is also. So I could do S anything that's from tc, TCP stream. The reason it's called currently S is actually because it's for a couple of reasons. It's because it could be that people want to do this for testing. Like you want to test it over. Like you just want to use buffers instead of having a real zookeeper running.
05:24:02.345 - 05:24:38.925, Speaker A: Or if you want to connect over UNIX sockets, that should also be fine. Yeah, it's not ideal. I think we're gonna need our own trait here. It's a little awkward. Like it would basically be a trait that has an associated type, which is the address, and it extends async, read and async. Right. And it has a connect method.
05:24:38.925 - 05:25:08.535, Speaker A: Yeah, it's not great. Not great. But I think we're gonna have to. I do not want to do that. But I guess we have to. So we're gonna have a pub trait zookeeper transport. It's going to extend async read and async write.
05:25:08.535 - 05:26:40.241, Speaker A: It's going to have a type parameter adder. It's going to have an FN connect which takes a self adder and returns a type error Connect error which implements into failure error. And this is going to give an a result self and self connect error. And then we're going to implement zookeeper transport for Tokyo net TCP stream, which is also really weird. So the adder is going to be socket adder. In fact it's going to be. This connect error is going to be IO error and this is going to be actually not going to be a result.
05:26:40.241 - 05:27:19.665, Speaker A: It's going to be a. I don't even know if I'm allowed to do this. I don't think I am. Connect foot which has to be into future item itself Error is self connect error. This has to return. Oh, this is awful. Luckily the users will basically never have to see this, but it's still pretty sad.
05:27:19.665 - 05:28:00.675, Speaker A: So a connect future. Oh, I can't even name the connect future. I think the connect future is going to be Tokyo. What do you get back if you do a net? Okay, so it's one of these. It's gonna give you a self connect foot. That's true. I could take a reconnect function instead.
05:28:00.675 - 05:28:45.895, Speaker A: Oh, hey, that might. So this is sort of the proper way to do it. But you're totally right that maybe it's better to just have a reconnect future or just a reconnect function. It's a little awkward though, because we want it to be a single. So it would have to be a function that returns something that is a future. Although we could totally do that. The generics turn out pretty awkward.
05:28:45.895 - 05:30:18.575, Speaker A: I mean this isn't actually that bad when you use it. It's just having this trait in the first place is awkward because like if you. If you look at it, all this is going to be is TCP Stream Connect, right? Like that's the entire implementation for TCPStream. And then down here we would say that we implement here where S is. What did we call it? Zookeeper transport. I guess structure packetizer is going to have the same thing because this is going to have to be sadder. And now down here all we really have to do is sconect self adder, right? So it's actually not that bad.
05:30:18.575 - 05:31:24.265, Speaker A: It's just an annoying trait to have. And I think there's probably yeah, this has to where S is zookeeper transport and this has to take an S. In theory this means that we could do the connect here directly. Do connect directly here. Now that we can IO oh connect future returns Tokyo error 24 oh info. Wow. That's when you can tell that it's been a while sized.
05:31:24.265 - 05:32:08.965, Speaker A: Yeah, we're not gonna have trait objects of this type anyway. 442 this also needs to be zookeeper. That is true. Oh, that's so many errors. 50. What? 58. Nope.
05:32:08.965 - 05:33:21.943, Speaker A: We're gonna make this not be generic at all. It's gonna take a Tokyo Net TCP stream. Does packetizer itself even have to be generic over S and not a few methods? It does because it contains an S. Right? It has to contain the underlying stream S Here is the stream that we're sending over and so it actually does need to be generic over S. Mod 100 send oh yeah, this has to be send. This probably also has to be sending. That is because it is into future that it implements maybe slightly off topic and better personal preference.
05:33:21.943 - 05:34:25.365, Speaker A: Does Linux make it easier to do this pure program in the Windows? I have not used Windows for programming for at least 10 years, so I can't really speak to that. I have never found that I wanted a different operating system for programming. I have several times observed people who use Linux and a VM for programming or for particular pieces of programming, which suggests to me that I'm not really missing out. But I can't speak to it directly. Map error we did say that the error has to implement O into failure error. Okay, so we have to do it this way. I'm almost there.
05:34:25.365 - 05:34:50.675, Speaker A: 542 with A. Basically what you're doing with this transport is strapping away the stream. Not quite. I'm not actually abstracting the stream away. The S is doing that. What I'm. What I'm doing with this with the trait is I'm saying I need a stream that has certain properties.
05:34:50.675 - 05:35:33.755, Speaker A: So you should think of traits as like behaviors that a type supports. So in this case what I'm saying is that I can be generic or packetizer can be generic over any S where S implements async, read async write sized send and has a connect method that returns something that is a future over itself. Right. So that's still Packetizer being generic. So I'm not. I am abstracting over it in the sense that I'm allowing it to be generic, but it's not like I don't need to know what the underlying stream is. It's truly the implementation doesn't care about which stream it is, but it needs to know like the types the compiler needs to know which type the stream is, otherwise it couldn't put it into the struct in the first place.
05:35:33.755 - 05:36:29.283, Speaker A: That is also true. This needs needs to also implement send. What? Oh, that's not what I meant. This needs simple incentive. Oh, I don't know if I can even say this like I need into future. Okay, so this is a little awkward. I need.
05:36:29.283 - 05:37:09.875, Speaker A: So. So I'm saying that connect can return anything that can be turned into a future, but I need to say that the future it is turned into is send, which I can do with where clauses, but I don't think you can have a where clause on type. So I think I actually have to do this, which makes it quite awkward to write connect. Probably still fine, but. And it has to be static, probably. Oh, right, that's our reconnecting. This has to be static.
05:37:09.875 - 05:38:27.505, Speaker A: So the expression is assignable where 560. It is telling me that this thing telling me that this thing is not static. Which is true, because it's borrowing self. This. Oh, I still have the into future. Yeah. Oh, because x x ID is going to be self xid self xid is going to be one.
05:38:27.505 - 05:39:22.113, Speaker A: This is going to be xid and this is okay, because we know that the will not start accepting new requirements requests until this is finished. Therefore that xid is still valid connect Few may not live long enough. Yep, because connectfut also needs to be static. Well, that's better. I like those errors better. Yeah, so this is where I told you where. This is where we need NLL because I'm.
05:39:22.113 - 05:40:26.835, Speaker A: I'm swapping. Wait, that's not where we need 542. We're swapping self.state but we're also borrowing out the password down here and the compiler doesn't know that. That's okay. So what I will do is this, which is also terrible. This of course now is on unreachable because we're checking it above.
05:40:26.835 - 05:41:01.805, Speaker A: So now we have the password down there and that's how you work out in an ll. Oh, sorry. Yeah, you're right. We could totally store a box zookeeper transport inside packetizer. This has always been the case. Right. We could also always have stored a box async read + async write send static if we wanted to.
05:41:01.805 - 05:41:45.635, Speaker A: But there are a couple of reasons to have it be generic. One of them is it produces faster code, although that probably doesn't matter too much for Zookeeper because you don't have dynamic dispatch within a bit. The other reason is because it means that you can look at the type and see what kind of connection you have. And this can make it easier to do things like imagine that you wanted to connect to Zookeeper over TLS right then. Now a part of the type will be this is a Zookeeper connection over tls, which would not be the case if you boxed it. Whoa, that's a bunch of errors. Okay, so apparently ZXIDs are not increasing.
05:41:45.635 - 05:42:27.925, Speaker A: That's also kind of interesting. ZXID self blasts. That's odd. Oh, I see. It's. It's greater than or equal, I guess. Might as well keep it but somewhere else.
05:42:27.925 - 05:43:40.155, Speaker A: Minus 1G. Thanks. Why would ZXID be minus 1? All right. What does Russ Zookeeper do here when it sees last last ZXID scene? Because that's awfully strange. I don't think Rust Zookeeper does reconnection. Yeah, and if it does reconnection, it does not do it correctly because this can get minus one. So unless there.
05:43:40.155 - 05:44:31.119, Speaker A: Yeah, I don't think that's right. I don't think this can be just be blindly accepted because what we're seeing here is getting a request where the ZX ID is minus 1. I think this is a bug in upstream in the Rust Zookeeper crate, the synchronous one. I think you need to ignore things that are negative one. If ZXID not equal to negative one, then do this. If you get negative one, then it's from the watcher. What makes you say that? Because this should be a response from.
05:44:31.119 - 05:45:07.900, Speaker A: Oh, I see. I see. Yeah, that's right. That still makes this wrong. This line is still wrong. Else I guess we can assert that XID is minus minus 1. Only watch events should not have ZXID.
05:45:07.900 - 05:45:44.325, Speaker A: It's also really weird. I don't know why ZX IDs would not be sent for Watch Events Panic poll. Right? Why? Let's just double check this code Panic. Not yet. Just to see that that code is not actually reached. No. Both Ping and Connect disconnect should have ZXIDs.
05:45:44.325 - 05:46:10.035, Speaker A: And in fact you see that they do, right? Like here we're getting the response to connect. I guess we should print them out here. Handing response to XID0 with opcode create session. And there you see we got ZXID 349. The exists we get 349. So this is basically how many writes they've been. So a read does not increment it.
05:46:10.035 - 05:46:46.505, Speaker A: But you see the connect does give us ZXID 0 +2. No, 0 gives us a ZXID too. Connections does assertion failed. Well, that's interesting. At Lib 132 153. Oh, it's because it crashed halfway through last time. So I need to delete foo.
05:46:46.505 - 05:47:21.705, Speaker A: Great. I think I agree with Patrick too that now is probably a much better time to get into rust than like in the past many years. I think it's also there's still things that are shaking out like the whole async await things. I think Tokyo still needs a bunch more work, but I think there are a lot of resources. There are a lot of like the Rust book is really good and so we are getting pretty far. And at this point you can actually use Rust for a lot of things. Like there are crates for most of the things you want to do.
05:47:21.705 - 05:47:55.875, Speaker A: And so I think I agree like this is a good place to start. Okay, well that's awesome. Notice how the. So if you look at it, the initial ZXID when we connect here. Now let's connect it 372 right? And then we do an exist and we still get 372. Then we do a create and then we get 373 because a modification happened. Then we do an exists and we get 373 again because nothing changed.
05:47:55.875 - 05:48:39.547, Speaker A: Then we do our delete and then we get 374 because it was a change and then 374 because nothing changed. 375 is when we leave leave because a node leaving also triggers ephemeral nodes to be deleted. And so therefore 375 has to go up. We could add a bunch of tests for things like ephemeral nodes and such. I think we'll leave that for some other time. We now have all the infrastructure. We haven't really tested whether reconnections work, so I guess to do test this, but I think that's basically I think now we have all the stuff there.
05:48:39.547 - 05:49:23.549, Speaker A: So in theory this should be all that's needed for the reconnects. All the clients that are waiting for replies will indeed get errors. And any that get sent after we detect the disconnect that happened, those requests will still be sent as normal. So I think we're in a pretty good position now. So let's commit that first round. First attempt at automatic reconnect. We'll still have to do things like if the user gives many addresses for zookeeper nodes and we'll have to iterate through all of them and keep trying because it could be the one server you connected to went down, but there are others where the connection will work successfully.
05:49:23.549 - 05:50:13.765, Speaker A: We'll want some tests test with watchers, but I think now we have most of the sort of core protocol and the higher level API at least functional. It's not necessarily well designed yet, but it is functional. I think we're going to leave it there because the stream is getting pretty long, but hopefully there'll be another one in not too long. So I hope you enjoyed it. I'll push this and as always like if you have questions or whatever then reach out to me on so I'm on Twitter at Twitter John who so you can ping me here if you apparently someone has already. If you have something you want to say, there's also the Patreon page where you can follow me and subscribe. If you want to hear about upcoming streams, you can also follow on Twitch or YouTube.
05:50:13.765 - 05:50:43.037, Speaker A: I did a test for deleting non existent things. No, so I've not added any test beyond the one we have. There are lots of tests that could be added now because we have all the functionality and adding those is a good idea. I just haven't yet. I figured I would focus more on the functionality and the async part of things than on adding tests for everything. Although that is obviously something that should be done. But yeah, you can follow me on Twitter, follow me on YouTube, follow me on Twitch, follow me on any of the others.
05:50:43.037 - 05:51:07.753, Speaker A: I do stop by the rustic chat at least every now and again. I'm the same username there. I'm basically John who pretty much everywhere except Twitch and YouTube and Mixer, which are the three streaming platforms because on those that username is already taken. In one of the cases it's taken by an old user of my own and I can't change it. So that's annoying. Yeah, thanks for stopping by. I hope you found it interesting.
05:51:07.753 - 05:51:19.965, Speaker A: Interesting. I'll post a recording of this once we're done here and then you can go back to the places where things moved quickly. So thanks for joining. Bye everyone. Like this.
