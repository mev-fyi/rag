00:00:01.560 - 00:01:06.681, Speaker A: Hi, folks. Welcome to another Decrusted stream. We haven't done one of these in a little while. We arguably haven't done any stream in a while. But the Decrusted series, for those who either haven't watched the previous video where we did the SERDE crate, or just it's been a long time, the idea of the Decrusted series is to take some crate that's popular in the ecosystem, and especially one that a lot of people use fairly directly like you have. You actually have to interact with it and kind of need to understand how it works under the hood and just sort of take it apart and figure out why is the API structure this way, why does it work the way that it does, what are the techniques that it uses, and really just form a more accurate and useful mental model of how all the pieces fit together so that when you are building your own stuff using that crate, you'll be in a better position to do so. You'll be in a better position to understand why you get the errors you get, understand why something goes wrong, understand how to fix it, or, or hopefully even just become more fluent with it.
00:01:06.681 - 00:02:07.725, Speaker A: And when you want to build something using that framework in the future, you'll be more comfortable with what you have to do and potentially more efficient, more proficient and such. So the crate we're tackling today is one called Axum, and if you haven't heard of Axum, Acum very briefly is a web framework. Think like Rocket or like Actix or Actix Web rather. And Axum is one that is a little bit different in the sense that it only really provides routing and request handlers and then all the, like, middleware stuff, anything that you might want to do in between a request comes in and response comes back. Apart from the actual handler function, all of that stuff is handled through the tower crate and in particular the tower service trait. We'll get into what exactly that means. But the essence of this is that Axiom is actually fairly small.
00:02:07.725 - 00:02:55.437, Speaker A: It doesn't implement things like rate limiting, for example. That's not a part of Axum itself. Instead, you get that via these other middlewares that are built around the same trait, this tower service trait. And we'll dig into how all of this works and why they chose to do it this way. But from a 10,000 foot view, it is really just a way to express application routes. So things, things like, you know, get to slash and what should happen when a request comes in like that. And then in addition, a sort of mechanism for writing those Handlers that receive the requests and extracting interesting information in those handlers.
00:02:55.437 - 00:03:26.955, Speaker A: So let's go ahead and just grab the example and then start straight from running code. Let's do Axum. Fun times. Okay, so we're going to add. Sure. We'll add Serde, we'll add Tokyo, and we'll add Axum. And then instead of this, we'll start with this right here.
00:03:26.955 - 00:04:09.389, Speaker A: Right. And we'll do add tracing and we'll add tracing subscriber and that should give us all the stuff we need to get started. Great. So if I now just, I just made this thing, I'm going to cargo run and that'll build some stuff. And now I should be able to just curl localhost port 3000 and I get back, hello world. Okay, so we now have the sort of very rough idea of Crate. We'll actually walk through the code.
00:04:09.389 - 00:04:48.873, Speaker A: But this is what it does. It has code that defines the routes you want to accept. It sets up a web server, it defines handlers for each of them, and then you can access that web server through something like Curl. So that's the basic functionality of the Crate. Okay, so let's then let's see, does it have an HTTP parser or does it rely on Hyper? It uses Hyper under the hood. So Hyper takes care of all the HTTP parts, or at least all of the sort of protocol level HTTP parts. And then Axum builds on top of Hyper.
00:04:48.873 - 00:05:26.865, Speaker A: So one of the things that's interesting about Axum's approach to the whole web framework thing is they lean a lot on the rest of the ecosystem. So they use Hypr for handling all the HTTP bits. They use Tower for handling everything that has to do with middleware and the like. They use tracing for anything that has to do with logs. And they use the. What's it called? Oh, minimatch. No, it is called matchit.
00:05:26.865 - 00:06:00.805, Speaker A: It uses the matchit Crate for doing route matching in an efficient way. So there's a bunch of bits in there in Axiom that are really just intended to be the glue between all of these to provide you the framework you need to write HTTP services. Okay, so let's now actually walk through the code here. So let's ignore the imports for now. We have a Tokyo main, an Async FN main. Okay, great. Runs on the Tokyo runtime that we can mostly ignore that we initialize the tracing subscriber.
00:06:00.805 - 00:06:46.985, Speaker A: We'll almost certainly do a decrusted on tracing because there's so much to talk about there. So I'M not really going to talk a lot about the tracing parts of this as we go through Axum, because we'll be just be handling that separately. There's nothing or there's very little that's unique about the integration between Axiom and tracing that we need to know about here. But we set it up just so that we get log output in this case. Okay, so the main thing that we, or where we start with the main actual Axiom logic is we create a new router. And a router is the sort of primary entry point in your application. It is the thing that when a request comes in, the router determines what function ultimately gets called to handle that request.
00:06:46.985 - 00:07:24.509, Speaker A: A router has a bunch of routes. And so in this case you see you have a route slash, and when a request comes in for slash, you'll see this bit on the right which says get and root. Root is an asynchronous function that we defined ourselves right here. So it's just an asynchronous function and it just returns a static string. And so what this implies is when a request comes in for root, then reply with this string right here. And in fact, if we do something like curl, verbose, you'll see back that the content type here is just text plain. It's not HTML, it's nothing like that.
00:07:24.509 - 00:08:03.857, Speaker A: It's generally just the plain text hello world that we get back. So that's if we do a get request to root, the get here, if we scroll back to the imports, comes from routing get. So this is a method matcher. And in fact, if you go back and look at Axiom's, if you look at routing and see the router sub module. No, the router sub module, you'll see that there are a bunch of these. So there's options patch, post, put, get, delete, trace, head. So all of the sort of HTTP verbs are treated as separate method routers.
00:08:03.857 - 00:08:47.161, Speaker A: Here you can also use which if you want to say I want to take any method under this path. And in addition you can just create yourself. So you can create one of these method filters that allows you to say, you know, get and post, for example, all get passed in here. If we try to use one that there's not a route for. So if we try to do something like X post and I still want verbose, please, then we get back 4 or 5 method not allowed. So Axiom tries to follow the HTTP standard here, where if the route exists but the method the HTTP verb you tried to use does not, then you get 405 method not allowed if we try to access a path that doesn't exist. So if we do foo, then Instead we get a 404.
00:08:47.161 - 00:09:28.345, Speaker A: Not fun, because that path does not exist. You can customize this if you want, but the default behavior is basically to follow the spec to the extent that it's reasonable. And we'll talk a lot about how exactly this sort of seemingly magic works. We can just have a random asic fn and it just works when you pass it to get. You'll see there's another route here, which is to users that requires the post method to be used to the post HTTP verb, and that goes to the create user function. And the create user function, you see, has a bit more heft to it rather than the root function. CreateUser takes arguments.
00:09:28.345 - 00:10:12.645, Speaker A: And if you just read this naively, you can sort of guess what it does right? It says that it expects that the body that's provided to this request is JSON, and that the contents of that JSON deserializes into the create user type. And create user is just something that derives deserialize here. And that's just an argument to the function. You might think this looks weird, like why is there something on the left of the colon? This is just structure pattern matching. So you could do this, and then payload is of type JSON. So we could do inside of the function payload equals payload zero. If we look at the JSON type, it is just a tuple struct with a single field in it.
00:10:12.645 - 00:10:35.385, Speaker A: So this is the zero. So there's nothing to unwrap or anything. But rather than having to do this, let payload equals payload zero inside of the function. We can use pattern matching right up here to deconstruct that tuple struct directly in the argument list. You can do this for any function. This is not an axiom feature. It just happens to be really useful in the axiom case.
00:10:35.385 - 00:11:24.145, Speaker A: And then you see that create user returns a tuple of status code. And we see this JSON object again with user as the parameterized type to JSON here. And as you would expect, this means that it returns a status code, which is the status code here comes from the HTTP module of axum and it defines all of the standard HTTP status code. In fact, I think it in fact is a re export. I'm not entirely wrong. Yeah. So the HTTP module is just a re export of the HTTP crate, which just has definitions for all of the different like verbs and methods and things in the HTTP Standard.
00:11:24.145 - 00:12:04.595, Speaker A: So all the status codes are in there. So as you might expect, returning a tuple of these two means that you get to set both the status code for the response. And you say the body of the response should be the JSON encoding of a user struct. And that just kind of works like you just give a tuple saying the status code should be created and the body should be this, this. But Jason serialized, if we go back now and we try to post. So we'll do data and what's the data? It expects. It expects a username and we do this.
00:12:04.595 - 00:12:47.231, Speaker A: Oops, users. It says unsupported media type because we didn't declare that the content type of what we sent in was actually application/JSON. So we do dash h content type, application JSON, fail to parse the request body. That's because this is not valid JSON. This is valid JSON. So you see now I passed in this JSON blob, I told the server that the content type is JSON. And you see the request we sent now has application JSON as the content type.
00:12:47.231 - 00:13:38.545, Speaker A: The response we get is indeed 201 created. So the status code that's in the handler, you see the response content type is automatically set to application JSON because it understands that if you're encoding a JSON response as the body, you should also set the content type to JSON. Oh yeah, there's also JSON, I think, instead of data, but it doesn't really matter. And you see that we got a JSON body back that has the encoding of that user struct that it produced. Okay, so this is just roughly how you write Axiom handlers. Questions about this before we dig into how this actually works, because it's pretty cool how this works. What happens when the payload doesn't match? Does Axiom return specific HTTP error codes? I think it just gives bad requests.
00:13:38.545 - 00:14:16.805, Speaker A: So you can see this up here where I didn't correctly encode username with double quotes. Like it basically wasn't valid JSON. This would also apply if it was valid JSON, but it wasn't a valid serialization of the struct that we tried to deserialize it into. Then you just get a 400 bad request. And you see here, by default it includes a description of like, basically a debug print of the deserialization error. You can turn that off to tell it to not sort of echo that back to the user if you're not running in debug mode, for example. In fact, it might even do this by default if you run it in release mode, then I don't think it prints this error.
00:14:16.805 - 00:15:13.625, Speaker A: Is it mandatory to have the status code first in the return tuple? No, it's not. In fact, as you'll see soon, the return type here can be a lot of different things. So I can do this like so restart the server and now if I post this, I get a 200 okay back instead. Instead of a 200 one created so that it's polymorphic in the return type as well. If you want to think about it that way, I'm interested about the variadic generics design pattern they use for services. Well, we'll get into all of that later. What happens when a route function panics? So routes aren't functions.
00:15:13.625 - 00:15:46.345, Speaker A: Oh, you mean when the handler panics so we can try it. So if I panic in here, what happens if I run this, send a request, I get empty reply from server and we got a panic. But what's important here is that these panics are isolated per Tokyo task. So if one Tokyo task panics, it does not panic the whole web server. It doesn't even panic that handler. So we can run other handlers. If we run that handler again, then it'll still run.
00:15:46.345 - 00:16:21.981, Speaker A: It'll just panic again. So they're isolated from each other. So you can panic in there. It's just a panic message will be printed. Are the get or post functions returning functions themselves? Yes, we can go look. So this is generally what I recommend people do if you have questions like this. So the getter here is actually returning a router or a method router.
00:16:21.981 - 00:17:09.704, Speaker A: And method router implements. If we go down here a little bit, Method router. Where is what I want now? I can't find the thing I want. It basically gets. So the way the method router actually works is it internally contains a sort of map based on the method of the incoming request. So it's basically a middleware. When it gets in, when it receives a request, it'll look at its internal map from method to handler and it will look at the method of the request and it will just call the appropriate handlers handling of that request.
00:17:09.704 - 00:17:40.335, Speaker A: So just think of it as like a. It has a mapping. Let's do it this way. So the request comes in here and then it just gets routed to the right handler. So the request then goes into say this handler here for get requests, it produces a response and it goes back up and back out. And this is where we'll get into the tower Service trait for how it does middleware like this. But the router is really just a thing that holds many handler functions and chooses which one to call depending on the properties of the request.
00:17:40.335 - 00:18:21.045, Speaker A: Is there a way to return that JSON serialized object but force the content type to be something else? Sure. So if you look at the kinds of things that you can return, which is in the response type here, you can return all sorts of things in response. You can return something like append headers, which lets you append additional headers to the response. You can fully customize the response if you want as well. So yes, you can, you can add that here. And in fact you can do this. So you can now make this a three tuple, where one of the things that you're returning is an append headers.
00:18:21.045 - 00:18:59.405, Speaker A: And again, we'll get into exactly how that works. I'm just trying to sort of get at all the top level questions before we dig into how this works. Under the hood, can you explain the extractor syntax in the case of query parameters? Sure. So if you want to take your query parameter, you do this. Anything that implements deserialize here, really, but hashmap string string is a common way to deserialize parameters. And now params is a hash map from string to string. And inside here I can do params.
00:18:59.405 - 00:19:43.175, Speaker A: Get my param to get the value for the query parameter, my param and query here, just like JSON is just a tuple struct that comes from the axum extract module, which has extract query. JSON is also defined under extract. Does it throw an error when a route function has no arguments but you provide a request body? No. So that's what root does. Right? It has no arguments, it doesn't read any. The way to think about that is it doesn't read anything from the request, but it produces a response that is a body. There's no error.
00:19:43.175 - 00:20:15.765, Speaker A: Oh yeah. Someone pointed out that if you. If you have a panic here, there is technically a middleware you can put in that catches panics in the inner handler and turns them into HTTP error responses, rather than just getting like no body connection closed kind of thing. So that's something you can do with do. We're not going to dig into that here. It's just worth knowing. Okay, great.
00:20:15.765 - 00:20:49.455, Speaker A: So now we have a sense for how you structure these handlers and the kind of things you can do here. Let's now dig one level deeper. Oh, actually, there's one last thing I want to talk about, which is starting the Actual server. So once you have a router, you have this thing, they call it an app. In the example, you create a socket adder, like where you want it to listen, and then you call Axum Server Bind and you provide that address. Axum Server is really just a hyper server, as you can see here. So this is just reusing the hyper service stack and bind.
00:20:49.455 - 00:21:40.235, Speaker A: This just returns you back a hyper server, specifically a hyper server builder. And then when you actually want to start serving requests, you call serve on that builder. So if I go to the hyperdocs, then go to server and go to server, you see the bind returns. A builder and builder has a Where are you? Has a serve method with lots and lots of trait bounds. But essentially it takes a thing that can make a service. And what that means is every time a new connection comes in, it calls this thing to produce a service as service. Being an implementer of the service trait, we'll get to the service trait in a second.
00:21:40.235 - 00:22:43.265, Speaker A: And so each connection gets its own instance of a service that gets called for every request on that connection. And so serve basically never returns. Serve is just like start the loop to listen for connections now and anytime there's a new connection, create a new service. And anytime there's a new request on a connection, then pass it to that connection's instance of a service and get the response back and then serialize that back over that same connection that the request came in on. And all of these bounds are all about like making sure that you actually have an HTTP connection that you can read and write from, that the errors are sendable across thread boundaries and all that. And then we'll get into exactly what a service is, because that's sort of the natural next point to get to. And if we, oh, how did I end up so far down? As you see here, when you call serve, you get back an actual server object, which is a future that you await.
00:22:43.265 - 00:23:54.585, Speaker A: And when you await that, that await essentially never returns. It would return if the hyper server itself panicked, which basically it does not. There is a with graceful shutdown which lets you take a future here and when that, when this future returns, this future, when this future here resolves, then the server is going to shut down gracefully and this await will resolve and this unwrap will finish with an okay. And so then you might be able to run additional commands after this. So commonly what you would do is do something like set up a one shot channel, where in fact we can, we can just do this Tokyo sync one shot channel and then this would be RX await. And so now, right, so this will. Now this graceful shutdown future will resolve the moment we send on shutdown.
00:23:54.585 - 00:24:21.933, Speaker A: And so now you can pass the sender part of this channel to like a control C handler or whatever you might want to do. And so whenever you want the server to shut down, you call shutdown.send and you just send an empty thing and then the server is going to shut down on its own. This future will resolve and you can continue. The other way in which it resolves is if it encounters an error. Like, for example, it tries to call Accept to get a new connection. And like, the socket itself is broken in the kernel and you get a.
00:24:21.933 - 00:24:41.065, Speaker A: Or like the. I don't know, the address has been. The network interface has been janked out, so you can't accept any more connections. So the kernel returns an error to Hypr's Accept call. That error would also propagate up here. But let's get rid of that. That's just extra noise.
00:24:41.065 - 00:25:24.759, Speaker A: Okay, so that's how you set up an Axiom server. That's sort of the glue that puts all the pieces together. Let's now talk about tower services. So it says pretty prominently in the Tower in the Axum docs that. Can I find the. Maybe not here, but in Axum over here it says, I thought I saw the word unique here. Has it gone away? Ah, the last port.
00:25:24.759 - 00:25:55.015, Speaker A: The last point is what sets Axum apart from other frameworks. That is this point, it takes full advantage of the Tower and Tower HTTP ecosystem of middleware services and utilities. Axiom doesn't have its own middleware system, but instead uses tower service. This means Axiom gets timeouts, tracing, compression, authorization, and more for free. And by free here, they mean via other things that already implement this trait independently of Axum. Like, people don't implement the Tower service trait because of Axum. They implement it for all sorts of other reasons.
00:25:55.015 - 00:26:35.575, Speaker A: But if you're using axm, you can make use of those implementations, which allows you to do things like share middleware with applications written using Hypr or Tonic. Okay, so let's now look at the service trait from the Tower crate. So the tower crate mostly exists around this trait. Like it exists to define this trait and to allow an ecosystem to develop around that. This service trait and the service trait fundamentally is a trait that takes in requests and asynchronously produces responses. And these aren't tied to HTTP. They can be requests of any kind, responses of any kind.
00:26:35.575 - 00:27:20.245, Speaker A: And the idea is that when you call what you get back is a future where that future types output is a result that is either a response or an error. So it's a very. It's almost the most generic way you can think of expressing a service, which is the intent, right, that you have this trait that everyone can implement. If they have anything that deals with requests and responses. You'll see there's a poll ready and a call here. We're not going to dig too much into why those are there, but the basic thing, in fact, there's a great article. Where can I find this blog? No, that's a lie.
00:27:20.245 - 00:28:31.531, Speaker A: Where is that article? Maybe it's under Tokyo. Where's the article? I'm thinking about Google Tower service trait Async fn. Where is that article? This one? It was from the Tokyo blog. Okay, so this, this blog post is really good. It basically goes through how we arrived at the exact structure of the service trait. I'll send a link here in chat. But the basic way to think about service is that a tower service is roughly equivalent to something that implements async fn, request to result of response and some error.
00:28:31.531 - 00:29:00.929, Speaker A: Type E for. Let's in fact do this for some request and E. So it's sort of generic over request and E. Like you might have a function that you might have a type that implements that supports multiple different types of requests. For example, you can implement the straight multiple times. But the very basic premise here is you have an asynchronous function from request to a response. So that's how to think about tower services.
00:29:00.929 - 00:29:36.485, Speaker A: What's really nice about this is that they compose. So imagine that you have one function or one type that implements the tower trait. It has an asynchronous function from request to response. And then you have another function that does the same. So you have, you know, A and B. You can now define a C that takes a request and returns a result of response to E. And what it will do is it will call A of B of R.
00:29:36.485 - 00:30:25.489, Speaker A: No, I'm lying, I'm lying. They don't compose in this way. They compose through the use of a separate trait which we haven't talked about yet, called layer here. Where is the layer trait? Layer? So separate layer trait that lets you take services and sort of merge them. So you can in this case say A dot layer B. And what that produces is a thing that is now that implements service that applies both A and B to your request and returns the response backup. And so you can pass in here the request and that's how layering kind of works.
00:30:25.489 - 00:31:56.345, Speaker A: Again, we're not diving too deep into the mechanisms of tower here, but I more want to give you the mental model for what these services are. They are ways to express asynchronous mappings from requests to responses. And every axiom handler is fundamentally one of these, or rather to be more accurate, gets turned into one of these. Okay, so that's enough stuff you need to know about service in order to follow the rest of this, I think. So that then gets us to the question of, well, how, when a request comes in, how does it actually end up calling root, and how does that get turned into response? Like we have this function, but how does that turn into like something that takes an HTTP request and turns it into an HTTP response? Like, how does this transformation happen? Is somehow transformed into by axum. Right? Somehow that happens. And somehow that also happens for this, this function, which is constructed very differently, somehow also gets turned into that same tower service, that same kind of asynchronous mapping.
00:31:56.345 - 00:32:52.835, Speaker A: Right, so that's the idea here, that you want all of your handlers to eventually turn into one of these things. And if we go back to something like a router. So we were talking earlier about what does get really do? Well, really you can think of get as it gets a request in and it's eventually going to return a response. And really it has like a map somewhere of all of the, of the, the inner handlers. In fact, maybe even let's reconstruct method handler is H, where H is some handler type. Let's do get imposed for now. And so we're going to implement service for method handler.
00:32:52.835 - 00:33:37.719, Speaker A: And service takes a request and response is going to be HTTP response. I'm not going to write this accurately, but just accurately enough that it's fine. And so when a request comes in of type HTTP request, then we have to asynchronously produce a response. Well, what we can do is we can match on rec method. And if it is get, then we call self.get of REC await and if it's post. So that is what a method router is.
00:33:37.719 - 00:34:18.587, Speaker A: So when you call the get function, the get router here, what you're really doing is you're constructing one of these method handlers and saying that the handler forget is the function that was passed in and the handler for all the other methods is return the method not allowed error. That's the way to think about it. Like there's sort of a fallback here that's also a handler and so all of these are really an option handler. And so this is like if self.get is sum, this is if self.post is sum. Right, you get the idea.
00:34:18.587 - 00:34:52.181, Speaker A: And if none of these really go anywhere, so for anything else then we call self fallback. And the fallback by default is return. A 405 method not allowed. So that's what a method handler is. A method handler is really a service that wraps a bunch of other services. These H's here are themselves themselves asynchronous functions from requests to responses. And then you then now you can start to sort of see how this composes.
00:34:52.181 - 00:35:32.985, Speaker A: Right. So imagine that, imagine you have this, you know, the outer router. It needs to know, well, how do I route this path versus this path? Well, I might have something like a path handler. And it is just a paths which is a hash map from string to handler. And it too has an impulse like this. And again, H here is just a service HTTP request really. So we could even do, if you wanted to think about it this way, something like a box DIN service HTTP request and response is HTTP response.
00:35:32.985 - 00:36:30.439, Speaker A: So in fact, if we want to be nice to ourselves here, type H equals that. And now this applies to the example further down as well. And again, of course I haven't actually imported any of these. Like this is going to produce a bunch of errors, but you can sort of glance at it and see that this is what makes sense. So if we now implement this for path handler, then it instead of matching on the method, it's going to match on the path. Or rather it's going to do self path get rec path and we're gonna and if let some handlers equal to that then handler of request await return that otherwise you know, self fallback rec 08. There are lots of errors here, but you hopefully you get the the idea.
00:36:30.439 - 00:36:50.863, Speaker A: Let me get rid of some of the errors. It might actually make it easier to read. Right. So a path handler is also just a service that takes a request and returns a response. But internally has a bunch of service and it chooses which one to forward to. That's how routing works. And it's really nice that you can just compose them in this way.
00:36:50.863 - 00:37:30.791, Speaker A: You can imagine constructing your own routing function that just has some other logic for how it chooses which handler to call. But this still gets us to this box didn't service bit like what this really means if you think about it, is that the argument to get here has to implement handler. Like it has to implement service from request to response. At least Kind of. Right, but here we're calling it with one function that's just an asynchronous function from nothing to string. Here we're calling it with a. An asynchronous function that takes some like, JSON object as an argument and returns a tuple that has a status code.
00:37:30.791 - 00:38:26.425, Speaker A: Like, how does that mapping happen from the handler to a tower service? If we go further down, right? Like this is somehow transformed into H, that type alias we had further up, or if we want to copy it so that we see it again, it's somehow transformed into this. How does that happen? And similarly down here, this one is also transformed into that same type how. And this is where we get into what I think is the sort of maybe the nugget of Axum. So let's now dig ourselves back up a little bit to here and go to handlers. In Axum, a handler is an asynchronous function that accepts zero more extractors. We'll talk about extractors later as arguments and returns. Something that can be converted into a response.
00:38:26.425 - 00:38:46.779, Speaker A: So we already see the sort of shape of this, right? The thing that you return has to be possible to turn into a response. Fair enough. Handlers are where your application logic lives. And axiom applications are built by routing between handlers handlers. That all makes sense to us. Okay, let's look at the handler module here. They just give a bunch of examples of them.
00:38:46.779 - 00:39:21.173, Speaker A: But let's go down and look at the handler trait. Okay, the handler trait is kind of close, right? So a handler is something that, okay, it has a future. You can call it with a request and state. We don't know what state is yet. And returns one of these futures. And the output from the future from that future has to be an axum response. Okay, so it takes an axum request or an HTTP request and returns an axiom response.
00:39:21.173 - 00:39:55.475, Speaker A: This looks a lot like service. And in fact, we see here handler, service. We look into handler, service, handler, service. Slow that down a little bit. Implements tower service. Okay, so there's like some path here where you can start to sort of see the shape that if we go back here to the method signature of the routing, if we go to no, that's unhelpful routing. We could get.
00:39:55.475 - 00:40:27.171, Speaker A: So get takes a handler H, where H implements handler. So what that means is this asynchronous function from root to static string implements handler. Otherwise we wouldn't be able to call get with root. Right up here we call get and we pass in root. So root must Implement handler. Otherwise we wouldn't be able to call this function, because that is the trait bound of get. And similarly, post is passing create user.
00:40:27.171 - 00:41:16.759, Speaker A: Let's assume that post has the same trait bound, which it does. Then that means a create user. So this function also implements handler somehow. Okay, so this handler trait, this whole thing is somehow implemented for all of our random functions. And when we change this to have like query with params here and hash map string to string, and we added in what append headers here when we made all these modifications, this thing somehow still implements handler. How does that work? How is it that almost any function we write here, this is not quite true, but. But it feels like anything we want to put here just kind of works.
00:41:16.759 - 00:41:59.425, Speaker A: It somehow is a valid handler. Well, now we get to the key. So the handler trait is automatically implemented for a lot of types. And if you look carefully, you see there's a pattern here, right? Like it's not random types, it's for a bunch of tuple types with an increasing number of tuples. This sounds suspiciously as though there is a macro at use, and of course there is. So if we go into the source here and we go to handler and we go to mod. Let me scroll down.
00:41:59.425 - 00:42:30.069, Speaker A: Okay, we see some macro magic here. So you see there's an implementation of handler where the first thing here is the empty argument list, basically. And S, we don't know what S is yet. It's state, but we haven't talked about it yet. If you have something that is just like the empty handler, then you do nothing. You just like. If it takes no arguments, then you just call it with no arguments and you turn whatever comes back as a response.
00:42:30.069 - 00:42:52.447, Speaker A: That's fine. And then we have this ugly macro business here, and we're actually going to read through this macro in a second. But if we scroll down here and you see we're here all the tuples impl handler. So it's passing a macro to another macro. Okay, what's all the tuples? Let's go over here to all the tuples. Aha. All of the tuples.
00:42:52.447 - 00:44:02.485, Speaker A: Indeed. So you see here, this calls the macro those passed in with macro with tuples of increasing length. Why? Why does it do all this? Well, if we go back to handler, this first type, this T that we see here, let's look at the where is my handler service? There's so many trait boundaries I want to find, right? So if we scroll down here, let's look for something that is a meaningful length, like this 1mt1t2. So handler is implemented for any F. F is generic here for any F where F implements FN ones. FN ones is. We talked about this in the crust of rust on function pointer types.
00:44:02.485 - 00:44:47.855, Speaker A: So a fn ones that takes two arguments, t1 and t2. Notice that this matches with what this first type is in the handler trait. So any function, this handler trait is implemented for any function F that takes two arguments and returns a fut. FUT is a generic, where fut is a future and the output of that future. The thing that the future returns is a rest, which is a generic, where rest implements interresponse. And interresponse, as you can guess from the name, is something that can be turned into an HTTP response. And then you see the last bit where T1 and T2 implement from request parts and from request.
00:44:47.855 - 00:45:32.497, Speaker A: And let's now scroll down to something that's much longer to see if the pattern holds. Okay, so here we something that takes, I guess, 13 arguments. Okay, so just handler's first generic parameter is M. And then all of these type parameters and F implements handler. If F is a function that takes 13 arguments and returns a future where the futures output is res and where res implements interresponse and where all of the types that are passed, all the types that are arguments to that function implement from request parts. And here too, you see, the last one is special. The last one implements from request and not from request parts.
00:45:32.497 - 00:46:39.755, Speaker A: We'll talk about that in a second too, but see how the pattern holds? Like the handler trait is automatically implemented for functions of basically any argument length, as long as all of the arguments implement from request parts, and the last one implements from request and the response implements into response. So let's do a sort of basic test here. Okay, here we have an asynchronous function. Okay, so does it return a fut where implements future? Yes, check. Does FUT output implement inter response? Well, let's see, what is interresponse? Inter response is just something that can be turned into a response, where response here is HTTP response and it's implemented for the unit type. Okay, whatever parts is, let's ignore that for now. It's also implemented for.
00:46:39.755 - 00:47:33.023, Speaker A: And here we see this sort of macro magic again, where it's tuples of basically any length. So it's all this trait is implemented for tuples of lots of different lengths, where all of the individual components of the tuple themselves implement inter response or interresponse parts. And the last one implements inter response, the separation between parts and the last one being different, we'll talk about in a second, I promise. And you see, there's a special case here for status code. So if status code is first, status code I think does not implement interresponse or inter response parts. Yeah, so it does not implement it during response parts. So it's sort of handled specially where status code can be the first thing before the other arguments.
00:47:33.023 - 00:48:06.347, Speaker A: But all of those have to implement inter response parts or inter response if they're the last one. Okay, so then the question becomes, well, here we only return one thing, which is the static reference to a string. So does static reference to a string implement implement into response? Yes, it does, right here. So the interresponse trait is indeed implemented for that type. And if we look at it, it just is the same as a cow borrowed. Okay. And cowborrowed.
00:48:06.347 - 00:48:31.775, Speaker A: We see the implementation for here and it inserts into the headers that the content type should be text plain UTF8, which is what we saw when we curled against that endpoint. So that's where this comes from. And full from this is the body type. Full here is saying the entire body is available straight away. It's not like a streaming body or anything. And we turn that into a response. Great.
00:48:31.775 - 00:49:11.575, Speaker A: So now we understand sort of where that response gets built up from. So does it implement response? Yes, it does. Check. Does every argument except the last implement from request parts? Well, trivially check, because there are no arguments. Does the last argument implement from request? Well, there is no argument, so yes. And so that's how this ends up working. This one ends up using the implant for handler when the argument list is empty.
00:49:11.575 - 00:49:39.653, Speaker A: So right here, this implementation is what we use. And that implementation is just going to call this function. That's all that implementation of the handler trait does when that is what the signature is. And then it's going to call inter response on the response here, which calls that function we just looked up or that implementation of inter response that we just looked up. And that's how you get a response. Great. And there is.
00:49:39.653 - 00:49:57.873, Speaker A: It's not actually very advanced generics here. Like it's not actually generic over functions of any argument length. It is macro expansion. Right? There's. There's the. All the tuples one that we saw. So it will only actually work for handlers with up to 16 arguments.
00:49:57.873 - 00:50:29.417, Speaker A: If you have more than 16 arguments, it will not implement the handler trade automatic. Then you would need your own type that you implement handler for. It would be nice if this was just sort of Supported by the language directly. But for now, this is a trick where you don't really notice that it's a trick. Oh yeah. So tuples also implement from request. So this also means that any one of these can itself be a tuple.
00:50:29.417 - 00:51:04.671, Speaker A: So you can actually construct larger ones if you're willing to do some nesting in there. Oops, that's not what I meant to do. Okay, so now we have looked at root. Great, let's now look at a more complicated one. So if we go back here, we do the same sort of checklist. Does it return a future? Yes, because it's an asynchronous function. Does the output implement into response? Well, this is a tuple where the first thing is status code.
00:51:04.671 - 00:51:42.285, Speaker A: Okay, great. The second thing is append headers and the last thing is JSON user. Okay, append headers. Does that implement into response or into response parts? Right, so remember the rule here is that we need to that a tuple here implements into response. If the first thing is status code, the last thing implements into response and the middle things all implement inter response parts. So does append headers implement inter response parts? I'm going to just tell you the answer is yes. Does the JSON type implement.
00:51:42.285 - 00:52:20.421, Speaker A: Oh, why did I scroll? Does the JSON type implement into response? Well, let's go look. So we look at the JSON type. No, not that one, but the response JSON type. Okay, so what does it implement? It implements inter response. If t implements serialize, which is what you would expect, that if you say that you return a JSON of some type, that thing is serializable so that it can be passed to serdejson and produce the right thing. And so that might make you wonder. Well, let's finish the analysis and then we'll do the wondering.
00:52:20.421 - 00:52:49.065, Speaker A: Okay, so this response type does implement into response. Great. Does every argument except the last implement from request parts? Well, so that would mean that query needs to implement from request parts. Well, let's go look at query. So query is what's known as an extractor. We'll talk in a second about what extractors mean. It does indeed implement from request parts.
00:52:49.065 - 00:53:35.545, Speaker A: If you want to look at it like, I recommend going to look at this like what from request? The implementation of from request parts for query is really just calling. Let's do from try from uri. It extracts the the URI from the request parts here is just like the request but split into its constituent parts. So the URI from the query, it extracts the query string. So the Things that follow question mark from there. And then it passes that to serde URL encoded, which decodes the stuff that comes after the question marks into a type using the deserialized trait. Right, deserialized owned here.
00:53:35.545 - 00:54:11.103, Speaker A: And so this from request parts implementation of query just extracts the uri, extracts the query, deserializes that into a T, and then that's the thing that it extracted. So it does implement from request parts. Great. And then the last part of our rule is, does the last argument implement from request? So does JSON payload implement from request? Well, again, let's go look. So if we go back here, we go to JSON. It does implement from request as long as the type is deserialized. So that's fine.
00:54:11.103 - 00:55:03.807, Speaker A: Let's look at the source here. Well, it checks the implementation of from request is the JSON content type set in the headers, then read all the bytes out of the body and then deserialize with serdejson. And that's kind of it like that's all you really need to do in order to extract JSON from a request. And so at this point we actually know what an extractor is. An extractor is something that implements from request parts or from request. And so it can take the parts of a request or the whole request and turn it into something that can appear in the argument list for a handler and have it still, you know, implement the overall handler trait. Okay, hopefully that this, this journey we've been on so far makes sense now.
00:55:03.807 - 00:55:57.085, Speaker A: You hopefully see how the handler trait sort of fits together here. The last part that was really useful to me actually when I first found it is. Let's go look here at this one. Okay, so this macro right here is what I would argue is the heart of Axum. Let's go to like 223. I don't know why GitHub has started doing this, but it will only highlight lines if I change the URL if I refresh. Okay, so the impl handler trait is the thing that actually implements the handler trait for all of these different function types.
00:55:57.085 - 00:56:31.925, Speaker A: So the argument list here is all of the ones that are in the square bracket. Square bracket is a repeated list of types. Remember, it's the, the list of arguments to the handler, except for that last one and then the last type. The type of the last argument is sort of kept separately in this last metavariable. And so we implement handler for F, where F is an F. And once. And this here's the macro expression for saying repeat all the types in the argument list.
00:56:31.925 - 00:57:10.791, Speaker A: So it's implemented for FN ones that takes two arguments. For example, these bits are fine. REST has to implement into response. All of the types have to implement from request parts, except for the last one that has implement from request. So this is really just the thing that generates the impo blocks we looked at earlier. But then let's look at the actual call here. So what does it do? Well, this is the sort of equivalent of the service trait, right of we get a request in, it splits that request into parts and into parts is really.
00:57:10.791 - 00:57:56.695, Speaker A: It splits the body of the request from everything else about the request. So think like the method, the uri, any additional headers, all of that goes into parts and then the body is kept separately. And the reason it does this and the whole reason why from request parts is separate from from request is because you can only read the body once. We don't want to keep the body like in reference counted memory or something. So that's why they sort of enforce this. From request parts only gets access to the metadata of the request the parts. And the last thing, the thing that gets to implement the from request trait, that one is also given access to the body and so will actually see that this means that you can't swap these two.
00:57:56.695 - 00:58:29.665, Speaker A: If I get rid of this and I import hashmap. Ooh, yeah, up here. So it says. Well, this is a relatively unhelpful error as you'll discover. Many of the errors when you use traits in this relatively advanced way are annoying. But it says the traitbound function JSON and query implements handler is not satisfied. And then it tells you about some other random types that are satisfied.
00:58:29.665 - 00:59:17.155, Speaker A: And what it doesn't tell you, which is a little bit annoying, right, is that it is because in the arguments to create user, this implements from request, this implements from request parts. And that wouldn't work because when, when we run, when Axiom runs the handler, it's going to run all of these things, all the argument extractors first, and they don't have access to the body. And then it'll run the last one which does have access to the body. But that means that JSON here is not given access to the body, so it would need to implement from request parts. But it doesn't because it needs access to the body and therefore only implements from request. There is a thing that can make this a little bit nicer. So there's a.
00:59:17.155 - 01:00:13.675, Speaker A: I think it's mentioned here. Yeah, here. So at the very bottom there's this thing called debug handler and debug handler is an attribute that you can add to your handler, and it will generally give you better errors about what went wrong. I don't know whether it'll work for this case, but let's see. Use axum debug handler, and I need the macros feature. See what it does. Let's see if it can actually help us with this one.
01:00:13.675 - 01:00:56.633, Speaker A: JSON consumes the request body and thus must be the last argument to the handler function. Great, so it gave us more information. It's basically it's a procedural macro that looks for patterns in handlers that are commonly erroneous and tries to give you better errors than what you would get from the trait resolver. Right, so by using that debug handler, it actually gives us a better description of what went wrong, and it correctly identifies that these need to be swapped. And now everything is happy again. Okay, so let's go back to the. Nope, that's the wrong page.
01:00:56.633 - 01:01:42.097, Speaker A: Let's go back to the code we were looking at over here. Okay, so what does call do? Well, it splits the request into the metadata of the parts and the body. Let's ignore state for now. And then this here is a macro rule for repetition and it's repeating over $ty. So that's these, that's all the arguments except for the last argument. And for each one it calls from request parts, passes in a mutable reference to the parts and the state, which we ignore, and assigns that to a variable called ty type. This is just a variable name because all types are valid variable names as well.
01:01:42.097 - 01:02:46.619, Speaker A: It's a little bit sneaky. And if any of the from request parts return an error, then we turn that into a response and return that from the overall call. We have that be the HTTP response. So this is where you would get errors. Like if the if you tried to deserialize the query string into some struct and it doesn't have the right fields, then what you'll end up with is that that call to from request parts for query will fail with an error and it will be turned into a response right here. And as a result no other parts will be exported from the response and the handler will not be called. So this just calls all of the from request parts for all the arguments except for the last, and then it reconstructs the request from whatever is left of the parts and the body that are originally extracted, and then it calls the from request trait method for that last type.
01:02:46.619 - 01:03:37.225, Speaker A: So it actually gets access to the full request that we reconstructed here and not just to the parts. And afterwards it then calls the handler function with all of the arguments that it extracted, right? All of these things that we called from request parts two and that last arguments. So this is where the, the tower service call turns into a function call to the handler with all of the arguments in the right order, with the right types that turns into response. We just await it because we know it's the future. And that response we call into response to in order to turn it into the appropriate response at the end. So that's the entire flow. That's sort of the heart of how do you get take requests and turn them into these handlers.
01:03:37.225 - 01:04:33.049, Speaker A: And you'll see a similar thing if you look at into response. So if we go over to inter response here and we look at the implementation of response into response for whatever this one, for example, there's some random tuple that is in an axiom core response inter response. Look at it on GitHub instead. Maybe response inter response. Where's my macro down here? 41290 so implement response. This is again using all the tuples, no last special case. So that's the same as that.
01:04:33.049 - 01:05:17.547, Speaker A: All the tuples except for responses. The last one doesn't get special cased. So we implement up here we implement interresponse for tuples of basically every length. And the way we do that is we take the response that we get out of the last one. So the last one is kind of special, right? That's the thing that gets to produce the body. So similarly to from for the arguments, the last thing gets to consume the body for the request for the response. The last thing gets to produce the body for the response.
01:05:17.547 - 01:06:19.865, Speaker A: So we call, we get the response from the last argument of the tuple, we call into response on it. So that generates an actual like response type instance. And then we construct the parts from there and then we call into response parts for all of the other arguments and they all get to like, we pass in the parts and they return the parts. So that way they can do whatever modifications they might want to. And that sort of essentially you can think of it as we construct the parts with the body and we sort of pass it through all of the inter response parts that are the other tuples in the in the type. And what we end up with is a response where all of the intermediate handlers, all the response modifiers have gotten to act and that in turn turns into the actual response. Okay, so we can look at the others too.
01:06:19.865 - 01:07:00.695, Speaker A: Like the Others look basically the same. There's a special case for if status code is one of them, a special case for if one of them is HTTP parts. So parts just means you've already assembled a bunch of things that are going to go into the HTTP response anyway. Those just get started, stuffed in there. But those are not all that interesting. And you see here for the R here at the end, R has to implement into response, which is because again, that last argument is the one that gets to produce the body. And so we can see that here too, if we tried to say let's do append headers, let me bring that in here.
01:07:00.695 - 01:07:47.375, Speaker A: I think I can do this. I just want some type that it's happy with, right? And then this can be append headers of back. So in this case I'm not appending any headers. But here you would get a similar kind of error if I tried to do this, because append headers is. And then this. See, now this won't accept it again and I get this horrendous error. Let me do debug handler and let's see if debug handler can be helpful here too.
01:07:47.375 - 01:08:25.837, Speaker A: See what it says. Debug handler wasn't helpful here. Well, we do get this error, which is somewhat helpful. The traitbound status code JSON user append headers implements inter response is not satisfied. The following other types implement inter response and it gives you a bunch of those and 60 others. So that's not super helpful. But the actual reason for this error here is that again, append headers can't produce a response.
01:08:25.837 - 01:09:15.885, Speaker A: It can only produce parts of a response. It doesn't produce a body. The thing that produces the body is the thing that goes last. And I think, you know, you might think maybe it should go first, but I think it truly is to match the order of the arguments in the argument list where the body the body type has to go last so they do the same for the response. I don't know whether I agree with this, but that's neither here nor there. And the reason why it's questionable to my mind is because all of these get applied in order. If we look at the expanded macro over here, you see that all of the type parameters that you pass in, they all get to be applied to the part in the order that they appear.
01:09:15.885 - 01:10:12.935, Speaker A: So the pass through here happens left to right, except for the body thing which is at the end, but actually is applied first. So the ordering gets a little weird. But I think it's for symmetry with the argument list. Okay, so now we have the stuff for like how handlers get called, how this all turns into a service, like how routing works, what the service trait is. And so we're getting pretty close to understanding the sort of whole Belgian waffle. I don't know the whole cake, but there's at least one bit left. But before I go into the last main bit, I want to talk about, let's do questions because I've been talking for a long time and I'm sure this has a bunch of you going.
01:10:12.935 - 01:10:53.293, Speaker A: I did not follow half of that and I'm lost. The body is also generally the last thing actually written over the wire, so maybe mimicking that, it's true. Like, I, I think there are arguments for keeping it last. The reason it's weird to me is because that type gets invoked first to produce the response type and then the others see the response after it produced it. So there's like a. The. The.
01:10:53.293 - 01:11:47.775, Speaker A: The order in terms of time in constructing the response is last, then second, then third, and then fourth and fifth, which is a weird order to me. The idea, the idea is that response tuples is that you shouldn't be able to accidentally overwrite the response. Yeah, you only get to overwrite parts of the response, but not the entire body. For example, should I use tuple as a return type for all the handlers or use something else like impl into response? If it works that way, yeah. So when you write the response type here, you can either give the concrete type or you can just do inter response. This is what I usually use. Right.
01:11:47.775 - 01:12:07.337, Speaker A: And then I need to undo the mistake. Mistake I made, the intentional mistake I made. But nonetheless. Oh, it didn't like that. Let's ignore that for now. It's not important. Yeah.
01:12:07.337 - 01:12:52.499, Speaker A: So you can just use implement response here. And that way if you decide to add another piece in here, it just kind of works. The main thing to be aware of here is even if you write implant response, which is what I almost always do, you're still under the restriction that you can only have one return type. So you couldn't do something like, you know, if RAND is for then return status code not found. Like this won't work. And let rand is 6 and if rand is 4. Because even though you used implant to response, Rust still requires that there's a single return type for the entire function.
01:12:52.499 - 01:13:38.597, Speaker A: And so it's complaining here. And you'll see this better in the actual output. It says mismatch type. It expected the return type to be status code, but here you're trying to return a tuple which is not the same as status code. So you don't get to do this, even though you tried to say I only returned something, that's interresponse. So if you have a type that has to diverge like this, what you do instead is you do this and then you do interresponse here and you do interresponse here. I don't.
01:13:38.597 - 01:14:25.921, Speaker A: I take that back. I want this to be response response. So here I'm saying I'm just going to return the entire response. And the way I'm going to do that is by calling into response myself, because that way there's only now a single type for the entire return type, but I get to still diverge internally. And response obviously implements inter response. Well, I see the reason why status code, we're very lucky we have David, who's basically the author of Axum in the chat. So I'm getting a lot of useful insights there.
01:14:25.921 - 01:15:16.395, Speaker A: So the reason why status code has to be first in all the tuples is precisely to avoid you accidentally setting it twice. So that if you set it here, you sort of know that that's going to be the one that's used everywhere else that's used for the actual response. What about having variatic types in Rust to not use these macros? Variadic function or variation argument lists are really hard to get right into design, into the language. So I wouldn't hold my breath for getting it for probably years. And I don't think we should wait until we get them before building things like this because they're useful. So that would be nice. But it's a much longer forward looking solution.
01:15:16.395 - 01:15:55.161, Speaker A: Okay, so the last thing I want to talk about I think is state. So let's. I want to start by going down here for sharing state with handlers. So there's an extractor. And again, remember, extractors are just things that implement from request parts. That's the only requirement for something to be an extractor is that it can extract things from either a full request, including the body, or from the parts of a request. There's an extractor called state, which works a little bit differently.
01:15:55.161 - 01:16:47.957, Speaker A: So when you want to have shared state between your handlers, think something like a pool of database connections or even just a data structure behind a mutex or whatever it might be like you just want to, or a configuration like anything you might want to share here, represented by app state. You construct the shared state, you construct the router, you Call route and you call dot with state. So this basically hands that state into the router so that it is going to pass it to all the handlers. And we'll look at how that works because it's actually really interesting. Once you call dot with state like this, you're able to now in your handlers declare in your argument list, I want state. And that is one of these. And so let's go look at what that actually looks like.
01:16:47.957 - 01:17:41.845, Speaker A: So let's say for create user here, we also wanted. I can't use that, can I? Arc, they just use. Yeah, fine. So I can do this and then I can appear, define, you know, struct app state. And it would normally have fields, but it's not going to have them right now. And then up here, for my route, I'm going to call with state, arc, new app state, whatever fields that might have. So that's all it really takes.
01:17:41.845 - 01:18:14.215, Speaker A: Now, every handler here. So I could do the same thing up here for root now. So I could say root here is also going to get access to state. And in practice what that means is they're going to get separate clones of the state. And so that's why the ARC is here. Because if you have multiple handlers, like those handlers might be called in parallel, you might have multiple handlers that all want access to the state. And so it needs to be cloned in order to be shared.
01:18:14.215 - 01:18:51.693, Speaker A: You could imagine using like a static reference or something. But ARC is an easy way to get something that's trivially clonable in order to share them. So the requirement is that for anything that you pass in with state like this, it has to implement clone. So it's pretty common to see ARC immediately following state. And so now inside of state, this can access state and so can this one. And they are referencing the same state because if you clone an arc, you get a reference to the same thing. But how does this work? Like, so far, when we say from request parts or from request, it's all a bit about things that are in the request.
01:18:51.693 - 01:19:21.471, Speaker A: How are they getting access to this state thing? Well, I'm going to ignore things like closure captures. You can read that on your own time if you want to. State is the sort of most common way to go about this. So the state extractor also implements from request parts. If we go look carefully at from request parts. This is an async trait. That's why it has a little bit of a weird signature here.
01:19:21.471 - 01:19:54.609, Speaker A: So let's look at the source instead. From request Parts is generic over S. S for state. We'll see why in a second. And the fromrequestparts function does get parts, which is the parts of the HTTP request, but it also gets a reference to the S to the state. So this is how the state extractor can be constructed from request parts, because from request parts also gets access to that state. That seems easy enough.
01:19:54.609 - 01:20:38.517, Speaker A: But this generic is scary. Isn't this going to end up everywhere? And you see, there's some weird, like distinction here between outer state and inner state. That one is actually just because if imagine that there's like here I want like root state, and here I want create user state. So I sort of want them to get specialized states. But root state and create user state are both like part of the app state. So this has, I don't know, root, just root state and create user state. Imagine that this was the structure, I had this indirection here of having two generics.
01:20:38.517 - 01:21:17.059, Speaker A: And then you require that the inner state, which is what you actually need, implements from ref to the outer state. So from request parts is past an outer state, here app state. And as long as you can construct an inner state from a reference to the outer state, you're fine, right? Then you can call the handler with the state that it wants. Like you can call root with root state by extracting the root state from the reference to the app state. But this distinction we won't have to think too much about. But the implementation here is implement from request parts of state for state of s. Great.
01:21:17.059 - 01:22:39.683, Speaker A: So there's the requirement here that the moment down here where we say, let's go back to having this be app state. For simplicity, when I say I want a state of this, what that actually means is that this handler now only implements. Remember, these functions only implement handler if the arguments implement from request parts, but state only implements from request parts for this generic state. So that only this doesn't implement doesn't implement from request parts for any S, it only implements from request parts S for app state or arc app state. Really. So this now means that the implementation of handler for root is conditional on S being equal to arc app state. If there's any other S here, then root would not implement handler for that size.
01:22:39.683 - 01:23:33.003, Speaker A: So if we go now back to handler, the handler trait is also generic over S. T is the argument list and S is the state. So what this really means is implant t S for root. This doesn't exist. There's no generic implementation of handler root only implements. This, right? This is the only version of Handler that root implements. So what does that mean? Well, remember how for get get required that the handler implements handler for any S.
01:23:33.003 - 01:24:15.255, Speaker A: Okay, great. So this is generic over the S. So you can pass in to get, you can tell get what state the handler is going to require. But inference works in both ways. So what actually happens here, and this is we're getting into a little bit of, like, nuances of the trait resolver, but basically, when I call get root here, what really happens is the compiler starts to infer what these types are. What these generic types to what hts and B. So H is the handler, so that's going to be equal to root.
01:24:15.255 - 01:24:33.763, Speaker A: That's because that's just what's passed in. So that's easy. This is the type of the argument, like it's dictated by the argument we gave it. T is going to be the argument list, which for root is the empty tuple. It takes no arguments. So that's also easy. B is the body, which is box body for everything in Axiom.
01:24:33.763 - 01:25:24.225, Speaker A: So it's a boxed body, which might be a streaming one or an already allocated, like full string or byte slice, but the S isn't tied to anything. So what actually happens here is the sort of an inverse inference where the compiler knows that root only implements handler if S is arc app state, and therefore it infers that S must be. So it's not equal to, by virtue of being called, it must be arcapp state, because that's the only way that this will actually work. And route. So now we go back to router. Router also has an S. Okay, so router is generic over some S.
01:25:24.225 - 01:26:08.775, Speaker A: And when you call route, that's a method router over S when that S is tied to the S in get. So the inferent goes all the way back to infer that this actually means that this router, which is S and oops, S, S and B. Well, B is box body, that's fine. But the S here is inferred that it must be app state. So the inference goes back for get and then for post, it then goes sort of forward that all of these S's have to be the same. So for post here, they must also be the same. And here is not inference.
01:26:08.775 - 01:26:39.415, Speaker A: Here is just it must be equal to that. Well, so now let's see what happens if we just let me get rid of. Oh, do I want to get rid of these? Mmm, yeah, that's fine. I'll get rid of these. No, I don't want to get rid of them. I Take it back. Okay, so what does that mean? Well, that means that at the end of this call chain of calling route, what we have is a router where S is arc app state and B is box body.
01:26:39.415 - 01:27:29.469, Speaker A: And we know that in order to pass this application. Oops. In order to pass this application into serve, it needs to implement tower service, technically a service service. But ignore that for a second. Well, if you look here very carefully, we implement tower service for a request over B for router of unit and B. So the service trait is only implemented for router if the state is empty. Well, now we have a problem because the inference here told us that at this point S is equal to arc app state, because that was inferred from the fact that we passed in root here.
01:27:29.469 - 01:28:17.615, Speaker A: That is the only S that works. But in order to be able to call, in order to be able to call serve, down here, the sort of S inside of app must be equal to unit. But our gap state and unit are not the same thing. So how do we bridge those? Well, that's where with state comes into play. So with state takes in a state and returns your router with a different state parameter. And in our case, we make use of that by saying with state, and then we pass in the app state and we can just say what state is required. Next we can just say with state, this is now unit.
01:28:17.615 - 01:29:22.599, Speaker A: And in fact, that's inferred for us because S must be unit, otherwise this call wouldn't work. So the way to think about the S on router is not that it's the type that you've passed into the router. It is the type that the router is going to require before it can be used as a service, or in other words, the route. A router with some S that's not unit needs to be provided with that state size before you can use it for anything useful. Right? So which makes sense, like root, we can't use root as a handler until we have provided the state that it's going to eventually see. And so hence this sort of slightly weird but really neat trait trick that makes it so that it's just impossible to construct a router and try to use it to serve requests if you haven't passed in the necessary state. But this should raise another question mark for you, which is, okay, we've done all this business.
01:29:22.599 - 01:30:34.805, Speaker A: Let me, let me get rid of all of my extra annotations here. Okay, so down here is equal to unit. So how does with state work? How does it accomplish what it does because root requires a state like it, it needs to be pat, that state needs to make it in the into the request somewhere. Right. When we looked at this from request here, you see state is equal to a reference to state and state is just passed into the call in handler. But if we now go back all the way to tower service, which remember is the trait that actually drives all of this. In call for tower service, the only thing you have is a request.
01:30:34.805 - 01:31:22.005, Speaker A: But in call for handler, in fact, let me put a handler here might be easier. So call for service, the only thing you get is the request call for handler. What you get is the request and the state. Where does that state come from? How does the state make it from the router and into the handlers when they actually get called? Well, we actually found this earlier. So see how on handler there's call, there's layer for stacking them and then there's this innocent looking function with state. And what with state does is it takes a handler, anything that implements a handler trait and it gives you a handler service. So you provide it with the state and it gives you a service.
01:31:22.005 - 01:32:03.949, Speaker A: And that kind of makes sense. And let me show you how that actually works. So a handler service holds the handler and the state and then it implements. Where's the implementation here? Implements. This is tower service now. So it implements tower service request for handler service where hshandler and the call here is handler call pass in the handler. So this is basically the same as handler call, right? Pass in the request and clone the state out of ourselves and pass that in.
01:32:03.949 - 01:32:42.493, Speaker A: So that's how the state actually makes it in is that you have to, in order to turn a handler into a service, you have to pass in the state that it needed. At that point it no longer needs the state. You don't need to pass the state in with every call because that's handled automatically in this impl of the type. And so that's what happens for you in router. If we go back here to router. So when you have a router and you call with state at the end there to make it so that it no longer needs its state. Well, router internally has like path routers and fallback routers and whatnot.
01:32:42.493 - 01:33:44.441, Speaker A: But if we find the path router with state. Let me dig that up real quick. Path router, where's my path router at? Over here. That maps into method router and method router with state states. Ah, that's a good state. Sorry, let me dig this one up real quick. Right, so Method endpoint here we ran really deep into the stack.
01:33:44.441 - 01:34:09.675, Speaker A: But basically this is the thing that get produces when you call get. When you call the little get router function and you pass in root, you pass in a handler. What it does is it boxes. In fact, let's look at it. Why not? We have nothing to hide. We're here to learn. We will do so relentlessly.
01:34:09.675 - 01:34:34.737, Speaker A: So what does get do? Well, all of these do basically the same thing. Where is my top level, top level handler fn? Top level, top level handler fn. Where you at here? So many layers of indirection. I understand why they're there. It just makes me. Makes my job harder. Okay, I'm not going to show you.
01:34:34.737 - 01:35:14.715, Speaker A: Then I take it back. But what happens is when you call get, it takes the handler that you get in, it boxes it so that it can store them all like together, and then it produces one of these. What a method filter. So this is the thing that we looked at earlier where like, it implements service, and depending on the method of the incoming request, it chooses which handler to actually call. In the case of the get constructor, it will call that handler if and only if the incoming method for the request was get. And the individual thing that it stores is one of these method endpoints. And the thing that it stores in there is either none.
01:35:14.715 - 01:36:10.165, Speaker A: If there is no handler for like post, for example, then the handler is none. And so it does nothing. Let's ignore route for now. The default state of this type is this boxed handler. So that is, you know, when you call get root, it takes root, it boxes it, and it constructs a method endpoint boxed handler, and it sticks that in there when you call with state. If it discovers that what it currently has is a boxed handler, then it knows that that handler still hasn't been passed its state because it implements a handler trait, not the service trait. And so when you call with state, like on router, it ends up calling with state all the way down into all of the handlers, including down to this little method endpoint, which then calls into route on handler, which then gets us to interroute, which we're almost at the end of the journey, I promise.
01:36:10.165 - 01:36:49.305, Speaker A: So into route over here. Where is into route again? It's like over here somewhere. No, not that one. It's. No, it is in boxed. It is over here, right here into route. Just trying to find the actual call to it.
01:36:49.305 - 01:37:33.157, Speaker A: Actually, I'm going to, I'm going to skip one step. I apologize for skipping it. But when it finds that what it currently has is a boxed handler and it is provided with the state. It calls this into route thing, which indirectly ends up calling this from handler function for boxed into route. And what that does is it takes the handler passes in the state. So this is how we go from a handler to a handler service. And it creates a route which is really just a boxed service out of that and turns that into an erased handler.
01:37:33.157 - 01:38:31.005, Speaker A: And an erased handler all the way up here is a handler that you've already turned into a service. So it already has all of its state. And when you do that, it gets turned away from being a method endpoint boxed handler into being a method endpoint route. So a route is a thing that doesn't need its state anymore because it's already been provided it. I know this part is convoluted and hairy and hard to follow, but it's a little bit important, which is that the moment you provide the state to a handler, it turns into a service. That's the key part to take away from this. So over here, the moment we've called with state now, now router is a service.
01:38:31.005 - 01:39:17.373, Speaker A: And so we can actually after with state, we can now call route again with something that requires some other kind of state. So let's in fact do this because it might actually be useful to demonstrate. So let's say I have root one, I have root two, and root two takes a completely different state. It actually takes a mutex over a bool. Actually it just takes an arc bool. Why not? So these take different states. So how do we make this work? Well, the way that you make that work is you construct all the routes that require one of the states and then you call with state with that state that it needed.
01:39:17.373 - 01:40:09.009, Speaker A: And so now all of those handlers have been turned into services that internally store the state that they needed. And so now if we call, if we create a new route that requires a different state, then now we can pass in that state over here. And now these things had already been turned into services. So they don't see this new state, they're unaffected by it. This route, this handler which doesn't have its state yet is provided with its state and so now is turned into a service and doesn't need its state anymore. And you can keep doing this so you could keep adding more and more states if you really wanted to, and have different routes that require different states. And this also means you get into really interesting things.
01:40:09.009 - 01:41:39.325, Speaker A: Like you can imagine that you have handlers that require different states and you actually say well, this with state only provides like half of the state, so it provides. Actually I'm not going to talk about it unnecessarily complicated, but this piece is important to understand, which is that when once handlers are provided with their state, they stop becoming hand, they stop being handlers and start being self standing services that do not need their state anymore because they already have it internally cloned. Okay, I know that's a rabbit hole, but I think the conclusion from it is useful and hopefully if you rewind and watch it again, then it'll eventually make sense. It took me a few goes to piece this part together as well. One of the things that hopefully you find useful from this is to see the value in sort of jumping through the call chains and seeing where do the types change from one to another, where do things implement different traits, look at the source of those implementations and figure out how that worked. So hopefully this was useful even if the specific conclusions from it are somewhat inscrutable. Okay, let's do more questions now because hopefully, and presumably you have some from this.
01:41:39.325 - 01:42:41.287, Speaker A: Oh yeah. So one thing that's worth pointing out here is that even for the people who built this, this was not an obvious design from the start, right? Like this is convoluted, but it's not as though some people are just so smart that they come up with this like immediately and it's just perfect. Quite to the contrary. What happens is you start with something that is, you know, not as strict as this, not as complicated as this, and then you discover, for example, that there's a foot gun here, right? Like it's possible to put in a route and forget to provide the state for that route, but still try to start serving requests from it. So now you get runtime exceptions because you didn't pass in the state. That's bad. How can we solve this? And you iterate on the design until you get to something where you can guarantee it at compile time.
01:42:41.287 - 01:43:25.215, Speaker A: It's not as though this fell out comp complete in the beginning. Rather it took a lot of iteration to get to the point where you have something that is enforced at compile time to this extent. The other thing I want to point out here is that I didn't dwell on this too much, but there's a lot of boxing happening here. There's a lot of trait objects, there's a lot of like trait erasure and generic erasure into boxes, which does impact performance, but in practice I just don't think it meaningfully slows things down here. Because once you have a web server, like your bottleneck isn't dynamic dispatch. Right. Your bottleneck is stuff like IO or talking to your database.
01:43:25.215 - 01:43:57.537, Speaker A: So if you can make the. The ergonomics of using the tool nicer by doing a box somewhere, it's probably worthwhile. Yeah, box.rs is. I don't know if it's the most complex file, but it's probably the most cursed file. Let me go just pull up boxed here because it is. It is fun.
01:43:57.537 - 01:44:58.605, Speaker A: Boxed, there's a box is the thing that does all of this boxing things and providing the state and turning things from handlers into tower services and does like erasure of generic types. There's a lot of just cursed voodoo in here that only. You only really see how cursed it is when you start seeing how it ends up being used throughout the code base and how all these state transitions happen for the types. But it is really interesting. Can you talk about multipart send in Axum? I think multipart send is really just a. A body type that you can construct in parts. And yeah, so it uses.
01:44:58.605 - 01:45:39.039, Speaker A: There's another library called molter. Yeah. Which lets you produce multipart types by essentially providing the constituent part separately. And then when it tries to produce an HTTP response, it streams it out with the appropriate encoding. Similarly for like, we didn't really talk about this at all. But here you can do things like colon me and now this is actually a string argument in the path that can be extracted and can be any value and the router has to deal with that. But that's actually not implemented in Axiom itself.
01:45:39.039 - 01:46:43.979, Speaker A: Axiom has to deal a little bit with it, but it's actually implemented through a library called matchit that I mentioned at the beginning, which does efficient routing from like strings with these parameterized parts to it into like what is it it constructs. It constructs like a prefix tree like a radix or. It's a radix try that lets you efficiently do like string matching of real URLs against the patterns and then find the appropriate value in a map. That's actually a try really neat data structure too that Axiom is using below the hood or under the hood in order to do. It's mapping an incoming request into the appropriate path handler and you can see those parts in routing path router. So the whole thing in path rounder is the sort of key part of it. Here is this node thing which.
01:46:43.979 - 01:47:31.695, Speaker A: Let me see if I can find it here. The trick is always you just look for the Implementation of service. Maybe that was the implementation service. Actually, now that I think about it, no, I can't Found it Route validate path. No, route is for creating one. Where is is it? Is it call with state? So it extracts the URI from the request, it extracts the path and then call self.node.at and node.
01:47:31.695 - 01:48:37.315, Speaker A: Here is one of those match it things and what that gives it back is the handler associated with the path pattern that matched that path. So all of the actual like string searching happens inside the matchit library. And then this really you can access almost like a hash map, except that the lookups are fuzzy, if you will, or parameterized or searches rather than direct match lookups. Are there any somewhat near future rust features that will obviously serve Axiom? Well, I think typeal is impul Trait will probably help a little bit. There are a couple of places currently where Axum has to box, but only because we don't have type alias infiltrate. David can hopefully confirm that, but that should be the case. I don't know if there are any others that are like likely to come anytime soon.
01:48:37.315 - 01:49:12.927, Speaker A: Oh, of course. Asynchronous traits, which is closely related to type alias infiltrate. But currently there are a bunch of places in here that use async trait. So if we looked at what was the one we pulled up? Handler. No, not handler from requests. Yeah, so if you look at from request, for example, you see that it actually looks really weird. See it has all these lifetime traits and has like pin box and where tick life 0 implements async trait and stuff.
01:49:12.927 - 01:49:57.725, Speaker A: Stuff. That's all because under the hood it's using the asynctrate annotation on that trait, which means anyone who implements it also needs to use asynctrate. And so being able to just have asynchronous functions and traits directly as part of the language would let them get rid of that as a sort of hack, which also then would reduce boxing. Right. So one of the things that asynctrate does in order to do its job is that it does everything through boxing and dynamic dispatch, which you would no longer need if you had true async event traits. Does the app state gets copied everywhere? Yeah. So when you use state, I mentioned this briefly, but it might have been lost in the noise.
01:49:57.725 - 01:50:42.005, Speaker A: The state that you take into handlers that the inner type here must implement clone. It does not have to implement copyright, but it does have to implement clone and it ends up being cloned once for each handler. I don't think it gets cloned for Every request or for every connection, it just gets cloned for each handler and then it ends up in handler service. All right, so remember we looked at this. So a handler service holds the handler and the state. And then when anything gets. When a request gets passed in, it just takes.
01:50:42.005 - 01:51:21.219, Speaker A: Oh, I guess it does clone the state. Actually, it clones the state for every request. That makes me sad. I wish this could be a reference, but it probably can't be, because then you couldn't have multiple requests in parallel, although technically you could, but you. You could never request that outlives the handler service. So the, the. The reason why it has to clone the state for every request here is because if you look at the tower service trait, the future that you return from call does not have a lifetime.
01:51:21.219 - 01:51:55.485, Speaker A: Oops. Does not have a lifetime bound. So it has to be able to live independently of the borrow of self. So the future you return cannot borrow self, and therefore you can't return a reference to the state because that's contained in self. So it has to clone for every request. That does mean it's only cloning the arc. It's not cloning the actual contents of that arc, but it does mean that you're like potentially contending on a cache line for the reference account for every request.
01:51:55.485 - 01:52:20.325, Speaker A: Is that going to be your main bottleneck? Unlikely. Possible at immense scale. At that point, you would probably use like a sharded ARC or something instead. But it does make me sad. I wish there was a nicer way to do this. One of the ways you could do this, if you. Because you know that the state is going to live for the entirety of your service.
01:52:20.325 - 01:53:21.961, Speaker A: And this is one of those where everyone's going to get mad at me, including probably David, which is, instead of using ARC here, you do static here too. You do static, and then up here, instead of ARC new, you do box leak. Box new. Because when you create a box, when you leak a box, you get back a static reference. So I think I can even do static here, or I can do this, I suppose. And so that way, what box leak does, it heap, allocates the thing, you pass it, and then it leaks it. So it basically never frees that memory, which means you can get a static reference to it.
01:53:21.961 - 01:53:56.345, Speaker A: And references are clone, and it's static because it's a static reference, so it will satisfy the tower service bound for the return future. So that's the other way you could do this. And then the clone is free. There's no reference. Counting at the risk, of course, with using Leaked memory like this, instead of using reference counting, is that the leaked memory is going to stay leaked for the entirety of the program. It will never be dropped, the destructor will not be run, and that memory will never be reclaimed. Now that's not a problem.
01:53:56.345 - 01:54:33.645, Speaker A: If the entirety of your program is running the server right, then it's fine for that state to just be leaked because it's just a single instance of the state, so it's not like it'll keep ballooning over time. And cloning that static reference won't make a difference. It's just copying a pointer. It doesn't allocate any more memory. So it's just really that one allocation that gets leaked and lives for the remainder of your program. But your server is running for the remainder of the program anyway, so it would stay around regardless. So you're not really losing anything by leaking.
01:54:33.645 - 01:55:33.565, Speaker A: Now, the performance benefit that you get is this only really matters if you're running in highly concurrent environments. But cloning an ARC is going to. It requires incrementing a reference count, which is on a shared cache line across all of the all of the users or all of the all of the reference counted pointers to that one memory location. All of them are going to share a cache line for the counter, which means that if you have lots and lots of clones all happening at the same time, they're going to contend on that cache line, which means they're going to slow all of them down. And so you might start to see a performance collapse if you have a lot of handlers that use state, because all of those handlers, every time they're invoked for every request, are going to try to increment the counter on that cache line and decrement it again. And you end up with a lot of contention. And contention is pretty sad when you get to highly concurrent states.
01:55:33.565 - 01:56:11.685, Speaker A: So if you have like lots of cores, lots of concurrent requests, and you're using the state all over the place, this might actually be a sort of lifesaver for you. If that's not you, then just use an ARC and it's fine. Okay. Yeah. So this is very much one of those, like, measure first. Like don't start to leak memory on purpose until you actually measure and discover that you truly need it. Because it does make your application, like more painful to work with.
01:56:11.685 - 01:57:22.575, Speaker A: It makes testing more annoying because now every time you start a test, you might leak memory and suddenly the lifetime of your program is actually quite long because it's. Every test spins up one of these and it remains until all of your tests are completed. So think carefully about this. Don't do this lightly, but it is a trick that you can pull if it turns out to be actually important. Couldn't you put it back into a box after you free your server if you cared enough? I would hope all references are destroyed after the server is dropped. This one's tricky. So the proposal here is basically, well, I could do this and then down here I do state, and then down here I do sort of I reconstruct the box by saying I would have to use from RAW of state.
01:57:22.575 - 01:58:36.625, Speaker A: Technically, in order for this to work, I think you would want to. I actually think you have to be a little sneakier. You need some unsafe because of provenance, which we're not going to dig too much into here. But you could do this and then unsafe this and then from RAW of this. And so that way after your server exits, you are actually going to drop and then we can just change this into this. The reason you need to do this is that if you instead did this and you say this is going to be a static of this and then get rid of the unsafe and then you tried to do this as star mute this, that's an invalid cast. So you would have to do this and cast it and this would be app state.
01:58:36.625 - 01:59:22.835, Speaker A: So the compiler doesn't yell at you for this, like this compiles, but from a provenance point of view, a pointer provenance point of view, this is actually incorrect because what you're doing is you're taking a shared reference and casting it to a mutable reference. And that is disallowed in all of Rust. You are not allowed to do it. So this version of the code, even though it compiles the unsafe here, the unsafe assertion is incorrect. This code is not actually safe. You have to do it this way, I believe. And if you do it this way, I think it's okay where the state that you pass back never leaves as a mutable pointer.
01:59:22.835 - 02:00:19.915, Speaker A: But you can do this, you can recover the leak. It's just. Do you want to do this? Unclear. Will this be better if the Tower API included lifetime bounds? So there is an argument that the service trait should move to use gats like generic associated types. If they do, then call could be generic over the lifetime to self and the future could have a lifetime argument that gets associated with the future. We might end up with that. The downside by doing it that way is you can no longer handle concurrent requests.
02:00:19.915 - 02:00:53.575, Speaker A: Because when you do a call, the future you get back is now tied to the lifetime of the mutable borrow of self, which means that you can't call call again until that future is resolved. In other words, you can only handle one request at a time. And I don't know if that's a requirement we want to add. Or maybe the trait needs to expand to also allow for things like concurrent calls. We'll have to see. Maybe call turns into taking a shared reference to self. That's one way to get around it.
02:00:53.575 - 02:01:55.371, Speaker A: Do you recommend using Axiom for serving ML models? The issue I'm thinking about here is having a message queue in the back into server requests. If model inference takes a lot of time, that should be fine. You might end up using something like Tokyo blocking in order to say that the generation part actually is going to be kind of slow so that you're not blocking handling of other requests. But that's not inherently a problem. Oh yeah, the other question for the unsafety here is whether do you actually know that once the server has exited that nothing is keeping that reference to state? Because it's really easy for them once they have a static reference to the state to just store it somewhere, somewhere else static. And now this unsafe invariant is no longer true. So this is pretty risky.
02:01:55.371 - 02:03:02.535, Speaker A: You need to. It's like a global invariant over your code that you need to make sure you don't violate. Why not also make service clones so that every request has its own service? That feels unnecessary. Like you don't really want to add clone bounds unless you need to, right? Because sometimes it is actually useful to have the call mutate the state for things like keeping track of how many requests have come through. You don't really want to have to clone it for every time you would lose the ability to do something like that. Why is Actix Web faster than Axum? Is it? I very rarely believe these benchmarks because they're usually micro benchmarks and micro benchmarks don't really represent a real workload. At the same time, I don't think there's a.
02:03:02.535 - 02:03:36.207, Speaker A: It's not as though I'm like opposed to using Actix webs or something either. I like the way that Axiom does things because it integrates nice with other ecosystems and I just. I like this way to write code. I think there is more rust complexity to it, but in some sense that's what the language is for. So it's like it eliminates more foot guns at compile time, which does add some complexity and cognitive overhead. But I also think it's Better. All right.
02:03:36.207 - 02:04:09.761, Speaker A: I think. I think that's all I really wanted to cover for Axum. Do we have other questions? Anything else that people want to know before we. Before we say goodbye? Let's go stick this back here. So I get rid of my own safe. You seem to use the. Use the term provenance a lot.
02:04:09.761 - 02:04:55.335, Speaker A: Can anyone in chat or you briefly explain what provenance is? It's very hard to briefly explain explain provenance. I would look up Ralph Jung's introduction to provenance. It's really good at giving examples for this. Can you talk about the fromref trait? Yeah. So from ref is not really all that magical. Oh, from ref. So fromref is mainly used in things like states.
02:04:55.335 - 02:06:07.237, Speaker A: So remember we looked at this. So state implements from request parts, but it implements it via this from ref trait. And the idea here is that if you have an impul of from ref, which direction does from ref go? Outer state. So app state for specific state. If you have this impul, then now you can write an async, a root handler that takes a state s state root specific state. You can write a handler like this and you can still call router with state with an app state. So you might wonder, well, why is that useful? This can be useful in things like libraries, where your library needs to have access to like a database connection, for example.
02:06:07.237 - 02:07:15.745, Speaker A: So there's like some like, I don't know, delete user or something like your library provides a route, and that route requires that you have like a DB connection or whatever it is, some connection type. But your application, the application that you have written, the larger application that includes that library and includes the delete user route from the library. You don't want to have the requirement that the state that you pass around is just connection, because you have all sorts of other state you want to include there too. And so the way that you do this is you implement from ref app state for connection. And so that way you basically write how you can construct a state connection from a state app state. So it's a way to have a level of indirection between the state that any given route needs and the overall state that you provide. The fallback router is just if you have a fallback router, what that means is if the main router fails to find a way to route the request, the fallback router is invoked instead.
02:07:15.745 - 02:08:07.601, Speaker A: Is action production ready? Yes, I think so. I don't have a reason to believe that it's not custom HTTP method handling, I think for method filter. No method filter is not what I want. I want on. Oh, I guess this actually does specifically only handle these. That's fine. So what you would end up doing is instead of using, instead of using the method route.
02:08:07.601 - 02:09:18.883, Speaker A: Method routing router from Axum, which only supports the sort of standard HTTP verbs, right? And so it, it has a pretty hard coded list of mappings from the known verbs to other things. What you would do instead is you would just have your own type that you implement that has service. Where's the impul? I just want the impul. I just want the impul here. And you would write an impulse like this impulse service request request, you know, body type 4 and your type goes here and then in call, you know, the call with state here for the method handler is really just match on the method. Like just figure out which method was in the request. So you would do the same and your type in the implementation of call, you would look at what is the method for the request and rather than try to turn it into one of the well known HTTP verbs, you just check whether the method is your own, the HTTP verb you're looking for and if so, call the handler.
02:09:18.883 - 02:09:55.975, Speaker A: So you wouldn't do it through the normal method router. You just write a tower service. Let's see, using Think Asynchronous. Asynchronous traits will stabilize this year. I hope so. But my, my belief is fairly low. Why doesn't Rust have a way to async drop? Because async drop is really hard.
02:09:55.975 - 02:11:06.655, Speaker A: Okay, in that case, I. Oh, there's one last thing I want to mention which is Axum Extra. So there's a crate called Axum Extra that has a bunch of extra utilities for Axum, things like handling cookies or JSON lines. So the format where you have multiple JSON object on separate new, like new line, separate adjacent objects and protobof and stuff. So these aren't in the standard Axiom crate because they have to take a bunch of extra dependencies and so you want to keep them separate so that the dependencies of Axiom itself is smaller and some of them I think are more experimental or the versioning of the underlying crates would mean that we would have to bump the version more often. I say we, but I mean, David, so this is a good crate to know about. If you, if there's some extractor, for example, that you, you really want to have and you don't don't see it in Axiom, it might be an AXM extra instead they have like other routers as well.
02:11:06.655 - 02:11:29.905, Speaker A: I think for query parameter based routing. I think there's also other response types. Yeah, like CSS specifically, so that it sets the content type. That kind of stuff. All right. I think. Oh, there's also Axum server for HTTP support.
02:11:29.905 - 02:11:56.555, Speaker A: Axon Server. Interesting. I don't know how this difference. This is also by a different author. I don't think you need this. I think you can just do it through like it's already through Hyper in. It's already through Hyper in Axiom itself.
02:11:56.555 - 02:12:22.839, Speaker A: All right, let's call it there. Thank you all for coming. I hope that was interesting. Annoying that it got split in the middle, but what I'll do is I'll, I guess, stitch this together so if you were watching the video on demand, you don't realize what I'm talking about and that's fine. It'll be a treat for the people who are here live. All right, I will see you all next time. I don't know what we're going to do next, but we will do another stream at some point in the future and it will be fun and interesting.
02:12:22.839 - 02:12:24.495, Speaker A: All right, bye. All.
