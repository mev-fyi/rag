00:00:04.000 - 00:00:30.645, Speaker A: Nom, nom, nom, nom. Hi folks. Welcome back to yet another crust of rust. In this one we're going to look at something called the drop check. And the drop check is another sort of weird topic, sort of like subtyping invariants like we covered in the in the previous video. That's like kind of niche, kind of weird. But you also run into it in more situations than you might think.
00:00:30.645 - 00:01:18.391, Speaker A: It usually only comes up in the context of unsafe code. And so we're going to sort of fiddle a little bit with that and try to figure out both why it's there, what it's for when it comes back to bite you, and how you work around that. The picture of my cat awkwardly trying to figure out how to lie on lap is only anecdotally relevant. All right, let me leave up the drop check here. So the nomicon has a page on the drop check, which is pretty good. I recommend you give it a read and it goes through why the drop check is there, what some of the awkwardness around it is, and how to work around that awkwardness. And that's basically what we're going to be working through today.
00:01:18.391 - 00:02:06.785, Speaker A: I think it's helpful to walk through an example in real time code and look at the compiler errors, which this article also does a decent amount prefer reading to sort of watching the code go live. Feel free to go read that article and it will probably cover most of what we do here, although it's a little bit different. All right, so what we're going to do is we're going to start as has become standard on these streams, we're going to start a new rust library. And this one we're going to call Box, spelled the Norwegian way. So this is a Norwegian wrapper type for box. And we're going to CD into box and we're going to edit this, remove the test. I don't need a new version of Rust analyzer, thank you very much.
00:02:06.785 - 00:02:48.665, Speaker A: And what we're going to do here. Oops, my vim bindings got weird. So we're going to create a new boxtype boxt, and it's going to hold a pointer which is going to be a star mut. So this internally really just is the same as a box, is the idea just with a Norwegian name to make it easier for Norwegian programmers to understand what's going on. And it's going to be pretty. We're not going to sort of do all the fancy stuff that you would want for a type like this, but what we are Going to need is a constructor. Right? So we're going to have a constructor for box.
00:02:48.665 - 00:03:22.845, Speaker A: And normally you would call this new, but because we're in Norway land, we're going to call it ni, which is how you say new in Norwegian. And this is really just going to return a box where the P is a box new of T. And then we're going to use box into raw to turn that into a raw pointer. So really we're just wrapping box is all we're doing. This should be a capital T. We will get to variance and non null. Yes.
00:03:22.845 - 00:03:36.701, Speaker A: Settle down. We will get there. And of course we get a warning. The P is never used. That's fine. In this case. What I want to do is actually set up a little test here just to see that.
00:03:36.701 - 00:03:58.469, Speaker A: Actually, I kind of want this to just be main. Let's make this a binary instead. Let's move source lib to source main. Source main. No, I don't need a new rust analyzer. Thank you very much. All right, so what do you do with a box? Well, you have.
00:03:58.469 - 00:04:19.311, Speaker A: Let's say we just do let B. Let's let. Let X is 42. Let B, which is going to be our new box. And we're going to do box knee of X and that's all we're going to do. And let's just see that this runs just sort of the very basics. Okay.
00:04:19.311 - 00:04:43.535, Speaker A: There's some unused variables and stuff. That's fine. One thing you might immediately notice here is this box is never freed. When a Norwegian box goes out of scope, it doesn't bother calling the destructor of the inner type. It just leaks the memory, which of course is not what we want. So we're also going to need a drop implementation. Going to put that up here so that it's near the type it's implemented for.
00:04:43.535 - 00:05:19.115, Speaker A: So we're going to implement drop not dorp drop for box. And it's going to take a. My typing today is awful. And all this is really going to do is it's going to do a. There are a couple of ways we could do this. We could either do like a box from RAW of self P, which is unsafe. So this constructs a box from the inner type.
00:05:19.115 - 00:05:55.895, Speaker A: This is probably the easiest way to do it because it. It both calls the destructor of the T and it deallocates the box. We could also just drop the T if we wanted to. So we could use steady pointer drop in place of self P, which would drop the T. But it wouldn't free the box. So this is why we do the first one rather than calling the destructor directly. And now indeed, if we run it, you won't really notice any difference because you can't really tell the memory is leaking, but it gets us close enough.
00:05:55.895 - 00:07:48.273, Speaker A: So now we have a working box type and everything is happy. I guess the one thing we are going to need here is we're going to need to implement deref for box because otherwise you can't get at the inner type. Its target is going to be a T. It derefs itself into a self target and it does that simply by doing a dereference of self P. This is unsafe because we're dereferencing a raw pointer and the safety here is is valid since it was constructed from a T, from a valid T and turned into a pointer through box which creates aligned pointers and hasn't been freed since self is alive. And a similar argument is going to apply for draft mute, right? So dref mute is the method that lets you mutably access the thing that's inside drfmut mute self and it's going to return a mute to self target. The reason we can refer to self target here, just as sort of an anecdote, is because dref mute is a subtraight of DF, so anything that is DFMute is also DF and therefore self target.
00:07:48.273 - 00:08:42.535, Speaker A: The compiler understands that self target is the associated type d ref of the parent trait of dmut. And here the argument is the same as here. Also, since we have mute self, no other mutable reference has been given out to P. Also, I misspelled reference. Great. So now in theory if we do something like print line of star B so the star here is the d ref goes through d ref to get there into the value that store below. And indeed when we run that we get out 42.
00:08:42.535 - 00:09:47.157, Speaker A: Great, so we have a working box. So far so good. All right, so I had two questions from chat. Why unsafe? The unsafe here is just because we're calling box from raw drop itself is not unsafe to implement. And indeed this should have a safety comment saying P was constructed from a box in the first place and has not been freed been freed otherwise since self since still exists, otherwise drop could not be called. I figured I consider writing these safety comments in Norwegian, but I figured that would be less helpful to everyone involved except the like three people in chat who know Norwegian, Danish or Swedish. Okay, so we have a working box and we can just ship it, right? We're Done, it turns out.
00:09:47.157 - 00:10:28.315, Speaker A: Not quite. This maybe will not surprise you, but it turns out there's more to this. So let's look at something that you can do with a normal box that actually doesn't work with the box that we wrote. So here I'm going to create a new variable, Y. I'm going to say B equals box knee, and what I'm going to give it is a mutable reference to Y. And now I'm going to print out the value of Y. So this is going to read a little weirdly to you.
00:10:28.315 - 00:11:03.941, Speaker A: So what we're doing here is we're constructing a box that contains a mutable reference to a variable that's on the stack. And then here I'm going to use that variable. So notice I'm not using it through B. If I used it through B, we'd be fine. This would run just fine. Instead, I'm going to try to access Y here. And if you think about it, this really should be okay, because even though B holds a mutable reference to Y, it doesn't do anything with that mutable reference to Y.
00:11:03.941 - 00:11:53.045, Speaker A: Like, even though, like, conceptually down here, there's a drop of B, right? When B goes out of scope and dropping, the B is going to sort of get rid of this mutable reference, but it doesn't actually use the reference for anything. So there's no problem in sort of the borrow ending early and allowing us to access the thing that has been mutably referenced over here. And yet the compiler doesn't let us do it. You see, it says cannot borrow Y as immutable because it is also borrowed as mutable. The mutable borrow occurs here, which we assign into B. And the immutable borrow occurs when we try to use Y. And as it, as it rightly says, the mutable borrow might be used here when B is dropped and runs the drop code for box, Right? And if you think about it, the reason it does this is actually fairly sane.
00:11:53.045 - 00:12:55.041, Speaker A: It sees that Box has a drop implementation, and there's nothing that really stops Box from doing something like this. Is that a bad example? Yes. Okay, so this is obviously weird, right? Like, no drop implementation would do this, but there's nothing that stops the drop implementation from doing this from, like, trying to read what's behind the pointer in the drop implementation. And it doesn't even need unsafe in this particular case. It needs unsafe because we're storing a raw pointer. But you can imagine that there are cases where you store some. Like you store something in the box and you touch it in the drop implementation, you like read out of it or something.
00:12:55.041 - 00:13:32.495, Speaker A: And if drop did this, then suddenly this code would not. This would not be okay. We wouldn't expect this to be okay, right? Because the. When B goes out of scope at the end, when B is called here, this is going to read from the mutable reference to Y, which means that this read of Y is not okay. And this might be more obvious if here we used Y mutably. If we set Y to 43, then now we have a mutable reference being used here, but also immutable reference being used here and things get weird. Okay, so.
00:13:32.495 - 00:14:10.561, Speaker A: So what the compiler here is trying to guard us from is sort of a drop implementation that might use the value, and this is what's referred to as the drop check. That. Not quite true, but bear with me, but basically the compiler wants to make sure that you don't have a drop implementation or when the value gets dropped. It needs to know whether or not it has to check any. Anything that the thing that gets dropped might contain. This is. That's a little convoluted of a way of saying it, but it's hopefully going to become clearer as we go.
00:14:10.561 - 00:15:13.355, Speaker A: So if box doesn't do this, right, if it doesn't have a line like this, then we expect this to be fine. And in fact, if we try to create a B using box new, then this code compiles. So our box is clearly somehow different from the box that that is provided by the standard library, right? For some reason with the standard library box, which does implement drop, right? It has to, because it needs to free the underlying memory. But somehow, for the standard library box, the compiler knows that that box won't sort of read the thing that it contains, it'll just drop it, it won't access it, like with the unsafe bit that we wrote above, and therefore it allows this code. But for R type, it doesn't know it. Nothing tells the compiler that this is okay. Specifically, nothing tells the compiler that the drop implementation for RBOX doesn't try to access the inner value.
00:15:13.355 - 00:16:40.315, Speaker A: And to understand why that is, we need to get into a decent amount of like, weird oddities in the, in the language and the compiler. And specifically it relates to this thing called the drop check, which is that when some variable goes out of scope or otherwise gets dropped, the compiler needs to know whether to consider that drop a use of anything that's contained inside the type. This is not related to nll. So in particular, the compiler has a rule that Says that if you have a type that's generic over some type parameters, in this case it's generic over T, then the compiler will assume that dropping the thing will access a T. So dropping a box T, the compiler will assume that that will use a T if boxt implements drop. So regardless of whether the drop implementation for that type actually accesses the T, the compiler will assume that it accesses a T. And in this case that means that it will assume that the drop implementation accesses this mutable reference, and therefore any intervening use of the target of the mutable reference is a conflicting use.
00:16:40.315 - 00:18:16.193, Speaker A: And the drop implementation here is important because if we comment out the entire drop implementation, then now the compiler knows that dropping a box T can't possibly access a T because there's no drop implementation for this type, so there's nowhere where it could do that use. And if we comment out the drop implementation, this code now compiles, right, because the compiler goes, oh, down here you drop a B, but the box doesn't implement drop, therefore dropping a box doesn't access the T. Therefore this mutable borrow I can shorten to be just straight after you create the box, sort of after the last use, rather than at the end of the scope and drop, and therefore this use at Y is valid. This does mean that implementing drop for a type is a breaking change, as one example, if it is a generic type. If it's not generic, I don't think it matters. So implementing drop is actually backwards incompatible for another reason, which is you're not allowed to move out of the fields of a type that implements drop. So if a type has public fields and you try to move out of that field, then you're not allowed to do that if the type implements drop, because the drop implementation needs to have a mutable reference to self which is complete and has nothing moved out of it.
00:18:16.193 - 00:19:04.645, Speaker A: It can't be partially moved. All right, so how do we fix this? Because we need the drop implementation for box. This has to be here because otherwise the memory would leak. But we also know that we're not accessing the inner value here. Like, we can sort of, we can look at the implementation, given that this is compiled, that this isn't here, we can look at this implementation and go, we know that we're not accessing the inner type T here, so we should be able to communicate that to the compiler. And there's actually no way to do this in the stable compiler today. And part of the reason for this is because we don't have a We haven't figured out what the right mechanism is, but there is a temporary workaround.
00:19:04.645 - 00:20:06.339, Speaker A: This is a feature that is sort of going to be permanently unstable because we're waiting for figuring out what the right solution should be. And that is something called feature the Drop check eyepatch. And I guess I'm going to have to override this instead nightly and do this so Rust Analyzer picks it up. So the drop check eyepatch is a permanently unstable feature that, as the name implies, lets you apply an eye patch to Drop check. So remember how I said that if you have a generic type, the drop check is going to assume that if this type implements drop, then the drop will access a T. And what the drop check eyepatch does is it lets us sort of opt out of that part of the drop check. It lets us mask a given type parameter from the drop check.
00:20:06.339 - 00:21:53.355, Speaker A: In particular, with this feature enabled, you can say unsafe impel and then you can say may dangle as sort of a precedent to any number of the type parameters. And what this tells the compiler is that even though box holds a T, even though it's generic over T, I promise, hence the unsafe keyword here, I promise that the code inside of drop does not access the T. It might drop the T. We don't make a promise that it doesn't drop it, but it will not access the T. And once we add this, then now, now this code down here compiles, right? So now, just like it used to be possible with a box to have this code compiler, now our code compiles as well, right? Because now the compiler understands that when B gets dropped down here, there's not actually a call to drop, right? It's just dropped at the end of the scope. When B gets dropped down here, it understands the promise we made that we won't touch the inner type, we won't touch the mutable reference, and therefore it can shorten the borrow of the Y to start just up here, and therefore allow the use of Y here, the shared borrow, the immutable borrow here. So I'm going to stop there for questions and then I'm going to go into why this code is still wrong.
00:21:53.355 - 00:22:50.793, Speaker A: Access here includes creating any kind of reference to the T, right? Access here is use the T, which I guess you could say is create a reference to it. But I don't know that creating a reference is a problem. Actually creating immutable reference would be a problem because mutable references are never allowed to alias. So even creating immutable reference would Be illegal even if you don't use it. So with this feature, a trait can sometimes be safe and other times unsafe to implement. Or is that a general thing? No. So this is one of the reasons why this is not stable is because we don't have another instance of this, of having implementing a trait sometimes be safe and sometimes be unsafe.
00:22:50.793 - 00:23:28.583, Speaker A: You can sort of think of this as this unsafe keyword isn't for the drop trait is for this attribute. You could sort of think like, maybe it should say unsafe here. So I don't. So certainly the drop check eyepatch is not going to land in its current form. And I think the idea is that we want some other more fundamental rearranging to make this work correctly. But no, it's not a general purpose mechanism. This is a different problem than what phantom data solves.
00:23:28.583 - 00:24:11.957, Speaker A: Yes, but you will see shortly why we still need phantom data. What if your container holds two T's and only accesses one of them in drop? It seems strange to me that we talk about access a T without being more specific about which inner T. So it doesn't actually matter if you contain two T's, they are the same type. You're right that they could both be mutable references and you'd then be tied to both of them. But at the same time, if you only have one T, then they. They must also have the same lifetime. And so therefore it seems kind of the right thing to say that if you access one, it's equivalent to accessing the other.
00:24:11.957 - 00:24:59.029, Speaker A: If you really wanted to distinguish them, you would have two generic parameters. This is sort of similar to the argument around. You might want multiple lifetime parameters to allow them to have different variants. And it's sort of the same property here that if you want two fields to have to have different drop check properties, you might actually want to have different type parameters. You are creating a box T to the T, which, like mutable references, may not alias. Yes, we are creating a box T, which means that we're not alias. We're not allowed to alias the T, but we're not aliasing the T.
00:24:59.029 - 00:25:32.105, Speaker A: Right? Nothing here ends up aliasing the T. Mutably aliasing. That is the box from raw here, if that's what you're referring to. The box from raw here does create a. It creates a box to the T, which means that you're not allowed to alias the T. Like at this point that the T is now sort of owned and then gets dropped. And that's fine because this is a raw pointer and not A reference.
00:25:32.105 - 00:26:28.651, Speaker A: So even though there is another pointer to it, it's not another reference to it. Is it possible to make T keep track of all the references and then drops them when accessed? I don't know what you mean. Although keep in mind here that the T here doesn't have to be immutable reference, right? As I showed in the first part of main, we can. The T can just be like an i32. Like, it doesn't need to be a mutable reference the way it is down here. And then the question here that came up is also, don't you still need to access the T in order to drop it? And the answer to that is no, you don't. Or rather, it matters whether you access the T or whether you just drop the T.
00:26:28.651 - 00:27:06.075, Speaker A: Think of something like a mutable reference to T. Dropping a mutable reference to T does nothing. It's a no op, right? Like in the compiler, borrow checker. It has an operation, but it doesn't issue any instructions. It doesn't actually dereference the mutable reference, but accessing the mutable reference does. Okay, so now the question becomes what's broken about this? Because this is not quite sufficient in its current state. In particular, let me write a sort of malicious type.
00:27:06.075 - 00:27:21.619, Speaker A: It's not a malicious type, it's just a. It's just a type. Leave me alone. So I'm going to make a new struct. I'm going to call it. Okay, I'm going to call it Topple. I wonder if this works.
00:27:21.619 - 00:27:49.905, Speaker A: I think this will work. Okay, so topple. I think Unicode works in types, right? Topple means to touch in Norwegian. And a topo is just going to hold the T. Is Unicode types unstable? No. Really? Oh, man. All right, then we're going to call it.
00:27:49.905 - 00:28:42.635, Speaker A: Oh, that makes me so sad. Okay, then we're going to call it oisan, which sort of means like oopsie daisy. And we're going to implement drop for oisan. I guess I could have just enabled the feature, but poison is fine. And what we're going to do here is that this is going to print line. It's going to debug print the inner value on drop. So oisan is going to.
00:28:42.635 - 00:29:16.205, Speaker A: Oisan is going to access the inner T when it gets dropped. So nothing. There's nothing unsafe about this. This is just a normal type that happens to access the inner value. And notice this is one case where the drop check sort of does the right thing. Right? The drop check assumes that any generic parameter, that or any Type that you are generic over is one that you may access in drop and therefore that it should assume is access drop. And indeed that assumption is correct here.
00:29:16.205 - 00:30:05.215, Speaker A: So it's always safe to make that assumption. It just might be constraining like we saw with box. So why does this type causes a problem? Well, now down here, let me do let mute Z. It doesn't even have to be Z, it can just be oisum and it's going to hold a. Actually, no, here's what we're gonna do. We're gonna have a let mute Z is 42, we're gonna create a new box and it's going to hold an OS of immutable reference to Z. And then down here we're going to print out Z.
00:30:05.215 - 00:30:46.857, Speaker A: So this compiles but shouldn't. So here's an example where when we drop the box, we're going to drop the osan. We're not going to access the OSAN ourselves. Like the implementation of drop for box does not access the inner T, but it just drop it. And the drop implementation for oisan does touch the inner T. So when, when we drop B here, that drop of B is going to access this mutable reference. So it's sort of.
00:30:46.857 - 00:31:38.465, Speaker A: This drop down here is sort of equivalent to doing this. But now there's a borrow of Z up here that is used down here and there's an immutable axis in between, which should be illegal by the borrow checker. And indeed, if you try this with the standard box, it will not compile. If we look at the compiler, the compiler error, it says immutable borrow occurs here, immutable borrow occurs here. And the mutable borrow might be used here when B is dropped and runs the destructor for the type boxoisan. So box clearly understands that this isn't okay, but our box does not. Because we use the eye patch to say the T might dangle.
00:31:38.465 - 00:32:45.525, Speaker A: And indeed what's missing here is that the compiler, what we've told the compiler with this is that we won't access the T, but we haven't said anything about whether we're going to drop T or not. And by adding this, the compiler just like thinks that we don't do anything with T on drop, but that's not true. We do drop a T, but the compiler doesn't know that. And the reason the compiler doesn't know that is because if a type is generic over T and implements drop, it assumes that that drop will access the T, but it doesn't make Any assumptions about dropping the T. But an access is sort of stronger than a drop, like more things need to be true in order for it to be valid to access something, as opposed to drop it. But there's nothing in here that says that we're going to drop a T, because this type doesn't hold a T. It doesn't.
00:32:45.525 - 00:33:38.525, Speaker A: Like if this said, like, if it actually held a T, then the compiler could look at it and go, oh yeah, obviously this is going to drop a T when it drops, but it just holds a raw pointer to T, which the compiler can't assume anything about. It doesn't know whether or not we drop a T. The only reason we drop a T is because of this unsafe bit here that the compiler doesn't necessarily know about, or it doesn't know the semantics of this operation. So what we need to do is we need to tell the compiler that while we're not going to access the T, we will drop a T. And this is where phantom data comes in. So a phantom data is a type that can be generic over some other type, but doesn't contain that type, and it's the only type that really works that way. So if you have a.
00:33:38.525 - 00:34:20.950, Speaker A: If you have a phantom data i32, its size is 0. It doesn't hold an i32, it doesn't hold anything in fact. But as far as the compiler thinks, and the type system thinks it holds an i32, and that's exactly what we need here. So here we're going to have a T that's a phantom data of T. And why do we do that? I guess I'm going to have to also have this be a phantom data. Oops, phantom data. And the reason we do this is because the borrow checker will again, look at this.
00:34:20.950 - 00:35:11.805, Speaker A: And when looking at any type that implements drop, it sort of has to ask itself two questions. It has to ask, does it act for each type parameter, does it access that type parameter and does it drop that type parameter? The maid angle tells it it does not access the type parameter. The phantom data tells it it does drop the type parameter. And in fact now this code will not compile with our box either. And the reason is because we've now taught the compiler that when the box drops, we're not going to access the reference, we're not going to access the inner T. So this code is fine, but we are going to drop the inner type. And so you need to think of it as it tells the compiler you need to go check its drop implementation to see that it does the right thing.
00:35:11.805 - 00:36:29.935, Speaker A: Right? This is like for fairly deep down, like a rabbit hole. But does this make sense? Does it make sense why we need this extra attribute, what it's for, and why this is sufficient and necessary to make the compiler understand our type? Correct. Without the phantom data T, the only uses of T will be moves or drops. No, that's not true. Without the phantom data T, the phantom data T is what tells the compiler that we may drop a T. In fact, I believe, and this is something that I don't know whether it's documented in the nomicon I saw there was some discussion in a pr, actually, or an issue on the nomicon is that I don't think the phantom data is necessary unless you use maydangle, because a use is stronger than a drop. So the normal assumption about generic parameters is sufficient.
00:36:29.935 - 00:37:39.585, Speaker A: What if oisean didn't touch the data and drop would it compile? So if OISAN did not touch it, if we just did this, then no, it still will not compile. And the reason is because the compiler still makes the assumption that because OISAN is generic over T and implements drop, it has to assume that it might access the T. But we could do the same thing here and say unsafeimple maydangle to say that we promise that this drop implementation also does not access the inner value and then the code indeed compiles. Or if this type didn't implement drop, then the code also compiles just fine, because dropping OISAN will drop the T, which is fine, but it does not access the inner T. Phantom data is a sort of special type. I don't think you can write it yourself. And the reason for that is if you try to write.
00:37:39.585 - 00:38:39.725, Speaker A: I mean, we could try it ourselves. Like if you try to write a phantom like this, like a unit type, the compiler will complain that the type parameter is never used, so you can't actually write this type yourself. So I think phantom data, phantom data required some special compiler magic to allow that just for that type. Okay, so the question now is, are we done? Is this all we really needed? And sort of. This does get us everywhere we wanted to with the drop check itself, but there is one more bit here that's a little awkward. And that is. And this gets back to the previous video on subtyping invariance, our box is currently invariant in T.
00:38:39.725 - 00:39:52.585, Speaker A: So what does this mean? Well, there's a lot to cover from the previous video, but here's what I'm going to do. Let's Say that I have a string new, and then I do. What's a good example of this? I don't know how to write a good example of this off the top of my head, but if I do, let B is box new Z and then I do B equals box new hello world. If I now, Sorry, I'm just writing this and then I will explain it once it doesn't compile. If I did that right? Yeah. Okay, great. Maybe not.
00:39:52.585 - 00:40:25.795, Speaker A: Damn it. E. This gets to work for silly other reasons. Let X let. I'm running out of letters. ZZZ is going to be a static stir. It's going to be hello world.
00:40:25.795 - 00:40:41.003, Speaker A: And then we're going to have this. Take a zcc. Great. Ooh, integer. That's not right. This compiles. Check static.
00:40:41.003 - 00:41:47.765, Speaker A: Sorry, I'm going to explain what I'm doing in a second. I just need to do some setup. Ooh, Mmm, interesting. Why did that not work? Oh, actually, here's a better one. If I write A, I think it's going to be too hard to come up with a good example for this, so let me try to talk through it instead. Yeah, it's. No, the type can't be box static stir either, because then it shouldn't compile even with box.
00:41:47.765 - 00:42:49.275, Speaker A: Okay, so let me try to talk through it instead. As we talked about in the previous video on variance, anything that you have a mutable reference to is invariant in the inner type. And the reasons for that we're not going to go over again here because they're covered in that previous video in a lot of detail. But this means that in general, if you have, say, a box static t and you want to pass it to a function that expects to receive like a box of a reference with a shorter lifetime than static, like a tick A. Except it can't be generic over tick A. This is part of why it's hard to come up with a good example for it. Then you Basically, the invariance means that you cannot treat this.
00:42:49.275 - 00:43:40.741, Speaker A: Oh, that's not at all what I meant to do. Cannot treat this as this or some shorter lifetime, even though normally. Right. I guess this should say box as box. Even though you can always treat a static str as some shorter lifetime stir. And you can treat a box of this like this is a box with an X as a box of this. So our box is sort of broken in this way.
00:43:40.741 - 00:44:12.479, Speaker A: It doesn't behave the way that you would expect box to behave. And that's because of the invariance that gets introduced here. All Right. I have someone gave a code example in chat. Let's see if that demonstrates it. Let s a string from hi or let's make it high because it should be Norwegian. Let me Box is box knee s Box two is box static.
00:44:12.479 - 00:44:33.857, Speaker A: Stir is box knee high? Salm Also Norwegian Box equals box 2. Oops. 2. So what does this complain again? Ah, yeah. Okay. This is a good example. You're right.
00:44:33.857 - 00:44:54.125, Speaker A: Thanks, Alice. So the problem we run into here is exactly this, that this box has a lifetime that's not static. It's a lifetime that's shorter than static. This variable has a lifetime that is static. So it's longer than box. Let's call them box one and box two. I guess.
00:44:54.125 - 00:45:56.005, Speaker A: So box two is like strictly more useful. It has a longer lifetime. And so it should be fine to assign box two into box one. And indeed, if we made this box box box new new, then this compiles just fine. But if we use our box, I'm just making this easier to talk through. So you see that the example with box compiles just fine because box is covariant in its contained type T, but our type is not. So even though you have a box, a box here with a short lifetime, you cannot overwrite it with a box with a longer lifetime because it's invariant in its inner type.
00:45:56.005 - 00:46:29.135, Speaker A: And that invariance is because of the mutable reference over here. So the easiest way to fix this is we can make this const. That does. And then we need to deal with the stuff down here. Realistically, what we'd probably use is instead say, bring in the non null type. So the non null type is sort of like a mutable, sort of like immutable reference or mutable pointer rather, except that it is covariant. And because it's not null, it.
00:46:29.135 - 00:47:15.845, Speaker A: It supports the niche optimization. So we can replace this with non null over here. This now has to be box from raw as mute. This has to be non null from this. I mean new and in fact new unchecked, because we know that. We know that box never creates a null pointer. Safety box never creates a null pointer.
00:47:15.845 - 00:48:08.995, Speaker A: And this as ref. And this as mute knee is new. No, that's right. So now you see that this actually compiles. Now the example when using our box, our Norwegian box also supports, is also covariant over the T. So it allows us to take this box with a contained type that's a subtype of the one we already have and assign it. Basically you can think of it as the compiler realizes that it's allowed to shorten the lifetime of this borrow or of this type parameter when assigning over here.
00:48:08.995 - 00:48:36.505, Speaker A: Nice. So now we've made it invariant. Sorry, covariant, which is nice. You might also have seen stuff like this. This also makes a type covariant, but this means that we are no longer subject to the drop check. So with this you would now be allowed. It would open up this bug again.
00:48:36.505 - 00:49:35.521, Speaker A: So you might wonder, well, why then, given that it opens up a bug, because this now compiles when it shouldn't, right? Why then would you ever see this? And you see this in types that do need to be covariant over the table, but they don't drop a T because they don't contain a T. The best example I know of this is if you have something like a deserializer, so deserializer phantom. Oops, phantom data T. If you have a deserializer like a serde deserializer type or something like a custom deserializer, then it doesn't contain a T, it's just. It's generic over the type that it's going to serialize into. Like imagine a vec deserializer that deserializes into a vec of T's. Then it doesn't contain a T.
00:49:35.521 - 00:50:58.485, Speaker A: But the way we've written it, if we just do the sort of the naive thing with phantom data, this is now going to mean that the drop check gets applied to the deserializer, right? It's going to make it so that dropping a deserializer T, the compiler is going to check the. Is going to do the drop check for whatever that T is. So if someone constructed a deserializer of oisan of immutable reference to say an i32 where remember, Oisan will touch the inner type when you drop this would not compile because the drop of the deserializer the compiler is going to assume is going to touch the mutable reference that this is two. Even though the deserializer doesn't actually contain an oddness, it isn't going to drop one. And so this is one example where you would use, you would use this because now this is one way in which you can, you can be covariant over T, right? So this is still covariant over T, but you don't contain a T, so you don't trigger the drop check for your generic type. And the reason you don't do this, oops. The reason you don't do this is because this is Contravariant, not covariant.
00:50:58.485 - 00:51:43.275, Speaker A: So in general this is what you want. Or if you wanted it to be invariant, you would do this. Who? The empty iterator is another example. Yeah, if you have a, that's a good example. Actually. The empty iterator is generic over T and it implements iterator for empty. So we're going to do this and the type item is going to be t and it returns an option self item but it always returns none.
00:51:43.275 - 00:52:21.057, Speaker A: So this iterator never yields a T, it never contains a t, but it doesn't need to be generic over t. So we need to stick T inside of phantom data somewhere and we want it to be covariant. And if we just did this, it would be covariant, but now it would trigger the drop check of T, which is not what we want. So we use this construct instead. Oh, interesting. The empty iterator in the standard library just uses T. So that means.
00:52:21.057 - 00:53:37.315, Speaker A: Okay, let's try to play with that a little. So if you have a iter empty, then I think this is going to. So if I say let a is 42, then I say I want to create an O. Let O is equal to sum of. It gets annoying to construct something that has the type that I want it to have O of mute of A. Then say O is empty empty. Does it have a new probably dot next or I guess I need to create empty.
00:53:37.315 - 00:54:41.125, Speaker A: Is it default maybe? Probably default it next and then print line A. Let's see if I can make this trigger. Can I sign twice? That's fine. Interesting. Oh yeah, you're right. So normally if empty implemented drop then this code would not compile even though it should because the iterator and so this is because in the standard library empty is defined as struct empty struct empty phantom data T. So this means that dropping an empty T is considered as dropping a T.
00:54:41.125 - 00:55:42.665, Speaker A: So the. The empty type that we have here is going to be considered as holding it. You can sort of think of it as going to be an OS on of the add mute of A. That's sort of the type that it's going to end up having because of the. Because of this, right? Because O has been given that type. And so when the empty gets dropped at the end of the scope here, right, that's going to consider it as dropping an oyson which because it's a phantom data T and not a phantom data this that's going to be considered as dropping an oisan which in turn is going to touch the inner value, which is a mutable borrow of a but. And in fact it should be even without an implementation of drop.
00:55:42.665 - 00:56:17.775, Speaker A: But because there's no implementation of drop for empty, the drop check never triggers, although it should still be considered dropping. I think it should still be considered as dropping one of these. So something here is not right. Like if I drop it here. Interesting. I wonder why that works. I don't think that's right.
00:56:17.775 - 00:57:12.995, Speaker A: I think this should fail. So if, if this is actually the definition of empty, this should fail because dropping the iterator down here should drop the empty T, which should drop this, which the compiler should assume drops a T. Even if empty doesn't implement drop, this should drop a T, which means that you considered the drop implementation for oisan, which does touch the inner type. So Interesting. Yeah, I don't know why this doesn't compile or why this does compile rather, given this implementation of empty. Let's go look at empty iter empty. So if I look at the nightly version.
00:57:12.995 - 00:57:55.251, Speaker A: Interesting. Hum, hum, hum, hum. Yeah, so that is the implementation. So why then is dropping an empty not considered dropping a T? Hmm. Hmm. So let's see. This will.
00:57:55.251 - 00:58:45.047, Speaker A: We're going to drop it down here. This is going to be just to double check. This is going to be an OSAN of immutable reference to an i32 if I drop the O here. Interesting. I honestly don't know why this compiles given this definition. I mean, I think you're right. I think it's because there's no implementation of drop for empty.
00:58:45.047 - 00:59:28.525, Speaker A: But I don't see why that should matter because the drop check should still consider this as dropping a T, because it does. According to this definition, this type drops a T. I think what probably happens here is. Oh, does empty implement copy? Good catch. It probably does. No, no, it implements clone but not copyright. Hmm.
00:59:28.525 - 01:00:22.625, Speaker A: The only thing I can think of is that the lifetime that gets assigned here gets shortened. Yeah, that's almost certainly what happens. That I think what happens here is actually that the lifetime. So this gets a lifetime of. Let's call it tick A. And I think what happens is that it just considers ticket ends here. I think that's why, like, there's nothing stopping the compiler from saying that tick A is just the duration from here to here.
01:00:22.625 - 01:01:17.511, Speaker A: Yeah, but then dropping the iterator afterwards should still be considered illegal. Oh, I'm stupid. No, no, no, no. I mean, we could try it next, but I don't think that's right either. I don't think that should make a difference because the call to drop it here is equivalent. Can we see the drop handler run? Yes, you can. Give me a second here.
01:01:17.511 - 01:02:02.875, Speaker A: So let me just copy and get rid of these 4,242. So why does that get printed twice? You get printed once when this gets dropped and then it gets printed again when this prints. Which is right, because this. It next returns none. It doesn't actually return a noise on. Hmm. Are you accidentally using your own empty? No, I called that empty Iterator, so I'm not using that one.
01:02:02.875 - 01:03:00.597, Speaker A: Huh. The drop of the. So the explicit drop of O is necessary because otherwise it thinks that always dropped down here and then the O just O itself conflicts with the A. Oh, yeah. I guess we can do. I guess we could do this default for empty Iterator just to, like, see whether there's some magic going on. I feel like it's weird for there to be magic here.
01:03:00.597 - 01:03:51.845, Speaker A: Like looking at the source, there's no magic. But, you know, who knows? So if we do this with instead of empty, we do empty Iterator and we do this. Yeah, so it compiles with mine as well. I'm just like, unsure why this presumably definitely compiles should be strictly more general. Hmm. Yeah, I don't have a good answer for you. I don't have a good answer for you.
01:03:51.845 - 01:04:48.415, Speaker A: I feel like this code should not compile and I can't quite explain why it does. Could you try wrapping all this in a function explicitly use the same lifetime for it and. Oh, we could try that. I don't think it's going to make a difference. So let's say we generic over tick A and it's going to take an Iterator, which is going to be an empty of poison of tick a mute. It might only need to take one argument and it does. Next.
01:04:48.415 - 01:05:56.555, Speaker A: Oh, what did I do? I did something wrong. Oh, this should be a thing. And what am I, blind? Empty oisan expected type found. Oh, yeah, you're right. Okay, so actually, what happens here. Yeah, yeah, yeah, yeah. It's because.
01:05:56.555 - 01:06:51.367, Speaker A: Oh, yeah, you're right. I needed a type after mute. Okay. So the reason is because a tick a mute T is invariant in T but covariant in tick A. So what happens is that even though this has the lifetime, so the lifetime tick A gets shortened to this lifetime. No, but even then dropping the. So it's true that empty is allowed to shorten the lifetime of this into one that ends here.
01:06:51.367 - 01:07:39.065, Speaker A: But then when we use this here. This should be illegal because the Iterator contains a value with a borrow that's already ended and if the borrow is extended to the end of the scope, then this use should be illegal. The. It may return a static. No, it has to return a T. Oh, you're saying this gets extended to be a tick static. Oh, I see.
01:07:39.065 - 01:08:07.155, Speaker A: Because it never yields one, it's allowed to claim that it does. Yeah. That's awkward. Yeah, you're right. I wonder if we can. Yeah, and if I create a function is going to bind the. Okay, so.
01:08:07.155 - 01:08:37.378, Speaker A: Ah. All right, so what actually happens here is the. As you can see from this annotation, like the empty gets created as a. As a thing that has a static mutable reference because it never. Yeah, because it never holds a T. Like it can produce a. Wait, that's not why.
01:08:37.378 - 01:09:07.955, Speaker A: Why not? No, this is definitely it. It. It is allowed to produce immutable reference of any. Of any length because it doesn't actually produce a reference. So it's able to produce the reference of any length. Right, so the O we get here. I bet you this is a option poison text.
01:09:07.955 - 01:10:08.937, Speaker A: Is that right? No, this won't be right. Yeah, that's not a static. So here O has a lifetime that's associated with the A here. But then when we reassign O here, its lifetime gets shortened because it can be like we were overriding O anyway. Yeah, so the lifetime of O at this point has been shortened to be here, but empty is still sort of is allowed to claim that it can produce mutable references of lifetime static because it never actually has to produce them. And therefore when we call it next down here, it's fine, because the empty is not actually tied to the lifetime of this because it. Because the static mutable reference that it returns here gets shortened to be the lifetime of the mutable reference here.
01:10:08.937 - 01:11:06.907, Speaker A: So think of this as like this returns a blah, blah, blah, tick static mute. Yeah, a tick static mute of I32. Right. But the O here is of time of type tick a mute i32 and the compiler. Because mutable reference or mutable references are covariant in their lifetimes, what actually happens is that the tick static that the Iterator returns here gets shortened to the tick A over here. So everything still works out as long as empty has a static lifetime. And therefore when we drop it over here, we're dropping an Oyson with a static lifetime, which is not a use of A because it's not tied to the lifetime of a It's just tied to the static lifetime.
01:11:06.907 - 01:11:37.439, Speaker A: That's why this works out. So I still think that the phantom data of empty should be this. Although someone mentioned it's because of const, which makes a lot of sense. This probably. You can't probably constify, this is my guess, but it's just hard to come up with an example where this is a problem where it triggers the drop check. Yeah. Yeah.
01:11:37.439 - 01:12:16.765, Speaker A: Okay. So at least now we understand why this compiles, even though it is somewhat convoluted. But the reason it doesn't trigger the so so it does trigger the drop check. Like this still considers itself as dropping a T. So it considers itself a drop of this and dropping oisan is going to use one of these. But because this is not tied to the lifetime of the borrow of a using this mutable reference using it's not actually going to use anything because it's none. But using this mutable reference is not a use of A and therefore does not conflict with the use of a down here.
01:12:16.765 - 01:13:03.641, Speaker A: And so the drop check does get triggered. Just it doesn't consider it a use of the thing that's borrowed. I'm sure you could construct one that does where this would be a problem, but it's probably weird enough that you don't run into it in practice. Yeah, I wonder if this could be this could probably be this. Although if you made it this, it wouldn't be send in sync, so it's a little awkward. All right, great. So even though this was more about variance than the drop check, it was related to the drop check.
01:13:03.641 - 01:13:46.639, Speaker A: So I don't feel too bad about going through it. And I feel I understand it better now too. I'm glad we managed to work it out. I recommend you go back and read this again and see if it makes sense the second time when I upload the video. All right, so now we have. Now we have our own box type, we have Norwegian box type and hopefully let me get rid of the stuff in between here. Okay, so just to sort of do a recap, we have a box T.
01:13:46.639 - 01:14:58.705, Speaker A: It contains a non null T because, well, we know it's non null because it comes from box and we want the niche optimization, but more importantly, because we want it to be covariant in T, which a mutable reference immutable pointer to T would not be. We include a phantom data T because we do drop a T when boxt gets dropped and we want to signal that to the compiler so that it will check the drop implementations of T when box is dropped, we have an implementation of drop for box, which we need to. Because we need to drop the box and call the destructor of the inner T. But we annotate the T as maydangle, because we sort of were promising, by virtue of the unsafe keyword here, that the implementation of drop that we have will not access the T. It won't use the T or dereference the T, if you will, not necessarily dereference, but use the T inside of drop. And therefore the compiler doesn't need to check the. It doesn't need to assume the T is used unless the drop of T implies the T is used.
01:14:58.705 - 01:15:41.575, Speaker A: So hopefully that now explains all of the weird, all of the weird bits of syntax that we're using in here. And keep in mind too, that this is probably not going to stay in the language long term. This is like a temporary fix for this problem that is nightly only and will remain so basically forever, I think. All right, hopefully that was interesting. I think we're going to end it there. There's not really that much more to say about the drop check. It's more just sort of talking through why it matters and why the different bits and pieces are needed and how they fit together.
01:15:41.575 - 01:16:15.143, Speaker A: So I think. I think we're in a good place. I just want to push back. There was a comment in chat saying this is complicated for no reason. I don't think that's true. As we walked through here, right when we started out with sort of the naive definition, then the reason why we needed to add this complexity was because without it the like, it's totally safe, right, to not have this made angle. But it restricts the use of the type and it restricts it for a good reason.
01:16:15.143 - 01:16:55.525, Speaker A: It restricts it because the compiler doesn't know what you do in your drop implementation. And so you need to tell it that you don't do certain things. And by telling it that you allow your type to be used in more ways. And then we sort of overcompensated to make it so that this makes it too, makes the type too flexible, more flexible than is safe. And so we need to reign it in with this. It might be that there's some other way to like expose this pattern. And that's part of the reason why this is not stable is because clearly this is sort of a sort of roundabout way of getting at it.
01:16:55.525 - 01:17:36.215, Speaker A: But there are some fundamental problems involved for why we need to tell the compiler this in some way. And this is the only way we currently have of telling the compiler, but if you can think of a better one, then I think the Rust standard library maintainers would love to hear one because it's not entirely clear what it should be and there have been multiple sort of draft designs. All right, I think. I think that's the end of what I wanted to talk about. I don't know quite when the next stream will be. I'm guessing in like three weeks or something. And I really want the next one to be like a live coding one.
01:17:36.215 - 01:18:04.685, Speaker A: I just still haven't quite decided what we're going to code. I'm still working through that and trying to figure it out. I've had some people reach out to me to sort of try to give some ideas and that's great. I love just getting the input. I can't promise I will do any of them. I sort of need to find something that just speaks to me because if we're going to do like three six hour sessions of coding, it needs to be something I really care about and so that's part of the challenge. But I think it's going to be fun.
01:18:04.685 - 01:18:20.995, Speaker A: All right, thank you for joining everyone. Hope this was interesting and not too confusing and I will see you all next time. So long, farewell, auf Wiedersen, goodbye. Ah, no, I don't want to accept it. I want to stop recording.
