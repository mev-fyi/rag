00:00:06.600 - 00:01:12.775, Speaker A: Hello everyone and welcome back yet again to another crust of Rust. This time I wanted to tackle functions and closures and the function traits and function pointers because sort of like the situation is with strings in Rust, there are a lot of different function things or function like things and the distinction is not always clear. And I feel like it would be useful to just sort of get a survey of the scene. What we're going to talk about today is like not necessarily a super large area. We might be able to cover it in as little as an hour, I don't know. But I do think it's useful to have some information about the distinction between these different types and traits and how they interact, just because you're going to come across them a lot. Like, especially things like being generic over functions is I think something you run into a lot in the Rust world where you want to sort of have these nice like callback functions or you want to be able to write things in a slightly functional style and then function pointers just come up everywhere.
00:01:12.775 - 00:02:02.099, Speaker A: And so I wanted to make sure that everyone sort of understands that fairly versatile primitive in Rust. Before I start, I do want to say that I wrote a book. It is called Rust for Stations. It is the. It's intended to be basically a follow up to the original Rust book, the Rust programming language by Stephen Carroll. So this book sort of picks up where that book left off and tries to give an introduction to all of the slightly more intermediate, slightly more niche, slightly more, I don't quite want to say advanced, although maybe that is an appropriate word too. It tries to cover more of what you run into after you know Rust the language and you want to know how to use it better for particular use cases.
00:02:02.099 - 00:02:43.167, Speaker A: And it focuses on things like idiomatic usage, but also like how some of the more complex building blocks of the language work and how you can use them effectively. The ebook version is now up on nostarch Press and the print book is like with the printers. And I think the goal is like early November for it to actually get printed and shipped from nostarch. It will be get like distributed by I think Penguin Random House. And because it's like global shipping problems, it might take a little bit longer to get the book if you buy it through other retailers, but it will be available on like Amazon and stuff already as well. And yeah, it's a lot of what I talk about here is covered in that book too. Please get the book.
00:02:43.167 - 00:03:30.325, Speaker A: It's a good way to support me as well if, if that's Your cup of tea. All right, now let's get into functions and closures and traits. So when we talk about functions in Rust, generally what people think about and in fact let's, let's start a new lib over here or something. Let's start a bin and we're going to call it, we're going to call it closure. See, it doesn't work. I was thinking of closure in the sense of like feeling like you get closure in something, but it has the same as the type, so it doesn't really work. Let's go with call me.
00:03:30.325 - 00:03:59.685, Speaker A: And what we're going to do in this is. Well, here we have a perfect example, right? So fn main is a function, perhaps unsurprisingly. And fn main specifically has a type like if I in. Let's say I go bar over here. So if I in main set let equal. Let X equals bar. Okay, X now has a type.
00:03:59.685 - 00:04:47.535, Speaker A: What is that type? Some of you might say, well, it's a function pointer. It is in fact not in Rust. In fact, if we try to look at the type of this, it sort of looks like it's a function pointer, but it's not. Actually what this is is a function item which is subtly different. Notice here I'm not calling bar, I'm just taking the sort of identifier of bar and the type of X here is a function item which is a zero sized value that is only carried around at compile time that references the unique function bar. And in fact, if bar was generic, then I wouldn't be allowed to do this because this does not uniquely identify a function. I would have to do something like i32 for example.
00:04:47.535 - 00:05:34.805, Speaker A: So this now specifically names bar instantiated with the type I32 as T. But if I now said X bar U32, then you'll notice here I get a mismatched type error. And that is because this is not a function pointer, right? The signature of this function, right, is that it takes no arguments and return nothing. So Bar I 32 and Bar U 32 are really the same in terms of if you thought of them as a function pointer. But that's not what X is here. X here is a function item that's uniquely identifies the function bar that takes i32 as a T. If you try to assign that bar that takes U32 as a T.
00:05:34.805 - 00:06:41.051, Speaker A: They're not the same type. And if we tried to, if I, if I skip this and I tried to do something like print line mem size of x size Of I forget what it's called is the size of val. Size of val? Yeah, and CD call me and cargo run. You'll see that the size of this is 00 bytes. So it doesn't hold a pointer at all. Because this is just an identifier that the compiler uses to identify this unique instance of this function. Now, function items have a coercion defined for them into function pointers, though is I can define a function bazaar that takes a function pointer, which is written like this.
00:06:41.051 - 00:07:10.344, Speaker A: Let's. I'm going to make this a little. Just give it a better signature and then change bar to match. So bas here takes a function pointer. That's what this signifies. So here I'm saying I take a function pointer. So an actual like pointer sized value to any function that has the signature one U32 in and one U32 out.
00:07:10.344 - 00:07:56.203, Speaker A: And I can call Baz with bar U32. I can also call it with bar I32 in both cases. What happens here is that the compiler coerces the function item type into a function pointer type so that this function can be called. So inside of here, if I now print size of val of F and run this. What? Oh, zero. That's fine. You'll see that here the size of the value is 8 because it's an actual function pointer.
00:07:56.203 - 00:09:04.827, Speaker A: And that's necessary because these two functions are distinct from one another, right? There are two instantiations of bar for different types, which means they have different code, right? They've been optimized separately. They're just. They are different chunks of code that happen to share sort of a generic name. But we need to pass the pointer to the first instruction of one instance of that function when we call baz the first time and a different function pointer the second time around. But this does allow us to be generic, if you will, over which exact function is passed in as long as it has the same signature. Right? And of course, if you passed in something that was the wrong signature, like if I did this right, then now it wouldn't compile because it'll tell me the it expected a function pointer to a function that had the signature U32 in U32 out, what it found was a function item that has a different signature, that is it's a void function. It takes no arguments and returns no value.
00:09:04.827 - 00:10:14.047, Speaker A: And crucially, here you see, it doesn't coerce here because it doesn't match the required type. But what we learned from this is that function items and function pointers are different from one Another, but function items are coercible into a function pointer. And part of the reason we need this coercion is because if I do this, if I didn't ever call this right then, now, even though I've named the function bar with t instantiated to i32, the compiler doesn't actually need to generate the code for that function. It's no, under no obligation to, because it's never called. However, here I'm calling Baz, right? And so, and I'm passing in this coerced to needs to be able to produce a value that's a pointer to that function's body, and therefore it has to generate the function so that it can generate that function pointer in the first place. Of course, if the whole thing gets that code eliminated, then that won't happen, but in general, this forces the compiler to actually have to generate this function body. In general.
00:10:14.047 - 00:10:39.295, Speaker A: Of course, you'll do the same here. You're unlikely to just assign it and then leave it. But. But regardless. All right, video choppy this time. What is going on? Huh? It's fine now. Okay? It's fine now.
00:10:39.295 - 00:10:57.347, Speaker A: I'll keep going if it's fine now. If it's not fine now, I'll stop. What do you think? Fine? Not fine. It's really weird that this is happening. I did upgrade obs, so maybe it's obs. That's very, very strange. Fine on Twitch.
00:10:57.347 - 00:11:58.267, Speaker A: Okay, so the takeaway from this, right, is that a function item uniquely identifies a particular instance of a function, whereas a function pointer is a pointer to a function with a given signature, and you can turn one into the other, but not go the other way around. And this, of course, would then work again. All right, so that's function items of function pointers. And then we have this thing called closures. So you might have seen isn't quoks is like the next metagenric type, I think. So this takes an F where f and let's start out with is just fn. Okay, so quarks with Bar U32.
00:11:58.267 - 00:12:54.199, Speaker A: What does this do? So this also works, and what we're saying here is that quarks is a function that is generic over some F where f implements the fn trait. And notice that fn with capital f is different from the lowercase fn that we use for a function pointer, although the construction is the same. So if I wanted to say it takes a U32 and returns a U32. I do it in the same way, but one is a trait bound, and the Other is a function pointer type. So this is not a type, this is a trait. And here there are three different traits. So if we go back and look at the list of operations, there's fn fnmute and fn1s, and the distinction between these is the definition of the trait.
00:12:54.199 - 00:13:49.677, Speaker A: Specifically, FN takes a shared reference to self, fnmute as its name applies, takes an exclusive reference to self, and fn onece takes an owned reference to self. And the implication here, as the name implies for fn once, you can only call an FN once a single time, and at that point you've moved the value of the function that you wanted to call and you can no longer call it again. Fnmute, you can only call once at a time, so you need a mutable reference to it in the first place. And if you have one, you can call it multiple times, but you can only call it once at a time. And this is important. For example, if you stick an fnmute in an rc, you wouldn't be able to call it. Similarly, if you given a shared reference to something that's fnmute, you also cannot call it.
00:13:49.677 - 00:15:05.775, Speaker A: This is also why in general in fnmute, if you pass it to multiple threads, like through something like Rayon, then you couldn't call an FN mute for multiple threads at the same time, because it wouldn't be exclusive. Fn, on the other hand, is sort of the equivalent of having a shared reference in that you can call it multiple times, and you can call it multiple times at the same time, or at least through a shared reference. And the reason for this will become clear once we look at what closures are and what they do. But let's first think specifically about what this means for function items and function pointers. So a function pointer, and in fact a function item, has no state, right? They are standalone, just chunks of code, and they don't reference anything in any other stack frames, right? They don't reference any memory that's stored outside of themselves. There's no lifetime associated with a function pointer or a function item is the other way to think about this. And what that means is that they don't really care about self, right? Like for them all self contains is, well, nothing really for a function item and for a function pointer, self is just the pointer to the function.
00:15:05.775 - 00:16:00.685, Speaker A: But there's no state to really mutate there. There's nothing to move and therefore function pointers. Well, function items coerce through function pointers and function pointers implement all three of these traits so if you have a function pointer, you can pass it to something that takes an FN once, you can pass it to something, take an fnmute, and you can pass it to something that takes an fn. The one way to think about these FN traits is that they are sort of a hierarchy where anything you can. You can almost think of it as here, implement FN once, or implement FN for F where F implements fnmut. We wouldn't actually ever write this, but you can think about it this way. And the reason you can think about it this way and I'll show you in a second.
00:16:00.685 - 00:16:43.625, Speaker A: It takes some arguments. I am lying. It should be this. So if we go back here to. Yeah, so as you see in the documentation, do. Since both fn and fnmut are subtraits of N1s, any instance of fn or fnmute can be used where fn once is expected. So in other words, fn implements fn once.
00:16:43.625 - 00:17:41.035, Speaker A: So let's start from there and then we can. And the reason for this is if it requires. If we're given an owned version of self, that is, so far we've only talked about function pointers, but if we're given an owned reference to self, or an owned self rather, then we could trivially produce a reference to self. So I can trivially then do the sort of FN call of self. Like I can easily translate one to the other, right? Because if I have something that implements FN and I'm given a self, I can just take a reference to it and pass that to the fn. And similarly, I can do the same thing for something like FN mute. If I an fnmute, I'm given a self, right? So I'm given ownership of it, I can trivially just generate an exclusive reference to it.
00:17:41.035 - 00:18:34.675, Speaker A: And similarly, FN mute I can easily implement for fn, right? So I'm given a mutable reference to self. Well, I can just turn that into a shared reference and then call the FN version, right? Because these are sort of strictly more powerful. Does that make sense? Like why these end up forming a hierarchy? So Anything that implements fn also implements fnmut and fn1s.Anything that implements fnmut implements fn1s as well, but not fn, because you can't. If you're given a shared reference, you cannot produce an exclusive reference. Anything that implements FN1s only implements FN once. All right.
00:18:34.675 - 00:19:33.363, Speaker A: Does that make sense so far? Yeah. I don't know what's going on I think it's my Internet that's being weird. So we have this hierarchy, and I think it'll make a little bit more sense why this hierarchy is needed once we start looking at closures. Because again, a function pointer implements all of these because it doesn't actually care about the ownership of the function pointer because it is a pointer to code. You can think of it as a function pointer implements fn, and therefore it also implements fn mutant fn1 by virtue of the same rules we just talked about. And so that's why here, when we require an F that implements FN, we can easily pass in a bar U32 because it courses to a function pointer which implements FN. And similarly, if I made this FN mute, this would still work.
00:19:33.363 - 00:20:38.945, Speaker A: And if I made an FN once, this would still work, because function pointers implement all of them. In terms of actually calling them, though, you'll see that here, let's say that I wanted to actually call the F that I was given. If I have an F in once, then I need to take it by ownership. If I did this, for example, reference to something that implements FN1s, then the compiler won't let me call it because FN1s requires ownership of the F. It requires that I be able to move the F into the call, which it's telling me it can't do because it's behind an exclusive reference, right? And now similarly, if I get an fn, if I say that it's an fnmute, then now all I require is an exclusive reference, which I have, and therefore I can call it. But if I got a shared reference, I couldn't call an FN mute because it can't be borrowed as mutable, which is required in order to call an fnmut. But I could if it was fn, right? And so then we've ended up going full circle here.
00:20:38.945 - 00:21:36.067, Speaker A: All right, so let's now go back to why are these different? Like we already mentioned how function pointers implement all of these by virtue of implementing fn. So why do we need this distinction? The distinction comes up once you start talking about closures. So fundamentally a closure is written this way, so you've almost certainly used closures. If you haven't, this may not be the stream for you, but basically it takes arguments which are passed in between these, and it has some body that returns the contents of those. And let's say here we can annotate these with the takes an i32 and i32, right? So this is a closure. This happens to be a non capturing closure. So in general, closures are named closures because they close over their environment.
00:21:36.067 - 00:22:21.541, Speaker A: That is, they're able to capture things from their environment and generate a unique function, if you will, that specifically absorbs or uses or references data from the surrounding environment at the time when they're created. In this case, it doesn't capture anything from the environment, it only references its own arguments. And therefore this is a non capturing closure. And what's interesting about non capturing closures is that they are coercable to function pointers. So I can actually call Baz with F if it had the right signature, which we can make it do. So see here Baz takes a function pointer. And closures that do not capture over their environment can be coerced to function pointers.
00:22:21.541 - 00:23:08.565, Speaker A: They can also be. They also implement the standard sort of function traits, right? So they implement FN, for example. And because they implement FN, they also implement FN, mute and FN1s and all the way up. But if I have a closure that does capture from the environment, so let's say that I declare a Z, which is a non copy value. So it's going to be a string new. If it's copy, I'm going to hand wave a little bit and say that we don't want it to be copy because it makes this reasoning more complicated than it needs to be. So here I'm going to declare this closure as just consuming Z.
00:23:08.565 - 00:24:22.025, Speaker A: And you'll notice that now it it no longer can be passed to B. And if we look at the compiler errors, you see that it says closures can only be coarse to FN types if they do not capture any variables. And in this case it does capture a variable, right? It captures the Z variable from its own stack. Now let's say that all the closure did was like print line Z, right? So it doesn't actually move Z, it just takes a reference to Z, but nonetheless it captures over the environment. And that means that you cannot represent, represent this closure as just a function pointer, because in order to like this, this closure, think of it as the compiler generates a sort of anonymous struct for the closure that contains fields for everything it captures from its environment. Because when this closure runs, it needs access to that information. So you can sort of think of this as it generates like a F closure struct that has a Z field which is a string.
00:24:22.025 - 00:25:58.559, Speaker A: And crucially, right, this is an A or if you will, scope, which is a reference to the surrounding scope and then you can think of it as it implements FN for F closure, and it can do that because if it's given a shared reference to self, then it can still call that closure in the sense of this implementation is going to be sort of copy paste from closure definition, right? It'll just turn that into self Z. And that works just fine because this is a shared reference anyway, so you can, you can't actually write this code, but you can think of this as what the compiler generates. And therefore you see why it needs access to the Z. The function pointer, which would just be a pointer to like the start of this code block would not be sufficient. It needs the additional state of this Z. Does that make sense so far? Okay, so, so now let's look at what happens if I make this mutable and I say that this is going to Z dot clear. So clear is a method on string that takes an exclusive reference to self and it clears the string.
00:25:58.559 - 00:27:02.319, Speaker A: It doesn't deallocate anything, but it clears the string. So now the F closure that gets generated, the sort of state for the closure has an exclusive reference to a string, because that's what it needs to capture in order to call clear, right? It can't capture a shared reference because this requires an exclusive reference. And at this point, if we now again imagine that it sort of copy pastes the body, this clear won't work, right? Self Z clear. And the reason this isn't going to work is because the Z here requires an exclusive reference, but all we have is a shared reference to self to the sort of closure state, if you will. And so we can't actually get an exclusive reference through that, even though we have one here. This ends up being a shared reference to an exclusive reference to a string, which is only usable as a shared reference to a string. And so this won't compile.
00:27:02.319 - 00:28:05.161, Speaker A: Or in other words, when you have a closure like this, it cannot implement fn, it can implement FN mute, right? Because here we now an exclusive reference to the closure state which has an exclusive reference to the Z, and therefore we end up having an exclusive reference to the string. And this works just fine. And again, anything that implements FNMUT implements FN1's and so therefore this would also implement FN1's and so this closure is an example of something that implements. Let me comment this out just to avoid the compiler errors for a sec. So you'll see that this doesn't coarse to a function pointer, right? Anything that captures cannot be. We try to call quokks with it, but it says the closure is FN mute because it mutates the variable Z here, right? It expected a closure that implements the FN trait, But this closure only implements FN mute. And that is indeed exactly what's going on.
00:28:05.161 - 00:29:17.793, Speaker A: As we just discussed, it cannot implement FN because it needs to mutably borrow from its environment, right? If I made this take an FN mute, then I would need to take at least this. Or I could just change this to be owned right? Then now this. And I don't pass in a shared reference to it. So now, now F is just fine to pass to quarks, because all it requires is a an FN mute, and this closure is FN mute. So what then, you might ask, is, okay, what about this FN once? Well, let's imagine that what we wanted to do in here was actually drop Z. So to drop Z, we need to have ownership of Z, which means that we need to move into the closure, right? So Z gets moved into the closure. And that means that you just like, obviously cannot call this closure more than once, because to call the closure you move Z, but if you try to call the closure again, you would have to move Z again, but you can't move Z Z again because it's already been moved.
00:29:17.793 - 00:30:08.105, Speaker A: Or if we expressed it this way, like we've been talking about so far, this no longer has sort of a lifetime here. It owns the Z string, right? Or you can think of it as it still has scope, but there's just no use for that scope. If we try to implement fnmute and this tried to call drop self. It's not possible for us to drop self here because calling drop requires ownership of self, but all we have is an exclusive reference, therefore this won't work. We can, however, implement F and once, because F and once is given ownership of self, and therefore we can drop self Z. Sorry, this should have been self Z all along. So here we are allowed to, because we get ownership of the closure state.
00:30:08.105 - 00:30:45.455, Speaker A: And so this implements FN once, but it cannot implement fnmute and it cannot implement fn. And you can see this also by if I comment this out again, because you can't actually manually implement the FN traits at the moment. You'll see here that it says that we can't. This call to quarks is not valid because it expected a closure, then implements the fnmutrait. But this only implements FN once, and it implements fn once because it moves the variable Z out of its environment here. So that's sort of the path we go around here. And you might have seen move closures.
00:30:45.455 - 00:31:48.505, Speaker A: So you can write the move keyword before the definition of a closer closure. And what that means is. So closure capturing is actually a little complicated because here the compiler sort of knows that what the closure needs is an owned version of Z. It needs to own Z, and therefore it determines that it should move Z into the closure. When we called Z clear, the compiler sort of automagically figures out that all we need is an exclusive reference to Z, and therefore it only needs to move an exclusive reference into the closure and not all of Z itself. And similarly, when we had print line of Z, it realized that all you need here is a shared reference, and therefore it only moves a shared reference into the closure rather than all of Z. And that logic generally does what you want, but it's not perfect.
00:31:48.505 - 00:32:46.497, Speaker A: And there are some cases where you want to move a value into the closure, even though you don't technically need it. An example of this could be if the closure you want the closure to be the thing that drops the value. That is, when the closure exits, you want the value to be dropped. So currently the way this is, this is organized is that Z, the string will not be dropped until the end of this scope down here, right at the end of main, because it's not dropped in the closure. If I write move here, what I'm telling the compiler is move Z into the closure. And so now Z is dropped here, we still only needed a shared reference. We're telling the compiler, I want you to move into it here and now because we're moving Z into it, we end up in the same state of we actually need to own the Z.
00:32:46.497 - 00:33:45.645, Speaker A: And so we can only implement FN once. We cannot implement FN mute or fn. That make sense? Actually, I don't know if why does this compile? Ooh, maybe I lied to you. I think I lied to you. I think the move it'll still apply this heuristic. Yeah, you're right. The reasoning for this is actually slightly different, which is, well, that it is true that you can make a drop in here, but it's also because if I do this, the lifetime of the closure is tied to the to the stack here.
00:33:45.645 - 00:35:11.685, Speaker A: So maybe if I give a slightly different example. So make FN is going to return an impul FN once. Sure, why not? And it does. Z equals string new and then it's going to return a closure that is going to print line Z right? So here is an example of I want to return a function, right? I'm not going to tell the caller whether it's a closure or not, but I'm going to return something that's callable and it's only callable once. And in fact, let's say fn, I want to return something that's callable and I want it to be callable multiple times, which this one is, right? It's just printing Z over and over. The problem is that right now this borrows Z, right? And so the closure that's returned sort of has a lifetime that's associated with the sort of self of this function, right? This you can sort of read as Z is like a reference to Z that's moved into here. And this reference has some lifetime, right? Which means that this closure type really has that same lifetime.
00:35:11.685 - 00:36:02.295, Speaker A: But if you don't specify a lifetime, it assumes that it's static. And so here we're promising to give back something static, but the closure that we return isn't static because it references this Z. And so there you can apply the move to say, move Z into the closure. And now this closure is fn, because every call to the closure just references the string that's stored in the closure self contents. And that's fine. You can have multiple calls that all get a shared reference to the closure state, which gives a shared reference to the string for printing. It would not work if this tried to say drop Z because it wouldn't implement fn, right? Because once you've called it once, you've now moved out of self and so you cannot call it again.
00:36:02.295 - 00:36:48.035, Speaker A: And so this is where move is useful. Now one downside of move is that move means move everything. There's no like move. Like, let's say we had X as well. This will move both X and Z into the closure. And that is oftentimes what you want, right? And here we wanted to return something that was static, but that's not always what you want. But the way that you work around this is you either don't use move, right, if you can get away with it, or you use move and if there's something you specifically want only to be borrowed, you do like let x2 equals reference x and use x2 in here.
00:36:48.035 - 00:37:42.275, Speaker A: Now this won't work in this case because this makes it no longer static, but that's the way that you can moves some things by reference and some things by ownership. And there are many ways to express this. Like sometimes use shadowing if you don't Care about the old value. You could introduce a new scope so that you don't have to deal with this later. Regardless of how you end up doing it, this is the way that you would move some things but borrow other things into the closure. Does that code create a new string in static every time? Make FN is called yes. So the way we had this, if I go back here and remove Z and make this pub, I guess this every time you call make fn, it's going to allocate a new string and then return a closure that owns that string that was allocated.
00:37:42.275 - 00:38:34.707, Speaker A: You can't choose per variable which to move or not move. Move is all or nothing. So that's why you end up with a pattern like this. For example, to specifically say the thing that I want to move in here, the X is actually a reference to the real X, so I want to move the reference. And of course, if you do move something into a, into a closure, then now the closure, as we saw up here, right? The closures collectively or the closure owns the string. And so it's only when then any call to that closure uses that same string and it's when that closure is eventually dropped. Like the actual variable that holds the closure or the allocation that holds the closure.
00:38:34.707 - 00:39:53.727, Speaker A: When that gets dropped, the state structure for that closure gets dropped and therefore the string also gets dropped. All right, so we've now actually talked most of what's important to grasp about these function types, but there are a couple of more things I want to touch on. The first of these is around DIN fn, so TIN FN like so. So just like with other traits, you can also use the FN traits through DIN to get dynamic dispatch and you specify the full function signature and you just put DIN in front of it and this works just fine. In fact, here I can just call F. And similarly, if this was a DIN fnmute, I can call it as long as I take this as mute. Right? So that works fine.
00:39:53.727 - 00:40:36.941, Speaker A: And if it's an FN1S, I can also still call it so, so far, so good. This was not always the case. Interestingly, it used to be that there was this special FN box trait, and the reason for this was that this is a little bit of an anecdote, but it is an interesting one, I think. It used to be that Box didn't FN once. And in fact Box didn't FN anything, did not implement FN anything. So basically it used to be that box didn fn, did not implement fn. And similarly for fnmute and fn1s.
00:40:36.941 - 00:41:20.125, Speaker A: And the reason for this actually is kind of interesting. So let's imagine that we were the people trying to implement this, because I do think this gives a sort of interesting insight. Let's imagine that we are the standard library and we want to implement, let's say FN for a box, DIN fn. So we have to implement call. We take no arguments, we return nothing. And now the question is, what do we put in here, right? So self is a box. But we have this challenge here of like, let's say I do self dot zero.
00:41:20.125 - 00:42:06.835, Speaker A: Let's say that's how I get at what's inside the box. And I want to do call with no arguments, right? So it seems like this is all I should really need to write sort of dereference the box and then call the thing that's inside. The problem is what is the type of self0 here? If we were to write this out as a variable, right? And let's. Let's take FN once, just because it's more clear what's going on. So I move out of self zero to get at the thing that's inside the box and then I do X. Col, what's the type of X? The type of X here is DIN FN once. But this type is not sized.
00:42:06.835 - 00:42:54.565, Speaker A: So how much space does X take up on the stack here? Remember, DIN in general is unsized, right? It's not sized. And that's why in general for box, you always need either a reference or an exclusive reference or something like a box around it. You can't have a freestanding DIN because it's not sized. So the compiler wouldn't know how to range the stack frame for this method call. And so it's kind of interesting if you look back sort of historically and this is going to be bright for a second. I'm sorry about that. So here in the release announcements for Rust 135, you see, it was like a big thing that now these traits are implemented for the appropriate box types.
00:42:54.565 - 00:43:49.367, Speaker A: And previously there was this event box that got to do special compiler magic. And as you see here, this sentence, this was ultimately due to a limitation on the compiler's ability to reason about such implementations, which has since been fixed with the introduction of unsized locals. So someone said, why couldn't you take a reference to the box contents? Well, this is why I chose FN1, because here to call it, you need an owned self. So you can't take a reference to this because if you had a this, you couldn't call it because FN once requires ownership of self. And slightly similar issues arise with fnmut. And so there is actually an RFC specifically for unsized R values which is required for this implementation to exist. And the RFC has landed with lots of implementation questions.
00:43:49.367 - 00:45:35.515, Speaker A: And basically the compiler gets to take advantage of this particular feature, but it's unstable, so you can opt into it on Nightly, but you can't generally use this in your own code on Stable, but it is required for this particular thing to work, which I thought is like an interesting tidbit, and there's all sorts of cool implications of what we could do if we got unsized R values, but that's neither here nor there. So when you have boxed in and then some FN trait that just works now, you don't really have to treat it specially like in general, DIN just works, but you do have to keep in mind that if you get something like a How am I going to demonstrate this best? So this implements fn. So let's say I here gave a DIN f. DIN equals. So this works just fine, right? I turn F into a dynamically dispatched fn. This is sort of like a function pointer, except it's allowed to, right? So it has a self, basically it constructs a self for this closure and then uses that as the data pointer of the dynamic dispatch. And the V table just has the call method.
00:45:35.515 - 00:47:12.421, Speaker A: So that so far is fine. The challenge here, right, is let's say that I try to make this fnmute, so now I have a DIN FN mute, but all I have is a shared reference to it, and therefore I can't actually call it, because this doesn't implement fnmut. This only implements FN because all you have is a shared reference. So when you use dynamically dispatched function traits, you need to make sure that the sort of the wrapper, the indirection type, the wide pointer type that you use allows the kind of access that you actually need in order to call that function, right? So in order to call an fnmute, you need to stick it behind a shared reference in order to call an fn, all you need is a shared reference in order to call an fn. Once you actually need a wide pointer type that allows you to take ownership, right? So I mean, I would have to box new. And of course again the same hierarchy applies. So if you have a wide pointer type that allows you to take ownership, then it will also work with any of the sort of weaker function or less Restrictive function traits.
00:47:12.421 - 00:48:01.429, Speaker A: So I can have a box DIN fnmute, because if I can take ownership that I can certainly get an exclusive reference. If I can take ownership, then I can definitely get a shared reference. So these are both fine. And we'll implement the appropriate trait outside of the white pointer. And if you think of something like arc, right? So standard sync ARC standardsync ARC will allow you to stick unsized things into it, but an ARC by necessity will only give you shared access to the thing that's inside. And therefore ARC DIN of FN implements fn. But ARC DIN fnmute still only implements fn, or in fact then can't implement the trait.
00:48:01.429 - 00:48:41.029, Speaker A: Rather. So here if I say this takes fn. Ooh, maybe they haven't implemented this for arc. Maybe they've only implemented for box. Interesting. So I'm guessing then that this implementation doesn't actually exist for ARC yet. If we go back to look at fn, for example, you see there's an implementation of FN for box of F where F implements fn, but there is no implementation of arc.
00:48:41.029 - 00:49:04.845, Speaker A: I wonder why that is. That implementation should exist. Interesting. And we can use the intuition we've built up so far for why that should be the case. An ARC supports unsized values. Basically. ARC can support being a wide pointer, and therefore it can hold the DIN fn.
00:49:04.845 - 00:49:51.765, Speaker A: And if it can hold the DIN FN and it's able to give you a shared reference to the closure state, then it should be implemented implement fn, because all that requires is being able to get a shared reference to the closure state. So this suggests that there's sort of an implementation missing here, and it might be because of this issue we were looking at about unsized rvalues. Maybe it's like specialized to box somehow, but that would be an interesting implementation to add. That's pretty good. Okay, so about an hour. I think I guessed about right. The last thing I wanted to touch on was const fns.
00:49:51.765 - 00:50:37.437, Speaker A: So what's a good example of this? Let's try to erase some of this stuff. Okay, so let's say I define a closure that takes. That just returns zero, right? So this closure is a constant closure. You could evaluate this closure at compile. Right. This is sort of equivalent to const of n, like make 0 that returns a use size. Or I guess i32 is the default.
00:50:37.437 - 00:51:16.855, Speaker A: Right. These are both the same in the sense that they're both callable at compile time. They're basically both const. But the question becomes let's say that I want a const fn. I don't know foo and I wanted to take an F. That's let's say FN1's and I want my const to be able to call F. Well, that's not currently okay, because the compiler doesn't know that F is callable as a const.
00:51:16.855 - 00:52:02.275, Speaker A: Right, because we've just said this is an any. Any type that implements FN1s and we don't know that the implementation of FN1 is actually const. So there's nothing in stable that you can do about this today. But there's a sort of interesting pre RFC discussion that's going on and has been going on for a while about Is there a way to say I want to take. I want to be generic over any type that implements this trait, but only using things that are const, evaluate able and the syntax they've come up with is this. And let's see if I can opt into this easily. I forget what the actual thing is called.
00:52:02.275 - 00:53:12.275, Speaker A: It might not be named anywhere that I can easily get at. What happens if I run Cargo R? Let me just pull this up real quick to see what the. But what is the name? Ah, feature gate. A constraint implant. So we're going to add this here and then we're going to rust up overrides at nightly and we're going to Cargo R and see what happens. Yeah, there's here, there's the second one you need to add, which is this one. So again, as you can see, this is very experimental.
00:53:12.275 - 00:53:51.545, Speaker A: Okay, so. So what this signifier means, this, this const, this, this tilde const is that it doesn't actually mean this F and ones or this F must be const. It doesn't mean that I will only take types that. That have a constant implementation of FN ones. That's what this would mean, right? This would mean F must have a constant implementation FN ones. It's also not question mark like you might think of, like question mark sized. It's not really question mark const because it's not saying may or may not be const, which is what question mark sized means.
00:53:51.545 - 00:54:39.825, Speaker A: Rather, what the tilde here signifies is foo will be constant if F is const. If F is not const, then FN is not const. And we haven't talked too much about const on stream. But the basic premise here is if you have a const fn, it's callable at compile time or at runtime, like you can call it either of them, which sort of means that it's a const. FN is also an fn. And what this is saying here is that this const FN is only const, so is only callable to compile time if its generic parameter is also const in its implementation of FN1s. And so that's why this is like new sigil here, because it doesn't really mean the same as the other sigils that we have.
00:54:39.825 - 00:55:30.267, Speaker A: So that's why, I mean, this is not a full RFC yet. It hasn't been merged. So this is very, very experimental, as you can see, with like the two features we need to opt into. But it is an interesting thing to keep in mind and something you will see going forward as we start seeing more and more constification of rust code. Foo calling X. Oh, sorry. Yeah, so if foo calls X here foo, what am I missing? Expected zero arguments.
00:55:30.267 - 00:56:09.097, Speaker A: I think this is just Rust analyzer being confused because it doesn't know about these features. Right, so this runs just fine. Oh, why? Oh, because string new is const. If I said string from foo, this is not const. Oh, a string from const to what is not Const. Vec 123 what is not const. Oh, sorry.
00:56:09.097 - 00:56:26.855, Speaker A: It's fine. Okay, so. Right, so this is what I was. Yeah, this is what I was getting at. Let's. Let's do con const of n test foo. That's what I need to do.
00:56:26.855 - 00:56:56.105, Speaker A: The. The problem here, right? Or the. The reason why I have to do this is because main isn't const. So there's no requirement that foo is const. So I think this can go back to string from foo. Now, string new is const. So in main I'm allowed to call foo because I don't require foo to be const.
00:56:56.105 - 00:57:31.695, Speaker A: I can call it even if it's not const and the closure here. So the implementation of FN1S is not const and therefore foo sort of genericized over this closure is not const. But that's fine for main. So if I comment out this for a second, you'll see that this runs just fine. But in a const fn, in a const fn, you can only call things that are themselves const. So here, if I try to run it, you'll see that it complains expected in FN1's closure. Found this closure.
00:57:31.695 - 00:58:14.755, Speaker A: And here you'll see the errors aren't very good. And that's because the Error reporting doesn't know about this const flag yet, but the actual complaint here is that const defends require that everything they call is also const. So this requires that foo, when generic over this closure is const. But this closures implementation of F once is not const. Therefore foo is not const and therefore this call is illegal. If on the other hand, I use string new here, which is const is maybe not const. Ooh, interesting.
00:58:14.755 - 00:59:22.081, Speaker A: That's interesting. Does it work if I do this? Oh, weird. Yeah, I think this is evidence of this being a very experimental feature. But the intention is that if the closure is itself constant or constant evaluatable, which string new is Because I believe string new. Yeah, string new is a const fn, then foo should also be const fn and therefore should be callable from context. Constefends are stabilized, but this kind of bound is not stabilized. And so error reporting doesn't know about this kind of bound and so doesn't really talk about it in the error message you get.
00:59:22.081 - 01:00:33.245, Speaker A: It does know about const event more generally. All right, I think that's all I wanted to cover about functions and closures and the traits and types that are involved. Are there questions about any of the stuff that we've talked about so far? Like any of the. Any of the bits that you want me to go over again? And I'm sad about the audio issues, but hopefully, at least in the video on demand, I'll chop it up a little. No, people seem to be happy you've generally followed any questions about anything else. Now that we ended up with sort of a relatively short stream, which was kind of as expected. Anything that I can answer outside of this particular topic? Sometimes you end up with complicated lifetime bounds with 4R.
01:00:33.245 - 01:01:11.225, Speaker A: So let's get rid of the const off n stuff for a second. Yeah. Okay. So an example of this is if I write a F and it takes an F and I want to say that F is a function that. Let's imagine that it's a map function. So it's going to be given a sort of. I don't know, it's going to be given a reference to a str and it has to return a stir.
01:01:11.225 - 01:01:51.891, Speaker A: So let's imagine that I want to write a function like this which maps a string and I want to try to call quarks with a closure that takes x and returns x. So far, so good. This is not a problem. This works just as expected. Um, but there are cases where this gets a little Bit more complicated. In particular, like, remember, in bounds, you usually, although not always, but you usually have to specify lifetimes. What are the lifetimes here? Right.
01:01:51.891 - 01:02:37.585, Speaker A: Whenever something returns, like, you can often omit the lifetimes. But if we were to try to specify what the lifetimes are here, what are they? Because there's no lifetime here. If we tried to fill in the lifetime for this, for this trait bound, what actually is it? There's no tick a because we can't assign a tick A here. What we're really saying is we want F to sort of reuse the lifetime that it gets in in its output. We want to say that it's allowed to reference the same thing that was referenced in its input it. And this is where you get this special for syntax and what this syntax means. This is the actual de sugaring of that syntax.
01:02:37.585 - 01:03:16.083, Speaker A: This you can read as for any lifetime tick A F is implementation of a function from a stir with a stir reference with a lifetime of A to another STR reference with the same lifetime of A. So it's not actually that complicated. It's a way to say that this. This needs to hold for any lifetime. This is what the bound should be. It's very, very rare that you actually need to give a four bound like this. It does sometimes happen if you.
01:03:16.083 - 01:04:06.315, Speaker A: If you have trait bounds that have lifetimes but are not FNs, the compiler is pretty good about inferring it for anything that is of FN type or FN mutant F at once, it can usually figure this out. But once you start having other traits that aren't FN in here, you sometimes need to reach for four, but it should be very, very rare. Will you be doing another Q and A session sometime? I will, but I don't quite know yet. I really want to get back to the hazard pointers library, so I'm trying to find time for that too. How much will I enjoy Rust? For rust stations over 9,000. How do you broadcast both video and your screen at the same time? What software are you using? I'm using obs. Very happy with obs.
01:04:06.315 - 01:05:12.907, Speaker A: If I want to pass a closure to an ASIC function, the closure needs to be static, right? How does this kind of closure capture its environment? If you want to pass a closure to an async event, you can just do so. There's nothing preventing you from taking any fn. It doesn't need to be static. It's more that usually with. Usually with futures, especially if you want to do something like Tokyo spawn of the future, you get Back then Tokyo spawn, just like thread spawn requires that the argument is like static. And if F here is not static, then the return future will also not be static. Right? If we sort of think of the de sugaring of this, right, it's fn this to impulse future that's really the desugaring of this and impul trait.
01:05:12.907 - 01:05:53.725, Speaker A: Just like async, FN automatically captures the lifetime of its inputs. So if this input is tied to some lifetime, then the output type will also be tied to that same lifetime, which means it will not be static unless the input is static. And so that's why you often end up having to add static to generic types that you pass into async functions. It's not because they're required. Like if I. If I just directly awaited here, then there's no need for the function to be static. The future that's returned to be static, it only comes up if you try to do something like spawning, where the future needs to live longer than the current stack frame.
01:05:53.725 - 01:06:27.375, Speaker A: You often need to pin it. I mean, you should very rarely need to pin things manually. In general, a weight syntax should take care of it. All right? In that case, I think we're going to end things there. Thanks everyone for watching. I hope you learned something. Go teach someone else what you learned and I will see you all in a few weeks.
01:06:27.375 - 01:06:37.835, Speaker A: I really want to do more hazard pointers, but I just need to actually find the time to do six hours of coding. All right, bye everyone. Hope you enjoyed it.
