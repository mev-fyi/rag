00:00:01.040 - 00:00:48.956, Speaker A: Hello folks, welcome back. I'm quite excited about this stream, actually, for a couple of different reasons. The first one is that it's been a while since I did just like a pure live coding stream like this won't be a crust of rust, this won't be as educational stream in the sense of the crust of rust streams that I've done in the past. Instead, this is one where we have a programming problem, or we're just going to dive in and write a bunch of code and see if we can make things work. The other reason that I'm excited is because this is a project that I'm kind of proud of. I think this is a really cool concurrency primitive, and I'll explain it as we go a little bit. And the other day I had this realization that I could do something cooler with it.
00:00:48.956 - 00:01:36.622, Speaker A: Again, I will explain what that means. I've been excited for the stream for several weeks now, and so we just barely lost the Twitter poll of which stream to do next. It was a little sad and why I immediately went to this one next. So here's what we're going to do. This stream is going to be on a project called EV Map. And EV map is something I built for Noria for my PhD thesis work. And essentially it is a concurrent hash map, but it's a concurrent hash map that is heavily optimized for reads, and it puts a lot more onus on the writer to do locking than on the readers.
00:01:36.622 - 00:02:19.152, Speaker A: And the readers basically get to be completely lock free. The reads are very, very fast. They scale very well. In fact, if you scroll down here, I think there's a chart of like, as you increase the number of readers, the throughput for the readers just goes up linearly with the, the number of readers, no matter how many writers there are. And that's a really cool property for a concurrency primitive. But, and I'll explain how it works in a second. The downside of it is that this implementation was written very specifically for Noria's use case, and you can see that if you start reading a little bit of the description of the data structure.
00:02:19.152 - 00:03:02.474, Speaker A: So it's a lock free, eventually consistent concurrent multivalue map, which is a mouthful. The lock free part is that there are no locks and readers, in fact, never have to wait on writers at all. So it's like wait free for reads, but I don't want to use the term wait free because I don't know whether I completely understand the, like, theoretical ramifications of that word, but pretty close to it. Eventually consistent in the sense that the writer can choose when to expose changes to the reads, they don't become immediately visible to readers. We'll talk about that in a second. It's concurrent, so you can use it for multiple threads at the same time. And in particular, it's concurrent for reads.
00:03:02.474 - 00:03:33.090, Speaker A: So there's only one write handle. There's only one writer. If you wanted to have multiple writers, they would have to serialize through a lock. But it's concurrent for reads, so you can have many, many readers and they don't contend with one another. And it's multivalue. So the idea here is that where a normal hash map is from key to value, a multivalue map is from a key to a set or a bag of values. And that means that it has some kind of weird restrictions.
00:03:33.090 - 00:04:34.950, Speaker A: So I've had a number of people file issues with it. And let me see if I can explain this a little bit more detail, sort of, before we dive into the technical things of how this works. The idea with a multi value map is that you can, this is just sort of the same way that standard hash maps work, right? You have an insert, you have keys, you have values. But one difference is that because it's a multivalue map, we can insert multiple values for the same key. And now if you fetch out a given key, you get back all the values for that key, not just the latest one. And here you also see this refresh operation, right? So we inserted these, but then we did a get, and that get still returned one for Grimm's fairy tales until we call refresh on the writer. And at that point, the reader actually sees the changes that we made.
00:04:34.950 - 00:05:36.704, Speaker A: And there are a number of implications of doing the map this way, which is once you have a, once you have the value bag, actually be a bag and not a single value, you get into some complications, because people need to be able to remove a given value from the value set for a key. And you can see this in, if we look at a right handle, for example, you'll see that not only do we require that the key is hashable and can do equality, we require that the value implements eek and hash two. And that's because if I want to remove a given value, I need to be able to compare values. So values need to implement eek, and in order to store the value set efficiently, we store the values themselves in a hashmap, or actually technically in a hash bag. And so the values also need to implement hash. And this is, this is pretty onerous. Like, you might not think about this very often, but usually when you use a hash map, the.
00:05:36.704 - 00:06:13.754, Speaker A: The values are like, arbitrary things. Like, you might want to stick, like, channels in there or something, right? The send half of a channel. But the send half of a channel is neither eek nor hash. And so this requirement is pretty sad. And so this kind of question comes up in a. In a couple of different ways. One is that storing the value, the value set as like a larger collection as opposed to a single element, means that we're sort of wasting memory for anyone who wants to use it only as a single value map.
00:06:13.754 - 00:07:14.030, Speaker A: Someone you want to use adjust as a regular key value map. And there's been a bunch of questions of, like, how hard or easy would it be to move this to something that is just, what, like, key to value? And similarly, people have had questions about why is there a hash and eq requirement? Is there a way that we can get rid of it, or is there a way that we can get rid of it? Only in certain. Certain use cases. And the answer to that so far has sort of been no. That if you wanted to remove the multivalue part of this, you would basically have to re implement the whole thing. And the whole thing is fairly complicated, so it would be a little sad to have to keep a fork of this whole data structure just to support, like, a single key value map, for example, which then brings me to the topic for today's stream. So, about two weeks ago, I had this idea for how we might be able to make EV map generic over the collection that it is concurrent over.
00:07:14.030 - 00:08:08.220, Speaker A: So that way you can have sort of an EV map that holds regular hash map, or that holds a multivalue map, or that holds a b tree map or something like it. And we'll get into the details of this in a little bit. But first, I want to explain how EV map actually works, because we're going to dive pretty deep into the guts of it, and it's important to have an idea for how these things fit together. I'm also going to do some questions, because I saw there were some questions that came in while I was discussing this on the topic of EV map itself. So let's see. This is not based on flurry map. So for those of you who may have seen some of my earlier videos about porting the concurrent hash map from Java to rust that ended up with a crate called flurry, this is not flurry.
00:08:08.220 - 00:08:51.560, Speaker A: This is a completely different data structure that I actually built long before I built flurry. And the use case is fairly different. So flurry is built as a fully concurrent map where you have concurrent reads and writes. EV map is specifically built for the case where you have many readers and you want as little overhead for readers as possible. It is an epic based map, sort of. I'll explain that in a second. And yes, this is the data structure that I described briefly in a talk I gave like a year and a half ago or something, maybe two years ago now on writing a concurrent database in rust, and I'll link that video when I post the video on demand as well.
00:08:51.560 - 00:09:40.298, Speaker A: Let's see, is it conceptually a set of key value pairs? No, it's conceptually, it's a map from a key to a bag of values. A bag differs from a set in that each value in the set can also have a sort of multiplicity, like a count. So you can have multiple elements that are the same in a bag. Will there be any performance improvements? I don't think this is going to improve performance. That seems unlikely. Hopefully it's going to keep the same performance. Does the EV and EV map stand for something? Yeah, it's for eventual.
00:09:40.298 - 00:10:44.392, Speaker A: So the idea here is that the map is eventually consistent in the sense that only when the writer chooses to synchronize with the readers are the results actually displayed to readers. And that will be pretty clear once I show you how it works behind the scenes. If value requires hash, then how can you have multiple of the same? Well, I mean, just because the value is hash doesn't mean that you disallow duplicates, right? This is just a way to efficiently store that bag of values so that you can efficiently remove something if you choose to. Okay, so let me explain how EV map works, and for that, we're going to have to do a little bit of drawing. Let's see here. So I think what we're going to do here is start out with a nice blue color, something like that. Alright, so the core idea in EV map is that we're going to keep two maps instead of keeping one map.
00:10:44.392 - 00:11:26.570, Speaker A: So we're going to have one map over here, and we're going to have a copy of the map over here. And if you imagine that all reads come from above and all rights come from below, then the, the basic structure we're going to have is that all the writes are going to go to one map and all the reads are going to go to the other map. As long as this is the case, there's no synchronization needed, right. The writer knows that it's the only writer that accesses this map, and so it can just do as many writes as it wants. The readers know that there's no one writing to their map, so they don't have to synchronize it all. They can just read directly from the map. Great.
00:11:26.570 - 00:12:15.240, Speaker A: So far so good. The challenge, of course, is what happens if the writer has made a bunch of writes and wants to expose those rights to the reader. Currently, the reader, or readers, will never see any of the modifications that the writer makes. So the way we're going to do this is that, um, this, this pointer up here with the readers, this pointer here is going to be an atomic, and the writer has a mechanism for atomically swapping that pointer to point over here instead. Great. So that part is pretty easy, right? The writer just does all the modifications it wants to this map and then swaps over to the readers to this side. And now the writer is going to move over to this side.
00:12:15.240 - 00:12:59.920, Speaker A: Okay, that seems fine so far. But now we run into two problems. The first of these problems is that there might be some readers who are still in the process of reading this map. So they read the, the atomic pointer before we did the swap, and so they're still stuck in the map on the left. This means that the writer can't start modifying the map on the left because there might still be readers in it. So the writer needs to have some mechanism for waiting for all the readers to depart, and I'll explain that in a second. The other thing is that the map on the left doesn't have all of the modifications that the writer has already made in the past to the map on the right.
00:12:59.920 - 00:13:59.244, Speaker A: The map on the left is the old value of the map from the previous time that the writer did the swap. So we're actually going to require that the writer keep an operational log, also often called just an oplog. And the oplog is going to log every change that the writer makes. So this might be something like insert key value, this might be remove key, this might be clear. Who knows? Right? So it's going to keep a log of all the operations that made. This also means that it needs to keep a copy of the key and value for each such operation. And then when it moves to the other map, then it's going to read out these values, this, this part of the oplog, and it's going to reapply it to this map first, and then it's going to start doing its other operations.
00:13:59.244 - 00:15:00.920, Speaker A: And those other operations then are also going to go to the oplog, right? So this is the way for the writer to make the, the stale map on the left become equal to the map is just less for the readers, so that at that point forward it can continue to just do normal operations. Does that make sense so far? I know there's a, there's like a lot of detail here, but let me pause here before I explain how the writer knows that the readers have moved on. As a reader, can we choose to read an eventually consistent mode and atomic mode? No. So the readers always go through whatever the current value of this pointer is. So there's no, there's no modes for the reader, it's just they read the pointer, whatever the current value is, they go to that map and they read from that map. That's all the reader has to do. And that will be whatever the writer has chosen to reveal.
00:15:00.920 - 00:15:35.038, Speaker A: And this swap, by the way, we call a refreshed. I believe if you refresh every write, then it's basically fully consistent. Yeah, that's right. If you call refresh after every write, then readers will always see the latest write. And so that is a way to use this data structure to provide fully consistent reads. For every insert into the map, you have to do two allocations, one in the actual map and one in the oplog. Not quite.
00:15:35.038 - 00:16:33.622, Speaker A: So the opera, the key and value is, is given to us by the caller, right? The caller does like an insert, and that gives us an owned value of the key and value in most cases at least, right? So we can just stick those in the oplog and then we do need to clone them. So we need to do one allocation for, for sticking it into the map proper. Now you might also observe that once we apply this oplog to the left side, what we end up with is every key and every value will be present in both maps, right? Because it has to be. The two maps are copies of each other. So there is this trait called shallow copy, that is, is a part of EV map. I wrote it as a part of EV map, and it basically just has, it has one unsafe method called shallow copy. And the idea of shallow copy is to copy a value without copying its allocation.
00:16:33.622 - 00:17:49.972, Speaker A: So for example, imagine that you have a box t, right? You can make another box t by taking the pointer out of this one and stuffing it into that one. Now this is clearly unsafe, right? Because now you have two owners for the same heap allocated value. But as long as you're careful about only dropping one of them and only dropping that one after the other one, has been has been forgotten, and that there are no pointers to it anymore. This turns out to be safe. So the idea is that if the value type here was box and this had a b one, and this has a b has another instance of b one, so they both point to the same people location, then the only thing we need to be really careful about reading both of these at the same time is fine, is that when b one is removed from the map, the first time it's removed we just forget it. The second time it's removed, we drop it, right? So these two are different, and we have to make sure that the second time we apply any given operation is when we actually drop, and the first time we don't actually drop. And this can be fairly tricky to get right, and you'll see some of that in the code later.
00:17:49.972 - 00:18:35.192, Speaker A: But it does mean that we don't have to duplicate all the allocations. Does keeping copies degrade performance? It shouldn't, because these still point to the same heap allocation while applying the updates from the stack. Are new updates blocked? Yes, they are. So there is only support for a single writer in EV map at a time you can't have multiple writers, and when the writer does a refresh, that refresh swaps the pointer, applies, wait for the readers to depart, and I'll explain that in a second. And applies the Oplog so refresh won't return until then. And refresh takes a mute self so no other operations can happen on the map. Although reads can still happen.
00:18:35.192 - 00:19:42.640, Speaker A: It's just that other writes can't happen. The writer never blocks reads in this game. Is there a point where the writer has too many ops in the log and just chooses to clone the map over? No, there it that might be a reasonable optimization at some point, but currently that hasn't really been something that's come up. No, especially all it depends on is how often you refresh, right? So the caller has control over how long the oplog is. If you refresh after every write, your oplog is only ever size one, and so it doesn't really matter. And so if the client thinks that the oplog is too long, they can just choose to refresh the uM. What could go wrong with letting readers that started before the write operation still read from the old structure? So the problem with the old readers, the readers in blue here, is that we can't, we can't start, or the writer can't start to modify the left map until all the readers have departed, because otherwise you have a read write data race, which is not okay.
00:19:42.640 - 00:20:41.130, Speaker A: Wouldn't an arc t also work? We could store, we could wrap every value and every key in an arc, but that would mean that we have to do an extra allocation for each operation, which is unnecessary, like we can just alias the box. In fact, shallow copy is also implemented for Arc, because it's trivial to shallow copy an arc. Is the oplog bounded? The oplog is bounded by when you call refreshed, but it's not bounded internally. Could this work with more than one writer? So the way you do this with more than one writer is you have them, you have a, so the read handle type is basically clone like, you can get many of them. The right handle type is not, and so you would stick the right handle type in a mutex. That way you can have multiple writers if you actually want a concurrent writers. I don't have a scheme that works for that, but it might be possible.
00:20:41.130 - 00:21:26.152, Speaker A: What's the condition? The writer chooses to do the refresh? The writer does a refresh whenever they decide to. So if they want strong consistency, they swap after, or they refresh after every write. Otherwise they just refresh sort of infrequently. Think of it as batching updates. They choose how often they want to batch or how long the batches should be. Could the oplog just store what keys are dirty and then update the old map from the new one? It could, but that also gets pretty bad, especially if you have something like a multivalue map where you might have a value set that has like a thousand elements in it. If you insert one element, you don't really want to copy a thousand elements in the map.
00:21:26.152 - 00:22:33.816, Speaker A: Like delete the old key, like the 999 keys, the 999 element value set for the key, and then copy over a thousand elements. You'd rather just do the insert. There might be cases where it's cheaper to just have the oplog just record read from the other map. It gets really complicated though, because the oplog, remember, if the oplog has many entries in them, you sort of need to do those operations in order, right? So imagine that there's an operation that's like an insert followed by a clear, right? You can't do the insert by reading from the other map, because the other map also has the clear operation applied, which if you did the clear op, which means that its value set is empty. So it's not quite that straightforward in theory. Maybe you could map like all these keys are dirty at the end of the oplog and then just copy those over. But then you potentially end up doing a lot more work than you technically need to do you really have a box there? If the pointer is not unique, yes, we're aliasing the box, so it's definitely unsafe code.
00:22:33.816 - 00:23:53.804, Speaker A: But it's okay as long as you only ever access it. Sort of read only, and you only drop it once and there's no use after free, let's see, doesn't have two box t to the same allocation break aliasing internally they have unique t. It's fine as long as you don't use them mutably, which we don't. What about iterators? Do all iterators have to be dropped before the old copy is considered without readers? So the winner read. And this is a good sort of transition to epics. When a read reads this atomic pointer and say it reads the old value like before the refresh, it now has a pointer into this map like it knows of the let's go back to the blue here. Right? So a reader that reads out this map and is now operating on this map, it is in that map until it no longer accesses that map.
00:23:53.804 - 00:24:28.940, Speaker A: Right. If it has an iterator and it walks that iterator, it's still holding up that that map. If the writer were to just like go ahead and do its rights, it would be concurrently modifying what the reader is currently reading, which is not okay. And so, and so this is, this would not be okay. And in fact, any operation that the reader continues to do on this map must hold up the writer. It's only when the reader eventually finishes this operation and returns and then reads the atomic pointer again. It's only at that point that we know that the writer can can keep going.
00:24:28.940 - 00:25:05.646, Speaker A: Is it worth trying to optimize the log by looking at clears and removes before executing the inserts? Maybe. I don't think it's worthwhile. I don't think that optimizing the oplog makes a difference here. Remember, this data structure is written for when you have a lot of reads. The oplog is free as far as that is concerned, because it's a write operation. It's true that maybe you could speed up writes a little, but it wouldn't affect reads. And we care only about reads in this case and in this stream.
00:25:05.646 - 00:25:46.480, Speaker A: I will not be focusing on the oplog. I mean, it's going to be a part of the implementation we're going to do, but we're not going to try to optimize the all plug. Are you planning on exposing shallow copy as its own crate? It doesn't look like it's currently available outside ev map. No, I don't want to expose shallow copy because it is a very dirty hack that requires extreme care to use correctly. So I don't think it's a good idea for other people to use it. Arc box would work. Yeah, I mean, you could use an arc to deduplicate these values as well, but it will require both an extra pointer indirection and an extra heap allocation for every key and value, which is just not worth it.
00:25:46.480 - 00:26:34.380, Speaker A: Okay, so now the question becomes, how does the writer know when there are no readers left in the map? And for that we're going to start a new drawing. So we're going to have, let's say here, reader one, reader two, reader three, three and reader four. And we're gonna have the writer down here. And what we're gonna do is every reader is gonna have an epoch counter. And this epic counter is not global. Like many epic counter schemes are global, this one is not. Every reader is gonna have an epic counter, which you can think of, it's really just a number, but I'm going to write it.
00:26:34.380 - 00:27:25.840, Speaker A: Okay, fine, we'll do it simply first. So like 7910, and this one is at 74. So these are just the local epoch counters for each, for each reader. And the writer is going to have a pointer to every epoch counter. So it has a way to get at every reader's epoch counter. So here's what the rule is going to be for how readers update their epic counter when a reader wants to do a read. So just before it reads the atomic pointer, it's going to increment its epoch counter.
00:27:25.840 - 00:28:23.506, Speaker A: Then it's going to do all the, it's going to read the atomic pointer, it's going to do all the operations it wants on whatever map it gets back, and then it's going to increment its epic counter again. So this means that a reader that is inactive or is outside the map is going to have an even epic counter number, right? Because it's a double increment, an increment on enter and an increment on exit. But crucially, these increments are local increments, right? They increment only their epoch counter. And that value is not normally shared. It's not shared with any other reader, and the writer will only be accessing it if it's trying to do a refresh. So this means that in general, if you think about it in terms of like cpu cache coherence, that epic countercache line is going to be an exclusive mode for the cpu that's running that reader. And this means that the, even though it is an atomic update of a number, it's a sort of cpu local atomic update.
00:28:23.506 - 00:29:40.946, Speaker A: In general, the cpu will already have the lock on that particular cache line, so it should be very fast. And then what the writer is going to do is the writer is going to, one swap pointer to read all epics, and then three, read all odd epochs again until they change. Okay, so this part is a little weird. So the writer's going to swap the pointer, right? And then it's going to read every epoch counter. And when it reads every epoch counter, it's either going to see that that value is even or it's going to see that that value is odd. If the value is even, that means that the reader, at the time when it did the, when the writer read the epoch, the reader was inactive. So that means that the reader cannot be in the old map.
00:29:40.946 - 00:30:07.434, Speaker A: If the reader was to immediately after do an operation, it would read the atomic pointer. But we've already done the swap, so it must be looking at the new map instead. So any epic counter that we see is even. We know that that reader is sort of safe. Like we know that it has, it is no longer in the old map. It might be idle, or it might be in the new map, but both of those are fine. Any epic counter that's odd might mean that that reader is still in the old map.
00:30:07.434 - 00:31:06.400, Speaker A: And so we need to continue to sort of recheck to detect when the reader has moved on. Well, when has the reader moved on? Whenever their epic counter increases, we know that they must have left the old map and it might increase by a lot. The readers might be really fast and might be faster than how often the writer rechecks his value. If the value is incremented by one, that's still enough, because it means that if it, if it was odd and it's incremental by one, that means it's now even, which means that it's now no longer accessing the old map and therefore it's safe for us to use it. So the algorithm here is actually fairly straightforward for when it's safe for the writer to continue. Does that roughly make sense so far? Does it do anything to handle starvation of writers? There's no lock here. The only, well, so the answer to your question is no.
00:31:06.400 - 00:32:02.510, Speaker A: If a reader just continues to hold on to the like, imagine a reader takes out an iterator to the old map, and then just like, walks that iterator really slowly, or just holds onto it but doesn't drop it, then, yes, that will hold up the writer indefinitely. But as long as readers are. As long as readers are doing things, the writer will get to go. Right? Because remember, the writers, the write and read here are completely independent, right. If a reader does a read and then there's another read, that second read might come from the new map, at which point the writer can continue. What if the counter rolls over? If the counter rolls over, that's something that EV map doesn't handle. But it's a U 64 counter, so it seems highly unlikely.
00:32:02.510 - 00:32:54.154, Speaker A: In theory, there might be a way to. In theory, I could make the. It might be safe for the readers to, like, reset when they hit even or something, but it's not quite that simple because the writer is waiting for a value that's higher. But yeah, it's a little unclear. You run into a potentially really bad case where the writer continuously see the reader as being odd, but the value starts going down and the writer gets very confused. So I don't think rollover is really a problem in the sense that rollover just doesn't really happen in U 64 SDE. Do you have any more use of the epic apart from signaling to the writer? If not, why don't we keep the values to zero and one? It can't be zero and one.
00:32:54.154 - 00:33:22.200, Speaker A: And the reason for this is, imagine that we swap the pointer. Then we read all the epics, and we find that some readers count is one, and then we read their epic again, and their counter is one. Then we read the epic again. Their counter is one. The reader might have moved on from the old map to the new map, but we can't tell because we only have the binary yes or no. The fact that the epics keep increasing means that we can. We can sort of figure out what round the reader is on.
00:33:22.200 - 00:34:15.632, Speaker A: And this is important because if they're on another iteration, like if they have read the pointer again since last time you checked, then it's safe for the writer to move forward. And you don't get that with zero and one, the counters are all atomics. Yeah, yeah. So there are a bunch of people asking, like, can't you just have this be a yes no flag and no, you can't. Or rather, if you did, the writer will end up waiting, potentially a very long time before they can move forward, because they might always see that the reader is in like a pending state, and then it doesn't know that it's safe to move forward because it can't distinguish between the reader has wasn't pending, went to idle, and went to pending again. It's the ABA problem. Like you don't know whether the reader has moved on or not, so you need to be pessimistic about it.
00:34:15.632 - 00:34:54.230, Speaker A: Whereas with the incrementing epics, then you always know whether or not the reader has moved on. Can we assume that the readers can be from different threads? Yep, the read handles are different threads. Can the writer check if the reader's counter is different instead of greater? Maybe. Maybe. Yeah, that might be a way to fix rollover, that the writer just waits for the epic to not be the same as it was. You might be right. That might be sufficient.
00:34:54.230 - 00:35:48.310, Speaker A: How can the readers write their epics and the writer read the epics without locks? So atomic counters let you do this instead of a counter, could you not have a unique id for each of the two maps for the readers to supply to the writer? Like the reader said, I'm on map zero. Um, you could do that, but the readers would need to. So the way you would have to do that is the readers would store like which pointer they're at, probably rather than zero and one because there's no left and right in, in memory. Right. But I guess they could probably store the pointer of their current map. I don't think it makes a difference. I think these are about the same.
00:35:48.310 - 00:36:11.590, Speaker A: Yeah, that could probably be, that could be fine. Yeah. Yeah. So I think it could be a pointer instead of a counter. One thing that's nice about this is. Yeah, no, I think you're right. I think it could be a pointer.
00:36:11.590 - 00:36:46.426, Speaker A: It feels like there'd be a race if you stored the map pointer, so you'd have to read it and then store it. I don't think that's a problem because as long as you use the pointer you read, I think it's fine. Oh yeah, no, you're right. You might read the. Okay, so this is the reason you can't use the pointer. That's a good observation. The proposed scheme is that every reader, instead of storing an epoch counter, stores the pointer of the map that they're accessing.
00:36:46.426 - 00:37:29.430, Speaker A: Imagine that the following scenario happens. A reader reads the atomic pointer, and then it needs to read it in order to write it into its sort of local storage. Right. But there's a gap in between those two operations. Like imagine the reader reads the pointer and then the writer squeezes in in between before it writes out the pointer of the map that it's using. And the writer sees the old value for the pointer and goes, oh, this one is on the map, that this one is already on the new map, so it's safe for me to proceed. And so the writer continues to do writes, assuming that the reader is on the old map, but then the reader stores the new map pointer in there, but it's too late because the writer has already moved on.
00:37:29.430 - 00:38:03.958, Speaker A: So this is the reason it can't be the pointer. Nice. Good catch. All right, so now that we have the scheme in mind, there's also an optimization that EV map makes, which is that it turns out you can be. So how do I explain this? I need a color green or whatever. Okay, so this step is super fast, right? This is just an atomic pointer swap. This one is also super fast because you're just reading all the epics.
00:38:03.958 - 00:39:10.240, Speaker A: This one, though, might take a really long time because it might be that there's some reader that's, like, really slow and hasn't moved on. And every time you call refresh, you sort of have to do all these three steps. And this last step, taking a long time, means that your fresh is going to take a long time. So it, it turns out that you can be a little bit smarter about this, and you can have that wait time overlap with when you can have that, that wait time overlap with the code between different refreshes. So the idea is to have refresh return here and then only apply writes at the beginning of the next refresh. So we're going to add a step zero, which is apply writes. And now this is going to be the first, this is, this whole thing is going to be the first step of the next call to refresh.
00:39:10.240 - 00:39:56.930, Speaker A: And what we're going to do is we're going to have, whenever you do an operation on a writer, it's not actually going to modify the right map, the one that we currently have a right handle to. Instead, it's only going to push to the oplog. So if you do an insert, it will not modify the map. It will just add to the oplog and nothing else. And this means that now it's actually safe for us to return from refresh right here, because we're not actually going to modify the map while we're waiting. Because in the interim, after coloring refresh, all the writes we do are just going to go to the oplog anyway. And then the next time refresh is called, then we're going to do this wait first.
00:39:56.930 - 00:40:38.940, Speaker A: And at that point, almost all the writers are, they're like almost guaranteed to have moved on because it might have been a really long time between the calls to refresh. So we're almost guaranteed that all the epic counters have, have either incremented or become, or become even. And so that means that now every call to refresh is actually fast, because the right, this sort of the minus oneth step, which is this one. Right. This one is likely to be fast because it's been a really long time since we read all the epics. This one is going to be pretty fast because it's just applying a bunch of rights to something that we're the only ones modifying. And then we swap the pointer, and then we read all the epics.
00:40:38.940 - 00:41:30.290, Speaker A: So we're just sort of offsetting the cycle a little bit so that we can overlap the weighting with the writer doing other operations that they do between calls to refresh. That optimization seem roughly right. So with that optimization, we can no longer read through the writer. That's correct. The writer, you cannot read from the write handle to see what the current state of the map is. You could. So, in theory, you could do this by doing a read from the map and then walking the oplog to figure out walk the oplog and, like, apply them to your return value.
00:41:30.290 - 00:41:53.620, Speaker A: But it gets pretty complicated. But it does make refreshes a lot faster. So it's definitely a trade off. But in general, the writer is unlikely to. At least in my experience, the writer is unlikely to really care about the reads. Think of it as all reads, regardless of whether they come from the read handle. The write handle go to the read map.
00:41:53.620 - 00:42:41.220, Speaker A: Does this mean that, on average, the oplog is twice the length as one refresh cycle? Yeah. So the oplog has to hold. This actually means that the oplog is a little bit more complicated. The oplog holds both values we haven't applied to the right map and values we haven't applied to the read map. So the oplog has sort of this, like, watermark in it. Of everything up to here, you've applied to the right map, but not the read map, and everything beyond this watermark, you've applied to neither map. All right, great.
00:42:41.220 - 00:43:52.350, Speaker A: So now that you have an understanding of how EV map fits together, I think it's time to look at some code, and I'll try to explain. Actually, what we're going to do is we're going to go back to this suggestion I had, which is currently, ev map is hard coded to deal with multivalue maps. Like, the oplog is like the values of the oplog are an enum called operation, and it has operations like insert, delete, empty, which is for removing all the values for a key set, which is to replace the value set rather than append to it, and a couple of other operations that are, that are less interesting. It's hard coded to like, have both things be a map. It's hard coded to the, the value, the values of the map are of type, like value set or value bag. And that's kind of sad, because if you, if you think back to this, this design, there's nothing about this design that's map specific, right? You can have an oplog over all sorts of structures. So you can have an oplog over a vector.
00:43:52.350 - 00:44:27.710, Speaker A: You could have an oplog overdose a hash set. You can have an oplog over a b tree map. You can have an oplog over whatever your own data structure is. And so the sort of the epic scheme and the choosing when to use which of the two collections, that part is entirely data structure agnostic. And so it's kind of sad for the sort of, at least in my opinion, coolness of the EV map sort of concurrency primitive. Being limited only to the one implementation that I wrote. I would much rather have this be sort of a wrapper concurrency primitive that you could then use for your own data structure.
00:44:27.710 - 00:45:22.768, Speaker A: So the question becomes, how can we do that? Well, the, that's basically the idea I had two weeks ago, and sort of, in hindsight this is very obvious, but early on there wasn't, I didn't have a good idea for how this might work. So the basic idea here is that we're going to have a new type that's going to be basically a concurrency primitive. Think like mutex, except it's, it has very different semantics. I'm calling it left right here for two reasons. One is because there's a left map and a right map, but the other is because there was, there was an announcement back in, like, I want to say like 2013 or something from someone who's like, we've invented a left right concurrency primitive. And the, the white paper they put out was, was very short. It was just like a brief description of, here's roughly what it does, and it looks a lot like EV map.
00:45:22.768 - 00:45:55.816, Speaker A: And this is before I built ev map. I didn't find out about this until a couple of years ago, like after I built ev map. And I think what they were going for was the same thing as EV map is. But, but I don't think they've ever published the actual algorithm. But sort of, in honor of them being first, I figured let's call it left right. And so the left right type is going to be generic over two types, t and o. T is going to be the type of the left and right things.
00:45:55.816 - 00:46:39.460, Speaker A: So this would be sort of the hashmap key and value bag. V for eV map for today, and O, which is going to be the oplog type. That's the enum that we're currently using in EVM app today. And then we're gonna have a trait, absorb, and absorb is gonna be generic over o, the Oplog type. And the idea is that it's gonna require that the t, the thing that we're sharing, implements that trait for the given o and the trait is apply first and apply second. Apply first is the first time you apply a thing from the oplog. So this is when you apply it to the right map, and apply second is the second time you apply a given thing from the oplog, which is when you apply it to the read map.
00:46:39.460 - 00:47:29.086, Speaker A: These need to be, these need to be different for a couple of reasons. The first one is that when you apply it the first time, you don't own the value in the oplog, because we need the value to remain in the oplog so that we can apply it again. And see, we can only pass an immutable reference to the Oplog element. We can't actually give you the element. So it might have to clone or something, or use something like shallow clone in order to stick it into the right map and then apply. Second, we can give in the o. And the other reason why these have to be separate is that if we're using something like shallow copy and you're doing something like erasing a value or a key, if that value was shallow copied, then the first time it's removed, we need to forget it instead of dropping it.
00:47:29.086 - 00:48:43.322, Speaker A: And the second time it's removed, we need to actually drop it. And so the implementation needs to be able to distinguish between these two cases. And if we had this kind of primitive, then EV map as it stands today, could just be expressed as left right, with a hash map of key in a hash and a value bag, and an operation where the operations are like a hash map operation of key value. And what's neat about this is that this, if we had this kind of structure, it'd be trivial to use left right to implement other kinds of collections in an efficient way. So for example, if you wanted a hash map that was just key value, you would just have a left right hash map key value and the operation type would be something that's operations over a single value map. Now there are some other aspects to this. Like it means that we can't have quite, we need like a layer of abstraction in EV map to make ergonomic access to the, to the underlying map nicer because with the left right handle, all it could really do is have like append operation and refresh because it doesn't know about things like inserts.
00:48:43.322 - 00:49:40.270, Speaker A: It can't because it's supposed to be generic. So the idea is that EV map would have to also provide like a wrapper type around right handle that has the hashmap specific implementations of these methods. Like it would have an actual insert method that just ends up calling append op on the inner right handle. All right, does that, does the, the plan here roughly make sense? Wouldn't you need a generic type constructor to make this work? Like, for the same reason there's currently no collection trait? I don't think so, because left right doesn't actually require that the, the thing you get is a collection. Like it doesn't require that. The thing is a map. All it requires is that it can apply things from the oplog.
00:49:40.270 - 00:50:04.790, Speaker A: So I don't think you need generic type constructors for this. Although like it could be that we start coding this and then we're like oh damn this. There's no way we can do this. But, but I don't think it should require that. And it's specifically because we don't. We're not trying to proxy any particular methods of t. All we're going to do is like a d ref into entity.
00:50:04.790 - 00:51:17.794, Speaker A: Like this is a wrapper type, not a generic trait. Could operations be closures rather than an enum? Maybe? I think that would be very hard to work with because you still need something like apply first, reply second. I guess you could have like the entries in the oplog are closures that you call on the map, and they're like past the value of whether this is the first or the second. It would make the type specification really awkward because you presumably want different closures for different kinds of operations, which would in turn mean that your oplog type would be like boxdin fn mute or something. I mean, it could work. I don't think it's nicer collection. Seems like the natural use case here might be handy to have a non collection type to keep in mind during implementation.
00:51:17.794 - 00:52:11.594, Speaker A: What might that type be? Yeah, again, I don't think this is specific to collections, but it is true that all the examples I have in mind are collections. All of what I've written so far is entirely collection or type independent. Right. So apply first and apply second is just you need to be able to, whatever type you have needs to be able to be modified by an operation that can be stored in an oplog which is not specific to collections. The only thing we're going to expose on right handle is append an operation to the oplog and the semantics of that operation. You get to define yourself refresh, which is just now exposed the changes, which is also not collection specific. And then the last thing we're going to do is really just implement draft for the read handle and the right handle into the inner type.
00:52:11.594 - 00:52:46.678, Speaker A: So I don't think any of this is written to be collection specific in terms of having a non collection type in mind. Hmm. It might be that. That's a good question. I can't immediately think of a non collection type you would use here. But then again, I've been wrong before. Yeah.
00:52:46.678 - 00:53:32.062, Speaker A: I can't immediately think of one. But, but looking at the API, at least, it doesn't, it doesn't feel like there's anything collection specific in it. Yeah, I mean, okay, so it's a good point from comments that like maybe a counter or a collection of counters, but like you could maybe have a counter. A counter is a really weird example because like why wouldn't you just use atomics instead? But, but okay, let's, let's take a counter as a sort of strawman example. Right? Apply first and apply second would just be applied. The, the modification to the number that you're storing. Right.
00:53:32.062 - 00:54:13.000, Speaker A: Handle would either refresh the count or append an operation that you're going to do to the count and you could deref into the count whenever you wanted to. So this would work for counter, which is not a collection. Well, strings are collections, right. A string is just a vector of characters, really. Yeah, like a very, very complicated way to do atomic counters. Okay, so let's start to actually look at the code here. So EV map is currently entirely geared around this idea of supporting maps.
00:54:13.000 - 00:55:44.450, Speaker A: And so I think what we're actually going to want to do here is create a new crate that holds this sort of generic version and then have ev map wrap that type. And cargo has a good feature for doing this already of sort of bundling things together, which is workspaces. So I think what we're actually going to do is we're going to create, we're going to turn ev map into a workspace that has that type and ev map where ev map depends on that type. So let me go ahead and start a new here and call it left right, and oh, now I need to remember how this works. So we're going to do, we're going to make dear left right, and actually we're going to not do that. We're going to cargo new lib left right, and then we're going to make dear ev map and we're going to get move cargo tommel and build rs and source and tests and benchmark into ev map. Oh, why do I have a build rs in here? Oh, that's from something else.
00:55:44.450 - 00:56:10.886, Speaker A: Let's just move that out for the time being. What else do we have? Why is it complaining? Right. All right, so we moved that. There's also ev map derive. So ev map derive is a way to derive shallow copies safely for types. I forget exactly how this is specified at the moment. I think it's currently just like a subdirectory.
00:56:10.886 - 00:56:50.996, Speaker A: So if you look at EV map cargo toml, I think it has a path dependency maybe. Oh, it's actually just a separate subdirectory. Okay, so this is going to be even nicer. So we're going to create a cargo toml workspace. I always forget what the specification for this is. Cargo manifest format and I specifically want workspaces. Yeah, so what we want is a virtual manifest.
00:56:50.996 - 00:57:29.690, Speaker A: We don't sort of have a primary crate really anymore because it's not clear whether left right would be the primary crate or EV map would be the primary crate. So I think we're just going to have them be separate and then we're going to say members. That was the thing I wanted to look up. Members are going to be ev mapental, ev map derive and left right. And let's just do a cargo check here to see if this actually builds. Yeah, a counter would be a good like minimal unit. Test is true.
00:57:29.690 - 00:58:20.724, Speaker A: Fail to get eV map as dependency of package eV map drive drive drive cargo toml. See if that now builds, that does not build. I really don't want to deal with EV map derive right now. It's just going to be, I'm just going to ignore it for now and fix that up later. EV map derive is like, it's not as important for us to fix this and it's certainly not important for the stream. Great, so ev map itself builds. I guess I should fix that.
00:58:20.724 - 00:58:58.806, Speaker A: Builder broken interdock links. So it's called now like so. Great. All right, so now we can start, I guess I can commit this now. I won't do that yet. All right, so now we can start sort of from something that's conceptually just an empty project and then start to add from here. And what we really want to do is we sort of want to start from what EV map has, right.
00:58:58.806 - 00:59:30.280, Speaker A: Because all of the, a lot of the types are going to be the same. A lot of the concurrency mechanism is going to be the same. So we're actually just going to copy everything from EV map source into here and then a lot of these things. We're really just going to be removing stuff so we can get rid of values. That's not going to be important. Ooh, I did a stupid deny. I should have moved that into source.
00:59:30.280 - 01:00:03.494, Speaker A: So we're going to move inner lib, shallow copy and write into source. And we're also going to move read into source. Great. Source lib. So ev map sort of root, root type or root file doesn't really do much. It mostly just forwards into types and various modules. So most of this is just going to be cleanup epics.
01:00:03.494 - 01:00:40.590, Speaker A: We're going to end up keeping predicate. It's not going to be used. Operation is no longer going to be used in here. We are going to have write handle and we're going to have read handle and read guard and maybe read handle factory. I'll explain these in a second. We're not going to have shallow copy and we're not going to have the sort of builder for a map because that's not actually important anymore. We are going to have this.
01:00:40.590 - 01:01:38.638, Speaker A: No, actually we're not even going to have that. I don't think we are going to have a new and new is going to do what that constructor used to do. And of course we're going to have to change the generics here to match, like having the taking the type and the operation. We're not going to require anything of v anymore because we're not even going to have a v. Okay, so there's one thing I haven't really talked about, which is meta. Meta is mostly uninteresting. The idea is that sometimes you want to communicate to the readers what version they're on, sort of.
01:01:38.638 - 01:02:28.946, Speaker A: So you can think of this as like a, an additional little bit of state that you want to include with every swap and meta is that information. So the idea is that rather than have the pointer be directly to the map, we're just going to have that. We're going to have the pointer be to a struct that we control and it holds the map but it also holds this extra little bit of meta information. Now, now that this is generic, I don't think we need meta anymore because the user can choose to have something that's like a map and some meta information. So I think maybe, I think maybe that can now go away. So we're going to get rid of meta. It's going to make things a lot nicer, right.
01:02:28.946 - 01:03:46.390, Speaker A: So new as we talked about before, is going to take a t and an o and it's going to return a read handle to. And what we're going to require is that t implements absorb odeenen and we are missing the trait absorb. So we're going to have to write that. And that has an absorb first which gets mute self and a mute o and an absorb second which gets the actual low. So new is going to create a new epics. Epics. Here you'll notice is the, it's a, an arc mutex slab of arc atomic u size, which is quite the mouthful, but basically it is, the writer has a, has access to a list of pointers to epic counters.
01:03:46.390 - 01:04:39.472, Speaker A: So this inner arch atomic us size, that is the epic counter for each individual readers. A slab you can think of as sort of like a, you can think of it as a vector, but where we can remove specific elements efficiently and we can index them with consistent keys, we won't be talking too much about slab. You can mostly ignore it. Think of it as a list and it's gonna be an arc mutex. And the reason that we have to arc Mutex this, even though generally it's only going to be the writer that accesses this, it's an arc mutex so that you can clone a read handle, right? So if you have a read handle and you want to construct another read handle from that read handle, basically you want to clone that read handle. The read handle needs to store its epic counter. It's going to allocate a new epic counter.
01:04:39.472 - 01:05:10.120, Speaker A: It has to store that somewhere where the writer can get access to it. And so it needs to be able to modify this and that might happen concurrently with a write. So that's why this has to be an arc mutex. I guess I should add slab to, I should actually add a bunch of these. But specifically slabdeen. It's the one we're going to want here. All right.
01:05:10.120 - 01:05:50.410, Speaker A: We don't need any of this capacity business. Inner is a type that inner is the thing that gets pointed to by the atomic pointer. So if we go to the inner file. A lot of this can be simplified too. You see that it holds data, which is basically a map. There's a feature in EV map that lets you choose what map implementation to use, but it basically just holds the map, it holds the meta and it holds this ready flag. The ready flag we might still need.
01:05:50.410 - 01:06:33.160, Speaker A: So the ready flag is there so that if you try to read after the. I forget what I'm using. Ready for even ready. Oh, it's, yeah. This is also something that the user can choose to implement. Ready is just used so that if a reader tries to read before the writer has had a chance to write anything, then it gets an error. But I don't think we care about that here.
01:06:33.160 - 01:07:04.690, Speaker A: Yeah, I don't think we care about that here. So in fact, the whole inner type just isn't needed anymore. So we can just do git rm, sor. Oh, I need to cd into left inner, just rm source inner. That's nice. That makes me happy. So inner goes away.
01:07:04.690 - 01:07:42.330, Speaker A: So really this is going to give us a read handle tache. And we're also going to require the t is clone and we're actually going to take in the original t, I think. So the idea is that we're going to take in some initial collection. We're going to clone it to get two halves of it. We might not require a clone. We could take a t one and a t two. So actually we might provide a second constructor here that takes them explicitly.
01:07:42.330 - 01:08:08.976, Speaker A: Right. So we can do this. Right, and then we can have a second constructor that's like new with clone, which takes a t that is, clone only takes one t and then just clones to get the two halves. You could even have one that doesn't take a t at all, but takes a t that implements default and just gives you an empty one. I increase the font size just a little bit. Yes I can. It's weird.
01:08:08.976 - 01:08:44.849, Speaker A: So my screen is 4k, so I'm showing you only a subset of my screen, and then it gets scaled to 1080. So it's hard for me to estimate what the actual font size you end up seeing is. I'd be worried about a t one t two constructor not being marked unsafe because there's no guarantee that the same. That's true. This does require that they are the same. All right, let's go with this then. I mean, even if you take clone, you're not guaranteed that they're the same.
01:08:44.849 - 01:10:02.840, Speaker A: They might have different hashing algorithms, for example. But what's neat. Is that it? That doesn't matter if you have like hashmap, for example, can be used with EV map and it's fine because the write operations, you do have the same effect regardless, unless you already use unsafe APIs like accessing things by hash value or something. Basically, EV map does require that the, or that this primitive does require that the operational log is deterministic over the tache. All right, so what are we going to do here? We're going to have t clone and tachyde, right? So we're going to give one clone of the t to the first read handle and one clone of the t to the first to the right handle. That might make a good doc comment. Yeah, you're right.
01:10:02.840 - 01:10:55.580, Speaker A: So here's what we're going to do. Note this is a note to self, like a note to developer document that operations must be deterministic. I think there already is a document to this effect in EV map itself, but I think it's like an internal comment or something. All right, so this alone just simplified this file a lot. I'm going to go ahead and remove all this documentation because it's map specific and I don't want it there. And I'm going to for the time being remove the warning from missing docs. Don't need this, don't need format, don't need build hasher.
01:10:55.580 - 01:11:32.550, Speaker A: Great. So this file is already a lot simpler. That makes me, makes me very happy. So now we have read and write and I think let's start with write because write is where most of the complexity comes from. So we're going to want to pull in the absorb trait, but that's probably all we need from super. There's no longer an inner we do need read handle, there's no longer a values, there's no longer any of this hash stuff. So manually drop here is kind of interesting.
01:11:32.550 - 01:12:15.246, Speaker A: The idea behind manually drop is that we'd like to err on the side of caution. Like remember how I said if we use something like shallow copy, you want to make sure that the first time you remove a value you forget it. The second time you drop it by wrapping the value in manually drop. What we end up with is that the standard case, if we don't do anything special is that they will both be forgotten, which is a memory leak, but it's not memory unsafe. So, so we do wrap them in manually drop. However, that I don't think that's going to come up here because we're not going to use shallow copy at all. That's a decision of the implementer of this data structure.
01:12:15.246 - 01:12:58.840, Speaker A: So I think manually drop can probably go away. The atomics we do need arc and mutex guard we probably need, don't know whether we need format, but we'll find out. Um, these docs can go away. Right. Handle now is going to take t and o. And again we're, and we don't even need to specify the, the bounds here because we might as well do those just on the refresh operation because that's the only one where we actually care that t can absorb o. So this is a pattern you'll see sometimes in rust wherever um, some people put the trait bounds for a type on the type itself and then on every impl block.
01:12:58.840 - 01:13:35.126, Speaker A: The idea being that you can't use this type if you don't satisfy these bounds, so we're not even going to let you construct them. Whereas if you look at the standard library, for example, it's much more common for the bounds to be on particular methods. So you'll be able to construct a right handle that has, say, where t doesn't implement absorbo, you just won't be able to do anything with it. And there are a couple of reasons for that. One is historical, where. So there's a feature called implied bounds. I don't know whether it's landed yet.
01:13:35.126 - 01:14:29.408, Speaker A: I don't think so. So implied bounds is that if you have where bounds on a type, then every impulse block for that type will automatically have those bounds included. So you don't need to write them out. But without that feature, if you had like, like you saw here, right, a long list of where conditions for this type, you have to repeat that list of where clauses for every impl block, even though not necessarily every impl block relies on all these properties. But you sort of made the statement that like this whole type doesn't make sense without all these bounds, and now every input block needs to repeat them. And so by not putting the bounds on the struct and instead only putting bounce on the individual methods, you sort of avoid this problem having to repeat yourself. The other reason why you might want it on the type is, is sort of related, which is imagine that someone else wrote a struct that contains a right handle.
01:14:29.408 - 01:15:29.742, Speaker A: If I have these bounds be on my right handle, I'm requiring them to put the same bounds on their wrapper struct because they can't have, they can't name a right handle without ensuring that these properties are held. If I don't include them here, and only have them on the input block, they will not have to include it on their struct and therefore everywhere in their code base. So in general, I think error on the side of having them on the methods instead. The reason this didn't is, I think because index map at least, which is one of the EV map backends and hash bag both required, both had these bounds on the struct and that's why we had to repeat them here. Accessing entries by hash is not unsafe though. Oh yeah, you're right. The like raw entry API, I guess, is not unsafe because as long as you guarantee that the hash you get as you.
01:15:29.742 - 01:16:23.996, Speaker A: Yeah, because the hashes are stored internally in the handles, you get back. Yeah. So I guess really it's unclear where this unsafety should be. It could be that the methods on absorb should be unsafe. To be honest, I'm not quite sure yet. We can look at that in a second. All right, so the right handle is going to hold a box of t, an oplog, which is going to be a Vec swap index, which is, remember how I mentioned that the Oplog has this watermark for everything before or everything on one side are the things that haven't been applied to the right handle or the read handle, and everything on the other side are things that have been applied to the right handle, but not to the read handle.
01:16:23.996 - 01:17:07.376, Speaker A: The swap index is that watermark. The writer has a read handle, and the reason it needs to have a read handle is so that it has a way to get a pointer to what the read map currently is. So this, this is the write map and it gets the read map through here. And this is also what it uses to allow you to read through the write handle. So this is going to hold the t and o. Last epics is, remember how we read all the epics at the end of refresh and then we're going to read again at the start of refresh and compare them. Last epics is what we read at the end of the last refresh meta.
01:17:07.376 - 01:17:38.710, Speaker A: We don't need anymore. First and second are kind of weird. First and second are optimizations. Wherever the first time you do a refresh, you don't really need to use the oplog. The first time you do a refresh, you can just clone the whole map. But that does rely on the type being cloned. So it depends on whether we want to require the t is clone everywhere here, whether we only want to require it in the constructor.
01:17:38.710 - 01:18:19.254, Speaker A: I think we're probably going to get rid of first and second. I don't think they're optimizations that we want to generalize. And you'll see there's a field here called refreshes, which is only enabled during testing. And this is so that we can test how many refreshes happened. Like when we're writing a test, we can ensure that it did the number of refreshes we expect. Yeah, it could be the absorb should be an unsafe trait. Epics are U 64, but their u size.
01:18:19.254 - 01:18:57.010, Speaker A: Yeah, we should probably fix that straight away. This should be an atomic U 64. All right, so we're going to implement debug for to where t. It's so nice to get rid of all these bounds. And I think the oplog also needs to implement debug. Right handle, oplog, swap, index our handle. There's no meta and there's no first and second anymore.
01:18:57.010 - 01:19:44.870, Speaker A: Great. Creating a new right handle now is also pretty straightforward. The write handle is really just going to be a t takes an epics, takes a read handle to and gives you a write handle to. We're not actually going to require anything of new here. Don't need the meta. We have to box the t because we're going to use it in like an atomic. So we need to have a pointer to it, which means that it doesn't need to be heap allocated, but the alternative would be that we need to like take something that can be used as a pointer and it's easier to just box it internally.
01:19:44.870 - 01:20:30.500, Speaker A: And notice that this boxing only happens once. Implement drop. What is it? Implement drop. I forget here we probably require the t implements absorb. I'll show that in a second why that is. So when we drop a right handle, we want to remember how we don't necessarily know whether it's safe to drop or forget a value. And so when we drop a right handle, we really want to like walk through the oplog and then do the refreshes so that we can reuse the logic from there to figure out which things are safe to drop and which things we should forget.
01:20:30.500 - 01:21:28.362, Speaker A: And so that's basically what's going on here. This code, I think can stay exactly the same as it currently is. This, there's no data anymore in w handle, I don't think. Yep, that can just be a pointer to inside the w handle. So this is going to be as dref mute unwrap. So this now is a pointer to the thing that the box holds, recalling when to add bounds directly to a struct. Does it make sense to add them if they're needed in drop.
01:21:28.362 - 01:22:06.790, Speaker A: I think the compiler actually requires that. That's a good point. So I think it's actually going to require that we add this bound here because otherwise we're not allowed to use it in drop. It's a good catch. It's a little sad, but you know. Oh, clear is gonna be interesting. Hmm.
01:22:06.790 - 01:23:04.804, Speaker A: Not quite sure what to do about this one yet. So the, the trick we're pulling here is that in drop we make sure that the two maps are identical and then we want to basically erase everything from the first handle before we drop the second. But if we. That's not gonna be nice. Actually, I think we do. Actually we are gonna want where is manually drop again, I thought it was sync, but maybe I'm wrong use where is my. Oh, mem? Of course it's a mem.
01:23:04.804 - 01:24:03.850, Speaker A: What am I thinking? We're going to want this, I think, to be manually drop. And the reason for that is if there's like a panic or something and the right handle gets dropped, it's not safe to drop what's in the right handle. Or I guess actually, yeah, because there might still be readers in it. But this one I'm not entirely sure how we're gonna do. Like, we need some way to inspect, instruct the, the t to like remove all the elements, but don't drop them. This might have to be like a, like we're going to require that the operations implement like a clear operation or something. I have to look at that in a second.
01:24:03.850 - 01:25:11.658, Speaker A: This one cast that's back into a tache r handle as inner. So where do we get the r handle from? Yeah, that's fine. Yeah. Presumably instead of boxing, you can use some unsafe around pointers inside the right handle and the inner part of the read handle. But I think the boxing is way less painful and so it's not an optimization to consider unless those allocations ever showed up as pain. Yeah, the other reason I want to do it with box is because it might be a stack value and then you need to box it. Like you can't have them share a pointer to a stack value.
01:25:11.658 - 01:26:02.756, Speaker A: It wouldn't be safe because the pointer has to be stable over time for this to work. Let's see. So to right handle, this is now going to require absorb o on every impulse block. So right handle holds a unique pointer to the right collection and right handle is unique. Yes, right handle. Well, it's not a unique pointer because there might still be readers in it. It will be unique by the time we use it as mutable, but right handle is unique.
01:26:02.756 - 01:26:33.220, Speaker A: Yes. Okay, so wait is a sort of helper function in right handle. And what wait does is basically, it does the waiting. This is specifically the step where you've read the epics before, and now you're waiting for all the epics to have iterated over. I guess this now has to be U 64. Yeah. And this is just code to, like, read all the epics.
01:26:33.220 - 01:27:10.990, Speaker A: I lied a little bit when I talked about even an odd. In practice, it actually uses the hibit. I forget why it uses the hibit. There might nothing be a good reason. And then it tries to figure out, like, if the, if a counter has, if an epic hasn't moved since last time we looked at it, what do we do? Well, we can just retry, like, imagine that there are like three readers or something that still haven't changed. We can just optimistically retry a couple of times because reads in general are pretty fast. But if it takes longer than that, we might actually want to yield the thread to give the readers a chance to run.
01:27:10.990 - 01:27:55.490, Speaker A: And so, notice that wait didn't have to change at all. There's nothing map specific in weight. And similarly, for refresh, remove the docs, because it's too high of a risk that there's something in there about maps, so they should be rewritten anyway. Yeah, so it calls. So this is where you'll notice that when you call refresh, it first waits. This is the sort of moving the thing up to the, to the top. And this is going to be sdref mute.
01:27:55.490 - 01:28:49.120, Speaker A: We're not going to have the second optimization. Why is there, why do we have the r hasher? That's interesting. I don't think we care about the hasher. Oh, I remember. So there's a, the hasher here is actually kind of interesting. We need to make sure that when we apply operations, we use the hasher of the map that we're modifying, not the hasher of the other map. And this gets a little complicated at times to keep track of, but I don't think it'll matter here.
01:28:49.120 - 01:29:48.960, Speaker A: This is making sure that we apply the, the correct portion of the oplog. Mm hmm. Apply a second op. We're not going to pass in the hasher. Oh, I see what's going on here. This might actually be a little hard to abstract away. So when pretty sure this is wrong, why is it using the same hasher for all the operations? That doesn't seem right.
01:29:48.960 - 01:31:08.860, Speaker A: I think something's wrong here, but, yeah. So the thought I had was that the t, when it is told to apply the operation second or first, doesn't really know whether it's applying it to the left or the right map, although it should use the hasher from the appropriate map. So why is this a problem? It's a problem because why is it a problem? I think you need to use the same hasher, otherwise operations don't end up being a deterrent. Deterministic, but I forget why. I'm going to remove this for now and then we're going to come back to that later, I think. Could you give each of apply first and apply second a reference t of the other collection so we can extract hashers if it needs to? Yeah, that might be the way to go about this. Sorry, you said I read it as a us size.
01:31:08.860 - 01:32:09.200, Speaker A: Oh yeah, you're right. Which probably also means that last epics should be a vec force. Yeah. Where were we? Yeah, I think it would be nice to provide a handle to the other thing too. I wonder why this is do drop. I forget what do drop even does. It has been a while since I looked at some of this code.
01:32:09.200 - 01:33:13.460, Speaker A: Oh, I remember what this does. Oh, that's so sneaky. Okay, so this is a modification I made a while back, which was instead of trying to remember, oh, my hair is crazy. Instead of trying to remember whether or not it's safe to drop values, I just, because manually drop is represented in memory the same way the inner type is, I just cast between the two. So if you're supposed to drop things, I cast to the thing, the, the version of the type that doesn't have manually drop for the values. And if you're applying first, then I don't cast to that type. Now that cast can actually happen inside the implementation of apply second and apply first.
01:33:13.460 - 01:33:58.360, Speaker A: So let me see. Do I even call apply second anywhere else? Yeah, I didn't think so. Okay, so I think this trick is something that can be performed inside the implementer. So that is just going to go back to bw handle. But I do think you're right that we probably want to pass in the handle to the other thing. So let me pull that back here. So this, instead of being our hasher is going to be our handle handle.
01:33:58.360 - 01:35:03.720, Speaker A: And this instead of being hasher is going to be, I guess just inner probably. Yeah, it's going to be inner dot load. Do I really not use ordering in this type? Oh, atomic. Fine. Yeah. Notice the comment here that because here we're reading out of the read handle, we are now a reader. So we can't swap while holding this because it would invalidate this handle.
01:35:03.720 - 01:35:37.970, Speaker A: Well, technically it wouldn't because we wouldn't drop it. But to be on the safe side, we don't want to swap while holding this reference and we won't. I'll show you in a second. So this is also going to pass in the r handle. And this is also going to pass in the r handle. So let me go back to, I guess, Lib. So that means that absorb is also going to be given other.
01:35:37.970 - 01:36:06.528, Speaker A: This is going to be a reference to t. No reference to self, actually. Now this is going to look a little weird because it looks like we're never applying anything to our handle. And that's true, we don't. But remember that. So like, imagine this being map zero. So this is also map zero.
01:36:06.528 - 01:36:42.650, Speaker A: The next time around we're going to call on this subset of the oplog. This is going to be map one. So we're going to apply it to map one on the the next iteration around w handle and our handle will be swapped. Do you want to always use the same hasher so the iteration order will be deterministic? I don't think that's why I did it. I'm trying to actually, there might be a pr. Let me check here what we got here. I'm pretty sure there was a pr that, that did this change.
01:36:42.650 - 01:37:48.180, Speaker A: Maybe I just push let's do hashere and see what we get here. Commits. No, it's a very good question. I don't actually know why. I don't know why that's there, actually. I suppose we can look at, we can look at EV map, right? Apply. So this is given the hasher.
01:37:48.180 - 01:38:34.600, Speaker A: Why is it given the hasher? Yeah, it just passes in the hasher everywhere. You know, I honestly have no idea. I guess let's go back and blame you. A little tour of git here while we're at it. So let's go ahead and look at source, right? Blame. Let's go ahead here and look at. Ooh, that's not at all what I wanted to do.
01:38:34.600 - 01:39:22.510, Speaker A: Let's undo that r hasher. Wow, what an innocuous commit name. Stress test duplicates plus fixed. I mean, I'm guessing some test failed, but don't know why. Yeah, this is certainly where I introduced that change. The drain must have been determined, must have a deterministic iteration order. Well, I guess here's the comment.
01:39:22.510 - 01:40:22.770, Speaker A: Let me just go to that one. Where's the file? This file? Oh, that's real subtle. All right, let me find that actual comment here. Okay, so this is actually in the values. So this is in the hash bag of values in ev map when it uses maps, because otherwise. Okay, I'll, I'll let you read this because it actually explains what the problem is. Basically, if the iteration order is not consistent, you might end up with swap remove, for example, being applied to two different sides of the map.
01:40:22.770 - 01:41:44.780, Speaker A: You might end up with swap removes being applied in different orders by the different sides of the map, which means that they end up dropping and forgetting different elements from one another, and you end up double dropping as opposed to forgetting and dropping. I'll leave this up for a second so you can read it while I catch up with chat. This is very specific to the value sets, so it's a good question whether we actually, whether this, this is something we have to preserve. Now that said, this change just always gave the hasher of the thing on the right. So. So in theory, if we just give a reference to whatever is currently, well, it's not the thing on the right, but the read handle. So in theory, if we just always give in a pointer to the read handle, that should have the same effect.
01:41:44.780 - 01:42:46.020, Speaker A: Just trying to see here whether I see it makes sure to use the same Hasher in all of the like nested hash bags and stuff. I think that's actually the primary. That's really what makes a difference here. It's just making sure that everything is using the same hasher. That's what's going on. So it's not that it's actually using the hasher each time, it's that if it happens to create a new like bag, hash bag for the values, it makes sure to use the same hasher as it uses for the map as a whole. And as long as all of the hashers in the system are sort of the same, this ends up not being a problem.
01:42:46.020 - 01:43:52.208, Speaker A: I see. So in that case, giving a reference to either left or right should be fine, because they, they always end up yielding the, they all end up using the same hasher. Alright, sorry, that was me trying to work through what was going on while trying to explain it. So let me take one step back and try to actually explain what went wrong. Okay, so remember, we need to make sure that every operation from the oplog is applied deterministically. This means that if you have, if you have the values, be for example, a hashmap or something, or a hash bag, in this case, the iteration order of that bag also has to be deterministic. That is, it has to be the same whether you're doing it to the hashbag when it's in the left or the hashtag when it's in the right.
01:43:52.208 - 01:44:45.480, Speaker A: For some given key, if they use different hashers, it won't be as. We need to make sure that anything in the valley, anything in the, anything in the type that we're creating the left right over, has to be deterministic, which means that if it uses a hasher, it has to use the same hasher. But in order to do that, we need to pass the hasher around so that if we ever, say, create a new hash bag because someone inserts a key for the first time, we need to create a hash bag. We need to make sure that we create it with the same hasher as it's used everywhere else. And so that's why this hash was being passed everywhere. Now, because the hasher is the same in the left and the right map, because they're clones of each other to begin with. Because that's the case, it's.
01:44:45.480 - 01:45:42.740, Speaker A: Well, yeah, because the initial two maps are clones of each other, their hashes are initially the same. So it doesn't matter which one we give a reference to to get to the hasher, because their hashers are the same. So if you clone the hasher, you'll get the same hash regardless of whether you took it from left or right. So ultimately, all that matters here is that it needs this, this shared reference in order to ensure that any determinist, any non determinist, any source of non determinism, like the hasher of the hashmap, is actually cloned throughout the system. So they also use the same source of non determinism that is the same hasher. And so giving a reference to the, the t on the other side, as opposed to specifically the hasher, should be sufficient. Great.
01:45:42.740 - 01:46:25.520, Speaker A: So our handle here should be enough. There's a bunch of reference to maps in the comments as something we can clean up later, I think. Mm hmm. We don't have meta information anymore. What I'm imagining is that modifications to the meta can be part of the oplog, and that way it's up to the implementation to make sure that it keeps that as an internal field somewhere. Notice also that there's this scope here. That's what causes the r handle to go out of scope, so that we make sure that at the time when we swap, we no longer have that reference in there.
01:46:25.520 - 01:47:03.266, Speaker A: Do you even need the r handle? If you pass the w handle anyway, probably not. The implementation could probably just use the hasher from the w handle instead. At the same time, I don't think there's really a downside to passing in the r handle here. It keeps the traits simpler. But I'm just like, I'm just paranoid that in the future someone will be like, oh, but I need access to the other one, to something, something. So I feel like we, given that we can trivially get at it, we might as well just provide it, is my thinking. Yeah.
01:47:03.266 - 01:47:45.756, Speaker A: So the comment here, right at this point we have exclusive access to the w handle and it's up to date with all rights. The stale r handle is accessed by readers through an r clone of the atomic pointer inside read handle. And Oplog contains all the changes that are in w handle but not in our handle. And so now we can do the swap. So this is just actually doing the swap, it after. So it does the swap here, that's the atomic pointer swap. Then it has a fence to make sure for memory ordering reasons, we want to make sure that we read the epoch counters strictly after we did the swap.
01:47:45.756 - 01:48:40.460, Speaker A: Otherwise the CPU is allowed to reorder these instructions and that's not okay. So this is the step where we read the epics at the end of refresh, right? As I talked about in the beginning, yeah. And as the note says, at this point there's likely still readers using the w handle because they haven't left yet. And second and first are optimizations we no longer care about. So flush is an operation that's conditional refresh, so it only does a refresh if there are things to refresh. Set metadata goes away, but add op is going to be appendop, that's going to be an o. And we don't have this first optimization anymore.
01:48:40.460 - 01:49:28.074, Speaker A: So we're just going to do this. That's all appendop is going to be. And all these methods that are specific to maps are now going to go away. We do have to figure out what to do about clear. I don't quite know what to do about clear yet, which we, I think we need for drop, fit, fit, all, reserve, empty, random, apply first. So apply first and apply second are methods that are going to be on the t itself. So if we go back up here, this is not going to be self apply second.
01:49:28.074 - 01:50:32.814, Speaker A: There's actually going to be w handle dot apply second, and w handle dot apply first, which means that the actual methods down here, and I guess we can go back and add these to the documentation over there. All of this like what you do for each operation. That's all going to end up in, in the actual implementation of absorb for map, that EV map is going to end up using. Same with extend. There's no reason for us to implement extend here because extend is a map specific thing. We do probably want to implement draf for right handle so that you can easily access whatever the inner type is through the right handle. Here we only need to implement.
01:50:32.814 - 01:51:13.412, Speaker A: This is where it's like, it's kind of silly for us to have this requirement, it just for draft, given that it's not a requirement. It's not actually a requirement, but we need it because it's on the struct. And it's on the struct because we need it for drop. There we go. And these tests I guess we'll port over later. Seems like the requirements for implementing absorb are going to be very subtle. Yeah, I think absorb is a very subtle trait.
01:51:13.412 - 01:51:46.570, Speaker A: And it could really be that. It could really be that this needs to be an unsafe trait. I think you're right. Which is like this is already in an unsafe block, I'm pretty sure. Yeah. Could you elaborate a bit more on what the problem with clear is? Yeah, so let me go back here up to drop a. Okay, so in drop we're first going to do is synchronize the two maps so that they have the exact same contents.
01:51:46.570 - 01:52:16.470, Speaker A: And then what we want to do is we want to drop both maps. But we don't really have a good way of dropping both maps because in the first map we want to forget all the values. In the second map we want to drop all the values. But we don't have a way to say forget all the values. Right. If we drop it, they get freed. We could just forget the whole t.
01:52:16.470 - 01:52:56.770, Speaker A: But that doesn't seem right. We actually do need to drop the t because there might be allocations in there, like the allocation of the buckets for the hash map, for example. So we can't just forget the whole t. We need to sort of clear the t. We need to make the that make one of the two t's be emptied by forgetting, but still dropping things that need to be dropped. And the other t is the one we're actually okay with just dropping. But that means that there has to be an operation that's like clear this while taking into account the fact that you're while taking into account the fact that you are actually not allowed to drop.
01:52:56.770 - 01:54:16.126, Speaker A: So I think maybe what we want here is for this to be a method on absorb. So this has to be like maybe it should actually just be forget. So this is maybe drop forget or drop first, actually. So this is drop self, but do not d allocate any shared values. Do not, I guess drop any shared values. So this will be drop first. Did that make sense? I'm sure there's still errors in this file, but I don't immediately see them.
01:54:16.126 - 01:54:46.090, Speaker A: So let's switch over now to read handle. So for read we have a bunch of actually, let me show you here. Source we can remove shallow copy. We're not going to need that here and read. Let's also go ahead and move read mod rs to just be source, read rs because that's nicer to work with. Oops. That's not at all what I wanted to do.
01:54:46.090 - 01:55:22.906, Speaker A: Ev map source read mod to source read rs. So there's read rs and then there's also a sort of subdirectory for read and that includes some, some handy helper methods. So a read handle, you can't just deref into the tache because it needs to also make sure to update the update. The epic counters appropriately. So this is why I have a read guard type. This is similar to Mutex. So the idea is that when you have a read handle, you can sort of take the guard.
01:55:22.906 - 01:56:19.950, Speaker A: You think of it as calling lock, except you're not actually locking anything that gives you back a guard. The guard dereferences into the t, and then when you drop the guard, it increments the epic again. So that's guard and factory is you might want to be able to clone new read handles without actually storing a read handle. This might be because the read handle, for example, is not sync. We'll look at that in a second why that is. But I imagine that you, you want to store like a lacy static or like a, just like a completely shared arc that people can grab new read handles from. You don't want that thing to be a read handle because it would, it would have, it would require that the read handle type itself was like send and sync and all that stuff, which it is not.
01:56:19.950 - 01:57:17.628, Speaker A: So that's why we have the read the read handle factory type, which is a sort of a stripped down version of read handle that only allows you to create read handles. It doesn't actually have its own epoch. And read ref is kind of uninteresting now that we're not dealing with maps. So I can get rid of that. Actually, let's look at redref first. Why is that there, I wonder yeah, so this just implements like map methods around guard. I don't know why these are not implemented directly on guard.
01:57:17.628 - 01:57:40.270, Speaker A: I forget. I think it's because of the iterator trait actually. So. But we don't need those anymore here. That's a type that would be provided by the implementer of absorb so we can get rid of readref. We do need to look at read rs. Let's start with that one.
01:57:40.270 - 01:58:15.490, Speaker A: There's no longer an inner and there's no longer a values. We no longer have random state or hashers. There is no longer a redref. This documentation goes away. Read handle now just also takes t and an o, but it does not actually know, need to know about absorb at all. In fact, it doesn't even need to know about o, I don't think. Yeah, I don't think read has to know about.
01:58:15.490 - 01:58:55.890, Speaker A: Oh, that's kind of neat. Ah, read handle, right. Because the read handle never sees the oplog. Nice. It just has an atomic pointer to a tache t, right? Just like the right side has a handle to a t and the read side has a sort of atomic pointer to a t. It has epics. It has a, it has sort of a shared epic counter for itself.
01:58:55.890 - 02:00:01.440, Speaker A: So it's shared between. The reason it's an arc, right, is it's shared between itself and the right handle. Epic eyes is like a local cache of the epic, I think, and my epic, I forget why exists, but I guess we'll find out later, right? Okay, so this part is a little weird. So read handle takes a read handle takes an immutable reference to self in order to do, in order like it has to implement draft, right? And D ref. Well actually it doesn't have to implement draf, but the call to get a guard take currently just takes an immutable reference to self, to the read handle. But under the hood it's not really an immutable reference because it needs to update the epic guard. So it should sort of be a mutable reference to self.
02:00:01.440 - 02:00:41.160, Speaker A: It just feels weird for read hand, like a read operation to require mute self. But I think there's actually something we want to change that's sort of an oddity of how it currently works. So I think we're going to tidy this up a little bit. This is so, okay, this is kind of funky. The reason that it I've implemented not sync this way is because at least it used to be that. And this might still be the case that there's a, you need to like use a nightly feature in order to specifically implement not sync. So instead I just inserted a type that is not sync.
02:00:41.160 - 02:01:28.140, Speaker A: This might actually, making this change might mean that we don't know that we no longer need the read factory. So we're going to switch this around a little. This is in fact a you size. This is the index into epics that belongs to us. So the index in epics that is equal to this and then my epoch is sort of a cache of what our epic was that wasn't atomic because we wanted to be able to take an immutable reference to selfdevelop. If we're going to change that now, that can change, which is nice. This now just takes t doesn't have to take any bounds.
02:01:28.140 - 02:02:47.410, Speaker A: So the reason we need to implement drop for read handle is because we have to make sure that parity must be restored is not quite right here, but we want to remove our own, well, we want to remove our own epic counter from the sort of master epic counter list. And we need to do that so that, so that we don't have the writer just continuously look at all these epics that are just no longer relevant. Oh, I think what I mean here is that epic must already be even for us to have at mute self. So okay to lock since we're not holding up the epic anyway. Yes, the drop here is just removing ourselves from the global list. We can implement debuggest. It's so nice to get rid of all these bounds, although we do, and we don't have any bounce actually for debug for read handle, because it's really just printing out integers.
02:02:47.410 - 02:03:50.280, Speaker A: Because remember the read handle, unless, until you sort of lock it, like unless you, until you increment your epic, you can't actually read through the read handle. You must implement the epic first. So if you wanted to just debug a read handle, all you can do is print out information about the epics cloning a read handle is really just creating a new read handle. So this should be fine. And the fact that you can clone a read handle now and the read handle is sync means we no longer need the factory. So let me go ahead and remove the factory entirely, source read factory, because now you can just stick the read handle in an arc if you wanted to clone it. It does mean that there's technically an additional epoch for the writer to use, but it's unlikely that you had many factories anyway.
02:03:50.280 - 02:05:07.320, Speaker A: All right. Creating a new read handle really just requires that you give me a t and an epics and it again just boxes. The t stores the pointer and an atomic pointer that is. That is reference counted so that it can be shared among all the readers. And the distinction between the outer function and the inner function here is nothing clear. It's a good one, really. I feel like it would be nicer to just have this be pubcrate new probably right? Isn't that just better? That's definitely better.
02:05:07.320 - 02:05:34.350, Speaker A: Let's do that instead. Much nicer. We don't need this extra freestanding new function. That seems silly. Great. We no longer have this thing and my epoch is going to start out at zero. I forget why it caches my epic.
02:05:34.350 - 02:06:24.360, Speaker A: I guess we'll find out soon. Factory goes away. I love just getting rid of all this stuff that used to be there. We no longer have any requirements on t. Okay, so handle here is the one that used to be used to take just a reference itself that's now going to take mute. Self hasher is going to go away, right? These are going to go away. These are just like convenience methods for take the lock and then call this method on map.
02:06:24.360 - 02:06:48.620, Speaker A: Those can all go away now. Nice. Makes me very happy. Very very happy. Very very very happy. Is destroyed. So destroy is if the right handle goes away, then it takes both maps with it.
02:06:48.620 - 02:07:05.350, Speaker A: So reads need to start returning like none. And that's what is destroyed. Does contains key is a map method. Contains value is a map method. Map into is a map method. Nice. And all the tests can go away for now.
02:07:05.350 - 02:07:37.500, Speaker A: We don't really need read to be different from handle. I don't know what the best name for this method is of the t. T can have been refresh or t has been destroyed. This function returns none. Maybe read is the right method. Right. This is sort of like lock, except it's not really lock.
02:07:37.500 - 02:08:21.370, Speaker A: So this is going to be a read guard of the lifetime. Here is the type lifetime of self. Right? So here's what we're going to do. We're actually just going to steal this whole implementation. We don't need this to be multiple methods anymore. So we're going to go here and steal that over here. Does that new change you made just break the clone impel? Oh, it probably did.
02:08:21.370 - 02:08:52.492, Speaker A: Oh, that's why. That's real dumb. I guess that's why I was there. New with arcanous, which takes a arc atomic pointer of t. Fine, fine, fine. I still think it's better for it to be on here. So we're gonna it is a change.
02:08:52.492 - 02:09:46.120, Speaker A: But that's gonna call self new with arcanous. Inner and this is not going to be public. And then clone has to call new with arc. Great. I think read is a decent name for this. It is a little weird to have a read handle that you call read on in order to get a read guard that you can read from. Like there's a lot of read, but I really don't want to call it lock because it makes it sound like you're locking something when you're not.
02:09:46.120 - 02:10:17.490, Speaker A: It can be guard, but like read is pretty appropriate. Like I want to do a read. It could be start read or like use or it could be enter. Enter is not bad. Enter is not bad. Borrow also not bad, but not technically accurate. Yeah, I like enter is good.
02:10:17.490 - 02:12:04.982, Speaker A: All right, there's a bunch of comments here, that's fine. I honestly don't know why my epic is stored separately because we could just update self dot epoch directly, but epic is self dot. Yeah, I honestly don't remember, but I'm not going to change it now. Epic plus equals one. Yeah, so this is where you see we first update the epic counter and then we do offense to make sure it doesn't get reordered to after the swap or after the read of the pointer. Then we read the atomic value and at that point, because you can think of like increment of the counter sort of locked the data structure, we know it won't change under us now, and so now it's safe for us to do this. This might be none.
02:12:04.982 - 02:12:43.860, Speaker A: If, if the pointer is, if the pointer is null because the writer has destroyed it. Ooh. Has not yet been initialized. Why would that be the case? This sounds like a case I didn't deal with. I don't think that can happen. This map has not yet been initialized. I think this has to do with the first optimization.
02:12:43.860 - 02:14:04.630, Speaker A: But I think the idea here was that until you call refresh the first time, you can't read anything from the MACD, I think is the intention, but I don't think that's the distinction we want to make here. But it can be null. It can be null if we read after the write handle removed it, but at that point it doesn't matter whether we restore parity. Hmm. So this is going to be old epic or previous epic to be very explicit about it. The map has been destroyed, so restore parity. And so this is going to be.
02:14:04.630 - 02:14:53.466, Speaker A: No, I think this really is letheme fetch add returns the value before the ad. Right? So something's wonky here. Let me check this in. Read mod what this used to do. Epic was set to the old epic, so old epic plus one does not. Oh, and then it sets the bit. I see.
02:14:53.466 - 02:15:46.130, Speaker A: I don't know why I did this, why I ended up using the hibit instead of even. Odd. It's a good question. Also probably something someone can submit a pr defects. I want to avoid changing as much of the concurrency primitive as I can, both just to show that it's possible, but also because it means that if things go wrong, they're probably because of the change we made and not changes to the concurrency algorithm. So I guess this is previous. Nope, I'm in the wrong file.
02:15:46.130 - 02:16:15.022, Speaker A: So this is going to be previous epoch plus one. But if I'm using previous epic plus one everywhere, then why don't I just store the epic that epic is epoch. Great. And then this is going to store the epic. Epic doesn't look like a word anymore. Oh, this uses the old epic. Oh my.
02:16:15.022 - 02:16:58.737, Speaker A: Why? Okay, so this means that the guard now is going to be off by one everywhere. Yeah. So this needs to not be a plus one anymore. And I think that's the only place it was used. Okay, great. And this is also just going to be epic and set the high bit. I don't think I want this if no refresh has happened to return none.
02:16:58.737 - 02:17:39.124, Speaker A: Guys, I think that should be up to the t whether or not the value is valid before the first refresh. If the t has been destroyed, this function returns none. Yep. To me it sounds like you're saying epic. Yeah, I mean it's epoch. Epoch is a different way to say it, but I think epic is also a valid pronunciation everywhere in read handle and read guard. You need to swap you size.
02:17:39.124 - 02:18:09.930, Speaker A: Yeah, that's right. This, I already did it. I think epic, I should remain use size because it's an index into the epic slab, so it should be a use size. But if there is another, this needs to be U 64 and this needs to be U 64. And I guess in guard. This needs to be U 64, this needs to be used. U 64.
02:18:09.930 - 02:19:00.762, Speaker A: U 64. U 64 left, right. There's no longer values in here. T being red cannot change. And runner attempts to call random refresh, that call will block until this card is dropped. Yeah, that's fine, that's fine, that's fine. Yeah.
02:19:00.762 - 02:19:50.790, Speaker A: So you notice that guard has some like handy mapping methods. This is the same thing that you see on something like if you use refcel or in fact I think mutex guards as well. You can map like if you have a mutex guard to a t. You can call map on it to map to a value that's inside of the t. So you get a map guard like you where you is like a field of t or something, but you retain the guardhouse. And this, this is sometimes handy if you want to pass a reference to something that's inside of a guard you're holding to some sub function without giving it a handle to the whole outer thing. And you see that for read guard we can actually implement as ref t d ref to t the drop we already looked at into iterator we will not implement for readguard.
02:19:50.790 - 02:20:19.220, Speaker A: All right, nice. There's a bunch of types here now that we don't use, like all of these guys. That's nice. Let's see if this compiles. Probably doesn't. This has been an epic journey. That's funny.
02:20:19.220 - 02:21:08.670, Speaker A: Is there a way to pass in the field into size of instead of the type name? So that changes the type and the sort automatically changes what size of a value it's to? Yeah, there is. So you can do. I think it's just size of Val. Let me look this up. I think it's size of Val where you give a reference to t. Yeah, there's also size of val. Size of val raw.
02:21:08.670 - 02:21:39.238, Speaker A: I don't know what size of val raw does. Oh, it's just a raw pointer. Yes, we can do size of Val of like self dot my epoch. Although we would also need to deal with this guy, which is a little more annoying. So I think I'm going to keep it this way for now. It's a little annoying that I had specifically. Actually, this might just not compile.
02:21:39.238 - 02:22:26.712, Speaker A: So if I do, if I do this and just do, if I did one like U 32, what would this say? I'm just gonna leave this for myself to see whether this stops compiling, because if this can just be an untyped one, and it gets coerced into the right type, that would certainly be nicer. All right, we've got some remaining things that are weird here. So read handle factory went away. That's nice. Read handle does not have an o. That's also nice. This should be read read handle new, which I guess means that this should be right handle new.
02:22:26.712 - 02:23:33.408, Speaker A: And since we're exporting the type, it can just be this, which means that here we probably have a freestanding new function, which should really just be a function on righthandle that returns a self like so. Alright, what else is it complaining about on writeline? 28. All right, I have to pass it everywhere now. It's very sad. I wish it wasn't needed for drop, but I, it kind of is. Okay, so it does actually complain about U 64 or with U 32. So that suggests that if I just make this one okay.
02:23:33.408 - 02:24:06.610, Speaker A: Yeah. Then I totally agree with you. This should be, so this would be in regard that should be a one and slice of val of. We just have to be careful here that we're not giving a reference to a reference because then we'd end up with the size of you size. So this should be self dot. We just make sure this is in fact true. Yeah, size of val self and same.
02:24:06.610 - 02:25:35.280, Speaker A: And right. This then should be so here it's a little trickier because we don't have something with that type, but we might be able to get something. We can't use any. We can use last epics actually. So what we can do is say epoch type is self lastepocs get zero unwrap or zero we need to unwrap or because last epics might be empty. And then we can do size of validity of epoch type and we can do, actually, this is real, really annoying, but we're going to do this map to one, yeah, map to one unwrap or one. And then this is going to be epic type.
02:25:35.280 - 02:26:21.588, Speaker A: So I guess epic unit is a better name. This is a little bit of an ugly hack, but the idea is that we want something that has the same type as the epics. And the way we do that is we just get something that is an episode epoch, but we need it to be a one so that we can have it be unit and shift it appropriately. So we map whatever value you get out to one. And we also need to unwrap or in case there are no epics in last epochs, but this will ultimately get us a one in the correct type. As long as last epics is of Echo view 64s, which it is a little bit of a hack, but it works. That map doesn't care about its input.
02:26:21.588 - 02:27:37.110, Speaker A: You're right, you're right. That won't work because the map here is going to generate an I 32. Good catch. So we're gonna, well, we could do operations on x, but actually here's what we're gonna do instead. We're gonna do unwrap or then we're gonna do epic unit is one what copied. Fine, because it get returns an option that's a reference. It's an option reference into epics.
02:27:37.110 - 02:28:14.960, Speaker A: This is going to complain with value read but not used and then we can just allow whatever that lint is. So that lint is going to be up. I guess the lint is going to come eventually. That way we avoid doing like ugly unnecessary arithmetic. So for example, if we did e minus ema, like map e, e minus e plus one, um, we could do that, but that seems even hackier. Xor with zero would also work, I guess. But I think Clippy might complain about that too, because it's like a useless operation.
02:28:14.960 - 02:28:48.438, Speaker A: The compiler might not complain, but Clippy will probably complain. Whereas if here we're being very explicit that we're doing this just to get the type. All right, what else we got? 138. This needs to be enter line 60. This is an atomic U 64. I love the compiler. Thanks for telling me all the way.
02:28:48.438 - 02:29:48.184, Speaker A: Some in which I'm wrong compiler. It's very helpful. Write 231. This is going to be a manually drop new this is going to be all right, this is going to be as star. So what we're using here, right, is we have the value in the right handle as in manually drop, because it wouldn't be safe for us to just drop it. We could alternatively have the value in the read side be manually drop. That might be better.
02:29:48.184 - 02:30:17.968, Speaker A: They're sort of equivalent. Like if you're mostly doing inserts, there'll be more things in the right handle. If you're most, if you're doing a bunch of deletes, there'll be more things in the read handle. I think they're, they're basically equivalent. So manually drop where this gets tricky, right, is here we have the w handle and we want to get at the inner type. We the, because the r handle is a box t or an atomic pointer t. And the w handle is a pointer to a manually drop t.
02:30:17.968 - 02:31:29.800, Speaker A: That's why we have to do the cast. I think there's a nicer way to do this, but I forget. Yeah, we could deref, but this seems fine to do as a cast anyway. That's fine. This can just be our handle as mute manually drop t. All right, what else we got? Actually, this is another good point. This logic of we're only going to drop things once would be sort of broken if someone passed us a t that had items in it already, because those items would presumably not be aliased.
02:31:29.800 - 02:32:00.502, Speaker A: I guess it would be, yeah. So to explain that in a little bit more of a sane way. So we have our constructor for the left, right here, right. It takes a single t. It clones the t and makes one thing the right half and one thing, the read half. But by cloning it, we mean, that means that both the two halves own their values. If, imagine that they're non empty like the, the caller provided some values in the t initially.
02:32:00.502 - 02:33:15.368, Speaker A: So if they did that, then those values will be owned on both sides and actually need to be dropped on both sides to free the memory. But from, from the point they give it to left, right and forward, we're only ever going to drop one of them because we're going to assume that they're aliased. But I think this is something we're gonna leave to the caller to figure out. There's no one safety here. It's just, it might end up with a memory leak if they, if the t is non empty. Note if t is non empty, values may not be dropped unless you handle them specifically in apply first. Unless you drop the, unless you specifically drop the initial values and apply first.
02:33:15.368 - 02:34:00.322, Speaker A: This is like, smells a lot like a foot gun. So there's an argument here for we should only provide a new, that does debug, does that uses default. So it also always starts out empty. You could require that for this new t approach you have t implement shallow clone. So t itself should not be a shallow clone or a shallow copy because then you would end up with both halves pointing to the same map, which is not what we want. That's what shallow copy would do. So I think one argument here is we make new unsafe, it's not really unsafe.
02:34:00.322 - 02:35:07.230, Speaker A: Like it's not memory unsafe. So it feels like not really the right thing to do. But this also seems like a big foot gun. Yeah, I think, I think we really just want this to require default. And then I think we want to create a t default here and a t default here. It's just going to lead to much less pain. Oh, we could have a new trait that's like an initial shallow clone, but I think we should just go this way instead.
02:35:07.230 - 02:35:54.270, Speaker A: All right, what do we have left? No method inner. No method inner. Oh, this should just be inner. It's not a method. Ah, so here, manually drop, I think, does not implement draft mute. It only implements draft. Not entirely sure why that is.
02:35:54.270 - 02:36:28.488, Speaker A: Actually. No, it does implement draft mute. So. But it doesn't forward the absorb trait. So here the one, there are two things we can do. So let me explain why this happens. So if you have some type that implements absorb and then you wrap that type in say a box or a manually drop, or some type that implements draft mute, that trait will not be implemented for the wrapper type.
02:36:28.488 - 02:37:39.850, Speaker A: The reason you can use a trait like clone or equality or something through box is because, is because box specifically forwards traits that it knows about. So if we read down into box, you'll see down here that it implements clone for box t where t is clone it implements default for box t where t is default it implements eek for box t where t is eek. So it forwards all these traits. But box doesn't know about absorb, so box won't forward the absorb trait sort of through it. And same thing with something like manually drop now, now there are two ways we can fix this. One is that we can have blanket implementations here. So we could do implo t o absorb o for t for mu t where t implements absorb and then just have all the methods forward and then do this.
02:37:39.850 - 02:38:40.650, Speaker A: We could even do the same for like have a blanket implementation for box t, a blanket implementation for manually drop t. This gets pretty tedious, but it will make absorb the absorb type a little nicer to work with. Like imagine that someone implements absorb for hash map, but then they pass in like a manually drop hash map, or they pass in a mutable reference to hashmap. That wouldn't work in our current scenario because those types that those pointer types do not implement the trait. But it does lead to a lot of duplication, which is pretty annoying in fact. But it does mean that we have to enumerate all of these. The alternative is that here we can just like deref it through the manually drop like this and then apply second will be the specifically the t.
02:38:40.650 - 02:39:38.634, Speaker A: Am I being stupid? Probably Amdae. Don't we require the t is absorbed no method apply second found from oh, we need to use the trait. We already use the trait. Alright, so the other way we can go is absorb explicitly say that that's the thing we want to do. W handle no function apply second, is it not? Oh, it's called absorb. Fine, absorb second. Actually, maybe this is just maybe the draft will actually handle this w handle.
02:39:38.634 - 02:40:26.526, Speaker A: Yeah, it probably will. It'll draft first and then realize that the draft implements the trait. The problem still holds here though, where actually here they're going to specifically. Yeah, so imagine that someone writes like, like left right new. I guess this would be like left right new. And they try to give the types a box hashmapkv some operational type. Now if they did that, then let's say absorb was implemented for this type.
02:40:26.526 - 02:41:23.520, Speaker A: Absorb would not be implemented for the type they're trying to pass in because box is not forward absorb and they can't implement absorb for box because this is the sort of coherence rules for traits that a third party crate. You can only implement traits for types if you own either the trait or the type. In this case they don't own the absorb trait, we do, and they don't own the box type, the standard library does. So we actually do need to provide these implementations. There's a separate discussion here for why is odd an associated type? Why is, oh, not an associated type? Why is it a generic parameter of the trait? We can go into that in a second. I do want to simplify this a little bit though, by writing a little macro. And the macro is going to be forward and it's really just going to take a t which is a type.
02:41:23.520 - 02:43:31.854, Speaker A: I can never remember what the actual thing is here and it's going to do this for. This may just have to be a path because t would include the generic parameters and then we're just going to have that implement all the methods. And in all cases it's really just going to rely on the fact that the type D refs to call self absorb first operation, another absorb second and self dot drop first. We might be able to, yeah, so someone pointed out you can maybe implement like absorb for you where you implement draft mute. I don't think we can do that because that if you guys, the proposal is implement like to you absorb o for sum you where you implements draft mute till and t implements absorb o and just have the forwarding be here. But if we did that, this is a blanket implementation for you. So this means that no one else could implement the absorb trait for their own types because the compiler would say, well, this overlaps with this implementation.
02:43:31.854 - 02:44:06.780, Speaker A: Even, even though we have a where bound here, this would be fixed, I think, with specialization, but specialization hasn't landed yet, so let's not rely on it. Did I write a borb somewhere? A borb, because if so, that's hilarious. I think it's just tie. It might just be tie. Oh, but also it has to be colon path. What is it complaining about? Oh, unused macro. That's fine.
02:44:06.780 - 02:44:49.368, Speaker A: So we're gonna forward through box and some other types later. Actually, here's what we're gonna have to do. Well, I'll explain that in a second. Yes, actually I may have to do it now. I think what this is gonna end up looking like is this, and this is gonna be a tie. This is gonna be a macro book, little book of rust macros. I love this thing, macro rules.
02:44:49.368 - 02:45:50.894, Speaker A: All right, show me what the different captures are, I think it's ident or tt are probably gonna work. Both gonna work. So this is gonna be t. Oh, there's a borb. I found it. And this is gonna be, this is gonna be through where t so many aborbs. And this should be absorb of, oh, I guess unsafe impul.
02:45:50.894 - 02:46:53.690, Speaker A: It's fine. And this obviously is going to have to do a deref mute. The whole point of these types is that they deref into the necessary type. Wait, why can't this one first? Why can't this do without recursing? That seems like a lie, right? Okay, fine. Yeah, because it's taking immutable reference to self. Fine, fine, fine. Okay.
02:46:53.690 - 02:47:33.654, Speaker A: And this is going to be absorb second. And this is going to be absorb drop first. All right, so this now can forward t. The, the reason that the t needs to be explicitly passed in here is because of macro hygiene. So you can't talk about a type. You can't talk about any identifier inside of a macro that exists outside of the macro and vice versa. So if we said, like if we had this be just a capital t, then the thing that gets passed in the second argument couldn't also use t.
02:47:33.654 - 02:48:24.106, Speaker A: Those would just be completely separate t's. So we needed to pass in the t so that we can name the t in the type. And now we can do like mutei. We can forward to like arc t. We can forward through manually drop taide. What else might we want? I think realistically, like what would people actually want to pass in here is the real question. Like mute t isn't going to implement default arc t.
02:48:24.106 - 02:48:56.170, Speaker A: I have a hard time thinking that anyone's gonna stick an arc t in here, to be honest. I have a hard time. People are gonna stick box tea in here too, but it's not impossible. But an arc t doesn't make sense because they're not gonna be able to share this type regardless manually drop. Maybe they would pass in, but it seems weird for both of these to be manually dropped. So for now I think we're just gonna forget box. Um, a borb is literally everywhere.
02:48:56.170 - 02:49:31.940, Speaker A: Chad really got obsessed with abort. I'm trying to, trying to save you from all the aborbs. You know, they're out to get you. Um, we could explicitly call draft mute. That's the other thing. So we could, but we would have to use the trait you have to write like use ops draf mute or borrow, I forget where there's ops, and then call self drfmute but this is the more concise way to do it. We could use.
02:49:31.940 - 02:50:18.792, Speaker A: Oh, that's a good point. We could use t absorb first self, maybe that's a five. Yeah, that's nicer. So this way, the deref, the azref actually is probably going to be used here to coerce this into a mutable reference to the inner type. This won't work with d ref mute. This will only work with as mute, I think, whereas this one will actually work with draf mute. I don't know if this is nicer, but I think it's probably fine given that we control the impul.
02:50:18.792 - 02:50:43.470, Speaker A: Anyway, this is a little nicer. Oh, you're right. ArC doesn't implement deer of mute anyway. Arc and RC no. Arc and RC do not dear off mute. So they don't make sense here. Abort the aborb.
02:50:43.470 - 02:51:22.160, Speaker A: I think box is really the only one I can think of where someone might want the left and right types to be box types. I don't think it makes sense for them to be arch types because they shouldn't be shared. I don't think it makes sense for them to be manually drop. Yeah, no, I think box is the only one I can really think of. Box is sort of special. Yeah. My plan is to switch ev map to use left right in the stream as well.
02:51:22.160 - 02:52:31.152, Speaker A: Do you expect there to be crates that expose specific common collections through left right? Maybe, maybe all of them exist in EV map? I don't know yet, but I certainly know there's a lot of appetite for a single value version of ev map. So one that doesn't have a value set and this change will enable that. All right, what else we got? Readdez 138, right. Is so, okay, this is where it gets a little weird, right? So this is on read handle. So remember how read handle enter takes immutable reference to self? Well, read handle used to have this method that's like is destroyed and is destroyed used to just take immutable reference itself, which makes a lot of sense. Like you're not, you're just checking whether it's destroyed. In reality though, it calls enter, which in turn needs to do all the weird work to like take the epic counter and stuff.
02:52:31.152 - 02:53:11.236, Speaker A: But I think we can actually optimize is destroyed because I think all it needs to do is check whether the r handle is nullified. So I think we can actually just do this nice, much much nicer because, because we're not dereferencing the value. We don't need to increment the epic right. To tell the writer that we're like consuming the point or anything. All we're doing is loading it and seeing if it's null. If so, it's been destroyed. That's nice.
02:53:11.236 - 02:54:07.220, Speaker A: I like that. So that one can stay immutable. Reference to self. What else we got here? Why is map ref and map opt? Why are they pub super and not just pub? I think they should just be published. I'm not sure why this has a map option. That seems excessive. Like why is, first of all, this should just be called map.
02:54:07.220 - 02:54:58.190, Speaker A: And this should because, so in general, this is another observation. So read guard d refs into the inner type. So imagine that the, that the type t also had a map function. That's really awkward because now when you call dot map, you're going to get the readguard map, not the t map. And this is the same problem that arc has, for example with clone, where if the inner type implements clone and you call clone on the arc, it's not immediately obvious. Would you get a clone of the arc or the clone of the inner t? And this is why for our clone, for example, the recommendation is that you never write like Myarc dot clone. You always write arc clone my arc to indicate specifically that you're looking to clone the arc and not the inner type.
02:54:58.190 - 02:55:37.140, Speaker A: And I think we want the same thing for read guard. This is the same thing if you look at ref mute, has a map method, and that similarly is not a method, but it's a function that takes like this, which is a self. So that way this is not an inherent method on self. It's not something you can use dot for. You would have to write read guard, colon, colon map. I don't know why we have map opt here. Is map opt really that different? Let's look at what ref mute, which is the thing you get back from ref cell, does.
02:55:37.140 - 02:56:10.762, Speaker A: So ref mute has a map, it has a map split, and it has a leak. Why if map split, okay. Oh, I see. I don't care about map split yet. Map is good enough. Yeah. And notice that map here does not take itself, right.
02:56:10.762 - 02:56:51.600, Speaker A: It takes an orig. I guess we can use the same naming here so that it's not an inherent method. And I think we're just gonna get rid of map opt. Ah, what did I do? Great. Does is destroyed make sense if it returns false since it could also be always been destroyed right after. Yeah, I mean, is droid destroyed as sort of a, you can think of it more as like an optimistic operation, like tell me if it currently is. This is the same thing as on Ark.
02:56:51.600 - 02:58:00.662, Speaker A: There's a like, give me the current number of like, give me the current reference count, which is also a useless method, because the reference count is like it might be changing, someone might be cloning it right now, but sometimes it's useful to have access to the information, even if it's sort of approximate. It might be that there are other invariants in your program that make it so that that approximate information, you know, is precise. An example of this is if the, if you are told that the reference count is currently one, then you know that it won't change, because the only reference is the one that you have that you called reference count on to get one. I don't know whether the same applies to is destroyed, but it's a cheap operation for us to provide, and the caller can't get it any other. Well, they could call enter, but there's a much cheaper way to giving it. Do you have a benchmark for EV map? Yeah, I mean, there's a, there's a benchmark for EV map in, in the repository. We can run it.
02:58:00.662 - 02:58:59.122, Speaker A: I haven't, I don't know if I've run it on this computer before, so I don't know if I really have representative results. This abstraction layer shouldn't matter because of monomorphization, the code should end up being the same. The only place where it will be different is rust generally doesn't inline across create boundaries unless you explicitly mark a method as being inlineable. So that might be a small difference, but my guess is it doesn't really matter. This map is mean. You can't use method syntax, maybe just use a different name. So the reason why the standard library does it this way and doesn't do self is because no matter what name you choose here, it might be that the t has the same type, and so it's always better to provide this as a class method or a type method, as opposed to a, as opposed to an inherent method.
02:58:59.122 - 03:00:16.420, Speaker A: It's true you can't use method syntax, but that's sort of the point. What do we have? Right, so this is the error we expected to get right, which is we had a warning here saying this is an unused assignment, and we want to allow that specifically on assignments. We want a one in the type of the epoch epochs without naming that type. Here. Rust does inline across create boundaries with LTO, but LTO is a little bit more of a pain to compile, like it's generally slower. You can use thin LTO, which gets most of the benefit of LTO without completely killing your build times. And I think that does inlining across crate boundaries, but it's off by default.
03:00:16.420 - 03:00:56.090, Speaker A: Nice. So I think that now compiles. That's cool. So now have this, this left right type. And now we need to figure out is whether we can implement ev map in terms of this type. There's obviously a bunch of documentation that's missing here that we need to fill out, but we now at least seem to have the concurrency primitive isolated. And then what's going to sort of be the big test is whether EV map can be implemented in terms of this.
03:00:56.090 - 03:03:11.100, Speaker A: Maybe run into some weird problems with generics. I don't think we will, but we're gonna find out. All right, I'm gonna take a quick bio break and I'll be back. Just chat amongst yourselves. It. I also just realized I have a pause screen, I think, but I forget what it is. Let me try this.
03:03:11.100 - 03:03:41.268, Speaker A: I think now you should see like a pause screen. Is that right? Maybe with, it's a pause screen with J on it or maybe I've set up my key bindings wrong. Oh, nice. Okay, sweet. And then this is me and this is my screen, I think. So we should be back to screen now. Yeah, I love the llama.
03:03:41.268 - 03:04:16.650, Speaker A: Jerry's. Great. All right, where were we? Right back to EV map cargo. All right, so the trick now is we're going to have Ev map work in terms of left right. That's the plan. So that means it's going to have a dependency on left right. And I guess it's going to be version one.
03:04:16.650 - 03:05:17.654, Speaker A: I guess we don't really, I don't really know what the version of left right should be yet. Should be like version 0.9. This is pretty close to stable. It's, it's a transliteration of something that's worked for a long time. I need to. What for workspaces? What is the recommended way? Specifying dependencies? No workspace. Multiple factors within the same work.
03:05:17.654 - 03:06:03.530, Speaker A: Use path dependency points to the local packages and use local version to development. You can create crates IO. Yeah. Okay, so I guess that's what they want you to do. So it'll be version equals this path equals dot, dot, left right. So now we're going to start with part two, which is going to be ev mapental. Yeah.
03:06:03.530 - 03:06:57.570, Speaker A: So having this, I'd grab this directly from here, which is if you're working in a workspace, you can use a path dependency to go into the local packages within the workspace during development and then use crates version once published. Now, whether you then have to like rewrite this each time you publish, I forget. I don't think you do. I think this will just work, but it might get annoying during publishing once you do like version changes. This gets hugely painful, but I think this will work fine. All right, so what are we going to have to change here? Well, epics is going to go away. Predator is going to stay, operation is going to stay.
03:06:57.570 - 03:08:23.920, Speaker A: Right. Handle and the various read things are going to stay, but they're mostly now going to be wrappers around the inner type read handle factory is going to go away. Shallow copy is going to stay. Options going to stay. Yeah. Oh, so this is an example where EV map actually doesn't need a new, it can't use a default because it wants to be able to specify like the hasher for it wants to be able to specify the hasher for a hashmap, for example. So I do think we actually need the, do you think we need the version of nude that takes a thing that's clone? So this is going to be, I think what we're going to do is call it new from empty note the t must be empty as otherwise apply first.
03:08:23.920 - 03:09:16.970, Speaker A: Would only forget values from, would only forget, would forget, not drop initial values from one of the two halves. So this is going to now take a t and it's going to do, it's going to take t where t is clone. It's going to take a t here and t here. Even for default. I'm not sure if we want to do this because remember, for hash map we need to ensure that they're deterministic. So they need to have the, the two maps need to have the same hashers. So I think we actually do want this to be clone.
03:09:16.970 - 03:10:16.160, Speaker A: So we're going to have like let t is t default or actually just going to call new from empty t default. Yes. As I mentioned before, we can't use shallow copy for new because we don't want to shallow copy the entire tache. We want the t's values to be shallow copied. If we shallow copied the t, you would have two stack like hash maps that point to the same underlying buckets, which is not what we want. Ok, so we now have new from empty. So this is now really going to do.
03:10:16.160 - 03:10:54.820, Speaker A: Right. So this is where ev map does something kind of weird. It marks the right handle as ready, but it does not mark the read handle as ready. I think the way this is going to work is the initial inner is not going to be ready. And then we're going to call like a ready method on. We're going to append an operation to the right handle immediately that sets it to be ready. So the, for the operations up here mark ready.
03:10:54.820 - 03:12:36.750, Speaker A: So here what we'll do then is let RW is left right new from empty t or I guess inner and the w is going to be mutable. And then we're going to append immediately append op operation, operation mark ready and return to the r and w. And then actually this is not going to be, this is really going to be our read handle new and our right handle. So EV map is going to provide its own wrapper types, its own wrapper types around the left and right read handles that do things like provide oops, specifically provide map specific methods on them like handle handle. What am I doing? Write handle. So right handle, for example is going to have an insert method which left right's right handle does not. And we're going to have to actually write these implementations.
03:12:36.750 - 03:13:21.030, Speaker A: Appendop does not exist. Why not? Right, because inner doesn't implement absorb, which we're going to have to get to. This is probably all fine because it all goes through construct. So we're actually going to remove EV. I guess we have to go to EV map. Now we're going to remove source read factory. That one's going to go away.
03:13:21.030 - 03:14:22.170, Speaker A: And inner. So inner in EV map is kind of interesting. Inner, EV map is now going to be the actual type that gets shared. So we could still do what it used to do, which is this like as a feature to choose the map implementation. But nowadays I, now that we have this like fancy generic trait, we could implement it separately for like index map and hashmap, for example, and have those just be two different types. I don't really want to do that because it would mean that I have to duplicate the full implementation of inner and read handle and write handle for each type. This is where it would be nice to have a collection trait or like a map trait because that way EV map could be generic over its map implementation while using the underlying, the underlying left right.
03:14:22.170 - 03:15:35.422, Speaker A: But barring that, we're just going to say that you can choose it with a feature flag. All right, so it's really just going to hold a map implementation of meta and a ready. So inner is actually fairly similar to what it was before. And let's see here. All the debug stuff is the same, all the clone stuff is the same, all the construction stuff is the same markready and is ready, is going to be, there's going to be operations. So these are just going to be, I don't know why these are even here. These should be fairly straightforward to deal with.
03:15:35.422 - 03:16:43.770, Speaker A: So I just want to get rid of them and do the same thing I do here, which is mark that as pub crate. Okay, so inner is easy enough. Inner doesn't really have to change because it's just the type we're going to share. Right is going to be simplified significantly. So right is now just gonna have a handle, which is gonna be a left right right handle of. And this is where it gets tricky of a inner K manually drop Vmsheen and an operation KV. And I wonder whether we can try to implement the first and second optimizations here that may end up working.
03:16:43.770 - 03:17:19.480, Speaker A: I'm not quite sure. Oh right, we need to implement absorb for inner. So I think the apply first and apply second things are currently in the right file. Yeah, they are. So these are going to be methods on inner instead. And I think the way I want to express that is to probably leave them in the right file. It seems more appropriate that it here than an inner, but I might come to regret it.
03:17:19.480 - 03:18:53.536, Speaker A: Left right, absorb operation KV for inner, k, v, M s, a lot of generic parameters. Absorb first, absorb second. And we're also going to have to do here a, what did we call the last method? Drop first. And that one is unimplemented for now. Oh yeah, I mean, now that, now that this is generic, now that left right is generic, you could pretty easily have any type you want as the inner type, whether that's a binary tree or a heap or a map or a counter, as we talked about before, arguably that's the other thing we should do is try to implement like a test suite for a simple counter. This one is gonna be a little bit annoying and I'll talk about that in a second. Actually I can maybe talk about that.
03:18:53.536 - 03:19:14.938, Speaker A: Now. The trait absorb operation typer, typer requires. Right, this is unsafe. And kvms. Oh man. And that's gonna require, I guess actually that's gonna require all the different types we have here and. Right.
03:19:14.938 - 03:20:10.210, Speaker A: It's gonna be pretty annoying. Right. And this is now missing Operation Mark ready, which really is just going to be inner. Dot ready equals true and same thing down here. That's a new operation we added. That's fine. Okay, so we have absorb for inner now, which should mean that now we should be able to write to construct one.
03:20:10.210 - 03:20:53.606, Speaker A: Right. So here's where this gets a little annoying. You see how it says the trait bound inner. Basically this is that absorb is not implemented for inner manually drop. That's true. We implemented absorb only for inner of kvms, not k manually drop vms. And the manually drop bit here is a little bit of, I think I mentioned it briefly earlier, a little bit of trickiness that right handle does, which is instead of trying to keep track of, instead of manually calling, like forget versus drop in apply first and apply second.
03:20:53.606 - 03:21:44.220, Speaker A: What it does is just if we're applying first, then it uses a type that has manually drop v as the, as the type that absorb gets called on. And if it's apply second, then it uses just v as the type that gets called on. That won't really work anymore. Like this now just has to be v always. But I think the way we're going to get around this, the way we're going to be able to keep that simplicity, which was kind of nice. Is that in apply first or. Actually, no, the way we're going to get around this is to have.
03:21:44.220 - 03:23:11.240, Speaker A: Yeah, no, it is going to be v absorb for v is that this is going to take mute self and it's going to take other. And what we're going to do is we're going to say that inner is going to cast self to be a, to be a manually drop. It's not quite as nice, but I know that it's, I know that it's. Okay. Yeah. So this is gonna have to be unsafe, perhaps unsurprisingly, which is we're gonna have to do a mem transmute here. Okay, so let me write this out and then explain what it does.
03:23:11.240 - 03:23:38.158, Speaker A: Let's see if that works. Yeah. So we're given in here an inner kvms, but we're told to absorb first. What that means is we shouldn't drop any values. We should only ever forget them. And instead of trying to make sure that all the code below here, like that, we explicitly call forget anytime something might drop a value, like we wouldn't be able to call just clear on a vector because that's going to drop them. We would have to like walk the vector and forget each element.
03:23:38.158 - 03:24:31.350, Speaker A: Instead of doing that, we're going to do is just change the type of inner to have the values be wrapped in manually drop so that dropping then will not actually drop the inner value. This is a super sneaky little trick. And what I have to do here is cast the self that I'm given, which thinks that it owns the v into the same value, but where the these are manually dropped. And I can't do that with a simple cast like with an s because the compiler doesn't know that these are the same type at all. Clearly what I'm doing here is super unsafe and so I have to use mem transmute to transmute self. And the syntax here is transmute is a function that takes two generic parameters, the from type and the to type. The from type is dictated by the argument I pass in and the to type is what I want out.
03:24:31.350 - 03:25:13.484, Speaker A: And you can, you can see that if we go to transmute, where's the. Yeah, transmute t, u takes a t gives you a u. Are all types of manually drop in the generic parameter guaranteed to have the same in memory representation at the same time without the manually drop. I believe that to be true. True if, certainly, if that's not true, this is not safe. Let's go check. Manually drop t is subject to the same layout optimizations as t.
03:25:13.484 - 03:25:48.580, Speaker A: It has no effect in the assumptions the compiler makes about its contents. So it should be, I think putting the type that we transmuted into after the let inner would be a lot cleaner. Yeah, you're probably right. We can do that in instead. So that would be this. Oh no, ms, that works too. That's already cleaner.
03:25:48.580 - 03:27:21.570, Speaker A: Make sure that no methods below drop values since we're only operating on the first instance of each value, the first shallow copy of each value, and then safety manually drop t has the same layout as t. And then for absorb second down here, this one is just going to take a mute self just the way that it is, and other, which is going to be self. And I'm guessing that all of the, all the complaints here is that I don't have a hasher. So let's just go ahead and get that. Is it not dot hasher, dot data, dot hasher. And we'll do the same thing here and here letinr itself. But yeah, just minimize the diff.
03:27:21.570 - 03:28:05.096, Speaker A: Technically I could now use self here rather than inner, but I'd rather keep the diff small if we can. No methods. Yeah, you're right. All right, so we only have 68 errors to go. That seems good. So right handle now is really just a wrapper around this handle business. So maybe what we do here is I don't think we can do the first and second optimization.
03:28:05.096 - 03:29:04.810, Speaker A: Actually, I'll show that in a second, but this is really just going to be handle now because it doesn't have all these fields. And I'll leave those commented out for now because they might come later. Creating a new right handle no longer require epics. In fact, creating a new right handle now all it requires is a left right handle over an operation KV. And I think the other thing we want is just like before, we probably want this to just be a method on right handle. Oops, that's too much. So we'll just stick that up here.
03:29:04.810 - 03:30:05.610, Speaker A: So that's going to take a w handle and return a self. It doesn't have to have all these wear bounds because they're already on the impl block. And all it really needs to do is stick in the handle there. So remember the handle now the right handle here is really just a super thin wrapper around the left right right handle that provides nicer access to inserting things into the OPL. That's all it really does. Can the compeller rearrange the order of fields of inner versus inner whatever? So even if manually drop v's v, the inner type is not the same. They shouldn't be, they should be.
03:30:05.610 - 03:30:59.550, Speaker A: They should be subject to the same layout restrictions. So they should be laid out exactly the same. Now we don't need wait anymore and refresh. We do kind of need refresh in the sense that we just want to call self handle refresh. That's all it needs to do. Similarly with flush, we probably want to expose that to our callers. Remember, we probably don't want this to draft mute into the inner right handle because that would expose methods like like handle op or append up.
03:30:59.550 - 03:31:55.730, Speaker A: So we're just going to rewire these to redirect inside. Oh, this is a. Why is this written as a mem swap? That's real weird. So I guess we want another oplog here which is like set meta m and that also. Oh no, this means that the, oh there's so much documentation. This means that we need an m here now as well. Which means that anywhere that takes an operation now has to include the m in there.
03:31:55.730 - 03:32:54.558, Speaker A: It's like the hell of generic parameters. Where is, there we go. Absorb, absorb, absorb. And this now also has a, I guess operation set meta, which takes the meta and unsurprisingly sets the meta to be that. And similarly down here. Great. Now apply first is this is probably going to complain because when we get a set meta operation, I think we already have m implements copy or something.
03:32:54.558 - 03:33:30.610, Speaker A: M implements clone. So when apply first is called right, we only get immutable reference to the operation. We don't get to take ownership of it, which means you only have immutable reference to the meta as well. So we're going to have to clone that out here, I think. I don't know, it's probably, it doesn't, there are too many compile errors for it to realize this particular error yet. But yeah, all the application of the operational log stays the same. Let's see what else we have up here.
03:33:30.610 - 03:34:19.880, Speaker A: So we've add op, which used to be the same thing as sort of append op like we have in left right right handle. And this is where the first optimization came in. Wherever. If you haven't refreshed yet, you, you know that there are no readers in your write handle because you just created the map. So you can just do the operations directly into the map. The reason this optimization was helpful was because when you first create a type, chances are you want to like dump a bunch of stuff into it. And it's really annoying if you have, if those all have to go through the OPD when it's not technically necessary, we might be able to fix this.
03:34:19.880 - 03:35:19.778, Speaker A: So I guess this would be self handle append op. And otherwise we have to do some real sneaky. I don't think we're going to be allowed to do this because without changing left right. So basically here we want to get a mutable reference directly to the inner, but all that left right provides us with is the, the sort of, it's an apply op that you get immutable reference to the inner, because that's when it can guarantee that there are no readers there. And apart from that, all it ever gives us is an immutable reference to the read side. Whereas here, what we're trying to get is a mutable reference to the right side. And left right has no way to promise that that is safe to do so.
03:35:19.778 - 03:36:32.190, Speaker A: It doesn't provide that method. But if we wanted to enable this optimization, what we would have to do is have like an unsafe, actually it doesn't need to be unsafe. What we would have is a method on left right handle that is specifically raw. Right handle takes a mutable reference to self and returns a mutable pointer to t. And the reason we want this to be a pointer is because we can give out a pointer and then the caller has to like, in order to make that immutable reference, they can actually use for something, they have to write an unsafe block. It's not unsafe for us to give out the pointer, but it is unsafe for them to try to mutate through it because there's no guarantee that there aren't any readers, but this is all that we really need for the optimization to work. So this is just gonna be, I guess, let's see here.
03:36:32.190 - 03:38:01.780, Speaker A: I think it's just gonna be this. Now, why is this unwrap? Okay, this unwrap is okay because write handle is only null after drop. I don't know why it even is an option. Like why is w handle an option? Like do we ever take it? I don't think we do. Oh, we take it here. I don't think there's a good reason for us to do this. So I think what we.
03:38:01.780 - 03:39:00.090, Speaker A: Hmm. So the reason for the option here is because we're using box into raw to get the pointer from the right handle. I feel like this is something I fixed on a branch. This doesn't actually need to do that, but that's fine. It's just a little awkward. This is something we could fix later. Like the w handle will only ever be none between here and here, which is when we do the swap.
03:39:00.090 - 03:39:55.780, Speaker A: So it should basically never be none observed externally from, from, wait, I'm pretty sure we could rewrite the code to not have that be an option, but I'm going to not meddle too much with that code at the moment and have it work this way instead. And this is going to be a manual drop t, I think. Wait, why is this. All right, this could also, this is need to include the manually drop. I don't think that's an important detail. So this we can do as star mute. Manually drop t as star mute.
03:39:55.780 - 03:41:01.670, Speaker A: Ah, that's real ugly rust format. Why you, why you do this to me? Oh, so now the sort of ad op on, so that add op that we have on the ev map. Right. Handle, I think, can now do this optimization, which is it grabs the handle. Why does it need to get the hasher from the retendle? I mean, that's fine, I guess, but. Yeah, but I don't want to have to enter here either. I feel like this could use the handle from either side, to be honest.
03:41:01.670 - 03:42:32.980, Speaker A: Yeah, I think this can use the hasher from either side. So, so this is just going to be hasher is going to be, actually it's gonna, we're gonna make this into a reference here. So the reason why this is safe is because we know there are no outstanding readers since we haven't refreshed ever before. And then the hasher can now be w inner hasher, I guess, data hasher. And now it's going to complain about other things, which is going to be annoying. We don't need do drop anymore. This is just gonna work.
03:42:32.980 - 03:43:21.290, Speaker A: But getting the hasher is gonna be a little bit annoying because we're gonna do basically this. Right, apply second. Why not absorb, apply second w hasher this, oh, right, I need to actually use that left, right, absorb. We need to use the trait in order to call the trait. That's fine. And I guess now where we implement absorb, we don't need to name it. This is absorb second.
03:43:21.290 - 03:45:02.750, Speaker A: It takes a w inner and a hasher, but the right, so this is going to complain because, oh, actually, I guess it actually wants the data, but we can't actually do that because the r handle, I guess because the borrow checker is going to kick and scream here, saying that we're right, that we're accessing w inner both mutably and immutably. And it's right, right. Calling absorb second, which requires immutable reference to the inner. But then we're trying to also give an immutable reference to the same thing here, which is clearly also not okay. We could call enter here. That's like a chief enough like operation anyway. So we could call our handle dot enter, is it not r? Oh, self dot handle dot enter, dot expect map has not yet been destroyed.
03:45:02.750 - 03:46:23.480, Speaker A: This does mean that we're gonna end up like taking an epic. But taking an epic here is basically free because we are the only writer and we're not waiting. Let's see. Okay, so now we have the self first operation and the self first operation here, optimization, I mean, actually seems to work, right. We get a, we, we happen to know here that there haven't been any refreshes and therefore we do have exclusive access to the right handle. And that means that we can just directly absorb the operation rather than add it to the oplog, just absorb it directly into w inner and then not store it in the uplog. Of course, as does note point out too, because we did this, the, the next time we try to apply operations like basically after the next refresh, the all plug is going to be empty.
03:46:23.480 - 03:47:29.670, Speaker A: And so we're going to have to have, we're going to have to clone the right handle into the read handle on the next refresh because there's no oplog to copy over because we didn't add these operations to the oplog. There is the reason this is if not self first, someone asked in chat, is because this is just the sort of happy path or the common path, rather. It's not the happy path, but the common path that's why I put it first. I see there's a bunch of discussion of whether, whether it's okay the transmute I'm doing transmute whether it's okay for me to transmute a inner kvms into an inner k manually drop vms. So, okay. To take a quick aside, the reason this discussion arises is because V and manually drop v are guaranteed to have the same layout of by the compiler. We know this from manually drop.
03:47:29.670 - 03:48:24.730, Speaker A: The question is whether, like some type v, some type generic over v is guaranteed to have the same layout as some type generic over manually drop v. I'd be very surprised if it wasn't, but you're right that I don't know. So let me, let's see. So what does the Namicon say about this? So the Naumicon is a really great way to look up, like, basically stuff about any unsafe code. Yeah. So rust does not guarantee that an instance of a in this case has the same field ordering or padding as an instance of b, even though they have the same fields in the same order. The question is whether this applies to generics as well.
03:48:24.730 - 03:49:04.330, Speaker A: This is not quite the same. Yes. It doesn't really say. Right. So, okay. This example indicates that maybe they could be different, but it's not really the same case. The case we have here is like struct a generic over t, and then is a of I 32 the same as a of manually drop I 32, which happens to have the same layout.
03:49:04.330 - 03:49:54.140, Speaker A: I don't know. It is true that we rely on that here, and that may not be safe to rely on. I wonder if unsafe code guidelines. So there's a, there's a rustling working group called the Unsafe code guidelines Working Group. And I think this is the kind of stuff that they've been looking at. So let's see what they say here. That's not quite the same.
03:49:54.140 - 03:50:52.990, Speaker A: That's also not quite the same. Repertransparent. Let's see if they have any discussion of transparent. No, that's not quite the same. That's also not quite the same. All the end fields are single. That's similar, but not quite the same.
03:50:52.990 - 03:51:50.524, Speaker A: Also not quite the same. I guess we want repro transparent generic representation of structs. Yeah. So clearly a lot of discussion. I don't know what the conclusion was. Let's go down here. Only reordering is still mandating greedy's padding.
03:51:50.524 - 03:52:37.840, Speaker A: That would certainly help. Oh, collection, transmute. Let's see what that says. This is like diving pretty deep into technically with generics you could even have different sizes. Yeah, but it's specifically the case when we know that the layout is the same because it's repro transparent that seems, yeah, that's not what we want. All right, let's see what this chapter says. Representations of structs.
03:52:37.840 - 03:53:31.940, Speaker A: All right, and let's look at this from master just in case. Like diving pretty deep, but it's important. Oh, it's not on master. That's good. Reference reference source layout structs and tuples the statement here are not yet guaranteed until an RFC struct types. Just the layout tuples, that's tuple structs. I don't really care about those.
03:53:31.940 - 03:54:11.290, Speaker A: The layout of these fields themselves is already entirely determined by their types and since we intend to allow creating references to fields, struct do not have any wiggle room here. Uh huh. All right, default layout. Default layout is not specified. Have not yet reached a full consensus, not required to select the same ladder cross compilations. That's fine. Two structs with the same field types may not be laid out in the same way.
03:54:11.290 - 03:55:25.280, Speaker A: Naturally, in practice the compiler aims to produce deterministic output as the, as of the time of this writing, the compiler will reorder struct fields to minimize the overall size of the struct. So that suggests that currently at least, this is fine because the layout is the same. This seems like a good, I guess it's an unresolved question. Yeah, it's sort of like deterministic layout, I guess, is sort of what we're after. Yeah, like this is a good question, right. Whether it's deterministic only dependent on certain properties of the fields. Like if the, if, if all that matters is the size and layout of each field, then our two things should be the same.
03:55:25.280 - 03:56:22.140, Speaker A: But it seems appealing. Yeah, so here's an example of like substitution might be worth for us to like chime in on this discussion, but I don't know. Yeah, so here's right, like I suggest repertransparent equivalent would still be enough. All right, so it sounds like we need to chime in on this discussion to move that forward. We could make this reprecee, but I don't really want to make it replic, so I'm going to keep it the way it is and then I'm going to add a comment to this discussion after the stream finishes. But I think it's fine for now. All right.
03:56:22.140 - 03:57:12.360, Speaker A: Okay, so now we have the first optimization, which is that if we haven't swapped yet, then we just do the modifications directly to the map because we know that no one else has it. And then what we need to deal with is if we're trying to refine refresh and we can see this in. Remember I changed refresh to be, to just call the inner, inner handle refresh. But in reality that's not quite what we want. So we're going to do source write rs. So it used to be that refresh did. Where is, is it here? It did a wait and after the wait did a second.
03:57:12.360 - 03:58:21.390, Speaker A: That's gonna be a problem. Ah, I know what we can do. Okay, I think, I think we can still do this. So, okay, this is going to be a little bit ugly, but I think it's going to work, which is that we're actually going to. So what I was thinking here was that we could append an operation that's like do the second pass of copying over, but it might just be a pain. Kind of tempted to get it to work, but I think it's also going to be a lot of pain. Let's.
03:58:21.390 - 04:00:03.800, Speaker A: Right, so what I was thinking here, right, was self handle append opend up like operation swap in read, just clone maybe. So that would be one way to do it. It might mean that we end up with an oplog that has a lot of these operations. But I guess we could, we could get around that. Okay, this is gonna be, this is a little ridiculous, but. So I guess maybe, maybe we just do like enum optimization step. So we can either be no refreshment cued clone is bool, or it can be, or it can be the right, right side empty, or it can be none of.
04:00:03.800 - 04:01:11.654, Speaker A: So I guess I, I decided to go against myself in, in saying that I would not change things around. All right, so the idea here is going to be that if, oh, drop for right handle can now go away. That's really nice. So this handle is going to start out with the optimization being optimization. No refresh has happened yet and we have not queued a clone yet. We're going to match here on self dot optimization. If we're in optimization, no refresh, then whatever.
04:01:11.654 - 04:02:23.260, Speaker A: If we're in optimization, right side empty, then whatever. And if we're in optimization, whatever. I think that's going to happen after the refresh. So this is just going to move the optimization forward. Optimization right side empty, optimization none and optimization none if. Right. So if we're in the case where optimization where we haven't done a refresh yet optimization, then, then we're going to just do the if a refresh hasn't happened yet, we know that we own the right handles.
04:02:23.260 - 04:03:07.380, Speaker A: We're just going to do the modifications directly to the right handle. If we haven't queued a clone, then we need to queue a clone operation. The reason for this is if we didn't do this, absorb wouldn't be called for our operation and therefore the, the copy would never happen. We need there to be at least one operation in the oplog that tells us that we need to pull in everything from the read handle into the write handle. But we only want to do that once. We don't want the oplog to fill up with tons and tons of these things. And if we're not in that optimization state, we're just going to, we're just going to append the operation to the queue as normal.
04:03:07.380 - 04:05:16.310, Speaker A: So we're going to have here a just clone our handle. And what is this going to look like? Well, in apply or absorb first, I guess if the operation we get is just clone our handle, what does that mean? So, so apply first is going to be applied to the right handle that we have already modified. So we're going to do nothing. This is applying the operation to the right handle, to the original right handle. Just, she's that true? Yeah, to the original right handle, which we already applied the first batch of operations to. If we're told to apply it second, that means that now we're applying the, this means that it's the first refresh that's happened, and the right handle is the original read handle, which is empty and needs to copy over all data from the right handle that we wrote to directly. So in this case, inner data is just going to be, I guess, dot extend.
04:05:16.310 - 04:06:34.920, Speaker A: Well, is that even really gonna work? That may not work. Well, what did it used to do on second? It used to get the r handle. Yeah, it used to have this comment in it. So really it would be nice if we could just clone here. But remember the problem around hashing, we need to make sure that the, we need to make sure that the any bucket, any like value sets of like a created in the, in the map all use the same hasher, which means that we need to pass in a hasher, which means that we can't just clone over the whole map. Actually, maybe we could clone over, I feel like we might be able to clone the whole map, but I'm gonna not risk that. So we have the r handle, don't we? Oh, I guess it's called other like so.
04:06:34.920 - 04:07:28.160, Speaker A: And who knows why this is complaining. Type v cannot be dereferenced. That's fine. Ooh, that looks ugly. Oh, it's, it's like a manually drop challenge here, which is values from the, this is going to be a manually dropped new of that I think. Oophenous, little unclear. Right.
04:07:28.160 - 04:08:42.574, Speaker A: So inner here is a thing that holds versus. So why can't I give it these values manually drop? Oh, I see. This gives me back the shallow copy here gives me a manually drop and I need to make those not be manually drops somehow. So into inner into, all right. This is actually manually drop into inner that thing. All right. Yeah.
04:08:42.574 - 04:10:12.840, Speaker A: And then I think actually we don't even need this, this right side empty thing. So really this is just an option. So this can be, instead of calling it something grandiose like optimization, it can be called, can be called just direct. Right. So initially direct write is going to be sum and the inner value is false to indicate that the, I guess we should document that up here. If some write directly to the right handle map. Since no refresh has happened, some false indicates that no, that the necessary, necessary operation just clone our handle has not yet been appended to the op log for when a refresh does happen.
04:10:12.840 - 04:11:25.440, Speaker A: And this can now just do take, in fact, it doesn't even have to do that. It can just set that equal to none. Once we've done a refresh, we can no longer do direct writes. And now we can say if let sum is direct. Right, then we do that. Can you replace, can you replace the star v with v as ref? Probably. I don't know if that's nicer, but it has to be deref, which means I have to use a trait which seems not worth it.
04:11:25.440 - 04:12:35.650, Speaker A: All right, where's our error now? Inner with capacity Ic is manually drop. So I think what we want is for our, we don't have, we don't need do drop anymore. Don't use that. These, I think is actually going to do just this expected read read handle. So where's our new, why does it complain about this thing? Oh, it's from, it can just be new instead of. Instead new seems fine. It's a private function anyway.
04:12:35.650 - 04:13:47.428, Speaker A: All right, so now we're getting, we've gotten pretty far, right? So now write doesn't really have any stuff in it about like refreshing or like any of the epic stuff. Like none of that is an write anymore. Now it's only just tons and tons and tons of, tons and tons of, and tons of map specific operations. Why does this even need to deref, I think this is gonna be annoying. That's gonna be a left right read handle of inner of that. Alright, so now we need to get to the, ooh, all right, the, it's complaining about the tests. That's fine.
04:13:47.428 - 04:14:15.640, Speaker A: So let's look at the read sign now. Reads should also be a lot simpler now. Factory goes away. That's great. Read handle should now only really have a handle, which is going to be a left right read handle. And again to an inner of that. And it shouldn't really have anything else.
04:14:15.640 - 04:14:58.870, Speaker A: We don't have to implement drop specifically anymore. Which also means that we don't need to have these anymore. Oh, we do. For inner to make sense, which means that this implementation is now just handle. We can actually just derive clone, but we're not going to, the reason we're not going to derive clone is we, we don't need. So if you would derive clone, it's also going to say that KVM s need to implement clone. We don't really care about that.
04:14:58.870 - 04:15:41.170, Speaker A: So we are just going to do self handle. Is self handle clone. What else do we got? This thing is now gonna go into read handle. So this is gonna be a pub create new that's gonna take a handle. Just gonna be a left right handle. Again, no epics. And really it's just going to write wrap self with that handle.
04:15:41.170 - 04:16:29.120, Speaker A: And again, the only purpose really of us having a wrapper type here is we have the wrapper type so that we can provide map specific methods on this. It's no longer a handle that can go away. That's all handled by left right hasher. We no longer need in here. I guess we can still have read, but I don't kind of want to call this enter again. I guess if we're doing a breaking release anyway, we might as well. And that's going to give me an entertain and that's going to create a map redref.
04:16:29.120 - 04:17:18.710, Speaker A: That's fine. This I guess is going to be enter. Enter. All of these are just going to be entertained, right? I need to. That's just because map. We haven't fixed up map read ref yet. This is just going to be map, but it's actually going to be left to deal with that in a second.
04:17:18.710 - 04:17:46.120, Speaker A: That's going to be mad. Map read ref. Map. Once we're done with it, do we even use. I guess that's going to be a read guard. Oh, I see. So read is actually a little different.
04:17:46.120 - 04:18:27.210, Speaker A: Read gives you. Okay, so, so in the, in ev map side of things. We actually have two kinds of guards. We have a read guard and then we have a map read ref, and map read ref is basically a read guard specifically for the map. I don't know if we need this distinction any more. I think map readref is all you really need. I see read guard is actually used for m, but I think this can just be a left right read guard and no one's gonna care.
04:18:27.210 - 04:19:25.250, Speaker A: And this is gonna be this. That's fine. This is gonna be left right read guard. So that means that we're not even gonna have a read guard here, I don't think. Like what does our read guard do? Yeah, nothing really. Nothing that map redref couldn't do. So I think we're not going to have a guard, we're just going to have read ref, which means that we can rm source read guardhouse.
04:19:25.250 - 04:20:00.782, Speaker A: I think I found proof that manually drop transmute is unsound. Alright, let's check this out. This is why it's nice to have chat, because people can check things up while I'm coding. Guaranteed to have the same size alignment. Abi, this is for maybe uninit, nothing from obvious any bit value is valid. Ah, so this is not quite the same. It's similar.
04:20:00.782 - 04:21:09.074, Speaker A: I mean that this first sentence right is pointing out specifically what we saw in the other thread, that there's no formal guarantee that they're the same, but in practice the compiler, compiler currently treats them the same. They go on here to say that specifically because any bit value is valid for maybe uninit the compiler can't apply optimizations that's not true for may manually drop. For manually drop it has the same validity requirements as maybe on in it you can't stick like if you have a manually dropped bool, you can't stick like arbitrary bit values in the bool for maybe on in it. You can stick any bit value you want in that pool. So it can, the compiler can optimize manually drop just like it optimizes manual, it can optimize manually drop t the same way as it optimizes t. So I think that should be fine. But you are right that this is something that's clearly not guaranteed by the compiler, but it seems to be what it currently does.
04:21:09.074 - 04:21:49.310, Speaker A: And that's why I want to follow up on this on this thread specifically pointing out this issue and see what they say. It's true, we could just replicate it repre see has some other implications are kind of sad, but maybe that's worthwhile. I think for now, I want to keep it and then point out the issue. But I mean, it's a good problem to point out for sure. All right, so we can tidy up this quite a bit. Don't need mem anymore. That's always a good sign.
04:21:49.310 - 04:22:30.780, Speaker A: So this is guess this is a left right read guard. We can reuse the left right read guards because all they're really doing is they deref into the inner type. We might be able, we might want to re export left right read guard. That might be good. I really want, oh, I see. This should be self handle entertainment. That's what we want.
04:22:30.780 - 04:24:05.166, Speaker A: This should be self handle enter. This should be handle entertained. This one's trickier. This one is like if inner is none, then none else. Inner dot left right read guard map inner as ref unwrap data, get key map of error. Why would this be? Oh, right, yeah, so this one's a little awkward. This is why it had map opt, which is, it's not that we need to do this, it's that inner dot data dot get of key.
04:24:05.166 - 04:25:11.670, Speaker A: What this is going to return is a read guard left write read guard of option like v. But what we want to return from the function is a option readguard v. It's not really a nice way for us to do that, actually. Maybe there, yes. This is why I think, I think we can't do this with a normal map. We're going to have to basically do let value is this. So we're going to map out the data for the key, and if the value is none, then that, otherwise we have to map again to value value inner dot unwrap.
04:25:11.670 - 04:27:07.060, Speaker A: What am I doing something silly? There we go. Mismatch types. Yeah, I was worried about that. Yeah, we might actually just need map opt. There might not be a nice way to do this without map opt, which is, okay, so the problem here is that get returns an option of a reference, but map requires that we return a ref, actually, why does it require that we turn a reference? Can we just fix that instead? Like if map was not required to return that, but just did this, and now I do want you to be sized. Is that fine? Oh, it's because this internally stores a t, doesn't it? Well, this is probably gonna be weird. Hmm.
04:27:07.060 - 04:27:58.576, Speaker A: Gee, that's a good question. I wonder what they do for ref mute, for example. So what's the signature for ref mute? Yeah, so they do the same thing. They do the same thing this used to do. And then the map that they provide is the same type of map that we provide. But I think that means you can't really do options, which is pretty awkward. Like, we could always return this, but it doesn't seem quite right either.
04:27:58.576 - 04:28:47.740, Speaker A: So I think we do actually want a map opt here, which is kind of silly, but. Oh, actually maybe we don't. Maybe I'm just being silly. So this gives us something that derefs. Now the problem is we can't. This gives us an option ref, but we have to return a ref itself, which won't work here. So I think we do need a map opt or I guess a try map.
04:28:47.740 - 04:29:42.490, Speaker A: Although try should really be a result. If we had the tri trait, that'd be great, but we don't. So this is going to have to be a option u, and this is going to be that, and this is going to be this. And it returns an option read guard. So now we're going to just do trimap of that. And it complains because the value is manually dropped. It doesn't have to be because we're giving a reference to it.
04:29:42.490 - 04:30:20.286, Speaker A: Whoo. Can't you write to immutable option variable in the outer scope in the map and return in the map? I don't think you can, because we want to, because we actually have to return the guard. We're returning a guarded value. We don't want to clone out the value or anything. Right. We want to return a guarded value, which is basically a guarded reference. So we can't move.
04:30:20.286 - 04:31:24.380, Speaker A: We, like, if we, if we did like a val is none. And then we did like a map where we set Val equals this, that wouldn't work because the, the return, the, the thing that we stick inside Val is tied to the lifetime of inner. So if we tried to return Val, it would say this has, this lives as long as the inner does, and we're not allowed to drop inner. Think of it as like, if we returned the, if we tried to return just the reference, that would mean that we dropped the guard, which releases the epic, which means we now have a pointer into the map. But we've also released the epic, so the writer might overwrite that value. So that won't, I don't think that will work. What else we have, we have left right read guard, and this presumably does a trimap as well.
04:31:24.380 - 04:32:51.860, Speaker A: Oh, right. We called this read guard trimap, and this now doesn't have to do that anymore. Wait, did I, I did something stupid here, didn't I? What did I do that was stupid? Oh, I see what I did. I think I need to do read guard trimap. Reidguard trimap of this thing. Wait, I thought that's what I did. I mean, clearly I'm doing something silly here, but what? So get raw returns an option.
04:32:51.860 - 04:33:44.240, Speaker A: So what we get back here is a regard to values. Like, just to see if I'm being silly, if I do this, does it work? Oh, I'm entirely being stupid. The old version here uses mapref, not trimap. So really I'm just being silly. And this needs to be map. This just needs to be map with this. I thought, and apparently I was wrong.
04:33:44.240 - 04:34:38.820, Speaker A: Why is this given a manually drop? I've definitely been doing something strange here with I have a manually drop somewhere where I shouldn't have a manual drop. And I think I have it. I think I have it. Oh, this expects to take a manually drop. I see. But there's no reason to remove the manually drop anymore. So that can just go away.
04:34:38.820 - 04:35:08.380, Speaker A: Which means that this can go away. Great. Get one. Left right read guard. This. This one is a map op. Okay, so left right read guard.
04:35:08.380 - 04:36:02.119, Speaker A: Really, I should give, I should use this to avoid having to type it each time. Trimap of that with this. Except it no longer has to be user friendly and it does this right thing. So so far, like this transition is going pretty nicely, I think. Like these are mostly mechanical changes because the types changed. Oops. Left right read handle tri trimap of inner with this thing.
04:36:02.119 - 04:36:42.220, Speaker A: And this map is no longer necessary read guard. Try map is destroyed. Is just handle. Dot is destroyed. This does a. This should be an entertain. That's probably fine.
04:36:42.220 - 04:37:15.109, Speaker A: This should be a, just a normal map. This should be an enter. All right, so now we need map redref, which is at least in theory, the last thing that we need. No read guard. That's true. Oh, there's no read guard. So what am I even doing? I can just use left right read guard.
04:37:15.109 - 04:37:55.320, Speaker A: Left right read guard is just gonna be read guard because there is no left. There's no read guard. Redefined in ev map. Now that's nice. So this can now use left right read guard as well. This holds a v read guard. Iter gets pretty close, except it doesn't need manually drop anymore.
04:37:55.320 - 04:39:30.570, Speaker A: Doesn't need to call user friendly anymore user friendly. So user friendly is just like a helper type that maps from things that are manually dropped to things that are just remove the manually drop. And that's because all of the read stuff only operates on, on shared references anyway, so there's nothing really for them to deal with. What else we got? We're getting pretty close, I think write rs 121. That's in 121 set meta. So that should just be add op operation set meta, meta. Why does this return m? Oh, it used to return the old meta, even though that's not really documented.
04:39:30.570 - 04:40:32.214, Speaker A: That's awkward. We're gonna have it not do that, although I did realize that. Yeah, no, that seems great. All right, what else we got? We've got something here in lib, right? New compile. So close read guard is private. Yeah, we're no longer gonna expose read guard. I guess we might wanna, yeah, we'll pub use left right read guard almost completely compiles read.
04:40:32.214 - 04:41:31.938, Speaker A: And I also want to do the same change we did here of moving read mod to read rs. So read read rs line 176. What we got here cannot borrow self handle is mutable, right? So this is definitely one of the big annoyances, right? That now with a read handle, all these methods now need to take mute self. Like get one. It's gonna take immutable reference to self. Get is gonna take immutable reference to self get raw. Like, this is what I was sort of trying to avoid with having, with having read handle not be sync.
04:41:31.938 - 04:42:26.422, Speaker A: And just having it do an immutable reference to self instead. In practice, it probably doesn't make too much of a difference because you couldn't alias a read guard anyway. So I guess we'll just have to keep this the way it was. But yeah, it is a little weird that a read handle requires you to have a mutable reference to self to call a given method. Huh, we're getting somewhere, right? 322. Oh, where is it? Trying to move. It's trying to move down on 405.
04:42:26.422 - 04:43:07.110, Speaker A: I love the compiler. This is gonna be refm. It's like, oh, you're trying to move out of this thing because here, nice. Write 134. Cannot borrow self handle as mutable. Right? We're gonna want to do this. Actually.
04:43:07.110 - 04:44:36.600, Speaker A: What do we got here? Cannot borrow is mutable self handle. So the right handle only gives us an immutable reference to its read guard. So it's read handle. But now that, that all takes mutable references, that has to implement draft mute. So down here we also have to implement draf mute, which is fine. There's nothing really preventing us from having that be safe, right, 549. No, the other.
04:44:36.600 - 04:45:59.250, Speaker A: Right. 549. Ah, so this is the downside of us doing all this wrapping is that it's not clear how we provide reads through the write handle in ev map because it only holds a right handle. And the right handle gives us access to a left right read handle, but it doesn't give us access to a EV map read handle. We could construct an EV map read handle, but then we wouldn't match the draft trade. One option here is to store our read handle ourselves here, but that seems ugly too. Hmm.
04:45:59.250 - 04:47:17.926, Speaker A: So do you see the problem here? So we have the, let me go back up the definition. So the right handle in EV map, all it really stores is a left right right handle. However, we would like for it to be possible, if you have a right handle, to call read handle methods on the right handle. And the way we did this before was that right handle would draft into a read handle. Unfortunately, in our case, the while we have a right handle, draft of this right handle will give us a left right right handle, not an EV map right handle, which means that the only methods you can call are the methods on a left right read handle, which is really just like accessing the, like, it's really just calling enter, which only gives you the non map specific methods, which is kind of sad. We don't really have a way to give you a EV map read handle from a write handle. We could provide you with a method that's like, call this, and it will create a read handle for you that wraps the inner one.
04:47:17.926 - 04:48:07.060, Speaker A: But it's not very nice to work with. We need an enter on right handle itself. Like, the other way to do this right is to have an r handle stored in the right handle, which is like a proper read handle, like this. It's a little unfortunate. It means we have an extra epic lying around, but it seems nicer than having to provide this, like enter functionality. Wait, why? Why does. Oh, I'm being silly.
04:48:07.060 - 04:49:04.420, Speaker A: Whoa. All right. Yeah. So with this, we can now have both draft and draf mute interetendle at the cost of storing sort of an unnecessary extra epic. So this is now going to target a handle, and this is going to give you a mutable read handle, and it doesn't even have to go through DRF. And now we're going to have to make sure that we construct that. These are all in tests.
04:49:04.420 - 04:49:59.878, Speaker A: I don't care about tests yet. Line 93. So this is gonna have to do an r handle, which is gonna be a, it's gonna be a read handle. Huh? How's this even gonna work? It's gonna be a read handle. New? Yeah. Read handle. New from handle, dot from left right read handle.
04:49:59.878 - 04:50:40.340, Speaker A: Clone of dereferencing handle, I think. Okay, that was a little bit of a magical incantation. But what we want to do is we want to construct a new ev map read handle that we can stick inside our ev map right handle. And the way we're going to do that is we're going to take the left right handle dereference it. So we get a left right read handle. Clone that left right read handle. So now we have an owned left right read handle, and then we construct a new ev map read handle from that.
04:50:40.340 - 04:51:53.180, Speaker A: The other way we could go about doing this is we could have like map the map methods of read handle be like a yemenite, a trait that we implement for left right read handle. That would also work, but it would mean that people have to import the trait in order to call any of our methods would be a little annoying. Yeah, it's annoying that right and write are pronounced the same in English and that the opposite of right is left and also wrong. It's a little annoying. Why do we need to clone? We need to clone because in order to construct a read handle, like an eV map read handle, an eV map read handle is a wrapper around a left right read handle, but it's a wrapper around an owned left right read handle. And the one that's, we can only get shared access to the one or mutable access, but we can't own the one that's already in the right handle. We can't extract it, so we have to clone it.
04:51:53.180 - 04:52:35.050, Speaker A: But this is cheap. Like this is just when you initially construct the right handle. So this is not an operation you do like all the time it compiles. Okay, so there's no longer a use for user friendly. That's good. Write no longer needs a bunch of its imports. That's good values no longer needs manually drop inner no longer needs manually drop lib no longer needs a bunch of things that are imported up here.
04:52:35.050 - 04:52:59.700, Speaker A: That's good. Love deleting code. Okay, so now we have ev map compiling as well. The tests will not, probably not compile yet because they rely on access to private fields in what are now in left right. But let's see. Let's do a cargo test. Let's do the lib test first.
04:52:59.700 - 04:54:12.946, Speaker A: Yes, you see, it depends on this refreshes field and on being able to look directly into the oplog. And neither of these are things that we currently have access to. 583 we got here that should be enter. Now. I think realistically these tests probably all need to be on left right instead. So if we take grab all of these, we're gonna left, right, right. And actually why not? Alright, so we're gonna do something wonky.
04:54:12.946 - 04:55:13.570, Speaker A: We're gonna do config test. We're going to impel absorb. We're going to have a enum counter operations. It's going to have add and subtract. And that's all it's going to have for now. Absorb counteroperation, counteroperation t for. You're going to have a struct counter also till, which just holds a t for.
04:55:13.570 - 04:55:50.336, Speaker A: Actually, I don't want this to be generic. What am I doing? That seems entirely unnecessary. This is just going to be for testing anyway. So we're going to impel counteroper, absorb counteroflation operation for I 32. Oh, we haven't implemented. We haven't implemented clear the drop first. We're gonna have to do that actually, but give me a second before I do that.
04:55:50.336 - 04:56:23.110, Speaker A: Actually let's do that right now before I forget. So remember there's a drop first method. It used to be that, that just called clear. So let's look at what clear does. Well, clear just adds the operation clear. I feel like that probably didn't work in the past because. No, it called clear on the map itself.
04:56:23.110 - 04:57:48.320, Speaker A: Hmm. And that's what we'll want to do here too, which is for drop first. We're going to want to do inner clear like this, that we don't drop values since we're only dropping the first child copy of each value. So actually drop first is pretty straightforward. Right. We again pull the trick where we transmute into manually drop so that when we call clear, clear is not actually going to drop any of the values, but it is going to like, well actually maybe drop first should not take a mute self but itself. But it's actually gonna be hard to do that I think.
04:57:48.320 - 04:59:02.724, Speaker A: Because where we call it, we only have a mute self. This is gonna be really annoying. It's gonna be real annoying. Hmm. Actually we don't need, well all right, let me try to explain what's going on. So when we drop a right handle, we now have two maps. One, and they have sort of clones of each other's data.
04:59:02.724 - 04:59:53.230, Speaker A: So we need to forget from one and drop from the other. We need to have a mechanism whereby we. Hair in my mouth. That was really annoying. We have to somehow tell the inner type, the absorb type that like drop all the things in this thing. Unfortunately we don't really have a good way of doing so because all we can give it is a mutable reference to itself. The reason for that is if we look at, right, and the implementation of drop the right handle.
04:59:53.230 - 05:00:38.930, Speaker A: All we have is a mutable reference to it. I guess actually we can make this be owned, come to think of it, because we've, we've swapped it out. We set it to null and we wait. Yeah. So we actually do know that. So we can actually take an unwrap here. And that way, that way we can actually drop first.
05:00:38.930 - 05:01:22.870, Speaker A: Yeah. So I think we want drop first to actually take self so that it can, so that it can actually drop the values safely. So here, drop first is going to take self. That's going to dereference self. And, and now over an evm up. Right. This is now going to be given self as we're going to cast self to that type.
05:01:22.870 - 05:02:25.830, Speaker A: We could even if we wanted to hear, and maybe that is a good idea, is to say that this actually gets a boss box of self. Oh, do we really want to forward through box here? Seems dumb, but yeah, I guess we do. Given that we're only doing this for box, we don't really need the macro anymore. This star is going to get weird for any type that's not box. So I think we're actually going to just do this straightforwardly. Unsafe impl t for box t. Or t is absorb that.
05:02:25.830 - 05:03:24.598, Speaker A: And now what we do is we transmute it to have manually drop. And then we don't even have to do anything. We can just drop inner. We don't have to clear it first because the value is already marked as manually drop. So notice that we, you could also unsafe manually drop drop in where we call drop first. I don't think that would work because remember we want to d. We want to actually run the destructor for the, the type itself.
05:03:24.598 - 05:04:57.466, Speaker A: It's just there might be alias stuff inside of the type like the values in the map that are aliased that we don't want to drop. All right, so now back to what we were doing for testing thing, which is. Ooh, yeah, I guess really this should be a manually drop box, not the other way around. Oh, manually drop into inner that. I'm sure there are other areas that resulted as a part of that. Yeah, fine. What, why does this.
05:04:57.466 - 05:05:46.318, Speaker A: Nothing expected reference box t. Oh, this. Ignore this. It's a silly error. Box into raw. I really want this to not be an inside of the wait function. We really shouldn't be like doing into raw.
05:05:46.318 - 05:07:04.460, Speaker A: It seems like it's probably a mistake. Like it's not actually a problem. It's just like a recipe for shooting yourself in the foot. Because here we, well, this means we have an owned, an owned box which means that if we happen to panic or something in here then we're going to drop that box and things are going to be set. Well I guess actually we can do manually drop of this. Why is this being annoying box. Oh, this is doing into raw.
05:07:04.460 - 05:07:35.360, Speaker A: What am I doing? I'm being, I think I've had been streaming for too long. This is not doing from raw, it's doing into raw. This is the part that should be manually drop new and this should not expected. Manually drop box t. Got manually drop box. Manually drop t. That seems annoying.
05:07:35.360 - 05:08:20.526, Speaker A: Why? That should just be, this is why. Alright, what else we got? Casting mute box t as mute. Manually drop t. That should be fine. Oh, that's awful. Oh man. Right.
05:08:20.526 - 05:09:09.670, Speaker A: This is now going to deref into a mute box t and then we have to deref it again. But I thought this would work, but apparently not. So w handle is a manually drop of box. It's an option manually drop box. So I guess let's do as mute. So that gives me, and then expect, so that gives me a mutable reference to an manually drop of a box. And then we need to dereference that twice.
05:09:09.670 - 05:09:32.240, Speaker A: Once to go through the three times. Once to go through the mutable reference ones to go through the manually drop ones to go through the box. And then a mute of that is a pointer to the actual t and then we cast that. Now that's obviously terrible. I mean the signature is healthier. Right. But it's really stupid.
05:09:32.240 - 05:10:19.060, Speaker A: But I'm surprised that the SDRF mute twice didn't work. Um, all right, I'm just gonna leave that there cause it makes me kind of happy even though it doesn't. Um. Censored swearing at the compiler. Yeah, you're not wrong. Doesn't star mute t implicitly cast to mute? Oh, it might, you might be right. I might be able to just do this.
05:10:19.060 - 05:11:00.260, Speaker A: Yeah, good call getting some implicit cast. Not that really helped the readability that much. But you know, ev map. Right. Rs drop first. So we missed something up here. Oh, that's in the tests.
05:11:00.260 - 05:11:56.370, Speaker A: Okay, so let's go back and see if that test passes for here in left, right, right. So I was in the middle of implementing this thing. So this one is kind of funny. So the operation can be either a counteroperation additive I, in which case we, we're going to do star self plus equals I or we're going to do a subtract minus equals I. And would you believe it? The implementation of absorb second is the same. I guess technically this is an unsafe. I don't know if this needs to be an unsafe.
05:11:56.370 - 05:12:40.970, Speaker A: I'm undecided whether that's necessary. And drop first doesn't have to do anything. So as draft mute twice shouldn't be the same problem as into into because Deref has an associated type target. So there's no type inference. Any type can only dereference into one type, which is not the same as into. All right, you're right. Because it's assigned you.
05:12:40.970 - 05:13:12.330, Speaker A: Because it's assigned, you can just add a negative number. True. I mean this to be honest. You know what, let's just, it doesn't matter that this is an enum. Like different types do not matter. So really we're just going to do this self plus equals operation zero. Great, even better.
05:13:12.330 - 05:14:12.390, Speaker A: And I guess this is now counter add auth. All right, so back to our write test. How about we have this test use. Wait, is there a new in the root? I guess there is, yeah. Penned opde. I guess we're going to also use counter add up. And then we're just going to counter add up 42.
05:14:12.390 - 05:15:00.240, Speaker A: And then we're going to check that our so r enter dot unwrap. We're going to search that that is equal to. And here comes the magic 42. Nice. And then we're gonna pin it again. That's fine. Oh, crate add up.
05:15:00.240 - 05:16:09.940, Speaker A: This doesn't need x, but this does need type annotations, which is going to be I 32 and an empty oblock. Actually, this is a good point to talk about associated types. So you'll notice that the absorb trait is generic over o. Another alternative would be to have an associated type here. So we could say operation is equal to type operation and then get rid of the o and there. These are both valid options. The decision comes down to do you expect that people will want to implement a the absorb trait using different operational types, but for the same type? Because if you expect people to implement absorb, like my op type one for hashmap and someone else to implement my oplog type two for hashmap.
05:16:09.940 - 05:16:47.608, Speaker A: If you do, then it has to be a generic type on the trait. If on the other end you expect any given type to only have one possible implementation of absorb, like an implementation of absorb for hash map will always use the same operational type. Then you make it an associated type. The the so. So having it be a generic type parameter is more, more generic like. It means you have more flexibility in what implementations you can have. The downside is that you need to have new, for example, needs to be generic over t and o.
05:16:47.608 - 05:17:35.940, Speaker A: If O was an associated type of t, we could get rid of this entirely, right? And new would only take one type parameter, which is the type of the, of the type that implements absorb. And so that that's more ergonomic because it's constrained to there is only one implementation. This is sort of what I was getting at with draft and into before that. Into is has a generic parameter of what type it can be turned into, which means that any given type can be turned into many different types. You can implement the intutate trait multiple times for a given type. Draft, on the other hand, does not DRef has an associated type target, and this means that you can only d ref a given type into one other type of. There's never an ambiguity, there are never multiple implementations.
05:17:35.940 - 05:18:32.820, Speaker A: And this means that sometimes when you call into the compilers, like I don't know what you want me to turn into, like there are multiple options here and you need to tell me. You often need to give compiler annotations, whereas that's not true for draft. For draft, you will never have to say what type to draft into, because there is only ever one choice for absorb. I don't know which case makes sense. I guess it's probably unlikely that people will want to bring their own like operational type, but it's not entirely unreasonable, right? You can imagine that someone wants to support specific operations on like hash map when the key and value is their type of. So I'm inclined to leave it at o for now. Which does sadly mean that new needs to be generic over o.
05:18:32.820 - 05:19:48.030, Speaker A: But at least now you know that that was a conscious decision, as that means that when we call new here, we have to specify the like comma underscore. The compiler can infer what o should be from what we pass to append op, but it can't infer what should be because there can be any type that can absorb a counter add op, which as far as the compiler knows, there might be many. Yeah, it does look weird. Fine, that better? Let's see here. I guess this is going to be like a penned op counter add up. 42 actually. That's why this was here, I think.
05:19:48.030 - 05:20:34.500, Speaker A: So that this value, when I check it down here. Oh, I mean, there's no real reason for this to be different then, because we don't actually check the output value ever. Right. Maybe the new function should have some information as to what it creates, kind of like channel or remember, normally you would use this as EV mapping. Colon. Colon new. Right.
05:20:34.500 - 05:21:06.050, Speaker A: So that's why it currently doesn't. 303. What I do here right now, the read handle has to be mutable. Okay, great. So the test and left right work. They don't do anything particularly interesting, but at least it checks that refreshes are happening. The real, like, big question is going to be around the EV map tests.
05:21:06.050 - 05:21:42.636, Speaker A: So let's go to EV map read. So these tests could, oh, some of these are very specific to EV. Oh, I guess this one is very specific to EV. This only needs to be mute. I think that should just work. So that's nice, right? So the EV map API has stayed almost exactly the same. Okay, so all the, the EV map like unit tests succeed.
05:21:42.636 - 05:22:25.912, Speaker A: They don't do anything pretty particularly interesting. But this is just, we didn't, like, majorly screw up somewhere. Now is where it gets really interesting, which is to run the full ev map test suite. And that's going to be much more of a pain, I think many of these, so these are the library tests for EV map. And I think many of these, it makes a lot of sense for us to sort of port over into port over into left, right. But we can keep them here for now. It doesn't like, because EV map hasn't really changed, it should be fairly trivial for us to port these over.
05:22:25.912 - 05:23:17.490, Speaker A: So, for example, anything that has calls read should instead call enter. Anything that has arcanous comma should probably be, oops, oh my. Anything that has r comma should probably be mute our comma. And that's probably going to make most of the test compile already. This apparently doesn't need to be mutable. This does have to be mutable. This doesn't have to be mutable, but the clone does.
05:23:17.490 - 05:23:54.294, Speaker A: This doesn't have to be mutable, but the clone does. And, yeah, so this is EV map is also set up with quick test. So that's probably going to account for most of the other compile differences. But the change here is fairly mechanical. 261 is probably another mutable thing. Yeah, this needs to be mute. What else we got? 223.
05:23:54.294 - 05:24:43.070, Speaker A: This thing does not need to be, oh, it definitely does. What else we got? This needs immutable reference to the read handle now. Immutable reference to the read handle. Mutable reference to the read handle. Oh, that's gonna be bad. I'm gonna skip. Oh, is that the only one? All right, what do we got here? A dot enter dot iter, dot map.
05:24:43.070 - 05:25:43.070, Speaker A: So this is one example of where it was kind of nice for read handle to only take an immutable, a shared reference because we could do things like enter but then also call get, which it won't really let us do anymore. Hmm. But to be honest, I don't know what this would even end up doing. I feel like this would end up doing something kind of stupid. The basic observation here is that if you call enter, you should be allowed to call enter again. Right. There's nothing really preventing you from doing that.
05:25:43.070 - 05:26:57.590, Speaker A: But in the current API, we are restricting the caller from doing this. If they call enter and then that takes immutable reference to self and it ties the lifetime of that mutable borrow into the read guard that it returns, which means that you can't then borrow again. But what we might be able to do is guard is a enter guard iter and guard get enter unwrap guard. So this, I think this is guard keys. I don't know why there's a flatten. Great. Actually that's not too bad.
05:26:57.590 - 05:27:51.610, Speaker A: I guess we are at like the six hour mark, huh? Quick test generates like random test inputs. Yeah. What's the meaning of m when you use percent sm magic? This makes, this makes Vim regular expressions interpret more things as special characters. I should really make that alias be using berry magic instead, but which is v. Oh, it does pretty well. Operation String did something weird, like 146 of course, of course. That's the one we just did.
05:27:51.610 - 05:29:26.790, Speaker A: Alright, so this is going to be if let some guard is this then guard else in the past this would actually here we want to assert. I see. So really what this is saying is that it failed to enter, which means the map has been destroyed, but it's already checked the, the reference map and the current map are the same length. So really if this is destroyed, that means we've already done the testing we need. Reference was empty, read handle was destroyed. So all is well, maybe return true. Something failed.
05:29:26.790 - 05:29:46.030, Speaker A: Oh, these are doc tests. That is a good sign when only the dock tests are failing. Yep. This needs to be muted. Mute. Hmm. Oh, I'm almost positive some of this is gonna be bad.
05:29:46.030 - 05:30:28.890, Speaker A: This is gonna be mute. Actually this is not gonna be mute. This is gonna be muted. This is gonna be mute. This is no longer true. Read handle is sync. Nice.
05:30:28.890 - 05:31:14.480, Speaker A: I guess let's do doc. The readguard didn't need mute self before because it was using atomics internally in itself to allow it to just take refself. The thing is, it doesn't actually need mute self because most of what it's doing is just operating on the epic counter anyway. Which is, which is anyway shared. Like you need to use atomics for it regardless. But it's sort of like hiding the fact that really it's mutating some state. It's a little misleading.
05:31:14.480 - 05:32:03.520, Speaker A: Right. Because when you see a read handle take mute self, you think that it mutates the map but it's, it has an immutable reference to the map. It's just as a mutable reference to its own internal state like the handle state which is a little subtle. What do we got? What else is failing book reviews are that does need to be mutable. What else, what else we got here? Right on line 32. That has to be mutable. 34 what I mean 86 that's very misleading.
05:32:03.520 - 05:33:12.750, Speaker A: Source lib rs line 34 Source librs line 86 I know it's because of doc comments having this is line 34 of the example but that's annoying. 86 no method read for strike. Ah this has to be enter. Nice. That's pretty promising. Let's run cargo miri test two. Oh, thought it was is miri like not available these days? I know there's been like a bit of ups and downs.
05:33:12.750 - 05:33:37.900, Speaker A: That's annoying. Tool state no. Tool state no. Miri is supposed to be building. Oh, it's missing on tonight's nightly. That's really annoying. Well all right that's fine.
05:33:37.900 - 05:34:06.430, Speaker A: I'll run Miri later. I guess the last thing we'll do a cargo clippy here. Oh, Clippy's just happy. Great. What about here? All right this is pretty nice. I guess what I'll do is I'll go ahead and, and commit all of this. Did I read, did I leave any todos? I did read left right read 126.
05:34:06.430 - 05:34:42.780, Speaker A: Oh, we already fixed that to do. Great. I guess we might as well get oh, EV map drive was using the wrong version but that's fine. It's easy enough for us to fix I think because derive cargo this can just be version eleven dot 0.0 alpha dot one. I think that's the version I've set. Yeah.
05:34:42.780 - 05:35:49.582, Speaker A: Why not run Miri on stable? It wouldn't install for me on stable but maybe I was doing something silly. This also says broken intradoc links. Oh, Nitkin is in. Um the mutable reference feels kind of unergonomic and it's a very breaking change. Is it possible to use some unsafe magic to take an immutable reference? It is. The trickier is going to be to use a, to use a cell and then keep track of how many times we enter. So.
05:35:49.582 - 05:36:31.350, Speaker A: Whoa. I really don't want to deal with that right now. I don't know why. Oh, the failing one is. Oh, man. Oh, the compiler has changed. Yeah, that's what we want to do.
05:36:31.350 - 05:37:26.688, Speaker A: Great. Yeah, I mean, I think we can do that pretty easily, actually. If we, if we really want to, we can do that. So that's going to be not guard, but. All right, so, okay, we have two options here. One is to keep the handle as usually taking immutable reference. And that makes these things nice.
05:37:26.688 - 05:38:40.274, Speaker A: And it also allows read handle to be sync. The other alternative is to do a little bit of cell hacking here, which would make read not be synced, but would allow it to take immutable references to self. That is, I mean, maybe it's worth it. It'll allow a bunch of internal complexity, but maybe it's not too bad. Basically what we have to keep track of is if you enter multiple times, you should still only reset the epic when the last thing gets, when the last guard gets dropped. Um, yeah, yeah, that's true. All right, so let's do that.
05:38:40.274 - 05:39:38.200, Speaker A: We might as well. So in that case, we're going to use cell. Cell and enters. And then we're going to do is. So enters is going to be a count of the number of times enter has been called without the guard having been dropped. So whenever that goes, if we call enter while that value is one or greater, then we do nothing. We just give out a guard.
05:39:38.200 - 05:40:29.640, Speaker A: And when we drop a guard, we check whether that value has reached zero. And only if it reaches zero do we reset the epic. All right, so in that case, my epic is going to be cell new zero. And enters is also going to be cell new zero. So let's see. If self enters is not zero, we have already locked the epic. Just give out another guard.
05:40:29.640 - 05:41:49.870, Speaker A: So actually this is tricky because I know we are preventing another swap. So this should be safe to do, which only happens when the last read guard is dropped. And then if it's. And then we're really going to do like, I guess an r hand. No, we'll just do it this way. This is just going to return. So we're just going to give out.
05:41:49.870 - 05:42:46.920, Speaker A: What am I doing wrong here? Because we know that a previous enter has happened, we know that we don't need to bump epic. The epic is already locked, so we can just read the pointer, cast it to a reference. If that, or if the pointer is none, then we just return none. And if that point, this shouldn't be possible. In that case we didn't give out a guard, so no guard was dropped. So this should be unreachable. If, if pointer is null, no read guard should have been issued.
05:42:46.920 - 05:43:44.748, Speaker A: Because if you look down here, it's only here that we're going to do self, dot enters dot I guess enters is self enters get plus one set enters. There's only here that we increment. We're not going to increment in the, in the else clause. So in this case we're going to do cell, we're going to do the same thing. Enters itself, enters get if enters not equals zero. And then we're going to enters set enters plus one. And the epoch here is just my epic.
05:43:44.748 - 05:44:23.500, Speaker A: Epic. I'm pretty sure let epic is read after it's incremented. So that's what's set there. So this is just self, my epic get. That means this is self plus one set epic. Great. It is funny that the struct has four fields that all say epic in it.
05:44:23.500 - 05:45:47.366, Speaker A: I can't use fetch add because this is cell. I don't think cell has fetch ad. It's not as far somewhere. Okay, so what we're missing now is, oh, what we're missing now is that the guard, when you drop a guard, I think really I want this to be a reference to self. That has to be a reference to self. The guard is going to hold a reference to oh, this is why I didn't want to do that. I don't want to have to give the type of the handle as an additional generic parameter to the guard.
05:45:47.366 - 05:46:40.000, Speaker A: Right, because the guard has the guard. T is the generic type parameter of the currently guarded value, which might be different from the overall type of the handle. We can get around this though by only giving it this information. It needs read handlestate, which is going to take this and it's going to hold a handle awful. It's going to hold an epic. I guess it's like shared handle own handle. So stupid.
05:46:40.000 - 05:47:46.330, Speaker A: And needs a reference to the enters. And this is going to now have a pub super handle, just a read handle state. And crucially, the only thing it's really leaving out is the actual pointer type, which is what gives read handle its tachyde. Remember we're going to do impl, oops, nope. And do impl from. Read from ah, read handle t for read handle state. Just to make it a little bit nicer to, to use turns a self.
05:47:46.330 - 05:48:44.640, Speaker A: This is why the mute version is nicer. Rh epic this should also not be called handle. This should be called epic. And the own epoch is going to be ra my epoch and the enters is going to be ra enters. That's going to be super. And I guess this old derivedebug. Sure, why not? And that actually works great.
05:48:44.640 - 05:49:58.100, Speaker A: This I guess is probably both copy and clone. Crucially, the drop is going to have to be let enters is self dot handle dot enters dot get minus one and then handle dot enters dot set enters. If enters is zero then we're going to do this which is handled dot shared epoch dot store is going to be self dot. This is also not right. I feel like we need to update our own epic as well. Here is your benefit to using cell U 64 over atomic u 64. Yeah, it avoids atomics faster.
05:49:58.100 - 05:51:05.096, Speaker A: All right, let's we certainly have to update the shared epic. This is going to be handle own epic. Oh my God. Epic is self dot handle dot ownepoch dot get. We are the last guard to be dropped. Now release our epic. So this should now be, I forget what it's called.
05:51:05.096 - 05:52:11.036, Speaker A: It's gonna be guard read. This needs to be pub super read handle state from self from self. And same thing down here. I remember why I even have my epic. It's because my epic is the current epoch with the high bit never set. So yeah, so the implementation considers the epoch number just be a number that keeps incrementing by one. It doesn't actually care about even odd.
05:52:11.036 - 05:53:45.720, Speaker A: And then it's using the hi bit is either set or not set for whether it's idle or active, I guess. So my epic here, the cell only ever holds the current like round, which only ever goes up by one. And so this is why when the guard gets dropped, we don't actually change the the cell U 64, the my epoch, because that one should only be incremented when you increase it. All we have to do is reset the idle bit. This could probably be made nicer by just having it be even odd, but it's fine. So crucially, what this enables us to do is that all? Did I already do that right? Is that in ev map ready? Yeah. Which also means that in read ref I thought, I guess nothing right now we're going to get a ton of warnings about the mutable stuff again.
05:53:45.720 - 05:54:48.300, Speaker A: So let's just go ahead and get rid of all those. We do still have to do the read change to be entertained. Where else, where else does this show up? Test quick. Nice. It is a lot nicer when reads can actually be reads. I'll still, keep this the way it was because that seems nice. What else we got? Right.
05:54:48.300 - 05:55:27.756, Speaker A: EV map ready. EV map map redress. Something's not right. Read rs 243. This doesn't need to be. Ah. All right, so cargo check.
05:55:27.756 - 05:55:43.160, Speaker A: Just check the lib for me, please. I guess. Cargo test, lib. So. Right, right. So that can go away. That makes me happy.
05:55:43.160 - 05:56:33.260, Speaker A: This is a really annoying. I'm pretty sure this is a really annoying issue. I think in cargo, where notice that the tests still require r to be mutable and that's because it relies on the previous build of ev map. I don't quite know why that is. Why it does that. That's real annoying. So I guess the only way I know of to fix this is either to clear your cache or to increment the version of the thing you're building, which basically just forces a rebuild of everything.
05:56:33.260 - 05:56:58.700, Speaker A: Still doesn't quite work. Okay, ev map test. Oh. EV map. Cargo. This is gonna have to use version zero nine one. Really? Why? I clearly missed the mute self somewhere.
05:56:58.700 - 05:58:01.742, Speaker A: But where is the real question? Well, we shouldn't need the draft mute anymore. We can still provide it, but it's less interesting. But why on earth am I blind? I am blind. What? Oh, Ev map read. That's. I'm dumb. There we go.
05:58:01.742 - 05:58:32.570, Speaker A: Alright, so I maybe lied, but it is a problem I've seen before, but I'm guessing it probably did not happen this time. Ooh, ev map. Right. Draft mute. We no longer need to import that. Which also means in left, right, we also don't need to import that. Let's see if the test pass again.
05:58:32.570 - 05:59:59.480, Speaker A: Fantastic. Okay, so now in theory, the diff we have now should be fairly small that we can ignore. Oh, did I not change that to not be alpha two anymore? I mean, I'll need to eventually, but cargo t dock, those should all be giving warnings, which I'm guessing are silenced because they no longer need to be mutable by here. What do we got here? Do you have any examples that we need to update here? No, I don't think so. All right, I think we're just about there. Yeah, that just changed from read to enter. That's fine.
05:59:59.480 - 06:01:17.410, Speaker A: I guess I should bring back the text about read handle not being sync source lib somewhere, I guess. Really it should go in the documentation for really, it should go in the documentation for left, right? Like I'm gonna have to write documentation for left, right? Anyway, I just haven't done so yet, and much of that is probably just gonna get like cribbed from cribbed, from ev mapp proper. That's something I don't think I'm gonna do on stream because my voice is getting hoarse. But it should also be fairly uninteresting, like, it's just moving text around. Operation now takes m, which is a little sad, but not too bad. I think we simplified the types of decent amount we removed the need for. Oh, we do need to bring back factory now because read guard is no longer sync.
06:01:17.410 - 06:02:09.056, Speaker A: That's a little awkward. Mmm. Yeah, I'm gonna have to bring back Reed guard factory, which is pretty sad. Not even sure where I would put that, to be honest. Mmm. I mean, Reed guard factory is the other reason why I want it to be, why I sort of like it to be sync. But I also agree that it's nicer for it to not take mute self.
06:02:09.056 - 06:02:31.390, Speaker A: I don't know. Reedguard factory is. Is pretty simple, though. It's just a bunch of like, mechanical restoration of what we had. I'm gonna leave that alone. This stuff didn't really change. I'm really just scanning through to see what, whether I missed any, like, mute arts or anything, but I don't think so.
06:02:31.390 - 06:03:03.576, Speaker A: Yeah, this changed to endpoint, but that's mostly uninteresting. That seems fine. That seems fine. All right. I think we're good. I think that's all I wanted to do for today. I'll take some time, probably offline, to, like, tidy this up and like, right up the docks and release left right distance as a crate.
06:03:03.576 - 06:03:30.962, Speaker A: But this suggests that this actually works, that this approach of having a generic left right wrapper type works. And what's neat is that once I land this, you'll be able to use left right to provide your own types that you want really fast read concurrency for. But you're willing to say that there's a single writer. Whew. I need to go eat some food and drink some water. Thanks, everyone, for coming out. I hope it was interesting.
06:03:30.962 - 06:03:50.162, Speaker A: I know it ended up being a pretty long stream, but that was sort of the intention, right? For this to be a, like, serious live coding stream again. I see we still have a decent number of people with us. No benchmark. That's true. But remember, like, benchmark wise, there's no reason to believe that this would change anything. Because we haven't changed the algorithms. Right.
06:03:50.162 - 06:04:24.052, Speaker A: The algorithm is the same. The only reason why anything would slow down would be because of, like, generics not being monomorphized. But generics should be monomorphized. It would be like crossing crate boundaries, which could matter in terms of ev maps. Specifically, I would say it probably doesn't matter because the concern is about the scalability of reads. If each read is a little slower, that doesn't bother me. Hopefully it isn't, but that doesn't bother me.
06:04:24.052 - 06:04:57.890, Speaker A: What bothers me is the curve. If we're no longer linear, like if the read performance is no longer linear in the number of readers, that would be a huge problem. But because we haven't changed the algorithm, that shouldn't make a difference. I will point some benchmarks at some point, but you could maybe use bustle to benchmark this. You could try, I don't know, give it a try. I'll probably post this as like a work in progress pr so people can look at it, put it on GitHub somewhere. But apart from that, I think we're done for today.
06:04:57.890 - 06:05:04.330, Speaker A: Thanks for coming out. Hope you had fun. Hope it was interesting and I'll see you next time, probably in like a few weeks. Bye everyone.
