00:00:02.800 - 00:00:45.354, Speaker A: Hello folks, welcome to yet another one of the long coding streams. This is part two of the video series where we implement hazard pointers. I almost call them haphazard pointers, which is not right, hazard pointers in rust. I'll give a little bit of a recap from last time and sort of where we ended and where we go next, but a little bit of housekeeping. Just first I decided to sort of start a subreddit. I don't know whether I'm going to use it yet. It's just r John who I figured this might be an easier way to sort of post updates for people who aren't Twitter people, or where you want more structured discussion or something.
00:00:45.354 - 00:01:06.174, Speaker A: Maybe I'll do some q and a here. I haven't quite decided, but this is now a thing that exists, and you can go look at it if you want to. There's not too much of interest there right now. Also for the stream. So Neovim 0.5 was released, which is really cool. I'm excited for it because it includes native support for the language server protocol.
00:01:06.174 - 00:01:46.892, Speaker A: And so I have upgraded to Neovim Zero five. I have changed my configuration to use this to integrate with rust analyzer. I haven't tested it very much, so we'll see on stream to what extent this will work, whether it'll be better than the old setup. I have. I haven't checked in the configuration yet because I'm not sure I'm done with it yet, but this will be a nice beta test of that functionality. I'm using it with like Nvim, LSP config and stuff. There's a decent amount of configuration to change, actually, especially if you're coming from something like CoC neo vim, like I was.
00:01:46.892 - 00:02:57.424, Speaker A: It's a little bit different. All right, but how about we start where we left off? So last time we started writing this library that implements hazard pointers, and I won't go over what hazard pointers are that sort of covered in part one, but basically there's this paper from 2004 on how to use hazard pointers to do safe concurrent memory reclamation. The idea is that if you have a highly concurrent data structure in particular where you need to deallocate memory, deallocating memory is non trivial in a concurrent setting, and so you need something like hazard pointers. There are other schemes too, but this is the one we, we decided to implement to safely do that, memory reclamation. So we wanted to write a library that implements that algorithm for you, and we ended up calling it haphazard because that's a fun name and it has hazard in it. We got pretty far last time, so we managed to sort of run a test that doesn't crash and it checks that things actually get dropped. It's not super rigorous yet.
00:02:57.424 - 00:03:45.820, Speaker A: We know that there are some atomic barriers, for example, that are missing. We know there's some functionality missing around having like custom domains, domains, if you remember, is each hazard pointer and allocation is associated with the domain. And there's sort of a global domain that everyone can use. But you might want a local domain for something like a data structure where you want the collection of garbage to not have to sort of contend with collection from all of, all concurrent deallocations in your program in general. And this is what the documentation from the library we're basing this on says too. In general you won't really need this. Like most people should just use the global domain, but we'd like to implement support for it anyway.
00:03:45.820 - 00:04:35.674, Speaker A: The library we're basing this on is out of Facebook's folly library, which is an open source sort of data structure and algorithm library. It's great, there's all sorts of stuff in there. But in particular they have a pretty solid implementation of hazard pointers. It's well documented and it also forms the basis for a proposed standard that I think they wanted to get included in the c standard. And so we'll sort of switch back and forth between using the proposed standardization document for reference and using the actual code that they sort of serve different purposes. And we end up using both for this. So that's sort of where we ended off.
00:04:35.674 - 00:05:30.248, Speaker A: I think that the places we want to go next are we want to get all the sort of atomics right. So this includes both getting the barriers in place and choosing like memory orderings that aren't necessarily just sequentially consistent. And then we also want to get multiple domains to work. Ideally. We also want to figure out a way to provide just better ergonomics for this. In rust, like currently our interface pretty closely maps onto the c one and I think we can do a little bit better. In particular, I want to make sure that we take advantage of the type system to do things like make sure that you can't, for example, accidentally use a hazard pointer from one domain with a, with an allocation from a different domain.
00:05:30.248 - 00:05:59.806, Speaker A: These are things that like we can have runtime checks for them, but it would be nice to have some static checks too. And even just like making the type signatures nicer and giving them better names are things we're going to be looking at. I still have some questions in chat. Let me see those real quick. Great. Nothing too relevant. So after last stream, it seems a decent number of people were just interested in the code bases, wanted to dig into it.
00:05:59.806 - 00:06:55.170, Speaker A: And one great thing about having people look at your code is that they found problems. So in particular, there have been three, well, a little bit more than three, technically, but three relevant prs posted to the haphazard repository already that identify actual problems with the implementation that we had. So I figured I would go through those quickly because we should just merge them and get those, get those into the, into the code base before we keep going. The first one here is, if you'll remember from last time, we, we added this, this feature, if you will, of reclamation, where it can sort of recurse. And we wanted to make this potentially tail recursive. So we pass in the start the thing, the number of reclaimed items to start counting from this. This is what allows tail recursion, because if you add to the count after you return, you can't tailor curse.
00:06:55.170 - 00:08:20.128, Speaker A: Unfortunately, when we did that, the, we, we sort of computed the total number of reclaimed items as, like, we just added to that counter, but we still subtracted the total number from the count we keep of number of retired items, which of course becomes a problem because this reclaimed number includes the ones that we subtracted last time around. So we end up double subtracting them. So this just fixes that up so that we only subtract by the number of items that we reclaimed this time around. So I'm going to go ahead and merge that like so. That's great. The other one is the entirely correct observation that we remember we have this deleter trait, and on deleter, we have a delete function that just takes a sort of a vtable trait object through a raw pointer, and its job is to drop it. And the idea would be that if all of your allocations that are guarded are created with box, for example, then you need to like box from raw to reconstruct the box, and then drop the box so that it gets to run its own deallocator, which is going to free the underlying memory.
00:08:20.128 - 00:09:09.359, Speaker A: Of course, this itself is an unsafe operation, and the trait method should be marked as unsafe because otherwise, remember, we exposed this drop in place function closure, but we expose this as not an unsafe, even though internally it uses unsafe and relies on the safety guarantees of retiree. But that is an unsafe property, right, like that. That is a requirement of the caller, that the caller is retire, which doesn't necessarily hold. And so we need to propagate the unsafety up here. And so this just marks the trait function as being unsafe. And that's great. So I'm just going to go ahead and merge this too, because this is a correct and good change.
00:09:09.359 - 00:10:21.180, Speaker A: And then finally, remember how the actual hazard pointers are sort of cached over time. So even when a thread stops using a hazard pointer, it doesn't actually deallocate it, it just marks it as inactive, but leaves it in this linked list of hazard pointers so that other threads that come along don't actually need to sort of modify this linked list to do allocations in order to get a new hazard pointer. They can just take one that's currently inactive. Well, when we walk through to look at which pointers are guarded, we should skip hazard pointers that aren't active because they're not actually guarding anything. Otherwise we're going to be checking them when they're not, they shouldn't be checked because they're not used by anyone anymore. And so this just changes that loop that walks through and sort of collects all the guarded pointers so that it only guards active pointers. So we're going to confirm, merge that one.
00:10:21.180 - 00:11:11.696, Speaker A: Great. If you remember from last time too, I should have prepared these, but I did nothing. Let's see, author John, who maybe we filed two issues last time, two which were this one. So actually, let me go pull this code here. I just left some diffs here for myself to remember to merge these prs because things are clearly not okay. So let me go ahead and get rid of those ones. And this I think is something we need to fix manually.
00:11:11.696 - 00:11:37.626, Speaker A: And this one we fixed in prs. Yeah, I thought of some problems too. And we're going to move that one down there and then do that. Great. Yeah, so if you remember, oh, this is maybe a little too large. There we go. Yeah, like the text is going off screen.
00:11:37.626 - 00:13:22.732, Speaker A: So I'm sorry, I'm gonna have to make it a little bit smaller. We have this annoying problem where for the deleter trait, we implement deleter for just freestanding functions. But unfortunately if you have, let me dig this up down here, it's easier to show if I show the actual code that calls this man, where is my call to this? Ah, so retire, if you recall, takes a din, deleter sticks that into the, the retired objects, right. And the retired objects down here take sort of call the delete method on the deleter that's passed in. And the deleter trait is implemented for freestanding functions. But what we want to do is provide a, a function like Dropbox. Unfortunately, function definitions like Dropbox here are not equal to function pointers, which is this type.
00:13:22.732 - 00:14:06.230, Speaker A: And indeed the, the type that we implement the deleter trait for, we implement for function pointers, not for function definitions. And that's what requires is like not very nice static in the middle here to sort of do that cast for the user so that they don't have to think about it. We filed an issue about this seems sad, and there was actually a really interesting discussion that followed about whether this is the right thing to do. Ultimately, it's not entirely clear whether the compiler could just do this cast for you, whether this should be an implicit cast. I highly recommend going through and reading this discussion. I thought it was interesting. I learned some from it too.
00:14:06.230 - 00:15:31.220, Speaker A: I think for now we're probably going to keep this interface in place, because it does mean that the drop in drop box, the fact that we declare the static that does the cast for you means that users can just pass in a sort of deleters colon, colon Dropbox, rather than having to do the cast in their call to retiree. So that's really nice. The other thing that we filed an issue on was this, this drop bounce lint. So if you recall, for has pointer object, we say that anything that implements this trait needs to implement drop. And the reason we say that it has to implement drop is because we need to be able to turn it into a trait object that has the drop method. Because ultimately when we retire any allocation, so anything that is a has pointer object, so something that can have a hazard pointer point to it, we need to be able to drop it later on. And we want to treat it as a traitor object so that we can keep sort of heterogeneous collection of all of the objects that need to be dropped, regardless of what their original type was.
00:15:31.220 - 00:16:11.676, Speaker A: And it's a little bit silly because you can really take any type and turn it into a trait object, and it will always have the drop function on it. Like every vtable for any trait always contains the drop method. But normally if you do this, if you don't have this allow, if I remove that, in fact, let's see whether. Nice. Okay, so I do get a warning. It says the bound self drop is useless, even though if we remove it, the compiler complains you can't turn this into a trait object because it's not guaranteed. The self implements drop.
00:16:11.676 - 00:17:06.110, Speaker A: And so we added this, this bound, and then we added this allow drop bounds. And like the warning is clearly wrong. Like the trade is trade bind is not useless. And that's some of what this discussion sort of came down to. But one interesting observation that came up here, and in the sort of linked pull request that tries to improve the warning, was that like in some sense the link is it is getting at something, which is, and this is something we noticed ourselves, this drop bound shouldn't really be necessary. It's not really the right thing, because even though it's true that you can drop any object, the drop trait is only implemented for a certain subset of types. And really here we want to accept any type, but then we need some way to turn it into a trait object that we can call drop on.
00:17:06.110 - 00:18:02.312, Speaker A: And this is why we had to add this like unnecessary implementation of drop for our object wrapper type. We had to implement that drop because otherwise this wrapper doesn't implement drop and can't be used as a has pointer object, even though it doesn't do anything because it just calls the inner drop method. And what came up in that discussion, which I think is a pretty decent suggestion, was basically to add a new trait with a blanket implementation. So what we do here is we find the, I also really need to split up this file because it's getting a little bit unmanageable. So has pointer object. What we're going to do is we're going to add a new trait called retire or maybe even reclaim. That trait has no methods.
00:18:02.312 - 00:18:51.680, Speaker A: We're going to implement reclaim for. Net. And then we're going to say is that this is going to require that the type implements reclaim, which we know is true for any type, right? Because we have a blanket implementation for all types, then we can turn this into a DIN reclaim. And because claim has no methods, this doesn't meaningfully create a larger vtable, but it will include drop. Because remember, every trait object vtable, in fact every vtable includes drop. Close enough. And so now if we go to retire, we say that this has to include a dinner claim, which then in turn means that.
00:18:51.680 - 00:19:13.200, Speaker A: Where is it complaining over here. So I want to go to definition. That worked nice. So this is going to take a dinner claim. Deleter is now going to be given a din reclaim, and this is going to be a dinner claim. This is going to be a dinner claim. This is going to be a dinner claim.
00:19:13.200 - 00:19:42.984, Speaker A: This is a dinner claim. This is a dinner claim. And in some sense reclaim here is like an alias for drop, right? It has no methods, it doesn't provide any methods, that's just what it does. Cannot find. Right. So this needs to use super reclaim din drop. Okay.
00:19:42.984 - 00:20:45.700, Speaker A: And now this impl drop for, for the wrapper is gone. And we no longer need this dropbound lint that can now go away because it will no longer trigger. So that's kind of nice. And I, I thought I left a to do for myself here, so let me go ahead and just commit this. So we're going to say here is avoid din drop like so. And then I'm going to stash pop because I had some notes for myself in here. So this is another sort of error that I realized after the stream ended, which is in retire.
00:20:45.700 - 00:21:35.398, Speaker A: This is the rumor. This is if you're trying to deallocate an object, like you've removed it, you've unlinked it from the data structure, but there might still be readers of handles to it, so you're going to sort of retire it. Bye. Sticking it into the collection that's later going to be reclaimed. We added this optimization where if the type doesn't need drop that, then we might, then we just return. Now, this isn't quite accurate because like technically it might be that the pointer type needs to drop, right? So the example would be a box u eight, right? Imagine that the, the actual object type here is a box u eight. So this, this star mute is a box turned into a raw pointer and self is a u eight.
00:21:35.398 - 00:22:08.128, Speaker A: Well then u eight doesn't need drop. So we would return, but then we wouldn't call retire, which means the raw pointer would never be turned back into the box. So the box would never be dropped, so the memory would never be free. So we end up with a memory leak. There are two ways we can deal with this. One is we just remove this optimization and have it go through the normal procedure. The other thing we could do is we could say, and like deleter dot needs drop, right.
00:22:08.128 - 00:22:50.512, Speaker A: And to sort of add a method to deleter that says, does this pointer type require dropping? I think in practice we should just let it go through the machinery. Like, it avoids the extra complication on deleter, it avoids the extra complication of this method. It sort of means more things use the same logic, which tends to be better. I think in reality it's like unclear that you would ever really get here. In general, the pointer type is just going to require drop. Like, because you have to turn it into a raw pointer. The only cases wouldn't be is like if it's already like you're sticking stack pointers into atomic pointers, which is already pretty weird.
00:22:50.512 - 00:23:17.980, Speaker A: And in that case, I think it's fine to just go through the retire. So I'm just going to get rid of that logic. Oh, that's nice. And then I think I left one more to do or xxx or something. Right. So this is, I think I definitely need to zoom out more because I can't even. Whoa.
00:23:17.980 - 00:23:55.518, Speaker A: Okay, that's fine, I guess. This is actually a good size because this is 100 characters, which is what rust, the rust format spec dictates is the right, like, wrapping size for text. Yeah. So I wrote a note to myself, this is clearly not okay. Readers may still be accessing the nodes. We can't take ownership until we verify it's not guarded. What about panic? So to recap what this code is doing, this is we're trying, so we have a collection of objects that have been retired, so they've removed from the data structure and we're trying to figure out whether or not we can reclaim them.
00:23:55.518 - 00:25:05.380, Speaker A: Can we actually drop them? Which is only the case if the, if no readers, like, basically, if no one has a pointer to the element anymore, is it no longer guarded by any hazard pointers? And so what we're going to do here is we're going to walk through all of the nodes and then we sort of grab the node into, into a box. Then we check whether, whether any of the guarded pointers had that pointer in it. And if that's the case, then it's not safe to reclaim the node. And we, we do this, we turn it back into a raw pointer and stick it onto the remaining tail, and otherwise it's no longer guarded and it's safe to just drop the box. The problem here, as I tried to sort of articulate in the comment, is what happens if there's a panic here? So imagine that. What's a good example of this? Maybe we're guaranteed no panics here, but I just don't trust that that's the case. Like imagine that guarded pointers contains panics for some reason.
00:25:05.380 - 00:26:00.290, Speaker A: I don't know, there's a weird draft implementation in there. Or just like we did, there's like a bug in the hash map, whatever it ends up being. If the code panics anywhere between here and here, we have a problem because we've turned the node into a box, which means that we're claiming that we own it. And a panic, at least if it unwinds, is going to drop all local variables, and that includes it's going to drop this box even though it could be that we're, in this case, where there are pointers, there are hazard pointers guarding that box, and so we're not allowed to deallocate it. We don't actually own it. In fact, this claim is just false, right? It's not true that we know that we own this here. And if you remember, I have a video, I think it's called like the unsafe Chronicles on box.
00:26:00.290 - 00:26:46.872, Speaker A: Basically, you're not allowed to construct an aliased box. So you're not allowed to construct a box unless you actually, actually have exclusive ownership to the underlying value, never mind using it. You're not even allowed to construct one, which is what we're doing here. We're constructing one even though someone else might already have a shared reference to node. Think of this as this is because box internally contains a unique pointer, and unique pointer has optimizations, assuming that no one else has that same pointer. But that's not true if this is shared. So in reality, what we need to do here is we have to do this right.
00:26:46.872 - 00:28:02.350, Speaker A: So it's totally safe for us to take a shared reference into the node. That's totally fine because we know that it hasn't been deallocated because we're the ones considering deallocating it. So that can go away. And what else here? I think actually what we're going to do is say unsafe node, call that NDE, and then we're going to do is only in the case where we know that it's okay. Are we going to take back the n? So here, end pointer, that's fine. Not safe to reclaim, still guarded. So here I think what we need to do is actually say n, dot, next dot, store remaining and same here.
00:28:02.350 - 00:28:53.140, Speaker A: And then remaining is going to be equal to node. Oh, I see. So this is going to be, hmm. So here what I'm going to do is say current is equal to node, and then this is going to set remaining to current. Right. So the idea here is we're walking the list of nodes. We're looking at the current node, we're setting node to be the next node because we're iterating, right? So we need to move on to the next node at some point.
00:28:53.140 - 00:29:56.066, Speaker A: And in the case where we can't reclaim this node, what we need to do is make sure that the node goes back on the list of nodes that are still remaining, still retired, but not reclaimed. So we store, we set the next pointer of the node that we just sort of unlinked to be. I guess we didn't un yeah, we unlinked it because if you remember here further up, what we do is we sort of, we swap out the head of a retired list. We sort of steal that whole list for ourselves. And so now the steal list is, sorry, the retired list is empty and we need to, anything that we don't end up reclaiming we have to stick back on the retired list. So that's what this remaining list is for. As what we do here is we walk all the things that we stole, right? So this is, we take the current node, we find the next node because that's what we're going to iterate over next.
00:29:56.066 - 00:31:31.844, Speaker A: But in this case we need to stick the current node back onto remaining, so it eventually goes back onto the, onto the retired list so that we can try to reclaim it the next time around. And then only in this case is it okay for us to deallocate the thing. So I think here, I think here what we're going to do is let n is unsafe from current, so no longer guarded. So here the safety for this is current has no hazard pointers guarding it. So we have the only remaining pointer and the safety for calling delete. So this box from raw is for the, remember that there's sort of two parts here, right? There's the data that was actually stored in the atomic data structure. That's end pointer.
00:31:31.844 - 00:32:11.450, Speaker A: And then the box recurrent is sort of the, the node on the linked list of elements that were retired. And that one we have to deallocate as well. So that's this part up here. So the safety here is that endot pointer has not yet been dropped. Has not yet been dropped because it's still on the retired list. It will not be dropped again because we have removed. I guess let's actually make this a list.
00:32:11.450 - 00:32:55.440, Speaker A: That's a good point. It will not be dropped again because we removed it from remaining. Not from remaining from retired. It was still on retired. It will not be dropped again because we removed it from retired. And end pointer was allocated by the corresponding allocation method as per the safety guarantees. Safety guarantees of calling retire.
00:32:55.440 - 00:33:47.000, Speaker A: Great. So that's why it's okay for us to call, call, delete, and then reclaim plus equals one. And just to check that that's not entirely insane. The test tweets still passes. So let's see here. Also deallocate pointer pointer type. So maybe this should say deallocate pointer type even if self doesn't need drop.
00:33:47.000 - 00:34:52.209, Speaker A: Let me see if I can deallocate pointer type even if self drop pointer type even if self type doesn't, ah, drop pointer type, even if self doesn't need drop. There we go. What I was trying to do is, in general, the, the first line of a git commit should be 72 characters. So you see, if I make it longer, you see how the characters on the right turn red. The later lines can be, I think, 80 characters, but the first one should be shorter so that it like fits an email subject and whatnot. There are sorts of conventions for what these rules should be, and I try to stick to them when I can. And then the other one here is, don't construct a box until it's safe.
00:34:52.209 - 00:35:32.732, Speaker A: Great. So let me go ahead and push that just so I have less of a dirty local change. All right, so now I think we're sort of at the point where we have all the things we did in the last stream, plus fixes for things that were buggy in the last stream. So this was sort of a, we went through a bunch of things. We sort of, we didn't really do a ramp up, we just sort of jumped into problems from the end of the last stream. Let's stop for a second and take like questions on how do we get here? What just happened? Remind me what these things are. I'm sure that if any of you are like, I don't remember this thing, there are probably many others.
00:35:32.732 - 00:36:19.430, Speaker A: So let's do like recaps of things that are unclear that people don't remember. Why not a const rather than a static for the deleter, I'm guessing for this alias. Can this be a const? This can probably be a const. You're right, it might not. It might not actually, because it needs to be. Oh, maybe it can be. I was thinking it had to be a static, because we actually need the address of this.
00:36:19.430 - 00:36:54.866, Speaker A: Like it's stupid. But up here we implement deleter for a function pointer, but delete takes a reference to self, which is a reference to a function pointer. So we need an address of a function pointer, which const doesn't give you. Right? Consts don't have addresses, at least not in the general sense, whereas a static does. So that's why I was thinking it might have to be static, but maybe not. Maybe it'll just let me have this be a const. If so, I don't quite understand why this actually came up in the discussion on the issue too.
00:36:54.866 - 00:37:53.064, Speaker A: Like why does the compiler allow this cast if you make it explicit? Like where does the address live? Where is this reference? Right. The function pointer is the function pointer. But what is this a reference to? If this is a constant, or in the case of an explicit cast, it's not clear. Like does the compiler just generate a reference for you? Something weird is going on, but nice if it can be a constab. Why, when I'm returning a string literal, it doesn't recognize it as a tick static automatically. In rust you have to be explicit about lifetimes, otherwise they're inferred. So the function signatures that's given as like fn str like for this inference is usually what you want for lifetimes.
00:37:53.064 - 00:38:45.530, Speaker A: Like in general, you're not going to have a function like this in general, the rule is that output lifetimes are tied to input lifetimes. That's what the inference is. It's not going to look at the function body in order to determine whether this should be static or not, because that would mean that if you change the function body but not the signature, the signature might change and you don't want that property. You can make your own drop trait that's always implemented. Yep, that's basically what we did for I really need to just split this file up. I should just do that now for reclaim. When would drop not be implemented for a trait object? So drop is not implemented for a bunch for types that, or rather drop is only implemented for types that have an explicit drop implementation.
00:38:45.530 - 00:39:51.850, Speaker A: So if you have a, if you have something like a struct foo t, right. This type does not implement draw even if it contains a type that itself implements drop, like struct bar impulse drop for bar, and drop self, right? So if I now do buzz is foo bar. So bar implements drop even though it doesn't have to do anything. Foo does not implement drop, and even foo bar does not implement drop, even though foo bar does have to be dropped. It doesn't implement drop because it doesn't have an explicit implementation for drop. But if you construct a trait object over a foo bar, or indeed over a foo, that v table will always contain a drop method regardless of whether foo implements drop. And this is why this trick with the the trait which I believe.
00:39:51.850 - 00:40:54.572, Speaker A: Oh, you're right, this might not even be necessary. I might even be able to get away with not declaring that bound because it's implemented for any type. That's nice. Although it does need to be pub for these drop in place things to be pub. So I'm just going to leave it a pub. The other reason to leave it as pub is because it is easier to document why not use din any we could use din any, but din any has a slightly larger vtable because it needs to include the type id in there and there's no reason for us to really use any here. I also think, and maybe I'm misremembering, but I believe the any trait, yeah, any is only implemented for t's that are static, and I don't want that requirement for this type.
00:40:54.572 - 00:41:52.550, Speaker A: There's no need to have that requirement in this case. I guess I can close this and I can close this, and I guess I should make this be appearance dark so that people don't yell at me. I'm still a bit confused why you needed to define reclaim. I suppose using din any again because of the static bound that's required by any. Does Rust's const behave more like C const, Eva or Constexpr? Not sure. In general, as in I don't, I'm not sure what the difference between the C ones are, so I can't really speak to that. A const in Rust is generally a compile time value.
00:41:52.550 - 00:43:00.116, Speaker A: Like it's, it's computed at combine time and, and it's effectively replaced in every place that you use that constant at compile time. It doesn't have a location in memory. So is there a linked list of guarding pointers for each element of the data structure that as b that is being protected? No, there's a linked list of hazard pointers globally or associated with each domain, but think globally. And those hazard pointers can point to any pointer to guard that pointer from deallocation. And so if you have a data structure, like, I don't know, a b tree or something, what you would do is the readers would take a hazard pointer, sort of point it at the node in the b tree they're currently looking at. And that way they prevent that node in the b tree from being deallocated, but they could also point it at a location in a completely different data structure and guard that from being deallocated. So what's nice about the hazard pointers is they're not tied to any particular data structure or need any particular instance of a data structure.
00:43:00.116 - 00:43:57.650, Speaker A: They're just sort of, I'm guarding this pointer and then it's up to the, the thing that drops to make sure to sort of check with the list whenever they're about to drop something. All right, great. So I think then we're in a pretty good position here. What I'm going to do is I'm going to go here and first get rid of these. So we're going to say drop helpers can be const. And I'm going to add this because I not entirely sure where the address comes from for itself. Reclaim has blanket impulse, so not needed in where.
00:43:57.650 - 00:44:34.890, Speaker A: That's great. Push those two just so we have them out there. And then what I want to do is before we start doing anything more serious about this implementation, I want to split it into files because there are too many things. So what we're going to do is go ahead and take. How am I going to do this? I'm going to say that we want to split this into. Oh no, I've remapped my, one of my key bindings that I use for other things. That's fine.
00:44:34.890 - 00:45:45.010, Speaker A: So I want to edit a source. I guess we'll use the standard names for now. I still think that what we're going to do is replace most of the names mod Holder and we're going to go ahead and move all of that into here. And then we're going to take, I guess pointer, rs mod pointer and we're going to take this bit and put it into here. I'm going to take mod deleter or deleters, maybe deleter, haven't decided yet. That's going to be source deleter delete because the RS is implied. Great.
00:45:45.010 - 00:46:14.490, Speaker A: And then I guess pub use deleter deleters. And we want to pub use holder. House point holder. And we want to pub use pointer. Has pointer. And what else do we want here? Oh, right. We also need pub use deleter.
00:46:14.490 - 00:46:55.540, Speaker A: What else we got here? Haspointer domain. So we're going to have domain, rs and stick. Let's go with 6100, maybe 2052. So that's going to go in here. Mod domain and here we're going to pub use domain, has pointer. Domain. Bring that into here.
00:46:55.540 - 00:47:47.590, Speaker A: I didn't save that file. What else do we have in here? These are private things that go into domain. So those are going to go at the bottom there. There are a bunch of uses that are going to have to be in here and I'm just going to stick those into each of the files because it's easier to remove them than to have it complain about nothing existing. Great. This needs create has pointer and I guess shared domain for now. Although realistically this is probably going to take from the actual, this is going to construct a hazard pointer holder.
00:47:47.590 - 00:48:08.274, Speaker A: You're probably going to have to do that from a domain anyway. But for now we're just going to have it use that and then we can trim these down to only the ones we need. Beautiful. Same thing here. This is not needed. These aren't needed. That I'm going to find out soon enough what it's complaining about.
00:48:08.274 - 00:48:30.560, Speaker A: This needs reclaim. I guess reclaim can go in deleters too. That makes sense. So that's going to go in here. And this in fact needs none of these. Wow, very standalone file. That's nice.
00:48:30.560 - 00:49:55.900, Speaker A: Hazard object. So I guess it's going to be mod object and again it's going to take all of these so that we have them and we're going to pub use object, has pointer object and in fact we're gonna stick the wrapper in there too because we might as well remember the, the wrapper here is anything that's guarded by a hazard pointer needs to be sort of dropped in a special way. And so basically there needs to be a sort of back reference to the domain so that you know when you're going to drop the thing that's behind the atomic pointer, you need a pointer back to the domain so that you know where to do the dropping because you need to like retire it and then reclaim it. You don't get to just drop it in place. And so this is why we have this haspterobject that has the retire method which is when you call, when you removed something from the data structure. And we want people to be able to implement this trait themselves so that they don't necessarily have to use our wrapper type, but we provide this wrapper type for those who want it. So we can take this and stick that in here too.
00:49:55.900 - 00:51:10.000, Speaker A: And then this can be this and has pointerobject wrapper. Nice. And these tests could probably just be standalone tests. Actually the shared domain is a good question. I think I want the shared domain to be in lib probably no, let's move that into domain as well so that can go away. And then I guess what we'll do here is this probably has to be pub crate is my guess because we're going to have to use that from some of these other ones. All of the tests we're going to move into their own files because let's see, because that way changing a test won't have to recompile the whole program.
00:51:10.000 - 00:52:17.290, Speaker A: Haphazard. Haphazard, great. And just for good measure I'm going to stick these users in here too even though they may not be needed and these aren't necessary in this file now because it's just forwarding stuff. And what happens if I cargo t it yells at me because in object we need shared domain. So I guess I'm actually going to re export it pub crate re export domain shared domain because it's going to be used in so many places. So this is going to be create shared domain. This is also going to have to use create task pointer domain like so and also create deleter, possibly some others to reclaim claim.
00:52:17.290 - 00:52:29.650, Speaker A: And I guess I'll stick that one on there too. Great. Don't need that. Don't need that. Don't need that. Now back to lib. Great.
00:52:29.650 - 00:53:50.700, Speaker A: What else we got in domain we also need to use create. Probably a bunch of things. We need to use has pointer, we need to use. This is like the pain of restructuring. We need to use reclaim, we need to use deleter and I think that might be it because I don't think we need the holders or anything in here. Great. Yeah, some of these are going to have to be pubcrate, such as active and probably next end pointer and protect, which is on holder line 29 is a has pointer.
00:53:50.700 - 00:54:39.250, Speaker A: So has pointer this so protect has to be pubcrate. This is, yeah, this is not a method that we expect users to call. In fact, has pointers are arguably entirely private. Like I almost wonder if this can be pubcrate, but let's leave it pub for now. It might be that it doesn't even appear anywhere. Object can't call retire on domain because retire is almost certainly. Yep, retire on domain should also only be pub crate because we expect you to call that on.
00:54:39.250 - 00:55:17.256, Speaker A: You should call that on the object that you have take out of an atomic pointer or something rather than directly on the domain. What else we got? Acquire is the same, probably. So this is pump crate. Nice. Although, right, I made a silly in that this needs to be called tests and now. Great. This can go away.
00:55:17.256 - 00:55:56.846, Speaker A: This can go away. This can go away. And now it complains about shared domain. I guess shared domain can be pub. That's a good question. So should the shared domain be public? I think so. Like domains are public, so you should be able to get a reference to the shared domain.
00:55:56.846 - 00:56:35.390, Speaker A: I think that makes sense. So this is going to be a pub and that's going to be a pub, which arguably means it should just be here. Fantastic. And that test now passes. So if I do git add dot split into files. Fantastic. Oh yeah.
00:56:35.390 - 00:57:24.270, Speaker A: I monitor all the chats. It's just I don't look at the chat while typing code, but I get all of the different platforms in here. You can't see it, but my screen actually has like below where my video is or there like to the side on my screen I have chat so I see all of it. Great. So now we have this restructured. It's a little bit cleaner now I think the question is where do we start? Do we want to start by fixing up all the atomics or do we want to start by adding support for domains? I think I want to do domain support first. So this is like custom domain support because it might require that we sort of re architect some things at least a little bit.
00:57:24.270 - 00:58:23.260, Speaker A: And that might, it might both align our code more with what the Facebook library is doing, but also, also it might expose more places where we need the barriers later. So if we add the barriers are now, we might just have to move them later anyway. Yeah, so I think we're going to do that first. So let's head on over to domain. So the structure here is that we want users to be able to create their own domains. That's easy enough, right? So we can pubfend new and in fact it doesn't even need any arguments, it just does this. So this we've already done.
00:58:23.260 - 00:59:23.390, Speaker A: And in fact this can be const. Yeah, because there's nothing here that even does allocation. It's just, which means that because it can be const we can do this, which is very nice. We can even like implement default for has pointer domain. I think there's an argument for not implementing default, I haven't quite decided yet, which is I can just call new if it implements default. It's a little bit harder to document that you probably don't want to do this, right? So I don't know if you remember this from the Facebook documentation, but it says here most users do not need to specify custom domains and custom deleters and by def and by default use the default domain and the default deleters. Too many uses of the word default there.
00:59:23.390 - 01:00:25.616, Speaker A: But the idea is that in general you should just have like everything use the same domain because that way you get to reuse the hazard pointer holders, the retire list, the hazard pointers. You get to amortize the cost of deallocation across all different uses of this. And remember we end up doing like deferred d allocation with hazard pointers, right? So when you remove an object from a data structure, you retire it, but you don't necessarily get to reclaim it straight away. And that means it just sort of sits in this retire list and we don't check the retire list again until someone tries to retire something else. So imagine that someone does like a bunch of removes from your data structure, but none of them can be reclaimed yet, and then they don't do any more removes. That memory will just never be reclaimed if they have one domain for that data structure. If they use the shared domain, then any retire in any data structure will reclaim stuff for the other data structures as well.
01:00:25.616 - 01:01:30.230, Speaker A: Just like in general what you want is to use the shared domain. So I kind of almost want to call this like new, not recommended, but even if I, if the name doesn't imply it, like at least with new we can document why. With default that's a little bit harder. I don't know if you knew this, but you can actually write documentation here and it does get rendered in Rustdoc, but it gets rendered like you need to click plus next to default, which I certainly don't. In fact, there was a case where I was specifically looking for what the default value for a given type was and I just didn't think to look there because normally what you would get is the documentation from the standard library's default trait definition for the default method, right, which is like not helpful. It just says like the default value for the type. But if someone wrote a custom one here, it would show up in Rustdoc, but no one would think to look for it.
01:01:30.230 - 01:02:43.110, Speaker A: And I feel like given implement default, you're also just like more likely to create your own. So I think I'm going to not do that. What I do want to do though is this, which is going to give, in fact, this is a good argument for this not being pub and in fact not even being pub crate and then saying we're not going to expose the fact that this is through a static. Instead what we're going to do is here, we're going to say has pointer domain shared. That feels much nicer. And if we really wanted to, we could have this be an associated const. I think so we could say that this is equal to this.
01:02:43.110 - 01:03:13.110, Speaker A: This obviously has to be shared. I think this is legal now. And then we can do this. Nice. So it's an associated constant of the type. So that's kind of nice. Yeah, I think I like that.
01:03:13.110 - 01:04:00.750, Speaker A: Rather than like having to expose an actual static and now we can like write documentation for when you like documentation for new is gonna point you a chair and the like. Or maybe this should be called global. Actually, I think global is a better name. Could be called static, actually like the static has pointer domain. Not entirely bad, but global has a better feel to it, I think. Okay, so if you construct your own hazard pointer domain, it's going to have its own list of hazard pointers and its own list of retired. That part is fine.
01:04:00.750 - 01:05:10.380, Speaker A: And then what we're going to need is on hazard pointer object. Yeah, this one's going to be a little interesting. So here, I'm pretty sure there's a static bound missing here, sort of separately from all this. But this is going to have to be tied to the lifetime of the domain. Lifetime has to come first. Oh, I guess I could actually call this domain. Actually no, this is so if you use the default domain, you're going to get back an object wrapper that's static.
01:05:10.380 - 01:06:14.490, Speaker A: And this I guess is going to be domain is has pointer domain global. And what else do we want to say here? So this is going to be self dot domain. And for any domain we're going to return here is a reference to the domain. That's all good. Same thing here, although for the draf the domain doesn't matter. For drafm, mute the domain doesn't matter. This is complaining, but the complaint is off my screen, which is a little unfortunate.
01:06:14.490 - 01:07:10.724, Speaker A: Lifetime parameter instantiated with life domain, but lifetime parameter must outlive the static lifetime. I think the requirement here is that t outlive domain, not t outlive static, but has pointer object requires that self is static. And the reason for that is the reason for that is because when you call retire, you have no guarantee about when the object will actually be deallocated. And that's why we require that the, the type that you want to retire is static. It needs to live for however long it might be until the object is actually reclaimed, which could be forever. Like it could be the end of the program. That's why it has to be static.
01:07:10.724 - 01:08:06.660, Speaker A: But I guess now this is actually going to be parameterized by the domain and self has to outlive that domain. They have to be able to provide a domain that lives for that long. And we do. And the idea here is that we do guarantee that when the domain is deallocated, every t will be deallocated too. So if your t, think of this as like you have a domain that lives for this long and you have a type t that lives for this long. Right? This won't work because imagine that, like, okay, so this actually, what am I doing? Why am I using your hands? I have a drawing tool. I'm silly.
01:08:06.660 - 01:08:37.304, Speaker A: So let's say here we have a domain. Domain lives until here. And then down here the, the domain is the allocated right and this is the lifetime of your program. So, like, in some sense, tick static is like, down here. And now imagine that you have a t that can only live for this long. Like, imagine it's a value on the stack or something. And like, this is where that function that holds that t returns.
01:08:37.304 - 01:09:15.575, Speaker A: So after that function returns, the t is gone. It can't live anymore. Any references to it can't live anymore. This is not okay, right? Because you could imagine that someone calls like, retire here, but there are references to it, so it doesn't actually get reclaimed until here. So this is when we call drop, but it's not okay to drop the t down here because the t doesn't live anymore. So references to it are invalid. So we're going to have to require that any t lives for at least as long as the domain lives.
01:09:15.575 - 01:09:54.064, Speaker A: When the domain goes out of scope, like when the domain is dropped, then we do call reclaim on everything. Because if you think about it, the hazard pointers are tied to the lifetime of the domain. So when the domain is dropped, that means there are no hazard pointers to the domain anymore. Therefore all of the pointers must be reclaimable. Therefore we get to reclaim them and drop all of them. And therefore we don't require that the t lives any longer because its destructor will be called when the domain goes out of scope. Does that, does that make sense why we need this, this parameter? I was following the hands.
01:09:54.064 - 01:10:46.260, Speaker A: Yeah, I mean, right, like the domain lifetime, the t lifetime. What if something gets deallocated or reclaimed down here? That's what I was trying to get at, but my fingers didn't have enough dexterity to actually show it. And so what this implies is that as long as the object that you want to retire lives for at least as long as the domain, and you can prove that you have a domain that lives that long, you're fine. Great. So if that's the case, then now we can say this implements this. It's a lot of tick domain here. Great.
01:10:46.260 - 01:11:53.630, Speaker A: And we can prove that we have this because we have that self may not live long enough. That's probably because we have a constraint somewhere here too. So if you have a haspter domain where you're going to get back is actually a reference to a hazard pointer that lives for as long as the domain does. It's not going to be take static when you retire it. Take any pointer. That should be fine. So why is it complaining about this self? Oh, why is holder complaining? Oh, shared domain is no longer a thing.
01:11:53.630 - 01:13:06.780, Speaker A: This is going to be has pointer domain global. So I guess we need haspointer domain global. It's still complaining here though that the parameter self might not live long enough. That's because Din, I think by default is requires tick static. And here we want to say this and that means that retire now needs take didn'reclaim plus domain, which is undeclared here because. So this is going to be domain and you have to demonstrate that the pointer outlives the domain. Great.
01:13:06.780 - 01:14:29.190, Speaker A: And retired is also going to be generic over domain. This might get hairy because we might not be able to name this type here and you'll see why in a second, I believe if I go up here now. Yeah, so the problem here as the retired list is sort of self, right. It's however long the domain is around for. So here we're going to pull a little trick which is not super nice, but what we're going to have to do, which is that the retired is going to be a just a din and like we're going to have to use on safety here because you can't basically what, let me put this back and explain why this is a problem. What it's going to complain about here, right. Is that the things in the retired list need to live for at least as long as self.
01:14:29.190 - 01:15:43.240, Speaker A: We guarantee that because we never put anything in there that doesn't already outlive a reference to the domain. So we know that this will always hold for anything that we put in there. But we can't name this lifetime at this point like in the definition of haspter domain. This is, it's not even self referential really. It's just we can't name this lifetime, but we know that it always holds by the bounds, on the bounds that we enforce on putting anything into here in the first place. So what we're going to do instead is down here, get rid of this, get rid of this, get rid of this, get rid of this. And sort of say here, this is plus tick domain which is enforced on push which is enforced for anything that constructs a retired.
01:15:43.240 - 01:16:46.160, Speaker A: And in fact in the place where we do construct a retired, where do we do that? That's down here. Here. What I think we're going to do is impl retired. We're going to say fn new and that's going to take a, it's going to take all these same arguments except I guess not a next but it's going to take this extra parameter. So what we're going to do is we're going to take a domain that we don't use to, but the existence of it proves that you have something that has that lifetime. This is going to be didn't reclaim plus domain and a deleter. And it's going to return a self.
01:16:46.160 - 01:17:56.390, Speaker A: And at this point, and this is where the sort of funkiness gets in, we're going to have an unsafe pointer as star mute, then reclaim. And now if I, why do I keep going back to that file? That's not what I want to do. And now in the place where we actually construct the retired, we're instead going to do new self pointer deleter. And so here, notice that this isn't unsafe because we prove that the pointer lives for as long as the domain. I need to stop doing that. And inside of new is where we have this unsafe transmute and where we sort of erase the domain lifetime. And so here what we'll say is safety.
01:17:56.390 - 01:19:39.810, Speaker A: It's sort of misleading. But I think what we're gonna say here is the safety requirement here is that we know that the pointer will not be used after the domain goes away. So like arguably it should be unsafe here, maybe. And this has a requirement along the lines of, yeah, this is basically a transmute to static, right? We're transmuting away the lifetime, which is the same as transmitting to static. And what we're really saying is pointer, pointer will not be accessed after tick domain ends. Right. So as long as this is true, it's fine for us to erase the domain because the caller has already guaranteed that they won't, they won't take advantage of the fact that we're storing this as something longer the domain.
01:19:39.810 - 01:21:08.186, Speaker A: And the only reason we have to do this is because otherwise we would have to name tick domain all the way through, which would get all the way back to the sort of top level domain. So now where is the call to retired new? So this is now going to be unsafe. And here the safety is pointer will not be accessed after domain is dropped, which is when tick domain ends. So the question is, is that actually true? I have to think about this because actually I don't think this is safe. The challenge, the challenge you run into here is that imagine that someone has a, yeah, I don't think this works. Imagine someone has a hazard pointer domain that lives for some long period of time. Fingers again lives for some long period of time.
01:21:08.186 - 01:23:09.620, Speaker A: And then they take a reference to it, and that reference only lives for a short amount of time. And then they give a t ingesthen that outlives this short lifetime, but doesn't outlive the existence of the hazard pointer domain. So it meets the bounds here, but it still isn't safe to reclaim here after its lifetime ends, just because it outlives the reference. And actually that's sort of what Russ was trying to tell us, right? Is that the, yeah, that's real awkward, right? By sort of requiring that we declare self here, it's saying not only do you have to tell me that this outlives any given reference to hazard pointer domain, you have to tell me that it outlives hazard domain itself, regardless of how short or long any references you can construct to it are, which is awkward. And in fact this is a, there's a larger problem here, right, which is this isn't the life, the right lifetime, because the lifetime here is the, the lifetime of, it's the lifetime of the thing that is being referenced. And so remember that immutable references, or shared references rather, are covariant, which means that they can be shortened as much as you want. So you can always construct an immutable reference with a shorter lifetime than an immutable reference you already have.
01:23:09.620 - 01:24:21.492, Speaker A: And so that's why this won't work. Sorry to try to demonstrate this problem, just to make it a little bit more concrete. Imagine that I write code like this, that domain is, has pointer domain new. And then I'm going to do this and I'm going to say d is domain. And then I do t is string new. Why not? And then I do d dot retire t. I'm abstracting over a lot of details that aren't really important for this particular example, but down here the domain actually gets dropped.
01:24:21.492 - 01:25:08.890, Speaker A: So this, the syntax here isn't quite right. But imagine that this, imagine that we call this tick a and we say that this is a has pointer domain reference that lives for tick a. It's not quite true, but we could totally shorten it to that. Then this retire is going to sort of accept what we're saying, right, which is that we're giving in a tache that out lives or lives as long as tick a, right, because t goes away at the end of tick a. But it's valid for tick a. So this is allowed. But imagine that this retired doesn't get to reclaim t.
01:25:08.890 - 01:25:44.560, Speaker A: So it takes t and it sticks it on the retired list, but it doesn't reclaim it straight away. Then this ends. So now the t goes out of scope. So now it's no longer legal to access t. I guess this would have to be like a. And so when the domain is actually dropped, it's going to reclaim from the retired list and reclaim t. Now in practice it doesn't quite work that way because t won't be dropped anyway.
01:25:44.560 - 01:26:24.222, Speaker A: Maybe a better example here is that we try to retire a z is box new of reference to t. That's a better example, but that's not going to read t. So this needs to be a read on. Or let's see, print on drop. Now we're talking. Okay, so print on drop. Imagine I have a struct print on drop that implements drop.
01:26:24.222 - 01:27:08.730, Speaker A: When it gets dropped, it's going to print whatever is references it's going to print. Print the empty string in this case. So what's going to happen now is this type, right, is a box print on drop, tick a string, right. That's the type of z here. And when we call retire on z, it's going to allow, given what we just wrote, it's going to allow that retire because z lives for at least as long as the domain, they both live for tick a. Therefore the retire is accepted. Now z goes on dot retired, but is not dropped.
01:27:08.730 - 01:27:55.902, Speaker A: Right. Then we get down here. So now t. So down here there's sort of an implicit implicit drop t. So z is no longer valid at this point. So down here, let's say that now for some reason we sort of walk dot retired, we find that z can be reclaimed and so we call drop z. But when we call drop z, we're going to run the drop, the destructor of print on drop, which is going to try to print what it has a reference to.
01:27:55.902 - 01:29:12.992, Speaker A: But that reference was tied to the lifetime of t and t has been dropped. So it's a dangling reference. So this is the problem, right? This is why it's not sufficient to have retire, have retire require that its argument outlives its reference and why we really need this to be a reference to the domain itself. I wonder whether we can do this by intentionally constructing an invariant type. So the problem here, right, is that you can construct a reference that has a shorter lifetime, then you can construct a reference that has a shorter lifetime than the actual lifetime of the domain is sort of the problem. I don't think we can easily restrict that though, because we don't have a way to sort of get the, the real lifetime of this. Maybe with pin it's awkward.
01:29:12.992 - 01:30:19.520, Speaker A: It might be the retire just has to be unsafe. The other way around this, right, is to still just require the t is static. It's like unfortunate but that's certainly a way around it. If t is static, this problem can't occur in the first place because you wouldn't be able to stick this type, give this type to retire because it's not static. You can also think of it as static outlives any domain and therefore is always valid to drop. That's kind of sad, but I think that's what we're gonna end up doing here. That's unfortunate.
01:30:19.520 - 01:31:41.170, Speaker A: Yeah, that's real unfortunate. There might be a way around this, but not one that's immediately obvious. So I think we're just gonna not dive too deep into this right now and instead just request require for retire that this is just static. And in fact we could even say plastic static here it's implied we don't actually need it. It doesn't take itself anymore. It's no longer unsafe to call. Right? It's no longer unsafe to call.
01:31:41.170 - 01:33:03.230, Speaker A: And now here we're going to have to record require that this is still static. I kind of still want the object to be generic over the lifetime of the domain maybe. Yeah, I think we still want that even though we require the type to be static, just because in the future we might find a way to actually do this and then we don't want the trait to change. And relaxing this to a shorter lifetime I don't think is a breaking change. That's too bad. So now this has to require that t is static has pointer object. It's complaining somewhere.
01:33:03.230 - 01:34:12.130, Speaker A: Lifetime parameters essentially with tick domain, but lifetime parameter must outlive the static lifetime. Why? Oh balls. Yeah, well, so this is kind of weird actually. What's awkward here, right, is that hazard pointer object itself now needs to implement static, which isn't true if it contains a reference that only lives for domain. And so if it has that reference to any domain, that reference has to be static. I think this is just gonna have to be this. That's unfortunate.
01:34:12.130 - 01:35:20.730, Speaker A: But the problem that it's rightly complaining about is that you've said that haspointer object has to be tick static, but haspterobject is not tick static because it holds a reference that is tick domain. And you haven't said the tick domain is static. And so I think that the way to get around this for now is to just not make house pointer object be generic over the lifetime of the domain. Because I don't think we need to, because we're now requiring the type to be static. The domain can live for as short or as long as it wants to. The t will always live long enough to be retired. And this means now that, but that means that the domain now has to be, that would mean that the reference to the domain that we keep here has to be static.
01:35:20.730 - 01:36:34.000, Speaker A: We could have every object wrapper hold like an arc to a domain. The reason I didn't really want to do that is because the user might have an arc to the domain already. And I want them to not have to do like, I don't want us to enforce that for them. I mean, okay, so the reason why this doesn't come up in the C code is because in the C code all of this is like unsafe, right? Like these are all just requirements that the caller must uphold that the type lives long enough. And what we're trying to do here is enforce it on the type system. The challenge we're running into is basically that we can't really enforce this. Like basically we can't statically check that the domain lives long enough.
01:36:34.000 - 01:38:41.370, Speaker A: Because imagine that the domain is like in an arc, right? You can't check at compile time when the last arc will be dropped. And so there is no lifetime we can assign to the domain. The domain doesn't have a lifetime or it doesn't have a lifetime that's expressible at compile time. There's an alternative here which is to do what we just proposed of having this domain lifetime everywhere. So basically go back to go back to this and then just make this a requirement of retire instead. Domain doesn't look like a word anymore. So if we go back here and we still do this just as a sort of basic requirement, just like a basic safety check, but still says that this is unsafe, and then now we might mark this as unsafe.
01:38:41.370 - 01:40:50.800, Speaker A: So the safety here is, oops. The safety here is that pointer remains valid or until the, until self is dropped, which really feels like the pin guarantee. Pin is a little too strict here because we don't actually require the pin doesn't, that the domain doesn't move, we just require that it's not dropped. So, so this is then going to go back to the holder, no to object. And then I think we're going to have to add a fourth safety requirement here to retire, which is caller must guarantee that. So now this can be tick domain columnists require that self outlives the has pointer domain and not just any reference to it. Or we could phrase this differently selves lives until the haspointer domain is dropped.
01:40:50.800 - 01:42:19.178, Speaker A: There's a better way to phrase it because out lives makes it sound like reference lifetime outlive, when really we mean not just a reference to it, but the actual ownership of it. And this is more equivalent to what the c code does, which is that retire had to have to promise this in the c code too. It just basically the type system is forcing us into giving this on safety as it correctly should. And then I guess this, I'm going to go ahead and say pointer is this and pointer is this, and now this whole call is actually unsafe. So this is going to be something like this whole call is unsafe. The reason I move that cast out is because this cast I want to be safe. I don't want this to be an unsafe transmute.
01:42:19.178 - 01:43:02.250, Speaker A: And having be hidden by the fact that I put unsafe here, this, just to double check, should complain. Oh, it probably doesn't because lints aren't happening yet. Oh, I didn't remove the self I added for explanation up here. So this has to go away. Let's see what we get. Now 252 is captured and required to live. No, this has to be plus static.
01:43:02.250 - 01:44:22.710, Speaker A: What is it saying? Lifetime parameter instantiated with the lifetime domain, but lifetime parameter must outlive the static. Lifetime lifetime bound not satisfied. Yeah, that's oh, it's probably, it might actually require this to be a MEm transmute domain is complaining about shared domain constants cannot refer to statics. Consider extracting the value of the static to a const and referring to that. Consider extracting the value of the static to a const. No, I don't want to do that. I wonder why that is.
01:44:22.710 - 01:45:31.260, Speaker A: I guess it's because it's not a const. This is so the static is a location in memory, but that location in memory is known until link time, so the compiler doesn't know the value here. So in that case this isn't a cons, but it's sort of a public field. Like if I do this, is that accepted? I think maybe it's telling me that it is. Pub constfn global is that allowed? No method acquire found oh, that's just because this has to be global. And no, same thing. Constant functions cannot refer to statics.
01:45:31.260 - 01:46:13.924, Speaker A: Well, I guess global isn't a const. Yeah, I think it's because you can't. Well, you sort of can at compile time. You do know where the static will end up, but maybe it happens too early in the compilation process. Like this might be something that just isn't supported yet, because this feels like it should be allowed to be constified. The reason I don't want to make this a const, even though sort of in theory you could, is because then it, then you wouldn't necessarily have just one instance of it. I want this to be a single shared domain.
01:46:13.924 - 01:47:47.888, Speaker A: If I made this a const, what this would mean is that you have one, you have a different domain anytime you use this const because it sort of gets inline into the compiled code, or at least you might end up with several, whereas I really want it to be a single global shared domain. Test lib okay, so this has to be, has pointered domain global, same thing here, same thing here, and it currently probably tries to import it to. No. Okay, great, sweet. So at least that's, now we have a way to construct these holders. Yeah, great, great. Okay, so now remember, there's sort of two parts to this puzzle, right? If you have a, if you have a data structure that's using this, you have the hazard pointer object, which is the thing that's like stored in your data structure, that you have atomic pointers that are pointing to, to, and then you also have the hazard pointers themselves, which are, which may or may not point to a hazard pointer object in order to guard that object from being deallocated.
01:47:47.888 - 01:48:50.398, Speaker A: And both of these need to be associated with a single domain, the same domain, in order to actually guard, because when you retire an object, you need to check all of the hazard pointers, but you check all the hazard pointers from the domain of the object. So if the hazard pointer is in a different domain, it won't be checked. So we need to make sure that the, the hazard pointer domain that the readers, the clients, the things accessing the objects use is the same one as the one that's used for the call to retire. Currently that's not the case. So if I go to pointer, if I go to Holder, the hazard pointer holder, remember, is the thing that has a hazard pointer that it's going to use to guard, and it might not have one because it might not have taken one from the linked list, from the domain yet. There's a lot of indirection here. Indirection is maybe the wrong word, but there's a lot of sort of layers of abstraction here.
01:48:50.398 - 01:49:18.608, Speaker A: And then one of the things that's certainly not helping are the names here. And when you actually went. So you create a hazard pointer holder, then you say, now I want to guard this pointer. And the hazard pointer holder goes and like gets an actual hazard pointer from the domain. And that's this hazard pointer function here. And you'll see that if it already has a hazard pointer, it reuses it. If it doesn't, it currently just gets one from the global.
01:49:18.608 - 01:50:14.350, Speaker A: But this is a problem, right? Imagine a data structure is using its own hazard pointer domain that's not the global one. And then some reader goes oh, I'm going to construct a hazard pointer holder. I'm going to grab, use that to guard my load of that atomic pointer to the object. Everything is fine, but the reader is going to be using the global domain and the, the retire or the data structure is going to use its own custom domain. And so when it retires it's not even going to see the hazard pointer that the client is using. And so this really needs to be the same domain as what's used by the object. And we have some ways to deal with this specifically.
01:50:14.350 - 01:51:30.880, Speaker A: So first and foremost for load we're going to require that t implements has pointerobject of any lifetime has pointerobject. So if you try to load a hazard pointer to guard it with a hazard pointer, it better implement hazard pointer object because if it doesn't, it's, it's not something that even can be guarded. So we want to say that you can only load things that know about hazard pointers. I guess in theory there's no danger in having a hazard pointer to something that doesn't support hazard pointers, but we might as well add this as a bound here because otherwise you're probably doing something wrong. The other reason why we want this bound is because this gives us a way to get at the domain that that object is using. So let's see here. Tick underscore cannot be used here.
01:51:30.880 - 01:52:34.412, Speaker A: The object of domain needs to live for at least as long as l, that's fine. I think that's fine. And I think what we're gonna have to do here is do this is even stupider. So, okay, so here's, here's the challenge we run into. How do you know that the holder is for the right domain? Like I tell you, here's a hazard pointer and I want you to load this atomic pointer. How do you check? Because, okay, you construct a hazard pointer, you load the pointer. You're not allowed to dereference it until you know that it's protected.
01:52:34.412 - 01:54:04.172, Speaker A: But you don't know that it's protected until you know that the has pointer is for the correct domain. So I think this is just like inherently unsafe. Like I guess we could, we could have a debug assertion here, right? Of like debug assert e self dot domain, which we don't have yet. Is equal to actually up here is equal to r is this. So that's the target is going to turn r, but we're going to assert equals r domain is equal to self dot domain is there, there's a pointer equals, I think, which is really just this as star cons task domain. It should be equal to this as star cons task pointer domain. Right.
01:54:04.172 - 01:54:43.864, Speaker A: So this is all we can do here is a debug assert because like this is, if the domains are different, right. Then you haven't actually protected here. And so this draft is just not safe if the domain is, if it's not the right domain. Because even though you call protect, your protection is guarded by the wrong domain. So it won't be checked by the writer. So the writer might have deallocated. So this draft is incorrect and so this is already undefined behavior.
01:54:43.864 - 01:55:17.860, Speaker A: So this, like this is sort of a last ditch effort of okay, maybe it was deallocated, but the memory hasn't been overwritten yet. So maybe we can like detect it at least in a testing context. But if you ever hit this assertion like things have already gone wrong, it's just we happen to be able to detect it. But, but this is definitely another, another instance of this on safety that we can't trivially check. Although I have a, I have a trick up my sleeve that we'll see soon. It's not going to fully solve the problem. It's going to help a little bit.
01:55:17.860 - 01:56:52.820, Speaker A: So the column was guaranteed that the address in atomic pointer is valid as a reference or null. The columns also guarantee that the value behind the atomic pointer. Let's first and foremost make these nice. This will be call will only be allocated through calls to hazard object retire on the same has pointer domain as this holder is associated with, right. So that this is like the key addition here that it has to be the same hazard pointer domain as a. What we're going to do now is instead of deriving default, we're going to have, the holder is going to hold a, I guess this is the hazard and this is the domain and we're going to have a global, perhaps unsurprisingly, which gives you a has pointer holder. Static whoa, there's a lot of annotations on my screen right now.
01:56:52.820 - 01:58:14.020, Speaker A: So global is just going to give you a hazard pointer holder where the hazard is none. And actually this can just be self for domain of has pointer domain global. So we're going to have another constructor for domain which takes a, this is now going to be generic over domain, which is fine. But we're also going to have a constructor for glow for static which does this, which in fact does this. And this is going to then have to be hazard pointer holder for domain. So that's going to take a domain reference and give you back thing with the appropriate lifetime. And that's going to be a self where the hazard is none because we don't have a hazard for the domain yet and the domain is domain.
01:58:14.020 - 01:59:10.030, Speaker A: This can no longer implement default. And now this is going to give you back a hazard pointer with the lifetime self domain and this is going to be hazard. And this is going to be hazard. And now this is not going to use the global domain but it's going to use our own domain. And now this load still does the same thing. This is going to use the hazardous, we're going to implement drop for has a pointer for any domain. That's fine.
01:59:10.030 - 02:00:00.970, Speaker A: This is just going to set it to inactive and that's fine. So now you can construct a hazard pointer holder either for the global domain, which is what you normally want. In fact, we could implement default here. Again, the downside with default is people will just like use it and not think carefully about it. And so I want them to explicitly make a choice as to whether this is for the global domain or for a particular domain or they can choose to use it for the particular domain. And then we have this debug assertion which arguably happens too late, but it's sort of the best we can do. Let's see if this compiles.
02:00:00.970 - 02:00:34.230, Speaker A: It does not because the tests have changed now. This is now going to be a global hazard pointer holder. A global hazard pointer holder. A global hazard pointer holder. A global hazard pointer holder. Ooh, I wonder why this is complaining. Borrow of h occurs here cannot borrow h as mutable more than once at a time.
02:00:34.230 - 02:01:25.820, Speaker A: That's because first borrow occurs here. Okay. But why doesn't it end there? Oh, it's because of this. So this needs to be like a tick. Oh, this is tick. Oh, where tick. Oh outlives tick.
02:01:25.820 - 02:02:07.036, Speaker A: L I think that will do it. Yeah. Okay. So the, the challenge here was, I was saying so. So remember how the, the reference we return from load is tied to immutable borrow of the holder? Right. So the idea here is that for as long as this holder still exists and you haven't used it to load anything else since the, the exclusive part, this reference is still valid because the hazard pointer is guarding that reference. What I was doing when I said l here is that I also need that lifetime is what I'm saying here, that lifetime needs to be the same as the lifetime for the object behind the atomic pointer.
02:02:07.036 - 02:03:13.736, Speaker A: But that's just like not true, right? Like remember this is basically static for most things, and that sort of goes back in requiring that. This is saying that this is going to be static and this has to be static, which is like not true. What I really wanted to say is that whatever the guarded object is, that guarded object has to live for at least as long as we want this reference to live for, but it doesn't have to be actually the same. And so that way this can be a long lifetime without requiring this to be a long lifetime. This is an example of where multiple lifetimes are just needed in order to accurately express the constraints we want. And you'll notice, like it's, you can do this, it's just that it becomes a pain to use because now any load is going to borrow the holder for eternity, which is not what we want and not what we need, in fact. Oh, so there's some discussion about constants referring to statics.
02:03:13.736 - 02:03:45.392, Speaker A: It's true that in general, like because statics are mutable, you can't. Well this is not quite true. Statics are not mutable. Mutable statics are mutable. You could have interior mutability in a static. But that does mean that the, the address of the static is still constant. Right? So that's why I agree that you shouldn't be able to have constants referred to that the dereference into a static, because that value is not constant.
02:03:45.392 - 02:04:51.450, Speaker A: But the address of the static should be constant, which is all we were using here. So this is why I'm saying, I'm guessing this is a limitation of the const evaluation that it doesn't realize that if you take, if you only use the address of a static, then it's still constant. That would be my guess. All right, so now we have this, now we have multiple domains. And just to sort of sanity check that, our test actually does something useful. So we have feels good, let's do feels bad because why not? So what I'm going to do here is, I guess go ahead and do this and construct one of these. And I'm going to have like d one is hazard pointer domain new and d two is how support domain.
02:04:51.450 - 02:06:14.600, Speaker A: And then, oh, I guess, did I not declare a constructor for this? So let's do with default. With, let's maybe say instead of default, call it global. And then something along the lines of with domain, which is going to take a domain which is a tick domain of has pointer domain which is then going to take that domain and stick it in the domain. Too many domains. This is going to be object wrapper with domain of this. And it also needs to pass in the t. So now I should be able here to say with domain and given, say d one, or I guess actually a reference to d one.
02:06:14.600 - 02:06:42.950, Speaker A: What did I put in? Multiple feels bad. That won't work. Can only have one feels bad. Okay, so the writer is going to be using domain d one. I guess maybe let's call them d, d, w and doctor. So the writer is going to use dwell. The reader is going to use doctor.
02:06:42.950 - 02:07:48.460, Speaker A: Actually, I wonder whether we want this to not be a for domain. Maybe we don't want to require that it's a reference, but maybe we want to require that it's any type that implements like as ref or d ref or something. Because if someone stores like a keeps like an arc of a domain, they can't actually give you a reference with the appropriate lifetime. With Ark, maybe it's good enough for readers, but for writers is a little bit of a pain because the object wrapper gets a little awkward. Yeah, I think it's okay. So as a reader, we're going to create a holder for that, and then we're gonna h load x and this should panic. Should panic.
02:07:48.460 - 02:08:30.230, Speaker A: Reader uses a different domain than the writer. Let's hope this catches the error, at least in debug mode. Right. It's no longer called default, it's called global. And on line 53, same thing. Global domain and unused variable. That's true.
02:08:30.230 - 02:09:24.710, Speaker A: Thread panicked while panicking. That's certainly interesting. It probably panicked when dropping the holder or something. That's interesting. Let's go with no capture here and let's do test. Lib feels bad who? Yeah, that's fine. That's so that's the assertion failure we expected.
02:09:24.710 - 02:10:18.486, Speaker A: That's because the domains are different. And we could, we can sort of double check this by saying in holder object guarded by different domain, then holder used to access it. Right. And if we test now, that should be the error we get. Yeah, object guarded by different domain than holder used to access it, but it panicked at not yet implemented at domain. Oh right. So it panicked when it drops the domain, because implement drop for hazard pointer domain.
02:10:18.486 - 02:10:54.460, Speaker A: So we haven't done this implementation yet. And in fact, if I just comment this out just to see that this indeed works. Yeah, so that does panic, which is what we expected. So the test passes. So that's great. The reason this panicked was we want when the domain is dropped, it should clean up all of its retired things, right? It should be at that point safe for it to reclaim basically all of its objects. So here I should be able to do self dot.
02:10:54.460 - 02:12:01.730, Speaker A: What does block do again here I think I don't even want to block at this point. It should be fine for me to say self dot retired, dot count dot load. In fact, dot dot get because I should have immutable reference to it. Like when the haspointer domain is being dropped, there are no references to it. So I own all the values. So all so n retired, I guess. And then I want to call bulk reclaim of zero and false and reclaimed.
02:12:01.730 - 02:13:02.092, Speaker A: And these should be equal, right? I should be able to retire, reclaim all the retired objects when the hazard pointer domain is gone because there should be no hazard pointers outstanding. Now technically, maybe this should be a debug assert because you could imagine that someone like panics while holding a holder or something. And in that case maybe this isn't too bad, but in general this should be true. And there's still a little bit more of to do here for us, but at least that's a start. Okay, so that works. And then the little bit of work that's still needed is if you recall inside of a hazard pointer domain we have the linked list of hazard pointers and the linked list of retired lists. And both of those are sort of contain or the retired list should be empty, I guess.
02:13:02.092 - 02:14:24.630, Speaker A: But the hazard pointer list, remember, we never deallocate from, because the idea is that you can always reuse these hazard pointers, but when the domain goes away we can deallocate them because no one should be using them anymore. So self dot retired, I dot head get mute. So we're gonna assert that this is null, right? There should be nothing in the retired list anymore. And so we could say here there should be no hazardous pointers active, so all retired objects can be reclaimed. Also drop all hazard pointers as no one should be holding them anymore. So this one is a little more annoying in that we have to walk a linked list. So in fact, what we could do here is we could just implement drop for hazard pointers instead.
02:14:24.630 - 02:16:07.074, Speaker A: But I think what we're going to do is just, we're going to do headland is self dot hazard pointers get mute and then we're just going to walk the linked list. So while I guess this can be node, it can be muted while, and in fact I think I want it to be as cons. You'll see why in a second. So while the node is not null, we're going to say we're basically going to reclaim the hazard pointer so we can here just assume ownership of this one. Actually we can say n is box from raw of node and that's unsafe. That's why this can't be this. This is safe because we're in drop.
02:16:07.074 - 02:17:27.348, Speaker A: So no, so no one holds any of our hazard pointers anymore as all holders are tied to tick domain, which expired on drop, which must have expired on drop. And then node is n dot next dot get mute. Really we have pointer, we have next and we have active. That's fine. So why can't I use next here? This should be a box has pointer and I can also here assert that n is not active. That should certainly not be the case. I guess this is dot get mute.
02:17:27.348 - 02:18:21.852, Speaker A: Why not, right? This is a mutable reference to the pointer, which is silly. This should be a starring you task pointer. Just to make it clear what this is actually is. And this is going to be that. So we're going to move to the next node and this is going to implicitly, but we can do it explicitly drop nde as we're just gonna walk the whole list, linked list and drop all of them. Get mute not found for this, just because that has to be dot head cannabaro and active as mutable. Is there a get as well? Apparently not.
02:18:21.852 - 02:18:59.889, Speaker A: All right, fine. I wonder, does it just implement like D ref? I didn't think so. Be too good to be true. That's fine. So the, the observation here is that if you have a, an exclusive reference to any of the atomic types, you can just get their value with get mute, which is not unsafe because no one else has a reference to it, so there's no contention possible. Great stuff. All right, let's see how that does.
02:18:59.889 - 02:19:40.176, Speaker A: Great. So now I think we have all the bits that we need for multi domain support. So let's do commit that as support non global domains. And it's like it's unfortunate that we still have the static bound. I wish that wasn't the case. That's something we can look at separately. We do have this like pending foot gun though, right? Of this debug assert is really unfortunate.
02:19:40.176 - 02:20:46.584, Speaker A: It's really easy to accidentally use the wrong domain. So how do we fix this? Well, it's not trivial to fix because ultimately you just like need to compare the domains by pointers and you can't get the domain until you do, until you have protected the target. So there's like a catch 22 here. It fundamentally needs to be unsafe, but we can do a little bit better. And this is, this is a little bit of a weird trick, but I think it might be valuable, which is also an idea that chat came up with on their own, which is nice. So the trick here is going to be to have a sort of associated or not associated type, but a type parameter on domain, which is we can call it like differentiator or mark like. It's a type that doesn't matter.
02:20:46.584 - 02:21:45.190, Speaker A: It's only there to sort of denote that a domain that denote the two domains are different, but statically. So what we're going to do is let's call it m for mark. And what we're going to store here is use standard marker phantom data and this is going to store a mark. So maybe she, the name of this is actually fairly important because it's not, it's not a uniqueness guarantee. You could totally make multiple domains that have the same mark type. And so we want to use sort of a name for this that indicates what's going on. Class might be a good name here.
02:21:45.190 - 02:23:20.790, Speaker A: It's like a category almost. I wonder if this class, a reserved keyword, it's not family is not awful, right? So a domain belongs to a domain family. And so the only thing this is going to guarantee, and you'll see the implementation in a second, is that you can't accidentally use a domain from one family with a domain from a, like you can't use a reader using a domain from one family with a writer using a domain from a different family. And the idea here is that we're going to make the global one, the global domain sort of have a distinct family that no other domain is going to have. And so that means that you can't accidentally use a global client with a non global writer. You could still have like imagine someone has their own data structure and that data structure is, let's say like they use their own family for the data structure, but multiple instances of that data structure use different domains, but you can't create a type at runtime. So each instance of that data structure is going to have a domain, a distinct domain, but of the same family.
02:23:20.790 - 02:23:49.240, Speaker A: And therefore we can't statically detect that those don't, that you don't use the wrong domain. Like use a client from one instance of that data structure, but a writer from another instance of that data structure. That wouldn't work. Yeah. So let's call this family. It just gives us a little bit more of that, of that protection. And then the shared domain, I guess, can have a really, what we want here is for this to be a private struct.
02:23:49.240 - 02:24:17.510, Speaker A: I don't know that we can do that. I think that's going to trigger the private type and public interface error or warning. It's a warning. It's fine. Let's see. So let's call this global. So we, we have a unit struct global.
02:24:17.510 - 02:25:14.350, Speaker A: And this, you can only get a global using the global one. And otherwise you can construct a new. And I think what we want to do here is like you can use any family you want in new phantom data of f. We use the phantom data because we don't actually want to store an f. We want this to be sort of erased at runtime. Comparison operators cannot be chained. Right, right.
02:25:14.350 - 02:26:00.500, Speaker A: This is an instance of phantom data, not the type. Yeah. And so the reason why I want global to be a private type is so that no one can construct a hazard pointer domain global themselves. Now one way to, let's first see whether it actually complains. So this is going to complain about f. That's fine. This is gonna, right, so now the, the family is gonna just actually, it's not gonna go in here.
02:26:00.500 - 02:26:36.070, Speaker A: The family is sort of gonna infect everything. That's fine. Holder probably needs now a family. And this is going to be global. And in fact this is going to be pub crate. So this is going to be pub crate. Use domain global.
02:26:36.070 - 02:27:07.330, Speaker A: I have another trick up my sleeve if this ends up being not quite right. So this is going to be a create global. This is going to be for any family. Oh, that's not what I meant to do. And object also holds the domain. So this is now going to be for family. This is going to be for a family.
02:27:07.330 - 02:28:00.830, Speaker A: This is now going to be generic over the family. And in fact this one is going to be for global. But this is going to be for any family. This is also going to be for any family. F four t f. So notice that this, this is not actually a cost at runtime at all. Like there's no dynamic check here.
02:28:00.830 - 02:28:30.284, Speaker A: It's just everything is getting this type parameter which is going to make it impossible to do what we did in the test. The test is just not going to compile, which is really cool. Just finish up. Oops. No, that's not what I meant. What else do I have? Holder has some more. This needs the family.
02:28:30.284 - 02:29:21.724, Speaker A: Now. What else we got? This needs the family now, this needs the family now parameter f may not live long enough, but f, f is not fine. Fine. F is always gonna be static. F doesn't need to be static here. That's right. What it's complaining about here is that hazard pointer object needs to be static.
02:29:21.724 - 02:30:15.000, Speaker A: Remember, requires self a static and it's generic over f, which might not be static. And then it's like, oh, but then the trait isn't static. But like realistically, of course it is because there's no, I guess we could say f domain, but like it doesn't matter, it's not used for anything. So I think we're going to claim that FDA is just static. Now I'm going to have to add it everywhere. Static. Thank you.
02:30:15.000 - 02:31:02.168, Speaker A: Ah, all right. Oh, and it did not complain about my type being private. That's good to know. It might maybe later on, but here. Okay, so let's say that we make the writer use a global one type global as private, because it really doesn't like that. That's fine, that's fine. Okay.
02:31:02.168 - 02:32:30.322, Speaker A: It's a little awkward, but it's fine. So let's take the simpler case here of I'm going to make this domain be, let's just see, let's just make this be any like weird type, okay? So notice now that these domains have different families, right? They have different family types. And now this load just doesn't compile because it says haspterobject u eight is not implemented for haspterobject integer. What? Sorry, it's this, this is last, the, the error is not very nice, but at least it wouldn't let you compile, right? So see how this underscore is this underscore and it says has pointer object of this is not implemented for haspointer object of this family, right? So it's now catching at compile time they're trying to use different ones. And like in reality, how often are people going to remember to give a particular value for here? But the thing is, they have to, right? If, if you don't give a value here, the compiler goes, I don't know how to find this value. In fact, if you, if you don't give one for one, it'll just go, oh, they're probably the same. An inference gets you, but if we don't give it for either of them, it goes, I don't know what family to use here.
02:32:30.322 - 02:32:59.204, Speaker A: You need to tell me which family to use. And so this still doesn't catch the instance problem, right? Of if these have the same family, then this will be allowed, will be caught at runtime. Global is private. We'll get to that in a second. Right. So, so these are different domains, but they have the same family. And so it will compile crash at runtime because of the debug check we added.
02:32:59.204 - 02:33:38.286, Speaker A: So it doesn't catch all the problems, but it does catch the fact. And this is the sort of big one where if I use global for one and non global for a different one, where it'll say like, this is not the same as global, not. Okay. And it should catch the other way around too. So if I made the reader be global, the reader be global, and the writer be non global, it would also catch that. So that's kind of nice. I guess I'll make them new for now.
02:33:38.286 - 02:34:26.170, Speaker A: And now it'll fail up here because it complains that global is private. Yeah. Why? Okay, so it complains that the global type is private, which it is entirely correct about. The global type is private and we need it to be private because if it's not private, someone can, can basically, someone can accidentally do this. And now if someone, if the reader now was global, then now this wouldn't be caught at compile time. And I think this is the clearest case of an error someone would make. And realistically, like, no one should be doing this.
02:34:26.170 - 02:35:35.382, Speaker A: In fact, maybe we can just have a static check that this isn't the case. But static checks for that are a little bit difficult because it's sort of a, like a negative impl block. Like you'll have new for any type but global. So instead what we're going to do, and this has some other nice benefits too, is we're actually going to make this pub. And bear with me for a second, we're going to mark it as non exhaustive. We're going to give it a private constructor, like so. And then we're going to require that new is given an instance of the FDA, it doesn't use the f like, it doesn't use the f.
02:35:35.382 - 02:36:02.100, Speaker A: You pass in. This is not used, but it requires that you pass in an f. But, and the global type is public, but you cannot construct one yourself. So in new, we can use. And this, I guess is const. Right. This can use global new because why shouldn't it? But anyone else has to pass in the f.
02:36:02.100 - 02:36:33.786, Speaker A: The structures cannot be evaluated at compiled. And now this can't be consens. That's fine. And you just, oh no. But then it can't be. Oh no. It totally can be.
02:36:33.786 - 02:37:55.888, Speaker A: We just need to inline this, which is real dumb. Fine, fine, fine makes me so sad. Great. It can't be const, but it is actually really unfortunate that it can't be const because I want people to be able to create a shared domain for their data structure that's like shared across all instances. So I do really want it to be const. Can I make this argument be, can I say that? Oh, can I say where fde is? Copy. That's fine.
02:37:55.888 - 02:39:05.176, Speaker A: This can be copy and clone and debug and partial eek and eek and hash whatever type you want. That's fine. Trait bounds other than sized on const parameters are unstable, but I want my const to work. Umm, can this be a reference to an f? It can, it can, it can. Great. Okay, so you can still construct a global just the way you normally did, but you can't make a global the type yourself. So you can't make one of these yourself unless you call global, which means you're getting the shared domain and you can construct your own.
02:39:05.176 - 02:40:51.520, Speaker A: And one thing that's nice about this part is that now you can use types that you can't even name, such as closures, which always have unique types. So now you can just like use a closure to pass to new, and that type is now going to be the type of the domain. The problem, of course is you still need to be able to name this type in order to use it for your readers. Oh no you don't, because you can just get them from this. If you ever have to name your reader, you're in trouble if you use a closure here, but that's fine. So now if I go to test lib, okay, this should be called at runtime, but here's a how am I going to do this? I'm going to make a compile fail test over here, which is going to be, actually, I'm going to make it not a compile fail first and then, and then check. So now, so if you try to make a global and this can be any types, now this doesn't have to be a fancy type compile because families differ.
02:40:51.520 - 02:42:39.604, Speaker A: This I guess will be a structure. Cannot confuse global writer and same we want cannot conflue globalreader where this is the reader and this is the writer. And I did something silly here, which is in tests. This now needs to take an instance of the type, which now arguably makes it easier because I don't need the weird turbofish and something complains in probably my doc test my doc test needs to do this here, same thing here, and probably needs to use like, I guess it probably just needs atomic pointer maybe. Oh, our load almost certainly needs to take an ordering. I just realized that's something we need to fix, but to do ordering and oh, and it all. My my test also obviously needs to use all of the things from the crate.
02:42:39.604 - 02:43:32.284, Speaker A: So haphazard star and same thing for this one. Let's see what it says. Indeed, this one fails to compile. And the tricky thing about compile fail tests, at least when you make them in this particular, particularly like simple stupid way, you should use something like compile test or try build, I guess it's called to check for the exact error message. When you use a compile fail doc test, you need to manually check that it actually fails to compile for the right reason, right? Because otherwise this could fail to compile because I was missing a semicolon and the test would pass if I marked it as compile fail. But here it does indeed fail with the correct error message, which is that, like, the parentheses are not the same as global. I wish I could make that error a little nicer, but it's good enough for now.
02:43:32.284 - 02:44:23.860, Speaker A: It at least means that that code does not compile. Beautiful. Why doesn't it run this? This that should be compile fail, that's why. Notice that if you misspell this, it's no longer considered rust code and therefore not run as a doc test. It's like there are two lines missing. Great. Add domain families to statically catch misuse.
02:44:23.860 - 02:45:45.080, Speaker A: Okay, let's talk through this particular solution, because there's all sorts of subtleties here, and that that might be helpful for us to talk through. And let me also scroll back and see if I missed any particularly good questions. Can you use pub crate for global? Yes, that doesn't work. You get a family. You get a family, everyone gets a family. Let's see, would it be worth making creating domains unsafe where the caller has to guarantee that there's no dupes? I don't want to do that, because there are valid reasons for creating duplicate domains, right? Like, just because you create a domain for a given family doesn't mean that creating another domain for the same family is the wrong thing to do, right? That might actually be what you want. If you want a domain for each instance of a data structure.
02:45:45.080 - 02:46:58.290, Speaker A: For example, like imagine, imagine a concurrent hashmap that used this, right? You would declare a family for the hash map generally. And then you would declare a, you would create an instance of a domain of that family for each individual hashmap, so that if you deallocate anything from, from one hash map, it only considers the hazard pointers for that hashmap and not for any other ones, even though the family is the same. So it's still correct use, right? There isn't an error there. The error that could still occur when using families is someone takes a hazard pointer holder from a domain that was generated for a particular instance of that hashmap like map one, and tries to use it with a value that is, that was retired from another instance of the data structure, which uses another instance of the same domain, but by the same family. And now you have a problem because they're not really the same domain, even though they share a family. But we do want to allow the use wherever the family is the same. But there are multiple domains.
02:46:58.290 - 02:48:13.940, Speaker A: So that's why I don't think it's the right thing to do to make the domain creation unsafe, because there are valid reasons to sort of alias them, if you will. I kind of want new to take an instance of t. It does that now. And to have a macro that calls domain new with a closure. Yeah, so that's an interesting idea. So you could have something like macro rules, and I guess this would be something like macro export domain, and this would take no arguments. And what it would do is has pointer domain new this macro export.
02:48:13.940 - 02:48:49.740, Speaker A: And so the idea now would be that now you can use this to create a distinct domain every time. So in our tests, this could be domain and this could be domain, and they will now be. Notice that this error is now caught, because, and this is going to be an even more painful error to debug. Right. But the closure types are different and therefore the types are different. So that is pretty nice. In this case, I did want to catch it at runtime, so I specifically want them to be the same.
02:48:49.740 - 02:49:33.090, Speaker A: But you're right that this does mean that if I go back to our compile test failure is cannot confuse unique domain, you cannot confuse across families. Right. So this is going to be domain. This is going to be domain. And just double check, remove the compile fail cargo t. This now correctly fails to compile with the write error. So that's a nice addition.
02:49:33.090 - 02:50:18.358, Speaker A: The challenge, of course, with this particular macro we just added is that you can no longer name this domain anywhere. So you get a unique domain with a unique family and you can't create multiple instances of it. That's not possible. So in some sense it's like immune to abuse. But the downside is that it's also much harder to share between your readers and your writers. Can't domain say something like f is not global? No, unfortunately not. Right? So you could imagine something like f not global.
02:50:18.358 - 02:51:41.400, Speaker A: This one's work for a couple of reasons. One is that negative trait implementations aren't the thing, the other is a global isn't a trait. We could here say that the way you would actually get at this is like f is not global, and then you would have a trait not global that's like impl not global for any t, and then implement not not global for global. But this needs negative trait implementations which don't exist at the moment. Besides, I like this being able to pass in by value because for example you can use closure types as this demonstrates. So I may guess maybe this should be called like unique domain. Probably anyone can construct a struct with no fields, so that's not true because it's marked as non exhaustive.
02:51:41.400 - 02:52:19.244, Speaker A: I should have called this out explicitly. So non exhaustive is an attribute that you can put on any type, and it makes it so that adding fields to the type is backwards compatible. So I can add bool here, which normally would be a backwards incompatible change. Because in the past some other crate could have written like let x is global, right? And have that compile. And if I add a bool here, that's a private field, then now their code will no longer compile. And so this would be a backwards incompatible change. Normally, but with non exhaustive.
02:52:19.244 - 02:52:52.968, Speaker A: Basically it takes away the sort of built in constructors is one way to think about it. So the other example would be, let's say pub x is bool, right? Then in the past someone could write x. True. And now adding say y bool would be a backwards incompatible change with non exhaustive. This constructor is also removed and disabled. Same thing goes for matching over the struct. All matches need to be need to be non exhaustive.
02:52:52.968 - 02:53:49.750, Speaker A: So this is no longer permit permitted on a non exhaustive struct. It has to be marked as this. But crucially, the property we're relying on here is that this means that global does not have a constructor that anyone can call. Do you actually need to derive all that stuff on global? No, we don't need it anymore. It was just in case the f copy trick worked, but it did not. So I agree, we should just not have those, have those derives. Can you use associated types to tag all types as global, not global? Oh, maybe.
02:53:49.750 - 02:55:04.040, Speaker A: Okay, yeah, so this is a real ugly trick. But you could say like maybe global and it has an associated type is global and we do impul t maybe global for t and say type is global as unit and then we also implement maybe global for global where type is global as bool and then we say here where f implements maybe global is global equals this. I think that works. No, it's still conflicting implementation. The blanket implementation still conflicts. There'll be one way to do this. Basically this requires specialization, which doesn't currently exist.
02:55:04.040 - 02:55:46.170, Speaker A: The doc test structs could be marked config doctors. Yeah, that's certainly true. There's no like huge reason to do this. The big reason is that you don't accidentally start using this type in actual coding. It seems pretty unlikely that you're going to start doing that. But at least this way there's just no way that you can. One downside of doing this is that now the compiler is telling you oh, this code is inactive, which like is fine.
02:55:46.170 - 02:56:15.596, Speaker A: I don't think it adds too much. Could be an associated const. Yeah, it could be an associated const instead of an associated type. Would have the same property I think could probably be done with auto traits. What we could do is we could make sure the global isn't senditive and then require that f is send. But it just doesn't seem worth it. And the upsides of having this be able to take a closer argument.
02:56:15.596 - 02:57:07.992, Speaker A: I think it's worth it, but you're right, it could probably done with basically getting out of the auto impl of send and then requiring f two b send. But I don't want to do that. All right, so let's go ahead and amend that actually and let me push that out for you all too. Fantastic. Alright, that's pretty good. So now we have these domains. I think the next step now that's sort of necessary is arguably this should be doc hidden, but I'm gonna not do that.
02:57:07.992 - 02:58:02.042, Speaker A: Oh right, let's fix the ordering here too. This is gonna take an ordering, which is gonna be an ordering and then ooh, actually I don't know if it can because we have to make sure that the protect here doesn't get reordered. So before we add the ordering, I want to check what the actual implementation does. So I think this is going to be the next step now is to sort of align all of our memory ordering and barriers and stuff with what's in the actual implementation and folly. So let's do that next. I'm gonna take a quick break though. We can all make tea and pee and be happy, and then in like a couple of minutes we'll keep going.
02:58:02.042 - 03:01:14.340, Speaker A: All right, see you in a second. I think in theory, I'm back. Let's see whether in practice I'm back. Like, can you all see and hear me again? Maybe? Yes. No, can you hear my crunching? I'm back. Great chat has confirmed that I'm back. Glad to hear it.
03:01:14.340 - 03:02:42.090, Speaker A: So could the unsafe onload be moved to the method for creating a domain? No, unfortunately not. There are a bunch of requirements for load to be safe, and I don't think it's meaningful to move even some of the unsafety constraints to domain I because creating a domain is just like not unsafe. What's unsafe is when you load, you have to make sure that you load using the right holder. It's real dumb that this has to be static. All right, let's start exploring the Facebook codebase and see what they got here. Synchronization. Okay, so house pointer domain threshold for the number of retired objects to trigger asynchronous reclamation.
03:02:42.090 - 03:03:16.820, Speaker A: Hmm. Right. So they have a bunch of optimizations on like, they have these like tags and groups and stuff that we don't implement currently. Hmm. Currently, anytime you retire, it tries to reclaim a bunch of objects. And I think like here those are trying to be smarter about that. You see the, they have these like all these additional stats that are kept for domain.
03:03:16.820 - 03:04:09.350, Speaker A: They have an executor. The executor is presumably like the thing that a way that you can say what should be deleting in the background. Like if you want to do reclamation in the background, then you could spin up a thread every time you want to do it. But in reality, you probably already have a thread running somewhere that could do that work. Retire new house pointer, retire node. That's fine. Push retired.
03:04:09.350 - 03:05:16.872, Speaker A: Yeah, so a bunch of, this is just for sort of keeping track of these stats. You see like due time counts for the retire list to figure out when you should reclaim. Push retired is a full fence. Interesting. Yeah. As you see, rather than have a count that they decrement for the number of items that have been retired, they add the number of ones that have been reclaimed. Oh no, they add to the number of ones that have been retired.
03:05:16.872 - 03:06:39.010, Speaker A: I see auto r is retired. So I'm guessing retired here is retired is a acquire load of the retired list. Okay, so let's go back to, I guess, domain because that's the one we're looking at. So they're looking at retire. So we allocate a new node that's sort of the same thing they do. Okay, so retired, get me back to where I was, please. I see push retired lets you retire multiple objects at once, which is not something that we currently implement but relatively easily could, which makes a lot of sense, right? Because what you can do, and this is the nice property of linked list, is that you can just construct a sort of subset of the linked list and then atomically insert it into the existing one, which is nice, which is basically what they're doing here.
03:06:39.010 - 03:09:21.330, Speaker A: So there's a full fence before the push increment account, before we give anyone a chance to reclaim it. Okay, so there's a standard sync atomic fence. What does full fence here mean? Like, is that a sequentially consistent fence? Let's see what I want the definition of this one. Aha. If is Linux then asm volatile memory, otherwise offense. Why, why is this considered good enough? So I, what I, okay, what I don't understand is why is a compiler barrier sufficient but only on Linux? That just seems odd, like if we're on Linux and not on mobile, so I guess not on Android, then K's Linux is true and we can use a different kind of barrier. Why? All right, well I'm, I'm okay with using their definition here.
03:09:21.330 - 03:11:26.680, Speaker A: So I guess we'll say fn, we'll even call it the same as they do, asymmetric light barrier. And we're going to do if config Linux else standard sync sync atomic fence standard sync atomic ordering. Then what's our equivalent here? Where is the definition they use of that? Here we go. So it's not even if Linux, it's different on MSc. What, okay, but what is read write barrier in, in MSVC specifically? That's awful. That's awful. Okay, here's the thing though.
03:11:26.680 - 03:12:44.730, Speaker A: I know that the rust standard library has a compiler fence because I added it a while back, which is a single threaded fence. And the single threaded fence, I think differs by platform. That's the crane lift implementation. Where's the actual implementation? This has to be in mirror, like it gets lowered to like a don't reorder. But, but why does it not appear anywhere in the compiler source? Single thread fence. Aha. Mirror intrinsics becomes an atomic fence.
03:12:44.730 - 03:13:41.690, Speaker A: Okay, I just want to see whether we can use the simpler one and get the semantics of the more complicated one. Rust cogen LVM, what do we get for atomic fence? We get build atomic fence. Alright, LVM, show me your build atomic fence, please. That's unhelpful. Is that just what the. Okay, LVM rust build atomic fence. Great.
03:13:41.690 - 03:14:14.958, Speaker A: So that's gonna be over here. And that is a LVM create fence. We're really diggin deep here. That's unhelpful. Like, I don't, even if we find that this is the right thing, I don't know if I believe it. Alright, create fence. Wow, that's super helpful, LVM.
03:14:14.958 - 03:14:49.140, Speaker A: Thanks. Alright. Where have I seen memory before? Oh, this is what standard hint black box uses. In theory. We could abuse that here too, but that doesn't seem quite right. All right, let's not do that. But let's do look at intrinsics.
03:14:49.140 - 03:15:44.850, Speaker A: Let's see what we find here. These are all atomic fences. That's probably not very helpful. Equivalent to LVM memset. The reason I'm looking through this is because I want to find if for this and for that matter, for this. Oh, this is even worse. Okay, imagine that you're on Linux but you're not using nusi or clang.
03:15:44.850 - 03:16:10.706, Speaker A: Do you see the problem here? Let me, let me demonstrate. Don't program this way. Asymmetric link light barrier. If k is Linux, call this function. What does this function? Do this function. If you're in gnusi or clang, does this. If you're an MSE, does this.
03:16:10.706 - 03:16:56.000, Speaker A: Otherwise does nothing. So if you're on Linux and not in one of these three cases, your, your asymmetric light barrier does nothing, which seems like entirely the wrong thing to do. We could make it always be this. What is atomic thread fence? Is it a single thread fence? No good. Okay. Yeah, it's not a signal fence. That makes sense.
03:16:56.000 - 03:17:35.480, Speaker A: Why do what I don't understand also is why do they fall back to this? Here's what I'm gonna do to do. We did it, team. Good job. Back to domain. This is going to be a crate. Asymmetric light barrier. Great.
03:17:35.480 - 03:18:51.690, Speaker A: Close that, close this. And then it grabs the head of retire. So first of all, the count can definitely be acquire release, probably even relaxed. But I think we want it to be acquired release because we do need it to happen before we add to the list. And acquire release will make sure that acquire release is stores can't be delayed and loads can't be hoisted. So acquire release is actually not sufficient here kind of technically because we need this to take effect before this store because otherwise someone could, in theory, otherwise this could be hoisted to happen before this. In which case someone could see the new head but not see the updated count and end up doing a subtraction that ends up below zero.
03:18:51.690 - 03:19:53.050, Speaker A: Arguably, the right thing to do here is to never try to subtract from this, but. Or do this. That's fine. Okay, so the head here, they're saying we can load with acquire, right? So that's what we saw. Retire did it, loaded the head with. With acquire, and then it does a compare exchange week with release and acquire. Now, the other question here is, is the ordering the same for the c one and for Rust? Probably success and failure.
03:19:53.050 - 03:20:50.880, Speaker A: That's the same order as the rust one. So here, this is release, and this is acquirevere. And this one we want to be acquire release as well. So here, actually, I guess, yeah, they do the add down here, right? So they do the add after, which, you know, is maybe reasonable, I guess. Like, there's a question here of, we probably want to implement sort of their smarts rather than our smarts. All right, so let's do that. Fine, fine, fine.
03:20:50.880 - 03:21:43.978, Speaker A: So we're going to do this. We're going to have this be a fetch ad with release, and then they have a if check. So they have a check, which is a bool, which for them defaults to true. And it's like, if check, I'm going to remove the check from now and just say, letheme, isn't the load, like, always not equal to zero here? Basically, I think we're just gonna do this. That seems fine because we just added a thing. So there's something to reclaim, in all likelihood. So we should just try to run it.
03:21:43.978 - 03:22:26.976, Speaker A: And, of course, here, we should figure out whatever their check is. What's. What is their push list do? This is for their, like, cohorts and tags, which we don't use. So that's fine. This is check, cleanup, and reclaim. What does check, clean, up, and reclaim do? I guess we could just mirror this straight away, really, but, yeah, fine. Let's do self check, check, cleanup, and reclaim.
03:22:26.976 - 03:24:03.980, Speaker A: And we're gonna have a fn check, cleanup, and reclaim, which takes self, and it does if I. If self, try timed cleanup, and if self dot reached threshold r count, and h count, which I think is just their r count. I think this is the load. Yeah, it's the load of r, which is the number of retired elements, and h, which I don't know what is yet. So this is going to be self retire count load, and that's going to be an ordering acquire. So if that tribulk reclaim, and there's going to be try bulk reclaimed eventually, I'm sure. We'll actually call reclaim.
03:24:03.980 - 03:25:01.370, Speaker A: So I guess we need a try timed cleanup. We might just leave some of these empty for now, just so we don't have to implement all of the sort of complexity of their cleanup in one go. So I want this line to stick around. Try timed cleanup is if not, check sync time of sync time, which I guess we'll have to figure out what that parameter is for. If not that, then return false. Okay. Otherwise self dot relaxed cleanup and true.
03:25:01.370 - 03:26:06.710, Speaker A: So we need a relaxed cleanup which takes itself. How deep does it go, you think? Oh, check sync time is right here. Sync time is probably just a field on selfdevelop is my guess here. So check sync time probably doesn't need to actually take that. It's just going to be a check sync time which takes itself and returns a bool we know that much chrono duration, cast nanoseconds, steady clock now time since epic count. So this is figuring out, but this is just finding the current time in nanoseconds and the previous time it's loading from sync time. So I'm guessing sync time here is a field on this.
03:26:06.710 - 03:27:12.800, Speaker A: So this is going to be an atomic, I guess use u 64. That makes sense because it's nanoseconds. And I guess we might as well just have sync time here be atomic u 64 probably zero is fine, let's import that too. And now this is going to be let time is standard time instant, instant now duration since standard time epoch. I'm pretty sure there's a way to get time since epoch. Unix epoch. Oh, it's a system time, damn it.
03:27:12.800 - 03:28:41.310, Speaker A: System time now duration since, great, that's, that is what I want. So duration since and then I want that as so in duration there is from memory a as nanoseconds use 64 as as nanos which gives a u 128 as nanos. And I guess we're gonna do a u 64 from this is definitely fine. To unwrap current time is after the epoch. Actually I guess system time is set to before the epoch which we're just gonna not say is okay. And we're gonna say u 64 from, which isn't gonna work. Can we try from, can we use standard convert? Try from and then try from.
03:28:41.310 - 03:30:03.350, Speaker A: And then can we expect system time is too far into the future? Sure. Fantastic, great. So now we have the nanoseconds. All right, now what do we want to do with them? So now we want to all have rev time which is self sync time load. And this one was a relaxed and if time is less than prev time or not, or self dot synctime dot compare, exchange strong prev time with time plus casing time period with ordering relaxed, then return false, otherwise true. And this can be simplified a little bit. But we need this.
03:30:03.350 - 03:30:56.850, Speaker A: We need this ksing time period. Wow, great. Love that. Alright, so const k sync time period is a u 64 is equal to, I'm gonna make this from nanos, this dot as nanos standard time. This. Let's hope this is const I think it is. Sync time period plus sync time period.
03:30:56.850 - 03:31:31.470, Speaker A: Beautiful. Orlando. This dot iserror, that's what they're after. And this expected, four arguments. All right, that's fine. They're both relaxed. So this is like if it's not time to clean yet, or someone else is just started cleaning, don't clean.
03:31:31.470 - 03:32:39.086, Speaker A: So I'm gonna call this maybe I feel like many of the names here are not great. Like it's true that it checks the sync time, but really this should be something like is next cleaning period or something. So really I would probably rewrite this too. If the time is greater than prev time. If time is less than Prev, something's off here. I think something's a little odd because this means that you're just like, if, if time is later than a past time, which like seems obvious to be true, like, why would this not be true? Also, system time is sort of wrong here. Realistically.
03:32:39.086 - 03:33:49.622, Speaker A: This should be like a monotonic time, which is what instant gives you. But instant doesn't tell you about the Unicode, the Unix epoch, so you can't take duration. Since it's all a little stupid. Arguably we could just like get the time at startup, but. But what we could do here is if time is greater than, so time is greater than prev time and we succeed at this, then true, right? So if the new time is greater than the last time we did a sink, which feels like should most of the time be true? And if we like successfully say, oh, I see, prev time isn't actually set to the current time, it's set to the current time plus this period. I see. So that's why.
03:33:49.622 - 03:34:07.720, Speaker A: Great. So really this isn't like, I guess this is a sync time. So this isn't prev time. This is Prev sync time. Or something more like it. This should really be sync time. So this reads much better.
03:34:07.720 - 03:34:47.570, Speaker A: No, I specifically did not mean to use the available field. I wanted to do this, but thanks for catching it. Hmm. Oh yeah. The intel compiler is a case where you could be on Linux and have atomic barriers do nothing. That's good. There's a return zero at the top of bulk reclaim.
03:34:47.570 - 03:36:01.970, Speaker A: You are completely right. Good catch. Prev reclaimed. Okay, so we have checksync time now. Now we need relaxed cleanup. We don't have thread locals, so relaxed cleanup just does this bit down here, which is self dot retired, dot count, dot store zero. How does that make any sense? Relaxed cleanup is just store zero and then bulk reclaim.
03:36:01.970 - 03:36:38.200, Speaker A: What is their argument for bulk reclaim? Actually, let's make sure it means the same thing. It might actually not at all transitive. All right, bulk reclaim should be transitive. Num, bulk reclaims. All right, fine. We can keep track of that. That's fine.
03:36:38.200 - 03:37:46.240, Speaker A: N bulk reclaims is an atomic USA. Why not? So self dot n bulker claims dot fetch, add one, and that one is acquire while true. Yeah, so this is the example of where we use tail recursion instead. I think, I think that's the equivalent here, but that's fine. We can do the same kind of separation they did, so that probably means we can get rid of prev reclaimed. So while true is a loop. So we're stealing the retired, and that should be with acquire.
03:37:46.240 - 03:38:32.570, Speaker A: Then an asymmetric heavy barrier expedited. Wow, that's quite the barrier. Mm hmm. Asymmetric heavy barrier. I'm sure that one has no bugs either. Okay, so that's declared elsewhere. I guess we'll, we'll add it there and figure out what it's supposed to do.
03:38:32.570 - 03:39:52.400, Speaker A: Takes a flag. This is a, I guess a barrier heavy heavy barrier kind, which is going to be normal or expedited. And I guess we don't actually know what this function does yet. Let's try to figure that out. CPP. Oh no, there's another is Linux emprotectmembarrier, which creates a dummy page. All right, so this one also we're gonna go ahead and to do if config Linux, add a link to, well, first of all, stick this in here.
03:39:52.400 - 03:40:40.060, Speaker A: It's so silly. All right then this business, great. That seems like great chances for optimization later. 64 bits is not enough time. Mmm. Oh, do they have retired count as a, as an eye size? That seems pretty reasonable. That way we don't have to worry about this underflow.
03:40:40.060 - 03:41:12.470, Speaker A: Mmm, sync time is EU 64. Our count is an int now. Alright, that's fine. Well we can make it an int retired list. What? Where's my retired list? This count bite size. Fine, let's see what we got here. While true.
03:41:12.470 - 03:42:24.566, Speaker A: So we're going to loop and I guess we can, as we do have a lot of code just inlined here that they've just split up into multiple sort of functions. So here, um, they do a asymmetric heavy barrier with a heavy barrier kind expedited, apparently. Um, they just write full fence anytime they call it. But sometimes they use light barrier and sometimes heavy barrier. It's not entirely clear why rec is haspt load. I'm surprised that they don't do that. They don't like do a shortcut for if the retardless is empty, right? Like, okay, bulk, bulk lookup and reclaim has a while object and just, it's just gonna end up returning.
03:42:24.566 - 03:43:28.740, Speaker A: So I'm pretty sure we can just, I guess I'll leave it after the barrier. But this is definitely fine to just do that. But then they have find all guarded accesses, so that's gonna be, they call it wreck. I'm gonna call it first tas pointer or has pointers head. I guess that one they load with acquire and then, but this, so really this could just stay the way it was. Let's do that. And then they loop through all of them, which is the same thing we do here.
03:43:28.740 - 03:44:44.240, Speaker A: Although interestingly enough, they don't skip ones that aren't active. Maybe that's because when they drop haspter, they null the pointer as well, which isn't currently something we do. Oh, this can't say never deallocated anymore either. But while the domain lives, unless they have an implementation of next that skips over active, that could also be. So that would be in has pointer rec, probably. So what's their implementation of next here? No, that just returns next. That's interesting.
03:44:44.240 - 03:45:16.900, Speaker A: Yeah. So they really don't skip over ones that aren't active. Does the destructor? Because reset. We have a reset to release that's active to false. Yes. It's not entirely clear. This feels like it would, it's not quite right.
03:45:16.900 - 03:46:22.310, Speaker A: I think this does need to skip over the ones that aren't active. Folly doesn't skip active here, but that seems wrong. Oh, well, yeah, so we just record the pointer. And here they just use has pointer, which is probably even just a relaxed load, to be honest. Has pointer. Oh, it's an acquire load. Okay, so we need to do an acquire load here.
03:46:22.310 - 03:46:55.450, Speaker A: That's fine. And for next. I guess next actually never changes once the thing has been allocated. That's why this is just, this is why next isn't even considered atomic. In fact, that's kind of interesting. Maybe ours shouldn't be either. Maybe next really just should be a star mute this.
03:46:55.450 - 03:48:21.240, Speaker A: That it could be. I have too many ones now, but I think it actually should be. I think that's correct. Because when we allocate one, I need to import tomic eyesize. Once we allocate one, its next never changes again. So why have it be an atomic pointer? It doesn't need to be. That's a fair point then for each retired object, reclaim if no match and that they have in their own little if self dot bulk lookup and reclaim wreck which is the loaded head no obj which is steel.
03:48:21.240 - 03:50:15.890, Speaker A: So steel and the set that we made or not. Transitive. Transitive then break and then they ended there and then I guess, I guess what we'll do is, I'm at least, my assumption here is that bulk lookup and reclaim also take self takes stolen has pointers head which is a star mu tas pointer, sorry stolen retired head which is a retired yep. And a guarded pointers which is a hash set of star mute. What do we even store in there? We store pointer load which is a star mute u eight. And then I guess at the bottom of the loop they do self dot n bulk reclaims fetch sub one with release and bulk lookup and reclaim almost certainly is just the same thing we just did. Like the same thing we already had.
03:50:15.890 - 03:51:10.350, Speaker A: So they call it children and matched. But I'm guessing realistically this is just like the same code just phrased a little bit differently. So there's a while not node is null. So that's the equivalent, just our like obj. So node for us is stolen retired head next is object dot next which is equivalent to this part, right? So we set node to be the next one. I guess we could say let next is equal to this and then at the bottom say node equals next. It's like the, the equivalent to what they're doing there.
03:51:10.350 - 03:52:01.574, Speaker A: And that way we don't have to override node quite yet. And then d check any. So this is a debug check not equal object to next. So they have a debug assert not equal that node is not equal to next. That's fine. I wonder why they have that. But okay, I guess it's good to have checks for these things so that when you run something like loom or thread sanitizer or whatever, or not really thread sanitizer, but I guess loom is the best one.
03:52:01.574 - 03:53:03.132, Speaker A: Best example here, or a fuss tester, you want to make sure you have panics if something goes wrong, because otherwise your program will just silently crash. If the hash set contains the raw pointer, what's a raw pointer for them as opposed to just the pointer in as object? Raw pointer is probably just the name they use for, for the like, pointer to the data. Oops. Raw pointer returns this. Okay, great. So that's not super complicated. So that's the same thing as here.
03:53:03.132 - 03:54:07.148, Speaker A: If it contains the pointer, then if it doesn't contain the pointer, that's fine. I feel like it's valuable here to match their ordering, unless we have a reason not to. Okay, so if it doesn't contain that, then object. Reclaimed object and children. Not entirely clear what children? Why children is useful here. I guess we'll have to figure out what children eventually does, but so here we can reclaim it using the deleter. Oh, I'm guessing there's like the reclaimer can choose not to reclaim it or something.
03:54:07.148 - 03:55:05.190, Speaker A: Oh, it's probably for, they mentioned in the docs we read last time that they have support for like linked nodes. So like the deleter can know about the fact that nodes are like nodes may have in turn have other nodes that need to be reclaimed. So this is probably the way that you can say also reclaim these other child nodes of this node when it gets reclaimed. So that's something we don't actually need to worry about right now. This is where the child optimization sort of would be implemented. So I guess here we could leave a sort of to do for ourselves, which is support, support linked nodes for more efficient deallocation or something, children. So somewhat unhelpful comment, I guess.
03:55:05.190 - 03:55:57.490, Speaker A: Otherwise not safe to reclaim. Right. So here they push it onto matched, which is a linked list. And this is where we instead do. We stick it onto this remaining, which is the equivalent to pushing it onto a linked list. This now is, oh, this is why it's an atomic pointer for us, because we, yeah, okay, let's keep it an atomic pointer then. That's fine.
03:55:57.490 - 03:57:02.600, Speaker A: So I'm pretty sure this can be relaxed because for them, it's as if this was a normal memory operation. In our case, we do change it. We do change it, but only so that we can rejigger the linked list while we're walking it, rather than doing it in a separate pass. So they have to do this like, oh, I see, this is to splice in the children, and then they push retired. Right? So this is where I see what they're doing. So remember how push retired for them or sort of our retire, right. Only takes a single pointer.
03:57:02.600 - 03:58:14.640, Speaker A: Theirs takes a linked list of pointers where you want to retire all of them at once. And I see. So that's why they have the check, which is a bool, which all that really does is just stick them back on to the list and then call, like check, cleanup, and reclaim, which we can just do in line here, really. Okay. I think we're going to change the structure a little bit from what they're doing here because I don't think we want to recurse up to push retired, but they do. And I don't think that's valuable here because I don't want to have to construct a new linked list to pass to push retired. That seems unfortunate.
03:58:14.640 - 03:58:45.800, Speaker A: Although I guess we can reuse the next pointers probably. But realistically, what they're doing is just keeping a list of the ones that weren't reclaimed, which is the same thing we're doing here, right, with remaining. It's just they called it matched, we call it remaining. And we keep a track of the tail because we use that for the atomic parent swap. That's fine. And then they do object with next. We do node equals next.
03:58:45.800 - 03:59:21.900, Speaker A: So that's fine. Then they have some stuff for house pointer. And they do if children not count as zero. And why does this even return a bool? Well, it does return a bool, apparently. So we don't have children. So the children count is zero. So the question is whether retired is a null pointer and retired.
03:59:21.900 - 03:59:55.310, Speaker A: If I go back here, retired is a. I think it's just an acquire load. Great. So if self dot retired, dot head, dot load is, is null. Done. This is the equivalent of what they're doing, right. Because we don't have, we don't deal with children.
03:59:55.310 - 04:01:04.894, Speaker A: Then they splice children into matched, which we don't have to do because we don't have children. And then if this case is the equivalent, for if the tail is empty, then remaining is null, which is the same as the else case for them. So here they return, done. If it's sum, which is the equivalent for this case, then they call push retired. And instead what we're going to do is, I guess, note folly here calls push retired. We do the push in line below. So, right, so this is like, this is basically the code that push retire ends up executing.
04:01:04.894 - 04:01:50.960, Speaker A: And in fact, if we go back up, and this is presumably why they do it too, right. Is so that you don't have to repeat this code, but it has to like do allocation and stuff. And we don't, we shouldn't need to do that allocation. So they do an asymmetric light barrier, which I don't think we need to do do anymore. Although maybe we do, maybe we do, and then they do. Right, so this is just making the same changes we made to push retire. We just, because we're doing it here, we're doing it again.
04:01:50.960 - 04:02:29.440, Speaker A: This is a release. This is an. And I think those were the only real changes. And then the difference is going to be that down here, their code calls the equivalent of, like, up here. Right. We do a fetch ad for how many things are retired. And so here we're going to have to do the same kind of fetched ad, except this is going to be the number of things that we retired.
04:02:29.440 - 04:03:21.832, Speaker A: So I guess this is going to be retired zero. So here we're going to say still retired. So still retired plus equals one. So I guess here we can also say assert not equal, still retired zero. And assert equals still retired zero. And so here we're going to add the number of nodes that are still retired to the head of this. And the reason we add this is, remember, it does, like, the, the relaxed cleanup, which just sets it to zero.
04:03:21.832 - 04:04:12.328, Speaker A: So we need to add them back here. There's definitely a lot of, like, weird indirection in the c or not indirection, but, like, things are done a little bit here, a little bit there, and together it happens to work. I'm not a huge fan, but it is what it is. And then, so they push retired, which is the equivalent to what we do here. They push retard with false, which means that they don't do the check, which is the same thing as we're doing by not recursing, which would have done the check. And we're going to just not support block, and then we're going to return done. So this is a little weird.
04:04:12.328 - 04:04:32.420, Speaker A: Done. Seems like it would be potentially overwritten by this. So it seems racy to use done here, but. But that's what they did. Cannot convert an usize to an eye size. All right, so this is going to be an eye size reclaimed. Is not actually used anymore.
04:04:32.420 - 04:05:25.670, Speaker A: This is now node great bulk reclaim. See, I wanted to return the number reclaimed. I take that back. I think that's a useful thing for it to return. And then I'm going to have this be a usize and a bool, which is going to be reclaimed and done. This is also going to be reclaimed and done. And this is going to be assert done.
04:05:25.670 - 04:06:38.420, Speaker A: And who knows what this actually is going to end up calling I guess this should call like, bulk reclaim. This no longer needs that, but bulk reclaim. Probably true. So this now is going to be let mute reclaim to zero. Return reclaimed. Otherwise go in here and we're going to do reclaimed now. And done.
04:06:38.420 - 04:07:01.912, Speaker A: It's going to be equal to that. Then we're going to do reclaimed plus equals reclaimed now. And then we're going to do. If done, then break this, and then reclaimed. This is now get mute again. That's fine. So that way.
04:07:01.912 - 04:07:28.082, Speaker A: Now this can actually return this supply. Two arguments. This should just be one. Great. So the code we wrote is actually pretty closely aligned with what the Facebook code does. If you like, you just squint a little bit about where we draw function boundaries and stuff. But apart from that, it looks pretty nice.
04:07:28.082 - 04:08:35.430, Speaker A: This expression has type us great and reclaimed is right as eye size. That's fine. Yeah, tuples are great. Tuples aren't very great. All right, but, but now to go back up to the, the tower we were once in, there's like something. I think this one no longer needs the check argument. But folly has if check here, but only for recursion from bulk reclaimed or from specifically from bulk.
04:08:35.430 - 04:09:07.270, Speaker A: Lookup and reclaim. Lookup and reclaim, which we don't do. So check isn't necessary. I mean, we could have a check bool here that we just like assert is always false. But I think it's fine for us to have this here. And then if we ever find somewhere else that tries to call it with true, we could just. Okay, we're going to need it after all, reached threshold.
04:09:07.270 - 04:10:00.418, Speaker A: Because a reached threshold is a thing that we don't have yet that we're going to need. Right, so where is, I was right there. I was right there. Reached threshold. Alright, so there's an fn reached threshold, which takes a, I guess an eye size, which is the RC, and an HC, which I don't know if we need Hc yet. We don't have HC yet, so I'm gonna skip it for now. That returns a bool.
04:10:00.418 - 04:10:39.520, Speaker A: It's a const FN and it just returns. Is RC greater than or equal to threshold? Solid name for a constant. Oh, okay. Where does this come from? No, that's not what I wanted to do. This 1000. That's just, it's just a constant. It's just a thousand.
04:10:39.520 - 04:11:28.320, Speaker A: Because of course it is. Why the indirection? I don't understand why the indirection? Okay, so we're gonna call this domain rcount threshold. It's gonna be an ice. Ice. It's gonna be a thousand because that's what it is. All right, fine. That's fine.
04:11:28.320 - 04:12:06.950, Speaker A: This is all fine. So reach threshold is just, is this value greater than 1000? And this is going to be domain r count. It doesn't even need to say domain because we're in the domain file. Great. So reached threshold up here is actually just, this should be retired. Great. This no longer has to be zero.
04:12:06.950 - 04:12:48.350, Speaker A: That's good. What are we missing? There's still definitely something missing in here. There's no way we have the whole implementation. What is H count? That's the other thing I want to know. Oh, it's the number of hazard pointers which never goes down. Does it actually never go down? It never goes down. Okay.
04:12:48.350 - 04:13:17.418, Speaker A: Okay. So they keep a count of the number of hazard pointers. That makes sense. But here's what doesn't age count. Reached threshold. Oh, I see, I see. Okay.
04:13:17.418 - 04:13:44.920, Speaker A: It's less dumb than I thought. So it's if the number of retired objects is more than twice the number of hazard pointers. Got it. All right, so there, so reached threshold is going to do this. And this, right. H count is also an acquire load. Okay.
04:13:44.920 - 04:14:38.890, Speaker A: So this is going to be a. Has pointers. So has pointers down here is going to also gain its own count field. Reached threshold is now going to take, I guess, HC, which is an eye size. So it's this. And RC is greater than multiplier times hc, multiplier. So H count multiplier times hc and H count multiplier is two.
04:14:38.890 - 04:15:06.220, Speaker A: Right, two. Great. Got it. And then where do they increment h count? They increment h count whenever they give out. Whenever they give out a hazard pointer, which is in acquire. I guess we should look at acquire too. Right? See that it does the right thing.
04:15:06.220 - 04:15:53.480, Speaker A: Allocate one rec set, active, ret. Set domain. That's interesting. So they set the domain here, which I found fascinating. Oh, this is if, you know, you need a new one. So that's, that's this part specifically which says. So they stored the domain in the hazard pointer itself, which we're not currently doing.
04:15:53.480 - 04:16:43.646, Speaker A: We have the holder do it, but not the hazard pointer do it, which I think is probably fine. I guess that means that you could use one holder with multiple different domains. I feel like that's probably not worth it, especially given that we sort of want to avoid the abuse here. So if you allocate a new one, then allocate one, which we do. Stick it at the head of the linked list, which is our loop here. Which loads the head here. Just, there are too many heads.
04:16:43.646 - 04:17:27.500, Speaker A: I want the ability in c to do like fn space nava function. That is an acquire. I don't know if they've thought very carefully about these. I think they just went with acquire for every load and release for every store. But who am I to say then set the next ahead compare exchange week with release and acquire. And if that succeeded, then we break. Otherwise we retry with the new head.
04:17:27.500 - 04:17:52.684, Speaker A: Huh. They have to do another load. We don't. We save a load because the compare exchange returns the old value. Nice. And then they add to the count once they break here. So here self dot has pointers, dot count, fetch add one.
04:17:52.684 - 04:19:08.138, Speaker A: And that is, what's the ordering of this operation? It does the c fetch ad have a default for ordering? Because that sounds scary as hell. Okay, it defaults to sequentially consistent. Is that what they meant to do here? That's the only saying default. But, but, but why is this a sequentially consistent ad? Like when we increment r count, it's a release. All right, if you say so. All the domain lives. Note folly uses sec const here because it's the default.
04:19:08.138 - 04:20:18.120, Speaker A: Not clear if necessary. All right, well, oh, I guess I do have the source locally. I could have done that, but it's fine. It is handy to have them in tabs. Okay, well that's not too bad. So where is the thing that actually calls trot? So they have try acquire existing. I guess we should probably do the same, right? So this try acquire which returns like, I guess an option has point which does sort of all of the outer stuff of this function.
04:20:18.120 - 04:21:48.184, Speaker A: It loads the head, which is an acquire load. It walks them. And pretty sure the tri acquire here is just a load of active which is an acquire. Oh, I see they do this slightly differently. So they say, while not notice null if I guess we can do this, let n is unsafe of that while the domain lives. So we have an n here and, and then what they do is a try acquire and the try acquire here is load active and then try to compare exchange it. So I suppose we could add this to pointer.
04:21:48.184 - 04:22:52.110, Speaker A: That's pretty easy. So probably fn try acquire returns a bool and does, I guess actually this could return like an option mute self. But I don't think we actually want to do that. So this is going to be let active is self dot active dot load of acquirever. So this is return not active. And we managed to compare swap or compare exchange of the current active with true, this could have been false. And with release and relaxed dot is okay.
04:22:52.110 - 04:23:31.868, Speaker A: So here then we can do if and try acquirever then return n. Otherwise no equals n dot. Next, dot, load. And next, I think was an acquirer. No. Right. This is where next for them is not an atomic.
04:23:31.868 - 04:24:05.760, Speaker A: So it's probably relaxed. That's fine. And then otherwise, so this doesn't need to be a loop. And then this can just be none. And then there actual acquire. Then the calls. This is our acquire.
04:24:05.760 - 04:24:41.110, Speaker A: And our acquire for them is called acquire new. And their acquire. Oh, man. Their acquire. I do like the separation. Like this one is actually nice. Which is going to be something like if let some has pointer is self try acquire existing.
04:24:41.110 - 04:25:32.690, Speaker A: Then return that. Otherwise, yeah, this is where having an option type is nice. Oh, what did I just do? Otherwise? Self acquire new. And this part we just did. This is the exchange it to true, which we've already dealt with. And so all of this now just becomes acquire is going to try acquire existing. And if it fails, this is a sum then it calls acquire new.
04:25:32.690 - 04:26:05.880, Speaker A: And this one our acquire new. Didn't I just change this? Our acquire new is going to. That's a try. Acquire existing. So try. So our new one doesn't even have to do this walk. Our new one just does the allocation bit, which is here.
04:26:05.880 - 04:26:46.570, Speaker A: And it doesn't need to break. It can just do that loop. This goes away. This goes away. This is the head of self has pointers. This is also the head of has pointers. Right.
04:26:46.570 - 04:27:05.700, Speaker A: So this compare, exchange, it sit into the start of the list. And this should be head. Beautiful. Beautiful. That is much nicer. I agree. And less, less indented too.
04:27:05.700 - 04:27:42.938, Speaker A: And we have n bulk reclaims, which is an atomic u size new zero. Beautiful. That's not okay. This has to be a load of ordering relaxed. That's fine. And I don't want to dereference it. The code is inactive.
04:27:42.938 - 04:28:11.346, Speaker A: Great. What else we got in here? So we now have, I think acquire. Try acquire. Acquire new. Those are all fine. There's what is their retire look like? Their retire is just calling push retired with a node list of none. Great.
04:28:11.346 - 04:28:35.862, Speaker A: And that's effectively what we implemented. And they call push retire. And push retiree has checked default to true. We don't have check, but we always do the check. So it's the same thing. So that means this is the correct thing to do. Check, cleanup, and reclaim.
04:28:35.862 - 04:29:02.490, Speaker A: We have check, cleanup, and reclaim. It does the same thing as this one does. Try timed cleanup. We have check sync time. And we have relaxed cleanup. They call try bulk reclaim. And try bulk reclaim.
04:29:02.490 - 04:29:32.580, Speaker A: We don't have. So I guess we got to have tribulk reclaim, which probably just calls bulk reclaim, but it does some more things, too, so. It does. He itself has pointers. Dot count, dot load of. This is an acquire and same with RC. That's retired dot count.
04:29:32.580 - 04:30:21.324, Speaker A: And if not, self reach threshold, RCHC return. This returns a. This just returns. And then it exchanges self retired count. Swap zero with ordering release. Because at least this is a swap, right? The thing that bothered me about. The thing that bothered me about the other one was the cleanup.
04:30:21.324 - 04:31:00.142, Speaker A: Relaxed cleanup is that it just, like, stores zero, which is really weird. Although I guess, actually, my. It almost feels like there's an assumption here, right, of when you're doing a. Oh, it's because it's transitive. So, you know, that'll end up zero. There's, like, a weird property here where. Okay, relaxed cleanup only gets called if it's a timed cleanup.
04:31:00.142 - 04:31:44.368, Speaker A: And the timed cleanup has a compare and swap, which means that only one will happen at a time, and only one will happen every so often, right? Every. What is it? 200 milliseconds, whatever that nanosecond constant was. So, yeah, so maybe they just assume that this bulk reclaim is going to finish in time for the next period anyway, and therefore they can just store the zero here. It seems really sketchy, but, you know, it's a. It's a thing. So this swaps rc with zero, and then it checks this again. Oh, there's a comment.
04:31:44.368 - 04:32:46.290, Speaker A: Wow, there's a comment in the code. Holy smokes. No need to add RC back to self retired count. At least one concurrent tribulk reclaim will proceed to bulk reclaimed. I don't know if I believe that either, but it's commented, which means it must be true. So we're just going to assume that that's true, and then otherwise, it calls self dot bulk reclaim with the bool unspecified, which means false, right? Transitive is false. All right.
04:32:46.290 - 04:33:27.659, Speaker A: And call that. Right. There's. We also have our eager reclaim, which, I wonder, is even sane now, like, I. In some sense, I feel as though there is a, like almost that some of these are unsafe and, like, expected to not be called concurrently. Although having written them, they all seem like they should be safe to run concurrently. Right? Because we do the atomic swap of the head with null, so even if they run concurrently, there shouldn't actually be a problem.
04:33:27.659 - 04:34:19.156, Speaker A: So maybe that's fine. Maybe that's fine. Oh, I see what's going on. It's always fine to set the count to zero, because if the count. Because the next reclaim is going to count all the retired objects anyway, so it's just going to end up setting retired account again, I guess, is the. The reasoning here. Bulk reclaim, we have this, we have checksync time, we have try cleanup, try acquire, acquire new, invoke, reclamation and executor.
04:34:19.156 - 04:34:44.170, Speaker A: No, that's background stuff that we don't want to deal with. These warnings we haven't implemented. All right, this seems pretty promising. Let's see that the test suite still passes. It doesn't even compile, so who knows? This kind is currently unused. That's fine. Test lib.
04:34:44.170 - 04:35:22.980, Speaker A: Eager reclaim and eager reclaimed. An eager reclaim. Ooh, a failure ordering can't be stronger than a success reordering. That does seem like a correct thing to complain about. Domain lane 94. A failure ordering can't be stronger than a success ordering. Is acquire stronger than release.
04:35:22.980 - 04:36:36.444, Speaker A: Like, is it? It's not really. Ah, that's what they specify. That's fine. I mean, this can be an acquire release, so I guess note folly uses release, but rust doesn't consider that stronger than acquire. Another one in retire 137 seven. I guess this is the same thing. Is there another one? Oh, man, this seems like a bug in rust.
04:36:36.444 - 04:37:31.470, Speaker A: Like, like, it seems fine for the success ordering to be released when the failure ordering is acquire, given that the success ordering. Oh, I see why they're complaining. Because a success ordering is a load and a store. And so if you just use release here, you're not saying anything about the ordering of the load, which the failure ordering does. Okay, arguably the C code should be using acquire release, because that's what it's implying that it is. Okay, fine. We're just gonna use this release, but needs to be both for the load on success is really what this should say.
04:37:31.470 - 04:38:13.270, Speaker A: Oops. This. Alright, but it passes. That is good to know. All right, so this now will be match follies domain implementation, right? I think one of the reached threshold calls. I think you are entirely correct. This needs to be this way.
04:38:13.270 - 04:38:47.624, Speaker A: Good catch. And now push it, so it must be done forever. Great. All right, that's pretty good. That's pretty good. I think this check. This comment can now go away here.
04:38:47.624 - 04:39:29.176, Speaker A: Oh, I guess this shouldn't be a to do. It should just be a comment that explains why we don't have the check. What other to dos do we have children, which we don't support. That's fine. All right. Has pointer holder, so let's go over to the holder and see what they do for the whole. Okay, that's the destructor they call acquire in the domain.
04:39:29.176 - 04:41:09.370, Speaker A: That's fine. I guess load is the one I want to see, which is the same as try protect. Right. So they have a variant of triprotect which is, I see, so there's a, here's one thing that they have that we do not, which is for them this is a, there's a tri load which takes a, a sort of current which is a star mute t. And the idea here is treat this as, I've already read this variable once, so you don't have to read it the first time. Remember how we have to like read then protect the thing we read, then read again to check that it didn't change. So the, this is sort of a method that you can call if you, you can call this method if you've already done the read once yourself and you, so you only need us to do the protect and the second load and then I guess we can then provide load.
04:41:09.370 - 04:42:41.900, Speaker A: Fstatic is so stupid here, which is just going to do a, this used to do I need this load, thank you very much. Which is just going to do this and then self dot triload of PTR One and PTR and this doesn't take current and okay, they call it protect. Oh, I see. There's even a slightly more of a subtlety here which is, so they provide, there's sort of a, there's a try protect and then there's a protect and then separately there's load. Why did it remove the pubs from that? Oh, cuz they're, that's why. So try protect doesn't actually return you the, I see, I see, I see, I see. So try protect just tells you whether or not the target has been protected.
04:42:41.900 - 04:43:22.858, Speaker A: It doesn't actually give you the, like a reference to it doesn't load it for you. Right. So try protect here returns a bool of is it now protected or is it not? And what we do with try load is that it actually returns you the pointer. So really this is try protect, it's just a better one, right. It returns to not just a bool, but it returns like an option of if it isn't protected then we return none. If it is protected then we return some of the reference. So we sort of do the dereference for you as well.
04:43:22.858 - 04:44:19.790, Speaker A: If that turns out that it can be safe. Safety here is same safety requirements as try protect. So this should be protect if you will, and this one protect although these are backwards, this should be protect and this should be triprotect. Why is this an option? Like when can this return false. I see. It returns false if the second load doesn't match. That's why.
04:44:19.790 - 04:45:26.288, Speaker A: So why do we have a loop here? Okay, so they have two variants of protect. They have one that, see. Their protect does also return a pointer. I see. And their triprotect. Their triprotect does not loop, but their protect does. Why do they need the f reset protection of f of pil, I wonder, for stealing bits of the pointer word.
04:45:26.288 - 04:46:09.350, Speaker A: Oh, I see. This is like if you, if you have like a, an atomic pointer type, but you have like flipped some bits in it so the actual pointer isn't the real one you need in order to turn it into a reference. That's what's going on. Okay, that's kind of neat. So this seems a little inefficient, though. This because you, it means that you're, it means that if you fail, you do an extra load. So we can do a little bit better here by having this return a result of a reference or a star mute tea that you can retry with.
04:46:09.350 - 04:47:14.166, Speaker A: So let's get rid of the loop and this and this. And in this case, we're going to return, okay, of, I guess this should be an option because it might be null. And in the else case we're going to return error of pointer two. Right. So if the pointers don't match, we return what we loaded the second time. So that if you call us again, you can use try protect and you can call try protect again without having to do the load again. In fact, this is super weird, because why would you expect this to succeed? It's an out parameter in c.
04:47:14.166 - 04:47:43.100, Speaker A: Try protect will overwrite pointer for you as well. Ooh, that's disgusting. I would rather this be a result. I don't want an out parameter here. Yeah, I don't, I don't want that. That's, that's bad. I don't like that at all.
04:47:43.100 - 04:48:26.880, Speaker A: So let's see, what do they do? And try protect. Try protect calls. P is pointer. Thanks. Reset protection. What does reset protection do? What does reset protection do? It resets the hazard pointer. Okay, so in try protect, we first make sure we have a hazard pointer.
04:48:26.880 - 04:49:58.580, Speaker A: Then we call hazard pointer. What even is this? That's fine. HP rec. So this is check that we have an actual hazard pointer. Reset protection. This is weird though, because where do they actually check that they have a. Oh, they're using, not entirely clear how this ends up getting called make hazard pointer.
04:49:58.580 - 04:51:14.182, Speaker A: Oh, so they do always acquire one. So you can't have a holder without a hazard pointer. Okay, well I guess we'll match that then. That seems fine. So this is always going to have one of these and the hazard is going to be domain acquire this now doesn't have to do that, although I wonder whether there's like a, is there a way you can like give up your HP wreck? I see, yes, you can make an empty one. Oh, I see. So what they've done is actually oh, I see what's going on.
04:51:14.182 - 04:51:52.620, Speaker A: So you can create a holder without associating it with the domain. Like you can, you can get a holder that doesn't have a has pointer yet and presumably you can also reset one so that it no longer holds one. But if you're going to call try protect by that time you must have one. I think it's what's going on. It's like if you call make hazard pointer, it'll create the holder and also immediately assign a hazard pointer to it. But you can also use the empty constructor. Create a holder without a pointer in it.
04:51:52.620 - 04:52:48.604, Speaker A: I see, so this is if you move it. That's weird. Oh see it's so that, I guess this is maybe so that you can clone it although the clone would be none. Yeah, that's weird. Recent protection swap. I see. You can set it to a particular one.
04:52:48.604 - 04:53:37.700, Speaker A: So this seems a little niche. I think maybe we just require that it be set for now and just don't provide the empty one. And then in the future we could if we wanted to, but. All right, so now I see. So that's why reset. No? Yeah, that's why reset protection has this assertion in it is because otherwise you could try to protect using a holder that doesn't hold a has pointer and that's what they want to prevent. But basically what this does is it calls self hazard.
04:53:37.700 - 04:54:53.350, Speaker A: I see. It resets the hazard pointer. So that's going to be reset and that's over on pointer, which really just should have a reset because why not? And reset just stores. I see. So they have a set really a null mute with release and I'm guessing that it's the same for interesting setting. Active is relaxed, that's fine. So this one is also released then.
04:54:53.350 - 04:55:43.780, Speaker A: So in here it's going to call reset. That's the first thing we do in protect. We do reset, then we do a full fence. This is an asymmetric light barrier this time then we do a, I see, they call this pointer and this source. That seems fine. And then here we'll do so. Has pointer to protect pointer.
04:55:43.780 - 04:56:09.150, Speaker A: This is self dot has pointer. Then we're going to load it the second time. Oh, they don't call protect yet. Reset protection. Oh, this doesn't reset. It just, the name is just stupid. This is protect.
04:56:09.150 - 04:56:48.760, Speaker A: They just call it reset. So this is protect pointer as star, mute u eight and then a barrier. And then pointer two is source load with acquire and then this. They have like a. I don't think there is a likely in rust yet. Oops. There was debate on this, but I don't think it's standardized yet.
04:56:48.760 - 04:57:29.980, Speaker A: Yeah, this intrinsic does not have a stable counterpart. I think it's something they've been debating, but I don't think it's something you can currently do. So if pointer not equal to pointer two, they call them p and pointer. That's awful. Awful. Then self hazard resettle and return. And this is where we're going to return error to.
04:57:29.980 - 04:58:18.760, Speaker A: And just to avoid the indentation we're going to go here and say all good. Return. They return true. We give you the actual dereference. Nice. And I guess we can say this reset what hazard and drop for the holder. What do they do for dropping the holder? They just do.
04:58:18.760 - 04:59:00.620, Speaker A: If it's not null we don't have the case where it's not null. Then reset. Reset has pointer which. Why is that not the same? Yeah, that's just a store. I don't like it. So that's going to be self dot hazard dot reset. And, and then return it to the domain which they write as domain release.
04:59:00.620 - 04:59:48.900, Speaker A: Domain dot release of self haspt, which probably just sets active to false. But I guess we might as well just add their release which just calls release on the HP rec which just sets active to false. So fine, fine. I'm not gonna complain. Not gonna complain. I'm light as a feather. Pub fn.
04:59:48.900 - 05:00:43.930, Speaker A: No fn release. Release is gonna be given a, a hazard which is going to be a has pointer. And what's it going to do? It's going to call hazard dot release. And what is that going to do? Well, release on this. This is going to be self active store false ordering release right there. Great. Okay, fine, fine, fine, fine.
05:00:43.930 - 05:01:43.330, Speaker A: This should say hazard and that probably needs to be pubcrate and. Right. We didn't do our try protect. Right. So here, this is where we can now do a little bit better than their, than their protect. So their protect is a dual load which is relaxed. And then while.
05:01:43.330 - 05:02:24.256, Speaker A: So, so I'm gonna do a loop here. I'm gonna match on this, and if I get back an okay ref, then I'm gonna return, I guess. Break. Break is fine. Break with r. If I get error of pointer two, then I'm gonna set pointer one as pointer two. And in fact, let's call this source.
05:02:24.256 - 05:03:07.140, Speaker A: It'll make it a little bit nicer. So pointer, source, pointer, source, pointer two, pointer equals that. And then go around the loop again. It's complaining. Why is it complaining? Because that's interesting. Well, so the, the thing that this saves us from that the other one has to do is. Oh, right, no, it's an out parameter there.
05:03:07.140 - 05:04:16.500, Speaker A: This is just a nicer way, at least to me, to structure this return. Why is this not okay? Selph was mutably borrowed here in the previous iteration of the loop. Cannot borrow self as mutable more than once at a time. Time. Oh, this is a known borrow checker problem, where basically it doesn't realize that I've run into this before. The borrow checker doesn't realize that we don't hold on to anything. We don't even, even though what self returns is tied to the lifetime of the borrower of self, the case in which we take advantage of that lifetime, we break from the loop.
05:04:16.500 - 05:05:26.270, Speaker A: Oh, what's the work round for this one? Oh, I don't even remember. I remember this being really frustrating last time I ran into it. Borrow checker, self mutable loop. What else? Keywords previous iteration. Yeah, it's this one. It's almost certainly this one. Well, okay, this is a particularly ridiculous one, but slightly less artificial example.
05:05:26.270 - 05:06:15.568, Speaker A: Yeah. In fact, this one. Yelp comment. This out to no compiler. Yeah, it's the same problem. And yep, I commented on this in 2018, and it requires Polonius to fix the so comment from Nico 25 days ago. There isn't much active work on Polonius.
05:06:15.568 - 05:07:20.530, Speaker A: Okay, so we have to work around this ourselves. I think the way we have to do this, there's like some really stupid workaround. It's something like hurting my brain. There might not even be a workaround here, actually. I mean, there is some workaround. It's just like the workaround might actually be fairly annoying, like inline the implementation of triprotect. But I feel like I've done something slightly cleverer in the past.
05:07:20.530 - 05:08:20.760, Speaker A: Uh, I forget whether there is a. Yeah, so this is that one. Right? So there's a. Right, and this is the observation that something's broken and no real answers as to possible workarounds. Yes, this is the exact same problem, and all of these are the same issue. Really, they're all duplicates. The workaround is something like this.
05:08:20.760 - 05:10:08.120, Speaker A: Tldr Polonius is supposed to fix this. Repeat the borrow here, where it can never reach the latter use. All right, so something like if x dot is if let ok r is x, then break r. Is this the workaround else like I guess panic, or maybe I can even just do. Well, let's see if that works first and then pointer two is x. Unwrap error what? It's trait bouncer not satisfied because the type doesn't implement debuggest. Fine, if let error pointer equals x.
05:10:08.120 - 05:11:06.440, Speaker A: So painful. Else panic this that this does it compile now it does not. What about if I return? It does not. Alright, Niko, what do you mean here? Input dot. So it's rematching on the input data. This may just not work. Yeah, I mean, that's also wrong, but.
05:11:06.440 - 05:12:38.000, Speaker A: Oof. I mean, we can work around this by inlining the whole implementation of try protect. I believe, I believe that's true, but I don't think we can do what's suggested here, because basically what he's proposing is do the match using a shared borrow, and then do the exclusive borrow only later. That's not an option we really have here, which is what makes this awkward. So I think we just have to inline it, which is really unfortunate. Could maybe make it a macro. Should we make it a macro? I think maybe we should make it a macro.
05:12:38.000 - 05:13:07.332, Speaker A: Okay, it's. Damn it. I hate, I hate running into things like this. So the reason I hate it so much is because I know that I can express what I want in the compiler without these ugly hacks, but the compiler isn't smart enough to realize that it's correct. Bad sad. Macro hack thingy. I'm going to give it a better name.
05:13:07.332 - 05:14:19.090, Speaker A: Just give me this one. Give me the reason I don't want to repeat it is because this code is like fairly nasty, and I just don't want to run into a situation where there's a bug in this code and we fix it in one place but not the other. Like that's just real unfortunate. So I'm going to take self, which is an identity. So that's going to be this. I'm going to take pointer, which is an ident. And this is now going to be, I think this now has to be a block to not cause too much headache.
05:14:19.090 - 05:15:14.680, Speaker A: This has to be pointer, and then this has to be source, which is an ident. So this is going to load from that. This is going to be selfdevelop unused macro. That's fine. This whole thing is now just going to be fine. I'll give it a better name. Try protect actual of point of self and pointer and source and the types don't match up.
05:15:14.680 - 05:16:22.896, Speaker A: Why did I add a semicolon when I shouldn't have? Almost certainly. Right, this needs to be a block, otherwise it doesn't do the right thing now try protect does the right thing. And now this can go, can go here. And I think that will just do it. Yep. Now it's the tests and then let's be nice to ourselves in the future and say this is really just, this should really be the body of try protect and then protect should call try protect. But that runs into a borrow checker limitation circumental.
05:16:22.896 - 05:17:25.980, Speaker A: This issue, this issue, this issue and this issue. And for my own sanity and OCD, we're going to order them. All right, and in test lib, what do we have left here now? 115. So that's every load is going to be a protect now. Oh wait, these shouldn't be. Fantastic. So I guess this will document as match Follies has pointer holder implementation.
05:17:25.980 - 05:18:11.120, Speaker A: There's just enough time between each commit that I have to type my password each time and it's real frustrating. Git push. All right. I don't vote for inlining it. Does it strongly dislike macros? Normally I would for something that's only 25 lines, but not 25 lines that are as hairy as this one. Okay, I think we now have. Let me close these down.
05:18:11.120 - 05:18:33.766, Speaker A: Did I even forget an issue? I probably did. That's fine. Doesn't seem worth it. Sorry for blinding some of you. Let's go back here and look at haspointer holder. So has pointer holder is sort of the big one. And then I guess there's haspterobject.
05:18:33.766 - 05:19:27.190, Speaker A: So that's really the only one we have left which has retire, but retire on object, I think just calls retire on the domain. I don't think there's anything else for it to really do. They have these cohort tags and stuff that we don't currently implement. Haspterobject list haspterobject cohort. But I just want retire. Great. Base calls preretire setreclaim push object, pre retired, check set reclaim and push object.
05:19:27.190 - 05:20:01.760, Speaker A: Okay, so pre retire, check. What does set reclaim? Do set reclaim just. Okay, so this is all about setting the deleter and stuff, which we have our own little mechanism for that part should be fine. That's really just sort of type juggling. The pre retire check is has pointer. This is for hasbro interject. Great.
05:20:01.760 - 05:22:04.474, Speaker A: Is just next not equal this. Okay, so we can implement that pretty easily, which I guess is here. Okay, so if self, okay, so let, this is unsafe self, this should be fine because it's by safety guarantee one. So safety by safety requirement number one. And then I guess here we can say safety by the combined requirements of this method. The reason I wanted to do this was if this is, this also seems weird. So if they say if this not equal to next, this dot next, why do they even have a next? They have a next so that they, oh I see, they have a next so that they can basically intern the linked list.
05:22:04.474 - 05:23:17.970, Speaker A: So remember we have to, in the domain when we want to retire things, right, we have this retired struct and the retired struct holds the pointer, the deleter, and next, well we have to allocate and deallocate these retired objects. And then we take, we stick the users, the real users objects into this. What you can do is instead have the deleter and next fields be a part of object, just like the domain has to be. And that way you don't have to have this wrapper, you sort of Del, like we would basically do the same of like set next, get next and just require these methods of the implementer. And that way we don't have to do this. This additional allocation for each retirement probably arguably worth it, but also a decent amount of added complexity that I feel like we would avoid. At the same time, those fields would realistically just go into the haspter object wrapper.
05:23:17.970 - 05:24:24.350, Speaker A: So maybe it's just like not, maybe we should just make that change. I guess that's why they don't have this retired type, because you just, you just inline it instead. Although that gets a little weird because you need to type erase in any case. So what they do here is no sure that works. If next not equal this, then fail, right? So we can't actually do this check because this check doesn't make sense for us because we don't have a next pointer that's inline in the structural. So I think we're just gonna leave this the way it was and that's fine. And so they do the pre retire check, then they do set reclaim and set reclaim.
05:24:24.350 - 05:25:54.476, Speaker A: Just set the deleter which we don't have to do, and then push object, which is just push to retired, which is the same as retire for us, or push to retired here, which is has pointer domain push retired, which I assume is just here of that and check, which is true, which is true, which is check is always true for our retire. Great. Okay, so I think, I think what this means is we now have a, an implementation that matches the, the folly implementation modulo that like additional features and optimizations that they have. We have support for multiple domains. What's sort of missing is, apart from the optimizations and the, and the additional features, is just this whole, like this whole testing thing that apparently people like. No, realistically, there's a bunch of testing that's missing here and there's also just like tidying up the interface. In fact, we could arguably do that.
05:25:54.476 - 05:27:01.970, Speaker A: Now, the reason I'm hesitant to start renaming things yet is because it is just really helpful to be able to use the same names for things while referring to the code. And because there are still optimizations and features to implement. It seems like maybe you'll be valuable to keep the names for a little bit longer until we've implemented them, at least until we've implemented the ones that we know we want to implement. Like the cohorts may be valuable, for example. But I do think the next step now needs to be better testing, which in all likelihood is just going to be essentially building out a bunch of test cases with loom, which should pretty quickly catch a, any errors we may have made here. Although if there is here at this point, I feel like it's likely that they're also in the Facebook implementation because we match it pretty closely now. But given that we're now at the five and a half hour mark, I think we're gonna call it there.
05:27:01.970 - 05:27:29.990, Speaker A: I think this is a pretty good place to stop. I think we have something pretty good here. And I pushed everything I had, right, great. As I mentioned at the, at the top of everything, I'm taking a vacation. Finally. I didn't really take a vacation after my PhD, so this is the time. So I'm gonna take a break from like the end of next week for about three weeks or so until like mid August.
05:27:29.990 - 05:27:54.672, Speaker A: And so the next stream will probably not be until then. I might also do another crust of rust before I do part three of this. I haven't quite decided yet. I. But in any case, there is more to do here and we will do more, I promise. I'm excited to have a library for this too, so that's really fun. But in the meantime, take care of each other.
05:27:54.672 - 05:28:14.954, Speaker A: And hopefully this was interesting. And I think we got to something pretty cool. I'm pretty happy with where we landed. There's room for improvement. I'm sure people will find a bunch of bugs in the next, like, two days, but also while I'm away. But we'll pick those up when we come next time. All right, everyone, thanks for watching.
05:28:14.954 - 05:28:27.530, Speaker A: And I guess if you're watching the recording, no time might have passed between now. Like, the vacation is irrelevant to you. So in that case, you can just jump to the next video. Otherwise, I'll see you in, like, a month. Bye, everyone.
