00:00:01.240 - 00:00:33.185, Speaker A: Hello everyone. Welcome back. It's time for us to do more proc macros because I ran a poll and everyone wanted more proc macros. So that's what we'll do. I also ran a poll about whether people wanted to see chat in the video and the consensus was that we should not have it. Keep in mind that if you are watching this sort of after the fact on YouTube, there is a link in the description below that links to the live version of the video which will have the chat on that side, that side while you watch. And so that'll be kind of neat.
00:00:33.185 - 00:01:25.585, Speaker A: So before we get started on today's stream, I also want to point out that I tweeted this a few days ago that I used to have a Patreon for this work that I do and realized that I'm not allowed to have that in the US because I'm not allowed to have any source of income outside my studies. And that was a bummer. So I've been trying to find a way because a bunch of people have been asking me how they can sort of support my work. And so I've decided to set up an Amazon wishlist where people can, like, if you want to like donate something to help make the stream better, you can do so. And I posted this a few days ago and I've already been just overwhelmed with the responses. It's been really cool to see people just like strangers on the Internet sharing things with me. And so to all of the people who have sent me things, thank you so much.
00:01:25.585 - 00:01:44.411, Speaker A: I appreciate it a lot. It makes me. Yeah, it's great. I very much appreciate it. And so there's a list where there's some small things and some large things. There's a bunch of D and D stuff because I like D and D. And so if you want to buy me stuff from this list, then that would make me very happy.
00:01:44.411 - 00:02:22.513, Speaker A: If you can't, that's okay too. This is just the only way I could find where there's some way of showing support. But even just like your thank yous means so much to me. I also want to remind you about the live coding voting site. So I'll post this link in the chat somehow. In fact, how will I even do that? I'll do that this way, like so on the site you can vote for upcoming stream ideas. My guess is this will be the last proc macro stream.
00:02:22.513 - 00:03:01.715, Speaker A: And so the next stream, unless things change, is going to be a second open source contribution stream. We did one of these a while ago. And the idea here is basically I spend the five hours or so that the stream goes for trying to contribute to a number of different open source Rust projects. And I'll sort of solicit opinions from you, the viewers, as to which projects we should contribute to. And it can be small contributions, large contributions, whatever we feel like we want to do. Usually what we'll do is try to find less developed projects and then look at issue trackers, for example, and then try to find a thing to contribute. Let's see before we start.
00:03:01.715 - 00:03:43.839, Speaker A: Okay, so there was a question here. Do you have any videos implementing event loop? So some of the future stuff is event loop based. You could try that. I couldn't have a Patreon because I'm on a student visa in the US and so I'm not legally allowed to have any source of income that is not basically the assistantship that my university pays me. I'm not allowed to have any other source of income. Okay, so let's dive into procedural macros again. I'll try to get better at reading chat aloud as well.
00:03:43.839 - 00:04:31.495, Speaker A: So I'll be monitoring that in the background. So if you remember from last time, we started working on David Tolnay's procedural macro workshop from the Rust Latam conference, and we basically did the very first exercise of deriving a builder pattern. So the way this looks is you want to have some kind of struct and you want to be able to put derive builder above it. And what our macro does is basically generate the code to have a builder for that thing. So if you remember back to. Let's see if I can find this. Let's go with builder just to sort of bring us back to where we were.
00:04:31.495 - 00:04:46.215, Speaker A: 09. No, let's do 08. Builder. 08. No, builder. 07. Great.
00:04:46.215 - 00:05:40.139, Speaker A: So the idea is that if you have some code that looks a little bit like this, so you have a struct with derived builder and you have some fields with different types. You might even have things that are vectors. For example, where you want a builder to have a builder argument that just gives you a singular thing, then that should give you a builder type that you can then use this stuff on. And so to remember, the procedural macros basically take as input. Oh, what did I do? I did a stupid. Did I? The procedural macros basically take this program as an input, sort of a stream over the tokens of this program as an input the things that have been annotated with derived builder and then produces a stream that adds new tokens to the stream. So what that means is it basically expands the program.
00:05:40.139 - 00:06:41.495, Speaker A: So in this case, cargo expand shows us the expanded version. So here we have the command that was in the original source. Remember, the derived builder attribute has now been removed because it's already been parsed. And what we generate is a new struct command builder with the same fields, a bunch of methods on that builder, and a build method that produces the final command. And so what this means is ultimately this generates all the code that's necessary to make the operations that the user gave us work out. So the question is, if we go back to our list here, the question is what, what exercise do we want to do next? My hope is that we might be able to do maybe two in the five hours we have, given that. The first one basically taught us a lot of the concepts that we're going to need in order to do these, and then the other ones are sort of expansions upon those topics.
00:06:41.495 - 00:07:07.431, Speaker A: So let's do a quick straw poll in chat here. Let me first briefly go through the options. So there's derive custom debug. So the idea here is that you know how you can have derived debug on a struct. Custom debug is going to also let you define how you want different fields to be debug printed. So in this case this would say print the bitmask using this format. So that would be one macro we could implement.
00:07:07.431 - 00:07:44.247, Speaker A: Another is seek. So the idea of this macro is that you can give the seek macro followed by basically an iterator and then a segment of rust code. That will be where we're going to look for this pattern. This like pound open brackets, similar to like in macro rules. And what's inside there will be expanded n times where n is the iterator with pound n replaced with the value of the iterator. Right. So this would generate like CPU0, CPU1, CPU2, CPU3, etc.
00:07:44.247 - 00:08:57.485, Speaker A: All of them as variants of processor. But it doesn't have to be inside of an enum. It could be all sorts of different things. Sorted is going to be a compile time assertion that the variance of an enum are ordered. And so if you put pound sorted on an enum, then if the enum variants are not sorted, it will be a compile time error bit field is, I see you basically define how many bits each field takes up and then the attribute lets you access those fields and set those fields appropriately and make sure to store them using whatever the appropriate integer type is. And my guess is that the bit fields one is probably a decent amount more complicated. So, looking at the project recommendations here from David, Custom debug is going to look at trait bounds.
00:08:57.485 - 00:09:23.787, Speaker A: Seek is for custom syntax. Right. So normally we've been using the syncrete for parsing out Rust syntax. In the case of seek, we're going to have to basically walk the tree, the syntax tree, to find places where we need to replace the main variable. Right. So this is basically like custom in text parsing. Sorted is mainly for looking at how to get good diagnostics from a macro and bit field.
00:09:23.787 - 00:10:02.883, Speaker A: Yeah. So bitfield do only when you have a strong grasp of at least two other projects. So I think we should. We might do bitfield today, but we should not do it first. And so I think the options are do we want to do sorted, do we want to do seek, or do we want to do derive Custom debug. All right, so votes who thinks we should do which specifically out of these three and not bit fields, we might do bit fields after, but I think we should do at least one more to like get back into the group of things. So there seek.
00:10:02.883 - 00:10:29.011, Speaker A: Seek. Seek is probably rather pronounced like sack than seek sec maybe. So the reason I pronounce it seek is because it's sequence, Right? Seek sequence. It's not sequence. Right. Or sequence, but I don't know. Sorted looks nice and easy.
00:10:29.011 - 00:10:58.655, Speaker A: Custom debug sorted seek. Okay, it looks like there's sort of a tie between sorted and seek maybe. I think seek looks like the contender. Okay, so let's go for seek first and then we can always do the others later. I agree that sorted is probably easier, right? Because it. It only. It's only like enum variants and checking whether they're sorted.
00:10:58.655 - 00:11:32.275, Speaker A: All right, so let's get started with seek. Function like macro seek. So the idea here is we're going to be given sequence. We're going to define a function like macro seek. Right? And it's going to have the format like this. This is going to have to require numbers stamping out, sequentially indexed. Sequentially indexed copies of an arbitrary chunk of code.
00:11:32.275 - 00:12:21.411, Speaker A: All right, so great. So we're going to have to parse basically this followed by an identifier, the keyword in numeric range, curly brackets, and then just regular code. And then inside of that code segment, we're going to have to look for this. So let's see how we might do that. So the syncrate, if I remember from last time, has a visit thing, which is basically a way to walk a syntax tree. And in this case we want to mutate the syntax tree. Right.
00:12:21.411 - 00:12:49.585, Speaker A: Actually unclear. Is that what we want to do? I think that's what we want to do because we want to replace. We want to replace the occurrence of this with expansion of it. Right. So visit mute. So I think the idea here is visit mute. This is not at all documented.
00:12:49.585 - 00:13:26.079, Speaker A: That's potentially unhelpful. I wonder how we're supposed to use this. So does it say visit anywhere else here? Not really. Actually. Maybe visit is documented and visit mute does not. Let's take a look at visit. That seems relatively unhelpful.
00:13:26.079 - 00:14:18.195, Speaker A: Is there a visit token stream? Maybe like a top level entry point? Are there provided methods for this where. Oh yeah, that's a good point. All of these things from the workshop are actually there are real implementations available of them. I don't know where they're linked. I think if you read this more carefully than I did basically all of these exercises. There's a crate on Crates IO by David that implements this feature. The real question is where is like the top level entry point? Where do we start? There's no like.
00:14:18.195 - 00:15:08.437, Speaker A: Is there a token tree? No. Interesting. Oh, maybe there's a parse, a variant of parse that takes visit parsing a custom syntax lacy static example. Great, let's take a look at that implement parse. Well, we don't want syntax. Actually this might be useful for parsing the. This might be useful for parsing the top level thing.
00:15:08.437 - 00:15:40.195, Speaker A: Right. So why is it giving me the seek for parsing this business? Right. That business is sort of like lazy static in that we'll want to parse a particular sequence of tokens because that works decently well. Mm. Giving error messages. That's fine. The real question though is.
00:15:40.195 - 00:16:41.965, Speaker A: Ah, this still doesn't really give us the visit pattern. I'm like fairly convinced we want the visit pattern. But the question is how do we start parsing that way? Actually I wonder whether this would let us parse module. Maybe something in here takes visit parser trait parser. No, this all seems to just be to turn token streams into parse streams. Wonder. Here's what we'll do.
00:16:41.965 - 00:17:26.785, Speaker A: Repositories, Fold visit visit mute. Is there a fold in there? So for, I guess, visit mute. Do you see a fold? I did not see a fold. I guess it's a top level fold to transform the nodes of an own syntax tree. Oh, interesting as a fold. Might even be better. Yeah, you're right.
00:17:26.785 - 00:18:05.415, Speaker A: I think fold might be a. Might be better because that really is what we want to do, we want to walk the input, transform it and produce an output. But it sort of has the same problem in that these aren't really documented. Like none of these give me an example of what they do. Although the function type sort of helps. Fold macro specifically. The question is what is like the top level function I call to fold over a stream qself.
00:18:05.415 - 00:18:35.541, Speaker A: So what I wanted to do is look at this and see how this does it. So here, okay, a bunch of documentation. That's fine. Right. So this is parsing that. This is basically the same code we're going to end up writing. Expand, repetition.
00:18:35.541 - 00:19:31.285, Speaker A: This is really what we want to see. Yeah, so the body here is the token stream, right? The token stream is sort of what we care about and. Oh, interesting. So this doesn't actually use the visitor pattern, which is surprising to me. Instead it just walks the groups. So if it's a group, then it does that. Huh, interesting.
00:19:31.285 - 00:20:20.125, Speaker A: I guess what we're really going to need here is proc macro 2. So remember, proc macro 2 is the crate that gives us access to the procedural macros in the compiler in a way that's independent of the current compiler version and the token stream. It basically gives us an iterator. Where's the Here an iterator over token trees that are either groups, idents, puncture, literals. Okay, well, in that case I'm very surprised we can't use fold here. I feel like we probably can. The biggest problem is that fold isn't really documented.
00:20:20.125 - 00:21:03.105, Speaker A: I wonder whether the trace var example uses fold. Oh, nice. Okay, let's try that then. Trace var trace source. Let's see here. Unfold. Oh, is like expression, the top level thing as item fn.
00:21:03.105 - 00:21:41.069, Speaker A: I think the real question is what do we parse it as? Parse microargs as R. Okay, so that's fine. This is to parse if we go back here. Okay, so this, this macro is an attribute always on a function. And so that's a little different because. Okay, so it parses the input like the body that it's given as an item or specifically a function item. It parses the arguments of the macro as args, so that's reasonable.
00:21:41.069 - 00:22:17.105, Speaker A: And then just fold item fn. The problem we have in our case is really that for if we go back here, we don't really know what type is going to be here. It can be anything. Right. It's like any token stream, which is why we don't actually know where to start the fold. Maybe we know it's a block or we know it's an item. I wonder if there's a general like fold item.
00:22:17.105 - 00:22:56.415, Speaker A: Ah, fold item. That might work. An item is an extern Create a. Use a static constant FN mod existential structs. No, because it doesn't have to be an item either. Like, our problem here is this could be anything, right? Like the stuff that follows C could be just a sequence of tuples that it gives an example of here, right? It could be an expression, it could be. It could really be anything.
00:22:56.415 - 00:23:34.787, Speaker A: And it looks like fold doesn't have an entry for anything. Like I. What I really want is like a fold, but I don't think there's just a fold. So it seems like we might actually have to just walk the token stream ourselves. It's a little unfortunate, but we can do it. Okay, so we're going to start with where's our no longer in builder? We're going to be in seek. So we're going to be in seek and.
00:23:34.787 - 00:24:12.423, Speaker A: Nope, here. This is still going to be cargo expand and here test 0 parse headers. Great. What I want is just for us to have something to start with for our main so that we. Which we can use cargo expand with. Right? So if I go here now run. Actually, let's make this bnc.
00:24:12.423 - 00:24:44.995, Speaker A: Can this be in here? So cargo expand currently just crashes because we have an implement the macro. But now at least we'll be able to. There's something you want is called the token tree. Yeah, I know that it's a token tree, but there is no fold token tree. Okay, so what we're going to do is we have to start implementing this thing in the first place. So seek source lib. Right, so now we're at the point where we know we define a proc macro, right? It's not a proc macro derived like we wrote last time.
00:24:44.995 - 00:25:41.711, Speaker A: This time it's a proc macro which defines a sort of a similar thing to what you get with macro rules. Like a macro you can call and so that's what the proc macro attribute here tells the compiler is that what we're defining is a function like proc macro. And what that is given is it's given an input token stream and it has to return a token stream that's going to replace the current item. So if you remember from the last stream, a proc macro derive appends to the token stream. It's not allowed to modify. Well, I don't think it's allowed to modify the input, but it produces a new input, like appended input. So won't seek 0,1 million be horrible for compile times? Well, so it's true that if you were to repeat a particular thing a million times, you're basically expanding the source of your program a million times.
00:25:41.711 - 00:27:06.835, Speaker A: So yes, it would be terrible, but then again, that's what the user asked you to do, right? Okay, so we know from last time that what we want to do here is parse the input to the macro, right? So if you remember, in sin there's this handy dandy macro called parse macro input, right? So if we hear use in parse macro input, then here what we want to do is parse macro input of. Remember how the syntax is the identifier as the type, right? In our case we're taking the input and we want to parse it as. Remember last time we used derive input, right? This time that's not actually what we want. This time we want. Where's the. Oh, maybe the default is just what we want. So what does it say here as my macro input? Oh, interesting.
00:27:06.835 - 00:27:42.477, Speaker A: Actually, that is what we want to do. In fact, this is exactly what we want to do, right? We want to parse it. The input to our macro is going to be some custom syntax. And so sure, we're going to do this, although it's not quite. We're going to give it a better name than that. But first of all, we're going to have to just like make it not crash, right? So here we're going to return a token stream new. So the macro is going to expand to nothing.
00:27:42.477 - 00:28:23.223, Speaker A: Currently we're going to parse it, print it, and then expand it to nothing. And in our case, I guess here we're going to have to do this business. So this is going to be a seek macro input seqinput. We're going to parse the input we get as a SEQ microinput and here this is going to return, ok, seek macroinput. Let's see what that does. Oh, do I actually need to do this? Oh, right. I haven't even defined these dependencies.
00:28:23.223 - 00:29:14.195, Speaker A: I want. Oops, no, I want dependencies to be seek 015 and also quote 06. Oh, I meant Sid. And here we want to derive debug. Great. Unexpected token. Huh? Oh, I see.
00:29:14.195 - 00:29:41.457, Speaker A: Because now we're not actually consuming the input and so it thinks that the macro basically starts parsing here and then it consumes no tokens, right? Because our parser does nothing. And so it then says, okay, I'm done. And then the compiler encounters this token is like. I did not expect there to be a token here. The macro said it was done parsing, but it hasn't moved along in the input stream. And so what we need to do here is basically the same thing we thought we saw earlier. Right.
00:29:41.457 - 00:30:34.953, Speaker A: We want to basically parse the custom syntax that we're expecting. So if we go back to here, we basically need to parse out this business. Right. And so what that's going to use is if we look at the parse module, it basically provides a number of parse functions. I don't actually need look ahead for this. What was that? There's a nicer parser. Yeah.
00:30:34.953 - 00:31:00.965, Speaker A: So you basically give. Oh, I see how they've done it. That's interesting. So there's parser and parse. How do they different? Oh, we might need the parser module. It might not be on by default. Yeah.
00:31:00.965 - 00:31:29.955, Speaker A: So parse is anything that can be parsed in a default way from a token stream. Right. So we're going to have to say something like, if we expect the next thing to be a literal, for example, then if I understand this correctly, it's going to be something like the variable we want is going to be. Actually, no, it's not going to be token. I guess the first thing we're expecting is an identifier for the. The variable name, the N. Right.
00:31:29.955 - 00:31:56.465, Speaker A: So it's going to be sin ident parse input. Let's see what that var is. Hopefully this should print N. Let's see what it gives. Yeah. So this gives us an ident N and it shows the span, remember, from last time, which tells it where in the original source that ident appeared. Right.
00:31:56.465 - 00:32:23.195, Speaker A: All right, Parser, you're right. Parses what we implement. But I was wondering what parser is, because all of these use parse. But I don't think it's important. Right. So if you look at the syntax, we're expecting, we want N, we want the literal token in, then we want these things. So next question becomes how do we get a keyword like in from memory? There's a token thing.
00:32:23.195 - 00:32:51.685, Speaker A: Let's see if I can find this somewhere. It's a macro token. Yeah. So I think this is what we want. So here, let's bring in token as well. So in is going to be token in parse input. And I guess we can.
00:32:51.685 - 00:33:22.845, Speaker A: We can print that out too, although this one is less important. Right. We don't actually care about the value of in, we just care that there Is an in there. Sorry, I meant. Oh, that might not work. Yeah, Although that's not actually what we want either. Interesting, because token in gives me a.
00:33:22.845 - 00:33:40.789, Speaker A: I'm guessing like sin token. Like it is basically a rust keyword. Right. It gives me a concrete one. So I don't know how to call parse on that. Oh, it's probably something like this is input dot parse. Not sure, but.
00:33:40.789 - 00:34:01.845, Speaker A: Oh, is that what you wrote? Oh, nice. Great. Right. Because token in gives me a type. Although that should then still work. Actually, if it gives me a type, then this should be the same. But the compiler might not be able to figure out.
00:34:01.845 - 00:34:25.061, Speaker A: Yeah, but if we do this, I think that should be the same. Basically telling it this is a type called this associated function. Great, that's the same. Perfect. So the in, if you look at it, just parsed in. Right. Just a keyword, we don't actually care about the value, which is why I use the underscore so that the compiler won't warn us about unused variable.
00:34:25.061 - 00:34:53.614, Speaker A: Right. So the next thing we're expecting is we want a literal followed by two dots followed by 512. Okay. So we're gonna have. I guess from. It's gonna be a literal parse, two is gonna be a literal parse, and in between we're gonna have dots, double dots. Oh, and I guess I want to print out.
00:34:53.614 - 00:35:27.349, Speaker A: Let's just keep all of these in one. So var in from dots to. Did I miss any? I think that's right. Right. So we get the ident N. Right. We get the in keyword, we get a literal number zero, then we got dot two.
00:35:27.349 - 00:35:54.447, Speaker A: Right. So dot two, that is a double dot, which is a literal. Then we got the literal number eight and that's what we parsed. And then it's saying unexpected token for the curly brackets. And so now what we want is the next thing that's going to come is basically a block. Right. So the question is, how do we parse a block? What is the type for a block? Which.
00:35:54.447 - 00:36:22.165, Speaker A: Let's look at our parse here. Actually, this might tell us the type we're going to use for fold. Whatever we parse here. Actually, the body is going to be a token stream. Right. The next thing now is the token stream of some kind. But is there a way for me to say like curly brackets? Use tree is not what we want.
00:36:22.165 - 00:37:02.707, Speaker A: Expert block. It's not really necessarily an expert block. I wonder whether it'll. Let me. It's really almost like a module block, like an item, item block. Is that a thing? No. Item mod, maybe? No, because that needs to include the name.
00:37:02.707 - 00:37:39.975, Speaker A: So what's the content? The topple of brace and I and a vector of items. Oh, interesting. You could probably also parse as an expert range. So the reason I don't want to parse it as an expert range is because we're going to have to iterate over this range and I probably don't want to allow. I don't necessarily want to be able to support any range. Although you're right. I mean, we could just assert that it's a particular type of one.
00:37:39.975 - 00:37:57.563, Speaker A: So what does expert range parse? Okay, any of these. Yeah, but like. Okay, so imagine that I got this back. Right? That's not a useful construct for seek. It can't generate an infinite number of things. We don't really have iterators here. We're going to copy the same thing multiple times.
00:37:57.563 - 00:38:20.099, Speaker A: The one thing that might be nice is that we get this, but I don't think it's terribly important. There's an impulse parse for block. Yeah, but I think a block is like an expert block. I mean, what. What is a block? A braced block containing rust statements. No, you're right. That looks perfect.
00:38:20.099 - 00:39:17.035, Speaker A: I agree with you. Okay, so the next thing we're gonna have is body, which is gonna be syn block this, but that is not an input to fold, which is weird. What? Oh, I need the full feature. Okay, fine. So version is this features is full and then you can continue with sub input. Wouldn't block have to be completely valid syntax though? Oh, that's a good point. Block might actually part.
00:39:17.035 - 00:39:36.655, Speaker A: No, I think. What? That's a good question. No, I think it just parses it as syntax. And like remember macro invocation is also valid syntax, right? I guess. Actually we're going to find out. Okay, so we now pass. My guess is we pass test one.
00:39:36.655 - 00:40:22.031, Speaker A: What was the progress? Great, so we're now going to pass the first test. We should pass without a problem because basically, because we don't crash. You need symbraced. Ooh. What? Oh, do I need to explicitly enumerate all of them? Oh man. Why? What are the default features? I see. So I probably.
00:40:22.031 - 00:41:21.009, Speaker A: What I want here is just like all features, but let's do full. Wait, what? Why does it work in cargo expand but not in cargo test. Oh, extra traits. But why? But why does it extra traits? I wonder why it works in cargo expand. That's weird. Oh, Cargo Expand probably also relies on SIN with that feature added is why. So what Cargo does when it builds something, if it finds one dependencies in multiple parts of the dependency graph that have the same version, it takes the union of the features for it.
00:41:21.009 - 00:41:46.575, Speaker A: And so if CargoExpand builds with a dependency on SYN with extra traits turned on, which it might very well do, then it will also compile the underlying crate with that feature on. Which is why this compiled fine. And also why this. This was not working great. So we now pass test one. So let's go to test two, I guess. Progress.
00:41:46.575 - 00:42:18.011, Speaker A: Let's do two. Okay, so this. What is this? Expand too. Okay, so I'm guessing this won't actually pass. Wait, what? Oh, interesting. The macro invocation in the previous test case is an empty loop body inside the brace. In reality, we want for the macro to accept arbitrary tokens inside the braces.
00:42:18.011 - 00:42:51.225, Speaker A: Calls should be free to write whatever they want inside the braces seek macro won't care whether they write a statement or a function or a struct or whatever else. So we'll work with the loop body as a token stream rather than a syntax tree. Yeah, so this is what was pointed out elsewhere that what we might want is to not even parse it as a block, but just as a brace. Like just. It is contained in braces. But we don't actually want to parse the thing inside yet. Although that still means we can't do it with fold, which is a little sad.
00:42:51.225 - 00:43:38.995, Speaker A: So if I go to lib here. So instead of this, what's the if we go to here? Braced. Hmm, interesting. Content in input. What is that? What does this do? Why does it need this in syntax? That's interesting. Content Brace. Token is a type token, brace.
00:43:38.995 - 00:44:39.757, Speaker A: So why does it need braced? That's super weird. Oh, I see. It just consumes the braces. But why is the let content necessary? Like specifically. Specifically is it fine for us to do like let Braces is sin. Where's token? Like token Brace parse input. Like, is that a thing that it's going to be okay with, right? I'm guessing.
00:44:39.757 - 00:45:03.135, Speaker A: Why doesn't it just expand to its own value? The real content kind of file body. What did I do? Oh, this business. Okay, so brace can't be parsed. So it's really. That's so weird. I don't understand why it has to be called this way. Braces.
00:45:03.135 - 00:45:25.615, Speaker A: Input as content as input. Like, why is that necessary? I guess this is braces. Oh, the content is the stuff that's inside. Never mind. But I still don't see why it can't Be this. Right. This is what I really want.
00:45:25.615 - 00:45:48.203, Speaker A: Oh, because you also need the braces. Okay. Oh man, that's. That's funky is what that is. Okay, so this returns the braces and I have to write this to say I want the content to be placed in that variable. Oh, that's awful. But I see why it's needed.
00:45:48.203 - 00:46:15.695, Speaker A: Specifically, the problem here is braces really needs to do two things. It needs to give you a handle to the content inside the braces and it needs to give you a handle to the braces themselves so you can replicate them if you need to. This means that it needs to return a value. Right. So one of those can be returned, but both can't be. Well, it could return to tuple, I guess. Actually, wouldn't that be nicer? Wouldn't it be nicer if this just returned a tuple of braces and content? Oh, in.
00:46:15.695 - 00:47:19.999, Speaker A: Right. Oh, well, okay, so this means that the content is the stuff that's going to be inside the braces braced. Question mark operator cannot be used here. Wait, really? That's fascinating. What if there aren't braces there? Why doesn't this return an error? Right, okay, so now we're not currently parsing the token stream inside, I guess how do I. Can I just say that I want to consume a token stream proc macro 2 if I have a token stream, I guess I could just walk the entire thing. Oh, is he braced? Contains a return statement.
00:47:19.999 - 00:48:07.749, Speaker A: That also seems weird, but okay. Right, so the real question is what is the stuff that is inside of. Inside of the content? So inside the braces. Well, I think what we want here is. Right, so the content expands to a token stream that's going to have whatever kind of syntax in it. So here, what I think I want us to do is just for in content, parse buffer. Oh, right.
00:48:07.749 - 00:48:50.247, Speaker A: That's what braces give us. So if we look at it gives us a parsed stream, not a token tree. So if I go here, go to parser. This is where parse stream is parse buffer. Right, A cursor position within a buffered token stream. Uh huh. Yeah, I did.
00:48:50.247 - 00:49:16.935, Speaker A: So, okay, the content is now input. I agree, I understand the setup. The point now is content. So the, the error we're now getting is in parsing we're currently looking at over here. Right. This is the current file we're trying to work on. And currently what we've done is we've parsed everything up to the curly.
00:49:16.935 - 00:49:45.561, Speaker A: This curly bracket and this inside here is still a Token stream that we're not consuming anything of. And this is really what content points do. What I've just highlighted, that's what the content variable is, the parse stream over that content. But currently we're not consuming any of it. So our parsing basically stops here. And when our parsing stops there, the compiler then says up here, unexpected token expanded, nothing. Right.
00:49:45.561 - 00:50:07.555, Speaker A: Because we haven't told it that it should expect to parse that out. And so one thing we could do here, of course, is we could just do like, while. Is there like an. Is empty? Yeah. Okay. So while not content is empty and then like. Yeah.
00:50:07.555 - 00:50:29.537, Speaker A: Will this even. I don't know what this will give us, I guess. Let's see. Yeah, the problem is we have to actually say what we want to parse it as. Right? Oh, someone suggested the same thing. Nice. Yeah.
00:50:29.537 - 00:50:57.625, Speaker A: Felix, I think. No, no, it's. It's super helpful what you do. It's more like I end up thinking through the same thing as you do while you type it. Although it is useful to have someone else who knows this during the stream. So let's see, the real annoyance here is that we don't know what to parse this as. We sort of really just want it as a token tree, actually.
00:50:57.625 - 00:51:17.859, Speaker A: Let's take a look. What did the. Over here. Yeah. Because in David's version, he keeps it as a token street token stream, which seems like the sort of right thing to do. That's sort of what we want to. Oh, that's funny.
00:51:17.859 - 00:51:41.931, Speaker A: So he parses out a potential equals there require braces. So this seems to be much lower level. Does he even use SYN for this? Oh, he just parses it manually. He doesn't even use the syncrate for this. So that's part of the reason why this gets complicated. Whereas we're trying to use a. Do it with the syncrate.
00:51:41.931 - 00:52:36.345, Speaker A: So what does he require? Braces. Where does require braces come from? Create parse, parse, acquire braces. I see. Yeah. This is why we might not want to use the. This is why we might not want to use the SYN parser for this. Because here what we really want to do is just get the raw contents within the.
00:52:36.345 - 00:52:54.545, Speaker A: Within the braces. Unless. Unless we can go from a par stream to a token stream. Right. Like for parse. Where's our. Where did I have parse open here? Oh, yeah.
00:52:54.545 - 00:53:46.005, Speaker A: So what we can do here is actually just something like let. Token tree is going to be proc. Macro, token tree, parse, input content. See what it does with that. Which token tree is this? Oh, Proc Macro 2. Right. And I need to also depend on Proc Micro 2, which is what version Proc Micro 2 is version 0.4
00:53:46.005 - 00:54:23.891, Speaker A: expected reference Billy apparently. But it can't be a token tree either token stream. Right. Because a token tree is a single. It's not quite a single token, but it's like it's basically one sub tree of the ast. So if you look at the error we got was unexpected token was now exclamation mark. And that's because this is an ident.
00:54:23.891 - 00:54:39.313, Speaker A: So this is an AST in and of itself. This is a separate part of the. It's the. Basically the next token. Right. This would be one token would be a group that's delimited by brackets. And so if you park it as a token tree, all we're really parsing is this.
00:54:39.313 - 00:55:04.465, Speaker A: We parse a token stream that should be all of these basically all the stuff that's in content. So I think token stream is going to give us the right thing here. Great. Right, so this parses out. This gives us back a token stream that is the entire body of the thing. Oh yeah, See, same thing. Nice.
00:55:04.465 - 00:55:29.393, Speaker A: Right, so we don't really need content because it's going to be the same as this token stream. Now the question is what we do. So one way to do this is now just to sort of walk down into this tree until we find a relevant thing. Right. So this now already parses everything. So we don't really need. We now already consume the content.
00:55:29.393 - 00:55:47.442, Speaker A: So that's all fine. Consider. Right, we're going to need the 2. That's fine. Great. So now we should pass 0 and 2. Sorry, 1 and 2.
00:55:47.442 - 00:56:27.251, Speaker A: So the next question is going to be for progress 3. So the next one. Now construct the generated code. Produce the output token stream by repeating the loop body the correct number of times as specified. Okay, so this is going to be. Basically now we're going to have to start to actually do the. Do the real code generation repeating the loop body the correct number of times to specify the loop bounds and replacing the specified identifier within the loop counter, the invocation will need to expand to a token stream containing.
00:56:27.251 - 00:57:01.899, Speaker A: Yeah, so this four times with n being 0, 1, 2, 3. Great. Okay, so what this is going to mean is we're going to have to walk the token tree. So let's do the same thing we did before. So we're going to stick this into main so that we have a good way to see what it expands to the cargo Expand now is going to expand to nothing. The input code that we gave the seek. If we look at the expanded output, it's not there.
00:57:01.899 - 00:57:44.593, Speaker A: And that is because the output token stream we produce is empty. And that's of course not what we want it to be. So here, what we're really going to have to do is interesting. So we're going to have to walk down the token stream until we find somewhere that is the variable Interesting. So we're basically recursing down into. This is where it would be really nice to have something like fold. But of course the problem is we don't have a top level.
00:57:44.593 - 00:58:40.345, Speaker A: Let's take one more look at fold. It'd be really nice if we could use fold for this. Fold who X? What does X do? It's not what we want. Yeah, we just like have no idea. I mean there's fold, block. I wonder whether. I wonder whether we can get away with parsing this as a block and then just walking the block instead.
00:58:40.345 - 00:59:21.943, Speaker A: But it might not matter. Okay, so we're gonna for I into to From. No, what am I doing? From to. No, it's not a block. Yeah, I worry that. Well, currently it is a block, but it's like a general type of block. It's not an expression block.
00:59:21.943 - 00:59:45.865, Speaker A: Right. So I think it is a block, it's just not an expression block. The real problem is whether it will allow us to also get at macro syntax deeper in the. In the token tree. So I think we might just have to do this manually. So we're going to do expand TT with I. We're also going to.
00:59:45.865 - 01:00:18.105, Speaker A: Symblock is a valid rust block. Hmm. Yeah. If a SYN block needs requires that it's a valid symblock, it wouldn't be. Actually, let's do this for now. Preempt myself. So expand is going to take a proc macro to token stream and is going to produce the same thing.
01:00:18.105 - 01:01:05.901, Speaker A: So it's going to get stream, probably clone and it's also going to have to take an. I might not know. It does need to return the token stream, but it might not need the question mark. And here what we want to do is. Oh, interesting. We need a. We need a way to basically construct up the output we're going to get.
01:01:05.901 - 01:02:08.449, Speaker A: So I think what we want here is let expanded is from. To map I to this collect and then we are going to. Well, so actually really what we should do here is at this point we've already parsed out all that we need, so really we should sort of stick that into here and then implement essentially implement print for SEC macro input. It's not really print it's like into token stream. Right. So really what we want to hear is impulse into token stream for SEC macro input. Right.
01:02:08.449 - 01:02:54.155, Speaker A: So this is going to have the fields from which is a usize to actually let's make it isize we don't know if they're negative and token tree it's going to be a Proc Macro 2 token stream. Right. So at this point we can do sec macro input and we can produce this thing. At this point we're sort of. We're kind of done parsing. It really depends on how we want to define parsing. I don't think we want to parse any more than this.
01:02:54.155 - 01:04:42.307, Speaker A: So from to tt and then it's only really at here when you want to turn it into a token stream that we want to do the expansion. You can pick stuff from SEQ micro input inside the SEQ function. Not sure what you mean by that, but regardless this I think now in theory we should be able to do input into instead of that. This is going to expand those. Yeah, I mean that was basically my. My plan was to now do this right Quote of Although I sort of want. We also need to use quote quote I basically want this to be so where I can iterate in quote I forget it might be that the way we have to do this is out it's going to be an empty quote as a I guess a token a proc macro to token stream empty and then this doesn't need to collect.
01:04:42.307 - 01:06:22.535, Speaker A: We just do for I in this and then we do out is quote oh man, I forget from our other 1 pound is what it is expanded is expand tt.self.tg. clone I and then this is going to be out and expanded and then we're going to Produce out simpler parse 2 quote quote I don't see how that helps. Okay, so this is going to basically keep appending to the token stream what we get from the expansion and then eventually return when they've all been expanded. So now the trick is going to be to implement this, right? And here, this is where we're going to have to recurse into the sort of depth of the token stream. And I think we're basically going to end up with sort of an expand inner that's going to be expanding token trees instead. Because I think what this is ultimately going to be is it is just going to walk the element of the. The elements of the token stream.
01:06:22.535 - 01:07:01.075, Speaker A: So while actually take a look back at token stream. Token stream. So token stream implements into iterator. So I think what we're going to do is just walk the walk this iterator and for each thing basically look for the identifier that we know we're looking for. Oh wait, that's also true. I need the identifier in here, the identity which is going to be a synident. So this is also going to have ident.
01:07:01.075 - 01:07:54.965, Speaker A: Let's call this ident because that's what it is. So we're going to do stream dot into iter map. This is going to be a. For each token tree we're going to do some expansion and then we're going to collect it into a token stream again because that implements from iterator token tree. Right. So we're basically we're going to walk every token tree we find and see whether we need to expand it. And here, hmm.
01:07:54.965 - 01:09:01.235, Speaker A: I think really what we're going to need here is something like expand, I guess Expand2 for now it's going to take a token tree and it's going to produce a token tree token tree and it's going to match on the TT. And if it gets a. If it gets a proc macro token tree. So what are the different candidates here? So the candidates are groupident punctum literal. So if it gets a group, then it might have to do something. It has to recurse into the group what is a group here? Right. And if it's anything else, then it can just return that token tree if it's a group internally contains a token stream which is surrounded by delimiters.
01:09:01.235 - 01:10:15.355, Speaker A: Right. So here really what's going to happen is we're going to have to do proc macro to group and have to do this. Right? It's going to produce a new one with the same delimiter as the old one. And the adapted token stream is going to be expand. So this is calling the stream expand of the group stream and still the same I and we probably also want to do set span is going to be G span. So this is going to be the expanded. So this is going to produce a this of expanded.
01:10:15.355 - 01:11:02.499, Speaker A: Right. So this is going to map a group into us expanding the stuff inside the group. And expand is just going to call expand 2. I guess actually it might have to do this expand 2 of the TT with the given I. Now this isn't quite true, right? We know that if we encounter the identifier that we care about the Variable, Right. Then we actually do want to expand that differently. So in particular here, if we encounter an identity, an I where it is item we want.
01:11:02.499 - 01:11:59.925, Speaker A: Right? Ident, probably ident we want. And if that. I wonder if that I is equal to. Oh, so this is still going to have to take self and this is going to have to take self, which means they're going to have to be moved into implseek macro input. This is going to be self expanding. Right? If the I is equal to the identifier that we were given by the user, then we do something specifically. Then we expand it to.
01:11:59.925 - 01:12:45.225, Speaker A: Then it's going to become a proc macro to token tree literal instead. And specifically it's going to become the literal that's going to be the current. I guess I here is going to be an I size, we decided. And that literal. I think there's like syn lit from I, although I think we want to make sure that we keep the right span here. So the lit is going to be this. So this is the literal we're.
01:12:45.225 - 01:13:28.873, Speaker A: This is the literal we're inserting in place of the identifier in the stream. And I think we want to set span I span to make sure that if there's an error with this literal, it is tied back to the identifier in the original input. And then we give this a slit. All right, let's see what this gives us. This is probably all sorts of broken. Yep, that was broken. That is totally true.
01:13:28.873 - 01:13:58.147, Speaker A: We're gonna have to do. Wait up here. Self from self to self expand. Love your vim setup. Got your config somewhere? Yeah, there's a video in the. If you look at the YouTube channel. If you look at my YouTube channel, there's a video on my editor setup and stuff.
01:13:58.147 - 01:14:35.249, Speaker A: So if you're interested, you can go look there. I've made some changes since then, so arguably I should do another one, but it should be there from. Ooh, you're right. These are not isis. These are sin literal, which is kind of awkward, right? Like we actually want to require that they're integers. So I think specifically I want this to be a lit int. Is there implemented for lit int.
01:14:35.249 - 01:15:26.849, Speaker A: Great. So this is going to be a lit int. This is going to be parsed as a litint, and this is going to be parsed as a litint. Still probably going to complain that they're not numbers. 44 is going to be new, so 45 litint dot value. Oh, is there a lit U? Oh, interesting. That's surprising.
01:15:26.849 - 01:15:50.627, Speaker A: That this is only a U64. It doesn't take a signed integer. Well then, okay, I guess it's gonna be a U size. Actually. Yeah, no, it's going to be U64. Fine. Surprising.
01:15:50.627 - 01:16:30.335, Speaker A: I don't know why it requires a U64. Mismatch types expected token stream dot into right. This is needs to become. So this is a token Stream from Proc Macro 2. We need to turn it into the actual type that the compiler expects, which is from just a proc macro. Crate here from synident. Oh, I'm shadowing the eye, aren't I? Ident.
01:16:30.335 - 01:17:10.995, Speaker A: If ident ident. Because minus 1, 2, 3 is 2 tokens. Oh, that's awkward. Yeah, you're right. The sign integers are modeled as a separate AST involving unary minus. Yeah, this might be the a good reason for why to parse it as a range. We talked about this a little bit earlier, but it could totally be that we want to use expirange here because limits.
01:17:10.995 - 01:17:41.835, Speaker A: That's the stuff in between from and two are both. Why are they box expressions? Right. This is the reason why Expo range would be annoying because I guess we would have to check that the experts are the right type. So what is if an expert lit is a. Lit is a. Hmm. Wait, that doesn't seem right either.
01:17:41.835 - 01:18:07.605, Speaker A: Oh, it would be an unary expression. I see. Yes, we would actually have to parse it. We do not walk it all the way down to figure out what it is. So even export range wouldn't really help us here. Okay, that's fine. How about now 63? Sorry, you're right.
01:18:07.605 - 01:18:49.713, Speaker A: This should say I. That was the whole point in the first place. From U64 is not implemented for synlit. Really? Maybe like that. Do I really have to expect destruct int. What does. Am I missing something here? Syn lit int Oh, I actually need to do new.
01:18:49.713 - 01:19:14.785, Speaker A: Fine, fine, fine, fine, fine. And that gives me a lit int. Okay, so this is going to be new. It's going to take the I. It's going to take a suffix, which is going to be none, I guess. And it's going to take a span, which is going to be the span from the identity. Wow, I can't type today either.
01:19:14.785 - 01:19:40.525, Speaker A: Which now means we don't need this or that and also means we can do this. See what that becomes. Mismatched types expected proc material too literal. Oh, so this. Presumably there's a. Yeah. So lit implements.
01:19:40.525 - 01:20:34.075, Speaker A: I assume this implements from lit int and I assume it implements two tokens. It does Great. So here I could use quote, but I probably also need. Maybe I can just do into here. Actually, come to think of it, really, I can't turn this into a token tree literal. So there's a token tree literal. That's surprising.
01:20:34.075 - 01:21:38.875, Speaker A: I mean, I guess I could just construct this instead. I don't need to go through sin for this. So I could here instead just do basically go back to this and say the lit is going to be not this, but proc macro to literal u64 unsuffixed or. Or sin to parse quote. Yeah, I mean, not clear that's even the right thing. It wouldn't give me the span. I would still have to set the span manually.
01:21:38.875 - 01:22:32.661, Speaker A: Man, why is like really what I want is just this. But this won't work because literal needs to contain a proc macro literal, not a syn literal. There's a macro for that coming over, setting the span. Oh, quote spend. Yeah, I see. So your proposal here is really that this just becomes sin parse 2. Can I make it just.
01:22:32.661 - 01:23:10.477, Speaker A: Okay, parse 2 of quote spend of span, ident and then. Oh, isn't this code span does some like funky syntax so that. So that it's clear where the span is. I can never remember what it is though. No, sorry. Quote quote quotes bend. Right.
01:23:10.477 - 01:23:59.809, Speaker A: It specifically requires the white space to be like this. So this bend to. Oh, this is the name of it. So this would be like identify. And then here I guess it would just be I. Right, what am I missing? Or on one line with. Oh, I see.
01:23:59.809 - 01:25:19.125, Speaker A: Or I can just do this. That's fine. Still not going to be right though. I want quote and I want quote spend actually, is this quote going to just erase all of my. It is, isn't it? I think we're going to have to be a little bit clever here, which is this is going to be this dot map, this dot collection I this collect into where this is going to be a proc macro 2 token stream. Oh, I see. And this parse 2 doesn't know that this is basically required to be valid syntax.
01:25:19.125 - 01:25:48.365, Speaker A: So here we can unwrap. Quote doesn't require it, but it prefers. Oh, one line. Yeah, yeah. You can make a vec of syntypes and work with that. I don't actually need the vec of syntax though. I think this collect is fine.
01:25:48.365 - 01:26:29.145, Speaker A: The real question though is punt ops range. Well, that's not right. This needs to be this. First of all, this is now a rough. Can't compare synodent with this. So this has to be that. Ooh, wait, that's pretty nice.
01:26:29.145 - 01:27:04.445, Speaker A: That looks awfully correct, right? Error number zero, Error number one, Error number two, error number three. So I think it generated all of these correctly. You don't think we need the into. I don't think this would work because expand returns. We would have to make expand, not return a proc macro to token stream. I don't think that will work. Yeah, because expand.
01:27:04.445 - 01:27:28.025, Speaker A: Yeah, we want that to return two so that we can use it in here. Which means that up here. Well, I guess we could up here do into. Oops. Here dot into. Unclear that the two matter. But then this could be proc macro token tree.
01:27:28.025 - 01:28:11.051, Speaker A: No token stream. And then this can collect into that. Hmm, am I confused? This should return this and now E2. So like it's not clear to me that that's all that much nicer. Oh, I suppose I could just make all of. You're right. This could just be PROC Macro 2 token stream.
01:28:11.051 - 01:28:46.385, Speaker A: PROC Macro to token stream. Get rid of this, get rid of this. Get rid of the Into. Just collect into a proc macro 2 and then only at the end here. The problem is this now is going to be dot INTO dot INTO Right. It's going to be proc macro to stream. No token stream from this dot into which is a little awkward is all.
01:28:46.385 - 01:29:35.875, Speaker A: Oh, that's annoying. To Token stream from input.into Problem is, the compiler is not going to be able to resolve these types for us. So I think it's going to mean that I have to do something like proc macro token stream is input.into and then like output.into here to turn the proc macro to token stream into a Proc Macro 1 token stream. But it'll still work.
01:29:35.875 - 01:30:05.155, Speaker A: All right, so let's see if we pass the test now. No, we did not pass the test. We also now have an unused import here. What is it complaining about? 1 of 3 tests failed, so it expected the output. Oh, it's because I also print the stuff at the top. Get rid of these. Don't actually need these anymore.
01:30:05.155 - 01:30:56.615, Speaker A: May end up needing this later. No. Oops, that's not what I meant to do. Seek. So what is it complaining about now? It's complaining about the suffix. Yeah, See, this is the reason why I kind of wanted to construct this manually. Because this I think quote always puts the suffix for integers because it knows the type of the input.
01:30:56.615 - 01:31:35.885, Speaker A: Yeah, I don't think that's going to work. I think we're going to have to construct it manually, specifically if it wants it to be unsuffixed. Right here it says now error number two U64. Right. Which is not what we want. So we're going to have to go back to what we had. Which is lit is sin.
01:31:35.885 - 01:32:33.725, Speaker A: Actually, can I. I can't really construct that with an unknown, can I? Think what I need to do here is just construct this macro to literal U64 unsuffixed. I let set span identify and then do this. Yep. And now I don't need code span either. Oops. Great.
01:32:33.725 - 01:33:05.405, Speaker A: Okay, so that gives us what we wanted. Why is it still printing stuff out? Hmm, great. So now we pass the first three. So let's look at progress number four. Paste ident. One of the big things calls will want to do with the sequential indices is use them as part of an identifier, like F0F1, F2. Implement some logic to paste together any ident followed by pound followed by our loop variable into a single concatenated identifier.
01:33:05.405 - 01:33:59.725, Speaker A: Optionally also support more flexible arrangements like f n suffix. I see, I see. The idea here is that you might want to use n as a thing that appears in an identifier and then we want to put together those identifiers. Okay. So this one shouldn't be too hard for us. Right, because we already have this expansion business. And so here what we're saying is if the identifier is just straight up the same as the identifier, we're going to make it n if we find another identifier where? Hmm, I guess we're going to have to manage identifiers, especially here.
01:33:59.725 - 01:36:01.085, Speaker A: So here we're going to search for followed by self ident or selfident pound for myself followed by the end of an identifier or self identical. Here is look at the ident name and then look for any occurrence of pound and see what follows it. So here, if we have an ident, what do we get from that identity here to get impul display? Really? Is there no way to get the identifier itself? It's unhopl. I really can't get the string of an identifier. That's awkward. Can I get one with like a sin ident maybe? Probably identify. That's not very helpful.
01:36:01.085 - 01:37:33.605, Speaker A: Is it really not? Is there really not a ah. Through the tostring method? Why is that not listed here? Am I just like blind? This doesn't say that it implements tostring, but okay, great. So tostring, I mean, you can always format it with display, but you know. All right, so let. Yeah, but does implement display doesn't give you tostring, does it? Or am I misremembering? Yeah, or maybe there's a blanket implementation of tostring for anything that implements display ident tostring name. All right, so we're going to look for where's my down here somewhere. Specifically what I want to do is split.
01:37:33.605 - 01:38:56.471, Speaker A: Split parts is name dot split on pound for part in parts Actually if parts any actually I is parts dot position car no string where the string is equal to self identify. Unclear. That will work. I guess it depends whether there's a partial E for string. There might be. So if let some I let's do a collect here. So in that case we're done.
01:38:56.471 - 01:39:34.185, Speaker A: If it's sum we need to implement. You need to peek ahead ident. Oh, because pound wouldn't be a part of the identity. Oh, you're right. That's kind of awkward. I hadn't thought of that. So specifically the observation is that if you have something like foo pound n pound bar, right.
01:39:34.185 - 01:40:47.855, Speaker A: This won't show up as an ident. What I was thinking here was I thought this would show up as an ident. That's this right where that is the ident. But that's not true. It's going to show up as foo followed by pound followed by n followed by pound followed by bar as we actually need to peek ahead in the stream when we encounter a literal pound which is also going to be a little annoying because I think it's basically going to mean that we have to do we have to also take the token stream here, which is pretty awkward. Do you need to find a way to stay using parse stream? Yeah, you're right. You might be right.
01:40:47.855 - 01:42:09.565, Speaker A: So in sin where's our parse? The recommendation here was is there a way that we can keep using parse buffer instead? Because parse buffer already has like look ahead methods and such. Because if so, what we could do here. Yeah, so instead of parsing this as a token stream, just have this can be a syn parse parse buffer. Although I don't think that will work either because this has to be tied to a lifetime. Although maybe it's a. Yeah, my guess is this parse buffer is tied to the lifetime, the input, which is kind of awkward. Maybe the way to do this is really not parse the braces here.
01:42:09.565 - 01:43:09.405, Speaker A: Well, or rather do this Right. But then still keep this as tt as input. That won't work either. Actually, here's what we might be able to do. We might be able to turn the token stream back into a parse buffer for the purposes of expansion. That might really be what we want to do. So down here, when we're given the stream, we're going to do this, right? We make a new one of these.
01:43:09.405 - 01:44:35.977, Speaker A: Oh, I can't make a new one of these, can I? So this is going to be a SYN parse parse buffer and it's going to be stream parse and then see? Why do I see. Hmm, it's a little bit awkward. How are we going to do this? So for parse buffer into a something parse, actually. Oh, does it implement just from. No, I don't think there's an impulse from here. I mean, unless I'm missing something here. But I don't think there's a.
01:44:35.977 - 01:45:13.205, Speaker A: From Syn Parse 2. Well, okay, what does. Let's take a step back here. What are the functions that I get here? Parse tokens of a source code. No, parse a proc. Micro token stream into something. Parses a token stream when procedural marking.
01:45:13.205 - 01:45:52.207, Speaker A: I see. That gives me a T. But what is a parse. Is this implemented for like parse buffer? No, I would have to know what type to parse it into, which I don't. Yeah, I don't. I don't think I can use this because I don't have. It's not clear to me that I want to parse it as anything in particular is the awkward part.
01:45:52.207 - 01:46:26.365, Speaker A: Like I basically don't want to write implements of parse because I would have to parse every possible item because you never know where the end is going to appear. So I would actually rather walk it as a token stream and I think from memory. Doesn't token stream also have a peak? Where's token stream here. I see. I mean it has a clone. It has clone and into Iterator, which is still kind of awkward. Yeah, no, I think I want to keep it.
01:46:26.365 - 01:47:25.065, Speaker A: I think I want to keep a token stream and then really just do. Yeah, here's what I want to do. Hmm, It's a good question. What is being coded? We're doing the second part of the procedural macro workshop from Rust Latham. I recommend you look at the first procedural macro stream that we did a few weeks back. If you are just jumping into this now, Chat needs a way to pin something. Were you thinking of pinning? That's kind of awkward because we don't have a good way.
01:47:25.065 - 01:48:03.871, Speaker A: I think what we have to do is give. We have to give. Expand to Access to the following parts of the stream. So what does the into Iterator give me here? It gives me one of these. I see. Oh, the answer to what this is about. Yeah, we should pin that.
01:48:03.871 - 01:48:55.445, Speaker A: You're right. Yeah. I might have to clone the stream, which I think is fine. It's just I have to clone it at the current point is where it's awkward. I guess I could clone it just every time I call expand. The recursion is going to be annoying too though because really this is going to be like rest, right? So if this is rest, then now this is fine because this. This would have to also give rest and expand.
01:48:55.445 - 01:49:30.357, Speaker A: What am I talking about? Oh man. Yeah, cuz no, that's right. G stream. Yeah, no, that's fine. This. This only needs rest because it's gonna have to walk it there. So all we need to do is find a way to give the rest of the token stream to expand to expand to.
01:49:30.357 - 01:49:56.031, Speaker A: I mean and I think the way we're going to have to do that is. Is definitely pretty awkward. I basically want a way to walk the stream without. Wait, is in. Is this clone? If that's clone. That is clone. Okay, so this is far easier.
01:49:56.031 - 01:50:44.265, Speaker A: Actually. I'm just being silly. So the token stream is going to be stream dot INTO iter here. This is going to be far easier. Where's my. This is tokens stream intuitor. So here what we're going to do is while some TT is equal to I guess let mute out is proc micro 2 tokenstream new while TTs next.
01:50:44.265 - 01:51:25.855, Speaker A: Then we're going to do out extend self expand to TT and TTS clone even. That's not going to work because we needed to return how far it walked, I think. Oh, so maybe we. Maybe we just do this. Yeah, yeah, yeah, yeah. Okay. This will.
01:51:25.855 - 01:51:53.367, Speaker A: This will be good. This will be good. I have faith. So it's gonna do this and the eye and then this is going to return out. And now this has access to the rest mutably so it can choose to consume more tokens. And so here there's going to be all sorts of funky. So if it's that, that's fine.
01:51:53.367 - 01:52:16.791, Speaker A: It doesn't have to do anything special here. If it gets an identifier, it's going to have to peak. And the way it's going to peak is by cloning the iterator. And then actually it's not even if it sees an identifier. It's if it sees a. Oh no, it is if it sees the identifier. Because the.
01:52:16.791 - 01:52:37.691, Speaker A: Where we. Where we get into trouble is there are a couple of things we could see, right? We could see foo and bar. We could see foo N. We could also see n bar. No, that can't be the case because identifier can't start with numbers. Okay, great. So you will always see an ident first.
01:52:37.691 - 01:53:41.381, Speaker A: And then if. And I guess what we're gonna do is match peak dot next, right? If the next thing is a proc macro to token tree literal lit. If the literal is equal to this, then something otherwise, if it's not, then we know that what we just got was an identifier that was not followed by a pound, it was followed by something else. And in that case we don't need to do anything about the identifier. We can just leave it the way it was. So in that case, we can just do this, which means that we can just do. Yeah, yeah, yeah.
01:53:41.381 - 01:53:59.655, Speaker A: Okay, this is good. This is good. This good. So now if we go in here, now we need to sort of search further. So the stuff down here is probably just wrong. 8. So I don't know if I can do this comparison, but it'll be fine regardless.
01:53:59.655 - 01:54:59.995, Speaker A: Okay, so at this point, what we've seen have seen ident followed by pound. So the question is what follows? This is the next thing, the chosen identifier or the repeat identifier. And so here we're going to do match next. And if that is a proc macro Token Tree Identifier Item 2. If Item 2 is equal to self ident. Right. If that's the case, then we have seen ident n.
01:54:59.995 - 01:56:05.715, Speaker A: We might want to clean up this a little, but for now I'm just going to leave it this way. Okay, so now the question is what comes next? So match peak dot next. If it's none, then we know that we should expand because that means that the pound n was the last bit in this block. If it's some. Actually, should we just always do it? In this case it might immediately be followed by some other identifier. Right. So imagine that someone writes like fn foo n.
01:56:05.715 - 01:56:44.975, Speaker A: I guess it would be this. So it would be a literal open parentheses or it would be a literal group. Actually, no, it would just be a group. But you could also imagine something like const. No, can't actually think of a thing that it would be. Yeah, the question is in this case, in what case would we not expand the n? I think in this case we always expand the N. The question is, why does the exercise talk about.
01:56:44.975 - 01:57:20.815, Speaker A: If you remember back to the exercise, the exercise also talks about n . Oh, because it needs to be. Because otherwise the N would be n underscore suffix, which we would not recognize as n. I see. So it's specifically if. If the ident is this, then may need to also consume. Consume another pound.
01:57:20.815 - 01:57:55.805, Speaker A: You don't have to worry about that because at the end Rust will still validate your output. You can just transform into a new ident and move on. Yeah, but we do need to consume. If the. If the user wrote another pound after the identifier, we do need to get rid of it because otherwise it'd be invalid syntax. So we need to consume it from our input so that it's marked as consumed. Because otherwise Rust would say unexpected token pound.
01:57:55.805 - 01:58:54.095, Speaker A: I think specifically because we replicate all the input we get that we don't specifically get rid of. We would just repeat out the pound sign as well, which is not what we want to do. And so I think here we want to do. How do we even do this? Let's leave that for a second. In this case, what we do know is that we need to produce a new identifier. Actually quote spanned. I guess it's going to be the spanned the span of ident.
01:58:54.095 - 01:59:51.105, Speaker A: And it's going to produce. It's going to produce ident. I. Oh, and I guess this has to be syn parse 2. Let's just see what it gives us for this. Well, first of all, I did something silly somewhere here. And I also did something silly down here.
01:59:51.105 - 02:00:33.035, Speaker A: I probably also did something silly somewhere else, like on 67. What did I do here? Found colon. Oh, yes, line 71. Yes. That also means one of those 96. Yes, indeed. 72 can't compare literals.
02:00:33.035 - 02:00:58.285, Speaker A: Of course it can't. Of course it can't. But this we know would be a pack marker two token tree lit stir. Otherwise it couldn't be a pound. That's not true. I'm totally lying. Actually.
02:00:58.285 - 02:01:22.875, Speaker A: It would be punctuation. It wouldn't be literal if the next thing is a punk'd. And it is a. What is a punk'd. Great. Punt. If punt is one of these guys.
02:01:22.875 - 02:01:52.715, Speaker A: Pound is not literal. String. Yeah, that's okay. Yeah. So let's see. Oh, am I really not allowed to compare that? Fine. If punked as car 76 should say oops.
02:01:52.715 - 02:02:45.005, Speaker A: Should say ident. And what else do we have? 79 should say token tree. Right, this we can unwrap. I think token tree is not an iterator. Oh, wait a second. What else does. Where is my token Stream? Token Stream implements.
02:02:45.005 - 02:03:10.045, Speaker A: Yeah. Extend token tree. Ah, fine. Iter once needs to be an iterator. Huh? 76 it's complaining that I moved something. That's fine. I don't particularly care if it doesn't move that.
02:03:10.045 - 02:03:49.625, Speaker A: 72 that's fine. This can also be by reference. 81 huh? That's fine. This can also be a reference. Don't actually need to own any of these. 83 oh, that's why I wanted to own that. Fine.
02:03:49.625 - 02:04:15.967, Speaker A: Not important. Probably. Oh. I guess our main needs to look like R4 for this to work out. What is this? Expand to proc. Macro panicked. Ooh.
02:04:15.967 - 02:04:48.605, Speaker A: Unexpected token. Where did it panic though? Also why is it. Oh, it's printing that just to be helpful. Okay, let's have it not print that. But where did it panic? Is what I really want to know. Unwrap here. Maybe we made invalid syntax.
02:04:48.605 - 02:05:23.227, Speaker A: Yep. Pound is not lit stir. I don't think I'm assuming pound is liter anywhere line 80 or something. Yeah, it's here. Doesn't need to be. Let's start. It's saying unexpected token.
02:05:23.227 - 02:05:48.145, Speaker A: Huh. Macro. Parse 2. Parse 2. Yeah. Macro. Not sure what you mean, Felix.
02:05:48.145 - 02:06:12.519, Speaker A: Great. Yeah. So apparently it doesn't like this. It doesn't like trying to parse this ident that we create here. We might just have to create the ident ourselves, which is luckily pretty easy. Right. So going back to here, where's our ident? So we can just create this with new.
02:06:12.519 - 02:06:57.235, Speaker A: And all we really need to do is give the string in the span. So here we're really just going to do proc macro to ident new and then here going to have to construct the string that's going to be the be the ident. And that of course is just the ident and the I concatenated to one another. And the span is going to be the original ident probably. I think that's the span we want. That way we don't need the unwrap either and we no longer need quotes. Line 81 token tree found ident.
02:06:57.235 - 02:07:30.165, Speaker A: Ooh, I see. I think that means I can do this instead. And then I can here do ident is equal to that. Do this. I could do this. And down here I could just return that. How does it like that? Hmm? Oh, none of that.
02:07:30.165 - 02:08:13.915, Speaker A: Well, that doesn't seem great. Expected one of parentheses or square found pound. Oh, right. We're right. So here. What's happening here is basically we are still emitting the pound symbol, right? Because here we given the Iterator but currently because it's just peaking ahead, it doesn't change the Iterator so it doesn't skip the pound sign when we find it here. And so once we get to this point we need to do.
02:08:13.915 - 02:08:55.473, Speaker A: We need to set. We need to set rest to be equal to peak. How about that? F1 1 times 2 F2 2 times 2 F3 3 times 2 Not bad. Not bad. Not bad at all. We still have this to do, right? Like it might still be that there's yet another. That there's yet another pound, right? So remember the case of foo pound n pound bar.
02:08:55.473 - 02:09:51.501, Speaker A: Currently we wouldn't. We would correctly replace this with the integer but we would not get rid of this pound. So here we may need to also consume another pound. And so if I guess we're going to do peak.next the problem here is actually who we might need to if we peek ahead. So if we peek ahead and it's not a pound sign then we don't want to consume that next token. And so this is why here we actually need to take the current peak and store it into rest and then continue operating on peak.
02:09:51.501 - 02:10:32.715, Speaker A: But we don't have a way to put something back into an Iterator. So in this case, I think really what we want here is this. Only in this case and in no other do we want to do this right. If we found anything else, then we don't want to touch the. We don't want to set rest to be equal to peak again because peak has consumed the next identifier. All right, so let's see how far we get in tests. Is it happy with our test 4? It is happy with our test for excellent.
02:10:32.715 - 02:11:55.085, Speaker A: I also really want to get rid of all these match statements. Sadly, I think it's a little tricky. There's. There's work on getting if let to work with and which would make this a lot nicer. I think in theory we could at least do this a little better by saying peak next, peak next and do do this and this to this, if that and this to that, then this and now we can get rid of some of these. Am I missing something? Probably. Yep, that's a little nicer.
02:11:55.085 - 02:12:24.355, Speaker A: See that it still works great. All right, so progress number five repeat section. So far our macro has repeated the entire loop body. This is not sufficient for some use cases because there are restrictions on the syntactic position the macro invocations can appear in. For example, the rust grammar would not allow the caller to write that. Oh, I see. You can't call a seek.
02:12:24.355 - 02:12:46.775, Speaker A: You can't call a macro here. Right, Exactly. Instead, we will implement a way for the call to designate a specific part of the macro input to be repeated so that anything outside that part does not get repeated. The repeated part will be written surrounded by the invocation below. Should expand to whatever. Yeah. Optionally allow for there to be multiple such section.
02:12:46.775 - 02:13:19.805, Speaker A: Well, the test suite does not exercise this case. Each of them will need to be repeated according to the same loop bounds. Ooh, are you planning on a break? What kind of break? A real world break. In what sense? Like during the stream. I wasn't planning on it. I have my water. I'm happy.
02:13:19.805 - 02:14:45.315, Speaker A: Okay. Right, so now we're going to have to be able to parse something like this. So this. Okay, so this changes the calculus a little because now this is also funky because it means that we need to. We need to figure out whether there are such repeat sections in the macro body before we decide whether to repeat the macro body or not. Interesting, interesting, interesting, interesting, interesting. Okay, so we're going to have to walk the input and if we find a pound followed by group.
02:14:45.315 - 02:15:51.615, Speaker A: Right. A punk pound followed by a group followed by a star. In that case we want to repeat the body multiple times. And in that case we don't want to repeat the overall body of the macro. Interesting. So this is now going to have to change because I think the way we want to do this is we probably want the. I think we want to try to do the inner replication first.
02:15:51.615 - 02:17:19.129, Speaker A: And if there is no inner replication, then replicate the outer, I think is going to be the plan. Okay, so in that case. So expand is going to. Huh. Ooh, interesting. How do we want to do this? The problem is we can't just run the inner and have it like set a boolean as to whether or not it's expanded something. Because if it told us it didn't expand anything, then would it leave? What would it do if it found the repeat identifier that has to be replaced with the number is.
02:17:19.129 - 02:18:09.925, Speaker A: One way would be to run the expansion in like a mode where it knows not to replace the identifier. Oh, that's kind of cool. So it'll basically be like a two. We could do this in two passes, actually. The first pass does the inner replacement and the second would do the outer place. So basically what I'm thinking is first you run a pass that expands any inner iterations, like any inner, like pound, bracket, star and if they did something, then then you just return the resulting stream. If they never made any changes, sorry.
02:18:09.925 - 02:18:42.985, Speaker A: And they're. They have to not be allowed to expand a pound n. They have to not be allowed to expand the identifier to the number unless it's inside of an internal repetition. Yeah, yeah. Okay. This will be easier to explain with code. Okay, how do we want to do this? I think we want to do this by saying expand ident bool.
02:18:42.985 - 02:19:06.094, Speaker A: This also means that there's going to have to be. This is going to be expand pass. This is going to be need to give these better, better names. But let's write the outer one first. So imagine that we have this expand. That is sort of the. The overall procedure we're going to follow.
02:19:06.094 - 02:20:21.125, Speaker A: And that is going to here do out is self.expandpassstream. clone and false and then is mutated. If mutated, then return out. Otherwise self expand pass clone true. So when this variable is. And then let me fill this out. So let mute mutated is false.
02:20:21.125 - 02:21:52.655, Speaker A: This does not have the I. Oh, this is weird. Okay, so I don't know if this is the best way to do this, but the idea here is going to be that Expand 2 when Expand Ident is false is only going to only going to expand repetitions and nothing else. Interesting. Let me see if I can make this a little bit more explicit. So we're going to have an enum of like, let's see, mode which is either going to be replace ident of which is going to be the identity I you're going to replace it with or replace sequence. And so it's going to be in one of those modes.
02:21:52.655 - 02:22:49.995, Speaker A: So this is going to start with mode expand. What did I say? What do I call it? Place sequence. Otherwise it's going to do self from self to value value. Oops, A map I span pass mode replace, identify I collect. Does this make sense? So it's first going to do a password. It's not going to replace any identifiers. It's going to write out the tokens and then replace only sequences.
02:22:49.995 - 02:23:57.985, Speaker A: If that indeed changed something, then we're just going to assume that we're done. Otherwise we're going to walk the range and then replace the whole thing with the identifier replaced. This means that think of this as something like what if a user writes in 0 to 10. Like if they write something like fn xn something and then they also write fny n. Don't know why they would write this, but imagine that they wrote Something like this. What should this expand to? Right? Because this outer one sort of implies repeat the whole block n times. But this part of the block is saying repeat n times.
02:23:57.985 - 02:24:41.017, Speaker A: And so if we did in fact repeat the whole block n times, then what this would end up being is this line N squared times right, which is just not what we want it to be. And so I think we're basically going to require that the user give us one or the other. Specifically, if we encounter code like this, the first pass in which it's only allowed to replace sequences should emit an error when it hits this. Right? That would probably be the best way for us to do this. To say, if you encounter this in. Oh no, we can't even do that. It can't be an error, because then this would be an error because the first pass is always going to be the same, so.
02:24:41.017 - 02:25:23.965, Speaker A: Oh, that's not what I meant. So if you see code like this, what should we do? The first pass is going to replace all of these. Hmm. I think the user is just going to see this as a compile error because this is just going to remain pound end. Ideally we'd give a slightly better error message, but I think that's okay. So this would actually expand only the innermost one and not the outermost one. And that's basically what this expand pass is doing, right? It is first running a pass with only replacing sequences.
02:25:23.965 - 02:26:07.745, Speaker A: And if they did something, then we consider ourselves done. Otherwise we're going to replace the whole block with every eye. Okay, so let's try that. How? Well maintainable are proc macros? What do you mean? Well, maintainable? This is not Python. This is Rust, the Rust programming language. It's funny that Rust gets mistaken for Python though, so arguably a good thing for us. Okay, let's see.
02:26:07.745 - 02:26:49.635, Speaker A: So this first pass is going to do a normal pass the way we did. So I think all of this actually stays the same. We just pass in the mode up here. We also need some way to express mutated. Mute mutated. So this is going to take rest. Mutated bool and a mode.
02:26:49.635 - 02:27:50.317, Speaker A: If we get a group, we're gonna. This is gonna use expand balls. What's that even gonna do? Pass mode? Yep, if it gets an ident. So in this case we replaced something. So we're just going to set mutated is true. Also, we only want to do this if the mode lets us replace the ident. So if let mode replace ident I is mode, then we do that.
02:27:50.317 - 02:28:31.895, Speaker A: Otherwise we're not allowed to replace this ident. And so it's going to stay what it was. Ident, I guess. Idents in top level pass in first pass. This is not for a game. No, this is not related to the Rust game. Okay, so that's fine.
02:28:31.895 - 02:29:10.229, Speaker A: This is going to have the same restriction where let I is equal to that. Then I otherwise. Otherwise return that ident. Also, this doesn't. Why did I even do that? Shouldn't be necessary. Then we're just going to return the ident here. Technically we can do this.
02:29:10.229 - 02:30:26.255, Speaker A: It's a little less nice, but fine. What? See, we could do even better. We could say mode here and then match on it down there. That way we don't need the if let's. Right, so if we're in the replace ident and we find those things, that's all great. So now there's one more bit we need here, which is what happens if we find a. If we find a proc macro token tree punct.
02:30:26.255 - 02:31:39.179, Speaker A: If p is equal to pound is. Then we need to figure out whether this is a repetition sequence. Right? And now we're going to play the same trick like we did previously, which is basically this if. And then we're going to match on peak next twice because we need to look at the next two items, right? And if those are. If those are a group. So I guess the group would be through their petition and this would be the star. So if what we find is this, if star dot ask is a star, then yes, indeed, actually.
02:31:39.179 - 02:32:39.517, Speaker A: And not just that, but also the repetition delimiter, the group delimiter is this. Right? So this case is we got a pound followed by a group followed by a punctuation where the group delimiter is parentheses. So I guess this should be. And the punctuation that follows is a star. The other thing we might want here is we want to make sure we're in the right mode. So here I guess if we only want to do this expansion if we are in replace sequence mode. Oh, you're right.
02:32:39.517 - 02:33:08.499, Speaker A: Should say star. Good catch. Although this part is going to be funky because here we're going to have to return a token stream, not a token tree. I think. Yeah, that might be problematic. Gonna have to figure that out in a second. Actually.
02:33:08.499 - 02:33:39.165, Speaker A: That might be an easy change. Otherwise we're just gonna keep it the same thing it was. Pete. So if it's this, then now funky things to do here. We're going to have to repeat the stuff that's inside. Luckily we already know how to repeat groups. Right? It's basically what we did up here when we encounter a group earlier.
02:33:39.165 - 02:34:07.905, Speaker A: Right down. If we go here, down here, right, we're going to expanded into. We're going to run. Where is it here expanded. We're going to call expand pass. Let's ignore those bits for a second. Yes.
02:34:07.905 - 02:34:49.955, Speaker A: Expand as many times as for each ident, for each element, for each sequence in the range. The problem here is this has to return a stream, right? This is not. We're going to replace the contents of that with a sequence of things, basically a token stream. Whereas what this function currently returns is a token tree. So we're gonna have to make this a token stream. Luckily that's not too hard to do. I should change the stream title to what's going on.
02:34:49.955 - 02:35:41.335, Speaker A: Yeah, this is one of the things I think is the biggest pain with streaming is like I don't want to have to go through all of the different channels that I multi stream to and give a title each time. But arguably I should usually like my announcements of the events happen on Twitter anyway. I sort of want all of these to just be synchronized. But yeah, arguably I should. So the real question here is whether I can easily get a token stream from basically. Ah, here's what we'll do. We're just going to assume that it's the token tree and then we're going to do iter once tt collect.
02:35:41.335 - 02:36:07.015, Speaker A: Because now we can early return in here with a token stream. That way the other code doesn't have to change. Right. So this expand pass is actually not quite going to be this. What it's really going to be is. I forgot we also need to do this like mutated business. This also mutates.
02:36:07.015 - 02:37:01.125, Speaker A: This is also going to mutate. So here we're going to. We've encountered a sequence. We need to expand it as many times as are necessary, which means we basically need to run the expand pass on this substream with the mode that is replacing the identifier. So how's that going to work? Well, it's going to be pretty straightforward actually. Self from value self to value map I expand mode replace identity. This collect, which is collect here is going to give us the token stream, the concatenated token stream.
02:37:01.125 - 02:37:29.585, Speaker A: I think in theory that should do the trick. Oh, this should be wrap stream. You're right. Thanks. Good catch. Where this is going to be a little bit tricky potentially though is can I set the span of a token stream? I don't know. Probably not.
02:37:29.585 - 02:38:36.725, Speaker A: Might not matter. What else do I have to do here? I also have to set rest is peak. Because we've now, once we've done this, then we have parsed up to and including the star. All right, this is probably going to be all sorts of broken 65. If identify star ident. This should be a proc macro to delimiter what? Proc macro to delimiter parenthesis. We might not even care that it's a parenthesis, but, you know, might as well do it properly.
02:38:36.725 - 02:39:23.699, Speaker A: This should return out and mutated. So this and a bool. This is going to then map out the token stream because we don't need the bool here. Expand, pass. This also ignores the bool. And 162. This should also ignore the bool.
02:39:23.699 - 02:39:58.705, Speaker A: 112. Really fine. Just kind of sad. But you're right. What? Oh, that's not what I meant. Ref is what I meant. Am I really going to have to make all of these be that pattern underscore not covered? Sure.
02:39:58.705 - 02:40:43.111, Speaker A: Underscore is gonna mean do nothing. So we're gonna go back to making this a mute P. Actually, it doesn't need to be a mute P even. It's just this 65 does really have to be that. So frustrating. Mind by move. P needs to be a ref.
02:40:43.111 - 02:41:13.935, Speaker A: Because ass car takes self. She does askar even take self. I'm not convinced. But yeah, that doesn't consume self at all. All right, Use a moved value mode. Oh, that's fine. Mode is all of the things it is copy, it's clone, debug.
02:41:13.935 - 02:41:34.935, Speaker A: It's probably other things too, but, you know. Ooh. Okay, so let's first see that we still pass the first ones. Great. Okay, so we still pass those. Now let's take a look at five. So five.
02:41:34.935 - 02:42:11.455, Speaker A: If we go back to our main. See what that expands to. Ooh, I got some errors. Expected square bracket, found parentheses. Oh, that's the compilation. Okay, so what did we generate for this? We generated nothing. I see.
02:42:11.455 - 02:42:52.905, Speaker A: So that's probably us generating this message. We expected square bracket, found parentheses. Did we now? Huh. All right, so something is wrong. So let's see how far we get here. First pass, second pass. See whether we even get to the right pass.
02:42:52.905 - 02:43:32.505, Speaker A: So it. Oh, that's interesting. So it runs the first pass and the second pass. And that is certainly wrong. So the real question is, why does the first pass not catch this found square? I'm assuming it's gonna hit that a number. Wow. It hit that more times than I thought it would.
02:43:32.505 - 02:44:22.135, Speaker A: Something's weird. Should not have found it that many times. Okay, well, I guess before and then here we have the luxury of being able to use rest before. Oh, token reiterator. That's annoying. Found it before derive. Found it before derive.
02:44:22.135 - 02:45:07.515, Speaker A: Found it before derive. Why does it call this so many times the first pass? So confused. Oh, because it runs the second pass, that's why. I see. So really, let's just to make our lives easier, let's make sure it doesn't actually run the second pass just so that we can. Right. So it found it on derive and it didn't find it anywhere else.
02:45:07.515 - 02:46:12.305, Speaker A: So the first pass did in fact correctly replace the thing, but mutated was false. Well, here's an observation. This should probably not do that anymore. What? So somehow it. What does it look like after the first pass? Spend here after first pass Pass. It looks like this out after the first pass is just a pound. That seems wrong.
02:46:12.305 - 02:47:26.433, Speaker A: Dot extend self Dot extend spin to mutated. Oh, I wonder which pound did it find? So it find the derived pound and then after the pass. Is that the same span? The bytes are a little off. 3730. No, 3738. Okay, so after the first pass, the only thing that's left is the first pound. So the one that's before the derive.
02:47:26.433 - 02:48:30.995, Speaker A: So this makes me think that. That this code for some reason ends up replacing the entire stream with just the first pound symbol it finds, which seems not quite right. So do we even get in here? Time to replace? I seriously doubt it, but you know, we did not. So it gets to here. So that's a punk expand. I guess we're gonna have to now have that. Oh, expand TT now have out.
02:48:30.995 - 02:48:58.417, Speaker A: In fact, let's do expanded this. Extend. Expanded. Expanded to that. Let's see what this actually expands to when we run it. So it expands the pound and it expanded to pound. So that seems correct.
02:48:58.417 - 02:50:49.165, Speaker A: But why does it stop iterating? Why on earth does it stop iterating at that point? Because the stream we get in should be the full program stream, right? Like if I do this, presumably that's the full program. It is not. It is just the very first token. Wait, where does stream come from? Am I doing something stupid up here? What is this token tree? That just seems wrong. The token. So the token stream that we get when we parse the stuff in the braces, what is content and what is tt? Ah, this is something stupid, isn't it? Yeah, this just seems wrong. The content.
02:50:49.165 - 02:51:42.769, Speaker A: It's saying that when it parses the rest of the input after the Range with braces, the content is just this. Actually just this symbol, which is just not right. Because like, if we go up here, what is input at this point? Oh, wait, maybe I'm just reading this wrong. I'm totally just reading this wrong. All the characters are there. I'm being stupid. I just read this as just the punctuation.
02:51:42.769 - 02:52:09.155, Speaker A: Never mind. I'm being very stupid. Ignore me. Okay, so we do actually. I'm being very stupid. So found before the derive, right? So the rest of the stream still has things like the star that we want to expand. Okay, so it found before.
02:52:09.155 - 02:52:47.973, Speaker A: It's not in that. It is in that mode. So in theory it should go in here peaking. It does go into peeking, but it doesn't go into here because it doesn't find the appropriate pattern. So it returns the punctuation which is correct, and then it returns the correct token tree. That's what it expanded to. Then it extends out with that.
02:52:47.973 - 02:54:13.725, Speaker A: So the real question is why does this not do another iteration after that expanded to. Yeah, I know about debug. It's just in my fingers at this point. The debug macro is really nice. Also gotta use an and else you move the thing inside the. Oh, yeah, sure, that's fine. So the real question is why does it stop consuming things from the token stream? Why does it think the token stream is empty? Does the peaking not actually work? Okay, let's first of all make this clone rather than consume the rest of the input.
02:54:13.725 - 02:54:43.295, Speaker A: Great, much better. Okay, now what did it generate? Okay, so it's walking the stream. Found a bunch of derives. That's fine. It walks some more. It found enum, found interrupt. Then it finds delimiter brace.
02:54:43.295 - 02:55:24.271, Speaker A: So it finds this square bracket, which is this brace. Yep. And inside of there is the pound, the parentheses token stream that contains the stuff where we need to replace things. Punctuation found pound before. I see what's wrong. I see what's wrong. No, never mind.
02:55:24.271 - 02:56:02.995, Speaker A: I don't see what's wrong. Okay, so it found a pound before the correct thing. It decides it's time to replace it correctly identifies that it's a pound followed by a group followed by a star. So now it doesn't expand on the inner bit. So it expands IRQ to IRQ 0 followed by a comma. It replaces IRQ with IRQ 1. So all of those are expanded correctly.
02:56:02.995 - 02:56:34.425, Speaker A: So the full expansion of that pound is our Q0 followed by a comma. Argue one followed by a comma. Okay, so all of that is correct. So Correctly expands that expanded to. So overall, that group expanded to a brace. So this is the group that starts at here. So that expanded to a group with delimiter brace.
02:56:34.425 - 02:57:13.935, Speaker A: So that's the variant list followed with that contains a stream that has IRQ0, RQ1, IRQ2, et cetera. So that seems. That all seems right. It just seems like it doesn't. It doesn't realize that it's done. Oh, I know why. It's because the mutate happens inside of a group and this doesn't propagate that change to mutated.
02:57:13.935 - 02:58:48.229, Speaker A: Okay, so this is going to have to be this expanded G mutated. Is this expanded and then mutated or equals g mutated. Yeah, now we're talking. So now it expanded to all of them. Beautiful, right? So the problem was this wasn't propagating out the mutated get back from expand pass and therefore this call had mutated be false. So it thought the first pass didn't change anything, so it ran the second pass. Okay, nice.
02:58:48.229 - 02:59:37.115, Speaker A: Okay, progress. So number six, make working function as of 134 function like procedural macro calls are not supported inside of a function body by the stable compiler. What do you mean inside of a function body? When you enable this test case, you should see an error like this cannot be expanded to statements optionally. Okay, great. Yes, I did see that error. Now what Optionally? If you have a nightly tool change, temporarily adding the following features to this test case. To this test case.
02:59:37.115 - 03:00:11.245, Speaker A: But before you move on, let's fix this in a stable way. Check out the proc macro hack crate for a way to make this work with relatively little effort. Shouldn't need to be any change to the macro implementation for this test case beyond picking up proc macro hack. But for the completeness, the expanded code here will look like that. Interesting. Oh, what a surprise. The workaround is also written by David.
03:00:11.245 - 03:01:32.327, Speaker A: Creators contain nothing but procedural macros, private help of friends and private punch. Fine, but nothing can be public. Oh, that's so funky. Shouldn't need that. Hygiene instructor says that the expanded code can refer to local variables other than those passed micro Must refer to local variable fake call sites. But why? I mean, it's not very hard to fix, I suppose. But why is this fix even necessary? Okay, so we don't need these anymore.
03:01:32.327 - 03:02:06.905, Speaker A: You. So what do I need to do? I need to do this and then make this. No, where is it? Down here. It needs to be a proc macro hack instead of a proc macro. Does that just make things pass? Oh, fine. What? Oh, right. I still need extern crate proc macro because it's special.
03:02:06.905 - 03:03:09.325, Speaker A: Proc macro is the crate that the compiler exposes, which apparently still requires. Okay. Oh, unresolved import. What? Well, that did not work. Interesting. So now seek is not being exposed at all. So this really makes it seem like proc macrohack does not work correctly.
03:03:09.325 - 03:03:59.585, Speaker A: Huh. Don't you need at least two crates? Oh, two crates are required. I see. The implementation and the declaration crate. That's awkward. Oh, I see. That really is a hack.
03:03:59.585 - 03:05:05.615, Speaker A: Okay, so that means we're going to cargo new libsec proc and then we're going to move source lib to sec proc source lib remove copy cargo toml to sec Progress there. And my. This. Oh, never mind. And then here we need a source library. What? Yeah, that's fine. And that's gonna have this proc sec.
03:05:05.615 - 03:05:51.035, Speaker A: So this is gonna have a sec proc which is going to be equal to path sec proc. And this should not have that. Right. And this should be like SecProc. And this needs no other dependencies or something. Actually, it needs proc micro hack. Great.
03:05:51.035 - 03:07:07.985, Speaker A: And also macro expansion ignores token curly brackets. That seems even more broken. And this should not be necessary for this. So I am running on beta currently, so I don't know if there's something on beta that would make this not work. Macro expansion ignores token curly bracket and any following in the. Wait, in our main. Why? And any following.
03:07:07.985 - 03:08:40.705, Speaker A: Why am I missing something from this, like micro hack? Yeah, and this does the right thing there. This externs. This uses. They both depend implementation crate using why? How is this different? Let's see. Is this a known issue? One Closed rust macros in expression position must expand to an expression. I see. So this is really saying.
03:08:40.705 - 03:10:38.129, Speaker A: So this. The claim here is that this is a bug in our implementation, that we have to produce something that's valid in expression context. What does this test case say? Shouldn't need to be any change to the macro invitation for this test case beyond piggybark. Micro hack, huh? I mean, I'm not sure I understand what it's complaining about, because in this case, expansion ignores. I mean, this seems like exactly the same error. Expression position must expand to an expression. So this suggests that it thinks that what we're generating here is invalid.
03:10:38.129 - 03:11:44.185, Speaker A: Wait, let's see exactly what it is we generate. So here, this gives me a. Let Z equals that. Fine. No, actually I specifically want this, which I think I can. Is this legal? How does it crash before I even produce any output though, right? Like this seems to complain about the input, not the output. Because I don't even get to the point where my output happens right here.
03:11:44.185 - 03:12:58.415, Speaker A: Ignore sum and any following. I think this is a test case bug fixed in master. Okay, let's do a get fetch upstream. Doesn't seem like it. Does it need to be fixed in earlier test cases too? Yeah, because I think. I think the problem is the earlier ones. See new text.
03:12:58.415 - 03:13:44.237, Speaker A: Keep the original seek macro for use outside of function bodies. Introduce. Oh, I see. Oh, that's funky. Okay, so this. You're telling me that what I should do here is have this be a proc macro and this be a proc macro hack. It's gonna be this and then source lib.
03:13:44.237 - 03:14:27.901, Speaker A: This guy is gonna use I guess this and this and now cargo R. Do I not need to attach that one? Okay, yeah. Great. So this is basically keeping the old one the way it was, but introducing a wrapper for the test case. Okay. No, no, that's fine. I mean it's nice that.
03:14:27.901 - 03:14:52.619, Speaker A: It's nice to. So we have David in chat and it's very handy that he could just fix the test case while we were running into it. Eseek. So should it be ESEEK or fseek? I guess eseek. Did I just like read it wrong? Did it say. Yeah, it says fseek. I see.
03:14:52.619 - 03:15:10.067, Speaker A: So this text should say fc. It should say eseek. Nice. All right, so cargo test. All right, we have six. Make work in function progress. All right, seven.
03:15:10.067 - 03:15:48.909, Speaker A: What do we got in seven? Should hopefully be a freebie. Ooh, freebie, Freebie, Freebie, freebie. Yeah, I like freebies. 8. Oh, inclusive range, huh? Okay, fine, David, I will implement inclusive ranges if you insist. Okay, so this should hopefully not be too bad for us. I think actually we're gonna change the orientation here a little bit.
03:15:48.909 - 03:16:39.655, Speaker A: And rather than store to and from here, store range, which is going to be a rust range Range. Isn't there a really. Is there a separate type for inclusive range? Didn't think there was. Yeah, there's not. Fine. 2. From an inclusive inclusive.
03:16:39.655 - 03:17:55.355, Speaker A: Is the range inclusive? So the real question here is how do I optionally parse a token? I don't actually know. What does parse say? Haha, I'm guessing it's this one. Just gonna let inclusive is token dot. Actually it's going to be option token dot parse input is some. Yeah, that's sort of what I guessed. Fill up our main again and expand inclusive ooh so many errors. Expected literal.
03:17:55.355 - 03:18:19.745, Speaker A: Did you expect a literal. Don't think that's true. Oh, sorry. This should go before two. Of course. Expected literal are now written as dot, dot equals. And you should swap the order.
03:18:19.745 - 03:18:38.519, Speaker A: Inclusive ranges are now written as dot, dot equals. Yeah, that's what I'm parsing. But why did it expect. Expect a literal. Oh, it's a specific. I see. So it's.
03:18:38.519 - 03:19:07.745, Speaker A: It's really that I have to do this. It's. It's considered one token dots, one exclusive, exclusive, inclusive. It's. It's not three tokens. It's. And then I guess I want to assert.
03:19:07.745 - 03:19:37.383, Speaker A: If not, I think really here's what I want. I can't option that. Why can't I option that? Oh, I guess I could just parse it as. Fine, I'll. I can pass it. Parse it as a range. Fine, fine.
03:19:37.383 - 03:20:02.043, Speaker A: I give up. I give up. I give in Expert range. Fine, fine, fine, fine, fine. I will parse it as a range. Okay, fine, fine, fine. Why not arrange.
03:20:02.043 - 03:20:31.789, Speaker A: Wait, what do you want me to do here? You want me to use peak. So. Okay, fine. The. I see. So I can't. What does parse give me? Actually parse buffer.
03:20:31.789 - 03:20:51.067, Speaker A: Peak. I don't have a parse buffer. Oh, I see. From parse stream. I see. So what you really want me to do here is with the parse buffer, do a peak. I see.
03:20:51.067 - 03:22:11.575, Speaker A: So here, this is going to be input peak. Yeah, Input peak, token equals. And if not inclusive, then just to give a better error message, we should be able to do token parse input. I don't think this will work because I think this is going to generate a type. Oh, token here. Expected literal. Oh, I see what you mean.
03:22:11.575 - 03:22:36.245, Speaker A: Yeah. So we need to. I see. This is what you want me to do. Except this would be that and this would be this. Because we need to consume the input regardless, right? No. Eh.
03:22:36.245 - 03:23:03.575, Speaker A: And I still want this because I want the variable and I want this and this. Yep. Nice. Ooh. Oh, right. We're not actually using the fact that it's supposed to be inclusive. Great.
03:23:03.575 - 03:24:09.565, Speaker A: And then we're going to do self from. There are two places I iterate. So let's make an actual iterator. It's going to give me. You know what? So because we're operating on numbers, we can do this normally. You can't do this normally. These are not the same.
03:24:09.565 - 03:24:52.835, Speaker A: But in our case we can, except this has to be value, value, value, value and value. And then this is going to be self. Range and this is going to be self range. Some big pyramids. Yeah, these are kind of unfortunate. It would be a lot nicer if you could use and. And if.
03:24:52.835 - 03:25:46.559, Speaker A: Let's. I mean, arguably we could like split this for example, into a function, but there's a lot of like local annoying stuff where we're going to have to pass all the arguments along. All right, progress. Nine, what do you got for us now? Pseudo macro API uses a type called span to attach source location and hygiene information that returns token in order for compiler errors to appear underlying in the right places. Procedural macros are responsible for propagating or manipulating these spans correctly. The invocations below expand to code that mentions a value missing 0 which does not exist. When the compiler reports they cannot find value missing 0, we'd like the error to point directly to where the user wrote missing N in their macro input for this has to pass.
03:25:46.559 - 03:26:05.815, Speaker A: Ensure that the pasted together identifiers are created using the specific of the identifier written by the caller. If you're using the nightly toolchain, there's a nightly only method called span join. Yep. So that we would get it to span including the N. Yep. I think this is just gonna pass. I think we've been good enough for that to happen.
03:26:05.815 - 03:26:57.685, Speaker A: Yeah. Why don't you use the inclusive range in the range method? So the reason I don't do that if you take a look at it. So implementer requires there to be a single concrete type that implements. It's not a din, right? It's an impul and dot dot equals returns a different type. This is why earlier I looked up standard ops range and see how range and rage inclusive are different types and so therefore I can't return both. Like I couldn't do equals here because these two match these two. If arms would have different types, I could return a box, I could do a box then iterator, but I can't do it with implementer.
03:26:57.685 - 03:27:35.363, Speaker A: All right. 10. Interaction with macro rules Suppose we wanted a seek invocation which the upper bound is given by the value of a const. Both macros and const are compile time things, so this seems like it should be easy. I suspect it's not going to be easy. In fact it isn't, because macro expansion in Rust happens entirely before name resolution. That is, a macro might know that something is called mproc but has no way to know which of many m proc values in the dependency graph does identify refers to.
03:27:35.363 - 03:28:04.669, Speaker A: Or maybe the improc constant doesn't exist. Yet when the macro runs, because it is only emitted by a later macro that hasn't run yet. In this compilation model, it isn't possible to support a query API where the macro can give it the name of a constant and receive back the value of the constant. All hope is not lost. It just means that our source of truth for the value of NProc must be a macro rather than a constant. The code in this test case implements this workaround. This test case may or may not require code changes in your SEQ macro, depending on how you've implemented it so far.
03:28:04.669 - 03:29:06.961, Speaker A: Before jumping into any code changes, make sure you understand what the code in this test case is trying to do. Okay, let's do it. So this uses e Seek source of truth, call a given macro passing NPR as an argument. Want this number to appear in only one place so that updating this one number will correctly affect anything. That depends on the number of procs. I see. Make procs array make procs array Pass proc Make procs array.
03:29:06.961 - 03:29:36.475, Speaker A: So this calls the macro make procs array with the argument 256. So calling Make Procs array with 256, this is going to be a literal 250. So this will work just fine. And this is going to call the macro literal identity macro with the value 256 returns 256. So this is set. So in theory, this should just work, I think. Nice.
03:29:36.475 - 03:30:27.467, Speaker A: All right, so this means that we now have all of the things right. Pass all the test cases. Good job. We did another macro exercise. All right, let's do Git seek implemented and push that. Beautiful. All right, now what exercise should we do next? Given the time we're at, I think we should do sorted, because my theory is that it will be faster than trying to do custom debug.
03:30:27.467 - 03:31:03.753, Speaker A: I don't think we'll have time for Bitfield. So I think, in fact, Bitfield might be a good exercise for you as the viewer to do after having gone through this with me. Okay, so let's do sorted. So in theory, all this does is. It's like. It's almost like a clippy lint, right? It checks that the variants of the enumerate in the right order and then emits errors correspondingly. Correspondingly.
03:31:03.753 - 03:31:25.365, Speaker A: Is that a word? Unclear. All right. Sorted. Huh? So let's go to sorted Cargo Tomo. I'm gonna assume that we're gonna need sin 15. We might not need quote. Actually, come to think of it, do we even use quote? I might be able to just remove Quote from the other one.
03:31:25.365 - 03:32:10.481, Speaker A: All right. Sorted source library and test progress first test 01 parse enums main. Alright, let's see what it says. This test checks that an attribute macro sorted exists and is imported correctly into the module system. If you make the macro return an empty token stream or exactly the original token stream, this test will already pass. Be aware that the meaning of return value of an attribute macro is slightly different from that of derive macro. Derived macros are only allowed to add code, so what they return is compiled in addition to the struct enum that is the macro input.
03:32:10.481 - 03:33:22.955, Speaker A: On the other hand, the attribute macros are allowed to add code to the caller's grade, but also modify or remove whatever input the attribute is on. The token stream returned by the attribute macro completely replaces the input item. Right? So this is what we talked about earlier when we talked about both derived builder and when we started on seek, how there's a difference between proc macro derive and just proc macro where proc macro derive adds code that includes like the implementations and the other types, but it doesn't change the originally annotated type. Similarly, a proc macro, if you if you annotate a function with proc macro, it replaces that entire token stream with the implementation of the macro instead, right? So what that means is the meaning of the function signature token stream to token stream is different for the two. For the custom derive, it's here's the token stream for the input, now produce a token stream to add. For proc macro it's here's the input token stream, here's return what to replace it with. And in the case of attribute macros it's the same.
03:33:22.955 - 03:33:56.645, Speaker A: It also replaces the original input item. So it's more like a proc macro than it is like a proc macro derive. Also parse the input token stream as a SYN item. In order for item to be available, you need to enable features full. This is by default, it only builds the minimum set of parts parsers needed for derived macros. Great, so let's do that. Here we're going to use syn.
03:33:56.645 - 03:35:01.705, Speaker A: See what even are we going to use here? My guess is I'm just going to bring in the other things that we know we probably need. So probably proc micro 2 is version 0.4and we're probably going to need. Actually we might not even need anything from SYN for now. So recall from the previous stream that for SYN there's this like super handy dandy proc macro input macro, parse macro, input macro where we do like this parse macro input args as sin args and item specifically. We could probably parse it instead of just parsing it as an item. We actually know that it's an enumerated, but that might not matter.
03:35:01.705 - 03:35:26.129, Speaker A: I don't know if there's an enum item. Probably not, actually. So an item enum. Great. Let's just parse it as an item enum instead. So this is going to be our type and this is going to be any args to sorted. And we sort of.
03:35:26.129 - 03:36:36.435, Speaker A: We assume that it's that we assume that args is going to be empty. All right, so here, let's go into sorted cargo T actually, let's do cargo expand first. Huh? Did I do something stupid? Yeah, I did. And of course we also need to use syn parse macro input synarg syn meta builder source lib. What do we parse that as? Oh, interesting, interesting. Sorted source lib into does not exist. Huh.
03:36:36.435 - 03:37:43.265, Speaker A: Two tokens. I guess what you're saying is also bring in quote and use quote2 tokens. Millie. I mean, I guess we could do that, but seems like a waste. Quote quote expected proc Token stream found proc2 great. And I want a debug of this. And I want a debug of this.
03:37:43.265 - 03:38:43.465, Speaker A: Unexpected end of input expected ident. Oh, it's not a meta, is it? See what args actually is. But we also. What? What did we say we needed features to be extra traits. And it's an empty token stream. Maybe it's just adder. I forget what is.
03:38:43.465 - 03:39:42.885, Speaker A: So derive input is a fec of attribute. I think it's a met. I feel like this was meta like. Okay, so we're trying to figure out how to parse the the pound sorted in the first place. And I feel like this was called a meta Medalist maybe Medalist. Yeah, something like that. Although it's not quite right either.
03:39:42.885 - 03:40:25.309, Speaker A: M. Yeah, meta. So why can't I parse that as a meta? Yeah, metasa were like test in that. Great. But it's not letting me do that. Why does it not let me do that? I mean, I guess args is empty. Oh, I guess.
03:40:25.309 - 03:40:45.595, Speaker A: Okay, fine. So for now we're just going to assert that args is empty and we can get back to that later. But for the time being, cargo expand of that just now produces the enum that we originally had. Great. And we parse it. So we should pass the first test. Beautiful.
03:40:45.595 - 03:41:10.907, Speaker A: All right, test two. So progress. Show me test two. Sort of macro is only defined to work on enum types, this is a test to ensure that when it's attached to a struct, it produces some reasonable error. Yeah, so we just parse it as an enum item. I see. So here we could.
03:41:10.907 - 03:42:18.885, Speaker A: We sort of cheated actually by parsing as an item enum because here the argument is really that we should use compile error. Like we, if you remember back to when we did the derived builder, we had to basically emit compiler error statements in the output token stream to make sure that we produce the right errors. And here really what the intention was was that if the thing you got was not was not an enum, you emit a compiler error thing that says this thing is not an enum. Yeah, but we don't might not need to do that theory and expected that we say expected enum or match expression. Oh, I see. So this is what Sneaky. So the exercises haven't told us yet that they want sorted to work on match as well.
03:42:18.885 - 03:43:21.885, Speaker A: And so therefore we can't get away with parsing it as an item enum because it's supposed to also work on match, which means that it's going to have to be an item and that would have given us the right thing here. Okay, so let's do it the way it's supposed to be. Parse it as an item and then we're going to basically, I guess, match on tie. Actually we don't even need to do that if let synitem enum. So I guess where's item here? So if it's an enum or it's a match, I assume match is a thing here. Oh, it's not, is it? Fine. Okay, fine.
03:43:21.885 - 03:44:15.005, Speaker A: If TAI is that. If TAI is that, then we return the enum. Otherwise matches a statement or expression, not an item. We'll get to it in later exercises. I think for now we'll just do it the way the way they want. I also want this to not have to do this. I want to operate on proc macro to actually here proc macro to token stream.
03:44:15.005 - 03:45:28.765, Speaker A: Actually, what am I doing? Let's just do this instead. Sorted implant then. Because now we can just do this and not have to deal with it. Because now this can return quote. Actually it's quote spend I guess. And here I want tie dot span to compiler error compiler and it should say expected enum or match expression. Actually why am I even doing that? Could just do this.
03:45:28.765 - 03:46:49.275, Speaker A: Use quote and quote spend proc micro crate types. Oh, this is a private function, so that's fine. It doesn't return, doesn't it? Fine, so we'll do this. This will just take input which is going to be a sin item. It's going to be tie and really didn't think that would be necessary. Yeah, something's not right there. I guess this is really going to be.
03:46:49.275 - 03:48:04.805, Speaker A: Wait, why is there not a span on sin item? That seems not quite right. Okay, what happens if I just do this? Then it won't highlight the right thing. I think like if I. If I now go here and take this thing and go to main and then run this, what's it going to tell me? I mean, that business is all fine. Master suspend items must limited with braces or followed by semicolon macros that expand to items. That seems unfortunate. Oh, actually that basically generates the right thing.
03:48:04.805 - 03:48:28.807, Speaker A: I'd prefer it if it highlighted the next item. There is. No, there's not. I just tried it. See? Use synspan span. This gives me a syn item input span. Run that span is private.
03:48:28.807 - 03:49:02.673, Speaker A: Oh, spend. I can't spell, can I? Great. Oh, interesting. This is all sorts of not what I wanted. Also, let's stop doing this. Debug print macros that expand items must be delimited with braces are followed by a semicolon. Oh, I see.
03:49:02.673 - 03:49:30.369, Speaker A: This arguably should still be input. Probably. Huh. Fine. No, really does not do the right thing. Oh, you're right. I'm being stupid because we're replacing the whole thing and so it needs to.
03:49:30.369 - 03:49:57.895, Speaker A: Yeah, you're totally right. Great. It's still highlighting something kind of weird. It really ought to highlight the whole item, but it highlights only the visibility, which is kind of weird. I see. So it actually wants us to not highlight that. I mean, I guess that's fine.
03:49:57.895 - 03:50:17.385, Speaker A: We can easily just do that. It seems worse, but. Okay. All right, so progress. So three out of order at this point. We have an enum. Let's do this.
03:50:17.385 - 03:50:58.615, Speaker A: Oh, now we're getting there. Right now we have an ENUM that's out of order. When your implementation notices a variant that compares lexiographically less than the one of of the earlier variants, you'll want to construct a synairror that gets converted to tokenstream by the already existing code that handled this conversion during the previous test case. The span of your error, which determines when the compiler places the resulting error message, will be the span of whichever variant name that is not in the right place. Ideally, the error message should also identify which other variant the user needs to move this one to be in front of. Ok, so here what we're going to do is if it's one of these. Right.
03:50:58.615 - 03:52:00.307, Speaker A: So I think the suggestion here is basically have another function that returns a result and then down here we're going to turn that result into a compiler error if necessary. Right. So if we look at 02, zineerror provides a method to render your error as a token stream. Great. So up here, the recommendation here is basically have the. Oops, have this, return a result, I guess proc macro to token stream or a synerror and then this can now return a error. What is this? How does Synerror work again? Synerror New.
03:52:00.307 - 03:52:32.665, Speaker A: Great. Synwoo. I don't know what span to give it though. Spend. Yeah, see, it's also kind of annoying. The problem here is parse macro input produces a token stream. So I can't put it in here because it wouldn't have the right return type.
03:52:32.665 - 03:53:13.207, Speaker A: And I don't want to use the span of the input because I want to use the span of args, basically. See, it's unclear what span I even want to use here. I don't think I want to give it a span. So I think actually in this case the span of args is call site. What is call site? Oh, I see. It's the call site of the macro. I see.
03:53:13.207 - 03:54:26.655, Speaker A: So how do I get one of those? I see, I see, I see, I see, I see. So I here really what I want to do is new where I give proc macro to span call site and then the error message I give is that. And then this is going to be. Okay, this, this is going to be unwrap or else e.to compile error, which we can write as synerror to compile error.intune but we can't because dref and into. Great.
03:54:26.655 - 03:54:56.165, Speaker A: So now let's see that it still produces the right thing. Okay, great. So for three, now we don't actually check that they're out of order. Great. So we're now at a point where we need to check that the variants are in the right order. Now check variant order. So this brings us back to we have a sin sin item which contains an enum.
03:54:56.165 - 03:56:14.245, Speaker A: So we have an item enum and we want to walk the variance, right? So for variant variant invariant in E dot variance probably by ref. Um, because punctuated implements ITER, right? Yeah, great.iter so it's going to give us a bunch of variants and each variant has an ident. So name is going to be variant identity. What we want to do is check that these are in order. One thing we could do is just allocate, basically parse all of them into a vector, sort the vector and see that it is the same as the original vector. The other alternative is let mute Last is string new.
03:56:14.245 - 03:57:11.015, Speaker A: If name is less than last then we return. Then we want to return an error because in this case name should have been before last but. But it was not. So in this case it would be variant span. So we're going to have to bring back use and the error message is going to be variant out of order and then last is going to be name. See how that works? Variant out of order. Something failed.
03:57:11.015 - 03:57:43.625, Speaker A: Is that what we expected? Yeah. Now it also says ideally you would tell us where it really should have been. Right. I mean, let's first see whether it gives us. Okay, what does it expect us to give? Something failed should sort before that failed. Ah, I see. I mean this is luckily pretty straightforward.
03:57:43.625 - 03:58:35.205, Speaker A: Names is going to be avec. If names not names is empty and names names last map is if the if name is smaller than last unrap or false names push name. So in this case we now have all the names in order. So we know that names is always going to be in lexiographic order. Right. So what we can do is. Should be.
03:58:35.205 - 03:58:55.335, Speaker A: Is going to be names. Binary search name. Right. Slice. Pretty sure there's a binary search in this somewhere. Oops. This one.
03:58:55.335 - 03:59:41.711, Speaker A: Nice theme. Do you have a setup for download? Yeah, I have a. There's a separate video where I go through how my whole setup works. You can take a look at that if you want. So basically what we do is we're going to search for where this name should have been in the list. Unwrap or else I guess we can match on that. Ok.
03:59:41.711 - 04:00:04.615, Speaker A: Means that the name was already in the list elsewhere. So I think we can actually do. Which the compiler would already complain about. So we can here do unwrap error. So the error type here is what index. It would have come right before. Right after sorted while maintaining.
04:00:04.615 - 04:00:40.985, Speaker A: Yeah, so this is where it would have been inserted. Which means that the element at that index is the element it should have been placed before. Right. So here. Oops. Here what we want is format. What was the merit message? This should sort before that.
04:00:40.985 - 04:01:24.055, Speaker A: Where that is name should sort before names should be. So this would be. I guess what should we call should be is a bad name for this variable. It's like next Lex. I see how that expands. Oh, something failed. Should sort before that failed.
04:01:24.055 - 04:01:52.217, Speaker A: That seems promising. Perfect. All right. Progress 04 this does it? Similar to the previous, we want to ensure the macro correctly generates an error when the input enum is out of order. This time it is using an enum that also has data associated with each variant. Okay. So in theory, that should be a freebie.
04:01:52.217 - 04:02:29.975, Speaker A: Who. It's not. Huh. This seems wrong here. There are a bunch of warnings. Oh no, this is probably still us probably doing something wrong. So if we expand this, what does it expand to? Oh, what? Oh, it doesn't emit the enum.
04:02:29.975 - 04:03:09.631, Speaker A: That seems like a problem. I see what's going on here. So we don't omit the enum if we give the error, but we should. Right. We should still keep the original enum in there. And because we don't omit the enum, a bunch of other warnings appear. So because we know that sorted is never going to change the enumerated, I think what we're going to do here is mute out.
04:03:09.631 - 04:03:57.075, Speaker A: It's going to be that out dot. So this result is really going to be empty. It doesn't have to produce anything. And then we're going to do. Oh, I see. I think out is just going to be equal to input. And then if let error E is that.
04:03:57.075 - 04:04:49.153, Speaker A: Yeah, this is what we're gonna end up doing. Right. Then out dot extend this and then out cannot infer type for a. This should be token stream. Yes, token stream from. Great. And now this.
04:04:49.153 - 04:05:27.375, Speaker A: Ok, doesn't actually have to return anything because we're always going to emit the enum back out. And this input is. We can just clone here. That's fine. Oh, this is going to clone that input stream. Great. So now we still omit the output, but also the error.
04:05:27.375 - 04:05:58.429, Speaker A: Great. All right, progress five Match expression. Get ready for a challenging step. Much bigger change than the others so far. Great. Not only do we want sorted to assert the variants of an enum are written in the order of enum definition, but also inside match expressions that match on that enum. Currently though, procedural macros on expressions are not allowed by the stable compiler to work around this limitation.
04:05:58.429 - 04:06:57.315, Speaker A: Until the feature stabilizes, we'll be implementing a new sorted check macro, which a user will need to place in whatever function contains such a match. The sorted check macro will expand by looking inside the function to find any match expressions carrying a sorted attribute, checking the order of the arms in that match expression, and then stripping away the inner sorted attribute to prevent the stablecompiler from refusing to compile. Note that unlike what we have seen in the previous test cases, stripping away the inner Sorted attribute will require the new macro to mutate the input syntax tree rather than inserting it unchanged in the output token stream as before. New procedural attribute macro called check. Parse the input as a SYN item fn Traverse the function body looking for match expressions. Easiest if you use the visit mute trait from syn. Yeah, see, I wish the visit mute or visit were documented because currently they're a bit of a pain.
04:06:57.315 - 04:07:54.353, Speaker A: For each match expression, figure out whether it's sorted. Should be able to get these present. Okay, great. So let's copy this into our main again so we have a thing to look at and back to our source library. All right, so we're going to define up here a proc macro. What did it say? Right, yeah. So procedural macro attribute check be the same thing.
04:07:54.353 - 04:08:39.407, Speaker A: We're going to parse that as an item fn and let's do. Let's say that sortedimple is a bad name. Let's say sorted variants and then down here we're going to say sorted match. Great. So this is still going to include the original thing that was given with the attribute. So now we're going to have to write sorted match and the input is going to be a SYN item fn. Right, because it's an annotation on a function.
04:08:39.407 - 04:09:33.765, Speaker A: And like before, we're going to reuse this error type of ours. Great. I guess we do get to use Visit after all. No, that's not what I want. Back to SYN and we want visit mute. Okay, so here we're gonna have, we're gonna have a struct lexiographic matching and we're gonna implement SYN visit mute Visit mute for that type. And in particular, in fact, I think this called out which one we wanted visit expur match.
04:09:33.765 - 04:10:15.827, Speaker A: So we're going to want that function which is going to take. That's not what I wanted, is it? Mute this function. This is going to be a SYN expert match. And specifically remember how down here. Oh, that's right. We can't. We can't do the same thing.
04:10:15.827 - 04:10:54.845, Speaker A: I lied. If we success. Oh man. We have to remove the sorted attribute regardless, because otherwise the program won't compile in the first place. So I think what we want to do here is be a little bit more careful. And specifically we're going to do that by not having this business and instead doing this. So not gonna do this thing.
04:10:54.845 - 04:11:41.275, Speaker A: Not gonna do this thing and instead just do. So how is visit mute supposed to be used? I guess it's supposed to be used like mute F. Right. And then we're going to do F visit item fn mute. No, it's not true. We can do lexiographic matching. Visit item fn mute.
04:11:41.275 - 04:12:19.495, Speaker A: Yeah, ute F. And now we still have the F. And at this point what we want to do is this lexiographic walk is going to insert the compiler error for us as well. So all we really want to do here is just return back out the F. Might not quite work that way, but, you know, roughly. Great. So here what we want to do is.
04:12:19.495 - 04:13:27.685, Speaker A: No, it should be M for match. Okay, so what we now have is a SYN expert match. So the first thing we have to do is check that there's an attribute there that called sorted. So if M adders iter any A A is equal to sorted. If not that, then return. Oh, we also need to add the visit dependency. Millie, is there a visit mute as well feature? Apparently.
04:13:27.685 - 04:14:39.505, Speaker A: Okay, so visit mute and I did something silly tonight. So for the attribute. Oh, I'm gonna have to parse it as well, aren't I? Oh, this is gonna be ann. Because what I really want to do here is like adders is going to be. Ah, no, that's fine. Any a dot path sort of equal to sorted inside the current one. Oh, you're right, I can't even do that.
04:14:39.505 - 04:15:25.825, Speaker A: I needed to visit all the arms as well. Okay, fine. So check. All right. And down here what we want to do is we want to walk all of the arms. Although there's a. Actually we can do a little bit better because visit mute has this thing which I assume these functions are the default implementations, which means where's visit exper Match mute.
04:15:25.825 - 04:16:30.795, Speaker A: Yeah, so here we can just do syn visit mute this with the visitor, which is self and m keep keep recursing. So really what I want to do here is if this is true, then check the variance. But crucially, this is not quite sufficient. What I want is. Well, sort of, I guess I want to remove sorted. Right. So we need to make sure that we remove this attribute, which we can do with retain not equal to sorted.
04:16:30.795 - 04:18:04.211, Speaker A: I probably can't use equal to string, but it's easier to fix later. And then we want to walk all of the variants of the expert names is going to be avec new for Armin arms iter we're basically going to pull the same trick here as we did above. Oh, I see. It can also be multiple patterns, which is all sorts of weird with this. I like, what do we even want? Like if the user writes something like match and they I guess they annotated with sorted and then they do A or Z this be this Z this. I guess, I mean like, is this a problem? I don't know. What if they do Z or A this? What are we going to require? Right.
04:18:04.211 - 04:18:44.625, Speaker A: This is why every ARM has multiple patterns. I think we just want to look at the first pattern, at least for the time being. So name here is going to be arm pats. Pats is terrible. Iter next unwrap we could stringify the full pattern. I suppose it's a good point. Is that what we want to do? Can I even do that? Like does this implement display? It's not clear to me that it does.
04:18:44.625 - 04:19:21.825, Speaker A: I mean it implements token I suppose, yeah. Like I could. I could quote it and make it a string. Was it also unclear that we're going to require the full pattern to be alphabetic? I'm not. I'm not convinced that's the case. I think we're just going to leave it like this for now. Oh, it gets even worse.
04:19:21.825 - 04:20:33.373, Speaker A: Oh, like what if the user writes this right and then they write like X at a, whatever A at Z. Is this wrong or not? Interesting. No, Only accept items won't work either. Right. You still run into the same issue. Like you want to handle things like pattern structs, tuple structs. I think we do require anything that's named.
04:20:33.373 - 04:22:08.465, Speaker A: So I think the options are like tuple structs, structs and idents. And for the ident we only care about the sub pattern. I think really what we want here is a get arm name which takes syn pat and gives us a string. It's going to match on arm, it's going to match on the arm and if the arm is syn pat struct then it's going to do something if it's tuple struct and if it is an ident. So if it's an ident a pat identified, then we're just going to match into the sub pattern. I think so then we're going to do get arm name of ooh I guess option string. Then this is going to be I.subpath.map
04:22:08.465 - 04:22:47.145, Speaker A: actually as ref map sp actually I don't care about the at, but I do care about this. That gives me a sub pattern which is going to give me. So this is going to be an end Then the other thing that's going to be annoying here is to get out the. Is possibly at least to get out the span. But let's stick with this for now. So this is going to Give me the sp. Anything else is none.
04:22:47.145 - 04:23:23.005, Speaker A: If it's a struct, then I want it to give me. It's probably just like the path. Yeah. Then it's s path, which probably has a two string. It does not. Why does it not have a two string? Let's try it and see if it does. I feel like it should, but I'm not sure if it does.
04:23:23.005 - 04:24:41.945, Speaker A: And the tuple structure is probably exactly the same where it has a path. Yeah, actually you're right. This could be sin pat ident. I could just like match into this where what I care about is sub pat is sum and then I don't care about this, but I do care about the sub pattern. I do think I care about other things than just idents. Like for something like matching on the struct like that seems totally reasonable to also order if it's an ident. The question becomes do I match on the bound variable name or do I match on the variant? And I think matching on the variant is actually the right thing to do because the named binding is just going to be a variable name.
04:24:41.945 - 04:25:09.655, Speaker A: For example, the name binding could be nothing. Yeah, exactly. The sub pattern is if I write, at least if I understood this correctly, like if I do foo at barzoo. Right. It's the barzoo I want to sort by, not the foo, because the barzu are the variants of the enumerated. And so that's the thing I want to sort by, not this. And this is the sub pattern.
04:25:09.655 - 04:25:49.785, Speaker A: The other question of course is whether. Yeah, so path doesn't implement tostring, which is a little awkward. M dot arms. That's fine. Yeah. So the real all of these come down to I have a path and I want. I want a string representation of that path, which like maybe what that gives me, but simple path.
04:25:49.785 - 04:26:28.325, Speaker A: So unhelpful. What does path segment give me? Oh, because it can contain types and stuff too. Mmm. It might actually be that what I really want here is, is to. I'm surprised the path isn't display. That seems wrong, right? Because I guess it implements two tokens. So.
04:26:28.325 - 04:28:08.441, Speaker A: So can I do like this? Or better yet, what does two tokens give me? Gives me a token stream. In fact, the other option here is to do this, but that's not going to be very nice. I actually want to print the path itself. Yeah, I'm gonna need quote, aren't I? Quote, quote. Okay, so here we're gonna do just the sort of silly F this TS into. That's fine. And of course, yes, I Do need to include this Path doesn't implement display pattern doesn't mention fields.
04:28:08.441 - 04:29:07.965, Speaker A: That's fine. Okay, so all of these now are about how do I get a string for a path? Okay, path as string. So I know that doesn't work, but let's at least move all the code to use this. So this would be path as string. This would be the same. This would be path as string this and same here. Definitely less efficient than it could be.
04:29:07.965 - 04:30:04.735, Speaker A: And now the real question just should just be this. Oh, I guess this is going to have the same property as up here where this. Where this is going to be. Get arm name. Get our name of that unwrap for now. Although that won't actually be an unwrap down the line 60 variant dot span. So this is actually going to be arm span 59 this.
04:30:04.735 - 04:30:31.505, Speaker A: Yeah, we're going to have to figure out how to change that to. I think this is. So this is where we're going to inject the error if something is not sorted. And I think we need to inject that into the body of the arm. Maybe might not matter. It might be we can inject it anywhere there is a path. Dot is ident.
04:30:31.505 - 04:31:38.905, Speaker A: Okay, so that saves us from this one, but it doesn't really help with the others where I want the full representation of that path. So here I guess what we're going to have to do is something like M dot. Where's the thing where I get expert? No expert match arms on a given arm body. It's a box expression. It's going to be awkward actually to modify this. Oh I guess actually what I can do here is just like an error is going to be a vec of Synerror. So here I can just do errors.
04:31:38.905 - 04:32:46.295, Speaker A: Push this. So we just accumulate all the errors that we find and then at the end here what we'll do is do that and then TS extend. I guess we can drive default for this. LM is lexiographic matching default LM that extend LM errors into iteration map for each error we need to do to compiler error. Great. So now I think the only thing is 49. I think the only thing now is the whole path to string business.
04:32:46.295 - 04:34:07.435, Speaker A: What? No field errors? Errors? I mean I'm. It might be that we can just do this format should sort before IO. That seems promising. Did that really just like work? Find that hard to believe. Oh, hey, finally. It's funny how I think most of the people who watch these videos have not watched it live. The advantage is now you can ask all the questions.
04:34:07.435 - 04:34:52.625, Speaker A: It's the real upside to watching it live. Hey, great, that worked. Okay, now that we have some experience with visit mute. Thinking back to when we did seek, I don't think we could have used seek for this because the input is like not valid, not a valid ast. So I think the parsing would just fail. So we couldn't use visit or Fold for that matter. Right, so progress six Pattern Path main so let's see.
04:34:52.625 - 04:35:31.334, Speaker A: When we checked enum definitions for sortedness, it was sufficient to compare a single identifier in the name of the variant. For each variant, match expression different in that each arm may have a pattern that consists of more than just one identifier. I mean, this is what we looked at earlier, right? Ensure the patterns consist of a past path are correctly tested for sortedness Path tuple search obstruct I think we just get this for free. See, I knew it wasn't just identical. Oh, so close. This is just. The only thing that's wrong here is that we don't know how to print a path.
04:35:31.334 - 04:36:00.905, Speaker A: Or rather we turn a path into a string the wrong way. Fine. Path dot. Let's go back to where's the. Oh, that's far away. That's annoying. So we could of course just render the path ourself.
04:36:00.905 - 04:37:01.441, Speaker A: Seems a little broken. But you know, we can do it just by saying. I really don't feel like we should need to do this. This is why I wanted to take a look at the like solution, so to speak. Repositories. Just to see how David writes out a sorted great source visit. Yes.
04:37:01.441 - 04:38:18.395, Speaker A: So see here as well. David just takes the path, quotes it and takes two string and then you end up with these spaces around the colons. But then how do we generate the right thing, the right error? Guidance of path. Oh, he actually keeps the idents rather than the string representation Unclear that that's important for us. Oh, there's also path. What does path do compared to ident? So path we might have to handle path as well. Okay, so let's go back here and make sure we also cover path.
04:38:18.395 - 04:39:05.857, Speaker A: So the. That's path P path. I don't know what qself is here qualified with a self type. There's a qself. Oh, it's like an ask as thing. Okay, wait, so what. Oh, the.
04:39:05.857 - 04:39:45.277, Speaker A: Oh, you've posted solutions in here. Neat. Proc macro commit 8320. Nice. Oh, I see they're not on the master branch. They're just like disjoint commits Right, Yep. So that gives you a bunch of paths.
04:39:45.277 - 04:40:09.835, Speaker A: That's fine. Yep. Oh, I see. You make the two implementations common by having them both produce paths and then you just check the paths. That seems reasonable. I see. Yeah.
04:40:09.835 - 04:41:00.553, Speaker A: But isn't this. Okay, where does the error come from? It's the myth that's tricky because the when I just quote, it's basically how do you print a path. I see. Okay, so you just constructed manually. So this means it does not include like the leading. Leading colon, for example. Yeah, I mean, I guess we could do that.
04:41:00.553 - 04:41:52.965, Speaker A: Makes me sad. But you know, great, because I think in theory we can just do. Do this. Right. Because each segment is like that and then join this. What does path segment implement? Implement. Wait, what? Uh huh.
04:41:52.965 - 04:42:40.985, Speaker A: Segment formant formatter. But path segments are also not display. Right. Path segment. Oh, I guess we can quote the path segment, but not sure why. Okay, fine. So we here we could do like quote this and then you need to do this and then you can join it.
04:42:40.985 - 04:43:15.505, Speaker A: Yep. Let's see. Okay, so. Oh, the span should span the whole path, whereas for us it does not. Right. So the error messages are the same but the Spanish should cover the whole. The whole path, not just the first part.
04:43:15.505 - 04:43:48.705, Speaker A: I see. Well, we already set the span to be the span of the arm. I guess you want it to be the pattern. Oh, this is because you use the path. I see. So the solution. Why is the span of the arm just this though? That just seems broken.
04:43:48.705 - 04:44:39.005, Speaker A: Okay, so maybe we should refactor ours to talk about paths instead. So rather than have oops. Rather than have get arm name, we have get arm path gives you a syn path. I guess it can give you a reference to it. And that means this is going to give you armpath. This is going to give you this, it's going to give you that, it's going to give you this. So now up here, get our path.
04:44:39.005 - 04:45:12.495, Speaker A: I guess really what I want this to do is. What do I even want to do? If. If a thing that's marked as sorted, a given entry has no path. I guess this is where there's like. If I read this correctly, it's like a. Not supported by. Yeah, unsupported by.
04:45:12.495 - 04:46:23.085, Speaker A: Let's just unwrap for now. That's fine. So this is a path and I think really what I want here is path dot span. But we could still leave the name as path as string path. Why is the span still wrong? Because this should give the full path here Air Force format should sort before error IO and This is printed from the path, but the span of the path is only this. Oh, is there. Is this where we need to use? Oh, you're right.
04:46:23.085 - 04:46:36.435, Speaker A: It's the whole, like the error. New can only take a single span. Okay, so new spend and then I guess give the full path. I think that's. I think you're right. I think that's what we did. Okay, great.
04:46:36.435 - 04:47:15.445, Speaker A: Good catch. Nice. Okay, great. There's still some, like, weirdity here, right? Like, we might want to support other types of paths, or we might want to support them differently. We might also want to try to, like, share this loop with the loop we use for checking variants, but progress. Seven Unrecognized pattern macro won't need to define what it means for other sorts of patterns to be sorted. It should be fine to trigger an error if any of these patterns are not something that can be compared by path.
04:47:15.445 - 04:47:35.575, Speaker A: Be sure that the resulting error message is understandable and placed correctly underlying the support. Unsupported pattern. I see. Yeah. Because here it's marked assorted, but the things are don't have a path. And so in those cases, I think we're actually still in pretty good position. Right.
04:47:35.575 - 04:48:23.775, Speaker A: So down here, I think maybe what we want to do here is if let some path. Is that then path. Otherwise. Otherwise we're going to push an error saying that Arm pat. Arm pats. See, that might not even work. We'll see.
04:48:23.775 - 04:49:06.765, Speaker A: And then it should say something like unsupported pattern. I'm guessing unrecognized, unsortable pattern. And it should say, it doesn't even have to do that. You can just say this. What am I missing? Seven. Right. Okay.
04:49:06.765 - 04:49:25.355, Speaker A: And we did something wrong because we said this, right? So there. I don't know if span is implemented for vectors. Apparently it is. Sweet. So it highlights the pattern. It says unsortable pattern. What does the test case require us to say? Probably something similar.
04:49:25.355 - 04:50:08.571, Speaker A: Request to say unsupported by by remains sorted. Why does it have to say that? I mean, we can pretty easily make it say that, but I don't know why it has to say that. That seems odd. All right, now what? Unsupported by. We're not allowed to emit all the errors. Okay. We actually emit too many errors.
04:50:08.571 - 04:50:36.305, Speaker A: So we emit an error for every pattern that we don't support, whereas the given solution expects us to only emit an error for the first one. So, I mean, I guess that's easy enough for us to fix. Intuitor, take one. Sweet. All right. Progress. Last one.
04:50:36.305 - 04:51:51.385, Speaker A: All right. 08_Main this is a. There's one other common. What did I miss? There's one other common type of pattern that would be nice as support the wildcard or underscore pattern Sorted macro should check that if a wildcard pattern is present, then it is the last one. I see. Well, we can do that pretty easily. So up here what we can do is else if arm pats.iter.next.map
04:51:51.385 - 04:52:58.569, Speaker A: actually, just that if that is sin pat what did we say the wild. Wasn't there a wild card pattern? Right. Somewhere up here, wild pat wild I guess W let mute wild is none. Then wild is some W. If wild if let some W is wild. So this means that we encountered an arm after we already had wild. Well, that's an error, right? And we can in fact break.
04:52:58.569 - 04:53:56.955, Speaker A: There's no reason to process any of the other arms. There's no reason to check them. And in fact that also sort of means that we can do that here too. Wildcard pattern should come first and then in fact here we can give the wildcard as the error point to the. The real question, I guess, for the span of this error is whether it should point to the wildcard pattern or whether it should point to the arm that came after the wildcard pattern. Also it should say last, not first continue. If that is equal to that, unsupported ported by remains sorted.
04:53:56.955 - 04:54:58.605, Speaker A: That doesn't seem right. That's definitely not what that should say. What? This suggests that we're not extracting the right thing. So I guess P. Show me what that thing is. What is it? We're not handling. We're not handling rust fest.
04:54:58.605 - 04:55:32.895, Speaker A: Rust. Oh, ident. Oh, is the. Ah. So this was your point back then, Felix, that the. Oh, that's so weird. So the sub pattern is what then? Like from the opening square bracket.
04:55:32.895 - 04:56:29.375, Speaker A: Hmm. Oh, that's interesting. The other question is whether I can get to a path. Whether I can make an ident into a path. I mean, probably see at box pattern. Yeah, that's what I looked at. But I don't.
04:56:29.375 - 04:57:53.575, Speaker A: That doesn't actually explain it. I see. So I can take. Okay, so if this is an ident instead that or if I want the ident out instead, then really what this should give me is I guess. I guess really then what I want is an ID into, I guess some ID into which gives me a path. So this means that this has to be owned, which is probably fine reference. Huh.
04:57:53.575 - 04:58:27.705, Speaker A: Okay, but does that actually give us the right Thing though. I mean probably not, but it's probably the wrong message. Oh right. We can't. Can't be printing out all these things. That's not. Okay, wait, we just passed the last one.
04:58:27.705 - 04:58:55.631, Speaker A: Wildcard pattern should come last. Was that. Did we just guess the right. That's too funny. 08. Oh, there's no associated check for 08 underscore. Oh, I see.
04:58:55.631 - 04:59:22.529, Speaker A: So there's no actual check for test eight which is why it was fine for us to not give any text. Wait, so this means we pass all the tests? There are no more tests. Nice. There's probably like a decent amount of cleanup here to do some code sharing between the different implementations. We could also do some tidying up of how to handle paths. But overall this now like does the exercise. Yay.
04:59:22.529 - 04:59:47.911, Speaker A: Well done us. Right, so we've done. This means that we've now completed. Well we completed Derived Builder last time. We've now done seek and sorted which I think means that if you've followed both of these videos, you're now in a good position to try out Bitfield and see if you can make it work. Of course you could also like warm up with custom debug. Great.
04:59:47.911 - 05:00:21.555, Speaker A: Which I think is a pretty good on time. I think this is a good place to leave it. The As I mentioned early on. No, that's not what I mean to do. As I mentioned early on, this will probably be the last proc macro stream for the time being and instead next stream is going to be whatever you all vote up. My plan for now is that it's going to be another open source contribution stream. So feel free to send me ideas of projects you would like to see me contribute to.
05:00:21.555 - 05:00:54.375, Speaker A: I not going to work on very large projects because it's very hard to make meaningful contributions to them in relatively small amounts of time like for these streams. So try to find smaller projects where you think it would be interesting for us to dig into them. Like the contributions we make can be smaller too. They can be things like reading the code and contributing documentation or contributing more test cases. All of these are totally fine. They don't have to be code contributions. I get the request about something about Noria a lot.
05:00:54.375 - 05:01:49.615, Speaker A: I think it's unlikely that I do a stream on Noria because it is just like not from a code perspective. It's not that interesting and I could spend spend a bunch of time talking about the research project and that might be interesting, but it's not really a live programming stream. There's also some pretty good. There's a talk up from two Sigma from last year where I talked about the system and I did a podcast interview with the Co Recursive podcast a little while ago, this one, so you can listen to that too. Where I go, we talk through basically a lot of how, how Noria works, what the inspiration was for it, how the implementation works. And so this covers a lot of that in detail. If you're curious, if you can, if you have ideas for things you would like me to cover, then please send them.
05:01:49.615 - 05:02:28.725, Speaker A: Like just ping me with them on Twitter, send me an email or leave a comment on this video and I'll check them out. Of course it could be that by the time we get around to it, people upvote some other idea over open source contributions, but I think currently it is like very high in the rankings and I think with that we're done for today. Thank you all for coming out and joining me live. And if you're watching the recording after, thank you for watching and I will see you in probably three weeks. Yeah, probably great. Thanks for watching and come back every and anytime.
