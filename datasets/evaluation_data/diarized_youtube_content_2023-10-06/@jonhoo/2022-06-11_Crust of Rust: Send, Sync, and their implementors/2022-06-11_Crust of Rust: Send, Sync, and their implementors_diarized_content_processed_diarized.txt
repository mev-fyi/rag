00:00:07.080 - 00:00:47.841, Speaker A: Hi folks, welcome back to Another Crust of Rust. It's been a while since last time, although if you're watching this recorded, I guess maybe it hasn't been. In which case, welcome immediately back. I've been trying to find what are good next topics for Crust of Rust, and over the past couple of months I've sort of been noodling with a couple of different ideas. And Send and Sync came up because. Not because send and sync are all that complicated in and of themselves, but more so because they tend to cause a bunch of confusion. Probably because people think they're more complicated than they really are.
00:00:47.841 - 00:01:39.989, Speaker A: And so I wanted to have a video going through at a high level, what are they, what are they for? But also dig into which types are send, which types are sync, and crucially, which types are not, because I think that's a good indicator of what they're really used for. I expect that this stream will probably be fairly short. There's not too much to talk about here. And so what I'll do is also some Q and A at the end. If you're watching this video on demand, what I'll do is I'll cut the Q and A sort of into a separate video. So I'll link that up here somewhere and without more ado, I think we'll just dive straight in. So Rust has these two traits, send and Sync, that are used to describe thread safety in the language.
00:01:39.989 - 00:02:47.455, Speaker A: And specifically they're used to represent thread safety at the type level. You know, there are all sorts of other languages where there are checks for whether you are doing something concurrently that you're not allowed to. The first one that comes to mind here, of course, is in Java collections, if you try to iterate over a collection while you're also modifying it, you get this concurrent modification exception. And you know, it's a good example of the language at runtime, catching if you're doing something that's probably wrong. However, in many cases it's really just documentation that tells you whether or not it's okay for a given value or a given type to be used either across thread boundaries or used by multiple threads at the same time. In Rust, those concepts are all baked into the type system, so that at least in most cases, you can check for the thread safety and the correctness in terms of thread safety of your program just by type checking it. The two traits are very related, but they do serve different purposes.
00:02:47.455 - 00:03:22.589, Speaker A: Like you couldn't really get away with just one or the other. And before I talk about how they Differ. I want to talk about how they are the same. So first of all, they are both marker traits. You'll see that send is in the STD marker module and same thing for sync. Now, markers, if we go over to the marker module, this talks about primitive traits and types representing basic properties of types. And what you'll see if you look through these is that all of these marker traits are specifically traits with no methods, hence the name marker.
00:03:22.589 - 00:03:59.841, Speaker A: They're only used to mark that type meets a given property or has a particular property or guarantee about it, but it does not confer any additional behavior. Like, for example, if something implements a send trait, you don't get a sort of send method on it. That's not a thing. It just tells you that that type is send. Marker traits are a little bit special as far as the compiler is concerned too. So if we dig into the source here, you'll see that it is marked as an auto trait. This is not directly combined with the fact that it's a marker trait.
00:03:59.841 - 00:05:00.451, Speaker A: Like you can have that not all marker traits are auto traits, but the fact that it's an auto trait means that the compiler will automatically implement this trait for you if all of the members of a type are themselves that same trait. So in the case of send, for example, if you define a new type, whether it's an enum or a struct or a typealias, that type will be sent. Typealias is a little different, but let's take structs and enums or tuples and arrays and whatnot. They implement send if all of the types that are inside of it also implement send. Same thing for sync. These are auto traits, and you can sort of imagine that it would be weird to have an auto trait that is not a marker trait, because an auto trait implicitly is implemented for anything where all the members implement the trait. But it's not clear what you would put in, like if there was a method you had to implement there, how you would delegate that to the inner types.
00:05:00.451 - 00:05:53.005, Speaker A: So in general, all auto traits are marker traits, but not all marker traits are auto traits. Yeah, the empty comment here is very helpful, thanks. So those are the ways in which they're the same. They're both marker traits, they're both auto traits, and apart from that, they sort of work the same way as all other traits. They're primarily used in trait bounds. So that would be you can have a function or a method or something, or even just a type that requires requires that an argument that is passed or a field that it has or something is generic over must be safe to cross thread boundaries. And so that gets us to, you know, how are they different? And we'll talk about send first, because it's easier to explain sink in terms of send than the other way around.
00:05:53.005 - 00:06:42.287, Speaker A: The property that send tells you about a type is that it's okay to pass that value to another thread. So specifically that is give away ownership of this thing to some other thread. So that thread from that point forward gets to do whatever it wants with that value. It sort of confers that it's not just that that thread gets to read or gets to write, that thread can do whatever it wants to. The value is the way to think about send. And most types are sending, just like in general. The idea being that if you have a primitive type, for example, if you have a boolean or a number or something, giving it away to another thread has no downsides.
00:06:42.287 - 00:07:41.365, Speaker A: There's no problem handing that value to another thread because it's just a number, it's just a boolean, it's just a string. The kind of things that are not send are more around types where if you pass them to another thread, then that thread might violate some implicit assumption or invariant of the underlying type. There are two primary examples of this rc. So the non atomic reference counted type, and we'll get into why that's a problem. And the other one that comes up a fair amount is mutex guards, and that applies both to the standard mutex but also to RW lock. This is not a universal property of like any mutex, but specifically the ones that are in the standard library that are backed by the OS implementation of these are usually. Sorry, yeah, so they are not send.
00:07:41.365 - 00:08:44.785, Speaker A: Because there's a requirement, at least on certain operating systems that the thread that gets a lock has to be the same thread that releases the lock. So if you, if you take a lock on thread A, you're not allowed to then have thread B try to release the lock that A got. It has to be A that releases that lock. And notice that this doesn't mean that the mutex type itself isn't send. It doesn't mean that RW lock is not send. It's specifically the guard that's not send. And this is an example of a more general property, which is if you have the drop implementation of a type refer to a thread local to thread local state that was created as part of the creation of the object, then that generally means the type can't be sent, right? Because imagine, you know, you create this object on thread A and it uses thread local state on A, and then you send it to thread B and then thread B tries to drop it, it goes out of scope or whatever.
00:08:44.785 - 00:09:27.035, Speaker A: Then when thread B drops it, if the drop tries to access that same thread local state, it's going to try to access B's thread local state, not A, even though A is what it used in order to create the object. And therefore you end up sort of violating some internal invariant. And that usually doesn't go very well. RC is a little bit of a different beast. The reason why RC isn't send is because I can write code that in fact let me cargo new lib. What are we going to call this one? Sharing is caring. So if I go in here, I'll get rid of some of this.
00:09:27.035 - 00:10:14.971, Speaker A: No, I mean actual thread locals, like, you know, the thread local macro from the standard library. So the problem with. The problem with rc. In fact, let's just make our own rc. This is roughly what RC looks like. There is a box of an inner of T and the inner has a count which is a usize and it has a value which is T. Actually this is a.
00:10:14.971 - 00:11:02.675, Speaker A: Oops, no, this is one of these. And you know, there's a. We did a separate video on reference count and smart pointer types and the like. So I'm not going to go through all the details of why it does exactly this, but I wanted to show specifically for RC what happens. So it returns a self and that's just going to be rc. Inner is going to be box into raw box. New inner count as one value is, I guess value is v.
00:11:02.675 - 00:11:44.665, Speaker A: So it's going to be new and then implone for rct. Notice here we don't require the T is clone. So I write this out because it's going to be a little bit easier to show where the problem arises. So this is going to be. We create a new RC where inner is self inner. But first we have to increment the reference count. So that's going to be so dereferencing self.inner
00:11:44.665 - 00:13:19.975, Speaker A: mutably count plus equals one. And we're going to implement drop for our CT and that's going to be do this. So when we drop it, if the current count is one, then we're going to drop the inner thing from raw self.inner and that's also unsafe. And finally, you know, we implement OPS deref for rct. I'm going to talk to this a little bit more in a second. So that's going to be just unsafe self inner dot value.
00:13:19.975 - 00:14:14.293, Speaker A: All right, so this is the construction of RC very roughly, and I've chosen not to use any of the other, like unsafe cell or anything. This is just to give you a very basic overview of what happens. So you have an rc, all of the arse, all the clones you have in an RC point to the same peep allocation, and in that heap allocation you keep both the actual value that you're protecting and a count of the number of RCS that there are. Every time you clone an RC, you increment that count by 1, and anytime you drop that RC, you decrement the count by 1. If the count ever drops to 0, that means there are no more RCS. Like you just drop the last RC and therefore you drop the inner heap allocation and the value with it. And the reasoning here for why this unsafe is, is okay is specifically because.
00:14:14.293 - 00:15:02.285, Speaker A: And again, this, you know, technically this can't be a star mute. This has to be an unsafe cell. There are a bunch of things that I'm sort of skimming over here, but the reason why this is generally safe is because RC is not send and not sync. And what that means is we know that even though we have an immutable reference, there are no other threads, there's no other concurrent execution that is accessing count and that is accessing inner at all. They might, like there. There might be other rcs that have a reference to inner, but none of them are currently accessing it because RC is not allowed to leave the thread. And therefore we know that nothing else can be concurrently touching self inner because we are currently executing on this thread.
00:15:02.285 - 00:15:32.945, Speaker A: So it's a sort of mutual exclusion by the fact that one thread can only be doing one thing at one time. So that's the reason why this access is safe. And it's also the reason why this can just be a standard USIZE operation. It doesn't need to be any kind of atomic, because we know that there are no other threads involved. Same thing for drop here. Same thing for why this is okay, right? We know that there's no race on this count because we know there's no concurrent execution. We are the only thread that's executing right now.
00:15:32.945 - 00:16:12.605, Speaker A: Oh, the reason this needs to be boxed from RAW is because self inner is just a RAW pointer, so dropping it does nothing. We have to turn it into an owned box again. So the box drop gets to run to deallocate the heap allocation and also run the destructor for the inner type. T. So that's sort of the basics of the argument. But crucially, as you see, this relies on the fact that RC is not sentenced. If RC was send, then what I could do is, you know, X is RC new of, you know, some value 1, and then I can do thread spawn.
00:16:12.605 - 00:17:32.709, Speaker A: I do let y equals rc new 2 and then I can do move and let Y standard thread unmatched. I think that's a lie. I don't think there's an unmatched here. Oh, it's because I need to move source lib to source main and if I run cargo check. Oh, oh. X clone is what I meant to do here. Why is it allowing me to do this? Wait, yeah, so as you see, the method signature on spawn requires that the function you pass in that it's argument descend, right? So it requires that you have to be able to pass the anything that the closure that you pass to spawn anything that that closure moves is is send is.
00:17:32.709 - 00:18:40.765, Speaker A: Is allowed to be sent to another thread. And this is sort of where send primarily comes in useful, right? Anytime you want to spawn a thread, you will almost certainly be going through this API. And this API requires send. That's the reason why send has an effect. Why this is allowing this particular operation though, is unclear, because starmute should not implement send. But let me try this just to. Why is it allowing this? No, so I shouldn't need to explicitly not implement send, because this type should already not be send.
00:18:40.765 - 00:20:07.709, Speaker A: Give me one second here, because this is real weird. Wait a second. Why is this allowing me to. This is a good way to just test whether a type constraint you expect actually works the way you want. So I'm going to take an X, which is going to be an RC of whatever, and it's going to call foo with X. Yeah. Okay, so our type isn't send, right? So what I'm doing here, right, is I create a foo, a function foo that requires its argument to be send.
00:20:07.709 - 00:20:49.935, Speaker A: I create a function bar that takes an rc this is RRC type and calls foo with that rc and the compiler says bar. Calling foo this way is not ok, because RC of unit does not implement send, right? And so the error gives us more explanation here. It says star mute inner cannot be sent between threads safely. And specifically this is because it appears within rc. So the traitsend is not implemented and it's required by this bound in foo. But this should also not be okay. It might be because.
00:20:49.935 - 00:21:37.001, Speaker A: Okay, I think it's just the compiler being particularly smart here and realizing that this thread doesn't actually use why I think that was like this meant that it didn't even need to move Y into this thread at all, and therefore it didn't require send. But that seems real weird, but. Okay, let's go back to this so I can remove our little foo bar business here. Okay, so this is. Let's pretend that didn't happen, although it was useful. This seems like arguably the compiler being too smart for its own good, but. Yeah, so what we're doing here is we're moving.
00:21:37.001 - 00:22:30.391, Speaker A: We're attempting at least to move Y into this new thread, and then we're just going to drop it. But we do need to move it into the thread, but we also have a clone of that same RC in X. And now, of course, these two threads both have a pointer to the same RC to the same inner. And when we imagine that these two threads run concurrently and they both try to drop Y, so they both try to drop what is effectively the same rc. So both threads enter drop for RC at the same time, they both read the count. Then you might end up with neither of them seeing the other one's decrement yet, because they're running concurrently, right? So they both here when they do, when they dereference the count, they might both see two, not one. So neither of them go into this, they both go in here, they both decrement the count by one each, so it's now zero.
00:22:30.391 - 00:23:00.875, Speaker A: But neither of them took this to actually drop, and that's less of a problem. It just means you have a memory leak. But it can happen the other way too, right, where you could have multiple threads seeing one because they race on the axis of this count field. And then they both end up dropping. They both end up calling box from raw, they both end up invoking the drop type of the inner T. And that's just straight up unsound. That's undefined behavior.
00:23:00.875 - 00:23:51.125, Speaker A: And so this is why send is valuable, right? It tells the compiler that this type, you cannot share across thread boundaries because bad things will happen and then the compiler will. And in fact, it's not even, you know, the compiler doesn't know anything special about threads. It just knows that this thread spawn function requires that the type it's passed implement send. And so it checks, does everything that goes into this closure implement send. RC does not, therefore this is not okay, right? The type of Y here is also rc. All right? So in other words, this is why RC can't be sent. Very different reason for why Mutex Guard can't be sent, but this is the reason that can't be sent.
00:23:51.125 - 00:24:35.587, Speaker A: So let's then move on to sink. So sync is fairly related to send. In fact, they're so related that sync is almost defined in terms of send. So specifically a type T is sync if and only if a reference to T is send. So let's try to digest that a little bit. If you have a type where a reference to that type is allowed to be shared across threads, then that type is sync, even if the type itself cannot be passed to some other thread. Like, I can't give you a mutex guard, but if I have a mutex guard, I can give you a reference to that mutex guard.
00:24:35.587 - 00:25:33.731, Speaker A: That's fine, right? Because, and this sort of the reason this distinction is important, this comes back to the reason why mutex guard can't be send, right? Is that we can't allow some other thread to drop it. But if we just give away a shared reference to one that we already have, they're not going to drop it for us, right? They don't get any kind of owned access to that Mutex guard. They can't drop it because it's behind a shared reference and dropping required a mutable reference. They can't do like tricks with MEM replace or anything because all of those require immutable reference to the inner type. All they can do is read from it, which is all fine. None of that means that they drop, which is the thing that we were concerned about. However, RC can't be sync, right? So it's the same kind of problem.
00:25:33.731 - 00:26:18.707, Speaker A: If RC was sink, then what I could do is I could take a reference to an rc, give that reference to another thread, and then that other thread just calls clone on it. And we know that the clone implementation also requires that all access happens on one thread. So that is why RC is not send and not sync, whereas a mutex guard is not send, but it is sync. No, when I say shared reference, I mean an actual reference. Like, I mean the, you know, this type, an actual shared reference. When I say mutable reference, I mean it this. So mutex guard is not send, but it is sync.
00:26:18.707 - 00:27:16.455, Speaker A: RC is not send and not sync. Which might make you wonder, okay, are there types that are sync that are send but not sync? And there are the primary examples of this are the interior mutability types. So things like cell and ref cell, and cell is a really interesting example. So the basic idea of cell is that it doesn't give out references to the inner type. So you can have A cell of T. And the things that you can do with a cell of T are you can create a new one by giving an old value, you can replace its value, you can extract its value, but again by value only, by consuming self. And there's nothing in here that allows you to get a reference to the value that's inside of the cell.
00:27:16.455 - 00:28:25.255, Speaker A: And the reason why this is okay, is because on any single thread, right? Imagine you're on a single thread here. If the value is encapsulated inside of there and you never give it a reference to it, then at any given point in time, you know that you have exclusive access to the inner value. No one else has a reference to it, because this doesn't give out references, and no other thread is currently executing on that value. So it's okay to. Again, this ties back to the fact that this type is not sync, right? So no other thread has a shared reference to this type, and you haven't given out any shared references to the value that's inside of this. So therefore you are the only one with access to the thing inside the cell whenever you are executing, and therefore you're allowed to modify the value that's inside there. Because you, you effectively have exclusive access, no other threads accessing, and the current thread is you.
00:28:25.255 - 00:29:24.845, Speaker A: And so that's why you can safely mutate the inside of a cell, even though you only have a shared reference. But again, it relies on the fact that cell is not synced. But it is send though, right? Because again, you haven't given out any references. So if you give away a cell to another thread, there's nothing left on this thread that might interfere with that thread modifying the value, right? If I have a cell and I give it away to you, I cannot possibly have any references to the cell, because then I wouldn't be allowed to move it or to the stuff inside the cell, because there are no accessors that give out a shared reference in the first place. And so sending it totally fine. The moment I send it, that other thread is free to do things like modify the inner value because it can rely on the same invariant, right, that no one else has a shared reference to the cell, as in no other thread. And on this thread, any shared reference to the cell is not currently executing because there's only one thread involved.
00:29:24.845 - 00:30:12.575, Speaker A: Before I continue, let's. Let's do some questions, because I think there are a bunch of questions that are sort of related on this. Shouldn't sell, not demand, not sync on T, then. Yeah, so this is another Good question. Which is what are the actual requirements on the inner type T here? So for cell, if we go down a little bit, you'll see that it implements SEND for Cell T only when T is send. So, so this, this requirement on the inner type makes sense, right? Because imagine that I have a cell T. If I give it away to another thread, then I'm effectively giving away the T as well, right? Because you can call into inner on a cell and get the inner T.
00:30:12.575 - 00:30:55.625, Speaker A: So by sending the cell, I'm also sending the T. And therefore it's only safe to send the cell if the T is also send. And you see, the implementation of not sync is just a blanket implementation, like there are no requirements on T. It's just saying cell is just never sync, no matter what the inner type is. And so there's a question, okay, should cell require that the inner type is sync, even though you're not sending it to a different thread? And you don't need that requirement because if I give away a cell to another thread, there are no references involved. I'm giving away the actual inner value. So all I require is that that inner value is sending.
00:30:55.625 - 00:32:02.755, Speaker A: Is it good to use cell directly, though I mostly see code wrapping it inside some box or rc. Cell on its own is not super useful, because why would you have the cell if you could just, you know, have an own T and just take references to it? The reason was cell comes in useful is imagine you're doing something like graph traversal, where you might have cycles and stuff. You might be walking this tree in a single thread, but that means that because you're walking the tree, you can only have shared references to everything, because if you're exploring the tree, who knows what? Like, let's say you're walking a chain, right? And that chain might loop you back on yourself. You can't take exclusive access or claim exclusive access to any given node because you might walk the same node more than once. So you're only going to have shared access to all the nodes in the tree at that point in time. But because you're single threaded, you know that even though you only have shared access, it's okay for you to mutate that thing in place. And so that's where you might want to be able to modify the value through a shared reference.
00:32:02.755 - 00:32:45.395, Speaker A: The reason you sometimes see it through RC is sort of the same reason, because you might have some data structure where you might want to store a given value in multiple places, but you do want to be able to mutate it if you ever walk to it. And so you have an RC cell. Sort of the same thing. Yeah. And then the other thing to mention about cell while we're on cell is that if the inner type is copy, then you can get the inner T even with just a reference to self. The idea being, of course, you can just copy the value out. Okay, so let's look a little bit more at some of the details here.
00:32:45.395 - 00:33:34.295, Speaker A: So if we scroll down the sort of implementation of send list, you'll see there are a couple of these negative implementations. So negative implementations are an unstable feature. I can't actually see what the unstable feature is called, but there's an unstable feature, I think it's called negative impulse, which allows you to write, as you saw just here, impl. Not send for some type. Normally you can't write that in Rust. Negative implementations are an unstable feature. You can, however, always write impulsend for a type to tell the compiler that, ok, this type, even though you think it's not send or you think it's not sync because of the auto traits, I'm telling you that this type actually is.
00:33:34.295 - 00:34:30.565, Speaker A: Doing so is unsafe, right? Because if the compiler knows that there's some inner type in what you constructed that's not send or not sync, it assumes that that means that your type is also not send and not sync. But you can sort of tell it that. No, I've really checked. But in order to do that, that is unsafe because you are claiming something that the compiler can't guarantee is true. So doing a positive implementation of send is unsafe, Doing a negative implementation is unstable, but it's not safe, it's not unsafe. So you might wonder, okay, why would I ever need this? Like, why aren't, you know, why would I ever want to not implement send for a type? It's fairly rare that you actually need to do this. Like, usually it's the case that, you know, the auto impulse are going to be overly negative rather than overly positive.
00:34:30.565 - 00:35:36.725, Speaker A: So in general, your types are not going to implement send and sync when you want them to, rather than they're going to implement sentencing and you don't want them to. That is very rare. It comes up usually if you're writing code where the internals of it hold only types that are sent async. Like they only hold, you know, boxes or integers or something, but you're doing something with them, like accessing a thread local, where the act of accessing that thread local makes it not thread safe. But there's nothing about the inner types that makes it not safe. So mutexguard might be an example of this, where you could at least imagine that what it contains is something that's totally send, but because of this thread local access, that makes it not send, and it's not something the compiler could infer for you. Another thing that's worth bringing up here, if we go through this list, is you'll see that there's an implementation of this is the one not primitive, but the basic implementation of sink, right? Which is we implement send for a reference to T where T is sink.
00:35:36.725 - 00:36:40.855, Speaker A: So that's almost the definition of sinc. You'll also see there's an implementation of send for a mutable reference to T where T is sent. And this might strike you as a little odd. Like, you know, if we're giving away a shared reference to T, why does that require that that T is also send? Because I'm not giving away the actual T, I'm just giving away a reference to it, even though it is immut reference. And the reason for this, of course, is methods like mem replace, right? So the mem replace function takes a mutable reference to a T and a T and gives you back the T that was stored behind this destination, and it sort of swaps it out in place with this T instead. But the problem here, of course, is that means that you can take ownership of something you were only passed immutable reference to. So if I send you a mutable reference to a T, if that T is not send, you could use this to take out the T and then you drop it.
00:36:40.855 - 00:37:32.379, Speaker A: So again, imagine a mutex guard. If I give you a mutable reference to a mutex guard, you could take your own lock, swap the two mutex guards, and then drop my mutex guard, which would not be okay. And so that's why there's this send bound on the T for mutable references. If we keep scrolling through a lot of these implementations that you see, you might be surprised. Like why does there need to be an explicit send implementation? Like auto trait implementations are not listed in this list. So why does there need to be an explicit implementation of send for itermute for vecdqueue, for example? And if we go in there, we might be able to see why. So you see there are these manual implementations of the types, and you see the safety comment says we do nothing thread local.
00:37:32.379 - 00:38:19.397, Speaker A: There's no interior mutability, so the usual structural sensing applies. So then you might go, well, why didn't the auto traits do this? And the reason for that we can find by scrolling down a little bit longer. Well, you see that there's an implementation of not send for const t and not send for mut. You'll see the same for sync. So if we scroll down far enough, you'll see that there's a negative implementation of sync for all the raw pointer types. Now, the reason that exists is not because it has to be there, right? If you have a raw pointer, you know there's nothing that stops you from sending the pointer or having sync on the pointer because ultimately it's unsafe to dereference anyway. So why have these implementations? They're not fundamentally not sender, not sync.
00:38:19.397 - 00:39:35.503, Speaker A: The reason why these negative implementations are there is entirely to make it so that if someone who writes a type isn't entirely clear on what the rules for send and sync are, we sort of fail in the safe way, which is their types are going to be not send and not sync if they have raw pointers in there, because chances are they haven't thought about thread safe. And then we would rather the types not be send in sync than for them to accidentally be send in sync when that wasn't okay. So this is sort of a. You can think of it as a sort of countermeasure to the auto traits, which is to say if your type contains raw pointers, chances are you have to think carefully about thread safety. And so therefore we're going to require that you put in a manual implementation of send and sync for those types. And so we were sort of going to break the auto trait inference intentionally. If you ever stick a raw pointer in there, does that make sense for why that's useful? And indeed that is what we see for Iterator, right? So iter mute here in vecdq, you see, contains a just a raw pointer.
00:39:35.503 - 00:40:26.495, Speaker A: And therefore this type does not implement send or sync automatically by auto traits. And so it requires this manual implementation. And the manual implementation is okay because as the comment here says, they're not doing anything that makes it not send in sync, but they need the explicit implementation to get over the fact that the auto traits did not apply here. And if we keep scrolling through here, the send list is fairly short. You see, there's nothing that's super surprising here. There are explicit implementations for anything that contain inner pointers. There are negative implementations for raw pointers, including things like non null, which is also effectively a raw pointer as a negative implementation for RC and for RC weak, which is effectively also just rc.
00:40:26.495 - 00:41:12.301, Speaker A: You see, cell and refcell both do implement send like we talked about, they do not implement sync because that would not be. Well, what is interesting is atomic pointer, which is also really just a raw pointer type, does implement send. And the idea here being if you know to be using atomic pointer, chances are you have thought about send and sync. I don't know whether this one was a good idea. I think even if you're using an atomic pointer, I think you should also still be required to do the manual implementation. But, you know, such is life. What else do we have? Anything that's interesting.
00:41:12.301 - 00:41:57.031, Speaker A: Yeah, so here we see the not send for the guards that we talked about. More not send for rcs. Oh, interesting. So the procedural macro types seem like they don't implement send, so that probably means that they are. That probably means that there's some thread local state when invoking procedural macros. I wish I could go to the source for those, but I think those are compiler implemented, so there isn't a source we can go to for sync. The list is pretty much the same.
00:41:57.031 - 00:42:23.611, Speaker A: There are a bunch of manual implementation, there are some. There's some negative implementation. Interesting. So receiver and sender are not sync. They are send, but they're not sync. Let's see if we can figure out why. Yeah, so this is another good example, actually.
00:42:23.611 - 00:43:22.615, Speaker A: If you look at channel senders, you'll see that. So imagine that you have one of these multithreaded channels, right? So you have a send end and a receive end. You'll notice that the send method does not require the T ascend. You know that there's nothing here that requires the T ascend. And the reason is if you have, if you create a sender receiver pair of a channel, but you never move them to other threads, then there's no requirement that the types that you send over there are themselves send, because they never cross the thread boundary. So instead, and you'll see this is a fairly common pattern in the sender library, you'll see that there's only a requirement that T is send if the sender is sent. So you can only move the sender and similarly the receiver across thread boundaries if the T ascend.
00:43:22.615 - 00:44:11.477, Speaker A: And so you can create a channel of non send things and use it within a thread just fine. And it's only the moment you try to move either end of the channel across the thread boundary that requires that the inner T ascend. Which is interesting. The reason I say you might say see this elsewhere is if we look at something like arc, go to ARC here. So for arc, you'll see that ARC also does not require the T is send or the T is sync. Sync is the more relevant one for arc. Right? Because in general you can't get a mutable reference from an ARC T, but it is possible, right? So it has things like getmute, where is getmut, right? So you have this.
00:44:11.477 - 00:44:44.323, Speaker A: If you have a mutable reference to an arc, you might be able to get a mutable reference to the inner table. If the. If the number of clones of the ARC is one, like you have the last remaining reference, then you can get an own T. But you'll see that none of these require the T ascend or sync. And it's only down here where if we find the send implementation. So ARC is only send if T is sync and send. So again you can create an ARC of some non sendable type just fine.
00:44:44.323 - 00:45:21.751, Speaker A: You can create clones of it, that's fine. It's only the moment you try to move any ARC across the thread boundary or a reference to an ARC across the thread boundary. Only then do we actually require that the inner type is thread safe. And notice that for ARC to be send and sync, the inner type has to be both sync and send. It has to be sync because all these other threads that have arcs effectively have references to that type. So that type better be safe to reference for multiple threads. But it also needs to be send, because whichever thread drops the last RC is going to drop the inner type and you don't control which thread that is.
00:45:21.751 - 00:46:03.405, Speaker A: So therefore the T must be send, because whichever thread drops it is going to take ownership of it. And that might be a different thread than the one that created the T. So it has to be sending. If it is a reference, then it needs to be static or do you have to move it by move? I don't know what that question is. Moving or sending a ref requires sync, which means it can be accessed by different threads. Yeah, exactly. So this is what we talked about earlier, where we only implement send for references if the inner type is sync.
00:46:03.405 - 00:46:58.455, Speaker A: Can we explicitly implement SEND for guards in certain oss? You know, it's a good question. I think realistically you don't really want to do that, because suddenly, now, which. Whether a type is thread safe in certain ways depends on what operating system you are on, which is going to be really weird to debug. Like, I understand the attraction, but I think it's easier to just sort of have the same thing apply for all of them. The other thing that's nice about requiring Mutex guards to be to not be send is that it probably allows you to do slightly more optimizations on it. Right. So even though there are some operating systems where maybe it's okay to drop it on a different thread, you might be able to do optimizations based on the fact that you know it's not going to be sent.
00:46:58.455 - 00:47:56.995, Speaker A: Yeah, I wonder why there's a not sync implementation for sender. I don't have a good answer for that. I think it's because sender so NPSC is a sing. You know, that's a good question. I think it's because the way a sender works internally in the standard library is each sender has a sort of slot in the channel. And so when you clone a sender you basically sort of add a slot and if you had multiple threads that were allowed to send through the same sender, then they would be contending for that slot. And that slot is not intended to be thread safe.
00:47:56.995 - 00:48:48.531, Speaker A: That's my guess for why it's not sync, because notice here, sending on a channel just takes a reference to self, not immutable reference. And so this is the way to say you can have a thread, can have lots of shared references to its one sender and send through any of them without requiring any kind of coordination. But you do have to have a separate sender for each thread. I feel like this is probably the implementation bleeding into the API a little bit. This is not a fundamental requirement of any multiproducer single consumer queue. This seems more like this particular implementation required it and therefore the implementation is there is the send trait by default implemented on users own structs. So this gets back to the fact that it's an auto trait.
00:48:48.531 - 00:49:50.405, Speaker A: So whether or not it is implemented depends entirely on what types it contains. So if all the inner types of your type are themselves send, then your type will be send. If your type contains an RC or a mutex guard or a reference to a T where the T isn't sync or any kind of raw pointer, then your type will not be sent. Okay, the last place I want to go to. Let me see if there are any other sort of sync things we should talk about here. Yes, you can like scroll through all the auto implementers too if you're curious to see these. But in general the auto implementations are much less interesting because they are only implemented.
00:49:50.405 - 00:50:39.625, Speaker A: They're implemented without the programmer of that type having sat down and really thought about the send and syncness, whereas the manual implementations are, because the auto stuff did not do the right thing and so they're usually more instructive to look at. And my guess is if you go look at the source for these, they're generally going to explain why this type is an exception. So as we talked about Mutex Guard, for example, totally fine to have multiple shared references that you send to other threads to that Mutex Guard, as long as you still retain ownership of the Mutex card and you're responsible for dropping it. And I wonder whether the implementation says that. I wish there were more comments for things like these Impulse. They really should have. If you want an idea for going to send a PR to the standard library, go do that.
00:50:39.625 - 00:51:30.045, Speaker A: The other thing you might have noticed is that for both the both send and sync in the standard library, they both refer to the nomicon. For more details, the nomicon entry on send and sync is pretty good. It talks about many of the things that we've talked about today, some of them in more detail, some of them in less. Feel free to go read it. It is a little bit of an interesting read. It gives a slightly different perspective on this and you'll see that it talks about the major exceptions, same thing as we have, you know, on raw pointers and rc. Unsafe Cell is the sort of deeper reason why Cell and refcell are not sync, right? Is because unsafecell is the only type in Rust that allows you the only basic type in Rust that allows you to mutably access something through a shared reference.
00:51:30.045 - 00:52:33.945, Speaker A: And that's what Cell and refcell both use internally in order to access their interstate because fundamentally they are mutating something given only a shared reference. So they must go through Unsafe cell and unsafe Cell itself is not sync because it if you are using this type again, they want to force you to think carefully about whether your type should be sync, given that you're using this unsafe construct internally. And that's why cel and refcel will, through their auto traits, not implement sync. And then it goes through, you know, the. Yeah, okay. So the feature is called Negative Impulse, and as it points out, you know, it should be incredibly rare that you actually have to add such a negative implementation to yourself. They go through a sort of example of a type that you might want to implement, send for, implement sync for, because it happens to be okay.
00:52:33.945 - 00:53:20.203, Speaker A: And the requirements where you use these inner bounds, we've talked a bunch about that too. And yeah, it talks about Mutex Guards. So I think in general it touches on everything we have. But it does have a more thorough example where they sort of walk through the code that it might be Useful. And that's sort of all there is to send and sync, right? There's no compiler magic around send and sync beyond the fact that there are autotraits. Like the compiler doesn't know about thread safety. All the compiler knows is that some types, some like primitive types implement send, some primitive types implement sync.
00:53:20.203 - 00:54:27.035, Speaker A: If all of the inner types of a type implement send, then that type implements send, same for sync. And so that's sort of the autotrade business. And then it knows that there are some functions that have a bound that requires that a type is send or that a type is sync, and it just type checks those the same way it would any other trait. So send and sync are not baked into the compiler at all. The only thing they rely on is auto traits. And one thing you should know about send and sync is that they are, because they're marker traits and they're a little bit special, you're allowed to include them in in dynamic trait dispatch as additional traits. So normally, you know, if I say if I do appear, I suppose fnfoo and I take a boxdin iterator item equal whatever.
00:54:27.035 - 00:55:18.975, Speaker A: So normally if you use the sort of DIN syntax, you're only allowed to name one trait. You're not allowed to say, you know, din iterator plus clone, for example. This is something that we might get one day. But as you say, it says only auto traits can be used as additional traits than a trait object. The way you would normally work around this, you would say like iterator plus and clone and you say that it extends iterator with item equals this and clone. And then you would say this takes a iterator and clone. Right? Clone is a bad example because it can't be a trait object anyway.
00:55:18.975 - 00:55:58.135, Speaker A: Let's go with debug. So this is the way that you normally get trait dispatch to multiple traits. But as that error message was indicating, the exception to this is auto traits like sendence sink. So you are allowed to write this. So I can say this type is iterator and it is also both send and sync, or I could do only one or the other. And this is a special property of these audio tricks. You can't do it with anything else.
00:55:58.135 - 00:57:24.827, Speaker A: You'll see this a lot in futures code, like anything that uses async, await and stuff where you might see DIN future output equals something plus send sync, indicating that this particular type, this particular future, is safe to send to another thread to continue execution there. Normally for futures, you only really care about the type being send because to poll a future, you need a mutable reference to it. So it doesn't really matter that it's sync, or it shouldn't really matter that it's sync, but it does matter that it's send, because very often you have multithreaded executors. And so imagine that a future is running on this thread and then it gets paused because the network socket isn't ready or something. So that thread of the executor picks up some other future and runs that instead, and then this original future becomes ready again, and then some other executor thread is idle, it might pick up that future, but that means that future now moved to a different thread. And so we need to make sure that the future is send so that that operation is valid. And so very often you'll see that multithreaded executors, like the Tokyo executor, for example, will require that the futures you pass it are sending, unless you use a sort of specific construct that allows you to run non send futures.
00:57:24.827 - 00:58:43.421, Speaker A: I think in Tokyo, it's called local set is a way that you can sort of spawn futures that aren't allowed to leave the current executor thread. Are there other basic methods other than thread spawn that require ascendancy? So the examples that come up here are, you know, arc and channels, but ultimately both of those. Only it only matters whether those are send and sync, because thread spawn requires it, right? Same thing for Tokyo, really. If you think about it, the reason it requires send and sync is because deep down there somewhere they spawn new threads and those threads, their arguments need to be sent. And those arguments are in some sense receivers for channels where they have to receive tasks on, and those receivers therefore have to be send, which means that the type inside those receivers have to be send, and that's why the futures have to be send. So like, it's not quite turtles all the way down, right? Like sort of at the bottom is whatever you try, just run on a different thread. That thing has to be send, which means that any inputs it takes and any handles it has to anything else has to be send.
00:58:43.421 - 00:59:50.915, Speaker A: And that's sort of where it all funnels down to. So the question is, you know, are there other routes to this graph than thread spawn? And not really. I mean, you could imagine that you, you know, if you directly implemented thread spawning yourself, you know, through like LIBC calls or the extreme version of this is something like fork. But if you were to implement this sort of primitive yourself, you would need to write the Sentence sink bound. But realistically, for most rust code, this comes down to the fact that somewhere in the call graph, deep down there's a thread spawn. And it doesn't have to be that you call thread spawn transitively. It might be you have a sender, but the receiving end of that was sent to a thread spawn, right? And therefore, in order for you to get that sender, the when the pair was created, you know that receiver went to that thread, but the sender went to you, which means that the sender had to be send.
00:59:50.915 - 01:00:48.583, Speaker A: Thread spawn only requires that the type is static and send it does not require sync statistic, because it shouldn't. Right? It doesn't take references to anything. The reason it needs to be static is because that thread. There's nothing that guarantees that this thread won't outlive the current thread. So, you know, if I allocate some value on my stack and then I spawn a thread and it has a reference to my stack, then that thread might keep running after I return, and then that reference would no longer be valid. There is some work in the standard library now to add back thread scoped, which allows scoped threads. So this allows you to have threads that don't take static arguments.
01:00:48.583 - 01:01:39.367, Speaker A: And the way that these work are basically by ensuring that the current thread or the current stack frame can't return until the thread has been joined. So you know that the thread won't outlive the current stack frame, and therefore it doesn't require static. It's a pretty neat addition. It used to be in the standard library way back in the day and then was found to be on sound, so it was removed, but now it's back and it's also existed in the crossbeam crate for a while. Could a type be sync but not send? Yeah, so Mutex Guard is an example of that. It is sync, but it is not send. All right, I think that's where I want to end it.
01:01:39.367 - 01:02:02.421, Speaker A: Unless there are questions, you know, specifically about send and sync before I. Before we move over to like a Q and A section. I told you this would be short. What I really want to convey here is like send and sick are not magic. They are the antithesis. Antithesis to magic. The only magical thing about them is the autotrade part.
01:02:02.421 - 01:02:53.615, Speaker A: And the autotrate part arguably doesn't matter, right? If send wasn't an autotrait, then everyone would have to implement it all over the place and be really annoying, but they would still work for their practical purpose of making sure that your program is threads safe. But there's no, you know, the compiler doesn't have knowledge of threads. It all just is. This is a trait that is generally not implemented for types that aren't thread safe. And that property sort of propagates through the system through the autotrade business. And negative implementations for sort of key things in the standard library and then they're used in thread bounce and that's the only way that they, you know, work. How do I implement not sync plus send? I mean, you just write those impulse.
01:02:53.615 - 01:03:38.299, Speaker A: I will say that you know, the negative impulse feature, because it's not. Because you can't use it on the. Let's see, let's say that I had a, you know, Mutex guard T and I can't use that. This is a stupid Mutex card. But let's say that I had this. So this will automatically implement both send and sync, assuming that T is respectively send and sync. But imagine that I didn't want it to implement send.
01:03:38.299 - 01:04:34.721, Speaker A: You know, I can't, I can't do this. Currently the standard library on the stable compiler, I won't be able to do this. Mutex guard negative trait bounds are not yet fully implemented. So you might wonder, well, how do I do this if I want to work on stable? And usually the trick you pull is something like what you saw me do earlier, which is you can stick, you know, phantom data in here of an RC of nothing marker. And phantom data means that you're not actually storing an rc. The phantom data is just like a pretend this type was here, but don't actually put one here. Don't take up any space.
01:04:34.721 - 01:05:20.065, Speaker A: And phantom data propagates through basically everything. So particularly it propagates through auto traits. So RC is not send and not sync, and therefore this type will be not send and not sync. That way you only write the positive impulse rather than writing the negative impulse. And those you can write in standard library. So here I could write unsafe impulse sync for Mutex guard T and that way mutexguard would be sync but not send. By virtue of this sort of one way to work around the lack of negative impulse on stable Auto traits are compiler magic.
01:05:20.065 - 01:05:59.797, Speaker A: Auto traits are the compiler, when it constructs a type, looks at all the contained types and if all of them meet the trait that's marked as auto, then the outer type also implements that trait. So those. Those are magic. Implementing sync and safe. Implementing sync and send are both unsafe properties, right? Because the compiler. You would only write these if the compiler's auto trade inference says that these types are not sent and sync. And then the compiler is going, these shouldn't be implemented for this type.
01:05:59.797 - 01:06:21.475, Speaker A: And you're claiming they should be anyway, that's unsafe. You're claiming these types that I don't think are thread safe are thread safe. Prove it to me. And that's generally the meaning of unsafe. The meaning of unsafe is the compiler saying, you prove it if you're so smart. That's really what the compiler does. So manually implementing these is unsafe.
01:06:21.475 - 01:07:03.145, Speaker A: Auto inference is not unsafe. Right. So if I remove these now, Mutex guard will be send and sync and I didn't have to do anything unsafe. All right, here's what I'm going to do. Let's stop the sensing stuff here and then I'll take just a quick couple of minutes break and then we'll do just general Q and A, not related to sentencing at all. So give me like 5ish minutes and then we'll be back and do more. All right, see you all in a very short while.
