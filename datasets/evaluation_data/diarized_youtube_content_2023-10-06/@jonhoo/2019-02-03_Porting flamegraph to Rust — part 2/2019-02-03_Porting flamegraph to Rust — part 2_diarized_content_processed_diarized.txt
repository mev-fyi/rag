00:00:01.360 - 00:00:33.874, Speaker A: So, hi, everyone. Welcome back. I decided to do another stream relatively quickly after the previous one because the first one where we started porting flame graph to rust, got a lot of attention. There were a lot of people excited about the project, and so I figured we might as well continue because we only sort of got halfway. So if you remember, flamegraph is this tool where. There might be a good example here, too. But the idea is that you run a performance profile of your, of some program, and then you can render this kind of visual representation of where your program is spending its time and how it got there.
00:00:33.874 - 00:01:15.910, Speaker A: So the way to read one of these is that here, for example, the bash was the function we were profiling, or the program we were profiling bash called main main, called main main, called reader loop, reader loop called execute command. And here, like execute command, you can see, took up 78% of the, basically the time that we measured for. And there are two components to this. So the first one is stack collapse perf, which we ported last time. So stack collapse perf is a program that will take the output of a tool called perf, which is used to basically collect performance profiles. So you would run. Ooh, that's not what I meant to do.
00:01:15.910 - 00:01:45.226, Speaker A: You would, let's make this a little larger. Dev streams inferno. What even is this diff? Let's dash that. So the idea is that you run a program with perf. Perf record whatever program you want to run. Let's get rid of some arguments here to make it clearer. So you do perf record.
00:01:45.226 - 00:02:33.098, Speaker A: Dash G just includes call graph information. So in addition to knowing which function was run at the time, when you sample, you also get to know which function called it callgraph dwarf includes more additional information. And then this is the program you want to run with any arguments. And the output of this is a binary file called perf data, which is a file that is pretty hard to parse. The format is not well documented, but you can run perf script, which produces a, it produces output that's meant to be relatively easily parsable. And then you pass that through stack lapse perf. And what stack lapse perf will do is basically generate the raw data that's needed to produce these flame graphs.
00:02:33.098 - 00:03:21.830, Speaker A: It basically generates call stacks and how many samples there are for each possible stack. And so that's what we did last time, is we ported over stack collapse perf. But of course, the next thing you do is you pipe it through flame graph, and that gives you one of these actual images like an SVG, and so the plan for today is to implement flame graph because we already have stack elapse perf. So last time we started this tool called inferno, and Inferno is the goal, at least for the time being, is just to port stacklabs perfume flame graph, so that we have sort of a self contained program that can do those things. Since last time we've actually had a bunch of people contribute to the project, which is pretty cool. So for example, we now have regression tests. So we have all the tests from the flame graph stacklabs tool.
00:03:21.830 - 00:04:04.490, Speaker A: We have a comparison script that will run benchmarks against both stacklabs perf and this program and compare them using hyperfine. We have the various Java tidying now implemented, and we also have some other fixes tests. And there's one big pr that's still outstanding that is basically on adding uninlined support. So this is using adder two lines. So it's instead of looking at the, the report from perf, just looking at the stack trace that perf gives you. Instead what we're going to do is use the debug symbols in the binary to resolve the addresses backwards, which gives you more accurate stack results. But this one still has a little bit of way to go.
00:04:04.490 - 00:04:55.074, Speaker A: But there's been a bunch of cool work from this person, Jason R. Hanson, who basically it's been putting it a lot of work to get this PR landed, and that's going to be really cool when it lands. But today the goal is to generate these. So what we're going to do is we're going to look at frame flame graph Pl, and this is the file we're going to port this time. One thing you'll notice is that because this generates basically a website like it generates an SVG with some inline scripts and such, a lot of this code is sort of not rust related. So what we will probably end up doing is at least for all the JavaScript code, we'll just copy that over the way it is, because that's not really code that we care about porting. The thing we care more about is generating the actual SVG, and that might be pretty tricky.
00:04:55.074 - 00:05:31.970, Speaker A: It might be that we end up discarding some options like color schemes and such, at least in the first iteration, just so we make sure we get something working. For those of you who didn't watch part one, you can find part one on YouTube. So if you go back and watch there's a bunch of older videos there, but that would be the one to start with. If you're interested in what we're currently doing okay. So I guess it's about time to get started. I think we still have, we still have a bunch of scripts left over from the previous stream that we can use to do this plotting. But what we're going to start with is in cargo toml.
00:05:31.970 - 00:06:47.886, Speaker A: There's going to be another bin and that's going to be in inferno, flame graph and flame graph. Now another thing you'll notice is I've done a little bit of reorganization in that inferno is now a library, and inside that library there's a collapse module that has a perf module because we might implement collapse for other source languages. And so most of the code that was in the binary that we wrote last time is now in source collapse perfect. And then bin collapse perf pretty much just does parsing command line options and then calls into the library. The other reason for doing this is it means that other, if someone else writes something that wants to parse perf script output or so, this means that other people might be able to use the stack collapse perf stuff we've written, or the flame graph stuff we're about to write. There's for example, this thing called nPerf, which is a re implementation of perf and it's also written in rust. And they really want the ability to have you type like n per flame graph, which would be pretty neat.
00:06:47.886 - 00:07:28.120, Speaker A: And they can do that if we provide basically flamegraph as a library. So in our case, what we're going to do is copy over source bin collapse perf to source bin flame graphite. Oops, that's not what I meant, like so. And then we'll also start a new file. So in source lib we're going to add a mod flame graph. We might end up with sub modules there actually. So let's do a makedor source flame graph and then we're going to have a modrs.
00:07:28.120 - 00:08:08.000, Speaker A: This is also so in the 2018 edition we don't actually have to have the extra folder. We don't have to have a mod rs within the extra folder. We can just have flame graph rs and also a flame graph folder. I still kind of like the mod setup, so I think we'll keep it like that for now. Okay, so this is where most of the stuff is going to be, and in the bin flame graph that is going to use not this, but instead use flame graph. Let's just name things the same way for now and then we can clean up that later. So collapse perf, the options are probably not going to be anywhere near the same.
00:08:08.000 - 00:08:45.330, Speaker A: Let's look at what options there are here. It's a lot of options. I think we're probably going to ignore all of these for now. Yep. We're gonna not take any to begin with. What that means is we're still gonna have the same, like we, the structure is gonna be the same, but there are going to be no options to begin with. We're gonna add them later and then we sort of want this pattern to still be there.
00:08:45.330 - 00:09:54.520, Speaker A: Yep. We also kind of don't want this to be called handle file, but, and I think we'll still use this. It might be, we still want to use this sort of basically state machine to produce the SVG, but I'm not sure about that yet. So there's certainly going to be a handle file and the bin flame graph is going to be called, I guess we're still using structopt. It's going to be this. We're going to cut out all the help text for now and they're going to be, no, only in file collapse perf output file and that's not going to be needed. Oh, what is from Arg's? Do we need a from Arg's? No, I don't think so.
00:09:54.520 - 00:10:25.782, Speaker A: Actually, it's a good question. What was from args? This is just sort of setting up the initial from ARg's really. Oh, bin collapse. Just setting up the initial structure. Oh, great. Okay, so flame graph bin just going to do that. And it's fine for it to include the options.
00:10:25.782 - 00:10:46.480, Speaker A: I guess we can include this here. It's just going to return an empty options because there are no options so far. And it's going to do the same thing as we did for the other one. Great. Oh, browser tabs on bottom are fantastic. I do that. So here it's not as important, but it work.
00:10:46.480 - 00:11:14.940, Speaker A: It's actually great because I have a vertical monitor and then the bottom of the screen is easier to reach with my eyes than the top. The top is farther away. Okay, so I think we now have the base structure. Let's just see that. Um, inferno flame graph help. Um, let's see that it actually runs. And we didn't make any really stupid mistakes.
00:11:14.940 - 00:11:50.860, Speaker A: Oh, we probably did. Uh, why is this complaining source liberal ferno flame graph? No, that should be right. But this though is missing collapse perf like these things. So not that. And this function's body doesn't return. That's fine. Great.
00:11:50.860 - 00:12:22.756, Speaker A: All right, so we now have something that like, we have a binary that we can start to fleshing out. So now the question is, what does handle file do? Make this a little bit larger. That is a good question. This is a bunch of stuff. Title I guess we're going to set after a while, name attribute file format. What's name attter file. There isn't really a file like that.
00:12:22.756 - 00:13:10.490, Speaker A: So where does that come from? File holding function attributes name attr. There is no name attter argument that's documented. That's pretty weird. Okay, so that's a function info by tab, then a sequence of tab separated name value pairs. Also, this is to be able to override things in the SVG. So we can probably just ignore that for now. And notes we're also going to ignore for now colors we're going to ignore for now SVG functions.
00:13:10.490 - 00:13:49.550, Speaker A: So these are things for, these are basically how to sort of set up the various SVG primitives. So, so if you remember in the gear, let's pull up an actual one of these svgs. So basically this SVG contains a bunch of rectangles, right? Like each of these is a rectangle. And so if we go in and inspect this, like each of these, just a rectangle that is probably contained within their parents somehow, maybe. No, they're just base G's. Okay. So you'll see.
00:13:49.550 - 00:14:40.790, Speaker A: I wonder how the position of this is set. It's another good question. It almost looks like all of these, each of these is a g and they're just sort of, they're sort of hanging around. So I guess it's really the stuff inside, right? Yeah. So there, each of these is erect a rectangle, right, that have their position set and a fill and then some text added to them as what we need is the ability to generate these kinds of things. And so everything that's in this like SVG package function business is just the ability to, I guess this is the SVG header. These are just to include raw SVG content.
00:14:40.790 - 00:15:14.836, Speaker A: Setting a color, starting a group, right. So this is where this is this, each of these G's is created by one of these start groups and then that sets the title. And what are these hrefs? Because we don't know what those are yet. So it says a bunch of attributes on the G. So that just starts the group, that ends the group with an NG. And then this is what creates the rectangle. This is what creates the text.
00:15:14.836 - 00:16:01.670, Speaker A: So this is the stuff that we're going to need. If you experience go, can you compare with rust performance wise and doesn't make sense to transport it to rust. Um, it really depends on what you're doing. I would say that rust is generally a more performance oriented language than Go is, but often it also doesn't make a difference. Oftentimes the additional speed that rust gives you is not something you need. Go is a little nicer to program in the sense that the language is simpler and the constructs are simpler. But it is like I like rust because the compiler is strict and you have better types, and so you can make the compiler do more of basically the work of figuring out whether your program is correct.
00:16:01.670 - 00:16:26.560, Speaker A: Consider to do a live stream of procedural macros. Two, we could probably do that. That's a good idea. I'll add it to the ever growing list. It sounds like what we might want is some kind of library for generating svgs, instead of just generating these just using text. Oh hey, SVG composer and parser, updated a month ago. Great.
00:16:26.560 - 00:17:12.460, Speaker A: All right, let's take a look at the docs for this document. Svg. Okay, so we can add nodes, that's fine. So what implements node group? That seems kind of promising. It seems pretty straightforward, right. And it means that we don't have to generate all of this just by writing out text the way the Perl version does. A lot more heavyweight than if we just output it ourselves.
00:17:12.460 - 00:17:50.990, Speaker A: So yes and no. It is true that it's easier to just print stuff, but it also gets you into weird territory with things like encoding. It means you have a bunch of inline svg in your file. You need to deal with things like closing tags correctly. The upshot of using crate for this is that it basically lets us use types instead of strings, which is nice. The other reason why. Well, so one reason not to do this is if we print, then we can generate the file on the fly, as opposed to just writing it all out at the end.
00:17:50.990 - 00:18:31.090, Speaker A: That said, though, I don't know that there's a huge advantage to that, because you can't really render the svg until you're done anyway. So I think we're just going to use the svg crate. That seems fine. So we're going to add a dependency on SVG version 0.5, and then this is going to use svg. Great. So how does this get started? Vector hash for the name stringental to pick the same colors for function names across different flame graphs.
00:18:31.090 - 00:19:26.588, Speaker A: Oh, that's interesting. So it's using the I see. So the way it's generating these then is things that start with similar characters are colored similarly. It's the way I read this, right, so it takes the name of a function, assigning more weight to the early characters, so prefixes of the, of the function so that you get consistent colors even if the thing moves around in the plot. That seems fine. Color is just different color palettes, multiplets I think we're going to ignore for now. That is sort of a, that is sort of an additional feature that is really cool.
00:19:26.588 - 00:19:59.462, Speaker A: Like it basically lets you, if you have a thing like this, if some of these happen in the kernel, then those would be colored in a different color so they're easy to, easy to distinguish. You totally can render the SVG while you build it if you manage to compile this to wasm. Yeah, but I don't think it matters. Okay, so we're gonna ignore this color business. I mean, we are gonna have to deal with actual colors, but I don't think we need quite this much complication, at least to begin with. So I'm gonna ignore that for now. Right.
00:19:59.462 - 00:20:45.870, Speaker A: Palette. Ooh, why is, oh, is it like you can give a custom color palette? Maybe like you can give a file or something. Pal file. What is pal file? It writes out a palette map. Why does it do this? If palette. Oh, I see. Cp.
00:20:45.870 - 00:21:11.550, Speaker A: I see. So it can like remember what paulette which colors it used for, which functions in the past and then restore that later. So that's also like an additional feature we could add later. Doesn't seem important for right now. For the people in YouTube looking for the twitch stream, there's no software development tag, but English IRL creative under science and technology. Yeah, it's kind of annoying. Okay, so read play.
00:21:11.550 - 00:21:57.660, Speaker A: So this business is really just dealing with persistent color templates. Flow merges, two stacks. Okay, this seems like something we're going to have to look at eventually, but let's, I want to get to the part that parses the file first and then we can look at where flow is called reverse if needed. That's weird. Okay, so this is where we're just reading in, just reading in the input which. So this is the output of stack collapse perf. So if you remember the output from stack collapse perf looks like folded log.
00:21:57.660 - 00:22:27.060, Speaker A: Basically it looks like this. So on every line there is a particular call stack. So this is API called core slice. I guess let's find a longer one. The thread client zero called some function which called TCP stream read and this call stack appeared in three samples is the way to read this. Similarly, this call stack appeared 56 times. So that is the entire structure of this file.
00:22:27.060 - 00:23:01.390, Speaker A: There is nothing else in it. So what is stack reverse? I mean, I assume it reverses the stack, but why reverse? Generate stack reversed flame graph? Let's just not support that for now either. That seems like an easier thing to add later in some sense. What I want is I want the program to work with no arguments, and then we can deal with adding features later. Right. This seems like basically all it's doing is splitting by semicolon and then inverting and then doing whatever other thing this is doing. It's unclear.
00:23:01.390 - 00:23:43.150, Speaker A: So really this is just reading in all the lines and then it sorts the data. That's interesting, because the data is already sorted. This should not be necessary. If you remember from here, stackcollapse perf, the last thing it does is it sorts. So I don't think it's necessary to sort here. Although I guess maybe, actually no, it is, it is because of this. Right.
00:23:43.150 - 00:24:48.050, Speaker A: If you reverse the stack, then you do have to sort again. All right, so we're, this is still that, if you consider there being no arguments, then this is still just iterating through every line of the file. And then we parse out, I mean, this is parsing the line, but it sort of, in a weird way, everything up to some number of space. Why is this is that complicated? Some number of digits followed by this is a positive look behind assertion. I wonder why that's there. I don't think that should be necessary. Let's look at the blame for this.
00:24:48.050 - 00:25:52.310, Speaker A: So blame is really handy for these things, because we can try to find the commit where that was introduced and see why it is that way. This specifically, what did this change? Oh, that just removed a whitespace. That's unhelpful. Let's see, where did it go here. So this changed. There may be an extra samples column for differentials. Why is that common comment not in the original? Why was that comment removed? Oh, maybe it's further up.
00:25:52.310 - 00:26:41.100, Speaker A: What are differentials then? Interesting. Okay, so this is really saying that, let's see, can you do something like cat file one, file two, flame graph so they wouldn't be sorted either? That's true. You could combine flame graphs that way too. So that's another reason to sort them. Yeah, I don't know why it's sorted in the first place. Like I don't know why the output of stack collapse perf is sorted. I don't think it needs to be, although that sort should be pretty fast anyway.
00:26:41.100 - 00:27:11.770, Speaker A: But you're right, I don't think that should be necessary. So it might be that we can just get rid of that. Although then it would become pretty hard to basically run our regression tests. Right. Because our output would just be nothing like the real output. What are differentials? Well, so that's what we're trying to figure out. It seems like there's no pull request document in this, but colored based on higher samples and smaller samples.
00:27:11.770 - 00:28:08.990, Speaker A: Let's show the before profile cardboard. What will happen? I mean, this seems like maybe it's useful, but it's hard to say. Okay, this sounds like a commit that we should keep track of for later and then just ignore this for now. See here, it's documented. Interesting. Yes. I think what we're going to do is just not parse the extra sample column.
00:28:08.990 - 00:28:44.770, Speaker A: Why is there a dot? Why are they dot separated? And then this is one of the things we can list as an issue of enhancement is support differentials. Okay, so let's ignore that line for now and just assume that what it really picks out is the stack, which is everything up to the, up to the number at the end and the number at the end, which is going to go in samples. And then we're going to ignore lines that don't match. That's fine. Also, now the comment is here. Okay, fine. So we didn't actually need to go through that.
00:28:44.770 - 00:29:41.650, Speaker A: Oh, why does this match again? Oh wait, this is doing something else. So this is, this is match. This is matching on the whole line. This is matching on the stack, which is the stuff with the last column removed. So why is this here? That is a very good question. Everything followed by maybe a space followed by digits followed by dot and numbers. Also, this is just ignoring fractionals, I think is what this is doing.
00:29:41.650 - 00:30:17.860, Speaker A: It's saying that if the sample count is fractional, then match against it, but don't include it in the match. I mean, let's double check. But I think that's what it's doing. Yeah. Non capturing group. It's really weird to decide to do this with non capturing groups, but that's what it does. So this is just saying if the sample count is fractional, then ignore the fractional part, which we can do much easier than this.
00:30:17.860 - 00:30:48.510, Speaker A: Okay, so really this is, okay, this is kind of weird. So really this is an r split. Well, it's sort of a, it's a split white space from the back. You pop once. Actually, you could just r split r split NDE two space twice. Although we might want to use split whitespace. It's not clear.
00:30:48.510 - 00:31:17.340, Speaker A: And then you look at the last group, and that better be digits. And if they're, if it's fractional, then discard the fractional part. And then you do, if you do it again, then you get the differentials. But we're just going to ignore differentials for now. So this would be false. So we can ignore everything that's in there and that's not defined. So samples two and delta are both going to be undef for chain graphs.
00:31:17.340 - 00:31:55.460, Speaker A: We're going to ignore chain graphs, merge frames and populate node. Okay, so there's this flow business. So last is going to be set equal to whatever flow returns and passed into the next one. So we're sort of recursing on last. We're giving a list that is an empty element and then stack split by semicolons. Time. Where does time come from? Does time come from? Time is zero.
00:31:55.460 - 00:32:24.802, Speaker A: Oh, interesting. Oh, it's probably. Okay, so what I'm guessing this is doing is it's looking for things that share a common prefix. Right. Doesn't discard. The non capturing group is still in the capture. Yeah.
00:32:24.802 - 00:32:54.010, Speaker A: The question is why is this a non capturing group? Like, why use a non capturing group here? I don't think it's important though. I think because like this part is just matching fractionals and this is a non capturing group. And so this thing is matching an optional fractional part. I just don't understand why it has to be non capturing. That doesn't seem important. I guess it's because otherwise this would return a three tuple. But I think you could just ignore that argument.
00:32:54.010 - 00:33:22.668, Speaker A: Okay, so my guess is this flow business is just going to look for things that share common ancestors. Time is just going to be how many samples we've seen so far. And delta is undefined. Okay, so now let's look at what flow does. Merges two stacks. Great. Okay, these are the arguments.
00:33:22.668 - 00:34:18.520, Speaker A: That's fine. Oh man. Perlna. So it's looping through the last stack frame and if, and seeing whether there's a shared prefix. Yep. It's just iterating over both and seeing the first point at which they diverge. And then it's looking at the part from where the previous thing ended, greater than or equal to Linseem.
00:34:18.520 - 00:35:21.120, Speaker A: It goes from where the previous thing ended and goes backwards towards where they diverge. Oh man, that's weird. Last I nuke id is constructed for func depth etime. So I is the, I is the depth of the call stack. Sure. So I guess that's like how far up it's going to be. So this is constructing what is the shared prefix and how deep is it in the overall call graph, like how many, how many stack frames are there? Because you need to know how far from the bottom of the, basically of the SVG to draw that square.
00:35:21.120 - 00:35:57.390, Speaker A: I do not have any experience with the Vulkan API, sorry. Etimeter. So node with that followed by v. What's v? V is time. V is just the number of samples you've seen so far. So that's guaranteed to be unique. So that's sample time, I guess is what is tempesthenne.
00:35:57.390 - 00:37:06.008, Speaker A: So we've got temp that's going to be set down here. Okay, so I guess we'll have to figure out what this line means. We're not using deltas, so that's fine. Oh, this language is Perl. Perl is a, it's a language that's very good for string processing and pretty painful to read for, well, I mean for string processing as well, but just generally pretty painful to read. Okay, so this is a unique identifier for why does it need last like Len a? I think this means that it's only processing a given line when it gets to the next one because it has to decide how deep that thing is going to be. Okay, so this is iterating over all the frames after the shared prefix.
00:37:06.008 - 00:38:07.890, Speaker A: And this is iterating over the things. Oh, this is iterating over all the things that are only in a. And these are all the things that are only in Bhidden. So this is the, these are the things that are only in lost and these are the things that are only in this. Why is this one iterating in reverse though? Don't know. It doesn't seem to be a good reason for that. Like why does this not iterate from Len same to Len a with I? Why is that important? That is, why is it important that it doesn't for the deltas, maybe, I guess k is not unique.
00:38:07.890 - 00:38:55.530, Speaker A: Actually k will be unique in this particular instance because the I is the depth and that will differ. Yeah. So I don't know why it's iterating in this order, especially because the iteration order of hash is also not known. So I don't think that should matter. I think we, we can reverse this and then iterating over the things that are in this, constructing that. Okay, so it's constructing the same key. Okay, so temp is really the samples, the unique things from the previous line we iterated over.
00:38:55.530 - 00:39:26.492, Speaker A: Right. Because remember, this is, this, this is last right. And so next time, this is called, this is going to look at, this is basically from last as well. This is where last differed from its last. Oh man, this code is funky. Return this. Why does it return this? Oh, because it's at last equal to this.
00:39:26.492 - 00:40:25.250, Speaker A: Okay, that's fine. So really this node key is what we need to look at. Seems like node is where, because that's the only, if you look at it, that's only, the only real output of this function is this map node. It's like modifying this map node and it's really just constructing node so that it has, so that it contains every, it contains one entry for every distinct call chain, every distinct item. I think. Oh, I see what it's doing. Okay, so I think, I think what it's doing is the following for, so what's a good example of this? Let's look at execute simple command.
00:40:25.250 - 00:41:00.782, Speaker A: So we're going to have a bunch of stack frames, one that contains like, execute simple, command, execute built in function. Cleanup redirects one that's execute simple command, execute built in function, do redirections, execute simple command execute built in, or function expand words, etcetera. But we only want one entry for execute built in function, even though it appears in multiple stacks. Right. As I think that's what this code is doing. It's adding things that were unique. I think it's basically just making sure that it only adds each thing once at the level at which it's supposed to be.
00:41:00.782 - 00:41:37.030, Speaker A: I don't know why this, why the time is included, though. We'll have to figure that out. And this really just sets, it just sets the s time, so. Yes. Okay, let's go back to here and see what it does with the results. So after it's flowed all of the stacks, then what does it do? Okay, that's fine. That we can just ignore time, Max.
00:41:37.030 - 00:42:21.260, Speaker A: Oh, this is to say, don't parse times with per time. We'll have to figure out what that does. Right. So now it's iterating over node, which is one entry for every, for every function that appears at a given depth. And it has to be distinct because you could imagine that, like here and here, both of these were due redirection internal, so they have the same name and the same depth. So you do need to distinguish them. And they do that by samples.
00:42:21.260 - 00:42:39.984, Speaker A: This is doing some kind of pruning. So we'll probably have to do that. Just getting rid of things that are too narrow to show. Draw the canvas. That's fine. We don't particularly care about that. Inject a bunch of JavaScript.
00:42:39.984 - 00:43:30.580, Speaker A: We don't really care about that down here. This is just a bunch of setup palette and then draw frames. This is what we care about. So for each node there's an id and a node. What is node there? What is the value within node? That's a good question. I guess that brings us back to flow. So the value within each node is, it's a hash that contains the value s time may contain delta.
00:43:30.580 - 00:44:09.240, Speaker A: Notice it's empty up here. Is anything else modify nodes? I don't think so. So I think it really is just a hash. So the only thing that's really in there is s time. So node is really just, yeah, it just contains s time and delta. Interesting. So x one is exped plus start time.
00:44:09.240 - 00:45:17.740, Speaker A: Hmm. Oh, I wonder. So it's considering the sample time. So what we pass in as the time argument is actually the, is actually what's going to determine the width of each bar. So start time is going to be like here and end time is going to be around here. How does it arrange for that to be the case, I wonder? Like why is that the case? How do we compute this time? So the time is computed by, the time is computed by just adding the number of samples in the line. Why does that work? If it never gets reset, then why wouldn't you? Oh, it's probably because of the sort.
00:45:17.740 - 00:46:02.050, Speaker A: So remember, the iteration order here is basically going to be like a depth first search. So you're going to be moving through this graph in this order, right? In sort of that order, or I guess, I don't know how the screen looks, but sort of from bottom left to top right. And that is really going to be the start time. The question is how does it determine the end time? Oh, that's so clever. Okay. This flow function is very clever. It is very dense, but very clever.
00:46:02.050 - 00:46:23.060, Speaker A: I think I need to draw this, actually. That might help. Don't I have a draw program? What's it called? Paint. There we go. Hey, I get to bring out my painting thing again. That's good. So I think here's what's going on.
00:46:23.060 - 00:47:27.612, Speaker A: Let's see if this works. Where's my greatest, I think I have a, so let's do file new discard. So when we work through the file, it's going to have something like a, b, c, like three. Then it's going to have a b, I guess d, four. It's going to have a c, maybe like eight. Of course, now the end time of b should be seven. Right.
00:47:27.612 - 00:47:51.960, Speaker A: Should be three plus four because b lasts for this entire duration. And the end time of a should be 15. Right. This should be seven and this should be 15. So what it's going to do is when it encounters this stack, this first stack, right. When it encounters that. Oh, that eraser is terrible.
00:47:51.960 - 00:48:16.838, Speaker A: Is there a way to. I feel like I had a button for this, but maybe not. Oh, like this maybe. There we go. Great. All right. It's kind of an helpful, but all right, like.
00:48:16.838 - 00:48:41.358, Speaker A: So, um. Oops. And now the colors are wrong. Um, and what's going to happen is when it's looking at this first stack, it's comparing against the empty stack, right. Because that's what we told it to do. So at first, um. Oh, man, I don't remember.
00:48:41.358 - 00:49:00.408, Speaker A: Mark. Or small, maybe marker fat. Great. That's. Sure, whatever. It's not important. So initially it's going to start with an empty frame up here, and then it's going to compare that to ABC.
00:49:00.408 - 00:49:37.000, Speaker A: It's going to iterate through. So remember, it first goes over last. So it's going to iterate through nothing and do nothing. Then it's going to iterate over new and it's going to set in its like, node map, it's going to set everything that, what was it? Everything that follows where they are the same. So first it's going to set a depth one to and then the current time, which was. Right. That is what it says.
00:49:37.000 - 00:50:11.660, Speaker A: Think it flow since it's s time to v and v is the time that's passed in, which is three. So it's going to set three and it's going to set that to. Oh, sorry. It sets that in temp. Right, sorry. So there's also tempesthe. So temp is going to have a one is three, right.
00:50:11.660 - 00:50:57.900, Speaker A: And it doesn't have anything in here yet. What? Let's do something like this. Really? Why is there not a better marker for erasing? So in temp, it's going to set a one to three. And in node, it hasn't set anything yet because it only sets node when it's iterating over things from the previous one. So that's all it's really going to. No, I guess. And then it's going to set b.
00:50:57.900 - 00:51:24.090, Speaker A: It's going to set b. Just b. Is that all it sets this I? Yeah. So just b. So it's going to set b at depth two is also going to be set equal to three. And c at depth three is going to be set equal to three. Right.
00:51:24.090 - 00:51:50.822, Speaker A: And then on the next iteration, this is last and this is this. Right. So it looks at the common prefix, which is here. That's the common prefix. And it looks at things that were. So it first looks at things that were in last but are not in this. So it's going to look at c and it iterates backwards over these.
00:51:50.822 - 00:52:31.110, Speaker A: Right. So it's going to look at c up here. Right. And it's going to set in node, it's going to set c three with the current time as the differentiator. So C at depth three was the current time, which is three plus four. So seven. It's going to set that to be what it deletes from time with the entry c three, which is three.
00:52:31.110 - 00:53:07.236, Speaker A: So it's going to be three. Then it iterates over this in forward order. And now this is deleted. Right. Then it moves in forward order on this, which is going to be just d. So it's going to set d at depth three is going to be equal to the current time, which is seven. Right.
00:53:07.236 - 00:53:38.460, Speaker A: Three plus four is the current time. And then now this is done. This becomes last. This becomes this. And the common denominator is now this. So it's now going to walk backwards through b and D and forwards through C. All right, so it looks at D and it constructs d at depth four with current time, which is 15, is equal to delete.
00:53:38.460 - 00:53:55.368, Speaker A: Sorry, D was. Sorry. This should be three. Right. Abd deletes d three, which is seven. So it set this to seven and then deletes this. And then it gets to b.
00:53:55.368 - 00:54:20.090, Speaker A: Right. B is the next thing in here. And so it's going to set b at depth to. With n time 15. Is that right? Yep. Is equal to delete b two. B two here was three.
00:54:20.090 - 00:54:50.220, Speaker A: Right. Three. And then it's going to move forwards through this, which is going to add here c two is going to be equal to 15 and then it's going to move down to. This is here. This is no longer last. This is now last. And then it's going to move backwards through these and forward through nothing.
00:54:50.220 - 00:55:19.790, Speaker A: So backwards through AC is going to be set c at depth two with end time. Actually, I might be off on all these. These should be. I think these should all be down by three. That's not important. So this, because this has to be 15, this has to be seven and this has to be three, I think. I think this is going to be three.
00:55:19.790 - 00:55:40.080, Speaker A: 7715. So c 215 is going to be delete. Delete C, two, which is going to be 15. Yeah. So these are also wrong. This should be zero, should be zero, should be zero, should be three. It should be seven.
00:55:40.080 - 00:56:15.500, Speaker A: So this is equal to seven. And then it gets to a. So it sets a depth one, time is 15, is equal to delete a one which is zero, like so. And now if you look at it, a, at depth one is going to be from zero to 15, which is the entire width. C at depth two is going to be from seven to 15. B at depth two is going to be from three. Two, seven.
00:56:15.500 - 00:56:44.042, Speaker A: Right. I guess these should also be decreased by three. I just messed up my counting of time. So for each one, the start time is what they're set to and the end time is where they, the time at which we decided to add this to node. I don't know if this was, this was kind of weird to follow. And I'm still not sure why it works, but it does seem like it works. Okay.
00:56:44.042 - 00:57:27.410, Speaker A: So I think what we do is just port that and try to document it as best as we can. Let's see. Because I guess down in the SVG generation, all it then really has to do is just compute the absolute coordinates of those times. Right, which is what it does here. Xpad plus time, times width per time, and then down here. Right. So all samples that just generates the very bottom bar and for anything else.
00:57:27.410 - 00:58:16.870, Speaker A: Yeah, so this is the kind of stuff we don't have to do if we use an SVG library. And then that just prints what's going to go, what the hover text is going to be for each one. So you see when I hover over these down here, there's like text that shows how many samples and percentage. So that's going to be, that's what this generates. This is the info and then it generates what we're going to have the different attributes be for the node that we create. So this is also pretty straightforward in our, in the SVG generation library. And you start that group, then you set the color and then you create a filled rectangle.
00:58:16.870 - 00:58:49.200, Speaker A: So this is the, in the SVG, this is the rect, right. So that has to have a color set for it. And the X and the Y's we've computed. I wonder what this is doing. Oh, this is saying if there is no room in it, then don't put any text in it. Right. So I wonder how it computes cars.
00:58:49.200 - 00:59:07.006, Speaker A: Oh, it just like looks at the font width. Okay. So it tries to guess how many characters it can fit. Inside the box, it generates. And then if it thinks it can fit at least three characters, then it does. Then it generates a short, potentially shortened version of the text. Right.
00:59:07.006 - 00:59:37.420, Speaker A: So this is like add dot, dot, if necessary, adds the strings, ends the group. All right. Yeah. These kind of like hidden gems in traversal are really neat. I wonder how Brendan arrived at this. It's like black magic to me that this works, but it is really cool. All right, so I think we're at a place where we can now sort of start doing this without any features or anything, just sort of to get started.
00:59:37.420 - 01:00:09.400, Speaker A: What we're going to do is we're going to create a new SVG document. Right? So this is going to be SVg. It's just document new. Document new. Yep. It's probably going to have to be mutable. And at the end, I guess, what can we do with document? Can we write a document to a writer? Great.
01:00:09.400 - 01:01:02.920, Speaker A: At the end, what we're going to do is SVG write to our writer, the SVG, and that's what is that going to produce IO result. Perfect, because that's already what we're returning. Okay. And my guess is that just like in collapse perf, there's like a decent amount of overlap in that we want to be looping over lines, but I think the looping is a little different. What we'll probably do here is the same thing as, as we did when we originally wrote the stack lapse perfport, which is, we'll start by sticking everything in one file, like keep the main loop, and then we can factor it out later. Where did you switch to rust from? Oh, all sorts of things. I did a lot of go before.
01:01:02.920 - 01:01:42.600, Speaker A: I've also done a lot of web programming. I've done some Java in the past, a bunch of c code, like all sorts of things. But I think rust is sort of my, the language I've at this point, spent the most time with. I've written a lot of c, did not like it. Okay. So the kind of stuff we have to keep track of, it seems like, is mostly like we need last. Right? We need, I guess let's call them the same for the time being, and then we can give them better names after a while.
01:01:42.600 - 01:02:06.680, Speaker A: So this is going to be a hash map. Similarly, node is going to be hash map state. We don't have, if we're at the end of the file, then we break the loop. We don't have to ignore comment lines. We do have to parse the line, though. I guess we're gonna trim the line. That seems fine.
01:02:06.680 - 01:02:46.908, Speaker A: If the line is empty, then I think we're just gonna continue remembering. The reason we have this here is in the old file, empty lines denoted the end of an event, whereas that's not the case here. And now we want to do the parsing to try to figure out whether it's a sample line. Right. Remember we're now just ignoring all of this business, right, of being able to reverse it and sort it. I guess we may have to cat multiple files, so that's a little awkward. I'm just going to ignore this for now and have it make, have it work, have it only work for one pub for now.
01:02:46.908 - 01:03:53.550, Speaker A: So I guess up here is going to be something like to do technically need to pre process lines, reverse stacks in case of multifile. All right, so now we have to parse the, parse the line, and we're gonna not parse it the same way they do. Instead we're gonna say fields is gonna be line, I guess split whitespace. It's a little awkward because split whitespace doesn't give you the index, so we wouldn't know where to trim to, which is why I think what we actually want is r split n, although that's going to require that these separators only a single space, which I think we know is the case. It sort of depends how. Help. Oops, that's not the one I wanted at all.
01:03:53.550 - 01:04:53.764, Speaker A: Collapse perf. What do we write out for this? I think we just write a space we push, where is it? Um. Oh man, on event line. Where do we actually write out the after event? I guess entries. No, it's entries sort here. Yeah, we do just write out a single space. I guess the question is how much do we want? Actually, here's what we could do.
01:04:53.764 - 01:05:26.920, Speaker A: We could just do r find instead. We're going to r find space. Yeah, that's what we're going to do. And then I guess what we want is samples. Any reason to use hashmap a default over new, but not for strings? No, not really. Arguably, it should be consistent. You're right.
01:05:26.920 - 01:06:05.378, Speaker A: I sort of like using default over new because, well, usually what I do when I'm making various structs is just do default. Default because it means that I only have to change the type in the struct definition, not in the implementations, because the type inference figures out which default to use. And that is more often hash maps than strings. But in this case, I think it's fine to just use new. I've been wondering how you get your search bar to the bottom of your browser. It's a nightly feature or something? No, it's actually in Firefox. You can write custom Css for your browser.
01:06:05.378 - 01:06:54.080, Speaker A: So there's a, I think I have it just somewhere that does this somewhere this business. If you just look for my gist and look for this, you can select this in, in the Firefox css and then your tabs will appear at the bottom. Isn't norm adapted for this kind of parsing? Yeah, so someone asked this in the previous stream as well. We could probably use Nom for this parsing. We probably could. One difference though is I guess we could write a parser for the line. I don't feel very strongly about that.
01:06:54.080 - 01:07:24.966, Speaker A: I guess I'd be fine with it in this case. The parsing is so simple though, right? It's just like we're splitting by whitespace, so it seems kind of weird to pull in all of nom just to do that, because we're not really parsing a full language. Right. They're very simple lines. So we're going to do is if, let's, I guess samples, I feels dot next. Yeah, I know. I miss opera too.
01:07:24.966 - 01:08:36.460, Speaker A: Although opera was also bad in many ways. Then, then I guess what we really want here then is sample. Then we want samples is going to be rewrite this better later, but it's sort of going to be line samples I dot, dot. And we want to parse that. We want to parse that as a usize. However, this is where it gets tricky with the, with the fractionals. So I think actually what we'll do is this strip fractional part.
01:08:36.460 - 01:10:18.630, Speaker A: Actually, I don't know what must use size, what the usize parse does, whether it just like ignores trailing fractionals, what does from string radix do? It sounds like this would just panic. If that's unhelpful, give me the actual source of this. Still pretty unhelpful there. Okay, so it's the leading plus or minus digits is positive. Yeah. If it got a dot, it would just gets sad. So we do actually have to strip the fractional part is samples.
01:10:18.630 - 01:10:48.240, Speaker A: Hmm. More of a trait of not pulling that many dependencies over simplicity of the problem. I think it's a combination. So you could totally pull in nom. I don't know that that makes writing this code simpler, because then you have to figure out how to write the correct norm for parsing this line. If you know norm, that's not an issue. I have written some norm in the past, but I don't know that I would.
01:10:48.240 - 01:11:36.230, Speaker A: I don't know that it would be any easier for me to write the correct nom code. Is it a lot of work to make your vim work like yours? I don't think it's that much work. I mean, there's a lot of stuff you can do to configure editor, and especially an editor like Vim, but that's the same for any editor. It will take you a while to get used to, but that's about it. So the reason I'm hesitating here is because it could be that the sample is like. So imagine a line that looks like this. If we strip the fractional part, then the fractional part will still be wrong, right? Like this is should not be parsed as a sample line.
01:11:36.230 - 01:12:47.700, Speaker A: But I'm gonna ignore that for the time being and just sort of assume that if the line has a, if the last column of the line has a space in it, then we're fine. Sorry, has a, starts with a digit followed by potentially a dot. Then samples is gonna be samples dot I. And then if samples dot isn't there an. I guess what we want to do is match samples dot parse us. And if it's okay, then we get n samples. If it is any kind of error, then what we really want to do here is just continue.
01:12:47.700 - 01:14:10.060, Speaker A: I guess what we may want to do is sort of include this ignored bit, right? So they have a, in the Perl version there's a number of ignored lines and we want to keep track of that too. I think in the, in this code, it doesn't really print anything, it just counts the fact that it ignored it. Right. And then while we're at it, we also want to set line to be everything up to samples. I trimmed move samples from line and then give out the sample count. Great. And if it's none, then I think we just continue.
01:14:10.060 - 01:14:48.260, Speaker A: And I guess ignored plus equals one. Of course we could also use regular expressions ourselves here. So in stacklabs, perf, remember what we started doing was we. Yeah, we started writing the regular expressions and then we profiled it and we figured out whether it was slow. And the things that were slow, we converted from regular expressions to inline parsing. And we could do the same here. This parsing, which is so trivial that it's like not, not worth it.
01:14:48.260 - 01:15:36.940, Speaker A: Although I say that, and I still written a screen full of text, so unclear. Okay, so at that point we have samples and we have stack is going to be equal to line. And of course here we're going to have the same thing of if, okay, these we don't use. If line is now empty, then we continue because it means that we didn't have a stack. And then we're just going to rename line to stack because it's easier to work with that. And I guess we could call this samples instead of nsamples just to match the pro code. But I would rather have it called nsamples.
01:15:36.940 - 01:16:22.900, Speaker A: Samples to me is a vector of samples and sample is the number of samples. Okay, so this is where we get to flow. And so this does something like last is equal to, I don't think this needs to return anything because flow does not modify this. Right? Unless I'm mistaken. No, it just returns this. So I think really what I want here is just, let's call it flow because why not? We might want this to be something like self dot flow eventually. We probably want to better name them flow too.
01:16:22.900 - 01:17:04.742, Speaker A: But this is going to pass in mu temp, mute node, last this, and this is just stack. Right. It's a little annoying that we're going to have to keep that string around. It's going to be an extra allocation, but it's probably fine. It only needs read, read only access to these. And what else? It needs n samples. Right.
01:17:04.742 - 01:17:31.150, Speaker A: And then we're going to set last is equal to stack. I like, I prefer that to having flow, like return this. It just seems odd when that's really what it's doing. It's easier to have that explicit here. Of course this isn't going to work because of types, but let's ignore that for a second. And then we're going to have time. So this is going to have to also have, let me, time is zero.
01:17:31.150 - 01:18:39.960, Speaker A: And we're going to say time plus equals n samples. And then there's also, after this loop, we're going to have to flow this with. I don't think I want this splitting to happen in the caller, actually. What does happen if you, if you split by semicolon and an empty string? What do you get in rust? It's a good question, I guess. Empty string split by semicolon collect vec. Let's see what that gives. Debuggest.
01:18:39.960 - 01:18:59.410, Speaker A: Great. Gives one entry, which I think is what we want. So this should be last and nothing. And this should not be n samples. It should be time. Right, so I got that right? Yeah. It should be the previous value.
01:18:59.410 - 01:19:25.830, Speaker A: It should be time. And then this should also be time. Great. And then we're going to go into like draw the SVG. To do draw the SVG. So now we need this flow function. And flow is going to take temp.
01:19:25.830 - 01:20:15.960, Speaker A: It's going to be a hashmap of indeterminate types for now node, which is going to be also something we don't quite know yet what else it takes last, which is a string. It takes this, which is a string, and it takes time, which is a use size, and it doesn't return anything. Question is, what are these types? I think they're all just to usize, right? Yeah, because we don't have this depth thing. So for now they're all going to be just two you size. And what is the key? I think the key is just like this unique string is the way they do it. We don't really need it to be a unique string. I think.
01:20:15.960 - 01:21:01.530, Speaker A: Well, it's actually going to be a string regardless, because it has to include the function name. So because of that, it might as well just be a string. The alternative, of course, would be that we do something like struct. In fact, maybe we want to do this so we don't have to parse again later. So there's going to be something like a function at depth, which is going to have a function, which is going to be. I think it has to be a string because we're going to keep it around for a while. Oh, so this is actually the real reason that we might want to slurp in the entire file in one and then do like the sorting and whatnot, because all of these can be stirs.
01:21:01.530 - 01:22:03.950, Speaker A: So this would also be, would also let us only operate on STR, which would be nice. Like last could then, for example, continue to be a pointer into the string even after we moved on to the next line, which is not true with the current way we're parsing, but that's an adaptation we can make later. So depth is going to be usize. This is going to derive, debug, partial, eek, eek and hash. This is going to be function, depth and an optional time. I guess this is going to be something like uid, and that's going to be an option use size. So remember how in this map we need this extra unique identifier? Actually, I guess that's end time.
01:22:03.950 - 01:22:48.196, Speaker A: End time. But if we're using it for temp, then temp doesn't have an end time. And now these are all going to be from function. Add depth to usize. Right? What is it complaining about? Like, why is it, why is it not formatting my file here? That's better. All right, so now flow takes those arguments. And again, I think flow is going to be function on a self where the self contains tempa node.
01:22:48.196 - 01:23:30.970, Speaker A: And so this, the arguments are just going to be last this in time might not even be last. Last might also be stored in self. It's going to take something like mute self this in time. All right, so what does flow do? Well, from, or rather not from memory, it looks for the first place of which two arrays differ. Right. So specifically it's going to look for last is going to be last split on semicolon. This is going to be this split on semicolon.
01:23:30.970 - 01:24:19.230, Speaker A: And I think we sort of want peak. Oh, really? Peekable? Isn't there a function on iterator? Yeah. Okay, great. So peekable lets you have an iterator where you can look at the next element without taking it. And the reason we kind of want that is because it means that we can just continue using the iterator in both of these cases. I still don't know why this has to walk in reverse. That is still really weird to me because this key has to be unique for each of these iterations.
01:24:19.230 - 01:25:25.190, Speaker A: Like k has to be unique for each thing in this iteration. So the iteration order here should just like not matter unless I'm missing something. But I don't, I don't see what that would, what that would be because now what we can do is while last peak is equal to this peak last next and this next remove common prefix. Right. So that's what this loop is doing, is just figuring out how far they are the same. And then it's. No, it's never looking at the things that are the same.
01:25:25.190 - 01:25:46.208, Speaker A: See, that's a good question. Len same. Len same. Yeah. So they're, they're not looking at the index of the last thing that is the same. They're looking at one past, maybe because of how the guy the wrote the code was thinking. He wrote it in reverse for easier reasoning, but doesn't actually matter.
01:25:46.208 - 01:26:37.390, Speaker A: It could be, but this one is written forward. So why is this one written backward? I don't have a good answer to that. I guess maybe we'll find out right when we try to test this code, but. And now what we're going to do is for, for func in. So Len A is lost. We're going to make a key that is going to be a function at depth and it's going to be the function. Is that what I called it? Function so the function is going to be func.
01:26:37.390 - 01:27:34.310, Speaker A: We're probably going to need some like two strings here, but let's ignore that for now. Depth is going to be. Oh, we need to keep track of the depth. So this is going to be like shared depth. So shared depth can't spell dot enumerate. So depth is going to be share depth plus one, sorry, plus I. Yep.
01:27:34.310 - 01:28:35.570, Speaker A: In that while loop would be that well, would be true if both return none. Yes, you are right. If last next is none then break move along prefix iterator they must both be none. So we're done. So let's stop looping. That's a good catch. So that's the depth and then I guess there's no.
01:28:35.570 - 01:29:22.990, Speaker A: All right, and the v. Right. So the, what did we say here? End time. So end time we're going to set to none first because we need to look up the s time. And will that always be there? We guaranteed that it's there. I think we're guaranteed that it's there. So start time is going to be temp remove key expect did not have start time for add depth.
01:29:22.990 - 01:30:35.710, Speaker A: Well, this is an unreachable, at least we think that that's the case. Start time four and that's going to be key and then we're going to insert into node. Right. So we're going to do no dot insert. Well, we're going to do key dot end time is equal to some v and v is really time and then we're going to insert. Why does this need to be a map even? I don't think this needs to be a map. I think this can just be a vector.
01:30:35.710 - 01:31:44.180, Speaker A: I think it matters that it's keyed because we just iterate over it anyway. Right. Well, maybe we prune without looking at the time, but I think that's the same. I think this can just be a. Yeah, exactly like I think it's just a vector. So I think let's try to see if we can get away with node being a vector. And then I guess if we want to be really nice in terms of time that we're going to say timed function up depth and that's going to be item is going to be function depth and there's going to be a start time which is going to be a use size and it's going to be an end time which is going to be use and this is going to be a timed function at depth.
01:31:44.180 - 01:32:40.110, Speaker A: This is going to be a function depth look up by key. I guess function of depth is a little bit of a weird name for this. But we're then going to set, I guess key for the time being is going to be a timed function of depth. It's going to have item is going to be key, start time and end time is time. And then we're gonna push key. If we iterate the unique postfix in reverse. Couldn't temp be a stack? That's a good question.
01:32:40.110 - 01:33:37.050, Speaker A: I'm going to go with maybe, and then I'm going to leave it as a map. And then we can always optimize it later if it turns out to be an issue. Why is it complaining about this? Oh, right. And what is this? Right, this has to be tostring this unreachable is complaining about something doesn't implement display. That's because it has to be debug and start time. Great. And then we have to do the same for the other loop, which is going to be ifunc in this enumerate.
01:33:37.050 - 01:34:33.814, Speaker A: And that's going to be also let key is function at depth. And that's going to be, function is going to be func to string. It's a little unfortunate, all these two strings, but I guess we'll just have to live with it. Depth is going to be shared up, plus I, and then we're going to say temp insert key as equal to time. And I guess expect start time already registered for frame. I don't think it needs to be an RC string. I think it can actually just be string references.
01:34:33.814 - 01:35:09.940, Speaker A: I think the trick here is going to be to ingest the entire file into one large string and then only work on slices into that large string. That way they can all be stores. There's no need for a string anywhere. So this would all be not quite allocation free because the map and the vector are allocations, but none of the strings would allocate. I think it's the, it's gonna eventually be the trick. Okay, so you're gonna love this. To dos are great.
01:35:09.940 - 01:35:50.980, Speaker A: All right. Yeah. If we have to sort, we need to build the lines anyway. And especially so the other thing here is for this stack reversal, you also need them. You actually need to ingest the entire thing and resort it. Sadly no method next for option usize because it doesn't have to be next. And that also means that this can just be this great expected use size.
01:35:50.980 - 01:36:14.390, Speaker A: Right. This has to continue. Great. And of course now we decided that node was going to be a vec, right? So here's what I think. This is what I really want to do. I want the type inference to take care of this business. I don't know whether it will, but that's what I want it to do.
01:36:14.390 - 01:37:10.766, Speaker A: This is sadly also going to have to be tostring. Okay, great. So now in theory at least we have this all working. So what we can do now is print out all of node and run that on, I guess, perf data self perl folded and see what happens. Empty, you say? That doesn't sound like what we wanted to happen. Apparently our output is empty. Okay, that seems bad.
01:37:10.766 - 01:38:01.034, Speaker A: What about temp? Temp is also empty. So this suggests to me that we're failing to parse the line. So I guess down here, if ignored, not equal to zero, then eprintline. What's the error? It prints. Let's just make sure we're as compatible as possible, huh? And watch this say like all of them 684 lines. Great. So something ain't right, I guess here we want something like print line debugging.
01:38:01.034 - 01:38:47.900, Speaker A: It's the best thing in the world. Maybe found sample at in there. Samples I line at 286. I mean, that seems kind of sensible found at there. Oh, you're right. I could use debug. It's true.
01:38:47.900 - 01:39:39.840, Speaker A: Oh, it's including the space. That's why, hey, it did something and crashed. Did not have start time for function empty. Oh. Oh. I guess we sort of need to seed it with the fact that the empty stack started at time zero. So we're gonna do that right up here and say temp insert function at depth.
01:39:39.840 - 01:41:22.020, Speaker A: It's going to be, I guess function is going to be string new. So the empty string and depth is going to be zero. And now it's going to complain about this start time already registered for frame. So you're saying I should not have this, huh? Let's see. Did not have start time. I guess what we really want here is just a trace flow, right? So what we want is stored temp four time this key, and then up here we want ending frame like so. And then frame finished.
01:41:22.020 - 01:42:15.594, Speaker A: Yeah, I know. Debug is nice. The biggest problem I have with it is like I could do like debug here, or I guess I could debug here. Maybe that is better. I'm like that causes my output to be more verbose than I sort of want it. And it also means that I can't include context like the time at zero ending frame. Oh really? Oh, that's so silly.
01:42:15.594 - 01:43:22.940, Speaker A: This is why all of the, this is why it passes in this empty thing at the beginning because it needs to match that against the empty thing it's gonna encounter in man. I see. And that's only there for this, not for last. Hmm. I mean, I guess I could chain this. I could say, yeah, I mean, I'll do the same thing. Makes me a little sad, but.
01:43:22.940 - 01:44:12.790, Speaker A: Huh. Did not have start frame. Um. Why would it. Why would it think it needs to have a start? Oh, balls. We're actually. So by doing this trick, if you get the empty string, you're going to iterate over two empty strings with this hack.
01:44:12.790 - 01:46:16.750, Speaker A: The alternative here would be to have flow. Just take iterators instead, which is fine. I mean, I guess we could do that. It's like a little sad, but it'll be fine. Right? This will be li. This will be ti. And then down here, when we call flow, then I guess what we can do is, if that's awful, I don't want to do that because it sort of turns into, if blast is empty, then this.
01:46:16.750 - 01:47:29.130, Speaker A: That's gonna be this regardless. So this is gonna be just iter one's empty, and this is gonna be. I guess this doesn't need to be the peekable can happen inside here. Last peekable. Right. So this doesn't need the peekable part, but it is going to have to be this, which is pretty awkward. Not going to lie.
01:47:29.130 - 01:48:30.186, Speaker A: Um, cannot find. Oh, this should be stuck. Um, compare to. Why is that needed at all? Why can't we just do, um, unwrap or on the remove? I guess it needs to know the start and end of the empty entry, which is basically going to be turned into. All right, so down here somewhere is probably a. Where are you here. If func is equal to.
01:48:30.186 - 01:49:19.720, Speaker A: Yep. So at the root, then you replace it with all. So that's where we're going to end up being. So that's why. So let's see. Inject empty first level stack, frame to capture. All right, so if last is empty, then we want to, I guess, need to special case this because otherwise iter this plus split.
01:49:19.720 - 01:50:09.490, Speaker A: Does that make sense? Right. That's why we need to special cases. Otherwise you get two of them. All right, let's try that. STR is not an iterator. Well, I agree with that. Uh, but why is it claiming that I need stir to be an iterator? String is not an iterator.
01:50:09.490 - 01:50:45.512, Speaker A: That is true. You are correct. This should be iter once. This should be last, which is going to be this, which is going to be this. And that's going to be lost. And then I need an explicit lifetime for the return strings. But I sort of want to say that it doesn't matter.
01:50:45.512 - 01:51:35.380, Speaker A: I sort of want this, but I don't know if it's gonna let me do that. Yeah, fine. I feel like the inference should be able to take care of this because any lifetime is fine because we're not returning anything. Now what? Stored temp four times zero function in front of collapsed death two. How is that the first thing that happened? I think we need to, I think we need some more instrumentation here. We're gonna do something. Where's the call to flow? We're going to have flow of this.
01:51:35.380 - 01:52:17.590, Speaker A: Sorry, this, this, this. And that's going to be, I guess, here. Actually it's going to be empty string, stack and time. This is going to be flow of last stack in time. And this is going to be flow of. I'm actually going to special case this just so we can tell them apart. And same with this one.
01:52:17.590 - 01:53:32.740, Speaker A: So that's gonna be last nothing in time. What do you mean? Argument never used. Oh, yes. So the first thing it does is call flow on an empty previous with that stuff and zero start time already registered for frame. Oh, did I not remove the thing I put up here? No, I did. Shouldn't that be empty? Did I like invert my condition or something? Oh, sorry. This should be none.
01:53:32.740 - 01:53:59.314, Speaker A: Oh, yeah, I have inverted this. This should be. If it's, if it's sum, it's a problem. Great. So this should be this, I guess, or just if let. No, no, not this one. This is not inverted.
01:53:59.314 - 01:54:25.640, Speaker A: The other one is inverted. This one down here. This should be. We should expect that it is none. Not expect that it's some. Is there on option? Is there like I want the opposite of expect? I want like expect none. There might not be one.
01:54:25.640 - 01:55:07.610, Speaker A: That's too bad. So I guess if let, if let sum start time, it's equal to that, then that's more like it. Okay, great. Try that. All right, so this should give us a better idea of what's going on as well because now we actually get busy. The drawing I did, we're now getting the steps for that printed out. Right.
01:55:07.610 - 01:55:37.700, Speaker A: So it's going to store stored in temp for time zeros at the very beginning starts all of these functions. Shouldn't that also include blank? No. Blank is shared. Right. Blank is shared. So it's not going to be pushed. Right.
01:55:37.700 - 01:56:20.628, Speaker A: And then it flows that and to the next one. Where's the comma, comma, comma, comma, chameleon. Where is the argument separator? Am I blind? I'm probably blind. Well, there is one there somewhere. I just can't find it. Hmm. Do, do I not print out both the arguments? I did.
01:56:20.628 - 01:56:31.124, Speaker A: I'm pretty sure I do. Top line after entry. Thank you. Someone spotted it better than me. There we go. There it is. Thanks.
01:56:31.124 - 01:56:57.732, Speaker A: Good catch. Okay, so this is last. And this is this. So now at time one I should probably print the line as well, shouldn't I? Okay, but the time there is one. So at time one it should end stack. Why? Because stack is not shared between this and this. Because this one is infernal.
01:56:57.732 - 01:57:27.910, Speaker A: Collapse stack. This inferno collapse start. So stack does end at time one. That is true. And therefore it creates an entry in our node that is function at depth stack at two. Right. One 20 is the all start time zero end time one at one ending frame libc read right, which is also entered in there for time zero.
01:57:27.910 - 01:57:51.500, Speaker A: And then it panicked. Did not have start time for libc read depth three. Okay, so the depth here is wrong. The depth there is wrong. Function of depth is wrong. That's probably because I'm adding one instead of adding I. Yep.
01:57:51.500 - 01:58:31.350, Speaker A: How about that? Ooh, it ran to the end. That's neat. Well, I mean, it seems to be doing some things. Great. I'm gonna just take all these eprints and comment them out because actually we might want to keep the calls to flow. I think those are going to be handy. We're going to ignore these though.
01:58:31.350 - 01:58:49.562, Speaker A: We're going to ignore that. And we're going to ignore that because they are verbose. But I think the calls to flow we can key. Oh, and debug. See, I can't just comment out debug either. That's a little sad. I actually said add I, but row plus one.
01:58:49.562 - 01:59:48.330, Speaker A: Great. Good job, me. Oh, these are too annoying. That's too bad. All right, so now, at least in theory, we believe that we have the correct contents in node. And so now we've done all of, so we're now like here basically, right. And I guess here if time is zero, so if there are no samples, then we do wherever this business is, which is print out this, this sure does some stuff.
01:59:48.330 - 02:00:14.848, Speaker A: Header. What does header do? So it's an SVG function they have up here somewhere. Header. I see. Seems fine. So there's always a header. So I guess what we'll do is SVG.
02:00:14.848 - 02:01:02.760, Speaker A: And now we need to look at the SVG docs. How do I create a comment? Is really the node element. Really? Can I not inject comments? That's kind of awkward. That seems awkward. Really? I can't append a sign. Um, well then stop. What's a stop? A stop element.
02:01:02.760 - 02:01:56.110, Speaker A: No, that's not what I want. Or really are none of these comments. I guess I could inject a script, but description desk element. Hmm. I guess this should probably be a comment. Well then I guess what we're going to do is we're going to do, let's go back to this. So a document is an SVG and SVG has add and set.
02:01:56.110 - 02:02:58.070, Speaker A: So we're going to do add svg nodes, right. Node description new. Node element description new and what is supposed to be under a desk. Core attributes. So I guess probably visible text. And we're going to do something like header add and we're going to have to figure out how to add text. Is there an easy way to add text or the only annoying way is to add text.
02:02:58.070 - 02:03:57.850, Speaker A: Can I add just like text directly? Because that would be great. What implements node does text implement node text node, sure. Add svg node text new this and then I'm going to do this. Break up that line a little and then we add a header variable does not need to be mutable. I feel like that's a lie. I think it does have to be mutable. I think it's lying to me.
02:03:57.850 - 02:05:08.720, Speaker A: Use of move value header header was moved here. Really? You're telling me that if I have a node like description and I try to add to it, it consumes self. Why? Oh it's for easy construction. It's so that I can do SVg. Add this, dot add this. It's so that I can do that. And SC, that's just annoying though.
02:05:08.720 - 02:05:45.838, Speaker A: There's also node which has assign append a child node. So I guess here I can use appenditive is probably then what I want. And I'll have to import this trait. That seems fine. Great. We successfully made an SVG. Well it's sort of a builder pattern but it's like a little bit weird that it, that it doesn't take mute self and return mute self.
02:05:45.838 - 02:06:50.550, Speaker A: There's a little bit more common, although I guess if ultimately you're giving it to an append then like I guess it's fine. All right, so here there's this, right? So where were we? We're making sure that we append this. There's an header, it's saying we also need these things, right. So we need to figure out what to set for these. So SVG was it set on node assign with two something? We don't know what that is yet. Does that return mute self? No, we don't know what these values are yet, but we know that we'll have to set them. Assign load.
02:06:50.550 - 02:07:44.470, Speaker A: Wait, did that really just say load and not onload? No, it's unload sign view box to be that. And I guess these we can probably stick up here as well. So where does with come from? So I guess header takes image width and probably the same here. Okay, so where does image width come from? Sign. Good catch. Thanks. So where does image width come from? Image width seems like something we need.
02:07:44.470 - 02:08:52.528, Speaker A: So we're gonna set up here, gonna be 1200. And where does image height come from? Ah, it's computed from font size and depth max and frame height and ypada. Okay, so it sounds like there are a bunch of these like size parameters we're going to need, right. We're going to need like probably these. Let's just like grab those for now. Isn't there at least one more we need? No, I guess Max depth. These depth.
02:08:52.528 - 02:09:30.960, Speaker A: Max. So where does depth Max get set? Oh, that gets further down, but. Oh, interesting. Okay, so these all get set to something. And this gets set to something. And this is this. Great.
02:09:30.960 - 02:10:17.040, Speaker A: All right, so now we have a bunch of variables that we're probably going to need later. And here image width, do I need to convert this to something or can I into value? Great. So I can just say image width here. I guess that is always set. And that is always set. These, we're going to have to set ourselves down here. Specifically, it's going to be set here.
02:10:17.040 - 02:10:58.330, Speaker A: And that's going to be image width and image height. And we don't know the image height yet. And this is going to be image height. And so there was some code here for setting. Right. Image height is going to be font size times five. And then there's this, whatever that does.
02:10:58.330 - 02:12:06.500, Speaker A: And then it prints the SVG and then it exits with an error. Hmm. So as we, what we probably do want to do here is like return error. Well, yeah, I'm not quite sure. I think we want to do that error from, I guess probably something like invalid input or invalid data, maybe no stack counts found. And now we just need to figure out what this text writing is. Right.
02:12:06.500 - 02:12:48.270, Speaker A: So it's whatever this is. And specifically we're probably going to want some kind of wrapper like this for, for strings, though maybe not. I feel like many of these are just gonna always be the same. Right? So string TTF. Are they generally always font type, font size. That fourth argument seems to always be 0.0 angle.
02:12:48.270 - 02:13:18.430, Speaker A: Okay. Int image width divided by two. Is that always image width divided by two? No. I see. Hmm. So what we probably want here is like some kind of handy struct for writing text. So we're going to have a struct write text.
02:13:18.430 - 02:14:18.204, Speaker A: It's going to have, I guess, color, which is going to be a string. What else? Size, which is going to be a string. X is going to be probably going to be a useize, come to think of it, y, which is probably going to be a use size text, which is going to be a string. Location, which is going to be a string. And extra, what is extra? What is that ever used for? Middle. That is the extra part, right? No, that's location. Middle.
02:14:18.204 - 02:14:49.820, Speaker A: Middle. Oh, it's like additional arguments. I see. Sure. And I guess that can be an option if we really want to. And then we'll have string is going to be, it's going to take a SVG, which is going to be a mute SVG document. And.
02:14:49.820 - 02:15:56.810, Speaker A: Yeah, I feel that way too. Dutch ghost that like other languages are now scary because I can't say whether things are immutable or immutable or what returns what, like reading pearl code for example, you sort of need to guess at types and return values and it's pretty, pretty unfortunate. Okay, so we want this closure to take the svg and a description of the text. And what it's going to do is basically what string TTF does. Right? Wait, does stringtdf ever get called without location set? Because it defaults location. Location is the thing after the string. Middle, middle, blank, blank.
02:15:56.810 - 02:16:58.672, Speaker A: Okay, so it does get, it is blank sometimes. Fine. So what we want here is svg dot. Oh, see normally you probably want it within a group, right? So here you never enter a group, whereas here, here you're also not in a group, but down here you are in a group. I see. So you may or may not be within a group. And so I think what we want here is then just parent and that's just going to be some SVG node and you don't know which is that exported through the great.
02:16:58.672 - 02:17:20.480, Speaker A: Yeah, I think that's what we want. Biggest, scariest stuff is copy or borrow. Yeah, interface. Oh, interface and go lang is. Yeah, I've had some pain with that. That's definitely true. String DTF.
02:17:20.480 - 02:17:54.010, Speaker A: All right, so what it's going to do is it's going to create a text which is going to be SVG nodes. Right? Nodes node, text, new. No, it's. Damn it. It's not actually going to be, it's going to be a node. Text. It is not going to be a text node.
02:17:54.010 - 02:18:39.220, Speaker A: It's an element that's a text. And I guess it's going to be text new dot, add svg node element. No, no. Text, new text, dot, text. I guess this is going to be item. So I guess we'll make this text item, right. So we're, this is just setting the content part.
02:18:39.220 - 02:19:06.260, Speaker A: Right. And then we'll want to have. Is it assign? Was that what it was called on node? It was assign and append. Yeah. So we're going to do. But on tech on here, it's set. That is such a weird interface.
02:19:06.260 - 02:20:10.530, Speaker A: Okay, so we're going to set, we're going to set text anchor to be parent, location, unwrap or left. We're also going to set x to be x is in fact an f 64. Is that even true? I don't think, I don't believe it. Here it takes the integer value, right? Takes the integer value of what it is about to pass in as x. Same here. Same here. Oh, xpad.
02:20:10.530 - 02:21:00.358, Speaker A: Okay, fine, fine. It'll be an f 64 then. X is going to be format 0.2 of parent x. But it doesn't do the same for Y. Why? Why does it not do it for Y? Why does it round x but it doesn't round y? I mean, if it says so font size, it's going to be parent size. No, these should, none of these should be parent.
02:21:00.358 - 02:21:46.038, Speaker A: These should all be item. And ultimately this doesn't have to say text. This can just be parent dot this. No, I think we do need to be text actually for extra. So xy one family, which we're going to set to want family. Really. What's it called with font type? Is that what it's called? And font type defaults to verdana.
02:21:46.038 - 02:22:19.960, Speaker A: So we're just gonna make it be that for now then. Where are you svG. There we go. Fill is gonna be color. Fill is gonna be item color. What am I missing? Also notice that angle is passed in, but it's never actually written. It's just unused.
02:22:19.960 - 02:22:45.590, Speaker A: It's like an argument you can pass in that is entirely ignored in the entire program. That's good. Okay. And then it's extra arguments. So I guess extra. I sort of want to be an iterator. So I think what we'll do is might as well, I guess here it's going to be an iterator.
02:22:45.590 - 02:23:55.690, Speaker A: Item is going to be string. And actually I guess we don't really know what is it used for. That doesn't have any extra, that doesn't have any extra id is details. Okay, so it's a bunch of pairs and it's probably fine to require that they're all strings, but are there any that are not key value pairs? No. Great. So then it's probably going to be just this and extra, it's going to be I and now that's going to be text. And then for key value in item, extra text, dot assign key value and then we're going to do parent append text.
02:23:55.690 - 02:25:01.830, Speaker A: Why is it complaining about this wrong number of type arguments? Really? I can't omit that and have it just infer it because that's what I want. Oh, it's not going to work is it? That is not going to work. It's going to have to be a generic function. I think it's a little awkward, but fine. No method set for stringental. That's because I'm missing these image height. All right, we haven't done this yet.
02:25:01.830 - 02:26:10.020, Speaker A: It's going to be zero. And append cannot be invoked on a trait object. Really? Are you for real? Requires the self is sized. Well shit. I think this just means that this really has to be a generic function. So it's going to have to take a node and a iterator. It's going to be a mute n and an item which is going to be a text item, I where n implements svg node and I implements, which also means that the struct that I made has to go here.
02:26:10.020 - 02:26:56.560, Speaker A: It also means that this bound I can just steal and place here like so now I don't need that anymore and I can have it do this. Now why is complaining? I expected one of those. That's because there's an extra comma, now it's complaining about expected zero. Found one. Oh, it does still have to be generic. Over I undeclared lifetime. That's fine.
02:26:56.560 - 02:27:17.160, Speaker A: Great. Okay, so that works. So now in theory we should be able to write out strings. Yay. In particular, what's the string that we wanted to write out in the first place? How do we get into this business? It was by trying to write out the error string. Just like up here somewhere. Yeah.
02:27:17.160 - 02:28:08.840, Speaker A: So we want a color. Yeah. So the other thing we're gonna have to figure out is colors. We might actually want to use a color crate for this, but I think for now I'm just gonna hard code that. So we're gonna do write SVG string, we're gonna pass in mute svg and textitem where we're gonna have color is going to be rgb zero zero, which is just black. You're going to pass in font size, which is going to be font size plus two because who needs things to be consistent? And font size we've already declared up there. Great.
02:28:08.840 - 02:29:03.800, Speaker A: This is going to be size. It's going to be font size plus, plus two. Image width divided by two is going to be x and Y is going to be font size times two. The text is going to be this, probably not. Pl location is going to be sum middle and extra is going to be none. I think that should work. Option is not an iterator.
02:29:03.800 - 02:29:42.630, Speaker A: Really? Is option really not an iterator. Feel like that's false. Since when doesn't it? I'm almost positive that that's not true. Oh, it's into iterator. Fine, fine. We want into iterator. Expected string found integer.
02:29:42.630 - 02:30:45.266, Speaker A: I think size can probably just be a usize x and y expected f 64. Yeah, I mean, I guess actually let's do f 64 from that. From you. Size is not implemented for f 64. Really? Oh, fine. Image with huh, fine. I guess it'll be this f 64.
02:30:45.266 - 02:31:52.570, Speaker A: It's basically complaining that I'm typecasting to a type that might not have room to fit all of you. Size, as in not every us size, can be losslessly turned into an f 64, which is true. Great. So I guess this means that if I run it with standard in and give it no input, what does it do? It says, did not have a start time. Oh, it crashes here. I don't know how to fix that. Basically the issue is it gets, although initially, yeah, it never, although it should still add this to temp, I guess.
02:31:52.570 - 02:32:12.600, Speaker A: Fine. Come back, my pretties. Come back. Come back you beautiful creatures. Actually, they don't need to be. There, there. Alright, let's see what it says.
02:32:12.600 - 02:33:43.402, Speaker A: Oh, I see. It immediately goes to the last one. Why doesn't that crash the perl script? Oh, it doesn't assert that the thing it gets out is empty. So I think the workaround here is probably to be oddly specific and say if key dot function is equal to nothing and key dot depth is zero, then return zero didn't, ooh, that's, oh no, this is even, this is even sillier down here. We should only call this flow if not last is empty. That's really what's going on. Yep.
02:33:43.402 - 02:34:17.360, Speaker A: And so now it correctly gives us some text output, I guess let's stick that in fail Dot SVG, and then let's open fail svg. Hey, it gave us an svG. We did it. We have an error SVG. Now let's see if we can actually make this work when things are non empty. It's really what we're after now that I want. Great.
02:34:17.360 - 02:34:42.238, Speaker A: This bit. This currently prints nothing. Great. So now we're past this sort of slightly boring bottom one. I guess there's some time max stuff that we're going to ignore. This add a debug flag. That's true.
02:34:42.238 - 02:35:30.390, Speaker A: I should do that arguably for all of this I should just add logging, but I think it's not sufficiently important to spend time on it. It's something that we will add later. This code is going to be cleaned up regardless because we're going to move things into state, is going to be moved out to some external struct and stuff. And once we do that, then that's going to help us clean up a lot of these things. Do you sometimes debug by stepping through the program with something like GDB or is it usually print debugging? I very rarely go to GDB for these types of things. It's because I don't think it's more efficient. It might be, I don't think it's significantly faster.
02:35:30.390 - 02:36:16.450, Speaker A: I do it if something seems really weird and I cannot figure it out. But usually print debugging is totally fine. It's probably mostly because of habit, more so than because that's like better in any way. Okay, so they have time Max. Time max is time. Is that what that argument was called? So just time Max. Wait, total.
02:36:16.450 - 02:37:01.270, Speaker A: Why are they named different things? And why is total not documentous? Alright, so back to that then. So down here, the next thing we do is time Max is that. And then we compute these. Do we have a minwidth, is that a thing that we define? Yeah. Cannot divide, float by you size. Sure you can. Just try harder.
02:37:01.270 - 02:37:42.870, Speaker A: You did it. Oh, actually I probably want this one to be width per time. This to be an f 64 is probably what I want. Because width per time, we're going to multiply by the time. And so the fractionals actually matter when we do this division. Otherwise you get quantization of the widths. Prune blocks that are too narrow.
02:37:42.870 - 02:38:20.580, Speaker A: Okay, sure. Prune blocks that are too narrow. So this is really just walking through. And this is just retain, this is just node retaindeh. And this is now a vector. So we don't care about that. This is really just, each node is a, I guess we could call it a location.
02:38:20.580 - 02:38:46.700, Speaker A: What do you want to call each of the boxes? Naming. That would help a lot. Like what? What do we call each one of these? Because they're not a stack. A stack is the whole thing. They could be an item, I guess, but that's sort of generic. We call it like a box, but that's relatively uninteresting. A frame, I guess frame is good.
02:38:46.700 - 02:39:32.210, Speaker A: Well, it's not really a node because a node is a node in our SVG. So I think this frame is pretty good for this, actually, frame is better for that. But just say that that's a frame. And notice we don't have to do the splitting anymore. We don't have to do that because we already have the start time. And so all we're going to do is we're going to retain it if. Oh, and they also do depth max is going be node, depth max is going to be zero.
02:39:32.210 - 02:40:44.310, Speaker A: And then down here we're going to say if frame dot end time minus frame dot start time is greater than min, with time is keep. Actually, no if. If it's less than minwith time, then true otherwise. Then false otherwise depth max is going to be of depth max and frame dot item dot de. So we're just keeping keeping running track of the highest, the maximum depth, because that's how we're going to determine how tall the plot has to be. Right. So notice here the image is as tall as their stacks.
02:40:44.310 - 02:41:28.750, Speaker A: Can you zoom in a bit on the code on GitHub? Yes, I can indeed. Better node name already being claimed by svg. It's also not really a node. Right. I like the idea of frame because if you have this stack, then each of those is a stack frame. Where it gets weird is the question is function a depth of frame or is timed function a depth of frame? And I think this is a frame. Timed function at depth is going to be frame.
02:41:28.750 - 02:42:28.542, Speaker A: And then the question is, can we come up with a better name than function at depth? Function add depth is really a. What is that? It's a. Okay, the other way to do this is actually call this a timed frame. Yeah, let's do that. This is a timed frame and this is a frame. Yep, I like that. And then this can still be framed.
02:42:28.542 - 02:43:11.070, Speaker A: That's fine. Right? Can I really not compare integers to f 64s? Which direction do I want this to go? I guess maybe this way. Did I make rust? No, I'm going to go pretty far from it actually. Oh really? I mean, but look at what the compiler did there. It was like, this is now interpreted as a generic. That's probably not what you want to use this. It's kind of cool.
02:43:11.070 - 02:43:54.208, Speaker A: This should be standard compare Max. Great. It's also fun that this working. Is it producing empty SVG? All right, so now we have this bit draw canvas and embed interactive JavaScript program. Great. This is going to be image height, is going to be depth, max frame height, ypad, ypada. And there's like some subtitle text that we don't care about.
02:43:54.208 - 02:45:33.480, Speaker A: The header we've already dealt with that is the header and now there's this business which is like a bunch of script stuff, and here we're going to have to be a little bit careful. So what it's doing here is pulling in a bunch of JavaScript code, which is fine, but notice that the JavaScript code does have some, some variables from the run in it. I think the way we're going to run or work around that is we're going to have one, I sort of want this to be an external file. Right. So actually let's just go ahead and do that straight away. So we're going to take this entire block of JavaScript to here and we're going to edit source, flame, graph, flamegraph, JSDEV, and then what we're going to do up here is we're going to use include STR, which lets you include a file directly into the binary. Right, which is what we actually want here.
02:45:33.480 - 02:46:27.560, Speaker A: But we're going to have to do that a little bit carefully because we need to wrap it in the appropriate tags. I don't know what defs is. What is it? Defs definitions. If you say so. So I guess here we're going to do SVG dot append and we're going to append these things in order. We're gonna append a svg node node element, I can never remember node element definitions, great definitions. New that has added a node, no, svg node element.
02:46:27.560 - 02:47:10.960, Speaker A: Linear gradient, what is that called here? Is it called linear gradient? I really wish this provided this svg crate provided nicer constructors that were based on what the field actually was. There are other svg crates, svg rendering library. That's not what I want. Fine, I guess we'll just use svg then. So linear gradient probably also just has a new and add. Fine. Okay, so we're going to have that new.
02:47:10.960 - 02:48:53.800, Speaker A: What else is in here? So that on that we're going to have to do set id background. Let's just get this formatted correctly. Set y one is zero, set y two is one, x one is zero and x two is zero. And we're also going to add a svg node element, element stop new dot set stopcolor bg color one, whatever that ends up being, and set offset to 5%. And then we're also going to add one that is 95% and that's going to be bg color two. That's our defs. We don't have a bg color one, so we're going to have to find that.
02:48:53.800 - 02:49:42.224, Speaker A: Fine. This, this is another thing where like we're gonna end up with themes at some point and that I'm gonna leave for later. Cause it's like not interesting to deal with right now. Great. And not that, what is it complaining about now? Oh, right, that's fine. Flamegraph js. I think it's relative to the current file.
02:49:42.224 - 02:50:38.210, Speaker A: Great. See, so now we've got our defs. So that's what we wanted. And then we're going to have a style. So we're going to have basically this entire same thing, except we're going to add a style. And under the style, let's see, that's going to set type text Css, add svg node text, new this business, right. And then comes the script that's going to be a node element script where we set type to be text eCMascript.
02:50:38.210 - 02:51:33.960, Speaker A: And we're going to have a text node which is going to contain what is in that file. Right? Am I missing a what is wrong takes one parameter. Ooh, why does it take a parameter? Why does this one take a parameter as opposed to all the others? Well, I guess that takes the content. We still probably need to set the type though. How's that? Ooh, style also takes its argument directly. I mean, that is kind of nice. Just make it a little better.
02:51:33.960 - 02:53:26.796, Speaker A: It didn't drop it in c data though, which is a little disturbing because I thought the whole point was that it should do that. Um, is there not a C data data? A data attribute path data? Huh. Okay, so we may have to place in the C data bit ourselves, although I think you can just concat the c data ourselves. What do you mean? C data in XML? So that seemed to work about right. What we still have to do though is figure out, also I want this to be there. Oh, apparently it does not. Okay, so that means we now have the JavaScript, we still have this issue of there are a couple of things here that are of basically anything that contains a literal dollar sign is a variable that is supposed to be taken from the external context.
02:53:26.796 - 02:54:38.450, Speaker A: I think what we're going to do is we're actually going to declare those in a separate JavaScript block that we dynamically generate and then we have those be variables that are available in here, right? So there's going to be name type. So I guess what we'll do here is this format and then it's going to be this, and then in here there's going to be a, what's it called? Name type. Name type is going to be equal to something? We're not entirely sure yet. Oh man, that's awful. Can I please have this be nicer? None of these are really all that much nicer. Right. So what else did we need? There's nametype, so now this can just use nametype instead.
02:54:38.450 - 02:55:12.858, Speaker A: What other dollar signs do we have? That's not important. Font size and font width. Font size and font width, those are going to be globals that we don't care about. Exped we need, it's going to be global. Expat is fine, expat is fine. Expat is fine. Expat is fine.
02:55:12.858 - 02:55:52.320, Speaker A: Inverted, I guess VAR inverted is going to be false. Search color. Search color. It's going to be something. All right, great, so those are the only variables. The remaining now is just like regular JavaScript code, which we can now keep and edit in our own file, which makes it nicer than having it directly in line like the Perl one does. We do need to figure out what name type is though.
02:55:52.320 - 02:57:01.350, Speaker A: Name type is only used there. Okay, so name type is going to be function. Oh, this is, that's fine. Font size. Font size is presumably just going to be font size, and it's a number, so it doesn't need to be quoted. Font width is the same, xpad is the same, and search color it's gonna be, that has single quote strings as well. That is true, I suppose.
02:57:01.350 - 02:58:08.130, Speaker A: I mean, does it really matter to us? Is this really better? Not convinced that that's better, but sure. All right, so now we have all of that taken care of in theory, like when this now generates a JavaScript to generate two script blocks, one that declares these variables and then one that later uses them. And I guess actually this is going to need to have new line there and a new line there. I also want this to not be indented. Oops, whoa, that's not what I wanted at all. It's a little awkward, but great. This is a, I sort of want to remove this from inline in drawing the SVG, but again, we're going to tidy this up with functions later.
02:58:08.130 - 02:58:26.478, Speaker A: Okay, so we've now got all the way past the JavaScript, so there's not that much left. Right. There's only really printing the stack itself. Include ink. Okay, so that's just adding that string and there's a filled rectangle. So it looks like filled rectangle is a thing. We're going to be using a bunch.
02:58:26.478 - 02:59:04.310, Speaker A: Right. If we look at filled rectangle. Filled rectangle, filled rectangle. But I don't know that this function is worth extracting out because it doesn't really do anything all that interesting. Yeah, I guess we could keep it around. Sure. Let's just sort of remind ourselves that this is a thing that exists by doing this.
02:59:04.310 - 03:00:13.458, Speaker A: Get rid of that and filled rectangle here. So now we're going to set up the background, which is just going to be SVG, I guess, appenditive, no element rect. Or I guess there might be an even filled rectangle here. Nope, just rectangle. It's going to be rectangle new and then it's going to have all this stuff on it. And specifically in our case it's going to have set x to be zero, set y to be zero set. Right.
03:00:13.458 - 03:00:55.440, Speaker A: Those are the first two arguments, x and. Yeah, just printed with point one, which doesn't really matter to us. Then image width and image height, which is going to be image width minus zero because of this business, which is just going to be image width. So that means that what this really is. Oh, but that is width though. Hmm. Image width, set height to be image height, set fill.
03:00:55.440 - 03:01:41.940, Speaker A: To be fill, which is this great. So that sets the entire background. There's no extra great. And then it defines a bunch of colors, which we don't really care about. So there's title text. What is title text? Title text by default is nothing. So title default, that is.
03:01:41.940 - 03:02:33.078, Speaker A: So now we're going to do, we're going to do our writing, which is going to be directly onto the SVG with a text item. And certainly the text is going to be this. The color is going to be black, which is going to be rgb zero. Zero. The size is going to be font size plus five. This is going to be image width divided by two. Right.
03:02:33.078 - 03:03:52.620, Speaker A: That's the same thing we did up here for the, for the error case. It's probably going to be the same, right? Yep. So these are mostly the same we don't have a subtitle text, and then we write out whatever this business is, but we have to write it. But see, even here, I think that this rust code, even though it's longer in terms of number of inverted, is zero not false. Oh, is this for the include? You are right. Well, is zero here intended to be false or true? Zero is intended to be false. So I think what I want this to be is this.
03:03:52.620 - 03:04:35.190, Speaker A: And then this. This used to say equal equal zero, which is just the same as not inverted. Yes. Which is weird. The negation of inverted, I think. That's right. What I was going to say was I think this is easier to read than this.
03:04:35.190 - 03:05:33.750, Speaker A: Right. Even though this is shorter because it's one line. I think this is like, it's much clearer what's going on here. Font size is going to be normal, black. X is going to be expad, y is going to be image height minus ypad two divided by two, because of course it's going to be text is going to be space, location is going to be some empty, which is none. An extra is going to be it, or once of id and details. Right.
03:05:33.750 - 03:06:20.510, Speaker A: And probably these need to be SF 64, ypad two times three. That's fine. I mean, arguably these could just all be f. It would be fine. Okay, what's the next thing? Reset zoom. All right, I. So that's expad.
03:06:20.510 - 03:07:43.220, Speaker A: This is font size times two, which is also going to be SF 64. Text is going to be reset zoom, and then it's going to be something like id unzoom on click, unzoom this. The other thing that's nice here is we get escaping just like for free, which is pretty neat. This is gonna give me not what I want. It's gonna give me a reference to tuples in the iterator, which is also pretty annoying. So I'm not actually allowed to do that. I have to make this a vector even though, man, that's unfortunate.
03:07:43.220 - 03:08:12.070, Speaker A: I could use a borrow or an asseriff in the traits, but I don't think I can be bothered. So fine, we'll do that. We could also chain iters, so, but we could do this without allocation, but unclear that it's worth it. And I guess this we don't need anymore. For reference. This we don't need anymore. And this we don't need anymore.
03:08:12.070 - 03:09:03.120, Speaker A: So what's the next thing we're writing out? Font type. Font size x is going to be image width minus xpad -100 it's going to be y is going to be font size times two. This is gonna be search. This is gonna be empty. It's gonna have id. Search on on mouse over, search on mouse out, search out. Now search over, search outdoo on click is going to be search prompt.
03:09:03.120 - 03:09:55.330, Speaker A: Style is going to be this, which is maybe the same. No, not quite. No, that's not what I meant to press. I meant to go left. And there's one more, one more before we get to actually printing the data. Image exped zero. This is the y is going to be image heightendeh minus ypad two over two.
03:09:55.330 - 03:10:38.140, Speaker A: Wait, was this already. Yeah, that's the same as that. Okay, ypad two over two as f 64, empty text, empty location. Extra is gonna be id is matched. Oops. Matched. All right.
03:10:38.140 - 03:11:19.640, Speaker A: All right. And we're gonna ignore the palette. I wonder what this now gives us. Like, if I write this to, what did we call this? Okay, SVG. Well, we do get a flame graph, and it does seem to have some kind of height, I guess. Let's figure out what we're supposed to compare against flame graph of that to compare. Okay, so the height seems to be correct and things seem to be in the right place.
03:11:19.640 - 03:11:50.930, Speaker A: So that's pretty promising. The background doesn't seem quite right, maybe. Yeah, I don't think the background seems right, which is a little interesting. Bg color. Yeah. So this one. Oh, we have a different, that's why.
03:11:50.930 - 03:12:24.874, Speaker A: So why, why did we get bg color one wrong? Bg color one. Oh, I don't know how I missed that. Must have looked at some conditional somewhere. So now, great, so now you see the only thing that's missing is the frames. And everything else seems about right. So that's a good place to be in. And now we get to the business.
03:12:24.874 - 03:13:07.938, Speaker A: Now we're going to actually draw the frames. Yeah, draw frames. Okay, so for every frame in, can we, instead of having this be called node, like, instead of having this be called node, can we just call it frames? Oh, man. Searching for node here is going to be frames. Push frames. Frames, frames, frames, frames. Node, node, node, node, node.
03:13:07.938 - 03:13:33.380, Speaker A: Great. Four frame and frames. Let's see what we got to do. We don't need to split a, because we already have it separated. We don't need to do this because we already have the thing. End time is time Max. I don't think that's necessary.
03:13:33.380 - 03:14:19.590, Speaker A: I don't think we're going to have to do this. Oh, I guess it's, if time Max is greater than time, then etime has to be increased. That's fine. We don't care about that. And if not inverted, this if not inverted business is really throwing my head for a spin here. Wait, these are constants, right? Oh, depth. They are not constants.
03:14:19.590 - 03:15:26.560, Speaker A: Fine. They're almost constants, but I guess not. So that means this can go away and we can say let here. Great. It's going to complain about, right? It's not s time, it's frame start time and frame end time and frame depth. Probably true. And then down here, this is frame dot.
03:15:26.560 - 03:16:05.840, Speaker A: I feel like instead of item that should be called location. Just seems more, seems more correct. Great. Now we have the values of what is factor. Seems scary. Factor is one. So that's not that bad.
03:16:05.840 - 03:16:38.582, Speaker A: If in doubt, set factor to one. So that is just samples. Samples is frame dot n time minus frame dot start time. Why are we computing this over and over again? We're computing it for retaining as well. We might as well just compute this when we first construct it. Like memory is not going to be the main thing to deal with here. Add commas, perl per pearl.
03:16:38.582 - 03:17:59.000, Speaker A: Fact five. What? I'm gonna guess that it's this thing. Yep. Great. We'll add commas to numbers. I don't understand why this is necessary. Like is it, is this actually just adding a comma to the end of the string? Like why is this different? Plus or minus any number of digits followed by three digits? Oh, it's a thousands separator.
03:17:59.000 - 03:19:14.550, Speaker A: It's adding thousand separator. Isn't that the default for if I do, like, if I do this for like, what will that print? Isn't there a separator? Hmm. The separator crate. Because of course there's a crate. That seems fine. Actually, I sort of don't want that. It seems like a very unnecessary dependency because all we really needed for is use size.
03:19:14.550 - 03:19:57.590, Speaker A: Also. That is not an efficient way to do that. Okay, but where's the macro? Macros? That is very inefficient. I'm glad we don't do that really. If the tolnai has one, then it's probably good. Thousands. Do you mean this one? Because that's a great name for one of these.
03:19:57.590 - 03:20:37.530, Speaker A: Digit group Stu Reese. No recent downloads. Uh, that one. Maybe there are too many of these. So I don't want to use separator because it's allocating two strings for every time it's doing it. Oh wow, that's awful. I don't want to do that at all.
03:20:37.530 - 03:21:50.470, Speaker A: Where there's this, what does that do? And stack allocated strings. Whoa. Except it also allocates a vector. Huh. I mean, I guess feels silly to like depend on a crate for something like this, but I guess maybe thousands. What does thousands do? Source lib. Separable.
03:21:50.470 - 03:22:48.460, Speaker A: So this first prints it to a string and then creates a new string and then walks that. That seems unfortunate too. Is there nothing that does this directly? Oh, human. Yeah, that's good. Floating point to string conversion. Oh, this is probably the detolk knight one you were thinking of. But does it also work for integers? Because that's all I need.
03:22:48.460 - 03:23:31.962, Speaker A: Performance. Great. It's a really fast way of printing things. That's good. But does it print integers, buffer, new format, floats? Nope. Human was a good search though. Human time, human size, that's file sizes friendly time.
03:23:31.962 - 03:24:43.720, Speaker A: Print messages for humans, human size, human readable strings, but that's even fewer downloads. Well, so the other thing to search for is itoa. Fast functions for printing integer primitives to an I o. Right, great. But does it, does it allow me to do comma separated ones is the real question. Oh no, this is just, this just prints the number directly. See, that makes me sad.
03:24:43.720 - 03:25:40.040, Speaker A: So pretty. Toa does call into itoa. So I think we're just gonna go with this one and it's gonna be fine. It's like not worth spending that much time on. So we're gonna use this and then we're gonna do thousands sep. And what was the, where were we here? Because sort of what I want is the ability to just print instead of allocate. Right? Like this is going to give me back a string, whereas really all I want is to.
03:25:40.040 - 03:26:43.160, Speaker A: Well, I guess we do need a string to pass it to svg, so maybe it's fine. Anyway, my info so letinfo is gonna be if func. No, if frame dot location dot function is empty. Okay, great. And frame location depth is zero. Then we want this, right, so this is where it's a little unfortunate that we have to create a string for samples text and then we have to create a second string down here. That seems sort of unfortunate, but I guess we'll survive.
03:26:43.160 - 03:27:47.112, Speaker A: What is count name? Oh, it's for like internationalization or something probably. Yeah, great. So we're not gonna have count name, I'm just gonna say samples. Otherwise do whatever is down here, which is. Hmm. Oh, I see a lot of code coming up that we're not gonna have to write, which makes me happy. Yep, I guess.
03:27:47.112 - 03:28:39.200, Speaker A: Why are we writing time max up here? Okay, fine, we'll keep this line just because we already have time max defined I if. No, actually I don't want to do that. Never mind. See down here it's escaping things for SVG. But we don't need to do that because we're using an SVG library. At least that's the idea. I mean, I assume that it will escape attributes correctly, otherwise it's being weird.
03:28:39.200 - 03:29:57.572, Speaker A: This is an if not so that is indeed the thing we want. So format that this samples, was it dot two? Yeah. And so we want to format frame location function and oh, this does need samples text. This needs sample text and also percent. One thing that's weird here though. Oh, I guess we do want that strip annotations. We're going to want to strip out annotations.
03:29:57.572 - 03:32:01.550, Speaker A: So I think what we want is de annotated is frame location function. If let sum AI is de annotated is sure rfind square bracket if AI is, well, we sort of only want to look at the, there's no reason to scan the entire function name, but it's probably going to be cheap enough anyway. It's probably not going to matter. If it does matter, we can fix it later. If d annotated AI dot dot is equal n squared 1234 and de annotated dot ends with a. I guess this is really if the annotated dot ends with, see, this is where I want chained while let patterns which are on their way but not there yet. So if it ends with square bracket, then we find the matching this if there is one, if that is for long, and de annotated AI plus two, dot AI plus three.
03:32:01.550 - 03:32:44.230, Speaker A: So that is the character that is in between. Is there like an is one of, because that's sort of what I want here. I want to check whether it is one of these characters. Um, aha. Yep. Then the annotated is equal to de annotated dot a. And this should say de annotated.
03:32:44.230 - 03:33:31.858, Speaker A: I wonder why it de annotates. It's like not entirely clear to me why, why that's necessary if not defined. Delta. Delta is not defined. So that should be correct. What is this shallow clone? Oh, this is so name attor, if you remember, is also an option that users can give to set additional fields to be set on basically all svg attributes or function attributes, file holding function attributes. Whereas for us, every g is just going to have these fields.
03:33:31.858 - 03:35:02.330, Speaker A: That's all that really matters to us. So therefore what we're going to do next is create our g. So we're going to say group is going to be actually it's just going to be svg append svg node element group new dot set. So we want class to be func g we want onmouseover to be s this we want onmouse out to be cdna we want onclick to be zoom this we want title to be info. And it's not quite all we want, but it's a good start because we also then want to append stuff within that. Right, so that's just the group start. I guess we do need to check whether there's anything else in group start, but I don't think so.
03:35:02.330 - 03:36:14.640, Speaker A: That's just turning the map into a string that is like key equals value. If there's extra, then add extra, add g with the attributes, then add a title element. Oh, I see. Only these are added as attributes. Class on on mouseover on mouse out on click. Title is not, there's also style, which we're ignoring. So then it's also add a title element that contains the title only if there's a title, why would there not be a title? Other calls to group start that don't have a title, I don't think that's possible.
03:36:14.640 - 03:37:10.550, Speaker A: Should be the first element within the g container. I mean, that's fine. So svg nodelement title. So I guess let's find out whether title is one of those special ones that always takes a value. No, it is not. So title new add svg node text new info what else does it do if href oh, I see. So one of the things you can do if you have this custom files, you could set hrefdhe specifically, you would set a name adder for that particular function.
03:37:10.550 - 03:37:39.340, Speaker A: So there's like an href for it, for example. So that when you click it, you go to say the source code of that thing. But that's not something we currently care about. Perl is really a write only language. Yeah, I mean it's been said before, and you're not wrong if the title is empty because a rect is too small to fit a title. Oh, I see what you mean. Yeah, you might be right.
03:37:39.340 - 03:38:28.684, Speaker A: I see. Although no, this hasn't checked length yet. The length check happens down here, and that just decides whether to write the string. The title is there regardless. The title, I think is the hover text, right? So that title is always going to be shown, even for the tiny ones. It's just for text that it decides not to show them. So the question is, why would that title ever be empty, given that we always set it to be a string.
03:38:28.684 - 03:39:06.616, Speaker A: It's always a non empty string. So I think this is still. Right. Okay, so now, color, if function is equal to dash, dash. Well, if you say so, I guess color is still something we have to figure out. But I think what we're going to do is just for now, steal this color. What color are you? You are this color.
03:39:06.616 - 03:39:18.994, Speaker A: Great. Everything's going to be that color for now. For now. We'll get there. We'll get there. Let color is equal to this. And then we're gonna do a filled rectangle.
03:39:18.994 - 03:39:59.550, Speaker A: Whoo. Oh, but that has to go within the group, right? This is where this gets awkward. Well, I mean, it's not really that awkward. It's just we're gonna have to do some more things with the group before we, before we append it. So we're here, we're gonna do group, group, dot, add, group, dot, assign. Was it or is it append like these names? Man. Append, assign is for arguments with mute self.
03:39:59.550 - 03:40:48.230, Speaker A: Append is for children with mute self. And we want node element, rectangle. New with this business. Oh, man. So I did actually kind of want, did actually kind of still want that function then just to be able to refer to it later is all down here. Down here somewhere. Even further there.
03:40:48.230 - 03:41:30.880, Speaker A: So set X is going to be x one. Do we have an x one? We do, right. Yeah. Set Y is going to be, I assume, y one. But now is where it gets a little strange because we want to set w and h. Right, sorry. Width and heightendez and what it passes in is x two and y two.
03:41:30.880 - 03:42:18.440, Speaker A: Right. Which is the end of the box. And so this is really going to be, width is going to be x two minus x one. And there's going to be y two minus y one. The question is, is it really more efficient to maybe it is like wondering whether we should just compute the width directly instead of computing, instead of computing the y coordinates, but maybe not actually, because the. Yeah, I think so. The width is really just samples times with per time.
03:42:18.440 - 03:42:55.678, Speaker A: And the y is just. Yeah. Hey, why are we even doing this? This. So width is just samples is up. There is really just samples times width per time. Actually, that's just to sanity check ourselves. Right.
03:42:55.678 - 03:43:46.242, Speaker A: So that's what it was. And this is what I claim it is similarly here. Yddeh and height, I think the height is just frame height. Is that true? That's height. Frame height plus frame pad. Right. If you subtract this from that, sorry, if you subtract, what does it do? What's the order in which it does it.
03:43:46.242 - 03:44:11.440, Speaker A: Y two, minus y one. Yeah. So you should take this, subtract that. So this goes away. That goes away. This becomes frame height. Negative frame height.
03:44:11.440 - 03:45:03.700, Speaker A: Right. Minus frame location, depth of frame times. Oh, my brain is hurting. I think this might be minus framepad. That makes no sense, I guess. Here's the question. Y one is going to be the, is going to be higher values, it's going to be further down in the plot, and then it's going to be, the height is going to be up by frame height.
03:45:03.700 - 03:45:54.234, Speaker A: Yeah. So I think it's just frame height. I think I take that back. So, okay, here's the, here's what we'll do. Instead of trying to figure this out in my head, this should say width. And now this down here is just going to be all right. And why is it printing those in like 0.1
03:45:54.234 - 03:46:56.250, Speaker A: f? Does that matter? I think it's doing that just to, just to generate a smaller output file, isn't there? First assert needs to be with. Oh yeah, you're right. For use size. What? Thousand sep four use. I think that's false. Parenthesis about value unnecessary. It's great.
03:46:56.250 - 03:47:48.646, Speaker A: Thanks. Rust compiler should be that de annotated. Should be this. It's not going to have a factor, but this does have to be SF 64, though. Otherwise it doesn't really make much sense. All right, is there anything else I'm missing then? Yeah. Right.
03:47:48.646 - 03:48:19.970, Speaker A: So the width and height here, that's what I was going to look at. F 64. I think there's a round. No, that's not what I want. I want round to a given number of decimal places. But maybe there's no such thing. Trunk, that's kind of odd.
03:48:19.970 - 03:49:08.900, Speaker A: Guess not. Let's just leave that for now. I mean, I think the only benefit of only printing out parts of that fraction is to reduce the final SVG file size, which is totally a reasonable thing to do. It just doesn't matter for us right now. It's going to be x two minus x one, which is width divided by. Should these be f 64s? They are f 64s. Font size times font width.
03:49:08.900 - 03:49:44.710, Speaker A: Actually, no, these can totally be that. It's already an integer. Why does it make a string ttf even if it's empty? That I find a little bit odd. Look how close we are to the end. Look how close it is. It's so close. It's so close.
03:49:44.710 - 03:51:03.960, Speaker A: We're almost there. Almost there. Um, so if fitcars is greater than or equal to three, then oh, what's this de annotation again? I guess. Fine, de annotate. Just factoring that out because why not otherwise fda. The annotated is f of this. No, is the annotate annotate.
03:51:03.960 - 03:51:47.490, Speaker A: And we don't need a function for it. We can just. There. Oh, that's why I wasn't getting things. That should make it happier. 426 saying use size times float. Is that what it's called? I think it was trunk truncate trunk.
03:51:47.490 - 03:53:15.828, Speaker A: Yep. Then I guess we do that again. It's a little awkward, but fine. Let f is that f is fdev if f dot len is less than cars, but len is the length in bytes, whereas what I really want here is like the length in characters. Yeah. It's a little unclear what the right thing to do here is actually for. Like, if you have a function name that contains like an emoji, then it's fine for us to like.
03:53:15.828 - 03:54:33.190, Speaker A: It's going to be multiple bytes, but it's going to fit. You don't need the dot, dot, dot. Then f is going to be f dot cars, dot take chain it er once dot, dot. It's not gonna let me do that, is it? Because cars gives me characters. I mean. Oh, I see. It only de annotates if it doesn't think it can fit.
03:54:33.190 - 03:55:33.250, Speaker A: So. No, always. So this is don't show the function name. And then what we sort of want is if it can fit, then don't truncate it. No need to truncate otherwise. Need to truncate. And in that case, I think the trick here would be we could actually, here just do, we could be really sneaky and just directly mutate the underlying string in theory, but it would probably be graphemes.
03:55:33.250 - 03:56:25.910, Speaker A: Yeah. What I do want, I want basically an iterator over graphemes. Is that not what cars gives you? Oh, maybe nothing. Scalar value. Yeah, but I don't think there's a. Yeah, I don't think there's a easy way to go over graphemes. I think what we're gonna do is just stick with lenth for now, use Unicode graphene cluster instead.
03:56:25.910 - 03:57:15.818, Speaker A: Yeah, it's unfortunate, but I don't think it's worthwhile to spend time on that right now. Probably, but it's a good thing to fix later. Certainly the original percode is not doing this right either. No need to truncate. I guess really what we're doing here is we're getting the text to write, this is gonna be cow from nothing. This is gonna be cow from f. And this is gonna be string with capacity.
03:57:15.818 - 03:58:41.130, Speaker A: Fig cars. What does it do though? I see. Yeah. So this substrings out that long and then replaces the last two with dot dot, which is basically what we're going to do, except we're going to do it this way. We're going to say s extend using f cars, take minus two, and then s push string this. And now we should be able to do our write svg string using. This is now going to be the group and we're going to do a text item.
03:58:41.130 - 03:59:12.860, Speaker A: And that text item is going to have color. It's going to be, it's going to be color. What else? Size. Size is going to be font size, right, I assume. Yep. X is going to be x one plus three. So I guess three here is the padding.
03:59:12.860 - 03:59:47.802, Speaker A: Y is going to be three plus y one plus y two. The average of y one and y two. That's funky. Oh, it's just centering. Okay. Sure. So it's really, this is just x.
03:59:47.802 - 04:00:47.330, Speaker A: This is y plus height divided by two. Text is text, which is going to be. This location is none and there's no extra. And then what does groupend do? Nothing in particular. Great. 0.00.0. Cannot add float to use ice.
04:00:47.330 - 04:01:38.100, Speaker A: Huh. I wonder whether we should just keep it as an f 64 instead of doing this conversion. Right? Like just do this. Well, sort of. I think it's fine for that to be use. The trick is just here, I guess this is going to be SFC 64. It's gonna be sf 64 and that's gonna be SFX 64.
04:01:38.100 - 04:02:10.350, Speaker A: What is it complaining about? Oh, Orocal. How about now? Ooh, crashed. Okay, so our compute is wrong. So minus framepada. What is framepad? Frame pad is one. Great. 387.
04:02:10.350 - 04:02:57.518, Speaker A: Width is samples. Oh, it's the, the rounding that's getting at me. Yeah, fine. All right, fine. We'll just stick with what the original code does and then we can just cry ourselves to sleep instead. So this is going to be y. Sorry.
04:02:57.518 - 04:03:42.430, Speaker A: This is going to be x two minus x one. This will be y two minus y one. This is going to be x two. X one. This is going to be y two plus y one plus y two as f 64 divided by 2.0. And this is now x one. Right.
04:03:42.430 - 04:04:22.160, Speaker A: How about now? We got a file. What do we think this is gonna look like? Okay, so remember, this is the target. Whoo. That was not what we were after. So a bunch of the seams. Right? That seems correct. So these G's, huh? There's a lot of new lines that this library is injecting that makes me a little sad.
04:04:22.160 - 04:05:58.100, Speaker A: X is ten, y is 741. The text is empty for a bunch of these. Oh, it is not escaping text contents. It is definitely not escaping text contents. Really? Like actually though, why does it not escape text contents? Like what kind of library is this really? That's not ideal. Parse, parser and writer. Is this better? Normalized values.
04:05:58.100 - 04:06:42.422, Speaker A: I don't know what this is. This just seems different. I don't think that's what I want. Documentation. Mm hmm. No scripts, external resources and complex css styling. Okay, that's fine.
04:06:42.422 - 04:07:56.320, Speaker A: I don't really care about the parsing will not be preserved. That's fine. The real question is, can I generate the SVG that I want? Enums, node, node type, element text. I want usage examples, examples, resave. It's unhopful. This is all parsing. I want to generate an SVG.
04:07:56.320 - 04:09:24.280, Speaker A: Like how do I make a thing attributes, attribute value? Oh, it's fully typed. It's gonna cause me some issues too. That doesn't seem very helpful. Fine. Xml escape. I mean, I guess I could just write this out as xml directly. It's not like the svg thing is giving us all that much.
04:09:24.280 - 04:11:07.040, Speaker A: Right. Writer bytes start. Oh, so that is kind of neat. We could totally do that. It's a little inconvenient to write the SVG out this way where you like basically have to write a stream, but we totally could. Yeah, okay, sure. I guess we're gonna switch this over to doing XML instead of this funky SVG thing.
04:11:07.040 - 04:12:23.450, Speaker A: Alright, so quick XML instead, zero one three. And we're gonna use this and probably also events event. All right, so anywhere we're currently doing SVG stuff, we should not do svg stuff. Great, so show me how to write writer. We're going to do writer, new writer. And then I guess we're going to have to do a, it does mean we have to deal with opening and closing things ourselves. And we're also going to have to set up the SVG prelude, which is perhaps slightly annoying, but not that bad.
04:12:23.450 - 04:13:18.390, Speaker A: Specifically, I don't want this business like so. So writer, give me the docs. So writer is really just write event. And I guess everything that I do on it is going to give an IO result. No, a quick XMl result. Let's ignore that for now. Is it just write event that I'm going to need? Probably, yeah, actually here I could probably just write bytes, but I think I'm gonna, yeah, I think specifically this.
04:13:18.390 - 04:14:49.840, Speaker A: In fact, I don't know whether this XML generator is gonna try to emit that for me to try to be helpful. What kind of events are there? Oh, there's a doctype event. Okay, it's fine. I don't think I particularly care about that writer write event. So if the first thing we want is an event, I guess start. Yeah, event start, and that contains a bytes start, I think we're gonna want some of these bytes start with optional attributes. It's gonna be content from the given name.
04:14:49.840 - 04:16:43.070, Speaker A: Ooh, I like this. This is a good API. Alright, so it's gonna be borrowed name SVG and then attributes. It's gonna be take I guess with attributes and with attributes things can be turned into attribute. That seems fine. Let's make this a vec for now. Of all of these things, substitute anything that is not an equal sign, followed by an equal sign that will end this, followed by an equal sign followed by double quote, followed by anything that is not a double quote, multiple of that to a double quote, two that.
04:16:43.070 - 04:17:49.446, Speaker A: Why does width have a space around it? Oh, I see. All right, so that's the event start we want. Is there also one for comment? Great. We're gonna want to bytes text as well. So writer write event, event, comment, bytes text, and what is invite text? Please tell me. I guess from plane. Oh, it does not like this.
04:17:49.446 - 04:19:38.920, Speaker A: What is it complaining about now? No rules expected that token. That's probably true, although width should be image width and view box should be, oh, I see. We don't actually have all the things we need to emit this yet because this is going to be writing out the header. We can't actually write out the header yet because we don't have the height. Right. Like this is going to be image width and image height and this is going to be image height, which we can't do yet, sadly. So this code is going to have to go further down, although I guess that is pretty reasonable.
04:19:38.920 - 04:21:01.060, Speaker A: Like there's no reason for us to really start writing out the SVG quite yet. So we'll do that down here. I guess we may want to have the header writing be just a closure up here. Write header be something that takes a SVG and image with an image height. And then does I guess svg do that on all of them? Because now then this can just do write header. Write out the SVG with the image, image width and the image height. It should be all that's needed.
04:21:01.060 - 04:22:18.790, Speaker A: And similarly down here we should be able to do the same thing. Where does this get a little bit tricky though is we also need to terminate the writer because I'm, well, I'm not sure whether it does that automatically, actually. If I send a write to it, it's a good question. If I send a write to this thing, where is writer? If a writer gets an unterminated event, what does it do? My guess is I have to terminate manually. It's probably not keeping state, although that is pretty straightforward. It's really just sVG write event, I guess writer no event end, which also means I need a bytes end borrowed svg. So that's not too bad.
04:22:18.790 - 04:22:58.156, Speaker A: And I guess. Is there a. I guess it probably just, is it enough for me to just drop it? Is that all I need to do? Like how do I close the writer? Because it doesn't implement write. I think I just drop it. So that, I guess is fine. So it does mean we will have to remember to do that down here. Instead of doing that.
04:22:58.156 - 04:23:32.630, Speaker A: We're going to do this and that's fine. Luckily we now have this right svg string, which is now a little bit different because it doesn't need to take this end anymore. Now the parent is just going to be there. In fact is no parent, it's just the writer, which is a writer. Right. I guess. In fact it's a writer over a w, where w is a write.
04:23:32.630 - 04:24:04.580, Speaker A: And in theory all that should have to do maybe write an end of file. Well, end of file isn't an explicit thing that you can write. Oh, to the stream, was there an event called end of file? Oh yeah, you're right. No, that's totally what we should do. You're totally right. Great. And I guess that should be up here too.
04:24:04.580 - 04:24:47.360, Speaker A: Up in this business. The other thing I notice is that this also has declarations, which we should probably use instead of like raw writing these, which would then be svg write event. But I don't think I care about that. I think I'm fine with that. Being unstructured. Right, sorry. So we were down here and here, I guess what we want to do is output a text element.
04:24:47.360 - 04:27:03.748, Speaker A: So we're going to do SVG writeevent event start, byte start, borrowed name text, and then we're going to include the attributes from item, dot, extra. Right. I think that's what we want. And then in fact we can be as generic as byte start lets us be, which is specifically that with attributes, anything like this. And this of course should be quick xml, quickxml at events, attributes that and this will return a quick XML result of nothing. It's actually going to be that and then with attributes again, because we want to, we also want to write out our own attributes here. Is there a way for me to not have to do that with an iterator? Like can I give it just one attribute? Zoom seven.
04:27:03.748 - 04:28:26.300, Speaker A: Use a new byte starch. Oh yeah, push attribute, great. So we want this and then we want, we'll eventually push that out, but then we'll do text push attribute. And I guess for each of these we will push an attribute. So it's going to be text push attribute attribute. So what implements. Oh great, so attribute from this one, two, three, great.
04:28:26.300 - 04:29:35.124, Speaker A: Why is it complaining about these? Expected slice found stirred. Huh? Borrowed name. It specifically has to be bytes. I can't use stars. Really? I mean, I guess that's fine. All right, fine. Let's also include events attributes, attribute from store, you, size is not implemented.
04:29:35.124 - 04:30:17.650, Speaker A: See, this is where it gets annoying. It needs everything to be bytes, although I guess it's gonna need to do that regardless. But I really don't want to have to allocate for these. But I may not have much of a choice. So can't you use b text? Oh, you're right, that's right. Item, dot location unwrap. It's complaining about this one.
04:30:17.650 - 04:32:53.220, Speaker A: This I think will complain about the lifetimes of this too, probably complaint, right? And then once we've pushed out that start, we're also going to have to write event end bytes and borrowed be text. And in the middle there, there has to be a text thing which is going to be event text, which is just going to be bytes text from plane stir. So there I have stir okay, fine, if you say so. What's the types of info that crates to be more flexible? Are you talking about the current one, the quick xml one? I think what I want is for it to take anything that is display, for example, like ideally attribute would allow me to create an attribute from something that is display just for convenience. Like it still ends up being forced to allocate, which is a little sad actually. I can probably do a little bit better here by saying, by manually constructing the attribute, by doing this key, this value, like this dot. What's the thing to turn a string into a vec expand everything.
04:32:53.220 - 04:33:54.520, Speaker A: Really? Isn't there one to just get the underlying vector? I was like pretty sure that was the case, but no, match the case please. Oh great. Okay, yeah, so I could just do here, I can do this instead and do Vec from that which I think is the same as saying I can do this into. Right? So I can do it. It's just like, I wish I didn't have to type this at the same time. It could be that this is like such an unusual case somehow. This is font size.
04:33:54.520 - 04:34:49.928, Speaker A: Value is going to be item size. Like fundamentally, if you have something that's a number, you have to turn it into the character bytes. So I understand that there needs to be some conversion process, right? Why is it complaining about this into. Oh, fine, because it has to be turned into a cow. Now what? Item dot. Item size. Huh? Item dot.
04:34:49.928 - 04:35:14.470, Speaker A: Oh, size. Great. So now, right, string should work. And generally we were using that, right. I guess now this is a bunch of basically static. So here we don't have to be as good about using the interface. We could just print this out as raw text.
04:35:14.470 - 04:36:23.882, Speaker A: Where it gets annoying is including variables and such. So I guess write event, vent. Start bytes start. Borrowed name. Actually here I could do borrowed. Why does it nameless? Huh? I wonder why is name len necessary as an attribute? Like if you do, if you do this, I wonder. Hmm, okay, well, because here what I can do is just give the for linear gradient instead of setting all those separately.
04:36:23.882 - 04:36:50.360, Speaker A: So I guess first I have to give a definitions. What was that? Just defs. I think it's defsitive. So just one of these. And we're also going to have a n bytes end of that. And this has to be b because we have to give bytes. But then we start a linear gradient.
04:36:50.360 - 04:37:45.552, Speaker A: Linear gradient. And then we have to end one. But this we can just do borrowed and then give the values directly in here. Right? Ooh, can I do that? Is that a thing that works? That's neat because then I can do oops. Background. Y one is zero, y two is one, x one is zero and x two is zero. And then I guess I have to give it the length of that.
04:37:45.552 - 04:38:57.730, Speaker A: That's going to be linear gradient dot Lentz. What am I missing? Yeah. Right. So that saves me all of this. And now I need to write out, now I need to write out borrowed name be stop with attributes. I guess iter wants stop color bg color one chain iter ones offset 5%. So this is a much more sort of mechanical construction of oops.
04:38:57.730 - 04:40:00.510, Speaker A: Ah. What am I missing there? Right, so this is actually an empty right because stop has no text content. And then we have another stop that is bg color two that comes in at 95%. And so this is really the same code should be roughly at least the other thing we'll have to do here is handle file has to be a whoops. Handle file has to be a quick XML result. Otherwise it's going to keep yelling at me. Right, so that's stop color, right? Yeah.
04:40:00.510 - 04:40:36.092, Speaker A: Now we need some css out there. Is there a way for me to just like give the contents as well in the event? Probably not, no. That's too bad. Mmm. So in that case here we're just gonna write does have arguments, doesn't it? I guess. Fine. So we're going to write out a start.
04:40:36.092 - 04:42:04.390, Speaker A: It's going to be a style with attributes, type text, Css style. We're also later going to have to do end style. And then in between these is going to be a event, text by text from plain string, this thing. So the whole idea here is this from plain string is implying that it's not escaped, which was the whole reason we switched to this library in the first place. And then I guess we want the same for script, and I guess we want text ECMA scripts. We're gonna have to end script. See, what bothers me about this is here it's suddenly a lot easier to like accidentally screw up, right? To accidentally forget to close a particular thing.
04:42:04.390 - 04:42:56.780, Speaker A: It does mean we can write out all the script in one tag though. So that's kind of nice. So we're going to write out c data. Yes, write eventc data. And that's going to be bytes text from plain string format that please like so. And then we're going to do the exact same to write out the rest of the C data. So now we don't need to do this like C data business ourselves, we can just do this.
04:42:56.780 - 04:43:49.764, Speaker A: So that's kind of nice. Nice. All right, now what are we missing? Bytes and borrowed. All right, and now we need a rectangle, I guess now what we might want to do, I guess we don't draw that many rectangles, do we? It's not worth having a function for it. But writing out this rectangle is mostly static, but not entirely. Okay, fine. So it's gonna be somewhat similar to this, but it is empty though.
04:43:49.764 - 04:44:52.540, Speaker A: So that helps us a little bit. It's going to be borrowed name rect with attributes x, which is going to be zero, width and height y which is going to be zero, and fill, which is going to be URL background. So you see that actually ends up being about the same length when you format them the same. That's not so bad. It is a little sad that we have to use a vector for this, though borrowed name has to be bytes. This has to be a. This has to be a star.
04:44:52.540 - 04:45:36.240, Speaker A: Did the voice change? I don't know. Did the voice change as in, since earlier in today's stream? I don't think so. At least I don't think anything has changed on my side. But in some sense you hear me differently than I hear me. Something is different. I don't think I changed anything. Does anyone else think the voice is different or is my voice the same? Direct.
04:45:36.240 - 04:46:22.946, Speaker A: It's gonna be x one, it's gonna be y one. Didn't notice anything. Oh, maybe, yeah. I mean, the mic is pretty sensitive to exactly where I'm sitting, so that could totally be it. Yeah, see, this is what's making me sad now. We have to do all of these like extra allocations for printing stuff out, which I wish wasn't the case. It's probably not that bad, but still.
04:46:22.946 - 04:47:19.474, Speaker A: Like this vec, for example, makes me Sadeena convert from string. All right, this has to be one of these. And then I guess here we're going to start a group. This is going to be start. It's going to be a g with just static arguments. So that's nice. But see, I kind of want this to be this, right? There's no reason for that to really be a vec, but I think it's a little hard to get away from, like.
04:47:19.474 - 04:48:17.450, Speaker A: So, like, I don't think that will compile. Something seems to have slightly changed since a couple of hours back, but not in a sense that it's gotten worse. I mean, it could also be that my voice is just more strained because I've talked for longer, because we need a title node start borrowed name title. Title doesn't have any attributes. And then we're going to have to end title here, borrowed. And in between we're going to have a text, which is going to be a bytes text from plane, from plane. Stir info, I think.
04:48:17.450 - 04:48:40.770, Speaker A: Right. So we're going to start the group, print out title, print out title. Oh, a sense that. Not in the sense. Yeah. Okay, good. Started third group start and end title.
04:48:40.770 - 04:49:23.176, Speaker A: Bytes, it should say bytes end. Then we're going to write out the rectangle. Then down here we're writing out the string, still going to be SVG. And then we're going to, I guess, end the group. All right, let's see how that plays out. 478 why? Oh, right, this, these have to be. Oh man, really? So quick.
04:49:23.176 - 04:49:51.750, Speaker A: XML errors cannot be converted from IO errors. That is also like an ergonomic annoyance because it is IO. It's just I can't make one. Fine. So this is going to be map error. This also isn't entirely true. Right? Like failing to read isn't an XML out error, but I don't have a good way to get around it.
04:49:51.750 - 04:50:39.250, Speaker A: This is going to be a mute writer, this is going to be a usize, and this is going to be a u size. Do I really have to give that? I guess probably right, because this has to be bytes. This has to be bytes. This has to be bytes. That's all fine. This should be from plain string. What else do we have? This should be bytes.
04:50:39.250 - 04:51:48.412, Speaker A: This should be quick smell error, I guess. IO, it's a little bit of an abuse of the type system, but it's probably fine. This should be borrowed, this should be borrowed, this should be borrowed. 420, right? Yeah. So the, here's the problem with attributes. It should be possible for this is where this will fix it, but it's because the iterator you get is an iterator over references to tuples, which is still fine if the underlying type is copied, which Str is. So it's just unfortunate that we have to keep making all these vectors cannot resolve.
04:51:48.412 - 04:52:41.820, Speaker A: Oh, this is going to be a pain, isn't it? Wait, what? Why does it, oh. Huh. The problem here is that the none, it can't resolve the none anymore because it's a generic type parameter. What you're iterating over is a generic type parameter. So I think what we're going to do is just require that the item is gonna be this. I think we're just gonna do that and not be as friendly. That's fine.
04:52:41.820 - 04:53:24.530, Speaker A: Wait. Oh, flame graph, the binary. All right, because this is now an IO result. This is a quick XML result file open can totally be turned into an IO result, into a quick XML error. IO. Okay, how about now? So this is what we got before. Let's try that again.
04:53:24.530 - 04:54:12.680, Speaker A: Ooh, that's pretty good. I see there are a couple of issues. So it looks like maybe it's just the colors. Okay, the JavaScript is not working and the colors are obviously wrong and some of the text shifts around, but that could just be like rounding differences. So let's try to figure out why the JavaScript isn't working. Ooh, c and s is not defined. Flame graph mod.
04:54:12.680 - 04:54:34.160, Speaker A: So that's these on mouse out things. So, okay, let's close some of these. They're not terribly important anymore. These aren't important. These aren't important. These aren't important. Neither is this.
04:54:34.160 - 04:55:04.574, Speaker A: Neither is this. So C is in the JavaScript that we include. So the question would be. Ooh, I hear something weird. That needs to be C data, clearly. Oh, that's because we're stupid. Well, I.
04:55:04.574 - 04:55:46.220, Speaker A: And by that, I mean I'm stupid. This should not manually set C data anymore, so that's gonna help a little bit. I don't think it's gonna fix it, but, yeah, I didn't think so. Okay, so this is not a script. Why is. Oh, if I set this not a C data, huh? Why is it parsing this? I'm guessing that it actually wants me to. Oh, wait, let me turn on that light.
04:55:46.220 - 04:56:57.290, Speaker A: There we go. I think what we want is actually from escaped, although it's a little unclear what they mean here, because the whole point of C data is you don't need to escape the stuff that's in it. So for event if I emit a C data, I think I should say that it's escaped, even though it's not really. So, like, escape isn't really the right name for that. Yeah, look at that. Okay, that's pretty good. So let's look at like that.
04:56:57.290 - 04:57:20.940, Speaker A: So that's 310 samples. And for us, it's 310. Great. So this is pretty much exactly the same. It seems like the color scheme is off, and there's a, like, a one pixel difference over here. You'll see that text shifts very slightly, but that's pretty good. All right, so I guess colors is the next thing to fix.
04:57:20.940 - 04:58:09.424, Speaker A: Now, also, notice the font color seems wrong. Fill. Fill. You say fill. Is it because we don't set color anywhere? Oh, I bet you that's what's wrong. I think I inverted my choice of color somewhere. So color down here, that should not be color.
04:58:09.424 - 04:58:41.070, Speaker A: That should still be rgb. Zero. Zero. It's the background of that. So where do we set? Where does the background get set for the g filled rectangle colorization? So that is on filled rectangle, which is here, which should have fill color. Let's try that. Try that on for size.
04:58:41.070 - 04:59:13.400, Speaker A: Yeah, that's more like it. Whoo. Okay, so now we need to get, like, colors to work, but this is pretty good. And focusing works nice. That's pretty good. There's some weird stuff on the right here in those that seems to be gone for us. I don't know what that's all about.
04:59:13.400 - 04:59:37.982, Speaker A: Interesting. Reset zoom. Okay, so there's still something wrong with the zooming, right? Because this should not show up anymore. I mean, it works. It just doesn't go away. Oh, or maybe it does. Oh, so that's just a bug reset.
04:59:37.982 - 05:00:15.190, Speaker A: Zoom never goes away. Great. Okay, so our behavior is now identical to flame graph, except for, like, all the flags and also colors. So let's commit this before we start doing more things. It's also probably warning me about all the places in which I'm ignoring errors. 361 and probably other places. Probably here and here.
05:00:15.190 - 05:00:55.180, Speaker A: And here. Where else? 443 does not need to be mutable. Depth max is not in use. Ypad three is not in use. Options is not in use. It's fine. Is that all? And 221, the all line seems to be missing for us.
05:00:55.180 - 05:01:11.040, Speaker A: Oh, you're right. It doesn't get drawn. It is there. Right? Notice there's a gap. It just doesn't get drawn. Huh. I wonder.
05:01:11.040 - 05:02:11.060, Speaker A: I wonder. It's a good catch, though. So that, to me, suggests that the thing where we draw the empty one is broken. Like here, if info starts with all. Ooh, why does it find that multiple times? That seems wrong. Okay, so it doesn't find that line. That's kind of interesting.
05:02:11.060 - 05:02:44.550, Speaker A: If frame location, depth. So there's no depth. Zero for us. Huh. So there's inferno collapse in perf. Oh, so that's what's over there. There's a tiny entry for perf.
05:02:44.550 - 05:03:54.010, Speaker A: That's what's over on the right of. But the question is, the top of the big flames is not the same. What do you mean? No, I think they are. It's just you can't tell the difference because they're not colored differently. But I think they are the same. But why is there no entry for zero? Is it retain or retain that? Like, if frame location, depth, it could be that we screwed something up there, but I don't think so. The very highest point looks different.
05:03:54.010 - 05:04:22.008, Speaker A: Like, up here. I am, maybe. Yeah. I don't know what that is. It's a little hard to tell, too. It's almost like. No, I think they're the same, actually.
05:04:22.008 - 05:04:48.186, Speaker A: I think it really just is. The colors split extend, took one sample. Split event, took one sample. Although theirs is wider than ours, so it almost seems like there's a. I think there's a rounding difference. I think it's the same rounding difference that's causing these. The text shifts over on the right here.
05:04:48.186 - 05:05:11.960, Speaker A: Like, notice the vfs text, for example. So I think there's a rounding somewhere that is different. But I think all the same things are there. I guess they are. They're pruning the one at the very top. And we're not. But where is our bottommost stack entry going? That's what I want to know.
05:05:11.960 - 05:06:38.820, Speaker A: That suggests to me that there's something left in temp. No. Hmm. If key dot location, dot depth, greater lesson than print out key we do. Hmm. Oh, you know what? I think I know why. I think the reason is this should actually be none.
05:06:38.820 - 05:07:33.770, Speaker A: You should get no entries for last when you first start. And similarly, at the end, you should get no entries for the current one. And flow should take into iterator. Peekable. Oh, into iterator, huh? Oh, into iter. Why is the method called something different from the trait? Let's take a look at that. Yeah, great.
05:07:33.770 - 05:07:57.796, Speaker A: Now it's there. Okay, good. Let's get that in there then. Let's get. Ignore all the svgs. So we're inevitably gonna end up with what's in samples. Oh, it's not care about that either.
05:07:57.796 - 05:08:52.150, Speaker A: There. First draft of flame graph. So that's pretty good. Really? Why? Let's push that as well. So, okay, here's what I'm gonna propose. I think the thing to do now is instead of trying to fix up the colors and stuff, because I think that's a pretty good, that's a pretty good exercise for someone who wants to contribute. Instead, I think what we'll want to do is to tidy up the main loop a bit.
05:08:52.150 - 05:10:12.180, Speaker A: I think that's probably the thing to do, and I think that will probably be the last thing we do as well, because I'm running a little bit out of time. So let's see. So this main function is pretty large, but it is pretty linear too. I'm trying to, I mean, we could totally split it into just like chained function calls, but I don't know how much better that is. I mean, I suppose, yeah, I mean, we could certainly split up some of the like known svg stuff and like write header, for example, could totally go away into a separate function. All this, like the prelude that we print in the SVG should probably be in its own function. Like that includes all of these svg stir things, because the frame drawing is sort of the key of what we want in handle file.
05:10:12.180 - 05:10:53.236, Speaker A: And then this parsing at the beginning, this sort of flow tracking. I guess we could also extract out. That might be a good idea. So how about this? How about we. What we want is something like mer. Yeah, merge, merge frames. And merge frames is going to take, it's going to be generic over r, which is buff read actually, in some sense.
05:10:53.236 - 05:12:03.940, Speaker A: What it should be is this could assume that you just, that you have already read it in somewhere that is just given us a giant string. I almost think I prefer that actually that this just takes like input and it takes some stir and it gives you back a stir. I think once we add options, there's gonna be more stuff here. Sorry. It doesn't give you back a stir. What am I talking about? It gives you back a vec of timed frame. Yep.
05:12:03.940 - 05:12:58.130, Speaker A: And this should be a, a vec of timed frame with a tick a. And then what we're primarily going to do here is here we're going to do while, while line is, or for line in input lines. What is lines? Any, that's a good question. What does this do? Deprecated use lines. Okay, if you say so. So that's gonna bring some of this, although not all of this. I'll just move all of it for now.
05:12:58.130 - 05:14:09.160, Speaker A: It's gonna be 27, 30, 53. Line is line trim. So at this point really what we're going to do is like slurp in the entire file, the entire input that is. So we're going to say let input is reader read to end. Is there one that just gives me a vic back so I don't have to allocate it myself? Probably nothing. Fine. I guess I want read to string.
05:14:09.160 - 05:14:51.220, Speaker A: So buff read gives me, I guess all I then really need is read. And then I want to see whether, no, I don't want these expanded. Really? Why didn't that work? Here we go. So read to string. Great. So we're going to have let mute input is string new. And then now this is going to be over anything that is read.
05:14:51.220 - 05:15:45.210, Speaker A: And we're going to do read Dot. Actually, I guess we'll do this reader dot read to string input. So, and then that's going to, then we're going to do let frames is this function which is merge frames of input. It that will make this go away. Frames and I guess ignored. We probably also want back. And so after this loop it's going to do this.
05:15:45.210 - 05:16:34.290, Speaker A: And then it's going to return frame and ignored and time probably. Okay, so this is going to return this. Usize, usize. All right. And then we want to set up the SVG file header. Huh. I wonder whether actually let's make all these const because they, oops.
05:16:34.290 - 05:18:00.880, Speaker A: Like so. Image width, image width, frame height. Frame height. Just so that it'll be really clear when they later turn into arguments. It also means that for now we can just pass them around sort of willy nilly font size font size font with font width minwidth minwidth ypad one ypad one iPad two two iPad two expad xpad frame pad frame pad pg color yeah. Two in one. And then all of these are going to be almost, I guess they're gonna be you size.
05:18:00.880 - 05:18:32.530, Speaker A: There is a two upper and vim. The problem is I don't want to two upper just these. I want a two upper all of the matches of that in the document. If it were just, yeah, exactly. It wouldn't work. In find and replace. Sadly, this is an f 64 and that's an f 64.
05:18:32.530 - 05:20:17.980, Speaker A: And now I think what we could do here is something along the lines of, ooh, this no longer needs to take that argument for now. SVG Prelude SVG that is a good question. I think first and foremost this is gonna go away to somewhere further down. I guess this is probably gonna require that w is right. Why is this complaining? Oh shoot. A quickxml error result. Let's start writing svg.
05:20:17.980 - 05:20:57.220, Speaker A: So that's going to write out the header. That's great. Remove that to do for now here. I guess this part. Hmm. Minwidth time business. We probably want to keep where it is.
05:20:57.220 - 05:22:39.146, Speaker A: Write Header should be write svg header svg prelude so most of this, and this is sort of what I'm most happy about getting rid of. This is going to be fn write sVG prelude it's going to take a w. It's going to take a mute writer w and give back quick XMl results where w is right. And that's going to do all the stuff that it's currently doing. It's also going to have to take image height, I think. I think that makes, that certainly makes handle file look a lot clearer because now it's just like read the input. I guess in theory, handle file doesn't even need to take a reader anymore.
05:22:39.146 - 05:23:35.750, Speaker A: It could just take a, if we wanted to expose this as a library, then that's really what it should do. So actually let's make it do that. Pubfn make svg. It's not going to take a read. I guess instead of handle file, this should be svg from read from reader. And this should be actually flame graph from stirred and flame graph from reader. Or just from reader.
05:23:35.750 - 05:24:19.880, Speaker A: That's much better. And then this is just going to call from stir input. This is not going to take a reader, it's going to take input. Just going to be a stir. You can run colon g pattern g u w. Oh that's cool. Yeah, so you can, you can tell vim to execute something on every pattern.
05:24:19.880 - 05:25:09.770, Speaker A: Unclear that, that's easier than what I did, but you're right. Why is it complaining about that? Oh, I guess ops and writer. Excellent. Okay, so now what do we think about from string, I guess from reader, relatively uninteresting merge frames does deserve to be pretty far up. It's like the order of this file isn't great either. We sort of, we'd probably want to split this into separate files, I think is what we want to do. So I think what we're going to do is svgrs.
05:25:09.770 - 05:26:07.270, Speaker A: And then in here, let's just take all of these for now, and we're gonna stick all of the svg thingies and stick them in here. Actually, that's a good point. Write svg should just turn into right. And now here as well. Write svg should turn into svg. Right. And of course this guy should also go here.
05:26:07.270 - 05:27:14.020, Speaker A: Yep. So that helps, I guess. This now needs a mod svg. And this probably needs a, well, it's gonna need all of these to be super. Oh, these should not change though. This should be super. This should be super, this should be super, super, super everywhere.
05:27:14.020 - 05:27:48.270, Speaker A: These of course, are going to go into options eventually when we actually implement them in a reasonable way. Great. And they use none of these, which is excellent. Why can't this. That's false. 103. That's fine.
05:27:48.270 - 05:28:49.560, Speaker A: So now this doesn't need attribute. Ooh, that's excellent. And this doesn't need thousand separator and oh, this should be pub super. Huh? Oh. Fn 37 92. This no longer needs to be tostring, which is like the primary reason to do this. Text item.
05:28:49.560 - 05:29:36.784, Speaker A: Oh, text item. So this is going to be pubsite super of that. So now at least we have most of the svg stuff in its own thing. Oh, I'm also fine with the salt being pub super. 171 cannot borrow svg as mutable. Oh, that's fine. You don't need to, you already have it.
05:29:36.784 - 05:30:34.948, Speaker A: Bar dismutable. All right, like, so what about now? 234. That's cause frames from here needs to be mutable. 176 cannot return value. Referencing local variable last. Oh, this should just be stack last should just be this. Can it assign twice to line? That's fine, I'll let you reassign line.
05:30:34.948 - 05:30:59.970, Speaker A: That's not a problem, nothing more. Bin flame graph. Oh, right. It's no longer handle file. It is now. Um, how about we just do self here and then we say flame graph. From reader.
05:30:59.970 - 05:31:29.170, Speaker A: See that reads much nicer. And just to sanity check, it's still exactly the same. Great. Okay, so this file is now a lot more reasonable. It's got the timeframe stuff, it's got the flow stuff. Flow merge, frame and then the from stir. I feel like the I think I want the merge stuff also in its own file merge.
05:31:29.170 - 05:32:40.106, Speaker A: And then let's steal these and then we'll do mod merge and flow does not need to be this, but this super is going to be framed frames. Merge is going to be merge frames. Oh, and I guess now a bunch of these aren't necessary anymore. A bunch of these aren't necessary. So that's good, I guess. Frame and timed frame are now going to be over here. It's going to be a pub.
05:32:40.106 - 05:33:18.180, Speaker A: Super. Sorry. Sometimes I do switch between files very quickly. It's easier because in I have a lot of the stack in my head of where things are and so I'm sorry about that. It will help. So when I post the recording later, you can also switch the speed so you can like rewind or slow down the stream if there are things are moving particularly quickly. But thanks for joining, it's cool.
05:33:18.180 - 05:33:49.352, Speaker A: Are you guessing function length to select a function? No. So if I'm only selecting a function, then it's fine. So here v won't really help me. Percent is good, but it won't work for here. For example, d percent will only delete the header for the function. So I could delete to. There isn't really anything I can delete to.
05:33:49.352 - 05:34:18.068, Speaker A: So one thing is I want to delete a full function. But actually in many of these cases I want to remove multiple segments, like multiple functions. So for example, I deleted both flow and merge frames and wanted to move that to a different file. And it's not, I don't know of any good way to say like delete the next three functions. Maybe there is one. It could totally be that there's a thing to match a full function. I don't know what that would be.
05:34:18.068 - 05:35:06.930, Speaker A: Vim match function. There probably is square bracket, although what is, is that doing? Yeah. So square bracket would do it. Sort of. Not quite. It seems to get a little bit confused by rust code. I often use jump to whitespace.
05:35:06.930 - 05:35:34.896, Speaker A: Oh, that's good. I didn't know about that. That still doesn't really solve my problem, but that is kind of neat. I would do v, then move down over all the functions. Yeah. Although a binary search with delete is very visual, and I think it's about as fast text objects. Yeah.
05:35:34.896 - 05:36:18.646, Speaker A: Although what I really want is the ability to select a function. This, I've won it many times. Wait, does this just work? No. What am I missing? Oh, okay. Yeah, the binary search. Binary search elite. I don't know of other people that do it, but I've just found it to be very efficient because like, I know roughly how long this function is.
05:36:18.646 - 05:37:10.634, Speaker A: Like it's not 1000 lines, it's also more than 30 because I can see 30. So I do 50 right, and then I'm going, okay, there's an at least another 30, so I do 100 right, and then there's still more, so 150 and okay, 153, so you can get to it pretty quickly. But of course, being able to just like select the full function would just solve this problem for me. Okay, so now from stir, what does from, so the reason I'm focusing on from sir is because it's the main entry point to all of this logic. So it's sort of important to get its structure right. So it's going to merge frames from the input. Then it's going to start writing the out the SVG output.
05:37:10.634 - 05:37:53.610, Speaker A: If time is zero, it got no samples and just prints the errors. Otherwise it prunes things that are narrow. This computation here is a little weird, feel like, but it does have to come there, which is awkward. Prunes things, prints out. This should be here. And then it draws the frames. Yep.
05:37:53.610 - 05:38:54.440, Speaker A: Color. This is where we're going to have to put in the themes, writes out those. So most of what's in here is really writing the SVG stuff that is, is like write a g, write the title, the rectangle and the text for it, and then end the G and the SVG. I like that. That seems pretty straightforward. I think from reader should go to the bottom because it's a relatively uninteresting, in some sense it shouldn't be there, but it's a nice convenient function. Wait, what is this? Zero vf open curly percent d.
05:38:54.440 - 05:39:23.286, Speaker A: So that works only in some cases. It would not work here, for example. So vf open square will open Curly will not match anything you could do. V slash open curly, enter percent D. But like it's 02:00 a.m. the sign of earth. No, of course.
05:39:23.286 - 05:39:55.266, Speaker A: I'm glad you came. We're about to wrap up anyway, so you're not missing much. Di di square squiggly. So di curly bracket will only delete the scope you're in. Right. Which doesn't really work when you have structs and such. So I want something outside of that DA with that also doesn't really help.
05:39:55.266 - 05:40:33.540, Speaker A: It just also deletes the curly, the curlies. So yeah, it's all sorts of annoying. Okay. I think now I have mostly the separation I want. There's obviously a lot more feature wise we could do, and what I'll do is create issues for all the things that I think of that people can contribute to after the stream if you want to, or like some other time in the future. But I think we have a pretty robust starting point now. This SVG generation code is a little sad, but it sort of has to be that way when it's SVG.
05:40:33.540 - 05:41:36.508, Speaker A: I also didn't benchmark this because once you have the script collapsed, the files are so small that it's unlikely that you're going to see much of a difference. But my guess would be that ours is significantly faster than the Perl one, just because like no regular expressions, for example. Okay, so let me first just do this add source, do at least some minimal separation. Yeah. So someone asked me whether I could do Vim, like basically have a stream where I do just sort of any kind of normal development, and then turn on screen keys so that you can see everything I type. So there's a screen. I don't know if I have it installed here, probably not.
05:41:36.508 - 05:42:06.392, Speaker A: So you can see every key that I type, including the ones that are not visible on screen. So you see all the keyboard shortcuts. Like, I would be happy to do one that's like that. I think it would mostly become distracting once you've seen the basic things though. Okay, let me just push this out and then I think we're, I think we're done for the day. As mentioned, I'll create issues for all the things we didn't get around to doing. And as you saw from going through it, there are a lot of them.
05:42:06.392 - 05:42:54.840, Speaker A: But at least now we have the entire structure for the program and fitting in any individual features should not be that bad. Yeah, I think I'm happy. Thanks for watching everyone. Are there any questions before we sort of end off about what we did that is set show command will not quite do what I want? There's a, I think it's called screen keys. Screen caps, screen keys. Screen key. Screen, screen key.
05:42:54.840 - 05:43:37.640, Speaker A: I mean here, I'll, I might as well show you while we're here. Yes, I do want to do that. Seems fine. Of course, I have no idea how the default style looks like, but we're about to find out the other reason. It's awkward is because if I type passwords, it'll just show my password, which would also be unfortunate. So I need to find a way to disable that screen key. Yeah, so it looks like this.
05:43:37.640 - 05:44:16.930, Speaker A: So I don't know, it might even be that that moves too quickly to really be able to follow. I think there's a way to set the display for much less time. I sort of wanted to. It doesn't seem like it, right. But that would show you roughly how I navigate files. Like how I jump from one file to another. Ooh.
05:44:16.930 - 05:44:44.240, Speaker A: It really gets in the way, though. And yeah, I don't think. I don't think it would help you much. I think it would mostly be distracting. But anyway. Okay, yeah, I'll create issues, and if you want to contribute, then feel free. As I pointed out earlier, in the inferno, there have already been a bunch of.
05:44:44.240 - 05:45:14.114, Speaker A: Oh nice. A bunch of things that have other people have contributed. So if you have things that you would like to contribute yourself, then please do so. I would be happy to review, pull requests, and sort of map them to issues. Even if there are features that you remember from the stream that we didn't do. If you write the issue instead of me having to do it, that's also great because I probably won't get around to it tonight. So I'm happy for any of any of you to sort of help out in any way that you want to.
05:45:14.114 - 05:45:53.692, Speaker A: You should think of this as our project, not my project. And in fact, I'm already planning on adding more contributors as maintainers to that project because it really feels like it's ours. If you contribute to it, then that's all that's needed. All right, well, thanks everyone. And next stream. I think next stream will probably not be on Inferno just because I feel like we're in a place where the remaining stuff would just be adding features, which I think would probably be less interesting. It looks like the next thing is going to be to implement tcp, which is going to be its own very different type of project.
05:45:53.692 - 05:46:44.140, Speaker A: It's like low level byte hacking and reading rfcs, but it's what you're voting for. In general. The way I decide streams is that about a week before I actually do the stream, I'll just see whatever is currently on top, and that's the stream that I'll announce and that we'll do. So now is sort of your chance to go in. And I've added a bunch more of stream ideas too, and so go in and vote for the ones you're interested in. And remember that the so now the porting flame graph to rust has been removed because it's done, and so you may want to add additional things to vote for into this list and then we'll see whatever ends up being the next winner over the coming weeks. My guess is the next stream will be in.
05:46:44.140 - 05:47:28.380, Speaker A: Let's see, what is it? February 2, two weeks? Probably like there will not be one next week. Yeah, the Java concurrency map would be pretty fun. To port lc three would also be really fun, and the open source contribution stream was really fun to do. So I think many of these are really interesting. Any chance to work on Toshi search or Toshi? I don't know what Toshi is. Yeah, I mean, so I have implemented tcp before I implemented in Go and it was a bit of a pain, I'm not going to lie. It's also a little bit annoying to test because you need low level network access, but it's something we can do.
05:47:28.380 - 05:47:37.960, Speaker A: In any case, thanks for joining the stream and I will see you all next time. Bye. Thanks for watching. In.
