00:00:00.440 - 00:00:53.475, Speaker A: Welcome back to yet another Rust livestream. Oh man, that's a great name for the channel. Yet another Rust livestream. We are going to continue with porting Java's concurrent hashmap to Rust. We started this a while back and it was really just under the observation that we haven't really done anything that deals with low level concurrency and like unsafe code. And so I wanted to do something like that. And in this case, if you haven't seen it before, we're porting Java's concurrent hash map, which is a data structure that the Java standard library provides that provides a map, a hash map sort of like Rust's, but where you can do reads and writes concurrently without having to stick any locks around it, and at least in theory, performs well as you scale up the number of readers and writers.
00:00:53.475 - 00:01:53.677, Speaker A: And so I don't want to say it's a straightforward port, but the entire code is written and pretty well documented in Java. And so we're just porting that code straight over to Rust and we had like a six hour stream on that a few weeks ago. And this is going to be part two. Now, in part one, if you remember, we did most of the read and write operations and we got sort of halfway through table resizing, which is a part of the insert code. And so that is, we're going to finish that up today and then we're going to move on to one of the big differences between Java and Rust code when it comes to concurrency, which is that in Java you have the garbage collector. So if you're accumulating garbage in a concurrent setting, you can really just sort of let it go out of scope because the and not have to think about it anymore. And the garbage collector will ensure that whenever it's safe to free and drop the relevant memory, it will do so safely.
00:01:53.677 - 00:02:23.275, Speaker A: In Rust, we don't have that guarantee. We need to make sure that we know when it's safe to drop a given element. Basically, we need to think of it as we have a bunch of pointers, like raw pointers, all over the place. And at some point we need to determine that this pointer is no longer being accessed by anyone else and it is now safe for us to free it. But we need to do all that tracking. Rust will not do it for us. And so that is the part that we're going to have to fill in today once we finish the resizing stuff.
00:02:23.275 - 00:03:07.005, Speaker A: Fantastic. Okay, I'm going to do a sort of brief recap of what we did last time, just to refresh you all on how the Java map works and what we've done so far in the porting and sort of decisions that we've made. And then we'll dive into what we're doing next. For those of you who are sort of relatively new to the channel, this is. So this is me, John, and I do a lot of these live Rust coding streams. This is part two of an existing stream. So if you haven't watched part one, go back and watch that.
00:03:07.005 - 00:03:42.855, Speaker A: And there are also a bunch of other live streams on different topics on the YouTube channel. If you want to support my work. I can't actually accept donations because international student visas are weird, but I do have an Amazon wishlist, so if you want to support. That's something that's linked to my Twitter account. All right, let's dive back to the code. So what we have here, just so you're familiar with the setup, on the right hand side here is the Java code and on the left hand side is the Rust code. And I'm going to jump back there eventually.
00:03:42.855 - 00:04:24.785, Speaker A: So the Java code has two primary sort of top level comments. This is just the code from the code from the Java standard library that's just been pasted into a file. Here it has an initial comment that explains what the API for the concurrent map is. And then a little bit further down, once you get into the class itself, there's a description of how it works internally. And I think it's useful to recap this just because we're going to be dealing a bunch with the invariants that this comment explains and that the code actually implements. So the way the Java code works. Actually let me try to paint this.
00:04:24.785 - 00:05:00.383, Speaker A: That might actually help. Ignore that for now. Let me see how well I can paint this. So let's do like red is good. So in the Java map we're going to have a. That's so far from a straight line. I think there's a bend in my drawing tablet right here we're going to have a bunch of buckets and each bucket that's real.
00:05:00.383 - 00:05:45.075, Speaker A: Give me a second. Let's try that. That's better. So there's a bunch of buckets and each bucket is really just going to be a pointer for us. And initially all of them are going to point to nothing. And the idea here, like with most hash maps, is that for any given key, what we're going to do is we're going to take the key, we're going to take it, we're going to take its hash and then we're going to do modulo the number of buckets, right? So this gives us a number into the bucket. Let's say it gives us like some key turns into 7, 0, 1, 2, 3, 4, 5, 6, 7.
00:05:45.075 - 00:06:31.677, Speaker A: So 7 is going to go into here and this is going to be a linked list of, of nodes. And the reason this has to be a linked list is because we're doing this hash modulo. You could have multiple keys that end up hashing to the same bucket. And so you might end up with multiple items, each with a different key. So for example, here, both 7 and 7 plus this is going to be 9, so 16 and 25, all of those keys are going to hash to 7, modulo 8. And so all of these are going to end up in this bucket. And so if you look up a key, look at its bucket, you're going to linearly walk this linked list.
00:06:31.677 - 00:07:09.457, Speaker A: This is just basic hashmap setup. Where the Java business is concurrent is in the following ways. First of all, why is this being difficult? First of all, there is this pointer, this initial pointer. When we want to do an insert, we're going to do a. We're first going to read this pointer and see whether it points to nothing. If it does, we're going to try to just compare and swap in the first node here. So this is going to be an atomic compare and swap.
00:07:09.457 - 00:08:25.385, Speaker A: And if that succeeds, then we're done, right? Then we didn't have to take any locks, we just did the insert and then we're done, we can move on with the insert. The second case is if there is already an element in there or if the compare and swap fails, which also implies that there's now an element there, then the element, the first element in here, technically all of them, but especially the first, is going to have a little lock inside of it. And if we need to add something later in the list, we're going to first take this, which is sort of called the bin lock, and we're going to take that lock and once we get that lock, add to the list. Now you might recognize this is something that's called a hash map with per bin locking, which is sort of similar in that for every bin you have a lock, right? So this is a design that C hashmap, for example, uses, which is another rust concurrent hashmap. The advantage of this design is that here in the common case where buckets are going to be empty, which is generally what you like, you expect in a hashmap for most of the buckets to be of roughly length one. Then you will not ever have to take any of these locks because all you have to do is this. Atomic swap.
00:08:25.385 - 00:09:24.655, Speaker A: Yeah. There's also the other thing that the Java hash map has implemented that is sort of a neat feature, is. Let me do that color is that for any hash map, it might have to be resized at some point, right? Imagine that you have some buckets that are getting really long. What you want to do is double the number of buckets, and then you want to move all the elements from existing buckets over to the new map, and then you can free the old map. Of course, where this gets tricky is if you have one thread that's reading from this map and then one thread that's trying to start a new map, which is going to be sort of logically twice as large. So there are twice as many things in here. So now at this point, you have two maps and you have some threads that are operating in this map and some threads that are operating in this map.
00:09:24.655 - 00:10:24.965, Speaker A: And so the way the Java code does this is if you're a reader, you're just going to walk from the. You're always going to access. You're going to access the old map unless you find a thing that redirects you to a new map. So the way a transfer is actually going to work is if some thread decides it's going to do a resize, it's going to allocate this new map and then it's going to start replacing these lists with a sort of special forwarding node that points to the new map. Any thread that encounters this is just going to move over to this guy and do any inserts and reads over here. Of course, there's a challenge here because moving all of these bins over to the new table is going to take a bunch of time. And so if a thread notices that this kind of resizes in place is happening, it's going to assist with the resize.
00:10:24.965 - 00:11:12.855, Speaker A: So we're going to have a bunch of threads and all of these threads are going to be helping with this move. And then eventually when the move is finished, then we're going to make sure that readers start accessing the new map entirely. And then we're going to mark this map as garbage, right? And once this map is garbage at some point in the future, we're going to free this map. We can't do it immediately because it might still be threads that are in the process of doing reads. But the idea is that this sort of transfer of bins from the old map to the new map is going to happen by having multiple threads help out with that process. And that's where we got to last time was this business of writing, this sort of helping to transfer business. And so that's where we're going to continue.
00:11:12.855 - 00:12:29.135, Speaker A: Before we do though, for those of you who are watching live, do you have any questions about the sort of high level structure? I mean, I guess this is low level, but the sort of structure of the design and how the concurrency works before we dive back into the code. Like anything you want me to explain in more detail? This is a very quick and dirty explanation of what we did last time. So if there are details that you feel are important and you're not quite grasping, now's the time to ask. So I'll give you like a little bit of time just if there are things you want refreshers on. Because it's important that we're all on the same page as to where we're going to start and what the sort of structure of the code is before we dive into like the low level code again, because it's been a while since last time, right? At least for most of us. All right, I don't immediately see any questions, so if you have any far them away and then we'll, we'll jump back into this and I'll try to explain more. So the place we were was this the put function.
00:12:29.135 - 00:13:44.807, Speaker A: So put is put does a. Well, it does a put into the table, it inserts a given key value pair into the table. And the code is pretty similar to, let me find here, put val. This is basically a direct port of the Java version and you can see that if you sort of squint at it and you'll see that mostly what it does is it finds the bin, it first hashes the key, it finds the bin for that hash, it gets a reference to that bin. And this is where you see the like linked list business where if the bin is a null pointer, then we're going to just try to compare and swap in the first node in the bin and if that succeeds we're done. We can just return. If there is already something there though, then either there's a node at the head, in which case we might have to, we might have to stick a new like, take the lock, which is what we're doing down here, and then insert the key value pair that we're inserting into that bin.
00:13:44.807 - 00:14:45.801, Speaker A: But this is the tricky case, right? This is where what we find when we're trying to do a put. When we find in the bin where we're trying to do the put is one of these forwarding nodes which we've called moved. It's equivalent to this clause in the Java code where it says if you are trying to do a put and you discover that the bin you're trying to put into has moved, then what we want to happen is we want for the thread that's trying to do that insert to help with the transfer, we want it to assist with the resize that's going on so that that resize is going to complete faster. And the reason why it will actually complete faster in our case is because, um, we have these, we have the set of bins and the bins are entirely separate, right. For each bin, one thread can just like compare and swap out the entire list at once and then compare and swap it into the new map. At least that's mostly true. We did went through some of the details of that in the previous stream as well.
00:14:45.801 - 00:15:42.995, Speaker A: We're missing is this help transfer function. And the way I think this is actually not going to be quite like that. I think this is going to be self.help transfer transfer table. And if you remember from the drawing, a forwarding node has a pointer to the new map, the one that we're resizing into. And one of the reasons why it has to do that is because you could in theory have multiple resizes going on, right? Where one thread discovers that the current table is too small, so it does a resize and then another thread and then starts doing inserts into the new table, why the resize is still happening and then discovers they want to do another resize because that is already too full. So it allocates another table and now there's a transfer happening from this table to that table and there's a transfer happening from this table to that table.
00:15:42.995 - 00:16:36.159, Speaker A: And so in theory we need to make sure that this still works out. And so these forwarding nodes actually have. If you look at here, this is our node and a bin entry is a pointer to a table. So this is if we look here at the help transfer function down here somewhere. Yeah, so this is going to be next table. Oops, that's not what I meant to do. So the pointer, there is going to be a pointer to the next table.
00:16:36.159 - 00:17:27.005, Speaker A: Now one thing that's worth keeping in mind is the Java code actually has two things that track the current table and the next table. There is a sort of a global pointer that's used for the Entire map. Let me see if I can dig that up here. So we have like this is our top level struct. It has a next table pointer and then it also has the current table pointer. But notice that the next table here and the pointer that is in a given node like a forwarding node might actually be different. I'm not entirely sure why the Java code has this, but I think the intention is because you can have multiple resizes and the top level next table is going to be the target next table, like the one we're ultimately going to resize into.
00:17:27.005 - 00:17:57.835, Speaker A: And this next table is where this entry, the one we're currently looking at, has moved to, which might. They might not be the same. For example, even if there aren't multiple resizes, imagine that one resize happened and completed. Then the old map. Let me flip this for you. The old map right here has a bunch of like all the bins are just forwards to this table, which is the one that we resized into. So all of the things in this table are pointing to that table.
00:17:57.835 - 00:18:34.085, Speaker A: And so there might still be readers in this table, right? Like readers that are really slow or something might still be in this table. And they are just going to encounter these forwarding nodes that point them to this table. Now imagine that there's another resize that happens. So this table is going to get resized. So we're allocate a third table over here. Now we're going to start replacing the pointers in this middle table to be forwards to that table. But there might still be readers in this original table, right? There might have been readers that were so slow accessing that table that they are still stuck over here.
00:18:34.085 - 00:19:11.615, Speaker A: We need them to sort of move to the middle table because they might have to do a read from there or they might end up getting forwarded even further. But so these pointers in the forwarding nodes are pointers to go look here instead. And that might not be the newest table because there might be a subsequent resize in progress. So this is going to be next table. So we're gonna have to write this method. It's a good question whether we even can. I think we can.
00:19:11.615 - 00:20:14.375, Speaker A: Yeah, we can call self here. Okay, so we need to write this. Let's write that down here. So we're gonna have a FN help transfer going to take a ref self. It's going to take a table. It's going to take a table which is going to be a what this transfer is probably going to take basically the same as transfer like so. Yes, yes.
00:20:14.375 - 00:21:37.485, Speaker A: So it's going to take help transfer. The way to read the signature is that it's going to help transfer from this table to this table and the guard here, if you remember from last time, the guard is something we are going to use in order to do garbage collection later. The idea is that the guards track Think of the guards as tracking sort of epics where we collect garbage in one epic. Once everyone has moved on past that epic, I'll go through this in a lot more detail once we start doing the garbage collection itself. All right, so what does help transfer do? Well, okay, so it does a bunch of null checks which are not necessary for us I think although we can totally do them. If is null or if next table is null then we just return table. Okay, so this actually returns a shared table although not entirely sure why it does that.
00:21:37.485 - 00:24:15.429, Speaker A: We don't need this instance of forwarding node because help transfer is only called if the node is a forwarding node in the first place. Okay, and then we're going to do RS is resize stamp it's going to be this where that's going to be table dot length where is our table down here. So it's going to be bins len and now we want what's this? While next table is equal to self next table load it's going to take a guard and an ordering. So this is checking that the we're going to help transfer from this table to that table. But we're only going to do that if this table is actually the target of the currently ongoing resize which is what this is checking and table is equal to self table load and this is a similar sort of correctness check of we're only going to do it if the target table is the same as the current target of the resize and the old this table the table we're transferring from is the same as the current table as far as we are aware. Basically we're only going to do it if the resize we're asked to do is the current resize. And whatever this is and interesting it's like a this then does SC is self size CTL load guard all of these loads are are orderings sequential consistent because the.
00:24:15.429 - 00:24:56.725, Speaker A: So this is one thing I dislike about Java is that these are actually all fields on self in Java. This Java uses this but there's sort of an implicit this before basically anything that's not a local variable. So this is really this dot next table. This is this dot table. This is this dot psictl and all of them are marked as volatile, which is roughly equivalent to doing a load with sequential consistent. Yes, the plan is to rewrite the tests as well. So if SC is greater than or equal to zero, then we're going to break.
00:24:56.725 - 00:26:12.399, Speaker A: Or if SC is equal to RS plus max resizers or SC is equal to RS plus one or transfer index is less than or equal to zero, in any of those cases we're going to break because that's what the Java code tells us to do. One thing that's weird about porting concurrent code like this is we're sort of blindly assuming that the code that's in the Java code is correct, which is probably a reasonable assumption. But it means that in some cases we're going to write stuff that we might not necessarily understand and we will only really dig into it. We will only really dig into it if something turns out not to work or if there's a line that's hard to port and we have to really dig into what it means. And this is going to be compare and set int. Okay, so we're going to do a self.syl compare and swap.
00:26:12.399 - 00:28:02.071, Speaker A: So size CTL, if you remember from last time, is this control value that's used to track how many threads are currently working on the resize and what state the resize sort of is in. And so this compare and swap is to add ourselves to the set of threads that are helping with the resize ordering const. If this is equal to sc, then the comparison swap succeeded and then we're going to help transfer from table to next table break. What else do they have here? This is going to return next table. One thing that's interesting here is for this next table, this next table is really a const table, if you remember right, because it's the thing that's stored in the moved. And what we're going to do down here is next table is equal to shared from next table. And if you remember from last time, shared is really just a thin wrapper around a thin wrapper around a shared raw pointer.
00:28:02.071 - 00:28:40.563, Speaker A: And it's unsafe to dereference it. And the idea here is that you can only dereference it if you know that the target value is valid. So the question here is, do we know that? Do we know that the next table is indeed a valid pointer that hasn't been freed yet? The way that we know this is. Let me see if I can illustrate this. Actually, let's leave that for when we add the unsafe annotations we'll do that for now. Okay, so this should be fine. That I think is roughly the definition of it.
00:28:40.563 - 00:29:03.513, Speaker A: And we wrote transfer last time to see if there any fix mes or to dos left from last time. Counter cell, figure out num, CPUs, tree bins, which we ignore, and reservation nodes which we ignore. Ordering could probably be relaxed. We're gonna ignore that. Treeify. We're gonna ignore that. Okay, let's do a cargo check.
00:29:03.513 - 00:29:43.335, Speaker A: There's no way this compiles, but we're gonna run it anyway. What's the point of the const keyword if things are immutable by default? The const you mean for raw pointers in rust. So the const keyword for raw pointers. It's just that they needed a way to name the raw pointer type that is not a mutable pointer type. And so const was the natural. I cannot find owned in lib. Let's see.
00:29:43.335 - 00:30:19.365, Speaker A: What do you mean owned is right there? Oh, it's the import. Not working for some reason. Use of undeclared type or module crossbeam. Really? But it's right there. Oh, crossbeam. Try that now. What? No.
00:30:19.365 - 00:31:17.553, Speaker A: Build hasher in hashmap. We want ordering, it's going to need to be imported. Where is build hasher? Let's go to build hasher. Oh, it's in standard #. Build hasher324 attempt to use a non constant value in a constant N. Oh, that's awkward. Yeah, yeah.
00:31:17.553 - 00:31:47.125, Speaker A: What we're going to do here is actually. Okay, so what we're trying to do here is allocate. When we're allocating a new table, we want to allocate a bunch of contiguous memory. These are going to be our bins. And this is trying to do that as an array, which won't actually work. This is going to have to be. I think we can do this with vec dot into boxed.
00:31:47.125 - 00:32:43.945, Speaker A: So down where we have table, this is really going to be a box of this because we want it on the heap and that should be okay. I believe we could make it a vec too. It's just I don't want it to be resizable is all. I cannot find. That's a node super table. Cannot find n only 59. That should be self.
00:32:43.945 - 00:33:41.687, Speaker A: Why it won't work. Why what won't work? I don't use LSP because I don't like noise in my editor. I would rather have them in a separate terminal. Expected trait found. Derive macro. What? Oh, that's because I didn't import hash Seems fine if absent. Oh, that's right.
00:33:41.687 - 00:34:46.630, Speaker A: We renamed this parameter from noreplacement to if. It used to be called if absent and now it's called no replacement, which now I need to parse Boolean logic. If absent and no replacement, are they the same or are they opposites? No replacements means that you will only do it if absent. So yes, they are the same. So this should say no replacement. What else do we got? 28 old value this should say old Val 390 finish equals true I think that should say finished finishing. 425 oops.
00:34:46.630 - 00:35:42.303, Speaker A: 425 bin I table bin I think we want I see, this is just I not bin I. When. When would you want to use the channel featuring Rust? I'm guessing to jump across threads. I'm not sure I follow the question. 500 all right, we need KV that's easy to fix. 504. This is hash.
00:35:42.303 - 00:36:17.485, Speaker A: These are just trivial fixes. I just want to get to the tricky parts. 49 wrong number of type arguments. That is true. There's no S parameter to table. 219 wrong number. This is KNV.
00:36:17.485 - 00:36:52.825, Speaker A: This is KNV and that's knee. 316 this takes KN. That takes knee. Great. Add some more of the errors I wanted. All right. No method finish line 78.
00:36:52.825 - 00:37:56.029, Speaker A: Why is that? Right, we need to use hasher. Yeah, this is like lower level cleanup that because the previous stream we mostly just ported the code and didn't actually try to compile it. This is just tidying up a bunch of the. Bunch of the shortcuts we made there, like mistyping variable names and stuff. What we'll eventually get to is the compiler complaining about the fact that you'll remember this from the end of the previous stream that shared does not dereference into its inner type. Dereferencing a share is actually an unsafe operation and so that's what we're going to end up with once we get through some of these errors. Like here for example.
00:37:56.029 - 00:38:40.999, Speaker A: Like find is not found for shared is an example of this isn't safe to cast U64 to usize implicitly. I don't think the compiler will let you do that or it'll be a checked cast, I believe. Is it normal to have use and functions? Well, I don't know about normal. Usually I do it if there's a. If there's a trait method that I only call in one place, I might do it. It's up to you. 27 I see, this is.
00:38:40.999 - 00:39:02.465, Speaker A: Yeah, this we're gonna have to figure out. This is definitely a fix me actually this has to do with move too. So let's do that before we continue. That's gonna be finding. It's going to be. Yeah. So this is the class node.
00:39:02.465 - 00:39:32.717, Speaker A: That's the find that we already implemented. And then there's a special case for this uses like Java overrides, which is really annoying. So forwarding node extends node. It overrides the implementation of find. And the idea here is that you're looking for a node in a list in a linked list in a. In a bucket that matches a given hash and key. And if you walk the.
00:39:32.717 - 00:40:24.339, Speaker A: If you walk the link list and you encounter a forwarding node, then of course you should stop looking in the current bucket you're looking in and instead you need to switch to the other table. And so interesting. That's going to be a little bit annoying to figure out because this obviously needs access to. Actually, maybe not. Maybe not. So what we're going to do is let table as well as next table. This assignment is sort of useless.
00:40:24.339 - 00:40:41.043, Speaker A: Like it doesn't really do much. It's just renaming the variable because the. We actually, let's just do. This is next table. This is next table. This is mute table. And here we're going to do.
00:40:41.043 - 00:40:58.595, Speaker A: Let's name it just like it did here. And this is just going to be a loop because we might move to the next table and then discover that that table. In that table the list we need has also moved. So it's. We need to iterate through these like it might have. It might be. Have to be a cascade.
00:40:58.595 - 00:42:07.591, Speaker A: Cascade or if. Interesting. So what is this? If this if is if the key is null, which we can ignore in rust because the key is a reference. So we know it's not null if the table is null or if what's N here I see. Or table bins len. This is the same as isempty or right? Then return null. Probably not what we want to do for now.
00:42:07.591 - 00:43:29.605, Speaker A: That's fine. And tab at is going to be the same as table dot bin. So you remember from our table at the bottom here we have this sort of convenience method for given a hash. Find me the corresponding bin. And so this is going to be why n minus 1? Why on earth is it n minus 1? That is interesting. Okay, so what this is actually doing is it's looking up the last bin of the table. Well, ended with H.
00:43:29.605 - 00:44:29.279, Speaker A: Why is it ended with H? What a bizarre lookup oh, this is just the inverse. N minus 1 is the mask from here. What a super strange way to do this. Because if you see here, let's look for another tab at. Find me a regular tab at. Yeah, all of these are just doing a H Here is the hash of the key and n minus one is all of the bits that are currently being used for the. It's equivalent to doing a modulo of the table length the number of bins.
00:44:29.279 - 00:45:29.055, Speaker A: If the number of bins is a power of two. I was just surprised that they do it in line like that. But that, that is why. And so this is really the same as doing bin I. So let n. Let bin I is table dot bin I of table binai of hash and then bin is going to be table bin bin I and if bin is null, then return this and then there's another loop. And this loop is why I wonder.
00:45:29.055 - 00:46:57.985, Speaker A: I think the outer loop is for iterating over tables. Like if we encounter another another forwarding node in here that forwards us to yet another table and the inner loop is just walking the. Walking the bin. Okay, so this does e hash. I think this is just doing this business. So this is if bin dot hash is hash and bin key is key, then we can just return that bin. So this is if the.
00:46:57.985 - 00:47:48.355, Speaker A: I don't understand why this needs to be a loop. Oh no, it is iterating over. Okay, so why doesn't this just call this find? That makes very little sense to me. All right, that's fine. So this is just going to loop over the nodes in the bin. So if the current bin we're looking at so that means this is going to be a mute. If the current node we're looking at is matches the entry we're looking for in the bin, then we're at the right bin and we can return if eh, less than zero.
00:47:48.355 - 00:48:36.565, Speaker A: This is their special marker. So I see. So this is really going to be match bin. That's what that means. If bin entry is a node, then we're going to do and find key guard. If it is a moved next table, then we need to decide what to do. Then what we're going to do is we're going to say table is equal to next table and then we're going to continue outer.
00:48:36.565 - 00:49:29.505, Speaker A: And I think that means this doesn't have to be a loop because the end find is what's going to do the actual loop here that's going to be this. It does suggest that maybe this maybe turn into a loop instead of recursing. I don't think that's going to matter. Yeah, so the idea here is we. If we encounter a forwarding node, then we follow that forwarding node. We look up the bin in the table we were forwarded to. If we find that there's a list there, then we're just going to search in that list.
00:49:29.505 - 00:49:59.461, Speaker A: If we find another forwarding node, then we move to the next table we're forwarded to and then we continue there. All right, let's see what that gives us. Which. Which also means actually that this can now just be a continue. We don't need the label anymore now that we remove the inner loop. The mask. Yeah, the mask is there for performance reasons.
00:49:59.461 - 00:50:30.707, Speaker A: The reason there's a mask instead of a modulo. Even though probably doesn't matter that much, but that's why it's there. It's a good practice not to use brackets in every if statements. In rust, you don't use brackets for if statements. Yep. Great. No method find fun for shared.
00:50:30.707 - 00:51:17.035, Speaker A: Okay, so this is dref, right? Shared node has a find method. And so in order to call find on it on a shared of node, we need to do the unsafe dref. So that is an error. We want to be there. That's expected mismatch type on 45. Oh, why does that unfind M expected? Nothing expected unit found shared. That seems false.
00:51:17.035 - 00:52:14.231, Speaker A: 45. Well, N find should be this which returns a node. So why is it saying that it's getting unit from this? Expected this. What is it expecting the entire match to be unit? Why is it expecting the entire match to be unit? Continue should continue for this loop. Oh, this needs to break. Great. No method BIN found for shared table.
00:52:14.231 - 00:53:05.415, Speaker A: Okay, so this is a D ref. This is a d ref. This is a DREF no variant release 534. It's because I misspelled it. 498 expected eyesize found U32 leading zeros. Interesting. Yeah, resize stamp is a really weird function.
00:53:05.415 - 00:53:59.903, Speaker A: Resize stamp returns the stamp bits for resizing a table of size N must be negative when shifted left by resize stamp shift. I think this is going to be eyesize from that. This is a draft from so dref. Yeah. Iceice from U32. It's not satisfied. Right.
00:53:59.903 - 00:54:26.825, Speaker A: You're not guaranteed to be able to do that. So we're just going to do this as ice. ICE this as iceice. We want that to be signed store for shared. Well, that should. That should exist. So shared.
00:54:26.825 - 00:55:00.151, Speaker A: Oh, that's Right. That only exists for atomic. It does not exist for shared. So in 488 this is in. This is in. Put transfer. Transfer.
00:55:00.151 - 00:55:58.595, Speaker A: Where are you? Down here. So what does this actually do down towards the bottom? It sets table store. Hmm. Set tab at. These shouldn't be store. I don't think these should be store bin because that's we're trying to do down there. Is shared equivalent to a shared pointer in C? No, a shared is very different.
00:55:58.595 - 00:57:15.555, Speaker A: So a shared pointer and in C is more like an arc in Rust, shared is a very low level type that the crossbeam library provides to us. So a shared is a just a raw pointer with no guarantees associated with it. But it has the implication that the target of a shared is accessible by many threads and we don't quite know how many. I'll go into that a little bit more detail when we start dealing with the actual garbage collection and with this, the fact that shared dereferencing a shared is unsafe. All right, so this is D ref d ref d ref 479expected atomic found shared. Oh, I remember we looked at this code last time. Okay, so this business is.
00:57:15.555 - 00:57:58.503, Speaker A: Let me go back to the drawing for this actually to figure out how this code is going to work out. All right, so here is. Get back to my. Let's do like a nice blue. Let's make it also bigger. For some reason the buttons on my drawing pad have stopped working, which is really annoying because it means I can't easily brush. Great.
00:57:58.503 - 00:58:31.485, Speaker A: Oh, that's maybe overly aggressive. Great. So the observation here is. So we have a. We have our hash table, right? And in one of the bins we have this business. So imagine that we have some really long linked list. And in the.
00:58:31.485 - 00:59:43.755, Speaker A: In the new map, let's do that in the new map, which is twice as long. Actually, let me just do that. So the new map is going to be twice as long, right? So if this is n long, this is going to be 2n long. And remember that the way that we take a given hash and turn it into this is its modulo n, right? Which means that in the resize case H, in order to go to a bucket, it's going to be modulo 2n. What this means is that half, if you look at any given bucket, roughly half of the things that ended up in that bucket are going to end up in a different bucket. When modulo2n, you can spend some time trying to convince yourself that that is the case. But it turns out to be true, that this has like hash 1, this is hash 2, this is hash 3, hash 4, 5.
00:59:43.755 - 01:01:09.675, Speaker A: Some of these is going to be the case that mod n is equal to H1Mod2N. But for some of them, oops, modulo that's an N is equal to is not equal to the modulo 2n. The reason for this is modulo 2n means. Let's take an example here. Let's do, let's take a trivial example. 7 modulo 4 module modulo 4, 7 modulo 4 is 3, 7 modulo 8 is 7. But 3 modulo 4 is also 3 and 3 modulo 8 is still 3, right? And it turns out that basically half of the things that hash to a given bucket is going to end up in the same bucket and half are going to end up in different buckets, which means that we're going to end up with some of these that are going to end up in, let's say bucket one and some of these which are going to end up in bucket two.
01:01:09.675 - 01:02:17.749, Speaker A: And it might be that this is actually split, right? So it could totally be that. In fact, in fact, this guy over here, Come on, this guy over here also ends up in bucket one. And what we would like to do is because we're going to have to link them into their new places, right? This is B1, this is B2, this over here is N. We would like to sort of amortize the cost of moving many things at once right here. We could just walk the entire list and move each element to its new bucket. So we do an insert for this in the new map, we do an insert for this in the new map with an insert for this in the new map. But that's sort of wasteful, right? In this case, these two elements could just because they're both moving into here, we don't actually like this link is going to remain valid because that link is going to be the same link in the new table because they both end up in the same bucket.
01:02:17.749 - 01:02:59.979, Speaker A: And so we call the Java implementation calls as a run, and it also calls this a run. And what the system is going to do is going to look for a run. It's going to move that entire run into the appropriate bucket. And then for the rest of them, they're just going to do normal inserts. And so that's sort of the idea behind the code that we're about to fix where the error we're getting. And so here you'll recognize what it does. So whether something is a run depends on the bit.
01:02:59.979 - 01:03:40.355, Speaker A: The next bit up from N. And so it looks for runs. This turns out to give you the sum run of N, some run of the bin that are going to all end up in the same bucket. And if the run bit is 0, if the next bin, next bit after n is 0, the those things that were in the run are going to end up in the low bin. So that is B1 in the drawing, or if the run bit is 1, they're going to end up past N. So this is like seven, then they're going to end up in the hibin. And this is moving the entire.
01:03:40.355 - 01:04:27.701, Speaker A: This is moving everything before the run. And here, for anything that we're moving, we're going to allocate new nodes and that node needs to. The nodes that we insert need to be linked to the run that's going to follow them. That's perhaps poorly explained. What we're going to have to do is we're going to have to construct a linked list for each of the two bins, right? One for the low bin and one for the high bin. Remember how we're splitting the bin into two bins, right? So we're constructing a linked list for the low bin and we're constructing a list for the high bin. But whichever run we ended up taking, we're going to have to append to the appropriate linked list and we can append them as one chunk.
01:04:27.701 - 01:05:24.085, Speaker A: That's sort of where we're saving the work. That means that the next pointer here is going to be pointing to the thing that we want to append to the end, and that's going to be. That may or may not be existing nodes, right? It might be one of these shared nulls, but it might also be the run that we found. And what Russ is complaining about is the fact that the next pointer should be an atomic, and it found a shared. So why is that the case? Well, when we allocate a new node for the nodes we're adding to the new linked list, the next pointer needs to be set to something, and we're setting the next pointer to whatever link was. The problem is that if linked was a run that already exists, we only have a shared pointer to it. We don't have an owned pointer to it.
01:05:24.085 - 01:06:12.775, Speaker A: And this is expecting. Well, it's expecting these to be atomic, which is not necessarily owned, but you can think of shared as the target. You can think of atomic as a pointer and shared as sort of the thing that's being pointed to. So if you have an atomic, you can call load and then you get the target of the atomic. Sorry, that's a lot of words. You can probably ignore the past, like, 10 minutes of me rambling, but maybe it helped. The problem we run into here is that we're going to keep appending to this linked list, which means we need to keep track of the start and end of the linked list that we're constructing.
01:06:12.775 - 01:07:30.253, Speaker A: And the pointer to the start of that linked list is owned because we're constructing a new one. But the pointer to the run, which we're going to append at the end is not owned because it's a part of some existing data structure. And Russ is complaining about the fact that these two types are mismatched. And so how are we going to do this? That is a good question. This next. The next pointer. What we're doing here is we're taking the run and we're sticking stuff.
01:07:30.253 - 01:08:34.315, Speaker A: We're sticking all the other things that belong in the same bin to the start of it. So the type of this next pointer is going to be an atomic pointer. So how do we get the atomic pointer for the run that we extracted? Well, in theory, we could get that out right here. So what is the head? Yeah, we need to find a way to get. We want. Not a. I'm trying to figure out how to draw this to explain it better.
01:08:34.315 - 01:09:09.935, Speaker A: Here, let me try. So here's the problem we run into. Oh, man, I wish I had my buttons back. Here's the problem we run into. So this is our node type. Node has a next. Next pointer.
01:09:09.935 - 01:09:56.115, Speaker A: And logically there's a. There's another node where the next points to that node. Right. In reality, though, this. Okay, so the type of this thing is atomic, which really just means that it is a. That it is a pointer. That's all it really means.
01:09:56.115 - 01:11:06.655, Speaker A: But this value, the address stored in the pointer, can change arbitrarily, right? Because it might be accessed from multiple threads. And so when we do an atomic load, what that means is look at, you can think of this as like, look at the pointer to this thing and do an atomic read of what the current pointer is. And the value of this, this is going to return a shared, and the shared is going to contain this value at the time of the read. So even though the value of the atomic is this pointer and the value of the shared is also this pointer, there's a distinction in that the atomic itself, its value, think of it as can constantly be changing. And when we load, what we get is the snapshot of the pointer value at some Point in time. And that is what's stored and shared. So you might do atomic load, get one shared.
01:11:06.655 - 01:12:00.335, Speaker A: Get a shared with a particular address. You might then do a subsequent atomic load with a different shared address. When we are constructing our new node over here, Right? And imagine that this has been identified as a run. What is its next pointer going to be? Well, its next pointer is going to be pointing to this. But this business here is also going to be an atomic. It's not going to be the same atomic, right? These are different points in memory. But it does have to have the same value, which I think means that we can just use atomic new because it doesn't matter that it's not the same atomic really.
01:12:00.335 - 01:12:36.615, Speaker A: Which means that down here, I believe. Let's just look up atomic. Does that have a. From shared. Great. Yeah. So this is just going to be atomic from like expected node found mutable reference.
01:12:36.615 - 01:13:17.379, Speaker A: Ah, yes. This is going to be a star. No implementation for U64 and eyesize. Oh, well, okay. This is another bit that's a little awkward actually. No, this should be fine. Why is N here an ice? Why are either of these an ice? What did it say? U 64 and ice.
01:13:17.379 - 01:14:09.487, Speaker A: So n is an ice. Ice. Why is n an ice? Ice? Where does n come from? N lens, which should be a U size. So why is it saying that it's an eye size? Although reading from the other code, we can just do Zu64 but I'm not sure why it thinks it's an I size. Really shouldn't be. All right. Binary operation cannot be applied to node 465 while p not equal to last one.
01:14:09.487 - 01:14:45.903, Speaker A: This, this is a pointer. Equality is what we want here. So we don't actually want to compare whether. Remember in rust, if you do like, if you do, if you have X of type reference to a node and Y of type reference to a node and then you do X equals to Y, what that will turn into is like x.eek y. Right? That's what Russ is going to turn it into. Whereas here what we want to do is iterate until we reach the pointer that points to the place where we found a run.
01:14:45.903 - 01:15:45.935, Speaker A: And so we actually want a pointer equality here. We don't want it to use the equality implementation for node. So there's a pointer E, I think that lets us do this. Expected shared found reference. Okay, so last run here. Why is last run a reference head? Why is head not a shared. It's a great question.
01:15:45.935 - 01:16:16.915, Speaker A: So lobe in here. These are both shared because they're shared pointers. Last run should also be a shared. Not sure why it thinks that's not the case. Yeah, it's thinking that. So head for whatever reason is a reference and not a shared. Which sounds wrong.
01:16:16.915 - 01:17:01.339, Speaker A: Where does head come from? Here I think I'm blind. Oh, there. Oh I see. Yeah. So the trick here is this dereference. So bin here is a shared a shared to bin entry. But we're dereferencing here which is going to be an unsafe operation.
01:17:01.339 - 01:18:06.915, Speaker A: But that gives us what's inside here is a is a node. So this is a normal reference, not a shared because of this unsafe deref. So I think what we want to do here is say lead is head is shared from head Turn it back into a shared because it came from a shared no field next on shared. So this is d reference no field value on shared. That's D ref 467. Yeah. So this is going to be how do I from a shared shared how do I get its pointer just as raw and p is also going to be as raw.
01:18:06.915 - 01:18:51.241, Speaker A: Yeah. So this is D ref D ref D ref D ref D reference this. Oh, it's not letting me do this because I need to do that. Which is fine. Draft. This is not a draft. Compare and swap.
01:18:51.241 - 01:19:30.945, Speaker A: So this is going to take an ordering. That's fine. This is fine. This is just part of the garbage collection business that we talked about earlier. So that's also going to have to do with D ref swap up here. That's missing something. Expected three parameters probably requires a guard, right? Give me atomic swap takes a guard as the last argument.
01:19:30.945 - 01:20:16.965, Speaker A: Okay. 382 owned does not have a null. Okay so let's look for owned. Oh, interesting. There is no owned null. So if I have a an atomic how do I set it to null store Just takes anything that's a pointer and shared implements pointer so this can just be shared. That's fine.
01:20:16.965 - 01:21:38.755, Speaker A: 361 isize minus u size that's fine. Actually let's just do where is stride? That's going to be an eye size can make that easier. What else do we have that is d ref okay, that's a D ref 334 no garbage. This is going to have to be a swap because we want the old value. So we need to get the. We need to get the value that was there because that is now garbage. That's fine and Yep, that's fine.
01:21:38.755 - 01:22:11.405, Speaker A: 330 Method not found into boxed so what is vec? So the notion Here is I want to take. I have a vector. This is when we initially allocate the set of bins. We have a vector of bin entries and we want to. We want to basically remove the ability to resize it. And I believe there's a method into box slice. That's what I want.
01:22:11.405 - 01:23:20.075, Speaker A: Which basically removes the vec wrapper and turns it into a box slice instead. 309 Transfer that's going to take a guard. 304 that's going to take a guard. 291 Max Resizers that's going to be an eye size as well. 288 Resize Step this is going to be an eye size. Although that really should be a use size. I think what I really want here is.
01:23:20.075 - 01:24:11.221, Speaker A: Wait. What? Why is there a comparison between isize and usize here? Partial equals shared uses pointer equality. Oh nice. Then we can just do this. All right. So why is it claiming that it can't compare those? I'm not trying to compare them to getting confused by this somehow. All right, let's leave that for now.
01:24:11.221 - 01:25:18.825, Speaker A: This is D reference. 270. That seems like a count as I says. That's fine. 241 Guard 233 Expected eye size found you size max resizers eye size plus you size but max resizers is an eye size, right? Yeah. That's weird. 229 is complaining about expected guard found ordering.
01:25:18.825 - 01:26:10.005, Speaker A: That's because the order of these is wrong. Which means the order of this is also wrong. 227. This is a draft. 207 Expected option found integer should be something count. 198 what is this? This is going to be the same thing as before. Where? Here we need to say let head is shared from head as const.
01:26:10.005 - 01:26:55.147, Speaker A: This is just to sort of reapply the shared wrapping after we undid it up here. Let's see what that gives us. Well, there are certainly fewer now. 311 where's the guard comes from up here. This probably needs to take guard. Just use the guard that it's given rather than make up its own guard. All right.
01:26:55.147 - 01:27:32.025, Speaker A: What else do we have? 209. This takes a guard. That's a draft. D ref that is not a draft. No field. No field value on type owned. Well, that is certainly interesting.
01:27:32.025 - 01:28:41.601, Speaker A: Own should have Own should implement DREF though, right? Yeah. Am I missing something here? Oh, bin entry. Bin entry can also be a forward. So how do we know this is not for. Where is this code, this is input the existing value old value node. What is this doing? Why is this even using node? Ah, node is the thing that we construct up here. And so we actually know that it's a.
01:28:41.601 - 01:29:58.215, Speaker A: We know it's a bin entry node. So here what we can do is let owned bin we're going to do entry node node value. We can destruct it here because we know that that is what we constructed in the first place. And this is unreachable. And then this can just use the value 211 missing guard or not missing guard expected reference found guard. And where's this guard coming from? Oh, let's just make this be reference boxed slice pointer to slice. In other words slice.
01:29:58.215 - 01:30:56.995, Speaker A: Yeah, a boxed slice is a. An owned pointer to a heap allocated slice. Draft draft draft186 this is going to be owned actually can I destructure owned? I cannot. Oh. But I can do into box into box which is what I want to do. No field key. This is 182.
01:30:56.995 - 01:32:06.263, Speaker A: Oh, that's really awkward. Yeah, we need to like. It's awful. Node ref key ref hash then key hash. It's because the code doesn't know that the value we've constructed to be put into the map or into the linked list is of type bin entry node. It doesn't know that it's not binantry forward or moved for example. So we need to reachable so we need to tell it that that is the case.
01:32:06.263 - 01:33:53.315, Speaker A: And then once we've done that then now we can use the hash and the key and I guess can actually do this so that you don't have to do it each time. A lot of drefs G ref no field lock that's also draft no field key though that is different. So up here this is the same issue actually where I think actually what we want to do here is probably this just hoist that all the way out. And then up here in this guard this is going to be key which means I guess this can probably be moved even further out. This can be all the way up here and I think we only need the key. Oops. This is basically to give us easy access to the key while we are.
01:33:53.315 - 01:34:37.295, Speaker A: We take the key that the user gives us and we stick it in this in this node. But we still want to be able to easily compare against the key. And so we just take a reference out to it down here and now in these places we can now use the key. This is just going to be H for hash and then I Think we're good. All right, let's try that. What else we missing up here? 162 that one we fixed. 159 this is going to include the guard.
01:34:37.295 - 01:35:23.985, Speaker A: 139 is going to include the guard down here. This is draft. Oh actually that draft drift ref init table has not been found. All right, so this is a function that we're missing. Init table. Interesting. So we do actually have to implement this function.
01:35:23.985 - 01:36:05.449, Speaker A: Should be easy enough though. Init table and I guess it's going to return a shared table. See idea. This is probably pretty straightforward. This is just you decide that you have to allocate a new table which only one thread should be doing. So I think what it's doing here is sort of double checking that there is in fact no table or the table is empty. And then it, it tries.
01:36:05.449 - 01:36:58.821, Speaker A: It checks that no one else is trying to do the table initialization. And yeah, it just allocates the new table. Great. So this should be straightforward here. We can just do while self table load ordering. I guess this is probably also going to have to take a guard. While this is null, it's going to have to be a loop Table is going to be that if table.
01:36:58.821 - 01:37:57.735, Speaker A: If table is not null or and table.bins.is empty. So basically if there is a table that's non empty, then we can just return that table. Otherwise try to allocate the table which is gonna. Which we're gonna do by doing SC is size CTL load. It's gonna take the guard. So we're basically going to check the control bits to make sure that no one else is trying to try and initialize the table at the same time.
01:37:57.735 - 01:38:36.745, Speaker A: If SC is less than zero, we lost the initialization race. Just spin. So that's going to be a thread yield now and a continue. Right. So here what we're really doing is we know that someone else is allocating the table for the first time. So we're just going to yield so that someone else gets to run if they can. And then we're just going to try to load the table again and presumably return pretty quickly.
01:38:36.745 - 01:39:56.755, Speaker A: Otherwise we're going to try to become the people who initialize the table, which we're going to do by doing a compare and swap on the control bit to basically make us the initializer. And we're going to do that by taking the old SC and replacing it with minus one with ordering const. And if we succeed at that compare and swap, then we get to do it let's see. So what does this do? Oh, so at this point we need to double check this business. Interesting. So this is if the table is null or the table is empty, then we're going to allocate it. Otherwise.
01:39:56.755 - 01:40:28.605, Speaker A: So think of this. The syctl is sort of like a lock here. And so we need to recheck the conditions under which we initialize the table after we took the lock. Right. So this compare and swap, if it succeeds, we sort of have the initialization lock. And now we need to check that initialization is actually still necessary. And down here we're going to do a sizectl store script.
01:40:28.605 - 01:41:47.625, Speaker A: Think of this as releasing the lock. And in here what are we going to do? N is if SC is greater than zero, then SC else default capacity. And then this is going to be the allocation which is similar to what we did under resizing new table. It's going to be this. And now we're going to do. Let's see here, this is going to return table. I guess actually we can just break here instead, given that this is a loop.
01:41:47.625 - 01:42:49.525, Speaker A: So in this case, table is going to be, I guess self table store because we're going to store this as the new table and we don't need to worry about deallocating the old one because we've already checked that there wasn't anything there. So we're just going to do this. We're just going to store it straight ahead. And I guess actually we could take a shared from it as well. So if I have an owned, can I get a shared. Yes. So we're going to do table is new table into shared and then this is going to be store table.
01:42:49.525 - 01:43:25.395, Speaker A: Let's see if that's going to work. And then sc. So remember SC is a sort of weird, weird value where if it's negative then it's. Then it's used to also count how many people are helping. Then there's a resize and it's used to count how many people are helping with the resize. If it is not negative, it is the next capacity to resize 2. It's a really weird value.
01:43:25.395 - 01:44:10.405, Speaker A: And so here, because we allocated the table, we're going to set it to N minus N shift right to not sure why. Oh, it's. I think it's actually how many threads are going to help with the resize. It's not the next size, although that's unclear. All right, well in any case, this is what it does. I wonder why. This is a try not clear.
01:44:10.405 - 01:45:06.255, Speaker A: Okay, but that is going to allocate our table for us. Then we break with the table and we return. All right? Now what's it going to complain about? That's draft. That's not a DREF 56. Couldn't that peculiarity be encoded through the type system to avoid future confusion? So one thing that's awkward about this kind of highly concurrent code is that you often the. The you. You're relying on what the CPU lets you do atomically and in this case and usually the CPU will only let you do atomic operations on things that are word sized.
01:45:06.255 - 01:46:00.495, Speaker A: So basically if you have like if you have a 64 bit processor you can only do atomic things on things that are 64 bits or sometimes slightly smaller. Which means that it's not arbitrary types that we can do these atomic operations on. And the site's control field is used sort of in a heavily in an atomic sense. Right? It's used basically as a lock. And so while it would be nice if it was a type that we can control ourself and like it was an enum and you got all these nice properties, if we did we couldn't have these atomic operations on it or we would have to use something more heavyweight as a lock to guard it, which might because it's such a critical piece of the concurrency business that would become a very highly contended operation. Now it could be that we could just replace it with a lock and it would be fine given that it's doing compare and swaps anyway. But I think we're going to.
01:46:00.495 - 01:46:46.845, Speaker A: We're going to assume that the authors of the Java version were like we don't want to lock the size control field. We want to do atomic operations on it. And because that is the case we can't have it be an arbitrary type unfortunately. 156 what's it complaining about here? Bin entry node has no field next that is true node does155 complain about those fields. That's okay.147 expected k found okay so this has to borrow the key. That's fine.
01:46:46.845 - 01:48:19.269, Speaker A: 144 insert this is going to be a self put key value false. So false because we want to allow replacement for insert 136 expected eye size found use eyes has eyesize that's fine. 134 into shared probably takes a guard if and else have different parameters default capacity because SC can be negative actually. So what we're going to do here is this can be an as usize because we're already checking that it's greater than zero. This is a dref de ref deref deref and 313 this business interpret as generic arguments. Yeah, it thinks that eyesize takes a generic parameter SC is what it starts to parses as. But that's not the case.
01:48:19.269 - 01:48:43.625, Speaker A: So we need to make it not be confused. Great. And this is not going to use unsafe cell anymore. All right, so now we need to deal with the. Great. Now we need to deal with all these drafts. So we're going to.
01:48:43.625 - 01:49:46.105, Speaker A: I'm going to commit here just so we finish up port except for garbage collection push it as well for those of you who are following along at home. Nice. Okay, so now we get to a real tricky part. Now we're going to have to deal with the garbage collection part of this. And so if you think about it, if we never deallocate any data, like if we never free anything, then all of the places that have shared, that have shared pointers, it's always fine to dereference them. They will always point to valid data. Right.
01:49:46.105 - 01:50:12.937, Speaker A: And so if we just never collected garbage, we could add unsafe derefs to all the shareds and all of them would always work. That'd be great. But that's not quite satisfactory. Right. What we really want is we want to deallocate things. Like for example, if we do a table resize, we want to eventually deallocate the old. The old table, the old set of bins.
01:50:12.937 - 01:50:47.805, Speaker A: Right. If we remove a value from the map or replace a value in the map, we want the old value to eventually be deallocated. But once you do that now you need to be really careful that if you ever have a shared pointer, that the moment you dereference it, you know that it's going to remain valid. And so that is what this next bit is going to be about. This is a great place where we're going to take a short break for me to go pee and make tea. I'll also annotate this in the video itself that people can jump to this point. So I'm going to run, get t everyone go pee and do whatever you need to do.
01:50:47.805 - 01:53:24.075, Speaker A: If you have questions about what we've done so far or what we're doing next, now is a great time. We'll take just like a short bit for me to go through any additional points of confusion that you might have. Right. So short break time. I should really have like elevator music. But I'll be back in a second. It we are alone, any way to specify an enum type represented a 64 bit INT and do the atomic ops with it.
01:53:24.075 - 01:54:26.925, Speaker A: You can make make an Enum like a wrapper. One issue we would run into here is I don't think it would help us much because here like sc, we really want to say something like it is either negative or positive. Actually we wouldn't have to stick to that. It might be possible to do that and sort of use the high bit as the Enum discriminant. I think it would basically end up with you would be operating on that Enum as if it were a number anyway. And it wouldn't really help you because you wouldn't be able to do things like pattern matching because the, the way in which you would know which variant you're in, you would have to like read out numbers. What we could do is maybe do a new type around SC and have that have some like helpful method names for things like Take control or like methods that under the hood did these atomic operations on the number.
01:54:26.925 - 01:56:19.975, Speaker A: So that might be something we can do. So Erwin, I'm about to go through what the plan for garbage collection is. So I'll do that in like a bit. I think the T is done and then I will. Then we will dive headfirst into garbage. All right, let's see here. So any further questions about the code we've written so far, what the plan is, anything about what we're about to do or does the explanation of why dereferencing shared is safe if you never collect anything, does that make sense? I'm going to take the silence as a yes.
01:56:19.975 - 01:56:56.545, Speaker A: Okay, so here's where it gets tricky. There are a couple of places in the code that we've annotated with. Let me see if I can dig one up here. For example, arguably I can call close this. Now let's close that. There are a couple of places where we generate garbage. This particular example is we are doing an insert and there is already a value for the key that we're trying to do an insert for.
01:56:56.545 - 01:57:47.389, Speaker A: And so we need to drop the old value or we're going to replace that value. Which means that the value that was there is going to go away. And if that value is going away, it should be dropped eventually. But the problem is we can't drop it immediately because there might be other threads that are reading that value concurrently with us. And so the question becomes when is it safe to drop that value? And there are many, many strategies for dealing with this. Mm. One search strategy is if you have a garbage collected language like Java the language has a runtime that tracks whether there exist pointers to basically every object.
01:57:47.389 - 01:58:29.815, Speaker A: Everything that you ever allocate, the runtime is going to keep track of whether you have any pointers to it and whether or no more pointers to it. So there's no way for someone to reach that value. Only then does it get destroyed in rust. We don't really have this luxury because we don't have a runtime. We don't have something that's running in the background and knows what pointers everyone has. Which means that we need to have some other strategy for when do you know that it's safe to drop a value? There are many strategies to do this without a runtime, and there's sort of all this research literature you could look into. What we're going to do is we're going to use one that comes with crossbeam.
01:58:29.815 - 01:59:35.395, Speaker A: We talked a little bit about this in the very early days of this port. Let me make that larger and easier to read. And so actually, I recommend you read this text while I eat some pineapple, because this is basically exactly the strategy we're going to take. But the premise here is that anytime some thread is going to start doing stuff with the map, and doing stuff can be do a read or write. Anytime it basically from the point when it does its first pointer read from the map, and so now has a live pointer into that map or any descendant data structures from that point, we're gonna sort of. We're gonna assert that that thread is in a given epoch. And when it releases the last of the pointers it has into the map, even sort of transitively deep down, then we're gonna say that that thread is now done with that epoch.
01:59:35.395 - 02:00:09.941, Speaker A: What this means is you're gonna have multiple threads and all of them are going to be entering and leaving EPIC epics. It's not technically true. They're going to be pinning and unpinning epics is usually the way it's phrased. And as long as an EPIC is pinned, any garbage that's produced in it will not be freed. So imagine that we are current. We start in epoch one, and in epoch one, some thread pins the epic. So now we are not allowed to move on from Epoch 1.
02:00:09.941 - 02:01:14.049, Speaker A: Epoch 1 is going to stay around for a while, or we can move on. But if that thread or any other thread generates garbage in Epoch 1, that's going to be stored in like the Epoch 1 garbage bin, and as long as anyone still has pointers into epoch one, that garbage is going to Stay around. So any pointers into it is going to be valid because the objects haven't been deallocated. When there are no threads left that have pinned epoch one, epoch one is considered complete or closed or ended. At that point we know that that garbage is no longer reachable by anyone, because if you entered after the garbage was generated, you would have entered an epoch two. And if you entered an epoch two, you can't have reached the garbage because it was already removed. And so once all threads have unpinned Epoch 1, any garbage that was generated in Epoch 1 is no longer reachable by anyone because everyone who's in epoch two must have happened after the removal happened.
02:01:14.049 - 02:02:03.135, Speaker A: And so therefore it's safe to remove that garbage and free those objects. And so this is what's known as an EPIC based garbage collection scheme. We're going to generate garbage and epochs, and we're only going to free the garbage in a given epoch when every thread has moved on from that epic. And because all reads need this is what the guard is for. In order to generate a guard, you pin the epic and so you know that no one is going to. Nothing you read is going to be garbage collected, right? Because I'm going to pin the EPIC and then I'm going to do a bunch of reads. And if someone deletes any of that stuff, it gets deleted in the current epic because I've pinned the epic, so the garbage gets entered in my epoch.
02:02:03.135 - 02:02:32.335, Speaker A: And that means that any pointers I read in that epoch are going to remain valid for as long as that EPIC is open. At some point I'm going to and so I can traverse these pointers just fine, and I know that all of them are safe to access. Then at some point I'm going to give up the epic. I'm going to give up my pin of that epoch. Then I don't have any pointers to anymore. So for me it's fine if any of that garbage is now freed. As long as that is the case for all threads, this should all be safe.
02:02:32.335 - 02:04:01.647, Speaker A: Did that roughly make sense? Should I try to draw it? Would that help? Pedantic on my pronunciation? Sure, go ahead. Does this mean that this strategy tends to accumulate more garbage on average over time than traditional gc, but less bookkeeping is necessary? Sort of. EPIC and epoch, they're both valid pronunciations for epic as far as I'm aware. So EPIC based garbage collection doesn't necessarily accumulate more garbage. The amount of garbage is is independent of the strategy used to reclaim the garbage. The Question is, how long does it take for garbage to be reclaimed? Or phrased differently, how long does it take between something gets deleted and it actually gets dropped? And this is a product of two different things. One is obviously it's not going to get freed until it can be freed, right? So that the time between when I remove something and it actually gets removed is going to depend on if there are other readers that hold on to it.
02:04:01.647 - 02:04:39.137, Speaker A: If, like someone is holding onto it for the duration of the program, it's never going to get freedom. And that's fine. It's unfortunate, but fine. So that amount of time is not that interesting. What's interesting is how long does it take from when no one has a pointer to a piece of garbage until that garbage is reclaimed? And so that period of time is determined by your garbage collection scheme. If you use a garbage collective language, they have different schemes internally too. Like they could, you can implement a runtime garbage collector using epics.
02:04:39.137 - 02:05:08.717, Speaker A: You can use, you can do it using sort of generational gc. There's sort of Stop the World gc, Mark and Sweep. There are all these strategies and they all have different properties in this regard. Very often a garbage collector language like a runtime garbage collector is not going to free anything immediately. Not at all. It's going to try to, what's the word? Amortize the cost of collecting that garbage. So it will also introduce a delay.
02:05:08.717 - 02:05:49.775, Speaker A: The other extreme of this is if you use something like reference counting. Reference counting is a garbage collection scheme. If I have a reference counted value, what that means is at some point I will know that no one has a pointer to it anymore because the reference count went to zero and the moment that happened, I'm going to free it. So in a reference counted scheme, garbage is destroyed immediately once you can. But that can also mean that you don't get to amortize the cost of deallocating things because you must deallocate them immediately. An EPIC based scheme does not have more or less garbage at any given time than a runtime garbage collector. The only thing that's tricky about an EPIC based garbage collection is that it is.
02:05:49.775 - 02:06:40.675, Speaker A: It is sort of based on cooperation. So I mentioned that a thread can choose to pin the EPIC and then release that pin. Well, imagine that some thread pins the EPIC and then runs for a really long time with the EPIC pinned. Well, if they do, any garbage that's accumulated, it's just going to sit around waiting for that one thread. And so it requires that pieces that are using your EPIC based memory Reclamation are cooperative in some sense that they don't hold on to a pin for longer than they need. This is also why if you look at guard, guard has this method called repin. And what repin does is it releases the pin and then immediately takes it again.
02:06:40.675 - 02:07:41.915, Speaker A: And this can be useful because if you repin, you allow the EPIC to move on, right? So because you take immutable reference to the guard, that means that any, anything that was using was dependent on the guard is now no longer valid. The borrow checker is going to check that and you're going to release the the current EPIC you had pinned and then immediately pin whatever is now the next epic. And so this is the way that if you have a thread that's like really busy doing some operations, it can occasionally repin. In order to let garbage be collected, do all previous epics have to be unpinned? That is, if EPIC1 is still pinned by some thread, we are in epoch three and epic two has some garbage and no one has pinned two. Could it be freed? Not quite. So you can't. This depends a little bit on the exact scheme.
02:07:41.915 - 02:08:28.815, Speaker A: Let me see if it says here. Yeah, so there is a global epic and you are pinning the global epic. So that means that if I pin epic one, no one is moving on. We are staying in Epoch 1 until everyone has moved on from Epoch 1. And so it's not, it's not as though every thread has its own epoch. It's that either you are in the current the pin the current epoch, or you are in the next epic. And once all the threads are in the next epoch, then the next epoch becomes the global epic, if that makes sense.
02:08:28.815 - 02:09:19.115, Speaker A: So there usually aren't many epics. There could be, in theory. You could, you could do sort of generational epics. But I don't think that's what Crossbeam does because it gets, gets really hard to keep track of. Does that make sense? Okay, in that case we're going to try to do this. So the, the gist of Crossbeam's EPIC base reclamation is that when you have a guard or whenever you load a value, you have to give a guard to say that I this, I load this value and it's protected by this guard. And the guard of course pins the epic.
02:09:19.115 - 02:09:56.175, Speaker A: So it's sort of like the, the read I'm doing now is going to remain valid for the current epic. And you'll see that there's this defer destroy. So defer destroy is. I say this value is now garbage whenever the epoch Moves on. You should feel free to free it and then crossbeam will under the hood take care of that. Freeing whenever all the threads have unpinned the previous epic, so to speak. And so what we need to do is use the guards, defer, destroy in the appropriate places where we generate garbage.
02:09:56.175 - 02:10:33.721, Speaker A: And in theory, that should be. This pin has nothing to do with standard pin, by the way. These are separate concepts. So any place that we generate garbage, let's see. Yeah, so the phrasing here is important. There is no guarantee when exactly the destructor will be executed. This is if we mark.
02:10:33.721 - 02:11:31.875, Speaker A: If we do a deferredestroy, the only guarantee is that it won't be executed until all currently pinned threads get unpinned. Right. Okay, so this is really important the moment we mark this as garbage. So when I do guard, dot, defer, destroy, now garbage, I like to annotate any unsafe code with a statement about why it is actually unsafe. So in this case, why. What we need to argue is actually, let's double check that I'm not being stupid. So for safety, the object must not be reachable by other threads anymore, otherwise it might still be in use when the destructor runs.
02:11:31.875 - 02:12:09.585, Speaker A: And the value must be sendable. The value must be sendable. That's going to be its own kind of interesting. Okay, so we're going to require. Actually, this is a little awkward. We're going to have to require that the value is sending. It's also going to have to be sync, obviously.
02:12:09.585 - 02:13:31.555, Speaker A: And I think the key is also going to have to be sync. Okay, so the safety we need to promise here need to guarantee that now garbage is no longer reachable. More specifically, no thread that executes after this line can ever get a reference to null garbage. Well, let's think about whether this is true. So think about a thread that a thread that already pinned its EPIC might have a pointer to this garbage. Right? Think about what happens if a reader reads this value and then we replace it. So we mark it as garbage.
02:13:31.555 - 02:14:28.327, Speaker A: That old thread still has a reference to it, so it's not safe to drop. And so the question is this deferred destroy still safe? And the argument is that, well, if someone has already pinned the current EPIC or phrase differently, we have pinned the current epic. That means that no one else is going to get. Anyone else who pins the EPIC is also going to get the current epic. So if someone else reads this value, that is prior to the line where we swap it out. The moment we swap it out, no one else can See it any future thread, any one of the pins in the future, they are not going to be able to access this value. It's only about threads that executed before this line because they are the only ones that might have seen that value and have references to it.
02:14:28.327 - 02:15:32.515, Speaker A: So any previous thread must have pinned what either before we took our guard or while our guard was active. That means that they must be in the same epoch that we are, or in an earlier one. And because that is the case, we know that this garbage is generated as of the current epoch, so won't be freed until the next epoch. And we just said that any thread that has seen this value has a reference to this value, must be in a previous epoch, and therefore this safety is promised. Let's see if I can phrase this for the purposes of the comment. No thread that executes after this line can I get a reference to now garbage? We are there are here are the possible cases. It's like a useful exercise in.
02:15:32.515 - 02:17:00.831, Speaker A: A useful exercise in like working through safety issues. Another thread already has a reference to now garbage. Well, they must have read before swap before the call to swap. This means there their guard must have been taken. Either their guard was taken before and was created before our guard in that case. Actually this is not a separate one. Either the guard was created before our guard, in which case, see, another thread already has a reference to Nagarbage.
02:17:00.831 - 02:18:38.855, Speaker A: They must have. They must have read before read it before the call to swap. Either because of this, they that thread must be pinned to less than or equal to to an epoch less than or equal to the epoch of our guard. Since the garbage is placed in our epic, it won't be freed until the next epic, at which point that thread must have dropped its guard and with it any reference to the value. The other case is another thread is about to get a reference to this value. They execute after the swap and therefore do not get a reference to the value. So free to no garbage, they get value instead.
02:18:38.855 - 02:20:12.365, Speaker A: So freeing now garbage is fine. All right, so that is the argument for why freeing here is safe. Does that argument make sense? Don't you need to guarantee that the swap pointer was unique, not stored in any other shared place? Yes, that is also true. We need to guarantee that this pointer, this now garbage pointer is this distinct is not ex. There are no other ways to get to a value except through its node, which is what we swapped through its nodes. Value field is what we swapped. So free now we're just fine.
02:20:12.365 - 02:20:55.797, Speaker A: Yeah, so there's a requirement that there's no other path to that value either. If there were, it would be a problem. All right, where's the other one? So that was for freeing values. And this one. Oh, I feel like we're missing a case here. So here, this is. We've done a resize and the resize is finished.
02:20:55.797 - 02:21:23.625, Speaker A: So that is. Yeah, this is. The resize is finished. So the next table becomes the current table and the old table needs to be freed. Right. This is the vec that we did like into box slice for. So that needs to be freed somehow.
02:21:23.625 - 02:22:10.987, Speaker A: How are we going to do that? Well, so here we're going to have an unsafe guard defer destroy garbage. I think I want this to be actually. No, that's great. Safety. So this one is a little trickier to argue because here we need to guarantee that actually we need to guarantee the same thing. Right, so let me grab the safety from before. Right.
02:22:10.987 - 02:22:39.585, Speaker A: So this is the property we need to guarantee that now garbage is no longer reachable. No thread that executes after this line can ever get a reference to now garbage. Right. So the safety property we need to uphold is the same. And so here are the possible cases. Either let's copy the cases as well. The argument isn't quite the same.
02:22:39.585 - 02:23:17.799, Speaker A: Well, actually the argument is pretty similar. Another thread already has a reference to now garbage. They must have read it before the call to swap. So that is certainly true. Because of this, that thread must be pinned to an epoch that's less than or equal to the epoch of our guard. Since the garbage is placed in our epoch, it won't be freed until the next epoch, at which point that thread must adopt its guard and with it any reference to the value. So that holds true here as well.
02:23:17.799 - 02:24:53.335, Speaker A: If someone else has a reference to what is now garbage, it must be because they read self table in the past, which means that they are tied to an epic in the past, which means that as long as we drop in the next epoch, we're all good. Oh, you can indent unindent with the number of lines followed by double angle bracket left or double angle bracket right. But in this case it's just rust format that does it for me. The other case is, and this is where the safety really comes up, is we need to guarantee that another thread that's about to get a reference to this value won't get a reference to this value. So how can we guarantee that? Well, actually, let's do this. First we need to argue that sale of dot table is the only way to get to that. There Is no other way to get to self table to get Sorry to get to now garbage.
02:24:53.335 - 02:25:48.295, Speaker A: Right, so this is the uniqueness property that we need to guarantee. We can't free something if or we can't. We can't give this guarantee that no other thread is going to get to now garbage unless we give the argument for why. Well, it is not accessible through self table anymore. It cannot be. It is not accessible through self next table anymore. What about forwarding nodes? So this is bin entry moved.
02:25:48.295 - 02:27:12.985, Speaker A: Well, okay, so the argument here is there are going to be some bin entry moves that or there might be some bin entry moves the point into now garbage. Because remember, bin entry moved is. Is bin entry moved is just contains a reference, just a raw pointer to the table that you're going to go search in. Well, for a only bin entry moved that existed before. Well, the only bin entry moved that point to now garbage are the ones in previous tables. I guess let's call it earlier table. Previous tables is good to get to those previous tables you must go.
02:27:12.985 - 02:28:38.927, Speaker A: One must ultimately have arrived through self table because that's where all operations start start their search. Since self table has now changed, only old threads can still be accessing them. Now changed, only old threads can still be accessing them. No new thread can get to past tables, no new thread can get to pass tables and therefore they also cannot get to moved that point to now garbage. So we're fine. It seems like Rust is not helping as much as it could using this allocation scheme. Maintaining these invariants seem hard to reason about.
02:28:38.927 - 02:29:32.695, Speaker A: That's true for this kind of low level concurrency. Like this is just unsafe code and it sort of has to be. Think of it this way, unsafe code is. It's there in order to let you write code that relies on invariants that the compiler cannot check for you. And it's totally true that the Rust borrow checker just like does not understand what we're doing here. Remember, we're relying on really intricate concurrency properties here, right? We're relying on things like the relative ordering between different atomic operations or control of like the size control field, right? And these are things that the compiler doesn't know. This, this is why for many of these data structures, like people have written long research papers about writing formal proofs why they're correct.
02:29:32.695 - 02:30:24.975, Speaker A: And so the Rust compiler doesn't really help us that much here. Now it does help us in some regards, right? Like this sort of guard and shared scheme does help. It does mean that it's harder to write incorrect code. But it does not by any means make it impossible, but it does mean that any code that might be incorrect is going to be marked as unsafe. There are also some other things that this saves us completely from, right? Like the putting the restriction that the key and the value are sync and that the value is send. In fact, I think the key also has to be send, now that I think about it, because it might be deallocated by a different thread. So these properties, the compiler just has no chance of checking for you.
02:30:24.975 - 02:31:18.815, Speaker A: But that's why it's nice. The Rust provides this sort of escape patch of. If you think you know better, like you know that the invariant makes sure that this is okay, then go ahead. Okay, so actually we can make this argument in a perhaps slightly more useful way, which is we first say. First, let's talk about threads with existing references to now garbage. Such a thread must have read. It must have gotten that reference before the call to swap.
02:31:18.815 - 02:32:23.755, Speaker A: Actually, no, here. Actually, yeah, this is the way to make this argument. This means that no future thread I in a later epoch where the value may be freed can get a reference to now garbage. Next, let's talk about threads with existing references to garbage. Such a thread must have gotten that reference before the call to swap. Because of this, that thread must have pinned to an EPIC less than or equal to the epoch of our guard, since our guard is pinning the epic. Since the garbage is placed in our epic, it won't be freed until the next epoch, at which point that thread must have dropped its guard, and with it any reference to the value.
02:32:23.755 - 02:33:41.373, Speaker A: You'll notice that these safety arguments, the safety arguments about when we free stuff, that safety argument is really the safety argument for both this and for the reads, right? If. Because as we mentioned before, if all of the. If we never deallocated things, then all of the reads would be safe. Like all of the dereferences would be safe. And so once we make the argument that this deallocation is safe, then that is sort of inherently also the argument why the D refs are safe. There should be one more of these, which is when you free a bin, although I can't find that now, which is interesting. One challenge we have with the Rust code compared to the Java code is in the Java code, it never actually specifically says where it drops a value.
02:33:41.373 - 02:35:16.219, Speaker A: Like when it goes out of scope, it just sort of like it just overwrites a value and then the old value will be garbage collected. So there's definitely at least one memory leak here, which is down here. Here the old P's P is now garbage because it has been replaced with the node we allocated above. Right? So this is. You're doing a resize and you're going to take. There's an existing linked list, right? And there's a new linked list and which we're transferring into. And we're going to.
02:35:16.219 - 02:36:07.745, Speaker A: For every node in the old linked list, we're going to create a node in the new linked list and we're going to fill it up with the field from the old one. And we. And once we've done that, the old linked list. The nodes in the old linked list are now garbage, right? Except for the run which remove wholesale. But we can't free them yet because there might still be someone sort of reading from the old map and hence the old. The old bin. The old linked list.
02:36:07.745 - 02:37:36.267, Speaker A: So. But it is garbage. And so here we are going to do guard deferredestroy P. All right, well, why is that indentation being weird? Strange. So what's the safety guarantee here? First we need to argue that there is no longer a way to access P which is not actually true. That's only true down here. Yep.
02:37:36.267 - 02:38:40.163, Speaker A: That's awkward. So it's not actually there, it's down here. The old bin linked list is now garbage. Everything up to last run in the old bin linked list is now garbage. Those nodes have all been reallocated in the new bin linked list. All right, so first. So this is going to be basically the same while loop is up here.
02:38:40.163 - 02:39:43.551, Speaker A: I'm going to do this business. Right? And then we need to give the safety argument here for why this is actually the case. First, we need to argue that there's no longer a way to access P. So why is that the case? Well, it is no longer possible to access P because the only way you would access P is through the table and the table's entry is now moved. The only way to get to P is through table. Right. Let me just double check that.
02:39:43.551 - 02:40:51.005, Speaker A: Yep. Is through table or table I. Specifically, since table I has been replaced by a moved node or move with a bin entry, moved P is no longer accessible. Okay, so that's pretty straightforward. Next we need to argue that actually we can simplify this argument. We need to argue there's no longer a way to access P. Any existing reference to P must have been taken before table dot store bin, at which time we had the epoch pinned.
02:40:51.005 - 02:42:16.295, Speaker A: So any threads that have such a reference phrase is better an existing reference to be must have been taken before table, store bin at that time we had the epic pinned. So any threads that have such a reference must be at at our epoch. Must be before or at our epoch since the P isn't destroyed until the next epoch. Those old references are fine for are fine since they are tied to the those old threads pins of the old epic. This is basically the same argument for each of these. It's the same argument about why destroying is fine, or rather why old references are fine. New reference is sort of the key safety concern, really.
02:42:16.295 - 02:43:56.097, Speaker A: Pretty sure there's at least one more missing and that is when the whole table is dropped. So specifically we're going to have to implement is that down here? Impl KV Drop for table kv. I missed the word fine. Where? Where did I miss the word fine? I mean, I'm sure I did, but. Okay, so this one is a little subtle here. We're going to have to do for bin in self bins. Great, Good catch.
02:43:56.097 - 02:45:13.461, Speaker A: Thanks. For bin and self bins. What's head here? How do I easily get that we're gonna do. Oh, I see. Okay, so this is gonna be. This is actually gonna be bin I in bin is self bin bin I if. Ah balls.
02:45:13.461 - 02:47:41.835, Speaker A: I don't have a guard, do I? So Erwin, you can use valgrind in and rust as well. Background works just fine with rust code well so okay, so what I'm thinking here is when a table is dropped. Oh, when a table is dropped. Actually this is much better than I thought. Debug assertions forbin for this assert cross beam epic guard epic pin assert bin is null or we have a node here I'm going to implement this has moved. So the idea here is. The idea here is we don't actually need to do anything we when we drop a table because if it's dropped because the resize finished then all of them should be moved anyway is moved I guess has moved.
02:47:41.835 - 02:49:04.565, Speaker A: Terrible spelling. Bins should have been moved or freed by whoever is dropping the table. If table is dropped due to a resize all bins should have been moved already. If table is dropped due to the whole map being dropped the map drop impul should have done the work. Cert bin is null or bin is moving then the work to destroy everything. So in fact we don't need to do any of this work here. That's refreshing.
02:49:04.565 - 02:50:29.649, Speaker A: We are however going to have to do drop for this is going to be KVs drop for flurry #map KVs because when you drop the map we want to make sure that you still end up dropping all the values and dropping all the bins. We have a huge advantage here though, which is drop takes immutable reference to self. That means that we know that there's no one anywhere who has any pointer into the map. And there's a special thing in crossbeam for this, which is where is it? Guard guard Epic unprotected. So this unprotected is used. It's basically a way to get a guard that will immediately destroy anything. The most common use of this function is constructing or destructuring a data structure.
02:50:29.649 - 02:51:15.345, Speaker A: And the reason of course. Yeah, exactly. We can use the dummyguard in the destructor because at that point no other thread could be concurrently modifying the atomics. Right, because that would just unnecessarily slow things or defer things. So we can do here we can do guard is crossbeam epoch unprotected unsafe safety. Not concurrently. We have mute self so not concurrently accessed by anyone else.
02:51:15.345 - 02:52:24.135, Speaker A: Nice. And now what do we want to do? Well, we basically want to walk the entire map and go through and free everything or destroy everything. Question is, what's the best way to do that? I think we're going to assert here. Oh, oh, there's some trickiness here. Like if the map got dropped in the middle of a resize. I think for now what we're going to do is assert that self next table load guard ordering const is null. Then we're going to load the table.
02:52:24.135 - 02:53:24.195, Speaker A: Then we're going to walk all the bins in the table and then we're going to do bin load guard ordering. Can you resize to 0? No, I think the resize is only ever growth. I don't think it lets you shrink the map. Although maybe that would be nice actually, if there was a neat way for us to do that, but not easily, I think. You see, this is like already a growth. I don't know that there's a way to shrink it after, which is perhaps unfortunate. But luckily this code is going to be fairly straightforward because it doesn't really need to do that much.
02:53:24.195 - 02:55:14.755, Speaker A: Specifically if bin is null continue. All it really needs to do here is do here this business let mute P has been all not P is null. And here the safety argument is actually pretty simple. We're dropping the map, the entire map, so no one else is accessing it. We are also leaving actually technically here we could do like we kind of want to leave in place a sort of destroyed here, although it shouldn't really matter load because here we can just do like. In fact that's Perfect. We just store.
02:55:14.755 - 02:56:16.265, Speaker A: We just store this, which is even better. We can just swap this with a shared null. We also replace the bin with a null so there's no future way to access it either. One thing that's missing is we also need. This load needs to go before because otherwise the drop here would drop that piece, we wouldn't be able to access P next. Oh yeah, yeah. The same argument came in chat.
02:56:16.265 - 02:57:46.733, Speaker A: There's another thing missing here which is that we want to. Where's the value? Yeah, the value itself is also an atomic p value.swap null card ordering sec const value and then we're going to guard, defer, destroy the value first drop the value in this node. Although there's another thing missing here which is. Oh, that's awkward. This is actually. We're going to have to match on p here.
02:57:46.733 - 02:58:54.245, Speaker A: We're going to do if. Bear with me here for a second. P is if let bin entry moved is bin actually this can just be a match. If it's a bin entry moved, then we just want to drop the value immediately and we don't actually need to do any of this like recursing. So if it's a moved, we just do this bin and if it's a bin entry node, then we actually need to. Then we actually need to walk the list. This is going to be mute.
02:58:54.245 - 02:59:53.295, Speaker A: So actually we're going to do this. I think ref head is shared from head. Right. So the drop here is we walk all the bins, we swap each bin for null because we're going to empty it out anyway. We have to look at what was in the bin. If the bin was just a moved entry, then we can just destroy that bin without thinking any more about it. If that bin was actually the head of a linked list, then we're going to have to walk the linked list, drop the values as we go and drop the nodes as we go.
02:59:53.295 - 03:01:07.885, Speaker A: And what we want to do here, I guess safety below, we replace the bin with a null. We own the. We own all the nodes in the list. We find the next, then we move to the next node and drop the one we passed through. All right, so that should indeed, that should free all the things. All right, so now is there anywhere else where we drop a value? When you resize, you drop the old bins, the old nodes in the linked lists, and then you drop the old table. But at that point it should be all empty.
03:01:07.885 - 03:02:15.055, Speaker A: Actually, that's not true. There's one thing we're missing and that is. And that is down here we do have to drop the if the head of the linked list is one of those is like forward pointers we still need to drop that head. So this is actually not entirely true. So this is going to be unsafe. Epic unprotected safety. No one else is accessing this table anymore so we own all its contents which is all we are going to use this guard for.
03:02:15.055 - 03:03:32.645, Speaker A: So this is we need to drop all drop any forwarding nodes since they are heap allocated and we're just going to do a straight up for bin in self bins we're going to do bin is bin. I guess swap. I'm just going to leave null pointers behind because there's no real reason not to. Sure. We can do a sequential consistent here. And if bin has moved I don't think we even need this house moved function. If let bin dot is null then we just continue.
03:03:32.645 - 03:04:28.391, Speaker A: If let bin entry moved is bin then we want to free it. So this is going to be a deferredestroy of bin and that is safe. It's safe by the same safety property we gave above. Otherwise this should be unreachable. Dropped table with non empty bin See what that gives us. All right, so the derefs are still missing. Right.
03:04:28.391 - 03:04:57.385, Speaker A: We just want to check that we haven't broken any of the things for. Here's one. This should be guard and guard. I always get the ordering of these wrong. It's annoying. These are all drafts. Draft ref DRF that's fine.
03:04:57.385 - 03:06:12.991, Speaker A: 158 is missing lock which is going to be. What do we say that this lock type was? It's a parking lot Mutex 160 it's an atomic new draft draft reference DREF and 620 it's going to be cross beam. Let's see what that does. Draft ref D Ref New empty Great. Okay, so I think all the remaining ones are drafts. So now let's think through it one more time. Is there anything else anywhere else where we drop value? You do a resize and when you do a resize eventually the old table is getting freed that we've dealt with.
03:06:12.991 - 03:07:08.285, Speaker A: And when the old table gets freed it's been heads that are forwards must be freed. We've dealt with that. If a value gets replaced the old value gets freed. We've dealt with that. If the map itself gets dropped then we need to drop all of the entries We've dealt with that and all of their values and we've dealt with that. Okay, so I think this means that we now have all of the, all of the destruction in place. And so now let's do the save for that all add all garbage collection logic.
03:07:08.285 - 03:07:52.545, Speaker A: Okay? So the one thing that's now missing is that, as we've talked about before, shared does not actually implement D. Right? And so that's why we're getting all of these errors. It's because dereferencing a shared, which is the raw pointer into a reference into the inner value for. Let me pull that up here. A shared dref. So you see the D ref function is unsafe, right? It is. It does not implement the D ref trait, which is commonly the case for wrapper types like this.
03:07:52.545 - 03:08:50.705, Speaker A: And the reason is because it could be pointing to invalid memory, right? A shared is really just a raw pointer, it's nothing else. And okay, so we need to, whenever we want to deref a shared, we're going to have to deal with this property, right? So this is the safety we need to guarantee when we want to call deref. Dereferencing a pointer is unsafe because it could be pointed to invalid memory, right? So this is what we talked about with garbage collection. So we need to make sure that we haven't freed the memory that it's pointing to and the pointer isn't null. Another concern is the possibility of data races due to lack of proper synchronization. For example, considering the following scenario, a store owned new relaxed a load. Relaxed unwrap.
03:08:50.705 - 03:09:37.369, Speaker A: The problem is that relaxed orderings don't synchronize initialization of the object with the read from the second thread. So one reason why this is less of a problem for us is that all of our orderings are currently sequentially consistent. But also the Java code is pretty careful about making sure that a load is going to check the value that it gets back. It's not just going to like immediately download the value. What's the as ref here? Oh, that's to get through the owned. Yeah, I think the primary safety requirement is here. And in fact, for basically all of the places where we do this D reference, the argument is going to be the same.
03:09:37.369 - 03:10:00.885, Speaker A: The argument is going to be because of our. Because our destruction logic guarantees that it's safe. All these D refs must be safe. So let's just walk through these, I guess bottom to top. 83. Hmm. 83.
03:10:00.885 - 03:12:00.909, Speaker A: Okay, so this is going to be a draft and it's going to be an unsafe safety. Next will only be dropped if we are dropped, we won't be dropped until EPIC passes, which is protected by Guard 38 Ooh. Table is unsafe table drop I don't think this needs to be a shared. I think this is just a straight up. Actually no, we do want it to be tied to the guard. I think no, we can just do this and. Okay, so the argument here is safety.
03:12:00.909 - 03:12:59.845, Speaker A: We are referenced to the old table otherwise we would never reference to self. We got that under the given guard since we have not yet dropped that guard. No collection has happened since the self can't have been collected yet and so neither has next table. We've not yet dropped that guard. This table has not been garbage collected and so the later table definitely hasn't. Safety Same as above. Great.
03:12:59.845 - 03:15:11.675, Speaker A: Now what line? 43 bin okay, so here what do we want to do here? Here we want to say bin deref Let bin is unsafe bin deref safety the table is protected by the guard and so is the bin. What solution takes two arguments. Guard makes sense. 34 can't be null 672 forbin in mute self bins is not an iterator. It is now 677. Okay, let bin is unsafe bin deref safety we. What's the safety here? We own self or we have exclusive access to self so no one else will drop this value under us.
03:15:11.675 - 03:16:30.185, Speaker A: 673 what? This is probably me being stupid. The guard needs to come last. 681 expected shared found reference. I see. It's just this. 646. All right, so here this is going to be unsafe PD reference safety.
03:16:30.185 - 03:18:26.465, Speaker A: Actually the safety is just the same here. That the same reason why we're allowed to destroy P down here is the reason why we're allowed to deref it up here. It's the same safety argument. 642 no value no field value on type P. Why is that really? That should give me a node and node has a field value. It that's interesting actually that what does the next pointer here? The next here is an atomic which I think means that the head here freeing the first node is actually a little bit different from freeing the subsequent ones because the first node in the linked list is a bin entry which contains a node. Right? So we have an atomic bin entry which contains a node.
03:18:26.465 - 03:19:25.865, Speaker A: The subsequent ones are just straight up atomic node so they're a little bit different which means that the freeing has to be a bit different too. Which is kind of awkward. Yeah, it's going to be a little awkward. I think what we want to do here is does it mean that the first node and the subsequent do not have the same type. Yeah, the first node is a bin entry node. So it is a bin entry node which internally contains a node. Right.
03:19:25.865 - 03:19:45.549, Speaker A: And then that whole thing is wrapped in an atomic. That's like the head type. But the next pointer is just an atomic node. There's no bin entry here. Right. So they're actually different types. And normally this is fine.
03:19:45.549 - 03:20:32.765, Speaker A: Right. Because we're only ever calling methods on node. We're not calling that many methods on bin entry, except for find, which we're already using. The challenge is that when you want to free them, they actually have to be free read differently, which is kind of awkward. So I think what we're going to do here is we're going to do head dot load next. Next load is what I meant. Guard.
03:20:32.765 - 03:21:35.065, Speaker A: And then down here, now drop the head, which is going to be this business. It's going to be safety same as for the tail above. So that should do. Should do that. 660. This is me being stupid because guard has to come last, which probably means that I messed this up somewhere above 2 up here. This has to have guard last.
03:21:35.065 - 03:22:34.075, Speaker A: Probably means that this needs to have guard last. All right, how about that? All right. 625 shouldn't pin fix the issue for self referential structs. So I don't think this is really an issue with linked lists. This is specifically an issue with a like linked list in this particular context where you also have delayed dropping. It is true that the standard library pinning will help with writing linked lists, but not this type of linked list where you have a lock free linked list. Can the tail end of your loop unwrap the atomic node to an owned node to match the first state? The problem is when you call deferredestroy you have to pass it a type that was.
03:22:34.075 - 03:23:05.313, Speaker A: That was originally a allocated using as using an owned. Right. And we never. For the head of the list for this first node we never constructed an atomic node. For the head we construct an atomic bin entry node and so we can't. Even though we can construct if we want to, a shared node, that would be incorrect because that's not the thing that we're supposed to free. We're supposed to free a shared bin entry node for the first entry.
03:23:05.313 - 03:24:15.485, Speaker A: For all the others we're supposed to free a shared node. So that's why it actually has to be different. Note that we must do this separately because for the head of the list we're dropping a shared bin entry node node Not a shared node. That makes sense. All right, so 625 for bin in table bins. Right. I guess here table is going to be unsafe table deref safety safe because same as above, 627.
03:24:15.485 - 03:25:05.345, Speaker A: That's true. So you come to think of it, where's the place where I do like this doesn't need to be that at all. It might be easier to manipulate using atomic into owned within the drop impl because an own pointer will drop for you when it got out of scope and you get safe derefs. That might be true though it's like unclear it matters that much. Well, okay, sure. We can do bin is bin into owned. So what it's called for shared.
03:25:05.345 - 03:25:57.303, Speaker A: Yes, into owned. Right. So this is your proposal, right? What if a bin head gets removed from the map, the next bin entry should change type type to replace the head. That is a good question. I'm not sure. We might have to make the head an atomic like be on a. Be a atomic bin entry node where bin entry node is an atomic node, which would be awkward to say the least.
03:25:57.303 - 03:26:30.687, Speaker A: Although it would mean that we could stick the lock right in that head. Maybe. Let me think about that. You. You might be totally right that. Well, so currently we don't implement removal I think. But yeah, I think once we.
03:26:30.687 - 03:27:02.897, Speaker A: Once we implement remove. I think you're totally right that that would be the case. And we'll have to look at what we do with that. That might actually change the underlying impulse. I agree. Okay, so here the argument is actually that self table. I see.
03:27:02.897 - 03:28:15.833, Speaker A: So here we can actually do a shared null. And then we can do into owned. And here we can do bin is bin is unsafe bin into owned. And here let P. So here we can actually take ownership of the P node is unsafe P into owned. I agree. This.
03:28:15.833 - 03:29:24.575, Speaker A: This does make it nicer. And now this can be into owned and then this can be. No, next. If you own the table, atomic into own skips the atomic load entirely. Oh, there's an atomic into owned as well. What does that do? Is that like if you have a mute self. Oh, that consumes self though, which I can't easily.
03:29:24.575 - 03:30:29.995, Speaker A: Oh, I see. You mean if I have this, then I can do this. I see. And then here we can do. So we can actually do even better now because we own this head here we can do a swap with shared null. Mm. That's owned.
03:30:29.995 - 03:31:39.665, Speaker A: Then this value we can now do value into owned and the bin is now going to be dropped automatically. And I wonder whether we can do even better, which is because we own this value. This we can just do into owned. And similarly here, this we can just do into owned. Yep, that should do it. That's nice. And then maybe we don't even need the guard.
03:31:39.665 - 03:32:56.735, Speaker A: In fact, we can do into owned here because we own the head and then we just do node next into owned here. Right. We still need the guard for the top level though, I think because we don't technically own the table because we only get mute self. But this does make it a lot nicer. I agree here. Yeah, this is going to stay the same. Nice.
03:32:56.735 - 03:33:39.395, Speaker A: I agree. That's much, much nicer. 680. Is this complaining about outright star? That actually gives us an owned back, not a method not found for owned nod. Yeah, this is just P now. 634. Ah.
03:33:39.395 - 03:34:37.355, Speaker A: If P next dot is null, break. Actually, that's awkward. Panics of the pointer is null. Yeah, but is there a way for me to check whether it's null without loading it? Nope. That's not great. That's really awkward. That's really awkward.
03:34:37.355 - 03:35:23.835, Speaker A: Yeah, I think we actually do need to do like a load here, which is super awkward. It's fine. It's just sad. And table bins. This is awkward too. Balls. We can't actually destruct this one.
03:35:23.835 - 03:36:07.255, Speaker A: Well, actually, no, we can. We can do vec from boxed slice. Isn't there a box slice? All right, 632. What's here now star. That. That's fine. 602.
03:36:07.255 - 03:36:53.685, Speaker A: Okay, so now here we really need to do a deferred destroy. That's fine. And this is going to be an unsafe P defer. And the reason that defer is safe is the same reason why it's safe to defer destroy. So that's all good. No method name defer. That's because it should be ref.
03:36:53.685 - 03:37:18.265, Speaker A: Wow. So many drafts. 584. Okay, so here, next table and table. So I think what we want to do here is to say none of this changes table or next table. Right? No. Great.
03:37:18.265 - 03:38:33.075, Speaker A: So up here. Okay, so here we need to make an argument along the lines of table deref, why that is safe, and next table D ref. Why are these safe? Why are these safe? It's a great question. I don't think that they necessarily are. I think that only if this is the case are they safe. Right. So in this case, those shares were both constructed.
03:38:33.075 - 03:39:45.005, Speaker A: What do I want to guarantee here? So for transfer, we want to guarantee that both table and next table remain valid. Specifically that they're not destroyed, they will be dropped when the guard is dropped. Right. We're guaranteeing that with the signature because if the guard was dropped, if the guard was dropped, then these would no longer be valid. So by having this constraint, we're saying that you that these shares are tied to the lifetime of this guard. Great. So that's what we want.
03:39:45.005 - 03:41:03.825, Speaker A: As long as that is the case, these will be dropped at the earliest or these were red while the guard was held. While guard was held, we still hold guard. And the code that drops these won't drop these ensures that they are only dropped. Actually, we got to be careful here. These were read while guard was held. We still hold guard. So guard was held.
03:41:03.825 - 03:42:16.791, Speaker A: The code that drops these only drops them after A, they are no longer reachable and B only drops them after they are no longer reachable. And B any outstanding references are no longer active, we are still active. These references are still active, marked by the guard. So they won't be dropped. So the target of these references won't be dropped while the guard remains active. So safe with all that unsafe. So keep in mind that for each unsafe block here, we're thinking very carefully about why that unsafety is okay.
03:42:16.791 - 03:43:12.725, Speaker A: And it is true that like unsafe code is less safe than safe code. But the reason for that is because in unsafe code you are you, as the programmer are telling the compiler, I have checked that I maintain the necessary invariants and the compiler cannot check those invariants for you. That sort of, if they could, then you shouldn't be writing unsafe code in the first place. And so this is really us being really careful about thinking through why. How are we sure that we're upholding the things that the the sort of restrictions of the unsafe code. Okay, now we're at 591. Wait, but that's why no method as raw found on table.
03:43:12.725 - 03:44:15.793, Speaker A: Oh, that's just this. That's fine. 591 expected USIZE foundation eyesize where does this I come from? Oh, I see. Well, at this point I can be usize because if it was negative, we would enter this. 591 respected owned found shared. So that is store bin. And I think this can take anything that's a P.
03:44:15.793 - 03:44:57.985, Speaker A: Where P is crossbeam epoch pointer. Right. Store is pointer to one of these guys. Now imagine this was C and you would have to go through all the code to check those invariants. Yeah, exactly. So the idea here is that at least we only have to check the unsafe parts. That's the idea.
03:44:57.985 - 03:45:37.095, Speaker A: And it's true. This code we're writing is like highly concurrent and unsafe code, but that's sort of what we chose to write. And the idea here is that once we get this code to be right, anyone who uses this code will not have to think about that on safety. That's the idea. We're sort of encapsulating the unsafety in our code. Yeah, this is where things get tricky. Maybe we're going to run into this business already now.
03:45:37.095 - 03:46:40.885, Speaker A: Yeah. So the challenge here now is. Oh man, I just realized something else too. No, that's fine. One thing we're going to run into here is. I think this is the point that came up earlier here. We're going to store a bin, but what we're storing is node, not bin entry.
03:46:40.885 - 03:47:38.795, Speaker A: But the head needs to be a bin entry. Yeah, it's kind of awkward. So there are a couple of options here. One is we do this like double indirection at the head. The other is that we merge the. We just stick node directly into bin entry, remove the node type and just have the bin entry type and maybe rename it. Problem there is that every node is now slightly larger, but it might not really matter that much.
03:47:38.795 - 03:48:35.725, Speaker A: Yeah, it's a little awkward, but that might be what we have to do. I wonder why are these constructs even needed? It feels like all of that validation can be done on a C compiler front end. Can you show any example when it's absolutely impossible to do that? I think you need to provide an example. I don't know what constructs you're talking about or what validation you believe can be done in a C compiler front end and if so, which C compiler front end. Saying that something is theoretically possible doesn't really help. Right. You would need to show me one that can do this, whatever this is.
03:48:35.725 - 03:49:16.611, Speaker A: Oh yeah, I think we're going to make the. I think we're just going to have to merge this into one type. It's going to be necessary for the removal business later anyway. That's too bad. Defer the wrapping of the node until it becomes another nodes next pointer. The problem with doing that is we're trying to do this all this atomically. So if someone wants to add another node, they're going to basically do an atomic like compare and swap.
03:49:16.611 - 03:49:59.323, Speaker A: And so you can't easily do that. Yeah, it's going to be awkward. The types aren't quite going to work out either. Merging node into bin entry will also make it tricky to follow chain of nodes down. Right now we have the good Logic that node points to forwarding node doesn't ever happen. Yeah, it means that we could no longer quite encode that, which is certainly annoying. Yeah, it's not.
03:49:59.323 - 03:50:35.941, Speaker A: It's not great. It's not great. Hmm. The problem we'd run into is we'd. We'd end up with a bunch of, like, runtime assertions of like, this pattern can't happen. So, for example, we know that if you have a node, all the subsequent nodes are going to be of the node type. You can't have a node that's followed by a forwarding node which is currently encoded in the type system.
03:50:35.941 - 03:51:19.585, Speaker A: But if we changed bin entry, if we. If we merged node into bin entry, then now there's nothing in the types that guarantee that that is the case. And so it would still be fine. Like the code would be fine, but it would mean that there are more places where we would have to match on the node type and then sort of say that it's impossible to be in the case where this is a moved. Can you explain the exact problem with the current types? Yeah. Okay, let me. Let me try this again.
03:51:19.585 - 03:51:50.275, Speaker A: Okay, so here's actually, let me draw this. That might be easier. All right, so here's the challenge. Let me make this a little bit smaller. Maybe there. Okay, so we have our table. And let's consider any given entry.
03:51:50.275 - 03:53:08.271, Speaker A: Each entry is just a pointer, right? And this pointer has some type T. And what we're going to construct is either a linked list or one of these forwarding nodes, right? That this head pointer is going to be either a pointer to like one of these, or a pointer to one of these. But if you are, in this case, if you have a linked list, then this pointer we know is a pointer to a node. It isn't. It cannot be. The one of these pointers is a pointer to one of these types. That can never happen, right? So the question becomes, what are these types? Well, if T is something like an enum of node or forward, right? It's an enumerative one of these.
03:53:08.271 - 03:54:26.447, Speaker A: So the question becomes, what do we go? What goes here? Right. There's going to be some type U, right? Where this is you, this is you, and this is you. So the question becomes, in the definition of you, which is going to be a struct, what is the next type? Well, it's going to be an atomic. And the question becomes, what goes here? Well, either we stick you here, that's what we currently have, right? And that now in the type system, there is no way when you, if you have a U, you know that the next thing is you, all is good. But it means that the head pointer, right? This pointer right here, that pointer is of type atomic T, right? Because that head pointer, it can be either or. So the head is of atomic T, but the next is of atomic U. And this means that the sort of, how to phrase this, this means that the allocation that happens at the head is an allocation of a T and the allocation that happens of next is allocations of U.
03:54:26.447 - 03:55:01.145, Speaker A: And that means that they're just different things. It also means that, for example, and this was the observation that was made earlier, if the head of a list gets removed and some later things becomes the head, its type is going to have to change from U to T and it's going to have to do so atomically. Because remember, all of this is like lock free atomic stuff. And converting something from a U to a T is not necessarily trivial. I mean it is, it's just a wrapping. But that wrapping is like a heap allocation and an atomic pointer swap. That is tricky.
03:55:01.145 - 03:55:49.321, Speaker A: So the alternative, and this was what was proposed, let me dig up like some other color here. One alternative to this is to say, well, this type is just going to be T instead. Okay, well now these two types are equal, right? So that's good. The problem now is if I have a U and I do u dot next, the type of u dot next is a T. I know, right? As the programmer, I know that this is always a U, it's always a node, right? I know that. But that's not encoded in the type system. So everywhere where I do U next, I'm going to have to match on u next.
03:55:49.321 - 03:56:40.613, Speaker A: If it's a node, then do the right thing. If it's a forward, then like panic, this is unreachable. But that's not very satisfying, right? Forward has to be heap allocated because it needs to be an atomic pointer swap. Would you combine using dynamic dispatch? Dynamic dispatch would not help here because for dynamic dispatch you need a wide pointer and a wide pointer. You can't easily do an atomic pointer swap on one more layer of indirection node. Atomic U in T. Yeah.
03:56:40.613 - 03:57:39.721, Speaker A: So the third option, if I can get this to do the right thing, the third option here is let's do that color I guess. Third option here is for this to contain an atomic U and for next to also be an atomic U. Because now the type of allocation at this point and the type of allocation at this point are both U's. So converting between them is Simple. The downside is that we now have a double in direction for every lookup. Right? Because an atomic is a heap allocation and so this is also costly. Why not a trait object for inside the atomic? Yeah, atomics can't be trait objects, I believe, because you need a.
03:57:39.721 - 03:58:11.125, Speaker A: It's a fat pointer. Because you need the vtable pointer as well. You could box the trait object, but the moment you box it, it is no longer atomic. You can't do atomic swaps on it unless you have like support for like wide atomics, which I don't think we want to assume. So these are the, the three options. The. The only one that doesn't come with.
03:58:11.125 - 04:01:06.065, Speaker A: The only one I think that doesn't come with overhead, sadly is the one where we just merge everything into the top level enum and then like the, the red solution basically. And it, it is definitely a little sad because we're going to have a bunch of unreachables, but I think it's what we're going to be stuck with at the moment. All right, let me go pee and think about this. And you can think about it too and pee if you need to. Are the current types only inconvenient to use? No, we don't actually have a way to. Sorry. This is where the issue came up, which is what I was getting to explaining, but didn't quite.
04:01:06.065 - 04:02:09.685, Speaker A: Which was here. The tricky part is when you do a resize and you have an existing linked list and now you're going to split that linked list and you're going to place it in two different bins in the new table. Imagine that you're moving a run, right? The run, the head of the run is going to be just a node. It's not going to be a bin entry, it's not going to be an enum, it's just going to be the struct. But it's going to become the head of the new thing. So now we would have to, we would have to reallocate it for that to work ahead of the run that is now arguably in this particular instance, we know that we own the target bin, so we could just redo the wrapping. But this is still going to come back to bite us when we do remove.
04:02:09.685 - 04:03:41.977, Speaker A: Red comes with some memory overhead. There's a little bit of memory overhead just because the tag of the enum, I'm more concerned with the effect it has on cache performance, but it should be small. Okay, well, the only thing we really need to change is that this is going to become a bin Entry. This, which means that this is going to become a bin ent entry. This, which means this is going to become a bin entry. This, which also is awkward because. Yeah, it's not great.
04:03:41.977 - 04:04:50.765, Speaker A: It's not great. Oh, you're right. It's going to be bin entry KV Yeah, it makes me real sad. Makes me real sad. The other annoying thing is that we can't have find on node anymore because it might have to return self. Well, yeah, I think this is just. We're gonna have to.
04:04:50.765 - 04:05:48.645, Speaker A: If n.else is hash and N key is key, then self. Oh, it's awful. Oh, it's gonna have to go through the whole. Fine, fine, fine, fine, fine. No. Okay.
04:05:48.645 - 04:06:59.245, Speaker A: This might be okay. This might be okay. It's just going to mean that this code is going to go up here and this is going to be. If this then returns self shared from self. Yeah. So this is currently recursive, which might not be what we want, but in fact I think it's very specifically not what we want. This is going to be break.
04:06:59.245 - 04:07:31.455, Speaker A: This is going to be break. This is one example of like here we would have to do this match to see whether it's moved each time and just like, not necessary. We know it's not a forwarding node. So in the. In the Java implementation it. It uses. It uses like virtual function overload.
04:07:31.455 - 04:08:47.885, Speaker A: No, I think self referential structure wouldn't really help here. So here instead what we're going to do is node is N. Jeez, this is terrible. So ugly. It's so ugly. Yep. Then it's going to break with that.
04:08:47.885 - 04:09:47.205, Speaker A: Otherwise it's going to do node equals next D. I think that's what's going to end up being. And this whole find can go away. And at that point there's no need for the node type anymore. That can just go straight into here. Although that would make this not work. So we're going to keep it the way it was, actually.
04:09:47.205 - 04:11:01.605, Speaker A: All right, let's see what that gives us. That's going to break to self find. No bin find. Great. Six, five no field. Next on owned bin entry. Yeah, so now we get into this pane, which is now.
04:11:01.605 - 04:12:09.949, Speaker A: This walk is awkward. We own the bin. We get the head right. And now this is going to be. We're constantly going to have to destructure this because this is going to be node is if. Let binantry node head. At least now these can be.
04:12:09.949 - 04:16:21.565, Speaker A: We don't need to drop the head separately. So now this can just be this P is head this is now unreachable. So this is the like ugly business. I mean right? This is going to drop the nodes value this is going to get the node and this is going to do the node 661 expected node bin entry found owned this should say bin what's my typo that's preventing all the formatting 652 right? No field next on bin entry yeah so this is going to be the same thing where next is going to be node is going to be if let's bin entry node head no N is equal to unsafepdref then I guess next then n dot next load and we have to do this whole business guard else unreachable and then p is next 591 why is n here a an I size where does N come from? But N is a use ice what am I missing? Missing what am I missing? N is definitely a use all right, let's do that later. 591 same thing expected us find outsize but it's complaining about this line But I comes from I is definitely a use and N like I equals N right here let N double check. So that is indeed usize but I don't see why it wouldn't be. Well okay.
04:16:21.565 - 04:17:28.327, Speaker A: Make as node an infallible method on bin entry the panics if it's a moved node we could do that. It's not a bad idea. Another is to implement draft just have been entry draft into node I'm going to leave that for later. All right, we're back to where we originally were which was to insert these unsafe PD ref business calls. So safety here is probably the same as in all the other cases. In this particular case though it is where's our safety argument nearby here. All right, so here.
04:17:28.327 - 04:19:18.257, Speaker A: Oh yeah, this is kind of subtle. So here we need to somehow guarantee that the given P that we are accessing. So let's do this a little bit nicer in that we do up here. Let node is unsafe PD ref Because that way these can all just be easier to deal with. So what's the safety here? P is a valid pointer and the reason why P is a valid pointer is because P would be dropped P would only be dropped where P is only dropped in the next epoch following when it was swapped to null. See safety comment near where's the place where that happens? That's down here. Following when it's been See Safety comment near table.store
04:19:18.257 - 04:20:33.775, Speaker A: bin below when it's been following when it's been a Swap to replaced with a move node. We read the bin and got to P. So it is not a move node. So its bin has not yet been swapped with a move node. Therefore it will be dropped in a future epic. And we have the EPIC pinned. So the next epoch cannot have arrived yet.
04:20:33.775 - 04:22:07.201, Speaker A: Therefore it will be dropped in a future EPIC and is safe to use now. All right. 580 oh, hiflet bit entry node node is that then node else unreachable 555 it's probably the same argument up here. Node node actually at this point we could do they need to be shared still? I don't think they actually need to be shared. Oh, last run does though. We just construct shared from them probably. Okay, fine.
04:22:07.201 - 04:23:16.035, Speaker A: We'll leave it this way. So we can do here to save us a little bit of extra typing. If no next is null, why is this while loop checking next first, why is it not if node is null? All right, fine. Stick to what it was. 56564 what? Oh, I see. We need to do next. Next is node next load.
04:23:16.035 - 04:24:16.915, Speaker A: If next is null break P is next.546. This probably doesn't have to happen here. This can happen here. 523 match bin all right, so here we're going to do a Unsafe bins. This is the same story. Safety here is. It's very similar to the safety.
04:24:16.915 - 04:25:19.135, Speaker A: YP is a valid pointer down here, right? Bin is a valid pointer bin. So when has been is dropped bin. Why does this is only B dropped? That's not what I meant to say. Same thing here. Bin is only dropped when the head of the bin is replaced with a move node. We are at the bin and we got read the bin. Actually the bin is only dropped when the table is dropped, right? That's when we drop all the all the heads.
04:25:19.135 - 04:27:09.855, Speaker A: Actually there are two. There are two cases or two cases when bin pointer is invalidated. One, if the table was resized bin is a move is a move entry and the resize has completed in this case, right? So if the table is resized and bin is a move entry and the resource is completed, then the old table is dropped and that includes all of the bin heads which are just forwarders. In that case the table will be destroyed in the next. The table and all its heads will be dropped in the next epoch following that. Two, if the table is being resized bin may be swapped with a move entry. If the table is being resized bin may be swapped with a move entry.
04:27:09.855 - 04:28:24.655, Speaker A: The old bin will then be destroyed will be dropped in the following epoch after that happens. In both cases we held the guard when we read the when we got the reference to the bin. So the next if the swap happened. If. If any such swap happened, it must have happened after we read. Since we did the read while pinning the epoch, the drop must happen in the next epoch. That is the one that we are holding up by holding on to our guard.
04:28:24.655 - 04:29:47.481, Speaker A: Who can this unreachable matching business be encapsulated? It can, but we can do this like if. If we feel strongly about this. And the way to do it is actually pretty straightforward. It's just going to be node or d ref to be honest. But as node I guess it's going to be self to node kv and in fact if we wanted to be really real fancy, we do this. If let bin entry node n itself then sum n else none unreachable. Does that make you happier? It does look nicer.
04:29:47.481 - 04:31:19.185, Speaker A: I agree. It's going to be ask node. This is going to be the same. This is going to be next here we actually want to keep the current one because we want to get the node as owned. This we want to keep here we can do node as node unwrap key that we want to keep this we want to keep 611 mismatch type. This needs to be a bin entry node 511. This needs to be method not found.
04:31:19.185 - 04:31:58.955, Speaker A: It's because next table should just be this 505 function. Takes two. It takes a guard. An easy fix. 491. You see, I don't understand where this end is coming from. What am I missing? And as a you size.
04:31:58.955 - 04:32:58.175, Speaker A: What's it on about? Expected eye size found you size resize stamp. All right, number of leading. It's definitely an eye size. All right, fine. So if that's an eye size, then I also has to be an eye size. So we're just going to keep it an eye size. We're going to cast it to a U size down here actually.
04:32:58.175 - 04:35:09.429, Speaker A: Where's the place where we combine it with 624 as eyesize no field. All right, so I think next table. Does any of this code do anything with next table? No, just that next n next table is read while the guard was held the code the drops Next table only drops it after it is no longer reachable and any outstanding references are no longer active. This reference is still active marked by the guard. So the target of the reference. Yep. 445 expected eyesize found use this is going to have to be as eyesize 386 this is going to be the same argument as for next table below.
04:35:09.429 - 04:36:30.435, Speaker A: So what I'm going to do here say should say table same argument as for table above. 398 what do we got here? I think we need that to be a use and then we're gonna do let N is N as I size. How can N be negative? I don't think N can be negative. Oh it's for the like resize stamp business. Take a resize the N is always show me this Resize resize stamp okay. Of size N. So N is definitely a U size okay.
04:36:30.435 - 04:38:27.225, Speaker A: Which means that my dear end up here can go back to being in usize this can stay usize. Great. 631 now these can just be I n the way it was meant to be. 498 why is I here? Right. Because I is an eye size until here because it can be negative 41 expected eye size. Okay if we get to this or then I must be positive so this can be this index Transfer index. Why can transfer index be negative? Like why is transfer index an eye size? I don't believe that for a second.
04:38:27.225 - 04:39:13.285, Speaker A: Unless they use like negative to indicate that next bound. Yeah. Unless next bound can somehow be negative. But all right fine. I'll store it as an eye size. I still find it very hard to believe that it has to be signed. 573 consider giving head type.
04:39:13.285 - 04:40:09.045, Speaker A: Well it is a bin entry. It's not a bin entry. I'm in fact entirely lying. This has to be a head is just going to be bin now. Yeah. This is just going to be going to be bin. This is going to be bin this is going to be bin this is going to be bin.
04:40:09.045 - 04:41:01.353, Speaker A: And let's make sure we didn't overwrite bin anywhere in between. I don't think we did. It's not mutable. Hopefully. Great. 620 no clone found for raw meat utex. Really? Why does it matter? So this is removing this lock is only taken if you want to overwrite the value decently.
04:41:01.353 - 04:41:53.185, Speaker A: Sure. This can just create a new lock but if we're unsure run then what does this code do? It doesn't. Oh I see. This can definitely be a new lock because in the Java world it's using the like per object lock. So there's just a new lock every time. So that's fine. Why does the key need to be cloned? The key does need to be cloned because the Old key might still stick around in the map.
04:41:53.185 - 04:42:45.295, Speaker A: That's real awkward. So the. The observation here is that the old bin is going to still have a bunch of the old bins. Linked list is still going to have a bunch of nodes and there might be threads that are accessing those nodes and need to look at the keys, but we need to allocate a new node and that new node also needs to hold the key. And so here we're going to clone the key. One alternative would be to not clone the key, but instead put the key behind an ARC somewhere. I don't really want to do that if I can avoid it.
04:42:45.295 - 04:44:03.495, Speaker A: So instead we're just going to require that the key is clone, which definitely makes me a little sad, but such as live for now. Muscle Team Yes, I am using CoC, but I don't actually want stuff in my terminal because very often, especially when doing development like this, like I know that there are a bunch of errors and if the errors just came as I typed, it would first of all take a lot of CPU cycles and also many of the errors I know about. I don't want to see the errors until I'm ready to see the errors. I could have a shortcut for running COC or running rls, but it's annoying to set up and it's easier to browse through them this way too, because now I have them in a terminal rather than have them show up in like the VIM Quick fix. So that's why. Okay, so here. What's the argument? The argument here is probably the same as what we've given above, actually.
04:44:03.495 - 04:45:14.335, Speaker A: 345 draft. So the safety here is. Do we have another safety further up? No. Table is only dropped on the next epoch change after it is swapped to null. We read it as not null. So it must not be dropped until a subsequent epoch. Since we hold a guard, we know that no new epoch is happening.
04:45:14.335 - 04:46:45.413, Speaker A: We know that the current epoch will persist and that our reference will therefore remain valid. You see, this is really just many ways of stating the same security property, all of which are relating back to when we choose to drop things. So this is going to be same thing de ref this. Oh, what did I break? What? 286. I'm confused. 489. Oh, all right.
04:46:45.413 - 04:48:23.155, Speaker A: 286. I think also for this we probably need to require that these are this. Next we read it as not null since we held guard at the time continues to persist and then our reference is therefore valid. 259. This is another node, isn't it? Yep, it is indeed. This is sadly going to be bin and here I guess we're going to do N is. No, it's going to be P because that's what we've been using PD ref as node unwrap.
04:48:23.155 - 04:50:13.955, Speaker A: It's the same pattern. And the safety condition here is probably just going to be exactly the same. Specifically, we read the bin while pinning the epic. The bin was a BIN will never be dropped until the next epoch after it is removed. Since it wasn't removed and the epoch was pinned, that can be cannot be until after we drop our guard. All right, we're getting closer. So here we can do another like table DREF safety.
04:50:13.955 - 04:51:35.485, Speaker A: Let's see that. That actually fixes a bunch of these. So what's the safety here? The safety here is there are a couple of them actually. TABLE is a valid pointer. If table is the one we read before the loop, then we read it while holding the guard so it won't be dropped until we drop that guard. Because the drop logic only queues a drop for the next epic after removing the table. If table is read by init table and what's the last case? If table is set by move below.
04:51:35.485 - 04:52:55.065, Speaker A: Are there any other things to change table? No. All right, so what does init? Because these both override table. Right. So we need to make sure that no matter with which shared we ended up with shared table, it is okay to do this. D so if table is read by init table, then the only way we break from this is either here, in which case we do a load after the guard is pinned, or here, in which case we did a store, so it must be valid and no one else. If someone else were to drop it, they would have to wait for an epic. If table is read by initable, then either we did a load and the argument is as for point one, we are in one of three cases.
04:52:55.065 - 04:54:35.265, Speaker A: Either we load in the arm is or we allocated a table, in which case the earliest it can be deallocated is in the next epoch. We are holding up the epoch by holding the guard. So this d ref is safe. And if table is set by a moved node. Okay, so this is a tricky one, right? So this is. We're just going to do. We're going to do this help transfer through help transfer, then what? Well, and all these cases is going to return next table, except for there, where it's going to return table.
04:54:35.265 - 04:56:21.865, Speaker A: It will either return table, which is fine by 1 and 2 it will either keep using table, which is fine by one or two, or use next table from or use the next table pointer from inside the moved in the latter case. Okay, so the question becomes. Okay, here's the question. We have a moved entry and the moved entry is a raw pointer here. In order for this draft to be safe, we need to guarantee that that raw pointer is still valid. How do we know that's the case? Well, raw pointer from inside the moved how do we know that that is safe? Well, we got to the move node transitively through a reload of tables. That load of table happened in the current epic since the EPIC is pinned is still pinned.
04:56:21.865 - 04:58:49.495, Speaker A: All right, so when is a table destroyed? A table is destroyed when a table is destroyed in the next epoch after the resize finished load of table. Since that. How do we phrase this? A table is only ever dropped in is only dropped in the EPIC following resized. Actually, a table is only dropped in the EPIC following. Well, it's weird because the moved points to the table after the resize following when it's resize has completed. In the case of moved T, T can only have been dropped if if T was resized and that resize has completed and an epoch has passed for T to be resized. This is a finicky argument.
04:58:49.495 - 04:59:54.705, Speaker A: So the question is, does the user code of this hashmap need to concern itself with not holding guards for too long to avoid growing memory, else the epoch never increases? Yes and no. We haven't implemented iterators yet, and iterators is one place where this is going to be tricky. But if you look at the signature or the contents of get and insert, those internally construct a guard so the user never gives a guard in. What this means is that the user just can't hold on to the guard for too long because the guard is only held for the duration of the getter insert. Either keep using table, which is fine by one or two, or use the next table raw pointer from inside the moved. How do we know that that is safe? A table is only dropped in the EPIC following when it's A table is only dropped if it is resized. That.
04:59:54.705 - 05:01:38.825, Speaker A: This paragraph gets too complicated. A table is only dropped if it is resized for t for table T and moved t to be dropped. I feel like there's a simpler argument here for table t and move t to be dropped. The property we want to make sure holds is that if you drop a moved t. Actually, the property we want to make sure we hold up hold is that if A moved T exists then the T is still valid which I think we uphold by virtue of the destroy But I don't think I can't quite figure out how to articulate it. We must demonstrate that if a moved T is red then T must still be valid. Fix me.
05:01:38.825 - 05:05:00.621, Speaker A: Let's leave that for a little bit later. I believe it's true. It's just we need to inspected reference found here this is. This is just going to be p instead of N285kv the value type for node is wrong Atomic new I think maybe this should just be that great 254 that was not at all what I meant to do and this is fine because we haven't given out so let's see. Safety we own value and have Never shared it 249 this has to be a reference. Oh yeah. Keys obviously need to be comparable 229 no field lock almost there Expect a reference found Shared oh yeah.
05:05:00.621 - 05:07:39.355, Speaker A: This should probably just be T because we need to still be able to refer to the old T Where are there other tables? Those are the only ones. Great. 212 match bin oh this is a simple one. This is just safety I think this is just the same argument as this one. Yep. Well that's just the same argument. 168 this is going to be table DREF safety C argument below for not is null case where we were saying 129 init table this is going to take G and give you back a shared over G Safety we loaded the table while EPIC was pinned Table won't be deallocated until next epoch at the earliest.
05:07:39.355 - 05:11:35.265, Speaker A: That's the same argument as here. So few errors left. I mean we haven't gotten to the borrow checker stage yet I think so probably still some challenges but R this is going to be unsafe DREF I think what we probably want here actually is implement guard API of our own so why is this okay? Safety we are still holding the guard so the and of and saw value and saw V so it won't be dropped until the next epoch after we drop our guard at the earliest 93 table is unsafe same argument again 102 safety so this is the same as the argument for our other bind ref Sort of want to collect all of these in one place rather than have them spread out like this but node is node as node unwrap 116 this probably takes a guard and 120 node is unsafe node as ref no as I mean deref and here the safety is the same argument as before, where no draft. Huh. PD ref. Nice. How many? Six.
05:11:35.265 - 05:12:35.365, Speaker A: Oh man, that's not many at all. Can I move out of Dereference? What? Where? 778 this is into box. So that's fine. 68. What? 68 value does not need to be mutable. 765 cannot move out of dereference. Owned into box, I guess.
05:12:35.365 - 05:14:12.575, Speaker A: Oh, that's awkward. So here we can't actually walk these bins and have them be owned because we can't take ownership out of table because table implements draw and if we iterate over the array the box slice, then we don't get very far either. What we can do here though is replace box, I guess just vec into box slice and then vec from. It ain't pretty, but it works. 7, 6, 5 should be mute. Indeed. All right, 667 run bit has to be mutable.
05:14:12.575 - 05:15:00.885, Speaker A: That is totally true. 461 count has to be mutable. That Is also true. 420 table does not have to be mutable. 237 node is borrowed. Oh, that's going to be real awkward actually to fix because we borrowed the key here to make life easier for ourselves, but that might have been a mistake. So, you know, we can just do it here instead.
05:15:00.885 - 05:15:27.389, Speaker A: What am I missing from that? There's no use of key further up, so we can just do it here. It compiles. It compiles. It is alive. It's alive. Saw bin length. That's fine.
05:15:27.389 - 05:16:53.409, Speaker A: We don't actually know what to do with that yet. Load factor is not used. Ooh, implement all perhaps. How to phrase this? How do we phrase this? I think what we write here is it doesn't really matter for these kind of commit messages, but perhaps something along the lines of add in all safety. Figure out most of the safety invariants. Do you plan on implementing tests? Yes, indeed. So actually your screen is going to go bright in a second.
05:16:53.409 - 05:17:21.315, Speaker A: Just so you're all aware, the Java testing, the Java concurrent hash map has a bunch of tests. So the plan is to implement those as well. But we won't do that today. My guess is there'll be one more stream on Concurrent hash Map. Now that we have the basics working, we now need to actually test it and get it to work, and that's going to be the next stream. All right, so we now have a thing that compiles. We don't actually have anything that can do anything useful.
05:17:21.315 - 05:18:31.515, Speaker A: All right, let's just just for the heck of it, it works. Flurry hashmap do we have like a new probably don't even have a new do we? That's awkward. Okay, we don't even have an implementation of new so this is going to be the fix me for next time. Do I not sign my git commits? I used to these times not so much anymore. It's not clear to me that it carries that much value if, especially if you turn on auto sign, I might turn it back on. I had some problems with GPG for a while, but those should be resolved now. Okay, I think we're going to call it there because now we have something that actually compiles.
05:18:31.515 - 05:19:20.941, Speaker A: The biggest things that are left now is actually running the thing. Removal is going to be a big, big thing. There's sort of the the tree ballot, the balanced tree stuff that they do, which I think we're probably not going to port, and the sharded counter business they do. There's one more oh yeah, and then, and then of course figuring out that last safety invariant that we ended up leaving as a fix me. We need to document and convince ourselves that that code is actually correct. With that though, I think we're in a pretty good position. My guess is there will be one more stream on the concurrent hash map where hopefully we'll be in a position where it all works.
05:19:20.941 - 05:20:04.587, Speaker A: So that's going to be whenever the next stream is. I'm leaving for holiday on Monday and we'll be back mid January. So my guess is that the next stream is going to be end of January sometime. I hope this was possible to follow. This is like very hairy code, but hopefully the us talking through it helped a lot and I've pushed all the code so if you want to like read through it at your own pace and compare it to the Java code, just have a look in the GitHub repo. And with that I wish you all a happy New Year and I will see you in 2020. Bye everyone.
05:20:04.587 - 05:20:11.635, Speaker A: It's great to have you here. As always, that's not what I wanted to do. All right, bye.
