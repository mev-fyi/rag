00:00:00.760 - 00:00:41.303, Speaker A: Hello everyone. Welcome back. It's been several weeks now of or several months actually where we've been working on implementing tcp and that's been a lot of fun, but I figured we want to sort of keep iterating through new topics as people get interested in them. And so if you recall, there's this website I use that I set up where in fact I live coded this website too. You can find it in an earlier stream where people can vote for what things they would like to see me stream. In this particular instance, procedural macros was the thing that most people were excited about. It was a pretty neck and neck race between that and a second take of the open source contribution stream.
00:00:41.303 - 00:01:15.893, Speaker A: So my guess is we'll end up doing that next. But for now we're going to dive into procedural macros. So for those of you who are not aware what procedural macros are, let's start just with what macros are. And to do that I'm going to. Actually, let's not do that. Let's start a new empty project here, actually. Ooh, how do I want to do this? Let's just start a VIM terminal file type.
00:01:15.893 - 00:01:54.807, Speaker A: Oh, I can't type today. It's going to be a chat. What file format? What? Fine, let's do this instead. So while writing Rust code, you may have used macros before, something like that. So if I do this. So the exclamation mark here means that it's a macro. And this, what a macro does is essentially it is given the piece of code that you give it and it returns some other code to run instead.
00:01:54.807 - 00:02:40.171, Speaker A: In the case of Vector, you could imagine the vec macro being something like the vec macro up here really being something like let MUTV is vec new V push 1 V push 2 V push 3 V. Right. So you could imagine that this is what the vec macro expands to. In reality, it's actually more optimized than this. You don't want to keep allocating, for example, as you grow it. So this is not actually what it expands to, but you can sort of imagine that this code ends up being turned into this code. And that is essentially what a macro is.
00:02:40.171 - 00:03:32.319, Speaker A: Now, normally you can write macros using macro rules. So let's say that we wanted to define the vec macro. We could do something like. In this case, we probably want like E xper comma so this is an example of a normal. This is an example of how you would write a normal macro in Rust. So if you want to write it Inline in the file. So you use this macro rules macro that is a macro that lets you write other macros.
00:03:32.319 - 00:04:17.277, Speaker A: And you basically write pattern matching rules for the arguments to the macro. I think this might have to be parentheses. And then you write the body that that should expand to. In this case, the pattern is saying anything that's an expression separated by comma zero or more times, it expands into the following code. It's a block that generates this vec. And then this syntax is saying write out the statement in between the parentheses as many times as they were in the input, right? So this is saying write out this line many times. And this macro we could use instead of the one for the standard library, you wouldn't want to, but this is sort of the way macros work in general.
00:04:17.277 - 00:05:33.305, Speaker A: Now, these are all, well, very well and handy, but they're pretty restricted in what they can do, right? So you have to be able to write this kind of pattern. And sometimes you want fancier things. Like if you've ever used the serde crate that lets you do serialization and deserialization, it allows you to do things like struct foo, it has a bar type usize, and you can do derive, serialize, deserialize, right? And what derive is, if we think about it, is really a way of taking some kind of code, annotating it in such a way that some program is going to run to generate the code needed for serialize and deserialize, right? And in fact, this turns out to be a macro. This is what we call a drive macro. So derive macro is going to take. It's going to be given as input this business, and then it's going to generate something like impulse, serialize for foo, and then whatever stuff is necessary in here, right? There are also other type of macros you may have seen. So a macro like test, right? So this is a macro that transforms this function into the appropriate format for a test.
00:05:33.305 - 00:06:10.975, Speaker A: This is what we call an attribute macro. Usually you can also use these with parameters. So for example, if you've ever used Rocket to the sort of web framework, you could do stuff like route, get, slash. And now this is going to be generated as one of the routable parts of your application, where if you get a get request for slash, then this function would be evaluated. And so this is an attribute macro. All of these are the class of macros that we call procedural macros. So the idea of a procedural macro is that you write a program that's going to run at compile time and it's going to trans.
00:06:10.975 - 00:06:46.615, Speaker A: It's going to be given essentially a stream of tokens. So tokens in the sense are a bunch of sort of the building blocks of the Rust language. You're going to get a stream of them and you're going to produce a stream that's going to replace or add to the original stream. So someone asked here, how can I see the macro expansion? And there are actually many ways. What we're going to be using today is there's a crate called CargoExpand. I'll get back to this a little bit later. But basically there's this command that you can run on your own.
00:06:46.615 - 00:07:30.219, Speaker A: So if you run Cargo Rust C and then with these arguments, which are nightly only, then the Rust compiler is going to run and it's going to basically print out with all the macros expanded. So here's one example where there's a derived debug and if you run Cargo expand, you get the fully expanded, or you get one level of expansion for that code. Actually you might get a fully expanded. These are sort of special. So that is one way to do it and probably the one we'll end up using today. And this is going to be really handy for debugging procedural macros later. So procedural macros are.
00:07:30.219 - 00:08:20.321, Speaker A: If we go back a little bit, they're effectively. So this is from the Rust reference, which actually might be less helpful than we want. But essentially a procedural macro are mostly a conversion from token stream to token stream, right? There are some variations. So if you write a function like macro, so that would be something like vec that we saw earlier, then it's just take a token stream and give the replacement stream. If you write a derived macro, then it's. You're given the token stream of the thing to transform and the output token stream is added to the same place as was, right? So if you're going to add an impulse, for example, you don't want to replace the original struct, right? Because that struct still needs to be there and the user has defined it. So you're not really going to be changing it, but you're going to be adding stuff.
00:08:20.321 - 00:08:51.611, Speaker A: And then finally, attribute macros are things like route or tests that we saw before, and they're given the token stream of the attributes. So this would be the stuff that comes between the parentheses and the token stream of the thing that has been annotated. And they're supposed to generate a token stream that is, say here the return tokenstream replaces an item with an arbitrary Number of items. We're going to be talking about items a lot here. Items in Rust. In fact, this is the reference, probably. Yeah.
00:08:51.611 - 00:09:30.747, Speaker A: So items are basically anything. They're like modules, functions, type aliases, different types that are defined, implementations, traits, external blocks. Think of them as basically anything with curly brackets. It's not quite that simple, but it can be simpler things too, like use statements are also items. And so procedural macros are basically a way of taking a stream of items and doing something with them and then producing a stream of items. We won't actually read through this document. I don't think that would be helpful for us.
00:09:30.747 - 00:10:41.151, Speaker A: Instead, what we're going to do is we are going to follow the PROC macro workshop from. So this was essentially a workshop from the Rust Latam conference. And this is written by David, who is a really prolific Rust developer and has built many of the tools that we'll end up using today. So he's written in particular the syncrate, which is what we'll use to parse a token stream into something that we can modify, and the quote crate, which is the inverse. It takes essentially sort of an abstract syntax tree, like something that we're going to be modifying, and turns it into Rust code again, basically turns it back into a token stream. And David wrote this as sort of a workshop guide with a bunch of exercises for this conference. And so what I thought would do is basically try to work through some of the suggested projects here, because they're basically built for people learning procedural macros, and I have not done them before.
00:10:41.151 - 00:11:30.813, Speaker A: In fact, I haven't even written that many procedural macros. So this will be an interesting learning experience where I have less experience than what I usually do for these streams. Do input items have to be valid? That's a good question. I believe the only requirement is that it lexes, but not necessarily that it parses. So all of the individual parts need to. Basically you need to be able to generate a valid token stream from them. So you couldn't have like an unterminated open double quotes, for example, but as long as you can parse it meaningfully, then you're given that stream of tokens.
00:11:30.813 - 00:12:16.141, Speaker A: But what you produce, the token stream you produce is what the compiler is going to be running on. And so that obviously has to be valid for the resulting program to compile. Yeah, but something like. Something like just an identifier, open curly brackets and some comma separated identifiers, which would not normally be valid. Rust is totally fine. In fact, the thing you give there is a Valid pattern, I think, but that's sort of separate. Okay, so we're going to be working through these, and in particular we're going to start with essentially what this suggests we should start with, which is write, derive, builder.
00:12:16.141 - 00:13:00.787, Speaker A: So for those of you who don't know what builders are, the builder pattern, that's unhelpful. The builder pattern is essentially a way of constructing something that you're later going to build. So an example of this would be, and the example that's given here indeed is imagine that you want to run some kind of command line utility from Rust. Well, when you do that, you're going to have to specify like the name of the program, you're going to have to specify arguments to that program. You might want to specify where the program should run, you might want to specify whether the program should replace the current one or be started in a separate process. You might want to say where the input should come from, where the output should go. And all of these are arguments you may or may not want to set for any given execution.
00:13:00.787 - 00:14:14.845, Speaker A: And so rather than have a constructor that takes like a million fields, you have a builder which has defaults for basically most of the options, and then it has methods for overriding particular parts of that construct. So here, for example, you create a new builder executable, returns a builder whose executable has been set to cargo. And so you can keep sort of layering on here, continuing to configure the command builder. So basically the command you haven't run yet, and then eventually you call build and that's going to actually produce the final type that you want to run, or indeed run it, depending a little bit on the setup. In this case this is sort of trivial, but here the idea is that what this is going to produce is a command, right? So our derived builder is going to produce a command builder that has these methods and then build is going to give us one of these back with all the fields set. And so what we're going to start out with doing is we are going to just clone this and that's where we're going to start. So you clone this.
00:14:14.845 - 00:14:49.575, Speaker A: Oops. Apparently I just cannot type today. Seems less than ideal. All right, great. So let's see what we have here. So for this, the skeleton is located under the builder directory. So we're going to CD into builder.
00:14:49.575 - 00:15:27.085, Speaker A: So this is essentially its own self contained crate that we're going to be solving this in. The cargo automobile has already been set up basically correctly. So you'll notice that There's a lib for lib. It's set to proc macro equals true. So this is what we want, right? We're writing a library that's going to be a procedural macro, and you need to communicate this to Cargo so that it knows to essentially compile it in a special mode where it has access to those things. For example, you don't require a main in a procedural macro. What is also neat about this is this also comes with a bunch of tests that we can use.
00:15:27.085 - 00:16:00.743, Speaker A: So if we look at the test directory, let's look at progress first. So this uses a crate called Try Build, which is handy for writing procedural macros. It basically tries to build the given source code and then checks that the compiler output is what you expect. So if you expect it to compile, that's all well and fine, Try Build will do that. But you might expect it to fail with a particular error message. So you might want to check that. For example, the compiler highlights the right part of the code if something doesn't work out.
00:16:00.743 - 00:16:38.685, Speaker A: And we'll see some examples of that later. In particular, the first test we want to pass is the parse test. So it looks for a derived macro with the right name. So we're going to have Derive Builder. It doesn't require any specific code to be generated. So really all that matters is to see that we can parse it correctly. Why did the chat go away weird, right? So the only goal here really is that we can parse the input, but we don't have to produce anything in particular.
00:16:38.685 - 00:17:05.141, Speaker A: What it's telling us to do here is use the syncrate to parse. Well, let's take a look at the syncrate. So the syncrate, as it says, is a parser for Rust source code. And essentially what it does is it gives you a parse macro input, which lets you parse, well, a token stream into a syntax tree. In particular, it generates this kind of derive input business. So let's take a look at. No, that's not what I want.
00:17:05.141 - 00:18:22.285, Speaker A: Let's take a look at the docs. So down here, where is my parse macro input? Great, so that should give us a derive input. So in particular, what we want here is we want to parse the token stream we're given as a derive input. So derive input here is the input to a derived macro. And you'll see that what we get back is something that has ATTRs. So ATTRs are any other attributes specified on the struct that we're deriving for or the item we're deriving for the visibility of that struct, right? The struct might be public, it might be crate only, whatever ident, which is the name of the struct, generics, which are any generics on the struct itself, and data, which are the contents of whatever data type it it's that we're deriving over. And so in our case, the test here is basically just a test that derive builder on command produces code that compiles, which would include adding no code, which is indeed what we're going to do.
00:18:22.285 - 00:19:04.931, Speaker A: So here, what we would expect is given this, we would expect adders to be empty because there are no other attributes on the structure. We would expect visibility to be pub. We would expect ident to be command, we would expect generics to be empty, and we would expect data to contain these fields. So if we look at what data is, so data can either be a struct, an enum or union. In our case, we're expecting it to be a struct. And so it's going to have a struct token, which is a structure, it's going to have a bunch of fields which are going to be these, and it's going to have a semicolon token. It may or may not have a semicolon token.
00:19:04.931 - 00:19:27.029, Speaker A: In this case it does not. So the fields are going to be named. So unnamed fields would be like a tuple struct. Then the fields do not have names, they're just numbered. So we're expecting to get fields named. And so here we're going to have a brace token which is going to be this. And then we're going to have the named fields.
00:19:27.029 - 00:20:16.395, Speaker A: So punctuated here just means that it's comma separated values. So this is going to be an iterator that gives us comma separated fields. Every field in here again has all of these in particular executable, for example, it has no attributes, it doesn't have any pound square bracket above it. Its visibility should be private, its ident should be some executable, right? So it's an option because it might not have a name, colon token is. Well, a colon and tie is going to be the type, which in this case is going to be string, right? So you can see that this all going all the way back up. This derive input basically gives us access to the entire thing that's been defined. So let's try passing the first test.
00:20:16.395 - 00:21:01.835, Speaker A: So we're gonna start out by uncommenting this and then run cargo Test and see what that gives us. Apparently I'm lying. What's the. No, over here. Oh, that's probably because I'm in the wrong directory here. Cargo test. The other thing we're going to need here is for the builder, we're going to have to depend on the syncrate, which is currently version 015.
00:21:01.835 - 00:22:01.525, Speaker A: So let's see what that gives us. Okay, so, great, so it ran 01 parse. It failed because the proc macro derived panicked. In particular, because we haven't defined any derived macro called builder, so we're going to have to define one. Great. So going back to the source for this crate right here, what we really hit here was we hit this not yet implemented, right? So this has already been set up for us so that it sort of defines the basic setup that we need for proc macros, which is we need external create proc macros. So this is a special crate that the compiler exposes to us that gives us access to this token stream type, which is what the compiler produces to macros and expect macros to produce.
00:22:01.525 - 00:22:46.581, Speaker A: And then the proc macro. When you write a proc macro, you also have access to three attributes for functions. It's proc macro, proc macro derive, and proc macroatt, which lets you define the three different types of procedural macros that we talked about earlier. In this case, we want a derived macro. So we're going to write proc macro derive and we're going to give it a name, which is the name that the user is going to put inside of the. The drive statement on their struct or enum or whatever. There's going to be a public function because it's going to be essentially called externally and it has the signature that we expect, right? So the input is a token stream, so this is going to be our struct and the output is a token stream that we're going to produce.
00:22:46.581 - 00:23:16.105, Speaker A: And in our case, what we want to do here is we want to parse. Let's call this an astronaut. I don't actually need this anymore, I think, because 2018 edition maybe. Great. I guess we'll find out. So what we're going to do is we're going to run something along the lines of what was given in the example down here. This.
00:23:16.105 - 00:24:00.515, Speaker A: This obviously means that we're going to have to use parse macro input. So let AST is going to be equal to this. Notice that there's no result return type here. The reason for this is procedural macros are expected to always Produce a token stream and a panic is considered a failure to compile. And so you really just want to panic if something goes wrong. And what the compiler is going to do if you panic is, and we saw this back here, it's going to highlight span that's contained in the error you produce in the panic. Basically the span that was processing at the time.
00:24:00.515 - 00:24:38.525, Speaker A: And then the message it's going to give you is the panic message from the procedural macros. Okay, so this is going to give us the ast and let's just print out the astronauts and then what we want to return is an empty token stream. I think there's a empty on there. Let's see what that gives us. Okay, so we can't do that. Do I actually need to. That's a little weird, but okay.
00:24:38.525 - 00:25:32.403, Speaker A: And we need to use derive input. Okay, so we're going to have to look at the PROC macro here. All right, so proc macro, token stream. Oh, it's just new, which gives you empty. Okay, so instead of empty, it's going to be new. And I think this implements display maybe. Isn't there a nice way to debugging? I feel like you're supposed to.
00:25:32.403 - 00:25:47.969, Speaker A: Oh, you're. You're able to print token streams. Okay, that's fine. I'm surprised though. This doesn't implement debug. It does. What are you on about? Why can't I do that? Derive.
00:25:47.969 - 00:26:22.707, Speaker A: Derive input does not implement debug. Pretty sure it's supposed to implement debug. Syndrive input cannot be formatted. Huh. How weird. Are we not building SIN with derive which. So it has a bunch.
00:26:22.707 - 00:27:08.315, Speaker A: So SIN has a bunch of features. I guess the real question is what features are on by default Derive is enabled. By default, extra traits. Okay, so back in cargo Tunnel we're going to do version is this and we're going to say features add this on. And then in theory that should give us debug for these types. Oh, it might even say in the. In the debug tips Proc macro workshop.
00:27:08.315 - 00:27:37.421, Speaker A: Let's see what it says. Yeah, so cargo expand I already know about. Yeah, see, we found it ourselves. Yes, we could add pretty printing, but you know. Great. Ok, so here we now pass the first test because we're basically because we removed the unimplemented. Right.
00:27:37.421 - 00:27:57.147, Speaker A: That's the real reason. Previously it was crashing, now it's no longer crashing. But that also means that we're parsing the input. So let's make this a little bit nicer for us. Let's use pound question mark. Right, so here we get to see the full parsed syntax tree for what we got. So let's see if it matches what we expected.
00:27:57.147 - 00:28:10.375, Speaker A: So there are no attributes. Remember, this is zero on parse. So it's this struct that we're comparing against. So there are no attributes. It's public. The identist command. There are no generics.
00:28:10.375 - 00:28:47.035, Speaker A: Data is a data struct. Its struct token is structured, its fields are named, and the fields are executable, which has SO types are specified with paths. In this case, string is just the final part of the path. There's no preceding path, which is why the path has no leading colon and it only has one segment, and that is string. The next field is a vector of strings. So we're going to see. Yeah, so comma field is called args.
00:28:47.035 - 00:29:08.481, Speaker A: This is a. So this also only has one path segment. A vector is the ident of the type, and the type also takes arguments. So if we look up here, the arguments for string were none. The arguments for the vector is deep down there, string. Right. So clearly our type is being parsed correctly.
00:29:08.481 - 00:29:41.375, Speaker A: We don't use any of the fields. Like, we don't actually do anything with any of this. But at least now we have the type. All right, so let's look at the second test. So we want to have the macro produce a struct for the builder state and a builder function that creates an empty instance of the builder. As a quick start, try generating the following code, but make sure the type name matches what's in the caller's input. Right, so here we want a builder function on command that returns the builder, and we're going to have to define a new struct called builder.
00:29:41.375 - 00:30:18.633, Speaker A: Right, so we wanted to generate this business. Great. Yeah. So if you look at what the test actually does, it expects there to be a builder method on command, which of course there isn't by default. And then it just sees that that returns the thing it can represent. The resources down here mentions the quote crate. So we talked about this a little bit early on.
00:30:18.633 - 00:31:09.485, Speaker A: So quote is basically a crate that lets you go the other direction. So syn lets you go from a token stream into this sort of tree, and then quote lets you take a tree that you can specify in a convenient way and turn it into a token stream again, roughly. And so that's what we're going to use to go the other way. In particular, if we go back to our cargo TOML here, we're going to have quote version 06 don't need this to do anymore. And so now we're also going to use. Right, so what we want to do here is the quote macro lets us use this. It lets us write.
00:31:09.485 - 00:31:47.915, Speaker A: It's sort of like a templating language almost. It lets us basically write Rust code and then interpolate things in there. So for example, the name we wanted to use here, is it just in ident. We want to generate an impulse for command, right? But we need to know the name command. So where does that come from? Well, we know the derive input has an ident that is the command, right? So we can just do this, which is going to be the name. So we're going to impulse. So pound is the way you signify replacement of some variable.
00:31:47.915 - 00:32:26.479, Speaker A: This is going to generate a builder function, is going to return some type that we don't really know yet. And who knows what's going to go here. So we're going to need some kind of struct here that's going to be the builder. But we don't just want to call it builder, because if we just call the builder, then you couldn't have derive builder for two different structs in the same file because they would generate the same builder type. So we actually need to generate a unique name for this. So how do we do that? Well, there are a couple of different ways. The easiest way is to generate a new ident.
00:32:26.479 - 00:33:04.335, Speaker A: So if you look over here and look at. So an ident is sort of a name in Rust, like a variable would have an ident, a type would be an identity. In our case, we want to create a new ident that's the concatenation of two existing ones or of some strings that we want to combine. In particular, what we want is let's call the builder name. So it's going to be. We can just. We're just writing a normal rest program, right? So we can just do this and give in the name.
00:33:04.335 - 00:33:49.825, Speaker A: Can I just do that or do I have to do something fancy? This implements display. Great. So that's going to be the name and the B identifier is going to be synident new and we're going to give in the B name. But ident takes a second argument and the second argument is a span. So if you look at new span here. So spans are basically parts of the original input file that we want to be able to refer to. So in this case, if something goes wrong with creating this name, we want the compiler to highlight the original name that caused us to build this string.
00:33:49.825 - 00:34:48.085, Speaker A: Right? So, for example, imagine that the user wrote something like structure this, which is not a valid name for a struct. Then our builder that we're going to generate. Let's make this simpler. Our builder would generate this, right, which is also not a valid struct name. And what we want is for the compiler, when it tries to compile this, to point at this being the error. And what that means is this identifier here, we want its span to be this, so that the compiler knows to point at that when it talks about this. Does that roughly make sense? So here we're going to take the span of the original, so that we're going to take the span of the original name and use that as the.
00:34:48.085 - 00:35:23.585, Speaker A: The ident span for this. So now this can generate bydeft, Right? So currently it generates no fields, but that's fine. This test does not require us to add any fields. We might add some later, though. So let's see what this gives us. So it doesn't compile. Because do I need to do this in two steps? Probably.
00:35:23.585 - 00:36:00.895, Speaker A: Expanded equals this expanded. So what quote gives you back is not quite a token stream. It returns some type that we can turn into a token stream, hence the. Into expected stir. That's fine. I wish this took into stir. Oh, well, all right, so let's see what this gives us.
00:36:00.895 - 00:36:44.275, Speaker A: Okay, so that compiles, but let's. Oh, I guess we need to actually turn on the test as well. Great. So now we pass both tests, but let's take a look at what this actually generated. So if I run cargo expand, it's going to give me the expanded source code. Let's do it just for test 02. What's the syntax for this? Oh, I see, sure.
00:36:44.275 - 00:37:25.975, Speaker A: So I guess we're looking at main and we're looking at builder 02. So let's do cargo expand, see what that generates for us. Oh, right. Not there. All right, so this is what gets generated. Well, this looks pretty sensible. Right, so this is the original struct, the one that had the derive on it.
00:37:25.975 - 00:38:17.599, Speaker A: And we generate struct command builder and we generate impl command. So this actually generates what we expect. Let's try to see what happens if we put something weird in here, like if in our main we try to do what we talked about earlier and make this like 777, what now happens? Expected identifier. Is there a way I can make this not work? Might not be. I wanted to see whether the span's Aligned correctly. But I don't think there's a nice way for us to test this just sort of quickly. Okay, so if you remember back to the test, it asks us to, once we generate all of this, to actually generate this struct.
00:38:17.599 - 00:39:08.125, Speaker A: So that's what we'll do. We'll go back to our source and instead of generating an empty one, we're going to generate this one. Great. And this they want to generate actually, let's do these. Great. Okay, so now let's just see that that actually works correctly. Okay, so we still pass the test, right? Test zero passes, Test two passes.
00:39:08.125 - 00:40:03.295, Speaker A: Time to move on to test three, call centers. So now we want to generate methods on the builder for setting the different values. So this is what we talked about before, right? When you have a builder, you want to be able to do arg and give one argument and have that be added to the list of arguments are currently there or like executable to set the executable and so forth. So here you'll see that it still has this derived builder. And now with the builder it gets back, it's expecting to be able to call these and have them do the appropriate thing. So they give an example here of the way this method should look like is fn and then the name, this should be the signature and the method should return the builder itself so you can keep building with it. This is basically so that you get to chain calls for a builder, which is sometimes handy.
00:40:03.295 - 00:40:57.785, Speaker A: And all this really going to do is it's going to change the appropriate attribute and then return self. And of course now in the very beginning, what we can do is just generate each of these manually. I don't know what the later tests do, but it could be that eventually we want to generate these dynamically based on the fields, right? Because this macro is kind of useless if it requires these to be the four fields, right? We want it to be able to handle any set of fields. In fact, let's just sort of peek at what optional field repeating field. Let's look at like seven. Okay, so these are sort of different. It might be that we just want to do this the straightforward first and then expand to other fields later.
00:40:57.785 - 00:42:12.311, Speaker A: Okay, so for the third test we want to generate a bunch of methods. In particular we want to impulent. And then we want methods like this, right? And we want, I guess we want them to be published. We want args, I guess what does the test test for? Executable args, envincurrent error, env string and current which should be a string. Right? So let's see what that does. Great. So we still pass all the tests.
00:42:12.311 - 00:43:00.115, Speaker A: Now, now we're seeing this is becoming really verbose, right? Because we're repeating the fields from the original struct multiple times over. And this is really what we want our macro to do for us, right? We don't want to have to write these out because then the derive isn't particularly useful. And so we basically need at some point to write a thing that's going to walk all the fields of the struct. So let's look at for call build. Okay, so we now want to generate the final build method that's going to go from a command builder to a command. And this should, let's see, this method should require that every one of the fields has been explicitly set. It should return an error if a field is missing.
00:43:00.115 - 00:43:51.435, Speaker A: The precise error type is not important. Consider using boxed in error, which you can construct using the input from string for boxed in error. Okay, sure. So now we're going to generate the build method as well. And this is of course not going to return a command, it's going to return name. Right? Because in theory at least, we're generic over or not generic over, but we're abstracting over what the type that we're derived from is. And so here it's going to be something like if self executable isnone, then return.
00:43:51.435 - 00:44:59.313, Speaker A: Why do we want to do that? Oh great. Okay, so we can just do executable is not set to Right. And here again we see this, we see this repetition that we don't really want that will eventually fix by instead just looping over the fields which you remember we have in the parsed ast. Just checking. Is the chat still working? Because it froze for a second there. Of course. Otherwise here, if all the fields are ooh.
00:44:59.313 - 00:45:24.395, Speaker A: In fact we could do this even nicer. But let's ignore that for now. So this is going to be name. This executable is going to be self executable. Ooh. In fact, here's a better way to do this. Ok.
00:45:24.395 - 00:46:21.355, Speaker A: Or is not. What am I doing? Is not set. I think that should work which is much nicer. And current dir and and args. Instead of having all these ifs, see what that gives us? Recursion limit while expanding the macro stringify. Ooh, that's interesting. Does it say anything about recursion limits? No.
00:46:21.355 - 00:47:16.311, Speaker A: Huh. Also, what is happening with the chat? Just checking that this is, huh, weird. Oh, all right. Well, I guess we get out of that. That seems fine. Oh, we need to actually use that. Yeah, that's fine.
00:47:16.311 - 00:47:37.649, Speaker A: As long as the stream is still working. I didn't see anything either. Thanks though. So here, this error is actually kind of interesting. So if you look up here, you see that it says error was not in scope back when we had this. Right. And the reason for this is in generated macro code, you can't really rely on something being in scope.
00:47:37.649 - 00:48:18.895, Speaker A: Like you can't rely on the user having written like use error somewhere as you really need to use full paths for things or explicitly use them yourself, otherwise it just wouldn't work. It's still failing though. Cannot move out of borrowed content. Oh, I see. This is going to have to do like, right, because we only have a mutable reference to self here. And so we can't move out of these fields. We need to clone out the string.
00:48:18.895 - 00:48:44.985, Speaker A: Great. Okay, so that passes. Let's see whether the next one. Oh, we did four. So five should be a freebie. Great. So five should just work.
00:48:44.985 - 00:49:38.275, Speaker A: Great. Can't you use the trait at the impul level? Use the trait at the impulse level? Yeah, So I mean, you could in theory use the trait here. My point is more that you can't rely on the user having imported the thing that you're naming. So whenever you're naming a type that's sort of external to you, you need to explicitly give out its path or explicitly use it. Okay, so six optional fields. Okay, here's what I want to do. Before we do this one, I want us to fix up this one.
00:49:38.275 - 00:49:57.727, Speaker A: So instead of doing this one yet, what we're first going to do is have this no longer be specific to command. I want us to actually iterate over the fields. Right. This is. It doesn't explicitly say this in instructions, but we can do whatever we want. We're learning. Okay, so let's think about this.
00:49:57.727 - 00:50:45.345, Speaker A: Well, so quote, if you take a look at. It has. Where is it? Right, so it has the ability to do repetition. This is similar to the dollar parentheses star that we saw for the macro rules in the very beginning. And this lets us basically evaluate an expression multiple times, as many times as the variable that is used inside appears. In particular, as long as the variable is something that is iterable, it can do the appropriate thing. So what do we want to do here? Well, what we want to do is we want to iterate over all the fields of the original thing and wrap the type and option.
00:50:45.345 - 00:51:57.375, Speaker A: Right. So how's that going to work? Well, remember how we got the syntax tree way back up here, right? So really what we want to do is we want to walk the fields of the data struct and then we really just want to replicate them in our own. But we want to wrap the type in an option. So that's going to be something like I guess let as let fields is going to be ast data. If let syn data struct. Is this else unimplemented? So keep in mind that the user could in theory put like a derive Derive builder on an enum for example, instead. And that is something that we currently just do not support.
00:51:57.375 - 00:52:54.919, Speaker A: So we're going to assume that the derive is on a struct. And here you could imagine that we should give better error messages. I don't know whether that's a later exercise, but you could imagine if the user puts like derive builder on an enum we really want to highlight the enum part and say only works for structs. All right, so the fields are going to be fields and we really want to do if let. Actually it can be even better here. So the structure contains a data struct which contains a fields. We don't care about the other things fields.
00:52:54.919 - 00:53:44.003, Speaker A: We're expecting to be a sin going back here. So where's the data should be under D data struct. So a data struct has a fields. And so this is going to be a sin fields and we're expecting it to be named. Right? And that contains a fields named fields named contains a bunch of other fields and the one we care about is ref named. So that's no joke. Right.
00:53:44.003 - 00:54:37.789, Speaker A: And then let's take a look at what happens if here we put fields don't actually know what this will do actually that's probably not going to work in all sorts of ways. But if we go back to here, let's see what this expands to now. Oh, I guess if let here this should just say named. Let's do our cargo expand. Ooh, data structures not. This should save fields. Okay, so this now expands to command builder and notice that it now auto filled out all of the fields.
00:54:37.789 - 00:55:06.355, Speaker A: Right? All the fields are here. There are twice because we wrote them out manually as well. Right. So we both have this hash fields and these. But we really want here is when we're printing them out down here we want to print them out essentially the same as they were but with an option around the type that they contain. Right. So named here is in fact an iterator.
00:55:06.355 - 00:56:02.667, Speaker A: If we look back at Here, so named is punctuated and a punctuated, if I remember correctly, implements into iterator, does it also implement. Great, yeah. Iteration. So really what we want to do here is down here we're going to do expansion of fields, right? So let's see what this will do. In theory, I think this should generate basically the same thing, maybe this way. Great. Yeah.
00:56:02.667 - 00:56:52.265, Speaker A: So this now generates the same thing. And the reason for this is this pound open bracket star. What that means is call into iterator on the variable that's used inside, iterate over it, and for every element, run the thing inside with the variable set to the item you got. And in this case, fields is the iterator over all of the fields. And so for each field in fields, we're printing out that field followed by a comma which is the same thing that you would normally generate. Of course, this is not actually what we want to generate. Optionized is going to be fields iter map and then this is going to be optionized.
00:56:52.265 - 00:57:46.647, Speaker A: Right, because really what we want to do with these, as I mentioned, is replace the type with the same type, but wrapped an option. So going back up to where we got the ast. So we want to leave all the other things, but we might want to set the visibility manually. In fact, maybe we just want to create our own field. Come to think of it, it's a good question. We might want to do that because we don't want to inherit things like attributes on that field, the visibility of that field, colon type. Like we don't want to inherit any other things, we just want the ident and the type.
00:57:46.647 - 00:58:26.565, Speaker A: So let's manually construct a field instead. So we're going to map the fields that we get and we're going to map them to synfield. So let's look at what synfield gives us. So asyn field field. Oh, we can just construct one. Great. So we want to generate a field whose address is an empty vector, whose visibility is a syn visibility public.
00:58:26.565 - 00:59:18.345, Speaker A: Actually, no, just inherited is fine. The ident should be the same as the one in the original field. The colon token is going to be same as the original one, I guess seems fine. And the type, this is where we don't actually want this to be the original, but let's just see that it expands to the thing we expect. Do I need to like clone this? Probably. Great. So this still generates the same thing, but now we have, now we have a starting place for actually modifying these fields as we desire.
00:59:18.345 - 01:00:18.373, Speaker A: In particular, down here we want to create sort of an option wrapped type. So f ty clone. So this is the original type and we're going to be modifying that type to wrap in an option. So if we look at something like vec, right, what that really does is it's so vec contains the T, right? And we want to generate option that contains T, where the T is the original field type. And so we basically want the same kind of wrapping as is applied to vec. So looking at this. So what we really need to generate is the same structure here, right? It's going to be a path, it's going to have a single path segment.
01:00:18.373 - 01:01:23.135, Speaker A: The ident here is going to be option and the arguments are going to be basically the same as for vec, but the inner args here is going to be a vector of the original type. So you'll notice here that here it starts with path, right? This and that is the same as this path. Everything below sort of nests. So we're really just going to nest that inside the option. So let's see how this is going to look. Skip part of the stream. This is based on David Tolnay's proc Macro workshop, see? So we're going to have to generate this is like original type, and then our type is going to be a SYN path.
01:01:23.135 - 01:01:57.635, Speaker A: What is a syn path, though? Syn path which contains. Ooh, leading colon. That's interesting. Oh, I see. Sure. It does not have a leading colon. So it's going to be.
01:01:57.635 - 01:02:28.845, Speaker A: This leading colon is going to be none. Segments is going to be punctuated path segments. Okay, so how do I construct a punctuated new. Great. So let. Segments is going to be sin. Punctuated.
01:02:28.845 - 01:03:17.455, Speaker A: So punctuated here just means an iterator that's separated by some punctuating character. In this case a comma colon for a path. Punctuated, Punctuated, new. All right, and then here we're going to segments. Dot push. Right, so there's only going to be a single segment here and that's going to be option, Right? That's the only type we actually want in here. So remembering back to vec, right, the original thing is a.
01:03:17.455 - 01:04:24.885, Speaker A: Oh, what's the difference between this path and this path, though? I want to. Oh, it's a type, isn't it? Yeah. Interesting. So we actually need to generate something slightly higher, which is going to be a type path, which is going to include a path, a type path. So this is going to be a SYN type path which contains a qself. I don't know what QSELF is here, but it is none for the vex, so it'll be none for us. And then it's going to contain a path and that's going to be this path.
01:04:24.885 - 01:05:04.445, Speaker A: So for the punctuated one that we had. Oh, man. Right, so we're generating, remember, we're generating the segment to the option type. So this is the. Let's see if I can explain this better. So look at a type like this one. Right? What, what is the type of args? Well, the type of args is a segmented path to a type.
01:05:04.445 - 01:05:39.177, Speaker A: Right. Logically, it's something like A, B, C that. So the segments of this path are A, B, C and option, including its parameters. After, when we. Given that we just want to generate option, we want a path with a single segment and that segment is going to be option of the type that the user gave us. Right? So hence we create a new segment, we're going to push a value. Not so remember, a punctuated stream has delimiters as well.
01:05:39.177 - 01:06:23.885, Speaker A: We don't want to push any delimiters, we only want to push the value. And in particular, the value we're going to push is a path segment. All right, so what is a path segment? Oh, here, Great. So we're going to push a SYN path segment. Path segment has an identifier. Now we're getting somewhere. And the identifier is going to be the identifier of the original type identity.
01:06:23.885 - 01:06:52.605, Speaker A: Actually, is that even true? Original path dot identity. Right. Should force it to standard option option. Yeah, arguably we could do that. I mean, it's pretty easy to do that. So we can do that. But I'm going to not do it right now.
01:06:52.605 - 01:07:27.947, Speaker A: So let's do a to do use standard option option, not just option. So the reason for this is you could imagine that the user defines their own type named option, and our code is currently written would end up using that option type. Right. Which is not really what we want here. We want to use the one from standard option. And this is why really the macro should generate this path. And then the path segment also contains arguments.
01:07:27.947 - 01:07:58.277, Speaker A: Okay, so the arguments is going to be. Wait, I'm lying here. This should be option. This should not be that. This should be synident new option. And what span should this have? I don't actually know how to give this a span. Oh, you're right.
01:07:58.277 - 01:08:11.795, Speaker A: We can just use quote directly. That's a good point. That is far better. I totally agree with you. That is far better. I did not think of that. So this is just going to be quote.
01:08:11.795 - 01:09:07.957, Speaker A: Good thinking. So this is going to be quote, name is going to be F ty ident and ty is going to be F ty dot tie. Actually I'm lying. This should be ident. This should be tie. You're right, that is far easier because we can get rid of all of that and do this instead and say name colon. Now we can even do this pretty easily.
01:09:07.957 - 01:09:30.445, Speaker A: I love quote. Forgot how much I like quote. Like. So let's see how that works. Great, that was far easier. You're totally right, thanks. Right, so now we see it actually generates all the fields for us.
01:09:30.445 - 01:10:02.895, Speaker A: Right. And now we don't need these manually added fields. Right? They are now just noise. And you can imagine that we can do the same thing down here. Right. So for the methods is going to be the same kind of thing. It's going to be quote pubfn name of the field.
01:10:02.895 - 01:10:48.763, Speaker A: It's going to take mute self name colon chai mute self self name is some name self. And now this can just be methods. Let's see if that works. What does this expand to? Oh, did I lie? Probably lied, yeah. We need to extract this. So this now expands to. Great.
01:10:48.763 - 01:11:22.365, Speaker A: So we get all the same methods. Right. Beautiful. Almost as though it was planned. And what else do we want? Well, in build we also want to generate these. So let's generate them clone to take in build. So okay, I'll address that when we get to it.
01:11:22.365 - 01:12:01.935, Speaker A: It's a good question. Okay, so we're going to generate this build method and it's going to have all these lines and in particular it's going to do something like name self.name. in this case clone. OK, or we're going to have to figure out what should go here. I think what we want is stringify name. But can I. Oh, that's a good question.
01:12:01.935 - 01:12:51.245, Speaker A: Is there a way for me to join these strings? I wonder, isn't there a concat. I forget. Forget this Concatenates literals. Great, so I want concat this with is not set. And now this is going to be same thing again. Build fields comma separated. Okay, so one question was raised here in chat here cargo expand.
01:12:51.245 - 01:13:44.985, Speaker A: What did I do? Token is not. This has to be a star and this doesn't need the tab. Okay, so this now generates the right build and there's a question from chat which is instead of this being clone, should it be take? Right, so option as a way where you can take the value that's in the option and leave a none. That way you don't have to clone it the reason we want this to be clone, not take is because if it's take, you couldn't reuse the builder without resetting the fields. And that would be like. It would be fine. You could still use the builder, but it would be unintuitive.
01:13:44.985 - 01:14:46.055, Speaker A: Arguably. Here build should just take self. In fact, that's something we can fix. Build should just take self to sort of document the fact that it doesn't change the builder. And now hopefully all the same tests will pass. Ooh, not so much. Why? Expected type string found result where Interesting Missing question mark in build.
01:14:46.055 - 01:15:03.175, Speaker A: Oh yeah, you're right. This should have a question mark. You are totally right. Good eye. Beautiful. Okay, so now we pass all the tests, but we no longer have any of this repetition. I guess actually we need empty fields as well.
01:15:03.175 - 01:15:49.895, Speaker A: Empty. It's going to be none. So this is going to be build empty comma separated with start. Okay, so at this point, what did I do? What did I do? Expected identifiers remove this comma. This should not have that. Right, so now we pass all the tests without specializing to the particular fields that we're being given. In theory, it now works across any fields that are given.
01:15:49.895 - 01:16:31.315, Speaker A: Beautiful. All right, so now we can try our hands at the next test. So, optional fields. Let's look at this. Some fields may not always need to be specified. So currently, remember we require that all of the fields are set right? We do this like unwrapor business and specifically something that's an option T in the original structure shouldn't need to be set later on. Have your macro identify fields in the macro input whose type is option and make the corresponding builder method optional for the caller.
01:16:31.315 - 01:17:03.747, Speaker A: In the test case below, current dir is optional and not passed to one of the builders. So current dir is option and so building one where you don't call current dir should not be wrong. It should allow you to have that be set to none. Let's see. Be aware that the Rust compiler performs name resolution only after macro expansion is finished completely. That means during the evaluation of a procedural, macros types do not exist yet only tokens. In general, many different token representations may end up referring to the same type.
01:17:03.747 - 01:17:56.205, Speaker A: For example, option and standard option option and vec option t as into iterator item are all different items for the different names for the same type. Conversely, a single token representation may end up referring to many different types in different places. For example, the meaning of error will depend on whether the surrounding scope has imported standard error error or standard IO error. As a consequence it isn't possible in general for a macro to compare two token representations and tell whether they refer to the same type. In the context of the current test case, all of this means that there isn't some compiler representative option that our macro can compare fields against to find out whether they refer to the eventual option type after name resolution. Instead, all we get to look at are the tokens for how the users describe the type in their code. By necessity, the macro will look for fields whose type is written literally as option and will not realize when the same type has been written in some different way.
01:17:56.205 - 01:18:30.743, Speaker A: The syntax tree for types parsed from tokens is somewhat complicated. So this is what we. We've already dug into this, right, which we're going to get into in this question. So here's the nested. This is the same thing that we saw. And in particular, what we're really looking for is this business, right? We want to look for somewhere where the identifier for the type is option. All right? So the only place where this really comes up is for build.
01:18:30.743 - 01:20:09.675, Speaker A: So in build fields down here, we don't want this to fail for fields that are optional, right? So we want to do something like. So the type is going to be. And we're going to have to sort of basically dig down into the type hierarchy for this field. So this is going to be f ty, which is a type dot. We're going to assume that it's a type. Let syntype path is f type if, right? So p now is a path and a path. We remember, have the fields qself and so a path contains a type path which has a field path which has segments, which has to have at least one segment, right? So here we could do something like if segments iter last unwrap, because we know there's at least one element there, so that will give us a path segment.
01:20:09.675 - 01:21:02.055, Speaker A: Actually, let's do if p path.segments.len is equal to 1 and the last one's ident is equal to option. We probably won't be able to do the equality this way, but we'll see. So if that's the case, then we want this. Otherwise we're going to do the standard thing. Then we just want this, right? So I think we always know that this is a path. No, that's not true.
01:21:02.055 - 01:22:01.675, Speaker A: They could inline a type, but if it's a path and that path is. Does not have any colons in it, basically, and I guess at this point this can then be zero, and if the identifier of that one path segment is option, then we know that they're just option types. And so we don't need to do this unwrapping. There's a separate observation here, which is if it is an option, we don't need to store it internally as option option. Right? So that's the other thing we might want to do, which is up here we could do let. In fact, let's just do a convenience. Tie is option, which takes a tie.
01:22:01.675 - 01:23:19.657, Speaker A: Actually we can do this even right, Takes a field and it's going to do this. It's going to tidy up our code a bunch. Excellent. Now you could imagine us optimizing this for like if they wrote standard option option, it would also work. But we're going to ignore that for now. And now down here we can say if tie is option for field, then this else this. The reason I wanted to do that is because we want to do this for the fields as well, so that we don't end up storing an option option, right, which is just unnecessary because currently we're just unconditionally wrapping an option.
01:23:19.657 - 01:24:22.865, Speaker A: So we want to do if tie is option, then leave off the option part. And similarly for the methods here, we want f ties option. Otherwise this then just set the field right. So this will still be option because that was the underlying type. But now because the inner type does not contain an option, we're still good. Let's see what this generates. Do I really? So this is going to be a SYN field.
01:24:22.865 - 01:25:14.365, Speaker A: So if we look now at current dir. Oh, this example does not actually have that. So I guess let's take 06, which had an optional field, so and then change main to have this instead. And now do a cargo expand. So now current dir is now stored just as an option. Notice it doesn't double capture the option, it just uses the option type from the original code. And current dir just takes an option sets self to be that.
01:25:14.365 - 01:26:11.339, Speaker A: And current dir does not unwrap. And so let's see if we now pass six. Ooh, we fail six. Oh, they're expecting current deer to not even take an option. That's interesting. Oh, that's very interesting. So specifically, if we look at 06, notice that when they do give current dir, they're expecting this to just take a string argument, even though the underlying type is option string, which would mean that there is no way to unset current dare.
01:26:11.339 - 01:28:03.105, Speaker A: But I guess it makes sense for ergonomics. So this is going to require us to do a little bit of trickery because we Basically need to remove the option, the wrapping option type, which is a little more annoying. So this is going to be let unwrap option T which is going to take a type syntype. It's going to give you a syntype assert. This shouldn't be reachable because this should only be called if this is true. I guess we can instead just do assert tie is option. I guess this should take a type, shouldn't it? So this is going to be type, this is going to be type and this is going to be type.
01:28:03.105 - 01:28:52.475, Speaker A: So we're going to assert that ties indeed an option. And then in here, if you recall back to do we have a convenient way to get at the expansion down here? So the actual type that's contained in an option is like hidden down in this arguments under args. Right. So we really want to extract the type that's in here. So how do we want to do that? Inner tie is going to be P. So P is the path. Path segments, zero arguments.
01:28:52.475 - 01:29:59.299, Speaker A: So what is the type of arguments? Path arguments. We're going to assume that that is this. Path arguments this and otherwise. Here we can actually give a helpful error message which is like ooh, which is something along the lines of unimplement. It's really a panic. It's a panic saying option did not con option type was not option T. Right.
01:29:59.299 - 01:31:10.811, Speaker A: Because this means that it's taking some other arguments or it has no arguments. So arguably this should be a part of this assertion. So I guess and if let we really want this, don't we? Actually how about this just returns a reference to the inner type that is much nicer that way we don't need to write this multiple times. Yeah, let's do that instead. That's much nicer. Is sum, is sum and is sum. All right, so if it's angle bracketed then this should give us this business.
01:31:10.811 - 01:31:26.305, Speaker A: So let's look back here. That gives us one of these, which is. So this contains the full syntax tree. Right. Which is why it needs to have all these surrounding tokens and stuff as well. All we really care about is args. We don't care about the surroundings.
01:31:26.305 - 01:31:55.857, Speaker A: So we're going to do inner tie dot args. So those are going to be the generic arguments to that type. And then we're going to. That's going to be another. Another iterator over generic arguments. And we expect that to only be a single type. If I this punctuated, does that give me a length? It does.
01:31:55.857 - 01:32:52.755, Speaker A: Great. So if length is equal to 1, we could also invert some of these. So if this return none makes the code a little less indented. Okay, so here we know that we have exactly one argument within there. If let. There's a first or something for this as well. Right? For punctuated first.
01:32:52.755 - 01:33:46.861, Speaker A: Great. So if let. Actually, no, it's not even that, is it punctuated first gives me an option pair. Okay, so inner tie.args.first.unwrap. right. So we can unwrap, because we've already checked that the length is one and that gives us one of these pairs. And in particular, what do I want from the pair? I want value if let.
01:33:46.861 - 01:34:29.285, Speaker A: Right. So what that is going to give us is one of these syn generic argument type T is equal to this inner type. Then return some of that T. Great. So this should give us the inner option type, which should mean that, well, so here in theory we could rewrap it an option. I don't think that's important. But it does mean that down here, if let some inner tie is this.
01:34:29.285 - 01:36:02.815, Speaker A: Then this should take inner tie and set it to sum of that where 75. Who did not like that? Oh, this. We can just make this a normal function. It takes one of these and it returns one of those without a semicolon tie. Inner type 20. Oh, wait, why is that not okay? Oh, fine. Borrow checker value.
01:36:02.815 - 01:36:25.075, Speaker A: That's fine. What does it expand to? That's what I'm more curious about. So now it still generates option string. That's fine. Current error now takes a string. So that is what we wanted. And this seems to generate the right thing.
01:36:25.075 - 01:37:07.753, Speaker A: So why is it complaining? It is complaining that it expected a vec. Oh, are we expecting. Are we extracting the vec as well? Yeah. So for args, notice that we're turning args into string as well, even though that is a vec, not an option. So really what we want here is if the segment is not one or if it's not option, that's what it really should be. Yeah. So now the only thing that is kept option is current dir, because it already was an option.
01:37:07.753 - 01:37:28.415, Speaker A: All the other things retain their inner type. Although this is showing that our type extraction is working for Beck as well. And current dir is a string. Beautiful. Now let's see if we pass the tests. The real question. Hey, look at that.
01:37:28.415 - 01:37:48.915, Speaker A: Excellent. Okay, so we now pass the first six tests. Time for number seven. Yeah. So command here is based on. In the standard library. There's also like a command builder, basically, basically.
01:37:48.915 - 01:38:23.657, Speaker A: But when you pass many arguments, you Sometimes just want to add one argument. You don't want to replace all of them. Right? So in particular you want to do things like this. You want to give. This is an arg and this is an arg. Currently we can't really do that. In particular, what this is asking is let's add an attribute to fields that have fields that are iterable, basically, or that implement extend and generate an appropriate method if they have this field attribute tag.
01:38:23.657 - 01:39:17.675, Speaker A: So that this is really saying add a builder method arg that when called, extends this thing with the given argument. The generated code may assume the fields with this attribute have the type vec and should use the word given in the string literal as the name for the corresponding builder method. Right, so this would be called arg. This would be called env. In order for the compiler to know that these builder attributes are associated with your macro, they must be declared at the entry point of the derived macro. Otherwise the compiler report them as unrecognized attributes and refuse to compile the callers code. Okay, so this means that up here we're going to have to say that this also takes attributes, builder attributes, builder.
01:39:17.675 - 01:40:17.845, Speaker A: These are called inert attributes. They do not correspond to a macro invocation on their own. They're simply looked at by other macro invocations. Great. Okay, so this means that for methods we also want a different one. We want extend methods, which is going to be basically, if so, looking back at what we get back from a data struct fields fields named punctuated field. So remember that fields have this ATTRs, which are other attributes on that field and it's a vec of attributes.
01:40:17.845 - 01:41:29.087, Speaker A: Okay, so if field.adders, if not field attrs is empty, then we're just going to sort of print out f adders and just see what it is. I don't know if this will work. I just want to quote an empty thing just to retain the type. And then I want 07. So let's look at what cargo expand gives us. Interesting, but how do I.
01:41:29.087 - 01:42:07.285, Speaker A: Oh, right, I don't actually invoke it, do I? Extend methods should go here. Right, so it did find some attributes. Right, so there are two. There are two things in our original input that have this builder attribute on them. So we would expect to see two attributes that are non empty and they're indeed both here. And we want to look for is. We want to look for ones where the path which is the thing.
01:42:07.285 - 01:43:11.317, Speaker A: So if you look at it here, the attribute has some symbols and stuff and Then it has a path which is the name of the attribute and then it has a token stream which is the tokens contained within that attribute. So in this case the path is builder, right? So recall this is the pattern we're looking at. So the path is builder and then the token stream inside is going to be each equals envelope. So if we look at here, we get a group delimited by parentheses, right? So those are the arguments and the stream inside is there's an ident each it's punctuated by an equal. Then there's a punctuation equals and then there's a literal which is env the string env. So we have all the information that we need here and so let's use it. So what do we want to do here? Well first of all we want to.
01:43:11.317 - 01:44:49.095, Speaker A: We probably want to do. This has to be a filter map, right? Because we don't want to emit any methods. Oops, that's not the right place, is it up here? Let's space these out a little. So if it's empty then this should return. Otherwise we want to deal with the attributes. Well first we want to check that it's actually a relevant attribute, right? So we're going to do like something along the lines of for actually then we might not need this for attr in F attrs we get back here we're going to say none and for each attribute we want to look at if we want to look at the path adder.path and the path has segments like before, right? Len not equal to 1 actually if it's equal to 1 and adder path segments 0 which is a path segment ident is equal to builder then we want to do something with it.
01:44:49.095 - 01:46:01.255, Speaker A: Well what do we want to do with it? Well then we want to look at the token stream and look for. We expect it to say each right? We expect it to have an equal sign and then we expect the string that's going to be the name of the method. So here we're going to do something like assert adder. Let's see if let. So the token stream is going to be adder tds, right? And we want to walk the token stream to get to check that these tokens are actually the right ones. So we want to assert that TTS next assert equal actually. Well, we want that to be a group.
01:46:01.255 - 01:48:18.925, Speaker A: So what is a group? Well, I guess this probably re exports token stream would be my guess or would be my hope Token stream Apparently not. Oh, maybe it's a re export no, Interesting. In that case, we'll go over here. So a token stream, right? So a token stream implements into iterator and it gives us token trees and a particular group, which is what we want. So if let proc macro oh, we can probably even parse this. What does SYN give me here? Maybe SYN has a convenient parser here. Parse parse a simplified tuple struct oh, it's just going to be a parse macro input and then we're just going to have to figure out what to parse it as particular we want to parse it as atter attribute maybe let's see, drive input, custom syntax.
01:48:18.925 - 01:49:27.747, Speaker A: I'm like fairly sure there's going to be a. I really want like inert but it doesn't seem like that's there could be attribute yeah, but the real question is how do I par. Oh, I see it doesn't. It wouldn't know what to parse it as is the real problem. Oh, examples attribute parse outer the TTS fields contains the rest of the edited body token. Try parsing the tokens of an attribute into the structured. Oh, I see.
01:49:27.747 - 01:50:47.617, Speaker A: So it's already parsed basically as much as it can. So we're expecting this then to be token tree group G is adder TTS Next, let's see that that actually gives us what we expect. This probably has to you like is there a convenient way to clone this? If I have a token stream, how do I. Sure, that seems fine. Intuitor Proc Macro 2 Ah, so now we get to. So notice that it's referring to proc macro 2. So proc macro 2 is a crate that's just a wrapper around the compiler provided Proc macro crate that basically gives you backwards compatibility.
01:50:47.617 - 01:51:53.575, Speaker A: It gives you features from nightly that aren't stable yet and it gives you some basically the ability to use this outside of just the procedural macro so that you can write tests or like basically do things when you're not in the context of running within the compiler. So these shouldn't really matter. Like it's fine for us to do this and I don't think this has anything more useful on token stream. I think it's basically the same. Yeah, we probably need to depend on it, don't we? Macro 2 is 0.4. Right. And this probably has to do something like sum quote just so that it can infer the type.
01:51:53.575 - 01:52:50.705, Speaker A: All right, so what does this give us? All right, so it gives me the group. That's great. And now we want to look at the stream. So this is proc macro to group and we want the stream from that. And then we want. What do we want to do with that stream? Tokens is going to be stream.into Iter we want to assert equal tokens.
01:52:50.705 - 01:53:31.985, Speaker A: Next it's going to be a. I guess we want to do next. I don't know if this will even work, but we can try. That's really what we want to say, right? We expect that there's an eek. We expect that there's an equal. This won't actually type check, but. And then arg is tokens next unwrap and then we want argument.
01:53:31.985 - 01:54:11.005, Speaker A: What Rust plugin are you using? Ale. It's pretty nice. I'm a big fan of it. Wait, what do you mean group does not have stream? Oh, fine, fine, fine. G. This is going to be G dot stream, right? Token tree you say can I do. Ooh.
01:54:11.005 - 01:55:31.325, Speaker A: So I can probably then do quote each into that something that would fly. No, see, I just don't want to fully parse this and I don't think it should be necessary. But I guess unwrap. So this really should be. How about now? Will that let me do this? No, I mean, it's not terribly surprising. I want this to be a proc macro to token tree. Actually, I just want to use proc macro to token tree just because I'm gonna be repeating it a bunch.
01:55:31.325 - 01:56:58.065, Speaker A: I want this to be an identity expected identified reference. So let's see. What can I do with a. Do I really need to like walk it? Because that sounds really unfortunate. So I guess this would be panic unexpected this. I might be happier about this. What was the thing before? Thing before is a punct, which we want to be equal to this expected each foundation.
01:56:58.065 - 01:57:41.275, Speaker A: This expected equals found that. See what this gives us? This should say P. I'm not allowed to compare punct to that. Okay, what can I compare? P? Apparently nothing really. But askar I can compare. This does need to be mutable. That's true.
01:57:41.275 - 01:58:22.915, Speaker A: Beautiful. All right, so now we get just the literals, which is what we wanted. Now we just want to extract the literal from the literal here. And that gives us how do I get out. But how do I get out the value? Oh, it implements display, I suppose, but that might actually not matter. We don't actually need to get out the value. All we really need is now we have that.
01:58:22.915 - 01:59:40.175, Speaker A: Let's see what this gives us. So if we now do fn arg if I do this, what does that give us? What does that expand to expected identifier found arg? Yeah. So now it's basically this turns into each, right? Because the way that this is written is this is a string and I want just the inner part. So the question is, how do we do that? Is there a way for me to turn a string into an identifier? Yes, there is. It's going to be ident new using arg and arg span synident. Right. Because I want to create an identifier for this method and I want it to be tied to the span of the original each part so that it's spelled wrong.
01:59:40.175 - 02:00:29.489, Speaker A: You still get something reasonable. So this, I want to be this. And it needs a string proc macroderived Panicked did it now what? Oh, arg is not a valid identifier. I really. I can't print this. How do I get. How do I turn a string into an identifier? Let's see if there's something in no.
02:00:29.489 - 02:01:24.985, Speaker A: 7 here. Okay, that's fine. Inert attributes. The word inert indicates that these attributes do not correspond to macro invocations. That's fine. So this token tree, when I have a literal, how can I extract the contents of that? Because display displays is going to display it as a string. How do I parse that out? Interesting, interesting, interesting, interesting sin.
02:01:24.985 - 02:02:49.875, Speaker A: Can I parse an ident I wonder Or a literal lit stir? Yeah, parse specifically, can I turn my literal into one of these? Is there a parse literal? Maybe parse macro input. Is there a literal type lit? All right, so how do I make one of these? Aha, great. So I can do syn lit new from this. So that gives me a litter. That gives me a lit. And then I should be able to do if. Let's syn lit stir.
02:02:49.875 - 02:03:56.233, Speaker A: Is this right? Actually I can just do the same here. Right, so if I get a synlit strs then that's great. Otherwise panic Expected identifier found. It didn't really expect an identifier, but it expected a string found. Whatever that is. And now. Right, but if I got a str then now presumably from a str I can actually get the string value.
02:03:56.233 - 02:04:38.995, Speaker A: Great. So now I can do s value and s span. Let's see how that works out. Expected literal found token tree. Oh, right. We need to let arg is match tokens next unwrap. And we have to do the same thing here.
02:04:38.995 - 02:05:19.905, Speaker A: Except this should be literal ll expected string found that and then this is going to match on the arc. So panics are bad practice. But when you're writing procedural macros, you are specifically supposed to panic. That is the way you signal errors to the compiler. Now, I think the next exercise is basically how do you give good compiler messages from procedural macros? But it is still all about panicking. We'll see that in a bit. In the next exercise.
02:05:19.905 - 02:06:17.775, Speaker A: Lit cannot be formatted with the default formatter on 97. Well then, how am I supposed to use it? Debug. All right, great. So here you see, we did in fact get a function with the name arg and the function with the name env, which are the things that were in here. Great. So we did actually get something semi reasonable. Now, of course, what we really want this to be is we want this to contain the inner type.
02:06:17.775 - 02:07:09.035, Speaker A: I think here's something we probably want. We want this to take wrapper to be a string. So this we want to extract from option. This we want to extract from option. This we want to extract from option. However, here we want psi inner type from vec. The specification said we were allowed to assume that this was a vec unwrap.
02:07:09.035 - 02:08:31.615, Speaker A: So this is going to take arg, I guess arg of type inner tie. It's going to also take I guess mute self and it's going to return mute self. And the body here is going to be if self. So I guess there's still name here, right? F ident. If self name is none, then self name is sumvec arg else. I guess we can do it the other way around. If let sum ref mute args or values is self name Then we just do values, push arg else this and then return self.
02:08:31.615 - 02:09:05.705, Speaker A: See what that expands to expected lifetime parameter. Really? Fine. This string is not a part of the return type, so it's just tied this way. Now what does it expand to? You can't do anything without writing without using unsafe. That's not true. There is no unsafety in this code. There's in fact no unsafety in most of the code I write.
02:09:05.705 - 02:09:37.295, Speaker A: So that's just not true. Okay, so what does this generate? To arg is if self args is sum, then we push otherwise. Yeah, so this is what the vec macro actually desugars to. Great. Does that pass though? It's the real question. This theme is called groovebox. I recently switched to it.
02:09:37.295 - 02:10:10.285, Speaker A: It's pretty neat. Pretty happy with it. Duplicate definitions with name env. Oh, that's sneaky. So this one, the name of the builder method and the name of the field are the same. So we actually don't Want to generate a for anything that has a builder, we specifically don't want to generate the standard one. It's a little awkward.
02:10:10.285 - 02:11:15.225, Speaker A: Like the question is basically for args, should it be possible to specify all the arguments at once? It sort of has to be right, because the previous test assumed that you're able to just call args. So it's specifically if the name is the same as the field, then don't generate the normal one. Although how is it possible for the past test to even work here? Like this. Expect this test expects ENV to take a vector. This one. This one expects. Well, this one doesn't actually expect anything.
02:11:15.225 - 02:11:50.035, Speaker A: Oh, that's super weird. I don't actually know what this wants me to generate. I think ENV still needs to take vex string because otherwise the other code samples would no longer work. Right. So let's look at five here, for example, this still calls args and still calls env and it calls them both with vectors. Right. So here we still need to generate orgs and we still need to generate end.
02:11:50.035 - 02:12:55.935, Speaker A: Actually, that's not true. I guess using this could imply that you don't want the default one. I don't actually know what the exercise wants us to do here. It sort of makes sense to generate both when you can. The question is when you can't. I think when you can't, you don't generate the vector version because the user has explicitly said they want this one. So that's going to be a little awkward for us because it means that if you generate an extended method and the name of the extended method is the same as the name of the field, then don't generate the normal method.
02:12:55.935 - 02:15:06.535, Speaker A: Also, I don't think this interacts correctly with. If the user had to type those option back, this wouldn't work correctly. Although that doesn't actually come up here. How do we want to do this? It's a very good question because we could. We could do these same checks from generating the normal builder, but I think really what we would want is just a single one and then mute made. I guess avoid conflict is false. And then down here we want to say if arg is equal to F ident, then avoid conflict is true and then we'll just generate this.
02:15:06.535 - 02:16:50.973, Speaker A: Yeah, I think we're gonna have to do something like that. We're gonna have to tidy it up more than this though. Extended method takes an F which is a field and generates an option token stream combination, I guess of a bool and an option stream. So this would be Instead of this, this would say method equals this and then return some. And if arg is equal to F ident, then it conflicts. Because now methods, this can also be. This doesn't rely on anything outside.
02:16:50.973 - 02:18:11.474, Speaker A: So this can go down here. Just like tidy up our file a little bit. So really what we want to do here is conflicts or conflicts. And extend method is extended method of F. So let's see. So if it conflicts, we don't want to generate this. Although, I mean, we can generate it regardless, right? So method is this, I guess set method.
02:18:11.474 - 02:18:59.879, Speaker A: And then we can do here match on that. If what we get back is none, then we just return the set method. If it's sum of true and extend method, then we give extend method. Right, because we can't also include the set method because the set set method would have a conflicting name. And if we have false extend method, then we produce quote of set method, set method and extend method. Let's see what that gives us. Gives us a whole bunch of errors.
02:18:59.879 - 02:19:59.985, Speaker A: What it does. And then now this should just be methods. Oh, I see. Into let expert is that. And then expert into. It's a bunch of errors. Trade from that is not implemented.
02:19:59.985 - 02:21:07.205, Speaker A: What? Something's very funky here. Extend. I guess this should really just say extend method. Extend method. Why is this getting weird? Token stream implements two tokens is not satisfied. I guess one question is we don't really need to do the into down here. That's mostly just calling us causing us pain.
02:21:07.205 - 02:21:52.625, Speaker A: In fact, this isn't even returning a token stream currently because. I see. Oh, I see what's going on. This is a proc macro to token stream. Great. Arg and F ident. But arg here.
02:21:52.625 - 02:22:17.435, Speaker A: So ident shouldn't ident. New just gives me a new right. Do I need. I don't need to unwrap it or anything. Yeah, and f ident if I have a field. Oh, I see. Could the fields ident be okay? I see.
02:22:17.435 - 02:23:15.655, Speaker A: So this really should be. And this should say name. Really? I can't compare two idents. Am I just confused about what? Oh, yeah, this no longer needs that. No, this should be able to do that. Great. All right, so let's see what it now generates.
02:23:15.655 - 02:23:44.855, Speaker A: Buffen args Buff and arg Puffen env, which is the single extend. And it does not generate the conflicting. The conflicting end that sets all of the method. Great. Okay. See what that does. Ooh, failed something.
02:23:44.855 - 02:25:18.405, Speaker A: Seven failed ENV is not set. Oh, they want us to not even make those when they have each set it shouldn't be turned into an option either. Interesting. So the example to consider here is if no end is ever given, should it fail or should it give you an empty vector? In all the previous examples it gave you an empty vector. So it seems like seven is a little bit underspecified. Assume that fields of the type vec in order for compiler to know. Because I think this is assuming that if something has a builder tag then it should no longer be an option, it should be an empty back instead.
02:25:18.405 - 02:27:23.495, Speaker A: Which I think means that what we want here is. Is built, I guess. And that's going to be something like F dot adders. Oh, that's all sorts of weird iter Any F builder of which returns you an option, I guess proc macro to group. Yep. So this is going to be these, then return some G, otherwise give me none. So now this should be let G is builder of F and this no longer needs a return.
02:27:23.495 - 02:28:36.535, Speaker A: So that is a little nicer. And what this means is also that here else if builder of F is sum then we also just want to do that. And here what we want to generate is different as well because it's no longer being going to be an option. So instead this is just going to take name. Right. So if a vector is given in it should just set the vector equal because the vector does not have a typewrapper. And I guess down here, if that.
02:28:36.535 - 02:29:52.205, Speaker A: Oops. And I guess these are the same and down here as well. Or builder of F. And here we want to generate when we generate the initial builder, anything that is a builder we want to generate as a vec. An empty vec actually let's do new otherwise we're going to generate a none. All right, let's see what that expands into. Psych type.
02:29:52.205 - 02:30:30.235, Speaker A: So now in the builder, args and ENV are both just vectors. They're not options anymore. When we create a new one, they're just created as vectors. When you call build. Oh, ALE does When you call build they're just cloned. They're not required to be some. That's weird too, I guess.
02:30:30.235 - 02:31:00.891, Speaker A: Sure. And for args. Nope. Args should take a vex string. So that is wrong. This should take the type. So args takes a vex string and just sets and just sets self args to that arg takes a string and pushes it and end because they would conflict is only the builder version.
02:31:00.891 - 02:32:08.713, Speaker A: So it only has a version that takes string. All right, let's see what that gives us. We still fail the last one SPECTruct VEC found option where? Oh, right. The code we generate for the extended method here should now always just do self name push because it's now no longer an option. Right, so notice how previously the code for adding just one of these things for an extendable attribute would like do a sum match on self dot the field, but in reality, because they're now no longer options, it should really just. Just do the push. See? Hey.
02:32:08.713 - 02:32:46.819, Speaker A: Okay, we passed seven, now we're getting somewhere. So, progress, Compile, fail. Okay, so this is a. An interesting attribute of try build. So try build, try build also lets you write tests that are not supposed to compile, basically so that you can check the output of your compiler. So you want it to provide helpful error messages. And so this is probably going to just fail, but let's try to run it and see what happens.
02:32:46.819 - 02:33:37.915, Speaker A: In fact, let's just speed this up a little by commenting these out for now and see what it gives us. I see. So here, let's look at what this. So this is someone asked earlier about the fact that we're writing unwrap in so many places. And isn't that bad practice? And it is bad practice in Rust in general. In the case of proc macros, panicking is the way you communicate to the compiler that something went wrong. Preferred way to report an error from a procedural macro is by including an invocation of the standard libraries compile error macro in the code emitted by the procedural macros.
02:33:37.915 - 02:34:15.925, Speaker A: Interesting. Interesting indeed. So here. Right, so here the problem is this is missing an H. So let's look at sync. So here. Oh, interesting.
02:34:15.925 - 02:35:27.567, Speaker A: What does this even do? Interesting. Okay, so we probably want to generate a new one of these. What's the difference between new spend some other span with a par stream? Yeah, so. Oh, I see. Well, that's a good question. Yeah, we don't actually have a parse stream, although it could totally be that we could. But at this point, remember, what we get from the token stream is like ident literal, as I don't think there's any point in parsing that directly with synthesis.
02:35:27.567 - 02:36:59.921, Speaker A: So instead let's just generate the message manually, which would be by doing. So this is up for the each. Right. So here, instead of asserting that it's equal to each, it's like if I not equal to each, then, uh, well, certainly sin error new and the span is going to be the span of the I and the message is going to be this. The real question is what do we do with this error? Like, see, that's what I'm trying to figure out. Because once you have one of these errors, what do I do? Render the error. Like, why does this return a token stream? Oh, I thought I mentioned that.
02:36:59.921 - 02:37:59.395, Speaker A: So I use the ale, which is a VIM plugin that gives you highlighting of compiler errors inline. Alex, how do we make the. Like, what does this method do? Oh, I see. It generates. It generates a compile error statement. Oh, I see what's going on. So really, it's not really that we want to panic, it's that we want to generate the syntax tree that has.
02:37:59.395 - 02:39:00.265, Speaker A: So there's a macro in Rust that's compile error that lets you emit a compile error at a particular point. Yeah. Okay. So in theory, this should be able to return some false. This to compile error. Maybe. What does this expand to? Oh, and then let's.
02:39:00.265 - 02:39:42.521, Speaker A: So O8. No O8. See what this expands to. Yeah, see, so here we now get. Expect. Yeah, so now we get what we wanted and the highlighting, because we take the span from the right place, gives us, in theory, the right error message. So really what happened here is the.
02:39:42.521 - 02:40:40.165, Speaker A: What we produced was when we tried to. Basically when we tried to generate the method for this line, like when we're trying to generate the output, what we instead instead generated was an invocation of the compile error macro which caused it to produce this error up here. I don't know if that's what I wanted, but in theory it might be. So what do we see here? Oh, it wants us to highlight the entire thing. So we actually specifically highlighted the keyword that was wrong. And it's wanting a wider highlight, which of course is relatively easy for us to provide. So instead of this being the I span, and we're going to make it the G span.
02:40:40.165 - 02:41:26.575, Speaker A: Oh, come on. Our builder off is too helpful. Oh, that's fine. We can just have this be F dot adders, zero dots dot span. That's me just sort of bullshit guessing. But so what does. What do we have on field? Field adders.
02:41:26.575 - 02:43:03.275, Speaker A: Attribute attribute. Huh. But how do I get the span of it? Why can't I get the span of this attribute spend? Oh, really? All right, take a look at that. What does it now highlight? Oh, what? Hmm, that doesn't seem right. That should not be the span of this attribute. So, I mean, what it wants us to highlight is everything between the square brackets. And it seems like we can only really get the spans for this or the span for the attribute is just this for some reason.
02:43:03.275 - 02:44:21.805, Speaker A: So maybe what we need to do is generate. Can I merge spans? Probably. Well, what does join actually do? That's why can't I really of a group. Oh wait, spin. Give me back to sin. So on a spot, if I join to what does that do? Join Inner. What is inner? Oh, docs RS proc macro.
02:44:21.805 - 02:44:54.843, Speaker A: Where is the real proc macro here? Does this have a Spanish? Great. What does span join do join. Okay, what does it do? Self.0 thanks. SPAN contains a bridge client span. That's very unhelpful. I basically want to know.
02:44:54.843 - 02:46:18.297, Speaker A: I want to know if I join two spans, what do I produce? Is it like disjoint parts or do they get combined? Because I think really what I want is I want to sort of what happens if I join this with the I span, for example, like this won't produce anything particularly useful, but. Oh, you need to opt in. That's annoying. The real oddity here is that the span of this attribute is not the span of the attribute, right? Like this is not a sensible span for that attribute. It might be that the easier part here is actually to. So basically to do what builder of does. No, see, it really just should be of the adder.
02:46:18.297 - 02:48:09.575, Speaker A: The whole adder. So if we look at what a SYN attribute is, right, the syn attribute, I guess it includes the pound and we really want the path and the like. Does this implement spend? No. Oh, it does. Okay, so what happens if I do like adders zero path span so that highlights just the path, right? I want it to. And if I join it with f adders 0tts span and what was the requirement for me to get join from proc macro to join sember except and not exposed by default. Can I create a new span though? Like basically how do I extend a span token tree? Because this, this really seems like Spanish is wrong for attribute style.
02:48:09.575 - 02:49:16.565, Speaker A: Oh, what's the style though? It doesn't implement spend so it doesn't matter. Let's look at this. Join spans. Okay. Joinspense. Is that a method that I get use the token macro instead? Nah, it doesn't really help me either. Spend.
02:49:16.565 - 02:50:53.431, Speaker A: How do I make my own Spanish? I mean we could just leave it the way it was, but it seems a little bit sort of dissatisfying. Oh, actually maybe this is a bug here because the. The token stream, like the spanned implementation for attribute is that it joins the spans of the attributes token stream filter map. Oh, okay. It needs this for that to work, right? See here like it doesn't actually join anything unless it has this. So that's why it's broken. Which suggests that we.
02:50:53.431 - 02:51:44.219, Speaker A: Actually, I think the span in the test case is the one from attribute parse meta. Sorry, from syn. So attribute parse meta. Oh, I see what you've done. Okay, so what we did here previously is we sort of manually parse the stream inside of the attributes. I see. And it just so happens that there's a attribute has a convenience method for parsing things that have a particular format.
02:51:44.219 - 02:52:49.085, Speaker A: And so when we instead use parse meta, that gives us. Basically what we want here is name value. Right. So name equals value pairs. I see, I see. So really what we can do here is something along the lines of meta is parse macro input. I guess I would be can we do G as syn meta Is that well defined? And then eprint line did not like that.
02:52:49.085 - 02:53:50.165, Speaker A: Although into token stream. Is that something I can use here? Oh, that's not an expression, is it? Oh, sorry. This can just be. This is just the attribute itself. So rather than do all of this business, this is going to return an optional, I guess sin attribute and then return adder. Yep. And then that will give us this.
02:53:50.165 - 02:54:48.345, Speaker A: And then we'll not do the join See whether it likes this expected token stream found right into token stream. Or I guess the alternative would be that I could just. Just call this. I guess the question is what is this result? Oh, I see. So if I get one of these. No, that's not what I meant. Match G parse meta.
02:54:48.345 - 02:55:32.595, Speaker A: So inner is going to be this. If it's inner, then I. If it's an error, then it's already determined what the parse error is. And so at that point I can do this business. Except the error is already constructed for me. Although can I give it a new message? I see. That's as if it fails to parse.
02:55:32.595 - 02:56:44.509, Speaker A: So this can still just be E and then we might need this for later and this is not going to be used. And now the question is what is this business? So this gives me attribute parse meta gives me a meta and if let sin meta name value. Actually let's just do meta name value then we're going to do some stuff. Actually then we're just going to return nv. If we get some other meta, then we're going to have to figure out what to do Do. I haven't decided that quite yet. Now down here, I guess if meta.ident
02:56:44.509 - 02:57:24.355, Speaker A: not equal to each, then we're going to pull this trick again. Right. Then the ident is wrong. So we're going to return false. And then basically the span of the meta with expected each great E token we can ignore. And then this is just going to be meta lit, which is now much easier to get out. So that saves us a bunch of stuff.
02:57:24.355 - 02:58:36.505, Speaker A: This is going to be meta lit. Excellent. And now the question is, what do we do if we get something? If someone does like builder foo and doesn't say foo equals and in that case we can also just construct an appropriate message, something along the lines of this is still metaspan and I guess that's probably fine. And now we also don't need line six and it doesn't like. Right. This is to Compile Error Expected Proc Marker 2 Literal Found. Oh great, we even get the literal.
02:58:36.505 - 02:59:06.275, Speaker A: Even better. So now. Okay, so it's still not quite right. The highlighting now highlights builder, which is still not what we wanted. And now it's using the. The YouTube stream is down for you. Well, that's kind of damning.
02:59:06.275 - 02:59:47.765, Speaker A: Is anyone on YouTube been able to confirm whether or not you can see the stream? I guess I can check here too. YouTube as a whole is having a massive outage. Great. Well, I guess go to Twitch. I guess now there may be more people on Twitch. We'll just continue. I mean people can always just catch up to the recorded video that's uploaded after.
02:59:47.765 - 03:00:24.325, Speaker A: Okay, so we're still not getting quite the right span for. I'm assuming we're hitting this message. Oh, it's because we're already. I see. No, that's still. That's still not right. So I mean, we're presumably hitting this just to double check that I'm not going insane.
03:00:24.325 - 03:01:18.315, Speaker A: I see. So it means at least you found one from the other expected builder. Oh, really? We're hitting this one? Why are we hitting that one? What kind of meta am I getting here? Getting a meta. Getting a meta list. Oh, I see. Okay, fine, fine, fine, fine, fine, fine. So this should be a list of.
03:01:18.315 - 03:02:13.625, Speaker A: If envy len not equal to one, then we have another error which is specifically Oops. Ah. Why then expected only this and then. Okay, so what's the type of the inner thing here? Nested meta. What else could be the nested. Like the thing that I get back from this. If I get a meta list.
03:02:13.625 - 03:03:25.765, Speaker A: Nested is a punctuated nested meta. Okay, so we're gonna do. We're gonna match on Envy's first and if it is a sin nested meta meta meta name value, then we're going to return that. If it's a. If it's any other kind of meta, then we're going to return basically the same thing here. We're going to return this error in a lot of places. So arguably we can make this nicer.
03:03:25.765 - 03:04:29.555, Speaker A: Metab. What does this give me? Meta list. You say out dot nested. Nested. Actually, that's not even true. Why does a meta list have an identity? I see what's going on. The list is.
03:04:29.555 - 03:04:50.045, Speaker A: Oh, okay. So the list that it's naming here is if you. If you look at this. This. Right. If we look at this in isolation. So this is a list that contains.
03:04:50.045 - 03:05:16.251, Speaker A: It's a list. Right. And that list contains builder, Whatever. Right. So that's the list and then I guess builder that further up here. Yeah. So it's a list and the ident of the list is builder.
03:05:16.251 - 03:05:42.425, Speaker A: It contains nested inside of it. It contains a name value pairing. So that's really what the structure of this thing is, which means that we need to parse it as such. So we expect to get this back. We expect the list to have only one item, I think. Right. In fact, Metalist is not a list at all.
03:05:42.425 - 03:06:09.915, Speaker A: So a list. What is it? Okay, list contains a meta list and a meta list is not a list. Oh, I see. Nested is a list. I see. Oh, see, I see. So really the reason this is coming across is you might actually have someone write the following.
03:06:09.915 - 03:07:19.015, Speaker A: If I write A equals B comma c. So this is a list whose identifier is builder, where the first thing is a name value and the second thing is a just is a literal. Well, it might be a meta word, actually. I see. So that's why that can be that way. So if envy ident not equal to builder, then in fact, what does builder even do down here? So our builder of. So this should just be true because we call builderof and builder of checks that it is in fact builder.
03:07:19.015 - 03:08:27.371, Speaker A: So this is fine. And then if the nested length is not equal to one, then rewrite this. And then if the first thing is not a name value, then we also show this, this and that span should have the meta, which is not including builder. This span should have including builder. And this should have if nv. So that's a meta name value. If NV ident not equal to each, then also return this error.
03:08:27.371 - 03:09:01.845, Speaker A: So we're going to create this error. A lot of times I would like this to be nicer. Let error. It's going to take a span and it's going to be this business. Great. So now this can be error and we spend. That is so much nicer.
03:09:01.845 - 03:09:36.505, Speaker A: This can be the same. And then nb. This is air metaspan. This is air also meta span. And this no longer needs to happen because that's. Oops. Because that's already happening outside.
03:09:36.505 - 03:10:12.605, Speaker A: Whoo. All right, let's see how that expands. Return expected option. Oh, no, Method name first. That is true because this is. We're looking at the nested arguments to builder. That gives me a pair and I want the value.
03:10:12.605 - 03:11:20.023, Speaker A: In fact. In fact this. We need to unwrap this and then we're going to match ARG's value. And this is yelling at me because what exactly nvs nested. It's because the punctuated iterator when I call first just gives me access to the first element, which I don't own. Which means that. So for the this.
03:11:20.023 - 03:11:58.809, Speaker A: Is there a way for me to just take the first pop? Sure. NVS nested pop unwrap because we know the length is one. That gives me a pair and then probably something like into value. Great. Into value. So now I own it and now this needs to be mutable. All right, how about now? Great.
03:11:58.809 - 03:12:39.385, Speaker A: This gives me an error and it's just builder. So we've gone like full round trip on getting the span to be back to what it was. Now that said, I think the code is much nicer now because we're using this like meta parsing. It's probably also more robust. Right. So this one, I guess. No, it's not that one, it's this one.
03:12:39.385 - 03:13:27.855, Speaker A: So this we're saying should really have the span of. Should have the span of the invit. Oh, is it because we pop it? So if I do nbspan and then down here do this like, does that help at all? No. So it's not the pop. Good old fashioned debugging. Yeah. Okay, so it is failing there.
03:13:27.855 - 03:14:33.817, Speaker A: It's just that this span. So this span contains just the ident. And I'm pretty sure that's because we're not. We're not including the feature that lets you join join spans and therefore syn is also not able to join spans. So I think what we really want to do is enable who actually, let's take a look at the cargo TOML for this crate, see how we might get at. Yeah, because specifically I think what we want is we want the. From the proc macro to crate.
03:14:33.817 - 03:15:11.545, Speaker A: I think we want this feature. So the question is, how do we do that? We want to concurly only underline one token. Oh, I see. So I can't use this. I need to use new spend. And what does new spend do? Error. Sorry for those not watching the chat.
03:15:11.545 - 03:15:56.875, Speaker A: David, who wrote these assignments is actually in chat and is pointing at all the things I'm doing wrong. Oh, I see, I see. Interesting. Well, I guess we'll do that because I feel like the other option would be to just join the spans manually. But I agree with you, it seems better to just not to just do this instead. So in that case, I guess T this would give in nvs. This would give in nvs.
03:15:56.875 - 03:16:35.605, Speaker A: Although now it might be a problem that we pop it. Come to think of it, this should give in meta. So I guess in these cases we really just want to give in the full token tree. That's going to complain somewhere. Oh, I see. And so now this, I guess has to be one of these. It's sort of annoying, but.
03:16:35.605 - 03:17:48.871, Speaker A: So this has to be generic over T which is SIN 2 tokens TT returns me what exactly a one of these. And now this should be possible, right? Yeah. So we can't use error new because you can't join spans as a span unless I guess if they're consecutive. But then you still need the nightly feature and two tokens is somewhere else. It's in proc macro 2. Maybe it's in quote now what does it highlight? Hey, it highlights the right thing. Great.
03:17:48.871 - 03:18:13.445, Speaker A: All right, now let's get rid of this because no longer needed. Now do we pass the test? Okay, great. Good job, team. All right, let's check. Check that all the other ones also still pass. Beautiful. Now the final one.
03:18:13.445 - 03:19:04.575, Speaker A: Oh, nine redefined Prelude types. So your macro still work if some of the standard library prelude items mean something different. Yes, we talked a little bit about this earlier and in fact here we get pretty close, right? We already use standard option option. We would still fail on this assumption, I guess. And these would fail. So sum is also a part of the option type, right? So this. This needs to say option colon, colon sum Just like this does.
03:19:04.575 - 03:19:43.345, Speaker A: Oh man. Option option sum. What else do we have down here? Those are all fine. This. This would have to be. Where does vec live? Standard vec vec this would be standard option. Option none.
03:19:43.345 - 03:20:20.255, Speaker A: This would be standard. Where does result live? Result. Where does box live? Standard box to box. What else do we have? Mute self. These are all fine. What else is it? Try to override result box option sum none. Okay, this needs to be standard.
03:20:20.255 - 03:21:08.495, Speaker A: Result, Result. Okay, there's another question of like what happens if. If here, like if they had A module called standard. And of course, this was very nice of you, David, to remove the other things that were option here, but in theory you could totally imagine that they then use this option type on this struct. And remember how we have this assumption that the option type is just called option which would totally break if that weren't the case. Is that the right one? Progress. That was the right one.
03:21:08.495 - 03:21:29.695, Speaker A: Excellent. Do we pass all. We pass all the tests. Nice. Of course, there are still more things we could do with this. First of all, the code is a bit of a mess because it's all written in one. But like we did the thing.
03:21:29.695 - 03:22:01.249, Speaker A: Take that Proc Macro Workshop. Although, why does my output give so many warnings? I want to get rid of these warnings. See, it gives me warnings from the test files. Can I just suppress that somehow? Is there a. I want. I want this output. I want it to look literally like this.
03:22:01.249 - 03:22:41.065, Speaker A: But I'm getting all these warnings. Field is never used. Are these the generated fields? Oh, there's something the implementation doesn't test, but that we very clearly need to do, which is. Oh no, we already marketed this. Pub. Ah, this should probably also be pub. Maybe you override rust flags.
03:22:41.065 - 03:23:11.383, Speaker A: Oh, I probably do. Yep. Hmm, I see. So you're saying. Well, I don't really want to remove that. I guess arguably it's unclear whether target CPU native makes a difference for me. I guess maybe I should just remove that at some point.
03:23:11.383 - 03:23:25.841, Speaker A: Well, all right. But we do pass all the tests, so. Yeah, we pass all the tests there. Right. So things we might want to fix about this. Well, first of all, the code is a bit of a mess. Right.
03:23:25.841 - 03:24:01.769, Speaker A: There's a lot of this, like things that look almost the same, but not quite. For example, like the first and last case here could probably be combined maybe even with this one, if you made this optional somehow. Like you could just construct. You could set name to be quote this of name, for example, in this particular instance. So in theory, all these three could collapse into one. I'm also a little bit sad about this vec business. For the.
03:24:01.769 - 03:24:21.747, Speaker A: For the methods. Right. So for the extended method, the fact that we have to do. Where's the check that we have. Yeah, here. Right. Like don't include the set method if the extended method ends up having the same name.
03:24:21.747 - 03:24:47.379, Speaker A: But I feel like these are things that you're going to run into when you write real. Right. Real world macros, regardless. In fact, how about we do some of that tuning? Just. I don't. I don't think I want to start another one of the projects. Like, one thing we might do is actually do us.
03:24:47.379 - 03:25:32.155, Speaker A: If there's enough interest in this, we might do a second stream on proc macros on some of the more advanced ones. Right. So the suggestion here is basically do this one first and then do the other ones, because the other ones have other things you need to deal with that are potentially harder or different. And so I kind of want to do the other ones too. So we might do those in a subsequent stream if there's sufficient interest to cover more of proc macros. I think this is a good intro to like. Here are all the bits and pieces you need to at least get get started and get things to fit together, which is why I think what I want to do for the remainder of today is tidy up this code, at least to some extent.
03:25:32.155 - 03:26:46.755, Speaker A: So the first is what we do about this, generating these methods that are like almost the same. So what we really want to do here is, let's see, how are these different? So this is the set method. So the set method. Well, the only thing that differs is what we choose to use as the the argument type and whether or not we use option. Right, so let's try to structure this a little bit differently, which is we're going to use arg type and value. So in this case we want the ARG type to be inner type and we want the wrapper to be quote this. Right.
03:26:46.755 - 03:28:17.351, Speaker A: In this case we want the type to be type and we want the assignment to be name. And in the last case we want type to be type and name to be this. And then set method can now be equal to without this to be equal to argtype and value. Ah, they're different, aren't they? Ooh. Oh, right. This is our type ident versus token stream. Oh, I see.
03:28:17.351 - 03:29:06.655, Speaker A: Sure. Just to make them have the same type. Right, so that already makes me feel a lot better. And then let's also leave certain comments for ourselves. If the field is an option, don't require. Wait, why does this need to take. Setting is an option T.
03:29:06.655 - 03:30:51.235, Speaker A: Setting should take just a T, but we then need to store it with within a sum. If the field is a builder, it is a vecty. It is a vec T. So we take the regular and the value in the builder is not wrapped in an option. So we shouldn't wrap the value in sum. And finally, otherwise we take the type used by the target and we store it in an option in the builder in case it was never set. Yeah, I'M of two minds of how I what I want Rust format to do with my comments.
03:30:51.235 - 03:32:10.715, Speaker A: It would be nice if it broke comments, but at the same time, and not in this particular case, but in some cases I really want comments to be I don't want it to wrap my comments if I've intentionally wrapped them, which is hard to detect. I agree with you though that it would be nice if it broke comments at 80 at a max width of 80 columns, right? So currently it just it allows a line to run for as long as you have space for within your maximum column. But I never want text to run that wide. I want it to force an earlier break. So here this is not a builder, so just use the regular set. Actually, let's not even do it that way. It's say we need to take care not to include a builder method with the same name as the set method.
03:32:10.715 - 03:33:32.869, Speaker A: For example, consider this struct derive builder. I want my comments to be lighter. Comments should be more important in code. Struct command env string builder each equals envelope. It would not be okay to generate both env string and env string for the field and env string for the builder. Let's these two do not need to be parenthesized to generate both. But here I think here we're decently happy with where we're at.
03:33:32.869 - 03:34:41.185, Speaker A: I mean, we could simplify this. But I'm okay with these being separate. I do sort of want some observations about what these are builder fields fields. So these are the builder fields, these are the methods. These are. These are the build fields. So this is for when you call builder build build empty.
03:34:41.185 - 03:36:00.837, Speaker A: And then I really wish this I didn't have to assign this to a variable, but I guess it's okay. So the other thing that would be neat here is if the if the proc macro also generated comments. It's unclear that it can generate particularly useful comments here, but the one thing it can do is refer back to the original builder using the new fancy auto linking that Rustock supports. In particular, this could say implement the API guidelines no predictability flexibility checklist builder. Wait, is there more than one builder? No, no. Great. So this implements the builder pattern for and then this is kind of cool.
03:36:00.837 - 03:37:16.505, Speaker A: I don't know whether this will actually work, but in theory it might for like we'll quote extrapolate things inside of doc comments. I guess we're about to find out. Name if I run cargo expand now, what do I get? No, it does not. Does not generate that. That's kind of Unfortunate. I think you're meant to use doc equals. Wait, what do you mean? For what? Oh, I see.
03:37:16.505 - 03:37:57.071, Speaker A: I see. I mean, I guess we can do that. That just seems less. Seems a little sad, but I guess. What was the concat. But am I allowed to use macros here? I'm not actually sure whether I'm allowed to use a macro here. Right.
03:37:57.071 - 03:39:42.807, Speaker A: Like this. This definitely seems weird. Am I the only one who thinks this seems weird? I mean, I guess we could try it, but produced unparsable tokens. Yeah, see, I don't think you can use macros in here, so I don't think that helps me at all. Let's look at quote and see what it says. M calls interpolation. Huh? I mean, we could always generate it manually, but that seems unfortunate too, right? Like what? One way for us to do this is to just create a new token stream manually and then just extend it with the appropriate token trees, I guess.
03:39:42.807 - 03:40:40.355, Speaker A: I guess one answer would be if this didn't need to do that. If, like, is this okay? And that could very well be. Well, that produced something kind of like what we wanted. Although that doesn't seem right. Like, is this. Yeah, it also didn't do expansion. It could be that we just need to generate this manually.
03:40:40.355 - 03:42:03.825, Speaker A: So I guess one question would be what? How do you even generate comments? Like, I don't actually know what a comment would parse to, although let's bring this back to what it was for a second. I think what we can do here is cheat a little by going up here and then doing give me the whole token stream and then go to main and then do like, hello. And have nothing in there. And now let's see what this expands to. So now. Oh, that's interesting. So triple equals really does expand to pound doc.
03:42:03.825 - 03:42:51.885, Speaker A: You're right. Well, that's useful. Okay, so. So in theory, then, what we should be able to do is. Here's what I'm thinking. Like, I guess let doc is something along the lines of quote doc equals empty string. And then let's print out what exactly doc is.
03:42:51.885 - 03:43:26.249, Speaker A: And then we just like stick doc here. Right? Does that make sense? And then we're just going to modify it in place. Oh, doc, please. All right, so that is great. And now we just modified this string to be the appropriate. I don't think doc compounds that way. But we can just generate it manually.
03:43:26.249 - 03:44:27.065, Speaker A: Right? So we do this and then we do she. Can I even mutate a token stream? Actually, I probably can. In fact, what I can probably do Instead is now that we have that say token stream, new dot append. And we're going to append a. I guess extend. No, that's not even append. A token tree.
03:44:27.065 - 03:45:04.215, Speaker A: A token tree. Punk. Proc. Macro. Punt. New pound. Spacing.
03:45:04.215 - 03:45:48.775, Speaker A: You say what is a spacing? Alone. Sure. Alone. All right, and then we want to generate a group. Okay, and what is a group? A group is a new delimiter. Is bracket. Delimiter, bracket.
03:45:48.775 - 03:46:28.925, Speaker A: And a token stream, which is this. Okay, so what's an inner? It's an ident. And specifically a. An ident. Doc. Okay, so how do I make an ident? Because now we're no longer using the. The DIN types.
03:46:28.925 - 03:48:08.363, Speaker A: Can I just create like a new span? Is that a thing? I think sure, that seems fine. Call site. Okay, so then we have that and then what we want to append next is a punct equals. It's going to be a loan and then a literal. There's got to be a nicer way to do this because this is a pain. Literal and literal string and that string is going to be this for that. Newline.
03:48:08.363 - 03:48:43.595, Speaker A: Newline. Actually, let's do this format's a little nicer. This. This with name. And this is gonna produce that. And this is going to produce that. And this is going to expand to ts.
03:48:43.595 - 03:49:39.655, Speaker A: I have no idea what this is going to give us, but we're about to find out. So this can now go away. And now what will this expand to? Well, it's a syntax error somewhere. Did I mess up here? Maybe see what this gives us. Oh, does it not take append. What do I have to do for a token stream? It implements extend. Really? So I need to do.
03:49:39.655 - 03:51:10.655, Speaker A: Fine. It's going to be like extend vec of these and this to extend vec of this. Like so I mean, I mostly just want to see whether this could even work. 134. Yeah. And why doesn't this do something useful? Okay, theory. That should be all valid.
03:51:10.655 - 03:51:43.301, Speaker A: Quote 2. Oh, I can't do that, can I? This has to be a Proc. Macro 2 token stream. Oh, that's gonna be annoying. This has to be a proc. Micro 2. This has to be a 2.
03:51:43.301 - 03:52:09.231, Speaker A: This has to be a two. These have to be two. This has to be two. How about now? Well, I mean, I don't know if this produces the right thing. I'm not actually sure it compiles. So this is just a car. We expand.
03:52:09.231 - 03:52:58.577, Speaker A: It's actually doing the wrong thing here or not necessarily, but it doesn't Realize that the new lines technically would need to be done the same thing with. But that's fine. So if I run Cargo doc here, what would this give me? So I think this actually generates the right documentation. I mean, it's terrible. Yeah. Command Builder implements the builder pattern for command. Now this shorthand URL will not actually work unless you're on nightly and stuff, but this is such pain for generating that documentation though it seems like.
03:52:58.577 - 03:54:17.235, Speaker A: It seems like quote just doesn't have a good way to deal with generating comments specifically with interpolation of things. I wonder whether proc macro comment not particularly helpful. What about quote issues comment? Yeah, it doesn't really say. Maybe this is worth raising as a thing. But hey, I mean, it works. I don't know whether we want to keep it there, but you know, this ugly business generates a doc comment for builder that points to the original type. And this experience tells me that.
03:54:17.235 - 03:54:45.625, Speaker A: Oh, I see. Oh, I see. You just format the message. I see. Okay, sure. So here's a suggested alternative method of doing it. Doc format is this.
03:54:45.625 - 03:55:20.515, Speaker A: I think this is what you mean, right? So this and then none of this and then doc is equal to doc and you're saying that should work. Yeah, I agree. That's nicer. It's a little weird. The indirection is a little weird, but yeah, that. I mean that is much nicer. Great.
03:55:20.515 - 03:57:04.123, Speaker A: I don't think for the functions, it doesn't really make sense to add any doc comments. I know that some people like to have comments to just say what the method do, but these. These methods. It would not be useful to have comments Builder maybe, but unclear what else. This is now a decent amount nicer. What we could do here, just for our own sanity is list here is builder is of elements inside the last element and then I guess here nvs nested zero. Ah, no, sorry, that's not true.
03:57:04.123 - 03:58:21.913, Speaker A: It's this list here is dot.in and then this is hopefully each equals foo. This is just sort of. This is the thought process that we went through when writing this code. And it's useful to document what each point is so the next time we get to this code we don't have to do it all again. So this is shouldn't be necessary. This is too was either just a literal or a an identifier or I guess was not.
03:58:21.913 - 03:59:46.795, Speaker A: Key equals value is really what that comes down to. This is. What would that even be like? What other metas are there? Let's save ourselves some future trouble. No, this inside of there was either just an identifier or so that would be something like this. That would be if it's if it's a word or a key value mapping, which would be builder equals foo. Neither of which are okay. Of course, this kind of syntax might actually be something we want to let the user use, but this is more to document what each of these cases are.
03:59:46.795 - 04:01:30.015, Speaker A: This can go in here, there a nested one because it's not supposed to be used outside Builder of we use other places. Wait, do we even. Yeah, okay, I think I'm decently happy there. Implement derived builder okay, I think that's where we're going to end today then. I think it's a good place to stop. What I'll do is I think what I'll do is I'll do sort of an informal poll, probably on Twitter, although also message me if you have particular thoughts of whether people want to see more procedural macros or whether we should consider that topic now covered and then move on to whatever the next thing would be which currently looks like this one, although there are always a bunch of shakeups in the votes after any given after we move on from one stream. Also, keep in mind I've added a bunch of new topics here, so feel free to vote for more things that you think are interesting.
04:01:30.015 - 04:02:20.411, Speaker A: I will upload the video, start a poll for whether people want to see more proc macros. If so, what we'll do is basically work through one or I mean in theory these will be faster now that we know what we're doing, maybe, but work through one or two of the other projects from here from the same workshop and otherwise if people don't want to see any more of it, then we'll do whatever the next voted topic is. Great. Thanks for coming out. I hope this was interesting. I certainly learned a bunch. And I'll see you next stream, which will probably be in three weeks from now, maybe little unclear.
04:02:20.411 - 04:02:25.795, Speaker A: I'll announce it as usual. So thanks for watching. Have a great day.
