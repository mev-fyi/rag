00:00:00.280 - 00:00:33.777, Speaker A: Hello everyone. Welcome back to another one of these long impulse streams. I still need to find a good name for them. I don't really have a collective name for these implementation streams the same way I do for Quest of Rust. Someone suggested Impel Rust, which could be fun given that they're all implementation streams. But I'm still debating it in my head. Today we're going to continue on the journey of implementing hazard pointers in Rust, and specifically what we're doing is porting a library from Facebook called Folly.
00:00:33.777 - 00:01:40.305, Speaker A: So Folly is like a concurrency and synchronization library that has all sorts of bits and pieces in it, but we're only specifically porting the hazard pointer scheme from it, which is also described in a sort of proposal, technical proposal, to the C standard, which I don't think has been officially accepted yet. But it is a real thing that's being proposed and people are being serious about it. And so I figured having an implementation of this in Rust would be helpful. I'm not going to go over all of how the implementation works and stuff again because there's already like part one and Part two, which cover that in pretty extensive detail, but because it's been a while since part one and two, I will sort of spend the beginning of the stream recapping a little bit of where we're at, where we left off and where we're going to go today. The high level summary is that today is going to be primarily about testing. At least that's my intention. Of course, if we run a test and then the implementation breaks, we have to fix the implementation.
00:01:40.305 - 00:02:36.343, Speaker A: But my hope is that we start with coming up with some decent testing strategy for this, because testing concurrent programs is notoriously complicated and hopefully we'll get to something where we're pretty sure that this works the way we want it to. I'll also take a quick second at the beginning to say I wrote a book. If you haven't heard about this book, then you've been hiding in a dark corner of the Internet where my voice hasn't reached you all the time. I've tweeted about this, so it's called Rust for rustaceans. And it's basically a book where I try to capture all of the little bits and pieces that I've learned about Rust and about using Rust and about being better at writing Rust and writing idiomatic Rust over the years. It's sort of intended to be continuation of the of the Rust language, like the original Rust book. It's not a replacement.
00:02:36.343 - 00:03:11.775, Speaker A: It's more like once you feel that you're fairly comfortable with the language, but you want to sort of expand your reach if you will, this is the book to go to, at least that's my hope. And you can order it on no starch. And then you get both like the print and ebook if you bite the print book. And it will also be on retailers like Amazon and stuff pretty soon. I also have a Twitter and on Twitter is where you will generally hear announcements about my streams. So go follow me there or subscribe on YouTube or whatever. However, whatever floats your boat wherever you can get notifications about when I go live.
00:03:11.775 - 00:04:09.539, Speaker A: So just a couple of things that I wanted to touch on as sort of a stepping stone from where we ended last time. Just sort of because a bunch of time has passed. Even if you're watching these back to back and sort of after the fact, in reality it's been about three or four months since the previous part of this video. And since then it turns out things change when time passes. The first of this, and this happened fairly quickly after the previous stream, is that someone sent me a PR for getting rid of this macro we had to do in the original implementation. You may not remember this, but basically we ran into a limitation of the borrow checker that basically meant that we couldn't write a method quite the way we wanted it to because the borrow checker would complain. And we ended up like extracting a macro that did the same thing.
00:04:09.539 - 00:04:57.565, Speaker A: And that way we worked around the borrow checker. Someone submitted a PR that simplified this a little bit. I'm not going to talk too much about this in detail. You can look at the PR if you want to and the linked issues, but just wanted to let you know that I've merged that so there's a slight diff to what I have locally compared to where we ended the previous stream. Someone also filed an issue about a panic in has pointer domain drop when using local domains and about like the counts that we use for retired versus reclaimed items. I'm not going to go into specifically trying to debug this right now. I'm I'm more interested in writing a test that reproduces this problem and then see if we can narrow it down from there.
00:04:57.565 - 00:05:33.665, Speaker A: There's also been a bunch of changes to Folly itself since the previous stream. So this is the commit that I last linked to for Folly itself and this is the latest head at the time of recording and there are a lot of commits. We can narrow this down a little bit. Like Folly has a bunch of things in it. So if we specifically want to look at the synchronization primitives, which includes hazard pointers, then I've narrowed that down here. It's just like two pages or so of commits. So this is the commit that we were on at the end of last stream.
00:05:33.665 - 00:06:19.403, Speaker A: Since then, one of the commits that's landed is this commit, which just aligns the Facebook implementation more with the standards proposal for the C working group. The biggest change here is that in the in folly, the protection mechanism. So if you, if you just sort of recap a little bit, right. In fact, let's do this the other way around. Let's open up the test that we wrote and then just sort of walk through, just so we remind ourselves of the interface. So feels good as a test that's supposed to pass is supposed to make us feel good. So if you recall, the types we export from our library is the atomic pointer type and sorry, not the atomic pointer type.
00:06:19.403 - 00:07:30.595, Speaker A: The atomic pointer type is the one from the standard library, the hazard pointer object wrapper type, which is just a thin new type essentially around an actual value of whatever, whatever kind the user wants to represent. And we expect the user to store that using some kind of pointer interaction scheme. So in this case we're using box. The reason we need the pointer indirection is because hazard pointers guard pointer values, right? So the idea is that a hazard pointer is saying this pointer, like this address is guarded, someone is using it, so you are not allowed to drop it yet. And so that's why we're required that there is some stable address that people can protect, which comes in the form of box in this case. So as a reader you have a holder. So the holder here is a local value to you that has a single sort of slot for a pointer value.
00:07:30.595 - 00:08:21.913, Speaker A: And everyone in the domain is aware of every such slot. So in this case we're using the global domain. There are also local domains, but we're not going to talk about those right now. So there's a global domain that keeps track of all of the slots that have been given out, all of the hazard pointer holders that have been given out. And when you have one of these holders, you can protect a given pointer value. So what you do when you protect a pointer value is that you atomically load. So this is, it assumes you give it an atomic pointer, it atomically loads the pointer value that's stored inside of there and then it stores it in that slot and then it gives you access to the value.
00:08:21.913 - 00:09:31.685, Speaker A: The idea being that because you stored it in your slot. Anyone who might want to modify that value is going to see that that pointer value is guarded by your slot and therefore refuse to make any changes to that value, or at least refuse to deallocate the old value so that you can continue accessing for as long as you have it guarded in your slot. As you see, the API here is I create a holder, I use the holder to protect the value behind X. So the protect is sort of protect and load, right? So you're going to load the value in the atomic pointer and protect the loaded value, and that gives you back a reference, like a real Rust reference, not an unsafe one that you can then use to access the underlying values. In this case, we're accessing the first element of the tuple, and then you can call reset on the holder to sort of end your protection of that pointer value. And at that point, if a writer, for example, had replaced your value, the old value that you're still accessing here would actually be possible to be dropped. Otherwise, it would just never be dropped, right? If you held onto this guard, or rather for as long as you hold onto this guard, that value cannot be dropped by anyone.
00:09:31.685 - 00:10:31.595, Speaker A: And then this is required by Rust safety rules, right? Like, the reference you get back here must remain valid at all times for as long as the reference lives. And similarly, like if you drop the holder, that implicitly releases your guarding of the value. And at that point you can no longer use the reference that you got back from protect, because the protection no longer applies. And then on the writer's side, what you would do is you allocate some new replacement value and then you call swap. So again, X here is an atomic pointer from the standard library, right? So it's just a pointer value stored somewhere that we can do atomic operations on. So in this case, we're swapping the value that's stored in there with a different box that holds a different value. And then what you get back, of course, is the old pointer value that was stored in there.
00:10:31.595 - 00:11:36.945, Speaker A: And at this point, if a reader comes along and tries to protect and load the value, they get back the updated values. If you read from MyX2, you're going to get the updated value from after the swap. But notice that my X, which is the read that we did up here, that one is still using the old value even though it's been swapped away. And that is because we loaded at the time of the protect. And the protect ensures that even though the pointer value has been swapped, the value that was pointed to by the old pointer has not actually been dropped and freed, and we can still access it because it knows that there is one of these hazard pointers guarding that value. And then at some point, as the writer, you can say, I want to retire this pointer value now. And when you retire a pointer value, what you're really doing is you're saying to the hazard pointer library, whenever it's safe to do so, you can now free this object, right? So swapping away the value is not enough to say that it should be dropped.
00:11:36.945 - 00:12:31.513, Speaker A: The reason for this is you can imagine having, say, data structure that has multiple pointers to a given pointer value, right? So this could be something like a cyclic data structure, for example, where you might have to do multiple atomic pointer operations before it's actually safe to say this value is no longer reachable and you can drop it whenever you want. So the idea is that you do whatever you as a writer, you do whatever you want with the atomic pointers, and at some point you tell the hazard pointer library this value should now be retired, which means it is no longer reachable. So that's one of the safety guarantees that you have to sort of sign off on in order to call retire. And you also say how to drop that pointer value. So in this case, we know that it was constructed from a box. So we're going to say this has to be deallocated by using a box when you do get to deallocation. So this does not immediately drop the value.
00:12:31.513 - 00:13:42.697, Speaker A: So we have this drop counter associated with this first value we made, and that drop counter is still zero even after we called retire, we can still keep using MyX, which is the value we read before the swap and before the retire. And if we try to run a reclamation in the writer, it doesn't actually reclaim any objects. It continues to become available. But the moment we drop the H here, we really should have named these better. Arguably, the H here is the holder that has the protection slot for my X. The moment we drop that, then. Now it's not like it gets dropped immediately, but the next time the hazard pointer sort of mechanism gets to retire objects, which tends to be whenever you sort of invoke something inside of there, like for example, the next time you call retire on some value, or in this case here, if you call eager reclaim, then at that point it realizes that, okay, this old pointer value, which is the one that pointed to 42, is no longer reachable, so it's been retired and there are no hazard pointers guarding this pointer value.
00:13:42.697 - 00:14:23.703, Speaker A: Anymore, therefore I'm okay to actually reclaim the value. So the nomenclature here is you have a value that's live, so that's one that's actually reachable. It has not been retired, and therefore it cannot be reclaimed, it cannot be dropped. At some point a value becomes retired, which means that it's no longer reachable by new readers, but old readers may still have access to it. A retired object cannot be reclaimed, yet it cannot be dropped because there may still be active references to it, but it also is not reachable by new ones. So over time, fewer and fewer readers will be guarding that pointer value. At some point that value becomes reclaimable.
00:14:23.703 - 00:15:14.015, Speaker A: So that is it can be dropped, and that is the point at which there are no hazard pointers guarding that pointer value anymore. So if we look at the state of the old pointer, the 42 pointer up here, it's live before we do the swap. After the swap, it's like it is retired, but we haven't let the library know that it's retired yet. Here we notify it that is retired, but it can still not be reclaimed because there's a hazard pointer. The moment we drop H here, it becomes reclaimable, and then the moment we call eager reclaim, we are actually reclaiming it, which then means dropping the value and invoking the deleter that we associated with the retire. And at this point you see that the 42 drop count becomes 1. The new value, of course is still not reclaimed because it's still active, it's not retired.
00:15:14.015 - 00:15:58.985, Speaker A: And even if we drop the handle that was used to store the 9001 value and then try to reclaim, it's still not reclaimed because it was never retired. Therefore it's still active in the data structure. So new reads might still access it, and therefore it can't be reclaimed. Okay, so this is just like the recap of the interface that we have. And it's not super pretty, right? It's very low level. You might imagine, for example, that we could construct a sort of. We could construct our own atomic pointer type, for example, that deals with many of the nuances here itself, like the fact that you have to pass in like deleters drop box, right? Instead we could say we have.
00:15:58.985 - 00:16:32.137, Speaker A: We provide an atomic pointer type that internally always uses a box. And so you never need to do this. One and three here are always true. The retire probably still has to be unsafe because we don't know how the outer data structure is constructed. So we don't know when an element is no longer reachable. But at Least it simplifies the safety invariance. The same thing with protect here, right? Protect requires that the pointer value you give it is actually valid.
00:16:32.137 - 00:17:24.119, Speaker A: And we would know that that is always true if we provide the pointer value and same thing, we could guarantee that retire is being used because we could, for example, refuse to do swaps unless they're unsafe or something like. We could probably tidy up this interface and that might be something we do eventually, but you could imagine that actually being a different crate that wraps what we provide in this library rather than us baking it into the library itself. It's nice to provide this very low level interface. You can build nicer abstractions on top of because. Because the lowest level primitive here is quite powerful and it's nice to have that flexibility to use it in different ways. So that brings us then back to the change that was made. So the first that they made is in folly, the protect method that we talked about.
00:17:24.119 - 00:18:08.425, Speaker A: This is the one that you have a hazard pointer holder, and you protect a given pointer to a pointer that you're going to load and then get the value of, and then you get a reference to it. It used to be called get protected. They've now renamed it to protect, which is the same value we always used and is what is in the spec. And the other thing is that they renamed reset, which is the sort of thing for re giving up the protection that you have to reset protection. This is a change we can make pretty easily. So this is over in Holder, right? So we have a reset and we want to call that reset protection. That is sort of the nomenclature they want you to use here.
00:18:08.425 - 00:18:39.437, Speaker A: And at that point this would be reset protection. Right. And I sort of understand why they made this change because it's not clear what resetting a hazard pointer holder means. Right. Are you resetting the pointer that you're currently storing or are you resetting the protection of it? Right. Whereas reset protection is very clear. You are resetting the protection just to see that this still works great.
00:18:39.437 - 00:19:26.415, Speaker A: So that's a minor change, but let's check that in just to keep the similarity with folly adoption name for reset. That's annoying. And if we look back, that's the only one on this page. That's why I wanted to get it out of the way. So really it's just this page of diffs. If we look through. So this seems to be around hazard pointers, you'll see that this is the whole synchronization directory.
00:19:26.415 - 00:20:06.155, Speaker A: Right. So there's a bunch of stuff here that that doesn't really affect us. There's this one, there's this one, there's this one, this one, this one, this one, this one. And here there are a decent number of them. This one, this seems to be about locking. Yep. And this is more hazard pointers.
00:20:06.155 - 00:20:45.521, Speaker A: So if we look through like a bunch of. These are actually decently large changes. Right. Just looking through the diffs, there's like a bunch of stuff in here. And this is why I wanted to keep the names similar. Remember when we did this original implementation stream, I was like, we could tidy up the interface here to sort of give these things different names. Like if you look at domain, for example, we have like has pointer.
00:20:45.521 - 00:21:19.315, Speaker A: Domain is not very Rustian name for a type. We have all these helper methods like check, cleanup and reclaim. That in turn is called try timed cleanup. And all of these just match exactly what was in the folly code base. And I think that's something that's going to turn out to be really beneficial now because it means that trying to follow these diffs is going to be a lot simpler because we use all the same names. So we can almost just like, port the PRs. Right.
00:21:19.315 - 00:22:26.801, Speaker A: The question now is whether we want to do the work to actually. Let me make this dark, because I know people are sitting in dark rooms. Default dark. The question now is whether we want to go through these and apply all of these changes to our port or whether we want to get started with testing first. I'm a little torn because on the one hand it's tempting to just do the testing first because we have something that we sort of think works. And it means that we don't have to sort of spend all this time looking at diffs and trying to piece them together into what we have. But the downside of doing it is that these might, these changes might be fixing actual bugs.
00:22:26.801 - 00:23:13.085, Speaker A: So when we write a test suite, we might just end up reproducing bugs that have already been fixed. And it's kind of nice to not do that, right? To just have the fixes already and then test something that's closer to being correct. All right, let's see roughly how bad we think these are. So let's read through the descriptions of them. Change the constructors for hazard pointer holder and add the function makehazardptr to be consistent with the working group arrays we never implemented. That's fine. Now the default constructors construct empty holders and arrays.
00:23:13.085 - 00:23:54.519, Speaker A: The free function make make hazard pointer are used to construct non empty holders and arrays. Ok, so this is about the constructor for hazard pointer holders where. Oh, I see a bunch of these diffs actually aren't relevant to us because they're in consumers of the hazard pointer library. That does make this a lot nicer. So let's just collapse these. I think it's worth going through these diffs. It'll also be a good way to sort of page everything back in for us.
00:23:54.519 - 00:24:19.155, Speaker A: So let's start with the sort of top level hazard pointer.h file. Right. So this is. I think they called this out initially. Yeah, that I see. I think it used to be that for them.
00:24:19.155 - 00:25:41.185, Speaker A: In fact, I think you'll see this pretty clearly here. Oof, man, I absolutely hate C templates. Let's see. Yeah, so here they used to have a constructor where you could immediately guard a value, but it seems like they still do is what surprises me, this change might actually not matter for us. They say you have to explicitly call make hazard pointers reset protection. That's fine. So they provide a free function for constructing a non empty holder.
00:25:41.185 - 00:26:04.855, Speaker A: Right, so make hazard pointer takes a. Oh, right. Okay. So I remember what this is. This is. I think this is actually very, very useful for paging things back in. So the holders, remember, have.
00:26:04.855 - 00:27:15.985, Speaker A: Are actually a little weird because the holders are. They don't themselves have a slot. The holders hold a hazard pointer and the hazard pointer has the slot. So the idea here is that you construct a holder, then you acquire a hazard pointer, which is one of these protection slots from the domain, you put it in the holder, and at that point you can keep using that without doing synchronization with the domain every time, and then you can release that hazard pointer back into the domain at some point. Yeah, right. And what we've currently done, and I think this is what the Facebook one was doing too, is that the constructor for a hazard pointer holder for us will always acquire a hazard pointer from the domain. And what that diff is doing is it's saying the default constructor should not acquire for you.
00:27:15.985 - 00:28:39.995, Speaker A: The default constructor should just give you a hazard pointer holder that doesn't have an associated hazard pointer yet. So if you look here, the private constructor, that's fine. Where's the public constructor? Yes, the default empty constructor constructs a hazard pointer holder, which internally contains a hazard pointer holder but no hazard pointer. And then if you want to actually fill it with a hazard pointer inside, then you have to call make hazard pointer, which is the thing that takes a domain and that acquires and then constructs what's weird here is why. Why did they change this? That's a very good question. Right, because it makes it a lot more annoying to construct one. What are they changing domain.
00:28:39.995 - 00:29:17.565, Speaker A: These friend classes are weird stuff. Hazard pointer forward. Yeah, it's got to be. So construction is cheap. I think you're right. I mean it's a simple enough change. I suppose I'm just like when would you ever just have a.
00:29:17.565 - 00:30:50.855, Speaker A: Have a hazard pointer holder that you never use? Also make hazard pointer. I assume you can pass no domain to, right? Like these calls where you don't actually provide a domain. Where's the. This one presumably defaults to using the global domain, although it's not entirely clear how because the free function here always takes a domain. The other thing that's a little weird is remember how our hazard pointer holder is tied to the lifetime of the domain that you constructed with and it's not entirely clear if you don't specify a domain what this would be. Well, one option here, right, is to say, okay, we're going to implement default for has pointer holder specifically for static. Oh, what's F here? F is the like family stuff I think we set up.
00:30:50.855 - 00:31:57.605, Speaker A: Yeah. So the idea here was that to make it harder for you to accidentally use a hazard pointer holder or hazard pointer from one domain with values from a different domain and to check that sort of at compile time. So it's a little unclear what we would even default this to. I think what we would do actually is just implement it for like unit, right. And then what this would actually produce is a hazard pointer holder. I think this would have to become an enum that's either empty or acquired. So this is going to become an empty.
00:31:57.605 - 00:32:27.685, Speaker A: I really want these variants to be private so we. It's really annoying to me that you can't mark variances private. I think we'll get it one day but in the meantime what we'll do is something like this or has pointer holder really as a. Has pointer holder inner domain F. It's. It's real annoying. So this becomes a non public enum.
00:32:27.685 - 00:33:55.465, Speaker A: And so this is going to be a as pointer holder has pointer holder inner static of this. And in fact this is going to be an empty. So the idea would be that rather than we could still have global be like a handy shortcut, right? So this is what they call the make hazard pointer. So if we do this oops. And then the other thing we would do is this is where it gets a little bit weird. Right. So here what we really want to do is say that this takes a domain and returns a hazard pointer holder for that domain and for the given F.
00:33:55.465 - 00:35:08.605, Speaker A: So this is going to be generic over F2, I guess. Actually it doesn't even need to. It can just be F and this would be a self of hazard pointer holder inner acquired. And now the problem we run into is exactly this, which is what I observed about the C code, right? Which is how is it possible to call it without an argument, which is you might be able to get this with sort of overloading in C land, but in Rust we don't have specialization, so you can't really do this. This name is also weird for me. I guess it is indicative of what actually goes on, which is a hazard pointer holder doesn't make a hazard pointer by default. So what you do is you say by calling this method, you're explicitly sort of saying, I want you to create a hazard pointer for me for this holder as well.
00:35:08.605 - 00:36:00.269, Speaker A: I guess we could say make global, right? And then this would not be global and this would be domain. And then this can return self. That's fine. Make hazard pointer. And then I'm guessing that they have some. Right, they have a constructor. See, I think what's weird to me is, okay, let's say that you use this constructor.
00:36:00.269 - 00:36:43.291, Speaker A: So now you have an empty one. How do you fill it? Right. In fact, let's go back to where is that file even going to be? It's going to be over here. So this is the state of the project at the time where we ended the last stream. So if we go to holder, what do we have here? Right. So this implicitly created one in the global domain in the past. Yeah.
00:36:43.291 - 00:37:30.475, Speaker A: Right. So they used to have this constructor which was domain, which is equal to the default hazard pointer domain. And they had a destructor. But did they have something for specifically setting the domain? If you constructed as empty. Right. If you use this empty constructor, then how do you later set the domain? And I don't see a way to do that. Yeah, I don't think there's a constructor for that at all.
00:37:30.475 - 00:38:30.305, Speaker A: No, the example up top here just shows it like it seems like you just always construct the global one. No set. HP rec is a little bit different because where do we have it? Oh, did you mean in the. In the final source, like over here? So the example here does not show how to do it. This is constructing from a given domain. This is constructing from a different holder as a move. But I don't See a way to retroactively set it for a given domain.
00:38:30.305 - 00:39:45.905, Speaker A: Yeah, it's really not clear to me why that API is sort of superior, so I'm a little tempted to just not support it, I guess. Like we could do this actually. I wonder what does protect do? Maybe that's the thing to look at. What does protect do if there is none? If you call try protect and you don't have an HP rec, what happens? Try protecting source load. It doesn't. Oh, I think they need the empty one for moves. They need something to leave behind when you move.
00:39:45.905 - 00:40:36.535, Speaker A: Yeah, but why? I guess it's like, okay, let's. Let's think in sort of Rust terms, right? When would you want to be able to just construct a default value to put in there? And you might actually want to do this if you want to do something like MEM swap or MEM replace or memtake for that matter. Right. Like if you only had a. An exclusive reference to a hazard pointer holder and you wanted to sort of steal it away from where it currently was, then MEMtake would let you do that only if there was a default implementation. And you would want the default implementation to be cheap. But this is pretty rare in Rustland.
00:40:36.535 - 00:41:21.093, Speaker A: Yeah. And like you as a user, you can always just wrap it an option. Well, we could totally do this, right? Of sort of any. You can always construct an empty thing of any type. But like here I just feel like I would tell the caller to use an option like why should we basically re implement option internally in the library? That doesn't seem worth it. I think we're going to ignore this change and keep what we had. I think it was.
00:41:21.093 - 00:41:55.451, Speaker A: I think it was a useful exercise to realize why. But I don't think this is the right pattern for us. Recent protection I think we should keep. All right, so that means this first diff is one we can ignore. All right, next, if. Remove unused hazard pointer domain data members unprotected and children and the function reclaim unprotected safe. That's fine.
00:41:55.451 - 00:42:19.549, Speaker A: We don't have any of those because Rust would tell us about these unused things. So that goes away. No need to do anything. Improve readability. Specialize friends and use specialized aliases. Reduce use of the atom template parameter. Okay, this I don't think is going to affect us.
00:42:19.549 - 00:42:47.951, Speaker A: This seems like C fafre. Yeah, this is irrelevant to us. Great. We're speeding through these support class and function names consistent with WG2. So they've renamed hazard pointer to has pointer holder isn't that the name we already use. Yeah. Has pointer Object base.
00:42:47.951 - 00:43:13.455, Speaker A: Has pointer domain. I think these are all values. Oh, I see. Are the left ones. Maybe the left ones are actually what are in the proposal. Sorry, this is. This one's bright.
00:43:13.455 - 00:43:50.885, Speaker A: That's fine. Yeah. So here you see the sort of example they give right. Of hazard pointer holders are called hazard pointer. I still don't understand why. Yeah. All right.
00:43:50.885 - 00:44:23.549, Speaker A: So this makes me think that we want to conform with the. With the names that are used in the spec. Right. So we would rename Hazard pointer holder to hazard pointer. Because in practice that's just. That is how the user will actually interact with these. In fact, the way the code is structured.
00:44:23.549 - 00:44:46.045, Speaker A: Right. The. The hazard pointer type, I don't think they even deal with like all the methods are pub crate. So I think what we'll do is. I think that change is a good one. So let's go ahead. Oh, do I not have a code action set for this? I thought I did.
00:44:46.045 - 00:45:49.265, Speaker A: That's fine. So let's go ahead and say that has pointer holder is going to become hazard pointer. Right. And our has pointer. It's not entirely clear that that's even a type that exists in the C world. In fact, I wonder what that code actually refers to. Like, if we go in and look at the code in here, what does has pointer holder holds a has pointer wreck.
00:45:49.265 - 00:46:44.733, Speaker A: And we don't have a separate wreck. So I think really what that means is has pointer is going to be has pointer rec as in a has pointer record. So in that case, let's go ahead and move pointer to record. Go to lib Hazard pointer. I don't think this needs to be pub at all. So I think that can go away. We do need this to be record and then we want record to be has pointer record.
00:46:44.733 - 00:47:57.805, Speaker A: That's fine. And arguably we could give this a nicer name too, but I think it doesn't really matter because it's entirely an internal type. So domain is going to probably come has pointer. This is going to be has pointer record. That's pub crate. So that's fine, that's fine, that's fine. And luckily now we should find out pretty soon whether Rust agrees that this type can be private, but I'm pretty sure it can.
00:47:57.805 - 00:48:56.895, Speaker A: This one, this one complains about in holder. This is going to be, I guess, fine. We can retain this as Pub crate Use record. Has pointer record. The reason I like having these pub crate uses is because it means that I can move this around and not have to Change everywhere. Test lib is obviously going to be sad, but I think this is actually for the better because now this is going to be hazard pointer. And in fact, I think what I want to do is I think they're onto something with the make keyword.
00:48:56.895 - 00:49:36.305, Speaker A: I think I want this kind of nomenclature to indicate that the hazard pointer make is not a free operation. Right? It's not just like an empty constructor. It actually has to do work. And at that point, like this will be make global. This will be hazard pointer make global. Same thing here. Has pointer holder is hazard pointer.
00:49:36.305 - 00:50:22.543, Speaker A: See if that compiles. It does not because this is make global. Great, I like that much better. And I think this is almost certainly going to also complain about some of our doc tests. Apparently not, which seems dubious. Remember, we have these compile fail tests and these will almost certainly now fail for the wrong reason. This has to be hazard pointer make in domain.
00:50:22.543 - 00:51:10.467, Speaker A: So I mentioned this when we made them that the problem with writing compile fail tests this way rather than using something like try build is that you don't get to check why it didn't compile you. You just get to check that it didn't compile. And in this case it's going to start not complaining for the wrong reasons. Make in domain. This is also going to have to be make in domain hazard pointer. And this is going to be make in domain. They're still going to pass because they don't compile, but now they don't compile for the right reason.
00:51:10.467 - 00:51:58.319, Speaker A: And we can check this, right? So we can run without this and you'll see it will fail. Who know method load. That's interesting. That is not the error I was expecting that. That's because there's another bug in this which is this should say protect. And now it'll say yeah, here. So now we get the correct thing that the the trait families don't match, which is what we wanted to get.
00:51:58.319 - 00:52:35.759, Speaker A: All right, compile fail back on here. If we do the same thing up here and I do this, I get family error. And if I get here protect, remove the compile fail, then another family error. Okay, great. So now they don't compile for the right reasons. What other renames did they do in this? They renamed has pointer domain to hazard pointer domain. I mean, that's true.
00:52:35.759 - 00:53:19.243, Speaker A: We could have this be hazard pointer domain. Really I want to just name this domain and hazard pointer just pointer. In fact, I will rename this to domain because it really just shouldn't be has pointer Domain isn't necessary. When you have modules, the qualification isn't necessary. So I'm going to go ahead and do that and that's probably going to make a bunch of things not compile. Ooh, same thing here. Object same thing.
00:53:19.243 - 00:54:09.897, Speaker A: Ooh, Holder F is never used. Oh, that's because it can no longer find domain which is now here. Test lib is going to make the same change and now that looks a lot nicer. Right, because the reason why there's no reason to have that prefix is because it already comes from a crate by this name. Right. So if you think about it, if you really wanted the qualification, then you would just instead of saying domain, you would say haphazard domain. Right.
00:54:09.897 - 00:54:56.539, Speaker A: And just don't import it without the. The rename and hazard pointer I'm more conflicted about. I'm sort of inclined to keep the hazard in the name there because it isn't a pointer. It is a hazard pointer that's like its type and it could be a haphazard pointer, but it's in that sense it's more like a guard. But it's not really a guard, it's like a maybe guard or a thing that can guard. So hazard pointer seems like the way to go. Why hazard pointers not epic based reclamation.
00:54:56.539 - 00:55:25.863, Speaker A: There's a whole table in the C proposal that talks about the differences. I'll send that thing here. Why don't you rename with language server? That's what I said. I thought I had the alias set up, but apparently I don't and I don't want to go look it up now. Hazard pointer, default domain. That's fine. We just use global so that's different.
00:55:25.863 - 00:55:59.355, Speaker A: I don't think the rest of these really matter for us. That's fine, we can close those. Fix typo in hazard pointer. That's fine. I don't think we ported that error. So this is going to be. The only reason I have to go through these is because there's one note in here that's like a note to myself that I left in a comment which I really should have just stashed before I started this.
00:55:59.355 - 00:57:02.717, Speaker A: Where is it? This comment and this comment. Yes, yes, yes, yes. Okay, so this is going to be better match names from spec. I really need to set a longer expiry timeout for my key because that's annoying. Fix a bug in hazard pointer Object cohort handling of children of reclaimed nodes. So that's not a problem because we don't support children or cohorts. So this one we can ignore Fix.
00:57:02.717 - 00:57:50.561, Speaker A: Flaky test. That one we don't have to port because we don't have the test yet. Extend cleanup to cover cohort objects. Well, this is certainly interesting because this seems like it's doing something else than it purports to. Like, it might well be doing that too. But this is changing code that doesn't have anything to do with cohorts. This change includes incrementing num bulk reclaims before invoking do reclamations, either directly or in an executor.
00:57:50.561 - 00:58:32.229, Speaker A: The corresponding decrement is done at the completion of do reclamations, which may happen on a different thread if reclamation is done in an executor. All right. I mean, this seems like a thing that we just need to. This seems like it's a bug fix that doesn't just matter for cohorts. So they have relaxed cleanup. Why don't we have a cleanup method? It feels like we should have a cleanup method. There's Load, Numb Bulk, Inc.
00:58:32.229 - 00:59:17.159, Speaker A: Numbulk Deck, Numb Bulk. That's fine. Check. Why don't we have a check, threshold and reclaim either? Do we have a wait for zero? That's interesting. Why don't we have those methods? Look for check, threshold, and reclaim. It didn't exist in our version. Oh, I'm in the wrong file.
00:59:17.159 - 01:00:03.485, Speaker A: So that's not very weird here. In the version we had push list. Do we have a push list? Oh, push list is the one that's used when you want to reclaim multiple items, sort of as a group rather than individually. Currently we only support retiring individually, and I'm guessing the push list. Yeah, I think we just don't do push list. We have push retirement, which is for retiring a single one. But I don't think we have push list.
01:00:03.485 - 01:00:56.705, Speaker A: And push list is the only thing that calls check, threshold, and reclaim, which is why we don't have that. It might be something that's, like, worth adding, but it seems this seems more like modification to a new feature, Although it's doing this even for things that aren't tagged. It's a good question, actually. Like, if we look at here, is there a call to push list, check threshold, push. Check threshold. Push comes from push obj. There's so much indirection here, which is pretty frustrating.
01:00:56.705 - 01:01:24.575, Speaker A: So retired just calls retire on the domain for us. Yeah, I don't think we have the same. I don't think we have the same logic as they do here. So I think that's okay. I think we can ignore this. This would only. Oh, is this In a method that we have.
01:01:24.575 - 01:01:53.913, Speaker A: Do we have a do reclamation method? We don't. All right, I think that's fine. I don't think then that this actually makes a difference for us. That's fine. Eliminate thread local list of retired objects. Non cord returned objects are pushed directly into the domain. Oh, nice.
01:01:53.913 - 01:02:14.495, Speaker A: This is already a change that we have. We don't do this anyway. That's fine. In fact, we didn't implement the thread local has pointer optimization anyway. So anything that relates to that we can just ignore. So this change is entirely irrelevant to us. Yes.
01:02:14.495 - 01:03:49.505, Speaker A: Consolidate non cohort and untied cohort retired objects. So this actually is going to be a little bit of a pain for us because here they're making it so that there's not special handling for things that aren't using cohorts. We implemented only the things that are not using cohorts and now they're saying you gotta use our logic for cohorts, which would mean we have to port that, which is a little annoying. Yeah. So right now we're going through the commit list of relevant files since last time and then making those modifications to our code and then we'll add the tests on top of that. Yeah, so they got rid of push retired, which is a little awkward for us actually, because it means that we sort of have to implement their cohort stuff, which makes me a little bit sad. Right, so we have oops.
01:03:49.505 - 01:04:23.835, Speaker A: Right. So we implement the retired list, but with this change, they're getting rid of retired and not special handling those things. So it's gonna be a little bit of a pain. Right, because they're. They're storing those in this retired list instead, which means we're gonna need to implement retired list. I don't really want to make that change, but to follow along with this, we might have to. Let's see if we can rebase these.
01:04:23.835 - 01:05:04.167, Speaker A: That gets even worse because now they're sharding that list. So we're going to have to do that too. Huh. So the advantage of the previous change, of this change is almost certainly simplification. Right. Because previously they had implementation for cohorts without tags, cohorts with tags, and non cohort retire. And we only implemented non cohort retire.
01:05:04.167 - 01:05:38.895, Speaker A: But they had two and a half code paths for this. Right. Because cohorts tagged and untagged are share a bunch of the code paths and then diverge further down, whereas the non cohort code path, which is different. And we were only implementing the non cohort part, but for them, because they want to support cohorts, which we really want to do eventually too. Right. Having the non cohort path as just a separate code path means that there are more opportunities for things to go wrong. So if you can get rid of them like they did in this commit, then now you have more shared code.
01:05:38.895 - 01:06:07.201, Speaker A: Right. So if you have a bug in one, you have a bug in the other, but if you fix it in one, you fix it in the other. So that's why they make this change. And I think that's pretty reasonable. All right, let's go through and make that change then. This is going to be a good way to sort of dig into some of the deeper stuff. I just want to see how much it changes later.
01:06:07.201 - 01:06:56.415, Speaker A: Right. So this is a change to shard the untagged list, which is probably to avoid contention on it. So that makes some amount of sense. This is. Right, so they have this like ability to have executors that do reclamation like in the background, for example. Like you could imagine, you have a, a background thread that does reclamation every so often rather than forcing the threads that are retiring to do that reclamation. And that's something we didn't really implement.
01:06:56.415 - 01:07:25.031, Speaker A: So I don't think this one's going to make too much of a difference to us. This is a change to the tests, which doesn't matter because we haven't implemented them yet. This is adding a benchmark. Nice. That's something we can eventually port. That's fine. Ooh, that seems like a good change.
01:07:25.031 - 01:08:11.235, Speaker A: And this is something, something improving reclamation. All right, I think we should do these one at a time. I think that's valuable because they seem like they're fairly disparate changes. So the reason I don't want to write the test yet is because my, my inkling here is that there are bugs. Like the part of the reason they did this, I assume is because there are bugs in the implementation and by unifying them you're getting rid of some of the, those bugs. And I don't really want to test known broken code. It might not be broken, but I worry that it might be.
01:08:11.235 - 01:09:10.495, Speaker A: And we like, we have a very basic top level test, right. So, so we know that the basic scheme works. So I think I want to port these first because I don't think that the old code matters in a sense once we do this port. All right, the one challenge here is going to be that as part of moving from push retired to push list, which is really the core of this change, we will have to implement all of push list, which includes a bunch of other machinery that we're going to have to grab from that file. The nice thing here is I think we'll just have to do this and view the file at that commitment. And what am I going to do about these notes? I'm going to. What do I have in my stash? Oh, and then I'm going to stash that.
01:09:10.495 - 01:09:43.865, Speaker A: All right, so they're getting rid of retired, and then instead they're going to use this untagged. So we're going to move this from retired to untagged. Their type is called retired list, which is a little interesting, right? We, we didn't use this type. We use this retired list type. But I don't know if our retired list is the same as their retired list. This is something that I guess we will find out. And then when we call push retired.
01:09:43.865 - 01:10:49.495, Speaker A: Oh, this is in where and retire. Oh, why do we do that in bulk look up and retain? What do they do to the bulk look up and retain then? Oh, they give the entirety of try bulk reclaim and bulk reclaim. See, this is why they made the change, right? Because all of this can go away because they can just use the cohort stuff. It's just that that's all the stuff we had. Well, even better of a way to make sure we understand what the code is doing. Okay, so they really get rid of this whole thing, huh? All right, that's fine, I guess. All right, retire.
01:10:49.495 - 01:11:53.105, Speaker A: So what do they do in retire now? So in order to retire, you have to construct a retire node that you stick on the retired list, right? So the idea here being that you're basically keeping a queue of objects that have been marked as retired. And then at some point in the future, something, whether that's a future thread that calls retire or some background executor is going to walk the list of retired objects, check which ones are actually reclaimable, and then reclaim them. So you construct one of these retired nodes that is basically the type of the things that you're going to stick on that linked list. And then you push it. So here, this is where we stick it at the head of the linked list, right? Where they basically we. I think we basically inlined push retire here. So push retired is basically from here and onwards.
01:11:53.105 - 01:12:36.355, Speaker A: This is where we construct the node and then this is where they have a barrier and then move to stick it on the end. And then if check, clean checkup. And that's the same thing we do here. We stick it at the head and then we do check, cleanup and reclaim. Which means that now this is going to change to self.push list of retired. And then if we find.
01:12:36.355 - 01:13:14.419, Speaker A: So they don't have a push retired, they just have a push list and we're going to have to implement the same thing. So push list. In fact, we can just stick push list right here for now. So push list is going to take a self and a. Does it need to take. It might need to take domain. That's fine.
01:13:14.419 - 01:13:53.705, Speaker A: And a star mute. In fact, it doesn't need to take a star mute. It can take. It can take a retired. What do we have over here? Retired just takes this one. That's fine. So we don't need this.
01:13:53.705 - 01:14:38.375, Speaker A: So this. I think we're gonna have to require that it takes a box retired. We could box internally in this function. The reason why it's nice to let the caller do it is if the caller for some reason already have a has a box, then you. They can still call this method. They take a list, not an item. Well, so only kind of they take a linked list node that may or may not be the head of an existing list.
01:14:38.375 - 01:15:09.597, Speaker A: And that's the same thing we do too. Right. If you look at retired, it has a next pointer, so it could itself be a list. So think of this as it's a node in a retired list which may or may not be a list. Like it could be an item or a list. But that's sort of the nature of linked lists is that any node is a list. So what do they do in push list if the list is empty? All right, so if.
01:15:09.597 - 01:15:46.835, Speaker A: How could the list even be empty? I don't think the list can be empty in our case. And I think what we're also going to do is work under the simplification that we're only going to retire one thing at a time for now. So what we can do here actually is like assert retire dot next. Is that an atomic pointer? It almost certainly is. Yeah. And. But we can do get mute.
01:15:46.835 - 01:16:25.401, Speaker A: Only single item retiring is supported at the moment is null. All right, so what do they do in here? They read out a cohort tag. We don't do cohorts. We don't do tags. So that's fine. Then they do a light barrier. They do a list from head to tail.
01:16:25.401 - 01:18:20.745, Speaker A: That's fine. If not tagged, then untagged dot push. Right. So this is going to be untagged is a retired list. And I think here we should really just help ourselves a little, which is just add a retired List push items or I guess this is like a sub list retired, right? Because this code is entirely generic and the sub list is going to be box into raw of sub lists, right? Because we're going to be sticking on. We're going to be sticking raw pointers on there. They read the head up here, which we're going to have to do up here and self count, fetch, add.
01:18:20.745 - 01:19:36.353, Speaker A: So here there's like arguably this should. This is one of the places where this one technically needs to count how many items are actually in that list, right? In order to find the right count. Here we can do that, right? We can say let n is n is zero and then we do something like actually we can do let n is. And we're going to do this, introduce a scope so that in here we can borrow into sublist. Next is sublist and then we're going to do While next while cur.next. get muted and here this can be an unsafe. Like this can be a get.
01:19:36.353 - 01:20:30.955, Speaker A: I'll explain this code in a second. Just so we're gonna do this. No, we're going to do while cur next do get dot is null. We're basically just counting the number of items in the list and we're going to set curr is equal to that. Is there not a. I thought atomic pointer? Why am I not getting autocomplete? Not entirely sure. Atomic pointer.
01:20:30.955 - 01:21:08.535, Speaker A: This might be bright. No, it's not. Okay, so when you have a. Now that's why when you have a mutable reference to an atomic pointer, then you can just call get mute to get its actual value. But I think that's fine. We can just do load of ordering relaxed relaxed. And because the idea here is that because we own the head of the list, we know that no one else is modifying the rest of the list either.
01:21:08.535 - 01:22:00.879, Speaker A: So safety. We own the head of the list and thus also all of its elements. And a retired can only be constructed from valid elements. Yeah, maybe. Maybe you're right. Maybe this should be a like fn len of self that returns a usize. The only challenge with doing it here is that here you no longer have the guarantee that you own it.
01:22:00.879 - 01:22:47.145, Speaker A: I guess what we could do is this actually. But down here we can safely dereference because we know that we own the list, we own the head of the list, there are no other owners and therefore the list is not going to change under us. We could have it be a length that takes a. An exclusive reference to self and that is probably good enough. Like if you have exclusive access to the head of the list. The question is, does having exclusive access to the head of the list mean that you have a guarantee that you can dereference the next pointers? And I don't think that's true. So I don't think I want to add it as a len there.
01:22:47.145 - 01:23:53.019, Speaker A: I think I want to have it be explicitly just in push where we own the source. So this is now going to be n plus equals one and this has to start at one because sub list it starts at an element of one and then it returns N. I don't understand why I'm not getting. Not entirely clear. Let me try this why I'm not getting any auto completion anymore. Oh, well, so N. I mean it could be.
01:23:53.019 - 01:25:28.065, Speaker A: You're right, it could be an unsafe helper function. I don't think we'll need len anywhere else though. So N is going to be there and then we're going to fetch add N here. So if we now go back to this change, we're basically implementing untag push may not be locked. Yes, I think this like retired list that they have is probably something we need to look at more carefully. So where did they get their retired list from? The has pointer detail shared head only list. So has pointer CPP oh, is there a house pointer Detail detail has pointer utils thread save linked lockable list that maintains only a head pointer, supports push and pop all it's lockable.
01:25:28.065 - 01:27:02.745, Speaker A: That sounds pretty painful. I wonder if we can get away with not allowing just not supporting the locking part of this actually, because my guess is that the locking is needed because of of the sort of cohort bits or maybe because like tagged is also a retired list. But I don't think we need that functionality in untagged. So for now I'm just going to say this is just going to stick it onto the head of the list. The other thing that's awkward here is so there's one more change that has to be made so that this actually can support a list which is that this has to change the next of the tail of the sub list, not the next of the first element, otherwise it only supports one element. So this is going to be last, I guess last. So we're going to set.
01:27:02.745 - 01:27:53.839, Speaker A: This is going to be. Oops, it's going to return n&curr.next and this has to be right. So we're returning a raw pointer to the next pointer of the tail of the list because that is the thing that we need to modify so that it Points at the head that we're replacing. Right. So you have a current linked list, right. Which has a head here.
01:27:53.839 - 01:28:36.449, Speaker A: And we're inserting a list here which has a head and a tail. And we need the next pointer of the tail to point to the head of the old list. Right. And in order to do that, we need to know what this next pointer is so that we can change it. And so that's where we're computing up here. Now this then is going to be instead of unsafe like this, we're going to say last oops.store head ordering doesn't even need to be that.
01:28:36.449 - 01:29:37.341, Speaker A: It can just be release as atomic pointer. Right. And it does need an unsafe this safety. We haven't moved anything in retire and we own the head. So last next is still valid. Right. So we're storing the head that we got from the list into the next pointer of the tail of the sub list we're inserting.
01:29:37.341 - 01:29:53.701, Speaker A: And we're doing that in a loop. Right. Because the head might be changing under us. Great. So now and this has to be just self. Actually I'm lying. This has to be now.
01:29:53.701 - 01:30:34.821, Speaker A: If we go back to push list were not tagged. So we're going to self.untagged.push retired and then what does it do? It does add count and then check threshold and reclaim L dot count. So we could probably have our push return, the number of things that added. That seems pretty reasonable. So that's going to be N. So it has a.
01:30:34.821 - 01:31:06.235, Speaker A: An ad count. I'm going to keep this one for later and just in case we need it. So that's going to be here. Add count is count dot fetch add. That's very unhelpful. I see Count is really. So remember how we have our count.
01:31:06.235 - 01:32:00.415, Speaker A: I think our count is just going to become. I think that's just the count of the number of things in untagged in our case, which we store as an item of retired lists. So we don't actually need to do anything special here because this ad count is a part of the push into untagged. Like this count is already kept inside of untagged. So we don't have to do anything about that. In fact, that also means we don't care about why is this an eyesize should be a use oh as is. That's why.
01:32:00.415 - 01:33:16.685, Speaker A: So push list up here that does that and then it calls check, threshold and reclaim. So this is no longer going to be check cleanup. It's going to be check, threshold and reclaim which is this method Right here which calls check count threshold. This is the same thing that we went through last stream right of we need to fall follow back like all of the methods that they have. And then eventually we can probably tidy this up a little bit. But for now we'll just do it the way it's going given. So check count threshold is I'm guessing load count is actually just going to read from count which is the replacement for our count which is the count value inside the retired list of untagged.
01:33:16.685 - 01:33:58.317, Speaker A: So check count threshold returns a use size, possibly an eye size. So our count is going to be self untagged count. That's easy enough. Dot load and how do they load in load count acquire. That's fine. And then while our count is greater than threshold. All right.
01:33:58.317 - 01:34:39.915, Speaker A: While our count is greater than threshold and threshold came from over here. And I think threshold we already have. Okay. Ah, I thought we already had this one like H count multiplier we definitely use somewhere we have reached threshold. I see. But we don't actually have threshold. So we're going to have up here.
01:34:39.915 - 01:35:43.785, Speaker A: Consteven threshold takes no arguments return say let's say you size and it returns the max of the k threshold which is a value that I don't think we ended up using or rather I don't think we made configurable, which is a little awkward actually because we're gonna need it now is the R count threshold. Right. And the R count threshold is a thousand with which I think we have up here in a value. Yeah. Okay. So our count threshold is really what threshold is. So this is just going to be our count threshold.
01:35:43.785 - 01:36:44.255, Speaker A: Well, I guess we can just do max. That's fine of that and the k multiplier times h count. So this is not a cons because it takes self and it's the k multiplier which I think is the same as the H multiplier. Why they have multiple names for this is not entirely clear. K multiplier is 2 which is our 8 count multiplier. Okay. So H count multiplier times self dot and H count is H count dot load.
01:36:44.255 - 01:38:02.885, Speaker A: So what is our H count? I think the H count is the number of hazard pointer records. So this is going to be has pointer. Why do I not have autocomplete? It's very unfortunate dot load and that's loaded as acquire. Yeah. So this is going to end up being an eye size. So now that we have threshold check count threshold. So I think if I remember from last time, this is really just Trying to.
01:38:02.885 - 01:39:12.925, Speaker A: It's sort of a heuristic that they've implemented for figuring out whether or not you should run reclamation. Because you don't really want to run reclamation every single time someone retires an object, for example, you want to do it only when the reclamation list or the retirement list is getting particularly long. And so that's why they have these like multipliers and stuff. It's not really a part of the data structure, is more a part of the heuristic. So it's while our count is greater than self threshold, then if cascount. Oh, that's weird. So here what they do is they're trying to do self untagged count compare exchange week of our count to zero.
01:39:12.925 - 01:40:00.825, Speaker A: Right. So they're trying to set it to zero. And if they succeed then they do whatever this is, which we don't know yet. So they're matching on this. Or actually they're just saying if this dot is okay, then return I count our count, otherwise return zero. And then they do set due time. I don't forget if we did this time optimization, we do have sync time, but we don't have due time.
01:40:00.825 - 01:40:41.735, Speaker A: So let's add due time in here. Oops, that's not what I meant to do. Yeah, I'm guessing what this is really going to be is all of. I think sync time is related just to retired. So I'm guessing these methods are all going to be deleted and it's not going to be the untied somewhere. I mean, I don't think I have a syntax error that severe. But yeah, I don't know what.
01:40:41.735 - 01:41:53.697, Speaker A: It doesn't seem like it's particularly confused, although it seems to think that maybe I have two of them open. Not entirely clear. I'm going to add a little helper function here and do time is equal to now. It doesn't even take self. Yeah, I mean it could be because there are a bunch of things we haven't changed yet. So set due time. Is that called anywhere else? It's only called there.
01:41:53.697 - 01:42:36.045, Speaker A: They have a lot of these helper methods that at least personally I would just not do. So they have a due time. So self due time.storeself now plus the sync time period. Yeah, see, I think this is the same as sync time and it's just been renamed. But that's fine. We'll just this and ordering probably release.
01:42:36.045 - 01:43:13.257, Speaker A: What do they do for that? It's acquire, release and relaxed. It's. This is very, very annoying. But fine. Ordering relaxed. I am glad that there's no. There doesn't seem to be any microphone trouble this time though.
01:43:13.257 - 01:43:56.355, Speaker A: So that's good. Great. So now we have check count threshold. So this next method, this one check threshold and reclaim is going to be let our count is self dot check. Oops. Check count threshold. And then if our count is 0, then check due time.
01:43:56.355 - 01:45:02.045, Speaker A: And what does check due time do? So check due time returns a U64 maybe? No, it returns us. So it does time itself now and then it low. See, they have like, even though load due time is only called in this one place, they have a helper for it which seems successive. Let do is self do time load acquire. So here I think this is just to try to have. Basically they're trying to make it so that you reclaim objects either if a certain amount of time has passed or if a certain number of objects have been. Have been acquired have been retired.
01:45:02.045 - 01:45:33.185, Speaker A: Doesn't calling system time so often put a big limit on maximum performance? It shouldn't. I mean it is true that a system call is expensive, but in general it shouldn't be because it's using. Oh, I forget what it's called now. It's not a traditional system call. It gets the load from like basically shared memory with the kernel. In general, you get to do this when you're just reading time. So it should be fairly fast.
01:45:33.185 - 01:46:38.165, Speaker A: Especially there was a recent PR that landed in Rust that changed how we extract these timestamps, which should help with this as well. So it's going to take the due time and if time is less than due or cast due time. All right. Self due time compare exchange, not the weak one. It's going to be acquire release of do with time plus sync period from ordering acquire release to ordering relaxed. Oh, or this is. Oh, I see.
01:46:38.165 - 01:47:42.905, Speaker A: So the idea here is that if it's not yet time, or if someone else has updated the due time is what this is saying sync time period. Right? So if this compare exchange fails, then that's because someone else has updated the due time, which means someone else realized that they needed to do the swap. So that's what this OR is for. Because we don't want like imagine two threads are both calling retire at the same time. They both check do, they both realize that you're due and then they both run reclamation and we don't want that to happen. So that's why this, this extra sort of second clauses here. So in that case, return zero not yet do or someone else noticed we were due already.
01:47:42.905 - 01:48:58.987, Speaker A: Otherwise return exchange count which is Just self dot untagged count swap zero with acquire release. So this is now an eye size. All right, so back to check threshold and reclaim. We do. If our count is still zero, then there's nothing for us to do. Okay, so I think the idea here. Let's try to reason about what it's doing so far.
01:48:58.987 - 01:49:56.705, Speaker A: Check count threshold is looking at. Okay, so check count threshold here is basically. You can think of this sort of as a not quite a lock or a semaphore, but it's basically like it's trying to change the number of items. Really. This shouldn't be under untagged because it's no longer really the. The length of the list because we're sort of mutating it all over the place. But what we're doing here is checking whether we are able to set it to zero.
01:49:56.705 - 01:50:33.915, Speaker A: If we're able to set it to zero, then we return the number it was before it became zero. If we were able to set it to zero, we are responsible for reclaiming the items. So if that's the case, then our count is not equal to zero and we're going to go on and do reclamation. If we weren't able to set it to zero because, for example, it changed under us, then we go and check whether reclamation is due anyway. If reclamation is not due either, then we just return. There's nothing for us to actually do otherwise. Either it's due to.
01:50:33.915 - 01:51:07.945, Speaker A: Either it's time to do reclamation and we sort of won the race there, or the we managed to set the number of items to 0. In either case, it's our job to do reclamation. So that's down here. It's like we discovered that we should do reclamation. There might still be other people doing reclamation, but we should be one of them. So num Bulk. Where's the counter for this? This one.
01:51:07.945 - 01:51:47.807, Speaker A: So we're going to start a bulk reclamation. Yeah, you could totally have two reclamations running at the same time, although. So you could do that even if you just had a reclamation running for a long time. If it runs for more than sync time period. So it doesn't actually. You don't get this guarantee even if it's monotonic. If it is monotonic, you might have fewer sort of false races.
01:51:47.807 - 01:52:27.509, Speaker A: But I think that's it. This one is if Atom INT is the same as standard Atomic Int and we're in the default hazard pointer domain and we've been told to use an executor, then invoke reclamation. Executor. Okay. We don't support executors. So we're just going to ignore that for now and we're going to call Do Reclamation Self Do Reclamation of our count. Great.
01:52:27.509 - 01:52:54.515, Speaker A: So now we need. Now we need Do Reclamation. All right, so do Reclamation Self Archize. Hello cat. While true. Great. Luckily, we only have to deal with Untagged for now.
01:52:54.515 - 01:54:04.055, Speaker A: So let's see what we got here. It's gonna be a pain. All right, so we're doing let Untagged equals I guess Null Bool done is true. Extract retired objects. Okay, so this is actually going to be pretty simple because we don't have support for tagged and this shards loop is only for tagged. So really all we're doing here is we're just. We're just taking retired.
01:54:04.055 - 01:54:58.501, Speaker A: That's actually all this is doing. So in here, the place where we used to call self retired, where's the place where we steal it? It's down not. Where do we take this? Oh, it's probably gotten swap maybe. Yeah, here. So in bulk reclaim, right. Which remember, is going to go away. We have this code for stealing the entire list.
01:54:58.501 - 01:55:41.437, Speaker A: And I think this code is going to turn out to be basically exactly the same as what this unwraps into. So let's go ahead and we know this goes away. So I'm just going to delete this here and I'm going to grab. Well, I'll leave it in place for now, but we can at least do this. So Do Reclamation is going to steal the head of Retired. That's all this really did. And if steel is null, then it's not quite true.
01:55:41.437 - 01:56:46.165, Speaker A: We're going to do nothing because we have to do this bit. So this is going to be. If not steal dot is null, then we're going to have to do this business. And this is going to be the same logic that we used to have, right? Which is find all the guarded addresses. So that's this load has pointer vals, right? So that is walk all the hazard pointer records and then store them in a set, which is the same thing we do here. We create a hash set, we walk all the records and we insert them into the set. It's not clear why Folly doesn't skip the active ones, but that's fine.
01:56:46.165 - 01:57:27.085, Speaker A: So I think this logic is still sound. So we're going to go with this here. So back to this. We don't have tagged, we have match reclaim untagged. And so this is where it's going to be interesting. So untagged here gets populated by extract Retired objects. So where does done come from? That's the other good question.
01:57:27.085 - 01:58:07.545, Speaker A: Let's see what Match reclaim untagged does. It's gonna walk. And this has support for this like children stuff, which we don't actually care about. List, match, condition, untagged match, no match. Right. So stick anything that matches into this. Take anything that didn't match into this.
01:58:07.545 - 01:58:42.475, Speaker A: And we're looking for the ones where the hash set indicates that the pointer isn't guarded. Okay, that's fine. So this is just basically a partition over the list. So this is walk the list, which is probably what we did inside bulk lookup and reclaimed. Right. Which is this walk the list business. And we can actually.
01:58:42.475 - 01:59:25.885, Speaker A: So this is a little interesting because do reclamation. Where does the actual reclamation gets done? I think it gets done here. Yeah. Reclaim unprotected, claim unprotected. Why does reclaim go for the ones that are not a match? Oh, right. Because match is that they are protected. Okay.
01:59:25.885 - 02:00:10.615, Speaker A: I think this actually translates pretty well to what we had before. So if I now go here and take this code and just. I'm just going to inline it up here for now. We can tidy that up a little bit later. Yeah, Match. Doing a reclaim is weird. But what we'll do here is we're really just walking the nodes and what we're doing is.
02:00:10.615 - 02:01:13.905, Speaker A: Or what this is doing rather, is constructing, taking the existing linked list that we stole, right? So we own that whole linked list and splitting it into one linked list for the ones that are now reclaimable and one linked list for the ones that are no longer or the ones that are not yet reclaimable. So the ones that sort of need to be put back, which is sort of the same as what we used to do as well, right. We. We notice the stolen retired head, which is a great name for a variable. Although here what we're doing is we're actually deallocating sort of on the fly, right? Like they collect them first and then call reclaim unprotected, which maybe is nicer. It does mean that this doesn't have to. This doesn't get indented quite as deep.
02:01:13.905 - 02:03:00.913, Speaker A: So maybe we should do that and say like reclaimable and unreclaimable. And then for each one we say, so this is no longer guarded, guarded, safe to reclaim. And so for this one, what we'll do is stick it onto not remaining, but onto reclaimable. And why do they keep the count as they go, I wonder? I guess they return the number of things that were reclaimed. That's fine. So we can do reclaimed plus equals one. And then this business, the bit that actually reclaims the nodes, this we can then do later on.
02:03:00.913 - 02:04:04.773, Speaker A: So this is a little bit nice in that we can sort of separate finding them and actually reclaiming them. So then here we're going to store remaining. We also store the unreclaimed tail. Unreclaimed. And I think I'm going to do just to keep them a little bit consistent. Oh, unreclaimable. Unrelaimable.
02:04:04.773 - 02:04:42.147, Speaker A: That's. It's a terrible variable name. I apologize. Sort nodes into those that can be reclaimed, those that are still guarded. Guarded. Right. So that's now that loop, which is basically this loop.
02:04:42.147 - 02:05:14.641, Speaker A: And then it calls reclaim unprotected here. Reclaim unprotected on reclaimable. And that's going to probably be self dot reclaim unprotected. And then it says done. It sets done to. So done actually is set up here. Right.
02:05:14.641 - 02:05:59.889, Speaker A: So at the. At the top of the loop it sets let done is true. And then down here it says done is set equal to untagged dot is empty. But this, see, this is where you get into real funkiness. Right where I hate implicit this, because that's what's happening here. Untagged underscore is the variable in the class here in the C stuff. It's not this untagged.
02:05:59.889 - 02:06:41.073, Speaker A: It is. It is this untagged. And calling the empty method on it, which is just awful. So done here is actually set to self dot retire, which is untagged dot like is empty, which I guess that is a helper method. We can add. That seems pretty reasonable. Which is pubfn is empty or fn.
02:06:41.073 - 02:07:26.633, Speaker A: It's fine. Turns a bool and it is self head. And I guess we can go over to this one. Empty head returns head, which is a relaxed load head dot load ordering relaxed is null. So done is true. Is set to true, but it defaults to true. When would it ever be set to fall? Oh, I see.
02:07:26.633 - 02:07:51.339, Speaker A: If it's not empty, then done will be set to false. That's really what's happening. Countremoveschildren count. We're not dealing with children. Splice children. That sound that reads real awkward match are all the ones that weren't retired. So it pushes those back.
02:07:51.339 - 02:08:49.343, Speaker A: Right. So this is the unreclaimable ones need to be stuck back onto untagged. Right. Which I think we already had code for doing down somewhere. Just gonna go ahead and delete some of this bulk, look up and reclaim. Yeah, is down. Right.
02:08:49.343 - 02:09:28.241, Speaker A: So here is where they push back onto. We push it back onto the head. So this is where it gets a little awkward, which is self.untagged. push. And we really here want to be able to pass it unreclaimed. So, like, if unreclaimed, actually we can just do this. Right.
02:09:28.241 - 02:10:39.005, Speaker A: So this is actually where fn push. This really does need to take a, I guess, mute of retired. And did we care about this returning the. I don't think we do. Which means that it doesn't need to count. So I think actually this has to be sub. It has to take the sub list tail, which is like, it's unfortunate, right? Because here.
02:10:39.005 - 02:11:01.693, Speaker A: Yeah. It's sort of the same thing they're doing. Right. Which is if you want to push onto a linked list, you need the head and tail of the sub list you're inserting. Because the tail needs to point to the old head, but the head needs to point to the new. The old head needs to point to the new head. And so that's really what we're saying here is that it's sort of a.
02:11:01.693 - 02:12:20.827, Speaker A: In order to push this, you need both ends of the list, which means that this now no longer needs to do that or this. It is going to be unsafe though, because we're going to be trying to dereference this, which is up to the caller to sort of assure us is safe. So this is going to be sub tail. No sub list tail.next.store. so arguably, I. I really feel like this count is starting to feel like it needs to move out of retired list. So I think we're gonna move that up to here and then anywhere that says self.retiredself.retired.
02:12:20.827 - 02:12:56.407, Speaker A: count is going to have to change to not be that and instead just read directly from count. I think that's just more. It's a more accurate representation of what's really going on. Which means that this count needs to not happen here. And then in the place where we call push list, it needs to change the count, which is, I think, the same. Same thing. This is like we're going.
02:12:56.407 - 02:13:36.899, Speaker A: Gone full circle. Right. The C code is also doing the count outside of the actual P. And this is now going to be a little weird because retired is going to be box into raw retired and then we're going to pass retired retired unsafely. Yep. And so it's certainly true now that this has to be. These have to both.
02:13:36.899 - 02:14:10.985, Speaker A: Both be const. I think. Yeah. And now here. This now becomes unreclaimed and unre. Unreclaimable. And unreclaimable tail.
02:14:10.985 - 02:14:41.239, Speaker A: And I think we can do this and have it be right. Because we're. We're pushing onto the head, which means the first thing we push is the tail. So that's why this is. If it's null, then set it. Otherwise don't set it. So this means we now have unreclaimed and unreclaimed tail.
02:14:41.239 - 02:15:21.037, Speaker A: We could tighten this up a little bit. The same with the C code had done of having like a new type wrapper around a linked list that rep. That holds the head and the tail. So this is going to be pushing those. And then I'm guessing we're also going to have to update. I'm a little surprised that this doesn't have to update the count. Yes.
02:15:21.037 - 02:15:52.835, Speaker A: See? Reclaimed. I don't understand why my rust analyzer is being. Ooh, maybe this is throwing it off. Almost certainly that's because. Okay, let's get rid of the things that are no longer real. Things like all the. All the things that we saw them delete in the.
02:15:52.835 - 02:16:40.005, Speaker A: In the commit before. And where is my bad closing brace? I think it's up here somewhere. It's not there. It's here. Well, I still have. I'm doing something bad somewhere. This one can go away.
02:16:40.005 - 02:17:35.202, Speaker A: That's fine. So it calls reclaim unprotected on those it decrements account by children which we don't care about. It pushes back on those which we're doing here. Yeah, there is. Ah, this is on. Should be on retired list unre. I really want this to be unreclaimable.
02:17:35.202 - 02:18:29.635, Speaker A: To be unreclaimed because that's what I keep typing everywhere. And then this is going to be reclaim unprotected. And then it returns count. So up in the parent which is what we're still inside of here. Our count. Our count minus equals the count that remains. So this returns count, which is the one.
02:18:29.635 - 02:19:22.305, Speaker A: The number of things that were reclaimed. All right, so this is minus equal the number of things that were reclaimed. Reclaimed and reclaimed. But actually in reclaimable, that's fine. Actually, let's just make this a. An eye size as well. That's fine.
02:19:22.305 - 02:20:26.807, Speaker A: Okay, so to explain my reasoning for the names, Reclaimable is a linked list of retired objects that can be reclaimed, but they haven't been reclaimed yet. Unreclaimed are retire retired objects that were not reclaimed and cannot be. So they are unreclaimed. Unreclaimed tail is the tail of the linked list of unreclaimed things. In reclaimable is the number of things in reclaimable and N unreclaimed is the number of things in unreclaimed. So the names are very intentional and hopefully sensical, but they're complicated words, which is unfortunate. Okay, so let's leave reclaim unprotected for a little bit, because I want to finish the structure of this one, which is we're still inside of.
02:20:26.807 - 02:21:09.033, Speaker A: So at the end of this, if it's. If our count not equal to zero, then add count rcount. I see. So this is where it ends up getting added back. And then our count equals self dot check count threshold. So this is like. It's a loop where when do you ever break? If arc.
02:21:09.033 - 02:21:41.715, Speaker A: If our count equals zero and done, then you get to break. All right. Okay. So I think the idea here is you only enter do reclamation if there's an indication that you should be reclaiming. There could be multiple threads that enter do reclamation that it's not an exclusive lock. It's just you should only enter there if it's somewhat reasonable that you will have to reclaim things. Once you enter, you're going to loop until it doesn't look like there's anything more to reclaim.
02:21:41.715 - 02:22:14.395, Speaker A: So that means. That means there's nothing that can be reclaimed. And there's no indication that you should try again. Like you should retry. So that's why we recheck this count threshold and we only exit if there's no indication that we should reclaim again and there is nothing that can be reclaimed. Great. And then down here, it does a decrement of n bulk reclaims.
02:22:14.395 - 02:23:26.687, Speaker A: It's a little weird to me that the increment happens outside the function, but the decrement happens inside the function. But very well that it is what it is. And AD count is doing release, which is interesting. Okay, so now we're gonna need this reclaim unprotected, which in this case takes just the head and the children. It takes the children and it takes just the head, which is a star mute. Retired. Yeah, yeah, yeah, yeah, Retired.
02:23:26.687 - 02:24:01.065, Speaker A: I get it. And it says while retired. So that's. While retired is not null. Next is retired dot next. And I. I believe that next here is going to have to open that up in another file because there are too many files.
02:24:01.065 - 02:25:43.905, Speaker A: So that's going to be has pointer object, which has a next method, which is a relaxed load, and then it calls reclaim. So the actual reclamation. I deleted that code, didn't I? Come back to me code. That is this code right here. So this is going to be unsafe dereference of that and this is definitely unsafe safety. All retired nodes in retired in retired are unaliased throughout. Yeah, our unaliased and owned be taken ownership of.
02:25:43.905 - 02:26:36.035, Speaker A: Yeah, I didn't want to go through git checkout P because you have to. It's more annoying to skip. And also I have the file open. So here this is really a safety comment for the call to reclaim unprotected. So safety. Every item in reclaimable, or rather no item in reclaimable has a hazard pointer guarding it. So we have the only remaining pointer to each item.
02:26:36.035 - 02:28:17.185, Speaker A: So therefore we can call this unsafe are valid, unaliased, and can be taken ownership of. So safety here is really like one, this is sort of the important one. But two, every retired was originally constructed from a box and is thus valid. And I guess there's also like three, none of these retired have been dropped previously and dropped previously because we atomically stole the entire sub list from self untagged. And what else do they do? Yeah, they just call reclaim. Yep. Great.
02:28:17.185 - 02:28:33.785, Speaker A: I do like this restructuring. I think it. I think it makes the code nicer to read and I think. I think that's the whole loop. Right. Check threshold and reclaim. They made this change, but this we've already picked up on.
02:28:33.785 - 02:29:16.095, Speaker A: So lookup and reclaim goes away. So if I run cargo check, what do we have left? A decent amount. Okay, so 434. This should be sub list head. Okay, fine. It doesn't return anything anymore. Reached threshold.
02:29:16.095 - 02:29:54.905, Speaker A: So I think this is going to become due time. I think this is going to become untagged. I think count is going to go away from there and just become a basic item. I think sync time is going to go away probably. This is now just count. This is now just count. This is now just count do reclamation.
02:29:54.905 - 02:30:37.815, Speaker A: This should be untagged. Oh, thank you. Type annotation needed. Why? I don't want to give it a type annotation. It should be needed. So I think check. I think this method is no longer called so that can go away.
02:30:37.815 - 02:31:33.685, Speaker A: I think this method and it's no longer called so that can go away. I think this method is no longer called so so we can go away. I think this is no longer called so it can go away. Eager reclaim. So this is the method we had mostly just sort of for helpers, which is if you want to do a reclamation now, you don't want to put it off until the next time it's due or something. And that one's pretty easy for us now because that one can just be this now. I Think the question is, what is Reclamations here? I think actually what this will be is this.
02:31:33.685 - 02:32:56.197, Speaker A: Let our count is self count dot swap with zero self do reclamations. And now the question is, can we find a way for this to tell us how many items were actually reclaimed? And I think we can. I think the way we'll do this is total reclaimed is zero. This is going to return like a view size or something, right? And here we're going to do total reclaimed plus equals N N reclaimable. And then here this is going to return total reclaimed as us. Actually we're just going to have here as us. So now Eager Reclaim is just going to whatever the count is, it's going to just try to take all of them.
02:32:56.197 - 02:33:25.037, Speaker A: Then it's going to start a bulk reclaim starting from that number and then it's going to call Do Reclamations. So lookup and reclaim went away. What else do we have now? What's it going to complain about? It's not too bad. 2, 3, 2. It still wants type annotations here. That's fine. We can deal with that in a second.
02:33:25.037 - 02:33:47.619, Speaker A: 3, 3, 1. So on drop, this is the destructor for domain. And those we got rid of. That's fine. Those we got rid of. That's fine. Sync Sync time went away.
02:33:47.619 - 02:34:18.665, Speaker A: That's fine. Push retired is now just push list. That's fine. Highest pointer object. That's also fine. I think Drop, though, we do need to deal with. So that calls reclaim all objects.
02:34:18.665 - 02:34:58.287, Speaker A: Seems great. Let's structure this the same way they structured their destructor, which is there's a shutdown field now apparently shutdown, which is an atomic Boolean. Do I already have Atomic Bool in here? I do. Nice. So shutdown is going to be Atomic Bool. New false. And then what we're going to do is in drop, we're going to self shutdown store.
02:34:58.287 - 02:35:39.395, Speaker A: True relaxed. And then we're going to call self dot reclaim all objects. And I think this is what Eager Reclaim is going to end up being as well. And self dot free pass pointer Rex. And I think this is going to mostly, mostly end up being what we already have. And then this debug will deal with in a second. So we're going to have a FN reclaim all objects.
02:35:39.395 - 02:36:31.313, Speaker A: And reclaim all objects who. That's interesting because this almost certainly assumes that you have exclusive access to Self. So we're gonna steal the head of Untagged. And I guess here, like Pop all is really what this is called. Right. So where's our Stolen head. So we could just have this be a.
02:36:31.313 - 02:37:32.365, Speaker A: Another helper here, which is pop all. And I guess really this could be like an option box, right? But I don't think we want that that because that would make it unsafe. So it's just going to be this and then stolen head is going to be self untagged. Pop all. And this can be the same now. And then it calls reclaim list transitive of head, which who knows what that does. Reclaim list transitive.
02:37:32.365 - 02:38:05.785, Speaker A: I'm just making these mute self for now. They might not need to be, but. But for now we'll. We'll keep them that way. And this is really the same as that loop we had above. Like this business. It grabs the choice children.
02:38:05.785 - 02:38:36.945, Speaker A: It grabs the children. Reclaim unconditional. Oh, I see. Because this is going to recurse into the children. That's a neat loop, actually. Like reclaim unconditional head, I'm going to assume, walks all the things from head to tail, pushing any children it finds into children. And then the head gets set to head of children, which means that you're going to do like scans by depth.
02:38:36.945 - 02:39:15.311, Speaker A: That's a really neat loop. I like that loop. In our case, we're actually just going to do self reclaim unconditional head. I think that's going to be like to do handle children. And then reclaim unconditional is going to be here and again, mute self. Mute head. And that one is just going to.
02:39:15.311 - 02:40:27.735, Speaker A: Yeah, exactly. So reclaim unconditional is the one that is basically the same as reclaim unprotected. In fact, how do they differ? Aren't these the same? I think these are the same. Reclaim unconditional and reclaim unprotected are the same. So self proclaim unprotected Head so unsafe. Self so unsafe Unsafe. What's the difference here? Also, why is this? Okay, because reclaim.
02:40:27.735 - 02:41:29.115, Speaker A: Notice that Reclaim unprotected. Oh, I see what's going on here. So this is tricky. I think. Here's what's going on. The observation is the same as what we used to have in Drop, which is there should be no hazard pointers active anymore. So all retired objects can be reclaimed.
02:41:29.115 - 02:42:37.015, Speaker A: Because that's true, you don't actually need to check the like, active guards and stuff, but in the Facebook implementation, they just sort of assume that that's true. Right. So notice that this just calls. It takes the entire retired list and it doesn't check guarded pointers at all because there should be no hazard pointers left. So the question is, what actually makes it so that that is the Case I think in C land, it's just the programmer knows not to keep a hazard pointer. Doesn't matter once the domain is dropped. In Rustland, the question is, can we do better? And I think the answer to that is yes, because the holders are tied to the lifetime of a domain.
02:42:37.015 - 02:43:26.335, Speaker A: So the moment the domain is dropped, there can't be hazard pointers to it. But for global, this gets weird because they're static. So the question is, how do you guarantee that the domain is dropped first? Sorry, the domain is dropped last. You guarantee that because they're dropped in reverse order. So you create the domain first and then you create handles to it. So the handles will end up getting dropped first. The domain will get dropped last.
02:43:26.335 - 02:44:38.847, Speaker A: So it is indeed the case here that once you have exclusive reference to. Once you have exclusive reference to the domain, there cannot be any hazard pointers because the hazard pointers have shared references to the domain, which would preclude the existence of an exclusive reference. So I think therefore. So that's why reclaim unconditional is sort of the appropriate name, right? Because you call this to sort of say you call this only in the event where you don't care about the protection status. So maybe we should document why that's the case. So here certainly safety is at mute Self implies that there are no hazard pointers active. No active hazard pointers.
02:44:38.847 - 02:46:01.817, Speaker A: So all objects are safe to reclaim. So reclaim. This is just this word man. And this can remain unsafe. This one, I want to say equivalent to reclaim unprotected, but differs in name to clarify that it will remove indiscriminately. Right? So, okay, so I think the reason why this alias is here is because it would look weird for reclaim. Let's ignore reclaim list transitive here and sort of inline it in our heads into reclaim all objects.
02:46:01.817 - 02:47:06.025, Speaker A: If reclaim all objects called reclaim unprotected, that sort of gives the wrong implication here, right? Which is that, oh, we're only reclaiming the ones that aren't protected, but in fact we're reclaiming reclaiming unconditionally. And that just so happens to be the implementation of unprotected. Now, arguably this means that unprotected is the wrong name for that function, because that one is really just reclaim these and then it's up to the caller to indicate to check whether they're protected or not. So I think this is really a naming error in the name of reclaim unprotected, but I want to keep that name again so that refactorings later with respect to the Upstream code base are easier. And in that case. Okay, so shutdown doesn't need to be an atomic bool, it can just be a bool. I have a feeling it's not even necessary, but you know.
02:47:06.025 - 02:48:37.625, Speaker A: And then the other thing they call is free hazard pointer rex. So FN free has pointer rex itself. Oh, yeah. All right, where's my other typo in discriminately? Yes, I think this is the same. This one we can ignore. And this code is probably already right because it's really just walking the list of hazard pointers. But they have this special like if self is global, if self is shared domain.
02:48:37.625 - 02:49:53.695, Speaker A: Am I missing something here? I feel like that I'm probably not allowed to reference. Maybe it's never dropped. This is weird, right? Because we have a mutable reference to the domain because it's being dropped. What if. What if that mutable domain is in a static? Then we can still refer to the static in the drop, which should would be unsafe. So how is this legal? This suggests to me that it just would never be dropped or this would just be unsound. But there's no one safe here.
02:49:53.695 - 02:51:36.515, Speaker A: If this was unsafe, then like imagine that I wrote the following program. Static foo is equal to what's a constant? I mean, impul const of nu returns itself just returns X. This is an x foo of type x. And I impul drop for X drop mute self. Right? Like there's no unsafe code here. Yeah, fine. This is irrelevant to the explanation, but fine.
02:51:36.515 - 02:52:30.505, Speaker A: This compiles and there's no unsafe code there. But the existence of this exclusive reference implies that this shared reference shouldn't exist. There's no one safe. This seems all right. Cargo new test drops source main. There we go. It the.
02:52:30.505 - 02:53:25.357, Speaker A: I guess new doesn't really matter. So statics are never dropped is the reason why that's not unsound. Which means that we don't actually need to deal with the global domain being dropped because it never gets dropped. And that's why there's no in safety there. Okay, well, in that case, the drop here is kind of stupid, right? Like, this can just never happen. So I don't know how to. I think statics are just never dropped.
02:53:25.357 - 02:54:29.907, Speaker A: That's certainly what this implies, right? Like the drop for X here is never printed. So the question here is sort of skip for global domain, but global domain is never dropped as it's a static. Like, I don't. I don't think we need this check. I guess we could assert it, right? Like we could assert that there's like no way to assert it. Because if it. If we could assert it, then that implies the global could be dropped, which is false.
02:54:29.907 - 02:55:06.735, Speaker A: And if you're relying on assuming false, then anything can be true. So it's just like not. I don't think it's useful to even think about this. I folly skips this for the global domain. But the global domain is never dropped as it's a static. Yeah. Oh yeah.
02:55:06.735 - 02:56:18.445, Speaker A: Someone linked to the documentation and saying actually let me copy that real quick and go over here. Static items do not call drop at the end of the program skips this step for the global domain. But the global domain is never dropped in the first place as it is static. See this link? We have mute self. So no one holds any of our HASR pointers anymore as all holders are tied to domain which must have expired to create. And so here, I mean we could look at what their implementation does, but yeah, it just walks. It asserts that they're not active.
02:56:18.445 - 02:56:37.405, Speaker A: This is a debug check for them. So it's a debug assert. That's fine. And then they drop the N. That's fine. That seems totally reasonable. And like it's about the same.
02:56:37.405 - 02:57:17.015, Speaker A: And then the other thing they do is they check not tagged empty. That's fine. We don't support tags, so that's easy enough. What else we got here? Actually I think we were trying to get this to compile. Now it's only the type annotation that's needed here. Why does it need the type annotation? I guess I can just say unreclaimed and then it realizes that they're the same. The number unreclaimed is not relevant.
02:57:17.015 - 02:58:24.675, Speaker A: That's fine. This should definitely not require MU itself. 132. Why is this unsafe? I don't think this needs to be unsafe. Although I do think that maybe. No, that's fine. All right, what else we got? 339.
02:58:24.675 - 02:59:01.205, Speaker A: That's fine. This is unsafe because that's unsafe. That's fine. 135. Does this even need to be pub crate? I don't think it's. Does. 289 unused variable.
02:59:01.205 - 02:59:34.535, Speaker A: Oh, that's. Thank you, Rust. That would have. That would have come back to bite us. Does cargo test work? No, it's seg faults. Great. All right, what else we got here? Any other changes that were missing? No, I don't think so.
02:59:34.535 - 03:00:13.915, Speaker A: All right. But something somewhere is causing us to poo poo and be sad. So the question is What I want just. I want only to run. Feels good. That's great. All right, let's see what we got here.
03:00:13.915 - 03:01:11.025, Speaker A: We're going to go ahead and GDB this GDB run. Why run with. I don't even care about no capture, I think. But I do care about Feels good. Oh, I forget what the GDB add. Add to path. Source path.
03:01:11.025 - 03:01:54.895, Speaker A: There is a search path somewhere. Oh, the question about unreclaimed, it's still set to null, right? It's just that by doing this, I'm indicating to the compiler that they're the same type. So whatever you. Whatever the compiler infers this type to be, this should be the same type, but it's still initialized to null. What is the. Yes, that's fine. Yeah, that's fine.
03:01:54.895 - 03:02:47.455, Speaker A: Where is the. No, no, standard library. I had this in my history at some point and now I've forgotten what the. All right, let's see if Google does better at searching. There we go. This thing is what I want, except it has to be not this, but this, which is like the particular commit of the release. And this is going to be this, which is home.
03:02:47.455 - 03:03:35.725, Speaker A: John. That if I now do backtrace, I'll get backtraces into the standard library as well. Nice. All right, give me that backtrace again. We're failing in retired when we're pushing to the retired list. Oh, yeah, Okay, I know what this is here. If sub list head is null turn, pushing an empty list is easy.
03:03:35.725 - 03:04:33.975, Speaker A: Hey, fantastic. All right, so this is then the full restructuring associated with that command with that commit, I mean, follow upstream in switching all to untagged. This again. And I think now we're most. I think that was like the biggest one of them. Right? So if we go back here, one thing I do want to do is this. And say this is the relevant commitment.
03:04:33.975 - 03:04:55.485, Speaker A: Sweet. All right, so we have this commit. Well, let's move on to the next one. This one is minor, I think. Which is it shards. The untagged list, which I think we can do pretty easily. So it keeps num shards, which I think is just a constant.
03:04:55.485 - 03:05:51.715, Speaker A: So as a num shards of type probably use size is this value, which is 8, and then untagged is now actually multiple untagged. I'm using the wrong syntax because that's what I like to do. Great. And then we're going to need calc shard somewhere down here. Probably down here. I feel like realistically we should probably reorder these functions as well. Calc shard of self and it might not even need.
03:05:51.715 - 03:06:41.161, Speaker A: Actually it just takes a tag, but. Oh, it uses the head pointer as the tag. I see. So the input here is like a star mu to nothing. Or if you will, the input as a usize and it returns a usize. So really this is just. Okay, so it's a standard hash.
03:06:41.161 - 03:07:41.193, Speaker A: You say, what exactly is a standard hash? According to C implementation dependent. That's good. Well, we can always use just the hashmap hasher. Honestly, sip hasher is probably fine. We'll use default hasher. The reason I don't want to use default hasher is because it's cryptographically secure, which makes it slower. And also you need to.
03:07:41.193 - 03:08:25.801, Speaker A: Basically it's seeded with a random number every time you create a new one. Although I guess that means the hashing function would be different for each domain, which maybe is nice. So let's do this. Let's really. This should be a hash. No, what am I doing? So I think what we're going to do here is go to Cargo TOML dependencies. It's a little bit sad to have to include a hash as a dependency here.
03:08:25.801 - 03:09:01.805, Speaker A: It's nice for it to take no dependencies. I kind of don't want to do it. FNV is no better, right? In the sense of it's still. It's still a dependency. I'd rather not take a dependency is sort of what I mean. All right, fine. Well, we'll do it and we can always factor it out later.
03:09:01.805 - 03:10:21.765, Speaker A: I don't want to. The reason why it's tempting is because this hashing is like every time you retire an object, you're going to have to compute this hash. I thought there was a, a speed comparison where, like, it doesn't really matter if the keys are small. Where is the standard library hash? I think the standard library hash is. Oh, here. This is great. Like it's a fair bit faster.
03:10:21.765 - 03:11:04.375, Speaker A: Okay, so the thing is we could. The point is whether we use a hash or FNB isn't that important. It's whether we take a dependency or not that I care about. I like a hash as a crate. We could take a user supplied hasher. It feels it's sort of an implementation detail of the library that we're doing hashing in the first place. Right.
03:11:04.375 - 03:11:51.075, Speaker A: It would be a generic parameter that I don't think any user will ever set. Or to phrase this slightly differently, I would like this change that we're about to make to not be a breaking change. Right. You need a hash for the global Domain as well. I don't think that's a problem. Oh, it's constructor needs to be const, which I'm assuming a new is not. No, not a hash map.
03:11:51.075 - 03:12:17.705, Speaker A: A hasher. Yeah, it's definitely default. Is not const. I mean, it does have const with seeds. So we could create a random state and then just set the seeds. Because we don't actually care about sort of cryptographic randomness here. Right.
03:12:17.705 - 03:13:27.435, Speaker A: Like what we're hashing is pointer values. I guess eventually we're hashing tags. It's definitely tempting to just construct a hasher with like static key material here because all that matters is that the values end up neatly distributed, which shouldn't depend on the seed of the hash. Is. I think A has fallbacks. No. Yeah, it uses AES on x86, but it doesn't require x86.
03:13:27.435 - 03:14:16.285, Speaker A: All right, so in that case, I think what I want is this and I think what I want here. Well, at that point, actually we don't even need to store the hasher. We can just construct one in here because it's const. So this can be a const fn and then this can be a hash random state from seeds. And let's make this 1, 2, 3 and 4, because those are. Those are random numbers. I'll roll a die later, it'll be fine.
03:14:16.285 - 03:15:07.155, Speaker A: And then it's that. And then we're gonna. So this is the hasher. And then we're going to hasher dot hash input or it's input dot hash mute hasher and then hasher dot finish. And then it ignored low bits. It's fine. So we're going to have a const ignored low bits usize or U8 for that matter.
03:15:07.155 - 03:16:18.845, Speaker A: It doesn't really matter. Ignored low bits with k shard mask. Const. Shard mask is num shards minus one also use size. This is going to be. This ended with shard mask, is it not? From seed. Did I misread that? Oh, with seeds, a hash random state implements hasher.
03:16:18.845 - 03:17:32.315, Speaker A: Oh, it's a build hasher. It implements build hasher but not hasher. So I'm going to have to construct one of these. But that one doesn't have constant. It really feels like there isn't a const way to do this, which makes me real sad. So part of the problem we're running into is that for the global domain we need a hasher for the global domain. The global domain is static, which means that we need a const hasher.
03:17:32.315 - 03:18:03.085, Speaker A: We could make One with lacy static. Right. Like there is a way around that. The. The other way to do this is just this, which. Which is maybe nicer. Right.
03:18:03.085 - 03:18:42.059, Speaker A: I think that's fine. Honestly. I'm gonna go with that for now. It just means that we're gonna. It means we don't take into account really the full information from the higher bits. The low bits we do have to ignore because the. Otherwise the shard mask is going to take out the lower numbers and the lower numbers are generally going to just be the same because they're.
03:18:42.059 - 03:19:34.675, Speaker A: They depend on the alignment of the allocated objects. So this is going to take sort of the high bits and then it's going to take just out the shard mask of the high bits and it's not going to take very many bits from there. Cuz we're not sharding that many ways. I honestly I think this is fine. I think this is fine for now. I think we're going to stick with this. And then because we don't support tags yet anyway, I think what we'll do is say that we're only going to support the star mute retired and then we're going to do this as us.
03:19:34.675 - 03:20:42.719, Speaker A: I think that's what I want to do. That's what I want to do. It's definitely a little like awkward, but it's fine. And then this is going to be up in push list. So push list is going to do here self calc shard of retired and like in theory here we could use like get unchecked or something because we know that this already takes a modulo of the number of shards. But I think the optimizer might be able to realize that that is the case here and then extract retired objects. Right.
03:20:42.719 - 03:22:13.517, Speaker A: So that one now has to change. So this is the bit where we here do the pop all where remember how there was this like match or extract retired where. Which splits it into the ones that can be retired and the ones that can't. And the ones that can be retired is just everything and untagged. Well that's now not quite as simple because we need to steal from all of them, not just from one. So I think what we'll do is this is going to be null mute num shards and then for I in numshards we're going to set stolen head of I is self untagged I pop all and then we're going to set let mute empty as false or empty is true. If stolen head I if not that then empty is false.
03:22:13.517 - 03:23:11.785, Speaker A: No empty Is yes. Then empty is false. If not empty, then we do that. What else do they change here? Right? This now just walks. It has to walk the shards for the inner loop. It's interesting because you could probably do better here by having by sticking them all into one list and then walking that one list. This is sort of a naive reinterpretation here, right? Like you could imagine that you instead just merge the match and no match lists first in the for loop and then you call reclaim unprotected on the merged no match.
03:23:11.785 - 03:23:50.079, Speaker A: Which I think would be an optimization here. But let's I guess not do that. That's fine. So this is then just. Do we want to split this out to a function maybe let's do that. So they call this match reclaim untagged. I hate the name of this method.
03:23:50.079 - 03:25:09.009, Speaker A: But fine. We're going to pass that stolen head. Stolen heads which is going to be a star mute retired num shards. What am I doing? That doesn't work. And is that how I want to do it? Yeah, it's like real. So it is true. The fact that we're not hashing in quite nicely means that some shards may get larger than others.
03:25:09.009 - 03:26:25.705, Speaker A: It's still better than everything being in one shard, which is how it was previously. And I'm guessing that just using pointer values, you're probably going to get pretty far. You're going to get a decently even distribution unless all of your objects are very large. So the alignment ends up going over. This is such a ugly piece of ugly piece of code. So I think what's going to happen here is I guess this whole thing goes in there. This does for I in zero to numshards does this right? This is basically the same refactor they did here.
03:26:25.705 - 03:27:46.355, Speaker A: They return a bool for whether they're done which they set to true. That's fine. Done, I guess. And then take in the guarded guarded pointers, which is the hash set of retired. So it takes stolen heads and guarded pointers. Is that not what I. Oh, this should be stolen heads and this should be guarded pointers.
03:27:46.355 - 03:28:37.525, Speaker A: I. I guess realistically it could just be passing ownership of the set, but it doesn't really matter. Start mute U8. That's fine. And what else? Actually I guess most of this is going to end up inside of there. Right? So they pushing back onto untagged and reclaiming unprotected both happen inside of there and so does setting done. So these all happen inside of here.
03:28:37.525 - 03:29:13.585, Speaker A: Except they do all as one untagged which makes a lot of sense. So they're setting these outside of the loop. And see, this is the optimization I'm talking about. But let's not do that one quite yet. So stolen heads. I'll explain in a second. Pointers.
03:29:13.585 - 03:29:54.435, Speaker A: So that sticks onto there. And then they reclaim unprotected inside of the loop. And they said done. Right. So this has to change to if not untagged, empty. This ends up being a nested loop, which I don't think they need. I think this goes outside the loop.
03:29:54.435 - 03:30:38.955, Speaker A: And I think they do. If. If self untagged iter any, then done is false, which I think just means that done is this. So this is. We have to check. Okay. So this is.
03:30:38.955 - 03:31:15.025, Speaker A: We're. We're not done. If there are untagged items after we've reclaimed everything we can and before we've pushed back the ones we couldn't reclaim. And it's important they happen in this order because otherwise the fact that we push the ones that can't be reclaimed yet would mean that this might be set to false, even though you can't actually do any work. So this order is important. They push. They push all the items that can't be reclaimed onto Shard 0.
03:31:15.025 - 03:31:50.075, Speaker A: Because let's not reshard them or anything. That's fine. I guess that's wild. We're not reshard. We're not respecting sharding here. Presumably to avoid multiple push casses, which would decrease performance. That's wild.
03:31:50.075 - 03:32:36.079, Speaker A: What I was going to suggest was that we do reclaimable up here too. And we call reclaim unprotected on all of them at the end too. Because why not? I'm going to leave that as an. This can probably also be hoisted out of the loop. And we can do reclaim unprofit. Do a single reclaim unprotected call as well. Facebook code doesn't do that.
03:32:36.079 - 03:33:06.545, Speaker A: Right. Like they call reclaim unprotected inside of the loop. I don't know why. This also just seems wrong to me because why do you have to check as you go rather than once at the end? I think that's wrong. Or I don't think it's wrong. I think it's less efficient than it could be. Um, this one I'm less sure about because there might be some subtlety I'm not picking up on, but I doubt it.
03:33:06.545 - 03:33:33.075, Speaker A: Okay. And do reclamation also needs to change. So this needs to be this for num. Shards. Shards. It's fine. And this.
03:33:33.075 - 03:35:30.635, Speaker A: Right. Match reclaim untagged also returns the count. So it returns usize and whether it's done and the use size is number of reclaimable or unreclaimed, if you will. And then this will be here reclaimed and reclaimed and reclaimed final be an eye size. Can it be a use instead? Nice. And then this is going to be now what count is that? What it gets assigned to up here where we call match. Where's the place we call match? I think it ends up being R count.
03:35:30.635 - 03:36:31.385, Speaker A: So this is N reclaimed and done. And then our count is minus equals and reclaimed total reclaimed is plus equals that. And this has to be is done and then done equals is done. Because otherwise we'd be declaring a new variable whose name is done that shadows the previous one and we wouldn't be overriding the done from up here. There's a like a cool thing that's landing soon, I think where you can do this, but for now we're gonna have to do that. Okay. Where else is complaining do reclamation? I don't think we need to change anything.
03:36:31.385 - 03:37:06.807, Speaker A: Oh, right. That's the same thing we already changed. That's fine. This just needs to loop over all the shards. So that's fine. 394 pointers cannot be cast to integers during const eval. That's fine.
03:37:06.807 - 03:38:02.765, Speaker A: It doesn't need to be const anymore. Retired list copy is not satisfied. That's fine. Because there's a new cool thing where if you have a constant constructor, then you can do it. I forget exactly how this works. Let's see. Like I think if I do this and then do retard list new.
03:38:02.765 - 03:39:22.948, Speaker A: I think it lets me do it. I thought that was what it did. I thought this landed in like 154 or something where maybe it's just you can't use this syntax. I'm pretty sure that you are allowed to do this now. I just can't remember the syntax, which is pretty annoying. I don't really want to make retard list copy because it shouldn't be time to go to the Rust blog and look back at 153, 152. Sorry that these are bright.
03:39:22.948 - 03:40:24.785, Speaker A: No, 151. It was like an accidental stabilization previously const value repetition for a race. I knew it was there somewhere. Petition has only been allowed for X or copy sought to allow any const expression there. However, while the feature was enabled for arbiter const values. Ah. So the way you have to do it is const retired list is retired list new and then here retired list.
03:40:24.785 - 03:41:01.275, Speaker A: Yeah and this is going to be retired list. And then it works. But you have to. It's wild, but that works. You shouldn't need try into here. I don't want try into because I don't want to have to write unwrap because I know that this is the right size. But you can do it this way, by telling the compiler that this retired list is a constant value, it's evaluatable at compile time, and then using the constant value here, and then the compiler is happy.
03:41:01.275 - 03:41:33.085, Speaker A: Well, one day we'll be able to move that into there. But what I'll do is put a link to this. I mean, I'll put it in chat, but I'll also put it here. Great. What else is it complaining about? Ooh, well, something's about to crash, but that's fine. 261 done is unused. That sounds like a problem.
03:41:33.085 - 03:42:24.715, Speaker A: That's because now it's computed at the end, so that part's fine. Ooh, but it spins forever. I mean, it could be that my optimization was premature, like. All right, let's stick it where they want it. They want it right after the call to reclaim unprotected. So here it's. If any is not empty, then done equals false.
03:42:24.715 - 03:43:20.565, Speaker A: What? I do not believe that that's necessary. I cannot done is all is empty. There's a negation missing. Okay, good. Great, great. Ah. Okay, so this is Shard, the retired, untagged, retired list man.
03:43:20.565 - 03:43:58.525, Speaker A: And there we're going to link to this one because that's the commit we just did. That one's done. We only have two more commits and then maybe we'll actually be able to test this thing, which would be nice. Rearrange Invoking Asynchronous Reclamation and Executor. That's fine. We don't support executors. Hey, that was one cheap commit.
03:43:58.525 - 03:46:23.755, Speaker A: What do we got here? Optimize the management of available hazard printers in the domain that are not in thread caches by adding a linked list of available hazard pointers with a lock bit packed with the pointer to the head of the list. What is the actual modification here? Try. Pop available. Try to lock available list. Why is this better? I'm still trying to figure out what it does it. Oh, I see. I think what it's doing is currently we keep a list of all the hazard pointers, but there's just one list that is all of them.
03:46:23.755 - 03:47:11.305, Speaker A: So the problem, if you want an available one, like one that's not being used. See if I can Find where this code is. Where is the old acquire, not acquire new. Yeah. So this method, Try acquire existing HP wreck. So it used to be, if we were just looking at the red lines, it used to be that it got the head, it kept walking the next until it find one that it was able to acquire by virtue of its acquired bit being set to false. And then it returned that wreck.
03:47:11.305 - 03:48:12.101, Speaker A: Although I thought Try Acquire removed it from the list, but is that wrong? Existing Try Acquire. Existing Try Acquire. Yeah, so Try Acquire just sets active to true with a compare and swap. So what this is doing is it's keeping a. It's specifically keeping a separate list of active ones. So there's the hazard pointers list, but there's also the like available hazard pointers list, which I think is just pointers into this list. So it almost becomes like a skip list, but where you can skip to the next one that's available.
03:48:12.101 - 03:48:55.815, Speaker A: Right. So it's not. It like lets you move, lets you seek directly to one that is active. Yeah. So it starts out being null and to acquire one, try pop available HP Rex. Right. So let's assume this is one.
03:48:55.815 - 03:49:57.165, Speaker A: Oh, it probably allocates them in batches too. Yeah. So you create one and then. Yeah, and then you stick them all onto the available list, which basically becomes a linked list of. It becomes. You're basically keeping two linked lists over the same set of objects and now this freeing. Why does it not.
03:49:57.165 - 03:50:28.625, Speaker A: I wonder why they removed the debug check here. It seems odd. Yeah. So trying to pop an available one is you load the head of the available list. If the head of the available list is null, then you go, I failed. I couldn't pop one that was available. Otherwise you try to lock the available list.
03:50:28.625 - 03:50:51.693, Speaker A: If you fail to lock it, you retry. If you succeed at locking the list, then you, you remove the. How the first. How many? However many you need. Let's say you only need one. Right. Then you would just remove the head of the list.
03:50:51.693 - 03:51:27.087, Speaker A: You would set the head to be the head of the tail and then you release the lock. Yeah. So that's this bit. Right. So you take. Yeah. So you, you.
03:51:27.087 - 03:51:46.115, Speaker A: You need to. If you're moving past n items, then you just walk. You need to find the. The head after an item. So that's what this loop does. And then it stores that as the new head of available. It sets the next of the tail to be null so that you don't.
03:51:46.115 - 03:52:05.555, Speaker A: You unlink the chain that you're removing and then you return the. You return the number of items you successfully stole. Right. So it might be. You might tell it. I want. I want eight hazard pointers and there are only five in the available list.
03:52:05.555 - 03:52:44.955, Speaker A: So it goes here or five. So you might still need to push more. And this is just a push for another linked list which has to take the lock into account. That makes sense. In fact, pushing. Right. For pushing, you just do a compare and swap on the head and they store the lock bit in the pointer itself to the head.
03:52:44.955 - 03:53:52.859, Speaker A: So the cast would fail if someone took the lock. And the cast would also fail if someone took the head. Like took the lock, took the head, release the lock. In either case, the cast would fail. D Check connected. And this seems to just be a debug check that I think this debug check is just to see that the. Oh, it just checks that the head is connected to the tail through the next step.
03:53:52.859 - 03:54:12.839, Speaker A: Available pointers. That's fine. We don't really care about that. And then the hazard printer holder. This seems like an entirely unnecessary change. This calls acquire HP Rex1. That makes sense.
03:54:12.839 - 03:54:51.703, Speaker A: Why did they even make this? So that it could acquire multiple. They did that for array. So this is. Imagine that you're writing a data structure where you know that you have to guard multiple pointers in order to make progress. So really you need to allocate multiple hazard pointers. Well, if you want to allocate multiple hazard pointers, allocating them one by one is a little sad because each one has to be added to this like linked list and now to multiple linked list. So if you can just grab multiple at once, then yay, you, you've amortized the cost of those pushes and potentially pops and allocations.
03:54:51.703 - 03:55:39.935, Speaker A: And that's what the hazard pointer array bit is doing, which we never implemented. But that's what it's for. I think it's probably fine for us to implement the available stuff for supporting multiple allocation and then we just only use the single one for now. So that if someone does want to like submit a PR that adds support for erase later, that would be pretty easy. And they've augmented the hazard pointer records so that they now both have a next pointer which is sort of the next pointer in the main linked list of hazard pointers. And that will never change. Right? Because that's just a list that you only ever keep appending to the head of.
03:55:39.935 - 03:56:13.365, Speaker A: And the only time it changes is when you deallocate all of them at the end of the domain. But next available is sort of this skip list that we're Drawing over the linked list itself. That's cool. I like that. And now. Oh, and now active. They removed the active flag because you no longer need it.
03:56:13.365 - 03:57:01.885, Speaker A: You no longer need it because all of the ones that aren't active are in the available list. That's cool. Thread Locals, we don't support, so we don't really care about those. They change the test a little, but that's fine. All right, this looks like a fairly straightforward and fun optimization to implement, and it certainly seems like it matters a lot. Okay, yeah, let's do it. I'm going to take a quick break to get more tea and a little bit of a bio break, but let's say we continue in like 5ish minutes, maybe a little less.
03:57:01.885 - 04:01:21.941, Speaker A: So I'll be back in a second. Talk amongst yourselves. I'll link this commit so you can all look at it in case you want to. So. All right, see you on the other side. All right, I'm back. Today I want to do mainly tests, but let's port these commits first.
04:01:21.941 - 04:01:55.345, Speaker A: Yeah, you're right. Although, like, I think this was still worthwhile because I know that there's a folly hazard test suite. It's not very large but or specifically for hazard pointers. And I have it open in a tab here somewhere. It's over here. I have the file and this test suite I'd like us to port. I would also like us to write tests with loom and.
04:01:55.345 - 04:02:30.255, Speaker A: But that's neither here nor there. But for this test file, this one is written with the latest code in mind. And I would worry not just about bugs that we haven't caught, but also that the tests might be relying on behavior that was only implemented since last time, which would make me a little sad. And also it just seems like the right thing to do. And also it lets me page everything back in. But you are right, we didn't. We haven't done tests yet.
04:02:30.255 - 04:02:58.915, Speaker A: I'm still hoping that we'll be able to do tests. I have faith. But you are right that I kind of lied. I mean, we could just not do this thing right. But I'm like, there's one commit left. We should kind of just do it. It was committed four days ago, so really, if I'd streamed like a week ago, we wouldn't have this commit to catch up on.
04:02:58.915 - 04:03:25.365, Speaker A: All right. But the improvement seems pretty. Pretty significant. But yeah, you're right, it is quite the rabbit hole. All right. All right, so we're going to go with const lock bit usize. It's going to be one solid lock bit right there.
04:03:25.365 - 04:04:32.325, Speaker A: And now we're going to have has pointers. I'm going to model this a little bit different than they do, which is I'm going to have head and I'm going to have available head. This is going to be available next. I think that's the way I want to structure it. You're right. We might end up just rebasing every time when you do stream. Like we have to catch up first.
04:04:32.325 - 04:04:56.695, Speaker A: We never get to actually write the tests you write. Although in my own defense, since last time I've been working on finishing the book, which is now finished. So in theory there should be less time until the next stream. At least that's my hope. Right. So that's fine. Head available.
04:04:56.695 - 04:05:25.995, Speaker A: That's fine. So the first thing we're going to have to do is the constructor. Constructor which is going to have to be head available. That's easy enough. System allocator. Yeah, I mean one day we'll be generic over allocators too. But that's.
04:05:25.995 - 04:06:19.555, Speaker A: We're not going to deal with that right now. This is just helpers for load and store acquire HP recs. All right, so we're gonna. This is the one that used to be HP Rec, which is this one. So that one has now been replaced. It's instead going to be acquire N. Hu.
04:06:19.555 - 04:07:52.805, Speaker A: What do we think of that? Is that bad? Is that good? It's kind of cool, right? I guess it's going to get specialized. It gets specialized to the one case and no bounce checks. Yeah, I like that. And I guess there's going to be a debug. Assert that N is greater than zero because, you know, so we're going to end up with let N and head is going to be try acquire available. This doesn't need to be called acquire end. It can just be acquire try acquire available.
04:07:52.805 - 04:09:47.893, Speaker A: So this one's going to be a little. How do I want to do this? I think what I want to do here is why does that have to be head? Do I care about that being head? Well, what I'm thinking here is what is the return type of try acquirer available? And I think think it's gonna be. I think it's gonna end up being something like option of this. Right. Really? It can return any M that's smaller than N. So it could return like a slice of them. Right.
04:09:47.893 - 04:11:23.067, Speaker A: It could return this, which is maybe nicer in the C1 actually returns a linked list. And I don't think it needs to. Ah, but they keep the. They keep them as a linked list so that they can all just be like stuck back onto the available list easy later. But that's fine. So in the thing that consumes this acquire, like let's look at array, which I guess is down here somewhere, it requires M. It uses the available pointers and then sets them to null, which I don't think it needs to.
04:11:23.067 - 04:13:16.985, Speaker A: I think we can relink them when we push them back, in which case, so we. I think I want this. It would be nice if I could express that this one is like at most N long, but I think that's fine. I think what we're going to do here is. Yeah, I think we can make this work. So here we're going to do assert that available len is less than or equal to n and then we're going to do for out is going to be the problem here is constructing this thing actually, because it is. I can use standard mem maybe unit new of has pointer record of n new maybe unit mem uninitialized is fine.
04:13:16.985 - 04:14:00.285, Speaker A: So what I'm going to do here is for rec in available.into Iter. It can't return that, can it? I think it has to be option, which is so dumb. I just really don't want this. Return a vector is the thing. Like it shouldn't need to. All right, fine, fine.
04:14:00.285 - 04:15:08.625, Speaker A: It'll return the head of one. Fine. I hate that. So return a pointer to the first one of a linked list. That's fine. So head and then N and then we're going to do for I in 0 to n out of n is maybe an init new of head. So the reason we need the maybe on init here is we need something to start the array as.
04:15:08.625 - 04:16:11.871, Speaker A: And then here I guess we're gonna set. We're gonna walk the linked list to throw them all in. This is where like you could sort of do this, right? To construct the linked list. But I think instead what I want here is can you collect into an array? Like is basically is from iterator implemented for array? Yeah, I didn't think so, sadly. And there isn't a try collect. Yeah. So then that sort of means we're basically.
04:16:11.871 - 04:17:11.625, Speaker A: We're basically implementing try collect for or try from Iterator or something for arrays here, but sort of manually. So we're going to do let. Next is. In fact, I think this is going to be a star mute to that. We're going to say next is unsafe head dot next. And this is going to be uns at head is unsafe. So the safety here is has pointer records are never deallocated.
04:17:11.625 - 04:18:04.445, Speaker A: So I guess this is going to be rec and then this is going to be head. So this has to be mutable. So head is rec. Next load relaxed is fine here. And this is going to be rec and then this is going to be for I in N10, right. So this is the second loop there which is anything beyond what we get back from available we have to allocate ourselves. So that's going to be out.
04:18:04.445 - 04:20:52.035, Speaker A: This should be I out of I is self acquire new and at this point we can do standard mem may I should really just use standard map maybe on init here. Because here what we can do now is maybe on init and then there's like an assume this landed I think in 156evenactually maybe155 there is assum init const array array assume init array assume init of out safety we have initialized all N. Oh, it's a nightly API, isn't it? All right, so this is really going to be safety. This is maybe an init array assume init and we have initially we have initialized all n and then we can just copy paste this. Oh, that's not what I wanted. Oh, where the T here is pass pointer record and same thing here. And I can't access the intrinsics so I guess I will just not have that assertion.
04:20:52.035 - 04:22:06.495, Speaker A: That's fine. This should say acquire new thoughts on using unit plus array map? You know, that's a good question. Can I use map for this? The problem with using map for this is that we're not mapping all of them the same. Right. The map function is different for the first lowercase n and for the latter for the remaining n. So array map would be a little weird, I think. All right, so back to this.
04:22:06.495 - 04:23:40.041, Speaker A: So what we've implemented now is basically this and there's a release they've added which is published create. Oh, I suppose you're right actually. So once you're right, we could do. Let me try and see if I can write that out this and then we could do out dot map. If we did this dot map and then we could do if not head dot is null else self acquire new and get rid of maybe an init. You're right, that is nicer. I take it all back.
04:23:40.041 - 04:24:35.145, Speaker A: I regret everything. Release AP rec. So this is going to be pubcreate fn release self and pass pointer record. So this is then going to be Assert that rec next is null next available and then self dot push available hp. I'm just going to call that push available. Right. And this is going to be head and tail again.
04:24:35.145 - 04:25:26.185, Speaker A: Oh, I guess we already have a release, which tells the record to release. I see. Which is going to stop being a thing. Okay, okay, that's fine. And then there's also going to be a release. Oops. Release HP Rex.
04:25:26.185 - 04:26:40.859, Speaker A: Oh, I see. Which is if you want to release, it's like release many, which is if you have. See, this is where I think what I actually want here is for this to also be constant. Because I think this is specifically this use case, right? Which is you have the thing in an array and you want to give them back because no one will be able to construct a linked list of has pointer records outside of this library. So the only thing that we'll ever have is what we give them. And what we give them is either singles or arrays of some length N. So there's no reason for us to really have the case where we have given them some number of things and they've like rearranged them and constructed a longer list.
04:26:40.859 - 04:27:11.961, Speaker A: The example I'm thinking of here is imagine someone calls acquire twice. They would call it. I guess this should be acquire many and we should have. Here they call it. They call acquire many twice, once with both times with the value 2 as the number or something. There's no way that they can provide us with a linked list of four items. All they can do is return them as they came because they don't have a way to.
04:27:11.961 - 04:28:05.535, Speaker A: To merge these. We know, as in the library authors, we know that you can string haspointer records together and construct a longer chain, but there's no way for the caller to do that on our behalf. So we don't actually need to support the use case where like you give me an arbitrary head and tail and ID allocate it for you. Instead, we only really need to deal with the case where they do what we. They give us back what we gave them. So this is just going to be acquire many one zero self which. And the reason why I want to do this is because it lets us.
04:28:05.535 - 04:29:03.677, Speaker A: The tail is just the last element of the array which we can compute trivially, right? So we can do Rex rex.len/1 which realistically we can use rec last sort of the same thing. We only give out with n greater than zero, right? So that's the equivalent to their. That's their. The equivalent to their check of the tail is Our check of last here because we're assuming that we're giving them out in. In sort of order. Do they chain them together when they give them out? They do.
04:29:03.677 - 04:30:05.285, Speaker A: So we probably need to do the same, which is let rec. Is this rec Next available dot store. That's awkward. I think what we'll do here is keep sort of a separate tail standard pointer null mute. And then we're going to say here tail is equal to head and here we're going to say tail is equal to rec. That doesn't look right. That definitely doesn't compile.
04:30:05.285 - 04:31:27.411, Speaker A: This can go away. And now I should get an error up here. This should be available next Dots store ordering relaxed because we haven't given this out anywhere. There we go. This is that. That's ugly and I apologize. So this way we're guaranteeing that what we give out is also a valid linked list through the available next so that they can all be pushed back together at the end.
04:31:27.411 - 04:32:32.379, Speaker A: And the last one and what we give out will have its next pointer be null load relaxed. And is that in fact what this does next avail? All right, Next availability. Where is the what does next avail actually do? It is almost certainly just a relaxed load. Yeah, it's a relaxed load. Okay, so we string these together so that what we return is both an array and a valid linked list. And the array is basically our way of communicating the N along with the value rather than like a linked list plus a length. Be nice to do the same thing here.
04:32:32.379 - 04:33:14.625, Speaker A: But we would have to return a slice and the slice doesn't have a meaningful lifetime. So that's fine. It also means that technically we should have this be like an option or something. But I'm going to not deal with that. So here in the release multiple. This is now going to be rex zero. And this is going to be.
04:33:14.625 - 04:34:27.134, Speaker A: I guess let head is Rex 0. Let tail is Rex last expect. And then we can assert here instead that the tail is that. And then this can be the tail and this can be the head. We no longer need to check the dot active flag. There is now this has disappeared. This is next or available next.
04:34:27.134 - 04:35:08.165, Speaker A: So that's fine. This is where we can get rid of the old. That's fine. I guess. I guess. Suppose it was up here anyway. So this is assert that N is greater than one and then this is just going to walk the linked list.
04:35:08.165 - 04:36:02.985, Speaker A: I'm a little surprised actually that it can't. Oh, it can steal multiple at a time. Okay, so we're going to loop. We're going to get the head of the list which like load avail is almost certainly an acquire load. Yep, it's an acquire load. So we're going to say avail is self pass pointers head available load and that's going to be an acquire load that should be n greater than 0. Yep.
04:36:02.985 - 04:37:07.317, Speaker A: Or I guess greater than equal to 1 is probably the better assertion here. So we grab available. If available is null, then we just return and that's going to be a standard pointer null mute and zero. We've reversed it from what they respond with, but that's fine if avail as usize and lock bit is zero. I'm always paranoid about the ordering of bit operations. Not current. The available list is not currently locked is the state we're in there.
04:37:07.317 - 04:38:49.165, Speaker A: In which case we're going to try to take the lock which is just going to be this. And this is going to be a compare exchange week of avail with avail as usize with the lock bit set. And this is going to be an ordering acquire release and fall back to relaxed. Ooh, maybe head available really needs to be an atomic U size. Really? I think it does actually because we're doing this like because we're doing this bit shifting on it. It's not always a valid pointer, so I'm inclined to not have it be a pointer, in which case I'm surprised it has to be a compare exchange week because it could be a. It could be a fetch or that'll be potentially more more efficient because with a fetch or even if you failed, you'd be told about what the new head was and you could keep going.
04:38:49.165 - 04:41:03.155, Speaker A: So let's do this could be be a fetch or. But fine, we'll keep it the way it is for now. So if this is okay, otherwise we yield. So this is the idea here being that if we lost the race to take from available, we should let some other thread run that is currently in the process of stealing from available and if it is okay, we hold the lock on the available list and here I suppose we're really just stealing. This should not be pubcrated, this should definitely not be great and should also be unsafe. And this should then be given the head which I think. Actually I think there's an argument for using const instead of mute here actually, which I think is what I want.
04:41:03.155 - 04:42:11.947, Speaker A: Which means that in record. No, because that really should be mute. Oh, it's a little bit ugly. Has pointer record so this should be caused. Has pointer record. Well actually no, it can't be that we're not allowed to turn it into a pointer until we've checked that the bit isn't set because it wouldn't be a valid pointer address. Although pointers don't actually need to be valid in the sense.
04:42:11.947 - 04:43:09.475, Speaker A: But it feels wrong somehow, like it's only here that we actually know that it is a valid point pointer. Definitely a valid pointer now and then this can be this and this no longer needs to cast. So the reason a fetch or would work is because you fetch or returns the value that was there when your OR happened. So you check the result from fetch or and see whether that had the lock bit unset and if so you won the race. Otherwise you retry. It just means that you can carry. If someone else got the lock and released the lock but changed the head, then you could still continue.
04:43:09.475 - 04:44:43.325, Speaker A: Whereas with this scheme you. You can't. You would have to retry even in that case and allow progress even if there's a new but unlocked head. So once we're here, we can now call self, try acquired, require available locked and give it avail. In which case this. It's like a terrible method name. So this should be let rec and n is equal to that and this should be debug assertion N is greater than equal to 1 and n is less than or equal to n.
04:44:43.325 - 04:45:53.587, Speaker A: And then we return rec and N and this can take a const. That's fine, return a const. So in here, what do we do in here the safety here first and foremost is must already hold the lock on the available list. So in here the. This is I guess the same thing, which is we should debug assert that n is greater than or equal to one. I guess we can also debug assert that head not head is null. And we can do that up here too.
04:45:53.587 - 04:47:13.345, Speaker A: Really that when we're asked to release these can't be null actually because they're references. So that's fine. All right, so back here, this is really just walking the available pointers and then constructing its own little linked list to return. So here I'm actually just going to copy this and then transpose it to rust. So the tail is going to be equal to the head and is going to be one. Next is going to be tail dot next available load and this we know is relaxed from other things earlier. And then while not next is null and n is less than n and so this is where this is going to turn into a.
04:47:13.345 - 04:48:24.453, Speaker A: Oh right, we don't have to turn it into array here. So that's great. So we're going to debug assert that not equal to zero. This should be available next. So here we're going to assert that next ended with the lock bit is zero, right? So as we're walking the available list, because we're holding the lock, we shouldn't expect anything else to hold the lock. It almost certainly won't, but nonetheless. And then tail is equal to next and next is equal to here and N + equals 1.
04:48:24.453 - 04:49:50.135, Speaker A: This is really just count to N and assert and collecting the tail as we go. And then why is doing this? It's impossible for NEXT to hold the lock bit because that's a pointer which we only set on the. We only ever set it on the head pointer. But I guess. I guess we can debug assert it through like a use size here. So this is just going to collect the length and find the tail. This has to cast next to a usize.
04:49:50.135 - 04:51:09.275, Speaker A: That's just because it has to do self dot has pointers dot head available dot store next as us. This releases the lock, right? Because we're storing next, which is a pointer which doesn't have the lock bit set and then tail dot next available next store here. We wanted to be disconnected from the remainder of the available list because this is the chunk we're given away. So the reason this matters is because when we want to stick this back on the list, we want to change the tail pointer and we didn't. We want to be able to assert that it doesn't currently point anywhere and that it is in fact the tail. And this is where we establish that. And then we can return N.
04:51:09.275 - 04:52:04.095, Speaker A: Although this is where this one's weird. And like the head you pass in is actually a pointer that gets mutated along the way. Instead we're going to do this, return it, and be nice citizens of the world. Why are we guaranteed that this is greater than or equal to one? Because it's not null. So this is head available was not null. You could make use of static assertions for the N equal N greater than equal to one check. That's true.
04:52:04.095 - 04:52:46.485, Speaker A: That's totally true. This could be a static assert instead. Beautiful. And so that's that one. And then we're going to have to also have push available, which is going to be fn. Push available takes a self takes a head, which is a has pointer record and a tail which is a has pointer record. And this bit.
04:52:46.485 - 04:56:36.417, Speaker A: We don't need these because references can't be null anyway. We are going to debug assert EEK tail and standard pointer null which is really just tail is null and here right. So this is where this d check connected comes in that we looked at briefly which just checks that there is a connection through the next available pointers between the head and the tail. So this is just to see that when you return something you're returning a reasonable head and tail we're going to not do that. So this is going to be like if config debug assertions check that head and tail are connected tail next available available next I really need to just rename that to next available honestly. And what else do we do? We check that the head doesn't have the lock bit set which is just head as I guess you size ended with the lock bit is zero load ordering laxed I mean this is why they have helper methods on like like if we did if we just had an available next like this that just did the load for you that'd be nice but I think you can easily get into having too many of these helper methods and then it's not actually available helpful anymore. So the head is going to be this business if avail and lock bit is equal to 0 then yeah this is just a standard sort of lock free append loop which is we're just going to set tail dot available next store avail ordering relaxed and then if self has pointers head available compare exchange this is a weak I'm assuming because in general you want to use weak whenever you're in a loop and you're you can and if there are spurious failures you want to retry which I think is fine here.
04:56:36.417 - 04:59:11.255, Speaker A: So we want to compare exchange avail with head as const as you size ordering acquire release ordering relaxed dot is okay that's silly but fine. If we fail here then we break if we fail here then someone has the lock so we need to give them a chance to run so that they'll release the lock and that's all it takes to append to a linked list create new hasn't really changed right? It just has set available next instead of setting active and now all of the things in record release goes away try acquire goes away atomic bool goes away at this point it's unclear it should be in its own module arrays we don't support Rex we already made this change those went away those we didn't add because we don't want helpers thread locals we don't have so in domain line 53 this should be a use size of 0 actually of this as usize is really what I want here. Actually, that's a good point. There's sort of a. I'm sort of cheating here in that there's a place where I check avail equals zero. In fact, there are two places and that's not really the right thing to check against. Really it should be this.
04:59:11.255 - 05:00:03.235, Speaker A: And the reason it should be this. In fact, it should really be this. The reason it should be this instead is because null is almost always zero. But the semantics here is we're checking whether it's null. We're not really checking whether it's zero. So I prefer the sort of being more explicit here and same thing up here. It like communicates better what the intention is here, which is this one is zero because we're checking whether a bit is set.
05:00:03.235 - 05:00:37.981, Speaker A: And same thing here. But that. But that check above here, this is a null check, which I guess there's like. There's sort of a debug assert here that avail is not equal to this. Right. Because that would be insane. This would be.
05:00:37.981 - 05:02:00.733, Speaker A: The lock bit was set but the pointer is null. That should just never happen. So we'll assert that that is the case. This can just be this. Does it work? No. 136 use the same cost generic here 56 pointers cannot be cast to integers during consteval. Well, fine, I tried debug assert equals this is zero, which is, you know, silly.
05:02:00.733 - 05:02:47.843, Speaker A: But I mean, it's a static assert. But you're not allowed to do it statically. Let's do this in. I don't know, I guess in. I guess here. That's really stupid. I do love when it just works.
05:02:47.843 - 05:03:34.375, Speaker A: But I think in this case I can't take very much of the credit because we're just directly porting an existing thing. But this is nice. Okay, we have this alternative list now. So this is keep separate. Keep list of available rex and this again. And then we'll go back here and again, be nice citizens and link the commit. Okay, now we have no more commits to catch up on.
05:03:34.375 - 05:03:46.661, Speaker A: Beautiful. Beautiful. There haven't been any commits, like in the past four hours. Right. Okay, good. So we can close this out. We can close this one out.
05:03:46.661 - 05:04:52.315, Speaker A: Close this one out. So now we come to the point. We come to a crossroads, which is we're now back up to speed. And the next question is, should we implement the sort of test suite from Folly or should we try to write loom tests? My instinct here is to use loom. And the reason for that is because I think the Loom test will be better than whatever they concocted in here because you just like, fundamentally have very limited control. Like, I'm guessing many of these tests are very straightforward, right? So we could probably port them pretty easily, but I don't know that they will catch like really subtle ordering bugs. For example, it'd be great to like port all these tests, but I don't think it'll be as interesting as running loom.
05:04:52.315 - 05:05:55.575, Speaker A: So let's go ahead and make a LOOM test. Okay, so LOOM is. Let me do a quick intro on Loom. So Loom is a tool, as its description says, a tool for testing concurrent programs. The basic idea here is that when you're writing concurrent programs, and in particular when you're testing concurrent programs, what you want to do is test all possible thread interleavings. And what I mean by that is like any time there's a race between, for example, a load in a store or a compare and swap or taking a lock, you want your test to run either case, right? Where thread one goes first or what thread two goes first. And you also want to sort of fully explore the memory model.
05:05:55.575 - 05:07:06.775, Speaker A: Like we have the video on memory ordering semantics and like they can get pretty convoluted in terms of what, what, what are valid, valid, but perhaps unintuitive values that a thread can read when it does a load during a race, for example. And LOOM tries to run all the relevant permutations of your concurrent execution of your test code to expose any kind of errors that might only occur, maybe in really unlikely scenarios, right? So for example, you might have a test that, or you might have a bug that will only occur if you have a very particular interleaving of thread interactions. And in practice, even if you ran your test like a million times, it might never trigger it. It might only trigger it if, like one core is running much slower than the others. Like the thread that, the thread that runs on that core like gets interrupted a lot, so it falls super far behind the others. And so you just wouldn't see this otherwise. But with loom, you will actually run every permutation, and you will only run every permutation once.
05:07:06.775 - 05:08:03.115, Speaker A: So in some sense the smarter way to explore the state space than just randomly searching. The downside, of course, is that LOOM is exhaustive, so it tries to walk every possible execution interleaving. And it turns out that for any non trivial program, there are a lot of them, which is why running tests through LOOM can be really, really slow. But it's because it's running your test so many times, trying out all the possible interleavings. In general, with loom, the way you want to go is to write simple tests that are trivial to convince yourself are correct, and that only have like maybe two, maybe three threads each just doing a few operations, because that's usually enough. If you ever find yourself writing like a for loop that just does something like a set number of times inside of Loom test, you're pro. That's sort of a code smell for Loom.
05:08:03.115 - 05:08:31.535, Speaker A: Because you shouldn't need to Loom is doing the permutation for you. You should like just assume that every permutation gets run. So here's an example and it's valuable to go through this, which is we have a test here. We have a a LOOM enabled test, if you will. Or it's not LOOM enabled yet. It's about to be a test that spawns a thread. It has a shared value between like v1 and v2.
05:08:31.535 - 05:09:09.995, Speaker A: Really point to the same value through an arc. You have a thread that you spawn that stores one into the value and the value is originally zero, and you have an assert equals that the load of the value is zero. And of course there's a race here, right? Because if this thread runs before this load runs, then this will be one, not zero. But it could be that every time you run this, it passes, because thread spawning is generally much slower than just running whatever instruction is next. It might be you can run it an infinite number of times, you will just never see a crash. But nevertheless, there is a race here. The code is wrong in the sense that the assertion will fail.
05:09:09.995 - 05:09:44.589, Speaker A: And this is a crucial point. LOOM can only detect errors that cause like that manifest as an actual error in your program, usually in the form of a panic, right? So here, if this assertion wasn't here, there would still be a race. Like if you wrote some code that assumed that it was zero, it might not crash. But in that case, LOOM also wouldn't have a way to tell you that your program was wrong. It wouldn't have a way to detect it. It would run your program in a case where that value was 0 and in a case where that value was 1. But if in either case your program ran to completion, then Loom wouldn't know to stop and tell you something was wrong.
05:09:44.589 - 05:10:25.649, Speaker A: So in general, LOOM relies a lot on these kind of debug assertions. And this is also why in our code we're going to want to have a bunch of them so that we can trigger them with loom. So in loom, what you do is you still write your test. The code looks fairly similar. There are two primary differences. The first is that you use types and functions out of the LOOM standard library or the LOOM variant of the standard library rather than out of the standard library itself. So instead of using standard thread spawn, you use loom thread spawn and you run your test in the context of a closure defined that you that you pass to loom model.
05:10:25.649 - 05:11:40.173, Speaker A: So loom model is this model checker that takes your closure and runs it many, many, many, many, many times, each one with a different permutation of all the atomic operations that occur within that closure. And the way that LOOM knows which which things might have multiple interleavings and figures out how to control them is because you're using its types rather than the standard library types for anything that might cause an interleaving. Right? So if you use a standard thread spawn here, loom would have way, no, no way to control whether this closure runs first or this code runs first. But if you're using the LOOM thread spawn, then LOOM is just given a closure and then it's told, which code do you want to run next? Do you want to run this load next? Or do you want to run this closure next? And it can pick one and the other sort of separately. Now actually using LOOM is a little bit annoying because you need to use these special types everywhere. Like your library needs to use them because otherwise, otherwise loom doesn't know how to interoperate with these types or not interoperate, but how to change their semantics. LOOM is also a somewhat annoying dependency.
05:11:40.173 - 05:12:30.665, Speaker A: Like you, it has to be a normal dependency because your library has to use types from it, but it is a testing dependency. You don't actually want LOOM to be in your dependency graph. So there are a couple of ways to go about this. The way that's currently recommended by the LOOM developers is to do this. So this is a special type of dependency declaration that CARGO supports, where you can say, only add this dependency if the loom config flag is set. And then the idea is that we're going to run LOOM with rust flags, equals and then config loom. Someone asked, does this add overhead for the library implementation if you use the loom types, The LOOM types aren't functional outside of loom.
05:12:30.665 - 05:13:04.715, Speaker A: So if you use like loom atomic use size instead of standard atomic use size, but you didn't Flag it on this. It would just fail like any of your methods would fail if you use this type. If you're not in the context of a loom model closure. And so this is why you can't just always use them. You have to use them only when you're running loom tests. And that's what makes it a little bit sort of odd in practice. The way you usually go about this is as they describe here as well.
05:13:04.715 - 05:14:07.425, Speaker A: In sort of the root of your crate or somewhere else. You have a set of all of the concurrency and synchronization primitives that your library uses. You represent them in a module that has like a config loom and a config not loom. And then everywhere else you just use out of that module. So the way this looks in practice is that we do something like oh no, sync.rs. let's take this as an example, right? So we do this and then in lib we do here mod sync. And then if we go back to domain up here where we currently import atomic usize, we're going to make this be crate sync instead.
05:14:07.425 - 05:15:04.005, Speaker A: So we're going to get rid of this. And then now you see the problem, right? There's actually a bunch of types. So there are many ways to go about this. The way that I like to do this is like so we do modify atomic and then this is going to do pub crate mod atomic pub crate use atomic use size and in fact it's going to be all of these. And then similarly for not loom these are going to be brought from standard library instead. Other things we're going to need so ordering can come out of standard sync. That's not a problem.
05:15:04.005 - 05:15:43.105, Speaker A: These are fine as they are. What about record? So record here uses atomic pointers. So that needs to out of crate holder uses this. So that has to come out of atomic crate. Great. Deleter doesn't use any of these. Yeah, we don't have too many files in here, so it's actually not that bad.
05:15:43.105 - 05:16:23.715, Speaker A: This is a little awkward. I think it has fences now forget. So we're gonna have to bring in in sync. We're gonna also bring in fence and same thing here. And cargo test should now still. Ooh, why did I make that a directory? Right, so the test still run. And this is because we're not currently running with loom at all.
05:16:23.715 - 05:17:15.495, Speaker A: And then what we're going to do here is as they indicate here too, we're going to have this. So this is going to run with rust flags config Loom cargo test. And we're just going to test the Loom only the Loom subtest is going to be run and you'll notice that because we changed rust flags, it has to recompile the entire dependency graph. In this case it doesn't actually matter, but it could matter, which is why it requires it. And you'll see here that we actually get a couple of compiler errors. One of them. Oh, that's interesting.
05:17:15.495 - 05:17:59.035, Speaker A: Yeah. So one challenge that you run into is that Looms types are mostly a sort of drop in replacement for what's in standard. The standard library, but not always. So for example, let me see if I can dig up. So if I go down here and find what where is. All right, Sync sync, atomic and where is this? On atomic pointer. So you'll notice that there's no, there's no get mute here.
05:17:59.035 - 05:18:35.881, Speaker A: There's with mute, but there's no get mute. And this is actually a. This is actually on purpose that this API difference is there. And if you, if you look at the top level documentation, you'll see here that they talk about how. Talk about Unsafe Cell too, where for Unsafe Cell there's also no get mute method in Loom. And the reason for this is because Loom needs to track when you stop using what you get back from get mute. It needs to keep track of sort of the entire scope of the users.
05:18:35.881 - 05:19:18.715, Speaker A: And it doesn't have to do a way to do that with get because you just get back a raw pointer which then Loom has to like assume that you use forever, which could totally be a problem. So it has these with methods instead. So instead of get mute you would do with mute and then pass it a closure so that it can keep track of that use. But that of course is a different API and of course the standard library doesn't have a with mute, at least I don't think it does. It would be nice if it did, but I don't think it does. Yeah. So this is an example of where the API is different between the two.
05:19:18.715 - 05:20:30.287, Speaker A: There are a couple of ways to fix this. One of them, and this is what the documentation sort of suggests, is that you create your own wrapper type and then for the wrapper type you implement the Loom method using the non loom using the standard library API. And that way you can use the Loom method API everywhere. That does work. How many places do we use get mute? Domain 221 and domain 262, domain 496 and domain 501 okay, so a decent number of places. So that means that instead of we can still use that from loom but here we're going to have to do pub create struct and I'm going to go ahead and derive transparent and debug for this atomic pointer which is going to have a standard sync. Standard sync atomic atomic pointer inside of it.
05:20:30.287 - 05:21:19.373, Speaker A: And then we're going to implement atomic pointer. This is going to be generic over T. That's entirely unhelpful. And now we're going to have to sort of copy paste the atomic pointer methods, which is rather annoying. Sync atomic ordering. Many of them are trivial. In fact, almost all of them will be self zero swap and it just, it just passes them on.
05:21:19.373 - 05:22:26.941, Speaker A: Right. Ordering. We're going to need comparison exchange week which again is just going to be self 0compare exchange week current new success failure and then get mute is the one that we won't have. What else we got? Store and load and new. All right, so new is pretty simple. Let's do them sort of in order which is just self of standard sink atomic atomic pointer new of P. So that's easy load also easy self0 load order.
05:22:26.941 - 05:23:27.851, Speaker A: Store is easy. Self0 store pointer order. I could implement deref. The reason I don't implement D is because I'm also overriding some methods and it oops, wrapper transparent. In general, when you have a type deref to an inner type, you don't also want to provide inherent impulse on that same type because it would mean that if the standard library ever, ever added a with mute method, my code would stop compiling. So a backwards compatible change to the standard library is now a breaking change for me, which I don't want. So that's why I don't want it to be draft.
05:23:27.851 - 05:25:15.689, Speaker A: You can work around these by using fully qualified methods. Calls for with mute, which I suppose we could do, but I kind of want to avoid that. So the one that we're now missing is for where are you? Sync atomic pointer with mute compare x change. All right, so now the challenge of course is that all of the places where we currently use get mute, we're going to have to change it to instead be with mute, which isn't usually that painful, right? Like that wasn't too bad. Some of them are kind of annoying. Like this one for example, will be a little annoying. That's going to be pretty painful.
05:25:15.689 - 05:26:33.075, Speaker A: Or is that the last one? So here it's annoying because on each like we're, we're iterating and Reassigning and like you wouldn't have a closure you could pass in here. Now there is sort of a way around this which is. Oh, it just dereferences it. Never mind. Yeah, so it can just be this. What's going on? Oh, there we go. Oh, balls.
05:26:33.075 - 05:28:26.365, Speaker A: So here's the other problem which is that loom looms new is not constant. Ooh, could I just use unsync load instead? That's fine. Looms new is not constant and it can't be because the new has to tie into the model checking machinery which you know isn't constant. Which of course is a problem for us because we have this static shared domain now all is not lost because loom has lazy static which we can use to have a an equivalent of this in the loom setting. So this is going to be loom ac static. That's fine because now we're going to have. And so this is a little bit off awkward but we're going to have a new that is not const under loom but is const otherwise.
05:28:26.365 - 05:30:19.445, Speaker A: And unfortunately there isn't a super nice way to do this. The best I know of is this so we could do this. Oh, what did I do? I did something weird to my copy paste. So we can do this which is fine. But it's really annoying if we ever have to change new because we have to remember to change it in both of them. So the other way to do this is to instead have macro rules new it takes an ident and it just does this. And yes, it is not pretty but maybe const and then we'd here do new new and in fact I think this can just be this.
05:30:19.445 - 05:33:06.259, Speaker A: So we're gonna have the declaration be here and this can be this now and it doesn't like that because it's going to be this and it's going to be this and this is going to be 0 or 1. There we go. So it's real ugly, but it works. This is complaining because isn't this how you declare lazy statics? Am I static ref shared domain? And this is failing because my macro is still not what it needs to be because this probably has to macro to make new construction only when not in loom. Actually I think we can just do this and I think we're okay. And then this is going to be const event and FN. Yep, fine.
05:33:06.259 - 05:33:53.801, Speaker A: 573. We're gonna have to do the same thing in retired list. All right, let's make this a little bit better. Which is going to be. We're gonna take a body which is gonna block. No, I take that back. So down here we're going to need the same thing for retired lists and we're going to need.
05:33:53.801 - 05:35:30.683, Speaker A: Here actually, we don't really need the macro because the constructor is so simple. So we're going to say config loom. No killing me here. All right. Awful, awful stuff. Don't at me, as they say. Yeah, it's.
05:35:30.683 - 05:36:59.287, Speaker A: It's terrible. It's terrible. This is going to be convert try into. I know, it's horrible. It's the worst. It's the absolute worst. Can't you just use array map here? The problem is array map isn't constant.
05:36:59.287 - 05:37:22.775, Speaker A: I suppose you're right. I could. You're right. I can do this. You are entirely right. I can't do that in const context, but I can in there. Good call.
05:37:22.775 - 05:39:04.751, Speaker A: Okay, so we now have something that compiles under loom and I was hoping it would run under loom, but it did not create private type sync atomic. So the problem here is that our public interface has a method where we take an atomic pointer, but the atomic pointer type we take. We want to be the standard, standard library atomic pointer type because it's part of our public API. So specifically this is in holder and protect. Here we want to be standard sync atomic pointer, but we don't want it to be that because it's very ugly. Okay, so we want it to be this. When loom is not enabled.
05:39:04.751 - 05:39:38.113, Speaker A: We want this to be the standard library type so that people can just use the standard library type and pass that to protect. We don't want it to. We want it to be the loom atomic pointer type under loom because we need to be able to track the interactions with this variable as well in order to like fully check all the interleavings. But it can't be those. Because the. We can't have the standard library atomic pointer type on the loom pointer type because the. They don't.
05:39:38.113 - 05:40:33.005, Speaker A: They're not compatible because one has with mute, the others get mute. So I think what we're actually going to have to do here, and this is. This makes me real sad, is we're going to have to go over here. We're going to have to not do this. This makes me very, very sad. I have to do this and then back in domain anywhere we do with mute, we're gonna have to. We could implement a trait here.
05:40:33.005 - 05:41:59.335, Speaker A: Actually, let's do that instead. I think we can get Away with that, which is we're going to have a trait with mute. So if we go back to sync, this is going to be the signature of it and we're going to implement with mute for standardsync atomic atomic pointer like so. Because now this should just work, I believe with Cargo T and with loom. Okay, great. So the public API matters in the sense that it. The problem is we didn't change it under loom, we change it not under loom to have with mute.
05:41:59.335 - 05:42:49.195, Speaker A: Does the trade temple always gets prioritized with this also break if standard lib changes, if STDLIB changes, I think the. The inherent implementation would be preferred. But that's fine. I mean it's a good question. Like if I added. Let's say I had. I added get mute here, right? And it returned this and I did just to see what happens, you know.
05:42:49.195 - 05:44:22.735, Speaker A: So this is going to be standard sync atomic atomic pointer get mute just to. And if I now down here used, let's say this one, or if I use getmute here, this is sort of the equivalent to what you're asking. And the question is, does that still compile? And it does. We don't know which one it calls, but at least the compiler doesn't yell at me, which is kind of interesting because the call I think is ambiguous. However, it's a different API. Mom, let's see. Just ignore me for a second.
05:44:22.735 - 05:45:26.865, Speaker A: It's fine, don't look here. Yeah, it seems like it still compiles. So it is preferring the local implementation I didn't want to put to do there because that would rely on the. That would only be checked at runtime. All right, so this is so that make atomic pointer usable with loom API, right? And this now needs to go back to with mute. PP is null. Great.
05:45:26.865 - 05:46:23.165, Speaker A: So now we have the infrastructure for writing a loom test. And if we now go back to test Lib and we take our feels good test and we sort of grab a hold of these imports and we're just going to make this a real simple test. So we're going to bring in loom sync, that count drops is fine. And what I want is, well, currently there are no multiple threads, so we need to figure out what is a test that uses multiple threads. The multiple multiple threads is going to be. We're going to have one. We're going to allocate this object.
05:46:23.165 - 05:48:01.335, Speaker A: We're going to have one reader. So this is going to use loom thread spawn. So we're going to spawn one thread that is going to be the reader and then we're going to have the main thread overwrite the value. Why is this. Oh, right. This is going to be a config loom only file. So as a writer, we're going to swap the value here and over here we're going to assert drops to our clone of drops.
05:48:01.335 - 05:48:42.547, Speaker A: Actually, we don't even need that because we're only going to check it in the reader anyway. So we're going to check. It should definitely not have been dropped here. And at this point it should eventually. It should eventually actually be dropped. As a writer, I'm going to overwrite it. And actually here, I guess I'll.
05:48:42.547 - 05:49:19.135, Speaker A: I'll do another thread spawn. Right, so this is reading after the swap. I'll tidy these up a little bit in a second. All right, let's keep this as 42. That's fine. Just to distinguish them. So inside of this thread we should be able to assert that it hasn't been dropped for as long as we still have a reference to it.
05:49:19.135 - 05:50:15.211, Speaker A: And then we should be able to retire it and then run an eager reclaim. And we should also be able to say where his. Let's see. So let T1 is here, at T2 is here. We're going to eager reclaim. Then we're going to t1.join.unwrap and then we're going to after.
05:50:15.211 - 05:52:15.547, Speaker A: So if we reclaim after thread one has terminated, we know that N1 plus N2 should be greater than or equal to 1, right? Because it should have. Should now have reclaimed 42 and it should also be in fact, what am I even saying? It should just be equal to 1, but not 9001. Right? If I now do T2 join and unwrap and eager reclaim should still only ever climb 42, but not 9001 because 9001 is the currently active value and then we can delete the rest. Okay, so the setup of this test now is this, I think can be a. We're going to impul count drops new. I think I actually want this to be a standard sync atomic use size because I don't care about interleavings of the load and stores of the. The drop counts.
05:52:15.547 - 05:53:20.465, Speaker A: In fact, I quite explicitly don't want it. So I think what I'll do here is this. And now this is going to be. It's going to return this so that we can. So that we can easily keep track of it. So now I should be able to do drops. 42 is count drops default.
05:53:20.465 - 05:54:00.789, Speaker A: And then like the counter, I guess drop drops 42. N drops 42. That's what we're gonna do. So drops 42 counter. And now this can be drops 42. And then this can be n drops 42. And then we can do the same down here.
05:54:00.789 - 05:55:20.105, Speaker A: So this is going to be count drops default N drops is going to be drops 9001 counter. And now this can be N drops now. So the setup of the experiment, if you will, is we create a new sort of guarded value. We spawn one thread that's going to do a read and we spawn one thread that's going to do a write. I guess actually one thing that's a little weird here is this reader. We expect to read 42, but there's a race already, which is this writer could go before the reader even gets to there. So I think actually this read has to happen before the writer gets to here.
05:55:20.105 - 05:56:17.065, Speaker A: So sort of. You can sort of think of this as to happen before we spawn, but really it has to happen before the writer gets to go. Is there a 9002? Nice. It's even more over 9000. So we're gonna have a let barrier is loom sync. I think there's a barrier in loom sync sync barrier. So we're gonna have a arc new loom sync barrier new two.
05:56:17.065 - 05:57:26.155, Speaker A: And then we're gonna have here barrier two is to be arc clone of barrier one. And then here we're going to say once we've read now we can let the writer change things, which is here we're going to do barrier to dot wait, and down here, wait until T1 has protected the value which is going to be barrier one. Wait. Okay, so we're first going to spawn a thread. That thread is going to make a hazard pointer and protect its read from X. And at this point 42 should be protected and should not be dropped. It it can maybe remove from the data structure, but it should not be dropped.
05:57:26.155 - 05:57:58.073, Speaker A: And once we've protected it, then we let the writer go ahead and actually swap the underlying value. But now we're going to race from this point onward, right? This thread is going to low check that it hasn't been dropped and also check that the value is still 42. And then I can reset the protection. That's fine. That shouldn't really make a difference, except that now it's allowed for this to be dropped. We don't really need this business. Arguably we don't even need the reset protection.
05:57:58.073 - 05:58:44.523, Speaker A: It doesn't do anything meaningful. And that's going to Race with the writer swapping out the value, and also race with the writer retiring the old value and also race with someone creating a new hazard pointer. Right, because loom is going to take care of making sure all of these actually happen concurrently. And it's going to race with these eager reclaims. But at some point, specifically here, we're joining with that first thread and at this point we know that 42 is no longer protected and it's retired. So when we reclaim, 42 should have been reclaimed. It might have been reclaimed earlier, it might have been reclaimed here if T1 finished earlier.
05:58:44.523 - 05:59:06.105, Speaker A: But at this point it must have been reclaimed and 9001 is still in the data structure. Hasn't been retired, shouldn't be reclaimed. Thread 2 is just another thread that reads after the swap. So it must see 9001. And we just want to make sure that 9001 doesn't get dropped. Arguably, this thread probably doesn't even matter. This is probably something we can get rid of.
05:59:06.105 - 06:00:19.765, Speaker A: The only real reason why I have it there is to deal with if there are races between making hazard pointers and stuff. Actually, you know what a better test here would be? Is to have two readers hold on to 42. That's what I want, actually. That's the more interesting case, I think. So T2 is going to be another thread that's going to go here. It's going to do the exact same thing. Thing.
06:00:19.765 - 06:01:04.775, Speaker A: And the reason this is interesting is because now imagine that we had a bug somewhere, right? Where dropping a hazard pointer meant that the protection went away. Even if there were other hazard pointers protecting the same address then now we have a way to sort of detect that kind of problem. The fact that we have A thread reading 9000 is not that interesting. It doesn't. Because it doesn't really protect anything. I guess it maybe would detect if we accidentally dropped 9001. Right? So there's maybe it would be interesting down here somewhere.
06:01:04.775 - 06:01:55.885, Speaker A: Right. But that's sort that almost feels like a different test. So I think we just don't care about having this here, this extra thread that reads the 9001. Remember, we can write multiple loom tests, right? In fact, arguably even this is too complicated. We should have one that's just the very straightforward one. So maybe let's do that first. Let's not complicated with having a second one, not complicated with having this, and just do the straightforward test of retire the old value, try to reclaim.
06:01:55.885 - 06:02:24.523, Speaker A: And there's no other thread. It's just this is all the Test really does. And then I think we can. We can easily write another one where we have multiple threads. For example, we check that if one exits but not the other, it's still not dropped. But this is a decent starting point. And again, keep.
06:02:24.523 - 06:03:19.425, Speaker A: Keep them in mind that for loom test, you probably want to keep them simple. Simple because loom is going to expose a lot of the complexity for you. Yeah. So there's a question in chat about doesn't the barrier sort of obstruct what we're trying to do here? And the barrier here is necessary so that we can have these asserts without this barrier, we can't even assert this. Right. So it's a way for us to ensure that we only get the subset of executions where these assertions are valid. Basically, let's loom prune the execution tree.
06:03:19.425 - 06:03:45.535, Speaker A: All right, so let's see what happens. I have no idea whether this is going to pass. Well, that's not. That's different. Let's have that be new, which is what I made it. So it turns out you can't call a method that doesn't exist. You can't call counter because it doesn't take self.
06:03:45.535 - 06:04:40.819, Speaker A: You can't use thread if you don't import thread by that name. You can't have an unused variable, I guess. N drops 9001. It doesn't really matter here, but that should still be zero. I have an atomic U size that I'm not using. 36 6. Ah, yes.
06:04:40.819 - 06:05:25.545, Speaker A: This has to go here. How about now borrow a value X. That's true. Now that we have multiple threads, which we didn't in the original, we're going to have to say X1 is ARC clone X. And this is going to be protecting our read of X1. Nice. Cannot access a scoped thread local variable without calling set first.
06:05:25.545 - 06:07:42.825, Speaker A: Oh, this is like something about looms thread locals being weird. I thought this was handled for us though. Cannot access a scoped thread local variable without calling set first. Do we have other red locals? I didn't think so. The only one I can think of is here, but. All right, let's see if there's some help to be gotten over here. If we search for AC static issues, you can't access ladies lazy statics in drop.
06:07:42.825 - 06:08:34.655, Speaker A: So this suggests that probably around here we need an explicit drop of H maybe. And here a specific drop of X. And here's a specific drop of X1. Oh, it's because the test isn't inside a loom model. You are entirely right. I am Entirely stupid. This needs to be loom model.
06:08:34.655 - 06:09:23.125, Speaker A: I don't even know what this is. An indication that the stream is nearing its end. You are entirely correct. Well, it caused an illegal instruction that's arguably good. One thing I do want is to make sure that this test is legal. So I want to do tests loom, but not loom. And this should now be standard sim sink, standard thread.
06:09:23.125 - 06:09:47.791, Speaker A: None of this and none of that. This should be standard sync. And now I want to do cargo T. Yeah. Okay, so it panics. It panics when you're not running it through loom. So that seems like an indication that we need to fix something.
06:09:47.791 - 06:11:37.195, Speaker A: Something interesting. So the Eager reclaim doesn't work here, huh? Fascinating. Why does it not do that? One challenge we have right, with with Eager Reclaim is that we don't actually know that it's right. I mean, Eager Reclaim is a function that we wrote, and we're just sort of guessing that it does the right thing. Thing. So check threshold and reclaim just does do reclamation of our account. Empty equals false, if not empty.
06:11:37.195 - 06:12:39.969, Speaker A: I feel like the bug when you drop a domain, I think is gone now because we. The. Because the code has changed. The code around dropping domains has changed now. Like, I think we accidentally fixed the bug in the process, but this one. Okay, so let's just see that it actually asked to reclaim. There's not.
06:12:39.969 - 06:13:53.671, Speaker A: There's like, not really a race here. Right? So this is why I want to loom but not loom. It's asked to reclaim. One empty is false. Guarded pointers is. There are no guided pointers. Match reclaim, untagged one and true.
06:13:53.671 - 06:14:54.577, Speaker A: So one was reclaimed and we're done. Archind is minus equals and reclaimed. Total reclaimed is plus equals and reclaimed. Wait, so isn't this value then one. I don't understand. Total reclaimed equals one. Am I just being stupid? Online 67, total reclaimed is one.
06:14:54.577 - 06:16:30.757, Speaker A: But the result from eager reclaim is zero. That. What? Okay, so the first call, we get back zero. In the second call, we also get back zero zero. So where is this reclaim coming from? Oh, I see what's going on. Okay, so damn it. Retire can itself choose to reclaim objects, right? So if you recall, in retire, we call push list and push list calls check threshold and reclaim.
06:16:30.757 - 06:17:11.345, Speaker A: And that might reclaim. So if. If the thread that does reads runs to completion before this returns. Now before this gets called, then the retire is going to immediately reclaim 42. So really what we want here is like this returns a usize. You get a usize and you get a U size and you get a U size. So this.
06:17:11.345 - 06:17:56.315, Speaker A: And then now this is going to be the real N1. N0, if you will. N0 plus N1 plus N2. What? Cannot add use size. Right. That's on object. So this is the one that has to return use size as well, which means this returns us.
06:17:56.315 - 06:18:43.955, Speaker A: Okay, good. So now we can go back to our loom, but not loom. Right. So our loom but not loom works, which means now we can say, let n 0 equals this. I mean, it's probably still broken, but at least now it's in a broken in a different way. Great. Holy crashed somewhere.
06:18:43.955 - 06:19:15.235, Speaker A: Barrier is not supported yet in loom. So that is a. But then I don't. What? But what? Wow. Standardsync. Barrier is not supported yet in loom. This stub is provided just to make the code compile.
06:19:15.235 - 06:19:53.329, Speaker A: All right, Next project, implement barrier in loom. It's fine. It's fine. It's fine. We're gonna. It's fine. Just no one tell anyone what's going on here.
06:19:53.329 - 06:20:04.729, Speaker A: It's fine. There's nothing to worry about here at all. Just. You can just. Don't worry about it. Don't worry about it. Just go to sleep.
06:20:04.729 - 06:20:17.307, Speaker A: It's all fine. There's nothing here. Nope. Nothing. It's all good. You saw nothing. You saw nothing.
06:20:17.307 - 06:20:42.965, Speaker A: I don't know what you're talking about. I have no. Literally no idea what you're talking about there. We never used a barrier and there was no barrier. What you're talking about. Yeah, see, so here we already see it. Ran a bunch of configurations, reached unexpected exploration state.
06:20:42.965 - 06:21:48.115, Speaker A: Is the model fully deterministic? What? What? It does need to be a loom barrier, actually, because otherwise loom doesn't know about the execution dependency. But this is fine. This is basically the same thing. But is the model fully deterministic? No, it isn't. Is it because we depend on the values of pointers? Because of course we do. Because why wouldn't we. All right, that's totally fine.
06:21:48.115 - 06:22:06.857, Speaker A: Nothing to worry about here. We can just ignore me. Just. There's nothing. There's. There's absolutely nothing going on here. Nothing at all.
06:22:06.857 - 06:22:18.545, Speaker A: It is. It's so fine. You know, there's like. This is just. I'm not even typing right now. I'm just. Oh, just saying random stuff.
06:22:18.545 - 06:22:39.215, Speaker A: You know, it's not. Not really a problem. You can just, you know, it's not. It's not like anything's really going on. We can really just all be happy and. Yeah, it's just. It's just great, really.
06:22:39.215 - 06:23:21.759, Speaker A: So I'm not. There's nothing. Nothing to really see here, actually. I'm just here making my model deterministic the way I was asked. Huh. Why can't I. Oh, you're right.
06:23:21.759 - 06:23:47.577, Speaker A: The time as well. That's fine. Time is easy to mock. In fact, I think. I think gloom has a mock for time already. At least I thought. Oh, yeah.
06:23:47.577 - 06:25:15.565, Speaker A: In fact, we have some other problems too, now that I think about it. It's always zero somewhere, you know. But we have yield nows which has to be crate sync yield now pub create use loom thread yield now 29 atomic. Ah, it. It ran to completion. That's not what I expected to happen. You know, I don't think it's the sharding.
06:25:15.565 - 06:26:07.305, Speaker A: I think maybe this is okay for lo. I think maybe it was the time all along. No, never mind. It's definitely a little awkward to do this. Like, I almost. I almost wish that loom had a like, random or something because effectively, from a model checking perspective, this is a random value. Like, arguably, I wanted to test all permutations of this, but at the same time, you can think of this as like, it is determined by racing on a value.
06:26:07.305 - 06:26:59.765, Speaker A: So yeah, it's like determined by racing on a value, but that value is the allocator. And here I'm just making it be the like, number of calls to shard instead. All right. Which means. Okay, so this is good stuff. Asked. Asked to reclaim.
06:26:59.765 - 06:27:51.695, Speaker A: All right, so what I want to know from loom now is how many iterations did it run? There is a way to get it to tell you. I think loom log equals one, loom log equals one. And I don't want no capture anymore. Or do I? I. Yes. There's like all sorts of things. When it fails, you can tell it to reconstruct what exactly the thread interleaving was.
06:27:51.695 - 06:28:46.775, Speaker A: But I thought there was a loom log equals one that I could. I wanted to print how many iterations it ran. Maybe they've stopped printing that. That makes me sad. I mean, we could always find out, right? Like, where is our test loom test loom print line. Hello. So it didn't actually run that many interleavings, which is interesting, but it suggests that there just like, aren't that many here or that there's somewhere where we're not using the standard, we're not using the loom type.
06:28:46.775 - 06:29:01.513, Speaker A: Anything looks suspicious here. That looks fine. This looks fine. That looks fine. That looks fine. That looks fine. That's in the test and that's in the test.
06:29:01.513 - 06:29:49.225, Speaker A: I think we're using all the loom types. Yeah, I don't think loom model returns anything would have been cool, I agree. But yeah, it doesn't. Maybe the builder see log execution output to standard out defaults to the existence of the loom log environment variable. Give me logs please. Loom log equals log. I don't know.
06:29:49.225 - 06:30:29.595, Speaker A: It's not working. What about the atomics inside of arcs? Does loom model that? This one you mean? I mean this is also using the loom atomic pointer. It doesn't model the ARC itself, but we don't actually care about that because the ARC here is just to. For the. For the test setup. But there are no uses of ARC inside of the library. This to me suggests that this actually does the right thing like reader single reader protection.
06:30:29.595 - 06:32:29.873, Speaker A: And then of course what we can do is now just because that worked, we can run a. We can run two of these, right? Both of which are going to read both threads have protected the value. TX1 is TX clone and we're going to have to do the same thing here. TX2 is TX. So clone TX1 TX2 this has to be X2 should still not have reclaimed 42 or this one's weird, right? Because. Oh actually the assertions inside of the threads are what really make this particular test. Right? Like the only guarantee we need is that running a reclamation I guess we want to try to trigger the.
06:32:29.873 - 06:33:35.555, Speaker A: The corner cases if you will. So we'll do T2 dot join N3 and then this plus N3 and I guess we could also do 42 is one here but I don't think that's actually. No, that's a. That's a good thing to test. We'll add that up here too. That it should check that that is actually dropped. So this is one, this will be one and this is multi reader protection and this is going to be two.
06:33:35.555 - 06:34:41.795, Speaker A: Yeah. So you see how for single reader protection there weren't that many possible interleavings. For multi reader protections there are a lot more. Right, because now it's every possible interleaving between the readers and between each of the reader's interactions and the writer interactions. It still did run in the end though it did actually tell us that there's nothing wrong with this code. And in some sense this shouldn't be surprising because we've been porting very carefully thought out code and so unless we like miss the line somewhere, which you know, could totally happen, but I don't think it's entirely unreasonable that maybe this is right. I'm going to go ahead and add.
06:34:41.795 - 06:35:46.215, Speaker A: Actually, I'm going to remove the loom, but not loom now that they actually work and just add dot loom tests pass. Now loom tests. Can you count the them again? Count what again? You mean like the number of executions? The problem is once you add a print here, they become a lot slower. Let's see. So if I do let mute I is 0 I plus equals 1. Arguably this shouldn't even work. I forget whether it does, because in theory these could all be run in parallel.
06:35:46.215 - 06:37:04.025, Speaker A: But I don't think LOOM does that at the moment. I see. Yeah, I can't do that, but I can do arc new atomic U size new. This has to be a standard sync atomic atomic U size new of Z0. And then let I is arc clone of I and then I fetch add one ordering acquire, release and then no, this is going to be I. I really don't understand why LOOM isn't giving me. That's a move.
06:37:04.025 - 06:37:48.845, Speaker A: Why LOOM is not giving me the log. Because it's definitely worked for me in the past. All right, let's see. See what it prints. So that is 1,087,712 permutations. Nice. That's good.
06:37:48.845 - 06:38:24.219, Speaker A: That's some number of iterations. No, I have no capture, so that. That shouldn't be it. Okay. That change I don't care about. Um, so what's interesting is that with more readers. So.
06:38:24.219 - 06:39:01.175, Speaker A: So loom partially just because the implementation gets too hairy. Loom actually has a maximum limit on the number of threads it can support. Do you see there's this constant max threads. You cannot include more threads than four, including the main thread, or not the main thread per se, but the root of the loom model closure. You cannot ever have more than this many threads in a LOOM program. Not concurrently, just at all. Within one loom model closure, which can be a little limiting.
06:39:01.175 - 06:39:41.045, Speaker A: But it's also if you had more, chances are A, you can probably reduce the complexity of your tests, but B would just take far too long to actually run. Now, the loom documentation has some pretty good description of things you can do if your tests are taking a long time. How to debug failures when they come up. We didn't really have to get into this, but I really recommend that you read the loom docs here. They are pretty good, I think. Now that we have the loom tests in place, I think I'm Going to stop here because we've been going for a while. But what we'll do is I think.
06:39:41.045 - 06:40:26.625, Speaker A: I do think that there is another stream here which would be porting the folly tests because I do think that's valuable to have. And two, actually documenting this API, which is something I sort of promised we were going to do this time last time. But I think this was a worthwhile endeavor to go through. And I think actually writing the documentation is going to be a little bit tricky because one of the things we will have to document well are all of the safety guarantees for the methods we have that are unsafe. And I think that is really valuable to go through. Oh, for dropping domain. That's true.
06:40:26.625 - 06:41:56.605, Speaker A: All right, fine. Let me add a test for dropping a domain. Drop domain. So we're going to do with domain. It's unique domain, right? I guess we could just do domain new. That's fine too. It's make in domain want to be able to protect the value.
06:41:56.605 - 06:42:41.561, Speaker A: And now I'm going to do this. Replace the value. This is going to be with domain domain. I'm going to assert that still hasn't dropped. It's going to retire it. Then it's gonna do the same thing. It's gonna try to reclaim.
06:42:41.561 - 06:44:12.295, Speaker A: Check that it's still not dropped. Reset the protection, then do an eager reclamation. See that it gets one and see that this is one and then drop the domain. Make in domain requires a reference and ooh ah, drop my X cannot move out of domain because it is borrowed. That's going to be. Oh, we're not resetting the production here. We shouldn't be resetting the production down there and here we're going to drop H before we drop the domain in 141.
06:44:12.295 - 06:44:52.415, Speaker A: That's because this is the global domain and I want this instead. Nope, passes just fine. So we can drop a domain. Nice. So we'll add a. Oh, did I accidentally delete the feels bad test? That feels bad. It's going to be.
06:44:52.415 - 06:46:16.677, Speaker A: It's okay, gang, I recovered it. Test for dropping a domain. All right, so summary, summary time. We are now up to speed with the head of folly. We are still missing implementations of the children optimization local array hazard pointer holders which are now just hazard pointers. We're also missing the sort of tag support for tagged cohorts. We have loom tests, but we don't have a port of the folly test which would be really nice to have.
06:46:16.677 - 06:46:50.643, Speaker A: And we're still very lackluster in terms of documentation. Probably also a little bit in terms of API ergonomics, I think we could do better there. I think realistically for next time the plan is going to be porting the tests and documentation. I think those are the sort of priority items, things like cohort support. I think in theory could be people submitting spr. Same with child support. And I think building a safe wrapper around this could be really cool too.
06:46:50.643 - 06:47:56.935, Speaker A: And then of course the ultimate test of whether this actually works is going to be to try to sort of unwind the stack a little bit more and try it in our in bystander, in the crate. We wrote for this sort of lock free, no weight free data structure abstraction thing that we originally got us down this path. Don't know when I'm going to do the next hazard pointer stream. I do think this is really fun. Like there's a reason I've been doing this now for like seven hours is because I think it's a really fascinating topic, but it also means I have to find a seven hour chunk of time to do this. And just to clarify, the reason I do this in such long chunks is because otherwise, as you've seen previously too, it takes so much time to get into it that if I did say a two hour stream, I don't think I would actually make that much progress compared to here where we can really dive in and have all the context in our head and therefore make a lot of modifications per sort of all at once and keep it in our heads what's going on. Great.
06:47:56.935 - 06:48:27.273, Speaker A: Thank you all for coming out. I hope you feel like you learned something. I hope you feel like it was interesting or that just this library is going to turn out interesting and I will see you all next time there's a stream whenever that ends up being or hopefully maybe now things are going to be in person. I can actually go to meetups and conventions if they start happening again. That'd be fun. In the meantime, see you all, have a great n amount of days. Until the next time, be nice to other people, be nice to yourself and see you around.
06:48:27.273 - 06:48:27.665, Speaker A: Bye.
