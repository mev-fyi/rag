00:00:02.240 - 00:00:52.312, Speaker A: Hello and welcome back. This is another Q and a plus plus. I guess I decided to do another Q and a fairly quickly after the previous one, mostly because, and we'll talk a bunch about this on stream after we had some issues with the site that did Q and a for us last time. So I reached out to the people who maintain that site, and they were actually working on a new version of the site that doesn't fall over if lots of people are using it at once. But they got back to me after I'd started writing my own. As I wrote my own, which is called wewerewondering.com dot, I put the link to the place where you can submit questions for this particular event and vote for questions and stuff in chat and in this stream.
00:00:52.312 - 00:01:41.298, Speaker A: I basically want to test that it works, so please go use it. Please don't double vote and stuff. It's not intended to prevent people from double voting in any kind of malicious way, but just see the things generally work. The interface updates, you see questions being marked as answered. I just, in general want to see that it doesn't fall over and that it roughly does the right thing. And so that's one of the reasons why I wanted to do another Q and A, is that now that that site works, at least in theory, I wanted to test that it works in a sort of real scenario. And the other reason why I wanted to do another Q and A is that I only barely got to compare the new camera I have to the old one I had on the last stream, because the cable came in the mail during the stream.
00:01:41.298 - 00:02:25.308, Speaker A: And so it was very like, let's just see if we can get this to work last segment, last minute. And then the third reason is last time there were a bunch of questions I didn't actually get to. And so I figured that sounds like there are still questions out there, so we should just try to answer them and see how well we do. I think the next question now is going to be what topic do we want to cover first? Let's do camera comparison first, because that way if it gets messed up, I I can just restart the stream rather than doing it in the middle, in which case it gets weirder to cut. Yeah, let's do that. Okay, so it's not going to be very long. This is just, I used to have a camera.
00:02:25.308 - 00:02:58.060, Speaker A: I now have a different camera. And for other people who are thinking about using an actual DSLR as your webcam, basically for things like streaming or just for meetings for that matter, if you want to look real fancy. It can be really hard to figure out what cameras to get, which ones work, how they work, how well they work. So let me switch to the view. That lets you compare them in theory. Boom. You should now see a side by side of one camera there and one camera there.
00:02:58.060 - 00:03:42.930, Speaker A: So that camera is my old one. That is the Panasonic Lumix G seven. And it's connected to an Elgato camlink four k. One of the things you'll notice is actually the audio sync is a little off on that one. And the reason for this is because I used to have to set an audio delay in obs to match the delay that's introduced by that particular camera and connection thing, which is unfortunate because it means that there's additional delay to the stream. Whereas now I've removed that audio delay because the new one does not have a delay. And so now you'll notice the delay on the old one, at least in theory.
00:03:42.930 - 00:04:10.974, Speaker A: The other thing that is different here is that the new one has autofocus. As you'll notice, when I point to this camera, the focus doesn't change. If I point to this camera, the focus does change. This is actually. It's really, really handy, because every now and again I want to show, like, if I want to show a cat, which we all know is very important, if I show the cat up to the camera, it'll be out of focus with the old one, because I had to, like either. I had to use the. So there's a button.
00:04:10.974 - 00:04:42.112, Speaker A: You can like, hold down the shutter button to cause it to focus, but the button is too far away, I can't reach it. So that's why I have. Let me see if I can find it. I have a focus stick. So this focus stick, which is really just a wooden stick, I used to hit the button so that I can trigger the focus. And it got so annoying that I've now just set it to manual focus and just put it at like this distance. But it's not ideal.
00:04:42.112 - 00:05:11.640, Speaker A: Right? And then the last one. The last reason why I wanted a new one was because I kind of want to use the old one for my work setup. Because I hate how the webcam works there too, which is really bad reason for getting a camera. But, you know, it was fun. So. Yeah, the real big reason here is I want to be able to show cats. That's really why.
00:05:11.640 - 00:06:03.990, Speaker A: The other thing that's neat is these both work with Linux. So that one's using the elgato card, which used to have a little bit of problems around color spaces, but that's now been fixed in the kernel. The new one is actually using a PCIe card that's, I think, recent, relatively new, but it just worked out of the box. They both just work with the video for Linux standard, so I've had no problem setting either of them up. One thing I'll show you though, that's a little that you may find interesting is let's see how well this is going to work is I guess I'll show with that camera. So here you'll see that's the video setup. It'll probably be a little trippy, but basically there are, the two cameras are just side by side on booms.
00:06:03.990 - 00:06:42.126, Speaker A: And you'll notice one thing that's annoying about the new one is the HDMI cable comes out on the same side as the screen flips out on. And so that means I can't really see myself in it, which makes it hard to fully position the picture. But apart from that, I'm pretty happy with them. Interesting. So there are definitely some people who prefer that one. Colors look better on the old one. Also the new one looks more washed out, so I can increase the contrast on that one.
00:06:42.126 - 00:07:08.756, Speaker A: The actual colors are, are more due to just the contrast setting and the white balance, which I haven't adjusted yet on the new one. So that's not terribly surprising. Looks like two different people. Sony is washed out, but looks better. Yeah. So I think I just need to bump the contrast on that one, which should be relatively easy. Oh yeah.
00:07:08.756 - 00:07:36.710, Speaker A: And so that one. The other thing that's nice is the new one has, it's using a prime lens. The other one is. The old one is using a zoom lens. So the prime lens has a, you can set a much shorter aperture opening, or smaller rather. And shorter, I think is the right word. And what's nice about this is it actually works better in lower light than the old one does.
00:07:36.710 - 00:08:13.400, Speaker A: So you can't open it quite as little or quite as wide. Aperture is how wide it opens, shutter speed is how quickly it opens. Right. So that one works a little bit better in low light, but it also means that it can have a shorter focus. So as you notice, I think someone observed the focus on the old one. You can better see the things that are in the background, whereas with this one you only really see the thing it focuses on, which is one of the reasons why it adjusts a lot. I can probably adjust the, the f stop for this one a little bit so that it's a little less sensitive.
00:08:13.400 - 00:08:34.760, Speaker A: Great. Okay, we've done camera comparison, I guess. Let me just. For completeness, let's go ahead and do. So this is the old one. This is the new one. This is the old one.
00:08:34.760 - 00:09:05.798, Speaker A: This is the new one. Old, new. So, yeah, now you've seen both. Okay, back to. We've done that part now let me then talk briefly about the q and a site. So let me share the link in chat again. Okay.
00:09:05.798 - 00:09:38.762, Speaker A: So on the site, what I wanted was actually something super simple. I wanted a page where people can submit questions. There's no need to log in or anything, because people will just want to ask questions if they have to. So there's no real authentication. It's just like it uses basically local storage to keep track of, um, which questions you've seen and which ones you voted for. So there's no like protection really, against, uh, like people opening multiple, like incognito tabs or something. It's not something I wanted to deal with.
00:09:38.762 - 00:10:24.380, Speaker A: I just wanted it to be very straightforward for people, people, people to ask questions and to vote. Um, and I also wanted it to scale really well because I hate when sites like these fall over, because it's really annoying when you're doing a q and a and suddenly shit just breaks and questions don't come in or you can't vote for them. So I wanted a really, really simple setup where it can be run on a CDN, it can just be scaled horizontally forever. So the way I ended up building this, and let me go ahead now maybe, and share this. So that's going to be. Oh, that's a good question. I think this.
00:10:24.380 - 00:11:13.000, Speaker A: So at least in theory, just to check the view, you should now see my browser fill most of the screen, and you should see my face on the left. My keyboard shortcuts I recently changed, so I want to make sure I actually click the right one. So it's on GitHub, it's just on John, who we were wondering. And the basic setup here is like an AWS stack. Not a particularly good reason why I went with an AWS stack here, except I still work for AWS, and so it felt useful to maybe build something using their infrastructure to sort of try it out myself. So the basic layout here is there's a cloud front, like the CDN sits in front and accepts requests. Any requests for static assets goes to s three.
00:11:13.000 - 00:11:53.650, Speaker A: And then anything that is an API call goes to through API Gateway, which lets you do throttling and stuff. And then to lambda. The lambda is a rust lambda I'll show you the code in a second. And the rust lambda uses the AWS SDK to talk to DynamodB, which stores all the data. The data in DynamoDB is actually super straightforward. There are two tables. One is events, which has just really just the, the unique identifier for the event and the secret for that event, which is used to basically get the admin view for any given event that lets you mark things as answered and such.
00:11:53.650 - 00:12:33.790, Speaker A: And then there's a questions table. And the questions table is really just the name of a question, whether it's hidden, whether it's answered, and the number of votes. And so in general, when you create an event, all it does is generate a unique id and a secret for you. And when people ask questions, it does an insert into the questions table. When you vote, it just updates the questions table. What this means is that the question text is immutable and so is everything about an event. So those are the APIs for those are long term cached, which is really nice.
00:12:33.790 - 00:13:30.800, Speaker A: And then there's just one view that lets you get the, the most recent vote counts for all the questions, basically the sort of ordered list of questions which just gives you the current vote count, whether it's answered and the number of votes. And so that's the one that has a shorter cache time, which is basically the thing that your browser now keeps refreshing in the background. And it's a poll, it's not like websockets or anything. The reason for this was because I don't actually think what people want is a sort of live updating view of every vote. I don't think that matters. So I would much rather just say in the case of we were wondering, the way it's currently implemented is the guest view, which is what you're all seeing. The guest view gives you a ten second refresh rate, or refresh period, I suppose, and that's also the cache time in the cdna.
00:13:30.800 - 00:14:02.620, Speaker A: So basically, no matter how many guests there are, there'll only be a request to the backend every 10 seconds. And that's fine. In general, you're not actively watching. The vote counts as they go, and then the host view. So if you have the secret in the URL, then it's every 3 seconds, which works just fine for me here. It also prevents things from bouncing around too much because it only refreshes every now and again. Of course, it also means the backend is dirt cheap because everything is cached basically all the time.
00:14:02.620 - 00:14:44.656, Speaker A: So someone asked in chat, is there an atomic counter there is. So DynamoDb has an API call that's like update in place and if you issue that from multiple places at once, it won't lose any of the states. And then there's what are they called? Global secondary index in Dynamodb. So DynamoDB is really just a key value store. You have a primary key and when you give that primary key you get the value for that entry. So the primary key of questions is just the unique question identifier, which we need to figure out which question you voted for, for example. But when you want to grab the current list of questions you want to grab them by event id.
00:14:44.656 - 00:15:54.180, Speaker A: And so there's a secondary index where the key is the event id and the sort order is the vote count. And so we use that API instead or that index instead for queries in order to render this view. And what I've done is actually in the readme for we were wondering and let me put this link in chat I suppose in the readme for it I've actually outlined all of the things that I've set up and how it's not like super interesting, but you may find it curious. There are a couple of things that are a little subtle in there, but in general it's a fairly straightforward, like just static things in s three and the dynamic things is just a lambda. We can look at the code a little bit. So the client side is not in rust, it's written in JavaScript at the moment using this I guess front end kit called Svelte, which I found decently nice to work with actually. It's styled using tailwind, which also works pretty well.
00:15:54.180 - 00:16:54.762, Speaker A: Haven't had any major issues there. I definitely had to learn some idioms that I wasn't used to, but it's all reactive style, same way as how you would expect it to work. So there's sort of a, I don't want to say event stream, but there's sort of a reactive connection between the array, the JavaScript array that holds all the questions and the number of votes. And so whenever it gets updated, all of the views get updated as well. And that's why the list here keeps auto updating. All that's really happening is there's sort of a set interval that fetches from the server and updates that array by JSON, decoding the response, it gets back and the svelte framework takes care of the rest and that works pretty nice. Then the server side is using the, what's it called? The lambda runtime.
00:16:54.762 - 00:18:01.682, Speaker A: This is like a separate crate that just basically gives you a translation layer between requests that come into lambda, like the way those requests are structured into regular HTTP requests, and the mapping back, so that if you return an HTTP response through the HTTP crate, an HTTP response to get turned into the kind of response that lambda wants to get. And then I'm also using cargo lambda, which does packing it up into a zip the way the lambda wants, uploads it, and sets it to be the current version and whatnot. It wasn't too bad to set up. I have the commands documented in there. The actual rust side of things. Also pretty straightforward if we look at source main down here somewhere. Where's my actual main? It has this dual mode where if you run it in debug mode, then it just keeps a like a local r commutex hashmap that tracks all of the state rather than talking to Dynamo.
00:18:01.682 - 00:18:42.696, Speaker A: And it also disables the lambda interfacing. So it just runs a straight HTTP server, which is really, really handy for debugging if you're not in debug mode. So if you're in release mode, then it actually tries to connect to dynamodb. It assumes you have all the credentials available, and it assumes it's running in Lambda. I could do something nicer here, have environment variables that dictate which mode you run in and stuff. But this seems like a very straightforward thing to just make testing work and all of the actual request handling is happening through axiom. So I was using axiom 0.5
00:18:42.696 - 00:19:06.566, Speaker A: at the time. Zero six is out now, and there's a pr to update to zero six that I haven't actually merged yet, but I'm about to. And accident was really nice to use, actually, I had very few problems with it. It felt very straightforward. It was pretty easy to actually implement all of the bits that I wanted, including things like limiting the size of requests and stuff. You can see here all the routes. There's nothing that's particularly surprising.
00:19:06.566 - 00:19:57.980, Speaker A: It's create an event, create a question, vote for a question mark, a question is answered, mark it as as hidden, and that's all there really is to it. There is one file, like one module for each API endpoint. So ask, for example, is the thing for actually asking a question. And all of them are really just proxy calls to DynamoDB. So it's very very straightforward. Then I also have DynamoDB has auto eviction that I've set up, so that questions and events just automatically disappear after. I think I set it to 60 days, but the website says 30, just so I have a little bit of leeway, but all just very, very straightforward.
00:19:57.980 - 00:21:01.460, Speaker A: And this was by design, right? I wanted this to be a straightforward architecture because that tends to imply that it'll scale well too. The one thing that I'm a little sad about is that currently the CDN is globally distributed, but ultimately, at least at the moment, the API gateway and the Lambda and Dynamodb all live in us east one. And the Lambda and API gateway would be easy enough to just ship to multiple regions and have them work. And I think Cloudfront would handle that well too. You can do geographic routing. The challenge is DynamoDB, as we all know, why globally distributed databases turns out to be a hard problem. But in particular, the challenge here is the question that came up earlier in chat, which was how do you deal with atomicity of updates? Dynamodb does have this notion of global tables, which is basically a table that gets auto replicated across regions and updates get autoreplicated.
00:21:01.460 - 00:22:17.244, Speaker A: That would have worked really well here, except for the fact that it doesn't guarantee atomic updates. If you have two updates for the same primary key across two different regions, then what happens with global tables is it uses whichever one comes last, it does not apply both of them, which for a counter is not what you want, which is really unfortunate. How do you scale the routing if you have 50 times more API endpoints? I mean, I'm not gonna. This is part of the design here, right, as I wanted this to be very small, very limited feature set, because it's not worth the complexity and the reduced scaling capabilities of trying to make it bigger. And so I've been trying to ponder, like, is there a way to sort of shard the database by region as well? One of the things I thought about was to, when you create an event, it registers which region you're currently in, and it marks that as the owning region for that event. And so all questions in that event will also be stored in a shard of the DynamoDB table for questions. That's in the region of where the creator of the event was.
00:22:17.244 - 00:23:18.304, Speaker A: So at least I'll distribute the load. Assuming that the people who create events are somewhat distributed across the world, I don't know that it's worthwhile at the moment. I think I'm fine with us east one being the bottleneck here, but it might be a thing to consider. It's not a perfect solution because it still means that if the person who creates the event is in, say, Japan, but the people who are voting for questions are in the US, then they all have to go to the server in Japan in order to vote and get questions, which seems unfortunate. I don't have a great solution here, but that's the basic architecture. I'll also here, just because we're at it, tackle one of the questions that I saw come up in the Q and a section, which was why did you pick uuids for? We were wondering rather than say ulids. So if you look at the URL, let me put that in somewhere.
00:23:18.304 - 00:24:02.130, Speaker A: Actually, let me put that in over here, maybe. Yeah, so the URL right here, you can see this is the URL for an event, and it has this long UuId at the end here that uniquely identifies the event. And I'm using the same for questions. So the reason why you need a UUID or something like it is because Dynamodb doesn't have a notion of like auto increment keys and stuff, because that would make it less scalable, because it can distribute. It's very hard to keep a globally synchronized counter. So you need something here as a unique identifier. For me, UuIds, which is the first thing that came to mind, they're designed for this purpose.
00:24:02.130 - 00:24:40.696, Speaker A: Now, the downside of UUIDs is first, they're very long like this. The second is there are multiple standards of UUID and they have slightly different semantics. This is UIDV four, which is really just a random string, and it's a fairly long random string. It's encoding. I forget how many bits of randomness, but using far more letters than is necessary. And because it's just random, you could imagine having more semantics here that would make them, say, orderable in a meaningful fashion. So for example, there is UuidV seven, which I think is still unstable.
00:24:40.696 - 00:25:09.744, Speaker A: And when I say unstable, I mean I don't think it's actually like ratified and standardized, it's just proposed. At least that was the state of it. Last I looked at it. UuidV seven is still as long, but it includes information about the current time in the encoding. So it's not just randomness. The question here is talking about Ulids. Ulids are a slightly different spec that basically aims to do sort of the same thing.
00:25:09.744 - 00:26:10.690, Speaker A: And the L here is for lexiographically sortable. The idea being that it would be nice if these uuids weren't just random, but actually had a little bit of semantics so that you could say sort them and get them in roughly the order they came in. You see, this talks about a comparison to some of the other schemes, including UUIDV four and the ULIDs are shorter, and not just shorter, but they're also denser information wise and they include the timestamp and the information. So if you generate multiple of them, you actually get a reasonably sorted list. I think it's totally reasonable to migrate, we were wondering, to UlIds. There wasn't really a strong motivation for choosing uuids over these other schemes, as much as UuID was the one that most readily came to mind. So, yeah, I mean, given that I auto delete questions and events and stuff, it would be trivial here to just move it to UlIDs and say that's what we're going to use going forward.
00:26:10.690 - 00:27:04.040, Speaker A: Okay, so I'm going to mark that as answered. Hopefully that works. Oh, one last thing I'll talk about here, actually, is I don't think it's a problem to show this, I'll show you this. So this is just the dashboard of traffic to the cloudfront setup. There's a lot of traffic because right now that turns out there are people accessing it. I've turned off detailed metrics because it turned out those actually generated a lot of traffic, or rather a lot of traffic to Cloudwatch, which they charge per traffic. So like, and if you look at the cost overview, let me do, can I do longer than this? Like can I do, say, I forget when I made this, but let's do 18th to the third, see how that works.
00:27:04.040 - 00:27:48.166, Speaker A: So this is grouped by service over time, and this is the cost. Notice that the top of this is $1. So initially you see how the Cloudwatch cost was kind of high, by which I mean what, twenty cents per day? That was because of the, using the like, detailed metrics. From Cloudwatch? No, from Cloudfront. So I turned those off and then it went down to what, three cents a day? And then yesterday I got charged for the DNS, which is fifty cents per month. And so that's my biggest cost is DNS at the moment. You know, I mean, this is going to change over time, right.
00:27:48.166 - 00:28:29.214, Speaker A: If the site becomes widely popular, of course these costs are going to go up. But in general, you can't even see the cost of things like API, Gateway and Dynamodb here, which is by design, it's intended to be extremely cacheable. But yeah, it's very expensive for me to run this site at the moment. You see, the cost yesterday was a whooping $0.00. So I think that's all I wanted to say about what we were wondering. Unless there are other questions before I move on, a lot of the detailed questions about exactly how we were wondering is set up. Like, in terms of services, stuff is in the readme for we were wondering.
00:28:29.214 - 00:29:17.780, Speaker A: I also want to go through the code and document a little bit more about why it's doing particular things, both in the front end code, which has a decent amount of weird smarts in it. You might find it interesting if you are interested in front end work and the backend stuff, where some of the routes are a little complicated for somewhat annoying reasons, mostly just to make caching better. I have a bit of audio latency that's interesting. Do other people see my audio being out of sync? I'm hoping not. I'm hoping nothing. Okay, let's then close this. Close that, and then switch back to this view.
00:29:17.780 - 00:29:56.534, Speaker A: Okay. Did you do. Oh, did you do a shootout before landing on svelte? So this is. I haven't done front end development in many years, partially because I don't really like doing front end development. I feel like I get bogged too much into, like, annoying details that don't matter, but I have to fix them. But I picked svelte just because I looked at the stack overflow survey results for the front end technology most developers wanted to try. And then I used that one.
00:29:56.534 - 00:30:23.980, Speaker A: That was felta, so I used it. That was the entirety of the decision making process. And, you know, I'm decently happy with the. With the decision matrix here. It's one of those cases where, like, when you have a lot of freedom to choose, pick semi randomly, and, you know, in this case, it was a sort of biased choice, but it was not worth spending a lot of time picking. It's the rust of front end. Yeah, basically.
00:30:23.980 - 00:31:05.954, Speaker A: All right, so let's start going through these questions. I see people are voting like crazy. One thing to keep in mind here is that the questions are ordered by number of votes, perhaps unsurprisingly, and that means that new questions come in at the bottom. I know there's a question in here about why are they ordered by votes, which is a good question, but you may want to scroll down to the bottom to see if there are interesting questions someone has asked that you want to vote up because you actually think you want to see me answer them. Is there a website to see the questions? Yes, there is. Boom. Okay, so first question.
00:31:05.954 - 00:31:56.772, Speaker A: 63 votes. Look at that. Go. Should rust be in university curriculums? So there's been a decent amount of debate about, you know, is rust hard to learn? And not just, like, if I'm an experienced programmer, but I want to start building my service in rust. But just like, if you're learning to program, is rust a good or a bad language to learn to program in? And I actually think that's a case where Rust is a pretty good choice. It teaches you programming in a way where you have to understand what's going on the way that C does. But it also protects you from a lot of the foot guns that the subtle foot guns that C has, where learning the foot guns is not that important.
00:31:56.772 - 00:33:01.712, Speaker A: It's not to say that rust is easy to learn, right? Like, if you do a language like JavaScript or Python, you might be easier to, like, get up and running faster. But I do think it teaches you a useful mental model as well. And I think it's slightly easier to learn rust if you're new to programming than if you are an experienced programmer, because there are fewer things that you need to unlearn in order to pick up rust. This is somewhat tangential to should it be in university curriculums? Because many students, at least in CS programs that are taking classes already, probably know some amount of programming. So the question is, is rust still a good choice for them or for that case? I remember at MIT there was one class that tried to pick up rust. I think it was a networking class, because someone had written a congestion control algorithm framework in rust, and I think as part of the coursework, they told people to implement a congestion control algorithm on top of that framework, which necessarily meant it had to be written in rust. And I think they had mixed success.
00:33:01.712 - 00:34:11.012, Speaker A: I think some students were pretty frustrated with the experience of having to learn rust as part of the class. And I think this is where it becomes tricky, where universities, at least in my experience, aren't great at teaching people. It depends where you look at in the process. If you're looking at the learn to program classes like intro to programming type classes, those are different from classes that teach other things, but the programming language is a choice in that thing that they teach. So for an intro to programming class, I actually think Rust could work really well for a class like introduction to operating systems or distributed systems or something like that. Requiring students to pick up a language like rust as part of learning all the rest of the material in that class may not be such a great idea, because rust does take a decent amount of work to learn. And ideally, you don't really want students to try to learn two unrelated things at once, right? They might actually understand the subject material really well, but struggle with the language, and that's going to impact their grades and stuff.
00:34:11.012 - 00:35:09.780, Speaker A: Which seems unfair, of course. There's sort of a cycle here where if you switch your integer programming classes to be rust, then you can switch more of your other classes to be rust because you can assume that they already know it. So there's certainly some. I don't want to say, well, there's sort of a dependency chain here that you need to get right. And I know there's also the rust education, which is doing a lot of really cool work here to work on university adoption of rust. I do think, though, that if I could sort of wave a magic wand and say, change all the classes as if they had been retroactively changed, I do think Rust makes a lot of sense for many classes, not for all. So, for example, I think for something like a system security class, I think you actually want to expose people to different languages because they have different threat models.
00:35:09.780 - 00:36:13.420, Speaker A: For something like a front end development class, I don't think you would start with rust for something like an AI machine learning class. I think Python is probably the way to go. Operating systems is an interesting one because I think you probably want to use c just because you want people to be able to directly use the things they apply or the things they learn later on. But at the same time, rust is going to make some of that operating systems work less painful. So I think it depends a little bit there on the structure, on the class and the nature of the class. What are you trying to teach? Are you trying to teach how to work in the context of a kernel or work on the kernel? Or are you trying to teach how do operating systems work in general? And now we're going to implement some pieces, in which case, like if you're using something like XV six, which is like the. Basically the teaching kernel, I think having xv six be in Rust and then tell people to do their labs and such by implementing features for XV six and have that all be in rust might actually be pretty reasonable.
00:36:13.420 - 00:36:46.008, Speaker A: And yeah, I know there's been some adoption already. Like it's, it's being used. I think Stanford is using it for some of their classes on like, systems programming. MIT, as I said, was doing it a little bit for networking. I know there's been some work looking at using it for operating systems. Someone in chat says that they're using it in their intro to computer graphics. So I do think there are places that are starting to adopt it, but it is a slow going.
00:36:46.008 - 00:37:43.652, Speaker A: And part of this is, from the university's point of view, you don't want to teach people something that's like, not likely to be a long term good investment. This is similar to something like writing a book. The moment you put something on paper, you want to make sure that what you put on paper is going to last for a while. Otherwise, you don't really want to reprint books all the time. And courses at universities, even though you can change the course from year to year, the students that take the course, you want to make sure that the knowledge that they accumulated actually is useful to them for a long period of time. Now, I happen to think that even if Rust, the language doesn't end up succeeding, learning Rust is probably still valuable, because, at least to me, it's taught me things about how to think about how programs work, that I can apply to other languages, too. Yeah.
00:37:43.652 - 00:38:25.130, Speaker A: So there are a bunch of people in chat here saying that they've experienced using it in their classes, that some parts are hard, some parts are easy, which is totally true for security work. Rust is interesting, but I don't think you want it to be the only language. Um, so C. C is an alternative to rust for. For some classes where, you know, you could argue, well, people use c in the real world, so therefore, using C in this class makes sense. I don't think that's a good argument. I think we're seeing a decrease in adoption of c.
00:38:25.130 - 00:39:11.114, Speaker A: We're seeing not just rust, but other languages, like go, for example, as well, started being picked up more in spaces where people were using c and C. And so I don't actually think you should invest more into C education unless the problem domain specifically makes use of C. So that's going to be kernel stuff, hardware stuff, embedded stuff, although rust is doing really well there. Um, but apart from that, I don't see a compelling reason to. Oh, perl in the curriculum. That's pretty. Actually, I had that, too.
00:39:11.114 - 00:39:27.378, Speaker A: I had a prologue in my curriculum. That was something. It was pretty fun. Yeah. So. So, for example, in Os course, it starts in C to show how the. The stuff currently works and then moves to rust for implementation work or complex systems.
00:39:27.378 - 00:40:01.840, Speaker A: Seems like a pretty good idea. Okay. I think that's. Oh, yeah. And game engines, a lot of game engines are heavily C based, and I think this applies to consoles, too, where you don't really have as much of a choice for language, but that, too, is changing. Right. So you have things like embark studios and Bevy, where I think we are going to see more and more games not being written in c and C, and that's pretty exciting, or c hash, for that matter.
00:40:01.840 - 00:40:49.650, Speaker A: Okay. Would you consider limiting votes by IP to make it harder to manipulate? No. I would note part of the problem with using IPS is because of nats, this would end up causing, say, multiple people are connecting from the same home, or multiple people who are at the same university, to end up not being able to vote more than once. And I don't think that's worthwhile. It also significantly complicates the backend, because now I need to keep track of every ip that's voted, and a, I don't want to store that information, and b, that's much more complex logic. And I just don't think it's worth the upside. Like if someone's just like spamming up votes for something, I can always just hide the question.
00:40:49.650 - 00:41:31.170, Speaker A: Like for example, with this question, I have a suspicion 68 people did not vote for it, but I can just not read the question. It's fine. Remember, this is designed for use by a human, right, so there's going to be a human decision making process as part of this anyway. And so skipping questions is not that hard. It is true that you can imagine someone actively spamming this and you don't really have a way to block them. I don't have a great solution for that. You could imagine that there was a sort of block this IP kind of button, but I really don't want to go that route, and until there's a serious demand for it, I think I'm going to just not do that.
00:41:31.170 - 00:43:02.010, Speaker A: How do you think gats will shape the standard lib in the future? So gats here, generic associated traits. I think what we're actually going to see is very slow adoption of gats in the standard library. And part of this is because it's such a new feature that I don't think as an ecosystem we best know how to make use of it. So the challenge here is if the standard library just decides that, oh, we should just take borrowing iterator, we should just stabilize it, we got it figured out, it's easy, it's just this signature, you could do that. But as with many of the other things that have made it into the standard library, the way we got there was through ecosystem experimentation of people developed crates that use the features from the language to basically prove out designs, prove out how to get the best ergonomics, how to get the best performance, how to get the best backwards compatibility over time. I think we're going to see the same thing here. We're going to see crates crop up that make use of gats to make better, more ergonomic, more powerful APIs, and the ones that emerge as being good designs, worthwhile designs, and things that actually should be in the standard library, which, remember rust, standard library is pretty small.
00:43:02.010 - 00:43:37.840, Speaker A: We've talked about this before. It's deep but narrow, and many things just shouldn't be in the standard library at all. They should just stay in separate crates. And given how easy it is to work with separate crates in rust, I think that's pretty compelling. So I actually don't think we're going to see a sort of rapid adoption of gats in the standard library. In fact, I think it's going to be very slow, and I think it's going to take quite some time before we see the first one. And even then, let's say, the time until we get to, say, ten of them, I think, is actually going to be maybe on the order of years.
00:43:37.840 - 00:44:53.074, Speaker A: Let's see. Oh, yeah. And also keep in mind that what was stabilized was sort of a minimal version of gats, so there's still a bunch of restrictions on them, that those restrictions don't matter always. But for something you standardize in the standard library, you don't want to standardize something that is subject to a limitation that it turns out you can't remove in the future. So that's even more of a reason to have experimentation in the ecosystem before, and potentially having gats improve in their flexibility and their expressive power before we end up stabilizing something, because it might be that we can then stabilize something better. Of course, there's this endless cycle of when have we experimented enough? And you can rehash that argument as much as you want, but realistically, often I think it becomes pretty clear when a design is just ubiquitous, everyone just goes, this is what we should use and stabilize. Not always.
00:44:53.074 - 00:45:41.366, Speaker A: Sometimes we get it wrong. But I'm not too concerned about the setting a time ahead of time. All right, how good are you at solving algorithmic problems that is leetcode? Okay, I. This is maybe one of my big hills to die on. I think leetcode is really stupid for evaluation purposes. I think it can be a lot of fun, right? So you can use it as basically the same as brain teasers, right, of, here's a fun little puzzle, try to solve it. The problem comes up when it's used for evaluating things like job applications, which is the primary place that ends up being used there.
00:45:41.366 - 00:46:18.120, Speaker A: I think it's actually extremely counterproductive. But for solving these puzzles, it can be great fun. I remember I was in a programming competition. Me and some lab mates signed up for last minute back in Australia, and I wouldn't call them leetcode questions, really, but it was things like the questions were framed in such a way that it turned out that the solution was you had to invent ray tracing. And that was really fun. It was a really fun experience to try to come up with this algorithm on our own. That turned out to be a real algorithm.
00:46:18.120 - 00:47:05.630, Speaker A: But, yeah, I'm not a huge fan of leetcode becoming a benchmark. And as for the question of how good am I at them, I don't think I'm particularly good at them. And I think part of the reason for that is there's two ways you can go with leetcode. The one is, you know a lot of algorithms, and therefore you can solve a lot of leetcode problems because you can quickly identify the algorithm, and because you know the algorithm, you can just type it up. The other one is, you don't know a lot of algorithms, and so you need to figure out the algorithm on the fly. The first one of those I'm terrible at, because I don't believe in memorizing algorithms. I think it's a terrible idea.
00:47:05.630 - 00:47:29.846, Speaker A: I don't think it's actually valuable. And therefore, I don't really know many algorithms. I know of them. I know their structure and their implications. Often, I know when you would use, say, you know, a tri versus a b tree, but, and I know that those two things exist, but I don't know how to implement one. Right. Same with a red black tree.
00:47:29.846 - 00:48:09.840, Speaker A: I know roughly what it does, and I know roughly why you might want that kind of implementation. The implementation I don't have in my head, because I don't see why I would. But in terms of coming up algorithms on the fly, I think I'm a decent at that. I don't think I'm, you know, I don't think I'm going to write papers about inventing algorithms anytime soon. But those kind of like puzzles I enjoy and I think I'm decent at. In an interview context, though, I'm sure I would mess these up. And I've, you know, I've had that experience before where I'm asked a question and I just have to make up an algorithm, and I couldn't think of a good algorithm, so it ends up like some n squared mess.
00:48:09.840 - 00:48:57.616, Speaker A: Yet another reason why they shouldn't be benchmarks. Interview systems are broken due to leetcode. Interview systems are broken for a lot of reasons. Leetcode is one of them. But like, there's some serious other problems too. Like, you know, one challenge that I run into a lot is having to, for the lack of a better word code under pressure. And this is a similar problem to what we have with exams at universities where they're not actually measuring anything that approximates real world experience.
00:48:57.616 - 00:50:07.112, Speaker A: Right? So at what point in your life are you going to be like, put in a room, you're not allowed to talk to anyone, you're not allowed to look anything up, and you have to solve a bunch of problems that just doesn't happen. Right? In general, when you're in like real life and working, you're going to have colleagues you can talk with, you're going to be able to look things up online, you're going to have a compiler you can work with that's going to tell you if you mess something up, you're going to be able to run your program over time, write tests, see how they work, run a debugger, all of these things just in an interview setting, you can't do, in an exam, you can't do. And it's stupid. It measures a completely separate set of skills that I think are barely correlated with the things you actually want to measure in an interview. And so you get into questions like, okay, maybe take home exams or take home interviews, maybe instead of having like write me code on a whiteboard, have it be help me design how you would approach this problem, help me explore this problem space. But it's a difficult question. I don't have answers for how we should do them.
00:50:07.112 - 00:50:39.826, Speaker A: I just know that what we're currently doing is broken. Yeah. Someone also points out that, which is entirely true as well. The kind of questions people ask in interviews are often not the kind of questions you have to tackle in real life. Leetcode is a particularly bad example of this. Right? Like, when are you ever going to be asked at work to implement a red black tree? Never. You should rather use an implementation that's like battle tested and optimized and everything, right? You shouldn't just write your own.
00:50:39.826 - 00:51:21.624, Speaker A: That's usually a terrible idea. But this applies more broadly too, right? For an interview, often at least you're asked a question that has to fit within the timeframe. It might be something like, I don't know, write me a framework for doing structured logging and start from scratch and we'll see how far we get. That problem is a really interesting big topic. There's a reason why the tracing crate, for example, is fairly complicated and convoluted internally. The interface, arguably, too, but it's a major piece of machinery. It's a complicated design.
00:51:21.624 - 00:51:53.934, Speaker A: It has a lot of subtlety to it. But when you're asked to solve it in the context of an interview, you end up doing the work in a way that's scoped to that timeframe. And it just doesn't, it's not going to match the way you would approach the work outside of it. You might actually go, like, go for a walk for 2 hours to think about the structure of the problem. Or I. You might be asked questions that are. The questions are so small that they wouldn't actually be like your task for the week or something.
00:51:53.934 - 00:52:14.548, Speaker A: So I don't know. I think this is difficult. The pro of leetcode is that you can prepare for them. I don't think you can either. There are too many algorithms, so it's bad. It's just really bad. I don't think you can study for them either.
00:52:14.548 - 00:52:57.944, Speaker A: Or if you can study for them, then they're even more useless because it means that the pool they're selecting from is just like a big overlap with a list that's publicly available. At which point what are you actually measuring? You're measuring the overlap of the list the candidate knew about. Did you interview with algorithms for your Amazon job? Yeah, I was asked to implement Quicksort. I was so mad. I also, at the time, wasn't allowed to use Rust because the editor, I don't know whether it's the interviewer or the editor or both, didn't support rust or didn't know rust. And so I had to, like, I ended up having to write quicksort in like pseudo Python. It was.
00:52:57.944 - 00:53:39.940, Speaker A: It was terrible. I got the job in the end, so I'm happy. But like, yeah, not good. Recruiters say that it allows them to narrow down the candidate pools because they have something to benchmark against. So this is a common observation that it lets you do basically automated filtering of candidates. If you get 1000 applicants for a job, running all of them through a reasonable interview loop with a human is tricky. Whereas if you just say, here's a coding problem, everyone's going to do like, online assessment, and then we're going to look at the code you submitted.
00:53:39.940 - 00:54:30.110, Speaker A: It's true that it scales better. I don't think it leads to you hiring the best candidates. So if that's what you care about. I don't know that this is the way to go about it, at least not if they're leetcode questions, and then of course, the question is, well, if they're not leetcode questions, what's the benchmark? What do you evaluate them against? And I think even there you can train people to review code, and this is arguably what engineers do as part of their job and just give them something that's not a leetcode problem and then just have people review their code. Oh, yeah. Not to mention real time interviews make people nervous, which can make really great engineers be terrible in an interview setting. And that's not great either.
00:54:30.110 - 00:55:16.610, Speaker A: Okay. You can measure how much someone wants the job. I don't think you measure that either, because there might be people who want the job, but they're not great at memorization, and that doesn't matter that much in programming. It might also be that candidates don't actually want your job. They don't care that much, and it shouldn't be a requirement of the job that the person passionately wants to work for you. I don't think that leads to a selection of good candidates, necessarily. It matters much more, for example, whether they care about the problem domain you work in rather than them being passionate about your company.
00:55:16.610 - 00:56:15.350, Speaker A: Google and AWS said that the algorithm interviews won't help you out on your day to day job, but it's a fairly good indicator that someone who can solve the algorithmic questions are reasonably decent engineers. I think that's wrong in both directions, actually. I think being good at leetcode style questions does not mean you're a good engineer, and many good engineers are not good at leetcode questions. So you get false positives and false negatives, and I think you get a decent amount of them. I actually think the correlation is not very strong. But also measuring the degree to which the correlation is good is really hard because you don't have the counterfactual recruiters told me they're okay with losing a good candidate as opposed to hire a bad one. Yeah, that's true.
00:56:15.350 - 00:56:49.726, Speaker A: The cost of hiring someone who does a poor job when you hire them is very high. I don't think lead code helps with this. I don't think if the way we currently evaluate candidates actually helps at all, I think it makes it more likely that you're going to hire candidates that turn out to be bad engineers. They were only good at leetcode, so I think you can still make bad hiring decisions this way. So again, it gives you false positives and false negatives. True correlation is often useful. Correlation is useful.
00:56:49.726 - 00:57:28.980, Speaker A: I'm saying I don't think there is a correlation or the correlation is really poor. Okay, let's move on to the next question. Are you doing advent of code 2022? A stream of idiomatic resolutions might be fun. I get asked this question basically every year and I don't think I'm going to do it. And it's not because I dislike advent of code. It's just because I don't have the time. I think I did advent of code one year like four years ago or something, not as a stream, just for myself.
00:57:28.980 - 00:58:11.120, Speaker A: Give me that much. And I have so many things to spend my time on that I don't think that's a good use of my time. It might be an interesting stream, but I have so many other things I want to stream that I think are higher value. So I don't think I'm going to do advent of code. And not to mention I'm sure there are lots of other people who will be. And so I don't know that I'm a the me doing one would add a sort of unique selling point. I'm not under no illusion that I should be the only person streaming rust code or rust programming or rust things.
00:58:11.120 - 00:58:56.320, Speaker A: I don't think that's true at all. I would love to see more people teach and do streams, and I think admin of code is a great thing for other people to stream. And that way I can drive viewers over there too. Okay, what are the best technical books you've ever read? Hmm. The best technical books I've ever readdeveloped. It's a tough question. It also depends on what you mean by technical.
00:58:56.320 - 00:59:42.940, Speaker A: I assume you mean related to programming. Let me see, actually what I might have here. I'm just gonna, I'm gonna check my, my goodreads because I think I've logged all of them there. My books read, apparently I've read exactly 100 books. So I read this book called Rust for restations, and I thought it was pretty good. But otherwise, let's see here. That's not a tech book.
00:59:42.940 - 01:00:16.750, Speaker A: That's not a tech book. So I thought the art of Unix programming was pretty good. I don't love the author, but I like the book. I think it's a decently worthwhile read. What else? The code book, I think is fantastic. It's not directly about programming. It's about how like ciphers and encoding and decoding and stuff works.
01:00:16.750 - 01:00:58.190, Speaker A: And it's by Simon Singh. It's also really, really good. I don't know that I've applied that knowledge in a lot of places, but it was a great, it was really well written and it was an interesting read that I think taught me more about how to think about basically cryptography. The programmatic programmer, I think is also really good. There's a new anniversary edition out. I don't actually know what's changed in the anniversary one, but I liked it a lot. That's also not a tech book.
01:00:58.190 - 01:01:35.640, Speaker A: Let me see what else I have. So there's a book called Hacker's Delight, which is by Henry Warren, and it's this one. So hacker's delight is it has like. I don't know, I don't know that it's useful, but it's a very fun book to read about. Like, basically ways to make computers do weird things. Like how can you do. Let me, let me find a random page here to give you an example.
01:01:35.640 - 01:02:56.360, Speaker A: Using bit shifting to convert to exact division, signed division by divisors that are less than or equal to minus two, using assembly. Like, it's just a very, let's see, counting trailing zeros using various techniques, finding coordinates from distance along the Hilbert curve. Like, it's all just like floating point specifications. Like it's a very, very low level book that I still haven't read all of, but it's a fun place to just like look up what a weird tidbit or weird algorithm or cool insight into, like, you can abuse the cpu instruction this way if you're into like, operating systems work. I also really like this book, which is basically like how the BSD kernel works. Also one I haven't read all of, but it's a. Because it's a fairly, like, I mean, it's basically a technical manual, but it gives you a really good overview of how modern operating systems do things, how they're designed.
01:02:56.360 - 01:04:05.770, Speaker A: I think those are the only ones I would say are like good ones that I would actually go through and recommend. I, I think for a lot of technical reading, I actually prefer just keeping up with things like blog posts. I think a lot of interesting content comes up there and it tends to be more up to date. And honestly, Twitter, and it's now many replacements is a pretty good place too to learn technical tidbits that otherwise you might get from books. Yeah, and there's a lot of online resources here, right? Like the Philip Opperman's operating systems blog post series learning rust, with entirely too many linked lists. I feel like I had another one that came up recently. There's a bunch of these like online semi books that I think are also really, really useful.
01:04:05.770 - 01:05:15.700, Speaker A: Oh, the freeBSD book is called the design and implementation of the freeBSD operating system. The other thing I would recommend is reading research papers, actually, it can be a really interesting view into a somewhat different world of bleeding edge work. Or if you look at a test of time papers, things that were really substantial innovations that have stood up over time and have turned out to be really, really valuable. And I think that's worth. It's worth digging a little bit into that world. It's a different kind of writing, and you kind of have to learn how to read them well, but I think you'd be hugely valuable. Let's see.
01:05:15.700 - 01:05:41.548, Speaker A: What's your take on carbon? Do I know what carbon even is? I don't think I know what carbon is. Programming language. I feel like I've heard of this as a programming language, which is to say, I know nothing about it. So I'm going to go with. I don't have a take on it. The project is open source and was started by Google. I have fairly little faith in alternative languages.
01:05:41.548 - 01:05:56.950, Speaker A: Started by Google. Cdart doesn't even have a 1.0 yet. Yeah, I have. No. Take the new Google programming language. Yeah, I have little faith.
01:05:56.950 - 01:06:45.940, Speaker A: Do you know any good Pytorch like ML frameworks in Rust? No, I do. Basically no machine learning, so I do not. Do you think Rust has its place in high performance computing as a replacement for C, C and Fortran? As a replacement for C and C, yes, as a replacement for Fortran. That one's harder because, like, if you think about it, C and C didn't manage to displace Fortran. Right. And I don't know that Rust has something that makes it likely to be able to replace Fortran either. So Fortran, I think, might just be with us for a while.
01:06:45.940 - 01:07:44.240, Speaker A: The other thing that comes up in HPC is that there are a lot of just heavily optimized libraries that someone would need to port. And traditionally, because they're such high performance things, porting them is fraught with dangers. And so I think it's gonna take longer, actually, even though rust, I think, is a very good candidate here. I think it's a subset of the world where it's harder to get in because it's a fairly strongly connected space where you kind of need all of the parts to be available to you in order to be able to use a new language. But I think we're going to see a trajectory in that direction. I think we are seeing it already, but actually seeing full uptake. I think it's going to take a while just because of dependency closures.
01:07:44.240 - 01:09:24.230, Speaker A: What other language pairs well with rust? Pairs well with the rust? Depends what you mean by pairs well with. I mean, webassembly is arguably my first thought here, and therefore JavaScript, that does work really well together. In general, I've seen a decent amount of people having success with Python rust interactions, often in the case where they build some core of their application that's particularly performance sensitive in rust, and then they expose Python bindings to it. This is sort of what python cryptography ended up doing, where I think part of the sub modules I think used to be written in c and are now written in rust. The Python rust binding space is in a decently good position. What else do we have? I think those are the two that immediately come to mind. I mean, c is the sort of obvious ffi one, but I think Python and JavaScript are probably the main ones that I would say pair well with Rust.
01:09:24.230 - 01:10:44.992, Speaker A: If you weren't a coder, what would you do as a career? Ooh, what would I do if I weren't a coder? I think it would be something in the gaming industry, maybe in the board game industry, I don't think I could be a professional DM well, maybe, but like, I might end up, I might have ended up being like a board game designer or something. Like, I think that's a passion that I haven't explored enough. Alternatively, it could be that I would end up as a teacher. I do get a lot of joy from teaching independently of what it is that I teach. I think that's a decently likely candidate. And if not either of those I've discovered that I really like. I guess puzzles is the right word, but I don't mean it in the sense of, like, I don't mean it in the sense of like brain teasers.
01:10:44.992 - 01:11:22.980, Speaker A: I mean it in the sense of figuring out how things fit together. Like, I remember even as a kid, I would like take things apart just to see what the pieces were and what they all did and how they work together. And I think it's one of the reasons why, you know, for some reason I get fascinated by games like car mechanic simulator. Like, I think it's really fun to just like see all the pieces that I hadn't thought about before and what they do and how they interact. Maybe I'd be a car mechanic, I don't know. But I think something like that is probably like one of those directions. I remember when I was a kid, my mom asked me what I wanted to be when I grew up.
01:11:22.980 - 01:11:58.104, Speaker A: And I think I told her I wanted to be an air hostess. Not air hosts or steward or something. Air hostess, a blood donor and a subway driver. Like, I want it to be all those three things at once. I have no idea why those three, but that was what I was gonna be. Camera. Microphone will shake.
01:11:58.104 - 01:12:08.800, Speaker A: I think it's. I think the stabilizer. I need to improve the. Or increase the stabilization a little bit. It's very sensitive to. If I like, wiggle my feet or something, then the. And the desk moves.
01:12:08.800 - 01:15:01.930, Speaker A: Then the camera also shakes. Alright. Actually, I'm gonna take a quick bio break and I'll be back. Give me two minutes. I'm back. And I brought a cat. At least assuming you can find me, you can see me.
01:15:01.930 - 01:15:37.380, Speaker A: So you want to say hi? You want to say hi? What's the Internet? All right, all right, all right. Oh, you can't see me. Oh, no. How about now, Lisa? Here we go. Now maybe look. Yeah, it's the Internet. They can see you right in there.
01:15:37.380 - 01:16:07.380, Speaker A: No, not in there. Where are you going? Where are you going, you little baby? There we go. Yeah, you're a celebrity now. You're very cute. Okay, bye. Yeah, you can leave here. The door is open.
01:16:07.380 - 01:16:34.656, Speaker A: So we have two cats, as I think many of you know, and. Oh, another damn bot. So we have two cats, Chai and Miso. That was Miso. Miso is not very smart. Chai is decently smart. Chai knows how to open doors both by pushing and by pulling them open.
01:16:34.656 - 01:16:52.510, Speaker A: Miso does not understand that doors move. She will just like the door was like, not. Not even closed. Like it was like a jar. And she could probably even push her way through, but she just like sniffs that and goes, well, I guess I'm trapped here. And then just waits for me to come open the door. It's very sad.
01:16:52.510 - 01:17:11.550, Speaker A: Which I will sometimes come help her. Okay, let's see here. Oh, not the right scene. Now it's the right scene I keep doing. No, that's. Yeah, that's the right scene. I keep choosing the wrong scene.
01:17:11.550 - 01:17:22.770, Speaker A: It's very annoying. I pressed. Yeah, yeah. But at least now you should see me full screen. See if I can grab me. So again you can see you're even better. Miso, come on.
01:17:22.770 - 01:17:38.080, Speaker A: Yeah. Hi. Come on. Yeah. Okay, now you're full screen. There you go. No, over there.
01:17:38.080 - 01:18:06.622, Speaker A: Should I hold you like a baby? Because you are a baby. Where are you going? All right, all right, all right. Here you go. Right. Thank you. And then here we have cheery, pretty. You're looking the wrong way.
01:18:06.622 - 01:18:35.420, Speaker A: Then you turn it the other way. Yeah, that way. You're curious about what she's doing? Yeah, she's sitting up on the D and D box. Where are you trying to go right now? Where are you trying to go? You can't go down there. You trying to get to the microphone? This doesn't look very comfortable. All right, here you go. Great.
01:18:35.420 - 01:19:00.674, Speaker A: Amazing. Now you've seen both chai and Miso, and in theory, full question. Okay, she's trying to answer my questions. Yeah, it's true. All right. And you finally got to see them full screen. Hi, John.
01:19:00.674 - 01:19:51.960, Speaker A: I'm starting with rust, and I'm new to programming in general. I've done some c in python. I want to ask you, how important are data searches and algorithms, and how should I start practicing and learning them? So this is Miso decided to lay down on the printer. I don't know if I can easily show you this. It's very cute. Yeah, you're very cute, niselle. Very cute.
01:19:51.960 - 01:20:15.490, Speaker A: Okay, let's see. The printer is made of worm. Yeah, it's true. All right. You don't have to eat my microphone. Boom. That's okay.
01:20:15.490 - 01:20:59.446, Speaker A: Yeah. I think this is an artificially boosted question, but that's fine. In this case, it's one worth answering. It's similar to the leetcode question, which is really just, I think I would say data structures and algorithms are important to know of and about, but it's not important to know how they work. At least that's been my experience. You should know the difference between, say, a b tree and a hash map. You should know roughly how do they differ? When do you choose between them? How do you choose between them? What are their relative costs and benefits? And you should know of their names so that when you're developing, you know what tools to reach for.
01:20:59.446 - 01:21:22.264, Speaker A: But I would think of them as exactly that. They are tools you can reach for. They are not tools. You need to know how to make yourself, because generally you shouldn't be. You shouldn't be like, you should know that there's a difference between sorting algorithms and some are better than other. Do you need to know the implementation details of tim sort versus quicksort? I don't think so. And in general, you shouldn't even need to know which sorting algorithm is used.
01:21:22.264 - 01:22:19.630, Speaker A: You should just be able to call, like, dot sort on a slice and assume it does the right thing. But, like, sometimes it's useful to know that merge sort is a thing because you can do it better in parallel. Sometimes you should be like, oh, actually, because I'm always going to need this data in sorted order. I'm going to keep it in a b tree map instead, because that way it's always sorted. So it's more of a know what tools are available to you as opposed to know how all of them work. As a student who has contributed to large open source projects the last couple of years, can I apply for senior engineering roles? In what sense is open source work comparable to professional experience? I wish I had a good answer for this question because it's something I ran into as well. When I was applying for work straight out of my PhD.
01:22:19.630 - 01:23:19.730, Speaker A: I didn't really know what level I was at as far as industry was concerned. And now that I've been at Amazon for a few years, if anything, I feel like I have less of an understanding. I understand how Amazon tends to view people coming out of academia at different levels, but I don't have a good sense for the industry as a whole how they think about things like senior engineer, what that means. I don't think, say, a senior engineer at Amazon is equivalent to a senior engineer at some random startup. That's not to say that they're necessarily worse or better, it's just the standards are different. What you're evaluated on is different. And so this question is a little underdefunctioned just because it's going to depend on where you're trying to apply for a senior engineering role, both in terms of where, of what company, what industry, and what part of the world.
01:23:19.730 - 01:25:20.080, Speaker A: It also depends on what you mean by contributed to and what you mean by large open source projects and what you mean by last couple of years, right? If you've been like the maintainer of, or a co maintainer of OpenSSL and curl for the last 15 years, that's pretty significant. If you have sent some prs to like, let's go with like Neovim and Rustup, and you've done that for the last two years, that's not going to count for much. So there's a very broad span here in trying to give you an answer. If I had to give a general answer here, my take is that open source experience is going to require you to be able to articulate the degree to which has given you senior engineering experience. A company is generally not going to look at that and look at your open source contribution history and go, this makes this person a senior engineer, but you might be able to use it as evidence for why you should be, but it requires more work on your part. So as an example for interviews at Amazon, and all of this is publicly documented in the recruiting packet that sends to candidates and stuff, you're asked a lot of they're not behavioral questions as much as they're like evaluation of leadership principles is what they call them. And you're supposed to basically give, you're given a prompt, like tell me about a time when you faced a trade off between two major project directions and you made the decision to take one over the other.
01:25:20.080 - 01:26:18.082, Speaker A: And the idea is that you need to be able to come up with a convincing response. You need to come up with evidence for, or you need to be able to describe the situation, describe what evidence you had available to you, what action you took, why, what the outcomes were. And if you can do that using open source work, then I think it counts just as much as industry experience does. But oftentimes it can be hard to make open source work quite fit into what companies are looking for. So that's why I say it depends on your, basically your ability to sell your own work here. And senior engineer at one of the big tech companies, I think is harder to swing with just open source experience. It's not impossible possible, but it will require that you have some pretty solid work to point to.
01:26:18.082 - 01:27:43.250, Speaker A: A couple of PRS is not going to cut it. As someone points out in chat, too, one of the things that senior means, again, this is why it varies by company. But senior tends to mean that you're taking on work that is not just programming. It's not just you're a better programmer. In fact, very often a senior engineer isn't necessarily a better programmer than an engineer or a junior engineer. It's more about the other things that you do. And that can be things like how good are you at seeing the long term implications of a design decision? How good are you at doing design work or architectural work for a potential solution? How good are you at evaluating the tradeoffs, short and long term, for a set of decisions? How good are you at mentoring others? How good are you at dealing with ambiguity in your work? So there's a lot of that kind of stuff beyond programming that goes into senior that with open source work, you can get experience in that, right? If you can point to, you know, you did a bunch of mentoring in open source, you did a lot of, you know, public architectural design work in open source.
01:27:43.250 - 01:28:42.700, Speaker A: Those are valuable things to point to. It's not just about the coding, but very often, like when you say, you know, contributed to large open source projects. If your contributions are mainly prsitive, that might convince them that you're a good programmer. It's not necessarily going to convince them that you are senior. Okay. Do you think there are fundamental missing features from rust that cause macros or repetitive code to be constantly required? If so, what are they? I think Const generics was this for a while? I think another candidate here is support for custom test suites or custom test frameworks. But apart from that, I think macros are a feature.
01:28:42.700 - 01:29:57.670, Speaker A: Macros keep getting a bad rep for being the sort of cheap way out. They're like the copy paste solution to programming, and I wouldn't actually think of them that way. I think macros are a tool like any other tool you have in a language. And maybe what the question is getting at is, are there places where macros is a suboptimal tool? Like macros is a sort of crude tool, and we could hope to have something that's more specialized. And you know, I think, um, good examples of this are custom test frameworks, const generics, which now are a first class feature, and maybe something around delegation and new time wrappers, like if you want a new type wrapper that just delegates to the inner type. And so you have to like implement a bunch of traits just to do the forwarding and you have to do this for multiple types. It's totally true that for those things, first class support in language might be nice, but I don't think macros are a sort of problematic avenue to solve those problems.
01:29:57.670 - 01:31:00.570, Speaker A: So I don't think they're fundamental missing features as much as there may be things we could do to make. You have to reach for the general purpose tool of macros less often. And the reason why that's advantageous is one sad property of macros is because they're so generic, because there's so general purpose. It's also harder to write things like tooling for it or good diagnostics because they really are just token manipulation. Whereas if you have a feature in the language, your editor can be aware of how that feature works, the formatter can be aware, the compiler can be aware, the borrow checker can be aware, and so having it be a FIR, having this be first class can be helpful in these cases. Yeah, variadics ZL1 like very variable length arguments, although even with macros that one's hard to solve. Is rust worth it for small projects, less than 1000 lines? My experience is that implementing something in, for example, Python is quite a lot faster.
01:31:00.570 - 01:31:24.886, Speaker A: I think that's because you're more experienced with Python than you are with rust. I can write rust projects very quickly, but it's because I've been doing a lot of it. I'm very familiar with the language. So when you say worth it, it depends what you mean. Worth it in the sense of the time it costs you to learn the language. No, worth it in terms of the speed up you get for the program. Depends on what the program does.
01:31:24.886 - 01:32:16.102, Speaker A: If what the program does isn't speed sensitive or performance sensitive, then you can write it in any language. Write it in whatever you're most proficient in. But if it is performance sensitive, then absolutely, write it in rust. If rust is the language you're most proficient in, then, yeah, write it in Rust because it's the one you're most proficient in. If you are a Python programmer and you're considering learning rust in order to write a small project, probably not, unless it's performance sensitive or if you expect that it has to do interfacing with other languages. For example, there is also a case for use rust, so that your program is more type safe, at least in my experience. Writing rust is nicer than writing Python because the type system helps me.
01:32:16.102 - 01:32:46.376, Speaker A: Um, and. But there it comes down to, like, how familiar are you with each language? And it becomes a trickier trade off. It also depends a little bit, as someone said in chat, on the kind of dependencies you need to take. Right. Not everything is going to be available as crates on in rust, but for Python, there are, you know, packages for most things by now. But I think these days, I. It's pretty likely that you're gonna be able to find whatever you need as a dependency in rust.
01:32:46.376 - 01:33:13.370, Speaker A: Two. Are there more doors or wheels in the world? Yeah. So I love these kinds of questions. Doors or wheels. Depends what you count as a wheel. Depends what you count as a door. Like, for example, is the opening mechanism for a mailbox.
01:33:13.370 - 01:33:58.886, Speaker A: A door for wheels are ball bearings wheels. So, like, I mean, this is, in some sense, part of the question. My inclination here is to say that there are more wheels because many things have many, many, many wheels, and there aren't that many buildings, but, yeah, I think, you know. Yeah, exactly. Like, do wheels have to have holes? Do doors need to have handles? Like, it's really just an underdefined questions. Yeah. So someone says, you know, most cars have more doors than wheels.
01:33:58.886 - 01:34:32.290, Speaker A: That's true. But also, are gears wheels? Because if so, there are a lot of gears. Just think of every watch. So, like, you know, I think and wheels and assembly lines. Also true. So my inclination here is that the multiplication factor for wheels is higher than for doors. So even though there are more things that have doors, and there's a small ratio difference in favor of doors on those things, some things have just, like, orders of magnitude more wheels, and that makes up the difference, I think.
01:34:32.290 - 01:34:52.944, Speaker A: Cell membrane doors. No, no, no. Is the steering wheel a wheel? Yeah. Also a question. Wheels under chairs. Yep. Eyes in the doorway to the soul.
01:34:52.944 - 01:35:16.160, Speaker A: There are a lot of eyes, if you start counting, like insect eyes. That's true. I'm gonna mark that as answered, even though there's not an answer. Plans for 2023. Another book. More time for more streams. Okay, so my most immediate plan for next year is probably moving to Europe.
01:35:16.160 - 01:36:20.490, Speaker A: The plans aren't fully settled yet, but the way I'm currently planning things is to probably move to Norway around summer of next year, which I'm very, very excited about, I don't know whether that will be the exact time. I don't 100% know it will be Norway, but probably both my partner and I have some reservations about moving to Norway. Again, we have different reservations, so I'm worried that Norway is still a little too okay. The crude way of saying this is small and boring. I don't think it's actually small or boring quite as severely. But one of the reasons I moved away from Norway was because I wanted to go places where I could see more things, have more experiences, interact with bigger, more impactful stuff. More people, more companies, more places.
01:36:20.490 - 01:36:59.580, Speaker A: And so going back, I worry I would end up in a situation where I have that desire again and would want to move away at the same time. Norway, and Oslo in particular, has evolved a lot over the past ten years since I moved away from there. So I think there's a decent chance that I will. That those things will bother me less now. There are also things that I value more in life now than I did then that might counterbalance that. For my partner, who's from the US, I think the concern is more around language. They'd have to learn Norwegian, and around Norway is kind of cold and dark.
01:36:59.580 - 01:37:43.278, Speaker A: You need to figure out whether you can live with that, especially in winter. Can you find ways to enjoy winters? And if you can't, then you're not going to like Norway. So I think realistically, what we'll do is probably move there for a year or so, and then if we enjoy it, then stay. If we don't, then maybe move to London and try that instead. I'm not planning to write another book next year. Um, at some point I'll probably write a sort of, you know, second edition or, or, you know, second revision maybe, of rust forestations. You know, there's some things that have stabilized since, there's some rfcs have been posted.
01:37:43.278 - 01:38:23.174, Speaker A: There are some things that might be updated. Not gonna be like a major rewrite or anything like that, but I don't think it's gonna be next year. I do hope that, well, so more time for more streams is unclear. One of the things that I really hope to do is once I move, I'm suddenly allowed to have a Patreon and GitHub sponsors and stuff, so I might set that up and see how far it gets me. I do have this longer term goal to be able to just do teaching and open source stuff full time. I don't know whether it's feasible. Maybe what I'll do is some kind of like part time thing.
01:38:23.174 - 01:39:16.400, Speaker A: But that also depends on how well funded I can be through basically contributions from people. I honestly don't know where that's going to take me, but it's going to be a sort of longer term plan. I don't know that next year things are going to change dramatically. More time for more streams is also, it's only, it's mostly bounded by time I spend on work. I do have a hope that I'll be able to spend more time doing streams as basically a part of my position at Amazon, not as Amazon sponsored work necessarily, but that I'll be given basically more leeway to do my streams because it also benefits people using rust at Amazon. So we'll sort of see how that progresses. I don't have a great sense of where that's gonna go yet.
01:39:16.400 - 01:39:34.172, Speaker A: Yeah, and I definitely miss, yeah, I miss viking raids. That's right. And yeah, I am norwegian. I grew up in Norway, in Oslo, glorious Sweden. Ha, ha ha. No, no, no. Norway all the way, man.
01:39:34.172 - 01:40:57.010, Speaker A: Our caviar is better than yours. What are you valuing more now than before? Quality of life. And I mean, that's pretty broad, but things like workers rights, things like right to healthcare, things like just rights for people in general. Many of these things are more things I dislike about the US than things I like about Norway, necessarily. But I also find that, like, Norway has a particular set of beliefs about how people should be treated and things you should have access to and rights to that I align with and, you know, things like right to childcare and long parental leaves and that kind of stuff that, you know, many countries do not have to the same degree. Well, you still work at Amazon. I don't know yet.
01:40:57.010 - 01:41:13.510, Speaker A: I mean, that's my current plan at least is to move and continue working with my current team from Norway. That changes. I don't know. But that's at least where I land for right now. Come back to Australia. It's too far away, man. It's too far away.
01:41:13.510 - 01:42:03.444, Speaker A: And yeah, I think the thought long term is maybe go a similar path to Amos faster than lime or filippo. I forget their last name. The person who's doing a lot of the crypto in go, who's also taken a similar path of trying to do basically open source full time. The other thing I've thought about is doing instead of just doing open source and teaching, maybe do rust training consultancy as part of that. And that might help make up for some of the. Basically some of the wage that I would need to actually survive. I don't want to.
01:42:03.444 - 01:42:45.290, Speaker A: So someone asked, you haven't considered going back to Boston? I've considered it, but I don't want to stay in the US. The longer I stay here, the more I realize I don't actually like the US. There are so many things that bother me about all of America. There are some things that bother me about specific places in America, but there are also things that bother me about America as a whole. And I feel like I've now spent the time I wanted to spend here. Oh, yeah. Another thing that I'm looking so much forward to is public transport and walkable cities and having actual neighborhoods that are not just either residential or commercial, which also don't really exist in the US.
01:42:45.290 - 01:43:11.270, Speaker A: Nice. All right. I think that answers that question. Petition for speedrunning questions at the end. Yeah, I will almost certainly do that. What are some board games you've been playing recently? Well, so I've still love blood on the clock tower. It is probably one of my favorite games.
01:43:11.270 - 01:43:51.850, Speaker A: Recently my partner and I have started playing Scrabble, which is a lot of fun. We bought a proper scrabble board and I just like word games. I used to play a lot of banana anagrams. Not banana grams, banana anagrams, which is you use a bananagrams bag of letters, but what you play is you put all the child's face down. So these are basically scrabble tiles, fails down in the middle of the table, and every player in turn just flips a letter. That's all you do on your turn at any point. If you see a.
01:43:51.850 - 01:44:19.862, Speaker A: If you can make a word with at least three letters using tiles that are visible in the middle. You can call out the word. You take that word in front of you. You don't have to arrange them in any way, you just keep the words in front of you. And crucially, you can steal words from other players by making an anagram of them and adding at least one letter from the center. Or you can steal multiple words if you can combine them into a single word by making an anagram. And there are some restrictions, like you can't.
01:44:19.862 - 01:44:45.140, Speaker A: The root of the word can't be the same with the anagram. So you can't just add an s to the end, for example, it has to actually be a different word. I. But it's hugely fun. And it moves pretty quickly because people keep flipping letters and the score is just whoever has the most letters in the words in front of them at the end win. It's so much fun. And no, you cannot play norwegian words or abbreviations.
01:44:45.140 - 01:45:09.486, Speaker A: It's basically scrabble rules. It's so much fun. What else we've been playing in terms of board games. I haven't been playing too many board games recently. I don't really have a board game group in LA, which is a little sad. But we've been playing codenames. Codenames duo, which is pretty fun.
01:45:09.486 - 01:45:37.950, Speaker A: We're playing a little bit of Hanabi, a little bit of love letter. There's also sort of a limit to what you can play as a. If you're just two, it sort of changes the set of games. There's one called Fox. Fox card game. It is. That's unhelpful.
01:45:37.950 - 01:46:08.140, Speaker A: Fox in the forest, which is kind of fun. Oh, and we've been playing a bunch of Gloomhaven. We started with Gloomhaven Jaw, the Lionhouse, just of the lion, and now we're playing just the full gloom heaven game. Just also so much fun. I love that game. Yeah, I think that. I think those are the current set of questions or the current set of board games that I play.
01:46:08.140 - 01:46:49.606, Speaker A: Oh, we played. Played a little bit of tacocat, goat cheese pizza. This is a very straightforward, like, party card game. What's your opinion on Elixir or Erlang? I haven't used elixir, so I can't really speak much of that. I've played around very basically with Erlang, but not enough that I have a strong opinion on the language. I think Erlang works really well if you're trying to build a language that fits Erlang's view of the world. But Erlang is fairly opinionated.
01:46:49.606 - 01:47:20.736, Speaker A: About how you should be building your applications. And so if you stray from that, you're gonna have a bad time. I don't know the extent to which elixir is the same, so I can't really speak to it. What's the longest word you've had in banana anagrams? I think I managed to grab deforestation once. I was pretty happy with that. Yeah. Taco cat go cheese pizza.
01:47:20.736 - 01:48:08.560, Speaker A: That's what I said. Demand for programmers is high and it's relatively easy to jump in. Do you think incompetence spreading too much in this space, basically because more people are programmers. Am I worried about the fact that there are more bad programmers? No, I don't think so. I think this is a sort of necessity of anything becoming more of a mainstream job or job family. I think this is already the case in every other job sector known to man. Right.
01:48:08.560 - 01:48:53.700, Speaker A: Is that there are, there are people who are good at their jobs and there are people who are bad at their jobs. And I don't think it's a matter of like the percentage of people who are bad is going up. Not really the way in which people who are less good at their job maybe goes up or not goes up, but changes. But the fact that more people are getting into programming also necessarily means we're getting in more people who are good at programming. So I think it sort of balances out. It's not something I'm concerned about. Yeah, there were a lot of bad programmers when there were a few programmers too.
01:48:53.700 - 01:50:10.260, Speaker A: And as someone said in chat too. It's good to get in more people, because that's how you get more perspectives, more diversity, more new ideas, fresh ideas into the field. That's how you end up breaking existing thought patterns and design patterns and approaches to programming that people are locked into. I think it's only a good thing. What are your thoughts on the allocator API? When do you think it will be stable, and should we, once we are there, go in the direction of zig and do explicit allocations everywhere? So I started following the allocator API back when it was first proposed. At this point that discussion has been going on for so long and there's so many nuances to it that I don't know that I can speak to the latest and greatest of the current RFC. I do think that you need a way to have allocators be a sort of first class primitive in the language, things like being able to parameterize box and collections and stuff on allocators.
01:50:10.260 - 01:51:10.950, Speaker A: I think it's critical. The tricky part is what is it critical for? This comes down to what are you designing for? What use cases are you trying to unlock? I think this is why it's taking so long to stabilize too, is because a lot of people want to use it for a lot of different things. Arguably, some people want to abuse it for some things where this is the easiest way to get at a particular solution that they want. I think we are getting closer, but I don't have a good sense of what the timeline is going to be. My guess is years, probably single digit, probably less than five, but it's hard to say. I do think that if this is something that the kernel is going to end up needing, that puts some more pressure on it happening sooner. But the kernel is also willing to use unstable features, so it's less of a stabilization pressure.
01:51:10.950 - 01:51:52.480, Speaker A: In terms of whether we should go in the direction of zig and do explicit allocations everywhere, I don't think so. I think that's going too far, and I think it's sort of going against the grain a little bit, because that's not what people expect. It gets into the whole, like, you know, c c new keyword kind of. Not c c new keyword kind of things, or c Malloc. I don't. I don't know that it buys you that much. I do think that we have to figure out the sort of inverse of this, which is, how can you guarantee that a given code path has no allocations? And we do have to solve that.
01:51:52.480 - 01:53:03.356, Speaker A: I don't think we solve it by making every allocation explicit. I think that's too high of a price to pay, basically. So I think, yeah, I hesitate to go the. Although rust does generally follow the sort of explicit is better decision making framework, so to speak. But I think this is a case where actually having every allocation be explicit is probably introducing too much noise overhead, and I mean cognitive overhead, not overhead in terms of performance. Can you recite the lyrics to Bohemian Rhapsody from memory? So I actually saw this question come in back when it was originally posed, and it, of course, made me immediately try to sing the song while listening to it. And I think I actually know the lyrics.
01:53:03.356 - 01:53:56.288, Speaker A: Like, I think I know there's, like, one part of the middle around, like the let me go chorus, where there are a lot of overlapping voices. That's like, the lyrics are a little complicated, and singing it alone is very hard, but I'm pretty sure I know the whole rest of the lyrics. I don't know that I want to recite the entirety of the lyrics. Now that seems maybe excessive. I don't know if chat wants to hear me sing for five minutes. What about don't stop me now? That one I think I'm close. I probably know.
01:53:56.288 - 01:55:04.120, Speaker A: So I actually tend to pick up song lyrics fairly well for don't stop me now, I'm guessing. I know maybe like 60 70% somewhere around there. But like rapper's delight by Sugar Hill Gang, for example, like the long version of that song, I think I know almost all the lyrics to that one too, I'm fairly sure. And I think part of the reason why I pick up on the lyrics so much is because I don't really get bored of things, or at least that's somewhat rare. And so if I find the first time I find a song that I enjoy, I just listen to it on repeat for several days on end to my partner's great annoyance. And so the lyrics sort of attach to my head. It does mean that usually I end up learning the lyrics the way I hear them, which both means that when I recite them back, I tend to recite them back in like the accent they were sung in, which is a little weird.
01:55:04.120 - 01:56:02.232, Speaker A: But also if I hear the lyrics wrong, then I learned the lyrics wrong, which is not unusual, but it really sticks in my head, so it's hard for me to correct afterwards. But so I will definitely sometimes just like, like while walking around, just randomly sing songs that get stuck in my head and actually just sing through the whole song. Is there a story here, you big queen fan? No, not really. Those are just two songs that I happen to like. I'm not really a big like, fan of particular bands or even genres or albums. Like, I just like individual songs and I will listen to those songs on repeat, but I don't like I there are a decent number of queen songs that I like, but I'm not like a die hard queen fan. A karaoke stream? That's funny, I don't even know how you do karaoke as a stream.
01:56:02.232 - 01:56:32.686, Speaker A: Like, it's just me singing and everyone else watching. Because that's not what karaoke is all about. Yeah, I'm pretty sure I know all the lyrics. The bohemian Rhapsody nice. Bicycle bicycle. Nice. I've used rust with lambda and the performance is phenomenal.
01:56:32.686 - 01:57:28.910, Speaker A: The developer experience could be much better. This is probably just related to adoption and lack of best practices. What's your take on rust serverless? Will we see an uptake of rust adoption in the coming years, or will serverless remain a field for JavaScript and python dominance. You know, my experience certainly with using rust for lambdas was pretty good and I could totally see more people adopting it because I don't really build services. I have a hard time saying how suitable is it for this purpose for anything? That's nothing, the simple thing I built. But yeah, I think there's a decent chance that as the developer experience that gets better and we get better tooling and support and documentation and best practices and examples, I think Rust is a pretty strong contender for writing lambdas in, for example. So I think the answer is yes.
01:57:28.910 - 01:58:25.920, Speaker A: I do see it being, I see Rust being used a lot in serverless. I think there's a question of is serverless sort of the future? Like is everyone going to deploy to like, you know, cloudflare workers or Amazon lambdas or whatever? Maybe. I'm not convinced that that's going to be where everything is going. Like I think we're going to see maybe many things moving to it because it's relatively easy. But, but I don't know that it's going to be, you know, the only way to deploy services, right? If you're, if you're deploying something like let's imagine you're building like s three. I don't think you build s three on lambda, right? There might be some parts that you build on lambda, but ultimately I think that's just not something that fits serverless. So I don't think serverless is going to be universal, but I do think that rust is a decent contender for using four serverless things.
01:58:25.920 - 01:59:29.460, Speaker A: Should rust have a more powerful alternative to macros? For example, C sharp allows analysis generators to consume full type information, flow analysis, etcetera. I'm torn on this one. One of the challenges here is that it basically becomes a compiler plugin. And I know that there's been work on trying to sort of standardize the API to the compiler so that you can more easily write a compiler plugin. Having it be in the language itself is a little weird to have basically proc macros on steroids that get to run at a particular point in the compiler pipeline. So it gets to consume type information and stuff. Feels like a sort of pandora's box, which doesn't necessarily mean that's a bad idea, but I think the way to do this is with compiler plugins.
01:59:29.460 - 02:01:10.364, Speaker A: There are certainly times when I have wanted this wherever it'd be really useful to be able to write something that can look at the type of the things being passed in and sort of branch based off of that and if you look at something like the pin project crate, it basically ends up doing some of this through the code it generates. So it has to do things like check that the type that you derive projection on or derive unpin on doesn't have an implementation of unpin. And the way it does that is not by at code generation time checking the type information, but instead it generates an impul that's going to be rejected at compile time because of a duplicate implementation. So basically it adds an impul that if there already is another impulse, will fail to compile. And so that's one way you can sort of trick your way into getting some of this. But I don't think we're gonna get a sort of macros on steroids in quite this way, and instead I think we're gonna get a better way to write compiler plugins. Um, can you recite the lyrics to Dover Gibbons hall, also known as hall of the Mountain King? It doesn't have lyrics.
02:01:10.364 - 02:02:03.214, Speaker A: I. I can recite the melody, but I don't think there's a lyrics to it, at least none of the versions I've heard. Um. All right, what kind of laptop are you using for work? Depends whether you mean work work or open source work. For work work, I use an m one, not an m one pro, just an m one, because usually I work on a cloud machine that has lots of cores and stuff and then I use my laptop essentially as a thin client and the main reason why it's an m one is because I use it as a thin client. What I really want is battery life, and the M ones have really good battery life. For open source work I still use a thinkpad x one carbon.
02:02:03.214 - 02:02:52.856, Speaker A: I think it's like a 6th generation one. So it's kind of an old one. But I've been very happy with those laptops. I think, you know, I tweeted about this a while ago that I think my next laptop, I really want it to be an arm one, but currently m one s are the only ones and I don't really want a Mac. So I'm sort of hoping that there's going to be decent arm laptops coming out and I would probably want them to be one of the sort of laptops that let you exchange parts yourself, in part because it means that I can upgrade it over time rather than have to throw it all away and get a new one. So something like the framework laptops for example I think would be really cool. Yeah.
02:02:52.856 - 02:03:53.850, Speaker A: So asahi Linux for example, on m one I think would be a reasonable path here. But I don't really like the apple hardware, and so I would rather have, like for example, I would rather have a laptop that's not silver. And so I don't, or overpriced for that matter. I don't think I really want an m one, but currently m one is the only processor that is a contender here. What's your take on front end in rust? You, etcetera? I have not used any of them, so I don't really have a great take here. It's definitely weird to me to use rust for front end development because it means that you have to traverse the boundary to another language as part of your front end development. And at least my experience is that transpiling is always a pain.
02:03:53.850 - 02:04:56.570, Speaker A: And certainly when you're transpiling from a language like rust, like through basically webassembly into developing frontend, I think it's maybe a pipeline that's too long for me. But I don't have strong feelings on this just because I haven't done front end development in rust at all. How can I make reproducible or hermetic builds work with cargo? You can't really. You can get kind of close, right? So you do you have your, instead of using crates IO as your registry, you can do it with, with crates as well. But you either do a vendoring or you do local registry. You commit a lock file, you use a custom cargo home that is at a fixed path. You use the rust c flag that lets you rewrite debug paths.
02:04:56.570 - 02:05:35.874, Speaker A: What else do you need? You run cargo in offline mode. You pull out your Internet cable so the build scripts can't access the Internet. But reproducible and hermetic here are fairly different, actually. Reproducible. I think you can get pretty close to. Hermetic is harder, mostly because of build scripts. And you can do some sort of pre analysis here.
02:05:35.874 - 02:06:27.356, Speaker A: You can use something like even just cargo vendor, and then you can scan all your vendor dependencies for build scripts and sort of look at what they do. But there's not a great way to support this. I would love to see things like running build scripts through webassembly or something so that they're somewhat sandboxed. But we don't have great ways to do this at the moment. And no, I don't think you can disable buildrs files at the moment at least. Yeah, but this is something I wish cargo would get better at, actually. I mean, not just like for work, but also personally, like, I do worry about things like build scripts and proc macros for that matter.
02:06:27.356 - 02:07:41.130, Speaker A: They both sort of have the same problem. I think with proc macros it's more likely we're going to see something like, or something like it, where the procedural macros are basically compiled into webassembly and then run so that they already run sandboxed for buildrs. That might be harder, but it would be really nice to see. And reproducible builds is going to be handy for things like supply chain security where you can actually check that you're building the same thing as upstream and stuff. But there again, I think we're much closer because there was a bunch of work to make the build of rust C itself, like the rust toolchain, be reproducible, which I think some of the Linux distros needed, for example. So some of that work has already happened. If you were a cat, which one of your cats would you get along with better? Ah, that's a good question.
02:07:41.130 - 02:08:16.390, Speaker A: I think I would get along with miso better. So Miso is very like full of life and very curious and very, I don't want to say happy go lucky, but she's like, she's very positive. Chai is much more like, I don't like this. She's like an old man. I don't like this. What's that? She grumbles like, some of her meows actually sound like grumbles. She's like, why is the toy all the way over there? So she's.
02:08:16.390 - 02:09:18.208, Speaker A: I feel like she's probably harder to get along with. Like I think I. She's like, she can be very cuddly, but she has to really get to know you first. She's a lot more reserved and so I think I'd probably get along better with Miso. Are you worried about AI taking the fun out of programming at some point? In the sense that humans in the loop might only be responsible for stitching together AI generated code and checking for bugs. I don't think AI can take the fun out of programming because you can always choose to write programs yourselves. Even if AI got really good at generating code and including super convoluted code and it had few bugs and whatnot, I don't think that doesn't mean that you can't write code by hand.
02:09:18.208 - 02:10:07.608, Speaker A: It just means that it's much less efficient to write code by hand. So it doesn't really take the fun out of it. It doesn't mean that if you were, say, if we got to that point and you wanted to work as a programmer your job might be more like glue checker than programmer, and so that job might change. Or you could even say the job of programmer goes away and instead the job family that's on the rise is like QA tester. And I don't think I would want to be a QA tester. That sounds like less fun to me. I like writing code, including if it's like convoluted weird code or glue code or some elaborate statement I need to get right.
02:10:07.608 - 02:10:56.110, Speaker A: I enjoy that parts. So I think I would still choose to do that. I think there's a question of would there still ever be value in it or would you essentially just do it for fun? And if you would only do it for fun, like if you couldn't actually get a job writing code yourself, which I think is unlikely, but then what would I do? And I don't think I would take this sort of QA tester job to pay my bills and then write programs manually for fun. I think in that case I would probably be doing one of the other questions asked for like teaching or something and then do programming entirely on the site for fun. Oh yeah. Or to be a prompt writer. That also sounds awful to me.
02:10:56.110 - 02:12:08.350, Speaker A: Right, where you write the prompts to tell the AI what code to generate. Yeah, and there's a related question here, like have you tried copilot? I actually answered that question last time we did a q and a, but no, I haven't used it, but I've seen it used and I'm not convinced. I think what I really want to see is AI getting better at code assist rather than code generation. I don't think I want the AI to generate code for me because I don't know that it actually reduces the burden that much. But using it for code completion, for example, I think is super useful. Or for code explanation maybe is leetcode really valuable for a programming skill? We talked about this earlier, so I'm going to skip that one. Do fish exist? So this is the good old Internet meme where obviously the answer is that fish do exist.
02:12:08.350 - 02:13:45.140, Speaker A: I'm a boring person, as you can tell, but the question was asked by a seal. So I feel like as a seal you should know that fish exist because I assume you've eaten many birds are the ones that aren't real. That's right. From what part of your life work, open source, teaching, friends, family, do you think you're going to make make the biggest impact in the world? Depends what you mean by biggest impact. And I know for a lot of these I say, you know, it depends on. But in reality, life is very, it's gray, it's not black and white. I think teaching, at least that's my hope that, you know, I think of much of what I do in terms of like, impact multiplicative factors, where the stuff that I do at work enables a lot of people at Amazon to build better things, which in turn means all the people using AWS get to build better things.
02:13:45.140 - 02:14:49.970, Speaker A: And to some extent it affects how AWS interacts with, say, the rust project. And I'm hoping that has beneficial attributes for the rust project. Same thing with generating more confidence in rust by virtue of making Amazon use it more. And as a result, that might give the rust language a boost, which I do think is like a good long term impactful thing. My open source work has less of a multiplicative factor, I think because the AWS work is a decent multiplicative factor. My open source work less so because you're only going to use it if you need one of the specific things I've built, and I don't think I've built anything where the thing I built unlocks a use case. Many of them are like, I needed a thing that does X and this thing does X, as opposed to like, let's take Serdi, for example, where like, that is the sort of linchpin for an ecosystem.
02:14:49.970 - 02:15:36.648, Speaker A: So I don't think my open source work is quite as impactful. Friends and family are very impactful to me, but they're not impactful like long term friends, maybe more so. I think there are friends I have where the interactions I've had with them let us both grow. But there's not really a sort of multiplicative factor there, unless one of them ends up doing something enormously great as a result of a conversation they had with me, which I think is somewhat unlikely, and family even less so. But teaching is the one where my hope is that it has a very big branching factor. Right. A lot of people end up consuming the teaching content that I produce.
02:15:36.648 - 02:16:33.108, Speaker A: As a result, hopefully they become better programmers. They might be inspired to build things or enabled to build things that they weren't already, allows them into a position where they can then make change or affect change. And that has the potential, just because of the branching factor, some of those people are going to be doing cool things, and they're going to be doing cool, impactful things, in part as a result of learning from the things I put out there. That gives it a sort of multiplicative factor effect beyond what I get within any single company. So I think it's going to be teaching. I hope it's going to be teaching, but it depends. For example, if rust ends up being a flop in ten years from now, people are like, well, we shouldn't have bet on rust.
02:16:33.108 - 02:17:55.280, Speaker A: I don't think that will be the case. But if that were the case, then most of the. The teaching that I've done is going to have not really amounted to anything, whereas the stuff I did at AWS might still have, because there will still then be all the things that people are currently building, that still are working and doing good things. Yeah, I think that's how I answer that question. If Rust suddenly disappears, what would your next go to language be? So, in general, I feel drawn to languages that are type safe, that are statically typed, that are. That allow me to encode more of the invariants and semantics of my program into the code itself and have it be checked. So I think it could be that I get drawn into the sort of formal verification world more and start looking at languages like Daphne or f star or cock, maybe.
02:17:55.280 - 02:18:38.804, Speaker A: I don't know. I think those are sometimes a little too hardcore for me, though, and that I would be more drawn to a language like Zig, for example. But I really, even for zig, zig is. I'll caveat this with prefix, this with. I haven't used Zig. So all of this is sort of a conjecture based on what I've observed about the language. But zig is less type focused than rust is, and I like the type focus of rust.
02:18:38.804 - 02:19:04.396, Speaker A: I like having things like the borrow checker. I like the strictness of the modeling of correctness of programs. And so I might miss that going to zig. And I don't really know what other language I could go to. There's, like, haskell, maybe, but I don't really. I think Haskell takes a little bit too strong of a absolute position on things like functional programming. So I don't really know.
02:19:04.396 - 02:19:40.548, Speaker A: I don't know that there's a great alternative language, which, you know, is arguably one of the reasons why I'm doing Rust is because I think it has the right mix of features for me. Oh, camel. Yeah. Lean. I haven't looked lean enough to really say any thoughts on becoming a digital nomad. I mean, that's basically what I am already. I work remotely.
02:19:40.548 - 02:20:25.460, Speaker A: If I moved to Norway, for example, I would still continue working for the same team I work basically, I live independently of my work, and so I think it's great. I'll say. I would never go back to working in an office or being tied to a particular office at all. I like this lifestyle. That's not to say that I do sometimes miss being able to meet up with my team in person and my colleagues and others in sort of that sphere. But being tied to a sort of local job is not something I would want, even if it's local just within the same country. So I highly recommend it.
02:20:25.460 - 02:21:18.758, Speaker A: So I'm positive to being a digital nomade, the latest good movie or tv show that you watched and likes well. So I do love the great British Bake off. But the latest one is okay. There are two. One is spy family, which is an anime that is, it's really good. It's very funny and it's like a, I don't want to say it's a parody because it doesn't feel like a parody of anime, but it's, it is very aware of the fact that it's an anime and it's. It's great.
02:21:18.758 - 02:22:19.226, Speaker A: And the other one is the sex lives of college girls, which is also a very funny and I think very well written show. I've been enjoying those both immensely. Lloydsania and yor great. It is very good, but both of those shows are very good. Why do you only sort by upvotes when we were wondering? This can easily lead to only top questions getting read and therefore uploaded. I don't have a better alternative is really the biggest reason because I don't want to penalize the question for having been asked early on and therefore having more votes. Like, if I only sorted by new, then votes wouldn't matter.
02:22:19.226 - 02:23:13.558, Speaker A: If I only sort by votes, then at least those are questions that many people have indicated an interest in. I could let you switch between new and most voted, but I don't know how much value that adds. How many people would actually switch back and forth? And would it be enough to make up for the difference in votes? I'm not sure. You could do something like a sort of weighted average or something, but a, it makes the backend much more convoluted, and b, I don't know if what you want is for the value of votes to decay over time. For a site like this, Reddit does this. If I remember correctly, the algorithm Reddit uses is something like the value of a vote continuously goes up over time. So if you voted six years ago, a vote was worth, let's say, one or one unit, and now one vote is worth three units.
02:23:13.558 - 02:24:02.030, Speaker A: So the effect this has is basically of a weighted average, right, of the more recent a vote, the more positively or negatively it counts. It's a really neat system, actually, for doing this for multiple reasons, but that might be a way to deal with a good way to deal with a site like Reddit for here. I don't know that the recency of the vote matters. I think you are onto something, though, that it might mean that people don't really review the questions that are new. They only vote for the ones that are at the top. But I don't know that that's a problem either, if those are generally good questions. If I was only getting really bad questions, I agree it would be a problem, but I don't really see that.
02:24:02.030 - 02:24:50.218, Speaker A: Another option here would be to do a split view where you see the top five and then you see the newest five, and then it's sorted by votes or something just to give them some visibility. But I don't know, I don't think it's that costly to scroll to the bottom of the page. This just seems very straightforward. Um, it could be randomized, um, and then the host view shows ordered by votes. I don't know if that's better either. Right. Like, realistically, if you're watching the stream, I feel like what you want to watch is the, the questions that are about to be answered next.
02:24:50.218 - 02:25:22.570, Speaker A: And if one of them matters more to you, try to bump it up so it gets answered sooner. So I actually think the current semantics are what you want. And the only question is about exposure to new questions so that they have a chance of getting up there. And my guess is this kind of already works. Yeah. So this feels to me like a premature optimization, maybe. Oh, actually, here's one thing I want to show.
02:25:22.570 - 02:25:48.400, Speaker A: So for the camera comparison, let me pull that up again real quick. So now it's a little darker in here. And notice the difference in the white balance. Right. So see how this one is much more, I don't know, accurate in its color balance, really, than this one. This one is far too white. Like, I haven't changed any of the camera settings.
02:25:48.400 - 02:26:24.330, Speaker A: This is just the camera continuing to run with the same settings. And I think they're both set to auto white balance. That's interesting. I also only see the small previews, so I'm going to look back at the recording to see how different these actually were. That's interesting. All right, let me go back a hot question sort option. Yeah.
02:26:24.330 - 02:27:10.470, Speaker A: So that is one way to do this, right? To have a separate tab that's ordered differently. I'm just wondering how many people would actually change the sort order. Right. I could have a hot be the default, but that means that the default view isn't going to represent the actual queue of questions that I'm about to read, which might be confusing to people who are watching. I suppose then you could at least do like these things have gotten a lot of questions in a short amount of time. So you could do sort by number of votes divided by time since asked to get that kind of score, which is basically what hot is. I don't know if it's better because it also means that the most popular questions aren't going to show up.
02:27:10.470 - 02:27:59.970, Speaker A: So it's interesting. Okay, thoughts on the upcoming book about rust, locks and atomics by Marae? I'm really excited about it. It's a really hairy topic that my book talks about locks and atomics in some amount of detail, but I don't think to anywhere near the depth the Mars book is going to look at it. So I'm very excited to see this. See basically a better write up of this because it's a very subtle, complex, an important topic. So I'm very excited. I think it's great.
02:27:59.970 - 02:29:03.898, Speaker A: Will you stream designing a D and D campaign? Maybe. I do really want to develop a D and D campaign. The biggest challenge I have at the moment is that I both don't have the time to run a large D and D campaign and I don't have the time to make a campaign. And, you know, as I've said many times before, the, the challenge that, that I keep facing is that you never find the time you have to make the time. But I have so many things I want to make time for and I don't know that a making a D and D campaign is high enough on the list of priorities to be prioritized over other work, like, like doing more crust of rust streams, for example. So that's really the tricky part here. That said, when I do end up taking the time to make a DNA campaign, I feel like it's totally something I would stream.
02:29:03.898 - 02:30:12.494, Speaker A: Because why not? It's interesting though, I've gotten to the point where these days I don't really feel a, feel much friction to doing a stream. Like if I'm doing something that I think might be interesting to others, I go, well, why not stream it? What's the reason not to? Thoughts on macrocotta, more exercise based learning materials? What we are missing in rust? I don't know what that is, but it sounds like rustlings. Like rustlings is exercise based. And exorcisms set of, or like rust track is also very exercise based. It's the closest I can think of. What is a monad? It's always this question. It doesn't always come up in q and A, but this is a question that I think all of computer science has been trying to articulate nicely.
02:30:12.494 - 02:31:14.170, Speaker A: And I don't think I actually have a sufficiently accurate mental model of a monad to be able to give a useful and correct definition. But I can give my mental approximation for monadheendeh, which is that a monad is more or less something you can map over. That is, it has a value that can be transformed independently of the structure that holds that value. That's going to be my. I'm going to stop there because it's not entirely correct. It's maybe enough to be useful, and if I say more, it's going to be more wrong. Endofunctors, hint, hint.
02:31:14.170 - 02:31:28.362, Speaker A: Bunch of words. Yeah. Monad is a monad in the category of endofunctors is the classic quote. That's right. You lose the ability to describe once you understand it. Also accurate. Looks like a collection if you squint.
02:31:28.362 - 02:31:56.652, Speaker A: Yep. Also right. We are all monads. Yep. All right, I'm gonna mark that as answered, even though in the history of human. Of humans, it has never been answered. What do you think about blockchain as a technology in general? Ignoring the bus and the buzz and financial and monetary usage? I think it's hard to ignore those.
02:31:56.652 - 02:33:00.770, Speaker A: But there was a really good article by Tim Bray. Let me see if I can find that one. So Tim Bray used to. Used to work at Amazon and no longer does. And he posted an article the other day, let me put it, put it in chat called AWS and blockchain. And it's a. The basic summary of that article is he and some other people were tasked ages ago with basically trying to figure out what is the blockchain? And should AWS be providing something that is blockchain based? Like what's the value of blockchains? And their conclusion, more or less, was ledgers are useful.
02:33:00.770 - 02:33:33.180, Speaker A: Distributed databases are useful. Let's see if I can find the actual quote. Yeah, ledgers are useful. Cryptography tech is useful, blockchains aren't. The field is full of grifters, but we could build distributed ledger infrastructure and then these cool services on top of it, which I think is how I feel too. Like there's a lot of cool cryptography in blockchains. There's some cool, like, distributed systems research.
02:33:33.180 - 02:34:44.890, Speaker A: Ledgers are certainly a useful abstraction, but I think blockchains themselves, we haven't seen compelling use cases for. I just, I haven't seen them. They keep, we keep seeing new claims that someone has found a useful use for the blockchain and they're just useful uses for a ledger. They don't need to be a blockchain that, like, distributed trust is, I think, something that we as humans just don't. It's very often not what you want or not what you need. It's a solution in search of a problem, in a sense, yeah. What do you do in the middle of the night if you suddenly get an idea to fix some problem? Will you go code immediately, write a note on your phone? Or will you continue to sleep? If it's a thought that's important enough that I wake up, or if I'm struggling to fall asleep because I've had an insight of some kind, usually what I do is I set an alarm for sometime the next day where the description of the alarm is the idea that I had.
02:34:44.890 - 02:35:32.046, Speaker A: I used to write notes and then I realized that it wouldn't let my brain relax because it was like, what if you forget to read the note? Whereas setting an alarm works pretty well because my brain lets go of it being like, okay, so now we know that we will think about this again later. It would take a lot for me to get up and go code the thing. It has happened, but then it's usually not in the middle of the night. It's more. It most often happens if I'm like, obsessing over something. When I initially wrote, we were wondering, for example, I had a few days that were sort of like this, where I was thinking about it all day and doing all this programming. And then when I went to bed, I'd be like, oh, maybe I can do this.
02:35:32.046 - 02:36:07.688, Speaker A: And then I would sleep not super well, and I would wake up kind of early. And the moment I wake up, the ideas continue propagating in my head and I'm like, okay, I'm not going to be able to fall back asleep. I'm just going to get up and do it. I remember one of these was, I wanted to use the page visibility API to reduce the polling or to lengthen the polling period if a tab is in the background. And I was like, I'm just going to get up and do this. This is a great idea. It's not worth me writing it down and then trying to fall back asleep.
02:36:07.688 - 02:36:59.320, Speaker A: And that was like maybe an hour before I usually get up and. And so I'm just going to do it. So that's my best trick is I have far too many alarms set on my phone. I have started turning them more into to do lists, but alarms are still the best way I know of. Have you heard of leptos? Thoughts on it? And in general using rust for web programming? Why does it ring a bell? Oh, I think there was a rust for rest. No, not rust for restation. Restation station episode where Alan interviewed Greg Johnston, who made leptos.
02:36:59.320 - 02:37:58.870, Speaker A: I have not listened to that episode or read about leptos or used it, so I can't really speak to it. But there was a rostation station podcast episode about laptops, but no. So I've heard of it in the form of I've read the show notes for that episode, but that is the extent to which I have any thoughts on it. And in general using rust for web programming. We already covered earlier. Thoughts on Haskell? We also covered earlier in which programming language would you use if you weren't using rust? Any idea why enum variants can't be used as independent types? I would think that would be useful to be able to specify the return type is always a specific variant of an enum and other similar benefits. Thoughts? Yes, I want this, and there's an RFC for this that I commented on because I really wanted it.
02:37:58.870 - 02:38:52.490, Speaker A: It's called enum variant types and it was opened in like 2017. Let me see if I can find it. Last comment from early November and yeah, I would love to have these, but it turns out that it's a really hard to implement and b it's not entirely clear, like it has a bunch of implications for the type system that can be awkward. Oh, it looks like there's an upgraded RFC. Oh, this is Lang team proposal that's been merged. Oh yeah, here. Here's a relatively recent comment from Niko.
02:38:52.490 - 02:39:33.194, Speaker A: Based on those meetings, we decided we are going to close this issue, but not without a good helping of regret. The bottom line is this. We all agree that it is a common and annoying pattern for us today to have to make a struct for every enum variant and then just have the enum wrap those structs. This gives you the ability to have a type for an enum variant, but is annoying and inconvenient. So for those reasons, we would love to see forward motion on this proposal. However, we also feel like this is striking at a fairly core part of the language, and there isn't anyone on the team who has the bandwidth to actively lay us on this effort. So basically this is a major change to the type system.
02:39:33.194 - 02:40:01.810, Speaker A: We'd love to see it, but no one has the energy or time dedication to work on it. So I'm totally on board with you. I would love to see enum variant types, but we don't have them. I should really subscribe to this issue. Where's the subscribe button when I'm zoomed out this much? Weird. Yeah, we don't have the time basically, which is sad. Maybe one day.
02:40:01.810 - 02:41:12.430, Speaker A: Have you ever done game development or game engine programming? I've done a tiny amount like as part of of my undergrad we had to do a little bit of game programming in Java as I built a little like fly the copter game, but very little. I actually would love to do more. I think game development is a super interesting space of software engineering. It has an interesting combination of problems that appeal to me. I think there's a decent chance that if I wasn't doing sort of developer tools type stuff like I'm currently doing, that I would do game development instead. Now, unfortunately, of course, the game development industry doesn't have a great track record for things like work life balance, or just in general happiness as a developer, or happiness being in that role, or deadline setting and stuff. So the industry sounds like it's not a great place to be, but it sounds like a lot of fun and it's totally something that I would explore.
02:41:12.430 - 02:42:38.130, Speaker A: Have you read and worked through structure and interpretation of computer programs? If so, what impact did it have on you? No, I have not. I feel like I've heard the title of that book, but that's the extent to which I know about it, so I know that's not very useful, but no. Are you familiar with the helix text editor which is written in rust? If so, what are your thoughts about it? I think Helix is abandoned now, but I remember I saw it when it came up and I kind of like the idea of people experimenting with new ways to do editors, but at the same time I don't feel a strong need to switch to them. Like, I'm just very, very happy with using neo vim, so I don't really feel the need to use a different editor. Not to mention that when you switch editors, it comes with all of the downsides of having an editor that hasn't been around for as long. So you don't have as many plugins, you don't have as much support. There are a lot more corner cases that aren't covered for you and support for weird programming languages and just a lot of stuff.
02:42:38.130 - 02:43:12.870, Speaker A: I think it's cool that people are building new editors. I think it's a good thing to experiment with, and, you know, that's how we get better editors over time. But I don't feel a compelling desire to switch. Oh, Helix is not abandoned, apparently. I lied. There was some. Oh, gee, yeah, Xi was the editor that was abandoned.
02:43:12.870 - 02:43:34.740, Speaker A: Helix was nothing. You're totally right. And yeah, someone pointed in chat too. It's hard to imagine an editor that allows you to be significantly more productive. At least that's been the experience for me. So there's not really an upside to switching. At least not that I've found for me.
02:43:34.740 - 02:44:23.394, Speaker A: All right, I think we're getting towards. I mean, we're definitely not getting towards the end of the questions of questions, but I think we're getting towards the end of there being significant questions that people want answered. So what we'll do is we'll do like a speedrun round. I'll just run through the questions and give rapid fire responses, and then I think we'll call it a day. Okay, are we ready? Let me drink some water before I start. Okay. What are the biggest blockers to impulse specialization? Landing in the wild, or do you think it's less likely with GAtt keyword generics moving some steps forward? I have no idea.
02:44:23.394 - 02:44:55.534, Speaker A: Specialization would be nice, but I'm not involved in the effort. I don't know. How do I get better with generics and traits in rust? Look at popular libraries and crates and actually sit down and try to understand their trait bounds and generics. It's the best way to learn them. Thoughts on chat? GPT haven't used it. I do think I've signed up for the beta. The screenshots I see of people interacting with it are really impressive, and I wonder how well it generalizes stream about your current setup, hardware and software.
02:44:55.534 - 02:45:44.216, Speaker A: I know I've promised this for so long and I need to do it. C has taken some inspiration from aspects of rust that are proven successful. Are there aspects of c you believe would make rust a more attractive language, but the lack of inheritance, for example? No, I actually think not having inheritance is probably a good thing. I think programmers have been indoctrinated is not quite the right word, but I think we have an overreliance on modeling things as object oriented when they don't need to be. That said, I have heard that object orientation maps well onto Gui's. I don't know whether that's because that's what they traditionally have been designed as versus that's how they should be designed. So I don't know that inheritance is necessarily one we should adopt.
02:45:44.216 - 02:46:08.126, Speaker A: And I don't know of other c things that I really think we would want in Rust. What about a stream together with Tim McNamara? That'd be fun. I mean, I work with Tim, and I know I'm. I think it'd be fun. I don't know what we would stream about. This is the same. Like, I've had a decent number of people ask me to do a stream with, or, I guess, another stream with the primogen, which would be really fun, too.
02:46:08.126 - 02:46:48.150, Speaker A: I enjoyed that previous stream, but I don't quite know what it would be. What I have thought about, and this becomes the slightly longer form answer, is a sort of like a rust fireside chat, where I just do streams, where I chat to people who are interested in rust or adjacent to rust, or work with rust, and just have an informal conversation. Not quite an interview, but just like, let's banter about rust a little bit. Those might be fun kinds of streams to do. So maybe. Maybe it'll be one of those. Have you ever visited an Amazon fulfillment center? I have not.
02:46:48.150 - 02:48:04.220, Speaker A: Lord of the Rings or Harry Potter? Harry Potter. But I also haven't read the Lord of the Rings books, and my partner is obsessed with Lord of the Rings, so maybe I need to read them and give it another shot. But my instinct in my gut reaction is Harry Potter. How do you come up with the llama? You know, how did I come up with the llama? It's also unclear whether Jay is a llama or an alpaca. I think I actually just went to a bunch of people on Fiverr or something and, like artists, that I enjoyed their styles and told them, hey, I'm looking for a mascot for my channel, whatever you think might be fun. And one of the people responded with basically a j, and I was like, perfect, let's do that one. And then I commissioned someone else to make the intro video for crust of rust, and it sort of stuck.
02:48:04.220 - 02:48:48.062, Speaker A: What's the advantage of the axiom web framework over the others? I don't know that there's necessarily an advantage. They're just different kind of APIs, they're different ergonomics, different ways of modeling the APIs. I like the fact that axiom seems very composable. I also like the fact that it builds on top of tower, because tower makes it easy to. First of all, it encourages that kind of composability, but also it lets you easily swap out things in the middle of the stack. And I think axiom is making fairly clever use of the rust type system without being quite as insanely elaborate as warp was. Did you try surreal db? No, I have not.
02:48:48.062 - 02:49:29.900, Speaker A: Don't even know what it is. Why not use YYID for? We were wondering. I think yyid is even less common than ulida. I'd probably use ulid over yYid, but there's no strong reason to prefer uuids as I do today. I think any scheme would do here. Have you ever tried advent of code? I've tried it once, but it's a long time ago. What's something available in rust that's super useful, but not a lot of people are aware of or use matching on tuples.
02:49:29.900 - 02:50:48.894, Speaker A: I do this a lot, actually, where instead of having like a complex if else block, what I'll do is I'll write a match, create a tuple with multiple values in it, and then basically do like the editor, complete the match arms for me can be useful for things like, you know, if you have like three options and you want to selectively do something based on what values they have, just doing a match on tuple, three elements where all the three options are there can be really nice. It can be really useful for if you have a bunch of booleans and you want to dictate behavior based on the combination of booleans, it can be nicer to express it that way than with a sequence of if else. So. So I think that's probably the first that comes to mind, at least. How can a database newbie get started with database development, especially for a Rust DB development study, routine resources and so on? You know, I would actually probably do look at a university course that teaches this. Like, for example, I think the MIT class on databases is publicly available, like all the labs and the reading lists and stuff. So I would go take that as a great place to sort of.
02:50:48.894 - 02:51:11.400, Speaker A: It's intended to be a way to bootstrap your knowledge about databases, right? So I think that would start there, and then you could look at whether there are any databases that are specifically written in rust that you might want to try to contribute to that are open source. It's not a question. I'm just letting you know that you're a really cool guy. Thank you. Thank you. I appreciate that. I'll mark it as answered.
02:51:11.400 - 02:51:45.100, Speaker A: Nonetheless, do you think you'd write an embedded project? I've wanted to for a while, actually. I just don't know what to write. Like, I would love to just get a little, like Arduino or something and just make it do something. I just have no idea what to build. But I do think embedded programming can be pretty fun. I remember back during my masters, we had a class project in an embedded class where we had to build a. Every student got their own little Arduino like thing, and we had.
02:51:45.100 - 02:52:48.470, Speaker A: Our job was design an algorithm for doing time synchronization across the devices, and every student had to implement their own device, but we all had to speak the same protocol. So the class had to agree on the synchronization protocol, basically reinvent NTP, and then do an evaluation of everyone brings your device, you run the software you built on that device, and then we put them out in various configurations in the room and look at the time it takes for the clocks to synchronize how well synchronized they are over time, how they drift, that kind of stuff. That was a lot of fun. I feel like I would do something. Don't really have a good project in mind. When someone, when can someone say that they know rust? What are the concepts one should understand so they can be considered a rust programmer? I don't think there's a right answer for this. I think, you know, if you've read the book, I think you can say that you know Rust.
02:52:48.470 - 02:53:56.330, Speaker A: I think you should. For your own sake, you should make sure you've actually written some things in Rust also, because otherwise, if you claim to know Rust, like you have to think about, why are you claiming that you know Rust? I think that's really the crux of this question, which is if you want to be able to claim that you know rust for the sake of getting a job, for example, then imagine you get the job because you said you knew Rust, and now they're expecting you to write rust code. If. If you don't actually know how to write rust code, then what have you gained? You're just going to get, you're going to do poorly at your job, maybe get fired or at least get a poor performance review. Are you really in a good place? So think about what it is you're trying to achieve by claiming you know Rust, and then look at, well, what should actually be the benchmark. What's the best source of beautiful, idiomatic rust code? The standard library implementation? Something else I would look at, code by Andrew Gallant, also known as burnt Sushi in general, he has a pretty good take on writing really good code. Standard library is also decent.
02:53:56.330 - 02:54:50.624, Speaker A: What's the last time you programmed in PHP? What do you think about newer versions? I haven't looked at PHP in a long time. I remember last I worked with PHP, we were at the tail end, version five, like version six just came out, I think. And so that gives you an idea of how long ago it is. And you know, I didn't hate PHP, actually. I thought it was a decent solution to the problem at hand, but I haven't looked at any newer versions. I still remember MySQl real escape string, though. How do you deal with unsolicited advice and criticisms, especially pertaining to personal matters? So there's a book called thanks for the feedback that I would actually recommend people read.
02:54:50.624 - 02:55:59.060, Speaker A: I think it's a pretty good read, and it talks a little bit about this, not necessarily in terms of unsolicited advice, but more about very often you're given advice and you can't control how the advice was given, but you can control how you receive the advice. And so they give advice on how to receive advice, and one of the things that they say is it's useful to basically communicate and set expectations for the advice that you're receiving and let the other person know if you want that advice or not. Keep in mind why they're giving the advice. So I used to get pretty frustrated about this kind of stuff, and I'm like, you know, I don't really care if you want to give me unsolicited advice, I'll maybe listen to it, maybe not. It doesn't really bother me that much. Unsolicited criticism, same thing. Like, you know, I, I'm decently confident in like, or rather, it's not that I'm decently confident in, but rather if I get drive by comments from people, I assume that they may not have looked at things closely.
02:55:59.060 - 02:56:43.510, Speaker A: And so I tried to interpret the criticism rather than letting it hit me directly. What are your thoughts on managing configuration for rust binaries? N variables, config files, CLi arguments, maybe a combination. It depends entirely on what it is on the configuration. I do generally like cargo's approach of, you want to be able to specify anything with any of the three, right? So prefer to put things in files. Environment variables can add to the file configuration and configure command line arguments can override things that are in those. I don't think there's a strong reason to say you can only use one of the one of them. I think it's pretty common to say you can use all three.
02:56:43.510 - 02:58:12.824, Speaker A: And the question just becomes, how do they operate, which override which? And for environment variables, how do you capture potentially complex file based configuration in a string key? What will you be talking about in the Rust nation UK conference? So my talk there is going to be basically on the long term stability of working with rust. So these are things like if the rust is sort of in constant flux, or at least there's a perception that there's a lot of motion in the rust space of new crates, new major versions, new additions, deprecations in the standard library. The language moves forward, new tools become available, old tools get dropped, and the question is going to be, and the talk is going to be about what kind of changes actually matter to you. What are the implications of things like 1.0 or minimum supported rust version or a new edition? It's going to be fairly user focused, so it's going to be on, you know, if you're someone who's using rust or considering using rust for your project, what are the implications of the ways in which rust and its ecosystem change on you that you should be aware of? Have you used zig? No, I have not. Given the game's somewhat steep cost and high player requirement, how would you recommend a newcomer get started with blood on the clock tower? It sounds like fun. First of all, it is fun.
02:58:12.824 - 02:59:04.918, Speaker A: It is very, very fun. I would recommend, it depends on whether you enjoy playing social games online. If you do, there's a discord server for blood on the clock tower where you can play games online. People find that a lot of fun. I'm not a huge fan of playing social deduction games online, so I don't generally play online. Instead, what I do is I look for meetups and other gaming groups that are in my area, usually on something like not eventbrite but meetup and just go see if there are any where they play clock tower or where they might play clock tower and then go play. It is by now decently common, so you can usually find them, at least in major cities.
02:59:04.918 - 03:00:18.408, Speaker A: Otherwise, the blood on the clock tower discord server also has a decent community. You could ask of are there people who are running the game around here also conventions? There's actually a clock tower convention that is being organized and they're running a Kickstarter and they just opened up more tickets, actually. So I'm very excited that I highly recommend. If you've never played it before, going to like, a three day convention is probably not the place to start, but you could even just buy a one day ticket and just play for a bunch. It's in Washington DC in mid April. Can you tell us something about your advisors at MIT pdos? Are there any particular things you learn from them that you feel very valuable? I admire both RTM and France a lot, and thanks for their awesome system courses. One thing that I liked a lot about my advisors at Petos was that they are, I don't want to say very hands on, because they're not necessarily necessarily hands on.
03:00:18.408 - 03:00:55.946, Speaker A: They can be if you want them to be, but rather they are extremely prolific programmers. They are great programmers and they're not afraid to get their hands dirty. They will dig in, write code, check out your code, and try to make modifications. They will experiment on their own with random new system software. They're very good at programming, they're very efficient programmers. They write a lot of code, they understand the underlying systems, they're involved in their research projects. So it really feels like you're working with them rather than for them.
03:00:55.946 - 03:01:44.338, Speaker A: And if I were to give advice to other professors or advisors out there, that is hugely valuable to really at least be able to be close to the work rather than just supervising it. That doesn't mean that you have to be hands on all the time or like staring over people's shoulders, but be willing to be involved. I'm often disappointed that rust doesn't have reflection without writing your own macros. Has this bothered you at all? No. I feel like it's rare that I actually need it. Usually I get pretty far with just generics and to some extent like the any trait but actual reflection I rarely have the need for. How comfortable at assembly am I? Not super comfortable.
03:01:44.338 - 03:02:36.706, Speaker A: I can decently read assembly, but I would not say it's something I'm super comfortable with. Are you excited for Wasm and Wozi? Yes. I think it is a very promising space that's already showing a lot of value, and I'm particularly excited for how it might be used for interoperability in sandboxing. Can you do a video on gats and how where to use in some edge cases one day? Probably not yet. I'll probably wait until they've had a little bit more of a Runway and until some of the restrictions have been lifted, because currently there are a lot of fuzziness around the edges of gats, of where it should be used, where it shouldn't. What restrictions are going to be long term, which are going to be short term, that kind of stuff. Should I just clone my strings? If performance is not a problem, is it considered bad practice or just fine.
03:02:36.706 - 03:03:28.284, Speaker A: It's just fine. I tend to write my programs in such a way where I try to avoid cloning when I don't need to, just so that I'm in the habit of it in case it does matter. But I don't go out of my way to avoid cloning when it doesn't matter. Like if there's like two paths where one is do something really annoying to not have to clone a string or just clone the string, I'll just clone the string, but I will generally write my code so that I don't have to clone do you still support Australia in the World cup? What do you mean still? I never supported Australia in the World cup in the first place. No, I mean I don't really have a strong preference for countries in the World Cup. Norway isn't in there because Norway is not that good at football. Although we did beat Brazil once.
03:03:28.284 - 03:04:41.362, Speaker A: We'll always stick to that, but I don't really have a favorite team. What are the best resources to find interesting and free to download research papers? I think all of the OSDI and SOSP papers are publicly available. Otherwise you can usually find them on Google Scholar because like the authors put them out as PDF's on their websites. For example, please do a quick public service announcement about what is an xy problem so that more people are aware of it. Okay, so the Xi problem is there are a couple of different instantiations of it, but very basically, if you come to me saying, hey, I have a problem, how do I do x? Or how do I do y in rust, how does, like, how do I, I don't know how to do inheritance in rust. It's like a common instance of this. Then the xy problem is you came to me with problem Y, but really you should have come to me with problem X, which is the problem that came before how you got to your current problem.
03:04:41.362 - 03:05:51.970, Speaker A: So rather than asking me how do I do inheritance, you should be telling me, I want to do x in rust. And I currently think the way to do that is inheritance, which it doesn't have. But by telling me about the originating problem, I can give you a solution that's not here's how you do inheritance and rust, but instead solves your problem in a better way. So very often, if you have a problem, before trying to pitch it to others, try to make sure you give sufficient context that if there are alternate solutions to the sort of bottom of the stack that you've ended up at, people can give solutions that are higher up in the stack and avoid the deepest problem you've arrived at. Okay, let's do three more. What are some interesting weekend projects for rust to learn from? For rust to learn from? I think you mean to learn rust from. Weekend projects to learn rust from.
03:05:51.970 - 03:06:13.654, Speaker A: I love writing parsers, like pick a random file format and try to write a parser for it. In rust, it's fun to learn a format. It's also code that might actually be useful, somewhat interesting to write. There are many ways you can write parsers. It's a little bit performance sensitive. It's easy to test it, easy to benchmark. If you're just looking for something, just like try out.
03:06:13.654 - 03:06:59.010, Speaker A: Parsers are a good place to start and I think that's where I'm going to start, is there are lots of file formats. It's easy to do it in different languages and compare. Write a parser. Okay, two more. Would you recommend getting a master's degree in computer science, or do you think a bachelor's degree is enough for a programmer career? Oh, a bachelor's degree is definitely enough. The value in a master's degree is twofold. One is that it tends to give you more leeway to explore.
03:06:59.010 - 03:08:16.658, Speaker A: That means both time like it gives you you can spend more of your time on looking at things that are unrelated to work, in this case, your studies, because the academic setting tends to just have a lot more flexibility at the boundaries and generally more spare time that you can spend on whatever you want. And the other thing that a master's degree gives you is it allows you to learn a lot about a field that you didn't know a lot about previously. If you're doing a master's in something you already know really well, that second value category sort of goes away. But it can be a really good way to explore a space that you've been interested in and sort of just dedicate time to learning it really well, which is harder to do in an industry setting. Usually you're not really encouraged to branch out in quite that way because you lose productivity when you switch fields, whereas in academia that's fine. So it's a good way to explore in both of those ways. For the last question, I'm actually not going to pick the top one.
03:08:16.658 - 03:09:48.736, Speaker A: I'm going to scroll and see if there's one I really want to answer. How are there questions? I'm going to answer this one just because it's simple. How are the questions from three days ago? It's because I announced this stream and the question asking website a week ago or on Tuesday, Monday, Tuesday. Just like scrolling down the question to see if there's one that particularly strikes me as I really want to answer this it what are your thoughts on creating a small twitch bot with a command like WwW to create and submit questions that we were wondering directly from Twitch chat? Happy to help if interested. That might be neat. I don't know how annoying it is to write bots for Twitch. That could be fun.
03:09:48.736 - 03:10:45.970, Speaker A: One of the things that is a little weird for me is that I do dual streaming, so I stream through the service called restream to both Twitch and YouTube at the same time. And so it's a little odd to have a bot that only responds to comments on Twitch but not on YouTube because it already syncs all chat, for example. So ideally what I would want is sort of a restream bot, but I don't think they support that. I have for a while considered whether I should just pick one platform or the other, but at least last time I looked at it, the viewership was split like almost 50 50 between YouTube and Twitch. So that indicates that there's sort of a, people have a preference for one or the other and tend to stick with it. And so it feels unfortunate to have to leave one or the other half behind. That's not to say that it's not worthwhile to have a bot that only works on twitch.
03:10:45.970 - 03:11:38.834, Speaker A: I don't know if it matters. It is true that as I'm sort of watching chat on the side, a decent number of questions tend to come in there. But I think the same thing is going to come up where people won't know to use the bot, and so therefore, just like they don't currently know to use the website, and so someone's going to have to tell them, and then does it really matter whether they do it with a question thing or go to the website? I also like to encourage people to go to the website because it means that they're more likely to vote for other people's questions. And I think the votes actually matter a lot. Whereas if everyone's incentivized to just fire off questions from chat, they're going to be fewer votes and more single vote questions, which isn't ideal. So that's my take here. Okay.
03:11:38.834 - 03:12:01.470, Speaker A: I think that's all we're going to do today. Okay. We got through a lot of questions, I think. Oh, that's one thing I should add is a count of the number of answered and unanswered questions because currently, there's no actual count shown anywhere. Great. Thank you all for watching. Thank you for coming out.
03:12:01.470 - 03:12:28.980, Speaker A: I'll make sure that when I upload this afterwards. I should have said this at the start. When I upload this video, I'll put in chapter marks for all the questions you can easily like, go back to look at what questions you may have missed and stuff. Next stream will probably not be a Q and a now that I finally got through all the things I wanted to do in the Q and a, so I'm guessing another crusted, rust or implust stream whenever I next have the chance. See you all. Thank you for coming out. Bye.
