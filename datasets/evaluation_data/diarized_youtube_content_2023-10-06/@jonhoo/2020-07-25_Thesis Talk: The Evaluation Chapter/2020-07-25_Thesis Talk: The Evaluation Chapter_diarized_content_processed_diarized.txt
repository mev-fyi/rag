00:00:00.240 - 00:00:57.505, Speaker A: Folks, welcome back. This is going to be a little bit of a different stream than the ones that I usually do because normally I do these like Rust teaching streams, whether they're like live coding, usually live coding, but they're focused more on like Rust code. In this stream, I want to focus more on my thesis work, which happens to be implemented in Rust. But it's not like this is not going to be a Rust stream in some sense. This is more going to be like an academia stream in particular. I'm currently writing my PhD thesis and as a part of that, it's just been a really interesting process to go through of like, how do you write a PhD thesis and what kind of things do you need to think about? And my guess is there might be multiple of these streams because there are many facets to a thesis that might be interesting to work on in particular. What I want to focus on this time around is.
00:00:57.505 - 00:01:43.593, Speaker A: Let me pull this up to the start is the evaluation section. This is the first part of my thesis that I'm writing. I have some text for the other sections, but the evaluation is the one that I've been like iterating on over and over for the past few weeks. And I wanted to take some time to basically work through my eval section and talk a little bit about why it is the way it is, why it has the graphs that it does, what it's trying to say, how it's trying to say it, and how I arrived at its current form, which I still think is not its final form. I'm going to do this relatively informally. This is more. I'm not going to be like reading my eval section, but I'm more going to try to give you an argument about my work and try to present the argument that this is making.
00:01:43.593 - 00:02:17.485, Speaker A: And then I really would just want to hear what do you think about it. I also want to approach this a little bit like a sort of Q and A type thing where if you have questions about, I mean, the eval section of course, or about my thesis or just about like writing a thesis in general or about PhDs in general. Any of these questions I'm happy to try to take over the course of the stream. I'll do my. Yeah, I'm going to zoom in once we actually get closer so that you can read the text and such. The text won't be too, too important in these. I'll focus more on the figures as we go later.
00:02:17.485 - 00:02:54.133, Speaker A: So someone just asked a question of whether this is a practice for my presentation and this won't really be that. Like this won't be a thesis presentation. I'm going to talk relatively little about what my thesis work is. I'm more going to talk about the argument for why it's a good thing. But of course I will need to do some setup to just explain what my work is at all. I'm going to do like the brief intro I sometimes do just because it's useful for people who may not know who I am outside of this particular stream. So I do a lot of different streams, usually focused on the Rust programming language.
00:02:54.133 - 00:03:40.735, Speaker A: I upload all the videos and will also upload this one to my YouTube channel. You can also follow me on Twitter if you want to sort of hear about some of the work that I'm working on, or if you just want to stay up to date about new streams that come out Sometimes I do polls and stuff here as well about what stream topics I'm going to cover next. And in fact, this stream came about because I tweeted out like, would anyone be interested in looking at sort of a walkthrough of a thesis evaluation? And there was a lot of interest. So that's why we're doing this. So my thesis work is. It revolves around a project called Noria that I've worked on now for about five years, a little over five years, and at a high level. Noria is a database.
00:03:40.735 - 00:04:13.889, Speaker A: It's a relational database, sort of like MySQL or Postgres or Oracle DB. Very similar in terms of how you should think as an application about using it. But NORIA is trying to solve the problem that traditional databases are really slow for workloads that are pretty common. In particular, you end up in this situation where you. You have your database and you do lots of reads and you do some inserts and updates. But reads are like select. Queries are the things you issue most frequently.
00:04:13.889 - 00:05:05.515, Speaker A: But the database is built in such a way that the reads are relatively slow every read. Every time you do a select, the database has to plan the query. It has to execute the query by looking up all these base tables and doing joins and aggregations and whatnot. This means your reads, even if the results haven't changed since the last time you issued the same query. For example, the performance of your application ends up not being as fast as you want it to be. And the solution that many people have to this is like you stick a cache in front of the database, you use memcached or Redis or something like that, and then you have your application like check the cache and hopefully hit in the cache, in which case the result arrives immediately or it misses in cache, it goes to the database and then fills the cache. This is a fairly standard setup that many people use to boost their database performance.
00:05:05.515 - 00:06:38.095, Speaker A: And it turns out, and this is part of the argument we're going to be making in the eval section is it turns out it's just really hard to get caching right. If you've tried to implement caching yourself, you might already have realized this. And the observation behind Noria is why doesn't the database just. Why doesn't the database just solve this problem for you? Right? Like the database already knows all your queries and how they're arranged, so why can't it maintain the cache? And that is what Noria does. I'm going to pause here before we dive into the sort of evaluation, just to get questions about what I've mentioned so far of like the setup of the project, what I'm roughly working on, and also just questions about what this particular stream is going to be. Let's see here, does GraphQL help with that? So, GraphQL, I've gotten this question a couple of times actually, of like, why SQL? Like why is Noria a SQL database? Does that, does that make any sense? Because we see all These like no SQL databases or GraphQL or data log based databases and these definitely have their uses, right? Like you want a query language that is well suited for the task at hand and that's not always SQL. But that said, SQL is by far the most common query language in use today.
00:06:38.095 - 00:07:33.575, Speaker A: And when I initially set out to build Noria, it was sort of with the idea that I wanted to make things better for application developers. And realistically they're not going to rewrite their whole application. If I told GitHub that you're using SQL today, stop using SQL, use Noria instead. They're just not going to do it if they have to change their query language. The only reason to do this is to use something like GraphQL or make up your own query language would be if you think it gives you a significant benefit in terms of the system that you implement. At least it wasn't obvious to me at the time that a different query language would have given additional advantages or given additional insights into the way the application functions or the things that the application is interested in beyond what SQL gives you. And so it's sort of like SQL is the default, so let's make the default better.
00:07:33.575 - 00:08:18.705, Speaker A: The two Hard problems of computer science. Caching and naming things. Yeah, caching, a concurrency, cache and validation and naming things. It is definitely very common for people to run into problems with caching and part of it is because it's, it's just really hard to get it right because you now have two systems where one is sort of a mirror of the other. But you need to keep these mirrors in sync. And we'll see a little bit about that argument in the eval section. Is there a team working on this or just me? There are a bunch of different students at MIT and at other universities actually over the years who have worked on Noria.
00:08:18.705 - 00:09:01.405, Speaker A: The primary developers for much of Noria's lifetime has been me and Malte Shwarchkov, who's now an assistant professor at Brown. And we've been like the main people behind the project and then of course my various advisors or the professors that I work with. Over the years we've had many other, both master's students and undergrads and PhD students who have sort of gone on and off the project. And so in that sense it's very much sort of a team effort. But the core people behind it are Malte and myself and we've all worked on somewhat different aspects of Noria. Noria is a pretty big project and it's. It would be hard to do it all by yourself.
00:09:01.405 - 00:09:32.581, Speaker A: And so my thesis is specifically on one aspect of Noria, which I'll get to into in a second. Doesn't postgres and my SQL already do query caching, so they don't really. They, they do. They cache things like query plans. They don't really cache results. And if, if they have support for actual query result caching, usually it just gets invalidated. Like if a write happens to the table, the whole cache gets invalidated.
00:09:32.581 - 00:10:09.943, Speaker A: Which of course is really bad if. If popular keys keep being updated. For example. Is it similar to Google Spanner? No, it's very different internally. How does Noria differ from row or column based databases? How are you getting your. Your efficiencies? So Noria primarily gains things from caching results. It caches the full result sets for queries and then that means your results can just be fetched directly from cache and it keeps the cache up to date as you go.
00:10:09.943 - 00:11:21.255, Speaker A: So if some data in one of your base tables changes, Noria will actually compute how that changes every cache result rather than just invalidate them. And it can do this because it knows all the different application queries that, that are currently standing in the system. Is a cache miss costlier than a database read? I mean a cache miss requires that you do a database read. So yes, it must be costlier is Noria acid? So acid is a term used to describe certain databases as it's like atomic consistent atomicity, consistency integrity and durability. Noria provides some of those, but it certainly has a much weaker consistency guarantees than traditional databases. If your project specializes in read heavy workloads, how does it hold up unfair in write situations? This is another thing that we'll look at in the eval section a little bit. Basically the project is entirely targeted at read heavy applications, but we obviously there has to be some amount of rights, otherwise the system is sort of uninteresting and we'll look at how that works out in a while.
00:11:21.255 - 00:12:24.155, Speaker A: Let's see here. Is Noria named for the water wheel? Yes. The idea this came from Malta actually the name Noria comes from like it's using the flow of data to bring something to a higher level. It's a very indirect name, but as many academic names are at what layer of the database is the caching mechanism implemented? So Noria is implemented as a very different type of database. Internally it looks nothing like MySQL or Postgres internally, Noria is a dataflow system. Essentially what it does is it constructs a dataflow program that keeps every single cached query result up to date. So as data sort of flows into the base tables, they flow through this graph of data flow operators that ultimately compute the changes to the materialized views, as they're called, the cache query results at the bottom.
00:12:24.155 - 00:13:29.345, Speaker A: What is your hope with Noria? Are you looking for wide scale adoption? It would be really cool. Noria is not currently production ready. It is very much a research prototype. But my hope would be that if not the Noria implementation specifically, that something that provides this would actually see adoption, because I think it's a really valuable thing as you'll see from the eval later on as well. How does differential data flow from MSR fit in there? Differential data flow is a little bit different in a couple of ways. One big difference with differential data flow and timely data flow, if you're familiar with those, is that they target much more sort of batch computation and much higher consistency than Nor yet does. They're built much more for write pipelines than for read pipelines and they target computations where the consistency of your results is vital to the application's correctness.
00:13:29.345 - 00:14:10.395, Speaker A: And so this is things like if you have loops in the data flow graph, you Want to make sure that you always compute the right result. If you do a read, you want to make sure that it represents strictly all the writes that happened before and none of the ones that happened after. Noria does not quite give the same guarantees. But what Noria does give that differential data flow does not do is for Noria, reads and writes are separate things. The reads do not go through the data flow at all. Instead they just read, read from the cache and then they have a way to sort of poke the system to fill in things if they miss in cache. Do you believe your approach is the future? I think it's a good idea for some applications.
00:14:10.395 - 00:14:36.671, Speaker A: I don't believe in this. Like there's one solution that fits everyone. That seems unlikely. Is the cache always in memory? Yeah, Norway. Nor yet does always cache everything in memory. And this is going to be an important point is basically the memory use of Noria, because Noria caches the results of every query you give it. And that obviously means that your memory use is going to balloon.
00:14:36.671 - 00:15:21.885, Speaker A: And we'll talk a bit about that later. What happens if somebody were to put this into production? They'd probably be making a mistake just because it depends on what they expect from the system. But Noria has only been tested in the context of academic research. And so there's a bunch of properties you want from a production ready system that Noria can't really guarantee. For example, does not guarantee that it won't crash if it gets a bad query, which is never what you want in a production system. And fixing this shouldn't be too hard, but it just requires a bunch of engineering effort that isn't really warranted in a research prototype. Is it scalable? We'll get to that when we get to the eval.
00:15:21.885 - 00:15:55.293, Speaker A: How will it cache something like a random value? So Noria is based only on relational algebra. So there all of the operators are like deterministic and commutative. So there's no random value in that sense. Like if you're thinking of like MySQL Rand, nor yet doesn't have that operator. In theory there might be a way to implement it, but that's not something we have. Is Noria multithreaded? Yes. Is there a built in way to do subscriptions? Sort of.
00:15:55.293 - 00:16:37.359, Speaker A: Like, because Noria is a dataflow system, any changes to the base tables are basically going to propagate as sort of incremental deltas down towards the views at the bottom and ultimately you could feed those to the application as well. I have no opinions on closure or datomic. Is the long term goal to productify Noria or is it meant to be a proof of concept for others to reimplement for production? I don't know yet. It sort of depends where the future goes. I want this to exist as a real thing. The path there I don't quite know. I'm also in a position where like I've.
00:16:37.359 - 00:17:29.225, Speaker A: I've worked on this for six years now and I certainly need a break from it. Not because I don't think it's a good idea, because I really do, but more just like my brain has been thinking of nothing but this for six years and I need a break. Is it distributed? Yes, it is distributed. Did you try out any other distributed systems ideas for your thesis? I did work on some other projects initially that didn't pan out, but this is what I've worked on for a very long time now. That. So someone asked, is this your thesis? And Noria itself is not my thesis. I'm focusing on a particular part of it because Noria is a fairly big beast and there are a lot of sort of different corners of it that you could write a thesis about.
00:17:29.225 - 00:18:08.299, Speaker A: And so actually that's a good segue into that. I'm going to do one or two more questions and then we'll dive into the actual thesis part of this. What's happening on the chart at 5000 views per second? Was that a crash? It was not a crash. I'll explain this kind of graph a little bit later when we get to eval. Can be implemented for back end systems written in Go Node and Java. Sure, yeah, you can use as normal database. Could you also explain in brief, what is dataflow? Yes.
00:18:08.299 - 00:18:51.075, Speaker A: So dataflow is a pretty poorly defined term, but it basically means that instead of having code fetch data and then operate on it, the data flows through. Think of it as a sort of like a tree or a graph where data comes in at one at the top. Let's imagine the top of the graph and then it flows through the graph along the edges and every node in the graph does some kind of processing on that data. And then ultimately what you end up with as the leaves of the graph are the ones that see the result of the computation. That's a very high level description of data flow. Noria was written in Rust from the beginning. Yep.
00:18:51.075 - 00:19:35.395, Speaker A: Is this something like Kafka streams? You can think of data flow a little bit like Kafka Streams. Or alternatively you can think of Kafka as implementing one type of dataflow but Noria has nothing to do with Kafka. If writes would only return only once the cache is updated when Noria provide acid no. The details for why the answer is no to that are a little bit outside the scope of this particular stream. But we might get into it if we do another thesis stream on the design of Noria. For example, there is no master master or master slave in Noria's distribution. It's not a primary backup type setup.
00:19:35.395 - 00:20:17.505, Speaker A: It is completely distributed in the sense that every operator of the dataflow graph can be on a different machine. And yes, I think Russell was the right choice for this. And no, it can sadly not make toast. Okay, so let's try to actually dig into what part of this my thesis is about. So one thing we talked about was how we're in this world where we want to cache results so that we can get the results faster, but caching results cost you memory. Every time you cache the result of a query, you need to store it somewhere. And if you're not storing it on disk, which would be fairly slow, you're storing it in memory and there's a limited amount of memory.
00:20:17.505 - 00:21:15.047, Speaker A: And so one of the key contributions of Noria is that it supports something we've called partially stateful data flow or just partial state. And the idea behind partial state is that you teach the data flow how to compute results after the fact. So normally in a, in a data flow system, every time new data arrives, it flows through the whole graph and then it, the whole data flow program and then it updates whatever leaf nodes have state and those are the ones you read from. And this works pretty well, but it does mean that you can never throw anything away. So with Noria, we teach it something called an up query. The idea behind an upquery is basically that you have a way in the dataflow graph to send a query up the graph. So normally in dataflow the data flows down an upquery flows up the graph.
00:21:15.047 - 00:22:04.455, Speaker A: And it's basically a way of asking your ancestor to resend data it sent in the past. And it turns out that this is actually sufficient to give you the ability to evict. It gives you the ability to only, only materialize, only keep parts of the cache that are important to you. So you don't need to cache the results for like a query that was issued like 10 days ago. And you also don't need to maintain the number of likes for some tweet that no one has looked at for 10 years. And so this really lets you bring down the memory use a lot, because suddenly now you only need to cache the things that are actively being accessed by the application right now or in this short period of time, rather than any query that's ever happened. And so that is what my thesis is about.
00:22:04.455 - 00:23:03.185, Speaker A: It's specifically about this support for up queries. And it turns out that that little mechanism, the upquery, is sufficient to give you the ability to give full eviction even internally in the graph, right? So imagine that you have this data flow program that computes lots of SQL queries. Every node in that graph is basically one operator in your SQL query. So if you do something like join A with B, that join will be an operator, a node in that graph. If you do something like count votes, then the count operator is going to be one node in that graph. And some nodes have to be stateful, right? So the count operator, if it's told that there is now one more vote for Article 7, then it needs to know what the previous vote count was in order to be able to say what the current vote count is to whoever is below it. And this means that that node needs to have state, it needs to have memory.
00:23:03.185 - 00:24:00.795, Speaker A: And partial state actually works not just at the leaves which hold the full query results, but all the way through the graph. So if you have a count over votes, that grouping by article id, for example, it doesn't need to store the count for every single article that is in the database. It only needs to store the counts for the articles that have been asked for recently. That was a lot of sort of technical detail in a short amount of time. So let's do questions about partial state and stateful data flow. I realized that I'm running through a lot of fairly complicated database setup here, and it's because I'm trying to get to the eval section a lot more of the sort of deeper design details I'll go through in another stream. And you basically only need to understand the high levels of what I just explained in order to understand the eval section is at least the hope.
00:24:00.795 - 00:24:41.021, Speaker A: Let's see, it feels like eventual read model composed through message passing of data changes of data changes between some objects. That's sort of true. So. Well, kind of. Okay, so let me try to rephrase, actually let me try to draw this, that might help. All right, so we're in a position where imagine that you have. This is like.
00:24:41.021 - 00:25:59.279, Speaker A: I'm going to go back to a classic example here, which is you have an article table article and you have a vote table, right? And let's imagine that what we want to do is we want to fetch an article, fetch a given article along with its vote count. So we're going to issue a query like select article star and count of vote from article. Sorry, my writing is terrible. Left join vote using article id and then we're going to group by the article. I didn't set up my pen correctly before the stream. My bad. We're going to group by the article ID where the article ID I'm just going to shorten it is some parameter to the query.
00:25:59.279 - 00:27:20.059, Speaker A: So this is a question mark, this is a prepared statement. And what NORIA is going to do when you give it the SQL query is it's going to look at the base tables and go, how can I set up a dataflow program that computes the result for this query? And the way it's going to do that is it's going to create an account node here, account operator over vote that is sort of told to group by the article id. Then it's going to create a join node here which is going to be a left join between article and the vote count. And then below that it's going to create like the actual, the actual cache that the application ends up reading from if it issues a read to this query. And notice that all of this is sort of keyed on the article ID, right? If I execute this query with article ID 7, then I'm going to look into this cache for article ID 7, right? And then the system will give me only the results for this query with that index or with that article id. And you can see from the setup what happens if, for example, a new vote comes in, right? A new vote comes in, it flows down, down the data flow along this edge gets to the count operator. The count operator increments the count for article seven.
00:27:20.059 - 00:28:15.471, Speaker A: So maybe it remembers like seven used to be four, like the count for article seven used to be four. And then it's going to now update that to be five. And then it's going to send along this line like a minus 4 and plus 5 for article ID 7. And then this is going to join against articles. It's going to do a lookup into article and then ultimately it's going to forward an update down to the view that says how the view should change. And then of course, the problem here is if we do this for every different article id, then this view becomes very large, right? It becomes sort of if, if we wanted to use that notation O of N, it stores every article, it stores one row for every article. Whereas in reality, like many articles, like basically any article that's more than like a week old is probably never going to be looked at again.
00:28:15.471 - 00:29:35.773, Speaker A: And so why are we continuously maintaining that state and keeping a memory and spending memory on it? And what partial state lets you do is that instead of storing all of these, we're only we're initially going to start with storing nothing in here. And then if a query comes in for seven, then this, this view, when it realizes it doesn't have seven, it's going to send an up query for seven to this join, it is going to send an upgrade to article for seven that's going to flow back. It's then going to try to do a lookup here for seven, this doesn't have seven, so it's going to do an up query there for seven, the result is going to come back and ultimately the full state for seven ends up coming back into the view and the cache gets populated with number seven, at which point we can reply to the user. So let's see whether this explanation of partial roughly makes sense. How do you define recent in the setting of databases? Well, recent in what sense? So in terms of whether we decide to keep it in cache, you can use basically any caching strategy here. It can be like least recently used. You can do things like least recently written in Noria.
00:29:35.773 - 00:30:26.919, Speaker A: Currently the strategy is random, like it just evicts a random entry whenever it has to evict, which is not perfect. But Noria is not trying to innovate on caching strategy, it's trying to innovate on caching mechanism. And you could always implement a different caching strategy if you wanted to. How does Noria or a system like it perform when it has to query a huge range of data? Let's say you have a node or query that uses a couple of dozen million rows. So Noria is definitely not written for applications that are sort of analytics queries heavy. So if what you're doing is like scanning your whole data set every time you issue a query, that's not what Noria is for. Then you want more sort of a batch processing analytics processing system, which Noria is not targeted for.
00:30:26.919 - 00:31:11.475, Speaker A: Noria is built for applications that are more likely to do like point queries or narrow range queries into the data, because that is when you can use this partial mechanism right of you don't need to store the whole result set. If think of it this way. If your query depends on every single piece of data in a given table or A very large portion. That means that if any of that data changes, the whole cache now needs to be updated, which is not great. Let's see here. Does the cache have a ttl? There's no TTL in the cache. There could be like Again, the caching strategy here is sort of up to you.
00:31:11.475 - 00:31:53.165, Speaker A: Noria is basically for the web. Yeah, that's a pretty accurate way to say it. It doesn't have to be. There are some use cases on mobile for example, but it is certainly geared towards basically read heavy web applications. Does that mean that the more cached queries you have, the more writes will be slow? Yes, that's a very good observation. So the more queries you have in this data flow, like imagine that there were tons of different queries coming off of here. Then whenever a vote enters the system, it would be more expensive because the vote would have to be processed by each of those child operators.
00:31:53.165 - 00:33:02.765, Speaker A: Yeah, so instead of having the data flow graph keep the read cache up to date for every change to the base data, the upquery sort of is an on demand pull of the data. You can think of this as it serves a similar way of a similar role as in a normal application that does caching, where if you miss in the cache you have to query the database, except that it happens internally in the system. Are there situations when Noria performs worse than an uncached database? Oh, almost certainly. First of all, Noria is relatively new and it's a research system, so it hasn't seen as much query optimization work as databases does. But also because Noria has this push this data flow model, it means that there are a bunch of optimizations the traditional databases can do to the to the query that we can't do. So for example, if you were given a query and you could choose exactly how to like scan the base tables, for example, you can implement some joins a lot more efficiently. And Noria doesn't get to do that.
00:33:02.765 - 00:33:46.919, Speaker A: It is sort of a this like update at a time processing kind of. Nor yet does not really maintain a change history. No. If this is a high performance system, does it make sense to use this on top of any other database? Like a cache or layered approach? Noria currently assumes that it owns the data and part of this is because it needs to ensure some amount of consistency between what's computed in the data flow and the data that's stored in the base tables. And part of the reason for this is when an upquery comes in. So imagine that this blue upquery for seven Goes up to article. There can still be writes in transit here while that upquery is ongoing.
00:33:46.919 - 00:34:14.477, Speaker A: And Noria needs to ensure that it doesn't like duplicate a given piece of input data or end up not including a particular input data for any results. And so to keep that consistency, Noria does assume that it owns the data. But in theory, each of these could be implemented as database tables. They aren't currently. So up queries. Queries the ancestors, which further resolves to the dependencies. Yes.
00:34:14.477 - 00:34:54.751, Speaker A: So they recurse and then the nodes hold partial state instead of full state. That's exactly right. There's no formal verification or model check in Noria. There are a lot of places where I could see it being used, but that's just not what I focused on. This reminds me of Meteor js. It's interesting you say that, because the model of Meteor js, the application model feels very similar, but the implementation is very different. How would that compare with Materialize, which is a streaming database also written in Rust? Yeah, so Materialize is built on differential data flow and timely data flow.
00:34:54.751 - 00:35:32.895, Speaker A: So the answer there is pretty similar. Like I interact a lot with the Materialize people and they're doing some really cool work. They're targeting slightly different application needs than Noria is. Like, Noria will not work well if you need strong consistency in your query results, for example, but it is real fast if you have a read heavy application because the reads don't have to go through the data flow. And also because Noria lets you evict, which as far as I'm aware, Materialize does not really let you do at the moment. All right. Do you ever evict a query from cache? Yeah, you can remove queries.
00:35:32.895 - 00:36:06.543, Speaker A: Okay, so let's now try to get to Eval. I think we have enough context now. And even if you haven't followed everything we've done so far, I think the eval questions are very related to the kind of things you've already asked. Okay, so the eval section. Yeah, so someone pointed out I have to read up. Everything's going over my head right now. And I think there's a good comment here, which is basically, you have to realize that this is the result of like many years of work.
00:36:06.543 - 00:36:52.575, Speaker A: So the fact that you don't immediately get it is not weird. Like there's a lot of complexity here and I'm explaining it very rapidly and at a very high level when there are clearly a lot of like underlying technical nuances. But the reason. But it's okay that you don't understand it, right? Part of that is like, this is why I'm writing a thesis on it, right? Is because I need to take all of the knowledge I have of this problem and the solution and like put it on paper so other people can understand it. And I'm not going to be able to do that in like half an hour on stream. But what I want to do for, for this stream is to specifically look at how do we even evaluate this as a solution. The evaluation has very little discussion of the internals of noria.
00:36:52.575 - 00:37:40.535, Speaker A: It has very little discussion of like how NORIA is built. It's just looking at let's assume that you solved all the problems, or let's assume that you present Noria as a complete solution. How do we figure out whether Noria actually is a correct solution, whether it is an appropriate solution, whether it's a good solution, irrespective of what happens under the hood. The eval section, like sometimes it goes into some low level questions about how does this mechanism work. But very often it's just like now that we have this as sort of a candidate solution, how can I try to convince people that it's actually a good solution? And that is very much what an eval section centers on. EVAL stands for evaluation. It's a short way to say evaluation.
00:37:40.535 - 00:38:36.695, Speaker A: Okay, so I don't know if you can read this text. It's not terribly important that you can read it exactly. But the evaluation section pretty much tries to make one argument. And the one argument it's trying to make is that NORIA is a good solution to a useful problem. Now of course there are many facets to that statement, but that is sort of the high level point that the eval section is trying to give. And the way it goes about it is first to say that Noria to sort of try to state the problem that NORIA is trying to solve. And specifically it starts out by saying the thesis is built on the belief that view materialization is useful.
00:38:36.695 - 00:39:40.605, Speaker A: View materialization is sort of the database way of saying query caching. And then it goes on to say but that it's prohibitively costly to use it with current solutions. So this is like the high level point, right? Like this thing is useful and we're going to demonstrate that, but you can't do it at the moment, and that is sad. And then it says, well, the thesis prevents a partial state as a solution to this problem. And then the first section of eval, well, the second section, we'll get to that in a Second is going to evaluate the validity of the assumption that view materialization is useful and also the efficacy of partial state as a solution to that problem. So this first paragraph, even though it's currently a little poorly written, is basically trying to get at like the first question in someone's head is why should I care about this thesis? Why does it matter? Why is it important to me or to anyone else? And it's. And the first, we need to convince the reader that that is true before we can really do anything else.
00:39:40.605 - 00:40:57.563, Speaker A: Any other evaluation will just be ignored by the reader until they feel like there's something there that's worth reading. And the reason this is that the big question is answered in section 7.2 is because the first section of eval, as we'll see in a second, is the experimental setup. And this is extremely important when you write a solid evaluation section is that you need to explain what experiments you ran and how you ran it. Because without understanding exactly what the experiments are and the context in which the run, it's impossible to evaluate your results. Like if you show a graph that goes up and to the right, even if there are numbers like throughput or latency or whatever, you can't evaluate whether that's good or bad without knowing what experiment was this? Like, what were the inputs, what machines were they run at? What was the problem like, how complex was the solution? That there are all these other things about your experiments you have to explain, and those go in experimental setup, which usually comes first in the eval. And then the second argument that this makes is that with partial state, only a subset of each view is materialized.
00:40:57.563 - 00:41:33.209, Speaker A: So this is the whole partial state that we've talked about and that missing results are computed on demand. This is the upquery business that I was on about. The thesis then makes the claim that this reduces memory use. And we talked about why that might be. But it also means that some queries take a while to be satisfied, right? The intuition here is if you, if you try to read from one of the sort of query caches at the bottom, but your result isn't there, the database now has to go in. Like NORA has to go in and do all these up queries, which means that your result is going to take a long time to actually be computed. And the.
00:41:33.209 - 00:42:17.101, Speaker A: The thesis like this is just like an inherent problem in how Noria design. In some sense it's not even a problem. It's just like this is the trade off the Noria presents you with. It's saying that rather than computing everything and sort of fully materializing all of the results, which takes too much memory, we're going to not store some of them. And then the sort of obvious follow on truth from that is, well, if some of them aren't stored, you need to compute them on demand and that will be slower. And so what we're saying is that this is like a trade off between the cache size and your miss rate, or in other words your memory use and your tail latency. Tail latency is just a way to say your latency for the slowest requests.
00:42:17.101 - 00:42:48.223, Speaker A: The tail is sort of the. Imagine that you have like a million requests, then if like 999,000 of them are fast, but the last 100 are slow, then those would be your tail. And you can talk about various amounts of tail. You can talk about like the highest, the highest tenth or the highest hundredth or. We'll see some examples of this later. But we basically want to talk about like the worst case scenario. And in Noria, the worst case scenario is that you miss and that you have to upquery.
00:42:48.223 - 00:43:47.727, Speaker A: And we want to have the thesis be sort of honest and evaluate what is the cost of these misses. Because if every read was extremely fast, but if you do miss it takes like 100 seconds to compute the result to your query. That would obviously not be okay. And so the thesis needs to look at, well, how expensive is it actually? And so that's what we're going to look at in 7.3. And then one thing that's nice about partial state that I touched on briefly is that you can start out every piece of state once you have partial state as empty. This means that if someone gives you a new query, you don't have to do any work because the result set is just empty and we're going to fill it in on demand. You can think of this in terms of normal caching as just we're going to start with an empty cache and then we're going to fill it as the application does stuff seems pretty reasonable.
00:43:47.727 - 00:44:30.505, Speaker A: But remember that if you don't have partial state, you don't have this option. You can't have things be empty because they're either non existing or full. And so what happens in a traditional sort of view maintenance system is when you add a query, you need to compute all of its results. And that obviously takes a while. Even if you don't care about most of those results, even if the application only cares about a subset of those results, you have to compute them. And so section 7.4 is going to be looking at how much does partial help for this context, if you add a new view, a new query, how much does partial hate help speed that up compared to having to evaluate everything or compute everything ahead of time.
00:44:30.505 - 00:45:25.245, Speaker A: And then finally, and this is sort of a big one that was touched on in chat too, is we. Well, actually this one is a little bit different. But one of the things that's interesting about partial is that it only helps if you only need a small number or a small amount of your computed state. If your queries are just like touching all of your data most of the time, like every other second someone is like reading every article, then it doesn't really make sense to only cache some articles because every article is going to be requested again shortly thereafter. And so partial being useful basically relies on there being skew in the data. That is, if you have a million articles, some articles are much more likely to be read than others. It turns out that this is true in many data sets.
00:45:25.245 - 00:46:27.653, Speaker A: But we sort of need to convince the reader that this is true for applications that they care about. Because if the skew wasn't there, if the application just randomly reads data with no uniformly at random samples the data, then it doesn't make sense to only cache some things because the application will be slow a lot of the time. 7.5 is going to go into how confident do we feel that a small number of things, a small amount of your dataset is usually what you care about and therefore caching makes sense or eviction makes sense rather, if we can't show that, then no one is going to believe that partial state is useful. If almost every application needed all of their data all of the time, there's no reason to use partial state because you either need to compute everything or you're basically always computing on demand. So this brings us. There's actually a paragraph missing here.
00:46:27.653 - 00:47:16.453, Speaker A: I just realized. We'll get into that later. Okay, so I've walked through just like the high level argument that the evaluation is making. Let's pause here and see whether this made sense and also whether there are other questions you have about why this might make sense, or why it's trying to make these arguments, or why these are real problems. Before we move on, is there any way to have a look at the current version of your thesis? Is it going to be published? My current thesis? The source code for my thesis is online. The benchmark results are not just because I've been lazy, but they will be. And my final thesis, like the PDF of the final thing will be published.
00:47:16.453 - 00:47:52.175, Speaker A: Yeah. How is Noria handling caching in a distributed scenario? So we're not actually going to talk much about distribution in the eval section. And that is because we're focusing on partial state. NORIA does a lot of different things. And I'm basically trying to say my thesis is about only partial state. And the reason for this is it would be too difficult to write a thesis about all of Noria. And it would also have too many obvious holes.
00:47:52.175 - 00:48:59.545, Speaker A: Like there are a number of things in Noria that we haven't quite figured out yet. And it's a little unsatisfactory to write a thesis where a bunch of the answers are, this doesn't quite work, but we don't have a better solution. And distribution is one example where it works pretty well for many things. But once you start to do sharding, you run into some really weird corner cases that we just like, haven't looked at as much as we've looked at partial. What is the timeline on the thesis being finished? I'm hoping to finish by the end of October. It's very hard to say, like working on a thesis is weird because you're in a position where there aren't any set rules for when it's done. Instead, the thesis is basically when your PhD committee thinks that the work is sufficient and well enough explained.
00:48:59.545 - 00:49:11.119, Speaker A: And that is very subjective criteria to work towards. Right. You're. You're dealing with. Dealing with people who like. It's not that they're bad. Right? It's not.
00:49:11.119 - 00:49:52.365, Speaker A: They're not trying to get you or anything. It's just that it's very hard to know in advance what is going to be needed from a thesis until you see the results. And you'll see this for some of the graphs later too, where we went through so many iterations even just to get to this particular graph. And you can't ahead of time know how long that will take. So it's pretty hard to estimate how long writing the thesis will take. I will say that at least for me, the evaluation section is the one that has the most uncertainty about how long it will take because the other sections, like, I know how the design of NORIA works and that is not going to change for the thesis. I'll have to like actually write the text, but.
00:49:52.365 - 00:50:33.875, Speaker A: But that's just writing which just relies on me and I can evaluate it pretty well how far along I am. It's much harder to figure out how long it will take to write the evaluation section. Because you run an experiment, it doesn't quite show what you want to show, or it doesn't show it in the way that you want to show it. And so you need to like design a different experiment, run that different experiment, and then maybe that doesn't quite give the results you wanted either. And you keep iterating and you don't know how many iterations it will take until you're happy. And so this is also why I started writing my thesis with the evaluation section, because that is the one that I have the least knowledge of. How it's going to pan out.
00:50:33.875 - 00:51:09.585, Speaker A: Does evaluation propose a specific data model and how those connections affect the data flow process? I'm not sure I follow. The evaluation section is not looking at. It's not looking at. It's not exploring alternatives. Like, that's not really the role of the evaluation section. Sometimes it is, and we'll see an example of that later. But generally the evaluation section is like, I have now explained the full system to you.
00:51:09.585 - 00:51:30.315, Speaker A: Let me demonstrate that this is a good solution. So it's not really. It's not like sampling lots of things and being like, oh, maybe this could be interesting. It's really saying, here's a good solution and let me tell you why. What will happen to your streaming schedule after this is over? I want to keep streaming. I. Once I.
00:51:30.315 - 00:52:09.715, Speaker A: Once my thesis is done, I think I'll be able to stream more because I won't be in like thesis crunch mode. The explanation in the eval made total sense. Any guesses what giants like Reddit, Twitter and Facebook are running to mitigate the problem your thesis is going to describe? Yes, actually. And this is something the eval will touch on a little bit later and something I want to move earlier in the thesis, but I haven't had a chance to yet. So I'll get back to that question when we get a little bit later. I would like to hear all Your advice and PhD and thesis work in general. Maybe at the end.
00:52:09.715 - 00:52:59.853, Speaker A: Yeah, let's do some. We'll probably do some of that at the end. I'm sorry, but reading again, I'm unsure what. This enables fast adoption of queries. So this part. So that sentence is about how if you add a new query to the system, like you issue a query to the system it's never seen before, then in the sort of traditional data flow systems or materialized view systems, you would need to compute all the results for that query and store all of them immediately. Whereas with partial, you can start out with an empty cache and that only when particular parts of that query are being executed do you need to fetch them on demand.
00:52:59.853 - 00:54:12.431, Speaker A: A good example of this is if we go back here to this query, right? Imagine that the database or the application rather tries to prepare this query and this is a new query the database has never seen before. Then with full materialization, it would have to compute the results for every article ID because it doesn't know the article ID yet. Or it can do no work like it has to choose one or the other. With partial, we can set up the data flow and then when a query comes in for say 7, then we do this like upQuery business for 7, and from that point forward any query for 7 will be fast. With full materialization, when 7 comes in, either you've computed the results for this query for any question mark value, or you haven't computed any of them and you decide to compute it just for seven. Now imagine another query comes in for eight, right? In the full materialization world, either you already have the result because you computed it for every question mark, or you have to go ahead and compute all of this again for eight without. You can't really reuse any of this because it's all specific to seven with part partial.
00:54:12.431 - 00:55:05.099, Speaker A: These are just like an upgrade for 8. If that distinction made sense, it's created data flow static. Have you run into situations where suddenly another join order algorithm makes more sense? The data flow isn't static. You can add to it, but you can only append to it. So if you Noria can't currently like change the join order, for example, that's not a thing it can do without rearranging the cache basically, and sort of clearing the cache and setting it up again. You can imagine being able to do some transformations internally, but it's not something Noria currently does. Are you planning a postdoc when this is done, or do you have other plans? I'm not planning a postdoc.
00:55:05.099 - 00:56:10.951, Speaker A: I'm planning to probably go into industry, but I haven't figured out my exact plans there yet. Is materialization similar to building indices? It's not quite the same, but it's similar. So indices are usually added when you already have the data that you're creating. An index over materialization is computing a derived value of some data you already have, so you need some kind of stored procedure in advance. Well, Noria does rely on prepared statements, which are pretty common in how applications use databases today. So it does assume that it gets to know the queries in advance, and it also sort of assumes that the application is going to keep issuing similar queries. This is another case where we get into, like Noria sort of assumes that applications are basically web applications because they traditionally do this, right? If when you deploy a web application, it's going to issue the same queries over and over and over again.
00:56:10.951 - 00:57:11.595, Speaker A: So it makes a lot of sense for the database to take advantage of that fact. Aren't the databases not doing the data flow already? That actually makes so much sense. Yet databases today, usually they might describe what they do internally as dataflow, but they're executing it sort of bottom up and not in this sort of data flow down way. When a query gets executed, usually the database ends up finding the data that it needs and then building the results piece by piece, which is a little bit different to what we're doing here. Are you going to stay in the US after completing your PhD at least for a few years? My girlfriend is getting into voice acting and so she. She's moving to la and so I move into la and so I'll be there for at least like a few years. All right, so let's start to actually walk through the eval and some of the.
00:57:11.595 - 00:57:53.691, Speaker A: Some of the graphs and such that are there. Let me zoom this out a little. Okay, so first is the experimental setup. And this is a little bit important to understand what comes in the eval later, basically what we've done, or one of the primary parts of the evaluation for Noria is the Lobsters website. So if you're not familiar with this, Lobsters is a page that's like a little bit like hacker news, but it has a few key differences that made it more viable for use and evaluation in Noria. The first of these is that Lobsters is open source. It's a Ruby on Rails application.
00:57:53.691 - 00:59:15.367, Speaker A: And the source code we can actually inspect and crucially, we can look at which queries are being executed, which matters a lot for Noria. Then second, I interacted a little bit with some of the Lobsters administrators a few years ago and I managed to get sort of anonymized data statistics about the lobster's database. Basically things like how many votes do users have on sort of like how many users have 10 votes or fewer? How many votes have between 10 and 50 votes? How many users have between this and this many votes? How many articles have between this and this many votes? Which pages are most frequently accessed? How often are they accessed? How popular? What's like the distribution of popularity for articles? What is the popular. What is the distribution of Number of comments for different articles. So I got all these statistics about lobsters, and this let me build a workload generator. So a workload generator is basically a way to construct, construct a benchmark that is artificial, right? It's not running the actual lobster's code base, because Ruby on Rails is pretty slow for something like that. But it means that I can run an experiment that shares many of the properties of a real data set.
00:59:15.367 - 01:00:02.371, Speaker A: In particular, what I did was I built a workload generator that produces page view requests that resemble the ones that you would see see in the real lobsters. So it will generate like most of the page views that are requested will be like requests for a particular story, and it will request like a particular. A particular set of stories more often than others. So this is the skew that we talked about. But all of the different parameters for how these are skewed. Like which if the workload generator decides that this user is going to vote for this story, it chooses to do so in a way that matches the statistics that we have about the actual lobster's data set. And there are a couple of reasons to use a workload generator.
01:00:02.371 - 01:00:51.509, Speaker A: One is that we can avoid Ruby on Rails, and the second one is that we can scale upload. So if we just worked from the base data set and just ran that, we wouldn't be able to experiment with. What happens if there were twice as many users? What happens if there 100 times as many users? When load increases, there are a bunch of other properties to change in the system. And a workload generator lets us sort of artificially turn up and down the heat, so to speak, to evaluate how Noria performs in different settings and at different load factors. All of the experiments are run on EC2 on multiple different machines. Generally the server is given a single machine, and then there are multiple clients issuing requests. And interestingly, all of the benchmarks are open loop.
01:00:51.509 - 01:01:58.913, Speaker A: So what this means is, and this is a pretty important thing that I think systems researchers need to do in their evaluation sections, which is a common way to benchmark is that you have just like a while loop that does the thing and then measures how long it took and then does it again and it just runs in a loop. And this is kind of a bad way to benchmark things. In fact, it is a bad way to benchmark things. And one reason why is that is not how a real application would work In a real application setting, right? Requests are coming in at some rate, and if your system takes a really long time to answer one request, more Requests are going to continue to come in while that request is being being serviced and those requests are going to be delayed by however long it took to run the slow request. If you just benchmark timing an operation in a loop, you will never see that. You'll just see that one request was slow. When in reality, if you run like if you had real users using the system, they would see many requests being slow.
01:01:58.913 - 01:03:01.496, Speaker A: Because any request that comes in while a slow request is ongoing, those requests would also have to wait and be experienced as slow. And so what an open loop benchmark does is that it generates requests at some relatively fixed rate or some random rate. It measures the time when the request was sent and then it separately measures the time when the request was completed. And what this means is that now if a request is sort of just sitting in a queue waiting for the next, for some slow request to finish, it's still going to be accumulating slowness. That queuing time is also going to be measured. And so the benchmarks that we do, or that I do, I guess in this eval section are all open loop and will measure the queuing time as well. Questions about experimental setup before we get into the actual Results? Something like JMeter.
01:03:01.496 - 01:03:41.405, Speaker A: I'm not familiar with JMeter but may very well be like open loop. Benchmarking is a decently well known concept. And it's just like if you're running a good benchmark, it probably should be open loop. Oh, let me zoom in. If any of you are trying to read the text, the text here is like not finished. It's just like my current draft. And another important point here is that the server is going to have 128 gigabytes of memory.
01:03:41.405 - 01:04:33.657, Speaker A: So remember how I talked about earlier that one of the big wins with partial is that you, you are able to evict, which means you're able to use less memory. And that 128 gigabytes limit is going to come up later. Doing the same queries over and over again will also train the cache and branch predictor. That's at a much lower level. The branch predictor will end up mattering for Noria. We won't really see it in the eval section, but the reads in Noria are basically just hashmap lookups. And so the branch predictor will end up mattering there, but because it's networked like so much of the actual, like the bottlenecks of the system in a large sense is like sending and receiving bytes over the network and serializing and deserializing them.
01:04:33.657 - 01:05:25.385, Speaker A: The bottleneck is not generally inside of noria, although sometimes it is. Oh yeah, Open loop is definitely what you should be doing. And the reason is because if you do what's known as closed loop benchmarking, so the one that's just like a tight loop that measures things, you're overstating the performance of your system for real applications, which is obviously not great. Would you be interested in doing a live coding session about benchmarking? Maybe one day? There's. It's unclear that there's that much to say about it, but maybe. Okay, so let's dive into the actual experiments. It took us a while, but now we're here.
01:05:25.385 - 01:06:36.415, Speaker A: So as I mentioned, the sort of the first thing we need to do in the evaluation section, because some people will read the whole thesis until the eval section. In practice, what usually happens is people read the introduction section and then they read the evaluation section, and then they decide whether they care enough to read something else. And so usually my guess is someone reading this is going to read like chapter one, maybe just the first part of chapter one, which is going to be like introduction and motivation. They may just read the abstract, then they'll jump to the evaluation section, they might read the first page, they'll skip experimental setup, and then they'll read the first part like basically this page. And here we need to convince people that like, this is useful. And this is also what the text in the beginning of the evaluation section was trying to set up, right? That sort of stating what the. What the core like tenant of the thesis, and in what sense we believe that this is a solution and what the EVOL has to do is convince the reader that it's a good solution.
01:06:36.415 - 01:07:55.035, Speaker A: And so the way that this sort of first and arguably most important part of the evaluation starts out is saying that the core argument of this thesis is that partial state makes view materialization features. The idea being that before it was not feasible, but with partial state it is. And it then makes the point to bundle up in this argument. There are a number of different questions that really come into this that we need to answer before we really look at partial state and micro benchmarks of it, which is, why do you want view materialization in the first place? Why is this a useful problem to even be working on? Because if the reader doesn't believe in point one here, if they don't believe that view materialization is useful, then the whole thesis is not worth reading for them, and then they're not going to care about partial because they don't believe that it's solving an important problem. And then we're also, by saying that partial state makes it feasible, we're saying that it's not currently feasible and we need to demonstrate that that is the case. Then finally we need to demonstrate the partial state is indeed a solution to this problem. And so we, we sort of want to convince the reader of all these three points in order to convince them that the rest of the thesis is worth reading.
01:07:55.035 - 01:08:44.127, Speaker A: Does that make sense? Can you explain the structure of a thesis? I mean it's like intro, motivation, related work, design, evaluation, discussion, conclusion. There isn't that much that's standardized really. But those are sort of the main points you need to touch on over the course of the writing. Okay, so we've set up the reader with like basically an acknowledgement that these are the three questions that they have in mind. And then it goes on to say figure 7.1, which you can't see on this page, which is a little sad. I'm considering moving it up.
01:08:44.127 - 01:09:21.235, Speaker A: Attempts to give insight into all of these questions by comparing the highest sustainable Request load for three different systems. MySQL Noria without partial state and NORIA with partial state. Notice here that MySQL is run entirely in RAM by running it on a RAM disk and on its lowest isolation level. Because MySQL has all these built in transaction things that might slow it down as we disable all of that to try to give as even a comparison as we can. And the figure shows the highest lobsters throughput that each system achieves before its median latency exceeds 50 milliseconds. There's some text down here. I'm going to show you the figure first.
01:09:21.235 - 01:10:45.815, Speaker A: So this is the figure and this is arguably the key figure of this paper. I'm going to give you a little bit of time to like look at the figure and the caption before I start talking about it. So the core point of this figure is that NORIA is good, right? So on the far right you see that the top part of the graph here is the throughput, the number of pages per second that the backend can support or that the workload generator can push through the system. And then the bottom part of the plot is how much memory does it use at that throughput level. So with MySQL you can issue. OK, so this is the number of pages Per second that MySQL can support of the of the lobsters workload generator. And notice that these two plots are with view materialization, and this one is without, and this is the top part here is really just saying caching is good, right? If you cache, you can do way better than if you don't cache.
01:10:45.815 - 01:11:20.291, Speaker A: But then the second point that's interesting here is that with partial, you can have a much higher. You can support many more pages per second that you can without partial. And the reason for this becomes obvious when you look to the memory use. So with MySQL because you're not caching anything, the memory use is obviously very low. But with full materialization, so this is without partial, you need to materialize every result for every query and you can never throw anything away. There's no eviction and therefore it ends up using a lot of memory. So at about 4.6
01:11:20.291 - 01:12:21.265, Speaker A: thousand pages per second, it just runs out of memory. It can't go any further because you're introducing new data to the system and the system just like doesn't keep up. Whereas with partial you can evict that state, you can evict any state that's not constantly being accessed and therefore it uses much less memory, which means that it can go further. Okay, I'm going to stop there to see whether the explanation makes sense and then talk about some of the things that this figure does not answer or some additional questions that might come up. When you look at this figure, do you consider to add postgresadapter other than the mysqladapter? So the thesis will not actually talk about the adapters because they're not in use here. This is interacting directly with Noria through the Rust API and with MySQL directly to MySQL there's no adapter involved. The adapter was something we built for the previous paper because it meant that we could compare the two a little bit more directly.
01:12:21.265 - 01:12:52.529, Speaker A: But it's not really relevant to the argument that this thesis is trying to make. So there's no adapter here. That's why I left academia. There's always this bias to or need towards positive results. I would be perfectly happy to read a paper or thesis that clearly explains why some concepts does not work. There are, there are theses and papers that do that, that give negative results or that are more survey papers. It is true that they're.
01:12:52.529 - 01:13:24.203, Speaker A: They're pretty rare in computer science and that's a little sad. It is generally harder to publish a paper on. We tried this and it didn't work. Which like, are also important results because it means that other people won't then waste time trying to do the same thing. But it is certainly true that like it's much easier to write a paper or thesis on. We tried this and it worked. Why was MySQL chosen? It doesn't really matter.
01:13:24.203 - 01:13:55.165, Speaker A: It just the the right bar here just has to be a database that doesn't cache. We could certainly try some other one. MySQL is just like by far the most common one. We couldn't use something like IBM, DB2 or Oracle because they all have no benchmarking clauses. So if we use them we couldn't name the system, which is just useless. Postgres would probably be about the same here. It's not clear they would be any faster because ultimately the win here comes from the caching, which postgres would also not have.
01:13:55.165 - 01:14:43.803, Speaker A: What eviction strategies are used? This is randomized eviction. So I mentioned this a little bit earlier too, that this thesis does not try to innovate on eviction strategies. You could implement any eviction strategy you want in Noria, currently just as randomized because that was easy and it still demonstrates the value of the system. But obviously you could do better if you had a smarter eviction strategy. Why isn't caching everything faster? So remember that. Okay, so the way this benchmark works is that you we're just measuring throughput here. We're not measuring latency, right? We're measuring just throughput.
01:14:43.803 - 01:15:32.437, Speaker A: And as the workload generator generates more and more requests per second, the one that doesn't have partial runs out of memory. It can't go any higher than this because it ends up with just too much stuff. So it's not that. The takeaway from this is not that with caching your requests are slower than they are with partial, it's that you can't scale as far in terms of throughput. Is Noria's data flow agnostic to the different types of database? There is no external database in Noria. Noria does not contain MySQL or any other database. Are there trade offs on request latencies? Yes, and we'll get into those in a second.
01:15:32.437 - 01:16:19.299, Speaker A: So this is the second paragraph that the introduction to the eval was trying to set up. Why is partial state better than caching pages in Redis, Memcache, et cetera? I'll get to that towards the end of the eval section. It's an important point. The high level answer is doing manual caching in Redis or Memcache or something is extremely complicated to get right, especially for anything but the most trivial applications and with Noria you don't have to do any of that. Would this scale? Well, with much bigger data sets it's hard to say. Like one challenge here is that I don't have like the really big applications aren't open source and don't have their data sets open. So I just can't test them.
01:16:19.299 - 01:17:28.405, Speaker A: And so the best I can do is scale up a data set that I do have. What's the rate of change in the data, how many changes occurred during the test? So this is just doing the normal, this is doing the normal lobsters evaluation, the lobsters workload and what that does is it generates different page views in lobsters. And to perform, to execute any given page view there are a number of queries that are issued behind the scenes which are basically the queries that the real lobsters like Ruby on Rails application would issue. So for example, if you issue a vote, it's going to do an insert into vote. If you do a, if you read a story it's mostly just select queries, although there is one insert in there that like logs the fact that you've now looked at this story for notification purposes. So I don't have a number for exactly how many modifications were made because there are, these are page views, they're not individual atomic operations. We'll look about that a little bit later though.
01:17:28.405 - 01:18:45.719, Speaker A: What is Lobsters and how do we know it doesn't Favor Noria over MySQL by design? So Lobsters is an application that I did not write and it's like a production website that mirrors the design of many other websites, although they're not open source, so it's hard to say it was built by other people. And basically what I did was I built a workload generator that runs the same queries and those application authors did not know about Noria at all. And so that's the best answer I can give that like there's nothing, there should be nothing inherent there that makes it favor Noria. Have you tried to calculate the potential cost savings of using Noria over MySQL Number of MySQL instances needed for the MySQL for MySQL to perform similarly. I don't think MySQL can perform similarly to Noria here. Like if you tried to run a cluster, you end up with a lot of overhead in the clustering in MySQL as well. Is this basically partially practicing defending your thesis? Not really.
01:18:45.719 - 01:19:30.795, Speaker A: This is just me trying to walk through an eval section where's the code. This is not a live coding stream like many of my streams are, but this one is not one. If you compared it to Facebook's database, Rocks DB, RocksDB is just a key value store, nor is a full SQL database, so the comparison isn't really meaningful. There's like Rocks DB with MySQL support. I have not compared against that. All right, so this is like one of the key figures for why that the thesis tries to use for arguing why Noria is like, useful. There are a couple of questions you should be asking yourself about this figure here.
01:19:30.795 - 01:20:31.445, Speaker A: One of them is where do these memory numbers come from? Like, why is it that, like, why is it that it uses 115 gigabytes at 4.6 pages per second? Why does that mean that it uses more memory? If this was pushed higher, basically, why can't we push the number of pages per second higher without increasing the amount of memory we use? And the answer to that is twofold. First, as you issue more requests per second, you're also generating more data, right? You're adding comments to stories, you're adding stories, you're adding votes to stories and comments. And so you're like adding data to the system that then has to be represented in every query result when you don't have partial. And so that is one reason why the rate of change, increasing, increasing the memory uses usage. The other thing is that even at 4.6 pages per, 4.6
01:20:31.445 - 01:21:15.491, Speaker A: thousand pages per second, if you kept running it for longer, you increase the memory use as well for the same reason, right? If you kept running at that rate, you're still generating more data. And so the memory use actually goes up over time. And that makes you think, well, why are these numbers even useful, right? Because for any given input rate, the memory use is not constant. It's going to be going up because you're increasing the size of the dataset. The answer there is basically all of these experiments run for two minutes. And so if you run this for two minutes, you get this memory use. So if you wanted to run at a higher rate for two minutes, you would get a higher memory use.
01:21:15.491 - 01:22:03.533, Speaker A: And because we don't have more than 128 gigs of RAM, you can't go higher. And that does mean that this is a little artificial, right? Like if we ran it at, if we ran it only for one minute, then you could go higher because you haven't generated as much data in one minute. And so there isn't really a good answer for why exactly two minutes. I Could make it longer and this would be. This would go up and this would go down. What is important though, is that for Noria with partial, the increase in memory use is much, much slower. So if I went to like three minutes, Noria with partial would increase memory use a lot slower than the other experiments would.
01:22:03.533 - 01:22:49.415, Speaker A: I don't have a good answer for this. Like, I don't know quite how to, how to illustrate this without being dependent on how long you run the experiment for. Because the input rate is just like it generates data, the best I can do is compare them for the same amount of runtime. Why does the caption say the full materialization blows up at 2.3K pages per second, but the picture says 4.6? Because the caption is outdated does not put constraints on what MySQL features can be enabled. There is no MySQL in Noria, so Noria does not put any constraints on MySQL features because you can't use any.
01:22:49.415 - 01:23:35.657, Speaker A: The more serious answer is that Noria does not support MySQL queries, it supports just SQL. So if you're using like fancy MySQL dialect features of SQL, you couldn't do them in Nori. This is partially just because Noria is a research system. If you wanted to add support for those features, you probably could support many of them. It's just not been a focus of the work. The argument then that we're making here is Noria uses less memory and it's Significantly faster than MySQL if we look back at the questions, why is view materialization desirable? Well, that's like the throughput difference. It's significantly faster.
01:23:35.657 - 01:24:21.169, Speaker A: It's like 9x faster. Why is view materialization not feasible currently? The answer is basically it uses so much memory that either you can't run for as long or you can't run at high enough a rate. And so you would just be really limited in what kind of application scale you could run at. And then does partial state improve on the situation? Well, yes, it does. It uses significantly less memory, which also means that you can push throughput higher. Or alternatively, the sort of inverse of this argument is you can use a smaller instance, for example, a smaller machine with less memory. Because here with Noria, like if imagine that you wanted to run at like 4.6
01:24:21.169 - 01:24:59.955, Speaker A: pages per second, that was just like the amount of users you had generated that load. The Noria would use significantly less memory. And so you could get away with having less memory in the machine, which is cheaper. How about if you ran it till it reached a steady state of queries. So the challenge is that it's not a steady state of queries. Like there's no steady state here because every, most of the queries do some kind of insertion into the data, so there isn't really a steady state there. The data set will keep increasing.
01:24:59.955 - 01:25:48.015, Speaker A: Shouldn't you run the test on different EC2 instances then with different parameters to show how much NORI improves the throughput in each scenario? I'm not sure I follow what EC2 machine you run won't really make much of a difference here. Did you look at the rate of change of resource usage and throughput over time rather than just instantaneous results? Yeah, you'll. You'll see those a little bit later. Remember that this is just the first graph and the idea behind this graph is just like immediately show why you should read the rest of the thesis. This graph cannot answer all of the readers questions. There's just no way to do all of that in one graph. All it can hope to do is convince the reader to keep reading.
01:25:48.015 - 01:26:34.901, Speaker A: If the first graph is not compelling enough that the reader is like imagine, right? Like these throughput graphs were at like 1k. The reader might be like why do I care? They use like 60 times as much memory for like a 2x increase in throughput. I don't care about this paper. I don't think it matters. Whereas this graph clearly demonstrates that there's something here and the hope is that the reader keeps reading and then gets more of a sort of refined image of what the system provides you with. You could add memory over time, capping at two minutes instead of the lower bar chart. Not sure I followed that.
01:26:34.901 - 01:27:19.133, Speaker A: What if you use SSD as memory? SSDs are much slower than memory, so that would not really work. I wonder how postgres would do if rustified. I don't think it would make a difference. I wonder how Noria would fare compared to MySQL if you turned off view materialization completely. If you turned off view materialization in nor yet it would be much slower than MySQL the reason for this is that MySQL has seen like decades right of optimization work to its query execution. Whereas Noria's upqueries I've built over five years and so they're just much less efficient and sort of by design too. Like they are requests for particular subsets of the data, which means you can only execute queries in certain ways.
01:27:19.133 - 01:28:05.227, Speaker A: So Noria doesn't even have the same flexibility MySQL does to optimize queries. So Noria without view materialization doesn't make much sense. Okay, so the hope of this graph is to convince the reader that this paper, that this thesis is worth reading. And there are some challenges with it, and some of them I'm still working on. But it's interesting because I've gone through a lot of iterations of this graph and I think this is the best one. There might be a better one, but I'm not quite sure what it is. And the reason I think this is the best one, even though it has the challenges we discussed, is because it very quickly gives many of the takeaways that I want the reader to have in mind when reading the rest.
01:28:05.227 - 01:28:41.755, Speaker A: Right. Higher throughput, lower memory use and view materialization is good. Ravi, the comparison to materialized and differential data flow I went over earlier. What is the rate at which memory usage of Noria keeps increasing as Morge page views are performed? So the way the. Actually this is something I can draw out. Give me a second here. Also, I want to set this to not be silly.
01:28:41.755 - 01:29:06.715, Speaker A: Oh no. HDMI1.01. That's awkward. Ah, fine. Okay, so let me demonstrate this. If you looked at memory use over time and this might be something that's worth plotting. I'm not entirely sure.
01:29:06.715 - 01:29:53.397, Speaker A: Is graph like this where you had like. If you have time here and you have like memory up here, then what you'll see is that with full materialization the graph will just go there for some arbitrary scale. With partial, what you'll see is that it'll more go like this. And so you'll see that there's sort of a. Down here, there's a. There's sort of a log component and this is basically filling the cache. And then there's a linear component here and that linear component is the data increase right in.
01:29:53.397 - 01:30:35.821, Speaker A: In. With full materialization, this delta is the data plus all of the. All of the cached results. Because we have to cache every result for every query for each part of the data. Whereas with partial we're only computing the. Well, actually I guess the difference between these lines at any given point is going to be cached but not accessed. Right? So the difference between these is basically a bunch of stuff that didn't need to be cached.
01:30:35.821 - 01:31:22.685, Speaker A: But with full materialization, everything must be cached. And so this is where the memory saving comes from. I feel like that graph mostly shows better than full materialization, but it's hard to see if better than MySQL it would be interesting to see what memory usage. It has the same throughput as MySQL. So I mean, I could show that. It's just that like the takeaway here is that MySQL can't do better than this. This is the highest I could push MySQL on the server because before all 16 cores are busy, this clearly can scale much further.
01:31:22.685 - 01:32:00.831, Speaker A: It does that by utilizing memory is the takeaway. This is the core trade off of materialization or of caching in general is you use memory to make things faster. The lower chart is how much memory is used after two minutes, which is arbitrary, but you could have a line chart with three lines that shows how much memory each config uses in two minutes. That's true. It's a little harder to sample, and it's also harder to read. But it is true that this could be a line graph and that might help. And I do like that.
01:32:00.831 - 01:32:28.605, Speaker A: This is very visually simple to make. Like you. You sort of want your graphs to make a single point, if you can. This one is making slightly more than a single point, but once you introduce like a timeline as well, then time seems like it should be relevant. But in some sense, the argument this this graph is making is unrelated to time. Is the memory saving due to random eviction? Well, it's due to eviction. It doesn't matter that it's random.
01:32:28.605 - 01:33:03.485, Speaker A: One thought on the first graph. If there's a strategy currently in common use with MySQL plus an additional caching layer, I would find it odd to. Not that it's not included. Okay, so this is another important point. Very commonly, as I mentioned, people will use MYSQL plus some cache like REDIS or MYSQL or something. Redis or memcached or something. The challenge here is that implementing caching for lobsters would be a huge undertaking, right? It would be really complicated to try to add caching to an existing application because not only do you need to add all the necessary caching layers, but you would also make sure to.
01:33:03.485 - 01:34:04.157, Speaker A: You would have to augment every part of the application to keep that cache up to date whenever the data changes. You would need to add a lot of mitigations for things like thundering herds, which I'll get to in a little bit later. So adding the fourth column, that's like MySQL +Memcache, I agree, would be great, but in practice it's really hard to do that. And it would also mean that we're basically evaluating My way of doing caching, like some arbitrary way I made up that you should be caching lobsters. So the way the thesis actually goes about this, and this is the paragraph I mentioned was missing from the first part of evaluating, is that the last part of eval is going to be compared to, basically compared to just rolling your own cash. And so that we'll talk a little bit, get a little bit of that difference. I wonder if a more sophisticated cash eviction policy would make it feasible to run Noria fast on cheaper machines.
01:34:04.157 - 01:34:44.115, Speaker A: 64 gigs of RAM is no joke. Yeah, smarter eviction will get you down a little bit. There's also an additional point here, which is that this 64 gigs of memory includes all the base tables. Remember here, MySQL does not store the data in memory, it stores it on disk. Noria stores all the mem, all the data in memory, including the base tables. And so that means that there's like a big chunk of this, probably about like 50 gigabytes that are only due to the base table data being in memory. If we could remove those, if Noria stored those on disk instead, then the actual memory overhead of Noria would be very small indeed.
01:34:44.115 - 01:35:11.929, Speaker A: MySQL does not support materialized views. No. And Postgres also does not support materialized views. Let me rephrase, they support materialized views, but they're useless. Materialized views in existing databases are basically like compute the results whenever this happens. Which basically means re execute the query when something happens. This is usually like trigger based materialized views.
01:35:11.929 - 01:35:53.935, Speaker A: And if the trigger is someone writes to this table, you're basically going to be re executing that query all the time and it's just not useful. It means that every write causes a bunch of work as well. And with Noria you don't need any of that. We did some experiments of this in the previous Noria paper. I meant instance types. My question goes towards this. Are you trying to answer the question of is materialization useful at all or are you trying to answer when it is useful? I'm trying to say the materialization is always useful and I believe this is true even here.
01:35:53.935 - 01:36:48.381, Speaker A: Like if your dataset is much smaller, then Noria will also use less memory. What happens when full materialization runs out of memory? Does it slow down or does it stop accepting further queries? Well, Noria currently crashes. Like it gets killed by the out of memory killer from the kernel. And yeah, materialized views and postgres are also not in memory, I think. Do you see a future where enabling partial materialization for some queries on a production database would magically improve your throughput. I think it's very hard to add good materialized views to an existing database to like MYSQL or Postgres or something. Oh yeah.
01:36:48.381 - 01:37:33.855, Speaker A: The other reason why materialized views in databases are a problem is because they re execute the entire query every time even if only a small part of the data has changed. Whereas Noria will incrementally keep the result up to date. So if one new vote comes in, it doesn't have to count all the votes, it will just add one to the current count. MySQL is measured with an in memory file system with basically with a RAM disk. But this is memory measuring the resident memory of the process. And so the RAM Disk part of MySQL is not measured. I could include that, but it seems a little unfair because MySQL doesn't necessarily optimize for the size of its on disk storage because the trade offs for disks are a little different than memory.
01:37:33.855 - 01:38:20.237, Speaker A: I could certainly add the the storage cost of the base tables here by measuring the size of the RAM disk. Okay, so let's move on from the first graph. It basically makes this argument about instance types, how much memory you need, that sort of stuff. Then the next section is on the memory latency tradeoff. So I mentioned this a little bit in the setup that one of the advantages of partial state is that you can throw stuff away. But the downside of that is sometimes a query will or a query will be executed and the application is waiting for the response, but that result isn't cached and we need to go to compute it. We basically have to do an upquery and wait for it to come back.
01:38:20.237 - 01:39:09.825, Speaker A: When you have to do that kind of on demand computation, there's a latency trade off inherent in that. Now the result doesn't come back immediately, you have to wait for it. And the most the easiest way to evaluate this is basically to start something like lobsters with all of the views empty, like the whole cache is empty. And then you just start the application, you start the workload and then you just see how the latency changes over time. And that's this plot which some of you may have seen if you follow me on Twitter because I've worked a lot on this particular plot and this one is, let me tell you, this is a doozy. But this is plotting the page latency over time. Time zero here is like Noria starts and the workload generator starts, all the caches are empty.
01:39:09.825 - 01:39:45.619, Speaker A: And then what you see Is that over time, as the workload keeps going, initially the page load latency is very high. Notice that the Y axis here is log score. So going from here to here is an increase of 10 times. From here to here is another increase of 10 times. And 10 times. 10 times 10 times. So this means that in the beginning, like your queries, requesting in a given page is going to take like on the order of seconds or like around a second, which is a very long time to wait for a page to render.
01:39:45.619 - 01:40:54.675, Speaker A: But then over time, as Noria starts to cache the most popular query results and the most pop that the pages that the different pages request, the latency starts dropping, right? Because the cache starts filling and then the cache keeps filling and the latency keeps dropping. And then what this plot shows, what the colors are for, is that the brighter the color, they're like closer to white, the higher part of a tail that is measuring. So very often what you'll see in graphs and such, they will measure like the mean or maybe the median, maybe show standard deviation, that kind of stuff. And that that's useful, but it doesn't really give the full image of what's going on. And so what this will do is actually tell you like, so the 50th percentile here is the the fastest 50% of requests. 50 to 90 is saying everything between the half fastest request and the 90th percentile of requests. So imagine you sort all the requests by how long they took.
01:40:54.675 - 01:41:33.985, Speaker A: Then the 50th percentile is the middle. The 90th percentile is 9/10. So that means if you look at the darkest purple with the next purple, those are 9 out of 10 requests took less than this time. Right? So if we look at the beginning, nine of 10 requests took two seconds. Some of them took less, but if you like, two seconds was sort of the top for how long nine out of 10 requests took. And then after about a second, that is one second, about two seconds later, that's 10 milliseconds. You can see the black bar here is the mean.
01:41:33.985 - 01:42:14.445, Speaker A: The white goes all the way up to the max. So this is the slowest request measured in that time frame at all. And you see all of these go down over time as the cache starts to get populated. Do you think Noria could become competitive with MySQL or Postgres without materialization? No. The computation, the query model is very different and it's not built for on demand computation. The outlier in the 95th percentile at 2 seconds is interesting. What Outlier.
01:42:14.445 - 01:42:39.777, Speaker A: You're talking about this. There isn't really an outlier here. It's just that some request do not hidden cache. Right. What's the typical query like in lobster? Lobster's queries are all over the place. They're like joins and aggregations and stuff. In general they try to avoid aggregations because they're too slow in MySQL.
01:42:39.777 - 01:43:20.945, Speaker A: So there's already a bunch of manual materialization work they did. I'll get to some of these in a second. But if you look at things like keeping vote counts, usually what you would do is instead of actually doing like a count in SQL, you would have a column on the article table that's the vote count. And over vote comes in, you insert it into the votes table, but you also update the vote count column of article and that way your reads can just read directly from that view. But there isn't really a typical query. The most common queries are things like give me the comments for the storm story, give him the front page. Like the most popular stories, that kind of stuff.
01:43:20.945 - 01:43:46.075, Speaker A: The 99th percent to max color is a little difficult to distinguish. Might be on purpose, but I think it would be a bit darker, distinguished from the white background. I think that's just the stream encoding. In reality the background is gray and the color is like yellow. I don't know if you can see it better if I zoom in. So I think that's just the stream video encoding. At least it's better in the PDF.
01:43:46.075 - 01:44:43.825, Speaker A: Why do you use log scale for the plot? So there are two questions here. Why is the Y scale log? And why is the XSCALE log, which you may or may not have noticed? So the Y scale is log because otherwise 1 second is so much longer than 10 milliseconds. So if I didn't plot this log scale on the Y axis, then you would just see that it drops basically to zero. Like once you get to two, it would look like it's just all zero, when in reality there's like there are things happening in the tail. Not in the tail, but there are things happening at the lower latencies here too. And that would just be invisible if this wasn't log scale. As for why is the X axis log scale A little bit of an artifact of the measuring technique, which is I'm measuring the latency in buckets of increasing size.
01:44:43.825 - 01:45:26.575, Speaker A: So I'm measuring the latency in the first second, then the next second, then the next two seconds, then the next four seconds, and so on. And this is because I wanted to not sample too frequently because it adds a bunch of overhead to sample. There might not be a good reason to do this really. Like I could probably plot them on a linear scale, but it comes back to if this was plotted on a linear scale all the way up to like 128 seconds, the this thing happening in the first few seconds would be invisible. It would appear just like as a diagonal line in the far left of the plot. And if I cut it earlier, then you wouldn't see that this keeps dropping. So that's the log X axis.
01:45:26.575 - 01:46:24.729, Speaker A: Do you have a graph that shows how the write performance changes depending on the amount of items in cache? Data still gets updated even in read heavy systems. So I don't have a graph directly on write? Actually, no, I do. You'll see one a little bit later. Yeah. So this is basically trying to make the argument that it is true that NORIA increases the tail latency, but in practice the tail latency is pretty low because most things hit in cache. So any given page in lobster issues, I think it's like on the order of 10 queries. And so even if one of those 10 miss, it doesn't add that much to your page load time if all of them miss, which is what happened in the beginning, certainly it takes a long time.
01:46:24.729 - 01:46:58.105, Speaker A: But what this is showing is that at least in this workload generator that just like doesn't really happen. Even your max is just not that high once the cache has been warmed. This is trying to demonstrate sort of that trade off. And then of course the next part of that trade off is what happens if you try to evict more aggressively. Right? So basically the how aggressively you evict affects how much of an impact there's going to be on your latency. If you evict more things, more things will miss. So your latency will go up.
01:46:58.105 - 01:47:49.205, Speaker A: And that's what this next plot gets at. So this is showing a cdf. If you're not familiar with the cdf, it's basically the same thing as what I encoded in the colors of the graph above. So this is saying that like 6 out of 10 requests for. So this line is without partial 6 out of 10 requests took less than 2, less than 3 milliseconds. Or if we look like here, 8 out of 10 requests took less than 8 milliseconds is the way to read this. So the place on the Y axis is what fraction of requests and the point on the X axis is how long, how much time did that part of that Fraction of requests take.
01:47:49.205 - 01:48:36.839, Speaker A: And what this is showing here is that I'm not actually quite sure why turning on partial slows things down this much, because this is steady state. So this is after the cache has been populated. I don't know where this gaps come from, and it's something that has to be fixed. But certainly there are a couple of things to take away from this. The first is that with partial, your tail is longer, right? So you see that in the very top parts of this graph, right? The last few requests with partial take a decent amount longer than the last few requests. The slowest requests without partial, and that is because sometimes you just miss. Like you do a cache miss, and now you need to upquery.
01:48:36.839 - 01:49:07.531, Speaker A: And so those will take longer. And this shows you how much slower the up queries are. And you can see that the up queries are slower by like a factor of 10. So it's a decent amount slower when you do miss in cache. But that's sort of as expected. And then the other takeaway from this graph is that as you evict more aggressively, so darker colors here is more aggressive eviction. As you evict more aggressively, your tail suffers, right? And this is because if you evict more aggressively, you miss more often.
01:49:07.531 - 01:49:44.507, Speaker A: Therefore more requests will take longer. And you see here, this is also a log X scale. And the reason for this is the same is why the other one is log scale, which is if it wasn't log scale, this would just look like an S with all the lines on top of each other. And you wouldn't really see these differences because the range of the tail is so long. Let me see if I can get there. So this is, as I mentioned, steady state. Basically, the benchmark runs for like two minutes.
01:49:44.507 - 01:50:29.595, Speaker A: And then I measure the cdf and you see here also the sort of names of these lines. And I don't know whether this is the way I want to go with it, but they're basically showing what is the memory use, what is the actual memory use. You end up with this amount of eviction. And you see that going from not using partial to using partial saves you like 10 gigabytes. These are things that are just like, never accessed. Turning on eviction saves you another like 7 gigabytes. And then you can keep making eviction more aggressive to save more, but there's sort of diminishing returns once you start pushing it down.
01:50:29.595 - 01:51:11.105, Speaker A: And so for those of you who are asking, like, how much slower are cache misses? This figure also tries to answer that question. Right. It's looking at this sort of tail end here is about 10 times slower than over here. And that happens when you miss. So it goes from like 10 milliseconds to 100 milliseconds. Anecdotally, some of you may have followed me on Twitter and seen some of my work on trying to amortize data structures. When I was initially plotting this graph, the tail here was like 10 seconds instead of 100 milliseconds.
01:51:11.105 - 01:52:01.665, Speaker A: And that was because one request every so and so often would end up having to resize a hash map of like millions of elements. And that just takes a really long time. And so the tail would just be really long. And so a lot of the work that I've done on the amortization stuff, just like getting this to just be the upqueries, I would change the bounds on the X axis slightly, zoom in a bit more. Yeah, I could do that. I mean, it's a little tricky because it would mean that it doesn't start on a round number, but it's totally doable. All right, so that's the argument about tail latency.
01:52:01.665 - 01:52:49.457, Speaker A: And the next one now is. Well, so another interesting point here is that you can only push this so far. And the text makes this argument too, that if you try to evict even more aggressively, then the system won't be able to keep up. You end up missing so often, like you end up missing on basically every request if you evict aggressively enough. And at that point the system is just not going to keep up with load because it's always filling the cache. It's just like constantly doing cache misses, serving cache misses. And so there's a limit to how much, how aggressively you can evict.
01:52:49.457 - 01:53:32.587, Speaker A: Basically, this line is going to keep being pushed to the right and there's sort of a cliff where something. Imagine that there's some story or some article or something that is very popular. If that article ends up being evicted frequently, then now, like, your whole performance goes over a cliff because you're constantly going to be recomputing that article. Why are the memory gains with more aggressive evictions so low? The reason for that is because, remember, this also includes the base tables. Noria has the base tables and memory. And what that means is there's sort of a. We can't evict from the base tables because they're like the durable storage of our data, right? Like up queries ultimately end up at the base table.
01:53:32.587 - 01:54:21.185, Speaker A: So they need to have all the data. And this value includes the Base table storage, which is unfortunate, right, because it means that the gains are all in the caching size above the base tables. But the base tables are pretty large and end up taking up a huge chunk of this. I think in reality, the base tables here are like 40 gigabytes, which then of course, these savings are much higher than what they seem like from this graph. I'm still trying to work out the best way to articulate this point, which is a little tricky. Okay, so this is the query I showed you earlier, and where the. Oh, sorry.
01:54:21.185 - 01:55:18.771, Speaker A: What's the difference between no eviction and no partial? Does no partial mean we compute vote counts for all articles in the beginning? Yeah, no partial means we're doing full materialization. So every query result is always kept and computed. And the no eviction is we have partial enabled, but we never evict anything. So one thing that you might wonder is like, the numbers here are sort of low. If you look at this graph, this is like 3,000 pages per second, and even if every page issues maybe 10 queries or something, then this is still only 30,000 queries per second, which may seem like a lot. But you might wonder like, what happens if we go further? And we can't really do that with lobsters, because the. Like, if you look at the plot up here, if we go above about 7,000 pages per second, Noria can't keep up anymore, even though it has memory to spare.
01:55:18.771 - 01:56:00.571, Speaker A: The reason for that is actually because it ends up being bottlenecked by a particular query that needs to be computed. Like, we just can't service the writes that have to go through that path any faster. We basically get limited by the throughput of a particular thread that services that dataflow path. And this means that we can't see what happens at like a million requests per second. But we kind of want to know that too, as what we're going to do is we're going to extract this particular query from lobsters. This isn't exactly a query that appears in lobsters, but it's pretty close. And this is the query I talked about earlier of articles and votes, where you just want to fetch a given article along with its vote count.
01:56:00.571 - 01:56:27.385, Speaker A: And then what we're going to do is we're going to build a workload generator for this query alone. So it's not going to do any of the other stuff that Lobspers has. We're going to do a micro benchmark of just this query and then we can push things a lot further. Right, so this is a Weird graph. And this is probably not how it's going to look in its final form. In fact, let me. I don't like this graph.
01:56:27.385 - 01:57:02.865, Speaker A: So this graph, which I actually plotted just before the stream started because I got some new data. What this is showing is a throughput latency graph. And these are a little bit weird. They deserves some explanation because if you read this graph, you might see that there's some really weird things going on. A throughput latency graph is a graph where you run the benchmark at a particular load factor. Like you target like a million operations per second. And you do this with open loop and then you measure.
01:57:02.865 - 01:57:46.071, Speaker A: I tried to run it with a million operations per second. How many operations per second did it achieve? And what was the latency of those requests? And in this case we're plotting the 90th percentile latency. But this could be mean or median or whatever. In fact, let me make this plot the mean just to see whether that's a more useful plot. Yeah, it's a little bit more useful. And so what that means is that it's not as though if you look at a given point and then look at the x and Y axis, it's not like the Y axis is a function of the x axis. Rather, the x and Y axes are both a function of the point they're at.
01:57:46.071 - 01:58:12.719, Speaker A: So there's sort of a missing data point you don't have here, which is what input rate was provided for any given point. And for many of these points, the input rate matches the value the. The achieved throughput. Right? So here this is like 2, 250 operations per second. And it achieved 250 operations per second and the latency was very low, close to 0. This is 5. This is 500 operations per second.
01:58:12.719 - 01:59:00.137, Speaker A: It achieved 500 operations per second with a low latency and so on. And the reason why throughput latency plots are useful is because they tell you when a system falls over, basically what you do is you keep increasing the input rate to the system and then at some point the achieved throughput is going to stop going up because the system can't keep up anymore. And at that point the system starts getting this backlog of requests that aren't being serviced. And so it ends up building a queue. So the latency goes up. And so you get this hockey stick effect where when the system no longer keeps up, it sort of ends up going like this, which is what you see here, right? At some point the system is no longer keeping up. So the achievement Throughput is no longer going up, even though the input rate is going up.
01:59:00.137 - 01:59:33.963, Speaker A: So for example, this point is an input rate of like 4 million operations per second. But this input point is like four and a half million operations per second. But you see that it doesn't actually manage to get much beyond 4. And in fact, sometimes what you see with these throughput latency plots is that the curve starts going backwards. Like you increase the input rate, but the achieved throughput goes down. And this is often because the system starts to get overwhelmed. Generally, systems become a little bit less efficient once they run like at capacity.
01:59:33.963 - 02:00:06.333, Speaker A: And you can see that effect in the throughput latency plot. But in particular, what this plot is trying to show is that the darker lines here again are more aggressive eviction. And what you see is that as you run with more aggressive eviction, you can't achieve as high of a throughput. Right. The darkest purple line here has very aggressive eviction and it falls over at about 4 million operations per second. This line has slightly less aggressive eviction. It falls over at about 5.5
02:00:06.333 - 02:00:29.515, Speaker A: million requests per second. This one has less and falls over later. And then you keep seeing this effect. I'll explain why in a second. But does the plot make sense? If you had the base tables on disk, that would mean the tail latency would be a lot bigger, but at the same time you would have much more budget for caching. Exactly. That's basically the trade off.
02:00:29.515 - 02:01:25.585, Speaker A: And I don't know what the right thing to run with for the thesis is because they're sort of irrelevant for the point the thesis is trying to make. Ideally what I'd want to do is in all these plots show like the memory use, like mark the part of the memory use that's for base tables in a different color or something. The problem is it's really hard to know what that is because you can measure the overall memory use for a process, but it's hard to measure how much of the memory use is due to this set of hash tables. For example, is a evicting is no eviction much the same as thrashing for paging? Not sure I follow. Are you required to have a larger left than margin than right? No, this is because it's book format. So this is a. This is a left page and this is a right page.
02:01:25.585 - 02:02:44.813, Speaker A: And this is just standard typography layout for book because the thesis will be book form. Okay, does the throughput latency, does it make sense why we're doing this with a throughput latency plot? And does the basic idea behind a throughput latency plot make sense? It's weird, I agree. Also, the Y axis here is really strange. And I'll talk about that in a. Okay, so the intuition here behind why more aggressive eviction falls over earlier is that when you evict more aggressively, or rather think about it this way, if your throughput is higher, then in a given period of time, you're accessing more keys, right? So at 2 million operations per second, let's say you're accessing 10 keys in a given second, like, or 100,000 keys in a given second. At 4 million operations per second, you're accessing say 200,000 keys in that second. Which means that here you can't evict any of those hundred thousand keys or you'll end up missing a lot.
02:02:44.813 - 02:03:36.755, Speaker A: Here you can't evict those 200,000 keys because you'll end up evicting a lot. And so as your throughput increases, you need to keep more, more of your status hot, so to speak, in your cache and therefore your cache size. The amount of stuff you can evict, your cache size has to increase as well. And that's what this plot is showing, that as your throughput increases, you can, you need to have a less aggressive eviction, which is a subtle point, but an important one. What causes. What causes the bend in the bright pink line? When a system runs at a capacity, it's real hard to estimate its performance in any reasonable way. The way I actually want this plot to go is I don't want this to go this high.
02:03:36.755 - 02:04:12.587, Speaker A: I basically want. Here, let me run this at a slightly more sane scale. There's no reason for this to quite go this high. Like this, for example, demonstrates the same point. Really what I need here is just more data points to make this look reasonable. Because all that matters is like at some point you get a vertical line and that doesn't really matter what happens on that vertical line because the system is not keeping up. And that is the only point this is trying to keep trying to make is where the system falls over.
02:04:12.587 - 02:04:44.881, Speaker A: We could do that just like with a table, but a plot is usually a nicer way for the audience to experience it. Evicting too much is similar to thrashing for page misses. Yep, that's right. Use a separate process which only contains the base tables and shared with copy and write pages. Not easily. Remember, like, NORI is a pretty complex system. It's like 80,000 lines of rust code.
02:04:44.881 - 02:05:06.275, Speaker A: And it'd be hard to Just like, be like, we're going to have another process store the base tables. Be tricky. Warrants an explanation, but totally makes sense. Yeah. So obviously there's a lot of text in the section as well that I'm just like that. I'm just saying. And that's not in the plot, but the text basically makes the same arguments that I'm trying to make.
02:05:06.275 - 02:05:49.333, Speaker A: Is this experiment run with rights turned off? No, sorry, I forgot to mention that this is run with 1 in 10 requests or rights, if that makes sense. So there's like 99% reads. One in 10 requests are rights, which means that at this point there are 400,000 writes per second that are rights to vote. And they're skewed. So it's a zipfian distribution. But that might not mean much to you. But basically about 90% of votes go to 1% of articles.
02:05:49.333 - 02:06:18.275, Speaker A: So there's a pretty significant skew in the data measuring the base table memory versus the cache. Memory usage is an interesting problem. Could use a customized allocator that adds the bare minimum you'd need to instrument that. Maybe. But part of the challenge is it would mean I couldn't use any standard Rust data structures because they're not generic over the allocator yet. So it's a little challenging. It'd be nice if you talked about your automation in that make file.
02:06:18.275 - 02:07:04.343, Speaker A: I can do that a little bit towards the end, which we're getting towards the end anyway. All right, so then we get to this point about bringing up new views, which is your application has been running for a while. You add a new query. Now what happens, and this is where the big difference between full and partial is that with full, you have to compute everything at once. With partial, you can just compute them on demand and fill your cache incrementally. And so what we're going to do is we're going to introduce a new query into this article and vote setup that computes a slightly different query using the same data. And the exact query isn't that important, but we end up with this plot.
02:07:04.343 - 02:07:51.357, Speaker A: So this plot is showing at the red line at time zero. We introduced this new query. And then what we're going to measure is in the top plot, the fraction of reads that hit in cache for the new view, the new query, and at the bottom is the write throughput in the system. So there's some interesting aspects of this. First, as you see, with full materialization, like without partial for the first 20 seconds or so after you add this query, you can't read from it at all. Notice that there are no reads prior to this line. And that's because with full materialization you have to compute the entire result of the query before you can answer any questions about it.
02:07:51.357 - 02:08:44.693, Speaker A: Whereas with partial it starts out empty and then we just on demand filled only the keys that the application is asking for. And so our hit rate initially is pretty low, but it increases slowly over time as particular articles are requested. But crucially the view immediately, the query immediately starts to become useful. The other thing we'll see is at the bottom one, you'll see that the write throughput is actually higher with partial than without partial, even after the migration is finished, even after the query is fully up and running. And this is because with partial you only need to maintain the values for the things that are cached. If there's a particular key, if there particular query that isn't cached, its results aren't cached, then any write that affects that result you don't need to compute on because there's nothing to update. So that's this delta over here.
02:08:44.693 - 02:09:42.185, Speaker A: And we see an interesting point here where while the full materialization version is building this new queries results while it's computing all of them right, throughput drops by a lot because it has to spend a bunch of resources on computing what goes into that new view. And whereas with partial you don't have that problem because it doesn't have to do everything up front. And so the only drop in throughput is due to the few upgrades that do happen. So this plot also a little subtle. Like maybe you've realized many of these plots are kind of subtle and they really are. But it is trying to make two points. But the key point being that if with partial materialization when you add a query you can immediately start serving it because you immediately have an empty cache, whereas with full materialization you have to do a lot of work before that view is even available.
02:09:42.185 - 02:10:44.199, Speaker A: Let me make sure you get the caption. I realize we're running a little bit long, we only really have two more graphs. I'm going to skip one because it's less interesting. But does this graph roughly make sense? All right, so I mentioned how I mentioned how the actually we're just going to skip this graph because it's not. It's important, but not important enough. So the last part of the eval is about rolling your own. And this is a point that came up when I showed the very early graph, which is for lobsters.
02:10:44.199 - 02:11:22.221, Speaker A: All we've really evaluated is Noria versus like MySQL. And in reality, what many people need once they start to try to run their application at really high scale and at really high throughput, is that you stick your own cache in front of the database. You set up like memcached or Redis or something like that, and you stick it in front of your cache. And now, lo and behold, your performance is better. And that's great. And that is something that Noria has to compete with, right? Like we have to be able to articulate why Noria is better than that. And Noria is better than that primarily because it's so much easier to use.
02:11:22.221 - 02:12:09.557, Speaker A: And of course, this is a very hard point to make because it's sort of a soft point. Many of the other ones have been sort of quantitative points where, like, we can show that, like, look, we're higher on the line that this other thing is. But this is more of a qualitative one where if you have to implement caching yourself, it's really complicated, right? Like caching is hard if you have a database. Imagine even just the article with vote count view above, right? Imagine that you in memcached, you kept the current vote count. Then now you need to make sure that anywhere in your application that wants to read the vote count, it checks the cache first. And if it hits, that's great. If it misses, what does it do? Well, it needs to go to the database and get the result.
02:12:09.557 - 02:12:49.705, Speaker A: But imagine that some popular key, some popular article has its vote count invalidated because a new write happens or it gets evicted. Then now imagine that lots of clients all try to read the same vote count because it's a popular article. They all miss, they all go to the database at the same time. And now the database gets overwhelmed by all these clients asking for the same result. This is called the Thundering Herd problem, and it's really hard to solve correctly. Similarly, imagine that, imagine that a client, an application like, tries to read from cache and then it misses. So it goes to the database and, and it gets the answer from the database.
02:12:49.705 - 02:13:38.999, Speaker A: Now obviously it needs to put the answer it got from the database into the cache so that in the future it'll hit in cache. But imagine what happens if a write comes into the database after the application reads from the database. But now the value that the application read from the database, if it sticks it into the cache, the cache is now holding a stale result, an incorrect old result because the data in the database changed. And so there's sort of a race condition here that the Application needs to have logic to handle and it turns out it's really complicated to solve this problem. I think many application developers just sort of ignore this. They just do. Like when you write, you invalidate the cache and when you read you, if you miss, you go to the database, you put it in the cache and normally that works fine, but it's going to sometimes yield incorrect results.
02:13:38.999 - 02:14:06.657, Speaker A: And application developers might not be aware of this. And like, there's a paper from a few years ago from Facebook where they basically built the system to try to solve this on memcached. And it's extremely complicated. It's like a big systems paper on integrating MySQL and memcached. It requires like code level changes to MySQL and to memcache to get it to work. And it requires a lot of application level logic. And that's the application developers should just like not have to deal with that.
02:14:06.657 - 02:14:42.927, Speaker A: Furthermore, you now need to remember everywhere in your application that touches the vote count for a given article. Like anywhere that adds a vote, anywhere that removes a vote, anywhere that changes a vote. If the user wants to change an upvote to downvote or something, all of those code paths need to make sure that they update the cache. If you add another cache later, you need to then go back and check every code path in your application to see whether it should also be invalidated in cache in certain places. So rolling your own is really complicated. And that is one argument the paper is trying to make. And it's hard to make this point.
02:14:42.927 - 02:15:34.795, Speaker A: It currently tries to make it just by explaining what I went through of just like, just how complicated that is. Right? This is like implementing caching correctly is really complicated. See all these papers? But despite how error prone it is to try to implement this yourself, it's still extremely common. And Noria still has to have a story for, well, how do we measure up compared to this? And we can't just say like it's super hard, so just use Noria. Even though that is compelling, right? Like with Noria, you just don't have to do any of this. Noria will do everything for you, but we need to still be able to say, even if you did it yourself, it's worthwhile to switch to Noria. And the way we're going to do that is to compare against Redis.
02:15:34.795 - 02:16:19.825, Speaker A: So what we're going to do is we're going to construct this a little bit artificial benchmark where we're really just like testing key value lookup performance in redis and we're going to compare it to key value lookup performance in Noria. And what you see is the this and this plot is a little weird. So this pink line over here is REDIS on a single core, because REDIS is not multithreaded. And this is running just like a single key value lookup for Redis. And you see it gets to about like three falls over. This is a throughput latency graph, right? So it falls over around 2 million requests per second, which is like pretty good for a single core. That's like quite good actually.
02:16:19.825 - 02:16:50.653, Speaker A: But remember, with REDIS here, you're just like, this is not implementing any kind of a cache invalidation, no misses. This is assuming that everything hits in cache, everything goes into a single lookup, like always. It's just like the best case scenario. It's assuming that you have perfect caching. Then the best you can do with the single core redis is this much. And then this line over here is 16 times that. And the reason this is 16 times is because this is the server we're running on is a 16 core machine.
02:16:50.653 - 02:17:57.115, Speaker A: And so if you had a workload that could perfectly shard redis across the 16 cores with no overhead, then you would end up at about 25 million requests per second on this server With Noria, which is like running, remember the full SQL query of vote and is doing all the cache invalidation and stuff, you get to about 12 million requests per second, about 12 and a half. So you get to within 2x of the perfect ideal you can get with Redis. Now this is like a really weird benchmark because we're benchmarking against a hypothetically perfect system, which means that all the numbers look kind of weird. But it does try to make the point that even if you did yourself, you couldn't do better than this pink line. And Noria gets this blue line with no effort from you. And so that is the way we try to tackle this problem of like, why don't I just use my SQL plus memcache the way I currently have been? Okay, complex argument, but in theory, the last argument. So let's see whether this made sense.
02:17:57.115 - 02:18:40.145, Speaker A: People think caching is easy and do it themselves, but every single time I tried it, it cost another 10,000 problems three months into production. That's exactly right. And that's part of what the text above tries to get at as well, is doing a bunch of reference of just like there was a survey paper from a few years ago that basically looked at like, I think the Results are up here somewhere. Let me pull it up here. A survey from 2016 found that like anywhere from 0.3 to 3% of application code spread across 2 to 10% of the source files is caching related. So these first two numbers are basically caching.
02:18:40.145 - 02:19:17.877, Speaker A: Not only is a bunch of your code caching, but it also ends up spreading throughout your code base because everywhere needs to know about the cache. And cache related issues make up 1 to 5% of all issues for the application. So this really just shows that caching is really complicated to get right. And so this is sort of a soft argument for why use Noria. And then the graph is trying to make the harder argument of even if you've already solved all the problems, it's still not clear that you shouldn't just be using Noria. Instead it works right in the first few weeks and then it explodes. Just put it into Redis.
02:19:17.877 - 02:19:42.310, Speaker A: Why would it be so complicated? It's a pretty common sentiment. It's true. That last graph is really impressive. I'm glad. I've worked a lot to make this graph look the way it does. It's weird. Like this benchmark is super weird and unrealistic because like this has like a read write ratio of like 10,000 to 1.
02:19:42.310 - 02:19:57.595, Speaker A: Because we wanted to emulate the case when there are no invalidations. It's like a lot of skew. It's. It's really weird. It's weird because Noria is given 16 cores and Redis runs on one core. But hopefully this gives you. Hopefully this tells the right story.
02:19:57.595 - 02:20:36.685, Speaker A: Redis might hit a different bottleneck, even if perfectly multithreaded. How Much data is 26 million requests per second? Maybe there's already memory bandwidth limited earlier. Could totally be. This is why this is a weird benchmark, because this line is like 16 times that. And realistically you just will never get to this line. You just like won't. It could be that like you could build a better caching system that has a higher baseline, that works better, but realistically you're going to end up somewhere in between because there are all these other bottlenecks that crop up, like the network memory bandwidth, serialization performance.
02:20:36.685 - 02:21:31.035, Speaker A: If you actually build this multithreaded, then either you need perfectly shardable cache keys, which are rarely the case, usually some keys are hotter than others, or you need to have this, some serious concurrency primitive, which Noria does have, but Redis does not. If nor yet abstracts even for the general case, the caching logic at this performance point, it makes a Very good case. I mean, yeah, that's. That's the hope, right? With Noria, there's no caching logic in the application and it gives you this performance. Now, realistically, as we saw from the earlier graphs, you're probably not going to get to 12 million per second. But this is just trying to show the best case for Redis and that Noria measures up to Redis's best case. You go to great length to explain this to the reader or the committee, but I feel like every web developer just sees immediately why Noria looks so promising.
02:21:31.035 - 02:22:07.745, Speaker A: I'm glad to hear that. But unfortunately, when you write a thesis, you need to convince people that what you're saying is true. It's not about convincing people that like something might be useful for a thesis. You need to convince someone that it is useful, not that it might be useful. And that's part of why I'm like working so diligently in a sense, to try to make all these points carefully that plot those numbers, even if artificial. And that exact argument is the story for Noria. I agree.
02:22:07.745 - 02:22:41.549, Speaker A: I mean, the argument Noria makes is we do the caching for you and we do it well. Migrating a workload to cache is messy and error prone and requires upkeep. By monitoring the cache hit rates, detect possible bugs, especially when dealing with loosely typed languages. Yeah, like caching is really, really hard. But unfortunately, unless you've worked with caching, you probably don't know how hard it is. And that's why the thesis needs to demonstrate that it's hard. Noria is really interesting.
02:22:41.549 - 02:23:17.039, Speaker A: However, I don't understand what the base data that you refer to in your benchmarks and why it is on memory in Noria right now. So Noria does support keeping the base data on disk using RocksDB, but it's a use case that we do much. We've used much less. Maybe it's worthwhile running these benchmarks with durable data just so the memory use goes down. I'm not sure. It would also increase the tail latency pretty significantly because now your tail has to hit disk, which, like, maybe that's a more realistic use case. I'm not sure.
02:23:17.039 - 02:23:49.255, Speaker A: Certainly currently it's a little awkward to work around the fact that that the base table is measured in memory use. I agree. Could you please slowly tell us about this topic? I have talked about it for about two hours, so it's hard for me to explain everything. Again, slowly. I would recommend you read back the. Just watch the video again after. Cache problems are like 75% of my debugging time too.
02:23:49.255 - 02:24:23.071, Speaker A: We almost always search all other possibilities before we say it was a caching race condition. We expect it to be correct, but it rarely is. Right. But again, it comes back to the thesis needs to demonstrate that this is true without relying on just saying I have experienced it to be true. It's very easy to have writing where you say obviously it's true that caching is hard, but in a thesis setting that just isn't going to fly. We use homegrown caching at work. It's the source of almost all our bugs.
02:24:23.071 - 02:25:31.455, Speaker A: Sounds about right. And another argument that thesis tries to make is that like when you There's a reason why there isn't just like automated caching built into ORM layers and frameworks, it's because it's really hard to generalize in the application, and it's in part because caching is really hard. But part of the challenge here is that all of this is sort of anecdotal evidence. And anecdotal evidence is pretty hard to use in a sort of relatively formal setting, which a thesis is. But I hope I've managed to get pretty close. My email address is on my website. Okay, so we've now worked through it's funny, so the last, last line that's on its own page and Noria achieves this performance while providing rich SQL queries without application specific caching logic, which I think is just like the point of Noria, but it just it takes like 25 pages of evaluation to be able to make that point point.
02:25:31.455 - 02:26:25.575, Speaker A: I agree with your point about measuring also with on disk data, but since it uses RocksDB, I don't know it's ready for that. Also might not even be the point of the thesis. That's sort of what I'm getting at the like it's sort of not the point that it supports durability, but at the same time the current measurements obscure the point because of this implementation detail, which is awkward. Why would you not recommend someone use Noria? Just for the sake of argument, don't use it if your application patterns don't fit what Noria is built for. Noria is built for read heavy web applications with skewed workloads and if that's not you, you shouldn't be using Noria. Noria is not built for cases where you need strong consistency in your query results. Basically it assumes that you're fine with caching results, you're fine with getting stale results.
02:26:25.575 - 02:26:48.735, Speaker A: Noria does not support transactions, so if you need Those you can't use Noria in theory, some of these things could be added, we just don't currently support them. So those I think would be the key points. Noria for me looks like CPU from some point of view. Data go. Brr. I don't know what to say about that. Sure.
02:26:48.735 - 02:27:36.235, Speaker A: All right, so I think we're then through the eval section which is all I wanted to cover today. And hopefully as you'll realize it takes a lot just to craft the story and hopefully you feel like the story that I've. Basically the story I've been telling you through this like two and a half hours is decently compelling. There are definitely some things that are not satisfactory here. Like one of those we talked about was this graph which is currently pretty hard to read and it's not clear it makes the right point. It might be that it shouldn't even be a graph. The other of course that we discussed at length was this one and about whether these different values make sense.
02:27:36.235 - 02:28:10.605, Speaker A: There's also the point about memory use. So some of these things I will have to fix up for the. For the thesis to actually be reasonable in the end. But I think it's gotten to like narratively a pretty good progression of points and pretty strong support for the main arguments of the paper or of the. Of the thesis. I think at this point it ran a little bit longer than what I wanted. But I'm happy to take like a few questions.
02:28:10.605 - 02:28:45.831, Speaker A: If people have questions about either about like the thesis or thesis writing or like why visualize the data this way or even just about like PhDs in general. I'll do some like some, some quick shot Q and A. NORIA does not save time series data. That is correct. Although in theory you can operate on any data you want as long as you can write SQL queries. You have a plan to use GPU for acceleration? No, but you could for production use. It's certainly necessary to have good performance with on disk data.
02:28:45.831 - 02:29:08.299, Speaker A: Totally true. We went with RocksDB just to have something because it didn't really matter. It could be the rocksdb is good enough for this. Maybe I should just run the experiments and see what happened. But I agree that that's more for the post research face of Noria. If that's ever gonna happen. How many pages do you think it will be when it's done? It's a good question.
02:29:08.299 - 02:29:57.505, Speaker A: It's currently. Well, let's ignore references. It's currently 45 pages and that is with only eval and headlines. So my guess Is It'll be like 100 sort of depends, hard to say. One section I want to write that might be pretty long is I want to write this like it's going to be the appendix, but it's basically me trying to give a non technical explanation of Noria, which I think is going to be pretty cool. So the idea is that if you have no idea how databases work, you read this section first and it tells you what NORIA is, why it's useful in ways that make sense to someone who doesn't know computer science. This is basically the section I'm going to tell my mom to read and I think it's going to be great.
02:29:57.505 - 02:30:41.705, Speaker A: The automation. Yeah, so I actually have. So my thesis, if you look at the makefile, the make file is pretty straightforward, but I use a lot of Python scripts to generate the graphs and stuff and I've set it up so that whenever my benchmark data changes, the relevant graphs are rerun and the paper is rebuilt. And I also have orchestration scripts that run all my evaluation on EC2. So for example, what's a good example of this? So for example, if I wanted to run my the vote benchmark again, I could run it on EC2 just with this command. Arguably like the command is much simpler. It's really just this.
02:30:41.705 - 02:31:25.615, Speaker A: So if I run that, it's going to like spread, spin up EC2 instances, run the benchmarks at all the different data points, download all the results and stick them in this directory and it's in the format that the make file and the Python scripts accept. So this makes it really easy for me to rerun experiments, try different things and just have them all run in the same setup. I highly recommend automating your evaluation this way, especially if it's as execution heavy as mine is. It's super helpful. How do you zero in on your research topic? You mentioned doing other things at the beginning of your PhD. It's funny because right before I started this project, one of the last things I said to my advisor was I don't think I really want to work on a database. And look where it got me.
02:31:25.615 - 02:32:07.923, Speaker A: Realistically though, what happened was sort of more driven by a desire to make something better. Like I'd been doing a lot of web development in the past and I was just like, databases seem like they're not correctly built for what people use them for. I wonder if I could do better. And then I just sort of started building something and dataflow seemed cool and I like concurrency primitives. And then it built up from there. And so it was very problem driven on my part. Do you like writing the thesis? Like writing the latex document? Is the process enjoyable for you? Yes, I quite like writing, especially sort of educational writing I think.
02:32:07.923 - 02:32:48.797, Speaker A: I think I will like writing the other sections more because the evaluation section you need to work really hard to make points that I feel are obvious and I think it's for good reason. Like I think I wish I could just say like obviously caching is hard, but I understand why I can't just say that. But it's also, it's a little frustrating to write about. To write convincingly about something you feel is obvious. And so that makes it a little bit more friction. It also is like sometimes the graphs just like don't show what you want them to show. Like the number of times I've run this experiment and tweak parameters and stuff and change the way it's plotted.
02:32:48.797 - 02:33:16.121, Speaker A: It's just mind boggling and I still can't quite figure it out. And that process gets a little tiring after a while. But I think the writing itself and especially writing about the system I like a lot. Look for references to work related to your caches your paper refers to. Don't know what that means. When is your thesis due date? There isn't one. I'm currently aiming to graduate by October 31st.
02:33:16.121 - 02:33:42.505, Speaker A: But like it's weird because your PhD doesn't have an end date. It's just like when you're done, which is when your committee says you're done. So there is no due date per se. What kind of work you're considering in industry. Ideal job. I really want to keep teaching, but I don't think I want to do it in academic setting. So I'll probably just keep doing like live coding streams and stuff is probably my plan.
02:33:42.505 - 02:34:26.223, Speaker A: And then as for my actual work, ideally I want to work in in like the Rust ecosystem. I like that a lot. Maybe internally at a company. I'd basically be sort of the Rust point person internally in the company for things like infrastructure, but also for interacting with like the Rust ecosystem, the open source space. Like contribute to like core libraries and the standard library in the compiler as needed by people who use Rust at that company or just work on Rust open source in general. But it's a lot harder to be hired to just do that. Do you enjoy working on challenging problems themselves or do you prefer the practical applications? I need there to be both.
02:34:26.223 - 02:34:59.735, Speaker A: I think for me it's hard for me to work on something that I don't think is important or that I don't care about. But it's also hard for me to work on something I care about if I don't think it's interesting or hard. Like I just, I don't just want to write some code, although sometimes I do. But usually I want my brain to have to be engaged in the process. And I also don't want to build things just because they're hard. I want it to be useful to build them too. All the things you wish you knew when you started your PhD in your thesis.
02:34:59.735 - 02:35:38.515, Speaker A: It's a lot of things to ask, but I'm going to go with. When you start a PhD, one of the things that's going to be weirdest to you is that it is only you. When you're doing a PhD. It's very rare that people tell you what to do and it's all going to be driven by yourself. You need to have a decent amount of self discipline to make sure that you like continue to do work and go in interesting directions and meet with your advisors and make progress. And that's. It's an interesting way of working.
02:35:38.515 - 02:36:37.801, Speaker A: And I think the second one is that writing a thesis is weird because there are no or very few guidelines. It's a very long term and like winding process. And so I would recommend try fairly early on to start a dialogue with your advisor, your professors, the people around you about what thesis you're working towards. You're not going to figure it out for a while and that's fine. But like when you're three or four years in, if you have a project you worked a decent amount on, like start the conversation about what your thesis should be because it sucks to spend like a year on something that turns out to not be related to your thesis or not be useful for your thesis. And trying to build up a better like mental map of your path towards graduating is useful for the graph that is Redis compared to Noria. What would it look like if they were given the same number of threads? You can't.
02:36:37.801 - 02:37:00.605, Speaker A: So Redis is single threaded. You can't run it with multiple cores. That's why there's a 16 core line. In theory I could run Noria on one core. I don't. I think its performance would be pretty bad because it's just like not optimized for that use case. Like NORI has a lot of internal concurrency mechanisms because it is multithreaded and those if you run it on a single core translate just to overhead.
02:37:00.605 - 02:37:40.165, Speaker A: And so it would Be a hard comparison. MIT pays for the Amazon instances. Yes. Basically like we have a grant for the project I'm working on and the grant pays for the Amazon instances. Are you working alone on this or is it a group repair project? Well, I'm working alone on my thesis, but as I mentioned earlier there's like a bigger team of people that has sort of rotated over the years of other people who have also worked on this project, usually on different parts of the project. Then like partial state has always been my thing, if you will, in Noria. What is the most time consuming part right now and in general in your thesis? The implementation.
02:37:40.165 - 02:38:25.697, Speaker A: The most time consuming part right now is just to get the evaluation results where I want them to be and to some extent figuring out how to even plot them. But often it's just like designing the right experiments, making sure they are the right experiments and iterating on it until you get the results you want. Very often what will happen is you think you have an idea of what the right experiment is, you design it, you build it, you run it and the results are just weird. And then you need to figure out why they're weird and then you need to run the experiment again. And that process takes a really long time because it's really. You're doing performance debugging in general. Debugging is most of what you do either performance debugging or just like debugging problems.
02:38:25.697 - 02:38:44.855, Speaker A: Sometimes it's more architectural debugging. Like currently we can support this kind of operator. How might we theoretically support such an operator? And then you like work on a whiteboard for a while. So. But it's like it's all in the flavor of debugging. But that's very systems oriented. I think that's not a general thing for PhDs.
02:38:44.855 - 02:39:07.273, Speaker A: Well, you open source the automation for the data. I mean all of. All of what you've seen today is open source, including all the scripts for automating on EC2 and all the benchmarks. Everything is open source. The section for non computer science is the number one thing I'm waiting for now. I want to see these real world metaphors. It's going to be interesting.
02:39:07.273 - 02:39:37.351, Speaker A: It's basically an explanation for how you could make a library more efficient. It'll be weird. I like it. Do you struggle finding good resources are acceptable for a scientific document like a thesis? Lots of good explanations are in blog posts which are hard to cite properly and get accepted in terms of references. Not that hard. There's just a lot of academic research out there. Sometimes searching for it takes a little bit of time, but it's not too hard.
02:39:37.351 - 02:39:57.951, Speaker A: Citing blog posts is fine too. It really depends on what argument you're trying to make. Like if you're trying to point out that, like, Twitter has a certain number of tweets per second, if they wrote in a blog post, you can cite the blog post and it's fine. So that hasn't really been a problem. I really loved your course. The missing semester of your CS education. Would love to see more of that.
02:39:57.951 - 02:40:23.337, Speaker A: It was really fun class to do. We're probably going to do it again next year. I don't know whether I'll be around to do it, but I do like that kind of education and my hope is there'll be more. I got my PhD title 8th of this month. Congratulations. Do you have some background in education or it just flows naturally? I don't know. I've just.
02:40:23.337 - 02:40:32.465, Speaker A: I've done it for a long time. Right. I've TA'd. I've been in academia for a long time. I've been a student for a long time. And I also just really enjoy it. And so it's probably a little bit of a mix.
02:40:32.465 - 02:40:57.395, Speaker A: I think it has. Trying to explain things has always been a pretty natural part of things to me. So that might be part of it. As a Rust programmer, what do you think about using Rust in the Linux kernel? It's cool. I'm not going to go too much in depth in it because this is not really a Rust stream. You mentioned that you are on your own. How do you cope with that? And how do you drive yourself? Sometimes it's hard.
02:40:57.395 - 02:41:33.793, Speaker A: Like sometimes you're just not feeling productive. Usually. I haven't found it to be that much of a problem, but that's because I've usually found the work pretty interesting. But there are certainly times where I'm just like not feeling productive either because I'm not excited by the current problem I'm working on, or I've been stuck on a bug for a week and I'm just not making progress. And some of it, I think, is just like some of the way you get through it is by recognizing that it's okay to get stuck. Like it's okay to not work for a week when you're doing a PhD and be like, I need to take a break. And that's just a natural.
02:41:33.793 - 02:42:28.199, Speaker A: Part of being your own boss is you need to manage your own sanity as well. Like, it's okay to not be productive for a bit and like, do something Else in terms of how I sort of drive myself, I think partially it's driven by interest, partially it's driven at this point at least by a desire to graduate and partially it's driven by. I do a bunch of other things that I think are interesting and that gives me enough distractions that I don't get burned out on the main project. Like if I didn't have my live streams and some of the open source work I've done, I would probably have gotten pretty burnt out by this. And I'm still a little tired of having worked on the same thing for so long. But having all these side projects have helped a lot. Are you working full time on your thesis? Yes, I mean I'm a full time PhD student so yeah.
02:42:28.199 - 02:43:05.155, Speaker A: Can you share papers this paper refers to? I mean they're all in the bibliography which is also in the. Which is also in the repository for the thesis which I'll include in the video description and I think someone posted it. It's just GitHub.com John who Thesis if you look at the bibliography file it has all the references. I think that's all the currently outstanding questions. So I think we're going to end it there. My hope is that this was still useful.
02:43:05.155 - 02:43:41.335, Speaker A: It's a little bit of a weird stream. It's very different from the ones I normally do and I didn't have a good sense going into it of what it would turn into. I think maybe it was useful, hopefully it was a little bit interesting. I might do more of these depending a little bit on how the extent to which people found this useful. If you did find it useful, please let me know. And then if there was enough interest in this then what I'll do is probably do a stream on like the introduction and motivation section at some point or maybe on the design section. We'll have to see.
02:43:41.335 - 02:43:50.595, Speaker A: But yeah, thanks all for joining in and I'll see you next time. Stay safe everyone. Bye.
