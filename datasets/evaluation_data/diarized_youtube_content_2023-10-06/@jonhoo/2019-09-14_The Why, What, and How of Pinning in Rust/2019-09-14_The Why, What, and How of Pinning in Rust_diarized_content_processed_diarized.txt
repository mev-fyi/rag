00:00:00.240 - 00:00:43.447, Speaker A: Everyone, welcome back. It's been a long time since last time, but finally I'm now back. I also have a new microphone which is really cool. One of you gifted it to me and that is really exciting that I can do something where people feel excited enough that they will contribute to help make things better. I am John, as you can see from screen, I've been doing these streams now for over a year and I do streams on all sorts of Rust related things. Some of them are live coding streams, some of them are open source contribution streams, and some of them, like this one, are more sort of educational streams. And so there's a Twitter where I announce upcoming videos.
00:00:43.447 - 00:01:31.631, Speaker A: I also have a YouTube channel where I post all of the sessions we have after the fact. So you can go back and look at any of the old videos if you want to. I also, for various annoying reasons, I can't actually have a Patreon in the us and so instead I've recently started this Amazon Wishlist that's linked to from my Twitter. So this is how I ended up with this microphone. If you have something to spare and you want to show your appreciation for what I do, then please find something here that you think could be fun to buy to help me and help with with the streams. So today's stream is going to continue on from a stream that we did a while ago, which is this one. The what how, the what and how of Futures and Async Await in Rust.
00:01:31.631 - 00:02:31.977, Speaker A: So this stream we talked through, like what are Futures, how do they work? What is Tokyo? What are run times? How does all this machinery fit together? What is Async Await? How does it interact with Futures? How does it change the way you write code? And as part of that video we also touched on this notion of pinning and we talked a little bit about what that means. But I feel like there's a lot more space for being able to talk more about pinning. And that's what this video is going to be about. It's going to be about what is pin, what is unpin, why do we need them and how do you use them. I'll try to keep an eye on Chat for questions as we go. For these educational streams, it helps a lot to sort of observe what you understand and what you don't as we go. So if there's anything you feel like I'm not entirely sure what he means here, please ask a question because that way there are probably other people who wonder the same thing as you do and I can then address it.
00:02:31.977 - 00:03:14.337, Speaker A: And also Your the question and the answer will then be recorded in the stream for other people to learn from. Right. So the reason we're doing this, I have this live stream voting site where a lot of you have voted in the past and in fact I can just pull it up here so this you can vote for what upcoming stream ideas are most exciting to you. The current winner is this open source contribution stream, which I think is really fun. We've done one in the past, but I had this idea of I really think it's important that someone do a stream on pinning. And so I decided, well, I should do one. And so I did this poll on Twitter to ask people what they wanted to see.
00:03:14.337 - 00:03:49.415, Speaker A: And as you can see, the overwhelming majority of the people who voted wanted to see like a deep dive into PIN and unpin. And so that's what we're doing. I will try to also take a few of the practical considerations into account when doing this. So my hope is to also get to look at some code and how code changes when you're moving to pin. But it will be primarily about sort of the ideas of pin, like why do we have them and how do we use them. Great. All right, no questions before we start.
00:03:49.415 - 00:04:38.075, Speaker A: That is great. So let's just dive right on in. So, as part of a recent Rust release, pinning is something that landed in the standard library. And pinning is usually talked about in the context of Async Await, because that is primarily where it comes into use in Rust today. But it's not really about Async Await. Pinning is a more general concept that happens to solve some of the issues that Async Await ran into. So what we're going to do today is sort of look at why do we need pinning in the first place, why do we need the concept of pinning and what does it even mean for something to be pinned? And part of that is going to be discussing the PIN type.
00:04:38.075 - 00:05:18.809, Speaker A: So PIN is a struct. It's not a trait or anything, it's just a struct. And also part of it is going to be talking about the autotrait unpin. So auto traits are things like send and sync and unpin, which are automatically implemented by almost all types in the Rust type system and that the compiler will auto implement for your types if all the things it contains are already unpin. We'll also look a little bit about more sort of tools for dealing with pin, but we'll look at those later. So what is like the fundamental problem the pinning is trying to solve? Well, Pinning. There's a lot of text here that you can read if you want to.
00:05:18.809 - 00:06:04.237, Speaker A: But we're going to look at this from sort of a code perspective, which is as follows. Let's say that you have some struct foo, let's call it. You have some struct parsed and parsed. In parsed, you want to have a bunch of bytes and you want to have like a wrapper, which is actually, let's do this. Owned parsed and you have a struct parsed. Let me just type this out. And then it has a bunch of fields that reference into a.
00:06:04.237 - 00:07:07.585, Speaker A: So, for example, like name. So the idea here is that you write a parser and your parser is going to generate these structs called parsed, and they're going to have references into the byte stream that was parsed in the first place, right? So this is totally fine. It means that you can write like, I guess if we wanted to write it this way, it takes like a bunch of. It takes an input string and it returns something like result parsed, right? But notice that there's a lifetime here. Who knows what this error type is? There's a lifetime here in parsed because it refer, right? It refers to data that is in the input. And now imagine that you wanted to write a version of this where they called owned parse that didn't have a lifetime. And the idea here would be that you have a buffer that has a bunch of bytes and you want to also have the parsed representation stored with that buffer.
00:07:07.585 - 00:07:51.435, Speaker A: So now you can sort of think of this as this parsed. Its lifetime is really sort of like self, right? This parse lives for as long as this buffer lives, sort of, right? It's a pointer into. It has a bunch of pointers into this buffer. I guess it should be U8 just for consistency. So this has a bunch of pointers into this buffer. So as long as those bytes don't move, this struct is fine and you can move it around, you can keep using parsed and you don't have to worry about the fact that there's sort of implicitly a lifetime tied to it, as you might wonder. Well, this seems like a very niche use case, and it's true.
00:07:51.435 - 00:09:21.633, Speaker A: But it happens to be that this pattern is pretty common, in fact, for async await, if you write something like an async fn foo and let's say it takes no arguments and it doesn't really return anything, and you write something like it doesn't really Matter. But let's say we have a buffer of something here and then we do something like. I don't want to write out the things here, but let's say we do something like read, mute, buff, await, and then we do something like write, buff, await. Fine, I guess this will take din, mute, din, async, read plus async, write or something. It's not exactly important what this does, but the idea is that you have an async function and you do some awaits in it. Now, this might not immediately remind you of this. There doesn't seem to be anything similar, but if we dig in a little bit more, we can actually see that these are the same.
00:09:21.633 - 00:10:21.715, Speaker A: And give me a second. So here, when you call foo the first time, let's de sugar this a little bit first, right? So this is really this, right? These are the same mostly. I guess technically there's something like an async move here, sort of like this, right? But the question is, what does await desugar to? Well, really what happens under the hood here is that, is that the compiler is going to look for every weight point and sort of turn it into a yield. I'm gonna, I'm gonna tell you what yield means in a second. So let's imagine that it gets desugared to something like this. And the idea here is the first time foo is called, it starts executing until it hits the first yield. Yield gives you a future, right? This produces a future.
00:10:21.715 - 00:10:59.579, Speaker A: And now it's going to continue executing that future until it completes. But the question is, what happens when it completes? Well, when it completes and foo sort of continues from the previous yield point, it needs to continue from here. It can't start from the beginning because then it would do the read again. It has to sort of continue from here. And the same thing, when this yield happens, this produces a future. When it eventually completes, foo is going to continue from here. But what does continue from here mean? It means that any of the state that the that we have already is going to have to be kept.
00:10:59.579 - 00:11:58.463, Speaker A: In particular, this buffer here has to be stored somewhere, right? Because if you're going to continue from here, you're going to reference buff, right? So. So this sort of has a pointer up to buff. Similarly, this future also has a pointer up to buff. So really what gets generated here is something like a foo future. You think the compiler almost generates this, which is like there's a start, and in start you just have this buffer, I guess this would be U8 something. And then you have a like step one, which is A, I don't know, an Ioread future, right? But this really sort of has a lifetime, it has a reference, it contains a reference to the buffer. So it sort as a reference to start in a weird way.
00:11:58.463 - 00:13:32.265, Speaker A: And similarly, this right future here also has sort of a reference to start. You see what I mean? Because this future is trying to read into this buffer. Similarly this future is trying to write from this buffer. And so both of these types are really the problem and what we're struggling to express both in this tickself and this tick start is that they're sort of self referential, right? They want to have pointers into themselves. How would it know the yield it got is the first one? So the compiler doesn't actually generate yields, but you can think of it as it remembers where it last awaited, right? So the compiler is going to generate code that almost looks like a state machine, right? So that foo is going to be called again, but when it gets called resumes from the right place, you could imagine this is something like an enum where if you're in start, then you execute from here, if you're in step one then you execute from here, and if you're in step two, you execute from here. So it's really just the compiler keeps track of where you are in foo and where it should continue from. Regardless though, all of this has to generate self referential code code that has pointers into some stuff that it itself owns.
00:13:32.265 - 00:14:49.557, Speaker A: All right, so why am I telling you this? Well, what was the other, who's the caller from that code? The caller is whoever tries to await this future is the caller. So why do we need PIN for this? Well, pin, the idea behind PIN is that the moment you place something in a pin, you are promising that you will not move it again. And why does that matter? Well, let's stick to the simpler example of our parser here. Once you have parsed into, Once you've parsed this buffer, you can no longer move the bytes in this buffer. If you did, then the pointers, the parser keeping would be invalid, right? If you move these bytes, then the pointer in here that points to those bytes would be invalid and the whole struct would become invalid. So if you have. So this is where we get to the PIN type so we can look at the definition for pin.
00:14:49.557 - 00:15:33.885, Speaker A: So PIN is pretty straightforward. It's just a struct that has a P. Where we learn more about P is when we look at the impulse for P. So PIN P, the P has to implement deref. So think of this as P is a pointer type and the target of PIN is the type that we want to talk about. So, for example, you can have a pin of a mutable reference, right? So then the target type of the DEREF would be a T. So, for example, let's see what's the best way to exemplify this? Imagine that.
00:15:33.885 - 00:16:39.673, Speaker A: Actually, let's bring back our async here. Async foo. Bring it back to the way it was. All right, so here, so here the await points right here and the await point right here require that buffer is pinned, right? The moment you have gotten to one of these futures, you are no longer allowed to move the buffer because this future and this future both have pointers to it. And so this is why, if we look at the future trait, let's bring that up here. So the reason I talk about future here is more because it's the currently the easiest application of pin, not because PIN is necessarily related to futures. So if you look at future, what this is.
00:16:39.673 - 00:17:39.549, Speaker A: So the poll method of future is the thing that drives a future forward is saying that self needs to be pinned. And why does it say that? Well, it says that because if you have a future that is like an async function, then only when it is pinned is it safe for you to keep executing it. Or let me try to find the right words to say this. Okay, let's think about this just from this perspective, first of all. So this is sort of going to generate at the point where we're the thing that we're awaiting here, the future that we're awaiting here. Right? Let's try to write that out. So it's an Ioread and it's a future.
00:17:39.549 - 00:19:07.763, Speaker A: It has a reference to a buffer, right? Somehow has a reference to a buffer that is the future that gets generated and it like keeps a stream, which is a mutant async read, right? And we're going to implement future for future. For Ioread output is, I guess, something like an IO results usize, but the exact type is not important. I'm going to leave off some of the less relevant parts here. Oh man, I can't type today. Yeah. Okay, so this future is written like this, but the future of foo needs to include buff, right? Because there's foo returns, a future. So what does that future look like in this case? So this does some stuff.
00:19:07.763 - 00:19:52.275, Speaker A: It's not terribly important. But the larger future that is generated for all of foo is something like buf, which is a U8 1024 and an ioread which needs to have some lifetime. Really it has the lifetime of buff. Now you can't write self referential structs in Rust today. You can write them with pointers, but you can't really. You can't write them with normal lifetimes, right? So this future has a reference to buff sort of. Internally you could imagine this is something like.
00:19:52.275 - 00:20:31.107, Speaker A: If you wanted to approximate this, you would use like raw pointers or something. But really what we want to say is that this future is tied to buff. But this would not be okay in and of itself because now if you moved foo future that moves buff, right? Buff is just bytes directly embedded in the foo foo future struct. So if I wrote some code like this, I would say let's say that I had a main. I said let F is foo. So F is now of type foo featured. We're imagining that this is the code that the compiler generates, right? It.
00:20:31.107 - 00:21:30.365, Speaker A: It magically knows how to make this buff lifetime work out because the compiler can do that. So when we call foo, we get back a future because it's an async fn, and we're going to imagine that that future looks a little bit like this. Okay, now imagine that I do something like f.f.poll, okay? And now I'm going to do let Z is F and then I'm going to z.f.pol. do you see a problem here? So here if, if we think about memory, right, the memory for the buffer is stored in F. It's sort of particular memory location. And when we call poll, this S is going to try to read into this buffer, okay? So it reads some bytes into that buffer and that's fine because this buffer points into F, right? And F hasn't moved.
00:21:30.365 - 00:22:06.475, Speaker A: The problem here is at this point we're moving F. Buff is no longer the same place in memory, but we haven't changed where the buffer in the IO read future points. It still points into F, but we've moved away from F. And so we now call poll on the IO read that we moved into Z. Then now it's going to try to read some stuff into buff. But this pointer points to buf, which was in F, which is no longer there. Like you can imagine that here effectively F is dropped.
00:22:06.475 - 00:22:54.075, Speaker A: So if we, yeah, it's just going to be an invalid pointer at this point that is not allowed to read into. And so at this point our program would like crash with like invalid pointer or use after free. If you're sort of from C world, you could imagine it's something like that. So before we continue, I'm going to take some questions because there's a lot to unpack here and yeah, let's see, how do they schedule the execution? At this point I'm not imagining that there's any executor. I just imagine that poll is called manually for now. That's still sufficient to explain what the. What the problem is.
00:22:54.075 - 00:23:49.937, Speaker A: Shouldn't the buffer be a field and a struct? So it's a separate memory location? Yeah, so that's why I moved it out to here. Really what you can imagine here is there's. There are some fields that are like the ongoing state of the async fn future and there's some stuff that's like. There's like an enum here which is like progress, which is like an enum, which is something like step one is an IO read. Buff, if we wanted to flesh this out a little, then this is really more what it looks like and in fact, let's write this out, this might actually help. So part of the problem with explaining this is that you can't express self referential types in Rust today. And so even writing the code is tricky.
00:23:49.937 - 00:24:40.255, Speaker A: There's going to be some return type here, so it's going to match on progress. Let's ignore the PIN for now because we haven't really explained what purpose it serves here. If we're in step zero, then what we're going to do is we're going to do self progress is. You can't really say this either. You can't have anonymous enums. But let's imagine that we do step one Ioread new of I guess this also has a new denmaison read. So buff and S Here are the fields of foo anything that's not a future, basically any local variables and such.
00:24:40.255 - 00:25:38.715, Speaker A: Right. So it's going to create S and then notice here that it takes a mute to the buffer. Right. So step zero is just creating the IO read in the first place. And this is where the pointers into the buffer in foo future is taken. And if you're in step one then what you're going to do is like Ioread future then ioreadfuture pol and here you can imagine it's doing something like it's going to match on this and if it's pollready then it's going to something, something, something. Step two and if it's poll, let's do this in a way where the Compiler won't yell at me.
00:25:38.715 - 00:26:28.627, Speaker A: And if it's poll pending, then it's going to return poll pending. Does this roughly make sense for why this would be the future generated by this async fn, right, that this is how it keeps track of how far through foo it is. Right. So here, if there was another future we waited on down here, then that would be the step two part, and then there would be a step two here, which is if you're now in step two, then this is the future to poll. That sounds like we initialize a second buffer to store a temporary value until the async is finished. Wouldn't that be pretty expensive to do? Yeah. So the reason we want to be able to write the code this way is because there's only one buffer.
00:26:28.627 - 00:28:07.971, Speaker A: Rather than having to allocate a vector or something, we can actually have a buffer that's like embedded into the future that we do the reading and writing for, so that we don't have to do any dynamic memory allocation at this point. Not going to deal with things that are off topic right now. Okay, so does it make rough idea that this is the kind of future we would get or would get generated by the compiler if you wrote something like this just to sort of check the realm the same page there. And does it also make sense that without any other considerations this would be a problem? Right, because here, in fact we could just do don't need dot f here, right. When we first get foo future here, where it's step zero right here we're now at step one and buff points into F. Yeah, or I guess I already buff points into f here we're still in step one and I read buff points into F, which seems like a problem because F has been dropped, right? So this seems like a problem. So the question becomes how do we fix this? In fact, let's just for now, this is the old future trait.
00:28:07.971 - 00:29:02.155, Speaker A: This is how futures used to look, right? That you just took mute self and then you can run into exactly this problem. Assuming you had a way to write self referential structs, right? This would not be okay, well, so how do we fix it? So this is where pin comes into play. So pin is you're establishing a contract. You're promising that once you've placed something into a pin, it will not move ever again. This is not saying that you can't move foo future. It's the moment you've given out a pin to a foo future that foo future will not move going forward. So this is A it's a little bit important, right? If I am here in step zero, then it's fine for me to do this, right? And then let G is Z and let F is G and then pull F.
00:29:02.155 - 00:29:53.985, Speaker A: Totally fine. Because at these points I haven't called poll yet, so I haven't given out a pin. Okay, so let's talk about why this matters. So with this type signature instead, poll is now saying, in order to poll, you must promise that foofuture will not move again. And the reason for this, of course, is that we have references into the foofuture once we've moved past step zero, right? Once we start polling, then it is no longer okay for foofuture to move. Because of this problem right now, once poll takes pin, look at how this changes. So now if I try to write the same code.
00:29:53.985 - 00:30:28.305, Speaker A: So let's copy that down here. Okay? So this is all still fine. I can't call Polon F, right? I have to do something like X is PIN new at mu def and now I can call F poll, right? And that's fine. IR read is now going to point to debuff, just like we did up here. I can't do this though. If I move. Well, I can if I move.
00:30:28.305 - 00:31:04.209, Speaker A: If I move F, then I'm really just moving the pin, right? I'm not moving F. And so this is still fine. And I can still pull here. So this is fine. So what if I really tried hard to move F? If I did something like mem replace and I did. So how do I get at the F? It's behind a pin. If I really wanted to, like I wanted the program to crash, how do I do this? Well, I really want to move the F behind the pin.
00:31:04.209 - 00:31:35.451, Speaker A: So how do I do that? Well, you can imagine that I did something like going to dereference the PIN and try to get at the thing inside it, and I'm going to replace it with a new foo or something. So will this work? Well, let's look at pin. So pin. So this is the critical part. This is basically what makes PIN work. D ref mute is only implemented for PIN if the pointer is dmute. So that makes sense, right? You can't.
00:31:35.451 - 00:32:07.241, Speaker A: You can't get to the thing the PIN is getting at without the type in between being drfmut. But also it only is implemented if the target of the pointer is unpin. What the hell does that mean? Well, remember I mentioned at the very early beginning that unpin. So this marker trait is generally implemented for all types. It's an auto trait. So you will get it for pretty much all your types. If you're.
00:32:07.241 - 00:32:45.575, Speaker A: If all the things inside your type are unpin, then your type will be unpin, and most of the things in the standard library are unpin. Some things that are not unpin is anything that contains self references. So for example, foo future would not be unpin. The thing that gets generated for this async fn foo is not unpin. Specifically here the compiler will generate something like not unpin for foo future. So notice that this is opting out of the unpin thing. What does that mean? Well, it means that I can't de ref mute pin.
00:32:45.575 - 00:33:08.611, Speaker A: That won't work. This pin to F. I can't. I can't do this. This won't compile. It'll tell me that the F I'm trying to get at isn't unpin, which was required for the D ref mu don pin. And so therefore I won't be able to get at this.
00:33:08.611 - 00:33:51.495, Speaker A: I won't be able to move the F behind the pin, which was the whole purpose. I have no way of invalidating this pointer. And so let's look at how this changes the implementation of future this poll. So when you're given a pin to self, you can no longer get at the fields, right? If I do match on on self dot progress, all I get is a immutable D, which seems like a problem, right? I can't. I can't change the step by mat and this is because we've. We are saying that we're not unpin, so it's not okay to mutate self. And you can imagine that this is because he if I could just violate the pin if I was given.
00:33:51.495 - 00:35:05.330, Speaker A: If I was given the ability to mutate self in here, I could violate the pin contract immediately by saying like member place self buff with or just memory place all of self with some new foo, right? This would violate the contract because we've given out a pin to this foo future, so we are not allowed to move it. All right. This is still a lot to chew on and we will go through many more examples because it takes a while for this to click. So don't worry if this is. If there's a lot here, does that mean a big impact on compilation times? Not sure what you're referring to as you are stating that for each await point another step is created. Oh, I see. So it is true that the longer your asynchronous function is, the larger a struct the compiler will generate for that Code, right? Because it has to keep track of all the progress points, so to speak, of that function that doesn't really lead to longer compiles.
00:35:05.330 - 00:35:44.531, Speaker A: It does mean that async function is going to generate a larger future. But it's not clear that that's really a problem. How can you mute itself if you only have a pin, right? So that's the big next question. So let's deal with that. So in the case of poll here, we know that the reason why foo future isn't unpin is because moving the buff wouldn't be okay. We know that it's fine to switch steps, right? Going from step zero to step one is totally fine. Step one just has a pointer two buff.
00:35:44.531 - 00:36:46.039, Speaker A: So buff can't move. So we can read. We can basically reason about our future implementation or about what other type we have and say that in this case, I know that it's okay for me to modify self progress, it's not okay to modify anything else, but it is okay for me to modify self progress. And so this is why for here and this. So you'll notice that there are unsafe methods called get unchecked mute and map unchecked mute, which are unsafe for this very reason right here. So, for example, let's use this get unchecked mute to demonstrate something that's wildly unsafe. If I did this, so why is this not okay? Why is this unsafe? Because if I did this, there's nothing swap.
00:36:46.039 - 00:37:32.521, Speaker A: There's nothing. There's nothing stopping me from doing this, right? Nothing stops me from doing this, but this would not be okay. In fact, and then let's say I drop X here. All of this is totally fine for me to do. And here I've moved something that was behind the pin, which I've promised not to do, and the. The reference to buffer inside F2 would no longer be valid. So this is why this is unsafe.
00:37:32.521 - 00:38:34.533, Speaker A: Because normally it's not okay to do. In our particular case, we know that it's okay for us to access access self dot progress. So what we can do is we can do something like progress is this progress, right? So what this unsafe is guarantee is not guaranteeing. But with this, what we have to promise in order to make this unsafe safe is that there are. We're not breaking any references, we're not breaking any self references by getting immutable, getting mutable access to progress here, right? And we know we're not doing this because we know that all the things inside progress refer to buff. But there's nothing else that refers into progress. So that's why this is okay.
00:38:34.533 - 00:39:34.115, Speaker A: And now of course, here we can match on progress, we can change progress, and that's all fine. And this now would refer to. And here we're mutating the Here we're giving out immutable reference to the buffer, which is also fine because we know. And the reason this is okay is because we know that the buffer won't move because foofuture is unpin. Now, of course we can actually write this code because you can't write self referential code in Rust today. But you can imagine that this is basically what's going on under the hood when the async, when the compiler generates a type from this is that it finds a way to get a mutable reference to this and assign it some lifetime. All right, does that roughly make sense why we need the unsafe here? If not, I will happily explain it again.
00:39:34.115 - 00:40:44.885, Speaker A: Just leave some time for chat to catch up. In particular, you see how this, this solves the issue down here of now there's no way for you to. For you to cause the IO read inside of the foo future to have an invalid pointer because it's hidden behind a pin. Can't the language team add reasoning in the compiler about internal references to avoid using unsafe? Yeah, so internally you can think of this as the code that the compiler generates. It knows when it can use this unsafe, it knows which things are referring to which. And so this is why when you write async fn, you don't have to write any unsafe. The compiler is going to generate some code that probably uses unsafe, but it doesn't have to generate any unsafe itself.
00:40:44.885 - 00:41:18.459, Speaker A: So you don't have to write any unsafe when using async fn. All right, so that brings us to things that are unpin. So one thing you'll notice is that if you look carefully at pin, you will see that there are. Let's look at. I get this one maybe. So we talked about get unchecked mute. So this is.
00:41:18.459 - 00:41:50.175, Speaker A: You are promising, right? So this is where you see in our safety, you must guarantee that you will never move the data out of the mutable reference you receive when you call this function, because that would, that would. That would violate the invariance on the PIN type. Right? So that's what we said. We. If we do this, then we will not move T. That is what we're promising by calling this function or by wrapping this as unsafe. So if I don't use async, I would have to use unsafe with pin Ah, no.
00:41:50.175 - 00:42:24.275, Speaker A: So not quite. This is what we're getting to now. Notice that there's also this function get mute. It goes from a self, which is a pin, a pin with a mutable reference to t and it just goes to a mutable reference to T. Why is this okay? Why is this unsafe? But this is not unsafe. And the critical thing here is where T is unpin. So if the thing you're pointing to is unpin, then it's totally safe to get mutable pointers to it.
00:42:24.275 - 00:43:24.615, Speaker A: This is the same thing that we saw below, right? There's an implementation of D refmute for pin. If the pointer type, so this would be like immutable reference or something, is dmute to t and the target is unpin, then you can basically just ignore the pin, right? If the target is unpin, then it's as if the pin wasn't there. Why is that? Okay, well, it's because if you have a type like if you have a type like if you have a U64, right, or a U size or something, then you know that a usize doesn't have any self references. So you know that that type doesn't care about being moved. So even if you've promised that you won't move it again, it's fine to break that promise. That is what unpin means. If a type is unpin, it means that it doesn't care about that promise.
00:43:24.615 - 00:44:11.895, Speaker A: So for example, foofuture is not unpin because it cares about being moved. It needs to have this promise that it will not move once you call poll, right? However, a type like let's take Ioread Ioread is unpin because it doesn't care about you moving the I.O. read you moving. This type is fine even after you've promised you're not going to move it again, it doesn't care about that promise. So what does this mean in practice? Well, let's go to also the. There's something wrong about this line. I'll explain that later.
00:44:11.895 - 00:44:39.417, Speaker A: So if I do something like, right, here's a type that you're going to see in the. You'll see in like all of the future, the futures crate. Like I think it's in futures util or something. And that is the ready future. Let's just call it ready. It takes a T and an e and internally. Actually it doesn't even do that.
00:44:39.417 - 00:45:41.005, Speaker A: It just takes a t and it has a value which is a t and there's an implt future for ready T. This is a real future. That you'll see in the futures library, its output is T. I'm gonna leave off the context just because it's annoying self output. And what does this do? Actually, I think this is like an option, and this does poll ready self value take, unwrap. All right, so this is the real implementation of ready, basically. So there are a couple of things you might ask yourself here.
00:45:41.005 - 00:46:41.055, Speaker A: The first one is how is it okay for us to call take on this option? Take takes a mutable reference to the option. Why is that? Okay, well, remember, PIN implements dmute. If the target type is unpin and the target type here is self, so the target type is ready. So is ready unpin. Well, actually, in this case it's not unpin unpin, although it's unclear it matters. So in this case, if T is unpin, then remember, unpin is an auto trait, right? So if all the things you contain are unpinned, then you are unpin. So in this case, ready T is unpinned in here because T is unpin.
00:46:41.055 - 00:47:52.975, Speaker A: So in that case, PIN implements draft mute, which means that we get a mutable reference to value, which means we can take it. So ready here is really just like a future that immediately yields the value you give it, and it is unpin, which is what lets us basically ignore the fact that there's a pin here at all. And this will very often be the case if you ever have to deal with pin of a type that where the type is something you have written. Usually that type will be unpin, right? Usually you don't have to worry about whether things are pin or whether things are unpin or not, because usually they will be unpin. And then you can just use the value as if you had a mule reference. And so now the question becomes why is this? Okay, well, so R is a ready where the value is, I don't know, 8. 8, right? And then I'm gonna call it R dot poll, and then I'm gonna, I guess, let pin you right, because I need to pin it in order to call poll.
00:47:52.975 - 00:48:48.677, Speaker A: And in this case, the unwrap is going to fail. But let's ignore that. Let's talk about the pinning aspect of it. If I now do mem replace mut r with another ready, this isn't a problem, right? Moving this ready even after I called poll isn't a problem because there are no self references here. There are no references here that would be invalidated by moving the ready at all. Right? This is just not a problem. And the way we express that in the type system is that ready is unpin, Ready says I do not care about the promise you made for pin, and so you can pin and unpin me however you want.
00:48:48.677 - 00:49:30.045, Speaker A: If you have me in a pin, you can get me without a pin. If you have me without a pin, you can get me with a pin. The PIN doesn't matter to me is what unpin says. In fact, we can see the extreme version of this if we look at PIN here, where you say, see that there's even a safe function on PIN into inner, which takes a pin to a P and gives you the P. So it just removes the pin, right? And here crucially, the requirement is that the target is unpin, because if the target is unpin, it doesn't care about the pin. So as long as you have unpinned types, nothing matters. Or rather the PIN doesn't matter.
00:49:30.045 - 00:50:22.295, Speaker A: And you see that this is explained in the docs too. That requires that the data inside the PIN is unpinned so that we can ignore the pinning invariance when unwrapping it. So the only time we really need to care about PIN is when types aren't unpin. Because then we need to deal with this business of there are self references that we have to be really careful not to not to violate. If I understand correctly, the only requirement to be unpin, as it's an auto trait, is to not be self referential. Basically, yes. Now, are there bigger requirements the other time you will run into it is if you are generic over things.
00:50:22.295 - 00:51:10.221, Speaker A: Because if you are generic over things, then they might not be unpin. So this is why for ready, for example, we have to bound ourselves by T being unpin, because otherwise we couldn't get a mutable reference to ready because ready wouldn't be unpin. Of course, the example of this is imagine that T here was a self referential structure. Then if you have a PIN of mute of self, then taking here would move that self referential struct even though it was pinned, and so that wouldn't be okay. Can we construct a PIN from an object? Or do we need some kind of pointer to call PIN new? Right? So that is. That's an excellent question. That's what we're getting at next.
00:51:10.221 - 00:51:45.875, Speaker A: So I told you there was something wrong with this line. If we look back at pin, we'll see what it is. So PIN new is totally safe, but it requires that the target is unpin. And why is that? Right? It's because creating a PIN around a type that doesn't Care about pin is obviously safe, right? It's totally fine. You can create pins left and right. You can remove them and add them and whatnot. However, if you have a type that's not unpin, I really, I want the docs to be like this.
00:51:45.875 - 00:52:53.999, Speaker A: If you have a type that is not unpinned, so this is the block for things that are not unpin, then putting it in a pin means that you are making a promise. You are making the promise that you will not move it again, that it cannot move again, or rather that you will not move it again, right? And so therefore the constructor for PIN when the type is not unpin is unsafe because you have to make this promise. And if you look at the safety here, there's sort of a pretty long argument for why this matters. So this constructor is unsafe because we cannot guarantee that the data pointed to by pointer so the P type is pinned, meaning that the data will not move or its storage invalidate until it gets dropped. If the constructed PIN does not guarantee that the data P points to is pinned, that is a violation of the API contract. It may lead to undefined behavior in later safe code. By using this method, you are making a promise about the D ref and draft mute implementations.
00:52:53.999 - 00:55:06.715, Speaker A: If they exist specifically, they cannot move. So let's dig into why this matters, right? Why is new unchecked a problem? Well, imagine that I wrote a malicious implementation of DREF mute. So my evil pointer, all right? So this has a T, and I'm going to target is T draft. All right? So I'm gonna have a main here. I'm gonna do let X is. So X is going to be a foo future, which we know is on pin, right? And then I'm actually gonna do my evil pointer, all right? And then I'm going to pin that. So this, of course is not okay, right? Because you can only pin when the target of the pointer is unpin, which for future is not.
00:55:06.715 - 00:56:02.427, Speaker A: So we need to use new unchecked. Now, let's imagine that new didn't have the requirement. Let's imagine that it was fine for the target of new to not be unpin, right? But we still had the requirement of unpin to get admutable references and such, right? So I still couldn't move out of X. I couldn't. I still couldn't move this because I wouldn't be able to do, say, mem replace X with this, right? This I still couldn't do because this PIN wouldn't implement draft mute because foofuture is not dmute. Right? So why isn't this okay? Why can't PIN new just work for any type? Why does it need to have this bound on unpin to be safe? So the reason is imagine that this code all. Imagine that PIN new accepted any pointer type.
00:56:02.427 - 00:57:29.675, Speaker A: It did not have any restrictions on pin. Then notice that if I do notice that the deref mute for my evil pointer, it is given a mutable reference to self. There's no pin here even though down here x has been pinned, right? This deref mute is still given immutable reference to self. So if I had this evil pointer where inside of here I'm going to replace, let's say like T is default or something, it's not important or replace it with something here then now this line violates the PIN guarantee, right? This wouldn't be okay. And I think they get at this here. Yeah, by using this method you're making a promise about the D and D mute implementations. If they exist, they must not move out of their self arguments, right? Pin as mute and PIN as ref will call them on the pinned pointer.
00:57:29.675 - 00:58:16.175, Speaker A: And if you look at as mute, so as mute goes from. So this is critically the reason this is necessary. There's this function, it's easier to read it here. So what does this function do? Well, it lets you go from say a pin box t to a pin at mut so as that useful. What is useful for cases like you want to call future poll. So future poll, if you recall has a type that requires a mute self. So if you have like a pin box t and you want to call poll, use as mute to get a pin mute.
00:58:16.175 - 00:59:43.957, Speaker A: Right? So this function is pretty straightforward, but it is safe for all types, right? So it internally basically just calls self draft mute pin new unchecked internally. This is what it does, right? And why is that? Okay? Well because if I have a pin to the outer to the to the boxt, then the target is also pinned like this should be totally safe. But the exception to that is I have to go through draf mute. And so if the draft mute did this, this would not be okay. And so this is why you creating a PIN in the first place. You are making a promise if the type is not unpin, you're making a promise that the dref mute doesn't abuse the power it gets from getting mute self. In fact, we have a similar problem with drop, right? So recall that the guarantee we give when we put something in a pin is that if I've ever given anyone a pin Around a given type, I can never move it again.
00:59:43.957 - 01:00:28.715, Speaker A: I am not allowed to move it again at no point in the future if I've ever given out a pin. I can't basically, I can't undo a pin promise unless the type is unpin. But when I drop a type, drop is given immutable reference to the type, even if I've previously only had pins, right? When the pin is dropped, then the pin is going to call drop on the inner type and that drop is given immutable reference to self. So it can move out of a thing that had a pin around it. Not okay. And so this is why you'll see in the documentation for pin up here. Yes, let's see, they have this like big example about self referential structs.
01:00:28.715 - 01:01:53.835, Speaker A: So here they talk about this thing called the drop guarantee. And so concretely, for pinned data, you have to maintain the invariant that its memory will not get invalidated or repurposed from the moment it gets pinned until when drop is called. And specifically, there's also requirements on the drop implementation, right? If you, if your type use is pinning, you have to be careful when implementing drop because the drop function takes mu itself. But this is called even if your type was previously pinned, right? So this is the issue we just raised. And exactly like this, it's as if the compiler called get unchecked mute for you, which is unsafe. So if you've ever given out pins to your type, right? If you basically think of this as if your type ever implements something where it takes a pin self, then that means that your drop implementation you must treat as if you're implicitly taking pin mute self. And so they give this example of how you could do this safely, which is just in drop pin yourself and only then do your write your drop implementation.
01:01:53.835 - 01:02:56.947, Speaker A: Yeah, does that make sense? Because otherwise you could do all sorts of bad things in here, which is not okay. I don't think ready T actually needs unpin for T. Why don't think that's true. Why do we need a weight? Can't compiler automatically do a weight when function called is async? Well, okay, so if. If you only ever wrote code like this, right? If you didn't write the await keyword, then it would mean that I would have no way to do something like. Well, this is a bad example, but sometimes you want to wait on multiple futures, so this is often referred to as a select. Like I have two futures and I want to wait for either of them to complete.
01:02:56.947 - 01:04:15.005, Speaker A: I don't want to wait on them in sequence, I want to wait on them in parallel. And if the compiler automatically awaited for any future it saw, then you wouldn't be able to do that. What is the context behind this? What is pin and why do you need it? Right, so this is what we've sort of been discussing in the past, but I think it's useful to summarize it at this point. So why do we need pin? We need pin because some types are not okay with being moved, right? At some point in their execution, they're going to take a reference to something inside of themselves, and if the type was moved, that reference would become invalid, which would not be okay. It would cause undefined behavior. And so PIN is a way to fix this, which is if you ever give someone a PIN of a type, then you are making the promise that it will not move again and they can rely on that promise, right? So for example, foo future relies on the promise that it will not move again to create a self reference. If it didn't have this promise, it couldn't safely do this because if it were moved, this pointer would become invalid.
01:04:15.005 - 01:04:51.475, Speaker A: How do you deal with panicking then? I thought that it was calling drop on remaining memory. So panicking will also drop types. But the requirement is still the same, right? The requirement is still that it's going to call the drop method on your type. And whenever the drop method is called on your type, then you need to make sure that it doesn't invalidate any PIN requirements you made in the past. So let's. Maybe this will help. Let's go farther down here.
01:04:51.475 - 01:06:19.425, Speaker A: So let's say I have a struct foo and I implement drop for foo here. Do I need to care about pinning? No, because at no point have I done anything that deals with pinning. Right? What about now? If I have this, do I need to worry about pinning and drop? No, because foo is unpin, so it's always safe to go from a pin of foo to a mutable reference to foo. And so drop still doesn't have to take any special considerations. What if foo internally contains the foo future? So now foo is not on pin. I have at least one method. Well, actually, how about now? Do I have to do make any specific special considerations and drop? No, because at no point has there been created a pin of foo, or if there has, I haven't taken advantage of it.
01:06:19.425 - 01:07:10.375, Speaker A: So that promise may or may not have been made to me, but I haven't used that promise in a sense, and so I know that I can't be violating any invariants that I have made around foofuture because I haven't used it. It's only if you have a type that is not on pin and that type is ever placed in a pin that you use. So basically, if you ever take advantage of that promise, right? It's only if you rely on that promise that you now have to be really careful in drop. And so the recommendation that they make in the docs is basically that you do this. You write this inner drop function which takes a pin to self and then you give it pin of self. So you basically pin yourself before you call drop on yourself. You have a specialized version of drop.
01:07:10.375 - 01:07:48.727, Speaker A: So really the solution to this would be for drop to always take pin self. But of course they can't do that because the drop, that wouldn't be a backwards compatible change, right? The drop trait has already been stabilized for a long time. You can do impul t unpin for ready. Let's see. For ready. Yeah. So here I could impl t unpin for ready.
01:07:48.727 - 01:08:30.717, Speaker A: Implementing the unpin trait is totally fine, actually. You're right. You're right. So the reason this is, okay, let's kind of want to keep all the other stuff, but let's try to actually compile some code just to see why this matters. This is actually an important point. So let's. Let's deal with it.
01:08:30.717 - 01:09:45.535, Speaker A: Use standard future future task poll context PIN p PIN See that we can actually compile this code. This technically takes a mute context. This. All right? So this code compiles, right? There's no unsafe in it. And so you might wonder, well, why is this okay, right? Why is this okay? Well, remember that the PIN promise only matters if you make it. So here we are moving T, right? We have a pin to self and we're moving T. Why is that okay? Well, it's okay because we've never given out a pin T, right? This T that we contain, we've never given out a PIN to.
01:09:45.535 - 01:10:12.835, Speaker A: So we've never made the promise that we'll never move it. And so therefore it's fine for us to move it here. Yeah. Now this might make you feel a little bit worried. Why is this okay, right? Why can we. Why is it not unsafe to implement the unpin trait? And it's because this implementation in and of itself is not a problem. It is only a problem if you ever write unsafe code elsewhere.
01:10:12.835 - 01:11:40.825, Speaker A: So specifically, this implementation of unpin is totally fine, right? It's more if we now tried to give out immutable reference to T, Right. If I here tried to do something like pin new, mute self dot, I guess self dot. Imagine that I wanted to write this, right? This won't work. Why won't that work? Well, okay, let's say that T is future, right? Right. I just want to show you that this doesn't compile for the right reasons. So you'll see that here it's saying that I can't call PIN new because unpin is not implemented for T. Right? So the only way that I can pull this value is I need to have a PIN to it, and so I would have to call PIN unchecked.
01:11:40.825 - 01:12:36.495, Speaker A: And this is not okay, Right? So this unsafe is not okay because T isn't unpin. So even though we have this impl, this impl is only problematic if we have unsafe code elsewhere. And so that's why. That's why we don't need the unpin bound here is because we never give out a PIN to T, and so therefore moving T is fine. Yeah. All right, so we've talked a lot about the sort of theoretical underpinnings of PIN and unpin, so let's look at some interesting cases from the standard library. I won't actually.
01:12:36.495 - 01:13:55.531, Speaker A: We can talk about structural fields. So the documentation spends a lot of time on structural pinning. And the basic idea here is imagine that you have a wrapper type. So I want to write a struct my future, and it's just going to hold an F and I'm going to impulse future for my future, where F implements future. Just write out the signature here. So what do I write here? So notice that my future here is entirely unnecessary. All it's doing is forwarding the future implementation to the underlying future.
01:13:55.531 - 01:14:27.101, Speaker A: That's all it does. But in this case here we have an example of structural pinning. And so basically what structural pinning means is that if you move the outer type, the field also moves. If you move my future, then F will also move. So structural pinning means. So in this case we have a pin to self and we want to call self F dot poll. Right? This is what we want to write.
01:14:27.101 - 01:14:58.715, Speaker A: What will the compiler say? It will say. It will say there's no method named poll. So this is a very unhelpful compiler error. Basically it's saying, I can't find this method poll you're talking about. And the reason for that is the poll method is defined on PIN of a type, not on the type itself. Okay, so PIN new. We always try PIN new first just to see whether it works.
01:14:58.715 - 01:15:49.493, Speaker A: Okay, so now it found the poll method, but it's saying that the traitbound F implements unpin is not satisfied, right? So remember PIN new, in order for it to be safe, it has to require that the type that's pointed to is unpin. Okay, so why doesn't this work? Well, we could of course say we only support forwarding to futures that are unpinned. Okay, so that compiles. Why does that compile? Well, if F is unpin, then my future is unpin. So self is draft mute through the pin. The PIN DREF mute sort of enables when the target type is on pin. And so now we can get to the F and we can call pin new because the target type is on pin because the target type is F.
01:15:49.493 - 01:16:44.465, Speaker A: And so therefore this code now works. But this is a little sad. This means that you couldn't do something like have a main. Let's do an async fn. I couldn't do this here. I'm trying to set F to be some async block where presumably I'm going to write a bunch of code in here, right? And then I'm going to await that future. This won't work.
01:16:44.465 - 01:17:43.255, Speaker A: Why is that? Well, we want there to be an implementation of future for my future, right? Because otherwise we can't await it. We can only await things for futures and for that to be the case, for this, for future to be implemented, for my future, then we've already said that we require that the F is unpin, right? And so we need the so gen future. Here is the future type that the compiler generates for async blocks. And so, okay, we need gen future of T where T is like the actual contents of the async block. We need that to implement on pin. But that requires that this. So see how it says static generator at source librs line 20, right? So what's at line 20? At line 20 is this async block.
01:17:43.255 - 01:18:41.023, Speaker A: So it's saying that the bound gen future implements unpin, right? So this async block implements unpin is not satisfied. And so now we're saying that this async block isn't unpin, because no async FNS or blocks are, and therefore my future doesn't implement future. And this is a little sad, right? We would really like to not have this bound. We would like my future to forward any future, because why not? So how can we write this code so that we remove this bound? Well, we're going to have to use new unchecked, right? Because our alternatives are either use new and require unpin or use new unchecked. So how do we know that it's safe to get access to a field? Well, on pin, there's map unchecked mute. There's also get unchecked mute. But let's use map unchecked mute.
01:18:41.023 - 01:19:24.995, Speaker A: First let's look at what it actually does. So MapUncheckedMute goes from a self. So that is a pin with a mutable reference to some type T. And it takes a function that goes from mutable T to mutable u and then it returns a pin of immutable reference to you. Right? So this is going from you have a pin of some type and you have a thing that converts from that type to some inner type, and then it gives you a pin of the end result. And so why is this? So in our case, what we want here is this is basically a reference to self. So let's call it this.
01:19:24.995 - 01:19:58.045, Speaker A: And we're going to give a mute to this F. Okay, let's first see whether that compiles. Okay, that compiles. We don't need this anymore. Let's make this pub so it doesn't warn us about it. Okay, so that compiles, but is it safe? Right here we have an unsafe block. What does that mean? Well, MapUncheckedMuse says the following.
01:19:58.045 - 01:20:51.195, Speaker A: This function is unsafe. You must guarantee that the data you return will not move so long as the argument value does not move, and also that you do not move out of the argument you received to the interior function. Okay, so there are two things that can go wrong here. The primary one is that here self is a pinned mute self. Map unchecked mute gets a mutable reference to self, right? So in here there's nothing stopping us from doing moving self, which might not be okay, right? It might not be okay to move self because F might be unpinned. So this is not okay. So this is one of the reasons it's unsafe.
01:20:51.195 - 01:21:49.905, Speaker A: The other is if, if map unchecked, remove returned a reference to something that might not move, that might move anyway. But let's ignore that for a second. Like if it, if it like dereference the raw pointer, the point is some other thread or something silly, right? Like, who knows what this does? It could take a raw pointer to somewhere on the heap that it just like generated randomly, and that would obviously be unsafe. But ultimately we need to figure out why this line is okay or whether it's okay. And so here what we're saying is that first of all, our Closure here does not move things that aren't unpin, right? It doesn't move anything, in fact. And second of all, the guarantee we need to make is that as long as this doesn't move, this won't move. And that is the case, right? We don't move F, we never move F.
01:21:49.905 - 01:22:20.717, Speaker A: And as long as my future doesn't move, right, which is this, then F will not move. Yeah. And so this is because here we can rely on this thing called structural, what do they call it? Structural borrowing. Structural. Structural pinning. Basically, they're asking whether pinning is structural for a field, and in this case F. F is a structural field of my future, because if my future moves, then F moves.
01:22:20.717 - 01:22:54.485, Speaker A: If my future does not move, then F does not move. And so it's okay for us to make this promise because we have been promised that we won't move, therefore we know that F won't move. And so therefore this unsafe is okay. Yeah, it's a little bit complex. There are a bunch of different ways you could write this code. This is the one that uses the least unsafe, right? Map. If you can use map unchecked mute, you should, because there's less opportunity for accidentally abusing it.
01:22:54.485 - 01:24:17.939, Speaker A: One alternative here, right, would be unsafe get unchecked mute, right? And then we do something like this.f.poll. but now we'd have to also do new unchecked to this with unsafe. And also now someone imagine this was in the middle of like a long complicated function. Nothing is stopping someone doing like, oh, I'm just going to set this to none or whatever. And the compiler wouldn't warn them about this line because this line promised that the code beneath didn't do anything wrong. And so this is why, where possible, you want to not generate these, right? Or you could do something like F is and then this, right? That way that this wouldn't accidentally be used further down. All right, so if we go back to this now, one thing we have to be really careful about is it's not okay for us to implement unpin for my future F here now, right? This is not okay.
01:24:17.939 - 01:26:09.005, Speaker A: Why is that not okay? Because now there is nothing stopping me from writing this function. Why is it annoying to write this code? Ah, async fn buzz. I just need something to stick in here, right? I can now write this code. There's no unsafe in this code, right? I create an F of type my future, I pin it. So I'm guaranteeing that it should not move again. And I'm saying that F should not Move again, right? So boz is an async fn, so it's not unpin. So I'm pinning it and that's totally safe.
01:26:09.005 - 01:26:38.055, Speaker A: And then I'm swapping out. I'm just straight up swapping out the my future. In fact, I could do.f swap it out with a different buzz. And all of this is safe, even though clearly I'm breaking the PIN guarantee, right? I made a promise with this PIN PIN you that I would never move F again. And yet here I moved F again in safe code. And there's a subtle interaction here.
01:26:38.055 - 01:27:14.031, Speaker A: The reason this is a problem is because this implementation of unpin is saying that you can move my future however you want, but this unsafe is relying on the fact that if you have a pinned my future, then it will not move. This unpin is opting out of that guarantee for my future. It is saying that you can freely move my future no matter what you like. You can just move it freely. And so this PIN means nothing. Therefore this unsafe which relies on this promise also means nothing. And so now we've broken this.
01:27:14.031 - 01:28:11.101, Speaker A: This is why this even though this implementation is not unsafe, this adding this safe implementation breaks the requirements of this unsafe. Did that make sense? Someone asked why is it safe to implement pin? And it's because this on its own is never unsafe. The only thing it can do is it can make things that are already unsafe be unsound, right? Be incorrect. So the when you write this unsafe, what you're really saying is I have thoroughly checked the code and I know that this is safe. I know that this PIN guarantee means that like, if this will never move, then this will never move. Adding this changes the guarantees of PIN on my future, making this unsafe no longer correct. And.
01:28:11.101 - 01:28:45.455, Speaker A: But. But this impulse itself isn't unsafe. Because if we didn't have any unsafe code in here. So for example, if this was like plus unpin and let f so this is what we had before, right? Of PIN new self F poll, right? This is totally fine. Now this unpin isn't bad. So it's not really the unpin that's the problem. So this is why it's not unsafe.
01:28:45.455 - 01:29:47.177, Speaker A: It's only that by adding it, you are violating an invariant that other unsafe code in your code relied on. Why doesn't the compiler always do it? The compiler can't add this input for you always because it doesn't know that you have this unsafe then relies on this not being unpinned. So always adding this would be wrong. Because if you have Unsafe code elsewhere, it might rely on you not having this impul. So therefore the compiler never adds it unless your type is unpin. If it's not generic, or if all of the fields of it are types that are unpin, then this unpin implementation will exist from the compiler. All right, so that should give us a decent view into unpin and why it's necessary, and also how to use this with unsafe.
01:29:47.177 - 01:30:54.505, Speaker A: Right? So now, if we remove this now, you'll see that this code no longer compiles, right? I'm not allowed to create this pin new, right? The compiler won't let me create this PIN new because my future is not unpin. One thing that took me a while to wrap my head around the generic way to make a value unpin is to call box pin on it. Yes. So that was what I was about to get to next. So one thing you will see, and this might strike you as surprising, which is why we're going to talk about it, is if you look at box, so box allocates something on the heap, you will see down here, this hidden in the darkness. So take. Take a little bit of time to read this and see if it makes sense to you.
01:30:54.505 - 01:32:19.995, Speaker A: Crucially, why is this? Okay, notice that here we're saying that for any type, no matter whether it's pin, whether it's unpin or not unpin, if you put it in a box, it is now unpin, or rather the box of the type is unpin. All right, so let's dig into it. Why is this okay? Well, this is okay because if you have a type that is on the heap, right? So for example, if I have here box of F, then if you move my future, then F is still not moved, right? So now you can move my future all you want. I can still always keep pinning it. If you pin my future and then unpin it and then pin it again, not a problem. All of that is fine because F still hasn't moved. So it's not.
01:32:19.995 - 01:33:04.865, Speaker A: Because it's not self referential, right? What. What unpin for box is saying is regardless of whether T is unpin or not unpin, it is unpin when it's inside of a box. And this is because now the structural guarantee is very different. So can we now do this right? So. So by making this box, given the implementation we just saw, this means that my future is now unpin, regardless of what F is, right? Because it was a blanket implementation. So can we now do this right now? That self self is now or pin of self is now going to implement draft mute. So we can get at this.
01:33:04.865 - 01:33:54.197, Speaker A: Does that now work? We get rid of this broken thing down here. This is now compile. Oh, I need to. Oh, that's fine. Let's wait a second with that too. So I can now correctly get to F and in fact I can even create a PIN to it. But really what I want here is this, right? I want a mutable reference to the target of the box to the F.
01:33:54.197 - 01:35:28.835, Speaker A: If I did this, I would just get a mutable reference to the box, which doesn't really help me. I want immutable reference to the target of the box and then I would pin that because I want a ref mute F, right? That's ultimately what I want to call Polon. So does this work? No, because unpin is not implemented for F. So notice that boxing in F just means that my future is now unpin. It doesn't really solve this issue. We still have this requirement that we can only guarantee that F won't move if we want if the box. How do I explain this? Okay, so why doesn't this work? Well, I can write a function that does this pin let X is box new async, right? So this is not unpin mute X new star X with async I need.
01:35:28.835 - 01:36:39.413, Speaker A: I need my async baz back, right? So a box of F makes the box itself is unpin. But we still that that's not sufficient for pin you to be safe on it because otherwise I could write code like this, right? Where I still get to move the thing that's behind the box. So boxing something in and of itself doesn't really help with pin it. All this is saying is that if you have a type that contains a box T, then that type is now fine to move. Even if you made guarantees about pin. If you've made guarantees about PIN of T, on the other hand, then box won't help you, right? Specifically in here we want a. What this code really wants to produce is it wants to produce a pin mute F, right? But in order to give out this, we need to give guarantees about whether F will move.
01:36:39.413 - 01:37:20.817, Speaker A: And so it doesn't really matter whether my future moves, right? All this box is saying is that if you move my future, that does not necessarily move F. But that's not saying that F won't move, which is what we require here. We require being able to say that F won't move. And so in fact, if you want to use box this way, then what you can do is store here is A pin of box of F. Now what we're saying is that if my future moves, then F won't move. And a pin of box of F. Let's find the.
01:37:20.817 - 01:37:54.307, Speaker A: Where is it? Did I close it? That's annoying. Pin. Yeah. So a pin of box of F. You won't be able to get a mutable reference to F through this, so you won't be able to move F. So if we know that my future won't move, then we know that people want to just like, switch out the F. That's fine.
01:37:54.307 - 01:38:20.645, Speaker A: But if we now want to get a mutable reference to the F, Let me see. So let's. First, let's see what. This compiles box does not implement structural pinning. Yes, that is one way to say it. That's right. Yes.
01:38:20.645 - 01:39:11.785, Speaker A: We still can't call PIN new, right? And the reason for this is if we. If we could just get immutable reference to F this way, then anyone else can as well, and they might just like, replace it entirely. And so we're going to have to use new unsafe. New unchecked. All right. What can't borrow is mutable. So what am I missing here? Just give me a second.
01:39:11.785 - 01:40:08.315, Speaker A: There we go. So we still need this unsafe, right? Even though now this is no longer structurally pinned, right? If you move my future, then box will still now move. Let me just tidy this up a little. All right, so we still need this unsafe map unchecked. Mute, right? And here, what we're guaranteeing, we're still saying that if my future doesn't move, then F won't move. So this is still the same guarantee that we made before. However, now my future is unpin, right? So you can freely pin and unpin my future, and that's fine.
01:40:08.315 - 01:41:52.735, Speaker A: But this guarantee can now be violated pretty easily. Imagine that I wrote some code like this not knowing about the stuff above, right? Unsuspectingly, I didn't really look carefully through the file and I wrote this implementation. Well, this is now a huge problem because now I can do this. Oh, what did I do? My future F of this. And then I pin that. Just give me a second to tidy up this so we can. And pause.
01:41:52.735 - 01:42:45.401, Speaker A: What? What am I missing? Oh, get F. There's a. Get mute on PIN as well. And this. All right, so now I've written completely safe code that moves the F, even though we pinned my future. This is not okay, right? Imagine here that I did like X dot poll and then I did X pol here. Again, not going to.
01:42:45.401 - 01:43:10.525, Speaker A: Yeah, right. This is totally safe code. It calls pulse, it gives out pin. But now this unsafe is being violated. Why is that? Well, this unsafe is saying if you've pinned self, then it's fine to give out a PIN to the F. But that's not true, right? Because my future is unpin. And so now you can write this function totally safely.
01:43:10.525 - 01:43:58.325, Speaker A: And this writing this implementation is going to violate this unsafe because this is giving out a reference to the to the. To the F. Seems like if there was a kind of reference that is like mute, but you can't use memory place on the like on it, then things would be safer. So that is what PIN is, right? If you put something in a pin, you cannot get at the underlying contents mutably unless you promise you won't move them. It's just that it turns out that there are a lot of ways to move things. And just saying like you can't do memory place isn't really sufficient. The standard pindocs has a bunch more examples of how you might accidentally move something.
01:43:58.325 - 01:44:26.735, Speaker A: But just saying no, memory place is not going to solve it. It really is. You cannot give out mutable reference to things unless they're wrapped in a pin. So PIN is exactly that promise. And that has to rely on things like unsafe. Remember, this doesn't have to be mem replace, right? This is the same. Just assignment memory place is just a convenient way to write it.
01:44:26.735 - 01:45:13.847, Speaker A: Okay, so this is a problem. So how do we make it so that people can't accidentally write this code? Well, we can write a pin box F here. So there's a box pin which returns a PIN of box. And now you see, get rid of these because they're not important. And see here, right? So now this function, you can't write safely anymore. Because what we're saying here is we're going to put F in a box and then we're going to pin it. We're going to say that this is going to be used as pinned.
01:45:13.847 - 01:45:43.031, Speaker A: And so you can't just like arbitrarily give out mutable references to it. And so now this get F. If you try to write it, you would have to write unsafe code, which wouldn't be safe, right? So this is now no longer possible. And now it's going to complain about this. Get F, right? So this, this you can't call anymore. So that's great. And in fact, let's just comment out this whole thing.
01:45:43.031 - 01:46:21.819, Speaker A: We don't read it, need it right now. What? You know terminated. It's terminator right there. Oh, it's awkward. And now look at what we can do. So as mute. I forget.
01:46:21.819 - 01:47:25.065, Speaker A: I think it's this. So this compiles and there is now no unsafe code here whatsoever. So how did we do this? Well, the box guarantees that moving my future will not move the F. The PIN guarantees that there is no way to move the F anymore unless it's unpinned, right? Because the PIN PIN wouldn't implement DRF mute to the F, and you can't. So that means you can no longer get a mutable reference to the F unless it's unpin, which means that PIN box is this neat construct that you can use to take things that are not unpin and make them unpin. And the reason is the box makes sure that it will never move, right? The box makes sure that it has a stable location, so to speak. And the PIN makes sure that you will never be able to move F unless it's unpinned.
01:47:25.065 - 01:48:21.185, Speaker A: So in general, PIN box is the way to go from things that are not unpinned to things that are unpinned. Of course, the downside is now there's a heap allocation here which may or may not bother you, but this is such a useful construct that if you look at box, you will see that box has a function called pin. You can give it a T and notice this is any T, it's not bound by unpin at all and it gives you a PIN of box of T. If T does not implement unpin, if it implements unpin, you could move it just fine, right, because the PIN is going to implement DREF mute. But if T does not implement onpin, then X will be pinned in memory and unable to be moved. Right? The box is going to put it on the heap somewhere and the PIN is going to make sure that you can never get immutable reference to it, or you can never get one safely. Of course, unsafely, you can do whatever you want.
01:48:21.185 - 01:49:17.365, Speaker A: Yeah. Okay, so let's look at the implementation of this, because our intuition here is that it's actually a little bit subtle why a pin box is safe to construct for any T. So let's look at what internally, what it does. So there's a function into pin that takes a boxt. In fact, we can look at this here first into pin. So this takes any boxt and gives you a pin box T. And remember, anything that's wrapped in a pin comes with the promise that the target type will never move again, right? So how can this function be safe? Right? This is what we Just discussed, it is safe because the box makes sure that it has a stable address and the PIN makes sure that you can't get a mutable reference to it anymore.
01:49:17.365 - 01:49:57.305, Speaker A: And you will see that indeed internally it uses unsafe. It says new unchecked. It is not possible to move or replace the insides of a PIN box t when T is not unpin. So it's safe to pin it directly without any additional requirements. And this is basically the short version of the long roundabout way we've got at this now. Yeah. Okay, so writing all of this unsafe code should make us all feel a little bit uncomfortable, right? So let's see if there isn't a better way.
01:49:57.305 - 01:51:03.729, Speaker A: Let's sort of save this by putting it in a comment, because that's how we save. So let's go back to what we had where we did. Let F is unsafe self map unchecked Mute this this F Paul cx and this is not neat. Uns Great. And we have this async foo that's going to use my future. So remember, this is how we wrote it without having to use box and it required this one line of unsafe. But ideally, when you write code like this, you don't really want to have unsafe if you can avoid it.
01:51:03.729 - 01:51:56.699, Speaker A: And so there's this really neat library called PIN Project, which basically takes away much of the pain of dealing with these invariants on your own. So let's go to our cargo toml and let's add pin project equals 040 alpha 11. Let's download a bunch of stuff. Great. All right, so what does this let us do? Well, PIN Project, let's look at how you use it first, and then we'll look at how it achieves what it does. So you add an annotation on a struct and you say which fields you want to pin. And then in here you do self project.f.pol
01:51:56.699 - 01:52:40.015, Speaker A: cx so notice that I added some annotations and then I replaced the unsafe code with this project call and it compiles. There's no unsafe code, Right? No unsafe code. And we get the same thing that we got before. Yeah, so that seems really neat. It would be great if we could just always do this. And in fact, PIN Project, you can. I've used this in a lot of situations already, but it's useful to dig into what does it really do under the hood.
01:52:40.015 - 01:53:14.355, Speaker A: And also you'll see something weird here. Like let's say that this had a T and this also holds a T. Notice that we've not Added the PIN annotation to the T places over here. Ft. Let me just build up a little bit of an example here. My future ft. Ah, my future ft.
01:53:14.355 - 01:54:11.685, Speaker A: It FN bar. So this is going to create a. Where's my example of this? Down here. X dot get T. T is going to be. I don't know. In fact, T is also going to be something that's on pin.
01:54:11.685 - 01:56:07.275, Speaker A: Sorry, give me a second. I will explain in a second. I just need to write some code to talk about first. In fact, I don't even need this code. 34. Oh, that's a no, fine. Oh, because the ref.
01:56:07.275 - 01:56:25.305, Speaker A: Oh, that's not ideal. I should file that as a bug. All right, fine. Not worth it. Fine. In any case, if we have a field that is not marked as pin, in fact. Fine, fine, fine, fine, fine, fine.
01:56:25.305 - 01:57:01.235, Speaker A: Then let's do this just to demonstrate what happens. I can do this T as bar and then I can do this F. Pol. I meant buzz. Oh, man. Fine. I don't have a type to use here option.
01:57:01.235 - 01:57:25.605, Speaker A: There's none. You can mostly ignore all the various back and forth. I'll explain at the end. There we go again. Now it compose. Great. So notice here that I have a T that is also totally unbound, right? It may be unpin, it might not be unpin.
01:57:25.605 - 01:57:50.997, Speaker A: And inside of poll, I'm allowed to change T even though I have a PIN mute self. And this F. So remember this. In order to call this, I need one of these. In order to call this, I need one of these. Yeah, and that works, right? This compile just fine. If I try to do this.
01:57:50.997 - 01:58:50.107, Speaker A: If we made this also an option, which is a little bit annoying, but give me a sum to this. This requires a mute F, and this will not compile, right? It's saying you have a pinned reference to F, so you can't do that. So PIN Project has actually generated a thing where I can safely touch. I can safely mutate fields that are never pinned, right? Because remember, the PIN guarantee only matters. The PIN promise only matters if you ever give out a PIN to that type. Here, we never give out a PIN to that type to T. Right? And so it's totally fine for us to modify it directly.
01:58:50.107 - 01:59:50.405, Speaker A: However, we do give out a PIN to F, and so mutating F is not okay, but getting a PIN to F is totally safe, right? Because we've never given out a mutable reference to it. And so therefore this code is fine. And so PIN Project really gives us exactly what we want. If we go Back to the READY example from earlier, right? Remember how we had this whole business, right? If we remove this unpin, then now this won't work, right? Because T isn't ready, isn't necessarily unpinned, so PIN won't be deref. So here, one thing we could do, we can PIN project this. We never need to pin value, right? We never need to pin the T. And so now PIN Project adds this project method here.
01:59:50.405 - 02:00:45.955, Speaker A: And now this will just work. So PIN Project is actually also going to automatically add an implementation of UNPIN for ready that is going to be guaranteed safe. So if we now do CARGO check, I guess this still doesn't work, right? Because it's not ok, but this compiles and notice there was now no need for any unsafe for ready either, and we didn't need to write the manual implementation of unpin, even though READY will now in fact be unpin. So PIN Project is really handy for this. But how does it achieve its magic? Right? That's the real question here. And so in order to explain that, let me first undo this like option F business because it's a little annoying. And then let's do Cargo Expand.
02:00:45.955 - 02:01:05.905, Speaker A: So CargoExpand is this really handy tool for cargo. Just a cargo install, Cargo Expand that lets you show the expansion of all macros. So let's scroll up here a little bit and see what we got generated. Okay, so we have my future. So we recognize. Oh man. So we recognize my future.
02:01:05.905 - 02:01:54.385, Speaker A: And you'll see that it generates this UNPIN scope. So this is just so that it doesn't pollute the type space with lots of names and there's some really like subtle stuff going on here. But basically what it's doing is it's generating a type called MyFutureProjection. And for any fields that are PIN, it's going to hold a PIN to a mutable reference to the field. And for anything that's not marked as pin, it's going to hold a normal mutable reference to the field. So notice here F was marked as pin, and so therefore the mutable reference to it is a PIN and T was not marked as pin, therefore we get a normal mutable reference to it. And then this project method is unsafe.
02:01:54.385 - 02:02:48.425, Speaker A: You notice that it doesn't get unchecked mute to self, which gives it the underlying future and references to all the fields. And then it pins the fields that are marked as PIN and does not pin the fields that are not marked as pinned. And based on what we know from before, why is this okay, why is this unsafe block? Okay, well, as long as we never move self, which this does not do, and we never give out mutable references to fields in self that are pinned, right? So F here is something that we pin. There is no way through what PIN Project gives you to get a mutable reference to the F safely. And so therefore we're not invalidating the guarantees required by new unchecked. And so therefore this code is safe. Giving out immutable reference T, totally fine.
02:02:48.425 - 02:03:50.385, Speaker A: Because we never give a PIN to it, or PIN Project never gives us a PIN to it. If we wanted to create a PIN to it, it would either need to be unpin or we would have to write unsafe code. And there's also. So this little bit nasty thing here, this is basically the impulse of unpin from my future, right? So it generates an implementation of the unpin trait, and it does some magic so that in our case, we will be unpin as long as. As long as F is unpinned, right? Remember that the reason why it was okay for us to have a blanket implementation. Remember back here we had an impul unsafe T unsafe for ready T, right? Remember, this was totally safe. This should say unpin.
02:03:50.385 - 02:04:49.125, Speaker A: And the reason for that is because we never give out a PIN to the T. And so it doesn't matter whether T is unpin for whether ready is unpin. And that is what it generates here. So it generates this intermediate struct that any fields that we. Any generic fields that we never give out a PIN to, we don't care whether they're unpin for the purposes of whether the wrapping struct is unpin, whereas we do care that myfuture is only unpin if F is on pin. It doesn't matter what T is, and that is what this generation does. So PIN Project will give us safe pinned references to any fields we need to be pinned, safe mutable references to any fields that are not pinned, and a correct implementation of unpinned for our type, even when it has generics.
02:04:49.125 - 02:05:55.285, Speaker A: It also does the same for, like, enums, where you have pinned fields, invariants and stuff. The other thing that's sort of neat that actually PIN gives you is if I have. And this might strike you as weird, remember this F here? So this dot F is a pin mute F. Right? I have a set method that lets me do this buzz. Oh, man, I'm gonna have to make this an option again. Some as unwrap as pint mute. That's funny.
02:05:55.285 - 02:06:48.375, Speaker A: And pin project and 21. All right, so this might strike you as funky, right? So this F is a pin of F and I'm allowed to change it. So remember how we said you should never be allowed to change to move something that is behind a pin unless it's unpin? Well, F here is not unpin. There's no unsafe code here. And yet I'm allowed to change it to none. And the reason is because you are never allowed to move it until you drop it. And setting is totally fine.
02:06:48.375 - 02:07:15.949, Speaker A: I don't give out immutable reference to the F. It's not going to get moved. It is only going to get dropped because I'm going to replace it with something else and I don't get back the old value. And so it's never moved, it's just dropped and then new thing is set in this place. So this actually, this actually works totally safely. Trying to catch up in the middle of the video is hard. Yeah, I believe it.
02:07:15.949 - 02:07:55.331, Speaker A: This is a deep, a deep like nest of things. Are we talking about PIN as in circuit board? No, we are not talking about PIN as in circuit board. We're talking about PIN as in the type used to give guarantees about self referential structs in Rust. So a very different type of pin. Yeah, so PIN Project is really neat for these types of things. It handles basically every use case I've thrown at it. And the author is also very receptive to bug reports and such, although I've found relatively few.
02:07:55.331 - 02:08:24.377, Speaker A: And so this is a very nice way to deal with pins. To deal with pins without having to write unsafe code. And this has nothing to do with futures really. Right. Like you can use PIN Project for anything that requires pin. It's just that currently you don't really require a PIN for many things that are not futures, because most things are unpinned unless they happen to contain async fns, which are futures. Now that said, these are things that might change.
02:08:24.377 - 02:09:30.937, Speaker A: So for example, if Rust gets generators. So generators would be something like, I don't know what the syntax will be, but like numbers. So this is something some other languages have where you could imagine probably something like this. So the idea here is that this would construct an Iterator, right? So every time you call it, it continues from the previous yield point and so it needs to keep any state. So for example, it's the exact same thing, right? I have a buff of like this and I'm gonna like. I don't know. I don't know, man.
02:09:30.937 - 02:10:10.633, Speaker A: Like buff. I'm going to yield like buff this or Something like that. So here, this generator, which is an iterator, is now not unpin because it has self references. And this has nothing to do with futures. But this will still require pinning because it's any self referential struct. And here you can see that this is the same as what we've been talking about before. If you remember, at the very beginning we also talked about this parser type.
02:10:10.633 - 02:10:47.905, Speaker A: Let's see if I still have it here somewhere. No, apparently not. We talked about this parser type that once, where you have a parsed representation of a byte stream. So such a type would also not be unpin. So if you think of a type like let's do docs rs Ooh, that's weird. Owning ref so the owning ref crate basically gives you self referential structs. I don't know if they have a good example.
02:10:47.905 - 02:11:26.145, Speaker A: Yeah, so the idea here is that you can return something that has a reference into itself. The owningref crate lets you do this. And currently they do this with a bunch of hacks through the type system and things like stable address traits and such. It is pretty reasonable to assume that this could be represented through pinning. It currently isn't. But here you sort of want to imagine that this type now requires that it's pinned, otherwise the self references would no longer be valid. Mozilla is a nice explanation for iterates and generators with JavaScript.
02:11:26.145 - 02:12:00.133, Speaker A: Yeah, I mean, generators are just yet another example of where you would need pinning because they so easily get self referential. So currently, this is also worth knowing. Any async block in any async function is marked does not unpin, even if it isn't unpin. Sorry, even if it is unpin. So for example, our little boss down here, this has no self referential fields. There's no internal pointers here, right? It's empty. This.
02:12:00.133 - 02:12:49.265, Speaker A: The return type from this will still be not unpin, even though it doesn't need to. I don't know if this is something that'll change. It'll. It's probably pretty difficult to figure out whether a given generated type should or should not be on pin, and getting it wrong would be disastrous. And so my guess is what we'll see is that these will all just remain not unsafe when they're generated. Okay, so the next and probably last thing I want to do is look at some changes from the old future stuff, which didn't require pinning, to the new future stuff, which does require pinning in the context of a particular library that recently made this Move. So we'll look at basically some of the PRs.
02:12:49.265 - 02:14:12.875, Speaker A: So that's what I want to do next. But before we do that, are there any questions about the stuff we've discussed so far? So now we've gone through basically all of the underlying theory and hopefully it's now clear what pinning is needed for and what unpin is needed for. I'm not going to deal with things that are off topic right now just because this is a sufficiently complex topic that I don't want to veer too far from it. We can do some Q and A at the end, maybe so probably when we demonstrated examples of code that is not okay by using Memory Place, we needed to call poll on the returned value, not on the new value. Yes, you're right, the poll would be on the actually they've both been moved, so they're both invalidated. But yeah, I mean, the problem doesn't arise until you use the PIN again, probably. But nonetheless, like, you shouldn't do it in the first place if SET is okay.
02:14:12.875 - 02:14:54.795, Speaker A: Yes, the reasoning why set on PIN is okay is a little bit subtle, but the basic idea is that SET doesn't allow you to move anything. Right? Nothing moves when you call set. Or rather the thing that was in the PIN gets dropped and the thing that is not in the pin and it gets moved into the PIN is moved into a pin. So it's now pinned. So regardless of whether it was unpinned or not unpin, it is now pinned and it wasn't before because we were given an owned version of it. Right. So that's sort of the informal argument for why SET is okay.
02:14:54.795 - 02:16:15.305, Speaker A: All right, so let's look at some actual changes to use this and you will recognize a lot of the patterns that we've built up to so far in those changes. So the library we're going to look at is a library called Tower. So Tower is basically it's an API for services, like network services, but all sorts of services. The idea is basically any function that goes from a request to a response as a service and then it defines various both traits and helper structs to manage these rate limiting and logging and and all sorts of things. It's not terribly important what it does, but it is a library that had a bunch of code that was written for future 0.1 and that has recently been converted to using standard future. The question was if there's a difference between set and replace where the return value is immediately dropped.
02:16:15.305 - 02:16:58.525, Speaker A: M I think those are equivalent, but I don't want to say for sure. Actually we could look at this. So sorry for the slight here. Set source. Yeah, so set is. This is basically a memory place. It's just setting the target to be equal to value, which implicitly drops the old value, which I think is equivalent to memory place, or rather it's equivalent to memory place, where you immediately drop the return value, I think.
02:16:58.525 - 02:17:50.365, Speaker A: So a warning for those of you in rooms with like where it's all dark now, my GitHub is light, so this will become very bright for you. All right, so as you can see from the closed pull requests, like a bunch of these are update like particular module to standard future. So let's take a look at some of these. Let's start with some of the early ones. Let's start with Tower load. So first of all, this bumps a bunch of the dependencies to use the Futures Core preview and like Tokyo and Tower previews. Notice that it also uses PIN Project because it's handy.
02:17:50.365 - 02:18:23.475, Speaker A: And so here we have a bunch of types and some of them we never give out pins to. Right. So we add pin Project to them just so that we're able to mutate their inner fields, even in a PIN context. Right. So we might, in fact, if we scroll further down, you'll see here that we want to implement this. That's a bad example. Well, actually, I can explain it without that.
02:18:23.475 - 02:19:12.555, Speaker A: There are cases where you have a pin to one of these and you want to mutate either inner or load. And mutating either of them is fine because we never give out a pin to a T or a pin to an M. And so therefore we sort of, basically we want to implement unpin for this type. But if you recall from back when we were. When we wrote the manual impl of unpin for ready, it's so easy to like someone will write an unsafe block somewhere else in the file and that causes everything to be broken because of that impel line. So this is why I prefer even in those cases to add PIN project to it because that will guarantee that no one will break it later. Some of it is just adding these context things that are now required.
02:19:12.555 - 02:19:48.447, Speaker A: You'll notice that service. In fact, this might be worth talking about separately though it's a while ago. So if we look at docstower service, so this is an interesting trade off. The tower service trait is sort of the core of Tower and it has two methods. It has pollready and has call. Now pollready is going to be called in an asynchronous context, right? So it's going to be called from a future, basically. But notice that it takes immutable reference to self.
02:19:48.447 - 02:21:34.895, Speaker A: It does not take a pin to self. And the reason for this is because call, which is used when you want to issue a new request, we really want call to take immutable reference to self, because otherwise you would have to like pin the service every time you wanted to call something on it, which effectively just requires that the service is unpin. And so taking pin here and not taking pin here is pretty weird, right? Because you're going to be basically alternating between calling these two different methods, right? You're generally going to be calling pollready and then you're going to be calling call. And so if we mark this as taking pin self and mark this is taking mute self, then now that is effectively the same as saying that services all have to be unpin because otherwise once you have a pin self, you wouldn't be able to get a mute self unless self so the service was unpin. Similarly, if we made and so this is equivalent to saying that service must be unpin, but just without requiring the user to write like pin you in the first place, we could make both of them take pin mute self, right? That way pollready would just be pin as normal and call would now require you to have a pin. But that makes it a little bit awkward too, because it means that first of all, anyone who wants to use a service needs to pin it before using it. And second of all, anyone who implements the service trait would have to deal with the fact that call can't mutate self like things inside of self.
02:21:34.895 - 02:22:07.289, Speaker A: So it just makes the API a little bit more awkward. Like implementers would have to use pin project and callers would have to pin things. But this is actually an ongoing debate. This is part of the reason why the tower on standard on standard future is still in alpha. I think there's an open issue tracking this basically where here. So I open this. This is actually partially in preparation for the stream, trying to figure out why is it shaped this way and what are the trade offs.
02:22:07.289 - 02:22:40.465, Speaker A: And so the observations here. So option A is we keep things the way they are. Option B is we add an unpin bound to service, right? Because requiring these to both be mute self, even though this is in an async context, basically implicitly requires that the service is unpin. So we could just make that requirement explicit. We can make pollready take pin mute self and then call take mute self just to make it even More explicit. But then we still. That's effectively still the same as making the service unpin or require that the service.
02:22:40.465 - 02:23:19.385, Speaker A: We could take everything, make everything a pin, but now the APIs are less ergonomic, so there are trade offs like this that affect real code bases. And if we look back at tower load, you'll see that, at least for the time being, they both take mute self. Let's see if there's anything else. You'll see here. Here, this is similar to my future, where we have a thing that internally contains the future and then it also has some other things. So in this case we use PIN Project on it. We pin the future because we know that we're going to have to.
02:23:19.385 - 02:24:19.135, Speaker A: We're going to need a PIN of F in order to call Polon on the future. But we want to have mutable references to both handle and instrument. Because the code, if you see here the implementation of future for it, it is going to modify handle and use immutable reference to instruments. We want to have mutable reference to both of them, but we also want a PIN to the future, which PIN Project all gives us. And you see this pattern just repeat over and over and over again, right? PIN project, only some of the fields are PIN and those are the ones that we're going to need pins to. And for the tests, what this means is that for the tests we can now use async blocks, right? Because they generate things that are not on pin. But because all of the methods now take pin self, it's all fine.
02:24:19.135 - 02:25:20.545, Speaker A: You can see also in this. So here we had a trait that. So this trait discover. So the idea with discover is that it's a trait that lets you discover new services. And it has a poll method, sort of like future Poll, except and sort of like stream, right? So stream is another example of a trait where core, so stream, this trait has pull next, and it also takes a pin mute self. Because we want to be able to support implementations of stream that are not unpin, because they might internally contain like an async block or an async function, right? You can imagine a stream for a stream wrapper that takes a function that produces futures and just keeps calling it and keeps producing the thing that it gives. We're going to have to pin the resulting futures.
02:25:20.545 - 02:25:58.603, Speaker A: And so stream poll next takes pin. In general, basically any poll method, any method you see that starts with poll is going to take PIN of mute self. And so here we have this trait that used to take a mute self in the old future 0.1 world. And in the new world, it now takes a pinself in this context and that also caused all implementers of that trait. So, for example, here we have service list. They now all need to take pinself and you need to use PIN Project in this case to access the thing that we don't even pin.
02:25:58.603 - 02:26:36.535, Speaker A: So the field isn't marked as pin, so that gives us mutable references to it because we never pin it. So we never give that promise. And here is an implementation of Discover for Stream. So here we're going to have to pin the inner stream. So therefore we use PIN Project with pin and that lets us project the inner, which gives us a PIN of the inner stream, which we can then pull. So in general for almost all, feel free to look through these PRs, they're pretty straightforward and see if there's anything you spot that's weird. In general, I think what really helps is the PIN projector is great.
02:26:36.535 - 02:28:02.495, Speaker A: I do think it's important to understand what it's doing under the hood and why what it's doing is safe, which hopefully the explanation today has done. Remember how back when we started talking about pin, how here, so we talked about this drop guarantee and the drop implementation. So you might wonder, well, what happens if you use PIN Project on a type that implements drop, Right? Remember how drop you have this additional requirement that you don't move even though you're given mute self and drop? And the way PIN Project handles this is if you try to use PIN Project on a type that implements drop, then it won't compile. So here, let's get rid of this generator which doesn't work. This still compiles. Great. So imagine, Let me now do impl FT drop for my future ft, right? So here, imagine that I did something like a mem replace mute F as mute unwrap.
02:28:02.495 - 02:29:35.195, Speaker A: Actually just f dot take what am I doing unwrap. And then we did like, yeah, I mean, who knows what we did there, right? But here I'm gonna move F inside of here and this is obviously not okay, right? Because we've given out a PIN to F before and so we're not allowed to move it now. Well, if I tried to do this, this code will no longer compile. This should say self F. So see here that the PIN project attribute is saying conflicting implementations trait my future must not impl drop. Right? We're not allowed to do this because it knows that if you tried to do this, you might violate the guarantees and so PIN Project will not Even let you do this. And so there's this PIN drop thing where if you do this, if you really want to implement drop for your type, then you do this business is like a whole invocation you do and my future ft.
02:29:35.195 - 02:30:37.295, Speaker A: And you'll see here that basically what they've done is they've added their own trait PIN drop. And pindrop has a method drop that takes self by pin to mute of self, just like the documentation for PIN recommended, right? And now of course this won't let us mutably get access to F, because the only way we can get F is through a pin. So even if I did like self dot project here, all I would get would be I would get a PIN to F. I would get a. I would get a PIN of F, which doesn't let me take, right? I get a PIN option F which I can't take because F isn't unpin. So project is saving me here. And if we look at the expanded code, let me just get rid of ready because it adds a bunch of noise.
02:30:37.295 - 02:31:44.455, Speaker A: So where do we have it up here? So here's my future. And you see there's an impulse of drop for my future which pins self and then calls the pinned drop drop method on self. So this is if you recall the exact same pattern that they recommended that you implement drop. You immediately pin self and then call a drop that only gets pinned self. So PIN Project is here implementing that pattern for you and it's doing such a way in such a way that you won't accidentally violate it. There's also, they also have this project which is for accessing fields with invariants. And there's also unsafep when you want to generate an unplin implementation that is sort of unsafe according to the rules the PIN Project knows about, but that you for some reason know that it's safe.
02:31:44.455 - 02:32:25.547, Speaker A: So I highly recommend you take a look at PIN Project if you have to do anything that does with pin. There is also I recommend you read through some of the Tower changes because they're almost just mechanical changes to move to pin. Very little of it has to do with like the implementation details of Tower. It's all about just moving things to pin. So that might help just to get a lot of that repetition in. I also recommend that if you, if you find old crates that were written for the old futures like future 0.1, try to port 1 to future 0.3
02:32:25.547 - 02:33:22.105, Speaker A: or to standard future. Some of it will be things that like traits have moved and stuff, but much of it is just going to be dealing with pinning. And now, at least in theory, you're equipped to deal with that and understand what the underlying issues are that you're. You're working with. There is, for example, there's one more thing that's handy to know about for the purposes of pinning, which is the futures utils crate which has a bunch of like the. Basically all the things that used to be in futures, like all the methods on future for example, are moved into this crate and one of the things it provides is this macro called PIN mute. So pin mute is actually very straightforward, but it's just a handy thing to know about which is actually maybe I can demonstrate down here with.
02:33:22.105 - 02:34:16.655, Speaker A: Yeah, basically if you have something like this and you want to pin it, you can do PIN mute X and now you have X which is a future is sorry, is a PIN of immutable reference to my future. It is basically equivalent to doing this, but it's just a tiny bit nicer. It avoids you having to write this code yourself. But that's also one to know about. It's particularly useful in tests, but at least now you know that it exists. And with that I think that's all I wanted to cover with pinning and unpin. Are there any questions.
02:34:16.655 - 02:35:05.955, Speaker A: Let's do questions about pinning and unpinning first or things you would like me to explain. Again, this is like fairly technical content. There's a lot of just subtle interactions that can be hard to follow. And even though like we've been doing this now for like almost three hours, it is hard to put words to exactly how these interactions interactions work. And so explaining some of them again might help. I'll do off topic questions afterwards. I do think that one thing you'll find with PIN and unpin is it helps a lot to just.
02:35:05.955 - 02:35:47.915, Speaker A: To just use them a lot, right? Like try to port something that needs pin. Try to read changes that are related to pin. Try to read like the documentation of standard PIN and see if you follow it. And if you don't then like just keep at it because after a while it, it clicks a little. What, what is needed and why. But it just takes, it takes exposure really. Will this stream be available when it's not live? Yes, I put the recordings of all the streams on YouTube afterwards.
02:35:47.915 - 02:37:17.195, Speaker A: I also, if you want sort of a mental challenge, so to speak, I would say think really carefully about why. Remember when we talked about box pin, like why is it okay for box T to implement unpin unconditionally? And why is pin box of T always Fine. To use like, why does that give you pins of T no matter whether T is PIN or unpin? All right, I think if there are no more questions about pin, let's like PIN that for later and do like general Q and A. I'll put so in the. When I post the video, I'll put time codes to when we covered the different parts of PIN and unpin, and also a pointer to like basically now and when we do general Q and A. So if you have general Q and A about Rust, the ecosystem, async me, anything, now's the time I'd like to start writing some CLI tools in Rust. Do you have specific crate recommendations for that? Well, it depends what you're trying to write.
02:37:17.195 - 02:37:47.281, Speaker A: I think Structop is great. Clap is also really good, but I don't have any recommendations sort of beyond that. It really depends on what you want your tools to do. Let's see those. One further up here too. This is neovim. It's not Emacs and it's not.
02:37:47.281 - 02:38:39.255, Speaker A: I mean it is vim, but it's not vim, it's neovim. And I have. Someone asked me about my desktop environment earlier. I have a separate video where I go through like what my desktop environment is like and how it's configured. And all my configs are online literature about database internal implementations. I mean, the SQLite documentation is actually really good, explaining how the internals of a database work. Sort of a traditional database.
02:38:39.255 - 02:39:16.015, Speaker A: For the internals of my research database, I would read the paper. It reminds you of Scala. I mean, so keep in mind that the code that we wrote today, you very rarely have to write yourself. So my guess is you won't ever have to write PIN unless you're implementing your own futures. And most of the time these days you will just write async functions and async blocks which deal with all the PIN stuff for you. So you won't have to think about this. That would be my guess.
02:39:16.015 - 02:39:45.315, Speaker A: It should only matter if you have to implement your own futures. How do you get error messages in vim? Is that ale? Yes, that is ale. ALE is super handy for this. It's ALE plus rls. Although I actually mostly find that I don't. I don't want warnings while typing. I would rather switch to a separate terminal and get the errors and warnings there.
02:39:45.315 - 02:40:26.301, Speaker A: Oh, I'm glad you think so. I mean, the topic we covered today is really challenging, like arguably more so than the stream on how futures work, because this is like very Technical and nitty gritty and subtle and like theoretical detail. So if you followed along, I'm very happy. It's hard to talk through it because so much of it is just. I don't want to say ingrained, but I've just. I've done so many of these changes to PIN now that it's. It's almost like in the fingers and it's hard to put words to why things work the way they do.
02:40:26.301 - 02:41:21.025, Speaker A: So hopefully this made sense in the end. Rust completions I'm using RLS for that and language client neovim yeah. Do you recommend any specific repo to get exposed to a basic usage of PIN besides Tower? Yeah. One thing you can look at is there are a bunch of crates that give sort of handy combinators, like smaller things. So for example, you could look at. What's an example of this? Like a while ago I ported. There's a crate called Stream Cancel that I wrote a while back.
02:41:21.025 - 02:42:01.395, Speaker A: I have a branch now that implements Standard Future for it, but you could try just doing that yourself. In theory, the change there was pretty straightforward of moving to pin. There are other things that are sort of fun to think about. Like you could try porting Buff Stream to be Async, but in general I would just look. You could almost just go to Crates IO and search for like Async and look for smaller crates or crates that haven't been updated in a while. They are likely to be on future 0.1 and they're likely small.
02:42:01.395 - 02:42:54.655, Speaker A: And then you could just try to move those to Standard Future and pin. Do you think the PIN enables GUI engines like Flutter to be implemented in Rust in an easier way? I don't think so. So PIN in and of itself only really provides a way to give you safe self referential structs or types. It doesn't really, unless you need self referential structs for things that won't really help you. Now that said, it enables you to get async functions and async blocks and Await. And so in that sense it's really useful for ergonomics. But that's more about Async Await than it is about pin, even though PIN is what enables it in the first place.
02:42:54.655 - 02:43:33.013, Speaker A: So it could only be that Async Await helps with Flutter, but I don't think PIN in and of itself does. I've enjoyed your videos, but as a novice a lot has gone over my head. Yeah, so these videos are very much targeted at people who are relatively experienced with the language and less so at like beginner content. And part of the reason for this is because I feel like there's a bunch of. There's a bunch of material out there for beginners. Like reading the Rust book for example is really good. I know there are some streamers who also do more like introductory Rust programming content.
02:43:33.013 - 02:44:10.395, Speaker A: I don't have any off the top of my head. I know Ryan Levick did some. I don't know if that's his surname, I don't know if that's how you pronounce it, but he's done a bunch of streams a while ago and I think hopefully he's starting up again. Has done some stream that are a little bit more sort of introductory or beginner friendly. So that might be something to check out. But if you just search for like Rust live coding, I know there are also more people who are excited to do it now. I don't think I will be doing beginner videos anytime soon because I have enough advanced concepts to tackle.
02:44:10.395 - 02:45:05.875, Speaker A: You might find for example the open source contribution stream better or the one where we write a hash map. Those might be easier to follow if you're in the earlier stages. And in theory the next stream will be an open source contribution stream. So that might also help Lock free needed for sing signal slot communication for GUI that doesn't really relate to PIN though. Will you still do go programming? Have you thought on doing videos on it? So I haven't done Go programming in a while now. I used it a lot many years ago, but for the past like many years I've almost exclusively been using Rust except for like coursework. I don't think I'll be doing videos on it.
02:45:05.875 - 02:46:00.803, Speaker A: I also just really enjoy writing Rust code and I think it's fun and interesting. Like the fact that I can talk for three hours about one type in the language is really interesting. Some might argue that I should like go into formal verification and that kind of type stuff, but that's too much for me. How'd you get into Rust? Was it just through your research? I got into Rust because when I started my current research project I had to pick a language for it and I was like, well, I could use Go, but go annoys me a little. And the system language from Mozilla looks kind of cool, so I might as well try. And now five years later I have like 80,000 lines of code written in it, much of it from like very old versions of Rust. So yeah, I mean I just sort of started and this is maybe a luxury of academia is that you can, you can just sort of do that and pick.
02:46:00.803 - 02:46:32.165, Speaker A: Pick a weird language and go for it and it's fine. It's actually worked really well. I had a bunch of co authors on this project too, and I think collectively we've found that Rust, while there's been. There's certainly been a learning learning curve and some things feel more frustrating to do in Rust than other languages. Like, you have to be more meticulous about your programming. But I think it has probably saved us time overall. And refactoring is a lot easier than I think it might be in other languages.
02:46:32.165 - 02:47:15.273, Speaker A: When will you tackle lifetimes, the ultimate advanced Rust topics? So what about lifetimes is you want covered? Because to me, lifetimes aren't that complicated. I should rephrase. There's like higher kind of lifetimes, which we don't have yet, but the. And there's like the four constructs. So there are some lifetime things that are somewhat complicated. But in general, I don't know what I would say about lifetimes for like three hours. We.
02:47:15.273 - 02:47:58.145, Speaker A: We just finished for today, but the topic for today was pin and unpin. All right. I think. Oh, implicit lifetimes makes learning and understanding lifetimes hard at first, maybe so. I mean, implicit lifetimes are. They are a little annoying because it. It hides you from things that will show up in errors later.
02:47:58.145 - 02:48:21.833, Speaker A: So that's possibly true. Oh yeah, the TCP series was pretty fun. It's a good combination of like real world, but also a lot of Rust. Oh, I see. It's true. Lifetimes have become like the. A sort of canonical advanced Rust topic.
02:48:21.833 - 02:49:21.101, Speaker A: Even though, like when you work with the language every day, lifetimes are just not generally my issue. Like they don't come up that often really. I think they come up more in when you start out with rust almost and then after a while it's sort of. You just implicitly program such that they aren't that much of an issue, maybe. Is async STD in combination with spin equivalent to normal std? Um, that's a good question. So the question is basically if you take the like asynchronous constructs we have in Rust and you just spin on them like you just keep calling poll until it returns. Is that the same as just using the standard library? The answer to that in the general case is no.
02:49:21.101 - 02:50:10.715, Speaker A: So for example, imagine that you're trying to read from a TCP stream. If you use async and you just spin on poll, then what's going to happen is you're going to be doing a read to the operating system. So you're going to do a syscall. The response is going to say, not ready, you're going to do another read, it's going to say, not ready, you're going to do another read, it's going to say, not ready. And so you're going to be spinning on the CPU and you're going to be spending a lot of resources crossing the kernel boundary. Whereas if you do a blocking call, like you do a read that's blocking, the kernel is going to basically park your thread until the read is ready to continue or to proceed with some data, which is far more efficient in terms of. Because you're not spinning and you're not doing lots of system calls.
02:50:10.715 - 02:51:03.345, Speaker A: Now, if you use a runtime, then that changes things a little, because the idea of a runtime is basically when you do the read and the operating system says not ready, that future will be parked and the runtime is going to go ahead and run other futures. And where there's no more work to be done, it's going to tell the operating system, here are all the things I'm waiting on. Wake me up when any of them make progress. And then the operating system is going to say, you can now read on stream three. And then it gets woken up, and then it continues on the future that was paused previously. So when you have a runtime, you get sort of the best of both worlds. What's generally your daily issue with Rust programming? I think my daily issues are a little bit different from many people's daily issues.
02:51:03.345 - 02:51:49.155, Speaker A: We have a code base that's large enough now that there's some really subtle, like, business logic interactions that come back to bite me. I think the biggest issue I have that's like a general Rust issue, is when I have. So I'm using Tokyo as my runtime, and I have lots of futures running all over the place. Many of them are manual implementations. And this is an older code base that used to be entirely synchronous that's been converted to be asynchronous. And that comes with some issues where there are some pieces of code that are still blocking. And you have to be really careful with blocking an asynchronous context, because you're going to block the runtime.
02:51:49.155 - 02:52:15.337, Speaker A: And that can lead to weird hangs where suddenly your application is doing nothing. It won't make any progress. It's using no cycles, but it's not finished. And figuring out why futures are hanging is a pain. So I spend too much time on that. When will the next live stream be, if you happen to know, no pressure. That's a good question.
02:52:15.337 - 02:52:51.825, Speaker A: I don't know yet. My parents are going to be in town next week, so probably not next weekend. I would say probably two to three weeks from now. It depends a little bit what it ends up being too. If it ends up being an open source contribution stream, which is what it's looking from the votes, then I'll sort of solicit some opinions on what people want to see me contribute to and then we'll take it from there. But my guess would be two to three weeks. Do you think it's worthwhile to learn Rust if you already know C and Haskell? Yes, absolutely.
02:52:51.825 - 02:53:26.525, Speaker A: I think C is a very handy language for doing like very low level work. It's also a handy language to know, just to know sort of how the computer works in some sense. At this point there are very few things I would use C4 instead of Rust. Like I feel like I would just use Rust instead and Haskell. So Haskell, you can't write performance software in Haskell or. It's very hard. And I kind of like the imperative style.
02:53:26.525 - 02:54:03.769, Speaker A: I don't want everything to be functional. So, I mean, I think there's absolutely space between C and Haskell for another language. I think Rust is closer to replacing C than to replacing Haskell. But then again, I don't really know what software you would write in Haskell in the first place. I've dabbled a little bit in Haskell myself and I don't think I would use it for anything, although I do use it for my Window Manager, but that's separate. Have you ever looked into the embedded working group stuff that's being done in the Rust ecosystem? A little bit. It's really cool.
02:54:03.769 - 02:55:07.465, Speaker A: I like that we're developing these toolkits in Rust for building embedded devices. There's been a lot of work on robotics, for example, which I think is really neat. I think Rust fits well into the space too, because it has the same low level control as C does, where you can actually work on embedded devices and have tight control over memory. But at the same time you get higher level constructs and more safety guarantees which are necessary in embedded contexts. The biggest thing missing there, I think, is better support in libraries for operating without the standard library. Basically a lot of crates rely on stuff from the standard library from std, which makes it hard to write things in embedded because you can't rely on any libraries or crates that require std. And so I think having a push in the ecosystem to move people towards no STD or in particular to move towards only requiring alloc, for example.
02:55:07.465 - 02:55:46.878, Speaker A: So only requiring the allocator and not the Syscall interface for crates that can do that would be really good. I'm the person that's been testing your PR to MySQL async. Oh yeah, that's been really cool. So what they're talking about Here is the MySQL async crate is future 0.1 and I did an effort to port it to standard future and that now basically works. You can write like async and await around MySQL connections, which is really cool. And it's sort of like the MySQL async has sort of been.
02:55:46.878 - 02:56:22.475, Speaker A: The MySQL library has been the primary focus for a long time and the MySQLAsync has sort of been a little bit of a. Not an afterthought, but it hasn't received as much love. I think now with Async Await really coming though, it's going to be the next. It's going to become a lot more important. Are you interested in xmodad, like VM in Rust? Yes. I mean, I already use xmonad. I would be happy to switch one to one that uses Rust because I currently can't really understand all of my own config, which is a little weird.
02:56:22.475 - 02:57:01.955, Speaker A: I don't really like having to recompile my window manager to change the config though, so I don't know exactly how those would interplay. I would really be interested in a general debugging video like with gdb or your perspective on it, and maybe more particularly on a future context. Yeah. So debugging and rust you can do with gdb. There's a lot of stuff out there. There's actually. I did a MIT lecture series a while back with some people from my lab where we covered a lot of just useful topics to know in computer science.
02:57:01.955 - 02:57:35.685, Speaker A: And one of them was a video on debugging. And so you might want to take a look at that. That covers GDB in some detail and applies the same to Rust code. Mostly doing some performance profiling might be fun, although there I would look at the stream where we port Flame Graph to Rust that has some of that in it. But debugging in future context I think is a big topic where I don't have the answers yet either. I think as an ecosystem we haven't figured out exactly how to do it. The tracing Crate is really promising here.
02:57:35.685 - 02:58:51.361, Speaker A: So I've been following that development a little bit, and because it's going to be integrated in or Tokyo is going to be using tracing as well, that's going to make it a lot easier to do tracing in future context and see which futures are stuck where. So tracing is a general logging like Crate, but that has a lot better support for things like keeping track of the context where the log statement happens. And that's going to help a lot. But I don't know exactly how far along that is. There's a work on something called the Tokyo Console, which is basically like a way to get insight into what the runtime is doing, which I think is going to help here too. But I think we haven't really seen how that whole part of the ecosystem is going to shake out yet. Was Rust the first language ecosystem you got this deep into? And you think mastering a language ecosystem offers a similar growth opportunity to learning a new paradigm? So I think so I got pretty involved in the PHP ecosystem back in the day.
02:58:51.361 - 02:59:31.495, Speaker A: I wrote a bunch of like libraries that got used for things. I got involved in the Go ecosystem in that I built a bunch of libraries there too. I just really like building libraries and I also tried to contribute to the language, but both in PHP and in Go, that was pretty hard at the time and I think to some extent still is. Like, Go is not a community language and so it's hard to be involved. Whereas with Rust, I also started writing libraries, but then I also got more involved with the community, in part because community or the language is more community oriented. And so I actually felt like I could contribute to the language as well. And so that was good.
02:59:31.495 - 03:00:28.545, Speaker A: So. So in that sense, yes, it's the first one I got this deep into, but it's not the first time I get into ecosystems. And do I think mastering a language ecosystem offers a similar growth opportunity to learning a new paradigm? I don't know how to parse that sentence, but I'm gonna go with yes. I think getting involved with an ecosystem is good for you as a programmer. That's what I have to say about that. Did you take a look at the Bastion project? I don't think I know anything about Bastion. Where's the lecture series? The lecture series is called Hacker Tools and it's at Hacker Tools GitHub IO oh, sorry, this is light.
03:00:28.545 - 03:01:17.261, Speaker A: Sorry, people at home. And it has videos on a, like short lecture videos and notes about a bunch of topics. And you'll see there's one on where Is it program introspection? So unlike debugging and profiling. So I would watch that video. Are there any problems or tasks for which Tokyo runtime isn't a good fit and why? So the Tokyo runtime is multithreaded and so there are some workloads where you really want single threaded operation. Tokyo has support for it, but it's less of a focus. But I don't really know where that would matter.
03:01:17.261 - 03:02:03.637, Speaker A: I think in embedded environments you might not want to use Tokyo because it relies on a lot of basically OS integration. So in embedded context you might want to write your own executors, for example. Apart from that, I've been pretty happy with Tokyo. I mean it has the advantage that it's being used in production in a lot of places, so it has a lot of maturity. And so for the database, like the research database I'm building, we've found it to be very performant, which is helpful. And I know that there are many people who use it who care a lot about performance. And so it is very focused on being fast for the cases that matter in some sense, like empirically have turned out to matter.
03:02:03.637 - 03:02:48.171, Speaker A: I also know that they're pretty devoted to backwards compatibility, which is useful because it means you don't have to like break your code all the time. Although the move to standard future is pretty breaking. I don't think I missed any. All right, I think with that we're going to call it a day. If you have thoughts about the episode, like feel free to leave comments. I'm going to upload the video shortly after this. Or if you have like follow ups.
03:02:48.171 - 03:03:28.345, Speaker A: I've had a bunch of streams now where people have posted really helpful comments and follow ups on problems we ran into during the stream where they find solutions, references to explanations of particular concepts. Find any of those. Let me know if you have ideas for upcoming streams that you want to see. Just like ping me on Twitter, send me an email and I'll try to add them to the voting site. Or if they're really great, I might just do them. And if you want to hear about upcoming streams, just like join the just follow me on Twitter or I'm also on Mastodon and that's where I announce all upcoming streams. They will all be on both YouTube and Twitch just like this one.
03:03:28.345 - 03:03:49.985, Speaker A: And if you want to support the Amazon Wishlist is there. How does one get begin to get into all of this? You start from the beginning. You read the Rust book. It's very concrete and practical. Thanks everyone. It's been great. And I will see you next time.
03:03:49.985 - 03:03:52.345, Speaker A: So long, farewell, auf Wiedersen, goodbye.
