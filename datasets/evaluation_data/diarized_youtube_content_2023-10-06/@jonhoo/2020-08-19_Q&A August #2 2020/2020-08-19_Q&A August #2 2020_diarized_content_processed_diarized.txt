00:00:01.080 - 00:00:57.585, Speaker A: This is going to be another Q and A stream, although this one is going to be a little bit different from the previous one in that I actually had people. I gave people the ability to submit questions ahead of time rather than just taking them in chat. So hopefully this will actually be useful even for those of you who are not here right now, because hopefully you already submitted a question. The way this is going to work is I've posted a link to chat and on Twitter that is basically a voting site where you can add, suggest new questions or vote on other people's questions. And then I'll just walk through them in sort of ranked order roughly and answer them as we go and we'll see how far we get. And then chat will hopefully be a way to just with sort of additional questions or stuff around the current topic that I'm talking about. This is also a little bit of a weird stream because at least in theory, this is going to be my last stream in this apartment, which is why I started doing these restreams in the first place.
00:00:57.585 - 00:01:29.219, Speaker A: This is a little bit of like a bittersweet feeling. But I'll be moving to la. It's going to be exciting there and hopefully there will be plenty more streams when I get there. My hope is also that once I finish my thesis work, I'll be able to continue doing some of the longer form streams. That sort of is where I started and the things that give me the most as well. There are some other videos of the sort of old stuff I did of like Porting Flame Graph or Java's concurrent hash map to rust that I recommend you give a watch. They're like five to six hour each clip.
00:01:29.219 - 00:02:21.015, Speaker A: Some of them have multiple parts so they're pretty long, but they are very thorough and they're a great way to just learn some more advanced and real uses of rust. And I hope to be doing more of those and of course more uses of crust of rust is the plan as well. So all of that hopefully if everything goes according to plan, will start up. I'm guessing like end of September sometime, but it's a little bit hard to predict and I still won't be finished with my thesis by then. So realistically the longer streams probably won't start until maybe mid November, but hopefully there'll be at least be some more crust of rust before then. All right, so let's get into questions. So the way this is going to work is I have a monitor over here with chat and with questions and I'll read out the question and then try to answer, let's see here.
00:02:21.015 - 00:03:29.125, Speaker A: How do you start contributing to small open source Rust projects? What good practices would you recommend to newcomers in the open source field? So this one's interesting. I was actually interviewed on a podcast called Humans of Open Source and the episode with me actually dropped today. So you can listen to that. What we talked a bit about my thoughts on Open Source in general, how I got interested in the first place, and also just the things I the ways in which I think it's good to try to get into open source. The sort of high level overview is that I think the best way to go about it is first of all to try to work on things that you find interesting and useful, things that matter to you. It's really hard to just sort of dive into some random code base and just start tacking on it because you won't have the right motivation, you won't have an understanding of what it's supposed to do or how it works. And so you have to learn what it's used for while you're also learning the code.
00:03:29.125 - 00:03:58.537, Speaker A: In general, I found it a lot better to start with something that you use, whether it's a library or a program or something like that, something that you at least to some extent understand what is for and what its purpose is. And then ideally you have some issue with it or something you would like to see it be able to do. And then you dive in from there. So you start looking at the code that matters to you. You don't have to understand the whole code base. All you have to understand is the stuff that matters for the things you want to change. So that's a good way to get into it.
00:03:58.537 - 00:04:52.737, Speaker A: And the other thing is, I would actually say try to avoid the very established projects, at least in the very beginning. And this is a little bit controversial, but my thinking here is that some of those code bases are really optimized. They've taken a lot of work from a lot of people and reading them, you might not immediately understand what they do because there's a lot of just finicky, smart, optimized stuff that maybe wasn't is there more for performance optimizations or that sort of stuff, but actually makes the code a little bit harder to understand. Whereas if you read simpler code bases or code bases that aren't as evolved, they might actually be easier to read. Now that said, they might also just be bad code and they might be harder to read for that reason. So it's a tough balance. But in general, I think just look for something that you care about and then work towards that.
00:04:52.737 - 00:05:15.855, Speaker A: And that will just make everything a lot easier. Can you post the link? I'm interested. It's. Ooh. I think their Twitter is Humans of oss. I think that's their username on Twitter and it's whatever the latest tweet is or I also just tweeted it out. Let's see.
00:05:15.855 - 00:05:59.699, Speaker A: All right, next question. Let's see what happens if I click this. It worked. Do you think the recent Mozilla layoffs will affect Rust greatly? If so, in what ways? So there was a post on the Rust blog about this also today, I believe, and like the thinking here. Right. Is that it's really unfortunate for so many people at Mozilla who were integral to getting Rust adoption started. Like, many of them, many of the people who laid off were not necessarily Rust core contributors, although some of them were, but they were a big part of driving Rust to what it is today.
00:05:59.699 - 00:06:40.039, Speaker A: Like, the Servo team is a great example of this, and it's sad to see those people go and to see those projects sort of disappear. I don't think it spells like the end of Rust at all. I think Rust has grown to the point now where there's enough adoption in industry and at large companies that I think the project is going to keep surviving. And we see this because many of the people working on the Rust core team are employed, not necessarily by Mozilla, and they work on Rust. In particular, they might be employed by, like, David Tolnay is a good example. Right. Who works for Facebook, but works a lot on Rust itself and on the ecosystem.
00:06:40.039 - 00:07:33.355, Speaker A: And I think that is the way that Rust survives going forward is not necessarily for Mozilla to employ all the engineers. That's not really a scalable approach either. And I think the blog post also talked about establishing a Rust foundation, which is, at least at the moment, it seems mostly like a legal process. It's not necessarily to, like, solve any, like, programming problems, but it's just because you need, like, you need Rust to have a bank account in order to just. And to own, like, trademarks and stuff. And this is at least reads to me as one way in which Rust wants to try to make sure that it's a separate entity from Mozilla. But yeah, I think that overall, I don't think that the layoffs are going to break Rust in any meaningful way, even though they are very sad.
00:07:33.355 - 00:08:24.247, Speaker A: I was especially sad to see that the MDN team basically went away. Like, that was. That seems really Bad for everyone. Advice on intermediate level programming I finished the Rust book and I want to implement a toy database. How would you generally approach that? I put it as going from language to systems level thinking. Advice on intermediate level programming well, so it's tough because I think for basic programming there's like a narrow waste there of there are sort of basic skills you need to pick up almost no matter what you're going to be programming. Once you get to the more intermediate skills, it branches off a lot more.
00:08:24.247 - 00:09:14.239, Speaker A: Like you can know a lot about GUI programming or Windows programming or game programming and be sort of intermediate or advanced in those levels. And you don't need to learn things like the. I don't know if you're getting deep into game programming, you probably don't need to know too much about how the Rust embedded space works. And so in that sense what intermediate resources to look for really depends on which intermediate areas you're interested in. That's sort of where you start specializing. That said, I think there are some general good advice for what you do if you want to learn intermediate Rust stuff and that is to look for the basically slightly more intermediate resources. So one example of this is my own videos on just like developing real stuff in Rust.
00:09:14.239 - 00:10:19.535, Speaker A: So this would be things like the two porting streams we've done, some of the open source contribution streams we've done just things where you get to work with realer Rust problems and develop sort of real Rust code. There are some resources that are not necessarily just like observing people writing code and reading code and those are sort of open source contributions is one. The other would be to read read and try to understand some of the more advanced guides. So for example, try to read like the Nomicon which is one of the sort of Rust resource for how to write unsafe code. You could try reading learning Rust with entirely too many linked lists which gets into more of like the unsafe nitty gritty data structure management type stuff. There's also Philip, Philip Opperman I think is his name, has a really cool blog series on writing an operating system in Rust and that goes into a lot of the lower level details. You can do things like David Tolnay's Proc Macro workshop.
00:10:19.535 - 00:11:20.637, Speaker A: And so it's really just like seeking out topics you don't know anything about or know little about that you want to learn more about and then just like try to do them or try to contribute to them. You could also look at like the internals rustlang forum or the Users Rustling forum and just look for interesting discussions like RFCs are in progress and just try to understand the process, understand the problem they're discussing and the solutions they're debating. And that's one way to just like pick up things a little bit more organically perhaps. But yeah, so the advice is very broad, but it's really just find things that seem interesting to you and then just read and learn about them rather than go, this is too advanced for me. Um, have you been following the cons generics developments? I'm definitely going to do a video on cost generics at some point. Currently it's not really stable enough to do that, but it's something I want to. Oh yeah, another the pink cap.
00:11:20.637 - 00:12:10.425, Speaker A: The company Pincap has a good Rust tutorial that has you write a database like you asked for. You could also like try to read the Noria code base, although realistically it's probably hard to wrap your head around. In general, if you're going to write something like a database, I would say start with a key value store, not a database. You might be using the terms interchangeably, but a database usually has a lot more sophisticated features, like try to implement a basic memcached or maybe even Redis clone. You can even implement the Redis protocol itself. It's fairly straightforward. All right, what is your opinion on test driven development and testing in general in Rust and other languages? I'm wondering, because in the streams you seem very structured and organized, but only write very few tests.
00:12:10.425 - 00:13:06.401, Speaker A: Okay, so this is a trickier topic because I think tests are really important. But to me the first instinct is not necessarily to start writing tests. I don't think it's a bad idea, it's just not how I think about the problem. Although my thinking is similar, it's just not quite the same, which is I like to start with the use of whatever I'm building, and that sort of might mean writing example code, but I'm not writing a bunch of test suites and then building out the thing by writing the tests. I'm more sort of constructing the use of the library and then filling in what's necessary to make that use work. And then I would add tests. Now, there's an argument that test driven development is better because you set up the expectations rather than adapting it as you go.
00:13:06.401 - 00:14:06.025, Speaker A: I don't know if that's better. I don't have a strong feeling about this, but I do think that one of the parts that's the most worthwhile to me about test driven development is this notion of beginning with writing the outside the external code rather than just diving into the internal straight away. As for why I don't write too many tests on streams, it's partially because it's really hard to write good tests and it doesn't make for very interesting watching most of the time. Usually over the course of a stream, we might not even get to testing that interesting of a behavior. Very often. Like when we're porting the concurrent hash map from Java for example, it's not clear that there's a nice self contained like the simplest test is like do an insert and do a get and check that you get the value. But that required like 12 hours of work for us to be able to satisfy that test.
00:14:06.025 - 00:14:59.439, Speaker A: There are some other streams where tests might be more reasonable. Like if you look at I did just a simple hash map implementation a while back where we did a little bit more testing. But in general there's a lot of work for many of the streams I do in order to even satisfy simple test cases. Your thoughts on Microsoft becoming a big player in the open source software scene? Linux, GitHub, NPM and such. Are you afraid they could hijack open source projects in the future? You know, I don't mind it. I think Microsoft is doing better. I know that Microsoft has this reputation of sort of like embrace and I forget what the.
00:14:59.439 - 00:15:31.895, Speaker A: It's like embrace and extinguish or something. I don't think that's what's happening here. It's. I think many people who like have been around for a while and seen what Microsoft has done in the past might have this sort of eerie feeling of like, but maybe they're doing the same thing here. I don't really have that here. I feel like Microsoft, Microsoft is just getting a lot better at dealing with open source and I applaud their efforts. To be honest, I think I do have some concerns around.
00:15:31.895 - 00:16:57.165, Speaker A: Microsoft is a very big enterprise company and usually when you own a product you sort of cater it to the use cases, you know. And so I'm worried that some of them become very enterprise. The best example of this for me is Azure Pipelines, even though it's not open source, but it is something they provide for free for open source and using it as a pain mostly because it's really geared toward enterprise settings. It has a lot of just like Org chart stuff and pipelines and artifacts that like they don't matter to open source projects. And I'm worried that they might, for example in GitHub, like encourage the development of features that don't matter. To open source projects which like might be a problem, but overall I'm not too worried about Microsoft entering the space or becoming larger in the investment in the open source ecosystem. If you'd have to pick something from the Rust programming language you don't like or you think could have been done better or that just doesn't make sense, what would it be? Um, I got this question last stream as well and I, I think my answer is the same that I don't, I don't have anything that I really dislike about Rust.
00:16:57.165 - 00:17:35.815, Speaker A: There are some design decisions that like retroactively could be fixed. These are things like having both from and into, which is probably not necessary anymore, or having like try from and from Stir. There's also stuff like Async drop or having the Drop trait take pin mute self. But these are things that, sure, if I could like wave a magic wand and fix something, those would be good things to fix. But. But they're not. They're not to me, like something I don't like.
00:17:35.815 - 00:18:10.127, Speaker A: I think maybe the no, you know, I'm actually pretty happy. Let's see, I have some people who are saying three types of strings. No, I think having multiple types of strings is a really good idea in Rust. Actually. I'm happy they did that. String and STR are just different types and U8s are not strings. The need for different future traits.
00:18:10.127 - 00:18:48.527, Speaker A: No, I'm pretty happy with the future traits. Yeah. No, and there's like file and module organization. I'm pretty happy with how that works too, actually. Yeah, I don't think I have any major complaints, which is maybe weird and maybe I would say something different if I was like in the middle of hacking on some project and was stuck on something the Rust compiler doesn't let me do. But in general, no, I don't think there are design decisions that I completely disagree with. I would like to reimplement some parts of a project I work on which is mostly written in C in Rust.
00:18:48.527 - 00:19:30.547, Speaker A: What is a good starting point for learning about interoperability between C and Rust? So the Rust book has a chapter on ffi. It's not very expensive. I would also read bind, the BindGen and CBindGen documentation which gets into this a little bit. There's also the Nomicon has some stuff about extern C and the in memory representations of types that is relevant. So those are maybe some of the things to look at. In general though, the interoperability story between Rust and C is. Hmm.
00:19:30.547 - 00:20:19.335, Speaker A: I'm totally going to get flack for this, but it's just like not that complicated. It's complicated for like the. What I mean by that is the mechanism is not complicated. It might be complicated to get any given library to work because of a bunch of corner cases you have to deal with. But in terms of what the mechanism does, there aren't that many things is like extern C, repr C, how to link it and then the rest of it is really like figuring out what is the how do I express the C type in Rust or this Rust type in C with rep C. That shouldn't be too hard unless you start dealing with things like unions and enums, which you have to do a little bit more magic with. But apart from that, like the FFI infrastructure is pretty good, I think.
00:20:19.335 - 00:20:52.385, Speaker A: Let's see. Yeah, that's what I would say. Okay. There's some follow ups to the previous question about other gripes with Rust. No pin and iterators. Yeah, that's another one where after the fact we know that it should have it. This is so that you can support generators better.
00:20:52.385 - 00:21:32.619, Speaker A: And it's a. We can't make this change after the fact. No proper aliasing model for writing safe unsafe code. So that's something the Unsafe Working Group is working on. The unsafe code guidelines is pretty good about this and part of it is just like it's really hard to figure out what the right answers are. I'm seeing there are a bunch of other questions here. If you can submit them to the question submission link, that's a lot better because that way I can actually go through the questions that you submit.
00:21:32.619 - 00:22:45.033, Speaker A: If you put them in chat, they're just going to get lost and I think chat can supply you with the link if you, if you miss it. Oh yeah. For the FFI question, Ryan Levick recently did a stream on FFI and Rust and that's something you should probably check out. I think he's planning to do more as well, so that might be a good thing to keep an eye out for. How did the Trump administration affect your or your colleagues student visas? So luckily for me it didn't make a difference because I'm a continuing student and MIT is in a position where. So there was a debate for a while about the change that would require that if you. If the university you're at does not require any in person attendance, then you cannot enter the US on a student visa.
00:22:45.033 - 00:23:38.389, Speaker A: They have to require some in person attendance. If it's fully remote, you would have to stay out of the country. Now, luckily that ended up not getting enacted. But even if it had, MIT would probably basically have just put in place, like, at least for graduate students, requirements for like one hour a week or something in person, just to have some nominal amount that lets you stay in the country. I luckily didn't leave the US when the pandemic started, and so I'm still here, which means that I don't have to go through customs, so that would be less of a problem. Continuing students also had slightly different regulations. More generally, I haven't been touched by them that much, but I know that there are many students that have, in particular, students from certain countries that just like, can't enter the US or new students that are just unable to come here.
00:23:38.389 - 00:24:38.529, Speaker A: Part of this is also not necessarily about visa regulation, but with how poorly the US has handled the pandemic now the US is just doing really poorly, which means that they're in this position where students who are here have a hard time leaving because, like, Europe, for example, is just like, we don't want Americans here right now. And similarly, people from Europe can come to the US but they kind of don't want to because everything is currently a bit of. It's not exactly organized and well managed here right now. So I think actually, for me, the biggest challenge has been the uncertainty. Like, it's not that the Trump administration has enacted policies that affected me personally, it's more the ongoing. I don't know if fear is the right word, but sort of anxiety around. They're doing, they're making all these changes and some of them might be relevant to me and all of them are bad.
00:24:38.529 - 00:25:30.933, Speaker A: Right. So for example, there was some talk about they might like, reevaluate things like H1BS or the student visa practical training programs, which would affect me. I don't think anything has happened in that space currently, but there's just like a lot of uncertainty that makes it really hard to plan for the future. For example, how can a beginner get started with systems programming? I covered this question in the past, actually, so I'm going to skip this one. I think the answers are pretty much the same. How can you centralize compiled rust dependencies to avoid having them in every project location? Ah, this is an easy one. So cargo has a lot of options.
00:25:30.933 - 00:26:11.575, Speaker A: There's a lot of configuration parameters you can set, and in particular you can set what target directory cargo should use. So by default, this is like dot, slash, target. So it's a target directory in the current projects directory next to the cargo tunnel or next to the workspaces. Cargo tunnel technically. Now you can override this either in dot config cargo or dot cargo config, or you can just set the environment variable cargo target dirty. And if you set that to some absolute path, then now all things you compile, I.e. rust code, cargo is going to compile into that target directory.
00:26:11.575 - 00:26:44.497, Speaker A: So for me, for example, I have that on a separate partition, a separate disk essentially. And that means that I don't end up having huge target directories that are duplicated all over the place. If I compile Tokyo for one project in Tokyo for a different one with like all features enabled, then it doesn't end up keeping two copies of the resulting binary blobs. And that's been really nice. It has some downsides, like it needs to serialize the compilation across multiple crates. So if I. Well, not across crates, but across projects.
00:26:44.497 - 00:27:41.531, Speaker A: So if I run like cargo build in one project and cargo build in another project at the same time, one will wait for the other to finish so that they don't step on each other's toes. That might be something that gets fixed eventually, but usually this is not a problem because it's rare that you're building multiple projects at the same time. Yeah, so you get this waiting on workspace lock kind of error, which is basically cargo saying someone else is currently using the target directory. I'm going to not use it at the moment. And this can be annoying if it comes up, but usually it's fine. And usually wouldn't even help you that much because if all your CPU cycles are going to Compiling this thing, compiling this thing at the same time would just make everything slower. There are some exceptions, like if like Rust Analyzer is building your crate and at the same time you're trying to run like cargo check, those can conflict and that's pretty annoying.
00:27:41.531 - 00:28:43.345, Speaker A: In theory, this shouldn't be necessary. They should be able to run it concurrently, but that's something that I'm assuming just hasn't been fixed yet. What is the Rust nightly feature you want to see stabilized the most? This also came up in the previous stream, but for me the answer is what's the feature called? Type Infiltrate Type alias Infiltrate. This is also known known as existential types. And it's just such a lifesaver when it comes to dealing with asynchronous code and traits. The basic idea is that it lets you write like type foo equals impl bar and now foo is a concrete type that happens to implement bar and you can use foo in multiple places in your code. And they will all refer to the same.
00:28:43.345 - 00:29:29.027, Speaker A: So it's basically being able to say like impl bar but have it be the same type across multiple instances. It basically gives you a name for an auto constructed impl trait which just turns out to be really handy. One of the places that comes in particularly useful is imagine that you have a trait like what's a good example of this? I mean towers service trait is the best I can think of, but it might not mean much to you. But imagine you have a trait with an associated type that has to implement future. It's really annoying to implement that trait because you need to name a type to go there. And you can't use imple trait in that position. You can't say like impl service for my type.
00:29:29.027 - 00:30:01.765, Speaker A: And then type future equals impul future. However, with this new nightly feature, you can. And it's a lifesaver. Yeah. So I think that's the one I want the most. Constant is nice, but I don't actually need it that often. Like I need it sometimes in very low level libraries, but usually not that important.
00:30:01.765 - 00:30:46.415, Speaker A: There's another one that's cool, that's label break value, which lets you give it lets you. You know how you can like name a loop in Rust? Actually, I can demonstrate this might be easier here. So in Rust you can do something like. Oh man, like outer. And in here you can do break outer. Right. So you can name a loop and you can choose to.
00:30:46.415 - 00:31:24.655, Speaker A: Let me make this a little bit larger. You can name a loop and then choose to break out of a named loop. That way you're not just breaking out of the innermost one, but an outer one as well. Now that's really cool. But what this new feature does, I think it's called Label Break value is that you can create an arbitrary scope with this name foo. So it's not a loop, it's just a scope. You write a bunch of code here and then at some point, like if, let's say early return, you can do break foo with like true.
00:31:24.655 - 00:31:44.515, Speaker A: And now this thing is going to evaluate to true. This turns out to be really neat. If you have things like asynchronous blocks, it lets you early return from an asynchronous block. Can't see screen. Oh, right. Ooh, nice. I forgot about that.
00:31:44.515 - 00:32:09.181, Speaker A: Now you can see the screen. Maybe with my fancy new. No. All right, how about now? Dude, we can only see your face. Great. Nice. All right, so yeah, so if you look at this code, if you.
00:32:09.181 - 00:33:03.437, Speaker A: Here we have a nested loop, I have a name assigned to the outer loop, and inside of the inner loop I can break out from both loops. Whoa. All the comments came in great. Everyone can see it. And with label break value you can name not just a loop, which you can already do on Stable, but you can name a particular scope and then you can break from that scope, right? If I type like return true here, that return would return from the whole function. But break lets me break from this scope, which is real handy. And in particular, imagine that you had something like you have an async block, and inside of this async block you want to write some code like if early return, then you want to return from the async block.
00:33:03.437 - 00:33:47.665, Speaker A: You can't type return here. That wouldn't work because it would return from the outer function, which would probably just generate an error. And there's no like yield keyword or anything like that at the moment. But this break label value label break value would let you do like block break block to early return from the whole async block, which is really neat. Why not use a closure? So closures often work, but closures have other problems. So for example, if I do like, like let X equals, I guess I'm going to execute this closure immediately. So something like this.
00:33:47.665 - 00:34:23.155, Speaker A: And if early return, then like return true. So this is what you're suggesting that works most of the time, unfortunately. A, it doesn't work with async blocks because we don't have async closures yet. B, it means that now you don't have a rate of returning from the outer function. So if I wanted to use like the question mark operator in here, then I would have to also propagate that error from here. If I actually wanted like a full early return, I couldn't do that at all in here. The other thing this doesn't let me do is imagine that I want to.
00:34:23.155 - 00:35:05.944, Speaker A: Like I have something the mutually mutably borrows like self.y and in here I want to do self X push or whatever. This code wouldn't compile because the borrow checker currently at least tries to mutably borrow all of self into the closure, but I still have Y mutably borrow here. And so this code wouldn't compile with a closure, but whereas with a block it would. Is that blocked by a technical issue or because they don't want to stabilize the design yet? I think it's a little bit of both. Yeah, I think you can do a little bit. I think it's a little Bit of both, but I'm not sure.
00:35:05.944 - 00:35:51.105, Speaker A: Alice, are you sure you can return an async blocks? I feel like I've tried this before and it did not work or specifically like it works in an async function, but in async block. You could be right. You could be right. I just. I feel like I've run into this before. What's the RFC name? Oh, I don't remember the name. Label Break value is the thing you would look at if you're not in a loop.
00:35:51.105 - 00:36:16.535, Speaker A: Doesn't unlabeled break already do this? You can't break outside of a loop in Rust currently. Who? Let's see what Alice came up with here. Oh, my browser is being weird. Let's see here. Oh, sorry. That's going to be bright. This is not the same.
00:36:16.535 - 00:36:43.805, Speaker A: It's not clear that this doesn't return from main. The way to actually check this would be how can we adjust this to actually make it do the right thing? It wouldn't print anything if it returned from main. Oh yeah, you're right. Interesting. I did not know that. Learn something every day. Neat.
00:36:43.805 - 00:37:14.951, Speaker A: Well, in that case, Label break value still useful. Not as useful. Sorry, it was very bright. I should have warned you. Okay, sweet. So let's switch back to questions. Theory shows me I'm currently feeling very comfortable programming in Rust and most of my projects rely on it.
00:37:14.951 - 00:38:11.705, Speaker A: Should I learn also languages such as Java and C because of its popularity in the job market, it really depends on what it is you want to do. Like you can find Rust jobs and that's fine. Now there are a number of jobs where it will still be useful to be familiar with other languages. There are some companies that are Rust only, but a lot of especially the larger companies will have systems that are implemented in other languages and being able to interact with them is going to be valuable regardless. You don't need to necessarily be as competent in those languages as you are in Rust, but it's probably worthwhile to at least not be completely out of the loop on how they work. But that said, I think you can totally get by with knowing just Rust. It will limit your job options though.
00:38:11.705 - 00:38:56.325, Speaker A: Do you have any experience with actor frameworks or languages? I dearly miss Erlang's model when I program Rust, but also know that there's a big interest from people trying trying to mimic it. I don't have a lot of experience with actor models, although I have written a lot of code that happens to work a little bit like it. I think very often in the async world, you sort of end up building a little bit of this. Like you spawn things that have channels to talk to one another. But I haven't used a framework for it, so I can't really speak to that. I have not used Erlang, although I do really want to try it someday. I just haven't found a thing to use it for.
00:38:56.325 - 00:39:40.675, Speaker A: Rust also has a sort of troubled history of actor frameworks, which is probably part of the reason I haven't really used it. But I think part of it is also I haven't felt a need for it. That could be ignorance on my part of not knowing the values that it brings. But at the same time I've been able to get by just fine without it. So is the answer I would give there. Do you think Rust needs a repl? This is like an interactive, like a programming language interpreter for Rust. Why is it hard to implement? I think if it was easy it would already come with a REPL.
00:39:40.675 - 00:40:24.487, Speaker A: In general, REPLs for compiled languages are hard because there isn't immediately obvious ways to take like a prefix of a program and then only run one more line. Usually what you have to do is like run the whole program again, which works, but is often a lot slower. You don't really want to reevaluate all the state up to that point. There are some ways you can get around this. Like you can take snapshots of memory and that kind of stuff. But in general it's like kind of painful to do this process with languages that don't have a runtime there. I think there are some like experimental ones for Rust, but I haven't tried them.
00:40:24.487 - 00:41:20.801, Speaker A: I don't know how well they work. And my assumption is that they're basically either they are recompiling and running the program from scratch each time or they're using something like Miri, which can actually interpret Rust. But I think then you need hooks into like very deep into your Rust code, into the compiler to be able to do this efficiently. If a company would offer you employment to turn Noria into a production ready database, would you accept or do you consider the chapter NORIA to be done for you after you finish your PhD? Okay, so I think I've said this before, but I'm in a position where I've worked on Noria for so long. Like I've worked on it for almost six years and I still believe that it's a great idea. I want it to be a thing that people can like use and take advantage of. But I'm sort of burnt out from it.
00:41:20.801 - 00:42:39.815, Speaker A: Like I don't want to work full time on Noria, at least for a couple of years, maybe more even for databases more generally. Like I wouldn't want to work on this set of problems for a little while. I basically need to sort of recover a little bit. I don't consider Noria done and I think there's plenty more research to do there as well. It's just that I am sort of done with the project, at least for the time being. If you could single handedly prioritize the projects that a new Rust foundation would fund, what are your top three and why that's tough? I think some of the most important projects for Rust are realistically Bind Gen. Bind Gen is basically, it's one of the key reasons why Rust is getting traction at bigger companies so quickly and that is that you can interface with existing code so easily and Bind Gen makes that easier.
00:42:39.815 - 00:43:36.945, Speaker A: And so I think bindgen is very important for that use. I think arguably synthesis sin and quote to me are like one thing and I think SYN is pretty vital. It should arguably be in the compiler, but it's a little unclear. It's only important for certain things, which is why I'm hesitating. But it is like a critical piece of infrastructure to make a lot of the cool things that we can do with macros possible. And I think the third one might be SERDE Big. And the reason for that is like everyone needs to serialize and deserialize.
00:43:36.945 - 00:44:31.963, Speaker A: I don't think SERDE really needs funding. I think SERT it's like gotten good enough as a core library that it. I mean I'm not a maintainer so it's easy for me to say, but I think it's fairly stable at this point. That's also why it's now 1.0. But that's certainly something I would consider like a key feature of the ecosystem is this just like ubiquitous ability to serialize and deserialize things in an efficient way. After finishing an undergraduate career, would undergraduate career. Do you mean undergraduate studies? Would you recommend gaining experience in the industry before getting into academia? I don't think you need to like if you, if you finish your undergrad you can just start grad school.
00:44:31.963 - 00:45:17.285, Speaker A: That. I mean that's basically what I did and it was fine for me. I do think there's value in being older at least when you start your PhD, because the PhD requires a lot of self discipline and that sort of comes with time. At the same time, I don't like, I don't think it matters. I don't think the industry experience will help you that much. It might help you a little just to be more familiar with like real world problems, but in general I don't think you need it. The other argument against it is that you'll be farther behind when it comes to things like recommendations in general for applying for academic positions.
00:45:17.285 - 00:46:06.765, Speaker A: It helps to have references from academia. It's not necessary, but it helps. And those sort of date as you leave academia and stay out of it for a while. And remember, you can always get industry experience in academia, right? You can do internships and such over the course of your studies and that might be a better way to get that insight into industry. Give me one second, I'm just going to open a window. Let's see, what's the best resource to learn Rust concurrence? Oh, I could have used my standby screen. You're right.
00:46:06.765 - 00:46:54.615, Speaker A: What's the best resource to learn Rust? Concurrency. I don't think there's a one best resource. I think it's a rich enough field that it just there's a lot you can get experience with. Like one example would be try to port some existing concurrent data structure or like find. Usually a good inspiration here is like find older research papers on concurrent data structures and try to implement one because usually they give like C pseudocode for example, and just go implement that and you'll learn a lot in the process. The other resource is to look at other people who implement concurrent code. This would be something like my stream on porting the concurrent hashmap from Java.
00:46:54.615 - 00:47:33.695, Speaker A: Or it might be things like look at the crossbeam code for things like crossbeam channel or the crossbeam skip list, for example. You can even just read Wikipedia articles on it. There's just a lot of good interesting concurrent data structures that you can implement without too much trouble. And I think that's really where learning those concurrency bits really come from. Of course there are parts of concurrency that are not unsafe. They're not about data structures. So this is the stuff like locks and convars and channels and that sort of stuff.
00:47:33.695 - 00:48:35.575, Speaker A: I don't have any good resources for that. Specifically, I would say that there's some good ways to learn it that are not necessarily tied to rust. So for example, MIT's 6824 class on distributed systems, there's a lab that's publicly available where you implement the RAFT consensus algorithm and that has a lot of concurrency in it. You need to have like channels and locks and all that stuff, and that is in go currently. So that part of it is not Rust specific, but it will teach you a lot about concurrency and about reasoning, about distributed systems, and it might be a good exercise. I think Pincap has a port of that lab to Rust that you could try, but I haven't looked at it myself. MIT's PhD program is probably one of the hardest to get into.
00:48:35.575 - 00:49:19.795, Speaker A: What is your personal experience at mit as a PhD student? What part you liked a lot, what part you wish could be better? It's a complicated question. I think my personal experience at MIT has, has generally been very positive. It's been. I think PhDs are weird in that they. It matters a lot what you do with it, as opposed to many of your earlier studies and the PhD program. Like, you decide, you decide what you work on, how you work on it, what area you work in. Very little is sort of pushed on you.
00:49:19.795 - 00:50:02.059, Speaker A: And that means that what the university provides is sort of the support structure around it. What you actually end up working on is going to primarily be down to you. And so that part is hard to evaluate. But in terms of that sort of surrounding infrastructure, I think MIT does really well. Like, funding has not generally been a problem for me through the years. I've worked with a very talented group of professors who have a lot of experience both with, both in industry, with writing papers, with academic research, and they're just good people to talk to in general. And similarly, like my lab, the other people in my lab are very smart people working on interesting problems.
00:50:02.059 - 00:51:06.885, Speaker A: The same applies to like the whole floor really and all of mit, but my floor is the one I know the best. I think one thing I liked about MIT is that there really is the spirit of you can just walk up and talk to people in general. If I wanted to talk to a professor, I could just email them and then go talk to them. Or if there are students in the database group, which happens to be on the same floor as my desk was on, I could just walk over and chat to them. It was a very informal atmosphere of academic collaboration. I also think MIT in general is pretty decent about supporting their students when it comes to, like, making sure they have housing, making sure that there, like our contact resources for things like immigration, and like the stipend you get is very little compared to working in industry, but it's good enough to get by as a student. Like, you're not building up debt as you go here as a grad student, for example, at least in the computer science department.
00:51:06.885 - 00:51:58.525, Speaker A: As for Parts I wish could be better. I think that comes down to very personal things. Not in the sense of I don't want to talk about them, but in the sense of it really comes down to your particular situation. So for me, I think what would have made it better for me is to have an understanding sooner of what a thesis is like, what what work needs to go into one to have it be like this is acceptable for a thesis. That's sort of something I had to figure out as I went. And there aren't really well structured guidelines that might just be because they're hard to set because of the wide range of work you can do for a PhD, but. But I think that was certainly one of the bigger struggles for me.
00:51:58.525 - 00:53:27.741, Speaker A: Why are you planning to leave academia and work in industry instead? So I'm planning to leave academia because I don't think it's right for me specifically. I, I really enjoy building things that people use that other developers in particular like. I like building tools and infrastructure that other people can sit down and either learn from used to be more productive or just have things be useful immediately or in some immediate sense. And academia is not really about that arguably for good reason. But there it's more about you have to make sort of meaningful intellectual contributions. And that means that spending a bunch of time on getting the documentation right or building out an expensive test suite, it's just like not that important. And that's probably the biggest difference of opinion there for me, that I want more of that sort of hands on usefulness that I feel like is more prevalent in industry than in academia.
00:53:27.741 - 00:54:16.007, Speaker A: At the same time I like sort of developing new things. I don't just want to be a code monkey, right? Like I want to feel like I'm designing, architecturing new solutions, thinking up new bits of infrastructure. And so there'll certainly be some of that like research and teaching certainly aspect of it to me. But I think I can do that better in. I think I can do that better in industry than academia. Do you have any podcasts you listen to or would recommend? I have several. I already mentioned the humans of open source podcast, which I think is just a really good idea.
00:54:16.007 - 00:54:52.745, Speaker A: I like this idea of trying to show that the people who contribute to open source are normal people. Like we have problems in our lives. We're like, we're, we have flaws and errors, we have ups and downs. I think that's important. I think it's very easy to think that the like big usernames you see all over GitHub are they're all humans that you can talk to and interact with, and they're not that unlike you. And you can also be one of those people. There's some other podcasts that I think are really good.
00:54:52.745 - 00:55:39.123, Speaker A: There's a psychology podcast called you are not so Smart, which I think is just absolutely fantastic. It looks a lot at sort of social psychology, why we do the things we do, why we think the way we do, the biases, the cognitive biases that we have. I found that podcast really, really interesting. I would of course, also recommend the rustacean Station podcast, which I sort of will obviously recommend because I'm a big part of it. But also I think it's a good way to just sort of stay up to date with the community. Like now we have this week in Rust that appears there. We still go through, like, new releases of the Rust compiler.
00:55:39.123 - 00:56:02.215, Speaker A: We have interesting interviews. So I think that's a good way to stay up to date on Rust itself. Let's see what else I have. Let's see here. Podcast app. What do we got? Stuff you should know is fantastic if you haven't listened to it. I highly recommend.
00:56:02.215 - 00:56:30.225, Speaker A: There's a podcast called not another D and D Podcast, and it is fantastic if you enjoy just like storytelling and D and D. It's. It is another D and D podcast. Like, it's one where you've watched them play through a story, but it's really good. I personally prefer the main story much more to the one called Trinivale, but it's. It's really funny. I enjoy that a lot.
00:56:30.225 - 00:57:18.155, Speaker A: There's a podcast called make no Law about the First Amendment in the US that I thought was pretty interesting. It's like a legal podcast. It's a podcast that hasn't been updated in a while called Playing for Fun, which was a podcast where these two people were basically playing their favorite games and talking about what they liked about them. So it's not a game review. It's not about talking about all the ways in which a game is broken, but just talking about the joy of video games. I like that one a lot. What else do we have here? Constitutional and Presidential were two other pretty good podcasts that they're more politics oriented, but they're sort of historical in nature.
00:57:18.155 - 00:58:21.595, Speaker A: Tell me something I don't know was also really good. It's a. It's sort of a game show podcast, but it's one where people have to come in and explain to the judges something they didn't know and they get rated on their answers. And I think the final one is there's a podcast called the Turnaround which is this person who goes around and interviews really famous interviewers and really good interviewers and try to get their take on how do you interview people, how do you talk to people you don't know and learn interesting things. And I highly recommend this even if you're not a person who normally interviews people. It was just a fascinating view into just like the minds of interviewers. Can you share your development environment, vim setup, which terminal shell, etc.
00:58:21.595 - 00:58:58.725, Speaker A: I actually have a video on that already. I'll put it there in the video or something. And it is. It's a little bit old at this point so I can go through some of the changes. So I'm using neovim, I'm using the fish shell and I'm using color scheme called Groovbox Dark Hard. I think that's what I'm using in all my programs. And I'm using Rust Analyzer to get like all the nice Rust things in neovim.
00:58:58.725 - 00:59:31.141, Speaker A: I'm using the neovim plugin I'm using for interacting with Rust Analyzer is called COC and it's really good. It's really good. I use MUTT for email because I'm old school and I like having my email in my terminal because I'm weird. I use Firefox as my browser. I use Alacrity as my terminal. I think those are like the quick. The quick glance.
00:59:31.141 - 00:59:56.685, Speaker A: Oh, and I use A ulauncher as my. This is like my program launcher which I'm very happy with. And I use the Binary Space Partitioning Window Manager. So bspwm, I recently switched to it. I'm pretty happy. And yeah, I use TMUX as well for doing things like having multiple buffers open. I find that that works really well.
00:59:56.685 - 01:00:20.205, Speaker A: And all my config files and stuff, all my dot files are on GitHub. They're on GitHub.com John who configs on Arch Linux. Yeah, let's see. Oh, quick reminder to. Because we now have a bunch more people watching. If you have questions, please post them into.
01:00:20.205 - 01:01:09.487, Speaker A: There's a website that like has all the Q and A where you can submit questions, you can also rate questions and in general I'll be answering the questions that have been the most highly rated, sort of working my way through them. That way the chat won't be just filled with questions that I don't get to answer. We can have them be a little bit more organized. Do you have any recommended books which helps you gain strong computer science knowledge? I actually mentioned this last time in the last stream, but I'll do it again now because I think the list got lost sort of among chat somewhere. Let's see here if I can find it. It's pinned in the. In my.
01:01:09.487 - 01:01:41.005, Speaker A: My channel on the restation station Discord. But let's see here. The books I mentioned last time were the Pragmatic Programmer, which is a great book. I highly recommend it for everyone. Seven languages in seven weeks, which is. It doesn't have rust in there, but it's a really interesting take on just like exposing you to how different languages work. If you're interested in operating systems, then Design the Design and implementation of the FreeBSD operating system is a really good and thorough book about how FreeBSD works.
01:01:41.005 - 01:02:27.355, Speaker A: The visual Display of Quantitative Information is a book that I haven't read yet, but I've heard really good things about, which is basically if you have a bunch of data, how do you present it in such a way that it's understandable and neat? Hackers Delight is a really cool book about very low level details about like bit twiddling and assembly and stuff. But it's just really cool to read through some of that. I use it almost now more for reference than anything else. While I'm at it, I might as well as well do some like. There's some other good nonfiction out there that I really like. So for example, there's a book called Mindwise, which is a social psychology book about why we misunderstand each other. Like the psychology behind why we misunderstand each other.
01:02:27.355 - 01:03:10.075, Speaker A: There's a book called the Code Book by Simon Singh which is about cryptography and sort of the origins of cryptography, how cryptography is broken in the early days. The Dorito Effect, which is a really interesting food about book about food and like how the like food processing and food development has developed through the years. The what if book by Randall Munro, the person who makes xkcd is really good. But yeah, if you look through the pinned the pinned post on my channel in the rostation station Discord, you'll see a couple of others I had there too. Factional books. Yeah, exactly. I still think factional is way better than nonfiction.
01:03:10.075 - 01:04:44.039, Speaker A: If I have a hash map with strings as keys, are they cloned when they are inserted? So if you have a hash map where the keys are strings, like string with a capital S, then when you do an insert, you have to provide a string. If you provide a string that is owned, then no, the key is not cloned. If you provide a STR type like a literal string for example, then it has to be turned into a string in order to be inserted if that is the type of the hashmap and in that case the string would be heap allocated and then copied over from the string literal you gave have you done any digital signal processing? What are your thoughts on Rust as a language for building audio tools? I've actually done fairly little signal processing in Rust, although I do think it's a language that is pretty well equipped for doing that. This is in part I think GStreamer is one of the libraries is looking at developing more stuff in Rust and that would be really cool. And I think it's basically because Rust is a language that gives you really good control over low level details like writing assembly, dealing with the memory management. And there's no runtime node gc, which means that you can actually do at least semi real time processing. And I think that is a pretty good argument for why using Rust for signal processing is worthwhile, especially in like an embedded setting.
01:04:44.039 - 01:05:18.709, Speaker A: You might be able to use Rust programs pretty easily, but I haven't done it myself. It's something I want to do more about. Like I like that space, but I don't know much about it. Oh, link to the discord. Can someone provide that? Should be easy enough if you're in there. How's the job hunt going? The job hunt is going pretty well. I don't have any public announcements yet, but my hope is that I have a sort of decision, maybe even by the end of this week.
01:05:18.709 - 01:06:17.315, Speaker A: I don't know yet, but it's going pretty well. Thanks for asking. Any thoughts about OCaml and modules versus type systems? No, I have never used OCaml and so I don't really have any thoughts on its module and type systems. What you'll be working on next after getting your PhD so as I mentioned, I'll be going into industry. I don't know exactly what position I'll be taking yet, but my a little bit more general take is that I like working on things that matter to developers, like developer tooling infrastructure, that sort of stuff. And I would like to keep doing that. I want to keep interacting with the rest of the community and ecosystem as much as I can and ideally I want to continue doing teaching, whether that's internally in the company, externally or both.
01:06:17.315 - 01:06:58.011, Speaker A: Ideally I'll certainly be continuing with these streams, but if there was an aspect of my job that included doing things Like Rust education. That would be fantastic. So that gives you an idea of what I'm looking for without necessarily being a specific job. I also really like high performance, low level concurrency bits and doing more of that would be super cool. It's not a requirement for my job, it's something I could also do in my spare time. But it appeals to me. Someone mentioned relating to the previous question about REPLs in Rust.
01:06:58.011 - 01:07:26.029, Speaker A: Haskell is an example of a statically typed language which has a repl which is heavily used. Very nice to have as part of the development work flow. That's true, but Haskell is. Haskell also has a runtime which makes it a lot easier because the runtime carries the state of the program. Now you still need to have reach, like reach into the runtime in order to be able to provide it with new things to execute. So it's still not trivial. But that is an advantage that the Haskell has over Rust.
01:07:26.029 - 01:08:28.595, Speaker A: In that context, what are some good beginner to intermediate systems engineering projects that one can finish in a week or so? Mostly to get the main ideas of systems engineering. Who depends what you mean by systems engineering projects. The first thing that comes to mind for me is to do like bigger university lab projects like in 6824, the distributed systems lab class at MIT, there's a lab that has you implement Raft. It's in Go, but there is a sort of a start of a Rust port of it. But even if you do it in Go, it's going to teach you a lot about systems programming just because you have to build the distributed systems. Alternatively, you could look at something like Philip Opperman's operating system that he's building from scratch in Rust. That's a great way to just learn all the components that fit together.
01:08:28.595 - 01:09:25.555, Speaker A: Although of course with a focus on operating systems. If you're looking at sort of slightly higher level things, you could look at something like in 6858, the computer security class, the final lab is to implement a encrypted remote file system, which is pretty cool. It's a pretty big lab where you have to figure out the systems design yourself. That one is in Python. I think when it comes to learning systems engineering, it's just sort of independent of the language you're working with. Like systems engineering is a skill that you learn and it doesn't have that much to do with the specific language that you're using. And both those classes I mentioned, like 824 and 858 are both like they're classes that are very much intended to teach you how to do, well, systems engineering in general, but specifically distributed systems and computer security.
01:09:25.555 - 01:10:02.025, Speaker A: But they're. All of the necessary material is available online. You won't have access to like the TAS for example, but all the lab instructions, all the template code, all of that is available. And you could try to implement the whole lab yourself. You wouldn't get the test suite that way, but it might be interesting. Have you been playing D and D or other tabletop games virtually since the event? As someone who's done podcasts and streams, how have you found the Switch? I have. So I've been playing a decent amount of D and D actually.
01:10:02.025 - 01:10:32.115, Speaker A: I have a campaign that I run myself for a group of friends. Like every used to be every week. Lately it's been like every other week. We just run that over Zoom and then we have D and D beyond and a tool called Dungeon Revealer, which is a browser based like Map Revealer thing. I think that's worked really well. I think I do miss some of the, like, table interactions. You don't really get over Zoom.
01:10:32.115 - 01:11:39.685, Speaker A: I've also been playing a lot of. Well, that's not true. I've been playing some Blood on the Clock Tower, which is this big, big group social party deception game that I'm a big part of helping develop and playtest, and that has a Discord server as well, where there are regular games run online. I've participated in some of those, helped run some of those, and that's also been really fun. It is just a very different experience online. These games that are intended to be very social, they're still social, but it's lacking a little chin, you know, I think, yeah, I think I just missed the sort of chatter that happens more in person than online because online crosstalk becomes too much of a problem. I have started appreciating how much it helps to have like a proper audio video setup when you do those like that has just made a massive difference for me and I'm very glad I had that before things started.
01:11:39.685 - 01:12:31.011, Speaker A: What do you think about the future of programming graphics with rust, Vulkan web GPU, etc. It's not something I've done a lot of myself. I've done a little bit of GPU programming, although that was in C. It seems like something Rust could be really good at, but without more experience is hard for me to really say. I think Vulkan is really exciting. I hope that we end up in a world where Nvidia also adopts Vulkan previously. What sort of happened is Nvidia has a little bit of a stranglehold on the market with Cuda, and because they're not adopting any other proposals that are put forward, everyone's like, well, we already have stuff that works really well in Cuda and this thing is like only supported by other GPU manufacturers, but it's not that good.
01:12:31.011 - 01:13:31.535, Speaker A: So we're just going to buy Nvidia GPUs and use CUDA. I'm hoping that with Vulkan it's going to be a sufficiently widely adopted thing and that it's going to have sufficiently good other features to drive adoption a little bit, but I don't know. How do we prevent Rust from becoming another C in regards to feature bloat, coding, friction, et cetera? It's a good question. I don't have a good answer for you. I think part of what happened with C was that it had so much legacy before it started formally developing or like things like C11 and C. I forget what the most recent numbers are. And C17.
01:13:31.535 - 01:14:09.229, Speaker A: They all developed relatively late in C life. I think maybe what we're seeing with Rust is that they might be getting a little bit ahead of the curve by having well established processes for doing sort of language development. These are things like the rfc, process additions, that sort of stuff. So maybe that can help stave some of it off, but it's hard to say. I don't have a good answer. I'm considering going into industry for two years after my master's and then doing a PhD. I'm afraid that I will lose too much knowledge and academia type of skills.
01:14:09.229 - 01:14:54.335, Speaker A: Do you think this is achievable? I think so. If you go into industry. Let me rephrase this a little. PhDs are just different. It depends a little bit of where you did your Master's, but in general, the stuff you learned over the course of your Bachelor and Master's is somewhat irrelevant for your PhD. Not entirely. There are some cases where that will be helpful, but at least for the purposes of my PhD, my master's was on a completely different area of computer Science to my PhD, my Bachelor as well, and I don't think that remembering more of what I did there would help me that much in my PhD.
01:14:54.335 - 01:15:55.769, Speaker A: Also, when you start your PhD, much of the initial work is just going to be catching up on things that you don't know that are important for the field that you join. So I wouldn't be that concerned about it. The biggest thing As I mentioned earlier, is things like references that can be a little bit harder to deal with if you have been outside of academia for a while and then ask for academic references. But in general, I don't think it should be too much of a problem. Do you believe Crates IO will become as bloated as npm? Like the is even, is odd and IS number packages, it has the potential to become that in practice. I actually don't think this will happen. And part of the reason is because I think the Rust ecosystem has been pretty good about making it making a virtue of having few dependencies.
01:15:55.769 - 01:17:14.125, Speaker A: Now we can argue whether that's good or bad, but in general the ecosystem has been pushing in that direction where there's actually a decent amount of pressure on developers of especially core libraries to reduce their dependency list their dependency trees. And this is something I know Burnt Sushi has been talking a decent amount about. And like, I don't. I don't think there's anything that's fundamentally stopping Crates that IO from becoming like npm. I just think the culture is a little different to the point where even if that kind of crate got built, and my guess is there already is one, it probably won't be that widely used because I don't know, there's just something about the culture, at least in my experience, that means that those things people aren't using dependencies for, they're not willing to add dependencies for that. What dependencies in Rust are more expensive than an npm? That factors into it too, a little bit that in Rust you have to compile your dependencies. You don't just add them.
01:17:14.125 - 01:18:11.185, Speaker A: And the fact that they get compiled means that the more dependencies you have, the longer it takes to compile your project. Even though the delta might be small, this effect gets exaggerated as your create dependency tree grows. So that might be another reason why it gets like. Well, why more dependencies is not shunned but sort of disparaged or avoided a little bit in the Rust community because it's more obvious that you have many more dependencies it increases like binary size and compilation time. What general advice can you give to a student that is into Rust but has very low chance in finding a Rust job? Oh, and finding a Rust job locally don't work locally. I'm semi serious. I think that work as we know it is changing.
01:18:11.185 - 01:18:57.623, Speaker A: In part, the current world situation is a factor in that. But also looking locally, it's bad for businesses and it's bad for people. For businesses, it's bad to Only look locally because you're restricting the pool of talent that you're willing to look at. You're like fishing in a smaller pond and that means you either have to pay more for the talent or you'll just find less talent. If you're a developer, it means that you can only work for the companies that are near you, which means that you have many fewer to look for and that limits your options. I think if you're willing to work remotely, or at least semi remotely, you should seriously consider doing that. And then Rust positions will not be that hard to find in general.
01:18:57.623 - 01:20:21.087, Speaker A: My experience has been that a lot of Rust positions are available remotely, even internationally. If you, if you're having trouble, if you specifically need to find a local job and you are comfortable with Rust, but you don't think there are any Rust chops locally, I would look for companies that you think might be willing to adopt Rust either because they're small or because they have use cases where Rust is a good solution. Like if you find someone in the embedded space, for example, or in the high performance space or in something like high frequency trading, where performance might be really critical, you might be able to start writing certain components and Rust where it makes sense. Like if it's a security sensitive module, you might be able to argue that the benefits of Rust by you are actually valuable enough that you should build this component in Rust and then have FFI calls from the existing code base. It's certainly a harder sell, but that would be my take. Yeah, I would probably also say like if it's like a Rust shop or a Python shop. Sorry, if it's like a Ruby shop or a Python shop, it's less likely you'll be able to use Rust there than if they're like a C or C shop.
01:20:21.087 - 01:20:57.481, Speaker A: So that's also worth taking into account. How would you write a concurrent and asynchronous cron like task scheduler in Rust? Asynchronous cron like task scheduler. So I think the question is really how would you implement CRON in Rust? The asynchronous is necessary for Cron. Task scheduler is what CRON is. So I think the question is how would you implement. And concurrent is something that Cron sort of has to be. I think the answer is pretty straightforward actually.
01:20:57.481 - 01:21:34.405, Speaker A: Like you define some format for way to people to define jobs. This could be crontab files or something equivalent to them and you just run it as a program. It uses like inotifier and Linux or some other API to Watch the file system for when those files change. Or you have a command for telling the daemon that the files have changed and it should update its config. And then really what it does, it just keeps. Usually you want something like an interval tree or a timer wheel to keep track of all of the different next schedule times. And then all you have to do.
01:21:34.405 - 01:22:18.115, Speaker A: It could even just be a min heap, right, where the key is just the time of the next trigger of this job. And then what you do is you just like look at what's at the head of the heap and then you sleep for that long and then you pull the job off. You spawn it as a background, you spawn it as a thread. Basically you have a thread that like forks and then you just run the jobs that way. I don't think you need Async here. Actually you could, but I don't think it's necessary. Are you considering a remote position? What do you think of remote work? Yes, I am almost exclusively looking at remote positions.
01:22:18.115 - 01:22:47.875, Speaker A: I think working from home is better. I think the only upside to me of not working remotely is that you get to see people face to face. And there is certainly value in that. It's more likely you pick up like, chatter from other people, for example. But to me, the benefits far outweigh the costs of working from home permanently. So, yeah, I'm entirely looking for remote jobs and I'm a big fan of it. Like, it means that you.
01:22:47.875 - 01:23:31.057, Speaker A: I mean, I haven't. I've done It As a PhD student, I haven't done it in industry. So, like, take this with a grain of salt, but it means that I can like, not have commutes. It means that I can like be at home with pets and like, get joy from that. It means I can like have lunch with my girlfriend, for example, and then go back to work. I think one thing that's very important though, if you are going to be working permanently from home, is to make sure that you have a dedicated space for it. Like, if you're using the same computer, the same desk, the same room for your working from homework as you do from, like your relaxation, it's going to be really hard to do work productively.
01:23:31.057 - 01:24:03.665, Speaker A: This is something I've experienced during my PhD that I've tried to keep like my desktop computer as something where I do work and then I do fun elsewhere. Like if I play games, it's like on the PlayStation or something. I don't. That doesn't always work. Sometimes I need a computer. But once you start mixing and matching what you use a given space for, your brain gets confused and it's much easier to accidentally end up procrastinating, like I might. It means that like, while I'm working, I'm used to also checking Twitter and Discord on the same computer.
01:24:03.665 - 01:24:47.675, Speaker A: And I think it's better just have like a dedicated physical space so that your brain knows that when you go into the space you're at work and when you leave the space you are not at work. And that's I think, a healthy thing to establish for yourself. The downside is that you now compete with the entire world for a job. That's true. Although realistically I think the calculus still works out that it's generally better for you to be willing to work remotely. It is true that like if you are local and the company only hires locally, that gives you an advantage. But there are a lot of downsides, as I mentioned as well.
01:24:47.675 - 01:25:15.035, Speaker A: It is true also that like remote jobs make communication harder. It's more difficult to just like randomly be a part of a conversation or pick something up like buy the water cooler. It's harder to accidentally be a part of decision making process disease. And that's. That is a downside. I think companies are getting better at this, of having all or much of the communication happen online anyway. Like think of it this way.
01:25:15.035 - 01:26:10.645, Speaker A: If everyone is remote, then there's no. There's no face to face benefit because no one is having it. Where you run into problems is if like some people are face to face and some people are remote because that way they can end up being this like split where they're not. They're like equal, but not equal. If everyone is remote, that helps, but you need to be much more structured about documenting processes, communication channels, that sort of stuff to sort of encourage that sort of serendipity that can happen when you're in person. Do you have plans to record a session about MPI programming in Rust? It depends what you mean by MPI programming. Let me see what the official definition of MPI programming is.
01:26:10.645 - 01:26:47.195, Speaker A: Message passing interface programming. So I assume you're thinking of things like OpenAPI and like the actual standard as opposed to just like concurrency. I. It's not something that I've really considered. Like I don't know that the MPI protocol and standard matters that much in the Rust space. When you have crates like Rayon, that helps a lot. It is true that maybe MPI might be nice if you want concurrency between Rust and C, for example, but it's not something I've looked at and not something I could really speak to.
01:26:47.195 - 01:27:56.795, Speaker A: Yeah. If you're not interested in being in LA long term, considering your career background, what places are you interested to settle in? Do you want to stay in the US do you want to go back to Norway, etc. I don't think I want to be in the US and it makes me a little sad to say that because there's a lot of cool stuff happening here in terms of intellectual work. But there are too many things that the country doesn't value that I value. I think, for example, the work culture in the US in general, not everywhere, but in general is it focuses too much on people being workers and people being employees as opposed to people being people. Like the amount of vacation days you get in the US is extremely low. Things like healthcare is something that your employer has to pay for and it has to be like it's an issue, it's a thing.
01:27:56.795 - 01:28:45.725, Speaker A: Things like taking sick days is something you actually need to look at before joining a company. Even just the amount of hours you're expected to work, how your work life balance works out, these things in the US are sort of second order things. Whereas like if you look at certain parts in Europe, there are countries that are considering doing like four day work weeks where that is totally reasonable. In the US that would be absolutely outrageous. As for where I'd want to go instead, I don't know. I think for me it would probably be Europe, just because that's where I have the most ties. I'm not opposed to going somewhere else, but Europe is probably where I'd be aiming.
01:28:45.725 - 01:29:21.727, Speaker A: Canada could be cool too, but I don't have much experience with it. In terms of within Europe. I really like London. I lived in London for a couple of years and enjoyed that experience immensely. I think London is a really cool city and it has, it has the advantage that it feels really local while being very large. The downside of course is that Brexit is a complete shitshow and currently everything is a pain there. And like the political situation there, like here is a little bit on fire and that's not great.
01:29:21.727 - 01:29:42.527, Speaker A: I don't know if I want to deal with that. Norway could be good. I think the biggest downside for me for Norway is that it's still. It's a fairly small country, it doesn't have that many people, it doesn't have that many job opportunities. I could work remotely, but Norway is pretty expensive to live in. So I would probably have to work remotely in Norway from the U.S. because U.S.
01:29:42.527 - 01:30:06.171, Speaker A: salaries are higher, which again limits my options. I honestly don't know. It also depends a little bit. Like my I'm moving to LA because of my girlfriend and she's getting into voice acting, which because she's from the us, that's something that she'll know how to do in English. And moving to Norway might be problematic there too. It might be hard for her to find work. So it's just like a very multifaceted problem.
01:30:06.171 - 01:30:33.545, Speaker A: Luckily, it's something that I don't feel like I need to decide right now. I think realistically I'll be in LA for two or three years and then we'll see. Like, who knows, like after that maybe I'm I've decided that everything is better in the US now and I want to stay, but I honestly don't know. And yeah, as for temperature, I. I come from Norway. I like things cold. Like even Boston is generally too hot for me.
01:30:33.545 - 01:31:22.683, Speaker A: I don't know. I guess I'll survive la. I lived in Australia for a few years so like I can deal with it, but certainly for me, like I want there to be seasons and I want there to be winter as one of those seasons. Let's see. What do you think of the future of Rust in web programming? I see more companies adopting Rust for web services. Even though the web tech libraries in Rust seem young, like grpc, I think Rust's future in web program is actually pretty promising. Rust has a really good story for WebAssembly and works a lot with the WebAssembly working group, both on the standard itself and for the Rust integration with it.
01:31:22.683 - 01:32:10.029, Speaker A: Things like integrations with constructing Node JS packages through Rust. It's just, I think there's a lot of cool stuff happening there and I think Rust is uniquely positioned to be able to provide high performance stuff for the web through its integration with webassembly in particular. I also think that even in the space of writing servers, Rust is pretty good. We have like Hyper is an excellent language for things like HTTP servers and clients. Rocket is great for writing web applications. I think it's going to be hard to like make everyone move to Rust. I think realistically, if you have developers that are using Ruby on Rails today or Django or something like that, it'll be hard to make them write that stuff in Rust instead.
01:32:10.029 - 01:32:51.917, Speaker A: So I don't think Rust is like going to replace that ecosystem at all. Same with Node js. It is harder to write Rust code in that sense, but I do think that it's very well positioned to do well in the web and networking space. It's true that some of the libraries are young. Like I wouldn't say HYPR is young or Rocket is young, GRPC is a little young. But I think once you start seeing companies adopted, there's enough development effort behind it that I'm not too concerned. Scotland would be a great trade off.
01:32:51.917 - 01:33:45.665, Speaker A: Scotland could be cool. I like Scotland. Can you name some programmers that you admire in particular? Maybe some that are active and open source, the media, blogs, teaching sites, et cetera. Who? This one's much harder because. Well, first of all because many of them I only know by their usernames, but also because I don't think there are that many programmers that I admire. But that's just because I don't generally admire people. I think there are many programmers that I think are good for the ecosystem that are sort of talented and their time is valuable and there's sort of a good force in the world of software development.
01:33:45.665 - 01:34:31.265, Speaker A: I think it's easier for me to answer this question in Rust specifically than for other languages. So specifically in Rust, the ones that come up for me are like, I think David Tolnay is great. This perhaps obvious. I really like David. Both like as a human being but also as a developer. He does excellent work. I think the same goes for Burnt Sushi for what's his name, Andrew Gallant also just like produces really high quality code, thinks carefully about things and it's just like he's also on the Rust moderation team and does a great job there, even though it's an extremely hard job.
01:34:31.265 - 01:35:25.605, Speaker A: I think much of the Rust core team like Niko Matsakis comes to mind as someone who just like has poured his heart and soul into both Rust and its ecosystem and it clearly pays off. I think there's some developers that are building really good, cool infrastructure as well. Like, I forget Jane's last name. Her Twitter handle is Yahc Underscore. I think she's the person who writes Airy and Color Air, which are error handling libraries that are. They build sort of on top of anyhow to provide much better error reporting with context and such. And she's done a lot of work in just expanding Rust's error handling story.
01:35:25.605 - 01:36:18.937, Speaker A: Then there's Eliza Wiseman who has built basically all of tracing. So this is the. If you don't know of tracing, it's a really cool crate that basically gives you sort of the same interface as you have the log crate, but it lets you emit generic events that can be consumed by a subscriber that, like, it could write it out to a log, but it could also do other things like analyzing statistics. I'm sure there are others if I try to go outside of the Rust space. There's a game developer called Oscar Stolberg. Let me see if I can actually give you the osc. Twitter handle is osksta.
01:36:18.937 - 01:36:42.855, Speaker A: This person. So this person does game development and in particular works on doing like procedural game development and posts a lot about that development online. And it's just. It's really, really cool, the stuff that he's building. He recently built a game called Town Scraper that just. It's super simple and silly, but it's. It's just really cool.
01:36:42.855 - 01:37:23.079, Speaker A: I think Frank McSherry is another person who is a developer that is also very good at writing about what he does. And I think this is a valuable. It's a really valuable skill that I think many developers lack, which is the ability to not just build interesting things, but also explain them to people. Like, explain why they're useful, explain how to use them, explain how they work, and basically do education. And that's something that I think Frank is pretty good at about writing about his endeavors. I see a lot of people in chat are mentioning John Blow. I don't have experience with him, but.
01:37:23.079 - 01:37:56.757, Speaker A: But I'm sure that's true as well. I'm just like going through my Twitter feed at the moment, actually, to see what else is out there. Like people that I specifically know are doing really cool stuff. Yeah, I think off the top of my head, those are the ones that I would mention. But I'm sure there are plenty of. Of obvious people that I'm missing. I think there are also some people who are not.
01:37:56.757 - 01:38:48.565, Speaker A: Oh, Dan Lou does a lot of cool work as well. Dan L UU in any case, I think many of these are talented developers, but I think ultimately what it comes down to is look for people who are interested in the same things you are. Like, there are a lot of talented people out there, and sometimes it's useful to follow people who do something that's very different from what you do. But it's just like, look for things that are interesting. And in particular, I would say look for people who produce content you're interested in. Like, one thing is if they produce quality software, like, that's great. But oftentimes, if you really want to learn from them, look for people to produce, like, educational content, to produce blog posts about what they're working on, who do like, good documentation and write ups.
01:38:48.565 - 01:39:51.689, Speaker A: That's the stuff that you're really going to learn from long term, I think. Let's see. Is Rust more informed by academic research than other popular languages? Well, certainly than some like the famous counterpoint here is Go right, which sort of explicitly did not include anything that had been discovered in the past, like 20 years. It's not quite true, but that's sort of the adage. Rust certainly tried to build on a lot of the programming language research that had happened over the past many years. And I think that has certainly helped the language. And I think that is something we're seeing ongoing as well, where there's a lot of academic interest in Rust as a language from people like Ralph, who actually recently joined the lab I'm in at mit, who's the person who.
01:39:51.689 - 01:40:35.783, Speaker A: One of the people at least who developed Miri, who's doing research on things like unsafe Rust and how to make it safe. And I think that is. That's one sense in which Rust is a language that fits pretty nicely with academia. And I think in return, academia is also working on building out the language. And I think in some small way Rust is also contributing to the programming language sort of set of information. Like things like the things like PIN from boats I think is a really cool idea and it's something that hopefully I think will see other languages maybe adopt or something similar. But I don't think Rust is the only one.
01:40:35.783 - 01:41:05.275, Speaker A: I think there's a decent number of other languages that are doing this kind of work, like Zig is an example. D is another language. Haskell, of course, is a very academic language. So I don't think Rust is the only one. But Rust is certainly one that has pretty successfully taken ideas from the PL community and put them into. Into production. In my last semester, I opted for internships rather than an undergrad thesis.
01:41:05.275 - 01:41:31.825, Speaker A: Is it possible to still have a chance of getting to grad school without the aforementioned research experience? Everything is possible. I don't think you're under. So certainly for me, I didn't even write an undergrad thesis. That was just not a thing I did in Australia. And that was fine. But I also didn't get into MIT from Australia. I went through London, which is where I wrote my master's thesis.
01:41:31.825 - 01:42:06.399, Speaker A: You might find that it's a little harder. It sort of depends on what you did during your internship. If your internship was a little bit research oriented, that might help. I wouldn't worry too much about it. One thing to keep in mind though is that if you apply to universities like mit, you're sort of competing against some of the best people in the world, but you're competing against other people. It's not as though there's a checklist and if you don't have all the boxes ticked, you can't get in. It's a set of people that is evaluating a different set of people.
01:42:06.399 - 01:42:51.085, Speaker A: And so what they're looking for is do they think that you would make a good grad student? That's what you have to convince them. It's not about showing them high numbers or like, I checked this box. There are certain boxes you must tick. Like if you, if all your grades were terrible, that's probably not a great starting point. But whether you did or did not do an undergraduate thesis is not going to make or break your application. I think that Rust's power and versatility can be used in a wide variety of projects. So in what situations should we choose other languages? Like for example, the ones that run on the JVM, such as Java, Kotlin, Scala, etc.
01:42:51.085 - 01:43:46.945, Speaker A: So I haven't found a use for many other languages than Rust. There are some exceptions, like using JavaScript in the browser. I still use like Bash, like ultimately a lot of. There has to be a lot of infrastructure code in Bash because something needs to run to start your programs and give it arguments and such. There's also, I think, a decent space for things like Python for doing plotting, R for doing data statistics, Python for ML to a great degree still today, Ruby for web development or Python for web development. So there are use cases for other languages. When it comes to the JVM specifically, I think for me it really comes down to whether, and I mentioned this a little bit on the last Q and A stream too.
01:43:46.945 - 01:44:37.741, Speaker A: It becomes particularly relevant if you have legacy code you need to interact with or if there are libraries written in that language that you need to use. So for example, if you're interacting with some hardware device that only has a library from the vendor in C, you might want to use C. If you're writing, I don't know. If you're working at a company and they have all their build infrastructure in Java, then it seems pretty reasonable that if you want to augment that build infrastructure, you probably need to use Java for that. Not necessarily, but. But it's more about having integrations because like all of their, I don't know, SDK stuff is written in Java, then you probably want to use Java too. Unless you want to port the entire SDK.
01:44:37.741 - 01:45:26.219, Speaker A: It more comes down to legacy choices like that. For me, the JVM does have the advantage of that. It runs in a lot of places. So maybe if you want things to just run everywhere, Java is a good target or the JVM is a good target. But in general, I think if you're writing sort of greenfield code, it's rare that I would go for C or anything on the JVM these days. What are your thoughts on writing new Linux kernel modules in Rust? Would the sacrifice of rewriting some parts be worth it? So this is something. I've recently seen some discussion about this actually, that they're working on making it easier to write kernel modules in Rust, and I think it's a really good idea.
01:45:26.219 - 01:46:37.825, Speaker A: I think Drivers in particular is a thing where Rust could potentially help quite a lot. Like you really don't want drivers to crash, and Rust is pretty good at making code not crash. You might have to do some things like provide a bunch of wrapper types. Like, I'm guessing what we will see is sort of kernel module support port libraries that wrap kernel functionality and safe wrappers, and with the hope of having driver code maybe even be completely safe or largely safe. It would be hard to probably make them 100% safe, but I think Rust can certainly provide a lot of value in that space. What was your favorite language before for Rust? I think certainly the language I used the most before, or at least immediately before Rust, was Go. I did a decent amount of work on 6804, the distributed systems class in Go.
01:46:37.825 - 01:47:05.275, Speaker A: The first. My first year in grad school, I worked on a system in Go. And I, to this day, I still like Go. I don't use it, like, I haven't used it in quite a long time. But I don't mind Go as a language. I think there are a bunch of features that I think are missing now that I have experience with Rust. But I think Go is a good language and it's good for many of the things it's being used for, and it's certainly good for large code.
01:47:05.275 - 01:47:36.275, Speaker A: I also, I like Python and I wouldn't want to build large complicated things in it. But I think the reason I like Python is because I can usually guess how to write the code. Python is the language that I can come back to without having written it in like a year and still write code. And it sort of does the right thing. It. It feels very much like pseudocode. And that I think is an advantage when you just want to hack something together quickly.
01:47:36.275 - 01:48:21.565, Speaker A: Like, I use it for building all of the graphs and plots in my thesis because they're good plotting libraries and the code is pretty straightforward to write and I don't need to like have a whole compile infrastructure for it. There's also the advantage that it just like exists on basically every system. The code will just run anywhere and also just there are libraries for almost everything in Python, so it's just like a very low friction environment. I also just really like Bash. I may be weird in this, but I like Bash as a language. I mean it's all sorts of broken and has all these warts and pitfalls for you to fall into, but it's like a very useful language to know. It comes in handy in a surprising number of cases.
01:48:21.565 - 01:49:27.379, Speaker A: Do you have any thoughts About WebAssembly and WASI? Rust seems to be a popular language to target those. Yeah, I mean I talked a little bit about this in the past. I think webassembly is really cool. I think WASI in particular is going to be a big win for interoperability between languages. But I haven't used it much myself and so it's hard for me to say like, yes, it will be the ultimate thing, but certainly what I'm seeing seems very promising and I think Rust is in a very good position compared to many other languages to sort of take the mantle in the Webassembly and WASI space. Opinions on butterfs I used to use butterfs. I stopped using butterfs because I realized that what matters more to me in a file system is whether it's going to lose my files than specifically the speed and the features the butterfs provide.
01:49:27.379 - 01:50:09.231, Speaker A: I didn't really need either of those. And so currently I'm using XD4 just because I feel like I want something that is, I want something that's more as stable as possible when it comes to my file system. Do you have any interest in joining a Rust team? Absolutely. I think that would be really fun. In fact, there was a Before the layoffs and actually before the pandemic, Mozilla announced this position of Rust Community Engineer. And it sounded like exactly what I want to do. But that was before I was looking for work.
01:50:09.231 - 01:50:42.191, Speaker A: And then the pandemic happened. So Mozilla went into a hiring freeze and then I went on the job market. But that position was not available because Mozilla was on a hiring freeze. And then they did all the layoffs and now I assume they're no longer hiring for that role. But that certainly would be really cool for me. I think working with the community in the Ecosystem is something that appeals a lot to me and if I could do that full time, that'd be great. Realistically, I'm fine working at a company, but in the Rust ecosystem and on the Rust ecosystem.
01:50:42.191 - 01:51:34.815, Speaker A: But from the position of a particular company, I think there's some value in that too because you get to see how the language is used somewhere and have that influence and inspire and inform how you work with the ecosystem, what you focus on. I haven't been invited to work on any Rust teams like any of the like core Rust teams, but I totally would if I was offered. Have you considered using Rogaine? I don't know what Rogaine is, so no, perhaps surprisingly. Oh, I can see you working out the Rust Foundation. Yeah, that'd be pretty fun. Go work at Oxide with Steve to teach Rust. All would also be really fun.
01:51:34.815 - 01:52:35.835, Speaker A: I don't know if Oxide is really doing teaching as much as they're doing like low level OS and embedded stuff, but I certainly, if I could work full time on teaching Rust, I don't know whether I would do it. I, I think I, if I was offered like a full time Rust teaching position, I think I would get too like antsy. I need to work on things. Like I need to build things and I guess I would just fill all my spare time with building things. But it helps to have specific use cases like working for a company where there's like a particular problem or set of problems you're trying to solve. I feel like that to a great extent inspires me to do the teaching that I do. Like I can do teaching where the teaching I do is informed by the problems I've run into myself.
01:52:35.835 - 01:53:06.213, Speaker A: What about a paid course? It would be great to do. Like I think it would be really fun to build a course, a Rust course, even if it's free. Like I don't really need to take paid for it. Part of the problem is because I'm in the US on a student visa, there are a lot of things I can't do in this country. It's stupid because if I weren't in the US I could do them in the us but like there are a bunch of things like I can't have a Patreon. That's not a thing I'm allowed to have. And it sucks.
01:53:06.213 - 01:53:52.715, Speaker A: But that's just how the rules work out, which makes things complicated. Sure, I'll. So I've had a bunch of people ask whether my mirror, my webcam is mirrored and yes, it used to be the wrong way around. Like this stuff is behind my right shoulder and it was showing. Well, it is now behind my left shoulder in your view. But it, it means that when I point this way, it points the right way on the screen. So yes, it's mirrored to past dreams, but it's because it made more sense to me for the webcam to be set up this way.
01:53:52.715 - 01:54:57.445, Speaker A: What is the most impactful book you read in your career? I don't know that I could tell you that. There was just one. I think the, the Pragmatic programmer is really good. There's also one called the Art of UNIX Programming that I remember thinking was really good, but I haven't read it in many, many years. But I don't have one that like sticks out as the most impactful one. I do think that I mentioned earlier the code book by Simon Singh and I think that was certainly one that taught me a lot about how cryptography works and how to think about cryptography. That was really like, I remember for many, many years later, just like some of the realizations I had during that reading that book.
01:54:57.445 - 01:55:42.813, Speaker A: Could you explain how it is possible that a program can be mathematically proven to be correct, like in the cases of ADA or coc? So, okay, I'm not the best person to explain this. I have a. It's funny because I have a lab mate who I've tried to convince this person to do a stream on COQ programming and they haven't done it yet. I'm still working on trying to poke them. I think they don't think that there's enough interest in something like COQ to do it. I think there is. I think formal methods is something that a lot of people are curious about.
01:55:42.813 - 01:56:27.673, Speaker A: And finding some way to do, like introductory stuff, I think would be very valuable, but I will try. So the basic idea behind program verification and formal verification of programs is. Well, there are two main approaches to it. One is to use basically a SAT solver. So a SAT solver is a thing like the Z3 is one of the well known ones. Where what it does is basically you give it a set of constraints. Like give me something that is a number that is less than 14 and greater than 10.
01:56:27.673 - 01:57:14.059, Speaker A: You give it to this program, it like runs for a while and then it tells you 12 because that is a number that fits all. That's a thing that fits all the constraints. And then the idea is that when you write your program, you write a set of constraints for your program. So for example, you might say when you run this program, it should Be impossible to reach a state where it crashes. It's like the most trivial correctness guarantee you can give. Like, it should not be possible for this program to crash. And then what the proof assistant will do is basically try to make any path in your program to somewhere it crashes.
01:57:14.059 - 01:57:48.227, Speaker A: Like, imagine you have a like assert somewhere in your program. Like assert true or whatever. Basically what it's going to try to do is make that value false. And it does this by walking your program to anywhere where it might panic and then trying to make the conditions under which it would panic true. And it does this by collecting all of the conditions down to that point, giving them to the SAT solver. And if the solver says, here's a value, then now it has proven that there's a way to get your program to crash. If the SAT solver says there is nothing that meets the constraints.
01:57:48.227 - 01:58:17.365, Speaker A: So, for example, give me something that is a number. It's greater than 10, and it's less than 9. There is no satisfiable solution, and therefore that particular crash cannot happen. So that's one way to go about proving. And this is something that's used by Daphne, I think, is one of the languages that approaches formal verifications this way. The other way to go about this is to basically reason about program behavior. This is a lot more complicated.
01:58:17.365 - 01:59:02.079, Speaker A: It's not something I'm really qualified to speak much about. But the idea is to have a set of axioms so you have some set of facts that you know about the world. Like, you know that if you have an array of length a thousand, then Every index from 0 to 999 is a valid index. It's not a bad example of an axiom, because this is not the form axioms takes. But you have some set of facts you know about the world. Like the Boolean true evaluates to the logical true, the boolean false evaluates to the logical false. And then you encode a bunch of rules based on those axioms.
01:59:02.079 - 01:59:58.279, Speaker A: For example, if you take something that's true, and you do, and with something that's true, you end up with true. And then over time, you build up all these rules, like the rules around boolean logic. You build up sort of higher and higher abstractions over time. And ultimately what happens is when you say something like this index will be in bounds, what it does is basically transform your code into a bunch of logical statements that it can reason about and figure out whether they must be true or whether they could be false. It basically tries to determine whether your program Logically makes sense. And the requirement here is that you have some way to express to the proof assistant how to translate between the program code and some logical framework that it can reason about. And there are many ways to do that.
01:59:58.279 - 02:00:44.565, Speaker A: Some of them are using like post, like pre and post conditions for functions. There's like a lot of depth to this field, but the basic idea is you teach, you have some tools that knows about and that you can teach about the association between the executable code and some higher level logical abstraction that it can reason about. I'm sure there are plenty of things that are wrong about what I said, but that's like the. It's like my mental model of what's going on. How old are you? I am 30 years old. I turned 31 on December 7th. So in theory I will get my PhD before I'm 31, which is my goal.
02:00:44.565 - 02:01:40.887, Speaker A: Let's see here. Are you only looking for Rust based jobs or are you willing to work in Go or Python or some other language? I'm only looking for Rust jobs both because I think that's where my experience and expertise lives. I think you should try to cater to your strengths. I think I can do a lot more good working in the Rust ecosystem, working with the Rust language and the experience I've built up over the years working with Rust than I can if I now started contributing to a Go code base. So that's one of the reasons. The other is that I really enjoy working with Rust and so I want to continue to work with Rust. Now those two things said, I think it's important that you don't say I'm only willing to work on this language.
02:01:40.887 - 02:02:20.015, Speaker A: And the reason for that is usually at any large company there will be parts of the code base that you will interact with that are not written in that language. Like if you go work at Google, lots of the code will be written in C. If you go work at Amazon, lots of the code will be written in Java. And this applies to like basically any company of decent size. The chances that their entire code base is going to be written in Rust or that everything you will ever interact with is going to be written in Rust is fairly low. And so you probably don't want to make it a requirement of you taking a job that the only language you touch is Rust. And I certainly haven't done that.
02:02:20.015 - 02:02:55.555, Speaker A: But I want Rust to be the primary thing that I work with. What was your first programming language? My first programming language was Visual Basic and it was great. I built a minesweeper clone. It was terrible, but that's what I did, realistically. My first language was php. I built some stuff in Visual Basic, but it was all kind of stupid. I built something like batch scripts for Windows, but all just stupid.
02:02:55.555 - 02:03:23.569, Speaker A: The first time I really started building like real programs was with php. I like PHP though. I mean, PHP is bad in so many ways. It's gotten a lot better. But I don't know, there was something just like very straightforward about php, like you just write HTML and you stick some PHP in there and then it just works. There's a lot of Pearl early on too. I like Pearl.
02:03:23.569 - 02:04:27.927, Speaker A: I still use Pearl sometimes. Any thoughts on the creation of the Rust foundation until the end of the year? So I have mixed feelings about a Rust Foundation. I think that there's certainly some value in it. I think it's valuable for Rust to have its own organization and sort of both a place that like money can go, money can flow from a thing, a legal entity that can own things and take responsibilities. I think when it comes to actually like employing developers and having people work on Rust, I think a foundation is probably not where most of those people are going to come from. Realistically, most of the work that will go into Rust, my guess, like on the whole, and the larger scale of things is going to be getting companies to work together to build out Rust and the Rust ecosystem and the Rust language. We need to get companies to invest in the language and they could do that through a foundation.
02:04:27.927 - 02:05:12.595, Speaker A: I think realistically it's unlikely that the foundation will employ enough people to make this work. And I think the more worthwhile take is like, many companies employ engineers to work on Rust and maybe it's coordinated through the Rust foundation or something like that. Yeah. What is the most idiomatic way to parse binary data in Rust? Depends what you mean by binary data. Like NOM works fine for this. Actually. You can also use just like Repr C and typecasting.
02:05:12.595 - 02:05:39.097, Speaker A: You want to be careful there, but it could work. Then you can also use things like the Bit Flags crate, which is really great. My experience has been that like NORM works fine for this. Like I implemented the MySQL binary protocol in Rust and that was a lot of just like bit parsing. And NOM worked fine for that. I know there are other approaches to parsing in Rust as well. I mentioned some of these last stream.
02:05:39.097 - 02:06:43.675, Speaker A: I don't have much experience with them, but it's worth just sorting, like play with a couple of the different libraries and then see which one sort of feels the best when you just start tacking on it and then go with whichever one you prefer the style of. I don't think there's a right answer here. Oh yeah, Be careful with typecasting for making sure you keep track of the allocation. You can use something like the zero copy crate for example, to hand off like the parsed version of the crate of the type and also the backing storage. Rust is being touted as the next C and C. But why is there no big project or platform like Twitter or Facebook or Gmail built on Rust? Is the learning curve productivity being an issue? I actually think there are lots of big projects that are written in Rust. Many of them are not public because many like Rust I think is often used for infrastructure more so than like the immediately public facing products.
02:06:43.675 - 02:07:33.695, Speaker A: But certainly we know from a lot of the, from a lot of the publicly available information that like Amazon is doing lots of Rust things, Google is doing Rust things, Facebook is doing Rust like a lot of Rust things. Discord is doing a lot of rust. NPM is using a lot of Rust. And so I think, I mean Denno is like, it's cool that Deno chose to implement its stuff in Rust, but it's not a mip, it's not a massive effort at the moment. It probably will be. So I, I like reject the premise of the question in a sense that I think there are big projects and big companies that are using Rust. Microsoft of course also is doing a bunch of Rust stuff.
02:07:33.695 - 02:08:29.769, Speaker A: It's funny too because like over my course of like interviewing at various companies, I also learn more about what they do, but I can't technically speak about what they do. But I think everything I said is like publicly available stuff. How to improve Rust compile time? Well, it's a very broad question. So in general for improving Rust compile time, the answer is have fewer dependencies. It depends whether you're doing from scratch builds. If you're doing from scratch builds, then like reduce number of dependencies, have more cores in your computer. If you're talking about building a particular crate, then Rust should be getting fairly fast at that right now.
02:08:29.769 - 02:09:09.975, Speaker A: If it's not, then that's probably because you have one crate that's very large and breaking that crate up into multiple crates might give you some benefits. In general, I've found that Rust compilation has gotten way faster, especially with things like incremental compiles. A lot of the work that's been going on behind the scenes in the compiler with like query based making the compiler Query based. This is like the salsa stuff. A lot of the work that I forget this person's name, they go by like Nether something on Twitter. They've been doing like regular blog posts about improvements to the Rust compiler. That's helped a lot.
02:09:09.975 - 02:10:02.735, Speaker A: It's been a lot of work on parallelizing the compilation of crates using multiple code gen units and llvm. That helps a lot. So I actually haven't found it to be that much of a problem anymore. Also, having things like a shared target directory has helped a decent amount, even just because you avoid compiling dependencies that are shared. But if you really just have one crate that takes a really long time to compile, usually it's either you have a very large crate or you have a lot of generics and macros. If it's the former, break it into multiple crates. If it's the latter, if it's like you have a lot of macros and generics, look at things like cargo bloat and cargo LVM lines, which are good ways to explore just like what generics are.
02:10:02.735 - 02:10:51.389, Speaker A: And potentially macros are significantly increasing the size of your code base, which ends up giving more code to llvm, which makes things slower. Examples of this are like, if you have. So imagine you have an implementation of. Imagine that you use hashmaps a lot, and you use hashmaps with a lot of different key and value types. Then what the compiler will do is instantiate hashmap the implementation of hashmap once for each type of key value pair, which means you end up with multiple copies of the hashmap implementation in your code. So even though you may have very little code, you end up producing a lot of binary code that the compiler then has to deal with. And so this is where crates like, or tools like cargo bloat come in really handy.
02:10:51.389 - 02:11:32.703, Speaker A: Where they tell you, like you have like 17 instantiations of hashmap. Maybe try reducing that and that will increase your compile time. I think endeavors like LVM11 and if we manage to ever get on crane lift, those things would be really cool as well. Do you feel like software has gotten slower with time and people have gotten used to slow software? Hardware has gotten vastly faster, but modern software methodologies do not seem to optimize for it. I think that's certainly true. I think there's been a decent amount of discussion about this over the years too, that software used to be fast, and even though hardware has gotten faster, software is not. I think that's true.
02:11:32.703 - 02:11:59.435, Speaker A: I think to some extent. This is an artifact of integration. We're building software that can do more stuff and therefore it gets slower, it gets less specialized. I think the other thing we've run into is that software today is often very deep. It's very abstracted. It used to be. I think that software was written a lot more from scratch maybe than it is today, and partially is a good thing that we get to reuse.
02:11:59.435 - 02:12:36.815, Speaker A: But then you end up with things like Electron js right where? Or Electron, I guess it's just called today, which is great. A lot of cool things have been built because of Electron. But the big downside of Electron is that now every application has to spin up a web browser. And that is just a lot slower than having a native application and causes a lot more bloat. And so that I think is one of the reasons we see this very often, actually. I found that you can just go in and like benchmark things and try to make them faster. And a lot of people will thank you for it.
02:12:36.815 - 02:13:27.735, Speaker A: Is it common to use immutable data structures in Rust in general or specifically when dealing with concurrency? I haven't done that much. So there's the. There's the IM crate, which provides like immutable data structures in Rust. They're really cool. I haven't seen them used for sort of high performance stuff at the moment or for concurrency for that matter. So I don't think they're particularly commonly used in Rust. I think another point actually to the previous question of why is software slow? One of the other things is that it used to be the processors were getting faster, and that's no longer true nowadays.
02:13:27.735 - 02:13:57.245, Speaker A: What we're ending up with is more cores. And so you need to write software that doesn't just rely on the hardware getting faster, but is able to utilize more cores. And in general, we're pretty bad at writing good concurrent software where its performance increases with the number of cores. Often what you see is like a trend like this where going from one to two cores helps a lot. Going from two to like 32 cores does not help that much. And that's unfortunate. And so that's certainly another place where this comes from.
02:13:57.245 - 02:14:54.385, Speaker A: The other is a general misunderstanding of how performance optimization should work. I highly recommend that you look at the. There was a paper a few years ago called Cause Coz, which is the causal profiler, which looks at how can we. How can we figure out how to make a program faster using a profiler that doesn't just rely on sampling profiles because it turns out they can often be misleading. And the author of that paper actually had some really good presentational arguments about why the current way we're doing profiling is often really bad. There's also just, I think, a general misunderstanding of how the hardware works and what we should optimize for. For example, very often the reason why applications today are slow is because of things like CPU cache misses and the latency of going to memory.
02:14:54.385 - 02:15:40.205, Speaker A: And optimizing for that I think is very valuable. But it's something that many developers just are not aware of, how that works. There was a talk on YouTube, Modern Hardware Optimization. Let's see if I can find this. Yeah, there's a video called A Crash Course in Modern Hardware by Cliff Click. That was a really interesting talk that goes through some of the. Just like some of the ways in which the ways we optimize applications need to change because the hardware has changed where different things now matter.
02:15:40.205 - 02:16:26.565, Speaker A: Do you know the interplanetary file system? If yes, what is your opinion on it? I only know very briefly what it's about. I think IPFS is maybe interesting, unlikely to matter. But that's my very naive take. I just like have little, I generally believe little in this like super distributed world. I think very often it falls apart when it comes to actual economy. And that's where things fall apart. All right, let's do another like two questions maybe.
02:16:26.565 - 02:17:10.995, Speaker A: So here's what I'll do. I'll drink some water. So, and then what we'll do is go, go to the link that has all the Q and A, look through the questions, maybe look through the top questions and vote on the ones that you want to hear the answer to. And then I'll take like in a minute or so I'll then look at the next top two or three questions maybe, because currently these are fairly low votes, so not that many people care about them. So if you look at chat, someone just posted a link to the place where you can ask questions. If you click that and then click ask a Question, it lists all the questions that people have currently asked. Like sort it maybe by the most number of votes and then vote for the ones that you want to hear the answer to.
02:17:10.995 - 02:17:58.779, Speaker A: Because that way I'll actually be addressing questions that many people care about. It's funny, every time someone votes for a question, a little like loading icon appears on my screen. Which like is good but. And someone asks a question that just says okay, which is not a question, but I appreciate the spirit. It's weird, like almost my entire apartment is in boxes at the moment. And my plan is actually to pack this computer the moment the stream finishes. Like take apart all the components and pack them.
02:17:58.779 - 02:18:11.185, Speaker A: It's weird. It's kind of sad. Oh, put the transition screen. I could do that. That's. I can just, just demo it. But I feel like I need like intermission music.
02:18:11.185 - 02:18:28.141, Speaker A: Click. Done. And then I'm back. Wait, that's the wrong one. This one. I think this should now show my face. I think I feel like I need like keycaps.
02:18:28.141 - 02:19:02.355, Speaker A: I have this like little numpad that I'm using to do scene transitions and feel like I need labels for them so that I don't keep pressing the wrong one. All right, I'm gonna go ahead and go to the next. More and more people are uploading the question that just says okay, which seems like. I mean, I guess that is a good question. I am. Okay, thank you. All right, let's go to the next one.
02:19:02.355 - 02:20:00.443, Speaker A: Do you think Webassembly will become a universal platform targeting a. Do you think webassembly will become a universal library targeting platform like Webassembly can also be used in Python, not just js why stop here? I think it has the potential to be. I think the. I think webassembly has the potential to become the next way to do ffi. And one of the reasons why it's particularly attractive is that it doesn't require that you share a memory space. In particular, you can basically do sandboxing through webassembly, which is much harder with something like direct ffi. I would say in particular the efforts around wasi, which is like the standard for how to describe interfaces over webassembly is going to make a huge difference here.
02:20:00.443 - 02:20:52.221, Speaker A: And I know that parts like some pretty core Rust people are involved with that effort and I think that's. We're going to see that pay off a lot as it comes to Rust position in that space. Do you think that Rust's static linking of crates will harm app? Especially in fine crafted Linux distros with specific dynamic libraries. So Rust doing static linking is definitely something that is. It's a mixed bag. This is something that go does as well. And it's tricky, right, because statically linking against libraries is really unfortunate because it means that you can't upgrade.
02:20:52.221 - 02:21:44.285, Speaker A: Like if I have like let's take the example of open ssl, right, where a lot of applications link to. On Linux, If I upgrade OpenSSL on my system, all of the applications that are dynamically linked automatically get that upgrade because they're dynamically linking with it. So the moment I launch it, it'll link with whatever the latest version of OpenSSL that is available is. Whereas in Rust, because everything is statically compiled, I the binary I have comes with the version of the equivalent of Open Sling would be the equivalent that I compiled it with when I compiled the binary. This means that there's no system wide update that can like update all of my binaries at once. And that is unfortunate. But it also means that the binaries run a lot more smoothly, you have fewer runtime dependencies.
02:21:44.285 - 02:22:23.903, Speaker A: It's a tricky trade off. One of the I would really like to see Rust doing more dynamic linking. I think if you have a library that you could dynamically link with, that's something that would be good to make easier. I think the biggest roadblock here is that there isn't currently a good way to do dynamic linking with generics. There was an interesting article on this. Let me see if I can dig that up. Ross Dynamic linking Swift this one.
02:22:23.903 - 02:23:26.165, Speaker A: I think it's a pretty long article. I know you can't see my screen, but it's by Alexis Bangusner on how Swift achieved dynamic linking where Rust couldn't. It is this one, and it was actually a really good exploration of why dynamic linking is hard in Rust, why it's hard in Swift too, but why Rust doesn't have it and why the path to getting it might be pretty hard. And without that, dynamic linking in Rust becomes just really challenging because it means that your APIs can't be generic, which is pretty unfortunate. Do you think it's important for us to have a stable abi? Great. So it's basically the same question. I think it would be really valuable for us to have a stable ABI precisely because you could do things like dynamic dispatch or not dynamic dispatch dynamic linking a lot more easily.
02:23:26.165 - 02:24:20.405, Speaker A: I think that would be fantastic. I think there are some pretty serious roadblocks to getting that to work and I don't have the answer. I would like to have it. I don't know how we get it, I think is the real answer. I do think there's value in Rust having a stable ABI even without generics, but I think ultimately it's going to be sort of a package deal where either Rust is able to provide a fully stable ABI that includes generics, or the stable ABI is just going to be ffi, which like FFI is valuable too. And I think it would be good for more Rust libraries to present ABI so that other languages could use them directly or so that we can even get dynamic linking. But it's just like the benefits of having generics directly in the interface are so large that it's a tricky trade off.
02:24:20.405 - 02:25:23.523, Speaker A: Do two more Are we living in a simulation? I don't think that it's reasonable to assume that we do, but at the same time, who knows? Have you tried the Crane Lift backend for Rust? C I have not tried Crane Lift. I think Crane Lift is really cool. It's a really cool effort to. For those of you who don't know, it's basically trying to switch out LLVM with a completely Rust built backend for compiling Rust code all the way down to machine code. I should say to. Yeah, to machine code. And one of the reasons why you want to do this is it gives you a little bit more power for doing things like optimizations.
02:25:23.523 - 02:25:53.339, Speaker A: It also means that you get to run Rust. You don't have to rely on all of llvm. It also means you can use Rust to make that part of the compilation process safer, potentially more efficient. Like you could use tools like Rayon to safely get concurrency even in that layer of the stack. But of course it's a monumental effort. It is cool that with Rust, at least in theory, it's possible to just swap out the code generation backend. In practice, I think we're pretty far away from seeing that being a reality.
02:25:53.339 - 02:26:53.765, Speaker A: But it would be really cool. All right, last question. What do you think about the current political climate in the us? Have you considered not staying in the US long term? And if so, which countries are you considering? All right, so clearly not a short question, but I think this is something I covered decently previously in the stream, so I won't go over it too much again. I think when it comes to the current political climate, the US is currently a shitstorm. I think most of the world thinks that the US is royally screwing things up and I don't think that's good for anyone, least of all for the U.S. i think the U.S. is really shooting itself in the foot and I think part of the problem we're running into here is like the long term effects of this remain to be seen.
02:26:53.765 - 02:27:43.317, Speaker A: Like one thing is the short term effects of like you can't travel from the US to Europe, the sort of economic downturn and all the suffering that people are experiencing. But I think there's a long term effect too of like the US being, I guess mismanaged is a word for it. And this is the same thing that happened to the UK because of Brexit. You end up in a position where people are much more hesitant to come here, to work here, to stay here. More people want to leave to go seek their sort of opportunities elsewhere. And that ends up having this sort of roll on effect where imagine that fewer people end up applying to US universities. This means that they go elsewhere, which means that that talent is being developed in other countries.
02:27:43.317 - 02:28:50.815, Speaker A: This means that the US university system starts to fall behind because much of the talent is not coming here. This means that in the next cycle there'll be fewer talented students to become professors, to become teachers, to become the people who start companies. This means that the US starts falling further behind and those the people who would have done those things in the US do those things elsewhere instead. And now those cooler companies start in those countries instead with those people where they chose to go instead of the US or the uk. And so now talent is going to be drawn away from the US to where those places now are being established. And so I think there's like this huge chain of events that come from just mismanaging a community, which is really what every country is that I think we haven't even seen the start of yet. I think in the short term there's also pretty severe effects which are disturbing to watch in real time and I think historically will be disturbing to look back on as well.
02:28:50.815 - 02:29:35.157, Speaker A: So yeah, this was my attempt to briefly answer my thoughts on the current political climate in the US which is such a question to end on. But I think we did pretty well. I think this is good. I think we're gonna end there. It's been fun having all of you, both the people who are in stream and the people who are watching the recording after the fact. It's been fun like up through the years to like be able to stream for all of you. Like it's become such a big part of my life and it's exciting that I could have all of you with me and it'll be weird to like this is the place where we started streaming.
02:29:35.157 - 02:29:53.181, Speaker A: It's not just me, right? It wouldn't be the same with all of you without it wouldn't be the same without all of you. And it wouldn't be the same without this apartment. Like this is where it all started. But I think it would be great wherever it goes next. And I'm excited to see you all there. Bye everyone, for the last time. Bye.
02:29:53.181 - 02:29:56.285, Speaker A: From. Bye. From Cambridge, Massachusetts.
