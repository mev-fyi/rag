00:00:00.240 - 00:00:45.165, Speaker A: Everyone, welcome back. It's the first stream of 2020 and this is going to be probably the last stream on porting the concurrent hash map from Java to Rust. This will be part three, I think, and we did part two about a month ago. So I'm going to spend a little bit of time like walking through where we left off last time so that we're all on board and with what we're going to do this stream. For those of you who don't know me, if so it's a little weird that you're in part three. You should probably start at part one. I am John, I'm a PhD student at MIT and I do a bunch of these live streams where we try to build like write real Rust code that does interesting stuff and really get into Weeds and program something complicated.
00:00:45.165 - 00:02:07.055, Speaker A: If you want to support me, I have an Amazon wishlist where you can get me stuff that I need in my life or want in my life, I guess the code for part one and part two is already up on GitHub and I'll push the changes that we make today as well to here afterwards. Hopefully by the time we finish today, this page will be a lot more helpful. My guess is in addition to doing things like writing tests, we're also going to expand upon the readme, write some decent documentation, maybe set up CI a bit of the sort of more meta stuff for projects. The Java code I think I've linked to in past streams, but the Java code reporting is available online under a sort of weird license, but one that allows us to publish a port with the same license, at least as far as I'm aware. If you know otherwise, please tell me. And the Java test suite is also online and so all these files I've linked from the repository, so if you look down here, the source file is linked here from the GitHub repository and also the tests are linked right here. Before we, before we dive in, one thing you should know is also that this will probably be the last stream for a little while.
00:02:07.055 - 00:02:40.281, Speaker A: My plan is to graduate sometime the end of this year, as in like somewhere in the September to December range. And so I need to like actually sit down and do that. So I don't know how much time I'll have to do streams in like the coming months. I'll try to get in like maybe a few more in 2020, but I don't know when they'll be just so you're prepared for that. I am not planning to stop though. Like, I think this is really Fun. I think it's interesting to build stuff in this way.
00:02:40.281 - 00:03:11.603, Speaker A: And so yeah, even though there might be a bit of a hiatus, the plan is to keep going. All right, so let's dig into the code. I think that should be large enough for everyone to see. So the code we had last time where we. Let's make that a little bit smaller. If it's more on screen, that's probably good. It's a pretty straightforward port of the Java code.
00:03:11.603 - 00:04:08.581, Speaker A: The trickiest part you'll remember from part two is dealing with all the safety guarantees and dealing with garbage collection. While we did the implementation, we left a couple of to DOS for ourselves that we might deal with in this stream. Things that I marked as to do here are things that aren't necessary in order to have a working environment implementation. But there are things that we will want to fix before like not just a 1.0 release, but before like a public release. Like either because there's safety guarantees that we need to really write down the explanation for, or there are API changes that we really want to get to. So for example, the get method for this hashmap currently returns you this shared type that you might remember from Crossbeam and it's a little awkward for this to be exposed in the public interface.
00:04:08.581 - 00:05:07.225, Speaker A: It also means that if we say upgrade the version of Crossbeam to a semver incompatible version, then that will also require us to update the major version of this library because we directly expose one of their types. And so that's a little awkward and we probably want to mask this at the very least behind a new type, but maybe something more than that. So one way to do that for example would be to stick, if you recall with these shared you need this notion of a guard and that is why this currently takes a guard in. One option here is for get to construct the guard itself and then for us to wrap that in some kind of return guard type. This is something we can think about a little bit later. Let's look at what other to do's we have. Yes, we did not implement the Java version has this notion of upgrading if you have a.
00:05:07.225 - 00:05:48.367, Speaker A: If you have a bucket that gets very long, right? For us the buckets are linked lists. Then if the bucket gets very long, it gets converted into a tree and that's an optimization that we have not implemented. But it's something that you'd probably want to add but. But it's something that is entirely behind the scenes and so it's not something that end users will notice except. Except in terms of performance, let's see, what else do we have that's a to do this ordering can maybe be relaxed. Okay, that's somewhere we're going to leave for later. Treeify.
00:05:48.367 - 00:06:18.975, Speaker A: That's if you notice you want to turn something into a tree, we can ignore that for later. So add count. This is used for whenever you add or remove items from the map. Then add count is used both to keep track of the number of elements in the table, but also in order to figure out whether we need to do resizes of the table. Right. To grow it. In particular, I don't think there's a shrink that's supported.
00:06:18.975 - 00:07:24.515, Speaker A: And the Java version does not just use like an atomic integer for this. It uses this notion of a counter cell, which as far as I could understand it, we'll have to go back and look at earlier streams. Counter cell is essentially like a sharded counter. And the reason you want to do this is if you have just one integer that, like one memory location that holds a number that all the writer threads are going to be adding to, then you create a lot of contention on that one number. And it's, it's not really. It might turn into a scalability bottleneck, right? Because if every write has to go through that one number, then barring some kind of like concurrent optimizations made by the CPU because it notices that they're all ads or something, it could become a point of contention and something that reduces the performance in highly concurrent scenarios. And so if you have a sharded counter instead, you might have, for example, one counter per core, then when you increment it, there's no cost.
00:07:24.515 - 00:08:05.503, Speaker A: It's only when you have to read the value of all of them that you have to pay that cost. And the original Java code has a bunch of code for dealing with that situation. And here we've simplified it into just having a single integer counter because it was just easier. And this in some sense comes back to the old adage of like, you don't want to do premature optimization. Right? The counter cell business is an optimization, and I don't think it's premature into the Java code. I think it wouldn't have been added unless they found that it was useful in real world scenarios. But for us, when we first port this, we should start with the simpler version and then we can add the optimizations later.
00:08:05.503 - 00:09:05.715, Speaker A: Like this might make for good PRs down the line. Given that this code is a little different from the Java code, this is one place I suspect there might be bugs Right. Because much of the other code is almost like a direct transcription of the Java code into Rust, whereas this code is not. Right. This code is different. What other to DOS do we have? Yeah, so this you'll remember in the, in the concurrent hash map, if there's a resize, then the way the Java version does this, and this is pretty cool, is if a thread tries to do an insert and it notices that the table is being resized, it joins in the resize effort. Right? It joins the thread that is currently doing the resize in helping it with resize.
00:09:05.715 - 00:09:49.771, Speaker A: And the reason this can work is when you allocate a new table that's sort of twice as large and it's twice as many buckets, you need to move all the elements from the old table to the new table. And each bin can basically be moved independently. And so you can have multiple threads that are assisting with the resize. And there's this size ctl, so size control field that's atomically updated and managed in order to keep track of like how many threads are doing what work. And this is one clause where for some reason it like adds two. And I don't know why this is. So this is something that I think we'll want to look at why this code does what it is.
00:09:49.771 - 00:10:24.305, Speaker A: Like figure out why this is an RS +2. And I think we spent a little bit of time thinking about this last time, but it's something where once we figure it out, we should probably add a comment. This is one thing where the Java code. Let me pull that up here actually. How about we do. Yeah, this is one place where the Java code is not graded comments. So the Java code has a lot of top level comments for how the thing works, but it doesn't really dive into.
00:10:24.305 - 00:11:15.325, Speaker A: See if I can find this here. Talks a lot about the representation, but it doesn't necessarily talk about all of the different fields. Like for example, when we get down to it talks a little bit about this, but in the place where it does, like RS+2, this place, there aren't any comments that explain this code. Right. Even though there's an explanation for what PSYCTL is, this code is not very well explained. And so I think once we figure that out, it would be good to update the documentation here. And we've tried to do that as we've been doing the port.
00:11:15.325 - 00:11:45.613, Speaker A: You'll notice as I scroll through here as well, a bunch of the safety arguments that we made last time. We looked for all the blocks where we needed to Write unsafe. And we documented why we believe that they're safe. And this is also something that the Java code does not have, in part because there's no notion of unsafe in Java. Even though they do, they sort of assume that certain pointers are valid. And here in Rust, of course, we have to. We have to use unsafe to basically tell the compiler we promise that this is safe.
00:11:45.613 - 00:12:43.697, Speaker A: And alongside any such unsafe block, it's sort of good practice to document. Why do we believe that this is safe? I think even there's a clippy lint, I think that requires there to be a safety explanation above every unsafe. But I haven't used it myself. I just learned about it recently. Yeah, so this is essentially if you have many threads helping to do a resize, currently we just sort of hard code how many. Let's say you have four threads, right? They need to know how many bins to skip when they have to pick the next bin that they're going to move. And this is something that really should depend on the number of CPUs, like, there's no reason to have more threads helping with the resize than you have CPUs, for example.
00:12:43.697 - 00:13:03.745, Speaker A: And here's something where we also just like, don't deal with that currently, but it should be easy to add. Okay, I think that's all the to dos. And then we left one. Fix me two. Fix me. Oh, I remember this one. Okay, so this is a somewhat complicated safety argument.
00:13:03.745 - 00:13:58.845, Speaker A: And here there's a particular case where we couldn't quite figure out what the argument was for, why it was safe. The Java code assumes that it's safe, and so in some sense we have it on good authority that it is safe. But if we want to stick to this notion of giving the safety guarantees explicitly, we should finish this paragraph for why exactly this is safe. And the other fix me, which is where we left off last time, is starting to write tests for this map. And so that is actually where we're going to start today is write a test that creates a map and does nothing with it, and write a test that creates a map, inserts into it and tries to read from it. And these might seem like simple tests, and it might be that they work like the first time we try them. It seems somewhat unlikely, but we should try it, and we're about to find out.
00:13:58.845 - 00:14:34.393, Speaker A: Let's look at. Did we actually add a test directory? No, we did not. I thought we did, but I guess maybe I was wrong. All right, so the first thing we have to choose is whether we're going to write these as unit tests or write them in the same directory or same like basically within the crate itself or whether we're going to have a separate sort of test directory. I like to do the latter. Unit tests are best for testing things that are internal, only that you can't access through the normal APIs. So we might end up adding some of these eventually.
00:14:34.393 - 00:15:25.791, Speaker A: But I think for the time being what we want to add are our integration tests. So I'm going to do make their tests here and then we're going to say tests. Let's call it just basic. The reason I call it Basic here is because we probably want different testing modules for different things. So for example, I'm going to assume that we're going to have one test file for all of the Java test cases. In fact, I think there are multiple even this is going to be a little bright for those of you who are in dark rooms. Yeah.
00:15:25.791 - 00:16:51.987, Speaker A: So here the Java concurrent hashmap comes with a bunch of tests and all of these we probably want to port into the Rust version. I wonder if there's a just like a straightforward what's map check? Interesting. All these look like they're interesting new map. These look like relatively basic tests, but I want something that first of all, I want to keep all the ported tests in their own files. This will make it easier to like if imagine that the Java authors add more tests to these, it'll be easier to keep the Java ones and the Rust ones up to speed because they'll sort of map one to one in the files. But also I want some tests that are just like completely dumb and are just like I'm thinking things like new. Right.
00:16:51.987 - 00:17:40.289, Speaker A: I want to see that new doesn't panic. And here of course we're going to do use Flurry Star just because it's handy in the test. And let's look at in source lib what is the name of our type? Flurry hashmap map Is Flurry hash map new? Do we even have a new. Do we have a default? Okay, so we don't currently have a way of constructing a new Flurry hash map. So that sounds like something we need to fix maybe first. So let's do pub fn new self and in fact this is a good question. We don't even necessarily know how you create a new one of these because we didn't implement the new method.
00:17:40.289 - 00:18:52.915, Speaker A: And if you look at it like there are a bunch of fields here that need to have sensible default values. All right, so let's look at. I wonder if it's called what's the constructor called in Java? I forget how constructor let's read object. Oh, it just called the name the same as the. I think it's just called the same as the type new empty map with default initial table size. All right, so you'll notice they have a bunch of different constructors here and they all seem to call to this one. Uh huh, I see.
00:18:52.915 - 00:19:38.955, Speaker A: So there's sort of a default you have to have with a default initial table size. Okay, how is that initiated? I guess for each field there's probably a default value. Then let's look at a feel like size ctl. Interesting. It doesn't actually say anywhere what the default value. Maybe the default value there is just zero. Forget about the M.
00:19:38.955 - 00:21:09.973, Speaker A: Yeah, maybe these really are just default. Interesting because it looks like the default constructor here doesn't change any of the fields which presumably just means that they are their default value. But then where does the 16 come from? Let's look for 16 default capacity. Okay, so where is default capacity used init table? Well, initable seems pretty promising. Okay, where does initable called? Oh, you know what, I think it actually just sets it to null and then insert is the thing that actually initializes the table. So this is why the, this is why the constructor is empty because it doesn't actually have to do anything because insert will already do the creation of the map for us. All right, so let's look at what new is going to look like.
00:21:09.973 - 00:22:16.163, Speaker A: It's going to be sort of self and then we're going to have I guess table which then I suppose might just be null. Like maybe the intention here is we set all of these to null. We set count to be atomic usize new transfer index just defaults to zero I guess. So this is going to be zero transfer index is going to be zero size CTL is going to be zero. Ah, and build hasher. Right. So here we actually need to take here we need to take out of the book for the rust hash map.
00:22:16.163 - 00:23:24.573, Speaker A: Well you notice if we do this new is implemented on so notice that the map itself is generic over KV and S where S defaults to random state. And you'll notice that new is only implemented for S as random state. And what is S here? Well remember that we need to have a way we need to be able to choose how to hash keys into bucket indexes. Right? So you need some kind of hashing scheme and random state. If we look at it over here, random state is a thing that constructs a hasher that has a random initial state. So this means that all any given key is going to initialize is going to hash to the same value. But if you have two different random states and you hash the same value, the same key, you might get different hashes, but within each one they'll remain consistent over time.
00:23:24.573 - 00:24:12.297, Speaker A: The reason for this is to provide sort of resistance to adversarial choices of keys. There's a lot more you can read about this for now. Just think of this as one way to initialize a hasher and a sort of secure, secure way to initialize a hashtag. No sizeCTL has to be isize because it can be negative. But specifically you'll notice that hashmap new is only implemented when the S is random state. And then you'll see that for the generic S then it's a with hasher method that actually takes the S you want to use. And I believe we also set ours to be S equals random state.
00:24:12.297 - 00:25:19.045, Speaker A: So we're in essentially the same position as a standard map where we want to allow the user to provide their own hasher should they so choose. But for the new method we actually want to say just the same as for the standard one where this is going to be random state and then it's not going to be generic over S and in that case build hasher is going to be random state new and in theory now this should work. Let's just try to compile and see what happens. We get a number of. What is this? 4, 2, 7. I guess there's some. Why do we have this, I wonder? Oh, we don't currently use the resize hint for anything.
00:25:19.045 - 00:26:19.455, Speaker A: So here I guess we'll do use the resize hint. This is something the Java code uses to be smart smarter about when and how it does resizes and it's something we didn't implement and so I just want just going to silence that warning. And load factor is also a to do actually use the load factor. Actually let's look at how does the load factor used here it's used in read object, write object and in the default constructor. I wonder why that's even there. Load factor. It's this thing.
00:26:19.455 - 00:26:52.883, Speaker A: All right, so what is load factor used for here it's used to set the number of buckets. Okay. So this is if the user says what capacity they want us to support. Right. So hash maps generally have this constructor that's called with capacity. If the user gives that Then in order to support that number of elements, our table actually needs to be a little bit larger than that because we want to resize. We want to resize once we reach a certain load factor.
00:26:52.883 - 00:27:39.025, Speaker A: The reason for this is at some load factor you end up with too many keys that hash to the same bucket, even though not every bucket is full. And so that's where this comes in. So it's actually correct that this one is not currently used because it will only be used to compute what the size up we use should be. All right, so I guess that means that we'll do here, just for our own sanity's sake, we'll do a with capacity N. Right. So this is the same thing that the standard library has. And what does that actually do? Well, it.
00:27:39.025 - 00:28:36.179, Speaker A: And we're not going to allow concurrency level to be set. So what does the thing that just takes capacity concurrency level of one. Okay, so we'll just blindly copy what they do. Right. And so there's like an assertion here that, that the N is greater than zero, which I guess is really a assert ne. If initial capacity is less than concurrency level, initial capacity here is the number that they pass in concurrency level is going to be one because we don't let the user set it for now. And the initial capacity can't be zero.
00:28:36.179 - 00:29:55.225, Speaker A: So this condition can never be met. So it's really going to be these. So really what's going to happen here is we're going to create the map using new and then we're computing, we're computing here 1.0 plus the initial capacity divided by the load factor where this is really a SF 64 and this whole thing as eyesize probably you size. And then the cap is going to be if the size. If the size is greater than the maximum capacity, then we limit it to maximum capacity. Otherwise we do this table size four and then we say M sizectl is equal to that cap and then we return M.
00:29:55.225 - 00:31:32.573, Speaker A: What does table size 4 do? Do we already have this table size 4? No. If the n is equal to 0, should you return error rather than assert? That's a good question. My thinking here is it's really annoying for with capacity to take a to return a result just for the one case where n is 0, I would probably instead just document that with capacity with the value provided to with capacity must be at least zero or it will panic. It would be totally. It would be a legitimate choice to make the return type a result. In this particular case, I think it's probably overkill okay, so what does table size 4 do? Returns a power of 2 table size for the desired given desired capacity. Oh really? Is this really just next power of two? Why is it not called that then? Section 3.
00:31:32.573 - 00:31:49.185, Speaker A: Do you actually have to buy it? I have this book, actually. I have this book right here. Hackers Delight. Hacker's Delight. Let's see, section three. So Hacker's Delight is a. It's an interesting book.
00:31:49.185 - 00:32:58.485, Speaker A: It's. It's basically got all these neat weird tricks. You can pull 32 rounding up or down to the next power of 2. Let's see what they say. Uh huh huh. Minus 1 left shifted by number of leading zeros of n minus 1. Okay, that looks like the next power of 2, but it's computing it like with.
00:32:58.485 - 00:33:53.185, Speaker A: Yeah. And then it's capping it at maximum capacity. Okay, so in that case, instead of doing all of that stuff, we are just going to do size next power of two, which I believe is in the sender library. The smallest power to greater than or equal to self. Yep. Great. And let's just make a note here.
00:33:53.185 - 00:34:46.945, Speaker A: This is table size 4 in Java. Just for our own sanity sake. And now we should no longer have the warning about load factor because we actually use it. All right, let's see what next? Unused import build hasher. Okay, so there are a couple of things here. First, this has to be an atomic isize new and I guess it's going to be as isize. Something about this build hasher that's not quite right.
00:34:46.945 - 00:35:45.703, Speaker A: 145. Ah, that's not at all what I intended to do. What I intended to do was just to have that impl block be there for the new methods and then this be for any S where S is build hasher. Let's see how it feels about that. Self.hash 152. Is that.
00:35:45.703 - 00:36:38.275, Speaker A: Didn't we make a function for this hash thing? What is our get to. Wait, did I just delete a bunch of code that I did not intend to delete? Where's our get function? I definitely deleted a bunch of code I did not intend to delete. Okay, let's undo that terrible change of mine. Let's bring get and friends back. Yeah, I don't know how I ended up deleting those. There we go. That's more like it.
00:36:38.275 - 00:37:49.369, Speaker A: Yeah, I somehow just deleted the entire top chunk of this block. That's not what I intended to do. Next power of two could be greater than maximum capacity. You are entirely right. In fact, why does it check it before Checking the capacity to. I feel like the right thing to do here is actually let size is size next power of two and then say I feel like that's really. That's really what it's trying to compute, right? Yeah, I think.
00:37:49.369 - 00:38:06.455, Speaker A: I think that's actually what it's trying to compute. Let's try that. Cannot infer type for type parameter K. That is true. We haven't said what the type of our thing is here. So let's say this is going to be over. It's going to be from string to string.
00:38:06.455 - 00:38:30.355, Speaker A: Or maybe it's just going to be from. Sure, from string to string. That seems it's going to complain about lifetimes. It's going to be from usize to usize. Ah, great, it crashed. Oh, and it's complaining about this. That's fine.
00:38:30.355 - 00:38:54.665, Speaker A: Okay, we have our very first test and it fails. Great. So we actually have something to do. This stream, it does not just immediately work converting a null shared into owned. That seems bad. I want these to go away in the next nightly. Maybe I should switch to nightly.
00:38:54.665 - 00:39:44.225, Speaker A: They fixed so that panics would start here as opposed to at the begin panic business when you do unwrap and stuff. All right, so let's look at this. Where does this happen in drop in 79 2? Oh, I know why this is. If we never put into the table, we never allocate a table. And because we never allocate a table, there's nothing here for us to adopt. It's right. It's just going to be dropped.
00:39:44.225 - 00:40:21.195, Speaker A: So I think actually let's look at what. Oh, there's no destructor in the Java version. In Java the destructor is just the default. I assume is not a destructor. Is it like Tilde or something? I forget. I guess not. So for us, what we actually want to do here is if table is null, then we just want to return.
00:40:21.195 - 00:40:55.133, Speaker A: Table was never used. Was never allocated I guess. Okay, so our first test passes. It's perhaps entirely unsurprising because all this test does is it creates a new map and then drops. It doesn't actually do any operations on it, but it does mean that we have a passing test. That's always a good place to start. Now let's see again.
00:40:55.133 - 00:41:43.725, Speaker A: This is sort of the set of basic tests, right? We're going to do map.insert is it put that it's called here? Oh no, yeah, we have an insert map dot insert and we're going to insert 42 and 0 and we're going to unwrap. We're going to. No, it's not an unwrap. This returns whether or not there was an old value. So let's just. I guess we can do old and then we want to assert old is none.
00:41:43.725 - 00:42:19.655, Speaker A: What would happen if you insert and then remove the element? Then we would do an allocation. Right? If you insert something, then that's going to allocate the first sort of set of bins. And then when you remove it, the bins are still going to be there. It doesn't eagerly deallocate. Okay, let's see if just a straight up insert works. It does not crashes converting zero into owned. Okay, that seems like not something we want to do.
00:42:19.655 - 00:43:07.115, Speaker A: Where does this crash? This crash is also in drop at 803. It also crashes in drop, which is interesting. See, notice that this code is. This code is not in the Java code. Right? This is code that we ported ourselves or that we wrote ourselves in order to deallocate. And one thing we didn't account for here is that, remember how in. In the Java world or in the concurrent hash map, it lazily allocates things, including bins, and so each bin can actually be null.
00:43:07.115 - 00:43:32.561, Speaker A: And that's something we didn't take care of here. So if bin is null, then continue. Bin was never used. One thing that's worth noting here is the fact that we panicked. And drop means that we did not panic in the insert. The insert actually. Well, the insert code ran.
00:43:32.561 - 00:44:20.725, Speaker A: I can't guarantee that it did the right thing. Okay, how about that? Oh, oh, interesting. I see. So we actually need to, I guess, load it. It's a little wasteful because we know that we own it. Isn't there a method for doing that? Well, it's intoowned, I guess, but intoowned fails if the thing is null. So I'm a little surprised that.
00:44:20.725 - 00:44:55.489, Speaker A: Let's do crossbeam. Let's look at crossbeam here for epic. So we have an atomic. What can we do about that? We really just need to do a load. That's fine. Okay, so we're just going to check whether that bin is null. All right, so what this means is we successfully created a map, allocated the map.
00:44:55.489 - 00:45:19.425, Speaker A: Right, because that's the first thing insert will do is allocate the map and then do the insert and then drop the map. And none of that panicked. Right. Let's just. Let's just run this a few times just to see that it doesn't like not an obviously broken one. Okay, So I mean, there's only one thread here, so it'd be very surprising if this was racy, but it's worth testing. Okay, this seems fine.
00:45:19.425 - 00:45:50.635, Speaker A: And now get empty. Now what we're going to do is we're going to do a get of, let's say, 42. And remember that currently our get API is such that you have to provide a guard. This is something that we want to change, but we haven't changed yet. Crossbeam. Epic. I forget, is it just here? Pin? Yeah.
00:45:50.635 - 00:46:45.381, Speaker A: So we need to do let guard is epic. Pin map, get the guard, and then we want to assert that E is none. Right? So notice that this. It's a little awkward to have to do this for every time you want to do a get. There are reasons to enable this API, which is if you know that you're going to do multiple gets, you might only want to use one guard because pinning the guards does involve some atomic operations. And in particular, whenever you release the guard, you might have to collect some garbage. And so there's an argument for still exposing this API for things like batch operations, but that's something we think about later.
00:46:45.381 - 00:47:45.295, Speaker A: But in particular here we just want to check that if we do a get on an empty map, it actually it doesn't crash, basically. So let's see what that does. Okay, that works great. So get can correctly handle an empty map. That seems promising. All right, now for the big daddy of basic tests, which is insert and get. What do we think? What do we think here? How's this gonna work? We're just gonna do map, dot insert and then we're gonna assert, and then we're gonna do dot unwrap and then we're gonna assert equal E and 0.
00:47:45.295 - 00:48:20.925, Speaker A: Now, this won't quite be right because this is going to return us a shared right? This is again because we don't have this guard API. This gives us sort of a reference to the value, but because it's a concurrent map, it's not just like a reference to V where V is the value type. Instead, it's sort of a wrapper around that reference to keep track of things like garbage. And so we can't quite do this. This will probably have to be a. Like an unsafe deref. This is another reason why we want that API to be better.
00:48:20.925 - 00:48:53.905, Speaker A: The reason this is unsafe is because we need to. The unsafe here implies. And we could write this here, safety. The map guarantees that it will not free something. There is a shared too, right? Yet another reason why this API is just not great. And we'll Want some additional wrappers? Do you really need to make the map mutable? No, you're right, I do not. Because it's concurrent.
00:48:53.905 - 00:49:41.105, Speaker A: Yep, exactly. So this is an important observation. One of the reasons you can't use a normal hash map in a concurrent context is because in a concurrent context you have multiple threads that all have pointers to the map through an arc or whatever, which means that they have shared references. They don't have a mute reference, they just have a regular reference. And the HashMap API for things like insert takes immutable reference, and this is why you just can't use it in that context. Whereas in rmap we want it to be accessible from multiple threads at once, which means that insert just takes a ref self. It does not take immutable reference to self and therefore we don't need immutable, we don't need mutable access to the map.
00:49:41.105 - 00:50:01.191, Speaker A: You cannot write to the shared. Well, actually it's a good question. What does shared. Let me do. Yeah, shared. Shared is not. Well, you can do a draft mute, but it's unsafe because it's a shared reference.
00:50:01.191 - 00:51:14.205, Speaker A: Right, but this is another reason why we want this wrapper is because shared is a really low level primitive, like a concurrency primitive that we don't want our users to have to think about. All right, See how that works? Usize equals integer, right? Insert and get works. Okay, what does this mean? This means that we created the map, we allocated the map, we did an insert into the map, and then we did a get of the key that we inserted, and we indeed got the value that we wrote, and then the map gets dropped. So this is amazing, right? This already means that the map doesn't immediately break when you try to use it for something. Hmm. It's still a very basic test, right? All this means that you can insert and get, but that's still pretty exciting, right? So the obvious thing to do next is to do this. That is, we want to create an entry.
00:51:14.205 - 00:51:57.765, Speaker A: We want to. We don't really need the read here, but we want to update that entry with a different value. Then we want to check that we indeed got that value, and then we want to remove the value. I think we added a remove, right? We did not add remove. Let's go delete. Okay, so we don't have a remove. Great, that's fine.
00:51:57.765 - 00:52:25.721, Speaker A: Create, Update. Read. So this is update really? And let's see that this actually works. One thing we'll want to do eventually too is to check that our garbage actually gets collected. This is not something we're really testing at the moment. Right. Because we don't know that the zero actually gets deallocated.
00:52:25.721 - 00:53:25.785, Speaker A: In the case of a zero, there's no deallocation that happens. But we'll want a test that actually tests drop. But let's see whether this works. That also works. Okay, this seems pretty promising. And now we want something that drop value because what are we going to do here? Well, what we're going to do here is we're going to have a derive, I guess hash e partial e struct foo. And what do I want from the struct? I want this to like notify on drop and then I want to impldrop for notify on drop.
00:53:25.785 - 00:54:42.587, Speaker A: And then there's going to have to be some code here and there's going to have to be some code here. And then here's the intention. If I make the value here notify on drop and make a notify and drop here, make a notify and drop here. And then I don't even need to care about the get. What do I want to check here? I guess here I want to check that first notify on drop was dropped and then I want to drop the map and then I want to check that the second notify and drop is dropped. Right. Does this make sense? Because this is not guaranteed, Right.
00:54:42.587 - 00:55:45.825, Speaker A: We've implemented our own drop implementation that does this like garbage collection using EPICS and stuff. And so it's not immediately obvious that this is going to work correctly. The question becomes how do we actually track whether or not something has been dropped? I think the way we're going to have to do this is we're going to use standard sync. Let's do arc and mutex or arc and atomic bool is probably sufficient. So notify on drop is going to contain an arc atomic boolean and then the drop is going to be self drop store true. And I guess we'll also use atomic ordering. And that is also where atomic bool lives.
00:55:45.825 - 00:56:51.511, Speaker A: So we're going to have like dropped one, it's going to be arc new atomic bool new false and drop two. And this is going to be a drop. Drop one is going to be dropped is drop two. And here we want to assert that dropped one load is true. And here we want to assert that drop two has been dropped. There's still one thing missing though, which is that this won't actually implement hash and partial leak. And I think the way we're going to do this is just like V, which is going to be a use, I guess.
00:56:51.511 - 00:57:33.465, Speaker A: And then we're going to implement. This is going to be a bane. The problem is that hash e compartial are going to include the dropped here. And I don't think atomic bool implements hash and partial leak because it requires atomic loads. So I think we might actually have to write manual implementations here. Isn't that bad. This might be something we will actually need outside of this particular test.
00:57:33.465 - 00:58:06.829, Speaker A: So I'm going to hoist this up here and then we're going to need I guess hash. No, this. It's a little awkward. This is sort of a helper type that like I'm sure there's a crate that actually does this for you. But here what we need is just like so straightforward. Right. So this is going to be.
00:58:06.829 - 00:58:44.895, Speaker A: It's only going to hash. It's only going to hash the V field. And similarly I guess we want partial EQ impartial E. Notice that if we did end up doing this tree optimization, we would also have to require ord as in being able to order these. But luckily we do not. So all we need is. All we need is eek and partial eek at least for now.
00:58:44.895 - 00:59:49.305, Speaker A: And then we don't need the drive. I guess we might need clone on that. I forget. And yeah, and then we probably here want something like V is 1, V is 0. And I guess what we could do here too is we want to assert that it has not been dropped up here. This is sort of a uninteresting assertion, but we might as well do it when it was replaced by the second when the map was dropped. When you need hash for a value.
00:59:49.305 - 01:00:19.435, Speaker A: You are totally right. I do not need any of this for a value. You are entirely correct. I don't need this at all. The value does not need this at all. So that was a good observation. So let's just get rid of that.
01:00:19.435 - 01:00:46.495, Speaker A: Still going to keep the V. That seems like it might be handy. But of course it's the key type that needs to implement hash and EQ and partial eq. So we can just not do that. Let's see what this does. Oh right. This needs to be clone and this needs to be clone because we want to hold on to the arc so that we can check it separately.
01:00:46.495 - 01:01:15.295, Speaker A: It's true that key types should also be drop checked, but for what we're doing right now, it doesn't actually matter. All right. Finally something that doesn't work field is never used. That's fine. Actually, let's make this fine. Fine. Let's remove the V for now.
01:01:15.295 - 01:01:46.995, Speaker A: That's fine. It doesn't work. Dropped one load 95. I guess that's moved now it failed. Where? At 92 because this assertion does not hold. So this might be. Remember that our garbage collection is a little bit lazy, right? Our garbage collection only collects garbage when it's safe to do so.
01:01:46.995 - 01:02:39.855, Speaker A: And if you recall back in. Let's see where we do this into owned. What is this from? This is from putting. Yeah, that's fine. It's this deferredestroy business and we don't actually have control over when that happens. Right? So let's look up the documentation for deferredestroy on guard. Deferredestroy.
01:02:39.855 - 01:03:28.197, Speaker A: Okay, so deferredestroy stores the destructor for an object so that it can be deallocated and dropped at some point after all currently pinned threads get unpinned. This method first stores the destructor into a thread local cache. At the same time, some destructors from both local and global caches may get executed in order to incrementally clean up the caches as they fill. There is no guarantee when exactly the destructor will be executed. The only guarantee is that it won't be executed until all currently pinned threads get unpinned. In theory, the destructor might never run, but the EPIC based garbage collection will make an effort to execute it reasonably soon. Right, so this makes this particular assertion hard to deal with because we have very little control over exactly when this will this drop will happen.
01:03:28.197 - 01:04:13.375, Speaker A: Right? So this assertion is actually not one that we can easily write because we have no control over when the destructor when the instructor is going to run. However, it does make sense that after the map has been dropped, at the very least at that point the values certainly should be deleted. So let's check that that is actually the case. That is still not the case. It fails at line 95. Okay, so this suggests that the value that got replaced is never dropped. There are many reasons why that might be the case.
01:04:13.375 - 01:04:59.495, Speaker A: One thing we could try here is to do an EPIC pin and then immediately drop it. So basically create a guard and then drop the guard just to increment the epoch and try to make sure that garbage gets collected. We might not have any control over that though. 97 is the same line flush. Okay, so there's flush and there's collector. It's useful when you ensure that all guards used within data structure. Interesting.
01:04:59.495 - 01:06:00.855, Speaker A: It is true that in some sense we would like everything associated with the map to be related to one collector. But one reason that the crossbeam EPIC stuff works this way is because if you have many data structures that all use this EPIC business, you could actually share their collection, their collection queues and such, so that you amortize the cost. I wonder what happens if we do. If you do like guard and then we do guard dot flush, even though there's nothing actually associated with that flush. Interesting. It might be. There's just no way for us to really force this, which would be a little awkward, but yeah.
01:06:00.855 - 01:06:45.355, Speaker A: Oh, interesting. So it sounds like we could just have our own collector associated with the map. So at least this way, when the map is dropped, all the things are dropped. But I kind of don't want to do that because maybe we don't even want to. Interesting. If you force the EPIC forward by two, then you can assert something gets dropped. I don't actually know whether that's true.
01:06:45.355 - 01:07:34.245, Speaker A: I mean, we could try, right? Like, let's just sort of try to see if advancing it twice will make a difference. Nope. See what that does. Or maybe, I guess it's not entirely clear when the garbage collection actually happens. Hmm. Interesting. Flush might also be necessary.
01:07:34.245 - 01:07:59.435, Speaker A: Well, so one. One issue here is that remember that flush does not get called on the guards that were created inside of the map. Right. Insert itself generates a guard for us that it only keeps for the duration of the insert, and that doesn't call flush. But apparently this works. It's like two sufficient. Three sufficient.
01:07:59.435 - 01:08:21.621, Speaker A: Three is sufficient. And that seems to. Yeah, but not always. Right. So what this suggests to me is that we don't really have a guarantee for when garbage is going to be collected. But if we make this like 10, for example. Yeah.
01:08:21.621 - 01:08:49.006, Speaker A: Even then sometimes it does not get dropped. Interesting. One thing we could do here is input. Right? There's a. We create a guard and we could do here like guard dot flush and see whether that makes a difference. Nope. Interesting.
01:08:49.006 - 01:09:29.275, Speaker A: Unreachable statement. Right. Interesting. Yeah, we actually need to deal with this up here, which is this is a return, and there's a return here, which we can ignore. And there's a return here. Let's see what that does. Yeah, so.
01:09:29.275 - 01:10:19.705, Speaker A: Oh, interesting. Still not always interesting. What's tricky about this is to this cargo test run multiple threads. Well, the insert happens in the same thread. I mean, one thing that's tricky here is it's hard to tell whether this is a bug in our implementation of dropping or whether this is just the fact that calling destructors is. Doesn't give You a guarantee about when that drop actually happens? It's a little hard to say. I wonder whether if we do cargo t test threads equals one.
01:10:19.705 - 01:11:34.815, Speaker A: Yeah, so cargo test does run each test in a separate thread and so it could be the like a different thread, like the garbage happens to be shifted to some different thread. I think what we're going to do for now actually is I don't want to delete this test, but what I want to do is just ignore it for now. Pull this into here after all, ignored because we do not have control over when dropping happens. Exactly. Dropping happens. The one thing we do have control over though is when the map is dropped. We do know that all of the keys and values are dropped.
01:11:34.815 - 01:12:46.195, Speaker A: Is that true? Yes, that is true. All of the keys and values that are currently in the map because they are immediately dropped as opposed to a delay drop. So actually what we can do is keep this outside and still do our. I guess, I guess I should not have removed those implementations for notify on drop. And where's hash hash here, let me, let me demonstrate. So if we, if we bring this back to what it was. Have this be V is 1, have this be V is 2 because otherwise 1, 0 otherwise they wouldn't compile.
01:12:46.195 - 01:14:18.815, Speaker A: But then instead of doing this whole like assert that it works during I guess current KV dropped is really what I want to test here. And I want to check that if I do this, neither of them are dropped and then I drop the map. Then now dropping the map should immediately drop not deferred all keys and values. So this test actually we don't want to ignore because this should be the case that here because we own the map, the implementation of map should know that no one else has any handles to our keys or values. And so any current keys and values really should be dropped. And that's what we're testing here. And I probably need to do like use standard hash hasher and hash89 because clone must exist for the key.
01:14:18.815 - 01:15:28.607, Speaker A: Oh, that's interesting. Sure. I guess really what we want here is we really want something like a ref count because the key can be cloned because it might have to if we. If we're doing a resize right and the key might be present in both the old map and the new map, in which case they're a clone of each other. And then we want to make sure that both of the instances of the key get dropped. It's a good question. Good question indeed.
01:15:28.607 - 01:16:28.805, Speaker A: Okay, how about we make this a ref count And I almost wonder Whether this could just be arc, because ARC already does this tracking for us. Here's what I'm thinking. What if we don't do this? What if we say arc new of zero? Same here. The key m value types are both going to be ARC U size. This is going to be dropped one and drop two, and then we're going to assert. So if you look at arc, there's a way to get the reference count. I'm pretty sure it's racy, but there's a way.
01:16:28.805 - 01:17:21.621, Speaker A: What is the main con for not having each map manage its own collector? It's because you don't get the sharing benefits if other things are also using crossbeam. There's sort of an advantage to using this shared notion of queues where you get to amortize more of the cost. It's really hard to write tests that assert destructors have run in code using crossbeam epic. The tricky part is it tries to be really good about deferring things because if you don't defer well, you don't amortize that cost, then it becomes really expensive to do these concurrent operations. As far as I can tell, each thread will queue 256 deferred destructors before pushing them to the global queue. And then once the EPIC is rolled forward by two, the global destructors will run. That sounds about right.
01:17:21.621 - 01:17:58.401, Speaker A: It means that I guess in theory the biggest problem is if the insert happened on a different thread, but that shouldn't be the case here. So there's something. There's something not quite right. All right. Yeah. So what I was going to look up is I think ARC has a way for you to check how many outstanding references there are to a thing, which is strong count. Yeah.
01:17:58.401 - 01:18:40.625, Speaker A: So what we want to do is that we assert not equal arc, strong count of dropped one. We want to assert that that is not equal to one. So keep in mind that we. This needs to be a clone, right? Like we have a copy right here and the map has a copy. And so in fact, we can be even stronger about this and say we want to assert that there are two copies. Exactly right. The one is the one we have and one is the one that's in the map.
01:18:40.625 - 01:19:17.675, Speaker A: And there shouldn't be any resizes going on here. And so that two should be right. When we drop the map, the number of references should be one for both of them. Let's see if that's the case. And I guess this notify on drop now is going to be. We might as well Just at least make sure that this compiles right. So this is going to be dropped one clone.
01:19:17.675 - 01:20:05.415, Speaker A: This assertion is going to be there are two of dropped one and there's one of drop two. Once we insert drop two to replace dropped one, then now our expectation is that they are both one at least. Now we can also here assert that there should be two of it. Okay, so that passes. That is good to know. Let's just get rid of these things. So we didn't need.
01:20:05.415 - 01:20:55.731, Speaker A: So this test is still ignored because we can't actually control exactly when destructors run. So I guess let's comment that here ignored because we cannot control when destructors run. But this one runs just fine. Which means that if we ever modified the drop code of map and we accidentally didn't drop keys or values or something, this test should catch that. All right, so we now have all our basic test work, which was surprisingly little work. Constructing the test was a little bit of work, but the implementation seems to work just fine. Of course, we haven't really stress tested it all that much yet as we don't know whether things like resizes work.
01:20:55.731 - 01:21:45.125, Speaker A: But at the very least the basic operations of get and insert work fine. So let's commit what we have right now. Very basic tests and some drop fixes. Will you be looking at the loom today? I don't know. Maybe. Loom is really cool for this sort of stuff, but I think there are more basic things we need to test first. In particular, how about we write a test that it's a little annoying that we don't have remove.
01:21:45.125 - 01:23:12.677, Speaker A: Actually, arguably we should implement that. But let's have a thing that tries to insert from two different threads. Actually, yeah, let's do that concurrent insert here. We're going to do arc. New map one is going to be map clone and we're going to start T1. It's going to be standard thread spawn and it is going to do zero to, I don't know, 64. It is going to do map one insert I thread zero and T2 is going to do the same, but it is going to use clone 2 of map and it's going to insert once and then we're going to join T1, join Unwrap.
01:23:12.677 - 01:24:21.025, Speaker A: We're going to wait for both threads to finish and then we're going to create a guard and then For I and 0 to 64 again, we're going to look up that I and we're going to say V is equal to that. Assert that V is either equal to 0 or V is equal to 1. This particular assertion is probably unnecessary, but we might as well keep it. Ah, apparently our thing does not implement send. Why is that? Well, if we look at the implementation for flurry hashmap, we need. Oh, this is probably a property of atomic. Where is atomic? I think we had atomic here somewhere.
01:24:21.025 - 01:25:09.735, Speaker A: Atomic. So under the implementations for atomic you'll see that. Oh, interesting. Implement send for atomic where T is send in sync bin entry. Ah, I see, yeah. So the challenge here is that the compiler does not know that the raw pointers to tables that we stick inside. Here, let me pull up node.
01:25:09.735 - 01:26:09.361, Speaker A: Remember that for bin entries, they can either be a node or they can be a moved, which is sort of a redirection saying this table is being resized. Go look over in that table this const. It does not know that it's safe to share that reference across threads. And so we will actually need to do either here an unsafe impulse send for bin entry or more realistically, what we want to say is that table we want to say that table is send even though bin entry is not necessarily send. It's unclear which one we want to do. In some sense neither of them are true. Basically we don't want to add an implementation that lies right.
01:26:09.361 - 01:27:16.577, Speaker A: It is not true that any table is sent because you could stick in a bin entry there with a pointer that actually could you do that? A pointer that was not valid across threads. Basically what I'm trying to figure out is the right place we're going to have to add like an unsafe impulse send for something and the question is what type do we add that unsafe impl for? We could add that unsafe impl for bin entry. We could add it for table, or we could add it for the sort of top level flurry hash map type. The reason we have to add the simple is by default pointer. Raw pointer types like star, const and star mute are not send or sync. I wonder why that is. Give it.
01:27:16.577 - 01:27:49.379, Speaker A: If. If the underlying type is sentence sync, then why would the raw pointers not be hu? That's a very good question. Mmm, it's just default, but it's not necessarily true. Let's look at the namicon. So the namicon is great at this. Let's do. Is there a dark.
01:27:49.379 - 01:28:22.073, Speaker A: Ooh, coal. Maybe iu. I like iu. Let's do that. Let's look at where is send and sync. RAW pointers are neither send nor sync because they have no safety guards. RAW pointers are strictly speaking marked as thread Unsafe as more of a lint.
01:28:22.073 - 01:29:23.011, Speaker A: Doing anything useful with the raw pointer requires dereferencing, which is already unsafe. In that sense, one could argue this should be fine for them to be marked as thread safe. However, it's important that they aren't thread safe to prevent types that contain them from being automatically marked as thread safe. These types have non trivial untracked ownership and it's unlikely that their author was necessarily thinking hard about thread safety. So in our case we are thinking hard about thread safety and we know, let's see, what is it that we have to guarantee. Yeah, in this case it certainly should. It should be the case that these raw pointers are just fine because we are managing the concurrent case for table and bin like the whole implementation here is concurrency safe.
01:29:23.011 - 01:30:51.405, Speaker A: Is what we're going to do is obviously we have to have a KV and save implement KV send for bin entry KV where node KV implements send and table KV implement send where K ascend V ascend. Now this additional restriction on node being sent is probably not necessary, but it does mean that we don't accidentally implement send, that we don't accidentally change node and make node not be send and then that error is not propagated up because of this unsafe impulse. So we're going to do that for this and we're going to do the same for sync, where as long as these types are sync, bin entry is also sync. Ah, that seems to hang. Oh, it might just be slow. What is my. My CPU seems to be.
01:30:51.405 - 01:31:03.725, Speaker A: Is this. Yeah. Huh. Well, that certainly doesn't seem great. So something ain't right. Good. Finally something for us to debug.
01:31:03.725 - 01:32:01.745, Speaker A: Let's see. So let's just add some prints here. So this is T1 at I and this is T2 at I and this is get I. Let's see what this gives us. Ah, okay, here's my guess. My guess is that this starts a resize and that the resize is what is blocking, Right? Because you'll notice that the first couple of inserts work just fine and then when it gets to 11 it stops working and 11 is like roughly 75% of 16 and 16 is the default table size. So my guess is we're here entering.
01:32:01.745 - 01:32:58.195, Speaker A: We're here entering into the space of a resize is happening. So let's do a GDB P. Oh, what on earth did I just do? What? I did something very weird. I have no idea what I just did, but I guess we gotta fix it. How? Sorry about that. No idea what caused that to happen. All right, well, so we're going to PGrab, I guess.
01:32:58.195 - 01:33:43.575, Speaker A: Basic dash pseudo. Okay, so let's look at what threads there are. It's in Syscall, it's waiting on a Mutex somewhere. That's interesting. It's waiting on Mutex Online 298. And what about Ted3? It is also waiting in Mutex, but it is waiting in Mutex in Transfer. Okay, so that's interesting.
01:33:43.575 - 01:34:21.005, Speaker A: Okay, so let's look at our lib. One was in 662. So that's where thread two is stopped. And thread one was stopped in 298. Interesting. Interesting. And they've deadlocked here somehow, huh? How that's fascinating.
01:34:21.005 - 01:35:20.391, Speaker A: Wasn't there some deadlock detection feature in parking lot that might be the case? I'm not sure. The question is why are they both waiting to take the lock? Or rather who is currently holding the lock? If they're both trying to take the lock, this implies that one of them is trying to take the lock while holding the lock. Right? Which if there was a recursive call here, that could happen. But I don't think there's any recursion in this one at least. Well, there's AD count. Oh, I wonder whether what happened was. Let's look at this.
01:35:20.391 - 01:35:48.529, Speaker A: Aha, look at this. Okay, so an insert happened. It did a put and called AD count and ad count called transfer. But it does this while still holding this lock. Right? The lock is still held when it counts, when it calls add count. And that is not what we want because transfer tries to take that same lock. So I wonder that the sort of.
01:35:48.529 - 01:36:08.161, Speaker A: The easy fix for this, right, is to. Here. Drop the guard. I guess. Let's. What do we. What was it called? Headlock.
01:36:08.161 - 01:36:42.045, Speaker A: Let's call it headlock instead. Keep them. If you remember, there's a. There's a lock that sort of belongs to every bin that you have to take if you're going to modify the sort of linked list under that bin. And here we want to make sure that we don't hold that lock once we call at count. Because AD count might actually end up resizing the table. I'm interested though in what the Java code does here.
01:36:42.045 - 01:37:36.685, Speaker A: Ad count, input val. What does it do? Ah, the synchronized block ends where exactly? Right before the point where it checks the tree phi threshold. So this is where we actually forgot to release the lock, where the synchronized block ends. And so we actually need to make sure that we do that now. And that is right before we check this so it should be here. Let's see if there are any other synchronized blocks. There's replace node.
01:37:36.685 - 01:38:21.125, Speaker A: Interesting. A replace node. We haven't implemented this is this does removal, for example. So that's something we probably want to implement, but we haven't yet synchronized and clear. Compute if absent is also not something we implemented. And compute if absent and compute if present and compute and computer and merge, which we don't have. And transfer.
01:38:21.125 - 01:39:09.577, Speaker A: Okay, so transfer has a synchronized section which is down here somewhere. Probably where it takes its lock, which is down here. Right. And that synchronized block ends where it ends. It ends at the end of that else. So here it actually just perfectly happens to mat the synchronized block matches up perfectly with the parent with the the else that we're wrapped in. That was not the case in the other place.
01:39:09.577 - 01:39:40.975, Speaker A: So here it actually is fine for us to do that. But what did I just do? But let's make it explicit here too, just for future sanity. Right. All right, let's see what that does. Okay. It ran, but it crashed. This is probably a crash in.
01:39:40.975 - 01:40:00.595, Speaker A: Oh, crashing get. That's fascinating. So all the inserts worked fine. And that probably then includes a resize. Right? Because remember, we had transfer, which probably means that one was transferred and our get code is wrong. Right. Our get code does not.
01:40:00.595 - 01:40:29.915, Speaker A: When the map got resized, it's either looking in the old table and not finding it. Or in fact that has probably has to be it. Or it's looking in the new table and the thing hasn't been placed in the new table yet. Interesting. Right, Because a write did happen to every key. So it should be the case that every key is present when we do the get. But the transfer probably made that not be the case.
01:40:29.915 - 01:41:18.275, Speaker A: So we need to figure out why that is. Let's go to FNGet. What was this test called? Concurrent insert. Concurrent insert. Oh, okay, so that test fails. Does it always fail in the same key? No, this almost definitely has something to do with the transfer. All right, so let's look at our get method and let's look at where it decides to return none.
01:41:18.275 - 01:41:49.215, Speaker A: Let's go with good old fashioned print debugging. We could probably do. We could use RR here. Should be pretty cool. But this is probably just fine. All right, let's see where it decides to exit for that. Of course, then it passes.
01:41:49.215 - 01:43:14.099, Speaker A: Forget seven, it exits at C. The bin is null. Why would the bin be null? Interesting. Interesting. Why, oh, why would the bin be null? Well, that's certainly concerning. Although interesting. What is the hash Computed to here table bin IH So this means it's looking up in what is presumably the new table and the key and the bin that the key hashes to is null.
01:43:14.099 - 01:44:13.941, Speaker A: That is essentially it is empty. Which I think means what I want to look at is for transfer there's sort of a. There's a transfer bin, I think, or maybe that's just the thing down here. Yeah, this is the thing that moves the bins. If bin is null, table cast bin. Right? So this leaves a moved entry in the place. So what this suggests is it's not looking at the old table because in the old table every bin is going to have a sort of moved entry in it.
01:44:13.941 - 01:45:25.191, Speaker A: Right. This is the thing that it's moving this bin from the old table to the new table and the old table. And in the old table, if the bin is null, it inserts a one of these moved pointers that points to the new table to consult. And this means that if the get sees a null, it can't be in the old table, or at least it shouldn't be in the old table because that should have all moved entries. So I guess really what we want to do here is let's first do here transfer into and then do like a P of next table. And then in our get, let's also do a get from just so we can make sure that we're really looking at the right tables. Okay.
01:45:25.191 - 01:45:50.823, Speaker A: So we can see that there actually been multiple resizes. There's one here, there's one here, and there's one here. And they occur at like increasing distances. Right? Which is what you expect because it's the next power of two. So the read happens from all the reads happens happen from 3,580, which is indeed the latest table. Right? There's a table here that's the wrong address. This is a table.
01:45:50.823 - 01:46:46.985, Speaker A: This is a table. And 3580 is the last one we transferred into. All right, so we are seeing, we're certainly reading from the right table. The question then becomes why is the bin empty? Well, I suggest to me that maybe some of the bins are like left behind somehow. So let's see, resize is finished. So this, let's say print line moving table bin. I just want to check that all the bins are actually moved.
01:46:46.985 - 01:47:29.265, Speaker A: All right, so here we move 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15. Right. Because there are 16 bins. Here we move 0, 1, 2nd, 3, 4, 5, six, seven, eight, nine, 10, 11 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31. So that looks right. And in this final move. 0, 1, 2, 3rd, 4, 5, 6, seven, eight, nine, ten, 11, 12, thirteen, 14, 15, 16, seventeen, eighteen, nineteen, twenty, twenty one, twenty two, twenty three, twenty four, twenty five, twenty six, twenty seven, twenty eight, twenty nine, thirty.
01:47:29.265 - 01:49:01.343, Speaker A: I'm going to stop counting out loud because you can all count with me. Right, so all the bins are at least hit the case where they know that it's supposed to be moved. All right, interesting redirecting. Let's do this moving and then in the GET method, what I want to do here is I actually want to print out the bin I. Let's do the hash as well, just so we have a little bit more information to work with here. See, the get is trying to read from bin 99. Well, that certainly seems wrong actually.
01:49:01.343 - 01:50:01.105, Speaker A: Does it? Also, why are so many of these. Oh, this doesn't seem right either. Because this is moving the redirection notices. Is that even what it's supposed to do? Yes, that is what it's supposed to do. Why is it trying to read from bin 99? All right, because this, the next table size is 128. So that seems right. So really what we need to do here is in the code that does the movement, it's going to.
01:50:01.105 - 01:51:05.885, Speaker A: Right. This is where we have the runs of things are going to the same target bucket. So this is going to be. So this is going to be low into low is going to go into I and hi is going to go into I plus N. Thank you. So what goes into bin 99, if anything here? Moving table bin 35, low goes to 35 and high goes to 99. Okay, so it is certainly moving something there.
01:51:05.885 - 01:51:43.263, Speaker A: The question becomes what does it move there? Low bin and high bin. I don't even know whether this will work. Probably not, but we can try it. It's probably not going to compile. Oh, okay, that's handy. Now it's looking at bin. Oh, it exited D.
01:51:43.263 - 01:52:07.265, Speaker A: Now that's different. Let's stick with the one where it crashes at C first. 103 is what we're now looking for. What goes into 103? Nothing goes into 103. 39 was empty, which would have gone into 103. Right. This went into 102, this went into 104.
01:52:07.265 - 01:53:25.231, Speaker A: Interesting. Interesting indeed. I wonder. We probably need more of a chain here. We need to know which Bin it originally moved into probably. So for FN Put, let's go with DirectCast to Bin Bin I or indirect insert to bin. Do we have a bin I here too? Bin I.
01:53:25.231 - 01:54:26.647, Speaker A: Great. So what? You know, that's D again. So we're going to get six. All right, where did six get inserted? Well, thread two inserted six. When does this print get printed? And get printed before the insert. So thread 2 did indirect insert into one of these bins? Probably into bin 4. Cosmodulo 26 modulo 2 is 0 and 3 modulo 2 is 1.
01:54:26.647 - 01:55:13.381, Speaker A: So there's an indirect insert into bin 4. Okay, so key 6 is in bin 4 and then moving table bin 4, bin 4 stays in bin 4 and nothing gets moved to 20. Okay, so it's 6 is still in bin 4. This is an indirect insert to bin 4. So bin 4 gets added too. And then where do we move bin 4 a second time moving bin 4. The low moves to 4 and the high moves to 36.
01:55:13.381 - 01:55:53.755, Speaker A: Okay, so we now need to look at 4 and 36. Those are the places where 6 should now be 4 and 36. 36 goes to 100. So now 4 and 100. Where did 4 go to? 4 goes to 68. So we need to look at 68 and 100 are the ones that have this key. Why does it go for 84 then? Something ain't right here.
01:55:53.755 - 01:56:49.015, Speaker A: Somewhere this decides to use the wrong bin. Maybe one thing that would be helpful is to print what the bins. But doing so currently might be a little bit of a pain. I think we need it though. We're going to need. Let's go up to the top here and say we want the key to implement display, standard format display. And we want these to implement display just so we are able to print out bins.
01:56:49.015 - 01:58:01.585, Speaker A: Because what I want to see is for transfer. Yeah, that's fine. Insert. I guess now we can actually print out the key to. We can do this up here somewhere and yep, indirect insert that key. And then in transfer we should now be able to actually print out the bin that gets moved. Moving table bin that and the bit that loops through all the nodes.
01:58:01.585 - 01:59:35.665, Speaker A: Moving key to. So the key is going to be node key, although we might have to match on this. And high is going to be whether the bit is set, which is going to be this, whether that is one. Let's try that. All right, so what are we looking for this time? Key 10 and bin 33. Key 10 and bin 33. All right, so where does 10 originally end up? 10 ends up in bin 1 somehow seems wrong to me.
01:59:35.665 - 02:00:29.665, Speaker A: I feel like it should be in bin 0. All right, so bin 10 is in bin 1. And then bin 1 moving table bin 1 moves the key 10 to high. No, it moves it to low. Okay, so 10 is going to be in low, which is going to stay one. All right, what happens to one the next time it gets moved? That is moving table bin 1, 10 stays in low, so it's still in bin 1. And down here, moving table bin 1, 10 stays in low, so it's still in Bin 1.
02:00:29.665 - 02:01:25.233, Speaker A: So all the way to the end it's in Bin 1. So why does it choose Bin 33? Here is the real question. Because 33 is not in the high end of 128. It's not in the, ah, it is the high of 64. So this suggests that this is if you count, remember how. Let me try to formulate this in a useful way. When we do a transfer, we are moving from N bins to 2N bins, right? And for every old bin we have, some of the things are going to move to the same bin in the new size and some of them are going to move to a different one, right? Because the.
02:01:25.233 - 02:02:03.645, Speaker A: For a given key, the way you choose a bin is the hash of the key modulo the number of bins. And for the ones where the modulo of 2n is in the next. How do I draw this is really the most the biggest question. I think I talked about this a little bit last time, but let's say that we're doing 10 mod. Let's just use 10. 10 mod 16 is 10, right? Because 10 is less than 16. 10 mod.
02:02:03.645 - 02:03:18.985, Speaker A: Actually this is a terrible example. 10 mod 4 is 2, right? Because 10, you take away 4, you take away 4 again and you're left with 2. And this is basically how modular works. 10 mod 8 is also 2, but 10 mod 16. Oops, 10 mod 8 is equal to 2, 10 mod 16 is 10, right'? So notice that if we resize from 4 to 8, then things that had a hash of 10 would not move, they would stay in bin 2. However, things that did move in this case, for example the modulo 10 modulo the number of buckets did change and in particular it changed into the lower half of the 16. Right? You can think of 16 as 8 and then 8 and 10 used to be in this half because it corresponds 1 to 1 to the old 8 bins.
02:03:18.985 - 02:03:59.502, Speaker A: But in the new path it's actually going to end up in the lower in the high bin, so to speak. Right? The first eight, the last eight, it's now in the last eight rather than the first eight like it was before. And its index there is going to be the old bin index plus the size of this, which is eight, right? These are eight each. So it's going to move from bin two to bin two plus eight, which is 10. Right. And so, and when we look at this bin, we know that the key 10. Notice that it's hash is like some obscure, like this large number, right? The hash of 10 is this.
02:03:59.502 - 02:04:54.154, Speaker A: And that number happened to be bin 1. Right. Initially it was bin 1 as we, as we looked up through the logs and it was bin 1 modulo 16, which is where we started. Notice that the number 33, right? Bin 33 is bin 1 plus 32. So the moment we resize from 32 to 64, 10 should have moved to bin 1 in the high, high set of bins. Instead it just stayed in bin one. So the question becomes why is that? And my guess here, that is the real question, isn't it? Why when we move to have 64 bins, which is.
02:04:54.154 - 02:05:47.045, Speaker A: Right. Like here we have 64 bins already. So up here, when we're moving table bin one here, why does 10 not move to high? That's the real question. Why was 10 not moved the hash on N? Let's see, the mask is. The mask is N. Let's print out both of these. Something here is definitely off.
02:05:47.045 - 02:06:05.407, Speaker A: Yeah. What do we got? This is a D error again. See bin 26. 26. So where did. Oh, this is 10 again. But notice it's hash is different.
02:06:05.407 - 02:06:22.023, Speaker A: That is because of random state. Get 10. Okay, so where did 10 end up in. Initially? I should just turn up randomness. That would. It's not really helpful. Key 10 ended up in bin 10.
02:06:22.023 - 02:07:02.032, Speaker A: Oh, that's handy. Okay. And down here we saw that the final get looked up in bin 26 and 26 is the is 16 plus 10. So it should have moved to the high bin when there were 32 bins and it did not. 26. Yeah. So when there were 32 bins, which is up here, right? Because you see it inserts into things like 26 when we moved to having 32 bin.
02:07:02.032 - 02:07:45.105, Speaker A: When we moved bin 10 moving key 10 to high, it decides not to move 10 to high, which would be bin 26. Instead it chooses to keep it in bin 10. In fact, it almost looks like all of these decisions are false. Right? Looking through it, it looks like it never ever moves Anything to the high. The high bin, which suggests that something is wrong in particular. Okay, so let's. So this is the hash and the mask is 16.
02:07:45.105 - 02:08:35.845, Speaker A: Interesting, interesting, interesting, interesting. Something here ain't right. I mean, we can check this pretty easily. And binary. This is going to be bright. All right, so 1, 2, 4, 8, 16. Right.
02:08:35.845 - 02:09:29.345, Speaker A: 1, 2, 4, 8,. So the 16 bit is set. Right. And the mask is 16. So why is this not equal to 1? Well, it's. Because that's the actual check, that's why. Yeah, so it does actually move it to high.
02:09:29.345 - 02:09:51.351, Speaker A: It's just my printing was wrong. We're doing an end with the mask. Right, we're doing an end with the mask. And that just is going to leave the 16 bit set. But 16 is not equal to 1. It's equal to 16. And so we need to compare to N.
02:09:51.351 - 02:10:16.287, Speaker A: That's where that got screwed up. All right, so that means those were just lies. So in theory, that's. That's frustrating. I guess this has to be as U64. That was kind of silly. All right, let's try that again.
02:10:16.287 - 02:11:01.645, Speaker A: Get of 16 and bin 57. To 57. What's the last move to 57? Doesn't look like there really is one. Wait, did I read that backwards? No, 16 and bin 57. All right, so let's look at the insert for 16. The insert for 16 is bin 25. All right, where do we move bin 25? 16 moves to high.
02:11:01.645 - 02:11:19.965, Speaker A: Ah, yeah. Look at this. This is a. Okay, so my guess, it's the. It's our logic for moving runs, which you might remember from part two. We had some difficulty there. 16 is supposed to be moved to the high bin.
02:11:19.965 - 02:11:58.705, Speaker A: Right? It does match the mask, but it is not. The high bin ends up empty. So question becomes, why is that the case? Okay, it first hits. Okay, so 0 and 16 are both in 25. And so we're going to have to. We're going to have to. So that means it's at the tail.
02:11:58.705 - 02:13:16.491, Speaker A: So last run is bin run bit is. All right, okay, so here it's looking for. It's looking at the bin and looking for the tail that share whether they're going to high or low. Right. And in our case, they do not share whether they're going to high or low. Right, because zero is going to low and 16 is going to high as that means in theory, the run that finds should be just 16 and then 0 should just not be in the. In the high bin run.
02:13:16.491 - 02:14:02.145, Speaker A: So last run should be pointing to the 216. At least that's the hope. If the run bit is zero. That's correct. Then the last run should go in the low bin. Otherwise the last run should go with the high bin while P not equal to last run. And then it walks all the things that should go in the everything that's before the last run and then sticks it in the write list.
02:14:02.145 - 02:14:41.445, Speaker A: At least that's the idea. All right. And for some reason here, even though 16 should go to high and 0 should go to low, high is just null. So we're going to need, I think, a little bit more debugging here. In particular, I think one thing we'll want to know is where the run starts. Run goes to high. Runs starts at that and goes to high.
02:14:41.445 - 02:16:10.813, Speaker A: And it starts at. Let's do a node here is going to be last run starts at that and goes to high is going to be whether the run bit is zero is not equal to zero. Right? Hmm. Yeah. Okay, so that'll tell us where the run starts. And then I think the other thing we'll want is, is this information down here on what it chooses to link where. So down here we're going to say linking pre run node pre run this to high.
02:16:10.813 - 02:16:59.764, Speaker A: And that's going to be node key and no hash and n as u 64 not equal to 0. All right, let's see what that gives us. Hash and N is not a helpful value. Need hash mod n constructor hash and n +1. Hash and n +1 gives you modulo that is true. But hash and N lets you check whether a given bit is set, which is actually what we want to do here, at least from memory. That's what the.
02:16:59.764 - 02:17:28.235, Speaker A: That's what the code here does. Yeah, it checks. It doesn't check the mask that you get for the modulo. It checks whether that bit is set. Because you can use that to decide whether, when you increase the modulo, whether that particular thing moves to the high bin or the low bin. So we don't actually want to take the full modulo, we just want to see whether it moves. That's a D.
02:17:28.235 - 02:17:49.365, Speaker A: That's D. That's A C. Okay, so seven, when should be in 27. All right, seven. Seven, seven, seven seven goes to bin 11. All right, where do we move bin 11. Move bin 11.
02:17:49.365 - 02:18:02.679, Speaker A: Moving six to high and seven to high. Run starts at six and goes to high. True. Okay, so that works correctly. Great. So that went to. That went to 27.
02:18:02.679 - 02:18:39.798, Speaker A: Because here it's at least claiming that both key 6 and key 7 are moved into bin 27, which is where we want it to be. Right. That's where the. That's where the read is trying to. Trying to read. So the question is, why is the read not finding it in 27? My guess is that some later time bin 27 gets moved again. All right, so bin 27, indirect insert 7 to bin 27.
02:18:39.798 - 02:19:02.533, Speaker A: Interesting. Okay, moving bin 27 Moinky, 6 to high, true. Moving keys 7 to high, false. Aha. Look at this. Here 6 is supposed to move to the high bin, but 7 is supposed to stay in the low bin. Right.
02:19:02.533 - 02:19:57.267, Speaker A: It's supposed to stay in 27. And yet our code says the run starts at 6 and goes to high, which is not right. Right. The run should start at 7 and go to low, but low ends up empty and seven ends up moving along with six to 59, which is not what we want. Right, so why does it do that? Why does it think the whole thing is a run? Okay, it starts out saying. It starts out saying the run bit is. What are we at here, like 16, 32, 64.
02:19:57.267 - 02:20:35.315, Speaker A: Okay, so the run bit is 64, or the run bit. Let's just go with the run bit is 1, but the run bit is 64 and the last run is the start. Okay, so initially it's going to assume that the run is the entire bin and it is moving to high, which is what it ends up doing too. Right. So this suggests that something's off. Then it looks at six and it sees that six matches that six has next set. I know what's happened.
02:20:35.315 - 02:21:05.317, Speaker A: I know what happens. Okay, let's just walk through it. Let's see if you also spot what's wrong. So initially it thinks the bin is the run is the entire bin and it's going to high. Then it looks at the 6, it sees that 6 has a next. Then it looks at the bit for six and it sees that the bit for six is 64 and therefore it's going to high. So it's going to skip.
02:21:05.317 - 02:21:45.535, Speaker A: This is just going to move to the seven. Then it looks as seven for the seven. It looks at whether next is non null and next is null for 7 because 7 is the last element. And then it breaks. So it never gets around to checking that 7 doesn't match the run. So this probably needs to be after the run bit check. So what does it do here? Yep, this check, which we transposed into the middle of this function, actually needs to go at the end.
02:21:45.535 - 02:22:27.401, Speaker A: That should be it. See what that does. Hey, great. All right, now let's get rid of these prints technically. One thing that would be kind of cool. Oh, we should instrument this whole thing with tracing. That'd be so cool, man.
02:22:27.401 - 02:22:59.045, Speaker A: I really want to do that now, but it's like unclear that it's worth the time. It would help a lot with debugging. Right. If we had tracing support for the whole concurrency business here. All right, I guess. And in the test as well. All right, so here we have a bunch of concurrent reads and writes and they seem to work just fine.
02:22:59.045 - 02:24:12.435, Speaker A: Let's see that the other tests also work. Presumably they do. What else kind of shenanigans can we get up to? Well, here's a possibility. How about we do concurrent reads or read while writing. So here we're going to have writer and the writer is just going to write into the map and then we're going to have a reader. How do you implement that? Which crate? Oh, for tracing, there's a really cool crate called Tracing Tracing that gives you a really nice high performance way to add trace points and group them together as well to related events and annotate them with additional information and stuff. It's sort of like log, but I think more it's like more sophisticated and lower overhead.
02:24:12.435 - 02:24:47.825, Speaker A: And it's useful in that you can choose what to do in response to every event. It does not have to be to log it. And so this is just like annotating this library with tracing events would be really cool because you could do things like analytics over them. The log crate, for example, is only built for logging your output. You can adjusted to do different things, but this is like built for you. Write a subscriber that chooses what to do with the events. I highly recommend you look into this, but I'm not actually going to spend time adding the tracing right now.
02:24:47.825 - 02:26:04.895, Speaker A: Okay, so read while writing is going to spin up a thread that's going to do a bunch of writes and then it's going to spin up a thread that does a bunch of reads. That's a good question. What is the reader going to do? I think so there are two options here. One is we just let them race. We just have them all do like reads and writes and not really check what the results of them are, but just to check that the code doesn't panic or anything. The other option is to make the reads actually read reasonable things like only read keys that have been written. How do we want to do this? Actually one option here is to have the writer just write keys Basically in order or maybe randomly and then to have the reader read randomly.
02:26:04.895 - 02:26:43.471, Speaker A: Actually, you know what the right solution here is to not do these. Let's remove that, keep the concurrent insert, and now let's move over to actually porting some of the Java tests because I'm sure that they do a bunch of this stuff already. No, tracing is not related to Tokyo. It's by some of the same developers, but it's not. It's. It has nothing to do with Tokyo and it's really cool for this kind of like tracing, especially in low latency, high performance situations. Why do you need that ARC there? I need the arc because it's the flurry.
02:26:43.471 - 02:27:36.545, Speaker A: Hashmap is accessed from multiple threads and so otherwise the thread spawn requires that you have a static closure. Doesn't it seem like this language is a little bit heavy on the syntax side and introduce a lot of friction for the developer? No, I don't think so. There's not actually that much syntax here that's like beyond what you have in C or C rather. I don't think it's that heavy. It is true that the borrow checker introduces friction, but I think it introduces friction in a way that actually makes for better programs. Like it tells you that your code has bugs and it's true that it's friction, but it's the good kind of friction. Okay, how about we start porting some of these Java tests? So this is going to be bright again.
02:27:36.545 - 02:28:07.135, Speaker A: And let's start with. Oh, I don't know. I don't know what these different tests are. Let's look at something like this one times and checks basic map operations. Sounds great. I guess this relies on a bunch of things that we haven't implemented. Like contains, contains key iterators.
02:28:07.135 - 02:28:50.115, Speaker A: Again, maybe we really do need to implement removal and iteration. Yeah, I think we do. It looks like a lot of these are. A lot of these are testing iterators or removal. Well, I guess let's do that. All right, fine, fine, fine, fine. So let's do P.
02:28:50.115 - 02:30:31.925, Speaker A: Actually, let's do. Let's actually add these properly because these have some somewhat interesting observations around why they were broken. So here we have drop, drop lock guard when Java synchronize ends. Otherwise put ad count transfer produces a deadlock. What was the other one we had here? Also consider last bin entry for runs. This is bin entry moved is thread safe. I want to keep the display bound because it might be useful for debugging later.
02:30:31.925 - 02:31:22.227, Speaker A: First concurrent test, exclamation mark. And we're Going to keep that. All right, how about we do. Because the tests rely on this, let's implement Iterator. I think that's going to be worthwhile. Iterator who base Iterator extends traverser. Okay, what is traverser? A stack is created on the first encounter.
02:31:22.227 - 02:32:09.125, Speaker A: Oh, this is another thing where we probably want to add some of this documentation ourselves. But one thing that's interesting about traversal is that you want to make sure that if there's a resize you don't visit keys that you have already visited. Right. If you're like bin 7 and you're like halfway through bin 7 or something and then a resize happened, you have to make sure that if a thing that you already visited got placed in a high bin, then when you iterate you yield it again when you get to that high bin. Right. Yeah. I wonder what that actually does.
02:32:09.125 - 02:32:41.095, Speaker A: It's going to be interesting. I'm excited. Contains value actually how about we do contains key first because that seems like such an obvious. Oh yeah, that's relatively uninteresting. Fine, I'll do it. Just to add a method, you know. Contains key.
02:32:41.095 - 02:33:21.715, Speaker A: Does this contain this key? Bool Guard is epic pin and then I guess we do self get key. Guard is sum. Good job us we added contains key but Traverser. That's where we were. Traverser. Traverser. Traverser.
02:33:21.715 - 02:37:08.805, Speaker A: All right, all right. I'm going to pee and then we're going to do Traverser. Actually how about we do like a 5, 10 minute break. I'll be back in like a few minutes. Just make tea and stuff and then I can do some Q and A and then we do iterators. Let's do that. It excellent.
02:37:08.805 - 02:38:20.415, Speaker A: I'm back. All right, let's do. If you have any like questions, doesn't have to be about this. Let's do like a quick Q and A while I eat a crisp bread and then we continue with Iterators. Like does not have to be related to Rust for that matter. Just if you have questions, now's the time I guess in the meantime we can also read the documentation for the traverser implementation. Have you heard about the drama around Actix Web and its maintainer? Yes, I have heard of the drama.
02:38:20.415 - 02:39:19.965, Speaker A: I mean I have opinions on it. Like many other things in this world, I don't know that they're particularly useful. I think in general unsafety is something to take very seriously. But it is also I think people shouldn't be as scared of unsafe as they often are. But at the Same time it is important to take it seriously and in this case I think it's like a combination of a difference in priorities and a bad mix of different communication styles that cause some problems. Is it always possible to avoid unsafe blocks in this language? No. If you need to implement, like if you have to call out to a C function for example, it's inherently unsafe.
02:39:19.965 - 02:39:55.339, Speaker A: Other than Rust, which languages do you think have a potential for the future? Many like I think Go does. I think C is going to remain for a long time. I think there's some cool like up and coming languages like Zig and Nim, but those are sort of more esoteric ones. ELM is pretty cool. I think JavaScript is going to be with us for a long time. So yeah, many languages. Java too for that matter.
02:39:55.339 - 02:40:54.895, Speaker A: Why do you choose the Java Concurrent Hash Map to implement in Rust? Because it's a very like well known and stable thing that is used like used by pretty serious consumers and it's sort of seen a lot of vetting and so it seemed like an interesting thing to port and especially because it's also like open source and the license is such that I can do this work and it's commented I made it interesting. What do you think of Microsoft new language, Verona? Oh, this is the Rust, but with Arenas sort of. I think the notion of Arenas is really cool. It's something that you often want to do in performance sensitive applications anyway and having a language that has that sort of a first rate primitive seems pretty attractive. But I haven't looked enough into the language to really say how is Flurry different from the C hashmap crate? The C hashmap crate from memory has a lock per bucket. We talked about this a little in part one. Whereas this library is.
02:40:54.895 - 02:41:28.335, Speaker A: It does not. It does have a lock per bucket, but only for anything following the first insert, which in theory should mean that it's a lot faster and a lot less contention. It also means that reads. One thing that's neat here is reads do not have to take a lock whereas they do in C. Hashmap I believe. I don't think he even sees this chat. I mean I'm looking at the chat right now.
02:41:28.335 - 02:42:24.253, Speaker A: What particular questions do you have? Could you give a quick overview of your development setup? I actually have a separate video on my desktop setup that's linked in my YouTube channel so you can look at that. And all my dot files and stuff are online. What resources would you recommend to learn how to use Unsafe in a safe way? Oh, that's tough I don't think there are that many good resources for unsafe. There's a GitHub repository called unsafe Code Guidelines. I think basically they're trying to work out what exactly are the rules around unsafe. The Nomicon is also fantastic at this and hopefully over time we're going to see more resources for dealing with this. This is both going to be stuff like what we're building here, right, which does have some unsafe and where we actually talk through what that unsafety means.
02:42:24.253 - 02:43:24.405, Speaker A: There are tools being developed like Miri that let you at least be more confident in your unsafe code and hopefully we'll have some more talks about this. I might give one in New York in like a month or so about unsafe and then hopefully there'll be like more books and stuff on more advanced uses of rust and that might be a good way to learn. Have you followed Jaya at all? I have not. Is there a Lib arena and Rust repo? Yeah. So Lib arena and the various arena crates are for arena allocation, but the idea with Verona from Microsoft is that the it's language level support for things like borrow checking at the arena level. Like you can say all of these things are related to this collection and they have the lifetime of the collection in a way that's hard to say in Rust currently. What do you mean, Basil? The Rust Nomicon touches on a lot of subjects of unsafe rust.
02:43:24.405 - 02:43:58.045, Speaker A: The Nomicon is great for if you already sort of know some of the unsafe. It's great at telling you like here is how a lot of these stuff work. But it's not great for like learning about unsafe. It's gotten better but if you're starting sort of from scratch, it's not really good at that. We almost need like tutorials in some sense. Have you seen the Dash Map create implementation? Yeah, it's pretty cool. I actually ran some multi core benchmarks that I posted on Reddit in one of the sub threads.
02:43:58.045 - 02:44:33.323, Speaker A: Dash Map is really neat. It doesn't try to innovate that much. Like the author said too that the basic idea was let's just build something where the structure is really simple and that ends up performing well. And so far that seems to be true. I'm really interested to see it compared to something like what we're porting here, which is like a very well thought through concurrent implementation and see how they scale. So for example here like gets take no locks and writes often do not take locks if they don't contend on a bin. So I this should scale better.
02:44:33.323 - 02:45:32.515, Speaker A: But it's hard to say. Can you test the crate with Miri? So one restriction Miri has, and I believe it still has this, is that it only works for single threaded code. That's not to say that it's not useful, but it means that there's only a limit to the kind of interactions you can test with it. Oh, I'm glad you liked the streams. Do you know why something like box pinaasyncfut await has a static lifetime, but if this food calls await, the static lifetime goes away. If the food. I don't know what you mean by if the food calls await.
02:45:32.515 - 02:47:02.457, Speaker A: Do you recommend another book for beginners? Apart from the book, as in the Rust book, there's a book called Rust in Action that deals with like sort of systems level programming in Rust. I haven't read it myself, but I talked a little bit to the author and that seems cool. I don't know there are that many Rust books currently, but hopefully this is something that will change. All right, let's dig back into the maybe one more question while I finish the last bit and then we'll dive into the implementation again. Also a cool book. Garrett. That's not valid syntax, so I don't quite know what that first bit is, but what box pin does is I think you're at least missing a move keyword.
02:47:02.457 - 02:47:29.395, Speaker A: But box pin will allocate something on the heap rather than the stack, which means that it will. Rather than only living for as long as the current function is living, it will live on the heap, which means that it gets a static lifetime. My coworker helped you out with a project. Oh, WP2Ghost. Yeah, that's a while ago. It's a bit of a pain. It's true.
02:47:29.395 - 02:48:21.083, Speaker A: All right, let's dive into how to write this. Concurrent iterator encapsulates traversal for methods such as contains value. Also serves as a base class for other iterators. Method advance visits once each Is this valid? English Method advanced visits once each still valid node that was reachable upon Iterator construction. It might miss some that were added to a bin after the bin was visited, which is okay with regards to consistency guarantees. Maintaining this property in the face of possible ongoing resizes requires a fair amount of bookkeeping state that is difficult to optimize away amidst volatile access. Even so, traversal maintains reasonable throughput.
02:48:21.083 - 02:49:14.635, Speaker A: Yeah, so this is the worry that I sort of had was that iterating over this in an efficient way is going to be a little tricky because you need to keep track of things you've iterated past just so you don't hit them again. Normally iteration proceeds bin by bin, traversing lists. However, if the table has been resized, then all future steps must traverse both the bin at the current index as well as at index plus base eyes and so on for further resizings to paranoiacally cope with potential sharing by users of iterators across threads. Iteration terminates if a bound check fails for a table read. Oh, that's neat. Okay, so if I'm reading this right, the trick we're going to pull is. Imagine that you are.
02:49:14.635 - 02:50:22.537, Speaker A: How would this work? Interesting. I think what this means is that you're going to if a resize happens to have been you look at both the high and the low version of that bin at the same time rather than just continue in bin order like normally we're just going to read the bins in order. But if one bin has moved, we look at its low and its high bin before we move on to the next bin in the original iteration. Because that way we only need to keep track of the keys that we've seen so we don't duplicate them as long as we're still in this bin as opposed to for the entire iteration would be my guess. Yeah, rustlings is great as a. As a side note, but let's see how this actually works out. I think at this point we're probably going to want to split this into smaller files.
02:50:22.537 - 02:51:34.495, Speaker A: Let's do a How big is table? Table is pretty small, I think. I probably want to keep table, but what I do want in its own file is mod iter. We probably actually want a mkdir source iter I want iter I guess Traverser Traverser RS the other question here is whether we want the iterator to have to have its own guard. Quite possibly it does mean that while you have an iterator, you're actually going to hold up all garbage collection. So this is something we're going to have to think about. I'm not quite sure yet, but we are going to need here. Great.
02:51:34.495 - 02:52:08.433, Speaker A: At the very least actually, probably. Maybe it's just table, node kv tab I think it's. It might actually just be table, but we'll find out soon. It's gonna have to be KV and s Kvs I guess this is. They call it tab. We're going to call it table because we like full words. Next.
02:52:08.433 - 02:52:55.135, Speaker A: Whatever next is going to be. I guess this is going to be. These are probably going to be shared would be my guess. We're not gonna. We're not gonna quite get away from these being shared to kem is my guess. Hello, Unclear. A table stack, which we're gonna have to figure out what does later.
02:52:55.135 - 02:53:52.271, Speaker A: An index, a base index, a base limit and a base size. I guess we might as well keep these comments too. This is current table update. If resized, I think. I think that might actually be just a straight up reference, but I'm not sure yet. This is the next entry to use. This is index of bin to use next.
02:53:52.271 - 02:54:35.025, Speaker A: I think by use what they mean here is access current index of initial table. Index bound for initial table. Oh, I see what this is about. Initial table size. So when you create the iterator, you're going to read out what the. You're going to read out what the current table is. But then if you encounter one of these like move nodes, then you're going to look at the.
02:54:35.025 - 02:55:07.985, Speaker A: You're going to follow the pointers inside of them. Right? But then you have to continue iterating on the original table you made. And so that's why it has to keep track of where we were in the original table. So that's why it has this like index is like where in the. Where in the bin we're currently in. And then this is where are we in the original traversal or something along those lines. Okay.
02:55:07.985 - 02:55:55.945, Speaker A: And there's a impolator. I guess we're gonna have to do like MKVs. MKVs. It's gonna be a new. Just gonna take a little bit unclear what it's going to take actually we'll find that out later. But it is going to do self table is going to be actually I guess interesting. Why does it take all these parameters? That seems fine.
02:55:55.945 - 02:56:38.135, Speaker A: It takes a table which is going to be I guess of shared table KVS because I think we can just load this once. Although it's going to be tied to its own guard. Remember that when you read out of a shared. What you get back is a guard is a. Is a reference to the underlying value whose lifetime is tied to the lifetime of the guard. Which I think means that the caller has to hold on to the guard. It's going to be awkward.
02:56:38.135 - 02:57:17.195, Speaker A: Think of it this way. If we stick the guard into the Iterator actually shared you already get. Okay, we're gonna have to think about this a little carefully how these lifetimes work out. But for now let's just do this I guess. Next. Oh, next is a node. Okay, so next is actually not a shared table.
02:57:17.195 - 02:58:05.335, Speaker A: It is A shared node or node entry. I forget what we called these node. Okay, so we're going to need node and table. Yeah, so this is while we're walking a bin. Next is going to be a pointer to the next bin to look at. So I guess next is going to be a shared null base size. It's gonna be.
02:58:05.335 - 02:59:01.655, Speaker A: I wonder why size is passed. Because isn't size just dictated by the size of the table? I don't know why it's a separate. Like if you look at, I guess, where do people make traversers? Yeah, it's just t length. And so why is that passed in separately? It's just always T length was f here. Yeah, T length. So that seems entirely unnecessary. Yeah, I don't buy that for a second.
02:59:01.655 - 02:59:52.739, Speaker A: I don't think that argument is necessary. I think the base size is just the number of bins which we can find with table. Table table table.bins. len and I think base index is just going to be zero and index is just going to be zero. Right. In all of these ones, index is zero. This might be like if you want to iterate over only a subset of the things, but it looks like nothing uses that.
02:59:52.739 - 03:00:35.025, Speaker A: So I think we're just going to ignore it. And then baselimit is also going to be table binslen. Now, these might change over the course of iteration, I don't know. But for initialization, it seems like you should always initialize it to traverse the entire table that you're given. And I guess advance is really what we're going to call is just going to be our implementation of iterator. Right. Iterator 4kbs.
03:00:35.025 - 03:01:14.405, Speaker A: This is just a standard Rust Iterator trait. Right. Which takes mute self and gives you an option self item. Where item here, I guess is going to be. That's also a good question. Yeah, I think. I think we're gonna have to be given a guard.
03:01:14.405 - 03:02:19.285, Speaker A: The. The. I think the caller needs to maintain our guard, which is pretty awkward actually, because it sort of means that what we need is a. We need to take in a guard here too, which we're going to use to read any additional items that we read out. So this is going to be a tick g guard. And then sort of implicitly, the lifetime of the map is going to be longer than the lifetime of the guard. How exactly we expose this to users is not clear though, unless they provide the guard, which again is an interface that we probably want to avoid, but there might be ways for us to deal with that.
03:02:19.285 - 03:03:21.075, Speaker A: So the Item here. This is sort of the same thing as what happens for get right, which is that at least for the time being, we're just going to expose these shared directly. And so the item type is actually going to be a shared to. Hmm, that's also a good question. Yeah, you're right. This does have to have a guard. What is the type here? I think the type here is node, because the node lets you get at both the key and the value.
03:03:21.075 - 03:04:10.585, Speaker A: So in some sense, right, like this is going to be a very low level iterator. It's just going to iterate over all of the nodes and then something on top of this. And that's probably what advanced does here too. Yeah, it returns a node and then you can have wrapper iterators around that that like filter it down to just the key or just the value or something like that. Iterating over the values in particular is going to be tricky because that's going to include a mutex guard. We're going to have to think about how to do that. Not entirely sure yet.
03:04:10.585 - 03:05:30.003, Speaker A: Okay, so what does next do? Well, it sets an E. Interesting. What's this? Okay, so E is the entry that we just yielded. Okay, so we're gonna have something E which is gonna be a shared G node kv, and it's initially gonna be null. And then if self.next, if self. So really it's not next, is it? Right, because this is taking e dot next.
03:05:30.003 - 03:06:13.085, Speaker A: So I think next is really previous. Yeah. See it. If it returns E, it's set next to E. So it's not next, it is the previous element you yielded. So I think this is a lie and that this should be called the last node yielded or iterated over. That makes more sense to me.
03:06:13.085 - 03:07:06.505, Speaker A: And if the previous node we iterated over is not null, then what we're going to do is we're going to say E next. Right? It has a next field load. And I think we know that the. I'm pretty sure that we know that if we hit a node, all the subsequent things are nodes. That's what this loop here is. Right. If the first entry in a bin is a node, all the remaining ones are nodes.
03:07:06.505 - 03:07:57.765, Speaker A: And since we know that this particular one is a node, we know that all its subsequent ones are nodes. And so this is gonna. Let's look at what do we do for load here? Ordering sec, const and the guard. Yeah. And then there's a loop. And what does this loop do? Well, okay, so if the previous node we iterated has A next then we just return that. That seems straightforward enough.
03:07:57.765 - 03:08:59.795, Speaker A: So this is going to be a loop and if not e isnull then we're just going to do self prev is e and then we return e and then the question becomes can you clone a shared? Which I assume that you can. They're probably not copy. Sorry, I should have warned you that this is going to be bright. But if we go back here to shared. Yeah, shared implements clone and it should be a cheap clone because shared is really just a pointer. What's the difference between ordering sec const and ordering acrel that is a big debate and there's a lot. It's not a big debate, it's just fairly complicated.
03:08:59.795 - 03:09:42.775, Speaker A: We go through this a little bit in some of the earlier streams on this port. It has to do with which memory reads and writes, you can see, and also whether the compiler and the CPU are allowed to do your instructions out order. I recommend that you look up some of the resources I talked about in the previous part and also just look up llvm. Memory ordering, for example, has a pretty good write up on it. How old is he? I am 30. Okay, so if it's not null, then we're sort of done. Otherwise I don't know what this must use locals and checks means.
03:09:42.775 - 03:10:32.099, Speaker A: This seems like a Java thing. If self base index is greater than or equal to self baselimit or why does this need to use locals? Wait, really? Shared is copy. Oh, shared is copy. Nice. That. That makes me feel a lot better. Or table is null I guess.
03:10:32.099 - 03:12:10.665, Speaker A: Actually this doesn't handle the case where Interesting. This is actually going to crash if the table hasn't been allocated, so we might want to Special case that it's a little awkward is if table.bin if table is null then 0 else table bins len and then this should be len. Oh, what did I mess up? Oh, maybe something down here. Yeah, or self table is null. Or I wonder why are all these locals necessary? I don't understand. Because these aren't concurrently accessed anyway, they're not volatile, so I don't use locals and checks.
03:12:10.665 - 03:12:58.655, Speaker A: It sounds like it's to make sure you only read them once, but that doesn't really seem like it makes sense either. T is equal to length. Oh, it's because they might get overridden as we walk through. That's why. Yeah, that's definitely why. Or self.table.bin Lens is less than or equal to self.index
03:12:58.655 - 03:14:17.325, Speaker A: or if I is less than zero how is that even possible? Where is I reassigned? I is equal to index. Can index ever be less than zero? Where does index get overwritten? Index gets plus plus base index. Where does base index come from? Base index never changes. So I'm pretty sure index can never be negative, which means that I can never be negative. So I'm pretty sure that check is unnecessary. So in this case, prev is null and we return none. I guess up here we need to return some of that.
03:14:17.325 - 03:15:43.377, Speaker A: All right, what else we have? All right, now we get to the gory parts. So let, I think for tab at is the one that we renamed to bin to bin. And so this is really saying let bin is self table, bin and I here is self.index, right? So this is where they do some, like, funky stuff where they say, like, let I is self.index, let t is self.table and then this is a read on t and this is a read of I. And the reason they do that is because presumably they're claiming that these values might change and you want to do the read on the local variable.
03:15:43.377 - 03:17:15.645, Speaker A: I'm not so convinced that's true, but I guess we're about to find out. All right, so if not bin is null, so remember how they're playing this trick where if the hash is less than zero, then it's a special type of node and they want to handle in particular here forwarding nodes. Whereas for us, that's a little different. What we want to do here, if you remember, is, I guess we need to pass in the guard here, don't we? The bin gives us back a shared bin entry. Right? So what we actually want to do here is we want to match on that. Actually we probably want to do. We want to match on that bin and if it's a bin entry moved.
03:17:15.645 - 03:17:59.355, Speaker A: Right. Table, then we want to do whatever they're saying right here. What about with overflow? It could be overflow. You're right. The check for I less than zero. But Rust should panic. In that case, I'm pretty sure, because if it's moved, then self table is equal to.
03:17:59.355 - 03:18:39.339, Speaker A: Oh, that's what it does. I see, I see, I see, I see. Then self table is going to be. I guess this is where the place where we follow moved. Interesting. Oh, right. That's going to be in node.
03:18:39.339 - 03:19:16.245, Speaker A: In node is where we follow moved. Right. So this is like where it got moved to. And in this case, we want to say that we're now iterating over next over that next table instead of the table we were iterating over. And in this case self prev is now null because we're no longer in were no longer on a particular entry. And then they're doing this push state business. And I think what they're doing here is actually every time they move into a new table, they sort of.
03:19:16.245 - 03:19:40.117, Speaker A: They keep track of which table they were in and what I they were at. And then they. Then they recurse into that table and then when eventually that table yields something interesting, then they popular. When you're done iterating over that recursion, then you iterate back up. I see, I see, I see, I see. Yeah, yeah. Okay, this is.
03:19:40.117 - 03:20:23.173, Speaker A: This is kind of special. So what we're going to do here is. So this iterates back up. So here what we're going to do is self dot push state. And here you'll notice it actually uses T and I and N. What is N here? N is the length of T. Right.
03:20:23.173 - 03:21:27.525, Speaker A: I don't think they need to do this. I think they could just push tab and stuff before they modify them. But seems fine enough. All right, so in this case we want to recurse down into the target table and make sure we can get back up to where we're at. All right. And then otherwise. Right, so that hits a continue and there's technically like a tree bin case, which we're going to ignore for now if we get to a normal table.
03:21:27.525 - 03:22:01.787, Speaker A: Right, so this is E hashes less than zero. So this is if there's a special node. It is not a special node. So bin entry node. Right. Which is this case. Then what? Then they're saying if the stack which is this table stack business that we haven't looked at yet.
03:22:01.787 - 03:22:49.515, Speaker A: What is spare for interesting? If self stack. I don't know what this does yet is sum, then recover state. We haven't written this sort of state recovery business yet. Right. So we're going to have to deal with that at some point. Otherwise, I guess else if indexes I plus base size. Okay, so it does mother modify index here.
03:22:49.515 - 03:23:20.728, Speaker A: All right, fine. This like I being able to be less than zero is weird to me, but fine as ice. ICE, I guess. But it's no. It's instantiated at the top of this loop. Okay, so this would only be the case if self.index itself is an ice.
03:23:20.728 - 03:23:39.865, Speaker A: Ice. Fine. So this will be an ice ice. Then that will be an eye size then. Or self.index is less than zero. I guess we'll keep that.
03:23:39.865 - 03:24:15.538, Speaker A: This Else if is else if I +self basesize is greater or equal to n, then self.index is equal to I +self basesize. Gee, this is executed regardless. So this is really an else. Self.index equals that. And if self.index
03:24:15.538 - 03:24:54.515, Speaker A: is greater than or equal to n, then self.index then self baseindex + equals to 1 and self.index is self baseindex. Okay, so let's see if we can actually reason about what this does. If the stack. If we. If we're walking and.
03:24:54.515 - 03:25:19.073, Speaker A: Okay, so this is the case where we have. We have hit the end of a bin, right? If we were in a bin, then this would. This would happen. So we've hit the end of a bin. This is. We're done. There is no next bin.
03:25:19.073 - 03:25:59.205, Speaker A: Otherwise there is the next bin and we look at the head of the next bin. If the next bin is moved, then we need to recurse into the table that it was moved to. Otherwise if we've stored some state, then why do we recover the state? This one's unclear to me as of yet. Let's ignore that for now then. Interesting. Oh, this is why. This is not bin.
03:25:59.205 - 03:26:49.267, Speaker A: This is E. Oh, I see what's going on. Then this is really E is equal to N, which is not really true, but it's kind of true. It's also a little awkward. It's not clear that I'm allowed to do that. Notice that this, this is like little sneaky clause here of E equals tab at. So if we get to here, then we're going to.
03:26:49.267 - 03:27:45.187, Speaker A: The next node we're going to consider is going to be the start of the next bin, right? And then if that happens to be a forwarding node, then we set E to null because we're going to start iterating over the other table instead. But if it was not a forwarding node, then we. Why do we recover the state? Still don't know that. But then we. Let's say we take neither of these cases, then we will just start iterating over that bin. Okay, so then it becomes. What are these two cases? Well, this case has to do with this push state.
03:27:45.187 - 03:28:44.255, Speaker A: So I guess we need to look at what push state is. Saves traversal state upon encountering a forwarding node. Okay, so it just preserves a bunch of state and recover state. Just brings us back. Not clear why that matters. Like isn't it just going to. When it hits a forwarding node, it's going to set the table to the next node and E to null and it's going to store the current the table we were at and it's going to loop through E is going to be null.
03:28:44.255 - 03:29:22.685, Speaker A: So it's going to go down here, it's going to look at the first bin, it's not special. So it's going to go down here and stack is going to be not equal to null. So it's going to immediately recover that state. So this write to tab is just going to be overwritten. Ah, but we're going to read from tab first up here before it gets recovered. Oh, this is some sneaky code. I see what's going on.
03:29:22.685 - 03:30:30.585, Speaker A: Oh, that is all sorts of sneaky. Okay, let me see if I can explain what's going on here. When we hit a forwarding node, here's what we're going to do. We're going to set the current tape, we're going to store the table we're currently in. Like we're going to store basically our current state and then we're going to recurse into that table and then we're going to continue. And when we continue, we're going to execute this code as if we are in that table. Right, because we set tab and T gets set to tab here and then we read the bin from that table and then we're immediately going to recover the table we were in.
03:30:30.585 - 03:31:29.535, Speaker A: So we're going to like recurse down just for the purposes of looking at that bin and then we're going to pop back up. It's a little unclear to me why this is necessary, like why you can't just read out E from here. Like why is the solution not to do here? E is equal to tab at this and I. I'm not sure what does push state do. Stack is S doesn't actually clear any state. Okay. So it's going to immediately recover the state again and then it's going to continue.
03:31:29.535 - 03:32:50.205, Speaker A: And now E is going to be not null. So now then it's going to walk the bin, just hit this case repeatedly and then eventually it'll get to the end of the bin that we sort of pop into and it's going to. And then it's going to try to read from the top level table again. And how does it know not to continue where it was? What does recover state do? Oh, that's awful. Why would they write it with this? An index +LEN is S dot length. The question is how does it end up? Also how does it hit this clause? Oh, oh man. This is.
03:32:50.205 - 03:33:40.595, Speaker A: Okay, it's going to. The first time it hits a forwarding node it's going to go into this clause, it's going to push the state change table, iterate over and descend into that table. The second time it hits the forwarding node, it's also going to do the same. It's going to push the state. No, but it still ends up in this. It still ends up in this clause, the set stack. Hmm.
03:33:40.595 - 03:34:46.205, Speaker A: Oh. This code is written in such a convoluted way, like the control flow here is awful. Okay. Okay, let's say that we're bin zero and bin zero is a forwarding node. We're going to execute this code. This is just going to sort of straight execute because it is equal to null, so it does not go in. We're not out of range, so we're going to keep going.
03:34:46.205 - 03:35:20.895, Speaker A: It reads bin zero and its hash is less than zero because it's a forwarding node. Now it changes table to the forwarded table, and then it remembers that we were at bin 0 in the original table. And then it continues, it goes back to here. Then E. E is the E is null. So it does not go in here. It now reads the.
03:35:20.895 - 03:35:47.849, Speaker A: It now reads the ith bin. So the same bin we were at in the original table, the ith bin of the target table, and that is a normal. That is a normal node. It's not a forwarding node. So it does not enter the cells. It does not enter this. If instead it goes down here.
03:35:47.849 - 03:36:57.913, Speaker A: Stack is not equal to null. So it's going to recover the state, and when it recovers the state, it's going to do this business which resets the table. Which resets the table and the index. Even though we haven't changed the index at any point here, none of this changes the index, only this clause does. So this recovers. What is this? If S is null, if we've recursed all the way up to the top. Oh, okay.
03:36:57.913 - 03:37:49.165, Speaker A: If we have recovered all the way up to the top level table, then. Then we add base size to the index and adding high to the high half of the target table. Except we're still in the. We're still in. The tab refers to the low table. So this is the termination clause. It's saying if that is greater than N, then we have completely exhausted this bin.
03:37:49.165 - 03:38:46.465, Speaker A: Oh, I think I see how this is starting to hang together. Okay, so what we're actually going to do is we're going to. When we hit a forwarding node, we're going to follow it all the way. There might be multiple forwarding nodes. Right? We're going to follow the forwarding nodes to the same bin in the deepest table and then once we've gone through that bin, then we're going to pop up. We're going to pop up all the way. Ah, we're gonna pop up one level.
03:38:46.465 - 03:39:14.351, Speaker A: Yeah, it's. This recover state is not really a recover state. It doesn't recover this state. It recovers us to. It recovers us to the high bin of the table above the one we were in. Okay, I think. I think I see how this hangs together now.
03:39:14.351 - 03:40:31.965, Speaker A: I think what we're going to do is actually just port this code relatively directly and then leave a comment as to roughly what it is doing. But this is definitely going to take a little bit of. All right, let's give it a shot. So we're going to need recover state and we're going to need push state. So up here we're going to do what was it called? Push state itself and it's going to take T and I and N, K V S. Okay, so T, I and N and push state seems pretty straightforward. This like reuse business is probably to avoid allocations would be my guess.
03:40:31.965 - 03:41:38.725, Speaker A: So there's going to be this notion of a table stack which we're also going to need I guess up here. Actually, no, it's going to go at the bottom. So a table stack and a gkvs, because we don't really have a choice. And a table stack has a length, an index, a table and a next table stack. And I think for these, these are actually going to be boxed. It's like one of the tricky things here. Let's.
03:41:38.725 - 03:42:30.621, Speaker A: No, we're going to leave that for now. All right. And then this table stack I guess we're going to have up here somewhere. Stack is going to be a table stack of GKVs and it's going to be something like an option box because initially it's probably none and then push. And there's also this notion of a spare. What is the spare for? Oh, the spare is so that we hopefully do not have to allocate. It's sort of one that we can reset and reuse if we wish.
03:42:30.621 - 03:42:58.349, Speaker A: Theory this could use like a. Not an arena allocator, but it's sort of like a pool allocator. And this is sort of a poor man's pool allocator. Okay. So pushing the stack is going to be. That stack is going to be self spare. Take and if.
03:42:58.349 - 03:44:05.515, Speaker A: If s not equal to null, let's sum s is stack then self spare Is S dot next where next? Because next is an option here as well. Yeah, this is really. These. These next. The. The next pointers in spare are just there to. Basically this is a linked list, right? This table stack is really just a linked list and what we're going to do is the tail of the linked list or if we need a new table stack, we're going to try to steal whatever is at the head of the linked list of things that we're not using and when we stop using something we're just going to stick it onto that linked list.
03:44:05.515 - 03:44:31.945, Speaker A: It seems fine. I don't really know why it has to be a linked list. Like my intuition here would be to make it like a like rather than allocate each one. But shrug there. There might be a reason. I guess we're about to find out. Otherwise.
03:44:31.945 - 03:45:54.585, Speaker A: Otherwise we have to allocate one. I guess we're going to do stack is stack, unwrap or else if there wasn't one then we have to allocate one which I guess only default values it seems like. So it's going to be like length zero, index zero. My guess is this is actually going to be. All of the fields are going to be instantiated just below going to be table and next is going to be none. Yeah, exactly. So then we're going to say there's like there's a different way for us to do this, which is arguably nicer.
03:45:54.585 - 03:48:00.375, Speaker A: But instead I'm going to say yeah, actually let's just do. Let's setup on the stack notice and it's going to have table, it's going to be T, it's going to have length which is going to be N it's going to have index which is going to be I and it's going to have next which is going to be stacked is going to be self stack, tick and then what we're really going to do here is if let sum S is stack then we're going to do if let's sums we could technically do a map here instead. But what I'm going to do is fine, let's use the same. This is not really stack because the stack is what we're the stack we currently have like self dot stack and so I want to use a name that's not that. Um, so if that already is one then what we're going to do is sum. We're going to do standard or actually we don't even need to do that. We do star S is target and do sums.
03:48:00.375 - 03:48:36.025, Speaker A: Otherwise we do Box new of target. That way we don't have to repeat the instantiator and the fields. Right. So this is out get on the stacks, it's basically free. And then we're going to set self stack to be either. If we did get a spare, then we're just going to overwrite that spare with whatever is in target and then return it. Otherwise we're going to use.
03:48:36.025 - 03:49:17.805, Speaker A: Otherwise we're just going to allocate a new table stack. So that seems about right. All right. And then recover state mute self also takes an N, which we still have to sort of figure out why that is. But recover state is going to do let mut. I guess let's do a loop. S is going to be self stack.
03:49:17.805 - 03:50:11.825, Speaker A: Take. I guess this is then really self stack. Take and then self.index+ equals. Ah, but this doesn't actually take it, does it? Yeah, this doesn't actually take it. This is while let some is self stack. That's really what we're doing.
03:50:11.825 - 03:51:15.357, Speaker A: So while there is a current stack frame, then we increment index by S length. And then if self.index is greater or equal to N, I guess actually if it's less than N then we break. See, this is where comments would come in really handy if the original author of this code had actually commented. Okay, so N is going to be mutable, apparently. Then N is going to be S. Length and index.
03:51:15.357 - 03:51:36.115, Speaker A: This is self.index I don't like that. In Java you don't have to say whether something is referring to a global field or not. It's not great. Self table is S table. Right. So this is the popping part.
03:51:36.115 - 03:51:57.913, Speaker A: And then S. Oops. Table. Hello. And S table is shared null. This is just to make sure. I assume that we don't have dangling.
03:51:57.913 - 03:52:45.995, Speaker A: We don't have pointers to things we're not allowed to have pointers to anymore. And then next let next is. What is this though? Oh, I see. This is we popped S. At this point we're popping S. That s is self.stack.take. we are popping the stack.
03:52:45.995 - 03:53:33.365, Speaker A: And so at that point, once we have decided that we're popping this, the stack, then we want to save that stack frame for reuse. So here, save stack frame for. And that includes we're going to reset the table. We are going to. We're going to add it to. Oh, interesting. Oh, I see.
03:53:33.365 - 03:54:15.365, Speaker A: We need to. We need to keep track of what the next stack frame is. Right. We're popping. And s dot next is the next Stack frame we're looking at. And so I wonder why is this not just the next variable is just not needed here? If you just move this line to here, then you're fine, right? Self stack is S next take. So unclear why that next is necessary at all.
03:54:15.365 - 03:54:44.475, Speaker A: But we do need to reset it for next use. And that's going to be S dot table equals null. Don't know why they said S table equals null. Maybe just to not have an invalid. Oh, it's probably for garbage collection. You want to make sure that the in Java, right, It's going to analyze the entire stack to figure out what things to free. And if you had these things sticking around in spare that held up garbage collection, that would be bad.
03:54:44.475 - 03:55:50.047, Speaker A: So but for us that doesn't really matter because we don't have. We can at least like make sure we don't leave an old pointer around even though it probably won't matter, right? And next is going to be self spare take and then self spare is going to be S. I guess some S. Oh, see. Okay, so this code is already easier to read, at least to me. Look at recover state, right? It doesn't actually pop the stack the first time you try to pop the stack it increments index. But if that index is still within range of the current table, it's not going to pop.
03:55:50.047 - 03:56:44.585, Speaker A: Instead it's just going to. It's just going to go to the high bucket. Don't pop if we are still in bounds instead. In fact this changes, right? That sets index. So really what we could do is this and that is much easier to read, although it's going to use that here. So well, we can write this as if self.index/s. Length is less than N.
03:56:44.585 - 03:58:03.527, Speaker A: It does mean that we repeat this operation, right? This addition is going to happen twice, but it makes much easier to read code. So what we're going to say is if. If we haven't checked the high side of this bucket, then do so then do not pop the stack frame and instead move on bin, right? So notice that this does not pop the stack frame only once. We have gone through the sort of other instances of the bin that we started forwarding down. Only then do we actually pop the stack frame. And then at the end here there is a. That's just a break.
03:58:03.527 - 03:59:07.125, Speaker A: That's equivalent to a break. Yeah. And then down here if S. What is S? Here S is self stack. This is the first thing it's assigned to. So if self stack dot is none and index again like These like inline assignments and conditionals are make for terribly hard to read code. If self stack is none, then we're going to do self index plus equal safe base size.
03:59:07.125 - 03:59:45.575, Speaker A: And then if self.index is greater or equal to n, then self.index then self.base index plus equals one and self index is self baseindex. All right, let's see if we follow this. If we've gone all the way down to the top frame. So this is like the original map that we started iterating over.
03:59:45.575 - 04:00:28.455, Speaker A: Then we're going to try to move index plus equal self base size. Does base size ever change? I feel like base size does not change. Be very weird, but it doesn't mean that we have to parse all these inline. It does not. But base size. How can index plus base size ever be. Oh, I see.
04:00:28.455 - 04:00:59.705, Speaker A: That's sneaky. If we go all the way up to the top, this might actually be easier to draw. Let's see how this works. And if it works, ignore for now. All right, back to one of my famously bad drawings. So when you initially create an iterator, what you get is a pointer to a table. And that table.
04:00:59.705 - 04:01:45.313, Speaker A: Oh, wow, I need this to be less stupid. Wacom that command. This is the pointer that the iterator holds, right? And it has a bunch of bins. And if a particular bin has been forwarded to a new table, right. That new table is twice as long, right? And there, sort of. If we imagine that this is the current bin, right. Then really you can imagine that there's sort of an artificial line here that's like the same N as the number of bins in the original.
04:01:45.313 - 04:02:47.465, Speaker A: And the low half, like we talked about before, the low half of the bin is here and the high half of the bin is here, right? So we want to iterate through all of them. And this is at the old I. And this is at the old I +N, where this is N. But now imagine that this is also a forwarding node, right? This is a forwarding node to a table that is sort of mirrored yet again, right? So now there's one here, and there's one here. And then both of those have their own mirrors. They both have a low and a high, right? And so there's a low, there's a low of, there's a. What would this be? This would be a high of the low bin, and this would be the high of the high bin.
04:02:47.465 - 04:03:46.401, Speaker A: And notice the difference between these is N all the way along, where N is like the original N. And so if we have recursed all the way down to this table, so the sort of current table in the current N if is like 4N, really, then one way for us to iterate through all these bins is to take the original I we had for the bin we're at, and then iterate through I, I plus N, I plus 2 and I plus 3 and etc. Until we have ex exceeded the length of the current table, which is 4N. And so that is what this code is doing. It's saying we're going to iterate up to the top. Once we no longer find forwarding nodes, we're going to go back up to the top and we're going to add base size, which is like the size of the first table. So the N here to index.
04:03:46.401 - 04:04:38.315, Speaker A: And if that index is now greater than N, where N is the size of the deepest table, only then have we iterated through all the highs and lows of all the highs and lows of all the intermediate bins. And then we move on to the next base index. And now the index is the next base index, right? So that would be equivalent to us moving on to why can't I do this? Because apparently I'm bad at this. So at some point we're going to move on to this bin, right? And we're going to move on to that bin only once we have iterated through. Because this N is actually base index. Base. No, base.
04:04:38.315 - 04:05:27.457, Speaker A: What's it called? Base size, right? And N is really. This N is equal to four base sizes, right? So that's going to be N. And so once we have iterated once, we're going to keep increment, we're going to keep adding base size to the current index we're at until that index is greater N, which is some multiple of the. Some power of two multiple of the base size. And at that point we want to increment the base index. So base index. Sorry, my writing is terrible.
04:05:27.457 - 04:06:10.637, Speaker A: Points to here. Even once we start recursing it to these. And only once we, we've sort of tried to move into this area and been like, oh, that's out of bounds, even in the deepest one, then we increment base index. So now we're going to move to the next bin, which is over here, and then the whole sort of juggle starts over again. This is also why it's useful to, you might see from this drawing why it's useful to keep these tree stacks. Because if you remember, when we do a resize we do it bottom up. And so once you have hit one of these forwarding nodes, you're going to keep hitting the same forwarding nodes going down and the at least as deep as they were further up.
04:06:10.637 - 04:06:51.385, Speaker A: And you will need at least as many tree stack nodes. All right. Hopefully that made a little bit more sense than my rambling earlier. That roughly makes sense. I'm not sure if the chat is working currently because sometimes it gets sad. Okay. But I think now we have a decent sense of like the next part of the top level bin in the deepest table.
04:06:51.385 - 04:07:21.661, Speaker A: Largest table. We've gone past the last part of this top level bin, so move to the next top level bin. Sweet. Oh, chat seems to work. That's good. Okay, you both work great. Just wanted to double check.
04:07:21.661 - 04:07:44.757, Speaker A: All right, so now at least we know roughly what this means. Recover state is a bad name for this function, Right. It's like next bin is really what it's about. But let's ignore that for now. So that's going to recover state. Yep. Yep.
04:07:44.757 - 04:08:41.925, Speaker A: I don't know why this is also necessary, but I'm just gonna believe them. I plus base size. Yep. All right, great. I think that's all of the Iterator code, right? Yeah, I think that's all the iterator code. So now the only thing where this is probably going to go wrong is if I remember correctly from node, it's not possible to have a shared node. You can only have shared of bin entries.
04:08:41.925 - 04:10:03.675, Speaker A: Which means we're going to have to do some like, unnecessary matching, which is a little Specifically, this is going to be a bin entry, last bin entry iterated over. Even though we know it will always be a node. Which also means that in our iterator implementation we won't actually do things like I guess, didn't we have a as node? Yeah, we did as node because we know that this must be a node. So we're going to do an expect we only ever iterate over nodes. Oh, I guess that's why it's not mod traverser. That's why this isn't being traverser Traverser. So I'm doing something wrong here.
04:10:03.675 - 04:10:31.885, Speaker A: Where's my syntax error? Traverser line 35. Great. Finally formatting. Oh, cool. Hi Zorin, thanks for editing Roastation Station episodes. It's really awesome. All right, so I think in theory that means that this iterator should now work.
04:10:31.885 - 04:11:01.705, Speaker A: So here, notice we don't actually get to use the N here. This is going to be equals bin, but that's fine. We don't really worry about that. Okay. Yeah, I think that's good. I think that's good. And in theory here we could totally have some.
04:11:01.705 - 04:11:31.383, Speaker A: We could have a bunch of test cases here for this Iterator in particular. Right. I think where this is going to get complicated is the guards. I don't have a good solution for that. I think what we'll want here is actually node iteration. Yeah. This really is a.
04:11:31.383 - 04:12:01.705, Speaker A: I guess it's a bin entry iter but it really is a node. Why does it do that? We can call it a bin integer. That seems fine because that. That is what it's going to yield. Even though it's not necessarily. Even though we know that they are all nodes. And so this is going to be a bin entry, sadly.
04:12:01.705 - 04:12:35.705, Speaker A: Yep. And so here one thing we could do is like in fact, why don't we do it anyway? Mod tests. We can have like an integration test here which uses. Super. Super. I guess just create is fine. And here we could actually set this up if we wanted to.
04:12:35.705 - 04:13:11.755, Speaker A: That might actually be the right thing to do is rather we can just construct the table the way we want. But like that would be the. Rather than this using the flurry, the like top level hash map interface. This could just use the. Like construct a table itself and then do the iteration just so we have more control over like where are their forwarding nodes and that sort of stuff. She. Maybe we just want to do that.
04:13:11.755 - 04:13:30.375, Speaker A: This doesn't care about things like hashes. So we can just. It's totally fine for us to construct what is essentially an illegal table here. So let's do that. Let's just do that. That seems great. Interempty.
04:13:30.375 - 04:14:13.975, Speaker A: Right. So I'm going to just create a. I forget exactly what t lib what's in a table again. Great. So table I guess fine. It'll be an owned new use. And this is just going to be.
04:14:13.975 - 04:14:55.835, Speaker A: I don't know, like 16 seems fine because it's a default anyway. Right? I guess default capacity. No, I want it to be 16 and then we're going to say iter is going to be a bin entry. I guess we need a guard. I guess let's do self. Nah, let's do. Here use crossbeam epoch and we're gonna.
04:14:55.835 - 04:15:31.395, Speaker A: We're gonna construct a new one of these. Didn't we add a constructor to this? We didn't. Great. So we're going to do a bin entry iter and we're going to do table shared from table and we're going to do a guard as a reference to the guard. And then we're going to do assert equals iter dot count should be an iterator. Right. Zero.
04:15:31.395 - 04:16:06.881, Speaker A: We're just gonna see what happens. Well, a bunch of things are failing Bin entry. Okay, that is easy to do. Unexpected type argument table doesn't take S. Oh, that's lovely. That is lovely. We don't need the S here at all because all it cares about are the tables.
04:16:06.881 - 04:16:55.351, Speaker A: Oh, that makes me so happy. This great, great. This is great news. Love simpler type signatures. What else do we have? That's a bunch of stuff here. I'm guessing a bunch of it is going to be related to shared not implementing DREF112. What now? Fine.
04:16:55.351 - 04:17:39.975, Speaker A: I guess I'll do cargo check first. Yeah, a bunch of these are going to be the same thing. Okay, so Traverser is not going to need Atomic or we are going to need owned down here. So we'll do this and owned. But it's more going to be things like here, right. Where it's unsafe for us to deref bin for example. And this is like the normal.
04:17:39.975 - 04:18:46.855, Speaker A: The normal argument we have to make. And the argument here is that why does this even need. It's a good question why that even matters. Like how could this possibly be unsafe? Shared was read under the guard. I guess Flurry guarantees that a table read under a guard is never dropped until after that guard is never dropped or moved until after that guard is dropped. Right. This is the same sort of safety guarantee that we've been using everywhere, essentially.
04:18:46.855 - 04:19:19.275, Speaker A: And my guess is most of the other ones here are probably going to be the same. What is this? I index. I Right. Table stack index is an ICE ice Even though there's just no way it's ever negative. I just do not believe it. But I guess it was we said overflow. I don't want to care about overflow.
04:19:19.275 - 04:20:04.579, Speaker A: Really don't. Yeah. I don't believe it. I don't buy it for a second, but maybe I'm just being stupid, but I don't buy it. I don't want to inherit their weird oddities for how this should be. Oh yeah, that it didn't compile because I mixed use and I size but I'm instead of I'm just going to use use everywhere because I. I think, I believe that that is the right thing to do is to not inherit the like overflow behavior from Java86.
04:20:04.579 - 04:25:40.935, Speaker A: No field length on option table stack. Okay. This we can unwrap because of the While at some above while at sum that should help with a bunch of these 117 this is another unsafe draft safety is that flurry guarantees that a bin entry read under a guard or it's really just any read under a guard from inside a table will remain valid until been dropped. So I should take care of that one three one is probably going to be the same argument here is my guess. Yeah see this is so this is unsafe right? Draft safety flurry only deallocates after guards guard drop and we really could use this for like all of them all of the ones in this file at least are really just relying on that same that Same safety guarantee 133 Take value of method bin no bins that's the one 145 this is going to be the same thing where we're going to do let match unsafe bin draft and this is the Same safety guarantee 148 here here we have to make the same safety guarantee that for the other place where we follow moved so if you recall in lib this one yeah so the argument there in fact the argument here is the same as the one for why following moved here is safe as for following moved in bin entry find which is that we still hold a reference to the and since that hasn't been freed nothing nothing later than it has been freed either because we haven't dropped the guard that we used to read the top level table 149oh actually this is another thing that's kind of stupid. We need to keep the table and that needs to be passed as a shared down here I think because it can't is a the table stack in theory could store references instead of shares probably but it wouldn't be able to restore them. So in fact one thing we could probably do here let's finish it with shared first But I think we could probably make this a regular reference rather than a shared and same with this in which case we could even make it a node.
04:25:40.935 - 04:28:02.635, Speaker A: In fact how about we just do that so this is going to be a reference to a table under that guard, right? Oh I guess we can. That's fine. We can take a shared here and then do like this. Oh I see fine. No, this can just be an option table is the real way to do this where we're going to say that table len is going to be this or table is that and then we're going to return some table and table bins len and that's going to be table that's going to be len and the reason for this is because we already established the fact that we're allowed to deref these shareds when we access them, and because the guard because we know that the guard is outliving this iterator, which this means this can be node. Now we already know that all of the references that we deref are going to outlive this guard. And since we stored this guard in the iterator itself, these can be stored as references because they're going to remain valid for the entire.
04:28:02.635 - 04:28:59.509, Speaker A: The reason we want this to be shared is because it's going to be read out by the caller and that means that it might be null, right? Like for example, if the table hasn't been allocated yet and we want to keep that interface, so we're just trying to be nice to the caller. But everywhere else here these can just be node node. In fact, it means that this can even yield these because the guard, again remember is tied to the iterator. So as long as the iterator lives, as long as the iterator lives, the guard lives. And this returned thing is tied to the lifetime of the guard. And so it's fine for us to return them. Which even means that even if you drop the iterator, this reference is going to remain until the guard is dropped.
04:28:59.509 - 04:30:05.829, Speaker A: It is independent of the lifetime of the iterator, which is what we actually want. Which also means that this can be a reference. And it also means that this really a none. It also means this unsafe can go away. And here we're going to need this is going to be next then if next is null, then E is none. I guess we can just do. Let E.
04:30:05.829 - 04:32:45.505, Speaker A: We can just do E is if next is null, then E is none, right? Where if it's not null, then we're going to have to an unsafe next draft. And the safety here is again that flurry only flurry does not drop or move until after guard drop. The move is important here because if it can move, then that would also invalidate the pointer stored under the shared, right? And then this is going to be a sum and the next here we also know is going to be a because only nodes follow nodes if and now this becomes if let sum E equals E then Yep, because we already do the D in the constructor this can now just be straight up self table. This does have to have an unsafe because here we're getting another shared bin draft. But then we can match on the bin just fine. That's fine. I guess this is really.
04:32:45.505 - 04:33:40.865, Speaker A: These can probably all just be represent star. No, they probably can't be actually. And then prev is going to be none. Now it's no more this shared business where we can avoid it. This is going to be if let some prev is self prevailing. Yep. And I guess this doesn't even need to say this because it's already.
04:33:40.865 - 04:34:43.365, Speaker A: It starts as none so we can just say if not next is null then this, then E is this. Let's see what else do we got here? That does have to be unsafe. That does have to be unsafe. E can now be to node no longer need the e to just refer to bin entries because the reason we couldn't before is you can't construct a shared node or you can only construct shared bin entries. But now that the references it's fine. Okay, that makes me so much. Let's see what this looks like.
04:34:43.365 - 04:35:46.489, Speaker A: Oh, I mean it's gonna. It's gonna complain right now this we still need to import node into here. Should make it a little better. Line 45 prev is now also gonna be a none. 89 it's gonna be S.it's going to be sum of s table Actually I guess really for this iterator business to work like this has to be option table because over. Okay, so the thinking here first of all was table can be none, right? If it hasn't been allocated yet.
04:35:46.489 - 04:36:47.406, Speaker A: But I don't think you should construct a table stack on something that isn't allocated yet because you wouldn't see any forwarding nodes. So technically this should actually you should never be able to construct a table stack where the table is none. And so really this should be sum. It's guaranteed to be. And here where we call push state. Where is our push state up here? So this is an is none. This is an as ref unwrap and down here we actually know that this is none in if above right, we know that this is sum because of this is none up here.
04:36:47.406 - 04:37:55.813, Speaker A: And so therefore we can operate on it. Let's see what that gives us. 45 expected node prev this is also an option because there might not be. There might not be a previous node that we've iterated over. Where are we at now? 94 this is just getting rid of the reference though it probably doesn't matter there either. 121Next.de oh, this is just bad parenthesizing 94 Yep.
04:37:55.813 - 04:38:26.565, Speaker A: This now is just not a thing because remember here this is where we set when we're storing one of these stack these like Table stack that we use to keep track of how deep we are. We use to set the table to none, which is what the Java thing did get things garbage collected, I assume. Whereas for us, that's now a reference. And you can't set references to none. They need to always be valid. But I don't think there's any reason why this wouldn't be. So I think we're just going to do that.
04:38:26.565 - 04:38:53.384, Speaker A: 130 is going to be that. How we doing? 151? Oh, I see. This is a raw pointer. It is not a. It's a raw pointer. It's not a shared. And 151 expected option.
04:38:53.384 - 04:39:23.145, Speaker A: Right. Expected table found star. I see. Because this is going to do a match by reference is why. And 56 cannot borrow S.0 is mutable as S is not declared as mutable. That's fine.
04:39:23.145 - 04:40:08.515, Speaker A: Nice. All right, now let's see if this test actually does anything. So here we're going to do with a shared from that table. Let's test the lib. We need atomic and we need shared. Wait, how do you go from an owned to a shared? Isn't there into shared? That's fine. Although I kind of wanted to.
04:40:08.515 - 04:41:31.335, Speaker A: Hmm. This consumes self, which is a little sad, but. But I guess what we can do here is table is table dot into shared with the guard. And now this table can be passed in here we assert on it the iter is dropped. And so now we can do table dot into owned. Actually, I don't even need that scope. And the safety here is nothing holds on to, well, to references into the table anymore.
04:41:31.335 - 04:42:18.535, Speaker A: I did and cannot infer key type. Fine. Key type is going to be usize. Ooh, segmentation fault. Invalid memory reference. All right, so something here is broken, I guess. Actually there's an even simpler test here, which is we don't even do this.
04:42:18.535 - 04:42:44.465, Speaker A: We don't do this. We just do shared null. Let's just make sure that that actually works. Right. Like this is just super straightforward stuff. And I guess we need a type here as well. That's fine.
04:42:44.465 - 04:44:04.823, Speaker A: All right, so at least that works. So this is like iter new and this one has been allocated, but all the bins are empty, whereas this one is like a complete blank. And my guess is that the segfault occurs up here where we need to check if bin is null. Then what? What does it do? It only executes this whole business. It's just going to loop, I think. Oh, this code gets executed even if the current bin is null. So we actually need, we need these lines to come down here and then this is going to be.
04:44:04.823 - 04:44:58.979, Speaker A: If not bin is null, then we're going to do this and then we're going to do that. Nice. Okay, so we now have an iterator that iterates over nothing. So that seems helpful. Now let's see if we can get it to iterate over something that's relatively straightforward iter simple or something. Right, so here, what are we going to do? Well, I guess here this is going to be a bin entry node. Right.
04:44:58.979 - 04:46:14.355, Speaker A: Remember here we're not actually constructing a valid table necessarily. All we're doing is, all we're doing is constructing something that node here is just going to be hash is going to be zero key is going to be zero usize. Now this should no longer be necessary. Value is going to be atomic new 0usize next is going to be atomic null and lock is going to be I guess mutex new. So we're going to here have to use I guess parking lot mutex. Now let's. It might very well not expected bin entry found owned Ah, like so.
04:46:14.355 - 04:47:34.795, Speaker A: This is actually not what we want. We want atomic null bins like so and then we're going to say bins zero is that the other one would have created 16 instances of this which is not what we want expected. All right, this has to be a semicolon. We want 16 of that mutex new of nothing. All right, that crashes drop table with non empty bin. Oh, we're hitting. I see.
04:47:34.795 - 04:48:22.505, Speaker A: During testing, if you remember in our, in our lib code dropped. What does it say? Drop table. Well, in our drop of table we we're going to drop all the bins but we assume that all the nodes have been dropped by the flurry map business and so we will have to work our way around that. And the easiest way is probably just to provide a helper for emptying bins. So this is just going to be like empty bins of a mute. I have water. Thanks.
04:48:22.505 - 04:49:46.857, Speaker A: Good call. Okay, so it's a knb and all it's really going to do is I suppose actually I'm going to make this even easier for us. I'm going to say that in test mode. In test mode we're going drop the tables. Ah, that's not right either. It's a little annoying right, because we don't really have to drop things in but it would mean that if you run a lot of tests you're just going to like consume a bunch of memory. Might not Matter too much here.
04:49:46.857 - 04:50:53.951, Speaker A: But it just feels dirty to not do it. How about we do something like fine, we're going to go back to what I had here and then this is going to move through all the bins and then it is going to. And then here I guess we're going to actually walk the nodes. And this is the same thing the flurry map does. Right? Remember the flurry map will walk. Will walk the table and for each one like drop all the nodes within each bin. It's a little awkward to replicate this functionality here.
04:50:53.951 - 04:52:08.085, Speaker A: Like that seems a little excessive. The other option actually is for us to just construct a flurry hash map. But it doesn't seem great either. Here's the actual solution to this which is impl. Actually just going to have a private drop bins on table drop bins and we're gonna. That's just gonna do the same thing of this. Boom.
04:52:08.085 - 04:53:13.425, Speaker A: And then we're gonna do table drop ins save. Great, great stuff. And the reason we want to do that is we can do in traverser we can do let mute t drop ins and then we can do the same here. See what that does. Great. Okay, so now it means it can iterate over at least one element. And I guess really what we want is something along the lines of we want to assert.
04:53:13.425 - 04:54:10.583, Speaker A: I guess we want something like here E is it or dot next unwrap and then at the end we want assert IC iter dot next is none. It's really what we want to do to make sure that the Iterator doesn't yield items that aren't there. And then we want to assert each something like the key should be 0 and the value actually key is 0 should be fine, we can make it 42 if we want to. But. Yep. And then we could make this. We could make this have a bunch of elements.
04:54:10.583 - 04:55:00.165, Speaker A: But I think that is relatively uninteresting. The one thing we can do is at least move this to like the middle of the map. Shouldn't make a difference what we will want though iter forward. Right. This is where it gets a little bit more hairy. Right where we're going to have one table and then we're going to have a next table. This is going to be deep bins deep table.
04:55:00.165 - 04:56:48.965, Speaker A: So here what we're doing is we're constructing bins. We're constructing the. Which is the one that has just forwarding entries. And here I guess really what we want is for bin and bins. Remember how when a table is moved when there's a resize all of the bins are replaced with these forwarders but we kind of want to emulate the case where only some of them have. So what we're going to do is all of the ones from let's say 8 and onwards we want bin to be equal to let's say bin entry moved and that's going to be at deep table as that. So this is going to be construct the forwarded to table and then construct and now we want to make sure that it still yields just that one element.
04:56:48.965 - 04:58:15.633, Speaker A: Right. So you'll notice that bin bin 8 is going to get forwarded. Right. And so in theory it should arrive at this entry in the deeper table. I guess we're about to find out. This needs to be a star bin and 261 this should say deep table and actually here this is going to be deep table drop ins. Can't Compare usize with i32 what? Why does it think the key here is i32? Interesting.
04:58:15.633 - 04:59:24.825, Speaker A: Well, and this does need to be mute table. That's fine. Great. Okay, so it does follow forwarding right? We're constructing the iterator over the top level map and then it follows the forwarding record and returns the one at the bottom. Okay, so now we have like a low level iterator test and now finally we can go back to the original test we were trying to implement which is this, these map check tests. So I guess git add dot commit oh man, I have messed up, haven't I? Diff cached it's going to include the formatting business. Yeah, Add, source iteration and that and this.
04:59:24.825 - 05:00:41.753, Speaker A: So here what we want I guess is we added node iter this add contains key and the formatting I think we can get rid of at this point. All right, so now it's time for us to try to port the first of these concurrent tests and that's going to be map check. And I think what I want to do here is I want to make their tests like Java or I guess upstream JDK JDK JDK is good JDK map check.rs and so here because I want these to map onto easily map onto the Java tests if possible. Right. So I'm going to use the same imports as I used over there and now we're going to have to figure going to. Actually no, that's not how I'm going to do it.
05:00:41.753 - 05:01:25.975, Speaker A: I'm going to raw we're going to do map check Java There we go. That way we don't have to switch to this all the time and I'll go over to somewhere darker. Okay. Main new map. Okay, that's fine. Run test force MEM T1 I'm guessing is test one. It tests one.
05:01:25.975 - 05:02:15.935, Speaker A: How are these even? Run end test one. How weird. Oh, the setup of this file is awful. Okay, I guess the idea is that T1 that they're going to run with things that are absent and things that are not. Okay, that's fine. I can do that. Why does it run multiple iterators? But all right.
05:02:15.935 - 05:02:46.345, Speaker A: T1 just. Just go with it. Man. This is going to be a static string name and use. It's going to be a flurry hash map. Who knows what the types here are. Object G.
05:02:46.345 - 05:03:34.939, Speaker A: Thanks. Okay, what calls test run test S Test test S key. Okay, run test map Map class map class new map. Okay, what does a new map do? Map class new instance. Okay, what is the key type? New object. I see. They're actually not even using a specific type.
05:03:34.939 - 05:04:07.965, Speaker A: They're just using the object type. That's chickening. It is true actually that like we could make all of these generic over the key and value and because we can. We will because why not? Awful stuff. Awful stuff is what it is. T1 Great. Okay, so key.
05:04:07.965 - 05:04:38.331, Speaker A: This should say keys. It's not key. They're lying. Is a vec of k and expect is a usize. Sure, if you say so. Let's sum 0 let iters is 4. They do timers which we're not going to do.
05:04:38.331 - 05:05:40.349, Speaker A: Although my guess is they probably use this for benchmarking as well. I'm just going to ignore the benchmarking aspect for now. For j in 0 to iters for why do they doing plus plus j on 1 and then I want if map.get map. Get keys I is sum. This is where we probably want to overwrite the square bracket operator on the map just so we don't have to call the get method. So we could totally clean up the API for this a lot.
05:05:40.349 - 05:06:34.685, Speaker A: Right. Is sum then sum plus equal 1. I can think of such better names for these variables. Timer finish and then at the end cert equal sum and expect time iters. All right, we have ported T1. I'm going to set up the structure around it too before we start porting the other T's. Okay, so they then have a FN test.
05:06:34.685 - 05:07:23.565, Speaker A: Great. I don't think I want that. I think I want a test T1 present which is really get present. Let's use sane names for these. And this does size S Key size. Okay, so there's some notion a set of keys. Do they run tests multiple times? Yes, they repeat the test multiple times, but with the same set of keys.
05:07:23.565 - 05:08:13.095, Speaker A: What an odd way to run these tests. But okay, this is going to be a let size s key absent. Okay so the call to. The call to test is they do let's size. Okay, they are. They shuffle the keys. That's how they differ with each repetition.
05:08:13.095 - 05:09:30.935, Speaker A: Maybe this would be good for a macro actually is keystop len don't care about the start time. Okay, so there's a. It's like a letkeys is equal to a vector of some form and that vector is of size. Where does size come from? Sure, why not numtests? No, I refuse. Size is 50,000. Where does absent size come from? Okay, so they have construction size it's going to be 50,000. They have Const absent size which is going to be 117.
05:09:30.935 - 05:10:30.675, Speaker A: Right. And then they really have a. This is really a macro rules something like stress maybe which really just takes the name of a testing function. Well, let's write it for one first and see what comes out the other side. Letkeys is going to be sum vec Then there's going to be a keys shuffle, which means we're going to need rng stuff. Let's do that in a bit. Absent I is new object.
05:10:30.675 - 05:11:32.763, Speaker A: Why do they even have an array of absent? This variable is not used. Oh, it's a awful, awful stuff. Okay, so they have a vector of absence which are just objects. All right, all right, all right. Run size is keys.len and then what else does test do? The keys are just basically random numbers because. So in if I remember correctly, in Java, objects are hashed by their pointer, which is sort of kind of random.
05:11:32.763 - 05:13:17.425, Speaker A: And so what this is going to do is it's going to give you different objects each time. So really this is going to be something like zero to size map, nothing like rent sort of collect. And there's an argument for like you could shuffle it if you want to but now that it's random anyway, it's like not clear it matters. All right, and then this computes size again because of course why not get present is then passed in. Why is this a separate parameter? Isn't it always just the length? It's definitely always just the length of the number of keys. Like they say size equals key dot length and absent size if we recall, absent size is just the size of absent. So in all these cases the first argument is just Right.
05:13:17.425 - 05:14:01.455, Speaker A: Am I missing something? Certainly for T1. All right, so this is not going to take an N. It's also not going to have a name. It is going to take a keys and it is going to take an expect. Then this is just going to be 4 key in keys and then this is just going to be key. Great, that is much better. That makes me much happier.
05:14:01.455 - 05:14:49.645, Speaker A: Now get present is going to do that and the as the is the S actually just empty. Nothing populates the S. Right. It's just new map which just creates a new instance. Okay, so it is indeed initially empty and that is presumably why. Why does it expect present? No, no, no, no, no, no, no. Here it actually expects all of them to be present.
05:14:49.645 - 05:15:54.695, Speaker A: Where does it doesn't. Instead this put test fills the map. So that's why. Oh, it's so stupid. It's so. So really there's just one test and it's like everything and the everything test is going to construct a bunch of keys. Then it's going to run a put test which is T3 because of course it's T3 and it's going to give.
05:15:54.695 - 05:16:48.867, Speaker A: Okay, so. Okay, okay, okay. Okay. So there's a map which is going to be just a flurry hash map new and T3 is going to be given a reference to the map and I think that's probably it actually. So T3 bear with me here. T3 why these names? Why? Why? It's awful. Okay, it's going to be generic over that.
05:16:48.867 - 05:18:48.095, Speaker A: This map is actually going to be this and this is going to be this. It's going to take also a map of course of knv and it's going to take a keys and it's going to take an expect. Very exciting. And what is it going to do with it? Well, sum is null 0 null n if I recall is size which is the length of key for I in zero. Fine, zero to keys len and then if map put keys I absent which not entirely clear what this is going to be yet absent mask is none. Okay, so expect here is the number of non overwrites and then assert equals some and expect this is. It's a little unclear what this absent business is.
05:18:48.095 - 05:20:06.973, Speaker A: I think. I think this is really just going to be non absent size. What an insane way to. Okay, absent mask is absent size minus one Absent size minus one and this is going to be like a sure an option of usize of. I'm just going to put absent. That seems fine. Although there's the absent things are all supposed to Be distinct.
05:20:06.973 - 05:20:57.011, Speaker A: So that's not going to work, but let's leave it for now because it's stupid anyway. Okay. And so everything is going to run T3 with that and keys and expect, expect all of them to succeed. It's going to run it again and it's going to expect none of them to succeed. So this is put absent, this is put present. Then I'm just going to ignore contains key. Yeah, let's just ignore that for now.
05:20:57.011 - 05:21:33.815, Speaker A: Let's. Let's do the ones we have. Why is T6 different than T1? Why. Why are any of these things the. What an insane way to. I can't find. Okay, so T1 is going to be given a map and keys and we're going to expect to get zero and then get absent is going to be still S.
05:21:33.815 - 05:23:36.533, Speaker A: But the keys are going to be all the absent keys. I see. So the absent keys, there's going to be some send of absent keys and there's going to be some set of present keys and we need them to be separate from one another. And so here, this is where Java has a bit of an advantage in that they are all distinct. And what we are going to do is this keys shuffle and here we're going to need an RNG at some point and then we're going to say key absent keys is keys 0 to absent size and keys is going to be keys absent size and onwards. And I don't know why this is using absent as the values. Any ideas? Rerun the test with the same keys but in shuffled order.
05:23:36.533 - 05:24:39.239, Speaker A: Yeah, so we can do that too pretty easily now. But like, why is it using. Why is it using the absent things as values? Is that just a way to choose random? I think maybe. So it can't quite be random because we have to be able to check for it later. That's what's going on. Okay, so we're going to go with values and this is going to be values. IMOD values.
05:24:39.239 - 05:25:37.955, Speaker A: Linux. Yeah, the trick here is we need to. We need to fill the map with a bunch of values. But in order for us to later check that the right values are there for the right keys, we need to be able to refer back to what the value should be for any given key. Which is what. Which is why it's using like a. Using a list here rather than just like randomly choosing the values.
05:25:37.955 - 05:26:35.815, Speaker A: Okay, let's make it just. Let's make all the values zero right now because currently we don't have any tests that actually check that the value is Something reasonable. So I think. Because otherwise we're going to have to like. Come on, it can't actually be zero. Where. Okay, how about currently this will only work with you size 43 and that's fine.
05:26:35.815 - 05:27:50.145, Speaker A: Yep, that would do it. And I think the only thing we're really missing now is like we need our RAND is. What's the current version of Rand? Current version of rand is 07 and here we want to do RNG is. I guess I probably need this, don't I? So we've got an RNG and now we want to shuffle using that. And now if we try that it's going to fetch rand. That's fine. And using new object we guarantee that the value is unique as well.
05:27:50.145 - 05:28:57.799, Speaker A: Yeah. So this is why for this test now actually the values are all unique but they're just increasing integers. But they're still unique. Method is never used Traverser oh, that's fine. I guess this can be pubcrate because this will be use Traverser, Nodder, Lib Iter parts, PUB and Crate. Great Unused import. That's fine.
05:28:57.799 - 05:29:49.319, Speaker A: I don't really care about it anymore. But it doesn't actually run. Oh right. For this to work I need modaris and I need mod. What's it called? Map check. For that to work, I think Mer. What am I missing? Test jdk no, test target name jdk Oh, I probably need test JDK test JDK RS for it to pick it up.
05:29:49.319 - 05:30:57.879, Speaker A: This seems like a bug. Actually this seems like something that should be fixed. Yeah, this is definitely broken File not found from module map check yeah, this is very broken. This is. I forget what the it's like Test this should not be necessary but it suggests to me that the paths are just completely off. That's too bad. Right, so map check at keys is not an iterator.
05:30:57.879 - 05:32:01.233, Speaker A: That is totally right because it's already now a slice put is private. That seems unfortunate, right? That's because it's called insert. Also this needs a guard. This should say insert. What else do we have? Absent size. This was absent mask and in fact these two I'm not using yet so we can get rid of them. 38 okay, we need some brackets there.
05:32:01.233 - 05:33:24.507, Speaker A: That seems fine. Pretty sure this is valid method not found in flurry #15 Interesting size method not found. Oh yeah, this. This is only available that you follow all the bounds that flurry hashmap requires of you which is admittedly a little annoying, but it's fine. We're gonna have the same for T3 except we don't need the value and we need standard #. # 18. Don't care about the iteration.
05:33:24.507 - 05:33:48.785, Speaker A: That's fine. Don't care about ARC. Do you care about 34? Nope. 33. Cannot move out of keys. I see. I think we're actually going to require that it's copy.
05:33:48.785 - 05:34:19.551, Speaker A: Yes, we're going to require that it's copy. Either that or we could have all the. All the values be references, but I think we're just going to say copy instead for now. Hey. All right. Who? It's. I've.
05:34:19.551 - 05:34:54.585, Speaker A: I've been amazed actually, this dream, how everything has worked. Like not quite. There have been some things we've had to debug, but like this is like one of their test cases and it just. It just. I'm sure there are things that are broken, but I think this also implies, given the tests we've written so far, that the implementation is actually a pretty faithful port because otherwise a bunch of things would be broken. But here it actually looks like it does. Resizing insert and get map with each other.
05:34:54.585 - 05:35:52.055, Speaker A: It does these forwarding iteration works fine. That's pretty neat. That's pretty neat. Not gonna lie. It's already. We're already like almost six hours in, so I think I'm gonna end it there. Let me just commit the stuff that we have add and I want let see start porting Java tests, invisibility issues.
05:35:52.055 - 05:36:49.495, Speaker A: There's. Obviously there's a bunch more of test suites that need to be ported, but I think this is something where it would be great if you as the viewers take a stab at porting some of these tests now that we have the rough framework in place and just then we should fix it. But at least now we have get insert and Iterators and so that should be enough for you to develop at least most of those tests and in theory for people to start doing benchmarks. Once we get some more tests, we can set up like CI and stuff on it as well. The biggest sort of feature I think that is missing, apart from the ones we talked about very early in the stream of sort of optimizations, is support for remove. The remove method I think is not that complicated compared to what we've ported so far. So if you want to take a look at it, I think you should.
05:36:49.495 - 05:37:27.221, Speaker A: As mentioned though, it'll be a while until I do the next stream. I'll still monitor this repository and like try to handle things like pull requests and stuff, but I won't be doing a stream on it for a while. My guess is that the next stream will be like in a couple of months. I don't know exactly but know that I still want to do more streams. I just need to settle my PSG first. So thanks everyone for watching. Keep like watch this repository and see what happens.
05:37:27.221 - 05:38:10.185, Speaker A: And please like consider this project our project, not my project. If you want to like submit prs to add CI improve like or add tests like please please do. And I will do whatever I can to actually keep up with whatever you contribute. I hope it's been useful. This will I don't know whether we'll do more streams on concurrent hash map itself because I think the port is now it's like unclear that a fourth part would teach you that much more about about new topics as opposed to just more about concurrent hashmap. So take a look at the live coding voting page that ooh, that's a good question. Does that even still work? It does.
05:38:10.185 - 05:38:44.967, Speaker A: So here you can vote on what streams you want to see next. So feel free to go in there and vote. I'll post the link in chat. The repo I think was linked above. It's just on GitHub, John who slash Flurry. I don't know if that's a name that will stick, but I'll post it into chat as well. And yeah, so vote there for the upcoming stream idea that you want to see.
05:38:44.967 - 05:39:13.097, Speaker A: And whenever I end up streaming next, that will probably be what I'm doing. I'm also giving a couple of talks in February that I hope will be published online and so I'll tweet links to those when they are same as with this episode. As always, the recording will be up. Just feel free to follow me on Twitter and then you'll see any of these announcements. Great. Thank you everyone watching. It's been fun and I will see you the next time I stream.
05:39:13.097 - 05:39:13.945, Speaker A: So long, farewell.
