00:00:00.600 - 00:00:34.941, Speaker A: Hi folks. Welcome to another stream. This is going to be another decrusting stream where we sort of look under the hood and try to figure out both how to use a crate in more depth and also kind of how it works. How does it work? Like behind the scenes and in particular to build up an understanding of how it works in order to be better able to use it efficiently yourself. Quick Housekeeping before we start, first of all, if you don't know already, there's a discord that you can join where announcements about my upcoming streams. That's where I put them. It's also where I announce other things that are going on.
00:00:34.941 - 00:00:45.773, Speaker A: So if we. So it's. It's here. But you can also just go to discord.johnwhoeu and it will take. Redirect you to the invite here. It's not a.
00:00:45.773 - 00:01:23.275, Speaker A: There's no chat or anything there unless you're a sponsor. It is just an announcement channel. One of the things that I've announced there is that I'm giving the opening keynote at Euro Rust in Vienna on October 10th. The talk is called through the Fire and the Flames and I'm basically going to try to explain a bunch of common stumbling blocks to being productive in rust. In 30 minutes we'll see how well it goes. But I'm going to try today in particular, we're going to cover the Quick Check crate. And the Quick Check crate, for those who don't already know, is a crate for doing property testing.
00:01:23.275 - 00:02:15.029, Speaker A: Now, I promise I will tell you all about what property testing is before I dive into this because not all of you may have heard about it. I did actually have a previous stream where I talked about property testing using a different library called Prop Test and that is the setting up CI and property testing for a Rust crate. There's sort of a chapter in the video called Property based testing where I started going through what this means and how to use that other crate. I'll link it here for the people who are watching this after the fact. There are a bunch of differences between Prop Test and Quick Check, but one of the main differences that the Quick Check crate is a lot simpler. And simpler here is both a good and a bad thing. Simpler means that it tends to be a little bit faster to build, a little bit faster to like generate examples and the like.
00:02:15.029 - 00:02:55.055, Speaker A: But it tends to. It's like less advanced, it's a little more convoluted to do things. It doesn't make it quite as easy to do things like generate strings of particular patterns or numbers. Within particular ranges. Again, we'll dive more into this when we look at the crate itself. But one of the reasons I want to do quick check is because quick check is simple enough that, but still useful enough that we can actually understand the entirety of the crate and how it works under the hood in this single stream. I'm hoping the stream actually will only take, and I'm going to eat my words here later, I think, but I'm hoping it'll only take about an hour, which will make this probably the shortest stream I've ever had.
00:02:55.055 - 00:03:26.015, Speaker A: But we'll find out. We'll find out. Okay, so, very briefly, what is property testing? The idea behind property testing is. Or actually, let's take one step back. So property testing is an advanced form of fuzzing is one way to think about it. Fuzzing, if you don't already know what fuzzing is, is essentially to take a program that you have and throw random inputs at it and then see if it crashes. That's essentially what you do with fuzzing.
00:03:26.015 - 00:04:13.181, Speaker A: This is particularly common in cryptographic libraries and the like, but it's used for all sorts of software this way. So the idea being that you have a program that just generates random inputs of whatever kind the program is accepting, and then you just run your program on it and you see what. What output it produces. And in general, the observation with fuzz testing is that your program should never like, seg fault and should never panic. It might return an error, right, if the input is just invalid, but it should not seg fault, that indicates a security problem. And it should probably never panic either, because that means there's some invariant in your program that's not being upheld that should instead have been an error. Fuss testing is in some ways a particular subcategory of property testing.
00:04:13.181 - 00:04:58.877, Speaker A: So property testing is, again, you generate random inputs for your program. But the difference is that with property testing, you're checking for a particular property of the output of your program in response to that input. So for fuss testing, generally the property that you check for is, does the program crash? With property testing, you can test for additional properties like, obviously, if your program crashes, you've probably found a bug. But you can also test for properties like, you know, imagine you have a sorting function. The property you might want to test for is, well, after I call the sorting function, is the output sorted right? Seems like an obvious property to test. There are other properties you can imagine testing. Like if I have a vector of length 10 and I sort it.
00:04:58.877 - 00:06:02.085, Speaker A: After sorting it, I should still have a vector of length 10, right? And so you should think of property testing as testing particular properties of the output of your program given a randomly generated input. And so what does the quick check crate do in this context? Well, the quick check crate provides three things. Roughly. It provides a way to generate values of random types, generate random values of arbitrary types. It provides a way to check whether your program succeeded or failed, right? So the obvious cases of failure that are sort of automatically handled, or if your program panics, then you know that's a failure of the test case. If your program returns an error, that's also a failed test case, and you can define additional properties that you consider a failed test, even though there's no sort of error like actual result, colon, colon, error being propagated up, there's no panic. But you declare that the program has failed.
00:06:02.085 - 00:06:55.915, Speaker A: So that's the second thing it provides. And then the third thing it provides is a means to shrink inputs to find the smallest input, the smallest random input that reproduces the bug that you've observed. So let's take the case of sorting an array. Imagine that, you know, it randomly generates an array of like 100 elements and finds that when it calls sort on this particular array for you, it gets back an array of 99 elements and it goes, well, clearly that's wrong. It could just stop there and tell you, well, I gave this array as an input and I got this array as an output, and that's wrong according to this property. But quick check does sort of one thing further, which is it has to this notion of a shrinker. And the idea of a shrinker is that, okay, now you've found a case that errors try to make the input smaller and see if you can still reproduce the same error.
00:06:55.915 - 00:07:42.331, Speaker A: And if you can, try to make it smaller again and see if you can still reproduce the error. The idea being, or the hope being, that at the end you might end up with an array of, let's say, four elements that returns an array of three elements when sorted. And that is probably easier for the programmer to debug. So those are the sort of the main three properties generating random inputs, checking whether you meet a particular property and shrinking the inputs when you do find that you value it, that you violate a particular property for that input. Let me sort of pause there. That's basically everything about what property testing is. We'll go into more details about how you do it and some of the sort of nomenclature, the names for things in this, in this world.
00:07:42.331 - 00:08:15.301, Speaker A: But just does the High level idea make sense. How many checks could a quick check check? If a quick check could check checks, that's pretty good. That's funny. Okay, I'm not seeing any particular questions for what I've said so far. Which makes sense. Like property testing is not actually all that complicated. It can be complicated to implement not in sense of like the quick check library itself, but writing your own property tests can actually get pretty convoluted.
00:08:15.301 - 00:08:53.314, Speaker A: Both because generating inputs for you is like you might have a pretty convoluted input format, but also checking properties are not necessarily simple, but the idea is simple. Okay, so let's then look at the quick check crate and let's actually start with the readme, which has a very straightforward example. I'll zoom in here a little bit for you. So here's the setup. The quick check crate is actually pretty old. It's still maintained, but it was written. I think it supports all the way back to like Rust 1.3
00:08:53.314 - 00:09:39.435, Speaker A: or something. There's something truly ridiculous. Oh, they've bumped to 165. I think it probably supports older with fairly small checks. Regardless, the example here is a little bit of extra noise because they support much older Rust versions. But the basic idea here is we have a function reverse that takes, you know, a slice of items and it returns that slice of items or as a vector, but in reverse order. So this is the function we are testing and the property that we want to check is that a reverse of reverse is the original array.
00:09:39.435 - 00:10:06.035, Speaker A: In other words, if you have an array of four elements, you reverse it and you reverse it again. You should end up at the original four element array. There are again a bunch of other properties you could check too. This is the particular one that's being demonstrated here. So the function under test, you write without thinking about quick check at all. You just write the function the way you you think it should be implemented. You don't have to think about, you know, requirements of the quick check create at this point.
00:10:06.035 - 00:10:53.675, Speaker A: Then when you want to write a test, you know, mod test is sort of standard nomenclature here. And then in this case they use a quick check macro and we'll dive into looking at what that quick check macro does in a little bit of a second. But inside of the quick check macro you just declare a bunch of functions, each one named after a particular property you want to check. You can think of each of these as eventually turning into a sort of, you know, pound test function. So really this just adds a little bit of boilerplate before and after this function. But each function you declare in here is going to test a particular property and turn into its own test function. Here, this is just prop, but this could just say, you know, reverse is reversible or something.
00:10:53.675 - 00:11:34.563, Speaker A: And I think there's a mathematical name for this that it is. I don't remember. It doesn't really matter. The way that you declare these functions is that the arguments to the function are things that Quick Check will generate for you. So you will never call this function yourself. Instead, you're selling, you're saying, I want to test the property that the reverse of the reverse is the original. And I want to test that by you giving me a random vector of U38.
00:11:34.563 - 00:12:11.685, Speaker A: So quick check's job is to generate this for you and generate a bunch of different ones, random ones for you, and then call this function for each generated one. So this function is going to be called, you know, thousands of times with different vectors of U32. And it returns a bool. And the bool here is the pro, the result of checking the property that we're looking for. And so in this case, the implementation of the function is that the vector that we're given should be equal to reversing the reverse of that input. So the property is actually pretty simple to express. In this case, the.
00:12:11.685 - 00:12:31.095, Speaker A: The it really just is. Call the function twice and see that you end up with what you originally have. And this is the entirety of the Quick Check. What I want to show you now is how this works out in practice. So let's go over here. We'll do cargo new. Let's do lib.
00:12:31.095 - 00:13:21.895, Speaker A: QC test. QC test in here as well. And we're cargo add Quick Check. If we run cargo test on this involution, is that really what it's called? Wow, Involution is quite the, Quite the name. Oh, I do also need to use Quick Check. Quick Check in order to get the macro here. Actually, I want it in here and use super.
00:13:21.895 - 00:13:41.371, Speaker A: Okay. So you see, when I, when I run cargo test, you see that there is now a tests prop, right? So that is this function right here. And we could have called it, what was it? Involution. Great. Involution. You'll see that the function is now. The test is now called involution and it returns.
00:13:41.371 - 00:14:09.625, Speaker A: Okay, and this doesn't tell you very much, right, because it just, just passed. But one of the things that we can do here and just sort of show that it's really doing work. I'll go down here and skip ahead a Little bit. And grab this environment variable so you can tell Quick Check how many. Oops. Oh, why did it. Okay, I think it's.
00:14:09.625 - 00:14:40.175, Speaker A: It's either test or test. Why didn't it copy? That's weird. Tests. Okay, tests. So if I run this, this effectively means, and I think thousand might be the default, it means that it's going to generate a thousand different vectors of U32, and for each one, check the involution property. Here what I can do is I can increase this number. And this test still didn't take that long because it's pretty fast for the computer to do 100,000 things.
00:14:40.175 - 00:15:18.255, Speaker A: What about a million things? See, now the test runs for longer. In fact, it runs for about 10 times as long. But eventually it returns back with okay, and what actually happened was that it was generating more and more and more test cases for testing this property. So this obviously doesn't guarantee you that your program is correct because the randomness could not find a particular property. But it does mean that you build confidence that for arbitrary inputs, this program ends up being correct. Invert. I think invertible is more right than involution, regardless.
00:15:18.255 - 00:15:47.007, Speaker A: Okay, we can, we can make this pub. Just for the warning to go away. So that's, that's the basic idea of property testing. You have some property you want to test, you can express it as code, and you express it. Basically you can think of this as sort of the mathematical or the quantifier of for all, right? So for all vectors of U32s that a quick check can provide, this property should hold. And then it's Quick check's job to generate a bunch of instances of this type to basically test it empirically. Right.
00:15:47.007 - 00:16:19.107, Speaker A: It does not do model checking. For that you can use. You know, there's a really cool crate called Connie. If you haven't seen Connie, then I highly recommend you go take a look at it. So Connie is a model checker that actually tries to exhaustively check your program, not by executing it lots of times, but by strategically choosing paths to your program. But it's also slower in other ways because it, it has to basically run an interpreter and a model checker and an SMT solver. So it, it operates very differently from Quick Check.
00:16:19.107 - 00:16:53.701, Speaker A: But the basic idea is the same. For all inputs of this type, this property should hold. And you can imagine here that we actually come up with a different property too, which is something like length preserving. Right, where we could say that the length of excess should be the length of reversing Excess, Right. This should also be true. And I'm going to get rid of this extra thing now. And you see, both of these properties are indeed validated.
00:16:53.701 - 00:17:12.865, Speaker A: And you might imagine that, like this implies that. And that's not quite true. You can imagine that reverse was all sorts of complicated and would like push elements and pop elements and everything. It's. We know it doesn't, but it could. In which case it could. You could imagine a way to write reverse such that it passes this test but fails this one.
00:17:12.865 - 00:17:35.995, Speaker A: So again, you build up this sort of list of properties and each one will be tested by Quick check. Okay, so invertible implies that there's some value that inverts it, but not that it's its own inverse. Involution is. Right. All right, we'll keep involution. We'll keep involution. That's all fine.
00:17:35.995 - 00:18:15.209, Speaker A: Okay, so that's the basic idea here of how you use Quick Check. You don't have to use the Quick check macro. It's worthwhile here to go look at what the Quick check macro actually does. And in fact I'm going to do this in an editor because that's nicer. So if we go in here to source Lib, you'll see the macro is right here and it's actually not very complicated. We might even do this just to see what it expands to. Test tests, really.
00:18:15.209 - 00:19:03.769, Speaker A: Cargo expand. Can't expand lib tests. That sounds real unfortunate. That's okay, fine, fine, fine. Just because I want to be able to do this, I'm going to touch tests qc. I'm going to move these quick checks into a different file like so you'll see that the tests work just the same. They're just integration tests now instead of unit tests.
00:19:03.769 - 00:19:53.805, Speaker A: Because now I can run CargoExpand and obviously this includes a bunch of extra stuff here. But if we now go down and look, you'll see that involution is now just a top level function that inside has a function called prop that is the body of our thing and it calls Quick check like the quick check function with a function pointer to our property. Our property test function. And indeed, if we go back and look at what Quick Check does inside of this Quick check macro, it takes a where is. Yeah, it takes here an item. An item here is something like a function. Like an item is a type declaration, a function declaration, a module declaration.
00:19:53.805 - 00:20:46.369, Speaker A: So it's sort of a thing, an item. It is not something like just a statement or an expression. And what it will do down. Right, so that's this first arm, which we can mostly ignore. This one is the arm that we actually care about, which will match on anything that looks like a function declaration. You'll see it matches out the attributes, it matches out the function name as an ident, it matches out all of the function arguments and the return type, and then it matches out all of the code. And then what it replaces it with is down here a test attribute and any other attributes that you originally had in the input function by the name of the same as your function name.
00:20:46.369 - 00:21:34.545, Speaker A: And then inline said FN prop that has the same arguments, the same return time, the same code. And then it calls the quick check function with that function pointer. So again, exactly the thing we saw come out of cargo expand and you might go, okay, well that just means the magic is in here, right? Surely there's magic somewhere. So let's go look at this. Right, but the macro itself just really turns this into that. And in fact, we could write this ourselves. Like instead of writing the test this way, we could write it this way fn like so FN prop Quick check Quick check prop as this.
00:21:34.545 - 00:22:11.951, Speaker A: And I think, I think it's going to be unhappy with me if I don't do the Right. So again, this is what the macro expands to really. And I mean, I can prove this by running the thing. And you'll see that, okay, the test ran. So the macro doesn't do anything magical. But what does this function do? Well, let's go find out. So the quick check function comes from tester Quick check.
00:22:11.951 - 00:22:34.937, Speaker A: So let's go to tester and find the quick check function. And that is not this one. This one. Okay. It just does quick check new dot quick check. Okay, what does quick check? Quick check is a struct, just really carries the configuration for the test gen. Here is the.
00:22:34.937 - 00:23:01.175, Speaker A: We'll talk about this when we talk about how to generate arbitrary values. But it's really a randomness, a source of randomness. And then it called new on quick check. What does that do? That just sets the default values. Okay. And then it calls the quick check function on that, which initiates logging. And this calls self start quick test with the same function and prints based on the output.
00:23:01.175 - 00:23:26.027, Speaker A: Okay, so there's no magic in here either. So surely there must be magic in quick test. All right, quick test. So this seems to be the thing that actually tests the property, right? The F here is a pointer to the property test that we want to do. What does it do? Well, it loops over the Maximum number of configured tests. If we pass a given number of tests, then we stop, and then we stop. We match on f result.
00:23:26.027 - 00:23:50.747, Speaker A: Okay, what's f result? That must be a method here of testable, which is the trait that we need that is required to be implemented by whatever function we pass in here. So we just do. We match on that. And if it says that we passed, then we add to passed. If we discard, we continue, and if we fail, we return an error. Okay, so the magic must be in result here. Then let's go look at the testable trait.
00:23:50.747 - 00:24:30.505, Speaker A: The testable trait is anything that can be expressed as a property, anything that can be tested by quick check. And you'll see that the there's a testable here for bool, there's a testable for unit. So surely there must be a testable here for functions. Ah, okay, this looks like magic, right? This is implementing testable for fn with a bunch of argument names that returns a T. Okay, this, I agree here. It looks like magic. So this is ultimately the function in quick check that actually tests, like for a bunch of inputs, whether we meet a particular property.
00:24:30.505 - 00:25:03.791, Speaker A: So let's go look at what it actually does. So there's this shrink failure case. So I mentioned shrinking briefly. We'll look at this a little bit later. But if we ignore the shrinking, this is the body of that function. So it does some stuff that macros need to do to like, make variable names not be problematic. You see here, the type of a is a tuple, where the type of the elements of the tuple are the same as the types of the arguments to the function.
00:25:03.791 - 00:25:29.095, Speaker A: Right? So in our case, this would be a 1 tuple of VECU32. And it goes arbitrary. Arbitrary G. Okay, so it generates a arbitrary value for all of our argument types. And we can look at what arbitrary does in a second. And then it calls. It uses the safe wrapper to call self.
00:25:29.095 - 00:25:49.247, Speaker A: So remember, self here is a function pointer. So this is really just calling the property function with those arguments. And then it calls dot result on the thing that comes back. The thing that comes back here, remember for us is a boolean, right? That's what our. Our. Our property testing returns. And the boolean is just whether we uphold the property or not.
00:25:49.247 - 00:26:28.433, Speaker A: So if we go up and look at result for bool, calls test result from bool, which is just if the bool is true, then we passed. If the bool is false, then we failed. Okay, so not really much magic there. So we're calling the function Pointer with the randomly generated arguments, and then we turn that into a pass or a failure, depending on what the Boolean was. And this mapping here is also how if our property returned, let's say, a result between either okay or error, then error would turn into a failure. Okay, would turn into a pass is what the result here gives us. Safe is an interesting one.
00:26:28.433 - 00:27:11.233, Speaker A: So if we look for FN safe, what does that do? It just catches panics, right? So the idea being that if we have a property that we're testing, and while testing that property, the program panics. Well, clearly that means something is wrong about that property. We might not have failed that particular property, but the program crashed. And so clearly this should be considered a failure. And so therefore we catch panics and we turn them into an error. Like you see the results coming back up here, such that quick check will realize, oh, you actually failed this test case. So we safely call the function pointer with the random arguments.
00:27:11.233 - 00:27:56.235, Speaker A: We turn that into a pass or fail result, then this R arguments here is we take the random arguments we generated and we turn them into string representations so that we can print them to the user, right? So if a quick check found a failing case, like an array of four elements that suddenly returned three when you reverse them, you want to know what those four elements are so you can debug. And that's what this does. It takes those arguments and debug prints them so that we can print them out to the user afterwards to help them debug. And then we just match on the status. If we had pass or discard, then we return R. I'll talk about discard later. And if we fail, then we call this shrinking.
00:27:56.235 - 00:28:55.955, Speaker A: So the, the idea being that if you can, if you can make a smaller input case that still errors, we rather give that to the user. So we'll talk about shrinking a little bit later. But for now this is the only magic, and it's not really all that magic. So there's maybe some magic in shrink. We haven't talked about shrink yet. And there's maybe some magic in arbitrary, but I'll pause there for the structure of how it runs these tests, which actually seems pretty straightforward and sort of take questions on that part first, and then we'll dive into arbitrary, and then we'll dive into shrinking. Okay, what does R at test result in the match mean? Test result in the match.
00:28:55.955 - 00:29:54.685, Speaker A: This was up in here. So in quick test, when we match on a thing, the R at here, this is a useful tool to know when you do match is that you can bind a variable name R here to any part of a pattern. So you're used to this normally, right? So status here. If I just did this, then I would. Inside of the match arm, I would now have access to a variable called status, which is actually the value of the status field inside of the test result. What this R@ syntax does, it says, I want a variable binding R to point to the entirety of the test result in this case. So you can almost imagine this as being the same as that, except it will only be entered if this was a test result whose status was fail.
00:29:54.685 - 00:30:35.251, Speaker A: As you see, we use that to. If we hit a failure, then we return with an error of that entire test result. Is value generation stateful? No. So this is one of the differences between Quick Check and prop test. So prop test is a much more involved library for doing property testing. It includes things like stateful value generation, where you try to avoid generating the same value again because you've already tested it. Quick Check does not do any of that.
00:30:35.251 - 00:31:00.195, Speaker A: It just randomly generates inputs. It is much closer to fuss testing in that regard. That means it's faster generating values, but it may generate overlapping values. For example, this regex like single syntax in an impulse block is new to me. What is this regex like syntax? Oh, this bit. This is a macro definition. These are.
00:31:00.195 - 00:31:31.815, Speaker A: If you look at macro rules. I recommend looking at the little book of rust macros. This is a really good intro to these declarative macros. I also have stream on it. I think it's a crust of rust stream on declarative macros. Okay, so let's then look at what arbitrary does, right? Because this seems to be the magic that produces a random value for us, or in this case produces a bunch of random values for us. One random value for each function argument.
00:31:31.815 - 00:32:29.631, Speaker A: So arbitrary, we'll skip gen for a second and look at the arbitrary trait. So the arbitrary trait has two functions, arbitrary, which generates a new self, right? So you can imagine implementation of arbitrary for, you know, U32. And then when you call arbitrary colon, colon arbitrary, you give it a gen here, which is a source of randomness, and you return an i32, because that is the self type here. That's the thing that implements arbitrary. And then as a shrink and the signature of shrink here we're going to come back to when we talk about shrinking, because it's kind of interesting. But shrink just as a way to turn, you know, the value you have currently generated, like the i32, and turn it into a Simpler value for many types there is no simpler values. Like Again, for an i32 it's not clear that 0 is a simpler value than 42 so the or you know, for boolean is false.
00:32:29.631 - 00:33:10.395, Speaker A: Simpler than true, not clear. So the default implementation for Shrink is empty Shrinker which just say this value cannot be shrunk any further. If you've hit this case then just you can just return. You're not going to make this simpler for the user. And the randomness generator here you could imagine this was actually something like from the Rand crate, like an actual like RNG that was provided. I think the main reason it isn't is because that would require a quick check to take a dependency on the Rand crate. And there are a number of reasons why I think relatively fundamental but also simple library like quickjet doesn't want to do that.
00:33:10.395 - 00:34:15.567, Speaker A: One of the main ones is the Rand Crate has gone through a lot of major versions over the years and because this would be in the public API of the Quick Check Crate, every new major version of the Rand Crate would require a new major version of the Quick Check Crate, which is just too much churn. Not to mention for Quick Check I think Burnt Sushi is the author really wanted to make sure that it remains pretty stable and you could use it with older versions of Rust. The ran crate moves pretty quickly and so you would likely run into a case where the Quick Check Crate has to update what version of Rust it works with in order to move to a new version of Rand. And it doesn't want to because it wants to retain or or still support users on older Rust versions. So this gen type is really just a really simplified version of an rng. And in fact if you look at it, this pub struct gen internally it holds a rand and I think this is from the Rand crate you see here from Rand 085 or 085. So internally it just holds a randomness generator.
00:34:15.567 - 00:35:28.255, Speaker A: It's just that externally it's its own type so that any updates to the Rand crate do not end up having a result on the public public API of of Quick Check. You also see it has a size parameter. So the idea of size here is that you sometimes want to how do I explain this? Imagine you're told to generate a random vector. Well, if you truly regenerated a random vector, then like the average vector you return is going to be what, like 2 to the 63rd long, right? Because that's half the space when you have a like a use size, assuming the use size is 64 bits. Realistically, those aren't the vectors we care about and it's unlikely that your bugs lie like when the vectors are that large. Not to mention you couldn't allocate a vector that that's large. So the generator here has this property of size, which, how large should the things I generate to be? I think the default size for quick check, which you can change if you want, is 100.
00:35:28.255 - 00:36:24.729, Speaker A: So when you initially start generating random values, it will generate things using a gen where the size is 100. And if we look at, and we can do that right now, the implementation of arbitrary for a bunch of types. So you see, for bool, let's just generate a random bool like coin flip Arbitrary for unit was nothing. But if we look at something like implement arbitrary for vector, you'll see that it gets the size of the current generator. It generates a number in the range between zero and that size, and then it generates a vector of that length. So it sort of treats the size as an upper bound on how large the vector should be and it randomly samples the length and then all of the elements in that range. The, the, the nice property here is it also means that you can either expand the space that is allowed to be searched or you can shrink it.
00:36:24.729 - 00:37:01.587, Speaker A: So one, one way in which I've used this in the past is I wanted to generate a basically JSON document. And when you generate a JSON document like Jason famously infinitely nests, right? Like you can put a map inside a map inside a map, inside a map, inside a map. Like there's no typing, it just. You can literally just go forever. But realistically, you don't want to measure or run your tests on JSON documents that are like, you know, a million deep. That's not particularly interesting. And the size alone doesn't save you here because at each level you're just generating one item.
00:37:01.587 - 00:38:14.095, Speaker A: It's just that they keep nesting. Does something has to stop the nesting. And so what I did was when I implemented arbitrary and you can implement this trait yourself, that's generally how you're supposed to do things like have arbitrary support for a struct that your type owns, for example, that your library uses when I implemented arbitrary for this type that represented a JSON document, anytime I decided to, or the arbitrary implementation decided to implement a nested value, like a nested map or, or array, what it would do is it would have the size of the generator that it passed into the arbitrary implementation of the underlying value. So think of this as, you know, I'M in the ARM where I decide to generate a nested object. So I have to call arbitrary, you know, a number of times to generate the keys and values of the inner map that inner call to arbitrary, I would give a size that is half the size I was provided, and then it recurses right to generate its values. And so that way, as you go deeper, your size decreases, and so eventually you get to a point where size is zero and you stop generating more values. Because you can think of this as sort of the budget you're allowed to generate size within.
00:38:14.095 - 00:38:58.005, Speaker A: So that's why size is there. But otherwise the implementation of arbitrary for vec here actually pretty straightforward. And shrink again, we haven't talked about shrink yet. I'll show you some examples of shrink to make it a little more real. And you see, there's an implementation here of arbitrary for tuples, which again is just you call arbitrary ones for each element of the tuple using the particular type of that tuple element. So nothing particularly magic really in the arbitrary here. If we look at arbitraryforoption, if the G gen here generates just a boolean, it's a generic function from rand where in boolean context it will generate a bool.
00:38:58.005 - 00:39:53.649, Speaker A: So if this bool is true, then we generate none, otherwise we generate sum, and then we just recursively call arbitrary on the inner type of the option. So arbitrary itself, fairly straightforward, okay? So that's the arbitrary side of the system. So we've now talked about how values are generated. And if you're curious about, well, how would I do this if I had a struct input, for example, what's the exact same thing you implement? Well, here's an example maybe of a B tree map, right? So in order to implement arbitrary for B tree map, this is the B tree map from the standard library. You just generate a vector of key value tuples and then you turn those into a B tree map. You could do the same for hash maps, but if you had a struct. I wonder if there's an example of a struct in here.
00:39:53.649 - 00:40:32.239, Speaker A: There might not be, as you see, IP adder. Same thing. Just decide whether you want to do IPv4 or IPv6 and you recursively call arbitrary. It's not a. None of these are struct because they're all standard library types which don't generally have public fields. But if you had to implement arbitrary for your own struct, what you would really do is you would write, in fact, we could do this, right? So A struct foo that has fields. Or let's do point, right? I32Y is i32.
00:40:32.239 - 00:41:12.765, Speaker A: Then I could implement quick check arbitrary four point and the implementation is just going to be x is i32 arbitrary of g and y is y32 arbitrary of g. That's all. Now arbitrary does require that the type is clone. And I think also it has to be debug for you to actually pass it to quick check. Like this. If we put point in here and it didn't implement debug, the compiler would complain because it needs to be able to debug print the arguments to show the user what the path to the error. But it also needs to be clone.
00:41:12.765 - 00:41:43.515, Speaker A: And the clone requirement here is for shrinking. So if you want to shrink, then that means you are going to replicate all the elements and then try to make it smaller. But that means you have to clone them. So that's where the clone requirement does. But you'll see here that actually implementing arbitrary for other structs, usually pretty straightforward. It of course does get more complicated. Right? Imagine that point had, I don't know, kind, which is a string, and the kind actually has to be one of three string values.
00:41:43.515 - 00:42:27.649, Speaker A: And those are the only valued ones. We could argue endlessly about, like that should be an enum and whatnot. But like, imagine it was a string for some reason. Then you would have to do something like if G dot choose like a, B or C and we would have to like match on that. And then if it's A, then we return, you know, string from A. And then we would have to do that here. And then like the last case is unreachable because we didn't choose can only generate one of these three.
00:42:27.649 - 00:43:02.193, Speaker A: So it's doable. But it does get more convoluted as you start to have more constraints on the inner types. What you'll often see with. And again, prop test does tend to make this better. So with prop test you can describe limitations like this of things like generate me random values that match the following reg ex right? So it has more powerful tools for this. But that also means that there's like more mechanism and in some sense more overhead to the library its itself. Whereas with quick check you need to do all this yourself.
00:43:02.193 - 00:43:39.985, Speaker A: There's no magic that provides it for you. And this also means that often what you'll see with quick check is you'll introduce additional new types. So you'll have a kind here and then you'll have a struct. Kind is actually A string. And then you implement quick check arbitrary for kind. And in the implementation of that, that is where you do this. And so that way this can now just be arbitrary kind in here.
00:43:39.985 - 00:44:26.005, Speaker A: So that's a pretty common thing that you end up. So it's a pretty common pattern. You see with Quick Check is you have new types that represent constrained values. Same thing where if you imagine that point only ever allowed i32s that are between 0 and 100, for example, then you don't get that guarantee from here. So you need to write your own new type that will ensure that the i32 you generate is within a given range. Again, Quick Check doesn't provide any ways to help with this. So there is some amount of, you know, pain and suffering when it comes to more arbitrary or more more involved constraints on the types that you generate.
00:44:26.005 - 00:45:39.711, Speaker A: Quick Check does not have a derived macro for arbitrary, at least not as far as I'm aware. There is a quick check macros crate, but I believe that, yeah, the only thing it provides is the quick check attribute which goes on a function to make it be a quick check. So the this being here or here, we could also describe this with this if we brought in the quick check macros create, but there's crucially not one for derive there is. So Prop Test actually also has this notion of an arbitrary trait, but it uses the arbitrary arbitrary trait from the arbitrary crate which does have a derive, but quick check does not do that. It is a very self contained crate that tries to solve the problem in totality within the crate. Yeah, our commenter in chat here points us out totally. Right.
00:45:39.711 - 00:46:38.665, Speaker A: So this can feel a bit like magic when it all comes together. When you see that it like magically finds bugs in your code and says, oh, with this vector configuration you have a bug, but on closer inspection the smaller pieces are not magical. And I think this is very often the case for Rust libraries and actually for the Rust compiler as well, is that it feels very magical when you look at the total totality of the outcome. But once you start digging into the pieces, I mean, it sounds silly, but it's just code, right? And the more you look at it, the more you understand like, oh, this is just that thing and then that thing and then that thing and then that thing. Yeah, a user struct with an email field would be a good example of something where the email field clearly has some rules for what goes in there. And so you wouldn't actually want to generate random strings. And in fact if we look at the Arbitrary implementation for string, you'll look that what it actually does is it's basically generating a vector of characters.
00:46:38.665 - 00:47:21.383, Speaker A: That's all it does. And so obviously that has no rules that might match what your application has for a given string. Yeah, so a worthwhile bit of history here. So the Quick Check crate is actually almost a straight port from a Haskell library called Quick Check that does the same thing. And all of the logic here is almost taken verbatim from, from the Haskell implementation. Okay, so we've talked now about this idea of how do you generate arbitrary values. We've talked about how you check the outcome of that.
00:47:21.383 - 00:48:29.745, Speaker A: The one thing we haven't talked about when it comes to checking the output is this notion of a test result. If I go back here to the tester, Right, So we have this notion of a test result, which is what you get back from a testable. And a test result has a status, arguments and an error. The error is sort of a description of the panic or, you know, of the. Of the error case that you hit or whatever the arguments are. What arguments did I generate to hit this error case? And the status is was it a past test, was it a failed test, or was it a discarded test? And discard is worth pointing out here. So when you implement or when you write a property up here, this is going to be a little bit weird for vectors, but let's see if there's a way we can make it real.
00:48:29.745 - 00:49:14.165, Speaker A: It's a good example of this. Sometimes you have additional constraints you want to place on when a property holds. So you might want to say that this is a silly. I kind of don't want to give a silly case. I wonder if the examples has one where it uses discard. Let's go ahead and look. Discard out of bounds BT set range.
00:49:14.165 - 00:49:48.445, Speaker A: Okay, yeah, let's look at B tree set range. This is a good example, actually. I really like the examples directory for the Quick Check crate. It has like pretty reasonable examples of how to use Quick check for testing real properties. In this case, what it's trying to test is the B tree set type from the standard library and in particular the range method on B tree set. So imagine you wanted to write a quick check for that. The reason they declared their own range here is just again, because they support a much older version of rust where range bounds is actually in the standard or wasn't in the standard library yet.
00:49:48.445 - 00:50:39.279, Speaker A: So we can ignore most of the stuff that's at the beginning here. But what you want to do with Checking a range is you take a set and you take a range, and the property you want to test is that the set you get back. If you take the set and you cut out everything that's in the provided range, that should be the same, that should only contain the values of the set that are in the range. I'll state that again. So if you extract the things the range from a set, then the values you get back should be exactly the same as if you walk the entire set and filter out just the ones that are in the range. Those two should be the same statement. And that's indeed what this checks.
00:50:39.279 - 00:51:39.837, Speaker A: Now, the one caveat to this is if you generate a random range arranges the two of a start and an end. But ranges have this additional constraint that the end needs to be after the start. But the arbitrary implementation doesn't know this. If you ask it to generate a tuple of I32s, it could just as easily generate a start of 42 and an end of 2. And that is not a valid range. And so what you can do is if you write a property that instead of returning a bool, it returns one of these test results, then what you can say is that if the range is invalid and the panics here is basically checking for this property that there are only certain ranges that are valid, then if the range is not valid, if the randomly generated range is not valid, then we want to skip this test run. It's not that it passed or failed, it's just that the input is not meaningful to test.
00:51:39.837 - 00:52:35.305, Speaker A: And that's what discard is for. Now, the thing that's awkward about discard is that when we discard a test, there's nothing that guarantees that that input won't be generated again or another input won't be generated again that also fails the same property. And so the more likely you are for the inputs to be invalid, the more generated values are going to be discarded and therefore be wasteful. So imagine that you add some type where like 90% of the randomly generated values had to be thrown away. They were invalid for some reason. What that means is the efficiency of your quick check execution is 10%, right? It generates 100 values, but only 10 of them are actually used for testing. What that turns into is your test suite is way slower because you basically end up generating way more values than you end up executing as tough.
00:52:35.305 - 00:53:26.325, Speaker A: So this is where you can use test result discard as a useful tool, but it should not be the way that you can constrain your input space Ideally, instead, your implementation of Arbitrary for the input type. The implementation of Arbitrary should make sure that everything it generates already satisfies most of the invariants you have for your inputs. So that way, when you generate random values, they're very rarely thrown away. So the efficiency of your Quick Checks execution goes up. This is something the prop test does quite well and something that is a little bit harder to achieve with with Quick Check. An example here being, you know, let's say that you wanted to take as input integers between 0 and 100. If you took an argument that was an i32, then what.
00:53:26.325 - 00:54:14.045, Speaker A: What Quick Check would generate for you is like arbitrary numbers between minus 2 billion and plus 2 billion, and you're only keeping the ones that are between 0 and 100. Everything else you throw away. Realistically, your test suite is going to run extremely slowly because Quick Check is going to spend enormous amounts of time generating inputs that you throw away. In fact, you might never get around, like, effectively never get around to running even a single test case because the range you're testing is so small. So you would much rather have the implementation of Arbitrary for some new type around i32 that guarantees that it generates values within 0 to 100, using Modulo, for example. Though Modulo has some problems when it comes to randomness in terms of the uniformity of the distribution. Regardless, that's what discard is for.
00:54:14.045 - 00:54:38.827, Speaker A: Okay, so now we've talked about the. We talked about arbitrary. We've talked about the idea of how you write a Quick Check test and how it sort of evaluates whether the property held no magic there, really. So the main thing we have left is shrinking. We have four. So I said I was. I thought this was going to take about an hour.
00:54:38.827 - 00:55:09.225, Speaker A: We have four minutes left until we hit the hour. But. But shrinking is going to take longer than four minutes. I'm already eating my words, but we're getting pretty close. Okay, let's then look at shrinking. So what's the example I want to use for this? Here's what I want to use for this. Let's grab sort.
00:55:09.225 - 00:55:53.365, Speaker A: Okay, yeah. So as the example says, this is a buggy quicksort implementation. Quick Check will find the bug for you, and I want to show you what that actually looks like. So fire run cargo test on this. No capture. What? No, I don't want main. I want keeps length here.
00:55:53.365 - 00:56:34.873, Speaker A: I want quick, quick check of these properties. Okay, so you say, you see here it says is sorted, panicked at whatever test failed with the arguments 1, 0. So the sort implementation here is wrong in some way. When we provided 1 0, we did not get back 0 1. In fact, the test panicked. Okay, so there is some bug in the SORT implementation and it's now given us a concrete example that we can work through. But 10 is a very helpful output here.
00:56:34.873 - 00:57:08.827, Speaker A: What if we didn't allow it to shrink? And is there an easy way for me to tell it not to shrink? I think there is. Otherwise we can always just make it. Can I limit the shrinking, I wonder? Oh, maybe I can't. Mm. Oh no, I can. All right, let's do. So this takes a vec of eyesize.
00:57:08.827 - 00:58:22.795, Speaker A: So what we'll do is we'll actually have our own V which is a vec of I size, and then we will implement Quick check arbitrary for vc. Why did my press analyzer crap out? Maybe it will be happy now. Yay. Okay, so I'm going to implement the arbitrary trait here and I'm going to say self and I'm actually going to import this so that I don't have to keep writing it. So I implement arbitrary for vc, I'm going to derive clone and debug for vc and I'm going to say that this is actually going to take VC and this is also going to take VC 0.00. Whoa, not what I meant. Now the reason why this is going to not shrink is because when I implemented the arbitrary trait, notice I implemented arbitrary, but I did not implement shrink.
00:58:22.795 - 00:59:21.681, Speaker A: And so as a result, there's no way for Quick check to get at the shrink implementation for vec. And so it's going to think that it can't shrink the input, or rather it's going to use the default implementation which says I don't know how to shrink this thing. And so if I run now run this test you see here, okay, these are now the results I got right, which is this giant vector with a bunch of really large values because they're all randomly generated and that's much harder to debug. And so this is what the shrinker does, it takes this input and it turns it into a nice looking input, like 1, comma, 0. So how does it do that? Well, so the idea behind shrinking, and this is where we're going to go back to what the tester actually does. You see here, if the, if a test failed, right? If we hit the fail case, we call shrink failure unwrap or R. So shrink failure here is going to try to shrink the failure.
00:59:21.681 - 00:59:47.065, Speaker A: And if it can't shrink the failure, then we return the original Error that we got. Right. So if all of the shorter versions pass the test, then we couldn't generate a smaller one. We're going to return the original R. So what does shrink failure do? Well, shrink failure here is it calls a shrink. So that is the shrink method from the arbitrary trait. We'll look at that in a second.
00:59:47.065 - 01:00:19.993, Speaker A: Actually no, we'll look at that now. So if I go back to look at the arbitrary trait up here, you'll see that the signature of shrink is it takes a reference to self. Remember, self here is the type that we have a have generated at random value before. So it could be an i32, it could be a vector of eyesize. Whatever it is, it's like the current value, the one that reproduces the bug. And it returns a box den iterator. So it returns an iterator whose item is self.
01:00:19.993 - 01:01:06.915, Speaker A: In other words, it returns alternative values for self, other thing, other variants of the self value that you should try. So if we scroll down and look at something like boolean, Bool's implementation of shrink is if it is currently true, then we return a single shrinker. So single shrinker here is really just a wrapper around like a single element vector or stditer once of false. So in other words, if the current value is true, then we suggest to the caller that try the value false instead. If the current value is false, there's nothing to shrink. So we shrink true to false. We don't shrink false to true, we end up infinitely recursing for option.
01:01:06.915 - 01:01:57.375, Speaker A: If the current value is none, there's nothing we can shrink. If the current value is sum, we are going to try none. And the chain here is like we're going to return an iterator, right? So the first thing in the iterator is going to be okay, try none. And the second thing in the iterator is going to be try some by shrinking the value inside of the sum, right? So if you had an option bool, then let's say you had a sum true, the shrink chain for that. The iterator returned by shrink on some true would be none and then some false, right? Because it called shrink on the inner value. And you'll see here that, you know, remember shrink is an iterator. So what we're chaining with is actually we shrink the inner value which itself returns an iterator.
01:01:57.375 - 01:02:43.497, Speaker A: In the case of bool it returns an iterator of only a single element. But even so it is an iterator and we map every element to have A sum around it, right? So the iterator here yields only one thing, and it's a single false that we then map to some false, which then map matches option bool. Here, if we look at something more convoluted, like for a. Actually, let's look at tuples, because tuples are pretty straightforward too. For tuples, the way that you shrink a tuple is you take the. You shrink each element of the tuple. So in particular, this is a little convoluted.
01:02:43.497 - 01:03:19.493, Speaker A: You see, it repeats here for every item of the. The. For every item of the tuple. What this actually ends up doing is it calls shrink on the first element and then map, and then that will yield new alternative values for just the first element of the tuple, right? So that itself is an iterator. And for each element that comes out of that iterator, it is going to clone all the other values of the tuple. So the only thing that's changing is the first value, and the other values remain the same. So that is one, that's the first chunk of the iterator.
01:03:19.493 - 01:04:12.095, Speaker A: The next chunk of the iterator is the first element, and all the third element and beyond are all cloned, so they stay the same. But the second value gets shrunk and its iterator gets sort of replaced. And then same for the third, same for the fourth, same for the fifth position of the iterator of the tuple all the way down. So you end up with long chain of iterators. You can think of it as like if you flatten it into a list, right? The first chunk of the list would be all the elements at tuple position. Two and beyond are all the same, but one is alternative values for the first element of the first element. So again, if the first element of the tuple was a sum true, what you would end up with is none, comma, all the existing values of the other tuple elements, and sum false, comma, all these distant values of the other tuple elements.
01:04:12.095 - 01:05:09.267, Speaker A: And then the next row would be sum true, which was the original value, comma, and then a shrunk value from the second element of the tuple, and so on down the line. The idea of shrink is that you should return the smallest elements first, and we'll see that when we go back to look at what actually gets done with this. So remember, we're now back to the code where we have a test failure for a given set of arguments, and now we want to shrink those arguments and then try again and see if we can still reproduce the error. What we do is we call dot shrink on the current set of arguments that we use to reproduce the failure. And that gives us a new candidate set of arguments, right? Because if you shrink a, you know this is effectively a. Here is effectively a tuple, right? It is a tuple of the argument list. So we shrink the argument list, which effectively turns into shrinking each of its arguments.
01:05:09.267 - 01:05:42.345, Speaker A: But the T here is a new argument list. It is a new tuple where at least one of the elements has changed into some smaller value. And then we just call self. Again, this is the. You'll notice that this line here is actually the same as the line down here. It is just invoke self, which is a function pointer with this new set of arguments instead of the old set of arguments. There's a little bit of macro trickery here just to have the names work out of the variables.
01:05:42.345 - 01:06:37.801, Speaker A: So we're just going to call the function pointer with this new set of arguments, and we're going to look at the result. If the new result is also a failure, then what we want to do is now try to shrink the new one, right? Because we know the new arguments are smaller than the old arguments. That's the contract of shrink. And so now that we have a new shrunk reproducing case, we're now going to try to shrink that recursively, and then we return the shrunk argument list. If, on the other hand, we go through all of the various shrinks of the current argument list and none of them reproduce the failure, so we never hit this is failure case for the new result, then we say we failed to shrink. We had the none case, so then we had the unwrap or down here and ended up returning the original failure because we weren't able to shrink anymore. As what you see here is that shrink failure actually recurses down.
01:06:37.801 - 01:07:58.305, Speaker A: It tries to find the earliest thing in the thing returned by shrink that will still reproduce the issue, and then it will shrink that, and then it will shrink that, and then it will shrink that all the way until there's no more shrinking to be done. And so, for example, the way that's going to look in practice, if you look at all the executions, is that it first tries to shrink the first argument all the way down as much as it can while still reproducing the error. And then it will start to shrink the second argument, then it will start to shrink the third, then we'll start to shrink the fourth, etc. And there is Actually a way for us to look at this. So if I now undo my removal of shrink here and then I run and rust logistrace I was hoping it would have a slightly more convoluted shrink. But here you do see that it you see this is the earlier execution, right? Test fail with the arguments these ones and then you see it has shrunk it to this and then sees a failure again. If you had a more convoluted generation.
01:07:58.305 - 01:08:52.739, Speaker A: Let me see if I can make that be the case. I'm going to claim that this is probably. This is probably the bug. Oh here didn't need to shrink at all past 100 quick check tests for. Oh that's for keeps length. Trying to figure out where this bug is is a fun one. So this finds all the X's that are larger than the pivot.
01:08:52.739 - 01:10:05.515, Speaker A: This finds all the X's that are smaller than the pivot. So we sort everything that's smaller than we sort everything that's larger than we push X We push larger than we get the result if the list is empty. So there's probably an error here in. Where is the error in this? Anyone immediately spot the quick check implementation error. Sort everything smaller. I don't think you need the single element base case because we have the base case here of if the list is empty. Oh, we're missing the case where xs is empty here.
01:10:05.515 - 01:10:36.389, Speaker A: But that shouldn't matter either because if the element if the list only has one element then this would be the pivot. This would be the empty rest of the list. Which means this call to sort would hit this case. This call to sort would hit this case. We would then push the pivot extend with an empty iterator. So that's fine. If it is a two element list, this will have a length of one.
01:10:36.389 - 01:11:50.887, Speaker A: This would be everything that's smaller than this would be everything that's larger than this is not super relevant to the stream. I more figured I wanted. I basically wanted to introduce a bug that shows you shrinking more. I don't think it's a strictly equal. That's the problem because. Oh actually I know how I can show you this instead what I'll do is just say here test result import if XS len is less than I don't know 50 then return test result discard 50 is too much. Let's do 10 and then test actually this.
01:11:50.887 - 01:12:36.793, Speaker A: I don't think this is going to work either but we'll see. Test result from bool false Interesting. So I just want to run is sorted. I thought it would print these, but I guess it doesn't. I guess it doesn't print its intermediate things. That would have been a nice. Okay, so I guess I could actually change quick check it itself, but that seems like.
01:12:36.793 - 01:13:25.643, Speaker A: Oh, actually I can do that. Sure. KurtOML patch creates IO quick check is equal to Path is equal to home John Dev others Quick check. And now if I go over here, what I can do is E print line our new arguments and now maybe. Yeah, great. Okay. So here you see the process and in fact now I don't even need my little thing here because it will just do the right thing.
01:13:25.643 - 01:14:00.753, Speaker A: Great. So you see it originally generated this array of inputs. This is the, this is the original set of arguments. And then you see this is a vector, right? Then you see the vector gets to half size and then you see it halves the vector length again and then it has the vector length again. And then it well halves and rounds up the vector length again. And at this point, if it tried to have the vector, it must have not been able to reproduce the failure because it's not having the vector anymore. So now instead of doing shrinking of the vector itself, it's now shrinking the individual elements of the vector.
01:14:00.753 - 01:14:22.675, Speaker A: So it's first shrinking the first element and that succeeds. It still reproduces the error. Then it tries to shrink the second argument. It probably tries to set it to 0, but 0, 0 does not reproduce the result. And so instead it goes to. And we can here go look at the implementation of arbitrary for a number. Let's see if we can find like i32 or something here.
01:14:22.675 - 01:15:29.085, Speaker A: Where is numbers, please? C String characters Unsigned shrinker okay, so for shrinking unsigned numbers, you'll see that the way that it shrinks an unsigned number is it first generates zero and then it generates every half number of that. So if it fails to use zero, like it tries zero first and otherwise it tries half the number and then half that number and then half that number, and so on. And so that's what we see happening here, right? It, it tried zero here and then it could still reproduce. Then it tried zero here and it could not, it could still reproduce. And so therefore it keeps having that number all the way until it gets to minus one. And at this point, no shrinking of this vector still reproduces the bug and therefore it returns that as this is where the bug is. This is the smallest test case I can use to reproduce the problem.
01:15:29.085 - 01:16:11.295, Speaker A: So that's what the shrinking does. You'll see that like for vectors it did something Interesting. And it arguably did the same thing for numbers. When you implement arbitrary for your own type, it is a really good idea to also implement shrink because if you don't, you end up with these really common, complicated bug reports. Right where, oh, I found a bug when like this input is all of these extra values and large numbers and everything, and long strings in particular. Whereas once you have shrink, you can actually shrink those down very, very both quickly, but also to make it much easier for you to debug. And the way that you do that, the strategy you have for shrinking is going to vary depending on the type in question.
01:16:11.295 - 01:16:55.045, Speaker A: Sometimes shrinking is pretty straightforward. Like for Booleans, you shrink true to false and false you let stay. Sometimes it's more convoluted, like for vectors, where the strategy for vectors we can go look at it. You'll see that the shrink implementation for vectors actually uses a separate type because it needs a bunch of logic. You'll see here it keeps track of whether it should still be trying to shrink the size, whether it should be shrinking the elements in general. The strategy for vectoring is that it first tries to make the vector shorter by keeping the elements the same. And then once it can no longer shrink the vector anymore because it can't reproduce the problem, then it starts shrinking the individual elements instead.
01:16:55.045 - 01:18:09.663, Speaker A: And this is actually a fun bit of code to read through on your own time of like, how exactly it achieves that. It's some kind of neat manipulation of vectors, but ultimately that's what it does. Make it smaller and then make the element smaller. The takeaway from the code that we read up here in shrink failure is that you want to return the smallest thing first, and then you want to make them larger and larger as a result of like, if you get to the next thing of the iterator, that means that the previous thing did not fail the test, right? If the previous thing had still failed the test, then we would have recursed into shrink failure here instead, we would not have continued with the same iterator. And so you want to shrink as much as you can as fast as you can. So therefore the earlier things you return from your shrink iterator should be the smaller ones, and then you make them larger as a result, trying to reproduce the failure again, okay, so that's shrinking, but I'm happy to take questions on shrinking because little convoluted, but again, not really magic, right? It's just, okay, you have a vector of 100 elements. Make it smaller.
01:18:09.663 - 01:18:45.405, Speaker A: Well, there are two ways you can make it smaller, you can either make it be less long or you can make the elements be less complicated. And those are both strategies of the Vex shrinker. A large vector of large numbers gradually reduces to a small vector of smaller numbers. And that's why it eventually gives you 1 0. Yes, exactly right. And crucially, it does this in order. So it first makes the vector smaller, then it makes the element smaller.
01:18:45.405 - 01:20:02.035, Speaker A: Is it really starting with 0 or 0, the base case? I don't know whether you're talking about the shrinking front sign numbers or whether you're still talking about Sort, but for the shrinking of unsigned numbers, and I'm guessing signed numbers are the same, the Vex zero here is if you're trying to shrink a number, then if the number is already zero, we can't shrink it anymore. If the number is not already zero, then first try zero, then try half of this number, then try half of that number. Or actually this is just. It might just be once. No, it keeps iterating through halves of the number to see if it can still reproduce. In fact, this one is kind of backwards because this one is generating the larger numbers first. I would actually have imagined that this shrinker should be the other way around, that it should first generate zero and then it should generate progressively larger numbers until it hits the number that that was in the original.
01:20:02.035 - 01:20:48.385, Speaker A: Because that way this reproduction here would have been way faster. Right. If we started with minus 1, then we tried minus 2, then we tried minus 4, then we tried minus 8 and so on going up until we hit the number that we originally had, then you would shrink way faster. That might actually be a good contributions to Quick Check if anyone wants to try it out. Why do I need to implement arbitrary for my struct that has fields that already implement arbitrary? Ah, so the reason you have to implement arbitrary for your struct is that otherwise there's no implementation of arbitrary for your struct. Right? There's no such thing as. Well, structs in Rust do not automatically implement traits unless they have blanket implementations.
01:20:48.385 - 01:22:34.105, Speaker A: There is no blanket implementation for the arbitrary trait because if someone tried in the quick check crate to write, you know, impl t like impl generic over t arbitrary for T. It doesn't know how to generate like your struct that you just defined like point with x and y earlier, there's no way in that impulse block in the quick check crate that they know about your fields. So there needs to be a little bit of glue code that says if you want an arbitrary point, the Way you do it is you generate two arbitrary i32s and you stick them in these fields and that glue code is the impulse that we have to write. Could the shrink function return an impul trait? So these days it probably could. However, it might be a little bit complicated or it might not be desirable because sometimes what you want to do with shrink is you want to delegate to the shrink of an of like two inner fields or like you want to chain multiple iterators. And so I guess you could still do that with infiltrate, but when you have a boxed in iterator, no, you know what? I think maybe these days you could. I don't know that it would make that much of a difference, but I think you probably could.
01:22:34.105 - 01:23:02.275, Speaker A: I think Quick Check will not make that change for two reasons. The first being it would be a breaking change. And it's been on like major version one since its release. I think it's currently on version like 1.0.3 because it's a very straightforward implementation. Right. And the other reason is because it would only work on newer versions of Rust where you can use and return position in traits.
01:23:02.275 - 01:23:52.449, Speaker A: But other than that, no, I think you're right. I think you could. So, yeah. So another reason why you don't want arbitrary, you wouldn't want arbitrary to be automatically implemented for types just because they contained a particular set of inner types is because sometimes the outer type has additional invariants on the inner types. So an example here being like if you had a new type called email that contains a string, you don't want the implementation of arbitrary for email to just be the implementation of arbitrary for string. You actually want to have a custom implementation that has additional constraints on that implementation. No, someone asked earlier.
01:23:52.449 - 01:24:51.137, Speaker A: There's no derived macro for arbitrary and I think the main reason for this is because the quick check crate wants to be very fast to use, very straightforward and fast to compile, fast to run. Once you start introducing a procedural macro into the mix, everything gets slower because you have to pull in the syn dependency and everything. There is a quick check macros crate that does use sin as a dependency, but the only thing it provides is the quick check annotation for functions. That one could probably have a derive arbitrary, but. And I don't exactly know why they don't. In fact, there's probably a discussion of this would be my guess here. I think maybe part of the original argument was that, well, if you want all of the sort of niceties of something that is more, let's call it ergonomic then PropTest gives you this.
01:24:51.137 - 01:25:30.635, Speaker A: So prop test uses the arbitrary crate. No, the arbitrary trait from the arbitrary crate, which does have a derive. Whereas quick check just has everything for itself, which comes with a bunch of trade offs in both directions. Let's look for derive arbitrary and see what the derive arbitrary. It is a duplicate dupe of 98. Let's see where this landed. I've often thought of having something like this, but in practice, almost every arbitrary impulse I write needs to encode some key invariants around the values being generated or shrunk.
01:25:30.635 - 01:26:03.865, Speaker A: This would defeat the use of a plugin to do any automatic derivation. Yeah, so you know, but this is from 2015, right, where it would actually be pretty onerous to take a dependency that included arrive close in 2020. Oh, there is now a quick check derive crate. That's interesting. Quick check derive, great. Okay, yeah, so there is now a crate. It's not maintained by burnt sushi, it's just a separate crate.
01:26:03.865 - 01:26:48.305, Speaker A: But that lets you derive arbitrary. That specifically lets you derive the arbitrary trait from the quick check crate. So that does now exist. And I do think a lot of this is about being explicit, right? Like the arbitrary implementations you actually have to think about. It shouldn't always just delegate to the inner values because often you have additional invariants either for your fields or for the shrinking of those fields, and often both. Whereas with the derive you're just saying it's just whatever the inner fields are, which is not uncommon, but it's not also not clear that it is by far the most common case. Does it return the last value of the shrink iterator that still causes the error or the first? The first.
01:26:48.305 - 01:27:42.229, Speaker A: So if we look back at the implementation here, right, we loop through, this is the shrink failure inner function. Here we loop over shrink. The first time we find a failure, we. We try to then shrink that case like the new case we generated, and then we return either the shrinking of that element or the one we hit. So every time we call shrink failure, we're returning the first thing that still errors and in fact we stop iterating there. Right? So this, the fact that there's a return here means that the moment you hit a new failure, you stop iterating over the shrink you're currently on and you start iterating on the shrink of the new value. Okay, I think that's all.
01:27:42.229 - 01:28:10.909, Speaker A: I think we hit the end. There's not really that much more to talk about quick check. In fact, if you look at the code of the quick check crate, we've now talked about basically all of it. There's almost no other code. There's a bunch of implementations of Arbitrary for different types, but it's all pretty straightforward. There's some mechanisms around, like configuration of quick check, like how many iterations it should do and the like, but all of that, very straightforward. There's not any more sort of quote unquote magic to make clear.
01:28:10.909 - 01:28:29.907, Speaker A: Is not magic. It's a great crate. I use it a lot. You can do really cool things with Arbitrary. Like you don't have to just generate a single type. You could have a type that represents, you know, the execution order for a distributed system. And you have an implementation of Arbitrary for that.
01:28:29.907 - 01:29:27.615, Speaker A: So it generates you an arbitrary system trace that you then execute. And you know, the property you check is that at the end of the distributed system execution of that trace, you end up in some known state. And actually, maybe this is one final point, which is one common way to test properties is you compare them to a implementation that is trivially correct, but probably kind of slow. Example of this is, imagine you wrote your own hash map implementation. Hash maps can be enormously complicated, but they're also very straightforward ways to implement a map, right? Or you could even just use a B tree map. So one of the ways in which you could quick check your own implementation of a hash map is either to use the hash map of the standard library as a comparison point or a B tree map as a comparison point, because you're unlikely to have the same error cases that they do. And also they're generally more likely to be correct because they've been around for a long time.
01:29:27.615 - 01:30:09.083, Speaker A: And so the thing that you do is you write a quick check where the generations of arbitrary give you arbitrary keys and values. You take those keys and values, you give them into your implementation of a hash map. You also give them into the standard library implementation of a hash map. And then what you do at the end, like the property you check, is that the two maps are equal, because they should be. And so this is what's known as an oracle property test, is that you're comparing against an oracle that you know is correct. So that's a particularly common way to do, to test a property is to compare against an obviously correct implementation. The obviously correct implementation could also be one that you write yourself.
01:30:09.083 - 01:30:48.575, Speaker A: But it's like stupidly simple. There's no way it has the same bugs as your real one, or maybe has bugs at all. Like represent your map as just a vector of key value pairs. So you know, well, that one's trickier because remove is complicated. But you get my point that you write a very straightforward implementation and then you have a real complex implementation. And even though the real simple one you would never use in production because it's like stupidly slow or something, you should still be able to use it to check whether certain properties sold. Okay, I think then we're all done.
01:30:48.575 - 01:31:07.603, Speaker A: We did it in an hour and a half. I'm pretty happy with an hour and a half. I think this might be the shortest stream. Not far from it, at least. Great. I don't have a plan for what the next stream is going to be. I'm getting a bunch of questions about that, but you'll hear it when I plan what the next will be.
01:31:07.603 - 01:31:30.477, Speaker A: I'm hoping I'll do a crust of rust again soon. I just need to figure out exactly what to do it on. But the next stream will generally be in about a month's time, so I tend to do streams roughly once a month. Okay, thank you all for coming. If you're watching this video on demand, you can now I'll wave you off. And if you're on stream, I'll wave you off as well. I don't know where I was going with that.
01:31:30.477 - 01:31:31.845, Speaker A: See you all later. Bye, folks.
