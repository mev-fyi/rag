00:00:00.280 - 00:00:33.415, Speaker A: Hello everyone. I saw the Rust Survey 2019 results and while reading through I came across this little bit. People are asking for more learning material about Rust, specifically intermediate level material. And a lot of it is asking for video content specifically. And if you're watching this, maybe you already know. I have a YouTube channel where I do live intermediate and uploaded intermediate Rust content. So I was like, huh, this sounds like my wheelhouse.
00:00:33.415 - 00:01:34.665, Speaker A: And so I tweeted out, like, what would you like to see if I were to do some of this? That's like a little less advanced than the stuff I normally do and a little shorter and a little more self contained than what I usually do, like, what do you want to see? And I got a ton of responses to this and that was pretty cool to see all the ideas that people had, the suggestions were sort of all over the place. And basically what I got from it is people are confused about lifetimes and they don't want to see another explanation of lifetimes. They want to see code that actually uses them in order to try to understand what's going on. And so I figured maybe that's something I could do. I only have one video that's like more beginner friendly than the normal ones I do, which are usually much longer sessions where we build something real in Rust. And that is where we did a live coding of a link to Hashmap and that one actually turned out pretty well. I think that's something that's easy to follow if you're relatively newer to the language.
00:01:34.665 - 00:02:05.155, Speaker A: But I figured I would do something that's sort of dedicated to this and if it turns out to work well, I might do more in the future. And so that's where we are now, specifically in the stream. What I want to do is basically have us write a bunch of code in Rust. Not very much, but sort of a. You'll see where we cover like multiple lifetimes. A little bit about strings because that seems to be something that's confusing people. And a little bit of generics depending on how we, how we turn out on time.
00:02:05.155 - 00:02:41.525, Speaker A: My guess is this stream will be about 90 minutes. That's sort of the target range I'm going for for this, which is much shorter than my usual streams. I'll try to be less verbose than I usually am. And if this is the first time you watch any of my videos, first of all, welcome. And second of all, if you go to my Twitter account, I have. This is basically where I post any new videos that I'm about to release both to Announce the live streams in the first place to ask for input on what you want to see. And also, whenever I upload a recording of a live stream, then I will put them up here.
00:02:41.525 - 00:03:28.545, Speaker A: And so, without further ado, let's get started. Because the stream is sort of geared more towards people who are still getting to grips with sort of some of the complexities in Rust. I'll also be taking a bunch of questions from chat. So if at any point you get sort of you feel like you're not quite following, or you feel like something doesn't make sense and you would like me to explain it again, then please mention it in chat and I'll try to make sure to look over there now and again to like, make sure that you're all following along. And in particular, this is important because the people who are watching this after the fact, they won't have the opportunity to ask questions. If you have a question live, chances are someone else will also have it later. And if you ask it, the answer will be recorded in the stream.
00:03:28.545 - 00:04:45.125, Speaker A: Great. Okay, so I also got some questions actually from people who relatively need to wrestle, like, how do I even start. Start a Rust project? That's not normally something I cover, but I figure given that we're starting something new, I'll start from the very beginning with Cargo New, we're going to make a library, and the library we're going to make is one that lets you take a string and split it by the string and walk the splits of that string. And so we're going to call it String Split or strsplit. It's not a very original name, but it doesn't have to be. And inside here you'll see that we have the Cargo toml, where we get to define sort of metadata about our new crate and also Source lib, which currently basically has nothing of real value. And the starting point here, there's a bunch of stuff I like to add as a prelude to any package that I make, and that's things like I like to add warn for missing debug implementations, Rust 2018 idioms, and missing docs.
00:04:45.125 - 00:05:09.875, Speaker A: There are a bunch of others you might add to. These aren't going to matter that much for the stream. We're not going to be writing a ton of documentation, even though normally I do when I publish something like this. But here we're going to focus more on sort of the insides of the thing we're going to build. But I figured it would be good to give you that prelude. It's something you can use in your own crates too. I like this to be warn, not deny, because sometimes these change over time.
00:05:09.875 - 00:05:54.419, Speaker A: Like the compiler gets smarter at some of these lints and you really don't want a lint to be breaking your compile because someone has a later version than what you originally built with. All right, so here's what we want. Well, we want to type and it's going to be called, let's say string split split and the methods. Really what we want for spring string split is we're going to add fields to it after a while. But there's going to be something that's going to be a new and it's going to take some haystack. This is usually. Haystack is usually the thing that you are searching in and it's going to take some needle.
00:05:54.419 - 00:06:22.465, Speaker A: In this case we're going to call it the delimiter. So this is the thing that we're splitting by and it's going to return a self. Self here is sort of a special type that refers to the name of the input block. It's useful to use self rather than. We could write str split here. Using self is just nice because it means that if we rename the type later, we don't have to change all the return types of the methods and stuff as well. So basically this is saying I want to split this by this.
00:06:22.465 - 00:06:57.797, Speaker A: And we could call this like split by instead of new. But we're not really doing API design here. This is just to give you a sense for what this type is going to do. And then what we want to do is implement iterator for strsplit so that the iterator trait is. The iterator trait allows you to do something like for part in. Let's say you have a X that's of type strsplit. Then you can do 4 part in X as long as X or strsplit.
00:06:57.797 - 00:07:42.693, Speaker A: Xstype implements Iterator so the item here is going to be str. And the only thing that you need to implement on iterators is the next function which takes a mutable reference to self and returns an optionalitem. Notice I haven't put any implementations any fields yet. I'm just giving you roughly the API we're going to be working with. And the idea here is that the for loop construct is really turned into a while let sum equals the type next. That's what for desugars do. So it's going to keep calling next while it's still returning sum and when it no longer returns sum, then the loop will be terminated.
00:07:42.693 - 00:08:39.272, Speaker A: And so the idea here is, and we could arguably write this as a test, although this test won't really do much at the moment. The idea is that you have some string like let's say A, B, C, D, E and you want to do for letter in haystack dot. Well, I guess in this case this is going to be str split new haystack and then let's say here space. Right, that's going to be the idea. And this is going to produce A then B, then C, then D, then E. Ideally, how do we write a test for this? Well, we could do letters. Is this this collect or in fact could just be this.
00:08:39.272 - 00:09:21.313, Speaker A: And then we can do assert equals letters with something like intuitor. You can compare iterators as long as they have the same type. Does the basic thing we're building make sense? We'll probably not talk about higher kind lifetimes. That probably won't come up. Won't that just add noise when debugging early prototypes? Yes. This whole thing at the. This prelude is in the initial phases of development.
00:09:21.313 - 00:09:49.625, Speaker A: You probably don't want it on because it's just going to cause you get more warnings. So it's harder to see which ones are which ones matter and which ones are more stylistic, if you will. How do you decide between library and binary? And how do you check the library output results while coding? So you decide between library and binary depending on whether you are. Whether you're building a binary or a library. Right. Binary is if you're building a program that someone's going to run on the command line. Everything else is a library.
00:09:49.625 - 00:10:25.817, Speaker A: You might build a thing that has both a library and a binary, in which case it doesn't really matter. The only difference between the lib and bin flags are that the bin flag creates a source main and the lib flag creates a source lib. Those are most of the differences. But you can have both in one crate. And if you build a library, the way you check its output is you write tests. What do you do to mock external dependencies? I'm not going to cover that in the stream, but there are good ways to do it. I thought all loops desugar to loop with a break condition.
00:10:25.817 - 00:10:49.895, Speaker A: Well, in mirror I think while loops desugar to loops as well. It's just. It's easier to explain it as for turns into while. But you're right that deeper down while turns into loop. Yep. All of this is going to be about lifetimes you're about to see. Great.
00:10:49.895 - 00:11:10.895, Speaker A: All right. Equality comparison between iterators is element wise. Yeah. It also checks that the links are the same. Okay, so now we have a program, and now we're going to have to actually figure out how to write this. And there are a couple of things that immediately come up. So let's start with.
00:11:10.895 - 00:12:02.211, Speaker A: I'm going to call this remaining remainder, and we're going to have a delimiter, right? So we're going to have a remainder. This is the part of the string that we've not yet looked at. We haven't returned anything from it yet. And delimiter is what are we splitting by which we need to remember over time, right? And so new is really just going to create a new self where the remainder is the haystack and the delimiter is the delimiter. Notice that delimiter here I don't have to put field colon value because the two the field and the variable have the same name. And so I can sort of deduplicate them. In the case of remainder, the field and the variable do not have the same name.
00:12:02.211 - 00:13:14.795, Speaker A: So I give both. And the reason I don't change, I want this to be called remainder, and I want this to be called haystack. And that's why I end up with this format. Okay? So new is pretty straightforward, and most of the magic here is going to be in the implementation of next, right? So the question now becomes what do we do in order to implement next? Well, the implementation is pretty straightforward, right? What we're going to do is we're going to find where the next delimiter appears in the remainder, and then we're going to chop off that part of the string. That's what we're going to return. And we're going to set the remainder to what remains after the delimiter, right? So the next delimiter, next delim is going to be self remainder, find and we're going to look for self delimiter. And this is an if let sum, because it could be that there is no delimiter in the string, right? The delimiter no longer appears in the string, in which case we're sort of done.
00:13:14.795 - 00:14:47.245, Speaker A: But if it does appear, then what we want is until the delimiter, right? Is going to be self remainder from the start until the next delimiter, right? And then we're going to modify the remainder to be self, remainder, everything following that delimiter, right? So that's going to be next to lim plus the length of the delimiter. So everything from there and out. And then we're going to return sum of until delimiter. Right? And if the delimiter is not found? Well, in that case we can just return none. Actually then if the delimiter is not found, we have two options. We either either the remainder is empty, in which case we return none, or if the remainder is not empty, then we return the remainder. So in that case we're going to set rest is going to be self remainder, self remainder is going to be empty, and then we're going to return some of the rest.
00:14:47.245 - 00:15:14.845, Speaker A: You'll see. There's actually a bug in this code. I'll get to that later. Okay, let's take some more questions. Is the cascade itself really the preferred way of implementing that? I'm very much new to Rust and it seems a bit odd coming from other languages. I've seen both. I personally prefer using self, as I mentioned, because it means that if I change the name of the type, I don't have to change anything else.
00:15:14.845 - 00:16:09.695, Speaker A: I think the biggest cost to this is that it means you can no longer do local reasoning. Looking at this line of code, you have to figure out which type you're inside, the impl of which is trivial here, but if you have a really long one, it might be trickier. Also, you need to rely on a later release of the Rust compiler. Although this was added I think a decently long time ago now can explain later. When should I use associated types versus generics? There's actually a decent description of that in the Rust book. I believe the basic idea there is use generics if you think that multiple implementations of that trait might exist for a given type. Use associated types if only one implementation makes sense for any given type.
00:16:09.695 - 00:16:43.695, Speaker A: When do you use Match versus if let sum? I use match if I care about more than one of the patterns. If I only care about one of the patterns, then I use if let. How should I read line 15? So I'm using relative line numbers. So when you say 15, it's not clear what you mean is else if not required. Oh, you're right. That should say else if. Good catch.
00:16:43.695 - 00:17:12.853, Speaker A: Great. All right, so we have an implementation now that we think. Let me. I'm just going to write a to do bug here because I know there's a bug, but I don't want to talk about it yet. Okay, so in theory, we're now done, right? We have our implementation. Great. We're going to just CD into STR split cargo test oh, no, it doesn't compile.
00:17:12.853 - 00:17:34.855, Speaker A: What is this? Right. It's telling me missing lifetime specifier. Missing lifetime specifier all over the place. Let's do cargo check instead so we don't get these duplicated. It's telling me in all these cases where I have references that I need to give them a lifetime because I can't figure out what that lifetime is. Okay, so we do what we've been told. The Cabala said add a ticket, so we're going to add a ticket.
00:17:34.855 - 00:17:54.055, Speaker A: Okay. Now it's telling us we have to do that here as well. Okay, so we're going to use the new fancy, like anonymous lifetime here. We're going to do the same thing here. All right, so we did that. Now they all have a lifetime. I'll talk a bit about what this actually implies, but let's just see if it's happy.
00:17:54.055 - 00:18:52.767, Speaker A: It's still not happy down here. Okay, so down here in the Iterator we say that the Iterator returns a string reference, but Rust doesn't know. Think of this as a pointer to a string, right? And Rust needs to know how long can I hold on to this pointer for? So, for example, this pointer, right? We know it points into the remainder here, right? That's where we know that that's where it points. But Rust, when it calls Iterators the Iterator next method, it just gets back a pointer to a string. And if that's all it gets, then can it hold on to that for the end of the lifetime? Can it. The end of the program, can it drop, stir, split, and then still use it? It doesn't know how long it's okay to keep using this pointer for. And it needs to know, right? Because otherwise it might use that pointer after the string it's pointing to has already gone away after the memory has been deallocated.
00:18:52.767 - 00:19:34.081, Speaker A: And that would be a problem. Well, so we have this tick a now, right? And this tick a here is really a lifetime to like. Well, let's, let's keep calling it tick A for now. And this is really. How long does this reference live for? Right? What we're saying here is that if you have a stir split, then the remainder and the delimiter both live for this long. The pointers are valid for that long. And down here, really what we're saying is, well, if the remainder is valid for this long, right? The ticket here and the ticket here are the same that we could call them different letters.
00:19:34.081 - 00:20:06.005, Speaker A: Think of this as like generic over lifetime, then the thing that we return has the same lifetime. You could imagine other lifetimes here, right? The lifetime of the returned string could be something that's tied to the lifetime of the STR split itself. Right? But that's not the case here. We're actually having. There's some lifetime that's longer than STR split. Right. Even after you drop the STR split, the thing that you get back from the Iterator is still valid because it's about the lifetime of the string we were originally given.
00:20:06.005 - 00:20:21.341, Speaker A: The haystack we were given. That's what matters. All right, so that was a lot to cover. So let's talk about that before we continue. That looks very foreign. Yeah, it is foreign. Lifetimes are.
00:20:21.341 - 00:21:01.721, Speaker A: You don't have these in other languages. In general, the plugin here is COC with Rust Analyzer. Can I be wrong by specifying lifetimes? You can never be wrong by specifying lifetimes. If you specify a lifetime that the compiler. Think of it this way. It's like using the wrong type. You can use the wrong type, but eventually there's going to be like, you have to call a function and you have to provide something that is of some type and you give it some other type and the compiler goes, these are not the same.
00:21:01.721 - 00:21:41.407, Speaker A: So the compiler won't let you compile a program with the wrong lifetimes. It won't generally let you do that. It like. Yeah, so you can't really give the wrong lifetimes any more than you can give the wrong type in the sense that the compiler is going to catch that you did that. How to tell where an anonymous lifetime can be used. So anonymous lifetimes are places where you tell the compiler, guess what lifetime. And that only works when there's only one possible guess.
00:21:41.407 - 00:22:21.987, Speaker A: So one example of this is if you. Let's have some other impulse here. I'm just going to make up an impulse and it's something like get referred takes a reference to self and it gives back a reference to str Right here. If I put this here, there's only one other lifetime here and that's the lifetime to self. And so the compiler can guess what this type is as you don't need to give this. Right. The compiler understands when you give this that it must be this lifetime.
00:22:21.987 - 00:23:07.115, Speaker A: So that's an example of where the compiler can guess what's the difference between tick A and tick underscore. Tick underscore is telling the compiler you guessed the lifetime. It sort of means it's sort of the same as underscore for types that's where it originally comes from. Sorry, underscore for not underscore for types. It's sort of like a pattern that matches anything. That's not quite true either, but it's something that you can use when you don't want to specify the lifetime and you think the compiler can figure it out. Tick A is a specific lifetime.
00:23:07.115 - 00:23:45.515, Speaker A: It's similar to a generic. It's like a T. Is there any kind of ordering on lifetime specifiers? Like it's tick A more than tick B? No. Well, yes, you can order lifetimes based on how long they are. So, for example, the special lifetime, tick static is a thing that lives for the entire duration of the rest of the program. And so you can have some tick A that's shorter than or smaller than tick static. In general, though, the name you give does not matter, just like the name of a generic doesn't matter, like tick A versus Tick B is just a name that you choose.
00:23:45.515 - 00:24:28.785, Speaker A: How does the compiler know it's wrong, but it cannot infer it? I think of this as I can write a function, multiply, and it takes an X that's a unit and a y that's an i32. Right. This is wrong, right? Like, I can't write the implementation here, and so the compiler knows that it's wrong. The compiler doesn't know what this should be right. Only you know what this should be right. If I here write, I guess X times Y, you know what this should be. The compiler does not know.
00:24:28.785 - 00:25:07.367, Speaker A: So the compiler can tell you that you're wrong, but it can't tell you what the right answer is. Yeah, so underscore is basically type inference for lifetimes. Why would you not align the lifetime if you're leaving the tick underscore in the type? You basically want to align whenever you can. There are some cases too where tick underscore. You can use it to say, don't consider this lifetime for the purposes of guessing. As we expand this a little bit more, this might become clearer. There's a way to use multiple lifetime specifiers at the same impulse.
00:25:07.367 - 00:25:33.695, Speaker A: Yes, we'll see that in a second. Yes, you can specify an order for lifetimes. We won't need that here, but you can this tick underscore only get used if there's only one possible lifetime. No. So tick underscore. You can also use it if. Imagine that you have a function.
00:25:33.695 - 00:26:20.711, Speaker A: Imagine that you're writing something like this, where it takes. Why is it take B stir, and you want to say this returns something of the Lifetime of the X. Right. So we could call these X and Y as well instead to make this easier to to read. Right. If this is the impulse you have, you can simplify this with anonymous lifetimes by saying this, this, in which case this gets ignored. This basically gets in argument position, it gets turned into an arbitrary unique lifetime.
00:26:20.711 - 00:26:54.527, Speaker A: And in the output position it means type inference, basically lifetime inference. And so it's going to infer that this must be tied to X, but must not be tied to Y, because Y has its own lifetime. So in other words, the lifetime of STR split remainder and STR split delimiter is now tied to the lifetime of the STR split itself. No. So this is where you'll see that we still get a compile error. So actually let's move on to that because I, I think those are most of the questions. Great.
00:26:54.527 - 00:27:26.875, Speaker A: So let's do a cargo check. Okay, so what does this do? So now we get an error saying lifetime of reference outlives lifetime of borrowed content. So this is where we get into sort of weird lifetime land, right? And this is probably an error that you've seen in the past. You throw up your hands ago. What is even going on? So let's try to actually read through this. It's complaining about the new function and it's saying specifically there's a problem with Haystack. The reference is valid for the lifetime tick underscore as defined on the implementation up here.
00:27:26.875 - 00:28:17.211, Speaker A: But the borrowed content is only valid for the Anonymous lifetime number one defined on the method body at 10:5. So 10:5, if you see is here. Oh, sorry, yeah. So 10:5, right? Line 10 column 5 is like right around here. So what it's telling us here is you told me that you were going to give me something with this lifetime, right? When we say new return self, then that self has this lifetime. But the thing that you gave me in remainder, which is supposed to have that same lifetime, right? The remainder here is supposed to have tick a where the ticket is the one from the definition of stir split. But you gave me something that has a lifetime that is just whatever this lifetime is.
00:28:17.211 - 00:28:59.935, Speaker A: And those are not the same. Specifically. I don't know that the haystack pointer here lives for as long as this lifetime here. They're just both like some lifetime and we haven't given any relationship with them or between them. And the same thing here for delimiter, the delimiter that's given in is a pointer to the string. To some string, right? But for all we know, the Moment that new returns, the string that haystack and delimiter point to might be deallocated immediately, because we haven't put any restrictions on the lifetimes of those parameters. So imagine if that were the case, if the caller immediately removed those strings from memory.
00:28:59.935 - 00:30:53.639, Speaker A: At that point we still have a stir split hanging around with some lifetime that has some random name, right? And that stir split struct has pointers to those strings still. And that should obviously not be okay, because it's not okay for us to continue to refer to those strings once the memory has gone away. So clearly there has to be some relationship between the strings that are the string pointers that are passed in here and the lifetime of the pointers we hold inside strsp. And we want the compiler to ensure that the as long as the STR split is around, those strings are still accessible through the pointers we were given. And so how can we express that? Well, what we really want to say here is that I can give you a STR split with a lifetime tick a if you give me string pointers that are also tick a, Right? You see the difference here? So here we're saying the pointers you give me in they can live for however long you want, but they have to live for at least some some duration tick a and the type I give you back has a lifetime that is the same as that lifetime. And the compiler is now going to check that, as you can only keep using this as long as that lifetime is still live, which implies by the fact that it's connected to this lifetime, that you can only keep using the str split for as long as the input strings are still valid. Does that make sense? Okay, so that was a lot more.
00:30:53.639 - 00:31:54.405, Speaker A: Let's iterate on that and then continue. Why do we use generic names for lifetimes and not proper names like typical variables? I mean, why do we use T for generic types? That said, I have seen an increasing number of people using more descriptive names, and my plan is to do the same here. We can't currently do it, but I'll get to it a little bit later. How resilient is the anonymous lifetime? Will you get yourself in trouble if you rely on it too much, or is the compiler going to pick correctly the vast majority of the time? Use it if you can is generally the answer for the anonymous lifetime. Can you impose restrictions between lifetimes? Yes, you can. Here. So far we only have one lifetime, right? We only have the lifetime ticket, and so there's no relationship to really give.
00:31:54.405 - 00:32:32.855, Speaker A: But yes, you can give lifetimes. You can give more than one lifetime and then give relationships between them. Saying this reference must live for longer than this, at least as long as this reference. I don't think we'll need that here, but we'll see. Great. Oh, great. Great.
00:32:32.855 - 00:33:22.885, Speaker A: Yes. This is very much related to type systems. Like lifetimes are types, lifetimes are like types, and you can use similar language to talk about them in some sense. I don't know to what extent this is actually accurate, but in general, you can think of lifetimes as the relationships between lifetimes as sort of like subtyping. Why is the ticket next to the impulse keyword needed? Yeah, so notice we're doing ticket here and tick a here. The reason those are needed is for the same reason as if you have some struct food that's generic over T. You cannot write this.
00:33:22.885 - 00:34:00.685, Speaker A: That is not something you can write. If you did, the compiler would say you're using a type T here, and I don't know of a type T. The placing it after the impl block is what makes it a generic impulse block. It's saying this input block is generic over t over any type T. Similarly, this is saying this impl block is generic over any lifetime. Tick A. The Rust type system has two bottom types.
00:34:00.685 - 00:34:26.271, Speaker A: Yep. Subtyping is actually the language used for lifetimes in the Rust nomicon. Yeah, that makes a lot of sense. I'm generally not going to be answering questions about other things because I want to keep this stream short. Great. All right, so let's see whether this works now. Okay, so here's another thing that won't work.
00:34:26.271 - 00:34:46.983, Speaker A: So if you're in cargo, check now, you see that the errors we got for new have now gone away. This. Oh, that should not be that. It's an empty string. Okay, Notice here the compiler. Let me get rid of these because they're not that useful at the moment. Notice that the compiler.
00:34:46.983 - 00:35:28.465, Speaker A: So it's not giving us any errors now. So the compiler is totally okay with me having a star split that contains tick a reference to a str and me just assigning the empty string to it. Why is this. Okay, right, think of this as self. Remainder has type tick a str. Right? This has type tick, static stir. So why is it okay for me to take one of these and assign it to something here? Well, so this gets back to the static lifetime.
00:35:28.465 - 00:36:05.873, Speaker A: So the static lifetime is the lifetime that extends until the end of the program. Think of it as it basically never ends. And this is where the subtyping relationship comes in. So if you have any lifetime, you can assign to it. If, if you have a reference of any lifetime or a thing that contains any lifetime, you can assign to it anything of the same type, but a longer lifetime. And the reason for this is sort of straightforward, Right? If I need something that lives for at least a. Then some other lifetime that's longer than a trivially can be reduced to that description.
00:36:05.873 - 00:36:37.545, Speaker A: Right? The other, the other thing, the other way is not true. If I require something that's a pointer that lives that is valid until the end of the program, I. I can't give it anything that has a shorter lifetime because it wouldn't meet those criteria. But we were going the other way is fine. All right, so let's try. Our test case here does not implement debug. Okay, so we're going to derive debug up here.
00:36:37.545 - 00:37:19.497, Speaker A: Oh, I forget what the trick here is. It's like letters, dot, eek. This, I guess. Great. Okay, so our test passes. So the question now is, are we done? Let's just see whether the things I just did. So now we have sort of a complete program in the description of static.
00:37:19.497 - 00:38:19.937, Speaker A: Let's see whether that roughly made sense. So everything by default has a static lifetime. You can sort of think of it that way, although it's not really true. Any value has a lifetime of however long that value. If you have a value that's you assigned to a variable, say the lifetime of that value is until that value is moved. If the value is never moved, then it has a static lifetime. But the value itself, like if you store something on like the stack of a given function, the lifetime of that value, unless you move it somewhere else, is going to be the lifetime of that function.
00:38:19.937 - 00:38:42.559, Speaker A: Basically the stack frame for that function. And when the function returns, that lifetime ends. And it has to. Right. Because if you gave out a reference to something that's on the stack, then that reference can't be allowed to continue living after the function returns. That wouldn't be okay. Can I think about stir split like a fold R.
00:38:42.559 - 00:39:18.825, Speaker A: No, it's not a fold, it's a split. It takes. It takes a sequence of characters. Well, it takes a string and it splits it into multiple smaller strings separated by some delimiter. Yeah. So one reason why this empty string over here is static is because any constant string, any string that you write directly in double quotes is compiled into your binary. It lives as a little.
00:39:18.825 - 00:39:54.899, Speaker A: Like it's stored in the program that's stored on disk. And so. And when Your program is launched, the operating system is going to load that binary into memory. And anything that is a static like that, anything that's a value that's written into the binary is in sort of read only memory that will never move. And so if you take a pointer to it, which is effectively what this does behind the scenes, it takes a pointer into that. The text segment of your binary. Well, it takes a pointer into a particular segment of your program, then that reference naturally lives for the rest of your program.
00:39:54.899 - 00:40:26.475, Speaker A: That pointer is always going to be valid because that part of your program's memory never changes. Yeah, so eek is the thing on iterators. It's very handy. You're right that we don't need to like. Another way to do this would be to collect this into a vec and then assert eek of letters. And this, we can do that instead. That's fine too.
00:40:26.475 - 00:41:02.685, Speaker A: This is more to show that it's neat. Don't variables die at the end of scope, not just return? Yes. So lifetimes are for as long as a value still lives. And so this is why a value. It's not like values default to being static, they default to living for as long as they do. There's not really a default, it's just any value only lives for as long as it lives for like until it's moved or dropped, basically until it goes out of scope. But it can be shorter too.
00:41:02.685 - 00:41:38.965, Speaker A: Right. If you call some other function with that argument and it gets moved, then the lifetime for that for that value ends and you can't use it even later in the same scope. Yeah, so one reason to prefer assert equals is we'll get nicer errors. Okay, so I mentioned a bug. Let's just deal with that before we go on to the next. And the bug is this. If I run this, it's going to fail.
00:41:38.965 - 00:42:17.805, Speaker A: Specifically here we have a delimiter that tails the string. In this case, the iterator should produce the last element as an empty element because the delimiter was there. And so technically it should produce an element there. And so we need to distinguish between whether the remainder is empty or whether the remainder is an empty element we haven't yielded yet. And these are a little bit subtle. The way we're probably going to end up doing this is I'm going to make the remainder. Oops, that's not at all what I meant.
00:42:17.805 - 00:43:16.495, Speaker A: And option this. And so here we're going to do. Hmm, how do we want to do this? In fact, there's a different problem Here, which is really. Hmm, it's a good question. There's a separate problem here, right. Which is in fact even more subtle, or not even more subtle. It's just tricky, which is that currently it's not even going to do the right thing for.
00:43:16.495 - 00:43:57.875, Speaker A: Actually, no, that is the only case that gets hit. Does the bug make sense? Why can't the compiler infer these lifetimes? The compiler does infer these lifetimes. The compiler infers the lifetime for every value here. What we're saying was we're writing code that is generic over lifetimes, and so the compiler doesn't. It. It can't infer that the type. The lifetime we return here is tied to the lifetime of the remainder, which is tied to the lifetime here.
00:43:57.875 - 00:44:29.765, Speaker A: It would have to do some pretty sophisticated code analysis to figure that out. And so we're adding these lifetime annotations to tell it how long we need different pointers to live for. Lifetimes are for all allocated memory. If you have a heap allocation, then that still has a lifetime. It's just the heap allocation has a. The heap allocation lives until it is dropped, so it still has a lifetime. If it's never dropped, then it would be static.
00:44:29.765 - 00:45:09.595, Speaker A: But in general, the only way you can get something on the heap and then never drop it is with something like box leak. And box leak does return a static reference if you dump the binary. Could you spot this out of collocation? Yes, you could. Not for the empty string because it gets optimized out, but in general, yes. In fact, there's a program on UNIX called Strings that prints all the strings in a binary. Great. All right, so let's fix this bug.
00:45:09.595 - 00:45:41.115, Speaker A: I think what we want to do here is else. If let some remainder is self.enderder. take, then we're going to return some remainder. Actually, we don't even have to do that. We can just do self remainder. Take. I'll write this out first.
00:45:41.115 - 00:46:12.785, Speaker A: It might be easier to follow. Right. If. Let some ref. Remainder is self remainder here, I could use the new Smart matching patterns. I don't really like that feature, but I could. So if there is some remainder, then we're going to search through the remainder.
00:46:12.785 - 00:47:00.695, Speaker A: I guess this has to be a mute. People are going to have all sorts of questions about this and I'll get to that in a second. And then this is going to be none. Sorry, this code is currently ugly. Let me get to that. Yeah, so if there is some remainder that's still to be searched, then we're going to look for the Delimiter in that remainder. If we find the delimiter in that remainder that's inside this second, this sort of nested if let sum, then we extract.
00:47:00.695 - 00:47:47.605, Speaker A: Then we do what we did before, right? We extract the stuff until the next delimiter and then we set the remainder to be everything past that remainder, and then we return sum. And otherwise we're going to return just what the remainder was, regardless of whether it was. Well, this, this will trivially be sum because it was some up here. But we want to take it so that we leave none in its place. And then I guess this just becomes none. And so now you might wonder, well, what's this business going on down here? Why do we have to do any of this? So actually this might even be able to do this might be fine. That great.
00:47:47.605 - 00:48:23.145, Speaker A: All right. Yeah. So question here. I'm aware of string split at. Thanks. So one question here is what is the ref keyword? So if I did this, that moves out of self remainder. This is saying, this is assuming that I own this and I get to move the value.
00:48:23.145 - 00:49:01.533, Speaker A: But that's not really what I want to do here, right? I want to get immutable reference to the value inside of self remainder if it is sum. And that's what ref mute does here, right? The type of this here, right, is an option. An option. Take a stir. And I want the type of remainder to be a mutable reference to the tick a stir, right? Oh, I did not want that wrapping. That's what I want remainder to be. And that's what this ref mute does.
00:49:01.533 - 00:49:51.357, Speaker A: If I did not have the ref mute here, then what I would get back is this, which wouldn't help me because I need to reassign that value to move it to be beyond the next delimiter. And so I don't want to sort of take that value, I want to modify the existing one. Yeah. So ref A means that I'm matching into a reference. Like I want a reference to the thing I'm matching rather than the thing I'm matching itself. And similarly, ref mute means I want to get a mutable reference to the thing I'm matching rather than get the thing I'm matching itself. What was the ampersand star? We're going to ignore it because you don't need it.
00:49:51.357 - 00:50:20.455, Speaker A: It was an attempt at a reborrow that wasn't needed. Why can't you write. Okay, so this is a good question. So why can't I write this? I think is the question. So this sort of does the Opposite this is saying take, take what the right hand side is and try to match it against this pattern. So the mutable reference here is a part of the pattern. It's saying what I'm going to give you.
00:50:20.455 - 00:51:03.225, Speaker A: This would only match something that was a option tick mu T and then remainder would be the T. Do this, do like a visual match. Here, let me try to line these up so you can see it more clearly. Right, so remainder would be assigned to T because it would automatically do the dereference. If I write ref mute and you give me something like this, then remainder is going to be a reference, immutable reference to that T. And so this is the way in which they differ. There's sort of inverses of each other.
00:51:03.225 - 00:51:24.225, Speaker A: If let some mute remainder equals. Yeah, so with the new automagic things I could also do this. That would also work. I don't like writing the code this way because it looks weird to me. But it does mean you get rid of the ref mute. But there's more magic going on here. So I like writing it this way.
00:51:24.225 - 00:52:04.037, Speaker A: Yeah. So ref, you can think of ref as make a new reference or take a reference to and similar to ref mute. What's the D ref on the left side of that assignment doing? Ah, so the type of remainder here is a mu is right. Remainder here is of type this. Right. But the right hand side is of type this. And I can't assign something like this to something like this.
00:52:04.037 - 00:52:39.039, Speaker A: That won't work because they're not the same type. And so I need to dereference. I want to assign this into where remainder is pointing and so that, hence the dereference there. Next delim plus self delimiter length this. Yeah, so this might end up being one past the end of the string. It might point to just beyond the end of the string. And that is a valid position to cut a string or a slice at.
00:52:39.039 - 00:53:19.451, Speaker A: It basically gives you the empty slice. Uh, what is the take call doing? So take is a really handy method on options. So take is a function. It's implemented on option T minus. Fine, let's make it proper. And take takes immutable reference to the option and gives you back an option T. And the idea behind take is if the option is none, then it returns none.
00:53:19.451 - 00:53:55.209, Speaker A: If the option is sum, then it sets the option to none and then returns the sum that was in there. And that's what we want here, right? We only want to return the remainder that doesn't have a delimiter once. And so that's what this would do, because the moment you take it, what's left is none. And so on a subsequent call to next, what you would get is this would no longer match and you would get to the none branch instead. And in fact. So just to check, this should work. Now we can simplify this code even more, which is the question mark operator.
00:53:55.209 - 00:54:29.445, Speaker A: The try operator also works on options. So we can do. And people are going to hate me for this. We can do this. Okay, so this is something most Rust programmer would never, would rarely actually write. Remember that every let statement is a pattern match. And so here what we're saying is I want a pattern match on what was inside the sum of self remainder to take a reference to what is in there.
00:54:29.445 - 00:55:07.975, Speaker A: This is weird Rust that you won't see very often. You could also write this as this. And we do the same thing. They're sort of inverses of each other. If self is mutable here, why is self remainder not mutable by default? So there's a. You need to keep in mind that the mutable references are only one level deep. So if you have a mute to self, what that means is you are allowed to modify any of the fields of self.
00:55:07.975 - 00:55:43.839, Speaker A: But so, so I'm allowed to modify remainder, I'm allowed to modify delimiter. But what delimiter is, is an immutable pointer to some string. And so while I can change delimiter itself to make it point somewhere else, I can't change the thing that delimiter is pointing to. For that delimiter itself would have to be immutable reference question mark. An option is available. Unstable as well should be at least. Okay, great, so this now works.
00:55:43.839 - 00:56:10.529, Speaker A: Let's just double check. Oh, that does, I guess, not work, because probably this would be my guess. Oh, huh. So this actually does a move. So we can't do that. So this has to be an asmute. Okay, so this is kind of subtle.
00:56:10.529 - 00:56:46.937, Speaker A: So let's go over this as well. This is not something I plan to cover, but we might as well while we're here, what this does is if self remainder is none, then it returns none. Otherwise it returns the value inside the sum. And normally that would move the thing that's the T that's inside the sum. But because the thing that's inside the T is copy, we get copy semantics instead of move semantics. So it copies this reference out of the option. This means that remainder is no longer the same remainder as the one it's in here.
00:56:46.937 - 00:57:34.525, Speaker A: It's not a mutable reference to this it is just a separate reference pointer. This means that when we modify it down here, what we're actually modifying is just our copy of that pointer. It's not modifying the pointer that's stored inside self. And so we can do as mute here, as mute is a function on option. So it is a function on option that takes immutable reference to self and returns an option that contains the mutable reference to self. And so now if this is none, then we return none. If this is sum, what we get back is a mutable reference to the thing that's inside the option.
00:57:34.525 - 00:57:57.015, Speaker A: And so now remainder will be a mutable reference inside of strsp. Great. All right, so now we have a working implementation. It doesn't hang. That's all fine. As nami, you might wonder. Well, I came to the stream to learn about multiple lifetimes, and so that's what we're going to look at next.
00:57:57.015 - 00:58:43.845, Speaker A: Imagine that you want to write the following implementation. You want to write this function that is a split by character. Or actually, let's do even better. Let's do until character. It's going to take a string s and it's going to take a character and it's going to give you. It's going to give you the string. It's going to give you the string until the first occurrence of that character, right? So if we wanted to write a test for it, we'd write something like until car test.
00:58:43.845 - 01:00:05.335, Speaker A: I'm expecting that if I do hello world and I give it a O, then this should return. Hell, it's a fun coincidence. I did not plan that. Okay, so that's our plan. And here we'll do a tick underscore to tell the compiler, just infer this. In fact, we might not even need to, but with the Rust 18 idioms, it's gonna complain at us. And naively, now that we have STR split, this should be pretty straightforward, right? We should be able to just do str split new, give it the S, just format the C to be a string and do next and do an unwrap, because we know that there will be a 0th element, right? So here, let's make this an expect and say STR split always gives at least one result, right? So we'd sort of hope that we were able to do this.
01:00:05.335 - 01:01:03.535, Speaker A: And if we run cargo check here, it tells us, okay, it expected a str and it found a string. So we're going to just take a reference to this string and it says cannot return value referencing temporary value returns A value referencing data owned by the current function. Okay, so let's dig into what this is actually saying. It's saying you're creating a temporary value here, and you're trying to return a value that references that temporary value. Basically, what it's saying is the str that we're returning is tied to the lifetime of this string. But that's stupid, right? Because we know that strsplit only ever returns substrings of this string. The first argument, the haystack, it never returns references into the second string.
01:01:03.535 - 01:01:48.005, Speaker A: The lifetime of the second string doesn't matter for the purposes of what strsplit returns. But if we look at our definition, we can sort of understand where Rust is coming from here, right? We've said there's only one lifetime. Both of these have that lifetime. And the thing that we return from, the Iterator has that same lifetime. And so when Rust gets what we're saying here, right? When you create a new stir split, it's saying that these two things have the same lifetime. And so when we down here pass two elements that have different lifetimes, right? One has the lifetime that's only the scope of this function, whereas S has whatever the lifetime of this is. Then Russ goes, okay, these two have different lifetimes.
01:01:48.005 - 01:02:35.691, Speaker A: And so in order to make them the same, I'm going to take the longer lifetime and turn it into the shorter lifetime. And so the tick A for this stir split is going to be the lifetime of this scope, right? And so when we try to return a reference to that here, that reference has a lifetime tied to the scope of this function. But what we've said in the function definition, right, if we sort of fill out the alighted lifetimes here, is we've really said that this is the contract we want, but the lifetime that this returns is tied to the scope of this. It's not tick A. It's not. Let's call it tick S because that's what the argument is called. So how can we tell Rust that this is.
01:02:35.691 - 01:03:01.899, Speaker A: Okay, well, what we need to do is we need to have two lifetimes here. Actually, let me see if everyone understands the problem first. Let's see. Should we copy the delimiter into our struct? Okay, so one option is we don't have multiple lifetimes. We just stored the delimiter as a string. So this gets us. In fact, let's.
01:03:01.899 - 01:03:23.065, Speaker A: Let's explore that option first. We might. I sort of don't want to. But let's talk about this without necessarily Exploring it fully. So imagine the delimiter was a string instead of a str. You'll notice that the string does not have a lifetime associated with it. And this gets back to the differences between STR and string.
01:03:23.065 - 01:03:57.189, Speaker A: So a str, a stir is similar to, similar to, but not quite the same as. Let me make this thing similar to, but not quite the same as this. It does not have a size, just like. Just like a slice that's not behind a reference does not have a size. It's just a collection of characters, a sequence of characters. It doesn't know how long that sequence is. It just knows that it is a sequence of characters.
01:03:57.189 - 01:04:47.095, Speaker A: Usually you will see str in the context of reference to a str, just like you would normally see reference to char here. There's all sorts of things we could talk about here. But the basic idea is the reference is this is a fat pointer, not a shallow pointer or not a narrow pointer, I guess. And so the fat pointer stores both the pointer to the start of the string, or in this case the start of the slice and the length of the string or the length of the slice. And so this is just a thing that remembers both where the string starts and how long it is. Just like reference to a slice is the same thing, string is a little bit different. So string is more equivalent to a vec of characters.
01:04:47.095 - 01:05:37.509, Speaker A: So the way there are two ways in which this differs. First of all, a string is heap allocated, right? This reference can point anywhere. It could point to something that's on the stack, something's on the heap, something that's in static memory. It's just a pointer to a sequence of characters. A string though has the property that it is heap allocated and it is dynamically expandable and contractable. It's a heap allocated thing, just like a vector, it can shrink and grow. Now, if you have a string, you can get a reference to a str, right? If I have a string, then I can go to a reference of a str, right? Because the string obviously knows where the string starts and that is the in memory representation of it is a sequence of characters and it knows how long that sequence of characters is.
01:05:37.509 - 01:06:08.965, Speaker A: And so going from a string to a str is trivial. And in fact this is why string implements as ref str, because if you have a string, if you have a reference to a string, you can trivially get a reference to a str. Going the other way is harder. So if you have this and you want to go to a string, you don't know where this reference is pointing. So the only way you can construct a string is by doing a heap allocation and then copying all the characters over. And now you have a string. And so this is cheap and uses as ref.
01:06:08.965 - 01:06:43.367, Speaker A: That's not what I wanted. And this is expensive. It basically uses clone. It's not quite clone, but it has to do memcpy, I guess. So it's true that we could store the delimiter as a string, but this has two downsides. The first of those is that now we require an allocation, right? In order to create a STR split, you have to allocate. This is not great for performance, but it also ties into the second problem, which is now you need to have an allocator.
01:06:43.367 - 01:07:32.713, Speaker A: So this means that once we start using a string, this library can no longer be compatible with embedded devices, for example, which may just not have an allocator and don't have a heap. And so really we'd like to keep this a stir if we can. Let's see, questions about this. Yes. Can you get that character from until car and transform it back to a str? Yeah. So that's basically what this reference in front of the format is doing, right? Format produces a string and then ref takes a reference to that. It's just that the lifetime of the reference we get back is tied to the lifetime of the string.
01:07:32.713 - 01:08:06.565, Speaker A: This might be more visible if we move this out. So if I say delimiter is this, this might be more obvious. This string is going to be deallocated. It's going to go out of scope here. And so when we take a reference to it, the lifetime of that reference is going to be this scope. And the lifetime ofs is tick s. And when the compiler is told these have to have the same lifetime, it's going to use the shorter one and we can't make it longer.
01:08:06.565 - 01:08:35.145, Speaker A: Right, because this is going to be deallocated, memory is going to be gone. And so this reference is just like, not okay, the way we've written this above. All right, so how do we fix this? Well, the solution here is to have multiple lifetimes. And I will say before you start this, usually you do not need multiple lifetimes. There are only some cases where you do. This is one of them. And it took me a while to figure out a case that needed multiple lifetimes.
01:08:35.145 - 01:09:38.755, Speaker A: It is quite rare. The time it comes up is when you need to store multiple references and it is important that they are not the same because you want to return one without tying it to the other. So let's name these lifetimes and say haystack and delimiter. I told you I was going to name them. And now this impl block is going to be a generic over haystack and delimiter, right? And the haystack is going to be haystack generic and the delimiter is going to be delimiter generic. And notice that these now have different lifetimes, so the compiler no longer has to for force these to be the same by downgrading the lifetime down here and now down here, right? We do the same thing. Oops.
01:09:38.755 - 01:10:43.973, Speaker A: Right, and now we have access to another lifetime Here we can say that the reference we give back is tied to only the haystack lifetime. It is not tied to the lifetime of the limiter, right? And notice here that the compiler is totally happy with this, because the code we wrote indeed follows that contract, because any reference that we return from in here is a reference into the haystack. If I change this and said, let's see, I just like made a mistake and somehow returned like self delimiter, now the compiler is going to complain. So there was a question earlier, right, about whether you can use the wrong lifetime. So here the compiler is going to get be very mad at us. It's saying cannot infer an appropriate lifetime due to conflicting requirements. First, the lifetime cannot outlive the lifetime delimiter as defined so that the reference does not outlive the borrowed content.
01:10:43.973 - 01:11:38.929, Speaker A: So this is saying the thing you returned self delimiter has a lifetime of delimiter, but the lifetime must be valid for the lifetime haystack as defined on the impal right up here so that the types are compatible. This error is a little bad. This should ideally be pointing at item, but specifically what it's pointing at here is the. What it should be pointing out here is the self.item up here, right? We promised in our code that the item would have a lifetime of haystack. And so that's what the compiler is pointing out. It's saying you said that the lifetime should be valid for the lifetime haystack, right? It's saying that that contract that guarantee you gave over here, but the thing you returned self delimiter has a lifetime of delimiter and these two are not the same.
01:11:38.929 - 01:12:25.305, Speaker A: And in fact we haven't even given a relationship between the two. So one stupid way, if I actually wanted to write this code, right, is I could say where delimiter is greater than haystack. This is something I'm allowed to write now. I'm saying now the compiler is going to go, okay, you returned something with a lifetime delimiter. You promised you were going to return something with a lifetime of haystack. Normally that was not okay, but here I have a clause saying delimiter is longer than haystack, or sort of phrased differently. Delimiter implements haystack, right? This is the subtyping relationship.
01:12:25.305 - 01:13:26.857, Speaker A: And if delimiter lives for at least as long as haystack, that if I have a reference with lifetime delimiter, it also can be downgraded to the lifetime of haystack, whereas the reverse is not true. Of course, this is not the code I want to write and I don't want that bound there. So I'm going to turn it back to what it was and now the compiler is going to be happy if I now run cargo test. Now it passes and the until car function actually works. And the reason of course is now, even though this string gets deallocated really quickly, that doesn't matter to us. That's totally fine, right? Because the items that are yielded by STRSP as an iterator have a lifetime that's only tied to the first argument that was given to new. Let's see, can you put underscore for the delimiter lifetime to say it's not needed? Yes, you can.
01:13:26.857 - 01:14:00.885, Speaker A: So here, I can do this, right? This block does not care what this lifetime is. We don't need to be able to name it. And so we can use the lifetime elision, basically, or the anonymous lifetime to say any lifetime here will do. It's going to be unique from all the other lifetimes. It's a good catch. And same thing down here actually, for until character here. The compiler can just infer that this must be tied to this lifetime because there are no other lifetimes to attach to.
01:14:00.885 - 01:14:33.167, Speaker A: Now let's say. Let's say that someone writes actually, that's not that important. Okay. Does what we did now make sense? I think so, yeah. So this does do a heap allocation. And that's the next thing we're going to look at. Introduce multiple threads.
01:14:33.167 - 01:15:00.145, Speaker A: I don't see in what way multiple threads are relevant here. Each thread would have its own store split if you ever were to make one. You don't technically need this, I guess, pub. But if you turn on this. So rust 2018 idioms. One of the things that they introduced. Oh, actually, I guess it doesn't.
01:15:00.145 - 01:15:50.061, Speaker A: Yeah. One of the things they introduced was that if you return a lifetime. Oh, they really should require it here too. Fine, fine, you're right, it can be left out here. I like to give it just to indicate that it is auto inferred, but it's not required. All right, so I want to cover one more thing in like the last 15 minutes or so, and that is we do have an allocation here, which is kind of sad. Can we get rid of that? And this is actually going to end up getting rid of the lifetime for delimiter, which is what if instead of the delimiter being a string, we want it to be able to be anything that can find itself in a string.
01:15:50.061 - 01:16:48.005, Speaker A: String is one such example. But it doesn't have to be. So let's say that this is going to be D for delimiter. So now this is generic over D and notice that D is not a lifetime, D is just a type and the delimiter is going to be D. And then here, what are we going to, what are we going to do? What are the requirements on D? Well, the only thing we really need is the ability to figure out basically the bounds of where that delimiter next appears in a string. So we're going to introduce a trait, pub trait, and we're going to do like, let's call it just delimiter. Why not? And the things that a delimiter has to be able to do, at least for the time being, is it has to be able to give us its length so that we can skip past it.
01:16:48.005 - 01:17:31.285, Speaker A: Actually, let's do skip. So it's given a reference to a string and it needs to return a reference to a string. We can even do better. We can say that it's going to be find next, given a self and a string, and what it needs to return is an option with two numbers where it starts and where it ends. That's all we get. So now we know. Let's say here that we want to say that D has to implement delimiter.
01:17:31.285 - 01:18:51.195, Speaker A: So we want to implement iterator for strsp for any D where D implements delimiter. And now we just need to write this in terms of find next. So this is going to be delim start delamend and then this is going to be self delimiter findnext of the remainder. And now we know that until the delimiter is delimstart and after the delimiter as del m end. Okay, that wasn't too bad, right? We just sort of flipped it around and now what we can do is we can implement delimiter for a reference to A string S is a str and it needs to return an option usize this. Okay, so for strings, this is pretty straightforward, right? Finding a string in a string. We already did this and it's essentially just s find self.
01:18:51.195 - 01:19:22.823, Speaker A: And then I guess we're going to map that to start because we also need to return the end that's part of the trait contract. So it's going to be start and it's going to end at self len. So let's see whether this still works. I'm going to cheat a little. Ignore that. Ok, so that still works. It's now generic over whatever the type D is.
01:19:22.823 - 01:19:48.905, Speaker A: And notice that there's no longer delimiter lifetime. And yet we were allowed to give a reference to a str. And the reason is because here we're saying we're generic over any D and that D could be reference, it could be. It could live for whatever time it wants. There's no requirements on D other than it implements delimiter. And now where this gets really neat is we can implement delimiter for other things. We can implement delimiter for character.
01:19:48.905 - 01:20:52.429, Speaker A: And now we want to find. Well, we can sort of cheat here, but what I'm going to do is S.car indices position where C is self start plus 1. Let's see if that. Actually, this doesn't have to be position. I guess this can just be cars. Actually.
01:20:52.429 - 01:21:46.061, Speaker A: No, it can't find. All right, so what this is doing is it's iterating over all the characters of the string, looking for one, that is the character we're searching for. And then when it finds whatever results it finds, if it finds one, we're going to map that sum to take the position and return that position and that position plus one. Right, because the character is only one character long. And now let's see if this works. So instead of now allocating the string, can we just pass the C here? We can. Ok, so now the allocation is gone, and now we can implement this pattern for all sorts of other types.
01:21:46.061 - 01:22:45.065, Speaker A: So anything that can find itself in a string will now just work. And so now we have a generic store split implementation that works for anything that can find itself in a string. All right, questions? Why news use pattern? I'll get to pattern self here in the implementation down here. The self here is a reference to this type. So it's a reference to a reference to a str. This does need to be Len UTF 8. I think you're right.
01:22:45.065 - 01:23:21.745, Speaker A: Is that even a thing? No, I think that's what len will do. I think that's right. Isn't there a simpler way than character indices? There is, but this shows the concept of it. Like, you can do way more efficient things than this. What does Find self. Return? Find self. So find is a method on strings that you can give it a string and it will tell you the start of that string in that string that plus one is wrong and will panic your code.
01:23:21.745 - 01:23:51.975, Speaker A: Is that true? I think you slice by. Oh, it's by byte indices. Yeah. So this is gonna have to be. Is this a thing? It's gonna be bright. For those of you in dark rooms, let's do character. Does character have like a UTF length to it? Yeah.
01:23:51.975 - 01:24:36.723, Speaker A: Okay, so this is gonna be Len UTF 8. So that's the one you were referring to. So that should do it. Great. All right, so some questions here. Can you explain find map? Yeah. So find gives you an option of where the thing is found, an option of the position where it's found.
01:24:36.723 - 01:25:05.041, Speaker A: And the map is, if it's none, then just return none. If it's sum, then I want to change the contents of the sum to be this. Because remember, the trait requires that we give both the start and the end. Why self len and not S len? Because self is the thing we're searching for. It's the length of the delimiter. So in order to find the end of the delimiter, it has to be the start of the delimiter plus the length of the delimiter, not the length of the string we're searching in. The S.
01:25:05.041 - 01:25:40.895, Speaker A: Here is what we're searching in. Okay, great. So now some of you have been observing this that. Why are you doing this? Like, find just works. And why don't you use pattern? So my plan was to keep this a secret, and now I successfully have. So all of the things we implement today exist in the standard library. Trust me, I am aware, even though I don't bring it up.
01:25:40.895 - 01:26:29.489, Speaker A: So if you look at str, you will find the find function. Better yet, you will find the split function. So split on a string takes a reference to self and some pattern p and it returns a split. And if we look at split split implements iterator and it gives you the thing split by that. And you'll notice that split has a lifetime of tick a and the tick A is the lifetime of the string you're searching in. But then it also takes a pattern, a delimiter that implements this trait pattern. And pattern is a trait that it's a little more convoluted than our delimiter trait, but it's basically the same thing.
01:26:29.489 - 01:27:19.203, Speaker A: It gives you a way to look for some. Something in a string. And so really what we've done today is go the whole route through how you get to what's in the standard library today, of how you split a string, but going through it in such a way that we also go through where multiple lifetimes are useful and how to turn these kinds of things into traits and generics. And so you could find actually that all of the tests we wrote today we could just use the standard library instead. We could just do sort of haystack split on space and it would work the same way. Similarly, we could do haystack split on characters, because characters also implement patterns. And so all the things we did today, there's no reason to publish this as a crate because it's already in the standard library.
01:27:19.203 - 01:28:14.595, Speaker A: But hopefully it was a useful exercise in understanding how these different pieces fit together, different types of lifetimes, when you might need multiple lifetimes, how to read some of these lifetime errors, and, and also things like differences between strings and strs and references. Okay, so I think that's getting us close to the end of the 90 minutes, but let's take some questions now that I've revealed the big secret. Let's see here. Why can't you create a string from a strfat pointer? Because you don't own the memory. A string assumes that it owns the underlying memory. It assumes that when it's dropped, it has to free that memory, and it assumes that it can grow or shrink that memory as necessary, which would not be true if you took some arbitrary pointer in length and just decided, that I own this. Now, that's not generally true.
01:28:14.595 - 01:28:50.045, Speaker A: It's true. We should have a Unicode character test. Yeah, so the I was. It's usually obvious that the top level thing is being reimplemented for education, but it's usually not obvious that the deeper things are also done for the same reason. Yeah, so it's a good summary of what I was trying to do here. And some, some people jump the gun in chat, but that's okay. It's good that you observe that this exists in the standard library.
01:28:50.045 - 01:29:28.325, Speaker A: Don't you think the Rust is kind of less readable than other languages? No, I don't think so. I think if you wrote Rust using only the features that existed in those other languages, it's equally readable. But Rust has additional features that require additional syntax. And it's true that when you Use those additional features, your code becomes harder to read, but it also adds additional features. So you couldn't even do the same things in those other languages. The pattern and the haystack seems to the same sharing the same lifetime. Tick A yeah, so pattern in the standard library is a little interesting.
01:29:28.325 - 01:29:58.955, Speaker A: There's a reason why it's nightly only and that is basically because they haven't quite figured out what the design for it should be. The tick A here is the lifetime of the string that the pattern is searching in that gets communicated sort of all the way down the stack. You'll see there's a second trait called searcher which then lets you do basically the same thing we did today. Right. So you see there's a next match and a next reject and all these things get to operate on the tick a reference to the haystack. So you'll see. Actually this is very similar.
01:29:58.955 - 01:30:46.505, Speaker A: It's just more convoluted in order to basically write more efficient implementations. When you see something like type tick X, how do you know what the ticket, what the X is the lifetime of? You don't just like if you see type T, you don't know what type what that type T is. What do you think of rust having a future in the industry? I give a whole talk on this if you look it up on my YouTube channel. It's called considering rust and the last like 10 minutes of it is basically looking at the future of rust and industry. Could you publish this as a gist so we can play with it? Absolutely. I will post this somewhere and then I will actually I can do that. I'll do that after the stream and post it in the description for the video as well.
01:30:46.505 - 01:31:34.245, Speaker A: Can you work with STD in as an input instead of a str? That's harder because STD in is a stream. It's not just a constant. So it's not something you can seek in, for example. So that might be trickier, but you could try. Great. How do you think generic associated types will improve trait definitions? I think it will help a lot. So gat generic associated types will probably not necessarily help with trait definitions.
01:31:34.245 - 01:32:36.035, Speaker A: For that you need existential types more so and a couple of other things. It will help a lot with being able to clone less as one of the big things that will help with. Does it matter that the second us in the find next is the end index and not the length? It could be either, to be honest. It might actually be better for it to be the length and that's something we could modify. Do you intend to do some lecture for newcomers to Rust? I'm not planning to do any complete like beginner streams. I think that that would be a good addition, but it's not something I plan to do. I might do more of these sort of relatively focused videos though, at least if it seems like there's some appetite for them and that people enjoyed this style and so I might do some more similar types of but they will still be more geared towards intermediate than beginner.
01:32:36.035 - 01:33:12.645, Speaker A: All right, I think that's about time for now. If you want to hear about other upcoming videos of the style or of the other videos that I do, check out some of the past recordings on my YouTube channel. And also I am on Twitter John who? And there I will post any and all notifications that are relevant. Sweet. Thank you all for joining me. I hope you learned something. I hope it was possible to follow and I hope that having it be 90 minutes instead of six hours made it more digestible.
01:33:12.645 - 01:33:21.585, Speaker A: Thanks everyone. Stay safe, stay home and I will see you I guess next time there's a video. Bye.
