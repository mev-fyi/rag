00:00:00.840 - 00:00:35.093, Speaker A: Hello everyone. Welcome back. It's been a little while since last time. Hopefully. Hopefully you haven't all been longing for this for so long that you're now desperate for some more. Just before we dive back into where we were first, there was a interview with me on the Co Recursive podcast about my research about Rust, about doing live streams and a bunch of other sort of things related to what I do. So if you want to give that a listen, I highly recommend it.
00:00:35.093 - 00:01:12.549, Speaker A: It was a lot of fun to do. I will also be at rustconf this year later in August. So if you are at rustconf and you enjoy these videos, then feel free to stop by and talk to me. Even if you don't enjoy the videos, you should still feel free to stop by and talk to me. We're going to continue this time with the TCP stream we've been doing for the past two streams. We might not finish all of TCP because it's a pretty large protocol, but I think we'll at least have gone through the interesting design challenges that we had. And I want to make sure that we switch up what topics we talk about.
00:01:12.549 - 00:01:51.015, Speaker A: And so I don't want to do more than three on TCP because this is not going to be a final usable stack in the end, regardless. Of course, if someone wants to take it further, they should feel free to, but I think we're going to switch to another topic after this stream. And when it comes to another stream, you may or may not remember that there's a page that is essentially a way where you can vote for what stream topic we're going to do next. I know that the last time a bunch of people voted, some of these options were not here. And so I recommend that you log into the site. You just go to this URL. I can put it in the chat too.
00:01:51.015 - 00:02:39.465, Speaker A: Give me a second. There we go. I will also put it in the video description. If you're not watching live and here, the idea is that you can vote on what streams you would like to see. You can also put them in order and it will basically run a ranked choice voting algorithm to figure out what people overall prefer. Currently it looks like the next stream we'll do is a second open source contribution stream, which will be really fun, but there are lots of other interesting ideas here that it would be interesting to hear your input on and sort of discuss what it is that you want to see. If you have other ideas that aren't listed here, then feel free to reach out to me on Twitter or email or some other way, and I'll consider adding them into the list.
00:02:39.465 - 00:03:18.383, Speaker A: All right, with that all said, I think it's time to continue with tcp. It's been a while since last time, so let's do a little bit of a recap of where we are, both for your sake and for my sake of sort of where the implementation is at and what we were thinking of doing next. So post a link to the interview too. Yes, I can. I'll put that in the show description as well. Here we go. Twitch chat.
00:03:18.383 - 00:04:07.325, Speaker A: Can't see YouTube chat if that's supposed to work. That is supposed to work. But there is something weird about Restream and ChatSync. I think they're preparing an update, so hopefully that will fix it for next time, but it's something that I sadly can't do much about. Right, so let's recap where we were. We have this rust TCP library that we've been building and if you remember, it basically sets up a sort of artificial network link using tontap drivers in Linux. If you go back and watch the very first stream, you remember that we sort of use this Linux mechanism to give us a way to essentially write our own networking stack on top of just ip.
00:04:07.325 - 00:04:50.631, Speaker A: And we've written essentially, if you look here, we have Source Lib, which implements both the stuff needed to handle packets and send packets. So this is this packet loop business that just handles all the incoming packets and decides how they affect the the underlying TCP streams that we are maintaining. So we have an interface which is just a network interface. You can create a new one that's going to create a new tontap link. You can bind to get a TCP listener, just like a standard. Net TCP listener. And you can also accept to get a new TCP stream.
00:04:50.631 - 00:05:14.363, Speaker A: And when you have a TCP stream, the idea is that you can read and write from that TCP stream. So these are very similar to the standard types you would find in Standard. Net. Currently, of course, we don't support handling actual data. All we do is we open up the connection and then we close the connection again. There's no exchange of data. That's not something we've added.
00:05:14.363 - 00:05:56.905, Speaker A: And so that's going to be the main topic for today is we're going to implement the necessary stuff in order to read and write data over tcp, rather than just handling connection setup and teardown. We also don't have a connect method, I think on interface. So currently all you can do is Set up a server. Ideally, of course, you should be able to connect to a server that's running elsewhere. This would be if you want to make an HTTP connection or something. And so adding a connect method would also be good, I think. So we have this main dot RS which is what uses our library and what we use to test it.
00:05:56.905 - 00:07:07.177, Speaker A: And if you recall from last time, it really just like creates an interface, binds to a port and then accepts a packet, reads basically no data from it, right? So it asserts that it read zero bytes because our connections are always immediately terminated. And so this server, if we try to just run one. So if I run the server, there's now a TCP server running on port 8000 on my machine. And if I run oh, where is my IP adder? Yeah, so my TON interface, this is the one that's generated by our server when we start it is running at local port. This, it's not even true. I guess we'll find out. And if I try to connect to it, you'll see that the server says it got a packet, established a connection, and then in theory it should just be terminating that connection.
00:07:07.177 - 00:07:32.751, Speaker A: So when, when I terminate the input here, say that I'm going to send no more bytes, then the server prints no more data and the connection has been terminated. And I can do this again, I guess. Let's do this. So this echo is essentially saying send no bytes. So N means no new line either. So this is sending an empty string to the server. So the connection should be terminated straight away.
00:07:32.751 - 00:08:17.845, Speaker A: And you'll see that here, indeed the server got another or accepted another connection, established that connection, read no bytes from the connection because we didn't send any bytes, and then terminated the connection. And so in theory we get to keep doing this. And luckily our server does not crash and the interface is, as I showed you, just something that looks very much like what you would use with standard. Net. So the real challenge today is going to be to make read, actually be able to read data that the other side sent and for us to be able to do stream write in order to write data back to the client. Right? So I should be able to do something like echo foo. Actually, let's see what happens if we do this.
00:08:17.845 - 00:09:11.095, Speaker A: So if I run this and I try to echo foo, what happens? Currently it crashes with we assert that data is empty because we don't handle data. And so this assertion is something we're going to have to deal with. And similarly, a similar assertion would fail if we tried to write data on the server side because that's also something we haven't added support for yet. So that's what's going to be our challenge today, is to implement those features. So let's take a look at where that happens. So if you remember, we've split the library into the source lib, which is the thing that runs the main packet loop, the thing that receives packets from the network interface. It parses out things like the port and whatnot and ultimately it calls into TCP connection.
00:09:11.095 - 00:10:24.835, Speaker A: So if we switch to the TCP packet, you'll remember that we have this connection structure that contains all the various things that are defined in the TCP RFC. So remember that we are following RFC 793, which is the TCP RFC and it defines where is it down here? Further, further, further, further, further. Closing a connection. Where is our diagram? Oh, the diagram is further up, isn't it? It defines where are you? Where is the giant TCP state diagram? Should it. Well, so certainly here, here it defines a bunch of variables. So we need to keep for the state, this is things like the sequence numbers for data. We' the latest sequence numbers we've received from the other side so that we can acknowledge the sequence numbers or the packets that they send us.
00:10:24.835 - 00:10:54.509, Speaker A: But there's also this diagram which keeps track of all the possible states that the connection can be in. Right. So initially you started in the closed state. When you decide to listen for connection, you're in the listen state. When you then receive a sin, which is essentially a connection request from someone else, you then go to this state, etc. And all of these states have various things you need to keep track of, such as the current sequence numbers. And so this is why our connection has a state and the state is thing.
00:10:54.509 - 00:11:50.533, Speaker A: Basically all of these states map to these states. We also keep track of the sequence number space of stuff we've sent and stuff we've received and information about the other side. And currently we also have this. This is sort of one of the last things that we added in the last stream, which is incoming bytes and unact bytes, right? So incoming is going to be bytes that we have received from the other side, but that we haven't returned to our caller to like TCP stream, read and enact are things that we have sent to the other side, but the other side has not yet said that they have received it. Right. So the reason we have to keep this around is in case we need to retransmit it. We can't just send bytes out of the wire and Then just forget about them, because it could be that that packet gets dropped.
00:11:50.533 - 00:12:34.875, Speaker A: And this is, of course what TCP is all about, is giving you reliable transmissions. So if a packet gets dropped, you need to resend those bytes so the receiver actually receives them and in the right order. And that's what UNACT is for here. And you'll notice there are a bunch of to dos here. These may or may not be important to us. Yeah, so the send sequence space, what we did last time was essentially abstract out all the states that's needed to keep track of how much you've sent and all the states that's necessary to keep track of all the state you've received. We might want to add some methods to this to make managing these variables easier, but for now I think we can leave it alone.
00:12:34.875 - 00:13:10.275, Speaker A: Connection has a bunch of methods that are. That basically corresponds to outside events. So this would be things like receiving a SIN on the network interface. And you'll see Accept is the thing that gets called when we receive a packet for a connection we have not yet established. Right. So imagine that a TCP stream, or imagine that the network interface is sort of in the listening state on a given port and you receive a packet from a peer that you've never seen before. Then Accept would be the thing that gets called so that you can establish that connection.
00:13:10.275 - 00:14:01.311, Speaker A: So Accept does the TCP handshake and sets up basically all of the initial state that's needed. So, right. I think what is right, right, is just if you want to write a byte out, like you want to write out a TCP packet, right, Takes care of that. It sort of sets up all the IP and TCP headers that you need and then sends out that packet. So we use this to send out things like resets, acks, any kind of packet we want to send to the other side goes to through write. Onpacket is the main event handler. So essentially our, our network interface, whenever it receives a packet, it's going to call this on packet.
00:14:01.311 - 00:14:49.599, Speaker A: So it basically turns into an event loop and it's going to call onpacket on the appropriate connection. So remember, there can be many connections open at any given point in time. So if we remember back to librs, LIBRS keeps track of this map from quad, which is a local IP import and a remote IP import to a connection. Right? So it is going to use the packet headers to determine which connection the packet is for, and then it will call on packet on that connection. And this handles all of the TCP State transitions that we've talked about in past streams. Let's see. Right.
00:14:49.599 - 00:15:13.915, Speaker A: So here, you see is the. The assertion that we failed earlier when the other side has sent us data. Right. So this is. We are in one of these. One of the states where the other side is allowed to send us data, but currently we just require that that data is empty. Whereas in reality, what we should do here is like accept that data and then push it into our.
00:15:13.915 - 00:16:01.475, Speaker A: Or make it available to read calls. Yeah, Right. And also currently we have no mechanism here for dealing with writing out bytes that we want the other end to receive. Right. So that's also something we're going to have to add. So if we go back to our Library, so on TCPStream, we implement Read, which looks up the appropriate connection. So remember, we take this lock to make sure that we only have one thing operating on a connection at a given time, and then we check whether there's data.
00:16:01.475 - 00:16:31.753, Speaker A: This code, in theory supports there being data for us to read. So that's good. Yeah. This basically just looks at the queue of incoming bytes, so bytes that we have received, and then reads out as many bytes as it can. And down here we have the. This is the condition variable that we added last time, so that if there aren't any bytes to read, we have a way to block. Right.
00:16:31.753 - 00:17:10.033, Speaker A: So our. Our code down here, what it's going to have to do is stick bytes into the incoming byte, the incoming byte array. It's a VEC DQ of U8, I think. And then it's also going to have to wake up any readers that are waiting to tell them that there's now data for you to read. Our write currently just adds bytes to enact. But of course it's also going to have to wake up. It's going to have to do something in order to make our packet processing code actually send out that packet.
00:17:10.033 - 00:17:27.233, Speaker A: Right. Just adding bytes to this is not sufficient as we're going to have to figure out a way to do that. Yeah, we're going to have to figure out what to do there too. Not sure how to do that. All right. Oh, and shutdown. We'll need shutdown too.
00:17:27.233 - 00:18:05.855, Speaker A: Okay. I think what we're going to do is we're going to start by implementing read, because I think we have most of the stuff that's necessary to read and it'll sort of get us into the flow of things. And then we'll implement WRITE later because that also requires dealing with wakeups and retransmissions. So let's see where we're at for reads. So for reads, we already have all the stuff that's necessary to get at the. To get at the incoming data array, right? All of this is done. So if there is, if there are bytes to read, then we copy out the bytes that we can read.
00:18:05.855 - 00:19:14.371, Speaker A: If you remember from last time, the double copy here is because we're using a vec dequeue, right? So it has a vec dequeue is like a ring buffer, right? So the bytes that you can read might be in two separate locations in memory. You should go back and watch the previous stream if you don't remember exactly how that worked. But this is us reading out as many bytes as we can into the buffer provided by the user and then basically erasing those from the ring buffer so that that space is available for later packets that we received. And then we return the bytes that we actually read. And if we ended up not reading any bytes specifically, if this is empty, then we block. All right, so the thing we really need to support here is this assertion we need to deal with, right? So this is. There's an established connection and data, where does data come from here? So data here is the body of the TCP packet, which is what's going to contain the data that the other side wanted to send us.
00:19:14.371 - 00:20:34.871, Speaker A: So what do we have to do when this happens? Well, there are a couple of things that have to happen. When we receive data, we need to stick it into incoming, right? So that part is easy. That is just. What was it called? Incoming, incoming, extend data, Right? So that part is easy enough, but now we also need to wake up waiting readers, right? So if someone tried to read in the past, but went into this condition, then we need to wake them up. In addition, we also need to make sure that we ack the bytes that we received, right? So remember, in TCP we always let the other side know that we have received bytes that they sent us, right? So this if here, that is just us saying that if we ever get anything from the other side and we are in the established state, we're immediately going to shut down the connection. Now in reality, of course, we don't really want to do that anymore. We don't want to.
00:20:34.871 - 00:21:11.725, Speaker A: We don't want to shut down the connection immediately because we want to be able to accept data from the other side. So this business we don't want to do anymore. This business is really going to happen only when. Only when the user calls shutdown. So shutdown is a command you can call on TCP streams to say, I have no more data to send. Think of this as like, when you drop the TCP stream, the other side has to know that you did that. But you can also say, I'm done sending you data, but you can still send me data.
00:21:11.725 - 00:22:06.955, Speaker A: And so we're going to have to figure out what to do about this business. But here, clearly, we also need to make sure that we acknowledge to the other side that we indeed received that data. So currently, what we do is when we receive the packet, we sort of check that it's a valid packet and check which of the bytes we should really adopt. In fact, I don't think it's even all of data here, stuff we haven't read. So, for example, I think I need my drawing program here to show what's going on. So let's see. Imagine that.
00:22:06.955 - 00:22:45.727, Speaker A: So we have. This is our machine, this is the remote machine, and there's a channel between us, right? This is the TCP channel. Imagine that in the past we have received bytes 1, 2, and 3, right? Those we've received in the past. And then we get a packet from the other side that contains the bytes 2, 3, and 4. Now, when we receive this, we have to make sure that we recognize that. Where's my. This is the one.
00:22:45.727 - 00:23:15.677, Speaker A: We have to make sure that we recognize that we don't want to read these bytes again because we've already read them over here. Right. Instead, we want to make sure that. That we only adopt this byte. Right? This byte we do actually need to receive and add to our buffer. Right? This needs to go here that I did something stupid and I meant here. So we might actually.
00:23:15.677 - 00:23:36.005, Speaker A: In tcp, we might get a data segment where only parts of the segment contains data that we haven't seen before. So if we just. Currently, what we did was.incoming. extend all of data. But that's not okay. It has to be only the stuff that we haven't read already. So let's look at how we might do that.
00:23:36.005 - 00:24:12.695, Speaker A: Let me see. It's been a while since I looked at this code too. So the received sequence space is the stuff we received from the other side. And let's see. So receive. Next is the. Remember that the sequence numbers are naming bytes in the byte stream, right? So this is essentially.
00:24:12.695 - 00:25:05.341, Speaker A: This is going to be 1 for the first byte, 2 for the second byte, 3 for the third byte, etc. And so we only want to read the bytes from next and onwards, right? So if we go back to the drawing. Yeah. If let's imagine that like this is sequence number 703, this is sequence number 704, etc. Right? Because remember, sequence numbers start at a random offset. Okay, this packet from the other side, we're going to be told that the first byte of this is 704, right? Because two was 704. And our next.
00:25:05.341 - 00:25:57.185, Speaker A: Our next pointer is going to be pointing to here. Our next pointer is going to be 706, right? Because in order for this to be the state of the system, we must have previously received all of these. Right? We previously received all of these. And when we received them, we set next next equal to 706. And that is how we can recognize that here, when we receive this packet, we only want this byte. And so then the question is, how many bytes do we skip off of the packet we receive? Well, this is the sequence number of that packet. And so we have to skip next minus sequence number bytes.
00:25:57.185 - 00:27:29.445, Speaker A: Does that make sense? And my guess is, in fact, remember how the TCP spec at the bottom has this really convenient overview of what do you have to do on all possible events? And so for us, we're going to have the segment arrive state, right? So this is a new packet arrives. So what do you do if it's down here somewhere? We already do all this. You can ignore the reset bit for now, ignore the SYN bit, the ack bit we can ignore. Think we also need to update the windows and then down here somewhere process the segment text. Right, so let's go back to here and see what it is we currently do. So it's actually pretty important to do these actually in order, as we have learned from messing things up in previous streams. So let's see what stage we're at here.
00:27:29.445 - 00:28:02.175, Speaker A: So check the reset bit. Oh, sorry. Even further up, up here. All right, so state is listen, this we've already dealt with. If the state is syncent that apparently we just like ignore. Oh, so SYN sent, we can only be in if we've done a connect, which is not something we've implemented yet. So we can ignore this bit.
00:28:02.175 - 00:28:34.785, Speaker A: Otherwise, first check the sequence number. Okay, so checking the sequence number is what we're doing here. We should arguably label these to keep track of where we are in the protocol spec. So this is implementing all of these checks. Second, you check the reset bit, which I don't think we currently do anywhere. Like we don't handle resets, which is fine. Then check the SYN bit.
00:28:34.785 - 00:29:13.223, Speaker A: So checking the sin bit in theory we should do up here somewhere. Yeah, up here. Okay. So we basically just don't handle the send bit at all currently. So this business we also don't do because getting this as an error and we just basically don't have any error handling currently. Right, like here it's basically saying you send a reset to let the other side know that you weren't expecting that. Check the ACT field though that we do do down here, right? If the ACT bit is off, drop the segment and return.
00:29:13.223 - 00:30:07.235, Speaker A: Okay, so no ack. Great. So we just return if the ack bit is on, which is what happens in the remaining bit down here if we are in SIN received. So if we're in SIN received then we do this business if we are in the established state. Interesting. Yeah, so this is we're still in the business of checking the ack field the ack bit is on because otherwise we returned if we're in the established state or if when we're in fin weight 1 or fin we 2 because they say in addition to. Right, so all of these three are doing this business, right? So that's this.
00:30:07.235 - 00:31:21.755, Speaker A: Any segments on the retransmission queue which are thereby entirely acknowledged are removed, right? So here we're going to end up doing some pruning of self enact, right? Because if the other side sent us acts for bytes that are still in our retransmission buffer, then we can now safely remove them because the other side has said that it's received them. So this is going to be relevant for rights. Users should receive positive acknowledgement for buffers which have been sent and fully acknowledged. That's fine. This is basically telling the when people did a write, you can now say that it's been written. So this would be relevant for things like flush. So like if no if unact empty and waiting flush notify, right? So if the caller has called flush, then at this point if there is nothing in on act, then we can say that the flush is completed.
00:31:21.755 - 00:32:39.465, Speaker A: If the ACK is a duplicate, it can be ignored. Okay, so this I don't think is something we currently do. So I think here we're going to say if sec N is less than self send you and A. Oh, this is probably not actually a less than, is it? I feel like this check is also broken because of wrapping. I think what we want here is actually wrapping less than, right? So if this then we can ignore the ack. Interesting. Yeah, so this is basically more error handling that we can pretty much ignore.
00:32:39.465 - 00:33:24.181, Speaker A: Let's leave that out for now. This is related to updating the send window. So if you remember from the earlier streams, one thing that TCP does is it limits how many bytes you can have outstanding. Like if I've sent 1000 bytes to the other side and the other side hasn't said that it's received them yet, there's a limit to how many more bytes I can send. Like I'm not allowed to have more than a certain number of bytes in transit. Of course, when the other side acknowledges something, then now my window can grow again, as in I'm allowed to send more bytes. And so this is also something we're going to have to deal with.
00:33:24.181 - 00:33:59.264, Speaker A: For writes update window. This is the groove box, dark hard color scheme. Okay, that's fine. And then if we're in fin weight one or fin weight two. So that's the check down here. If we're in fin weight one, if our fin is acknowledged, then our fin has been act. So enter state 2 and continue processing.
00:33:59.264 - 00:34:45.105, Speaker A: If we're in fin weight 2, mention for the processing for established state. Ah, so we don't actually want to adopt the data here quite yet. Right. So this is still handling the ack fin weight. If the retransmission queue is empty, the user's close can be acknowledged. Okay, so here. So that's also not something we really need to worry about.
00:34:45.105 - 00:35:07.328, Speaker A: Close weight. We're supposed to do the same as for established. So this should also include state. Do we even have close weight yet? No, we do not. Great. So there's a bunch of states that we don't currently deal with. I'm just going to ignore those for now.
00:35:07.328 - 00:35:19.884, Speaker A: We ignore the urgent bit. So now we get to process the segment text. And the thing after that is checking the fin bit. Right. So here we check the fin bit. That's the next bit. So here what we want to do is process the segment text.
00:35:19.884 - 00:36:03.205, Speaker A: And so here we're going to bring back this if. Right, because we only handle the segment text if we're in one of these states. The drawing software is called MyPaint. Right. So what do we do? Well, right, so it's just saying that when we're in the state, we're allowed to receive data. Right? Because the connection has actually been established and we can adopt text from the packet into the buffers. Either we can put a limit on how many bytes we allow to buffer, or we can just adopt all of them.
00:36:03.205 - 00:37:07.395, Speaker A: Like read all of the bytes out of the packet. We're just going to ignore push. Once the TCP takes responsibility for the data, it advances receive next over the data Accepted and adjusts the receive window. Right? So bring that. Oops, bring that in here because it'll be handy to have the docs here for our own reference. Right? So here we need to send an acknowledgement of this form as the requirement. And notice this.
00:37:07.395 - 00:38:01.009, Speaker A: So this is something that keeps coming up in TCP that you don't necessarily want to just like send an ack immediately. Because if you're about to send some data, you might as well include the acks, which are just changes to the header with any data that you're already about to send. In our case though, that's not actually something we're going to do next. So this is already, I think, what write does. Let's double check that. So our write function sets. Where is it? TCP sequence number is set to send next and acknowledgement number is sent to receive next.
00:38:01.009 - 00:38:42.183, Speaker A: Right? So send next, receive next and set the ack flag. So all of that is already handled by write. So write will take care of that for us. So if we just call self write, nick this, that will send that acknowledgement that will automatically set the right acknowledgement. We will however, have to do this business, which is updaterecieve next to match the data that we just received. And of course we're going to have to actually adopt the appropriate bytes. So how do we do that? Well, received next is the next byte we're supposed to receive.
00:38:42.183 - 00:39:34.817, Speaker A: So recall that this was going to be what did we say? Self.where is receive.next minus the sequence number. So minus the start of the packet, if I'm reading that right. I think that's right. Maybe as usual might be necessary. We also still have to wake up the waiting readers now from memory.
00:39:34.817 - 00:40:39.995, Speaker A: We already set up a way to do this right? So onpacket returns available to indicate what is now available. So if we go back to lib on where's our call to onpacket, right? So this already has the required mechanisms for waking things up. So really all we have to do is make sure that the returned a the returned availability contains the read flag and then the packet loop, the main event loop is going to make sure to notify the necessary readers. So here self availability and self availability already checks incoming, right? So it will already set the right thing. So we actually don't need to do anything here as long as we extend to this. It is now no longer empty. So when we get to this return, this availability is going to contain the read flag and then the packet loop is going to wake up any waiting readers.
00:40:39.995 - 00:41:20.725, Speaker A: So in theory, this should now already let us do that. And of course, now that we have read those bytes, we now set, let's see self receive next to be equal to the sequence number plus the length of the data. Right. So it now includes any byte. Oh, the received next is now bumped by how many bytes we received. And so here there are a couple of ways to do this. We could either just add the number of bytes that we read, or we can just set it to the appropriate value.
00:41:20.725 - 00:42:05.029, Speaker A: And we're going to do this by saying second plus. Oh, question. Oh, keyboard. This is the Philco Majesto touch ninja. So this is going to be self.it's going to be second wrapping add the length of the data and wrapping add. Keep in mind that here if the if it includes.
00:42:05.029 - 00:42:52.449, Speaker A: So remember that fin and syn are both extra bytes. So if the packet includes a fin byte, then we need to add one. So if tcph fin then one else zero like so expected. U32 found usize. Sounds not right. Let's do a check. How long have you been specializing in networking to know such so much about it? I don't think I've really been specializing in networking, but it has.
00:42:52.449 - 00:43:32.237, Speaker A: It does help that I've written a TCP stack before, although a simplified one like this one. But it's. It really just comes down to learning how the protocol works. The size for values of type U8 cannot be known at compile time. Oh, this has to be a reference 341 as U32. Great. All right.
00:43:32.237 - 00:45:02.581, Speaker A: So in theory, we can now receive data correctly. We do however, want to make sure that the connection is shut down once the other side doesn't have any more stuff to send. Like we basically want to make sure that the other side knows that we're done. So the question is, how do we do that? Well, what does write do? So does write set the fin flag? That's a good question. If you terminate a connection, do you have to keep sending the fin flag? I don't think so. I think what we actually want to do here is we still want up here to. Yeah, so the first.
00:45:02.581 - 00:45:47.987, Speaker A: The moment the connection has been established, we want to set the fin flag and write out the fact that we've set the fin flag. Although do we want to do this? Probably not. This is something we're going to have to deal with later. So this to do that we need to make sure that we resend the fin if the other side doesn't receive it is definitely something we're going to have to deal with, but not something we quite need to deal with yet. But this. These two lines are essentially. We're going to send a shutdown the moment a connection has been established.
00:45:47.987 - 00:46:20.385, Speaker A: Right, Because. Because we don't support write yet, so we might as well do this. We don't support write yet, so immediately send end of file. Of course, ultimately this will not be here, so we'll do this. But in theory, we should now be able to receive data, I think. I guess let's find out. Nope.
00:46:20.385 - 00:47:10.795, Speaker A: If I run this. Actually, no. We also need to modify main. So we're going to do. Buff is going to be something like this. If n is 0, then we break. Otherwise we print out the data that we got.
00:47:10.795 - 00:47:44.845, Speaker A: In fact, we could print this as a string if we really wanted to. Technically, it's binary data, but. Right. So we read into the buffer. If we got no bytes, then that means the other side is hung up. Otherwise we print out the bytes that we got and then we try to read again. All right, so let's try that.
00:47:44.845 - 00:48:46.265, Speaker A: Yes, I did do a master's in networking, although that was in wireless networking, so it wasn't quite this. Although it's just if you end up dealing a lot with networks, TCP is so ingrained in all of the networking stuff that it just becomes sort of second nature to know, at least at a high level, how it works, like how the various bits and transitions work. Like, people study TCP a lot for things like congestion control and how it behaves in various settings, and that I know a lot less about. But I do know sort of how mechanically the protocol works. Okay, so let's try now to echo foo to our server crashed. Question is, why did it crash? Slice index starts at 1 but ends at 0. Oh, I know why this is.
00:48:46.265 - 00:49:41.985, Speaker A: So remember this business. So remember how the sin flag is considered a byte in and of itself, right? So imagine that we received the very first packet from the other side. That packet has, say, the contents foo, but it also has a SYN flag set. So at that point, self received next is going to be zero, Right? Or it's going to be the first sequence number which is prior to the sin. And the sequence number is going to be that same value, although that shouldn't actually matter. Hmm. Slice index starts at one.
00:49:41.985 - 00:50:34.301, Speaker A: Where is this? So this is at on packet. Oh, that's unhelpful. Why do I not get the line number in on packet? Hmm. Reading data from this good old print debugging. Receive next sequence number and data, see what we get when we do this. So this crashed and it says reading data at there. Okay.
00:50:34.301 - 00:51:13.885, Speaker A: So it got an empty sequence of bytes and received next is one. Oh, interesting, interesting. So this would be the sequence number of the packet is this. Don't do that. The sequence number of the packet is this the sequence. The next byte we're going to receive is this one. But if this byte is the.
00:51:13.885 - 00:52:19.637, Speaker A: The sin bit, then this is telling us read one byte from this. Like, skip the first byte in data. But there is no first byte in data because that first byte is the SIN bit, which isn't a part of data. So how are we going to deal with that? Well, I think what we're going to do is if the TCP header has SIN set, I guess we're going to do unread data at, and that's going to be equal to this, and we're going to decrease it by one. And now we can do this. Let's see how that works. Still crashed.
00:52:19.637 - 00:53:06.161, Speaker A: What does it crash with now? Same thing. Huh? From. Hmm. So why is this misbehaving? Let's try that again. All right, so we got reading data from. From index one. Oh, it's the fin.
00:53:06.161 - 00:53:43.697, Speaker A: It's not the. It's not the sin that's throwing us off the sin. Actually, we don't even need to deal with the specialty because we always read to the end of the packet. If there's a sin there, we'll just end the unread data at will start at zero. And that is just correct that what we need to deal with is the case where there's a fin, because that's saying you should read one byte for data, but there isn't actually a byte in data. So instead. Ooh, how do we want to do this? This is.
00:53:43.697 - 00:54:33.725, Speaker A: This is only a problem if the fin byte is the first byte, as in the fin byte is the only byte if the fin byte is at the end. Here, let's draw this again. It's going to be helpful. Let's go over here. All right, so how do I explain this? There's a data stream which has some bytes, make them not very interesting bytes. 1, 2, 3, 4. And then logically, in TCP, there's also this, like, virtual 0th byte, which is the sin.
00:54:33.725 - 00:55:31.467, Speaker A: And there's a virtual last byte, which is the fin. Right. Now imagine that we receive a packet such that this is the sequence number of the packet. And also next, there's also. This is received next. So at that point, and let's say that that packet spans These bytes, okay? So we received this packet and what we're going to end up computing is that next minus seek is zero, right? So we're going to read zero, dot, dot. Now, data starts here, right? Data is going to be this because that first byte is sort of a virtual byte.
00:55:31.467 - 00:56:37.627, Speaker A: But because we are starting from zero, starting from zero is fine, because that's still going to get us all of the bytes. So the SYN is not actually a problem even if we don't do any special casing of the SYN bit. The FIN bit is also not normally a problem because let's imagine now that we get another packet over here that contains these bytes, right? So it contains 3 and 4 and the fin bit is set. And let's say that this is next and also seek, okay? So at this point we would do the same thing. We would say next minus seq, which is zero, okay? So we're going to do zero, dot, dot, and zero, dot dot is going to be from zero of data to the end of data, right? Because data only spans these because fin is virtual. So that's still going to give us the right bytes. Where this is a problem you might have spotted this already is if this is seek and next.
00:56:37.627 - 00:57:28.725, Speaker A: So data is actually empty, right? Data is entirely empty because the fin byte is virtual. So what are we going to do? Well, we're going to do. Sorry. Oh, this would be. If next is here, see actual problem. So next points here because we've already received the fin byte, right? So imagine that this is like the other side resending the fin, right? So our, the sequence number of the packet is the start of the fin, and our next is beyond the fin, because we already received the fin in the past. Well, if this is the case, we're going to compute next minus seek, and that's going to be equal to one.
00:57:28.725 - 00:58:47.245, Speaker A: And so we're going to do one, but data starts at zero, so there is no. Like one is going to point to here, which is outside the bounds of the empty data array. And so this will only happen if we see a retransmission of fin, where FIN is at the start of the packet. So with that in mind, what we really want to do here is if unraid data at is actually. Is this going to. This might be a problem for even if seek is here, the problem is if next is at the end, right? So I think what we actually want here is if unread data at is more than. Ooh, can't actually use more than.
00:58:47.245 - 00:59:55.915, Speaker A: No, we can is greater than or equal to data len. That is the only case in which it's a problem. So here, sort of as a note to ourselves, I think we want to assert that unread data@isdata.len because this can only be the case if must be that we must have received a retransmitted fin that we have already seen. Next points to beyond the fin. But the fin is not in data. So in this case, unread data at should be set to zero.
00:59:55.915 - 01:00:50.333, Speaker A: Let's try that. Still crashed. Where did it crash now? Crashed at this assertion plus one. Yeah. So unread data at is where we should start reading. And that should be after the fin. And the fin is located logically at the end of data, which is data.len
01:00:50.333 - 01:01:26.315, Speaker A: is the start of the fin, plus one is the end of the fin, which is where we would start reading. So this should be true. Now what? Zero. Oh, sorry. Greater than is the problem. They could both be zero, which is fine. Like in the case of sin, for example.
01:01:26.315 - 01:01:47.555, Speaker A: So that's fine. Who. Let's see. No ack got connection read zero bytes of data. No more data. Okay, so clearly something weird happened. Try to.
01:01:47.555 - 01:02:31.871, Speaker A: Well, we'll bring back our friend TCP dump wire. I don't remember what command we used tshark. So we're going to start the server and start tshark. We're going to do this and see what happens. Let's see. So first thing that happened is the connection attempt to the server. The server responds, so the connection attempt is a sin.
01:02:31.871 - 01:03:25.185, Speaker A: The server responds with an ack for the sin and a sin, right? So it acts one, the other side acks. It then sends four bytes of data. We respond saying we're done sending data, right? So this is the point where we like immediately send that. We're not going to send any more data they send us. We're done after five bytes, right? So this is or six, I guess. Syn + four bytes of data + the fin and the ack is two because they acknowledge our fin, then we ack. Then we ack their data, then we ack their fin.
01:03:25.185 - 01:04:19.237, Speaker A: The real question is, so this, this does imply that we're receiving all of their data. So the question becomes why does it say that we read zero bytes of data? That doesn't seem right. So let's here say reading from of and see where those bytes go. Reading from four. Well, that doesn't seem right. So reading from four implies that we're just reading from the end, which is not what we want to do. We want to read from the start.
01:04:19.237 - 01:05:24.295, Speaker A: So this four seems unfortunate because this should really. Whoa. What just happened? In theory, this should be zero. Instead it's saying how many bytes we should read, which implies that we have for some reason already updated Receive next. Is that true though? Ah, we do that there. Why do we do that there? Does the spec say to do that there? Where is this? This is after checking up here somewhere. Not the reset bit, but probably first check the sequence number.
01:05:24.295 - 01:06:27.245, Speaker A: That's fine. I don't think that line should be there. Check the ACK field. None of the sets to update receive next because receive next shouldn't be updated until here. So I don't think that's true specifically. I think this should only happen. Oh, when should this happen? I think this should only happen after we have received that data.
01:06:27.245 - 01:07:30.665, Speaker A: Yeah, this line is definitely not right. Oh, I guess when we receive the sin, we do want to say that we should skip the sin bit. Fourth, check the SIN bit. I don't think that's true. I think this happens further down. I think that it is only at this point where we actually decide to read some data that we're going to add to it. Because now receive next is going to be equal to.
01:07:30.665 - 01:08:44.735, Speaker A: Oh yeah, it's this business. And also of course, if seek, although there is a question here of when we get the initial seek from the server, we need to make sure that we set next to be one. Like I'm thinking of when the connection is first set up, then we get a packet that contains the seek. At that point our next should be one. Yeah, this is not gonna be quite right. We're gonna have to deal with that here too. Unpack.
01:08:44.735 - 01:10:03.634, Speaker A: Ah, so the initial seek packet. I see. If tcph syn then self.receive. next should be equal to the sequen number wrapping add one. This is. So this is got SIN part of initial handshake. So here we want to assert the data is empty because it should be.
01:10:03.634 - 01:10:30.795, Speaker A: The sin should contain no data from memory. Well, it. I don't think that's necessary. Take the SIN bit. If the AC bit is off. See this line makes me think that you can't send bytes in the. In the first packet of the handshake, which is unfortunate.
01:10:30.795 - 01:11:11.485, Speaker A: Right, so let's try that. Although now this is going to be wrong because now receive dot next is going to be. Oh, I see. In the subsequent segment and in the next packet, RECEIVE next is going to be one right immediately after the sin and seek N is going to be one, which is Going to be the first data byte. So that should still be right. And this. Oh, this should be sin.
01:11:11.485 - 01:11:47.335, Speaker A: And we should never get here with synset. So this should still be right. Let's try that. Well, search and fail. Left equals right. Destination and source slices have different lengths. Wait, where did this happen? In TCP Stream read.
01:11:47.335 - 01:12:46.855, Speaker A: Well, that's progress, but why is it not giving me the line number? That's kind of annoying. So this is happening in the implementation of read, so that suggests that it actually got some bytes to read, so that's good. It would be useful to know what line it was on, though, but apparently it doesn't want to do that, so it's one of these that are failing. Interesting. Oh, yeah, this is definitely wrong. So this code is where we are reading. We're reading bytes out of incoming and into buff, right? And we're going to copy.
01:12:46.855 - 01:13:07.595, Speaker A: Yeah, it's not. Definitely not right. And we want to copy stuff into buff. And we're going to have to copy from. Remember. Here, let me draw this again. It's useful for reference.
01:13:07.595 - 01:14:05.395, Speaker A: So we're using a VEC dq, which is a ring buffer. And a ring buffer is essentially just a list, like this vector. It has a head pointer and a tail pointer. And all of the bytes that we have stored are stored between the head and the tail, like so when you read from it, you erase the old head pointer and you stick it to where you're now reading from. When you write to it, you write at the tail and then you get rid of the old tail and you update the tail pointer. Of course, what can happen when you have a ring buffer like this is you can have the head be here and the tail be here. So now you have byte one here and by two here.
01:14:05.395 - 01:15:07.527, Speaker A: And so if we're now going to copy, we can only copy from contiguous memory, Right? So we actually need to do two copies. We need to do one copy from here to here, and we need to do one copy from here to here. If we're copying into buff, which is here, we want to make sure that this bit goes to here and we want to make sure that it's going to be goes to there. And we want to make sure that this bit goes to here. Currently, though, that's not really what the code does. So currently the code decides how many bytes is going to read out from the head, Right? So the head is the from the head to the end of the list or end of the ring buffer, like end, as in rightmost part of memory. And that's going to be either as much data as is in head or as much space as is in buf.
01:15:07.527 - 01:15:43.297, Speaker A: Right? So imagine that the ring buffer has like a thousand bytes in it, but buff is only 20 bytes long. Then we can't copy 1000 bytes into buff. It has to be the min of the two. And so buff is going to copy from slice as many bytes as we allow it to read. And then this is where. Right, and so the question now becomes how much should we read from the. From the tail? Oh, does it require these to be equal? That's silly.
01:15:43.297 - 01:16:42.299, Speaker A: Okay, so this is going to be buff, dot, dot, H read, right? So we're going to copy h read bytes from head into buff, and then we're going to see how many bytes are left. So this is the length of buf minus the number of bytes we read from head, the minimum of that, which is how many bytes we have left to read into buf and how many bytes we can read into buf. And then we're going to copy. Oops, Nope. And this is going to be, I guess H read to H read plus tread is going to copy stuff from the tail. So let's see if that works better. Ooh, read four bytes of data.
01:16:42.299 - 01:17:15.903, Speaker A: Got bytes. Okay, so our main program now actually got some bytes out. That's good. It doesn't look like it terminated the connection, though. So. Remember back when this used to work? Where's that? Much further up, apparently. Why can't I find.
01:17:15.903 - 01:17:36.111, Speaker A: Oh, because it's in this buffer. It used to say no more data. Right. So the server still needs to realize that the connection went away, which is not currently doing. In fact, we can do this here, like this. No more data is no longer printed, even though the client clearly went away. Right.
01:17:36.111 - 01:18:24.175, Speaker A: Like it terminated. So this means that we're now missing the signal that there's no more data to get. Which seems unfortunate, right? There's no more data here. It does get the four bytes, but this suggests that the second time it tries to read, it doesn't get to here. This suggests that isreceive close is not returning true. So why is that? Well, in theory, actually, let's look at what the packets we get are. Let's pull up our trusty tshark again, run this.
01:18:24.175 - 01:19:12.505, Speaker A: So it sends to us fine and we ack that fin. Right. So this suggests that over here we are probably entering this. So now the question becomes why is the reader not like, why does it block? So my guess is it ends up down here in the second call Although we could figure that out. Right. So here, trying to read. Connection has gone away.
01:19:12.505 - 01:20:02.695, Speaker A: And this is connection still active. What? Oh, connection still active. Oh, why does it say that's weird? So it says read some amount of data. Prints this. Oh, it's because I'm stupid, right? We want to keep reading. We don't want to keep accepting. Let's try that.
01:20:02.695 - 01:20:18.735, Speaker A: Great. Connection still active. Red bytes. Don't know why it prints. Got connection again. Oh, that's also because I'm stupid. Let's try that one more time.
01:20:18.735 - 01:20:30.463, Speaker A: Run this, print this. And now we'll see. We got a connection. We're trying to read. Connection is still active. We're at four bytes of data. And this of course, is foo and a new line.
01:20:30.463 - 01:20:48.925, Speaker A: Then it tries to read again and it notices the connection has gone away because the other side hung up. We read zero bytes of data, which indicates end of file. And then we recognize there's no more data. Great. And the other side seems to be totally happy with that. So with this, I think we actually have reads. Right.
01:20:48.925 - 01:21:20.915, Speaker A: Like now, clearly it works to just read. We can try this if we want to be a little bit fancier. Here's what we're going to do. This is going to get real fancy. Let's have this print out what it got from the other side. So this is going to be STR from UTF 8. We're going to unwrap because that's fine.
01:21:20.915 - 01:21:49.205, Speaker A: So this is just interpreting the bytes we get as a. As a string. I kind of want these ignoring weird packet things to go away. I also want these to go away. Ignoring weird packets. All right, let's try this. So let's clear out the screen a little bit.
01:21:49.205 - 01:21:57.793, Speaker A: Now what we're going to do is going to connect. Great. So we're connected. Got zero bytes. I do. Hello. Enter God.
01:21:57.793 - 01:22:20.011, Speaker A: Packet reading. Hello. Great. Okay, so it actually got the string that we sent. Now what happens if we try to send another string like bar, ooh, zubar, Ooh. And then I'm going to terminate the inputs of control. D sends an end of file and indeed it says no more data and the connection has been terminated.
01:22:20.011 - 01:22:37.975, Speaker A: Great. So reads now work even across multiple packets. Yay. Excellent. Of course, here there's no packet loss, so it's kind of hard to. It's hard for us to check whether all the logic is right. But it does mean that, like, we can actually now receive data that's sent over tcp.
01:22:37.975 - 01:23:04.205, Speaker A: In fact, here, let's try something real cool. So curl sends HTTP Requests. Right, like web requests. So let's see what it sends. Let's clear the screen and let's see what Curl does. Well, it does nothing. Could I type the wrong IP address? But let's see.
01:23:04.205 - 01:23:28.197, Speaker A: Boom. Read 80 bytes of data, get/ HTTP host, user agent, accept no more data. And Curl says empty reply. Great. So this now actually works with real TCP clients, right? This is the kernel sending like real HTTP requests to our server. We can't actually respond with anything, but at least we got the data that we wanted. Sweet.
01:23:28.197 - 01:24:06.295, Speaker A: So we now have working reads. Let's go ahead and commit this. Implement reads. Let's do great. All right, so now it's time for writes. And writes are a little bit more problematic because you also have this notion of retransmissions. Because we don't really emulate a faulty link.
01:24:06.295 - 01:24:41.895, Speaker A: We might have an easier time than you otherwise would. And there will almost definitely be bugs in what we implement, but we at least want the basic thing to work. I think what we're going to do is first implement. Do I want to implement shutdown first? Hmm, no. Yes, Maybe. Yes. So remember how we have this like ugly little hack up here? This can probably go away.
01:24:41.895 - 01:25:26.295, Speaker A: Kill that. So we have this ugly little hack where we immediately send essentially a shutdown, right? We send a fin byte to the client immediately because we know that we don't support writes. Well, let's do a little bit better than that. Let's make it so that in main we can do stream shutdown. Net. Ooh, that's a good question. Shutdown this.
01:25:26.295 - 01:26:16.635, Speaker A: Net shutdown, Right? So instead of us doing this internally in the library, we're now going to have this happen externally, right? Like you should be able to shut down the right side of your pipe. So basically saying to the client, I'm not going to send you any bytes. This means that this is going to go away. And this has to be something that the client can actually trigger. Do you implement time wait? Depends how you define implementation. Time wait is here unclear that it does the right thing. Like we don't have any timers yet.
01:26:16.635 - 01:27:07.395, Speaker A: So I'm going to go with no. But the state is represented, right? So this business, which we currently do, immediately, the moment any connection is established, we're instead going to have the client be able to issue this command, basically. So how are we going to do that? Well, fin is a little weird because it's not an actual byte, right? We can't stick at it an act because it's not. It's not A byte. But it is something that we sort of have to retransmit. Now, if we go back to our state diagram up here somewhere. Should have just kept it open.
01:27:07.395 - 01:27:54.855, Speaker A: It's pretty handy to have. There we go. So close is the operation that a client can make when it says it wants to send no more data. So that's when we send our fin. And so what we do know is that if we're ever in a state where. If we're ever in a state like fin weight 1, fin weight 2 or closing. Although can we even be in closing? Yes, it is possible for us to be in closing.
01:27:54.855 - 01:28:12.427, Speaker A: No, I don't know. We. I don't think we implement closing currently. Just probably its own kind of broken. But certainly if we're in. Ooh, that will actually be possible now, which we're going to have to be careful about. But if you're in finweight one or fin weight two, then you know that you've already.
01:28:12.427 - 01:29:20.121, Speaker A: That the client has requested that you close the connection. So the question really becomes down here in shutdown, what do we do? Well, certainly we're going to have to get access to down here. We're going to have to sort of open up the connection, right, get the lock for the connection and then we're going to have to do something on that connection, right, Like C dot finish something. How do you get in line? Compiler complaints in vim oh, this is using Neo Thing Language server, which gives you this. Or you can just use Ale, which is also fantastic. Yeah. So the question becomes what do we really want to do here? Like how do we want the client to signal that they want to shut down? Well, we could have a close function, right, so it's called close in the spec.
01:29:20.121 - 01:30:32.375, Speaker A: So we could just say that there's a close function and then what we want to do with close we can do in here. So the question becomes what do we want to do on close? Well, we certainly want to indicate that the connection should now be closed. We might even want to send another packet. So here, let's add in pubcreate closed Bool. Right, so this closed is really the fin byte, which is this virtual byte at the end of the send stream, right? So down here, I guess, on here on connection, we're going to have. Why do we have two of these? I forget close. What is close going to do? Well, close is going to.
01:30:32.375 - 01:31:03.935, Speaker A: Is certainly going to say self.closed equals true, right? And in fact we can again look at the spec and see what it tells us to do. So when you get a close. No, too far down. Segment arrives. Segment arrives. Status call, abort call, close call.
01:31:03.935 - 01:31:37.055, Speaker A: So if you're in the close wait state. Actually there are more here. If you're closed, like if you're trying to close a connection that doesn't exist, that can't happen to us, right? Because you have a TCP stream item. And so you can't. Like you wouldn't be able to call shutdown in the first place if you're in. Listen, we probably want to deal with this at some point, but let's ignore it for now. That's interesting.
01:31:37.055 - 01:32:18.461, Speaker A: So SIN sent. This is if you try to shut down a connection that has not yet been established. So in that case you can just like ignore the fact that you sent a sin. You don't need to send anything. And when the other side replies, it'll. They'll just get an error SIN received, right? So here the question becomes, what do we do? Well, really this comes down to essentially the established state, which is you queue the fin as if it were a normal bite, right? You queue it as if it were at the end of the send queue. And only when.
01:32:18.461 - 01:33:10.425, Speaker A: Only essentially only when we're allowed to send more bytes and we've reached the end where the fin would be, then do we send a fin segment, right? So let's see here. So remember how there's a window of where we're allowed to transmit? Let's go down here somewhere. So imagine that these are the bytes we're trying to send 1, 2, 3. And then logically we also want to send here, right? So when CLOSE is called, we're going to add a fin to the end here. But imagine that the other side only lets us send one byte at a time, or let's say two bytes at a time. So we send these two. So even the close has been called.
01:33:10.425 - 01:33:45.545, Speaker A: We can't send the fin yet because we're only allowed to have. This is the window, right? Only allowed to have two bytes outstanding. Now when the other side acts this byte, for example, let's say that this byte is act. Well, at that point our window extends to these two. So at this point we can, like this byte we can now ignore. This has already been received, right? And we can now send 2 and 3, but we still can't send the fin. Then at some point it's going to act two.
01:33:45.545 - 01:34:45.545, Speaker A: And now the window is three and FIN and two can be ignored. And so now we can send three, although we've already sent three because it was already in the previous window, but only at this point are we allowed to send the fin because it's within the window. So even though close was called much earlier, we can't send the fin until we're allowed to. Is that the reason you're trying to make TCP module development for Rust even though already have it on CC to be more secure? No. So the reason we're implementing TCP and Rust is just because it's an interesting use case in writing low level code. It's not actually like the intention is not for this to be like a production ready TCP stack. It is more because it's interesting to develop but.
01:34:45.545 - 01:35:30.135, Speaker A: But hopefully this makes sense, right? So we're only allowed to keep a certain amount of bytes in transit to the other side. So even though we want to send a fin, we might not be able to do so yet. This is also why we have this. The I don't have it open, but the unaction byte list is like basically bytes like these, right? So when we're only allowed to send one and two, blah. But the client like TCP stream has already written three. We need to keep this around somewhere, right? Until the time when the window extends to here and we're allowed to send. Right? And so that is an act and the fin is sort of logically in that same unact, but it's not a real byte.
01:35:30.135 - 01:36:29.475, Speaker A: So the question becomes what do we want to do on close? Well, we sort of want to send stuff if we can. Of course the problem is this, what we've introduced here is this notion of time that we didn't really have before. We might not be allowed to send anything yet. So we need there to be a timer running that like decides that hey, now is probably a good time to send something. Like we can't just do self right here, right? I would not be okay, so instead what are we going to do? Well, we can just. We can imagine that there's just like always a timer running and so we're going to set self close to true and then we're going to wake that sort of timer up to let it know that there are bytes to write out. That would be one way to deal with this.
01:36:29.475 - 01:37:33.005, Speaker A: How do we want to do that though? It's a good question. So at this point we have to decide what our timers are going to look like, right? So with this notion of time, it sort of means that there always has to be. There has to be something that deals with time and that schedules when we're going to send stuff or resend stuff. But where do we want that timer to be? The problem we have is that this timer also needs to access the connection state. So it needs to take the lock on the connection. So you can't like do a write while the timer is also writing stuff out. As an example, the easiest way to do this is probably to have the packet loop.
01:37:33.005 - 01:38:04.821, Speaker A: So we have this like on packet loop. Right. So the packet loop just spins trying to receive things from the nick ideally. So this is a to do we have from earlier. Right. Is we want this received time have a timeout so that we can like block on receiving a packet or a timer expiring from memory. When we looked at this, there wasn't actually a way to set a timeout on receive here.
01:38:04.821 - 01:38:45.825, Speaker A: So this receive is just going to block forever, which means we can't do the timer management in the packet loop. We actually need to have a separate thread that manages timers. So let's do that. Where is it? We. Let's see, what does interface new do? Interface new spawns a thread that does the packet loop. And I think we're going to need a timer handle. Timer loop.
01:38:45.825 - 01:39:31.355, Speaker A: And I need a thread handle here for interface. So this is going to be the timer handle. All right. So. Oh, actually that's going to be a problem that's not going to work. The timer loop needs to also have access to the interface because it needs to be able to send packets. Huh.
01:39:31.355 - 01:40:23.029, Speaker A: I don't know how we're doing this. So let me try to explain what the problem is. When we open a tontop interface, we only get one handle to it, and that is the handle we need to use whenever we receive packets. But it's also the handle we need to use whenever we write packets out to the network. And the timer thread sort of also needs to have this because the timer thread could totally decide that it needs to send a packet. But the packet loop is the thing that owns that interface. Right.
01:40:23.029 - 01:40:54.589, Speaker A: And in fact, it's blocking on it. Right. The main loop is going to use nick.receive and it's going to be blocking on receive. So it is using that interface. And we can't have the timer, the timer thread also try to use this at the same time, at least not safely, probably. So the question is, how do we set a timeout for that? Well, I guess we're going to look at tontap, see what we get.
01:40:54.589 - 01:41:43.475, Speaker A: Oh, ton interface. So there's receive here. And let's look at what receive does. Receive. So receive just as a Read on the underlying file descriptor. And what is the underlying file descriptor? In fact, the real question is, can I get the underlying file descriptor? Yes, indeed I can. So a file descriptor, if you're not sort of well versed in Linux and Unix, file descriptor semantics.
01:41:43.475 - 01:42:18.285, Speaker A: Basically everything that you can interact with, like files, network sockets, pipes, have this notion of a file descriptor. So this is a number that the program keeps track of that is mapped to the file, the network socket or whatnot in the kernel. So whenever you do a read or a write, you're really just doing a read. You send a read system call to the kernel, you tell it, I want to read from this file descriptor. And you just give it a number. And then internally the kernel translates that to, oh, that is this TCP socket. A tontap interface apparently is the same thing.
01:42:18.285 - 01:42:34.945, Speaker A: It's underlying. It's just a raw file descriptor. And we can in fact extract that raw file descriptor. And if we want. If we look at. Here, let's look at. Look at the Rust source code, because that's fun.
01:42:34.945 - 01:43:39.883, Speaker A: Oh, why is my Internet slow? That's somewhat disturbing. Really? Why? Okay, that was weird. All right, let's look here. LIB might be. No, it should be LIB standard CIS UNIX NET timeout. Let me find here. So these are operations you can.
01:43:39.883 - 01:44:12.455, Speaker A: This is sort of how Rust implements various operations on sockets, like TCP Stream, for example. So there's a. There should be a read set timeout, right? So there's a set timeout function that basically when you call things like receive timeout on. In fact, I can show you. Let's look at TCP Stream. So TCP Stream has a. Where is it? Oh, man, I want this.
01:44:12.455 - 01:44:39.895, Speaker A: You can do set read timeout and set write timeout on TCP streams. This is the same for any kind of file operation. And you'll see that self zero. What is zero here? TCP Stream is really a netimple. No. Well, it's going to be the same for TCPStream. It's a net imp, which is the implementation of TCP for this platform.
01:44:39.895 - 01:45:44.155, Speaker A: And ultimately this ends up calling the settimeout function for the given operating system. So on Unix, this is basically what that does. It parses the duration into an appropriate structure that the kernel expects, and then it does a UNIX system call to set options, set a timeout on that socket. And so the question is, how can we do this? A similar operation like what is the system Call we need to make giving the file descriptor of the tontop interface so that we end up setting a timeout for it. Well, that is a good question. Let's go here and do man read. No man to read system call.
01:45:44.155 - 01:46:17.205, Speaker A: Right. Because remember looking at the source for this, we saw that receive is really just calling read on the underlying file descriptor. Right. Where was the fd? Oh, FD is in fact a file. That's even better. Is there a way for me to get at the file? Right, so. So if FD is actually just a file, all we need to do is figure out how.
01:46:17.205 - 01:46:59.905, Speaker A: How Rust sets a timeout when it does reads on files. So instead of looking at TCP stream, we'll look at file. Oh, I don't know if there's a timeout for file. Actually this might be the problem we run into. Yeah, this probably doesn't have a read timeout. Let's see what read here does. Oh, that is a very good question on whether it's possible to set a timeout for READ on Linux.
01:46:59.905 - 01:47:53.837, Speaker A: It should be. It's probably an ioctl to be honest, but documentation for those are terrible. Linux set timeout read I guess I could select over it. I was hoping that was a nicer way. That's awkward. Okay, that's fine. We don't actually need this to be a high performance version.
01:47:53.837 - 01:48:43.575, Speaker A: So what we're going to do is use Nixon. Nix is a great. A great crate that wraps various like low level kernel features. In particular, what we want to use here is the. I guess it would be under sys probably select this one. So select is a system call on Linux that lets you. Essentially it notifies you when a given file descriptor is ready to do an operation on it does not actually do the operation, but what you can do is give in.
01:48:43.575 - 01:49:33.315, Speaker A: In this case, like a file descriptor that you want to read from and it will return when you can, when you're. When you would be able to read from it without blocking. But it also lets you give a timeout. So this is saying let me know when I can read from this or when this timeout has expired. I was sort of hoping there was a nicer way to wrap this, but it doesn't really look like it. So that is what we will end up doing. So Cargo Toml let's add in here nix013 and here we're going to have to issue this call.
01:49:33.315 - 01:50:23.175, Speaker A: We want to read from Nick, but we want to not block. But we want to make sure that we'll wake up when the next timer has to be triggered. Yeah, it's very similar to selecting over channels where one of the channels is a timer channel. There are many ways to do this. So E Poll is the other way that you often use on Linux. On macOS I think you would end up using kqs. Select is not what you want to use in very performance sensitive cases because it has some issues.
01:50:23.175 - 01:50:53.277, Speaker A: It also has the downside that we're now going to end up doing two system calls. Right. We do one for the select and then we have to do the receive. But we're just going to ignore that for now. So what does select take? N file descriptors, the highest file descriptor set. Oh man, this is awful. I don't want to use it, but I think we may have to actually.
01:50:53.277 - 01:51:22.767, Speaker A: Is there a nicer one that I can easily use? Probably not. Ooh, maybe Pole. Oh yes, great. Let's just use poll instead. Great. Even better. Because we don't actually care which of the.
01:51:22.767 - 01:52:03.645, Speaker A: So when you're implementing like Heavy duty Network IO for example, you probably really care whether you use select or Poll or E Pole or KQS or any of these mechanisms. In our case, we don't actually care because it's not super performance critical. But we do. We just want whatever has the easiest interface to use. And so poll is going to take all the poll fds. What does POL do? Oh, that's fine. Don't care about that.
01:52:03.645 - 01:52:32.495, Speaker A: Timeout is the number of milliseconds that poll should block. That's another good question. Whether milliseconds is good enough. But we'll see. So POL fd. All right. How do I make one of these? Great.
01:52:32.495 - 01:52:53.279, Speaker A: So we're going to say PFD is going to be mix POL POL fd. New. Right. And we're going to give. We need to give a raw fd, which we can get from Nick as raw fd. Right. And we also give it.
01:52:53.279 - 01:53:21.955, Speaker A: Need to give it event flags, which is probably just. Yeah, we want. Is there data to read? Right. So we want next poll event flags pull in. That gives us a poll fd. Now that we have a poll fd, we can pass that to poll. So this gives us a poll fd.
01:53:21.955 - 01:54:08.715, Speaker A: And now we want to call that on, I guess this. And we want to give a timeout. And what is that timeout going to be? Well, in theory it'll be whatever the next timer is. I think what we're going to do here is we're going to do something a little bit stupid instead of trying to cleverly manage timers. There are lots of ways to like manage a set of timers and wake up when the next one is due to expire. But instead what we're going to do here, it's a little stupid, but we're going to do the stupid thing is we're just going to wake up every. We're going to wake up every millisecond and then decide what to do.
01:54:08.715 - 01:54:53.445, Speaker A: This could totally be more clever, but we're just not going to be clever. And as you see this, the call to poll will block either until the file descriptor becomes ready. So this would be that we're allowed to read or there's a single signal handler is being called. We can ignore that for now or until the timeout expires. And of course there's also you can give timeout of zero and the timeout of zero makes it so that it's going to return immediately and basically tell you whether or not you would be able to read. Okay, so we're going to wait for only one millisecond. It's going to return a mix result.
01:54:53.445 - 01:55:56.807, Speaker A: It's kind of awkward and I think that's awkward. Remember that this function is supposed to return an IO result. What Paul gives us back is not an IO result, it's a nix result. And I don't think this implements into IO error. So what we're going to do is do map error E. We're going to do. Okay, what can I do with an error? No, can I turn it into an IO error? Let's see.
01:55:56.807 - 01:56:43.051, Speaker A: That's all I really want to know. That's unhelpful. Implement from erroneous for IO error. Great. So in theory I should be able to do E do what was it called as error no unwrap. We don't expect there to be any other type of nix errors. And then we're going to question mark.
01:56:43.051 - 01:57:23.447, Speaker A: So as error no unwrap is going to give us a nix error. No one of these that implements into IO error. And so therefore we can use question mark. So that I think should work fine. Great. And now depending on what the return value of this is, so poll the function will return as soon as any event occurs. All right, so the question is, what is this return value should really be documented here.
01:57:23.447 - 01:58:11.285, Speaker A: Maybe we should submit a pull request. But for now, what does pull return? Oh, the field revents is an output parameter. So what do we get back? Oh, it's going to Modify the polfd. I see. So this is going to be really this and we're going to give in this. It's going to be some N there and I don't exactly know what the n is. The N is.
01:58:11.285 - 01:58:55.727, Speaker A: Okay, that's fine. So what are the return values on success? A positive number is returned. This is the number of structures which have non zero revents fields. A value of 0 indicates the call timed out and no file descriptors were ready. Great. So here, if N is zero timeout or I guess timed out, do something with timers. I guess we should assert that N is not equal to minus one.
01:58:55.727 - 01:59:53.237, Speaker A: That shouldn't be possible, Right? Minus one would be an error which should already be handled by Nick's. If N is 0 something timed out currently we're just going to have that do A continue, which means that if we get down here, that means that the file descriptor is now ready and so therefore we can do this. Right. So pol F D. Essentially what this means is when the poll returns, if n is 1, that means that this pol fd changed, which basically implies that this event happened. We could double check that by checking the the events that happened for the file descriptor, which in in theory should return a thing saying that yeah, you can now read. But here, because we know that the only way that we can get to here is if it is now pollable.
01:59:53.237 - 02:00:25.485, Speaker A: We don't really need to is readable like there's data available that that basically means that we don't have to make this check at all because there's only one possible way you could get here with N. I guess we could assert N1. We could also assert that Poland is set. We're just going to ignore it. Great. So if I do like timers, if I do this. That's not what I meant to do.
02:00:25.485 - 02:01:06.961, Speaker A: If I do this, what happened? Ooh, why is it fetching the oh, because next you don't have to set non blocking on the fd. No, you don't. So this is one of the reasons why poll is nice is because you just tell it I want to read from this file descriptor and let me know if it's not available for reading. So keep in mind that poll is not I'm pulling this file descriptor. It's not like do a read. It is tell me when I can read, which is a little different. Cannot find the value of PDF.
02:01:06.961 - 02:02:01.325, Speaker A: That is because it is pfd. Ah, pfd. Somehow PFD is a lot harder to type than PDF and of course we need to assume that we're on UNIX so that we can use as raw FD Right. This. So this really just set Close equals true. Right? Close equals true. And in theory it should also re examine some timers to do.
02:02:01.325 - 02:02:55.729, Speaker A: But we don't actually need to deal with that at all currently because the timers should just take care of that, which means we don't need this function anymore. And shutdown can return okay immediately. And now this needs to include closed as false. Yeah. So now you see they're just like timers firing so often, which implies that our thing is actually working. If we want to make sure that the other stuff is still working, we can just not do the not print timers and then check that this command in fact still works. Which it does.
02:02:55.729 - 02:03:41.095, Speaker A: Right. So this is implying that this is all working the way it is because we now have a sort of an entry point for where we can do stuff with timers. And so what are we actually going to do? Well, there are a couple of things we could do really what we want to do here is when a timer expires then like do what the timer tells us should happen when it expired. Instead what we're going to do is something a little bit stupid and you're probably going to dislike me for doing this, but we're going to do it anyway. We are going to do. Where's my. Yeah, here.
02:03:41.095 - 02:04:50.975, Speaker A: Bear with me because you're all gonna hate me for. So we're just going to loop over all of the connections and we're going to call this ontick method. And ontick is going to get to decide basically whether it wants to do something. And so the idea here is that the, the. The connections are going to keep track of their own. Like when stuff has to happen they can just check that in on tick and they only really need to keep track internally of when they want something to happen. We'll see how we end up using that.
02:04:50.975 - 02:05:38.027, Speaker A: So if we now go to TCP we now we have on packet and now we will also have I guess here we can now finally given this I guess where is my onpacket. Yep, it will get these. Yeah, that's not what I meant to do. Onpacket. So. So this is going to be on tick and. Oh, you are right.
02:05:38.027 - 02:06:32.537, Speaker A: This will also check for availability. Huh. Do we really need to. Oh, we do, don't we? We have to drop the lock before we not. Okay, so like this is going to return an availability. So now it for example if tick means that we got to send some, that can never happen. Great.
02:06:32.537 - 02:07:24.635, Speaker A: So the availability cannot change because of this. I think to do don't die on errors. If, I guess if one connection terminates, it doesn't because of what happens in ontick. We might not want to just exit, but I'm not sure. So the question is, what are we doing on Tick? Well, what we really want to do is we want to retransmit. If there's something to retransmit, we want to send new data, if there is new data to send. Of course, you could also imagine that we want to do this proactively, right? Like if we see that we have data that we're allowed to send, we can just send it.
02:07:24.635 - 02:08:31.615, Speaker A: What this means is when you close the connection, you might as well just call ontick and you'll see why in a second. So what ontick is going to do is it is going to decide if it needs to send something, it's going to send it. Basically all we have to do, like the most of what the timers are is that. And in fact, if we look at the rfc, all right, we're also supposed to enter fin weight. We also need to figure out what to do about this, but that's a separate issue. If fin. Enter fin.
02:08:31.615 - 02:09:03.465, Speaker A: Wait. But that's a question for later. But there should be. I think there's a timeout. Is that what they call it? User timeout? No, that's not what I want. I think there's another timeout that's the wrong kind of timeout. User timeout.
02:09:03.465 - 02:09:18.665, Speaker A: Segment arrives. Segment arrives. Segment arrives. Segment arrives. Status call. Abort call. Close call.
02:09:18.665 - 02:09:46.545, Speaker A: Receive call. Send call. Yeah. So this is. What do you do when you're asked to write data? That's fine. Open. That's fine.
02:09:46.545 - 02:10:15.183, Speaker A: Event processing. I specifically want retransmission timeout. Those are really the only timeouts that matter to us. Yeah. Okay. So in Ontick, what we're going to do is see whether we're allowed to send stuff. And if we are, then we should send it.
02:10:15.183 - 02:10:55.335, Speaker A: If we're not allowed to send stuff, then we should check whether there's more stuff, whether there's stuff that needs to be retransmitted. So here, what we'll do is keep track of when we last sent data. So this is going to be last send, or I guess last. Let's do last sent. Last sent is good. And that's going to be a. Do we have time imported here? So last send is going to be an instant.
02:10:55.335 - 02:12:01.863, Speaker A: How do you set up unit test for this project? So unit test for this project shouldn't actually be that hard because you can just. You could imagine that you just set up the R U R TCP stack as the server and then use a standard. NET TCP client and see that they can talk to each other, and then you do the same in the reverse. The biggest problem here is that in order to start a server or client, you need to spin up a tontap, which requires a particular capability or root access. And you don't really want to run your unit tests as root. So the other way to do this would be to test just the TCP stack, so not actually use tontap and basically make our library be generic over the underlying transport so that it doesn't have to be a tontap. Like you could.
02:12:01.863 - 02:12:22.503, Speaker A: You could basically test unit test this by just unit testing connection and constructing the packets. Right. So that would be the unit testing. You would write. The integration testing is a little bit harder just because of permissions. The title just says Rust Livestream. Yeah, it's pretty unfortunate.
02:12:22.503 - 02:12:56.425, Speaker A: YouTube. It's really annoying to be changing the YouTube title. When I. When I upload the video later, it will have a more descriptive title. Okay, so we're going to have a last send, which is going to be time instant. Now, the chat bot is partially broken in the sense that I think people from Twitch can't see comments from YouTube and people from YouTube. I don't know whether you can see comments from Twitch.
02:12:56.425 - 02:13:45.205, Speaker A: I can see comments from both. So at least there's that. This was a problem last time, too, and I don't know. I don't know what's causing it, but I did see that I'm using Restream IO so I can stream to multiple places. And apparently they're planning like a giant redo of their chatbot, so hopefully that will fix some of these issues. Okay, so what do we want to do here? Well, we want to make sure that we need to start actually maintaining our window, because that's what determines whether or not we're allowed to send something. And in addition, we need to make sure that the sin and the fin are also included in.
02:13:45.205 - 02:15:04.795, Speaker A: Included in retransmissions. Right. So we might need to resend our sin. Now, maybe we just ignore that just because it's easier and it's not all that interesting. But certainly for data packets, we may need to retransmit them and we certainly will have to wait for the. For the window to grow. All right, so where is if self TCP thin why does it have to do that? Payload bytes unwritten write so this is probably wrong because this is going to update send next which means it won't work for retransmission.
02:15:04.795 - 02:16:26.745, Speaker A: So that's something worth keeping in mind and we're going to have to figure out fins and such. But for the time being let's first just deal with what happens in ontick and we can deal with the other stuff later. So where's our send? So basically to decide whether or not we're allowed to send stuff, we basically have to see that there's space in the window. Where is the send? Do they actually document this test? I don't think so. That's the interface managing the window. Right. So currently we don't manage our window size at all, which is probably fine for the time being.
02:16:26.745 - 02:17:25.134, Speaker A: This we will certainly have to update and here I think this, the other RFC we had gave a better estimation for how you compute this. I think the first thing we're going to do is where's the appear somewhere Actually let's go to the top and look for. For data communication center of data keeps track of the next sequence number to use in the variable send dot next the receiver of data keeps track of the next sequence number to expect and there will receive dot next. The center of the data keeps track of the oldest unacknowledged sequence number in the variable send an A. Right. So this is. So we have this like unacknowledged bytes vec dq right.
02:17:25.134 - 02:18:59.888, Speaker A: Una is going to be the sequence number of the first byte in that and send dot next is going to be the next the bytes we are going to send next, if any. Yeah, great. Where's the part about the window though? That's fine, that's fine. So we'll have to send empty packets every now and again just to make sure to keep alive the connection to guarantee that when either TCP has a zero window, the reopening of the window will reliably be reported. Yep, it's fine. Like certainly setting the window size and managing the windows is pretty tricky here. Things that we've already sent are self.send.net
02:18:59.888 - 02:20:23.249, Speaker A: I guess so data that we have not even sent once yet is all the stuff that is in an act and that is at or beyond send next. Right. So let's draw this again because it'll be easier down here. Let's do this color so our unacked buffer logically I guess let's label these because it's helpful. 4, 5 6, 7. So this, and when I draw the arrow here, I mean this element, this byte, the sequence number of this byte is sender.next. sorry.
02:20:23.249 - 02:21:04.175, Speaker A: No, that's false. The one thing that's annoying about this tool is erasing. Stop erasing. This is una, right? So unact. The first unact sequence number is this one. The moment that something is act, we're going to remove it from the beginning of this array so that this invariant always remains true. Somewhere in here we're going to have a pointer for next, right? And next is the next bytes we are allowed to send.
02:21:04.175 - 02:21:44.695, Speaker A: Sorry, the not allowed to send next is the next byte we want to send. So the next byte that we haven't sent previously. Now there's also going to be something like this is going to be the send window. I think we should double check this, but I think it's the sender window. It could be the receiver window, actually not important. No, I think it's the sender window. So this is how many bytes were allowed to have outstanding.
02:21:44.695 - 02:24:09.445, Speaker A: When ontick is called, this is basically the variables it's allowed to look at, right? In this case, it should observe that currently we are allowed to send these bytes, right? We're allowed to send these bytes because that would still keep us within the window. So if we do send these bytes, then the unacknowledged by distilled one and now send dot next is going to be here instead of here. And at this point we can't send seven because seven is still outside the window. At some point, if we get in, if we get ack is equal to, let's say an act plus two, then now this is going to be unacked, these are going to be deleted, right? The window now allows us to send two more things and so now we're allowed to send this. And so we're going to put send next here and send those, right? So there's like a sliding window of what data we're allowed to send. So here, how are we going to do this? Well, unsent is actually number of bytes sent is self send dot next wrapping sub self send dot unacknowledged. Is that true? Yes, that should be true.
02:24:09.445 - 02:24:54.593, Speaker A: So this is the number of bytes that we have sent but that have not been acknowledged. Unsent is self.anact. len minus an act. Right? So these are bytes that we have not sent yet. I guess as us, these are the number of bytes we have not sent yet. At this point we sort of have an option to decide what we want to do. And it's going to depend on whether we're allowed to retransmit yet.
02:24:54.593 - 02:25:37.949, Speaker A: If we're not supposed to retransmit, then. So here, let's see. Self.Last Send. Elapsed. I'm trying to remember what retrans 2 minutes is recommended for the retransmission interval when the window is zero. I want to see where they recommend how to set retransmission.
02:25:37.949 - 02:26:23.875, Speaker A: So, send window. Yeah. Okay, so it is the send window. The sequence numbers which the remote is willing to receive. The range of new sequence numbers which may be emitted by TCP lies between send dot next and send unacknowledged, plus the window minus one. Yeah, great. So this is the same that I showed in the drawing on the other one.
02:26:23.875 - 02:27:14.603, Speaker A: When the TCP transmits a segment containing data, it puts a copy on the retransmission queue and starts a timer. When the acknowledgement for that data is received, the segment is deleted from the queue. If the acknowledgement is not received before the timer runs out, the segment is retransmitted. The question is, what is the retransmission timer? What should it be set to? Duplicate detection. Retransmissions. It's fine. So TCP also technically says that you should keep track of retransmissions times per packet you've sent rather than per byte.
02:27:14.603 - 02:27:54.241, Speaker A: It's like if I send 5 bytes and then 5 more bytes if the retransmission timer expires. For the first five bytes, I should just resend those. I shouldn't resend 10, even though potentially I can. So this is also something we may have to keep track of transmitted. But what is the timeout? Here we go. Retransmission timeout. Because of the variability of the networks that compose an Internet network system and the wide range of uses of TCP connection, the retransmission timeout must be dynamically determined.
02:27:54.241 - 02:28:46.475, Speaker A: One procedure for determining a retransmission time out for determining a retransmission timeout is given here as an illustration. There is probably a better way to compute this. I'm pretty sure I've seen this, in fact. Measure the elapsed time between sending a data octet with a particular sequence number and receiving an acknowledgement that covers that sequence number. The measured elapsed time is the round trip time. I see. So the recommendation here is basically estimate what the RTT is, the round trip time is, and then keep sort of a moving average of the estimated round trip time, and then the round trip time is going to Be some multiple of that rtt.
02:28:46.475 - 02:29:48.575, Speaker A: Okay so they want that to be SRT we're going to figure out. So this means that we need to keep track of when we sent each byte and when that byte was act. It's basically what they're telling us to do. We probably don't want to keep track of every single byte, but instead every like every time we, every, basically every time we send something, we should keep track of the sequence number and when we sent it so that we can update the timeout appropriately. So let's go up. This means that we're going to have to keep a little bit more data here specifically on the connection. On the connection.
02:29:48.575 - 02:30:40.639, Speaker A: Let's start another timers. A timer struct structure timers. It's gonna have a last send. It's gonna have a. Huh. It's gonna have something like sends or send times which is gonna be, let's say a vec d a particular sequence number and a particular and when that sequence number was sent. Right.
02:30:40.639 - 02:33:00.871, Speaker A: So every time we send a sequence number we stick it into send times and when it gets act then we take the difference between, we take the difference between when we sent it and the current time and that is an estimate of the RTT and then we do SRTT is a time duration. Great. So this is going to be timers which is going to be a new timers with last sent equal to that with send times is a empty one of these and where SRTT is time duration from minutes to oh, what is it then From I guess 6 to 60 if self last send dot elapsed is more than and what did we want this to be? The retransmission timeout is ubound is an upper bound on the timeout for example one minute. Okay so not two minutes, one minute. There's more than oh, I see. They want a lower bound and an upper bound. So this is weighted for.
02:33:00.871 - 02:34:40.587, Speaker A: Is this if weighted for is greater than 1 second and weighted 4 is less than self timers the smoothed RTT times beta I guess 1.5 because magic numbers are. So in this case we've waited for what we believe the timeout should be. And so at this point we should retransmit things. Otherwise we should send new data. If we have new data and space in the window. So here we really, if we're going to retransmit things, the question becomes what do we retransmit? Well, we retransmit.
02:34:40.587 - 02:35:28.573, Speaker A: This is where technically the TCP protocol probably wants us to only retransmit the packet that has timed out rather than as much as we can. But instead what we're going to do is we're just going to send as much as we're allowed to retransmit. So what that means is we're going to do something like self write. Of course, self write is broken. We know that it doesn't work for retransmits, but that's something we're going to have to fix. And that takes the nick and it's going to take. I guess allowed is going to be self.send.
02:35:28.573 - 02:36:40.935, Speaker A: window, right? What was the. What was the computation here for how much we were allowed to send? Managing the window, the send window, or is it. We're allowed to send from this self send window, which means we don't really need it. So here we're going to write everything from. We're going to retransmit everything from self enact. That's also not going to work. But let's look at that in a second.
02:36:40.935 - 02:37:19.235, Speaker A: Everything. This many bytes, right? So we're going to send. Basically we're going to. Because we're retransmitting, we're just going to retransmit as much as we possibly can. And that might include some new data. Right? And then at this point, self.send. next is going to become self.send.
02:37:19.235 - 02:38:05.835, Speaker A: unact wrapping add self send window. Sort of. This code is still a little bit inaccurate, but does the rough idea make sense? We're supposed to do a retransmission so we just send basically the full window. Again, we could be more conservative here, but instead we're just going to. We might actually here want to send like only as much as will fit in a TCP packet, for example, but that's not currently what we're doing. And then now self send next will be. Actually, that's not even true.
02:38:05.835 - 02:38:36.451, Speaker A: Self send next should now point to the next byte that we want to send. Although this might not actually be accurate. But we'll get back to this code. There's more to lay out the rough structure of what it's going to do here. If unsent is zero, then we don't actually have anything to do. Right. If we don't have any bytes that haven't been sent and there's nothing to retransmit, there's nothing for us to do.
02:38:36.451 - 02:39:30.291, Speaker A: There's nothing for us to send here. So we can just return. Okay. Otherwise we should just send out as many bytes as we are allowed to send. Right? So how many Bytes are we allowed to send? Well, we're allowed to send self.send. window minus actually minus n enact. Right? And if allowed equals zero, then what do we do? Well, we can't send any data, can we? Right? Like if, if the window allows us to send.
02:39:30.291 - 02:40:36.085, Speaker A: Like if the number of unacquainted we have are the full window, that we're not allowed to send any more bytes, we need to wait for the window to open up. And so in that case we can't do anything and we are not supposed to retransmit, so we do nothing. Only in this final case are we allowed to send some bytes. So here we're allowed to write out to the nick self dot enact from from nunact to nunact plus allowed. Now the observant among you might notice that like there are some out of bounds conditions here that are going to be annoying to deal with, but that we will actually have to deal with. Oh, we just got a lot of people claiming that there's php. None of this is php.
02:40:36.085 - 02:41:32.881, Speaker A: If you are saying php, you're in the wrong channel. Right? So in this case we are allowed to send stuff and we do have some stuff to send. And so in that case we just write out as much as we're allowed to send. And at this point self send dot next is self send enact plus sort of plus. Actually no, it's not even that. It is self descend next plus allowed sort of. My VIMRC is public.
02:41:32.881 - 02:42:00.747, Speaker A: There's in fact a previous stream where I go through my entire like editor setup and stuff. So if you search for that, you'll find it. Okay. And we have to deal with fins, that's sort of separate. So let's actually now tidy this up a little. If we need to retransmit, what do we actually get to retransmit? Well, we get to retransmit up to the window. We might want to have a lower limit, but because this is a.
02:42:00.747 - 02:42:50.505, Speaker A: We're only going to be sending small things regardless, it might not matter all that much and we might get like IP segmentation and stuff, which is nice. So here, right. Remember, unact might not have enough stuff to fill a window. So send is going to be, or I guess resend is going to be the min of self unact len and the self send window and that's how much we're going to send. Let's also fix right, while we're at it. So. Right.
02:42:50.505 - 02:43:55.565, Speaker A: What is unwritten here? Buff 1500. Ah, great. So it will only Write out at most 1500 bytes. So that's great. This is not quite right. The updating of send next is not actually right because it might be a retransmission right now. How do we want to deal with that, though? We could of course update self send next in every caller, but we do call right in a decent number of places.
02:43:55.565 - 02:45:06.455, Speaker A: Right. The sequence number of course, is also not necessarily send next in a retransmission. Maybe the trick here is going to be giving in the sequence number of the first thing. Then I think we can write write properly. So the sequence number is not going to be self send next. The sequence number is going to be whatever the initial sequence number is. The acknowledgement number is correct.
02:45:06.455 - 02:46:34.155, Speaker A: And now this can actually update self send next because self send next is going to be. Let's see, let last sec is sec wrapping add. Well, this really -1 next sec. Really? If next sec. Ah, not quite. And of course, if it includes a. If it includes a sin, then we wrote one more byte.
02:46:34.155 - 02:47:40.835, Speaker A: If it includes a fin, we wrote one more byte. This is going to come back to bite us because these aren't actually true. Actually, no, that is true. It just resets the flag at the end. That's probably fine. I think what we want here is, okay, let's ignore that for now, but we only want to update send dot next if we actually have bumped send dot next. So in this case, if next sec is, I guess if wrapping less than self send next.
02:47:40.835 - 02:48:26.855, Speaker A: So if that's less than next sec, then next is next sec. So this means that in the case of a retransmission, we won't update send next to be less, to be like whatever the last thing we retransmitted was. We would just leave it alone. So the idea here is that sec is the sequence number of the first thing in payload or potentially in syn. Really? Like including counting the sin is a different way to phrase it. Yes. Great.
02:48:26.855 - 02:49:14.795, Speaker A: Okay, so now this is going to have to decide what to do. So here, this is going to be self send next. That's false. C send next. Right. So when we send the initial sin to establish the connection, our first sequence number is going to be whatever we decided the initial sequence number is going to be. Where else do we call? Right here, same thing.
02:49:14.795 - 02:49:51.165, Speaker A: Self send next. In fact, for all of the. All of the ones that were there already, they already assumed this to be the case and they send no bytes. So that's fine. Where else? So this is sending an ack. In theory. This could like also Include sending data.
02:49:51.165 - 02:50:48.325, Speaker A: So we could make this just be tick, for example, maybe just tick to piggyback ack on data. This as well self send next because it's sending the sequence number here is the sequence number of just pass the fin. This does mean that we don't have a way to retransmit the fin. So we'll have to deal with that later. What this does let us do those in the case of a retransmission. This is self.send.on a.
02:50:48.325 - 02:51:17.415, Speaker A: Right. Oops. That is the sequence number of the first thing in an act. How this interacts with sins we'll have to look at. And down here it's the same thing. No, that's not true. Here it is in fact send next.
02:51:17.415 - 02:52:24.685, Speaker A: Yeah. So the. It should be the case that self send next points to the first byte in an act that we have not sent yet. And here the bytes we want to send is the min of unsent and allowed. How do you like Rust compared to php? They are very different languages. I highly prefer Rust. PHP is a very dynamic language, which is nice and it's nice for simple web setups.
02:52:24.685 - 02:52:58.055, Speaker A: I used to program a lot in php. I don't think I would use it for anything anymore. Right. So here. Right. So this should now work for retransmissions. That's great on a.
02:52:58.055 - 02:53:17.219, Speaker A: Right. So when we first start sticking stuff in. Oh, right. We haven't added anything to write yet. Great. So now if we look at lib, what actually happens when we try to do it Right. What do we do here? Oh, I guess we're not actually dealing with writes yet.
02:53:17.219 - 02:53:48.945, Speaker A: We're mostly just looking at shutdown. At least that was our initial intention. So for now we're actually going to assume that. We're going to assume that there are never any bytes to send. We just want to get shut down to work first. Which means that the only thing we could be asked to retransmit is the fin or asked to transmit is the fin. Mm.
02:53:48.945 - 02:55:00.735, Speaker A: The question is, how are we going to deal with retransmitting the fin? Because it's not in an act. So we need to keep track of whether or not we have sent the fin, which we know because. Oh, interesting. So we have a couple of pieces of information here. Right. We have self dot closed, which is has shutdown been called, but we also have self dot state and self.state can be one of these which indicate that we have sent the fin.
02:55:00.735 - 02:55:55.505, Speaker A: Right. So if we go back to our diagram, when we send a fin we end up in fin weight 1. If we have sent a fin, we're in fin wei or closing or time weight. So in any of the states from fin weight one and down, in all of those cases we have sent the fin. Right. And so we actually know whether or not, I guess let's add a thing here, have sent fin. So that is in.
02:55:55.505 - 02:56:41.695, Speaker A: Let's see, in state soon received or established, we have not sent it yet. In fin weight 1, fin weight 2 and time weight we have sent it. So in theory we should be able to use that to determine whether we're resending a fin or not. So let's see. So these are the bytes we're going to resend and. Oh wait, did it say. Actually I don't think that's true.
02:56:41.695 - 02:57:36.235, Speaker A: Thinking back to. Thinking back to what it said on close, I think it said enter fin weight1 regardless, like no matter whether or not you can send the fin and close. So close and established. Yeah. In any case, enter fin weight one. So it's actually not sufficient. We need to have a separate mechanism for determining whether we have or have not sent the fin.
02:57:36.235 - 02:59:00.255, Speaker A: Because there also has to be like an if here, right. Of like if need to resend fin or I guess this is really just is the fin within the window. That's really all we care about here. So if, if resend is less than. I guess this is a. No, this is not that. If resend is less than the window and self closed, then we also set the fin, we include the fin or I guess can we include the fin? Right.
02:59:00.255 - 02:59:56.275, Speaker A: So resend is how many bytes we're going to send out. That might be zero. In fact in our case it will always be zero. And if the window has space for us sending the fin and we're supposed to send the fin, then we send the fin if unsent is zero. Right. So this is tricky. So here we need to know whether we have already sent the fin because if we haven't, we should send the packet if we can.
02:59:56.275 - 03:01:03.255, Speaker A: Specifically we should send the fin if we can. Interesting. So one way to do this would be and not self closed. But unfortunately the downside of doing this is that this will send the fin again each time, which is not actually true because it's not correct because the fin should not get like there aren't multiple fins which this would imply. So I think we may actually need to keep track of essentially the last sequence number like the se. Ah, here's what we could do. We could keep track of what the sequence number of the fin is.
03:01:03.255 - 03:02:35.849, Speaker A: So that would be up here in connection, I guess we could do closed. It's a little awkward, but we can do it this way. Right. So closed at is going to keep track of the sequence number we used for the fin if we have sent it. So here this is going to be closed at is none because initially we haven't closed it at all. Right. So if there's no data to send and we have closed the connection and we've sent the fin, then we have nothing to do if send is less than allowed and self dot closed and self closed at is none.
03:02:35.849 - 03:03:40.673, Speaker A: So this is if we're allowed to send more than what we're already sending and we're supposed to send the fin and we have not yet sent the fin, then we send the fin and in this case closed at is going to be set to self.send. next wrapping add unsent. Right. That's where we ended up sending the fin, because no more data is allowed to be written once we've closed. Right. So the actual structure of this is the bytes in unsent are followed by the fin and so self send dot next is before these things that are unsent. So plus unsent is after those.
03:03:40.673 - 03:04:16.625, Speaker A: And that's where the, the sequence number of the fin will be. Great. I think that's right. I think that's right. I mean, it's probably broken, but you know, there's also moving to fin weight 1. So the old hacky code that we had was this business. So this set fin to true.
03:04:16.625 - 03:05:30.121, Speaker A: Hmm. It moved us to fin weight one. So that means that that is something that shutdown is going to have to do, right? It's going to do this close true state finweight one and from memory. This was what close is supposed to do, right? Technically we should check here for. Check for that. As long as the second fin is not emitted. Nope, that's not.
03:05:30.121 - 03:06:41.785, Speaker A: We don't do that. I guess this should really just be if C state is equal to state established or stab, I guess if we even have that state. Yeah, soon received. If no send has been issued, there's no pending data to send a form within segment and send it. Oh, actually no, we don't even. That's also fine. We actually, I think we probably just want to do this.
03:06:41.785 - 03:09:10.045, Speaker A: So if we're in state syn received or we're in state established, then we move to finweight. And if we're in any other state, what other states could we be in? Close wait. And close wait is also Fine but also we don't support that state. So SYN received and established fin wait one is also fine for us to do this and time weight would be an error. So finweight one and finweight two are both fine in all cases we move to well actually in the others it doesn't matter if we're in these, nothing needs to happen and if you're in any other state, then we really want to return an error on the form of error. New error kind who knows. Error closing Is that an error kind I can use? Unclear actually do connection ported might not be the right one but closing actually maybe shut.
03:09:10.045 - 03:10:06.157, Speaker A: Maybe this is already documented in shutdown. What does TCP stream shutdown say? The second call not connected. Okay, that's fine. So shutdown is just going to set up the state to be right and then the tick is going to take care of actually sending out the finish. Is the goal to create as an exercise part of a TCP stack that you will use instead of the inbuilt kernel one? Sort of. So I mean what we're doing is really just building a TCP stack because it's an interesting way to learn low level programming and because you learn TCP in the process. I don't.
03:10:06.157 - 03:10:37.185, Speaker A: My goal is not to use this for anything. It is more as sort of a. An educational experience. But of course the goal is that it actually works. And in fact it does work for reads now and hopefully with this change it should work for writes soon too. We'll see whether that turns out to be true or not. That is a lot of errors and they're probably all because of my stupidity.
03:10:37.185 - 03:11:40.447, Speaker A: This should be timers. Of course there's a bunch of stuff we don't maintain here either. Cannot add conversion between numeric types. Ignore back off, get speed. That's not quite how it works. So this is. This is the third video in a series.
03:11:40.447 - 03:12:14.905, Speaker A: So if you want to learn about the underlying like setup for how. How we're doing this in the first place, you should go back to. You should go watch the first video in the series, which is on YouTube. So I would watch these actually in sequence. I'm. I won't actually go back to explain how the earlier parts work in this video because it's already explained in the earlier video. Expected slice found U8 that's a separate issue.
03:12:14.905 - 03:13:20.033, Speaker A: All right, let's see here. Oh, it doesn't have the state, does it? I think this is going to have to do C close and then we're going to have to in here add In a close IO results this. It's going to do self. Self, self. Great. 68. Why? Dot manager.
03:13:20.033 - 03:14:35.897, Speaker A: Oh, connections 268. I guess RTO is going to be duration from. No. Yeah, from nanos, actually. Oh, that's annoying. Problem is we have to do arithmetic on time, which is kind of awkward. U32 found U16 oh, that's a good point.
03:14:35.897 - 03:15:09.485, Speaker A: I can add stuff to my Twitch. It's a good use. Like add links to the other things. It's a good point. Expected usize found range 2 Ah, so here's the other problem we have, which is, remember how un unact is a ring buffer. You can't index a ring buffer like this because the ring buffer is really two segments. Right.
03:15:09.485 - 03:16:31.515, Speaker A: The sort of head segment and the tail segment, potentially. So the real question is, how do we want to do this? Oh, this should say resend. Hmm. This also has to set closed at. So the question is, how do we want to break up this? Right. Hmm. I think actually what we're going to do here is have Right support taking two buffers and a length.
03:16:31.515 - 03:18:41.235, Speaker A: Yeah, that's what we're gonna do. So there's gonna be payload one, payload two and len. And then we're going to do unwritten write payload payload 1 len. Well, hmm, we want to make sure it doesn't write more than we're allowed to write because of the window, for example. Right. So here what we want to do is we want to write from payload 1 as many bytes as we're allowed to, or that's there. And then we want to Continue Writing from payload 2 if we're allowed to, which I think means that we're going to have to do something along the lines of first write as much as we can from payload one, which is going to be min of len and payload one len plus payload two dot len.
03:18:41.235 - 03:20:22.151, Speaker A: And then we're going to do P1. Len is going to be the min of these we're going to write out. So written plus equals this, dot dot P1L and then Len minus equals P1L. Sorry, I'm going to explain this once I've written it, just to make sure I actually understand it myself, to L. Okay, then write more if we can, from pillar two. All right, so the idea here is we can write out whichever is less of how much data there is and how much we're allowed to write. Right.
03:20:22.151 - 03:21:01.625, Speaker A: So that's now going to be len. So the question first becomes how much can we write out of payload one? Well, we can write Whichever is less of how long payload one is and what our limit is. So maybe we should call this limit instead of len. Let's do limit. It's a better name for it anyway. Okay, so we write out Some stuff from Payload 1 as much as we can, basically. Now the limit is decreased by however much we ended up reading from payload one.
03:21:01.625 - 03:21:38.227, Speaker A: Right. So if we wrote so it can't even be that this has to be written. So now once we write some stuff from payload one, now the limit has been reduced by however much we wrote to payload one. Right. Now we try to write more from payload two. So there are sort of three cases here. Either we exhausted payload one or there are two cases.
03:21:38.227 - 03:22:13.869, Speaker A: Either we exhausted payload one and there's more room, or we did not exhaust payload one because we used up the limit. If we used up the limit, then the limit here is going to be zero. And so this is going to be zero. And so we're going to read zero bytes from payload two if we read some bytes from payload two. And now we're going to continue writing Sorry, from payload one. Now we're going to continue reading from payload two. The amount we're going to read from payload two is however much the remaining limit is or payload two's length, whichever is smaller.
03:22:13.869 - 03:23:43.835, Speaker A: So we write that out as well, and the result is we wrote this many bytes out from the two payloads. Okay, great. What is this? Right. I guess this is like max data. So what is size here? Size is how many bytes are there in a packet. Well, it certainly can't be more than the length of the packet, but it could be less, in which case it's the TCP header, the IP header, and as much data as we can write as we have. Yes.
03:23:43.835 - 03:24:36.133, Speaker A: Let's see. Can unwritten dot write end up writing fewer bytes than you ask it? Yes. This is why I do limit minus equals written rather than limit minus equals P1L. So I think this is still correct. Like unwritten write can end up writing fewer than P1L bytes, right? Because it could be hitting the limit of buff, which is of limited size, or limit of unwritten, which is buff. So that is why the limit is decreased by how many bytes were actually written out. And if we then try to write out more bytes here, unwritten would still then say I wrote zero more bytes.
03:24:36.133 - 03:25:56.035, Speaker A: So I still think this ends up being right. Okay, what now? Fails? Lots of things. Great. 193. Right. So now this is going to be this. Of course, now all of these have to include more Stuff in them, which is a little annoying, but it's worth the cost because now where is it here we can now do head, tail, self enact dot where's the place where we get the head H tail as slices.
03:25:56.035 - 03:27:26.775, Speaker A: As slices. And then we can do HT resend. So this will write first from H, then from T, and no more than resend, which was what we wanted in the first place. And the same is going to be the case here, where this is going to be let HT self enact as slices. Except here we have to skip forward by an act, which is also going to be a bit of a pain. We want self enact and unact, so we actually need to mutate these to skip, which is if it's writing to an in memory buffer that will only later write to the actual output. Yep, that's right.
03:27:26.775 - 03:28:18.543, Speaker A: So that's why I think it's okay if it wrote directly to the output. You're right. Then it could write too much. All right, so here we need to basically remove stuff from the beginning of H and T all the way up to N on act. So If H.LEN is greater than or equal to nun. Well, actually, let's write out the verbose version first.
03:28:18.543 - 03:29:54.615, Speaker A: Then H is equal to H nunact and T is T remains the same because we just trimmed off that many things from H. Otherwise, skipped is equal to H len, H is equal to an empty one, and T should be equal to T N on act minus skipped dot, dot. And this can probably be simplified somehow, but I'm not going to bother. Right, so here, let's draw again, because this is a little bit weird. So, all right, so we have our ring buffer again, actually, that. I don't want that to be a one. So we have our ring buffer and let's say that the.
03:29:54.615 - 03:30:51.933, Speaker A: This is the head and this is the tail. Let's actually write these out. So this is 1, 2, 3 and 4. So with this setup, let's say that N an act is three, right? So what that means is we really want this slice because we want to skip three, right? If we're going to send only the stuff that's new, only the four here is new. All the other stuff is stuff that we've sent in the past. So we only want to send for. So the question becomes how do we get a.
03:30:51.933 - 03:31:59.705, Speaker A: Like when we do dot ask slices, right, then what we get back is a reference to 1, 2 and a reference to 3, 4, right? Where this is H and this is T and we want to turn that into H is nothing and T is 4. That's what we want to end up with. Right? And so the way we do that, if we, if we look at the code we just wrote, is if H dot length is greater than equal to enact. So if, let's say an act was one, right. So if an act was one, then all we have to do is skip the first one elements from head, right, and leave tail the way it was, which is what this does, right? H is just set to be skipping and unact from H and T is left unknown. Otherwise head is going to be empty. Right.
03:31:59.705 - 03:32:27.235, Speaker A: So if N on act is greater than the length of head, then head is going to be empty no matter what. We always need to skip these. And so in that case we're going to set skipped is equal to two, right. So we skip these two. Right. So that's here head is going to be empty and T is going to be skipping. However we have left that we need to skip.
03:32:27.235 - 03:33:03.655, Speaker A: So end on act was three, skipped was two. So sort of left like how many are left is one. So that is this one. So we're going to skip this one as well. And so T is going to be starting from one and onwards which is starting from here and onwards, which is four. All right. And with that it should be possible for us to pass H T and send because send is sort of how many bytes we are allowed to send.
03:33:03.655 - 03:34:47.575, Speaker A: Yes, I think that's right. 289 is the multiplying time which we're going to ignore for now. 298 resend expected usize found U32 it's probably fine for this to be a U32 to be honest, but it'll be easier if it's a U size. So let's just make it be a U size. This should not need to do any of that anymore because the first byte here is the first byte of an act whose sequence number is the unacked sequence number 289. That's still the timer mismatched type expected result. Hmm.
03:34:47.575 - 03:35:14.015, Speaker A: We're certainly going to need to. We're going to need to maintain these like last send stuff as well. And those are going to have to be updated here. That's not what I meant to do. So here this has to return. Okay. In the end.
03:35:14.015 - 03:36:00.155, Speaker A: Yeah, we have to figure out what to do about these timers. So when do we. It might be the last send is not sufficient because we might have to keep track of last send for. Yeah, it's going to be a little awkward, I think we have to keep track of every send because imagine that you do ascend and then later on it gets act what is now your last send. Right. So I think you actually need to keep track of when you sent every packet does that. And that has to be updated when you.
03:36:00.155 - 03:36:52.275, Speaker A: When you retransmit. Hmm. Yes. I think the trick here, I know what we're gonna. How you're gonna have to do. We're going to have to make. I think what this is going to end up being is a B treemap from sequence number to when it was sent, because we can use the B treemap to look for all the sequence numbers before or after.
03:36:52.275 - 03:37:40.981, Speaker A: Of course, it gets weird with wrapping arithmetic, but we can figure that out. We're also going to have to figure out what to do here in order to estimate the rtt, because we don't want to use retransmissions to estimate the rtt only the original sends. Right. Otherwise, like if I resend a thing five times, that doesn't mean that the RTT is five times as high. So I only really want to count rtts from things I didn't have to retransmit because I also don't want to have it be the last send. Because imagine that I send something, the retransmit timeout expires, so I send again. But the first one actually arrived.
03:37:40.981 - 03:38:16.885, Speaker A: It just arrived a little bit late. So the other side sends me an ack that I receive immediately after the second send. If I use the second send is when I send the thing that was now act, then my estimate of the RTT is going to be very small, which is also wrong. I don't know how real implementations handle this. Like what do they use for the estimation? It's probably a lot of my guess would be there's a lot of research in estimating RTDs. I think it's just hard, which means it's fine if we do a bad job of it. In fact, we're probably going to do something stupid, which is great.
03:38:16.885 - 03:39:40.475, Speaker A: Okay, so we really need to maintain this send times business, send times. And I think what we're going to do there is down here, whenever we write something out, we're going to do self send times, insert the first sequence number and time instant now, right? So every time we send any packet, we store the sequence number we sent in that packet, the first sequence number we sent in that packet, and the time when we sent it. And then what we'll do later is in the code that deals with when things have been acked there. We can then sort of walk send times and use that to update the rtt. And now because we do this in write, it means we don't have to update all the places that call that send packets. We can just do it here. Of course, this might have some problem when we send resets and such, but we can probably just ignore that.
03:39:40.475 - 03:40:46.235, Speaker A: It does mean that waited for is a little weird. I think this is going to be like the minimum. Yeah, this is going to be send times.values.min. yeah. Right. So this is actually no map map TT elapsed and we want a max. So this is what is the.
03:40:46.235 - 03:41:41.717, Speaker A: What is the longest we've waited for anything that we've sent. Although that's weird too. I think it should only be for the currently unact. I think what we're really going to do here is what's the interface on B tree map for like next higher value. It's like a range. What do they call it? It's never what I want there. There's a range.
03:41:41.717 - 03:43:16.135, Speaker A: That's what I want. So I want send times ra and I want self send enact dot dot dot next dot map time instant elapsed. So that is how long is it since we sent the last thing? That is not an act. It's a little bit weird of a sentence, but this is like find the find when we sent the earliest unacked things and see how long it is since we sent that. Yes. And if the time that is expired there is more than the timeout then retransmit and if. I guess this is like how do we want to do this conditional though this is like let should retransmit.
03:43:16.135 - 03:45:00.985, Speaker A: So we should retransmit if waited for issum. I guess we could even do if let sum or is waited for if if there is no such timer like if we have no running retransmission timers, then of course we shouldn't retransmit because there shouldn't be anything to retransmit otherwise we should do it if weighted 4 is greater than 1 second, right. So this is the lower bound and waited for dot as float sex. So as floats X gives you the duration in floating point seconds. So this like seconds but with decimal points is more than 1.5 times self timers SRTT as float seconds. If should retransmit then we should retransmit things and here can we include the fin Then self closed at is going to be sum what is it going to be what is the sequence number of the fin? Well, it is self.
03:45:00.985 - 03:46:03.005, Speaker A: It is the start of the unacknowledged buffer plus the length of the unacked buffer. Yeah, that is the sequence number of the fin. Which I think is the same as down here. I hope maybe it is not, but that's not terribly surprising. Sort of want an assertion here to check that these are the same. I feel like this should actually be the same. So let's down here do like.
03:46:03.005 - 03:46:43.105, Speaker A: No, we can just make it be this. Right. Because the fin just should always be that. The start of the unacknowledged window plus the length of bytes that we are that are in that window should just always be the fin. Down to fewer errors. We need to import B tree map. That is luckily pretty easy.
03:46:43.105 - 03:47:53.145, Speaker A: Timers sometimes. 292 map fine. TT elapsed really? Oh, as sex float. What's it called? Duration. What is it called? It is called. Oh man, stop with that. Nightly.
03:47:53.145 - 03:48:40.621, Speaker A: Or am I on. I don't actually remember what I'm on here. Version beta. So I guess I'm on beta. And on beta it is called what exactly. It's called as sex F64 which means it's not going to compile because it's a feature, right? Probably, yeah. Override said nightly.
03:48:40.621 - 03:49:58.090, Speaker A: That's too bad. Pretty annoying. So we're gonna have to do feature duration, right? 292. Oh sure. 306 more numeric conversion. This of course needs to be wrapping add as does this. Which also means it has to be SU32 probably 31 6.
03:49:58.090 - 03:51:24.325, Speaker A: That's fine. 3 21. Numerical conversions are the most fun. So getting pretty close. Expected usize found u32 great. Now we just need to fix the borrow checker lib72 so why is this complaining? This is complaining because canopro connection is mutable values mute. Try that variable does not need to be mutable.
03:51:24.325 - 03:51:54.645, Speaker A: 107 okay. 252. 244. That does get reassigned. That is true. 300 and. Oh, that's awkward.
03:51:54.645 - 03:53:08.635, Speaker A: I'm borrowing into self enact which means that I can't call self. Right? That's pretty annoying. Ah, that we can't actually fix that easily. It could be that that self dot write should just always read from self dot enact rather than us like passing it in everywhere. Like we give a. We give a start and an end instead of giving those slices. Because currently here, right, like H and T are borrowing self enact but self dot right Needs to borrow self Mutably which it can't do.
03:53:08.635 - 03:54:29.305, Speaker A: I think we're just going to do here zero and then down here we're going to do nunact as usize. And now right is going to change a little bit. It's going to change to be. Instead of taking payload one and payload two, it's going to take start usize limit to usize I guess offset. And we're going to say let muth mute is self unacked as slices offset then offset offset minus skipped. And then now this is going to be H and T. These are all going to be H.
03:54:29.305 - 03:55:06.545, Speaker A: This is going to be T. Oops. T. All right. See how that works? And now anywhere that calls right, it's now just going to do this. Of course. Now we have a problem here.
03:55:06.545 - 03:55:28.755, Speaker A: Oh no. As long as you set limit to zero, it's not going to send any bytes anyway. Great. Even better. So it doesn't matter that it's using unact behind the scenes. 00 is always send no data any. How about now? Great.
03:55:28.755 - 03:56:21.103, Speaker A: How much faith do we have that this will actually work on the first try? I'm skeptical. Let's see. Well, it didn't crash immediately and it still got data. And then it crashed in on tick which called write. Well, that's better than I thought it was going to be. I guess. Actually we sort of.
03:56:21.103 - 03:56:47.365, Speaker A: We might as well have close call self.one tick. It can't do that. Doesn't have the nick. That's fine. Okay, so write is failing somewhere. Slice index starts at 1 but ends at 0.
03:56:47.365 - 03:58:04.761, Speaker A: It sounds an awful lot like fin in fact, because it knows the sequel, because right knows the sequence number. In theory, it can compute the offset. I don't think it needs to take the offset right, because here self send dot next should just be pointing to the end of an act. Here we want to send from the start of an act, which is zero. Here we want to send from next which is an act plus number of unactions. Here we want to send from next. From next.
03:58:04.761 - 03:58:41.923, Speaker A: From next. Okay, great. So we don't actually need to take the offset. Instead the offset is going to be self.send. next wrapping sub self on a right. No, sorry, seek. Because that is the starting.
03:58:41.923 - 03:59:33.595, Speaker A: So the sequence number of the starting byte and we subtract the unacknowledged index. Which means if you're starting to send from the start of an act, this will turn zero and the offset is zero. Otherwise it's going to be some larger value. Which means that anywhere that calls right does not need to give this argument. This starts us into an act which wrappingsub unact is just the same. Yep. This starts from next.
03:59:33.595 - 04:01:08.645, Speaker A: Next here could be pointing to the. To after the fin. These could both be pointing to after the fin, in which case right would crash because it's trying to look up past the end of an act. This does not need this. This does not need this does not need this and this does not need that. So here we're going to have to look at if. What do we want to do here? We sort of want to observe that we, we need to.
04:01:08.645 - 04:02:13.305, Speaker A: We need to handle the fin somehow. This will also have a problem with the, with the sin. I think we need to special case the two virtual bytes SYN and fin. So let's make the offset and the limit both be mutable. Actually the limit doesn't need to be, but the offset does because we never read past the end of the input stream regardless. But we do need to return it. Just leaving a to do for myself for later.
04:02:13.305 - 04:02:58.935, Speaker A: So if the, if the sequence number is. If the sequence number is the sequence number of. Hmm, it's a good question. So we have two sort of special cases. We have the sequence number is equal to the sequence number of the sin, in which case we need to like shift it one. Right. Although I don't think that can ever happen.
04:02:58.935 - 04:05:16.295, Speaker A: No, that would only happen if you retransmit a sin, which should not happen. So the real, the real issue here is if the sequence number is equal to the sequence number of fin, because it'll be off by one. And so therefore if, if we have the sequence number of the fin and if this sequence number is that sequence number plus 1, then seek minus equals 1 no. Then offset minus equals 1 no then equals 0. Right. So this is if we're asked, if we're being asked to send bytes starting at after the fin, then we need to set the offset to zero where we, we should not be reading any data or another way to say this here, although that's also just annoying. I want to see whether that does the right thing.
04:05:16.295 - 04:06:48.151, Speaker A: Oh, of course it doesn't. If I do this, what happens? So it crashes where it's so unhelpful that I don't get the line number here. All right, it's time for some print debugging. Right from I guess seek limit from. So seek limit self enacted as slices. And then I also want to print out here using offset offset. All right, so what do we get? Write sequence 0 limit 0 from there.
04:06:48.151 - 04:07:39.135, Speaker A: That's Fine. Right, so that's writing out the initial sin. Write sequence 1, limit 0 from there. This is writing out the fin she. Let's print some more stats. Like this is cell TCP fin. And then let's not do that here, but do that here instead in this.
04:07:39.135 - 04:09:00.065, Speaker A: All right, what do we get? So first we write out the sin at sequence number zero. Great. Then we write out the fin at sequence number one and the question becomes what happens at sequence two where sin is false and fin is false. So when that happens, it's using offset 1. Oh, so we're correcting subtracting 1, but the sin is the syn unact. Is that why the wrapping sub is not picking this up? Base this self send on a. Yeah, I think on A is not being updated correctly.
04:09:00.065 - 04:10:04.385, Speaker A: Base zero using offset zero. Base no, base one. So one base one. So what sends this fin? Or rather why is this not being picked up? All right, let's see. Fin clothes is none for all of these. How is this fin being sent though? That's the real question. Oh, do we still have our hack in place? Is that why.
04:10:04.385 - 04:10:56.535, Speaker A: We do? Don't we? Yeah, that should not be there. Let's see how that turns out. Ooh, that looks promising. So let's see. So first we write out the sin, then rewrite out just an empty packet. Unclear why. Oh, this is an act to the other side's something Unclear.
04:10:56.535 - 04:11:33.951, Speaker A: I think this is just an ack we decide to send. Yeah, this is just us deciding to act. Something unclear why here we do that again. Just seems like we're just sending acts without needing to then. Oh, we're acting. No, no, this is us acking the bytes that they send us. Right.
04:11:33.951 - 04:12:00.595, Speaker A: Because then we get the bytes right after. Then our shutdown happens. And so we send our fin and then it tries to send. Whoa, whoa, whoa, whoa, whoa. What is going on? Oh, this is the retransmission timer kicking in. That's also problematic. Right.
04:12:00.595 - 04:12:37.869, Speaker A: So we don't actually reset our retransmission timer anywhere. So whenever something is acting, act our sins. Right. So here we want to make sure that we remove anything from. Right. So this is. We got.
04:12:37.869 - 04:13:02.075, Speaker A: And actually, let's look at the RFC again down here. This is when we receive. Where is it? Check the ack bit. SIN bit. Check the ack field. Yeah. Any segments on the retransmission queue which are thereby entirely acknowledged are removed.
04:13:02.075 - 04:15:36.855, Speaker A: So this is the trick here. We want to basically remove. So self enact drain and we want to drain everything up to acknowledge wrapping sub Self send an A right? So this is act. So this is we got an act for something and now we want to remove anything from the unact queue that has now been acting and then we also want to deal with any of our timers. So I guess here what I want is we want to walk the B tree map. So the we want to make sure that we keep track of or remove any of the timers that are relevant. Right? So self timers send times I guess retain that's going to be a sequence number and a cent and if is between wrapped self send on a seq.
04:15:36.855 - 04:17:13.268, Speaker A: So for all the timers if the sequence number for that timer is in the list that has now been act then we want to remove the timer. However, we also want to make sure that we update our RTT estimate right? Which was self SRTT so RTT is centelopsed and self the smooth RTT is. Actually I think what we want is SRTT should just be an F64 as sex F64 then this should be. I don't know what they recommended as the alpha 0.8 sure. 0.8 times the SRTT plus 1 minus 0.8
04:17:13.268 - 04:20:33.375, Speaker A: times RTTS6F64 now what cannot find value. That's because this has to be self I guess this might as well just be sent elapsed 435437 really there isn't a retain on B tree map. That's interesting. B tree map huh. That's awkward. Hmm. Why is there not a retain on B tree map? I guess we will do it the stupid way B tree map new actually let old is standard member place self timers send times B tree map new and then we're going to do old extend no self timers send times extend old into iter filter map seek and sent which is essentially implementing our own really inefficient retain then none else sums and this has to be 1.0.39
04:20:33.375 - 04:23:08.225, Speaker A: so here this closure borrows self but we're also using self here. So we need to do some sad stuff like una self send una so this is going to be una and this is going to be srtt otherwise the closure would not work. How about now? How much is going to break O? That broke a lot. Drain upper bound was too large. Really this one huh? How is that possible? So back for that last was that prune in this again self send an A and self enact act for one last was. Oh, it's the. It's when we get the act for the sin if self is empty, we only want to do this like so.
04:23:08.225 - 04:23:34.607, Speaker A: Great. Ack for one. So it ignores that. And then somewhere down here for two. Great. So we still haven't sent any data, but now shutdown works. Increase font.
04:23:34.607 - 04:24:05.805, Speaker A: Sure. Better. Great. So now the trick. Now the real question is going to be can we implement. Right. This doesn't actually need to do anything flush.
04:24:05.805 - 04:25:01.511, Speaker A: So we don't actually have to have a way to do flush yet. But that's fine. Fine. Let's change our main to try to do stream dot write. Hello. How terribly wrong do we think this is going to go? Well, it crashed. All right, so it's all fine.
04:25:01.511 - 04:25:26.493, Speaker A: So all of this is establishing the connection. We receive the data from the other side first. That's fine. And then we send. Right, With a limit of five. So that would be our hello. And also fin set to true at this point, fin closes.6,
04:25:26.493 - 04:25:44.083, Speaker A: which is 0 is the sin.1 is the h in hello.2 is the e.3 is the l.4 is the l.5 is the o.6 is the fin that follows the O.
04:25:44.083 - 04:26:45.765, Speaker A: So that's right. We try to write 7, which uses offset 0. This should also set limit to 0 if we try to write. Trying to write following fin. All right, let's try that again. So it still did something weird. In fact, it's printing doing the same thing a lot.
04:26:45.765 - 04:27:55.015, Speaker A: Why? Ooh, why is it deciding to. Is the real question. So it is certainly writing out the data. It's just doing it a lot. Let's make our lives a little bit easier and have the timeout thing be like a second instead. Okay, so what actually happens here? This is all the received stuff so that we already have dealt with. Here's when the timer first fires after the write and it wants to write out five bytes.
04:27:55.015 - 04:28:22.045, Speaker A: That includes the fin. Why is limit five? Oh, right, yep. So it's using offset zero base one in that and it's supposed to write out five. So 1, 2, 3, 4, 5. This is the hello. Then it tries to write out from seven and then it's just writing nothing. That's all fine.
04:28:22.045 - 04:29:27.305, Speaker A: Although the fact that this stays full means that we never get an ack from the other side. So let's pull up our trusted T shark. Start this again. Start this. Run the client. Right, so what actually happened there? So we we sent sequence one and act their five. So this is the food that they sent us plus their sin and their fin.
04:29:27.305 - 04:30:42.205, Speaker A: No, just plus their sin. Then we send RFIN with a length of five. So clearly it got the Data. But also why are we sending the. We're sending those because we never get the ack for this. Why are they not acting the data we're sending them? That's certainly what's missing. Because our packets look well formed.
04:30:42.205 - 04:32:07.205, Speaker A: I guess. Let's try pulling up wireshark and then run this. So what does this get? Right, so this is the food that we get from them. Then we and this is us acking their sin again. This is us acking their fu. Then we send a fin act that contains hello data 5 bytes. But why, oh why do we not hear anything from the other side? Isn't that a problem coming from nc? Well, it does certainly look like netcat is not doing the right thing.
04:32:07.205 - 04:33:16.505, Speaker A: But why is it not doing the right thing? I mean we could certainly do dash N. I don't see why that should matter. Not yet implemented. Great. Why? Oh, I don't think we want that. Oh, I wonder. I wonder whether.
04:33:16.505 - 04:34:41.575, Speaker A: Yeah, if not of tcp. Let me just try a little hack here and see whether that makes a difference. Just not h. I have no idea why it's not. Why is it not printing the. It's clearly getting the data. That's what's weird.
04:34:41.575 - 04:35:42.125, Speaker A: I mean we could do. We could enable debugging and see whether that makes a difference. But sure, I guess debug and verbose it is. I guess not. Give me more verbose. It's just not printing the content. What happens if we do curl instead? Let's see if curl is better behaved here.
04:35:42.125 - 04:37:30.844, Speaker A: No, no, it shouldn't be firewall rules because the. The packets are going through like we see that in T. Let's see what happens in the case of like if I do. This is really weird because the very clearly the packet is going through right? Like T shark here when I run this. Oh, we are getting a retransmission from them. Why? Right, so this is their synac. This is our act of their sin.
04:37:30.844 - 04:38:32.754, Speaker A: This is them sending. What are they even sending? Weren't they just send oh foo and a new line Fu and a new line. This is us backing their sin again because our implementation is stupid. This is us acknowledging their foo. This is us sending our hello and also terminating the connection. This is us just sending acts. This is them retransmitting they're fin.
04:38:32.754 - 04:39:37.055, Speaker A: That doesn't seem right. There is no fin yet. I think this is the kernel from a previous run or something. But why are these just being ignored? That is very weird indeed. Let's try to just like leave this running. For a bit and see if that changes anything. Certainly at some point we should try to resend the data as well when the timer expires.
04:39:37.055 - 04:40:56.473, Speaker A: At least in theory. But our code there could be broken. No, I don't see anything. Huh, Fascinating. I mean, it could be. It doesn't like that we send the fin along with the data, but I don't think that should matter. So remind me why this doesn't work again.
04:40:56.473 - 04:41:46.905, Speaker A: This crashes us because not yet implemented on 5, 10. This is. We got a fin early. So this is something like we're in the established state and got a fin, in which case we have to go to close weight. Okay, fine. Don't really want to implement that. Shouldn't matter though, huh? I don't know why this is happening.
04:41:46.905 - 04:42:34.445, Speaker A: Let's do. Ah, here's what we'll do. Let's do an S trace of that process and see what it gets. All right, so it's loading a bunch of stuff. That's fine. Where does it start doing networking things. So it connects.
04:42:34.445 - 04:43:50.187, Speaker A: It reads foo, it writes foo to the network socket, and then it just pulls on the network socket. So this indicates that the kernel never thinks that it's getting data to read. So it's not netcat. So it is the kernel. So why is the kernel not delivering that data? Why is the kernel not delivering that data? It's certainly like the protocol interactions all look right. And the data that they send here we are receiving. And the data we're sending here looks totally fine.
04:43:50.187 - 04:44:33.365, Speaker A: The only thing I can imagine is that it's not okay for us to include the fin with the data. So I mean, we could try not doing that, I suppose. So in our. Right. No, in our on tick. So this is just. If unsent is zero.
04:44:33.365 - 04:45:49.865, Speaker A: So now we should only send the fin after everything else has been acknowledged. 510. Oh, did I run it with the wrong flags? No. Oh, forgot to run the T Shark. So if we run this now with this, what happens? No. So here. This is them sending data to us.
04:45:49.865 - 04:47:11.215, Speaker A: This is us acknowledging that this is us sending data to them. And notice there's no fin. And then we send the fin. Retransmission of. That is so weird. I don't have a good answer for you. Oh, hi.
04:47:11.215 - 04:48:02.215, Speaker A: Huh. It looks like all the let's pull up wire shark again because I'm. Oh, that's not what I wanted. French ark. Apparently not. Let's try because that did not make a difference and I don't think push should be necessary. So why Are we getting no X from the kernel? Here's one thing we could try.
04:48:02.215 - 04:50:00.165, Speaker A: If we do this, then this, and then sst. What's the thing for choosing an interface? SS show only one interface. All right, ss, what is the info? I specifically want to know. Oh, fine. SSTI dust destination, say 01 24. Let's see. So it says it is act five bytes.
04:50:00.165 - 04:51:22.795, Speaker A: No, it is sent four bytes and five bytes have been acting. Are we acting too many bytes? Last send, last receive, last act delivered. So it is receiving segments, it's just not adopting them. Why? So it's just ignoring all the incoming segments because it's saying there's nothing new in them, or it's deciding that they're not valid? Okay, that's the only thing I can think of that the. It's deciding that the segments we're sending here are invalid. Why is it deciding that? It's the real question. Hmm.
04:51:22.795 - 04:52:35.405, Speaker A: I wish there was a good way to just, like, log the kernels. Linux kernel log drop packets. Reasons why the network is dropping packets. What's in here? Start this, start that. RX packets, because it is getting packets. There are no RX errors. There are no CRC errors.
04:52:35.405 - 04:53:59.685, Speaker A: GNOME packets dropped RX bytes. RX packets, so it's getting all of them. This is what's bizarre. And it's getting more and more bytes, but it's just kind of ignoring them. Why is it ignoring them? Let's look more carefully at these. They send us a sin sequence number zero. We send them an ACK saying that the next thing we expect is 1, and including our sin with sequence number 0.
04:53:59.685 - 04:54:39.487, Speaker A: They respond acking our sin, giving sequence number 1 is the contents of this packet. But there are no contents. Length is 0 and there are no flags. And ack equals 1, because the next thing they expect from us is 1. They then send us with sequence number 1, length of 4. We respond with sequence number 1, acknowledging 5. So the next thing we should receive is 5, because we were expecting to receive 1.
04:54:39.487 - 04:55:44.665, Speaker A: Then we got 1, 2, 3, and 4. Right, because 4 more. So our next expected sequence number from them is 5, so that ack is correct, which is also why they're not doing any retransmissions. Then we send sequence number equals 1, which is still correct from our side, length 5, and that they just stop responding to. Hmm. It's also weird that they're not sending any. I guess the keep alive interval is like two minutes, so it'd be surprising if they did.
04:55:44.665 - 04:57:27.745, Speaker A: Why are they ignoring our bytes and crucially it seems like it's not dropping any packets. But if you look at the output from SS up here, the receive queue is also empty. The receive window is large enough to hold this initial window is 10. And we're not sending that many bytes, so we should be fine. There's just like nothing here. That looks weird. Oh, unless they think our window is too large.
04:57:27.745 - 04:59:36.921, Speaker A: Hmm. I don't know. I also don't know how to make progress without more insight into how the kernel is deciding to drop our packets, which this is not giving me. Are there other tcp? Except none of them are being dropped and there's no reset being sent back. And there. I think there is also, if we look at IP link, is there an IP stats? I wonder ton tap show monitor? It seems not helpful. I guess we could try sending.
04:59:36.921 - 05:02:11.365, Speaker A: I mean, it would be kind of stupid if this helped, but what happens if we send more bytes? I mean, this is clearly somewhat, somewhat of a desperate move. I don't know. I think what we're going to do then is I'm going to commit this because this. Looking at the traces, this looks like we're doing the right thing, which makes me think that what's actually going on is that there's a TSCP extension of some kind that we basically need to support and we don't, and that's causing the kernel to drop. What is TCP metrics? TCP metrics? I don't think that's going to help us, sadly, because really what we need insight into here is like the Linux kernels, TCP stacks like internal steps, and I don't think that's something we're easily going to get. I might end up debugging this sort of separately, but I think, I think we're at a point where me debugging this any further is not going to be interesting. And we also got like basically most of the way we wanted, right? So we know that reads work, we have shutdown working on its own and we have rights at least producing what looks like the correct protocol messages.
05:02:11.365 - 05:03:07.505, Speaker A: So I think we're actually going to end it there, even though it is a little bit unsatisfactory. Because in theory, I think we covered all of the, all of the sort of interesting aspects of this. I think the only thing we're really missing is the implementation of Flush. But Flush is also pretty straightforward. So the only thing we're missing for Flush is the ability to block until there's nothing left. And really all we'd have to do there is add a My TCP available, we would just add another available flag that would be like flush and we would set that flag in availability only if an act is empty. And then we would have a condition variable wake up, just like we have elsewhere.
05:03:07.505 - 05:03:48.427, Speaker A: Come to think of it, we don't do wakeups for writes here, but that is because writes in our system currently just cannot block. In a real system, you would have a limit to how large you allow your buffers to grow, and currently we don't do that. So here there's definitely a Currently our writes do not block and our flush does not block, which is not realistic. Right. I don't think IP metrics, like IPTCP metrics, I don't think that's going to make a difference. It doesn't print anything more than what we have from the other stats. Yeah.
05:03:48.427 - 05:04:44.055, Speaker A: So I think it's really bounding the size of the buffer for write and implementing blocking for writes and blocking for flush, which are basically going to be the same thing as we did for Read. Right. Like implementing the appropriate availability flags here and adding a condition variable for flush and a condition variable for write, both of which are essentially the same as what we did for Read. And of course we didn't actually get around to implementing Connect. My plan was to do Connect next, but given the issue we're currently seeing, I don't think we're going to get past what we're currently seeing without some deeper level network stack debugging, which I think is going to be mostly orthogonal to Rust and more like digging into kernel things, which I don't want to spend a bunch of time on now. So I think we're going to end it there. We have now a TCP stack that can do reads and writes.
05:04:44.055 - 05:06:04.745, Speaker A: The writes don't work for some relatively weird reason, but the fact that wireshark and T Shark both show like a valid TCP session with data going both directions means that we're like, if not, they're very close. And I think we have all of the components we believe we're going to need, including the timers and stuff. For now, managing all of this, like segmented TCP retransmission, it's definitely not the most efficient implementation you're going to get, but I do think we're in a point where the basic structure lends itself to writing a totally correct TCP implementation. This is likely going to be the very last TCP stream. I might do one like much later if there's a lot of requests for it and if we can get packed past this, the kernel dropping our packets in the meantime. What I would like to ask is first of all, if someone wants to dig into this more, I'll push all the code to the Rust TCP repository, so feel free to check it out on your machine, try to run it, try to figure out why this is happening. Separately from that, please do go to the live coding page and vote for what stream you would like to see next.
05:06:04.745 - 05:06:50.745, Speaker A: There are a lot of ideas here. They would all be interesting to work on. Just drag them in the priority order you would like to vote for them and then we'll see what ends up being the next stream. My guess is the next stream will be in about two weeks, but I will announce it when we get closer. And with that, thank you everyone. Do you have any questions before we like finish? Then I can take them. They don't have to be about TCP or this project at all, but anything at all that you want to talk about before I sign off? Need to wait for the delay on the stream? Doesn't look like it.
05:06:50.745 - 05:07:00.805, Speaker A: Great. Well thanks everyone for coming out and I will see you on the next stream. So long, farewell, auf Wiedersehen, goodbye.
