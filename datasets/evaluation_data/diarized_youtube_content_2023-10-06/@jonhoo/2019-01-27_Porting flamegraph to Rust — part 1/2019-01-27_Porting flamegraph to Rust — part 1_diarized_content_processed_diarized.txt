00:00:01.040 - 00:00:22.945, Speaker A: Right. Hello. Welcome to another stream, the first stream of 2019. It's pretty exciting. As some of you may be aware, there's a voting site that you can now use to vote for what you want to be the next upcoming stream idea. It runs, basically. We did a stream where we built this website and it basically runs ranked choice voting.
00:00:22.945 - 00:01:12.385, Speaker A: So you can rank all the things you would like to see and it will basically run an election every time I'm allowed to run a stream. And that way we can sort of collectively decide what we're going to work on next. The current winner is that we're going to port Flame Graph to Rust. So Flame Graph is a code profiling tool that gives you things like this for your code, saying like, oh, this is where you're spending your time, this is where your program is spending its time. And we're going to take the tool that generates these things and try to port it to Rust. And that's going to be a little bit different from any of the streams we've done in the past, because the past streams have often been sort of focused on async computation and that kind of stuff. Whereas this is going to be much more straightforward, like basically writing a program doing like parsing and performance analysis.
00:01:12.385 - 00:01:51.707, Speaker A: So it'll be very different from the past streams, but I think it'll be interesting. I don't know what the next thing will be. At some point I will mark this as being completed and then the algorithm is going to run another election and we'll find out what all of you want the next stream to be. All the recordings for past streams are up on YouTube, so if you're ever like, if you're watching this live and you didn't know they were recorded, then they are recorded. They're all here. Most of them are under the Rust Live Coding, the Rust Live Coding playlist. I'm also running a class at MIT at the moment called Hacker Tools together with Jose and Anish.
00:01:51.707 - 00:02:32.025, Speaker A: And we're basically doing sort of walkthroughs of how to use your computer more efficiently, like how to set up programming environments, how to use editors, version control, all of that stuff. These lectures will all be video recorded and posted online, so I will probably link to those either from Twitter or from my YouTube account at some point. Just so you're aware that those will be coming. They will not be under Rust Live Coding, of course. One thing I wanted to mention before we start is I've gotten a bunch of emails from people and Twitter messages and such where people Ask sort of what was a good project for me to start working on if I just. I want to use Rust, but I don't know what to build. So.
00:02:32.025 - 00:03:03.595, Speaker A: D. Talnay releases repository a little while ago called Request for implementation and it's pretty neat. It's basically a list of things that they wish existed and you can submit more if you want. But most of them are intended to be small, well defined, not really research project. Sure, I can do that. They're not really supposed to be research projects or anything. Just like things that are well defined in scope, small, easy to implement.
00:03:03.595 - 00:03:45.655, Speaker A: And so these are really good starting point for if you want to build something on your own channel. No dashboard category, I'm guessing there's not a programming fine. Science and technology, huh? Great programming, Great. Rust, no. All right, great. It's now in the science technology category. Great.
00:03:45.655 - 00:04:20.905, Speaker A: But yeah, so this is a really cool place to look at things. Most of them have a design as well for how you might implement it. And so you should really go in here and take a look if you're looking for projects to start up on. The other thing is, if you're looking for something larger, like if you've already written some programs and you want to have an impact or however you want to define that. I have a bunch of crates that I have built up through the years. Some of them I maintained, some of them I sort of built and now I'm not really doing much with them. And so these are either listed as passively maintained or looking for maintainer.
00:04:20.905 - 00:04:49.335, Speaker A: And so if you go to crates IO and you go to my user, take a look and you probably want to sort by recent downloads because that will show you the most active crates. If you see anything here where you're like, that's cool, I want to help maintain that, like reach out because I totally want more maintainers for these projects. Fantastic. For example, I would love to have more maintainers for. For the next live coding session. That's fine. So yeah, if you want something bigger to maintain, take a look here and see if there's anything that you fancy.
00:04:49.335 - 00:05:15.813, Speaker A: So that's those. So if. Are there any questions before we start dealing with Flipgraph? Because that's the next thing we're going to do. Nope. Great. Okay, so Flame graphs. It turns out that when you're writing any kind of performance sensitive software, very often you want to figure out why your program is as fast or slow as it is.
00:05:15.813 - 00:05:40.835, Speaker A: And normally the way you do this is. Well, there are lots of tools to do this. One of the most common ones is one called Perf. And so what PERF will do. In fact, I can show you here. Is that font large enough? I think it probably should be, but I'll make it a little bit larger. So now I'm on a remote machine that has Noria, one of the research projects I'm working on, and I'm going to run a benchmark.
00:05:40.835 - 00:06:14.859, Speaker A: Now I'll make it run a little bit shorter, just for exposition. So this is going to run a benchmark. If I ssh to this machine, you'll see that it's really busy, it's doing a lot of work, and so we're just gonna let that run for a little bit. You forgot to click Update. Damn it. Did I? Let's try that again while the benchmark is running in the background. Anyway, you are totally right.
00:06:14.859 - 00:06:38.609, Speaker A: I did forget to click Update. Programming and also probably software development. English. Sure, let's try that again. Right. So when I run this benchmark, it generates results and say, hey, this is how well I did. And this doesn't really tell me anything about what was slow and what was fast.
00:06:38.609 - 00:07:15.135, Speaker A: Like what was my CPU doing so that all of the eight cores of this machine were totally busy. Well, this is where PERF comes in. So PERF has a bunch of different commands that are useful. Perf stat. If you run PERF stat, it will occasionally print information about the process that's running and sort of tell you apparently did not want to do that, Sorry. When it finishes on YouTube, the video is a bit pixelated on and off. That's interesting.
00:07:15.135 - 00:07:46.325, Speaker A: Well, I don't know what that is. Um, let's see. It seems to be sending a full 1080p stream, so I'm not entirely sure. Bitrate 2400. Well, everything seems fine as far as I can tell from here. Maybe my WI fi is acting up. I guess what I'll do then the recording should be 1080p anyway.
00:07:46.325 - 00:08:43.979, Speaker A: So what I'll do is just increase the screen size a little and then hopefully the pixelation isn't too bad. How's that? Is that somewhat readable? Okay, so notice that I ran this command with PERF stat. And what that does is after the program is finished running, it tells me a bunch of of sort of interesting stats about my program. Like how how much time it spent executing cycles, how efficient the execution was, how many times to switch between threads, that kind of stuff, how many branch mission misses. Lots of information that may be useful in performance debugging, but this still doesn't really help tell me anything about what in the code that I wrote, which is like, there's like 60,000 lines of code in this project. Like, where am I spending my time? Well, for that there is Perf Record. Perfrecord is going to sample your program every so often and basically check where your program is.
00:08:43.979 - 00:09:41.105, Speaker A: Like, it sort of stops the CPU and asks it, what are you currently executing? And then if you sample this lots and lots of times over the execution of a program, you learn which places are hot places in your code, and those are the things that are executed more often and where you're spending most of your time. Top level stats. They're aggregated over all threads, the entire execution of the program. So perf Record is going to sample throughout the execution and then afterwards give you basically information about where the CPU is spending the most time. Now you probably want to include G, which basically, in addition to asking where it is, it also keeps track of the call stack. So you don't just learn that a bunch of time was spent in hashmap get, but you learned that it was hashmap get, which was called from somewhere else to keep sort of the call graph. You often also want to include call graph dwarf.
00:09:41.105 - 00:10:22.185, Speaker A: So this uses the dwarf debugging symbols, which gives you a lot more information about the names of functions and basically gives you a more precise call graph, but also causes you to generate much larger things. So let's run with just dash G first to see what it looks like. So now it's going to run my program. It does come with a little bit of CPU overhead, but just to show you why this matters. So this is going to execute for like 20 seconds or so. And what it does is it produces a file called perf data. So once this finishes, great.
00:10:22.185 - 00:10:46.425, Speaker A: So you see perf report here says it was woken up a bunch of times to write Data. It wrote 42 megabytes of PERF data. And so there's now a file called perf data in my current folder. And if I do perf report, then perf report parses that file and prints out. This is where time was spent. And then I can sort of expand. Like, for example, a bunch of time was spent in future.
00:10:46.425 - 00:11:27.957, Speaker A: Yes. You see here there's like a lot of things that I can't really dive in deeper into. Like the call stack is there, but it sort of seems to stop at weird points. And this is one of the. One of the drawbacks of not using dwarf information is often you don't get the backtraces you get, especially for complicated programs, aren't just all that good. So we're going to record with Call Graph DW and that's going to record a lot more information about what's currently going on at each sample. The result is that it's a little bit higher performance overhead when benchmarking or when recording.
00:11:27.957 - 00:11:55.265, Speaker A: And also the file ends up being a lot larger because there's a lot more information in it. So you saw the previous file was 42 megabytes, had 622,000 samples. Here, this generated a 4 gigabyte file with 506,000 samples. So fewer samples and significantly more data. But if I now run port for port, I think that's G's default, but we'll see. So now that's annoying. There's a.
00:11:55.265 - 00:12:23.319, Speaker A: There's a bug in Perf on my particular kernel that sometimes means that PERF can't read the file. When you include Dwarf, that's a little unfortunate. I don't know if I have a way to work around that. That's really annoying. Yes. You notice Dwarf produces a lot more data and if we're lucky. We were not lucky.
00:12:23.319 - 00:12:53.379, Speaker A: Fine, let's run it for shorter and see if that helps. But what, what this would give you if it did in fact run is basically a. It gives you a better view of here maybe. So this was a runtime of 10 seconds. It still generated about 2 gigabytes of data. I thought this was already fixed, but apparently not. It gives you a better call graph.
00:12:53.379 - 00:13:24.165, Speaker A: And that call graph that you saw me navigate earlier is really handy, but it's kind of hard to parse because it's given you as a. It's. It gives. It's giving you a sort of just list that you have to walk sorted by how. How frequently some top level function was called. Let's see if this might fix it. It's going to be its own kind of annoying, isn't it? Fine, let's try it, see what happens.
00:13:24.165 - 00:13:58.121, Speaker A: But what Flame Graph lets you do is take the output of a perf report and then generate this. So notice at the bottom, this is sort of the entry point to your program. And then it says like, called this function, called this function, this function, called that function, this function, called these three functions, this function, called this function, etc. All the way up. And it lets you inspect visually really nicely where time is spent. In particular, you can look for things that are wide and they spent a lot of time of the overall compute. And then you can zoom in by saying like I want to look at this function.
00:13:58.121 - 00:14:30.615, Speaker A: Okay, so this function called these functions and so most of the time was spent in this particular function. And so it's a really nice way to sort of dig through visually the performance of your program. I'll just let that run in the background. That's fine. There's a question. Woken up end times means that it also sampled the execution state that many times? No, so perfectly samples very frequently. But if you notice the message it gives is woken up that many times to write data.
00:14:30.615 - 00:15:15.885, Speaker A: So if it tried to write to file every time it sampled, it would be far too slow. And so instead it only occasionally. Oh man, that's annoying. So it will only occasionally write to basically flush out the memory contents. It's a little annoying that I had to do this, but it might not even be fixed upstream. So Flame Graph is written by a guy called Brendan Gregg and it has support for. Basically it's a two step program where the first thing you do is take the output of some tool that generates profiling information and create what's called a fold file.
00:15:15.885 - 00:16:08.373, Speaker A: So it basically keeps information about which functions called which functions in a sort of not standardized format, but in a format that the Flame Graph binary understands. So it's basically a translation process where you can take output from many different profiling tools and produce the same file and then use Flame Graph to produce an image of that file. No, I don't do that and apparently I have to do this. Okay, fine, not important. We'll let that work in the background. So for the way you would actually use this program is if you have some perf data file you would run perf script and then you would pipe it through stack collapse. Perf.
00:16:08.373 - 00:16:34.217, Speaker A: Right. So stack collapse is one of these programs, specifically the one that's built for perf. Perf script produces a textual version of your. The recorded samples that are basically that are guaranteed to be in a format that's somewhat reasonable to parse. And then stack left Perfs is going to produce that fold file. Let's ignore the all flag. And then you would pipe that through Flame Graph which, which is going to produce the final.
00:16:34.217 - 00:17:06.517, Speaker A: Like flame.svg. perf is Linux only on other systems you can use dtrace. Yeah, exactly. So this is why it's divided into like it supports multiple input formats because Perf is a Linux only tool. But you can use other tools like D Trace and I think there's a D Trace. I can't see it now, but there's also BPF Trace which is really really handy. So whatever kind of profiling information you have, there's probably a stack collapse tool for it that will produce the appropriate fold file.
00:17:06.517 - 00:17:42.729, Speaker A: And so the pipeline looks a little bit like this. You take the output of your profiling, stick it through a stack collapse program, pipe it through Flame Graph, and that generates your image. And of course, you can edit GDB for everyone, sort of. Although it's not really gdb because GDB lets you do debugging, but it doesn't really let you do profiling. Like you sort of can do profiling with it, but it's not really what it's intended for. In any case, this is sort of the pipeline. And in this stream we're going to focus on perf, because I think it's not realistic for us to port all the stack collapse things in one go.
00:17:42.729 - 00:18:49.489, Speaker A: And so what we're aiming to do is to port both Stack lapse perf and Flame Graph so that we can basically run this pipeline and have that work correctly. What I'm going to do is I'm going to take the perf script from the Noria run and store it in a file just so we can operate on that. Because it's large enough, the four gigabytes you saw is large enough that the existing stack collapse actually takes a while to run. So hopefully if this machine comes back online at some point, then what I'll do is I'll measure how quickly stack collapse perf runs and then we'll try to compare that to how fast the Rust version will be if we manage to get it working in the time that we have. No, let's do perf record again on this. Who knows whether that'll work? It's basically I just want a perf script file. I could also benchmark some other program locally, but it's handy to have something that.
00:18:49.489 - 00:19:26.775, Speaker A: Right, so this is a 2 gigabyte file, so that is hopefully at least. Come on, come on, come on. Please work. No, Fine. I wonder why it's being difficult about this, but fine. So in that case, what we'll just do is we'll just record without dwarf information and just record it running for longer, just so we have a decently big file to work on. It's not terribly important what the contents of this file is, as long as it's large enough that we can benchmark it.
00:19:26.775 - 00:19:55.265, Speaker A: Another cool version of the Flame Graph tool. Oh, yeah, there are a couple of other things, like stackviz, I think, is the name of one. Maybe that's the one that was Linked in chat this one and they're all like pretty much the same. I don't know if there's a demo image of this. Yeah, here. Right, so generate. Ooh, that's not great.
00:19:55.265 - 00:20:28.471, Speaker A: But yeah, there are other tools that do the same thing. So the programs we're going to port are stackcollapse, Perfect and Flame Graph. They're currently both written in Perl. So in theory it shouldn't be that hard to produce a program that has higher performance. It does mean that we sort of have to understand what, what is in perf script. And so we, we have two options here. Either we could just start reading the output of per script and figure out how to parse it, or we could take advantage of the fact that someone has already done that work and all we really need to do is port this file.
00:20:28.471 - 00:21:08.595, Speaker A: I'm going to go with the latter because trying to parse perf script on our own, we're probably going to run into really weird cases. But let's take a look at the help pages least. So let's see perf script. Let's see what the default is. Uh huh. The question is what perf script outputs. So as with all previous streams, I have not looked at these in advance because I think it's more interesting for us all to figure them out at the same time.
00:21:08.595 - 00:21:58.825, Speaker A: Comma separated list of fields to print. So that sort of sounds like it's almost generating a CSV for us. In fact, I wonder for this parses of multiline stacks generated by PerfScript. And now it's a semicolon separated stack followed by a space and a count. If memory addresses are present, they're stripped. Interesting. Should include stack traces.
00:21:58.825 - 00:22:48.629, Speaker A: Oh, this is another thing that's important. So this is CD CDDL licensed, which does mean that I'm not entirely sure it. I looked up this license a little bit and I think the idea is that we basically have to open source the end result and we probably have to use CDDL when porting because technically it is a modification of the original source. I'm not terribly bothered by that. So as you see, stack collapse perf is not that large. I'm just trying to see how it parses the inputs that it gets. Okay, so it looks like there's some line in perf script.
00:22:48.629 - 00:23:33.295, Speaker A: Okay, so if you haven't read Perl before, Pearl has a lot of like special arguments or special variables. So $underscore, for example is the current line. So this is basically iterating over the all the lines of the input, this is matching the current line against that regex. So this is saying starts with a pound and then followed by command line. So this suggests to me that there's some line in the, in the script that. That contains the name of the program that was run. Skip comments, ignore filtered samples so what is P name here? Target P name.
00:23:33.295 - 00:24:00.477, Speaker A: Oh, right. This lets you. So it sounds like there's a way to say that you want to filter. Yeah, event filter, probably. Okay. And then it's parsing out event records and those are space separated. Okay.
00:24:00.477 - 00:24:47.115, Speaker A: So it sounds like for this we can actually just use the rust split split white space method on strings to parse out these fields. Okay. And then it's matching the line against whatever up to colon followed by non space up to colon. Okay. So it's parsing out this part of the line. So this regex is anything that one or more of anything that's not a space followed by a colon followed by any amount of white space followed by the end of the line. So that's parsing out this word, the last word on those lines.
00:24:47.115 - 00:25:18.385, Speaker A: Right. And then it's doing event filtering. Okay. So it looks like there are a couple of different types of lines. So if you look at the example that's further up here, where's the example input here? So there are some lines that look like this and there are some lines that look like this. And I think each of these is an event. And then this is the stack when that event happened is the way I read this as.
00:25:18.385 - 00:25:56.195, Speaker A: And so this is why in the example output, what this is saying is when this event. So I guess swapper is the current location. And then notice that it's producing a semicolon separated list of the stack at that event followed by a space followed by the number of events with this stack. I think that's basically what it's counting. And so that's why here it's parsing out. This is the lines that look like that. So that's the one that had swapper earlier.
00:25:56.195 - 00:26:12.185, Speaker A: So we're parsing out those here. Otherwise it's a stack. Right. So it's a stack line, which is not the. Not the start of an event. So that would be. This is an event line and this is a stack line.
00:26:12.185 - 00:26:37.515, Speaker A: And so a stack line. I sort of want to see the stack line down here. Oh, well, any amount of spaces. Anything that is just ASCII characters basically. Spaces. Anything. Oh, this is a weird reg ex.
00:26:37.515 - 00:27:12.969, Speaker A: I feel like we could probably do better than a regex here. Worst case, we could also parse this with the regex crate and use the same reg exes because my assumption is that these have actually been battle tested. What caused an event to get in? Perfect. So Perf can run in a bunch of different modes. Usually your CPU has built in support for event sampling. Basically you can tell the CPU to like sample at certain rates or when certain events happen and basically ping you as some external process and say this thing happened. So an event is just like the program.
00:27:12.969 - 00:27:51.815, Speaker A: The basically perf decided to sample the program at this time and there are a bunch of different types of events. So that's what this business is. So this is the kind of event that triggered the sample, sort of. I recommend that you take a look at Perf help record. It explains all these different event types and it specifically explains the ones that are available on your machine. Okay, so this is parsing out the line, stripping out symbol offsets. Show inline.
00:27:51.815 - 00:28:15.025, Speaker A: Okay, so inline, I think is with certain debug symbols. There are some pieces. There are some functions in your code that might not be treated as separate functions. So they don't really get their own stack line because their code is just folded into whoever called them. But I think you can extract that inline information. I'm guessing that's what this is about. I guess we'll see when we start parsing.
00:28:15.025 - 00:28:58.355, Speaker A: Reminds you of ebpf? Yeah, EBPF is basically not quite inspired by perf, but it is a strictly more general thing for event sampling in the kernel. Splits by arrow. Why split by arrow? There is no arrow in the stack lines. Oh, in raw funk. Interesting. I guess we'll figure out what that means. Oh, this is probably for.
00:28:58.355 - 00:29:40.261, Speaker A: So the name of functions that are included in the debug information is going to depend a little bit on the language you're using. So for example, in. If you're sampling a Java program, it might actually give you the sort of module path as well. And so I think what this is trying to parse out is the. The module name of the function so that you can say, so you can sample. You can sort of highlight things that are modules separate from things that are functions by basically by trying to parse the function name that's given out. And there's some tidying up of generic names.
00:29:40.261 - 00:30:24.031, Speaker A: So often the debug symbols are going to generate names that are sort of obfuscated. Now there are actually tools for doing this. What's the one in Rust? I think Fitzgen wrote this debug function name mangled. I think it's called. That's the one via fishgen. Yeah, I was right. So CPP Demangle basically demangles symbol names.
00:30:24.031 - 00:30:46.551, Speaker A: So it might be that we end up using that to tidy up these names. Right. So tidy, Generic tidy. Java detect things that are inline or kernel things. Okay. So it looks like it's basically just parsing out events and stack lines, so that shouldn't be too bad. Let's look at whether we actually ended up with some samples here.
00:30:46.551 - 00:31:12.183, Speaker A: Okay, so this is now 160 megabytes of perf data. Look at the report and see what we got. Right. So this gave us a bunch of samples. It is a little sad that all the. That these are all weird. I wish we could get this dwarf, but I guess we'll have to make do for now.
00:31:12.183 - 00:31:55.207, Speaker A: So I'm going to stick this in a file. Let's see how long it takes to do that. Pv. So PV is a really handy command line tool for measuring how fast something for measuring how fast something is consuming data. So this here, for example, I can do perf script. Pipe PV to like perf data script. So it basically measures the throughput.
00:31:55.207 - 00:32:39.625, Speaker A: So notice the perf script actually takes a while to run because it has to parse the perf data file and produce this other format that we're looking for. And so you notice it can do about 80 megabyte megabytes per second. And then I'm going to steal that file. We're going to do cargo new bin. What are we going to call this? So Flame graph is the original. What's a rusty name for flame graph? Rust catch fire. Is there a way to make, like, actual rust catch fire using some kind of chemical reaction? Because that would be kind of fun.
00:32:39.625 - 00:33:08.115, Speaker A: Chemical. Does Rust catch fire? That's not what I meant. Mmm, maybe not. Oh, thermite is good. I feel like there's already a thermite crate. Thermite is good, though. Experimenting with a toy browser engine.
00:33:08.115 - 00:33:39.705, Speaker A: We're gonna go with Thermite. Although it's a little sad that there already is a crate. How busy is this crate? Last updated two years ago. Three years ago. We're gonna go with thermite. I like thermite. Okay, so we're gonna steal this curve data script file and stick it here.
00:33:39.705 - 00:34:27.189, Speaker A: Don't you need to recompile your binary to include dwarf metadata? Yes. So in my cargo toml, by default, Rust will compile in debug symbols and debug mode and not debug symbols in release mode. However, in this Particular project, I've set that in release mode. It should always build with debug information. So debug information is always included with this particular program. And so you'll notice the perf script file actually ends up being fairly large because the perf data file is a binary format, whereas perf script is a fire at the amusement park in Rust, Germany. That's pretty funny.
00:34:27.189 - 00:34:55.397, Speaker A: I mean, it's awful. But what was. Okay, what's the Pascal? What's the name of the amusement park? I think that that might be too grotesque. Let's see. I mean, I could also just do this. Oh, I shouldn't have done that. That's gonna take a while to rebuild.
00:34:55.397 - 00:35:36.673, Speaker A: But fine, I guess we're going to rebuild it and try later. Okay, so we now have this perf data script file. And let's just for fun see what happens if I take this. And we really not have PV here either. That's kind of silly. Europa Park. Okay, so now that we have this perf data script, let's pipe it through PV and then pipe it through stack collapse perf to.
00:35:36.673 - 00:36:13.647, Speaker A: I guess, actually. Yeah, and we're going to stick that in perf data folded. Let's see what kind of throughput we're getting here. Okay, so stack collapse perf is giving us what, about 16 megabytes a second? A little bit higher. So this is the Perl version that's in the repository. So notice that parsing this file, which isn't even all that large of a. Of a perf report takes a while.
00:36:13.647 - 00:36:38.775, Speaker A: Right? Inferno. I like Inferno. That's even better. And also if it's not taken, that's perfect. Sorry, Thermite, you're gonna be Inferno instead. Yeah, but there's. Oh, that's why Redox is called Redox.
00:36:38.775 - 00:37:15.671, Speaker A: Rust and burning are known as Redox chemical reactions. That's cool. Okay. No, Inferno is good. What's your dev workload for Noria look like when builds take so long? Builds don't take all that long as long as you don't have to cargo clean, which I just did. Okay, so as we noticed, it took almost 30 seconds to parse this perf data script file. Half a gigabyte large, but it should not take 30 seconds to parse that file.
00:37:15.671 - 00:37:55.483, Speaker A: This is one of the reasons I want to want to. One of the reasons I want to port this to Rust, because I feel like that should be faster. Once you have this folded file, though, notice that that folded file is actually a lot smaller. This is in part because we don't have dwarf debug information and so there are a lot fewer strings in here is also why I'm recompiling this to see if I can get dwarf one. But if we now take. The reason I'm doing this separately is so that I can actually benchmark each of these in isolation. So this is going to generate perf data SVG and this is probably going to be pretty fast.
00:37:55.483 - 00:38:32.655, Speaker A: Yeah, so the. Because the final file is so small, piping it through flame graph doesn't take that long. So it sounds like the thing we want to focus on is the stack collapse perf, which is the thing that's taking a long time. Okay, so let's look at our perf data script file. What we've got here should not have been that, should I? Okay, so it looks pretty much the way it was documented in the file, right? There are a bunch of event samples and for each one there's a stack. So that seems handy. I guess we start by here.
00:38:32.655 - 00:38:56.815, Speaker A: Here script just so we have a reference open. I guess eventually we're going to bring in clap, but for now we're just going to look at standard in. Eventually we're going to want to let the user specify a file. Take standard in whatever. There's a lot of stuff that we can do. But let's start with a very basic I just take a file from standard in. I'm going to write to standard out, nothing else.
00:38:56.815 - 00:39:44.935, Speaker A: So we're going to go look at standard in building Nori eats up all CPU cores for me and hangs PC with Linux. Yeah, that sounds about right. Let's see. So we're gonna here? Sure, why not? I probably also want buff reader. Right. Specifically I want to lock STD in because we don't want to take the lock on every iteration. So STD in is basically synchronized because you don't want multiple threads to read from it from this at the same time because then they'll each get subsets.
00:39:44.935 - 00:40:30.555, Speaker A: But so if you read from standard in just direct, if you just use whatever it is, the thing that you read normally from standard in, it has to take the lock each time. The same is true if you do a print, whereas if you lock it once, then the overhead of reading from it is a lot lower. We're probably going to use a buffreader because it's really inefficient to not use one. Buff reader is basically it keeps a memory buffer that whenever it does a syscall to read from its input instead of reading just like one byte at A time until we get a new line. It reads as much as it can into the buffer and then it looks at the in memory buffer instead. As in particular, what we're going to do is we're going to do. Ooh.
00:40:30.555 - 00:40:55.777, Speaker A: Huh. That's interesting. So this internally uses a buff reader. That seems fine. I mean, we do just want to look at one line at a time, so sure, let's do that. Oh, but that doesn't lock. I see.
00:40:55.777 - 00:41:18.653, Speaker A: No, I do want to keep the lock because we're going to read many, many lines. So like IO reader for files and go. Yeah, it's pretty similar. I'm trying to learn Rust from only having a Python background is pretty complex. That is true. Rust requires you to understand more of the underlying mechanics of what's going on than Python does. But the upshot is that you have a lot more control over the performance of your program if that is something you care about.
00:41:18.653 - 00:41:52.875, Speaker A: I also find that I really like the more expressive type system. It does mean that the compiler is going to stop you from doing things more often, but it does also lead to fewer runtime bugs in your program. So I think it's a worthwhile trade off. If you're reading BuffReader, it locks standard in internally, which is pretty efficient. How can it. If you're using buff reader, it locks standard in internally. How can it do that? It doesn't know that the read it's given is standard in unless it's using specialization.
00:41:52.875 - 00:42:24.721, Speaker A: I'm not sure. In any case, we're going to make this explicit and then we can. We can always tweak it later. So what I'm going to do is we need to have a buff reader. This is the thing we're going to read into. We're going to have a string buffer that we're going to read lines into and then we're going to. So this is going to take STD in like.
00:42:24.721 - 00:43:04.431, Speaker A: So this doesn't need to be mutable. And then if you look at BuffReader down here, it implements. Where do we have buffread? Buffread. So it implements buffread, which is a trait saying that it can basically that it allows you to do certain operations on the stuff that's in memory more efficiently. In particular, what we want here is readline. So we're going to do something like while let. Actually, it's a good question.
00:43:04.431 - 00:43:33.777, Speaker A: I think for now we're just going to do while reader dot read line. We're going to read into the line string. Is buff reader tied to standard in. No, BuffReader is not tied to standard in. That's why we're constructing a buff reader here. With new and explicitly passing in standard in BuffReader can operate over anything that is read and standard in is read. And we're just going to unwrap this for now.
00:43:33.777 - 00:44:15.025, Speaker A: We can do error handling later. So while let we don't even really care about what the the return value here is going to be the number the basically the length of the of the line which I don't think we really care about. Does this include the new line? All bytes up to and including the delimiter will be appended. Okay. So it will include the new line. Great. Let's go.
00:44:15.025 - 00:44:54.621, Speaker A: Good to know. Right. So what we want to do is if you remember from Stack Life Collapse perf if we go back to here oh, this doesn't have any comment at the top which is also a little weird. So that means we don't actually learn what program is running. I wonder why do while let and unwrap at the same time make sense? Yeah, I mean the thing here is we you I guess while requires that you give it a boolean. This does not give me a boolean. It gives me a number.
00:44:54.621 - 00:45:31.875, Speaker A: It gives me the number of bytes read. This lets me match on the thing that reline unwrap returns and so the while let is just always going to be true. This is basically the same as a loop and do this it just happens to be. I think it's a slightly nicer construct. It's also because eventually we're probably going to reconstruct this to be question mark instead and once we do that actually I wonder if main can main return errors yet unstable. I don't remember. Probably not, but it's on its way.
00:45:31.875 - 00:46:09.045, Speaker A: Right. So the things we want to parse out. So this is basically the equivalent loop in Stack Labs. Perfect. It looks for comments and so we're going to do the same thing. If line starts with ooh, does it take any pattern? Remember we go up here. I feel like the the expansion state of things is never what I want in in Rust code in the Rust documentation.
00:46:09.045 - 00:46:43.987, Speaker A: I feel like I always want block I want the default I want is this like all the method blocks are expanded so I can see all the methods but I don't want any of the docs it can return if they implement debug. That might be true. Yeah. Normally I would while let on the result. The reason I don't make this while it okay is because we would just Silently drop the error. Which I don't want to do is some can do the trick. That's true.
00:46:43.987 - 00:46:57.851, Speaker A: But then we would also just drop the error. It would actually be. Is okay. You're supposed to be careful with unwrap. Yeah. So you are totally right. This is not the way you would normally write this code.
00:46:57.851 - 00:47:24.525, Speaker A: I'm only writing this to prototype. The way you would probably write this file is something like operate on and it takes a buffreader and returns a IO results. Nothing. And then we would do like inside here. We would do this. In fact. Sure.
00:47:24.525 - 00:47:43.307, Speaker A: We can just do it now. It's not. Not terribly important. Right. And then you would do this where question mark would return to main and this would just call operate on our this. Right. So this is the nicer way to do it.
00:47:43.307 - 00:48:07.885, Speaker A: And then now in main you could unwrap or you could print a mirror a message on the error. So the only reason I'm not doing that right now is because for. For the time being I think it will only complicate the code. But you are right that that is the correct thing to do and what we will do eventually. You can return errors from main on stable. Just tried it yesterday. I don't know, maybe my stable is old.
00:48:07.885 - 00:48:26.541, Speaker A: I don't think it is. Why not? And then we can't use and then here because. Well, because we want the loop. We need the loop here. So there's no. There's nothing to and then. Right.
00:48:26.541 - 00:48:58.357, Speaker A: We don't specifically here we don't care about the result. I could and then to map it to a boolean but that just doesn't seem worth it. All right, so we're going to say that the line starts with a pound. Then we're going to continue just going to ignore anything that's a comment for now. Similar to what this does. Although notice that there is this business where we might want to parse things our command line. But for now we don't know what those are.
00:48:58.357 - 00:49:24.631, Speaker A: So. And we don't see them in our file. So we're just going to ignore them. This is saying that if we encounter an empty line then something has to happen. Right? So there's going to be something where we're over time we're accumulating a stack, right. And once we reach an empty line, that means that the event the stack has ended when we're about to encounter a new event. And in that case we probably want to save whatever stack we're currently on.
00:49:24.631 - 00:50:19.919, Speaker A: So notice this is where it. It sort of adds this Keeps track of the stack that it's accumulated so far. So while we're doing this counting, it's probably going to be something like occurrences, which is going to be a hash map. And if line is empty, well, I guess actually trim end because we have to trim the new line. Is there even a trim? I think there might be a trim. You may need to return results. Yeah, I may have to make main return results.
00:50:19.919 - 00:50:53.246, Speaker A: It's true. And yes, the unwrap will panic in the case of error. That is totally true. We will get back to error handling, I promise. Okay, so this is saying that if the line is empty modulo a new line, then we're going to like. So we're going to have to keep track of like the current stack and the current stack is going to be like a vec. And here we're going to say occurrences.entry
00:50:53.246 - 00:51:30.633, Speaker A: stack. Join semicolon. Or insert zero that plus equals one. So this is pretty funky. Occurrences Occurrence. Great. So if you haven't seen this entry API before, it is really neat.
00:51:30.633 - 00:52:09.725, Speaker A: So occurrences here is a hashmap entry. You give a key and if the key already existed in the map, then it gives you back basically a reference to the current value. Otherwise it gives you back basically a pointer to the empty slot. And then you can do or insert, which is if it was a pointer to the empty slot, put the following value in there and give me a pointer to the value. And so after we've done this, what we have is a pointer to the value, no matter whether it existed before or not. And then I'm saying now I want to plus equal that value. Might not even need the star unclear.
00:52:09.725 - 00:52:46.691, Speaker A: So that's kind of neat. And then we want to stack all clear, right? Because every time we finish a stack, then we don't want to keep adding to that stack as we move on to later entries. So we're going to clear the stack and then we're going to continue. So this is basically the same as this business. I don't know what this P name is. We need to figure out what P name means, but we're going to just sort of ignore that. And I guess here we're only going to do that.
00:52:46.691 - 00:53:16.835, Speaker A: If not stack is empty, what is these links or the. Oh yeah, great. The links in the chat show up on a blue background with a blue text. It's very unhelpful. It's probably process name. I agree. I guess we'll get back to it when we parse later.
00:53:16.835 - 00:53:57.245, Speaker A: Okay, so let's Leave some comments for ourselves. So first this is end of stack frame or end of stack. So emit stack entry. So this counter is just going to keep track of how many times we've seen a particular stack. And then down here, one of two types of line are possible. Event line start. Either we have an event line, like so.
00:53:57.245 - 00:55:22.155, Speaker A: And then let's give an example of some event lines. I guess we could probably give these. Either we have an event line which. Or we have a stack line and the stack lines. Let's take the examples from up here and let's also include some examples from our own file just so that we have them for later reference. And let's also steal like one of these. I think I want these to be indented.
00:55:22.155 - 00:55:55.625, Speaker A: I think that looks nicer. So this is just sort of for our own. For our own purposes. Later this will be easier to keep track of. Oh yeah, vim commands are really handy. There's a. As I mentioned earlier, we're doing a lecture series at MIT currently on hacker tools and that includes things like editors learning.
00:55:55.625 - 00:56:43.455, Speaker A: Vim commands is super handy. Someone mentioned in a YouTube comment that we should do I should basically enable screen caps so that you can see all the keys I press. I figure it's. It would probably be mostly noise, so I don't want to turn it on. But I might do one stream where I have it on just so people can see. Or we have a stack line that is a part that shows one line of the one stack entry from the preceding event. Either we have an event.
00:56:43.455 - 00:57:14.435, Speaker A: All right, so how do we know whether it's an event? He parsed it like this. I guess I don't have a good sense for how to parse the difference between these. I think I actually want to do it things a little bit differently. We know that either we are in an event or we're not. So what we're going to do is this in event is false. And then we're going to say instead of just seeing whether the line matches if we're in an event. If we're.
00:57:14.435 - 00:57:56.195, Speaker A: Sorry, if we're not in an event, then we must be about to enter an event. Otherwise move this into here. So if we're not in an event, then we are now in an event is true. And then whenever the event finishes, then we are no longer in an event. I think this is a more robust way of doing it. I can't find the docs for Vector join. It's not on vec, it's on slice where the type is String, I think.
00:57:56.195 - 00:58:52.859, Speaker A: Or I'm just like misremembering. Okay, so if we have an event, then we know what's the way that he parses it. Oh, that's such an interesting way to parse this. You get it on vector dref? Yeah, I think that's true. Okay, so what is it we care about here? What's com. Actually, let's have a look at. Oh, actually this is finished now.
00:58:52.859 - 00:59:57.165, Speaker A: Let's just try to record that with callgraph morph again. Let's do per help script and see what it says. Fields options are those things. Does it say what the default is? Huh? These are the fields. That's fine. Oh, that's so unhelpful. Why is it not saying what these are? Might be in record.
00:59:57.165 - 01:00:52.165, Speaker A: No Per health. Per health report. Aha. Com means command name of the task. So this is probably the name of the thread would be my guess. I do wish that this would say what the default was. Why does it not say what the default script is? That's very unfortunate.
01:00:52.165 - 01:02:05.045, Speaker A: Although here, I guess this is the default per script. Default fields, huh? Well, that's kind of unhelpful. Well, I guess. When in doubt. When in doubt, look at the source code. Where is the source code? This one really there? And where do we want to go? Tools perf built in script fields. Huh.
01:02:05.045 - 01:02:47.081, Speaker A: Are these the same? IP SIM offset, DSO period. That includes output. Okay, so the first fields are always the same. Oh no, those are just the available fields. It's not the default fields. So what are the default fields? Let's search for this. Uh huh.
01:02:47.081 - 01:03:20.875, Speaker A: Uh huh. Hmm. Maybe it's not even declared here what the defaults are. No, they're only used there casual kernel of code hunting. Yeah, I know, right? I wonder if this is just the default. The default is all fields. I wonder.
01:03:20.875 - 01:04:25.175, Speaker A: But that's a little weird because if you remember back to this file, in this case the assumption is that whatever is lost is the is the event that occurred. But that's not the case here, right? Event name is there not anywhere else? I wonder. So parse output fields. So look at that. What is default? How do I find default fault? Oh no. Oh, I see. Okay, fine.
01:04:25.175 - 01:04:53.945, Speaker A: Uh huh. Parse. Okay. Oh, this is awful. Argument parsing directly by string comparison. Great. So where does it see no fields requested.
01:04:53.945 - 01:05:47.835, Speaker A: Okay, so where does it decide? So this is parsing the stuff that follows E. So I guess the question is where is this called from? Call trace valid types fields. It doesn't say what the defaults are. Huh. Command script. Here we go. Yeah, those are the fields.
01:05:47.835 - 01:06:30.077, Speaker A: That's fine. Uh huh. Set up scripting Sub command has required args forks to do some stuff. Sample type. Aha. I wonder. So I wonder where it decides to print.
01:06:30.077 - 01:07:09.175, Speaker A: That's really the output type. Max if output. Okay, where does output come from? Field to string? I think that the default is not well defined. I think the default like depends on whether you say you want hardware or software stuff. I think it really is just this. It's just this list of fields and so therefore feel like this is wrong. I feel like this is assuming that you did.
01:07:09.175 - 01:07:38.985, Speaker A: I don't even know, like trace points maybe. I guess we could just look at the output we got. So the output we got has calm pid. This is the tid. So let's see if that matches any of these com TID cpu. Sure, that's probably CPU time. I can buy that.
01:07:38.985 - 01:08:04.789, Speaker A: Output time. No, not output time. Well maybe actually maybe this is CPU and this is output time. No event name. Oh, maybe this is output time. Sure. It does seem to be monotonically increasing.
01:08:04.789 - 01:08:37.998, Speaker A: Okay, sure. So that is output time then. And this is the event name. Okay, let's go with that. And then we can adjust it later. Right. So that means then what we're going to do over here is we're going to do line split whitespace fields.
01:08:37.998 - 01:09:06.960, Speaker A: It's going to be that. And we know that the first field is going to be column and again we're going to unwrap later we're going to not do that and instead probably probably just skip the line. So we'll probably have a function that's like parse line. We might guess the next thing was tid. It's going to be fields.next.unwrap. and we're going to parse the T ID as a number. Probably may not even care.
01:09:06.960 - 01:09:50.589, Speaker A: In fact, is the TID even important? Do we need the TID for anything? See here he parses out TID by this. This is why this parsing becomes pretty important. So it's any string. This non greedy match is tripping me up though. So it's any string without a white space followed by any amount of characters maybe followed by some spaces followed by a number. Because parsing everything up to the first number so it's not really split by white space. Right.
01:09:50.589 - 01:10:24.309, Speaker A: This for example, this thing is still the column. That's good to know. Oh, it's the slash. It's the slash that does it. Right. I'm just going to trust that this guy figured out what was going on. So in that case, let's undo that and instead say, sure, let's bring in the regex crate.
01:10:24.309 - 01:11:08.245, Speaker A: I'm going to assume that this regex is correct and then take it from there, probably. So in that case, let's switch over to Cargo tunnel and do regex 1.0 and we're going to do match line. It's going to be regex regex new. It's going to be this one. What? No further check. So that's going to be ma, I guess match event line.
01:11:08.245 - 01:11:46.495, Speaker A: And then we're going to have this as match stack line. I still don't believe that that's true. Feel like these should be easier to parse than that. But fine. So matching a stack line is going to be like this. Oh, that's fine. And then we're going to say here, what's the.
01:11:46.495 - 01:12:14.925, Speaker A: Oh, that's right. No, you're totally right. The Regis crate does not require the slashes. Good catch. Oh, and I also need to unwrap them. Well, you know, error handling. And then I guess what I want is captures.
01:12:14.925 - 01:13:03.955, Speaker A: Not quite captures actually I want just a single capture. Where's the here reg ex. And then I want. I think it's find. No, it's not find captures. Yeah, that's what I want. So if we're in an event, then we're going to match on match event line dot captures on the line.
01:13:03.955 - 01:13:44.605, Speaker A: Actually online dot trim end because it buff read includes the new line F12. What do you mean by F12? Right. So we're going to match on that and if it matches, then we're going to get the captures. Or I guess we could call that fields. If it does not match, then something is really weird. But we're just going to continue. We're going to say that we're not in an event after all, that this was just a unexpected line, I guess.
01:13:44.605 - 01:14:14.589, Speaker A: Unexpected line. And then we're going to print what that line was. Question mark after the plus makes it match lazily instead of greedily. No, I. Oh yeah. I mean question mark is super handy. I just don't understand why it's in that particular match.
01:14:14.589 - 01:14:39.635, Speaker A: That's the weird part. I guess it's because. Okay, so I suspect that the reason it's there is to make sure that you actually. This must be why it's there. It's to make sure you don't match past the first number, which is going to be the tidbit. Right. So you want to match up till the first number, even if this includes spaces.
01:14:39.635 - 01:15:09.497, Speaker A: So that's why it's there. All right, so if we get back fields, then. And notice how straightforward this porting is. Right. Like we're actually just transliterating the code to rust. So we're going to say we're actually going to do so calm is going to be fields dot get. It's 1 indexed, right? 0 is the entire match.
01:15:09.497 - 01:16:19.485, Speaker A: Yeah. And I want it string. And the next thing that comes in is the tid, no pid. And then the tidal and. Ooh, maybe that's a good question. What does captures give you for a capture group that didn't give a match? If the capture group did not participate in the match, then none. So I think that means that we're going to match on fields get 3 and if that is sum, then that is the tid, which means that I guess let pid.
01:16:19.485 - 01:16:44.675, Speaker A: I think you want fields one. No, I specifically want get. This is a captures. Oh, you mean here? I mean if captures implements index, then sure. This one. I know that fields one will always participate. Sure, that's fine here.
01:16:44.675 - 01:17:23.801, Speaker A: I guess what we want is tid PID or pid tid, if you will. If there. If the third field participated, that means that we got a tid, which means that PID is fields two and TID is, well, field three. However, if the third field was not there. So that's basically we're matching on whether there was something following the slush. In this case, this is pid tid. In this case there's only a tid and not a pid.
01:17:23.801 - 01:18:02.795, Speaker A: Right. So three, which is the thing after the slash, did not participate. So we get none. In that case, what we want to return is question mark for the PID and Fields 2 as String as the tidal. So this is equivalent to what's being done over here, where if the TID is none, then set PID to question mark. It also gets rid of the asterisk. Does it? That's handy.
01:18:02.795 - 01:18:27.185, Speaker A: Sure. Then I'm all for it. Great. So we've now parsed out those. And then there's this parsing. This is the business that extracts the event. And this is where I'm very confused as to why it's okay to assume that the event name will always be lost.
01:18:27.185 - 01:19:03.909, Speaker A: But if that's what's being done here, I guess we're just going to assume that that's fine and then we can always tweak it later. So we're going to do match event line event. Any reason for regex versus text IO scan macro. Not really. Never heard of text IO scan macro. But regex is straightforward enough. It's in part actually because the existing code, the one reporting already uses regular expressions.
01:19:03.909 - 01:19:41.795, Speaker A: If text iOS already does that, then that seems fine. Yeah, I don't. I don't particularly mind in either way. Great. So this is if we can match out an event. Okay, so if let match captures. So this means that we did.
01:19:41.795 - 01:20:45.585, Speaker A: We were able to match out the event at the end, then parse out the event which is not really used. Then event is going to be captures one and then there's this like event filtering business which I guess we're gonna just ignore. So here we're gonna do to do filter by event. Great. I guess what did they do? They don't really have this issue. So we're just going to leave it like that. What is MPID and mtid? Why does it keep track of that? Are those used somewhere here? No.
01:20:45.585 - 01:22:14.055, Speaker A: Why this reassignment, I wonder? Because that is assigning to globals, but I don't see those globals being used anywhere else. So why are they globals? I think that must be left over from some old code. Okay, so there's an optional here of whether we include the TID in the output. So I'm going to say here to do make including pid TID an option and then. Oh, I see. This is where the P name is being set, right? So here P name string new so here we're going to set P name is going to be equal to. And I think what we're going to do is we're going to do com replace space with underscore because you can't have spaces and column names in the final output.
01:22:14.055 - 01:22:48.039, Speaker A: Too many fl. What about branch predictions? What about branch predictions? I'm not too concerned about that. The branch predictor is going to be very good at this. This will not be a problem. Also, this will still be probably orders of magnitude faster than the pro code, but we'll see. So we're going to set the P name here. Tostring this tostring is a little sad, but it sort of has to be there, right? So that's basically all of this code.
01:22:48.039 - 01:23:31.625, Speaker A: This is just allowing you to include pid and tid in the basically in the stack frame. What's going to be the root of the stack frame? Is it going to include the process ID and the thread id, or are we going to collapse by thread, collapse by process into just name. In fact, we could also have an option that Says remove the thread name entirely, but for now let's just keep the P name as the column. Great. So that is, if it were an event, then we've now set P name, which is basically the only thing that really matters. And notice here that we're ignoring tidal. So I guess we could.
01:23:31.625 - 01:24:26.021, Speaker A: I guess for now. Actually, I do want the warnings for this to remind us of the To DOS doesn't replace produce a new string? It's a good question. In theory, you might be right. Because in theory. Well, I guess if you have a mutable reference to a string, you can do this transliteration directly. Yeah, that's a good question. No, it does return a string.
01:24:26.021 - 01:24:53.703, Speaker A: You're right. Great. Okay, so now we're at the point where we got a stack line. So for a stack line we're going to use the other match that we have. We're going to do basically the same thing as we did down here. We're going to match on this. I mean, it's going to have to produce a string regardless.
01:24:53.703 - 01:25:22.485, Speaker A: Like that is what we have to store in P name because by the time you move on, the reference isn't going to be okay anymore. So we can't have. We can't have P name be a reference because it would be a reference into the current buffer, which may be reused for later lines. So it does have to be turned into a string regardless. In some sense, I'm happier for a place to do it than for us to have to do it after. Right, so if we. Let's call it fields.
01:25:22.485 - 01:26:04.435, Speaker A: If it does not match, then it's the same thing. We're here. Let's make this weird event line. Weird stock line. What theme is this? Which theme? Oh, my VIM theme. It's one called Atelier Dune. Right, let's see.
01:26:04.435 - 01:26:42.503, Speaker A: So if that matches, then. See, this is where it gets interesting. So the way it filters out events is by not setting P name, but how. Why would pname ever be unset? Filtered samples. Why are they filtered? See, where else pname is used? Is P name ever cleared? Oh, it is. I see. I see what's going on.
01:26:42.503 - 01:27:19.665, Speaker A: Okay, so P name is being used in this sort of weird way where if you're filtering the event, then you. The event line you just skip. And because you skip the event line, P name is going to be unset from where it's cleared at the empty line. And so therefore, by the time you get to the stack line, PNIM is going to be unset. So you're going to know to ignore it. Hmm. Okay.
01:27:19.665 - 01:28:15.135, Speaker A: So the question is, do we want to do it the same way? So it's going to be something like if whatever, then. So we could do it the same way they are of just not setting P name, but in some sense, I don't know that I want to. I guess we could just do P name clear here. That's fine. So in the case where you filter, you just continue and P name is not set. And then down here, I guess it means that we don't even have to match the skip line. So that's going to speed things up a lot if you filter.
01:28:15.135 - 01:28:56.109, Speaker A: So if P name is empty, it's a little weird for that to be empty. I think we. Well, we actually want this. For this to be an option, although that's also a little unfortunate because it means that. So the reason I'm hesitant to make pname an option is because it means that we're going to keep reallocating the string instead of reusing it. But at the same time, I think that's what we end up doing anyway because of the replace. Because in theory, we wouldn't need to allocate a new string here.
01:28:56.109 - 01:29:34.955, Speaker A: So maybe something like reuse existing memory in. Yeah, this could save us a lot of allocations. We're going to split this file into multiple functions and such after a while, just like we're going to do error handling later as well. This is more to get the first place started. We could do a skip event pool. That is true. Yeah.
01:29:34.955 - 01:30:19.765, Speaker A: I mean, at this point I sort of want this to be an enum. It might become an enum at some point. Skip event is false, don't clear P name. And then here it's going to be if the filter matches, then skip event is true. And we want that to reuse the name of possible. Which we can do here. I mean, this is arguably premature optimization.
01:30:19.765 - 01:30:55.259, Speaker A: I wonder if there's a transliterate here. Part of the problem is because translator transliterating characters in strings is a little troublesome in UTF8 because they might actually take up different number of bytes. And so it's not clear that we can just do this, but it would be nice to not have to allocate a new string each time. But for now I'm just going to ignore that. Right. So that would set skip event to true. In general, skip event is going to be false.
01:30:55.259 - 01:31:25.275, Speaker A: And down here, if skip event then continue. Right. I guess this is what's being parsed out from that line. Let's see what we can do about that. So PC. So PC is the program counter. It's basically the address that was on what it made the sample.
01:31:25.275 - 01:32:02.903, Speaker A: So that's going to be field zero. We may want to parse these out as numbers at some point, but it might not matter. RawFunc is going to be Fields 1. So that is the actual function that got called. And module module is the stuff that comes at the end here that tells us in which module does this does this function reside. So kernel call sims means that it lives in the kernel. This is this section of the kernel.
01:32:02.903 - 01:32:31.555, Speaker A: This is this particular library file. And this means I have no idea where that run the unknown. You tend to get if you don't include dwarf debug symbols. For example, like if you try to run perf on a program that doesn't have any debug information in it, most of the things will just be unknown because there's no association between the program counter and like. There's no way to map from program counter to function name. And so all of these are just unknown. Let's see.
01:32:31.555 - 01:33:12.565, Speaker A: Sure. Symbol offsets. Right. So that's these. And I think we just don't care about those Strip off symbol offsets. Trim end matches. Is that what it's called? I think it's three men matches.
01:33:12.565 - 01:34:13.645, Speaker A: Yep. For each character. If the character is. Well, so here's a good question whether we can do this because I think this is given one character at a time. Can I give it an FN mute? Like what interment. What implements pattern pattern is implemented for string searcher? What is a string searcher? See, I feel like this is promising because we basically want to trim everything. Well, we don't want to trim everything to a 0x because you could have a function that contains 0x in theory.
01:34:13.645 - 01:35:11.675, Speaker A: Well, yeah, we specifically need to match on on hex is where it's a little awkward string. Yeah. So we could do this with a regex. That also makes me a little sad. But if trim end matches lets me give a mutable closure, then we can do this pretty easily by saying like all hex this is true. It doesn't even have to be that. Here's what I think we're going to do.
01:35:11.675 - 01:36:37.687, Speaker A: I think the efficient way to do this is look for the last occurrence of plus 0x walk from there to the end of the string and then trim it. Or we just do it with a regex. What do we think? Right. So what I'm thinking is like hex or offset is going to be if let some offset is Raw func dot what is it? Find rfind plus zero x if raw funk. Well, that's another question whether I can say everything from this point onwards. It gets really weird because this is a string, so they're all UTF code points. So I think we're going to do this with a regex going to be.
01:36:37.687 - 01:38:05.525, Speaker A: It's going to be nicer because I don't think I can split this out of character. Oh, I can. So I can say raw funk dot get offset unwrap offset dot dot unwrap. And I sort of want offset, I guess, plus three if end dot cars dot all. I don't really want to assume that it's all ASCII if I can avoid it. Is there a is hex is alpha numeric is too nice. I actually want is ASCII hex digit.
01:38:05.525 - 01:38:59.913, Speaker A: Great. It's a symbol. Then raw func is going to be raw func get offset offset plus three because we want to skip over these characters Specifically, X is not a valid hex character. So we could do this with a reg example. It's like a little bit stupid code, but let's try it and see what happens. We could have it like we are going to have to debug this. Like some things are going to be wrong.
01:38:59.913 - 01:39:46.755, Speaker A: But that's fine. If show inline and module does not match that that to do something about inline I this is probably preserved argument. The get should be just slices. Can't panic here. No, get returns an option in case the character is out of range. Oh, you mean this gets that I should just unwrap it? Maybe, but we don't really need to. So it's fine.
01:39:46.755 - 01:40:36.283, Speaker A: Skip process names. What does that mean? If raw funk dot starts with that's what it's telling us to do +ox position n you may slice it m +3. Yeah, that's what I'm thinking. So what you're saying is unrock here. Oh, sorry, you're right. Yeah. I guess we do know that offset is valid.
01:40:36.283 - 01:41:05.585, Speaker A: I. I guess we do technically know that offset plus 3 is valid too. So fine. It would be very weird if this did not work. So let's do this. Can you slice directly on a string? Probably this. That certainly makes that code a lot nicer.
01:41:05.585 - 01:41:43.521, Speaker A: If I can do that. Okay, and now this is where it like splits the the function name by arrow, which I think is like a Java thing. Did they. Were there any examples from the lines here that had arrow? Not really. I wonder if we look through our file, like, are there any Arrows in here? Not really. I guess here we could actually make it split by double colon. It's a little weird to me.
01:41:43.521 - 01:42:36.995, Speaker A: That arrow is like specifically the thing they're splitting by just not single index. Yeah, I don't know why they're doing this. I don't know why they're splitting by this specifically. That's what's weird to me. But I guess we will. So down here this is sort of walking basically the name, the parts of the names of the function. It's Java Lambdas but it looks a lot like it's not just Java Lambdas because this is being used for other things in Java too.
01:42:36.995 - 01:43:12.065, Speaker A: Although I guess in general like split is going to return just one thing if there's no arrow. Oh yeah, the page. I had to close the Patreon because I'm a. I'm an international student in the US so I'm not allowed to basically have income and so sadly I'm not allowed to have one. Quite unfortunate, but such is life. Thanks though. But we do want this code, right? So this is the thing that's using the module part.
01:43:12.065 - 01:43:53.767, Speaker A: It's like basically trying to. Trying to be smarter about things that are unknown. So if the function is unknown but the module is not unknown, then set the function to be the module and then replace everything up to the first slash with nothing. So module is the file. So that makes the function be just the file name. It's a little weird. Line 89.
01:43:53.767 - 01:44:25.325, Speaker A: Should I? Oh, you're totally right. Good catch. Massage function name to be nicer. I don't like the split so I'm going to ignore the split from now and just say if. If. Don't need that. It seems have something to do with inline functions.
01:44:25.325 - 01:45:05.405, Speaker A: Yeah, I mean this business down here is weird, but notice that none of these have these arrows in them. Even the things that are inlined, even this Java stuff. None of those have these arrows. So where are the arrows? Actually here's what we'll do. Blame and then we'll find. Where's the line? Where's the line? Where's the line? Down here. This inaccurate.
01:45:05.405 - 01:46:24.615, Speaker A: Include the complete inline stack at a code location in the form. Oh, what is hotspot? Hmm, that's interesting. I think this is only for Java code. Like inlining in Java code. Yeah, specifically for perf Java. Okay, that means that I'm just going to ignore that feature for now. Specifically ignoring that.
01:46:24.615 - 01:46:48.271, Speaker A: Oh yeah, the. The pro code isn't. Pearl in general is like not great, but this is not bad. Pearl like this is not at all bad Pearl compared to how bad Pearl can be. So what we're doing is if rawfunc is unknown, I guess we should. Oh, we already have. Great.
01:46:48.271 - 01:48:16.121, Speaker A: So if raw func is unknown and if the module is not unknown, then we're going to set raw func to be module dot. Is there a trim left until. I guess fine. So we're gonna do dot find, slash, unwrap or zero module everything from there and onwards. I guess actually that tostring. No, we don't need that roughness string. Right.
01:48:16.121 - 01:48:54.775, Speaker A: So this is find the first slash, increase the index by 1 if you do find it. So you skip past the slash. Otherwise start from the beginning of the string and give me all the characters. Use module as function name. Use everything following last slash of module as function name. Otherwise RAW func is going to be unknown. This is just stripping off the square brackets.
01:48:54.775 - 01:49:32.685, Speaker A: If include adders, add that adders. This is where we're going to add like command line options and we're going to have a command line option parser and whatnot. Then raw funk is going to be. Oh, that's kind of awkward now. It's going to have to be a string. Oh, sorry, you're right. Rfind.
01:49:32.685 - 01:50:04.765, Speaker A: Good catch. Oh, that's sad. We are changing raw funk to oh, weird. Oh, that's so silly. That's so inefficient. False include. This is going to be to do include adders.
01:50:04.765 - 01:51:05.925, Speaker A: This is like a lot of unnecessary string manipulation. If include adders, then it's going to be unknown followed by oh, I see. That's why they've done it that way because you might get the module. Yeah, I think raw funk is gonna end up being. Or funk is going to end up being a string, which is a little sad. We can make it a cow. I so I think what we're gonna end up doing, we're gonna end up having to do something like this, I guess, just raw fun.
01:51:05.925 - 01:51:57.585, Speaker A: It makes me a little bit sad to not reuse the memory here. Reuse memory of func and same thing here. Actually, we don't even have to do that here. We could do. It's gonna be this. We can do a little bit better. But func is gonna.
01:51:57.585 - 01:52:17.475, Speaker A: Oh, actually no, we can. We can. Yeah. I sort of want func to be. To reuse memory across executions rather than allocate on each. Each run. But let's ignore the allocation for now.
01:52:17.475 - 01:53:20.169, Speaker A: So we're going to instead say let func is going to be equal to this down Here it's going to be format. No, I don't want that. Then it's going to be raw func and PC. Otherwise it's just going to be raw func in square brackets. Otherwise it's just going to be raw func. Can you do match func unknown? I could. Sorry.
01:53:20.169 - 01:54:30.955, Speaker A: This should say module not equals unknown. In fact, one way to do this. Okay, let's see how we would write this with a match. We're going to match on func module and include adders. No, and we're going to say if unknown and unknown, then func is going to be if include adders. So we're going to that if include adders, then it's going to be this. See, the problem here is we're going to have to write out the rule for include adders multiple times.
01:54:30.955 - 01:55:22.435, Speaker A: Well, actually, no, that's not quite true. We could do this then unknown. I guess this. I guess this is sort of what you meant. This is a little bit nicer to read than this. Right. And otherwise raw funk anything to raw func and then let FUNC is going to be.
01:55:22.435 - 01:56:03.375, Speaker A: Get rid of that for now. Well, see, this gets weird too because now we're going to double square bracket. If it already had a square bracket. Right. Whereas the previous code will not do that. It will not add square brackets unless it already was unknown. And in fact it will add square brackets around module being used as function name.
01:56:03.375 - 01:56:58.731, Speaker A: I guess we could do. No, I think I want to keep it the way it was. Even though I agree with you that it's a. It looks a little yucky. Yeah, the problem is it's not really a Boolean table or. Because this happens regardless of which of these happen, but these have to happen first. So if we were to split this into like a binary decision matrix, we would have to repeat this code in each of these branches, which is a little unfortunate.
01:56:58.731 - 01:57:40.603, Speaker A: Whereas if they happen one before the other, then then it's a little bit easier. So I guess here try if we. I think documentation is going to help a little here. Try to use module part of module name as function if. And this is going to be include adders in case indicator. All right, so back to this tidy generic. This tidying business is weird.
01:57:40.603 - 01:58:49.645, Speaker A: So. Right, right, right, right. Yeah, the string manipulation is a little bit sad. So I guess what we're going to do here is this is going to be a bunch of string manipulation str. So is there an inline string replace on string place range? It's not really what I want. I Want to replace that doesn't allocate a new string because replace will. I guess the question is whether there's a thing on stir, but I don't think so because it would have to shift things over.
01:58:49.645 - 01:59:38.115, Speaker A: So my guess would be that the only replace on stir is a thing that returns a new string like this one. Extend index display from pattern. Yeah, I think the only thing we have is. Well, there is this replace range. Oh, the range is a. It's a text range. It's really not what I want either.
01:59:38.115 - 02:00:09.245, Speaker A: A little surprised there isn't one. Although I guess it is because it would have to shift things. Yeah, this makes me kind of sad. This is going to allocate a lot of strings, so I'm not going to optimize this yet. I'm just going to try to write it in the way where it's going to reallocate strings and then we can see if we can optimize it later. So func is going to be func replace. This is technically under if tidy Generic, I guess.
02:00:09.245 - 02:00:55.747, Speaker A: So this is if false, replace any semicolon with colon. Right. And then it's saying if it doesn't match. If it doesn't match. Dot followed by paren followed by dot. Oh yeah. My.
02:00:55.747 - 02:01:36.355, Speaker A: The plan is totally to profile our own tool once it's finished. Interesting. This doesn't look like a go method name. So everything after the first open paren is just noise. I wish there were examples of what this noise is. Let's keep this blame open because some. In some cases it's really handy to link to the commit or look at the commit that introduced that filter here.
02:01:36.355 - 02:02:22.095, Speaker A: I mean, I guess this is similar to the. The business we had further up with. If it starts with a. If it starts with a just an open bracket, then skip it. But that's a particularly unhelpful commit. Let's look at the further back history of that line. Oh, this is what this used to look like.
02:02:22.095 - 02:03:01.915, Speaker A: Oh, that's weird. Flame prior to this change. Okay, so this change, okay, that introduced the splitting. It did not introduce. Oh, just the indentation. That's awful. All right, let's go further back down here.
02:03:01.915 - 02:03:32.645, Speaker A: This file has changed a lot over the years. This business here. Okay, what is this? Yeah, I have. There's another video on my YouTube that where I go through the entire setup. I have. So if you just look at my YouTube channel, other context indicate the beginning of noise. I still don't understand what this noise business is.
02:03:32.645 - 02:04:35.745, Speaker A: So it's not really noise. It's just argument list. Right. So when they say noise, they really just mean cut out all the argument lists. Okay, that's fine. I mean, I guess we can cut that remove argument list. Except if this is a go method name.
02:04:35.745 - 02:06:30.535, Speaker A: This anonymous namespace business is also kind of weird. Where was that here? So anonymous namespace is also something you don't want to remove. Remove argument list from function name but don't remove go method names like that. Let's also link to. Let's be good citizens for other people who might look at R code and link to the appropriate pull requests. The other one here, 93C anonymous namespace annotations. See that? So now how are we actually going to match this? If it doesn't look like that, then substitute.
02:06:30.535 - 02:07:12.585, Speaker A: So what are they replacing? Any parenthesis that doesn't contain just the words anonymous namespace. I see. Yeah, I think regular expression is probably the way to go there. Wonder if these can be combined though with. I think with negative look ahead assertions. You can do this specifically. What we want is as follows.
02:07:12.585 - 02:07:52.451, Speaker A: I guess we're gonna have to do this Tidy stack generic. It's going to be replacing sort of this. But actually let's look at the docs for regex. Look ahead. Oh, lacks. Look around and back references. That's too bad.
02:07:52.451 - 02:08:42.795, Speaker A: So we can't actually do that. Ooh, but does it even support question mark, exclamation mark? It might not even support that. See if there's a. Huh. That's probably just going to say not supported. Huh. Yeah, exactly.
02:08:42.795 - 02:09:11.405, Speaker A: But can I use question mark, exclamation mark. What is that considered? Regex. Look around. Yeah, let's consider it a look ahead. That's awkward. So without that we can't really do it with just a reg X. We're gonna have to.
02:09:11.405 - 02:09:55.145, Speaker A: Man, this tidying is gonna not be cheap. We could tokenize this ourselves, but I think the thing to do is probably to match. Here's what we're going to do. Okay. Okay. Tidy stack generic. What it's going to search for is anything that is not a dot.
02:09:55.145 - 02:10:20.703, Speaker A: Maybe so it'll take it if it can. Followed by anything, I guess followed by every anything. But non greedy. No, matching brackets is a pain because once you have nested brackets. Yeah. Basically that the plan is to do a double search. It's a little.
02:10:20.703 - 02:11:08.005, Speaker A: Little annoying, but we'll do it. So nested brackets are going to be a problem, but let's just assume that they're well formed. Actually we can't even do that. This is Going to trip up with. If you have go with multiple methods and brackets, although the current code also has the same problem. This basically means that we have to like resolve brackets, which you can't really do with regular expressions because they're context free. Maybe the way we do this is by just walking.
02:11:08.005 - 02:11:57.295, Speaker A: It's a little sad, but it might be the right thing to do. Yeah, because it'll be linear. So I guess then what we're going to do is we're going to make a simplifying assumption. We're going to look for only the last opening bracket. Because if it. If it really is just noise, as in just argument lists, then there shouldn't be parentheses in the argument list. Right.
02:11:57.295 - 02:12:15.625, Speaker A: Alternatively, we look for the first and if the first. If the first one looks like a. Yeah. Okay, here's. I think. I think, here's what we do. We look for the first open bracket.
02:12:15.625 - 02:12:45.637, Speaker A: If it is preceded by a dot, then we assume that it's go. If it is followed by anonymous namespace, then we assume that it's C plus. Otherwise remove everything following it. I think that's going to be the. Like, it's going to fail, but it's going to fail in different ways than this one. But still, I think it's mostly sane. I don't know what that symbol is, but sure.
02:12:45.637 - 02:13:35.455, Speaker A: If. Let's first paren is. Is func. Find that if func first. Ooh, can I do reverse ranges in string lookups? I don't know if there's a way for me to go to the previous character in a UTF 8 string. It's a good question. If I have a string, what can I do with it? I can.
02:13:35.455 - 02:14:26.403, Speaker A: Yeah. The question is, what is the index by? Is it by like character or is it actually. No, this is. This is all fine. Funk.get first paren minus one if that is sum. If it's none, then that means the previous character must have been a UTF 8 thing.
02:14:26.403 - 02:15:21.515, Speaker A: And so therefore it can't be a dot. Can't be a dot if it is. If C is a dot, then it's gonna. So then we do nothing. Assume it's a go method name. So do nothing. If it isn't, then if func first why do I keep writing parent instead of paren first? Paren dot dot dot starts with anonymous namespace.
02:15:21.515 - 02:16:41.535, Speaker A: Kill it with fire. So then we're going to set func is equal to func first. Param question is what happens in the else case? Can't be a dot. We still need to do the check, don't we? Actually let's. Ah, so the trick is to do this first is go is going to be true. False. We can tidy that up a little by saying false.
02:16:41.535 - 02:17:37.284, Speaker A: Oh yeah. The regex rate is really well optimized. Like it is not stupid. And it also does really well if it turns out that your regex is a is just a string. It will do really good things like use mem to search for the literal prefix and then only do the regex search from there. It is very, very clever and I recommend using it whenever you can. There's none.
02:17:37.284 - 02:18:11.144, Speaker A: Can't be a do. So this could probably use a function because then we could return. So let's do turn this into a function. Yeah, Burn Sushi is a wizard. You're right. For what it's worth, I know some of you are thinking this code is pretty hairy. I agree.
02:18:11.144 - 02:19:05.384, Speaker A: Refactoring it a little bit is going to help. Okay, so that's tidy generic. What else do we have? Oh, it's also doing this. Whatever that is, did that actually do. Oh right. Is that actually where that was introduced or is that just the indentation? No, that was there before this. So where does this come from? Tidy a horrid JavaScript frame.
02:19:05.384 - 02:20:31.585, Speaker A: Gee, thanks, that's helpful. So this is tidy up ugly JavaScript things like. And then we're going to replace any double quote followed by single quote with nothing. I don't know why that seems odd, but sure funk is going to be. See, then we're going to have to do that. Oh no, this is just func truncate to there right on string itself. Okay, great.
02:20:31.585 - 02:21:47.665, Speaker A: So here this is going to have to be. I think we're going to do this if. If func contains. Fine, do it without a raw string only. In that case we're going to do replace this with nothing just to avoid the reallocation in the common case where it does not contain that string. It's really weird. Like why strip those particular characters? I'm going to ignore Tidy Java because I don't care about Java to do tidy up Java annotations.
02:21:47.665 - 02:22:49.777, Speaker A: Okay, sure. So right, so this is where this inlining comes from. All right. We don't actually need to care about inline because we're. We're ignoring this like Java inlining business. If scalar inline this means that we've gone through the loop before which will never be the case for us. I see.
02:22:49.777 - 02:25:17.085, Speaker A: So really all we care about is the other ones. Specifically what we care about is if false and Ooh, what is this business? I guess this is going to be a to do annotate kernel because that's the flag we're going to need to do. And module starts with either starts with open square bracket or module starts with VM Linux. Oh, what's the order presidents here? It's like oh, I see. That's what they're going for. So either if it ends with VM Linux or it starts with a square bracket and module I guess this is not equals and not module starts with or I guess that would only ever be unknown. Right? And not and module is not equal to unknown then func push string kernel and to do annotate jit which we like may care about this like JavaScript code and stuff.
02:25:17.085 - 02:26:45.205, Speaker A: So if false and what is this business? The module matches that? That's a good question. I think we are going to be a little bit more liberal and say mod starts with that and this is module and module ends with then func push string j and then push inline func we don't actually care about unshift. So this is put inline at the front of stack. It's a little weird. So is the output in reverse order? It is. Huh. That's interesting.
02:26:45.205 - 02:27:57.415, Speaker A: That is very interesting indeed. I see. So this is like up here. If I think what we really want to do here is just reverse the stack false is to do what is it? Include p name then stack push. Yeah, we're going to have to figure out what the ordering here is. So this vector, we want the vector to be in the order so that it will do this. But that means that we have to push the last thing we encounter first.
02:27:57.415 - 02:28:55.435, Speaker A: There are a couple of ways we could get around this problem. I think the way we're going to do it is we're going to say all of this is going to allocate so many strings. That makes me really sad. But I wonder whether we could be more efficient here by saying we might be able to use a VICDQ here. Actually I wonder if VICDQ has a join because that way we could push from either end and it would still be efficient. Might have been hoping for too much. That's totally something people should add though.
02:28:55.435 - 02:30:12.455, Speaker A: In fact, where does join live? Join slice, concat yeah, so that should exist for anything that implements this and vecdqueue derefs to that. So let's make the stack a vec dq. So the stack is going to be a DQ and what we're going to do is we're going to push to the P name to the front. Yeah. See, this too is going to have to take the entire P name, which makes me a little sad. Yeah, I like sort of that. Basically the one he's running, it doesn't derive to a slice.
02:30:12.455 - 02:31:12.245, Speaker A: Really? Vec DQ does not deer of the slice. I don't believe you. I mean, what? That's insane. No way. Oh, because it can wrap around. Oh, of course. Okay, the other way to do this then is.
02:31:12.245 - 02:32:43.485, Speaker A: That makes me really sad. Okay, here's what we're gonna do. What is the condition for not pushing to the stack? Is it empty including the P name or not including the P name? It is including the P name. Okay, so what that means is if the stack is empty and not include P name. See, that just gets annoying too. Right? The old VEX slice does also create a new string. It's just that now we would have to create two strings because we also need the P name.
02:32:43.485 - 02:33:33.205, Speaker A: How do we even want to do this? Let's take a step back here and look at it. Maybe. Okay, maybe we do keep this as just a stack. The clone is pretty unfortunate, but I guess it's fine. Let's ignore it for now. And then here we're going to say that the stack string is going to be. See, this is why I sort of want join to be over iterators instead of.
02:33:33.205 - 02:34:38.935, Speaker A: But that's fine. We're going to have to do something like if the stack length is one and basically have to special case it to deal with the semicolon, then stack pop back, unwrap else. This should basically never be the case. Otherwise we're going to say that. Okay, let me. It's a little bit hard to articulate this while typing it. So I'll type it out and then why I'm doing what I'm doing.
02:34:38.935 - 02:36:26.935, Speaker A: And it may or may not make sense like so. Okay. So that in theory should do the right thing. If we wanted to be even more efficient, what we could do is allocate a single string with the appropriate length and push onto that. In fact, maybe that's what I want to do. Led new stack line. And we're going to say here, stackline, clear stack line dot push string.
02:36:26.935 - 02:37:12.005, Speaker A: So if the stack only has one item that we need to make sure that we only. And we have to make sure that we don't emit any semicolons. Otherwise what we're going to do is push the first thing so we know there's a first thing because the length is like it's non Empty. Right. So we push the first thing and then for each remaining thing. Actually now we don't need these anymore. Great, that makes me much happier.
02:37:12.005 - 02:37:50.087, Speaker A: So we're going to keep this, we're going to keep this stack line thing around. So that's the thing we're going to be writing the current stack line into whenever we iterate through, just so we avoid allocating the memory for it. And we're going to clear it at the beginning. Ooh, we could be even fancier than that. Maybe I might have a way to avoid this clone. Let's deal with that in a second. So if the stack is not empty, we're going to clear that sort of buffer that we're keeping around.
02:37:50.087 - 02:38:43.965, Speaker A: We're going to push the first thing from the stack and then for each remaining thing we're going to push a semicolon and the string in that and that guarantees that you have semicolon separated things. Now this is just going to be stack line and this needs to be owned and so therefore stack line doesn't, doesn't help to try to store between these. So we're just going to do this and in that case this might as well just be this. Fine. I tried to be clever and I was not. Great. Does that roughly make sense? So we're trying to construct this like semicolon separated list of the stack and the way we're going to do that is push the first one and then for each remaining one add a semicolon in that string.
02:38:43.965 - 02:39:14.667, Speaker A: We could here optimize a little bit by trying to basically by measuring how long the string is going to be and then allocating that much memory and that might save us some reallocations. But I'm just going to ignore that for now. I don't think it's terribly important. This is a to do. That's fine. What we are going to have to be careful though is the order in which we push things onto the stack. So we know that we'll want the pen to be first regardless.
02:39:14.667 - 02:39:52.831, Speaker A: And I think what this, what this structure implies is that whenever we get to something, we always want to push front. Right? Yeah, we're always going to want to push to the front because that way we're basically reversing the order so that when we walk it in order, we'll get the bottom thing first. So where we previously had stack dot push oh me. All right. We never got to that part that's down here. Great. So now we're back to looking at each of these.
02:39:52.831 - 02:40:19.405, Speaker A: We ignored the tidy Java, we've done this business and this is where it unshifts inline onto the stack. Although for us inline is not an array, instead it's just func. And so now we're going to take. Sorry, that's. That's still tidy inline. So that should have ended up here. This is matching on the stack line.
02:40:19.405 - 02:41:17.875, Speaker A: And so here we're going to stack push front. No, the drain iterator adapter doesn't set the length of the vec until it is dropped and it doesn't shrink to fit, just set lens. So I think actually drain does set the length at the very beginning because it cannot. It's not safe for it to do the opposite. It can't set the length of the end because then you might drop an element twice if you have a panic. So drain, I believe, sets the length of the vector before the drain, so changes the length of the vector before the drain, then does the drain and then sets the length at the end. You are right though that it doesn't shrink to fit, it only sets length.
02:41:17.875 - 02:41:54.225, Speaker A: And this is intentional because you might want to reuse the memory. All right, let's do a cargo check just to see. So there's some stuff in there. Right, so what is left apart from the to dos? Well, there's this inline business, which. Where is it? It calls inline here. This is if show inline, which I think we added a to do for. If not we should do that.
02:41:54.225 - 02:42:31.023, Speaker A: That's just below where we parse out the raw func, which is like here somewhere. Yeah, here to do show in line. So we're not doing any inlining yet. What we are missing though is once we've gone through all the lines, then this occurrences is what we have to print out. Right. We want to print out. Ooh, sorted by value.
02:42:31.023 - 02:43:13.485, Speaker A: Really? Or is this sorted alphabetically? Why is this sorted at all? Why do they care that this is sorted? Oh, that's unhelpful. It's like the origin commit. Great. So what you're saying is we have no idea why this is sorted. Why is it alphabetically? It's sorted by key. It's not sorted by the count. Why is it sorted by key? I guess so it's so that it.
02:43:13.485 - 02:44:00.075, Speaker A: I guess it's so sorted by key. Actually, yeah, I guess it's sorted by key to ensure that the display is remains the same across different runs. Like the. Any given function is going to appear in roughly the same place. Maybe. Why do you clone the P name here? Well, the type of the Stack is a vec DQ of string. So what else would I do? Because P name is kept around, right? So I sort of have to clone it because I can't.
02:44:00.075 - 02:44:46.885, Speaker A: I guess I could take it. The problem is like the whole reason we have P name is to keep reusing that memory, right? And so if I take it, I'm basically removing that memory and saying reallocated on the next iteration. Whereas here, this clone will only happen if you choose to include P name. So it won't like won't incur a cost. Although split off would do the same thing. I think you just like, fundamentally this is going to require cloning something like in the case with including P name, I guess you could optimize it away by starting to construct the stack string here. That would avoid the clone, but you are still doing a string allocation, so it might not matter all that much.
02:44:46.885 - 02:45:19.535, Speaker A: Yeah, I don't think it's super important. I also don't want to optimize this too much before we actually profile it and see how it works. It is true though that now at the very end. So after this, after we've read all the lines, then this is where we want to print out all the keys. I wonder whether it's a for hashmap. Is there a way? I guess there is ordered hash map which you can walk in order. In fact, ooh, we could make this a B tree map instead of a hash map.
02:45:19.535 - 02:46:08.965, Speaker A: Arguably it should be a trimap just because a lot of the stack frames are going to share the same prefix. The advantage of a B tree map is that we could walk it in order by key. The hashmap is faster, but the B tree map lets us not have to sort it Sort all the keys in the end, this is what makes. It makes it weird to me that they're. That it's requiring that we emit them in any kind of order. I would think that random is fine because I don't really want to. I guess we could sort all the keys at the end.
02:46:08.965 - 02:46:39.795, Speaker A: It's a good question. I don't know which is better. It depends on the ratio of number of lines to number of keys. So the number of lines for every line you're going to have to do a. Sorry. For every. For every sample, you're going to have to do one B tree, one map, one map operation.
02:46:39.795 - 02:47:43.441, Speaker A: Or you're going to do. So that means you're going to do N log N where N is the number of events. Because of. So the B tree map is like log N To do any operation, I think. So you're going to do N log n plus N. It's going to be the total complexity of a B tree map for this, where n is the number of events, whereas for the map it's going to be like n + k log k, where n is the number of events and k is the number of. K is the number of distinct stack lines.
02:47:43.441 - 02:48:10.065, Speaker A: So I guess we don't know whether they're. Well, we should know this, right? We know that there are fewer. There must be fewer, strictly fewer stack lines than there are total number of events, because every event has exactly. Has exactly one stack line. So some of them will be. So it's better to sort it at the end. Great.
02:48:10.065 - 02:49:31.401, Speaker A: So what that means is that at the end here we're going to do vec from occurrences keys and then we're going to do keys dot sort and then we're going to do four key in keys and then we're going to print out whatever this is that right. Which is really just print line this, this and nothing more, which is going to be key and occurrences key. And now we have some compiler errors. That's good. Oh, weird. YouTube is being weird again. Can people from YouTube still see me? YouTube is really not doing well with the streaming business.
02:49:31.401 - 02:50:08.403, Speaker A: Like, it's so unreliable. The stream to YouTube can't find funk in 122. That's because this should say raw Funk. What else do we. Of 59? Okay, you can. Thanks. Okay.
02:50:08.403 - 02:50:32.465, Speaker A: Well, I don't know. It just. There's a status panel that's saying that YouTube is still like zero viewers and retrieving data. I don't know what that means. The size of string cannot be known. That's fine. I guess this is gonna have to be like these probably.
02:50:32.465 - 02:51:25.275, Speaker A: What else do we have? It's weird to have my terminal have a font this large. Ooh, why is it complaining about that? Oh, really? It doesn't really matter. Cloning a character is just taking a reference of it. It's fine. Should be at least. Really. What does.
02:51:25.275 - 02:51:59.325, Speaker A: Where's my. Where's the cars? Iterator Cars presumably gives me an Iterator over. Yeah. Oh, it's all. Just gives you a reference. That's kind of annoying. No, it's, it's, it's.
02:51:59.325 - 02:52:30.351, Speaker A: The problem is all. The problem is not cars. Let's take the ones towards the end first. Really? Oh, from Iter. I guess alternatively I could just collect. But yeah, I don't want to import that. Trade.
02:52:30.351 - 02:53:45.055, Speaker A: Fine. Okay. 159, 57 slicencies type usize or ranges of usize. What? I mean this should be a U size. What am I missing? Oh, it's the inverse of what I. No, but then it should just work because all gives you a reference. That's very strange.
02:53:45.055 - 02:53:59.609, Speaker A: But I guess. Oh maybe. Oh maybe all doesn't know. You're right. So actually yeah, no, you're totally right. You're totally right. You can't single index into strings.
02:53:59.609 - 02:55:02.245, Speaker A: Oh, this is the thing we talked about earlier. I specifically just want that one string though. Isn't there a car at. Am I misremembering? Oh, maybe that's in JavaScript. Yeah, that's true. Right, so I would have to do this great. Irrefutable wallet.
02:55:02.245 - 02:55:37.561, Speaker A: Yeah, we're aware of that. Oh, right. Did this ever run perforport G? Nope. I feel like I had a way to get around this, but now I can't remember what it was. Maybe we could try it on a different machine instead and see if that has the same issue. How do you structure your research code? How do I structure my research code? That is a very good question. We do.
02:55:37.561 - 02:56:14.663, Speaker A: We do generally deal with pr. It's like most of it is just committing to master for smaller changes. But when we're doing like larger sort of tests or larger research efforts, we usually do them in a branch and then we do not quite code review but at least that way we can look at the changes when they're ready to merge. So we do. For larger changes we do pull requests. If you look at the Noria repository, you'll see that there are some pull requests in the past there's also. So the branch I'm currently working on is the one called RPC rewrite, which is a fairly large change.
02:56:14.663 - 02:57:12.635, Speaker A: So that might be something that of interest to look at the diff there. Well it compiles so. So that's kind of interesting. So I guess now what we're going to do is run our thing release the cat perf data script pipe. Actually we're going to first have it compile. Let's see this command that crashed. Oh, probably close this now.
02:57:12.635 - 02:57:47.995, Speaker A: Don't really need that here. We don't need to backslash this. Recover type text from typing auto. Yeah, I know, I've been worried about that myself. Sadly there's not really a good way for me to work around it. But there. I'm also not really typing any sensitive passwords for this.
02:57:47.995 - 02:58:12.315, Speaker A: Mostly you're right, it's a good concern. I am aware of the Concern. Great. Okay, so it runs. That's pretty interesting. So perf data scripts PV stack collapse. Perf.
02:58:12.315 - 02:58:56.725, Speaker A: Perf data folded. This is the command we ran last time, right? Okay, so it's still like around 16 megabytes per second to parse that file. I actually have no idea whether we'll be faster or slower, whether it'll even work, but we're about to find out. Took about 30 seconds last time. Is that right? Yeah, actually, I'm going to move. Nope. Folded to perf data Pearl folded.
02:58:56.725 - 02:59:29.105, Speaker A: Now Rust folded as a partially. A moment of truth. Let's see what happens. That's not quite what we wanted. Huh? What was this? I mean, this just looks like it's printing its input. Seems like normal. We want.
02:59:29.105 - 03:00:08.195, Speaker A: Give me further up. Why is it. Something is definitely weird. Why is it printing anything? There's now I guess there's weird stack line. But let's just like remove all the prints and see if it still does that. It does not. Okay, so it's one of these that are triggering.
03:00:08.195 - 03:01:02.815, Speaker A: But then why isn't it including the weird part? It should say weird stack line somewhere. Okay, so let's also put that into error log. Let's look at error log. Whoa, that's a big file. Oh, it keeps accumulating all of the lines. Okay, so that's definitely wrong. Why is.
03:01:02.815 - 03:01:36.385, Speaker A: Oh, it's because we're not clearing line. That's awkward. Um, we need to clear. Okay, fine. This is now going to become a loop line dot clear. Then this. Okay, that makes a lot more sense.
03:01:36.385 - 03:02:03.315, Speaker A: So let's look at the error log now. Great. Now. Now it doesn't have lots of weird things in it. So let's now go back to not doing that. Okay, that's a lot faster. It's still not as much faster as I would like it to be.
03:02:03.315 - 03:03:44.765, Speaker A: You could just use the lines Iterator from Buff Read. It's true. Ooh, I don't like this part. Why is it doing that? What is it being slow about? What is it currently stopped doing? Really? Where is it stuck? Read. I guess while. Let's do that for now. Does this give me strings? That's another question.
03:03:44.765 - 03:04:33.845, Speaker A: Or does it give me stirs? Really hope it gives me strings. Sorry, stories. No, it gives me strings. See, this is the reason I didn't want to use it because it doesn't actually reuse the line buffer. Try that. Let's see if it actually finishes. Okay, so this is currently.
03:04:33.845 - 03:05:23.557, Speaker A: What about 2x faster? Let's see if we can do Some profiling and bring that up. But first of all, let's see whether this is even right. So the Rust code is definitely doing something wrong. There's a lot of zeros going on in there. This looks like it's picking out the wrong. The wrong field somewhere. Specifically, it's looking like it's not picking out the.
03:05:23.557 - 03:05:57.397, Speaker A: Com correctly. So let's do no from each stack frame. That is so here. Oh, here. This should be 1, 2, 3. Let's try that instead. Oh yeah.
03:05:57.397 - 03:06:32.221, Speaker A: The line count is another good example, but that will only given that we're deduplicating by function names. The line count only works if all of the other stuff is correct. That looks a lot more. Right, Right. So now the only difference is that we're not including the module name. And including the module name is pretty straightforward. Let's make these be so all our to dos.
03:06:32.221 - 03:07:20.365, Speaker A: So include P name we're going to set to true. If include P name we're going to ignore that for now. I guess we can include that option. So that was include tidal. So where's the place where that got used here? So this is going to be P name is going to be if include pid else. If include pid else this. And so this is going to be either calm.
03:07:20.365 - 03:08:12.085, Speaker A: Oh, that happens regardless. I see. That's awkward. No, that is not awkward. It does mean. Oh, actually we can just do that. First this and then say here we're going to do P name, P name dot, push string pid or pid and then a slash and then pid or that.
03:08:12.085 - 03:09:31.149, Speaker A: And then we want to do this right. And now we need to declare those. So include tid is false, include pid is false. Include adders false. Annotate JIT and annotate kernel. Are there any more tidy generic? Okay, so tidy generic is probably true by default. So this is also going to slow us down a little because now we have to do more processing and actually it did.
03:09:31.149 - 03:10:08.713, Speaker A: Right, but only very marginally. We went from 33.8 to 32 point or 30. Yeah, like high 32s. How about now? That's looking an awful lot better, huh? Okay, we're straight stripping single quotes, which we should not be doing. This is because this is because replace replaces anything in the pattern as opposed to the exact string. A parser library like norm.
03:10:08.713 - 03:10:39.651, Speaker A: I actually consider doing that, but I figured I wanted to do a more direct port instead. It's also this parsing is a little weird because it's like. Yeah, I don't know. It could be. But it is kind of nice to be able to do line by line parsing when it is a line by line format. Okay, so this replace won't work because the replace has to. Wait.
03:10:39.651 - 03:11:18.895, Speaker A: Why did this line doesn't include double quote single quote. So why is single quote being replaced at all? That's okay. So that's weird. Oh, the Perl version is missing the quote. You're right. Huh. So their tidy generic removes both.
03:11:18.895 - 03:12:50.795, Speaker A: It's not either. So now the question is like, which is more expensive allocation and copying or scanning? I wonder whether we can do in some sense. I guess what I want to do here is any C equals this or C equals that. I don't know if that's more efficient than just always copying the string. Do I need to remove it? I don't really need to. There's an argument for that code actually being the Pearl tiding being wrong here. It's a good question.
03:12:50.795 - 03:13:56.511, Speaker A: I'm not sure why it removes the single quote at all. Come to think of it, like, why is this not okay? So for this, like, why is it important that that gets removed? Oh, it's probably, you know what? It is probably for the SVG generation. So I know. I think what I want to do is not remove these. The Pearl version strips, we don't do that. And then I guess see that here. So we're just not gonna.
03:13:56.511 - 03:14:39.625, Speaker A: We're just not gonna split those. And instead what we're gonna do is here, we're gonna substitute any single quote or double quote with nothing. Now these are looking pretty similar. So let's do that. There's some difference here in sorting this horrible thing. What do you mean? Oh, from the. Yeah, from the commit message.
03:14:39.625 - 03:15:31.915, Speaker A: So. So why is this ordering different? That's weird. That's a little disturbing that they're sorting differently because these are strings. Does Pearl like sort capital letters before lowercase letters and Rust does the inverse. I guess apart from that though, like, this is all the same. Great. Okay, so we wrote something that is about 2x faster.
03:15:31.915 - 03:16:45.145, Speaker A: Let me push this. Just so if people want to look at the code, they can. And so that we have a track record before we start splitting this up into Inferno, a Rust port of flame graph. And we're going to ignore anything used for debugging. We're also going to ignore any log files. And then we're going to. First working version, uppercase is lower than lowercase in ascii.
03:16:45.145 - 03:17:27.605, Speaker A: Yep. Then is why. Why is Rust sorting them in the opposite order? That sounds like Rust is not sorting in ASCII order. Yeah. So the next step is going to be to run perf on our perf parser. Before I do that though, I'm going to do a little bit of cleanup because currently we have all these parameters that I sort of want to parse with clap and I also want to split this into doing like error handling properly and what not. So let's do that first we're going to go cargo toml and we're going to say clap.
03:17:27.605 - 03:18:42.915, Speaker A: Whatever clap's version is right now. And it's probably using Unicode collation. That's true. 0.1. Actually, this is Inferno Collapse. Perfect. Struct opt instead of using Clap directly.
03:18:42.915 - 03:19:03.649, Speaker A: I haven't used struct before. I'm very happy with clap. I don't. I like the fact that it gives me low level control. I'm sorting just by using sort. I have a vector of strings and I'm. Yeah, I have a vector of strings and calling sort on it.
03:19:03.649 - 03:19:29.825, Speaker A: Could be that the perl ordering is wrong. I don't know. Sorry, you want me to use struct instead? Sure. Seems fine. We can do that. Struct version 0.2 in a good way.
03:19:29.825 - 03:20:17.885, Speaker A: All right, we'll do it. Use. Oh, I do need to macro use it, don't I? Even though I'm on the new edition. Normally you can just use macros now, but I don't think you can do that for derives. Could be wrong. So let's follow the example, shall we? We're going to derive. We're going to derive debug and structops.
03:20:17.885 - 03:21:33.169, Speaker A: We're going to say structure name. I guess we should also change cargo toml to say bin can never remember the. I think it's this Inferno Collapse perf path source main to source collapse perf. Great about. It's going to be rest. Let's see. Oh, I don't need the macro use anymore.
03:21:33.169 - 03:21:49.391, Speaker A: Nice. Oh, right. It's because of the tick. A. Of course. So the Perl version doesn't see the tick, whereas Rust does. Problem solved.
03:21:49.391 - 03:22:08.501, Speaker A: Thank you. Good catch, Thomas. Right, so now we get rid of these. That is kind of nice. I agree. And the things that we want. Let's see what Perf health.
03:22:08.501 - 03:22:45.285, Speaker A: No Stack collapse. We sort of wanted to mirror this as well as we can. Right. So how are these written? So I guess what I want is like include P name. It's going to be a bool. It's going to be struct short is going to be. None of them have Short so I guess long pid.
03:22:45.285 - 03:23:26.945, Speaker A: And what's the default value? Is this the default of the type? So false. So I will want default as true. This is not pid. This is p name which really you can turn off. Well then I guess include p name is just going to be on. It's not actually an argument. What? That is so weird.
03:23:26.945 - 03:24:09.755, Speaker A: How does it. So this is an option you can turn off. Great. Well we're gonna let people turn that on and off by using I guess what is pneum against the process name or it's the. Yeah, it's the process name. So we're going to call that names scopes. What does com because that's what it's called.
03:24:09.755 - 03:25:14.205, Speaker A: Oh yeah, it's probably missing the to do make this configurable. It's true include pid which is going to be false by default. How do I express that? Oh, I guess. Okay, fine, fine. So for this I'm going to have to write something for this it's going to be whatever this says. I sort of want to say that include did implies include pid. Is there a way I can do that? Instructopt.
03:25:14.205 - 03:26:05.455, Speaker A: I mean I feel like there probably is, but argument types help messages, right? Yeah, that is pretty similar. That's fine. Uh huh. Optional sub commands, flattening string parsers. It doesn't really help me, does it? Okay, so I can't say that it depends on that. Oh, default value. I sort of want to say like requires or includes but I guess it's not terribly important.
03:26:05.455 - 03:27:02.645, Speaker A: What else do we have? Include adders which is just called adders which was off by default. And for adders it's going to be this. What else do we have? Inline which we haven't dealt with yet. Annotate JIT and annotate kernel to be separated a little. It's going to be annotate jit. I don't know whether is on by default or not, but we can find out. They're all off by default except for tidy.
03:27:02.645 - 03:27:56.175, Speaker A: Okay, so that's gonna be legit. But here I need to sort of say that all implies both. I don't know if there's a way to do that. Kernel functions with K kernel annotate kernel Looks like tidy is also not configurable. Yeah, if you look at tidy generic there's no way to turn it on or off. So I guess let's just not include those. Just hard code them to true just like the original code does.
03:27:56.175 - 03:29:21.875, Speaker A: You can use something like raw magic stuff in the adder. Oh, so in the attribute I can like give clap commands? Because that would be pretty handy. Raw. Ah, how does RAW work? Well, that's sort of what I want. I'm very surprised that there isn't a straightforward way to express this because like. Okay, so basically what I want is here, this all in some sense I don't want to declare this as being tied to any particular variable. Right.
03:29:21.875 - 03:29:49.275, Speaker A: But I mean, I guess I can. It's fine. I can just do it in post processing. It just makes me a little sad. What else do we have? So there's context and inline, which are things we haven't dealt with. And there's event filter, which we haven't dealt with. And then for.
03:29:49.275 - 03:31:05.859, Speaker A: Right. And then how can I define like help text to come after the main help the help message that will be displayed when passing help. Okay, great. So here. Yeah, so there I want sort of this. Can I declare positional arguments is the other thing the type of the fields gives the kind of argument optional positional argument or option. There are three types of arguments.
03:31:05.859 - 03:32:16.985, Speaker A: Okay, so how do I do positional? Oh, if. If it just doesn't have anything. I see. Okay, so we're going to have input be an option string and that's going to be in file is what it's called. And then that's going to be something like read perf script output file or standard in if not specified event filtering. We haven't dotted yet. This is what we're going to have to include up here.
03:32:16.985 - 03:33:11.035, Speaker A: The question is where does that go? I sort of want help message that comes at the end. I don't know if there's a way for me to do that. Like basically the same way as happens here. I guess if I run this, this should tell me. Oh, did we ever get the stuff from here? Port G Something is very broken with per friend later kernels like I keep seeing. It could be related to Rust code too. Not entirely sure.
03:33:11.035 - 03:33:45.127, Speaker A: Like, I see this error a lot. Well, I guess we survive line nine. Oh, and you're saying I should not need this. Oh, and then of course I need all the business. Is there an after help? I don't think there's an after help. I mean there isn't clap. So I guess I.
03:33:45.127 - 03:34:33.695, Speaker A: I guess the one way I could do it is. Oh, these are. I see. These are passed directly to clap. Oh, so this actually does specify what arguments these are. That still feels weird, but okay. And I guess this we probably don't need anymore.
03:34:33.695 - 03:34:54.255, Speaker A: Oh, I see. Okay. Yeah. That makes sense. If the values aren't strings, then you need raw. All right, great. So now I just need to actually parse this out, which is this opt from args.
03:34:54.255 - 03:35:44.347, Speaker A: So we're going to do that here and we're going to do anything that says include is going to be. Except for those. It's going to be op.op.op/dot. This all nice. Where did it get the author name from? Oh, it took it from the cargo Toml probably. Nice file. Yep, that looks pretty good.
03:35:44.347 - 03:36:33.355, Speaker A: How long have you been using VIM for? That's a good question. Since I'm gonna say like 12 years, maybe more a while. Okay, so this looks pretty similar. So that makes me pretty happy. I don't know if I want the author version, author info there or the summary. I don't think I want that. I sort of don't want the.
03:36:33.355 - 03:37:16.765, Speaker A: Can I just say, like, can I have it not do version? Is that an option that I have? Like if I do, maybe version equals nothing or is it gonna hate me for that? Ah, that's unhelpful. Like author equals nothing. Is it then going to leave an empty line there? Yeah. No, it did not. Great. So I guess then I can do. I can just skip name.
03:37:16.765 - 03:37:58.385, Speaker A: I can make the name empty and the version empty. Nope, it's leaving empty lines. And also I don't want to set the version to empty because I want it to be correct when you pass V. So I guess it's going to have to be like this, but that seems fine. I'm not too bothered by that. Okay, so we have our flags. What now? Now we're going to tidy up this a little.
03:37:58.385 - 03:39:21.005, Speaker A: So oops, parse, take command line flags. And now we're going to tidy up this main routine a little. Specifically, what we're going to do is we're going to have a like a handle file because now I guess infile match infile. Ooh, good question. Yeah, we're gonna have a handle file method that's gonna be generic over R, which is buff read. It's gonna take an R. It's going to return an IO results and also I guess an opt.
03:39:21.005 - 03:40:21.845, Speaker A: And now here, this is going to match on op.inflied if it's sum f, then we're going to do some stuff. Otherwise we're going to use stdin here. I guess we're going to have to. It's going to be handle file buff reader, new file open with some error handling. And this is going to be standard in lock with some error handling. Right.
03:40:21.845 - 03:41:21.795, Speaker A: Takes two parameters. That is true. It takes off, which it might not be very happy about giving me because I'm borrowing it. So F is going to be this optf, and I guess just for call it R for reader, it's going to be this and then that's going to pass opt in R mismatch types. Great. So file open can fail. So here we sort of want to figure out what we want to do with errors.
03:41:21.795 - 03:42:36.337, Speaker A: I think what I want here is I sort of want to use question markers, really. Actually, that's a good question. What does this do if it fails to open the file? Oh, this is just Pearl's default handling, so it does whatever Pearl does. So I think what we're going to do is match file open F. Okay, then this. If it's an error, then we're going to error out and say. The other option we have here is to allow multiple.
03:42:36.337 - 03:43:16.855, Speaker A: Multiple infiles, which I think is actually permitted in this version. I think in theory if you gave multiple infiles, it would sort of just do the right thing. But I don't think that generally makes sense. I could make my main return result. The reason not to make main return a result is that I don't have as much of a control of the error message that you get. But like, maybe that's fine. It doesn't mean that you don't really get quite as nice error messages, but maybe it's fine.
03:43:16.855 - 03:44:11.051, Speaker A: It does save us a lot of trouble. Sure, let's do that. And then I guess here we could even just do this. Why is it complaining here? Oh, all right. This is fine. Now the question was, do we ever really want to return error? I guess let's find these unwraps we put in earlier. These definitely should be unwrapped because the regular expressions should be possible regardless.
03:44:11.051 - 03:45:02.703, Speaker A: In fact, they can even be const, if I remember correctly. Where's the constrage business? I can never remember. Is it lacy static you have to use to get. Mm, yeah, I don't think that's worthwhile for us. It's fine to just do it there. But that one we do really want to be in unwrap, because don't use cons for lazy static. Yeah, that's what I meant.
03:45:02.703 - 03:45:30.245, Speaker A: It's not actually const, but I don't really care about it being lazy static. Like it seems fine to just call it a handle file. Although I guess with lazy static I would always learn whether it was valid or not. Whereas here I would have to actually run it on a file. Actually. No, even an empty standard in would do it. What else do we have? Unwrap.
03:45:30.245 - 03:46:00.611, Speaker A: This is now a question mark. This is an. This is fine. Actually this could be if let some new S is stack up front just so we avoid the unwrap. That's an unwrap or so that's fine. Yeah. The.
03:46:00.611 - 03:46:41.495, Speaker A: I had to shut down my. I had to shut down my patreon because I'm an international student and that means that I'm not allowed to be paid in the US So I had to shut it down. Sadly, the regexes are compiled on each call to handle file. But handle file is only called once, so that's not really a problem. Oh, I see. That's fine. This is actually what I wanted to return and 80 that should be reader just.
03:46:41.495 - 03:47:12.625, Speaker A: Yep, that's fine. This needs to be mutable. What else? 53 See, NLL would fix this. But I thought NLL was on in the new edition. Right? Use of moved value. Oh, that's because I'm being stupid. This should be rough.
03:47:12.625 - 03:47:45.175, Speaker A: Great. Okay, let's do some more cleanup here. What else do we want? Well, we could do something that handles each line by making all of these things be parts of a struct. That would probably be a little bit nicer. So we're going to have a struct that's going to be. It's basically a state machine. But what do we call the state machine? Yes, NLL is on.
03:47:45.175 - 03:48:31.425, Speaker A: It's just the identity needed to match with the ref. Otherwise I'm moving the infile, which is not what I wanted to do. It's going to be something like perf state. It's not very descriptive, but it's fine. It's going to be. The things we're going to have here are in event Skip event. So this is all lines until the next empty line are stack lines.
03:48:31.425 - 03:49:24.435, Speaker A: This is skip. This is really skip stack Skip all stack lines in this event. Oh, this is neovim. It's not vim, but neovim is. Or vim in general is extremely productive when you have the right plugins. The stack is basically we're going to derive debug and default and clone because all of these are default values. Great.
03:49:24.435 - 03:51:02.215, Speaker A: The stack. The stack is. Well, I mean the stack is just a stack. But how do we even document that function entries on the stack in this entry thus far as the other question is whether occurrences should be a part of perf state. I think probably number of times each each call stack. Each call stack has been seen. How are you faster with Intellij? Like what makes you say that you're faster with IntelliJ? See, this really is com name.
03:51:02.215 - 03:52:09.699, Speaker A: It's not P name. P name is a weird called P name I guess after original stack collapse. So back and forth between terminal and ide. What about that? I do that only to run things. Oh yeah, the stopping me while typing is really annoying. This is why I had RLS disabled for the longest time. You run the program to see compiler errors while I see them immediately during typing.
03:52:09.699 - 03:52:51.005, Speaker A: I see them immediately during typing too. Control J gives me the next error. Control L lists all and they're highlighted on the left. So they're all there in my editor too. Where were we? Right, so we're going to have the state and then I guess what we're really going to do is. Is on stack state on actually we could call this perf state. So we're going to say something like we're going to have a function for on.
03:52:51.005 - 03:54:20.619, Speaker A: On event line. We're going to have after event and we're going to have I guess on stack line. One of the annoying things is we might need the options in here too. So I guess this will also contain an opt the options for the current run. And so the idea would be that this loop is basically the thing that's going to be doing reading here. We would do state on after event and onafterevent is going to do this. One question is what happens at the end of the function while.
03:54:20.619 - 03:55:04.117, Speaker A: Is there always a new line even at the end? Perf data script There is. Okay, great. See, these are just weird to me. Like why are these variables in the. Oh, I never remember. What is the control T? No control I. What's the vim hotkey for uppercasing something? Control A.
03:55:04.117 - 03:55:31.105, Speaker A: No, I can't remember. It's too bad. This should be tidy, generic. Great. Yep. Huh. Great.
03:55:31.105 - 03:56:26.645, Speaker A: And then down here I guess this will really just be self dot. I think it'll just be online. Right. And this will do the if in event then on event line. Sorry, on this should be stack line. So this will be online. I suppose.
03:56:26.645 - 03:57:02.425, Speaker A: Oh, shift U. Yeah. So this is. Yep. It's a pretty handy shortcut. But I can never remember it because I. I use it so rarely.
03:57:02.425 - 03:57:56.175, Speaker A: Okay. So I guess down here we might want to split this into multiple files at some point because currently it's getting pretty long if I guess it was organized this way. So we might keep it that Way. Right. And so if we are. If it's not an event then. Sorry, if it on event line, that is easier to reason about.
03:57:56.175 - 03:58:33.195, Speaker A: So on an event line we want to say that we are now in an event. Yep. And then we're going to do. Oh, see, this is where we're going to need the. The lacy statics to get the patterns. So Suman, I think the. The chat can probably help you out instead of me stopping to do that.
03:58:33.195 - 03:59:10.985, Speaker A: Thanks chat. I appreciate you. Oh, continue is going to be weird. Why does this do continue? There's nothing happening. There's nothing happening further down. I don't know what I. That was continuing seems weird.
03:59:10.985 - 04:00:24.105, Speaker A: Great. And then I guess here, this is going to be the place where we do something like, oh, this shouldn't be self. This should be state. And then this is going to be state finish and state finish is going to be what does that. So we're going to have FN finish. So now we've divided it into functions. Now the.
04:00:24.105 - 04:01:34.053, Speaker A: The handle file is looking a lot nicer now, so that makes me happy. This is still pretty big and ugly though. I think we probably want to move perf state into its own file. Maybe unclear if it's worth it. I think we probably want to keep this here instead this down here for easy reference. These are going to need a bunch of selves. What else are we missing? Oh, also, the symbol stripping worked entirely correctly.
04:01:34.053 - 04:02:02.831, Speaker A: Like this whole business for stripping symbol offsets must have worked correctly given that the files matched up. So that's kind of fun. This is self opt. This is self opt. And this pushes to the stack and this no longer needs to continue because continues the default operation. Great. We do probably want to split out a couple of things.
04:02:02.831 - 04:02:58.015, Speaker A: For example, the. This business for tidying up a function name is probably the place where. Yeah. Hmm. Because this business, it would be nice to at least have it in its own function. Right. So I think the way we're going to do that is I sort of don't want to have to give it captures though, because then it.
04:02:58.015 - 04:03:46.649, Speaker A: Although that said on stack line is basically just the tidying that it is all it does. So arguably, arguably it's just a function that does that. Anyway, this one is particularly nasty though. So let's do a. First of all, handle file should be higher up. Yep. And then it's the regular expression.
04:03:46.649 - 04:04:37.995, Speaker A: So we'll probably have to do lacy statics. Right. So this business. No, this business. I guess it's basically a string function. So let's do so Tidy generic is going to take func as a string and give you back a string. It's going to be mute and we're going to return func and this place is just going to do.
04:04:37.995 - 04:05:53.295, Speaker A: Func is Tidy generic. So that does help a little bit. I guess we could do the same here for. Yeah, fine, we can do that. So that's going to be, I guess, module fallback, which is going to take module, which is a string, raw func, which is a string, and PC which is a string and give you back the string. It's going to be with module fallback. So this is going to be with module fallback of module, raw, func, PC.
04:05:53.295 - 04:06:46.229, Speaker A: Still don't know what the skip process names is like. It would be nice to have some examples of. Ooh, did the stream go away or are you still here? Because now Twitch also went weird. Seems to still be online. Why is this unreliable now? That's a good question. No, seems to be fine. Yeah, weird.
04:06:46.229 - 04:07:23.215, Speaker A: I don't know. So this skip process names. Okay, so here's another thing just to backtrack a little bit back to where we were. There's a test suite for this. So in tests there's a bunch of perf results that we could look like. Look at that basically shows you what the results should look like for a given file. And I wonder whether this has any examples that contain those parentheses that it's like skipping Specifically, what does it.
04:07:23.215 - 04:08:40.175, Speaker A: It skips if raw funk starts with parenthesis. So something like this. Oh, that's awkward. Everything match Do a clone of this. Actually, it's going to be handy anyway. So if we CD into here and into test and then we grep here for. I want to look for anything that is space open bracket followed by not an open bracket or a slash.
04:08:40.175 - 04:10:12.095, Speaker A: Really? How does this line match that Space open bracket anything that is not a square bracket or a slash. Anything that is. No, that should be right. I don't want anything that is this or that Weird. Is this just printing all lines? It is. Oh, what's the pearl print Matching lines. Could probably do this directly with grep.
04:10:12.095 - 04:10:50.765, Speaker A: Yeah, printf with oh, may have been overly aggressive. So there are none. There are no examples of these. Like start with a. Yeah. So where does the skip process names come from? I guess we're going to go to blame again. Skip process names here.
04:10:50.765 - 04:11:57.637, Speaker A: See, that's where it all comes back to that Damn commit. This is this. No, here. Oh, wait, is that. That was not the file I meant to close. So show me before that commitment where does it skip these skip summary line. Wait, that doesn't change that line, right? This line is not changed by this diff so why is it even complaining? Oh, this business.
04:11:57.637 - 04:13:01.745, Speaker A: Oh, it's just indented. I see. So really this has been error all along, but that suggests that it's common. When would the function ever skip process names? I'm just going to leave it in because it seems to have been there since like the beginning of time and so I'm going to do this then Inlining is the other thing we sort of need to figure out. But I'm going to not do anything with inlining for now and instead have inlining be something we deal with after we look at the proposal performance of why it's currently doing well. Not doing well. We do need to get this to compile though.
04:13:01.745 - 04:15:20.005, Speaker A: So let's add in lazy static lacystatic and then we should now get use this. Wait, can I not make lazy static global reg exes because that's really what I want it. Great, let's see if that works. Ooh, capture's not found from this. Oh oh, I renamed skip event deny skip event to skip stack three. Oh, off doesn't have a default. Why not sure it can have a default.
04:15:20.005 - 04:18:15.411, Speaker A: It seems fine state. Actually no, it's not going to be default. It is however going to have from opt for perf state just so we have a good way to create perf states in the first place. In event is going to be false stack is going to be false stack is going to be vec dq default occurrences is going to be hashmap default key name is going to be an empty string and opt is going to be opt it's going to be self opt what else do we have? Oh, this has to take include adders and once we get this to run then then we'll try to do performance debugging of our own thing which is going to be fun hopefully. 78 it should be from OP 92. Wait, what did I call it? Was it not on after event? Oh, of course not. It is after event and these continues should just be returns that has to be continue that has actually else this Ooh, what is that even gonna be? That's gonna be return seems about right.
04:18:15.411 - 04:19:09.035, Speaker A: Are there any other continues? No great. I guess filters we are still lacking but so the other thing we now have to do is try to figure out why it's slow. I mean not that it's particularly slow, but I guess we'll try to run it first and See how that turns out. Okay, so about 35 megabytes per second. So the question is, can we do better? Right? In fact, one thing we should check, just for sanity, is if I just cat out the file script copy, okay. So we can write files a lot faster. So here's what we're going to do.
04:19:09.035 - 04:20:06.311, Speaker A: We are going to do, first of all, we have to set up our things such that profile.release has debug info because without that we won't really be able to debug it much. And then here, I guess it's going to have to rebuild. And then what we're going to do is basically just run the same pipeline but perf record the entire run and then look at where all the time was spent. And at least for the. Usually the way when you, when you end up doing performance debugging like this, usually what happens is you run into weird situations where like, initially there are some really big wins and then after a while they just all disappear. Like after a while there's just no, no one thing you can optimize anymore.
04:20:06.311 - 04:20:59.027, Speaker A: But hopefully this should be something that stands out to us. The other thing to be aware of is that we can't actually use cargo R release here because then perf would record cargo inside instead of the binary. So we're going to do cargo target dare slash release slash inferno collapse perf and we're going to do sudo perf g call graph. I mean, that's the plan. We're gonna, we're gonna flame graph our flame graph. Now, of course, we haven't ported the actual flame graph tool yet. We've only ported the stack collapse part.
04:20:59.027 - 04:21:57.301, Speaker A: In fact, this is gonna be a little bit interesting. But let's do a pseudo per first. See, this failed to process sample business. It's just happening everywhere. Can I run perf script? Like is that fine self script? And what if we run it through our own thing? Oh, actually that's not what I meant to do. I should have done this. Yeah.
04:21:57.301 - 04:22:57.785, Speaker A: So keep in mind that we can't really go much further, much faster than whatever perf script can do, right? If perf script can only hand us data so fast, we can't go faster. So here, this was probably not a long enough run, but this was estimating that perf script was emitting about 70 megabytes per second. So we can only really get 2x compared to where we are now because otherwise we would be faster than perf script. So the bottleneck would be perf script, although that would be A great place to be in. But what we want though is to cat perf data self script through PV through stack collapse, perf to perf data self perl folded and let's see how fast that is. Okay, so stock lab perf here is about 23 megabytes per second. And in theory we should be.
04:22:57.785 - 04:23:54.097, Speaker A: Yeah, so we are faster currently not by all that much. Right, well, let's. It is interesting though that here everything seemed to work. So now we're going to run flame graph on perf data. We'll run it on the perl one just because something is probably broken self perl svg and then we're going to open that file which is in dev streams inferno perf data self svg. All right, so where is time spent? Well, handle file. Okay, so it's kind of obvious that handle file is going to be for most fun.
04:23:54.097 - 04:24:30.139, Speaker A: You might also want to try some config stuff like lto. Oh yeah. I mean, there are a lot of config options you could turn on to make the binder even faster. I sort of wanted to start this just as easy as possible. But let's see where we come down to, like, where is time spent? Well, after event takes relatively little time, most of the time is spent in online, which makes sense because usually an event is not finished. But let's look at what happens there anyway. So there most of the time is spent in looking up in the hash map and constructing the join strings.
04:24:30.139 - 04:24:51.255, Speaker A: That's sort of what we expected. Online, there's onevent line and on stack line. On event line is taking a surprisingly long time. This happens only once for every event, right. So these are running a lot. These on stack line is running a lot more than on event line. So here it looks like there can be a pretty decent win.
04:24:51.255 - 04:25:12.171, Speaker A: There's some string replace that's taking some time. But on event line captures. On event. Event line captures. Huh. On event line. Huh.
04:25:12.171 - 04:25:56.455, Speaker A: So that regular expression, the match event line. Ooh, that's a good question. We don't actually know which one it is. So this is one of the things that's a little bit unfortunate about this setup is you don't know whether you are like if you call this function multiple times, you don't know which call. So it could be on event line. Because we do two captures here, right? We do one with this match and one with this. This much it does suggest that if we can get rid of some of these, this is going to save us a lot.
04:25:56.455 - 04:27:04.515, Speaker A: So either we could try to Parse this out ourselves or. Actually it seems like all the work happens in captures, which is a little interesting. I wonder whether captures iter is a lot faster. I wonder whether it has to rematch every time if you use captures directly. Yeah, no, that's for finding multiple. So the work is actually in. Yeah, Capture locations.
04:27:04.515 - 04:27:45.681, Speaker A: Yeah. So the work is happening when we call captures and we call it twice, which is a little sad. We don't need the trim end anymore because that's already happening elsewhere. So the question is which of these is the bad one? So one way we can find out is by doing this. It's sort of artificial. So now I can just. The only thing I did was just change this to be so that I now know I'll be able to differentiate between these two.
04:27:45.681 - 04:29:14.513, Speaker A: Right. To see whether we're spending significantly more time on one than on another. Specifically, what we wanted was this one and what we wanted was actually what did we want? What I wanted was sudo perf script that one and now flame graph that one. Okay, so if we now go back to online on event line. Huh. So only captures really shows up, whereas this one is basically not showing up at all, which is a little interesting. Maybe just gets.
04:29:14.513 - 04:30:24.435, Speaker A: Gets optimized out entirely. Also that is only being used for filtering, so might be. Actually here's one thing we could try. Instead of doing this, we could just comment this business out entirely and just see whether that gives us any kind of performance improvement that is faster. Right before we got 23 and now we're at 37, so it's already a lot faster. So if we look at online. Okay, so most of the time is still spending captchas, which is not terribly surprising.
04:30:24.435 - 04:31:15.505, Speaker A: We did see a speed up when we got rid of this. This suggests that if we can get. If we can avoid having to do reg exes here, it's probably going to save us a bunch of time. So let's go down and look at this one which we have to run for every event line. Really what it's doing is it's looking for the first. The first occurrence of a space followed by a digitized. Maybe the question was whether there's a way we could turn the regex into a DFAS instead of an nfa.
04:31:15.505 - 04:32:14.121, Speaker A: I think there's a way you can hear. I think there's a way you could like set it to only do one but not the other. Regardless though, I wonder whether we. This is actually worthwhile to just have not be a reg X because the thing we have to do is actually pretty straightforward. Well, also separately, this regex is wrong. If you have. Com names that include numbers, this would not work like if this was not V8, but if this was just 8 and that was a part of the.
04:32:14.121 - 04:32:44.895, Speaker A: Com, then this regex would be totally broken. So let's see if we can do this in a better way. We're going to say that. Here's what we're going to do. A state machine for parsing. Be better than regex. I mean, regex basically is a state machine for parsing.
04:32:44.895 - 04:33:17.035, Speaker A: You're right. There might be a more efficient one that we could write ourselves. But part of the. Part of the reason I use regular is more that ideally we shouldn't have to or it's a lot more expressive. Right. I don't really want to write manual implementations for parsers. So I think what we're going to do here is we are going to do this forward in line, dot, split, white space.
04:33:17.035 - 04:35:23.641, Speaker A: If word dot all. Is there an easy way? It's almost always slower, but it is a lot more convenient, isn't there is numeric. Feel like I seen this, but so can split whitespace. Also give me the index, because that's really what I want. And same with the split, right? Split just gives me split. Doesn't give me the index, does it? I could just walk it character by character, but that makes me a little sad. No, enumerate isn't.
04:35:23.641 - 04:36:07.375, Speaker A: Isn't enough here because I don't want the index of the word. I want the index of the character. I'm at. I may just have to walk character by character to get this. The upside is that I think I can do it in one pass. This is going to be. Bear with me here.
04:36:07.375 - 04:36:52.655, Speaker A: Car. Oh, I already have that. Okay, great. So that gives me. Yep, here's what we're gonna. So notice that I would never have written this code in the first place in the first iteration. But now that we know that is one of the performance bottlenecks, then it seems fine here we could probably.
04:36:52.655 - 04:37:15.325, Speaker A: Ooh, we could use memcar here. No, not easily. We're not looking for a specific string. We could search for space, but like I guess I could just find space. Split. Sadly, won't work. Actually, maybe split will work.
04:37:15.325 - 04:38:15.465, Speaker A: And split should be decently efficient. Right? Because split I can give a single character and so I can actually keep track of where I am. Oh, match indices. That's excellent. And match indices. Space. Well, I want split indices.
04:38:15.465 - 04:39:41.625, Speaker A: This won't actually. Well, no, this will kind of Work, but it's kind of stupid because this will. This will tell me where all the spaces are, which I don't think really helps. Yeah, no, I'm gonna stick with this for now. Last was space true digits else if C dot is as digit then all digits equals true. If all digits found an all digit word. So we're basically searching for the first all digit word.
04:39:41.625 - 04:41:15.375, Speaker A: Although this is gonna be a slash, it's gonna be annoying. If c slash. If all digits maybe slash. This is definitely pretty hairy. What's the point of all digits? N equals true. Isn't that same as leaving it untouched? No. So if all digits is false, it will stay false.
04:41:15.375 - 04:41:49.805, Speaker A: If all digits it's true, it will stay true. Sorry, you're right. What I want is. I guess actually what I want is just this. So you're totally right. It's entirely unnecessary. We're still all digits.
04:41:49.805 - 04:42:26.191, Speaker A: If we were all digits. You're right. It's totally unnecessary. So this is going to be word start is index +1 found an all digit word. If maybe slosh then found pid. Found pid. Right.
04:42:26.191 - 04:42:53.905, Speaker A: Wasn't that. No, found tid. That's what we discovered. Right. And so really what we want to do is whenever we get to here, we want to terminate. Once we get to this point, we're done. Because then I guess here we're going to have something like let, calm, let page let.
04:42:53.905 - 04:43:21.695, Speaker A: And we're going to set. Calm is going to be line everything up to us word start minus one so comm is going to be everything up to where we first started seeing these digits. Right. Remember the lines we're trying to match are these. Right. So we want. We're going to walk up until this point.
04:43:21.695 - 04:44:08.015, Speaker A: So word start is going to be the highlighted character here, right? And calm is going to be everything up to the up to but not including the space before the current word. And then if there's a slash then we have a pid and a tid. If we don't have a slash, we just have a tid. Right. So if there was a slash, I guess this instead of being maybe slash this should be saw slash or contains slash which I guess we could just search for. So this could be. I guess that's probably not terribly important.
04:44:08.015 - 04:45:37.727, Speaker A: We could just search the word for that when we find it. But instead we could also do contains slash and contains slash. Asset none Fun with parsing. So if it contains a slash. So I guess if let's some slash is contains slash at then pid is going to Be line from word start to slash two but not including slash and TID is going to be slash plus one to index. So everything up to but not including the index of the white space we're currently at. Otherwise pid is going to be question mark and TID is going to be word start until the space we're currently at.
04:45:37.727 - 04:46:35.665, Speaker A: And comm is going to be everything up until and now. I guess the real problem is that these were not guaranteed to ever get to these. So the only real benefit of regex is that you write less code. Yeah, you get much more concise code and very often performance doesn't matter, but you get very nice and concise code sometimes so concise you can't really understand it, but it is really nice. So that, that is definitely the advantage. And sometimes they can be implemented really efficiently too. The problem is given this loop, we can get here and not have and not have initialized competent if we get to the end.
04:46:35.665 - 04:47:52.871, Speaker A: So I think these may have to be mute, which is a little bit sad, I guess. Fields is what we would do is none. And then we would say here that. And then we're going to set. Fields is sum pitted, calm or I guess calm. And then we break. And then down here it's really if let some fields, some compound is fields then do that.
04:47:52.871 - 04:48:48.515, Speaker A: We've already dealt with those. Otherwise. Otherwise do that. So I think in theory this does all the parsing that the reg ex did, but without the reg exam. Whether that works out in practice, I guess we're about to find out. And let's just for our own sanity's sake, check that it still produces the right thing. Whoa, something crashed.
04:48:48.515 - 04:49:51.383, Speaker A: I think our parser isn't correct. I guess we should go back to this business. Let's just go to this. So saying we have some weird line, weird event line line. Why is it a weird event line? Well, also, why are they not being given new lines anymore? Oh, that's why all digits should be true when you find a space. Oh, you're right. Yeah, you're right.
04:49:51.383 - 04:51:16.987, Speaker A: It doesn't mean though that if you get a double space it would get really confused. I sort of wanted. I sort of wanted it to be false because until you've seen a digit, there are no digits. I guess maybe here what we could do is. No, this will be sad if actually though there is a way we could deal with this and that is down here if the. I guess we'll leave it like this for now and say two spaces in a row would see all digits Equal true erroneously. So I guess we'll see how this turns out.
04:51:16.987 - 04:52:00.315, Speaker A: If I now run it, what's it going to say? Okay, well that seems better. Now I guess we'll have to do the vim diff to see it almost seems slow. Okay, so this still seems to have produced the same, right? Yeah, we didn't change any of the outputs. That means that it is now still parsing things correctly. So now I guess we'll look at the PV output of that. Yes, we'll see. That's not even all that much faster.
04:52:00.315 - 04:52:24.475, Speaker A: No, it is actually. No it is. This is the speed we were getting when we commented out the inner regex. So this actually is faster. But I mean let's check how the. How the flame graph turns out. Flame graph.
04:52:24.475 - 04:52:49.075, Speaker A: So online on event. So this is pretty promising. On event line all of that time is now spent in captures. We've got rid of captures the one but not the other. Right? So this is saying that the inner one is still taking a bunch of time time. Now remember how we commented that out to see. Let's see if we commented out now.
04:52:49.075 - 04:54:03.635, Speaker A: I think this is going to be pretty cool. So if we now do this, that's a pretty decent improvement. Right? So we went from basically from 29 or 30 or something to 41. That's pretty good. Let's check the flame graph now. Of course now I've commented out that captures right? So the inner captures will still have to do something with but now online. Wait, why is on event line still doing a captchas? Wait, what am I just missing a captures here? Am I doing something very stupid? Am I like running the wrong binary or something? I don't think so.
04:54:03.635 - 04:55:13.629, Speaker A: Then why is it showing captures running inside on event line? There shouldn't be a captures there anymore, right? The only captures now are in on stack line. So why is that showing up at all? I see why the flame graph has been wrong all along. This goes to that script. This looks at this needs to output to folded. So actually if we bring this back now. Actually no bringing that back doesn't matter. But so we build this, we run it with that.
04:55:13.629 - 04:55:49.255, Speaker A: That's going to per stuff in perf data. That is definitely a speed improvement though. And remember this was only matching on the event lines. If we do the same for the stack lines that should be pretty severe. So this is going to go into self pearl folded hell. I ought to do it now. Yeah.
04:55:49.255 - 04:56:17.645, Speaker A: So look how on event line is basically gone now because of the optimization we made. So I Guess let's. Let's put this one back in and deal with. So if we look back here, we'll see that in on Stackline captures is also by far the biggest offender. So let's look. Match stack line. So that's what that does.
04:56:17.645 - 04:57:09.797, Speaker A: This one is almost simpler because it's really just. Yeah, it's pretty severe. It's really just removing leading white space, which we can do very efficiently. Looking for anything that does not contain a space pretty much. Then looking for doing a greedy match until it hits some stuff without a space inside parentheses. So this should be very efficient to parse. So we're going to say we might even just.
04:57:09.797 - 04:57:37.705, Speaker A: Actually we can just split white space. This. This is trivial. We. Yeah, this is very straightforward. The address of the. I guess PC is going to be line trim start split white space.
04:57:37.705 - 04:58:24.145, Speaker A: Next module is going to be line. Is there a split reverse white space R split whitespace. There is. End is there Fine. So we can just use split that. That's fine. So PC is going to be line trim start split on space.
04:58:24.145 - 04:59:29.309, Speaker A: Module is going to be line R split on space next. And raw func is going to be line.trim start from PC Len. Ah, no, we can do this even better. We'll just do. We'll split this by two. So there's split N which splits only that many times.
04:59:29.309 - 04:59:41.615, Speaker A: So it's going to split only into two pieces. I think N is the number of pieces. Yeah. So it's going to return two pieces. Specifically it's going to run into the PC and. And then the rest of the line. Right.
04:59:41.615 - 05:00:30.865, Speaker A: So this is going to be line is going to be this and then PC is going to be line next. Yeah, I'm using both RLS and Racer, I think. So line is going to be that. PC is going to be line next. Then line is going to become line dot next. I sort of want to try around this because otherwise we're going to have to chain it, which is going to be annoying. Then module is going to be R split and then it's going to be this.
05:00:30.865 - 05:01:08.221, Speaker A: Please excuse the unwraps for now. R split 2 module is going to be line next unwrap. And raw func is going to be line next unwrap. All right, so maybe this is kind of weird, but let me see if I can explain. We get the line in and we remove the leading spaces because there are like tabs at the beginning of each of these lines. If I go up a little. Right.
05:01:08.221 - 05:01:35.739, Speaker A: So there's some spaces at the Beginning of each of the lines, we trim that. Then we split by space into two pieces which is going to be this piece and this piece. PC is next of that piece. Line is then set to this piece. The second piece, that second piece we split from the right into two into two pieces on space. So we're going to split from the right on spaces. So it's going to give us.
05:01:35.739 - 05:02:10.313, Speaker A: This is the first thing and this is the rest. Right. So module is the first and raw func is the next and that's then going to work even if there are spaces inside of this. Oh, that's so weird that the YouTube livestream is. Apparently the YouTube live stream is really bad quality. I mean the recording is going to be. Just checking that I'm recording good.
05:02:10.313 - 05:02:56.865, Speaker A: Yeah, the recording is going to be full HD anyway. But it's really weird that the YouTube live stream is so bad today. I don't know what. What that's about. Sorry about that. Is trial unstable? It isn't, is it 2018 ed? No, I don't think so. Oh, weird.
05:02:56.865 - 05:04:19.795, Speaker A: We don't get try, do we? As in try catch. I don't think so because that would make writing this a lot nicer. So one way to do this is. This is really stupid. Okay, we're going to have FN get stack parts or just maybe stack line parts and it's going to take a line which is going to be a string that's going to give you back a string, a string and a string. But an option of that and then let. Because now I should be able to do this and say that this is going to be question mark.
05:04:19.795 - 05:05:41.865, Speaker A: This is going to be question mark. This is going to be question mark. This is going to be question mark and this is going to return some module RAW func PC Sorry, no PC raw func module. So in string order and now here we should be able to match on self stack line parts of line. And if that is some PC raw funct module then that and this is going to be if let instead because that will save us one indentation. Great. I had to manually select 1080p option on YouTube.
05:05:41.865 - 05:06:16.525, Speaker A: Maybe that's in there. Then unwrap or default. No, unwrap for default is not what I want because I. I specifically don't want them to be empty. I want. I want none from the entire thing if the line doesn't match 216. Oh, specifically what we're taking advantage of here is the fact that quite question mark works for option 17.
05:06:16.525 - 05:07:16.205, Speaker A: What? Oh, split split N and split N. What do we think? That's a lot faster. You see how much faster that is? I mean, let's just for sanity check that they're the same. Oh, they're not. Not quite the same. Specifically, it looks like there are no unknowns anymore, but that is a lot faster. So the question is, why did unknown not work? It's a good question.
05:07:16.205 - 05:08:41.195, Speaker A: Last curve, actually, let's look for one of those lines. This. This is probably what I'm after. Then I sort of want like. Actually, no, I want this less perf data script. Did I really not copy that? PC Roth Specifically, I want here to search for like this business and look at how those lines are special in perf data script. What? Oh, right.
05:08:41.195 - 05:09:42.705, Speaker A: There aren't any semicolons. So why did that. Why is there any unknown involved there? Oh, it's from the context. Right, so let's give some context here for this. So unknown, unknown doesn't get parsed, right? Yeah, unknown never gets parsed out here. So the question is why? It just gets turned into a single open square bracket. So something here isn't right.
05:09:42.705 - 05:10:45.645, Speaker A: Let's see what this gives us. PC module. So this is going to give us a ton of output. But I need the original line. Oh, yeah, I could use debug. Actually, debug would be a little bit annoying here, but I could. Ooh.
05:10:45.645 - 05:11:27.635, Speaker A: Oh, it's because we're. We're not supposed to include the parentheses around the module. Great. So specifically, next dot trim and then there's a. This is very bright, dark trim. Is there a trim matches? Yeah, Trim matches. No.
05:11:27.635 - 05:12:13.855, Speaker A: Trim start. No. Is there a trim start one? If module starts with. I guess. You know what? No, we actually. It's problematic. We do actually need to only trim the one character because otherwise.
05:12:13.855 - 05:13:30.895, Speaker A: Hmm. Or maybe it always contains one. How do I know? I guess module always is always wrapped in. So remove those. So what we're going to do is say module is equal to module12 module.len minus 1. Yep, that did it.
05:13:30.895 - 05:14:09.165, Speaker A: Okay, now let's try to perf that. Remember, the old value was 30 megabytes. We are now currently faster than perf script, so I'd say we're doing pretty well. Now I want stack collapse that and flame graph that. And now let's look at the flame graph. See, now it's a lot more sort of diverse. In fact.
05:14:09.165 - 05:14:36.875, Speaker A: Now a bunch of time is spent in on event line. We're seeing some like string allocation show up. Buff read line is showing up. So this means we're doing pretty well. I think this captures an on event line is worth getting rid of. So on event on event line. I guess actually this should also be in its own function.
05:14:36.875 - 05:15:54.185, Speaker A: What do we call that Stack line parts is going to be event line parts. It's going to take going to return an option. What are the things compid? It's just basically the same string. String string. Great, that makes me feel a lot better. And then now we almost can get rid of our dependency on regex and lacystatic and regex go away. We don't need you here.
05:15:54.185 - 05:16:49.417, Speaker A: We're in performance land. All right, so now this one, this should be straightforward. All we're looking for is we're trimming this up at the end which already happens and then we're looking for the last word. So this is trivial. This is just line R split N2 by space next and event is going to be captures dot well, we want to get rid of the colon is all. So I guess we could. We could.
05:16:49.417 - 05:17:38.345, Speaker A: If we wanted to be really strict about this, we could do something like if captures dot ends with colon if. Yeah, then captures is. No, is captures everything until captures.len/1 except this not captures. It is event. If event ends with like so. Right.
05:17:38.345 - 05:18:16.905, Speaker A: Incorrect. Close delimiter. Really? Oh yes. How much faster do we think it is now? I mean we're still gonna check that it does the right thing. And also keep in mind this is while running it through. Perfect. I don't know.
05:18:16.905 - 05:18:45.375, Speaker A: This is so much faster it makes me very happy. So we're going to do a vim diff just to check that we haven't screwed anything up. No, that looks all good. Do this. And then we're going to do flame graph now what? Flame graph. Ooh, so much faster. So now notice, um, on event line is there.
05:18:45.375 - 05:19:39.433, Speaker A: So after event is now becoming pretty large because it is doing hash map operations. We're seeing string extend happen a decent amount because it has to reserve. Ah. So that we can do even better. So after event. So if you remember in after when event we do this thing where we have to construct the string. We could do a lot better here by pushing all the strings onto a single one or onto basically reserve once instead of continuously extending that that string because that's going to do a lot of allocations.
05:19:39.433 - 05:20:08.225, Speaker A: So here what we could do is S dot reserve. No. Here. No, give me string. So on string there's a reserve. No. Really? Pretty sure there's a reserve.
05:20:08.225 - 05:20:49.645, Speaker A: Wait, this is. No, this is string really isn't There a thing on string to reserve space for it. Ah, there, yeah. Reserve. Great. Right. So with this, in fact we do reserve exact if we want.
05:20:49.645 - 05:22:14.317, Speaker A: We know how much more we're going to stick on there, right? Stack iter map string length I guess for each s len one. Actually that's going to be a fold over zero and free choice. Does reserve in terms of Unicode characters? I think it's in terms of bytes. But len also reports bytes if I remember correctly. Yeah, in bytes and reserve is also in bytes. So reserve exact. We basically want to make sure that we have room for all the strings we're going to push.
05:22:14.317 - 05:24:02.755, Speaker A: So that way we won't have to continuously reallocate more memory to the string as we go here. If we wanted to be really fancy, we could do that in here too. Because we know that this will always be the first string. In fact, if we're going to do some performance engineering, why not do it properly? Allocate a string that is long enough for to hold the entire stack string with capacity and that's going to beselfpname length +this and then pname.extendselfpname or I guess push string is fine. Make sure we don't keep reallocating on the way. Of course if include p name was not an option, then we would just always know that we could use that string reallocating while we do push string.
05:24:02.755 - 05:25:23.525, Speaker A: What else was showing up in our flame graph? So after event that entire string thing now will hopefully just sort of go away. Readline we can't do all that much about although it is spending a bunch of time in read. One thing we can do is if you look at rust buff reader buffreader when you create a new buff reader here, you can say with capacity you can ask it to read more bytes at a time than what it normally would do. So by default it reads 8 kilobytes a time. But we might as well tell it to read more. So for buffreader, with capacity, like why not do this, right? So with capacity, why not only do the fold once? So the reason we don't do the fold only once is because this code doesn't know that this code will execute. One option would be to get rid of include p name as an option.
05:25:23.525 - 05:26:38.015, Speaker A: Actually, let's just do that. It's always set to true anyway. So stackster is going to be that and then this is going to be that. This is going to be stackster, Stackster, Stackster. So now let's see. Add the. Com name, add the other Stack entries, if any, and then count it reset for the next event.
05:26:38.015 - 05:27:17.445, Speaker A: Right. Let's see what that gives us. So now if we run this 209 megabytes per second. Remember where we started? We started just around 20. Just putting that out there, just letting you know that this is fast. Now what's going to show up in our. Okay, so still some buff read, but that's sort of unavoidable.
05:27:17.445 - 05:27:40.555, Speaker A: Prof. Handle file. What's in after event now freeing memory. Ah. So the freeing memory is probably dropping the string because the entry is normally in the map. But once, like once your problem is dropping memory, I feel like it's not that problematic. Yes.
05:27:40.555 - 05:28:31.835, Speaker A: You'll notice here now push string is not doing any allocation, it's just pushing. So online I think is the one we can do the most about. And there, there's like on event which does string replace and splitting and event line parts which does splitting. So that I don't think we can do too much about on stack line gets executed a lot. What was the upper limit on the IO? Let me check. So that would be this. The upper limit on the IO is a lot more.
05:28:31.835 - 05:28:49.207, Speaker A: Also keep in mind this was running with perf. If we run it without perf, it might even be. It might be faster. Not by much. Actually it's about the same. Sorry, what were you. Yeah.
05:28:49.207 - 05:29:19.285, Speaker A: So the question is what we can do about on stack line R find can't do too much about this formatting. It's kind of sad. Stack line parts is splitting tidy. Generic has to do some allocation, which is a little sad. Yeah. So this is like allocating strings. This is allocating strings.
05:29:19.285 - 05:30:02.805, Speaker A: This is just searching. So we probably won't get rid of that too easily. This is formatting the string. So where does that come in? That's this business here. We can do a little bit better because this doesn't need to go through format every time. Notice also that this entire function, this with module fallback is inlined. It doesn't even show up here.
05:30:02.805 - 05:30:23.365, Speaker A: So I guess there's no other format. Right? Yes, it's got to be this one. Specifically we have include adders off. So we're hitting this format a bunch. And that's a little unfortunate. Although the override of Right. Shouldn't be that much.
05:30:23.365 - 05:31:04.885, Speaker A: Might want to try the hash brown crate in place of hash hash brown instead of hash map. Yeah. Although like there just aren't that many hash operations. Right. It's only this tiny bit over there. The only thing we're really doing hash Operations. Also, the other thing to keep in mind is for this, remember how we benchmark the performance of perf? Let me see if I can find it here.
05:31:04.885 - 05:31:48.493, Speaker A: Right. Like perf script can only emit things at a very low speed. So the bottleneck is actually perf script. Now perf script is actually probably a little bit faster because now the cache is cold. But the bottleneck is definitely perf script. LTO true. Oh, just to see.
05:31:48.493 - 05:32:44.205, Speaker A: I mean we could. It might actually. So LTO is true. See, structop is bringing in all these. I guess I could turn on thin LTO instead. Didn't matter that much. Although at this point our script is too short to really measure anything useful.
05:32:44.205 - 05:33:33.413, Speaker A: But it doesn't seem to have made that much of a difference. So I'm going to leave it off. Okay, so I think we're going to end the stream there because we've been going now for about five and a half hours. So I think we're gonna end the stream there. I'm gonna push these out. Don't use regex or performance, see things get pushed. So now you have seen both how to use perf, what flame graphs are, and how to try to write something that's more performance oriented.
05:33:33.413 - 05:34:13.479, Speaker A: Hopefully. That was interesting. We will probably do another part of the stream, I'm going to say probably in two weeks. I know there are other things have been voted on too, but I think it's worthwhile to sort of fit finish this one up and do the flame graph part as well. And especially because we have some things left like inlining. That said, I'm going to do the same thing I do. So I'm going to do the same thing with this project as I've done with the other live streams I've done, which is add a bunch of issues to the issue tracker on GitHub so that you can go in and like please do submit changes to this.
05:34:13.479 - 05:35:02.717, Speaker A: Like if you decide that I want to implement the inlining or I want to make the parsing even faster, I want to get rid of the string allocation. Like whatever you think of, feel free to submit PRs and I will look at them and read them and sort of give the best feedback that I can. And so maybe by the time I get back to this, like all of those issues have been solved. That would be really cool. But it's up to you. Let's see, just to answer the final few questions, isn't LTO on premises per default now? LTO is not, but thin lto I believe is because it supports incremental compilation, whereas full LTO does not. With optimizing with flame graphs, you generally iteratively take the largest bar and optimize and continue pretty much.
05:35:02.717 - 05:35:54.997, Speaker A: Although there are some things that are basically profiling is really hard because sometimes the thing that shows up the most is not necessarily the thing that you need to optimize. So sometimes what you want to do is run things like blocking profiles. There are some cool papers on how so. One paper that was written a few years ago that was really cool was causal profiling. This tool, there's a talk in a paper about it too, which basically tries to figure out what is the actual bottleneck of your application rather than just where is the CPU spending the most amount of time. Maybe publish the crate to prevent someone stealing the name. I mean, I'm not.
05:35:54.997 - 05:36:22.101, Speaker A: I don't particularly care, but this. It's gonna yell at me for licenses and stuff, so I'll deal with that later. Also, if someone takes the name like I'll rename it it's not that important. Great. It looks like it was fun. Hopefully it was instructive. I don't know whether any of you will actually end up using this in part because it's still missing some features as we know having gone through it.
05:36:22.101 - 05:37:07.985, Speaker A: But in general this should be pretty close to the real tool and as we saw it, significantly faster. And this is one of the things that's nice about Rust is it makes it really easy to write these kind of things in a high performance way, whereas with the Perl stuff you could probably do some of the same, but it would be pretty painful. In any case, thanks for joining. If you have other questions after the stream, like if you're looking at the recording later, leave comments on YouTube, send me an email or tweet at me or I'm also on on Mastodon as well, so just sort of reach out and I will do whatever I can to sort of get back to you and discuss. Thanks for watching. My guess is the next stream will be in about two weeks or so, so thanks for watching. By.
