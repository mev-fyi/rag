00:00:01.800 - 00:00:40.810, Speaker A: Hello, everyone. Welcome back to another stream. This time it's another one of those Q and A's, which I'm always. I always find it weird to do a Q and a because I'm like, why? Why would I have answers to any questions? Like, who am I to try to give answers, but people keep asking for it. So I figured, why not do one? I shared a link to a page that has, where you can, like, ask questions and vote on questions. And so I've been keeping track of those over the past, you know, week or so. And my plan here is really just to go through the questions from most voted on to least voted on and just have a bit of a chat about each one.
00:00:40.810 - 00:01:10.480, Speaker A: One thing I'll mention, just because of all the mayhem that's currently going on in Twitter is that I am on other platforms too, although I need to get better at actually maintaining them in particular. Let's see how well this works if I do this. So I'm also on cohost, cohost.org johnwho. I'm also on Fostodon. Let's see if I can actually figure out how to open that one. Aha.
00:01:10.480 - 00:01:36.970, Speaker A: Which is just fostodon.org. on who? Fostodon has gotten some, a bit of a bad rep recently because apparently they have some blocking set up against the Macedon service in Japan, which is not great. Hopefully that's something that can be undone and repaired. Oh no, the Q and A link stopped working. That's unfortunate. Let's see. I think it's back up now.
00:01:36.970 - 00:02:16.084, Speaker A: At least it's back up for me. The way this QNA is going to work is I'm just going to do the questions top to bottom by most voted on, to least voted on. And if you think of other questions as you go, just put them in the Q and a site. Other people will vote on them. I'll mark things as answered as we go, so you'll see which ones are still the candidates for being answered. I'm guessing we'll probably go for a couple hours, which is pretty wild, but we'll see how long we go. And when the questions start to dry up, I'll try to keep an eye on chat as well as I go.
00:02:16.084 - 00:03:15.482, Speaker A: Let me switch back to this in case there are smaller follow up questions and such, but for anything that's sort of a change in topic, I'm going to use the q and a list instead. Oh yeah. Interesting. I think this website is struggling under the load, but at least it looks like I generally have access to the question, so we'll see how it goes. All right, first question. How do you manage your time for work, open source personal projects and life? So this is one that I get a fair amount, not just in public, but privately too, from people that I mentor, for example, of how do you find the time to do basically more than one thing? And I don't think there's a great answer to this. One of the challenges with having side projects is that you only have a finite amount of time.
00:03:15.482 - 00:03:34.434, Speaker A: The. I think there are two pieces of advice, maybe that I would give here. The first one is, you will never find time. You have to make time. That applies to me just as much as anyone else for things like streams. It's not as though I just magically have like a five hour gap in my calendar to do an implementation stream. It doesn't work that way.
00:03:34.434 - 00:04:57.996, Speaker A: It is. I have to like allocate that, you know, two weeks from now, I'm going to do a five hour stream on Saturday so that I don't have any other plans that time. And the second observation I would make is that make sure that you do things that you find to be interesting. It's pretty easy to make the time for things that are fun, but if you have side projects that you're not as enthusiastic about as, as the other projects, you end up just not spending time on them. That's in practice, what happens. And so it's important to sort of evaluate your side projects and figure out which ones are actually worthwhile spending your time on. Which ones are you finding joy in, so to speak? I know for me, I've accumulated a lot of side projects that are hard for me to put aside, and it's not necessarily that I still care about them, but it's I feel an obligation to continue to maintaining this, that this happens for things like open source projects a lot, where it's something that I built ten years ago and I no longer need that particular thing.
00:04:57.996 - 00:05:43.326, Speaker A: I no longer use that particular thing, but I am still the owner and I feel a responsibility to continue to maintain them. And finding times for those is pretty hard. And one of the things that I've been thinking a lot about is how can I offload some of that work, be it just mark it as abandoned or try to actively solicit new maintainers. It's difficult in terms of managing time more broadly. I don't really use a, a system. Arguably I should. I found, though, that if I sort of look at my schedule, it's not as though I have, like, if I filled my calendar, I wouldn't have lots of things to put in the calendar.
00:05:43.326 - 00:06:26.272, Speaker A: It's not as though I have, you know, tons of meetings. Let's ignore work. Like, just assume work is one chunk, like, one unit chunk of my calendar, but for all the other stuff, it's more that just things come up or I discover things I want to spend time on. So it's not really things that I can plantain plan out in advance. I do try to plan for open source work. So, in general, I now do open source work sort of every weekend. Like, I let it build up over the course of the week, because after I get home from work at the end of the day, I often don't want to sit down and do more programming, even though I really enjoy programming, but I end up feeling as though I've.
00:06:26.272 - 00:07:03.824, Speaker A: I've expended some of that creative energy. And then when I get to the weekend, I then catch up on my GitHub notifications, like, some of the streams that I've done on a day in the life of open source maintenance, it's that kind of stuff. And so I do end up sort of dedicating time to it, but it's not as though it's Saturdays from one to four. It's more. I know that on Saturdays I tend to do catch up on, you know, email and open source. And even that was a struggle, actually, to say, you know, I'm gonna not respond to things immediately. It was a.
00:07:03.824 - 00:07:54.080, Speaker A: There was a lot of, I don't know, resistance in me towards making that trade off, because I feel a. I don't know, a sense of responsibility or something where I want to address things straight away. If I. If I'm just sitting on the couch and watching tv or something, I feel bad about not responding to an open pr or an issue or whatever. But at the same time, I know that if I tried to respond to everything, if I tried to address everything quickly, then it would be counterproductive, because effectively, what would happen is I would burn out. I wouldn't have enough downtime. And I think managing your own sanity in that sense and recognizing that you need to have time that isn't set up to do something productive as well.
00:07:54.080 - 00:08:42.682, Speaker A: Otherwise you go insane. All right, I'm going to consider that one answered, even though it's a big, complicated topic, but I think it's hard to give a complete answer to it. All right, next question. When picking third party libraries for your rust projects, what design, architectural technical attributes makes you use one library over another. Are there any red flags that you pay attention to? This is a difficult question, and I don't mean that just personally, but I think professionally as well. It's a difficult question for anyone who's looking to adopt rust and any programming language. To be frank, this all ties back to, effectively supply chain security.
00:08:42.682 - 00:10:56.224, Speaker A: Or in this case it's more like supply chain sustainability, maybe of not just do I trust this project, like in the sense of do I trust that they're responsible maintainers and they're not going to publish anything malicious. But beyond that, I want to take dependencies where I think they're being responsibly maintained, in the sense of do I think maintainers are going to stick around or is this going to be abandoned at some point? Do I think that the developers have a sufficient commitment to things like backwards compatibility? Do I think that they generally address feedback, performance issues, prs in a timely manner? Or are they very hands off in terms of maintaining this project, which I'm guilty of in some of my projects, too often to tie this back to projects that I built a long time ago and no longer actually use myself, I don't think there's a a right answer for how to evaluate whether a given library is a sustainable dependency to take. I think there are some indicators, though, right? So I had a Twitter thread on this a while back. There's also something known as the OSSF scorecard, the open source Software foundation scorecard, which has these scoring metrics for how good or bad a project is, how responsibly maintained it is along various different axes. I don't know that it has a complete set of the kind of things I would evaluate. There are some things there that I don't really care about, but the kind of things that are on that scorecard are things like, do they have CI setup? Is their CI setup relatively secure? Do they have fuzzing in place? Do they have tests in place? How many open prs do they have? How many open issues do they have? What's the ratio between open and closed? I think for me there are some other aspects that come into this that end up being more social. So libraries that are developed by maintainers that I've had good experiences with, work pretty well.
00:10:56.224 - 00:12:37.380, Speaker A: So basically anything built by David Tolne, anything built by burnt sushi, like those are strong indicators of quality. And not just that it's currently high quality, but also that it will continue to be a thing that's worth depending on other factors I look at are things like when they respond to prs when they respond to issues. How do they respond? First of all, when do they respond? But also do they respond in a fashion that I think encourages people to contribute, to take ownership of that project and actually help out long term? Or is it much more of a sort of brush things off? Other thing that matters are, do they have decent testing infrastructure? I think that matters a lot. Do they have a decently constrained list of dependencies? I'm not quite on the extreme side of your dependency list needs to be zero, but rather I do think that you should have some amount of discerning taste over which dependencies you choose to take or when you choose to take a dependency and not. But ultimately it ends up being a very subjective evaluation, which I think is unfortunate. At the same time, I don't really know what a better alternative is. There have been proposals for things like either a blessed set of crates for the rust ecosystem, or even trying to build a sort of batteries included version of the standard library that has many of these crates in there, like Regex and Certi and such.
00:12:37.380 - 00:13:21.746, Speaker A: And I don't know that I love proposals like that either, because you end up essentially cementing the status quo, right. You end up making it not necessarily harder to develop a competitor. And I don't mean competitor in a commercial sense. I just mean in the sense of another crate that tries to achieve the same thing and ends up doing it better. And you just make it harder for people to adopt those because it's so easy to just use the ones that are on the list. They get so much credence by virtue of being on the list. And if you have something like a blessed crate list, you do have to make somewhat difficult decisions.
00:13:21.746 - 00:14:07.370, Speaker A: Right. You want to, you probably don't want multiple crates that do the same thing, but that then also means that you can't really swap out one for the other, because that's sort of a breaking change in your suggested list of crates. So it just becomes a really hard evaluation. And I think we have good examples of where it would have been a problem if such a blessed crate list existed or an extended standard library existed. You can think of things like, before we had surd, we had rust serialize, which I'm glad we have surd over rust serialize. But rust zeroize was used everywhere until Sirdi came along. And so if we at the time had blessed crates, Serdi might not never come around.
00:14:07.370 - 00:14:45.610, Speaker A: And I think we have the same potential for Serdi going forward. Right. It could be that surdy is not the be all and end all either. Maybe we come up with a better design for how serializers and deserializers should work. And if so, if Serti is one of the blessed crates, then how do we even make it possible for such a thing to be built and gain traction and get adopted and be moved to. Another instance of this is lacy static, where these days in general you'll want to use one cell instead of lacy static, but it similarly was used, and is used everywhere. So it's tricky.
00:14:45.610 - 00:16:21.950, Speaker A: And I don't know that we can codify the attributes that matter, because there's this problem too, of if you make a metric your goal, and I think there's sort of a well known way to phrase this, but basically, if you make your metrics your goal, then people are going to start to essentially gamify this and try to figure out ways to beat the system to get good at the metrics, because they are the things that people look at without necessarily actually making the project better. You can imagine someone writing an extensive test suite that basically doesn't test things very well, but ends up scoring well on the metrics around testing. And you know, I don't think we necessarily want that kind of gamification either. The same thing applies for trying to come up with objective scoring for is this a sustainable dependency? Is this a risky dependency? It's difficult, because not just are there a lot of metrics that go into such a score, but also what things you weigh heavily for your project might be different from what I weigh heavily in my project. And navigating those nuances if all we assign is one or two scores, is difficult. Once you start assigning semi arbitrary numbers to things, a lot of nuance tends to get lost. Oh, why one cell rather than lacy static? There are a couple of reasons for this.
00:16:21.950 - 00:18:00.520, Speaker A: I think the big one, I forget all the details, but one of the big ones was that with lacy static, your initializer for the lazy static happens at a special time in the library. It happens in a magical early function that gets called when your library is loaded, and that means it's harder to do things like handle errors. You don't really, in some sense, your program, the lazy statics, get initialized before your program gets to run, so they can't really do anything like handling failure gracefully with one cell. It takes a different approach of saying, um, when you access the thing, you also give the initializer, and that way the value gets initialized during your program execution, which means that you also have a way to propagate errors. Um, and so that ends up being a slightly more reliable way of, um, uh, of doing initialization, or not necessarily reliable, but more flexible, more powerful, perhaps. All right, let's mark that as answered. Okay, so this next question is, how can you morally justify working for Amazon, especially in light of Amazon's anti unionisms? This is a question I struggle with a lot, and obviously this is where I give the caveat of this is my personal opinion, not the opinion of Amazon or whatnot.
00:18:00.520 - 00:19:20.380, Speaker A: But I struggle with this because the way the question is framed, it ends up being a very black and white question of, like, Amazon bad, therefore, why you work for Amazon. And I do understand the framing of the question, but I take some issue with it, which is that it assumes that things are always right or wrong. And I don't mean that in the sense of like, the particular actions are being called out. Like, anti unionism is, at least in my opinion, just bad, but it's more a question of my decision to work there ends up being a multifaceted decision, where what I have to trade off is the benefits of working there versus the drawbacks of working there. And in the drawbacks buckets are things like, there are many things that the company does that I don't like and that I want to distance myself from. But at the same time, there are things that I'm enabled to do by virtue of working for this company and particularly in the role that I have that I see as significant advantages that I think would be very difficult to get anywhere else. And so ultimately it ends up being this kind of trade off of I can get benefit.
00:19:20.380 - 00:20:26.006, Speaker A: And when I say I can get benefits, it's not necessarily about me. It's more about the impact I feel I can have on the world, where there are good things I can do by virtue of being in this role. But there are also bad things that this company does. And how do I trade these off? How do I weigh them relative to each other? And at least for the time being, the balance for me comes out to, I think I can do more good than the bad that results from me being there. And so some of the examples here for me is stuff like, I end up having a decent amount of, what's the right word here? Impact on the adoption of rust at Amazon a lot of my work is essentially enabling more and more teams, more and more developers to make use of rust. That in turn has a positive effect on rust as a programming language, rust as an ecosystem. And what we can argue about is companies using a language a good thing.
00:20:26.006 - 00:21:07.850, Speaker A: But I think in general, it means that there are more jobs created using this language. In general, it becomes a better known language. The fact that a large company adopts it widely is a signal to other companies that they should start adopting too. So it creates jobs not just there, but elsewhere as well. Using this language, at least the way I try to push, means that more resources end up being funneled into the rust ecosystem beyond just the company. And I think if I wasn't there, it's not as though Amazon would stop doing things with Rust. But I do think it gives me an ability to steer the direction that that involvement takes.
00:21:07.850 - 00:21:30.506, Speaker A: And I don't think there are many other places I could do that at the moment. Someone mentioned in chat, thanks for even considering to answer this question. I thought about it a lot, actually. I saw this question come up and I was, like, not surprised. Right. This is a very obvious question to ask, but it's also a. It's a thorny question.
00:21:30.506 - 00:22:16.594, Speaker A: It's a difficult question to answer, and it's one that, you know, I struggle with myself. I can't claim that I have the right answer here. All I can claim is I've tried to balance this in my head and I've come out on the side of, for now, this is still the right thing for me. Yeah. And someone also makes the argument in chat here that if all the good people avoid working at Amazon, then Amazon never gets better, which applies to any company. That argument only goes so far where it assumes that given a sufficient number of good people, the company changes for good. And that's not always true.
00:22:16.594 - 00:23:04.690, Speaker A: I do think it's true in Amazon's case, but that becomes entirely speculation. Right. Following on that thread, what would it take for you to take a similar step as faster than Lime? Yeah. So Amos's path here is an interesting one that I've thought about doing myself too. So Amos, faster than Lime, recently announced that they were gonna start doing open source, full time, open source writing, teaching. And I've considered doing the same thing myself for a long time. One of the reasons why I didn't was because it's hard for me to do that in the US, because I'm on a visa, and in particular, I'm on an employer sponsored visa.
00:23:04.690 - 00:23:40.420, Speaker A: And so that means that I can't do work that isn't associated with an employer. And self employment is real tricky. And so I can't have a Patreon or GitHub sponsorships on the side because it's considered work from elsewhere. Than my primary employer, which is not permitted. And I couldn't do full time work on Patreon GitHub sponsors because they aren't full time employers. They wouldn't sponsor my visa. It is something that I've considered more in terms of when I do eventually leave the US, that might become more tenable.
00:23:40.420 - 00:25:24.400, Speaker A: But as Amos pointed out in the article they wrote as well, it is a scary step, because suddenly your livelihood ends up being shifted to depend on a lot of people who all contribute a little, which is difficult, right? It ends up being a pretty significant change in risk. It's harder for you to lose all your income, but it's also much harder to achieve a livable income on something like that. There are relatively few people who can sustain themselves only on that kind of work. I think a related problem here is that, and I think about this a lot too, that let's say I started a Patreon today, or a GitHub sponsorship, or both today I would feel bad about people sponsoring me with large amounts of money. Large, relatively speaking here, because at the moment my salary is pretty good. And so that would be a sort of wealth shift in the wrong direction, if you will. But at the same time, if people don't contribute much because they see that I don't really need it, or I say that I don't really need it, which then is true, it means that it's a more difficult choice for me to choose to leave the relative comfort of my current job for that, because I don't see what the actual payout would be, and I would have to sort of take the leap and gamble on the fact that people would increase their contributions when they see that I no longer work for a big company.
00:25:24.400 - 00:26:13.090, Speaker A: So it's a scary step, and I'm very curious to see how it ends up going for Amos. And I really hope it goes well, because it's a path that I would love to take as well. I think for me it would take maybe a slightly different path, in that I think I would focus a little bit more on teaching. I would continue to do my open source stuff. I would continue to do things like streams, probably much more regularly, but also I might do things like offer maybe some kind of class, maybe some kind of workshop, maybe even, you know, pay this amount of money and I'll come teach the engineers at your company about rust. You know, I think I would have to find some of those kinds of opportunities to make it sustainable, but it would be really fun. It's something I think would be great.
00:26:13.090 - 00:27:00.060, Speaker A: How does part time interact with that? Yeah, I've wanted to be part time for a long time, but again, us visa doesn't really let me do that. It is something I could potentially do in Europe. Right. I work part time and then do Patreon GitHub sponsors as a part time thing for a while and then transition slowly as I see it become possible. Very much. Also a path I've thought about it is a little harder to land part time work, but I think it might be doable. This all becomes, you know, it's something I can't really do at the moment, so I haven't looked enough into it to know whether it's a, it's a tenable thing for me to do in the future.
00:27:00.060 - 00:28:06.710, Speaker A: All right, next question. Would you recommend any beginner friendly open source rust projects? This was tricky because as I evidently say for basically every question, I think that the best beginner friendly open source projects are the ones that you start yourself, because trying to learn someone else's code is a lot of work and not always worth it. Right. It could be that you start learning a thing and you don't really care about the project. You just want to have an ability to contribute and to learn from a big codebase, and that's not a great environment to learn in. Whereas if you're building something that you need you deeply care about, you're going to be much more enthusiastic about building it. And if you started from scratch, then you don't have to also try to learn, in addition to learning the language, have to learn someone else's code base and learn the problem domain that you're not familiar with.
00:28:06.710 - 00:28:55.562, Speaker A: And so I actually think that I would recommend starting things from scratch. There's an exception. There are two exceptions to this. One of them is if there is an existing project that you find really interesting or cool, it's something that you have use for or you have an interest in, or ideally both, where you feel a passion and enthusiasm and excitement for learning how it works, then I think that those are great projects to start with. And when it says beginner friendly, people put different meanings into that description. So beginner friendly could be things like mentors are available, or there are issues that are beginner friendly you could start tackling. That helps.
00:28:55.562 - 00:30:26.050, Speaker A: But for me, beginner friendly is a weird term because I. It assumes that beginners are not slow to learn, but it assumes that beginners can't handle complex problems, which I don't think it's true it takes them longer, but that's where it ties back to. If you have the enthusiasm, the excitement, then even if there's a complex problem to solve, you might have the energy, the drive, the motivation to really dig into them and understand them. So I would caution against recommending don't touch any particularly complicated problems if you're new and instead say, tackle the problems you think are interesting to work on, because they're the ones you're likely to be most productive in and feel like you're making the most traction on. The other exception here is there are some projects that are very good at bringing people into the fold. And so here I'm thinking of projects like Bevy have been pretty good at this, Clippy has been pretty good at this, the rust project itself has been pretty good at this. And so there are some where there are enough resources, enough people who care about onboarding around to make the project relatively smooth for people who are inexperienced to get onto.
00:30:26.050 - 00:31:00.230, Speaker A: But at the same time, I don't think that means that you should start working on them. If you don't care about the problem domain, if you don't care about working on a compiler, then you shouldn't start contributing to rust C. Or when I say compiler here, the compiler is pretty large, it has diagnostics. There's a lot of type theory in there. There's also lexing parsing, there's performance. There are a lot of interesting components of a compiler. But if you don't care about that domain of things, then even though it's a beginner friendly project, it's not one I would recommend you start working on.
00:31:00.230 - 00:32:02.240, Speaker A: But it can be a good candidate if you find some of those problem domains interesting. Yeah, and another good recommendation here in chat is to do something where you have relatively fast feedback loops. So in general, with human learning, we learn by getting feedback. And so if the distance between, or the time between you submitting something to getting feedback on it is very long, that's going to be much harder of an environment for you to grow in. Now, the feedback doesn't necessarily have to be human feedback. It could be something like if you're doing performance optimization, then how quickly can you get results on your, your iterations and your improvements? But sometimes human involvement is important here too. If ultimately your goal is to contribute back, then if you ultimately submit a pr and you don't hear back from for a year, your learning sort of stops there.
00:32:02.240 - 00:32:57.844, Speaker A: And so this comes back to it's worth looking at whether the project is basically dead, or whether there are people who seem like they might be willing to help someone get started and at least contribute feedback, if not mentoring instructions. Let's see. Okay, I think, I think that's about the end. I'm just scanning chat for whether there are follow up questions to this one. If you have questions that are on different topics, then just submit them to the question site, because that's the thing I'm going through for, for, you know, getting new, new questions as I go. I'll put the link in chat again. What are your thoughts on webassembly? I think webassembly is really cool.
00:32:57.844 - 00:33:58.740, Speaker A: I love the fact that Rust has sort of leaned into becoming a pretty strong player in that ecosystem. I think Rust is a good fit for compiling to webassembly as well. Unfortunately, I haven't done much webassembly myself, but it is something that I want to do more of, if only because I see it as being a pretty exciting path forward. We were stuck in this, I don't want to say rut, but we were stuck in this world where you could only use JavaScript for front end development for a long time. And the fact that that's changing, I think is pretty cool. The other thing that I like about it is that webassembly is becoming a sort of interoperability language or interface maybe between different programming languages. That is not just the C Abi.
00:33:58.740 - 00:35:10.920, Speaker A: I wonder with things like Wasi whether that's going to make a huge difference to how we do things like developed corelated binaries. Think of things like plugins and extensions, where maybe instead of trying to link with the cabi you do interfacing through web assembly interfaces. That'd be really cool. But because I haven't used it that much myself, I'm hesitant to try to claim that I have any right answers in that domain. Yeah, the website seems to struggle under load. If you refresh it all, the event the Q and a site comes back again every now and again. Yeah, what I'll probably do actually is after the stream, reach out to the maintainers of the site and be like, hey, it looks like you struggle a little under load alright, what would it take to drop Vim and adopt another editor like Helix? It would take a lot for me because I don't really have any problems with Vim.
00:35:10.920 - 00:36:04.520, Speaker A: When I say Vim, I mean neo vim, although Vim itself has gotten pretty good too now. But like, why would I switch? I genuinely just don't have complaints about any of him, and I also exclusively use my editor in my terminal. I love the fact that I can ssh into a machine and have the exact same editor experience as I do elsewhere. So while I think it's really cool that people are developing new editors, and I understand the appeal, I understand the excitement, I don't need what they bring. Neo Vim has a lot of plugins. It's extremely customizable. It has key bindings that by now I'm extremely used to it.
00:36:04.520 - 00:36:36.238, Speaker A: Or Vim you can get everywhere. It runs everywhere. The key bindings you can find for basically every editor. So I just don't have really see a strong selling point for switching editors at this point. I think there are some arguments for things like if you build things in, you can make them faster. I'm thinking of things like syntax highlighting or language support, more broadly, auto completion. And that is true.
00:36:36.238 - 00:37:45.484, Speaker A: But at the same time this becomes the monolith argument of you can build better things if you co build everything together, but at the same time you end up with a more strongly connected and strongly coupled design that makes it harder when something like LSP comes along. If you built an editor before the world of LSP, and you weren't leaning into having everything be supported by plugins, then it becomes harder to move to something like that. I don't know. I don't really have a desire to move away, and that's maybe where the challenge comes from. And yeah, I know there have been a bunch of people asking me to do another stream on my desktop and editor and hardware setup, and I know I've promised this for a while, I will do one. One of the reasons why, and I've said this in the past too, why I haven't done one yet, is because I don't feel like my Neovim setup is stable. I still think things are sort of shaking out in terms of how you should configure LSP, for example, with Neovim.
00:37:45.484 - 00:38:37.396, Speaker A: And, you know, I feel like if I did a video on it, the chances that it gets outdated in six to twelve months is decently high. And that's unfortunate, but maybe that just says I should do a new one every every twelve months to update people on my setup. It could be my configs are already on GitHub, so someone pointed out that they've been using helix for about a year, and that they're lazy and don't want to keep maintaining a large config. And it's interesting because I don't actually feel as though my vim config requires me to do maintenance on it every now and again. I do. Every now and again there'll be changes to one of the plugins I use, for example, or we'll move away from one plugin to another. And I have to do some work.
00:38:37.396 - 00:39:19.960, Speaker A: But I found it to be relatively rare. In general, it kind of just keeps working. And then for me, you know, the tiebreaker often ends up being that I want it to work in a terminal, and most editors just do not work in a terminal. You can't run sublime in a terminal, you can't run versus code in a terminal, you can't run intellij in a terminal. So I don't even want to consider those editors. And there's a flip side argument of well, those editors have plugins that let you interact with something that runs on a remote system. To which my answer is yes, that's true, but I would rather just ssh there and use the editor locally.
00:39:19.960 - 00:40:22.326, Speaker A: The editor is so close to the developer experience that if I'm going to want a terminal there anyway, why not just use the editor there? But I do. At the same time, I recognize that there are limitations to what you can do in a terminal environment, and having a fully graphical editor does give you some abilities to play with more interesting designs for things like code suggestions and auto completions and stuff that are hard to pull off in a terminal. I appreciate that argument. I haven't seen anything that's compelling enough for me to move away from the setup that I already use. Have you tried to pre configure neo vim setup like Astro Vim? Nope. Again, I don't really know why I would. I'm pretty happy with my setup, and I feel like I would rather keep adding things until I have only what I need.
00:40:22.326 - 00:41:12.060, Speaker A: Then I would take a giant dependency and then remove things or disable things until I get to what I want. Debugging from other ids debugging is when I hear a decent amount right. If people want these sort of native debugging experience, you get in a more graphical id. I understand that, I just haven't found the need for that. For me, I get very far with just print line debugging and GDB, and it is true the experience is nicer in an IDE, but it's not a compelling feature for me. And maybe that's because the development that I do, it ends up that I do less of that debugging. I'm not sure, but that's just never really been that much of a pain point for me.
00:41:12.060 - 00:42:41.038, Speaker A: Okay, I'm going to consider that one answered next one is, what features would you remove or rework from Rust? I get this question every now and again, and I always find it tough because I don't really have a sort of hobby horse of, or I don't have a backlog of things where I'm like, Rust did this wrong. I think there are some smaller things. Like, one thing that's pretty frustrating is around things that stabilized in the standard library before we had capabilities that we have today, and what got standardized could have been better if it wasn't standardized that way. But that would be a sort of 2.0 kind of discussion. It's not really something that's broken with rust as much as it's a, you know, a result of a language growing over time. An example of this would be something like boxed errors.
00:42:41.038 - 00:43:58.608, Speaker A: So if you have a box in, you know, error plus static plus send plus sink, that type does not itself implement error. The error trait. And I, that makes it really annoying to work with in some, some cases, especially when you're using something like, anyhow, like, the two aren't, you have to play tricks to get them to cooperate, and it can be pretty frustrating. So there are some of those kinds of, like, pain points, things I'd remove. There's been a lot of discussion about whether the pin trait should have been unsafe, the unpin trait, rather, which, you know, I see the argument for why it is correct for it to be safe, but I also see the argument for why it would have been nice if it was unsafe, because there are so many foot guns, but these are all fairly minor. Like, I don't think I really have a sort of, this whole thing is broken. I have things that I, I wish Rust had, but they're not really things that are there that I would change as much as they are things I think are worth fixing up.
00:43:58.608 - 00:44:39.452, Speaker A: So these are things like custom testing frameworks. Be really nice to have. Currently, the fact that rust has a built in notion of unit and integration tests is really nice. Arguably, cargo has a built in notion of them, less so. But I really wish we could see innovation in how to develop testing infrastructure. I think it'd be cool to see what kind of things we can get there. Cargo next test is a test runner, but it doesn't really give you mechanisms for doing test setup and tear down and output reporting change and that kind of stuff that I would love to see innovation on.
00:44:39.452 - 00:45:48.410, Speaker A: And currently, we don't really have a good framework for doing. So I don't really think I have other things I would remove I think I'm relatively happy with where we've landed and the things that I see coming down the pike. Oh, yeah. Cargo bench is another one, although there, too, I think custom test frameworks are arguably the answer, rather than standardizing how to do benchmarks. All right, do you think Rust is on its way to become the next c? Due to the complexity of the language? That question did not go where I thought it was going to go. So I think this is asking, are you worried that rust is becoming as complex as c is? I. So, yes and no.
00:45:48.410 - 00:47:02.944, Speaker A: Rust is certainly growing more features, and that does mean that you have more tools in the language, and that does make the language potentially more complex. At the same time, a lot of the things that we've gotten in Rust recently, I'm thinking of things like generic associated traits are, at least in my mind, not really making the language more complex as much as it is filling in feature gaps. So if you think about Rust in a sort of abstract sense, not in terms of what the language currently supports, but just what the language is about, do you think of, you know, trait bounds and lifetimes and those kind of things, generic associated types seem obvious. They seem like a thing you should just be able to do. And the fact that that wasn't possible was a limitation of the implementation of the language. And making that possible, at least in my mind, arguably makes the language less complex because there are fewer rules for things that won't work. Now, of course, it does mean that things like trait bounds can now grow more complicated.
00:47:02.944 - 00:48:00.530, Speaker A: Right. So there's sort of the difference between the complexity of the language and the complexity of what you can build in the language, complexity of the abstractions. And so I think it actually makes the language simpler, but it makes it possible for abstractions to be more complex. And I think that's generally the right trade off. Like, I do think that you want a language that feels relatively complete, or rather feels like it doesn't have obvious holes, because holes are a terrible thing to try to understand when you're learning the language of like. But why can't I put a lifetime parameter here that makes no sense? Why can't I put it in these places but not those places? I think another candidate for this is type alias infiltrate. So existential type aliases, where it's something I think folks learning the language probably expect to be able to do, but they just can't.
00:48:00.530 - 00:49:48.090, Speaker A: Inferred bounds might be another example where. Why doesn't this just work? Why does the compiler require me to either not do this, or do it a different way, or spell things out when the compiler should just know that it's true. Borrow checker bugs have a similar flavor, right, of there's like one long standing bug in the borrow checker where if you return early from a function and you borrow something in the return, like the return value borrows something that's also used in the remainder of the function after the early return, the borrow checker can't reason about that and ends up just refusing to build your program. Like the borrow check fails and you can have entirely correct code that just gets rejected. And it's a terrible beginner experience if you run into this because your mental model is correct, but the compiler is telling you you're wrong, and that's a bad mismatch in some sense. I think this question is really, is Rust, is Rust's theoretical capabilities, is rust type system, let's call it too advanced, too sophisticated to the point where it allows abstractions that are so hard to reason about, that the experience of using the language becomes painful. And I think there's a similar question to be asked about something like Haskell, or if you go even further into form of verification, where you have languages that allow you to arguably state anything like your bounds are very complicated because they're essentially proofs.
00:49:48.090 - 00:50:42.862, Speaker A: Those things are, they are harder to work with, harder to reason about, but at the same time, they provide immense value. Being able to have the compiler check things for you, I think, is worth the cost of the added complexity that's required, because we basically need to state more facts about the code that we write. That's effectively what trait balance ends up being, and I think that's worthwhile complexity. And I think that complexity is slightly different from C's complexity. I think C's complexity comes more from the language, than the syntax, than from the sort of theoretical type theory complexity. Let's see. C grows features with compromises.
00:50:42.862 - 00:51:30.210, Speaker A: Rust can grow with lesser compromises, maybe. There are certainly compromises in rust, too, although I do think that we have been fairly good at trying to develop or trying to land features that have a decent amount of cohesion with the language that exists already. And there's a little bit less design by committee. Yeah. So another thing that comes up in chat is whether Rust and C end up being bloated languages. And bloated here, too, has multiple different meanings, and it depends on which meaning you use. The rust standard library is definitely not bloated.
00:51:30.210 - 00:52:06.950, Speaker A: It's a very narrow standard library. It's very deep, but narrow so option, for example, has tons of methods on it, but we don't have things like an HTTP server or a client or anything like that. So we cover less ground, but we cover it very well. Is that bloat? I don't think it is. Same for syntax. I don't know that when Rust introduces new syntax, I think it's usually for a good reason. I think we're decently good at only introducing it when needed.
00:52:06.950 - 00:53:36.610, Speaker A: That said, rust does have a lot of syntax, but I think that ties back to the fact that, as I talked about a moment ago, rust has a type system, theoretical underpinnings that are more powerful, in a sense, than some of these other languages, and therefore needs to have more syntax to be able to represent the fact that it has more concepts in the first place. That too is a trade off. But I do think there's a reasonably good argument for why Rust does need to have some of that extra syntax. Okay, let's see. Next question is, do you like copilot? Okay, so my hot take here is that I think things are. I think copilot and similar kind of endeavors are problematic in the short to medium term. And the reason I say that is because the number of times I have accidentally introduced bugs, because I've not necessarily copy pasted code, but just assumed that code did the right thing and not read it carefully, is pretty high.
00:53:36.610 - 00:54:45.910, Speaker A: And I worry that that only happens more if your editor gets just put in code for you. I think what happens is it puts in a bunch of code for you, and you start relying on the fact that it's mostly right, and it might even be right for the cases, for like the main execution cases. The challenge is all the corner case behaviors, and that means you start relying more on your tests, unless you actually go back and read the code that was auto generated. And if you go back and read the code that was auto generated, it has saved you relatively less. It is true that it can save you from things like looking up a bunch of API documentation, for example. It might allow you to get close to the correct solution faster. I think there's value in that, but I worry that developers will lean on it too heavily and then get bit by all of those subtle bugs or subtle mismatches between what the generated code tries to do and what you actually wanted it to do that you end up not really auditing that generated code well enough.
00:54:45.910 - 00:56:06.900, Speaker A: That said, I think we won't get to something that you can actually rely upon without going through the process. The learning process of using and then iterating on something like copilot, like something that works less well or less perfectly. I guess this comes down to I'm unsure about whether imperfect code generation is worthwhile. I think perfect code generation is worthwhile. I don't know whether it's achievable. Yeah, all these libraries have the same bug. Any thoughts on possible license problems? Yeah, so, I mean, this is a whole different rat's nest, or Pandora's box maybe, of when you generate code that's ultimately sourced from many different places, who owns the code where? And not just owns, but even for things that are actually open source.
00:56:06.900 - 00:58:12.540, Speaker A: Many open source licenses require attribution. But if the code that you got is built based on scanning hundreds of thousands of code bases, what does the attribution look like? You could imagine you just put attribution for all of the works that you scanned, but then attribution becomes meaningless because it's just a list of every software project because you scanned all of them. So I think we have both technical problems here, but also social problems around attribution, licensing, ownership. And I'm not going to claim I have the answers here, but I, I struggle to see how we get to perfect code generation, or code generation where, you know, you don't have to audit it, and it's a responsible way to use other people's code. What's interesting here, especially about that first one, about technical questions or technical imperfections in the generated code, is that a stronger type system might actually help you here, because it might be that the generated code, if it doesn't do exactly what you wanted, then it won't type check. This is the goal of getting more into formal methods where maybe we could have it so that you use code generation only in contexts where you can prove that it generated the right code, which is an intriguing possibility, but I don't know of any efforts in that particular direction. Yeah, and there's also the question of like, okay, what if you had bad programmers, like, is it better to use the use auto generated code that's imperfect, or is it better to let a not very good programmer just write the code themselves? I don't have a great answer to that either, but the auto generated, I think you don't want to use either of those code bases.
00:58:12.540 - 00:59:10.702, Speaker A: Even if a bad programmer reviews the auto generated code, I wouldn't trust them to do it properly. I don't know. It's a very difficult question. What is the difference between a human learning from thousands of open source projects and using what they have learned to write code without attribution and a bot doing the same. I think that's certainly at the core of the question. To what extent is a human just regurgitating things that they've seen in the past? And to what extent is an AI code generator doing the same thing? It could be that you can make the argument that really what AI cogeneration is doing is creativity. It's not just copy pasting lots of small bits from everywhere, it's actually generating new ideas or new combinations, in which case it is much closer to a programmer.
00:59:10.702 - 00:59:56.000, Speaker A: Just saying, I'm just applying what I've learned. But even there, that doesn't get you into a free for all situation. It's not as though that absolves you of all responsibility. If you, as a human programmer, read the source code that someone else wrote and then write it from memory, then it's still not okay for you to not do attribution, depending on how close the thing you wrote is the thing you read. This is why companies often do clean room implementations, so that they can't be liable where you're not allowed to look at any of the source material, so they can't be liable for being accused of copying things. So the answer is, I have no answer. But I agree that it's a difficult question.
00:59:56.000 - 01:00:58.802, Speaker A: All right, what do you think about Rust finding its way to the Linux kernel and the approach they have taken in doing so? I think it's really cool. I think it's fantastic to see Rust get into Linux kernel. I also think it is a very good input channel into Rust's development. So the kernel has some really weird, not weird, really niche requirements of the languages that they build on top of the ecosystems they build with the builds themselves. And I think many of those niche requirements are only the Linux kernel needs that exact configuration of niche things. But each niche things might be needed by many other projects. And the fact that the, the kernels picking up the language means that those niche things are more likely to get addressed.
01:00:58.802 - 01:02:31.020, Speaker A: I'm thinking of things like one of the big things that came up in Linux adopting Rust and the kernel is what do we do about allocators in the Linux kernel? You want to be able to guarantee that certain code paths do not allocate or only allocate in the known ways. And Rust doesn't really have a mechanism for doing that, especially once you take third party dependencies. And I think this has really pushed forward the question of, well, how do we, as how does Rust implement such a feature? Is there even a way to do so. And that is generally a lot of interesting discussion that probably wouldn't happen with the same amount of depth or weight without the kernel picking up rust in the first place. I also think it's a strong indicator that Rust is sort of here to stay and has merit, that this is sort of a stamp of approval, maybe, that I think ultimately matters a lot in the world of programming languages. You need to be able to point to other successful adoptions of the language for the more hesitant players to pick up the language. But I don't think I have much more to contribute there.
01:02:31.020 - 01:03:26.036, Speaker A: What are your opinions on management consulting? Interesting. I don't know that I have strong opinions on management consulting. Trying to think if I do or if there's a variant of this question that I have opinions on. Certainly consulting more broadly, I think, is actually a fairly good idea, mostly because it means that you can. Companies can avoid having to become experts in everything that they need. Think of things like security work. If you required every company to have their own internal pen testers, that doesn't scale, because for most companies, you ignore the very large ones.
01:03:26.036 - 01:04:12.200, Speaker A: For most companies, they don't do enough security work that it's worth having people work full time on security. That's not their business model. That's not what they do. And they wouldn't really do a very good job even of hiring a security professional or retaining them or giving them the tools that they need. And those are the kind of situations where consulting works really well. And I also think it's really great for someone to be able to work as a consultant. I've thought of this myself, of trying to be essentially a rust consultant that gets hired into, whether that's to develop a crate or help design an API or clean up some rust code or help with designing software built in rust.
01:04:12.200 - 01:05:09.000, Speaker A: That would be really, really fun, and it would allow me to apply my expertise very broadly while still getting lots of new challenges every day, new ways, new problems to look at. And that'd be really fun. Yes. When it comes to, you know, actually management consulting, like, you know, McKinsey and BCG and stuff, I don't really have a problem with them. I think in some sense, they provide a needed service. I think there's a question of, like, you know, you can apply some amount of ethics evaluation here of to what extent should they be more picky about what projects they agree to work on and such. But I think in, in general, the idea of consulting makes a lot of sense to me.
01:05:09.000 - 01:05:55.730, Speaker A: Okay. Have you tried Nixos? No. I've been told so many times I need to, but so far I've resisted the I don't know if urge or urgings, like urge being self imposed and urgings being from other people. I think this comes back to the same argument I have for editors, which is I haven't had a need. I've felt more of a need since I started working at Amazon because I can't run. It's much harder for me to run arch Linux there. But everywhere else I run arch, and I'm very happy with it.
01:05:55.730 - 01:06:48.616, Speaker A: So I don't really have a need for nics there. That said, it could be an example of, well, you don't know what you're missing out on. So certainly one of the things that appeals to me is the ability to very easily get a new system set up with a similar configuration to what I have elsewhere. But at the same time, that happens pretty rarely. And when I do that, I actually really appreciate setting it up from scratch because it means that I get to revisit the decisions that I made when I set up my last system. And very often I find that something changes. Like, I decide to change something about my setup when I set it up again, whether that's because, you know, system D has gotten a new feature that I want to make use of, or, you know, there's a better package to provide this, or I want to switch my window manager, or all those things that are really annoying to change in an existing setup.
01:06:48.616 - 01:07:30.658, Speaker A: But when you get to start afresh, it's much easier to just like, make different decisions. And so, yeah, I guess this comes back to I don't have a compelling case for moving. Yeah, I've also heard someone mentioned chat that the Nick's language is pretty cryptic and hard to get into. But, like, you know, I think one of the arguments is with Nyx, you can easily roll back, and, I don't know, I can pretty easily roll back on arch too. I don't. That's not really a problem that I have. But maybe this is somewhat unique to me running arch, I'm not sure.
01:07:30.658 - 01:08:14.920, Speaker A: Maybe the sort of distance from arch to Nixon is smaller than someone who's used to, you know, macOS, or used ubuntu for that matter. I'm not sure. Okay. Do you use any software or plugins for Nvim, for writing down notes? Nope, I do not. I'm terrible at keeping notes. I have a giant Todo file in my home directory, which is written in Markdown, and my terminal config prints it whenever I start a new shell. That is the extent to which I have a writing down notes and todos.
01:08:14.920 - 01:09:15.086, Speaker A: And it doesn't really work really well either because the to do document that gets auto printed is longer than the height of my terminal now, so I don't really even see everything that's on there. And in addition, I use my phone to keep track of things that I like have to do. And not just I need to get eggs, but also like, I should do a stream on this topic, or here's an idea for a crate. Or I found this bug in the standard library. Like the way I do this for myself, and it's stupid, is I set an alarm with the thing that I'm reminding myself in the alarm text. And the reason I do this is because it forces me to look at it later. Because if I have it in a to do list, it's like poll versus push, right? I don't go read the to do list very often, but if it gets pushed to me because my alarm goes off, I will at least look at it.
01:09:15.086 - 01:10:05.029, Speaker A: So I have some alarms that actually go off every week to just remind me about the idea and think about it some more. And then inevitably what happens is when they go off, I snooze them or I let them go until next week, or I transfer them into that todo document, which is at this point basically append only. And it's not an ideal setup, but I haven't really found a better way to go about it. And I've tried using to do apps and stuff and it ends up being the same thing. I think maybe the problem for me is so many of my to dos are long term to do's. They're not, you know, a thing that I can just do in 30 minutes, or at least that's somewhat rare. Like let me see if I can pull up my to do here.
01:10:05.029 - 01:10:49.840, Speaker A: I don't actually want to print my whole to do because there's some stuff in there, but like, all right, let me read, read some stuff from my to do list here. I want to add Miri strict provenance checking to haphazard flurry and left right. I want to do a follow up stream to the wait free algorithms. I want to do a stream on using cargo as a library. I want to do an unsafe chronicles and pointer provenance. I want to port more tests from folly into haphazard. I want to find new maintainers for a couple of the crates that I maintain.
01:10:49.840 - 01:11:36.386, Speaker A: I want to write a long form blog post on why we shouldn't be doing interviewing based on data structures and algorithms. I want to design a DND campaign again. I want to add a lint to clippy or the standard library to deny boolean arguments. I want to design a crate that does open loop workload generation. I have some errata I need to add into rust for restations. I want to do a director's commentary video of rust for restations. All of these things are things on my to do list that I can't just do right.
01:11:36.386 - 01:12:11.798, Speaker A: Like, these aren't a couple of hour projects. These are, I need to, like, schedule a block of time for them over long periods of time. And so they just end up going on the to do list. Like, they don't really work really well on. Like, if I have a to do app, the to do list is just going to be a ton of things that are very long term things. And then, you know, one or two things that I'm going to do next week. And then when it comes to, like, writing down notes, which is what the question was originally about, you know, notes more broadly, of keeping track of things that I learned.
01:12:11.798 - 01:13:17.912, Speaker A: I'm terrible at, and I, I used to be better at this, and then I realized I just never consult the notes, so why am I taking them? Which I think the number of times where it would have been useful for me to have kept notes is relatively low, and therefore I never, I never learned to be better. Yeah, I've heard obsidian can be pretty good because it lets you create, like, knowledge graphs, but there too. Like, I just, I just don't keep notes about things that I learn. And arguably I should, but I just don't. Yeah, one thing that is a problem with my current setup is that it doesn't really do synchronization. So I have this one to do file that I use on my laptop and my desktop, and I just scp it between them. And it's not a great way to sync, it's a great way to lose data.
01:13:17.912 - 01:13:54.220, Speaker A: At least it should be in git, but it's not. It's just a text file. I don't have access to it on my phone, which is why I sometimes set alarms to remind myself to move things from alarms on my phone into the to do file. It's a mess. And like, you know, arguably one of my to do items is figure out a better way to manage to dos. But the last time I did that, the improvement was have a to do file. I think at one point I had 30 alarms set on my phone for various random times, some of which were on and some were off.
01:13:54.220 - 01:14:48.410, Speaker A: The other thing is just like, you know, the I have open tabs on my phone for things that I had to do, and at the moment I have so many open tabs that why does it nothing that my firefox on my phone just chose. See if I can get it to focus there. The number of tabs open is just an infinity symbol because I have so many tabs open and it's not good. But I just haven't found a solution to this problem. And that's not like I also have pocket, right? So I have lots of articles that are also added on pocket. So these are all the things that aren't articles. It's a mess.
01:14:48.410 - 01:15:39.920, Speaker A: The answer here is, don't follow in my footsteps, don't do what I do because I don't have anything good to say. Oh, lots of people are asking questions now about things on my to do list. Okay, so denying boolean arguments. This was, I forget where I came across it. I think this was like I ran into a bug where the reason why my thing was broken was because in my head I had reversed the order of two boolean arguments to a function. And I spent like 3 hours tracking down why my thing wasn't doing the right thing. And it was one of those points where I was like, okay, I think I'm ready now to say we should just not have boolean arguments if you have more than one.
01:15:39.920 - 01:16:11.274, Speaker A: And so I came to this conclusion that it would be nice to have a lint that's probably like a pedantic clippy lint that's just deny boolean arguments altogether. Maybe you could say only deny if there's more than one. But I'm actually thinking just deny all boolean arguments. Like basically remove the boolean type from being allowed to be named. It should not appear instructs it should not. Well, structs might be okay, unclear, but maybe. But for function arguments, no, they should all require to be enums.
01:16:11.274 - 01:16:38.098, Speaker A: And then we just make it easier for people to have boolean enums. So you, like, you could imagine a maybe this crate already exists. I don't know. I haven't looked into it. It's on my to do list is to have a crate that makes it easier to create enums that are interchangeable with booleans to make their nicer to work with. And then just deny booleans throughout your codebase. Yeah, I mean, these are more projects than tasks.
01:16:38.098 - 01:17:03.020, Speaker A: And I think the answer here is that. Or the observation is I don't really have that many tasks, but I have a lot of projects or projects that I would like to do. Yeah, designing a d and D tick campaign takes forever. It's really fun. Like, I have a lot of thoughts for what I would want to put into this campaign, but I don't have the time. Or rather I haven't made the time. And, you know, it's because I make time for other things instead.
01:17:03.020 - 01:17:48.484, Speaker A: It is true that long term to do should really be split completely. And I think, you know, I don't really have that many short term to do's. Or maybe I should get better at, you know, keeping two lists and moving things between the lists as appropriate. I don't know if there's a tool that lets you do that, that lets you keep basically a sort of two tier list, but I don't know. Unclear director's commentary for the book would be pretty fun. I think that might be something that I would do as a. Maybe as a paid thing.
01:17:48.484 - 01:18:22.620, Speaker A: Like this might be a good candidate for Patreon, for example. Right. Of saying, you know, if. If you donate more than x amount, then I'm gonna do, you know, live streams where I read through the chapters or something. I don't know yet, but I think it could be really fun. I have considered actually opening a bug tracker for myself. Basically use like GitHub issues or something and use that as the way to keep track of my to dos.
01:18:22.620 - 01:19:06.532, Speaker A: But that feels too. Feels too heavy duty. Like these projects, many of these project things are just like one line things that I think ultimately what I need to do is I need to take a sabbatical for like a year and just do these things. Alternatively, instead of taking a sabbatical, what I would do is just do open source and teaching for a year, and then maybe I'll actually have time to get to all of these things. And like many of these, I could just stream, right? Like strict provenance checking, for example. I think it would be a great stream, like a useful stream to show how you add that kind of checking to highly concurrent libraries. So there's a lot of meat here for potential teaching opportunities.
01:19:06.532 - 01:19:48.250, Speaker A: It's just that I don't. At the moment, I don't have the time. And this is one of those places where I really think that if I didn't have a full time job, I would be able to do way more of these things and turn them into teaching. And the question is just, is that something I could live off of? How would you interview instead of data structures and algorithms? I think testing problem solving ability is way more important than asking knowledge and memorization based questions. I agree. I think data structures and algorithms are knowledge and memorization based questions. Problem solving has nothing to do with data structures and algorithms.
01:19:48.250 - 01:21:30.700, Speaker A: That's sort of where the core of my disagreement with data structures and algorithms comes from. I think when you want to get to actually asking questions that are problem solving, I think you want to ask questions where there aren't right answers, where they actually, you have ambiguous problems, and data search and algorithms very often do not. For example, one interview questions I like a decent amount is something like write the scheduler for the elevator system in a building. That's the entirety of the prompt, and then part of the interview process is which questions does the candidate ask? And then we explore the problem space together. So you might ask, well, how many elevators are there? How many people are there? How many floors are there? What is the general pattern of when people come in and when people leave? Are there restrictions on what kind of controls we can have for these elevators? What's the size of the elevators? What country is this in? Because that might change how people want to have the elevator experience. Beverage. And then you might also, like, ideally, you also get to writing code, right? So you actually write an elevator schedule and you try to come up, well, what is a good, if you were to write a crate that implements the elevator schedule, what should the API look like? Why do you make the decisions that you do? And maybe part of that is you have to choose to use the data structure as part of it, but it's much more of an organic choice than it is.
01:21:30.700 - 01:22:59.120, Speaker A: How do you rotate a red, black tree? Let's see, let's see. I'm just scanning through the chat here to see if there are more follow up questions to this. Trello Kanban. Yeah, I mean, there are a bunch of, you know, mechanisms for this, but part of the challenge I have, right, is that all of these projects are, I think of them as a bucket, where sometimes I have the spare capacity to reach into the bucket and grab a thing, as opposed to, I'm working on all of these things in parallel, so I don't really need planning for them as much as I just want to make sure that I don't lose track of them. And then sometimes I'm working on some of them. But that means that really, it is just a sort of flat list, sort of a set bucket. Get Morgan Freeman to read through the rust first station chapters.
01:22:59.120 - 01:23:34.590, Speaker A: That's pretty funny. Okay. Yeah. So someone pointed out in chat that clippy does have a link for excessive bouls. That's not what I want. It's close, but I think I actually want deny bouls, and I think I wanted to go as far as denying bools in tuple structs as well. Tuples, tuple structs, function arguments, return values.
01:23:34.590 - 01:24:20.346, Speaker A: Maybe not return values, unclear. But I want it to be even more pedantic than just, you have many bools as arguments. Dysfunction. Full time job gets in the way of doing really interesting things. Yeah, I mean, I would love to just full time do these projects. I think it would be an immense privilege if I could, but maybe one day. For the boolean thing, I think one thing that might be needed is actually language improvements to rust to make it possible to have a boolean like enum that actually you can use as a boolean.
01:24:20.346 - 01:25:14.080, Speaker A: That would be really cool. Not just in tube pool, but actually have like a. You know, currently, the rust conditionals all only take expressions that evaluate to a bool type. I wonder if there's a way to have them take expressions that evaluate to an enum type that has a particular attribute that makes them act like bouls. That could be really cool. Okay, I think it's time to move to the next question. How's piano going? Okay.
01:25:14.080 - 01:26:06.952, Speaker A: Not as well as I would have hoped. I haven't abandoned it. Like, the piano is still in my living room. Every now and again, I'll go play on it, and every time that I do, I'm very happy that I do, but I'm not doing it regularly enough to remember the progress. So I feel like every time I regress a little bit, and then I make up for the regression, but don't do it again until I've regressed sufficiently to be where I was, which is really unfortunate. I think this is another one of those make time problems where really, I should just say, every Thursday afternoon, I play the piano, and that would be an immense leap from where I am right now. I think, ideally, if you actually want to get, let's say, capable at doing this, I would have to do it more often than that, and I think that might be worthwhile.
01:26:06.952 - 01:26:45.762, Speaker A: Oh, camera's shaking. But I. Yeah. This question makes me realize that I really need to just set a day a week where I play the piano, because I really do want to learn it. I enjoy it a lot when I play, so I am roughly able to play with both hands. I'm using this. It's a piece of software called flow key, where you hook up.
01:26:45.762 - 01:27:13.748, Speaker A: So I have an electric keyboard. You hook it up to an iPad, you run the app on there, and then you connect your headphones can tell whether you're pressing the right keys. You can do it without the cable, I think, too. And it just uses, like, audio recognition. And so it's pretty cool that, you know, it can tell whether you're playing the right things. The problem is, I don't have the beat well enough in my finger. Or rather, I take too long to find the key I have to press.
01:27:13.748 - 01:28:14.630, Speaker A: So I can't play it to rhythm or to beat. And so I just play the same song over and over and over again on the sort of move when I've pressed the right keys mode until I know the song or I know the moves well enough that I can play it in real time mode. But trying to get to the point where I can get a song and I can just play it by watching in real time or even in slowed down real time at beat is I can't currently do, like trying to. For example, one thing that, you know, I think would be great is the ability to play. If I had the ability to get a sheet music and let's say simple sheet music and play it at half speed, but at the correct half beat, and I'm nowhere near there. Set an alarm to play piano. You're not wrong.
01:28:14.630 - 01:28:35.920, Speaker A: I have a piano for baking bread. I have piano. I have an alarm set for baking bread. I end up baking bread now almost like every week and a half, maybe week and a half to two weeks. And that's also really fun. I'm very happy I started doing that. Very hard to find good bread in the US, and it's a very peaceful way to play.
01:28:35.920 - 01:29:06.530, Speaker A: Oh, that's funny. When I retired, I was going to do all the side projects I didn't have time for. Yeah, my concern is that I'm going to end up with a similar kind of thing of, oh, I'll do them all when I retire. But first of all, that's a very long time for now. And second of all, I think by the time I get there, I'll have accumulated so many things that there's no way I get to even a small fraction of them in, you know, whatever time I have left. So I really think I just need to. I need to find a way to start doing them.
01:29:06.530 - 01:29:44.448, Speaker A: And I think the way to do that is not work full time, which is easier said than done. At the moment, I'm playing all sorts of things. I'm basically just, you know, Floki has a list of songs that you can attempt to play, and I've. The latest one I practiced on was happy birthday, because it's. It's actually. You can play it at various difficulties, so you can play it in a very simple mode, and you can play it in a very complicated mode where there's all sorts of, like, when it, like, flourishes. And so it's an.
01:29:44.448 - 01:30:13.450, Speaker A: It's an interesting one to, like, build up your expertise on. It's immediately useful. And it's a song that I know the beat of so well. Like, I know how it's supposed to sound. So when I play, I can more easily recognize whether I'm doing the right thing or the wrong thing. It's not a very interesting song. So, you know, I'm gonna graduate from that one at some point, but that's where I started.
01:30:13.450 - 01:31:09.112, Speaker A: Can you play and sing at the same time? That's a good question. I think I probably could if I've gotten to the point where I, you know, I've practiced a song long enough that my fingers sort of move on their own, but I don't think I'm at the point where I can do a performance for stream yet. I used to have a guitar many years ago, and my dating profile used to say that my guitar skills were at 2.71% or something. I used e to six significant digits as the percentage that I knew how to play the guitar. And that was a great way to signal how much of a nerd I am. I don't know that it was true.
01:31:09.112 - 01:31:37.780, Speaker A: I think I knew less than e percent, but even so, it was a fun little tidbit. And yeah, the bread I bake is soured out. I have a yeast that I made from. From nothing. From air. From thin air. Let's see.
01:31:37.780 - 01:32:30.316, Speaker A: All right, let's move to the next one. What is your advice for an undergrad student of computer science? Like, working on resume and stuff to get admission from institutes like MIT? What do universities focus on in the application process? Okay, so given that you are currently an undergrad, this suggests that you're applying for grad school. And I think I have. Let's go with three pieces of advice. My partner recently noticed that I do this a lot, where I explain how many enumerations there are, or facets there are to my answer, and then I enumerate them. And I have started noticing that I do this way more. Like, there are three things first, and I'm going to do the same thing here.
01:32:30.316 - 01:33:52.100, Speaker A: So the first thing I would say is think really hard about whether you want to get into grad school. I don't think it's a bad choice, but I do think it's a, it's grad school is a, it's a big commitment, it's a big opportunity cost and it has the potential to be miserable. It also has the potential to be great, but it really depends on whether you find or whether you have an area that you truly care about enough that you can dedicate x years of your life to and do very little else. You're going to be burned out at the end about the thing that you ended up working on. And you know that there are many alternate avenues to going into grad school. And you know, the opportunity cost is not just the cost of university, at least in the US. It's also that you're not working in industry, so you're not making the salary of working in industry, but you're also not building up industry experience, which means that when you start work x years down the line you'll be at a relative disadvantage because academic experience doesn't really count as much in industry.
01:33:52.100 - 01:35:48.640, Speaker A: So first bit here is do you actually want to go to grad school? Second one is the more prestige universities at least my impression is care a lot about recommendation letters, and in particular they care about what the recommendation says about you. And I don't mean that in the sense of what words are on the page, but what information about you can they extract from that recommendation? And a big part of that is who wrote the recommendation? Is this a person that they know? Is it the person they know of? Is it a person that if they look them up they understand that this person has, let's say, some amount of integrity or understanding or knowledge that's relevant to what they're writing. And the reason I say this is because it's partially from, you know, just conversations with professors over the years, but it's also my own experience because I applied to MIT several times, both for undergrad and grad school. And the time I got in was when my recommendation letters were from professors that were relatively well known. And I don't mean that in the sense of famous, but just in the sense of like, you know, they were professors at an established university in the UK, you know, they had published papers in conferences that are well known within the systems field. And so in general when they give a recommendation it carries some amount of weight and trustworthiness. So I think even if someone else, someone entirely unknown wrote the exact same words, it wouldn't have the same impact.
01:35:48.640 - 01:37:03.898, Speaker A: And I think having solid recommendations, reliable recommendations, is very valuable. It's more valuable than your sort of grades, youre your extracurriculars. Ultimately, that's a big part of it. And then the third thing is, this depends a lot from university to university, and it is a little different depending on the country you study in as well. But at least in the US, very often you're working with the professor or in some cases with multiple professors, although that is a little bit of a luxury. But you should make sure that you can find a professor that you align with. So if you can find a professor or a research lab where you think what they're working on is really interesting, you think it is like you have a passion for it, you have a drive for it, you have an interest in it, then try to reach out to them, try to see if they can recommend ways to get more familiar with their work.
01:37:03.898 - 01:37:48.680, Speaker A: And I say that because it means that you can write a more compelling personal statement for why you want to get into this university, why you want to get into that lab. If you can point to this professor, these papers, this lab, I want to do what they are doing. I have followed their work. This is the kind of stuff that I'm interested in. These are the kind of ideas I have for graduate projects. That makes for a much more compelling story in your personal statement, in your application letter, than if you just write, I really like computers, or, I want to work in distributed systems. If you have more concrete stuff, you can talk about that that matters.
01:37:48.680 - 01:39:51.362, Speaker A: It's not so much develop a relationship with a professor that might help, but it's also much harder to do. It is unlikely to yield any particularly meaningful results because very often you're applying to the university first and then to the lab, but getting in touch with them, or at least looking up the kind of work that they do and familiarizing yourself with that is going to help you in writing a better application. Are there follow up questions on this one? Otherwise, I'll move on. All right, next question. Is rust language adoption pace slowing, staying the same, or accelerating in the enterprise currently? Do you foresee any changes in this pace given the current Rustlang roadmap? I think Rust adoption is accelerating, and I do note the difference here between accelerating and momentum, that it's not just that rust has a certain amount of momentum and therefore it's growing, but I think the rate of adoption is also going up. And the reason I say that is because I think a lot of companies are. Have been hesitant to pick up rust because it doesn't have a track record of successes.
01:39:51.362 - 01:40:47.762, Speaker A: And I think what we've seen is that that track record is starting to become more established. More companies are announcing that they're using rust. More companies are announcing gains from using rust or switching to rust. More companies are investing in rust and doing so publicly. That, in turn, builds confidence that rust is around to stay, which reduces the perceived risk of the language, which means more companies are willing to step up and try it for them themselves. I don't know how long we're gonna see that rate increase go, but that's certainly the impression that I have from the industry as a whole, that I think the rate of adoption is going up. And to be clear, I don't actually think that the goal here should be rust adoption at 100%.
01:40:47.762 - 01:41:22.982, Speaker A: I don't think Rust should be used for everything or everywhere. I don't think everything should be rewritten in Rust. So the goal isn't to get to 100% saturation. And I don't think we would ever get there, either. But I do think what we're seeing is also a recognition that there are a lot of domains where Rust can do really well and is actually a good long term choice. And so we're seeing it being branched out into several industries. Right.
01:41:22.982 - 01:41:59.002, Speaker A: So, in the early days, it was more, it came into high performance settings, low level system stuff, embedded devices. But we're seeing much more now development into cryptocurrencies. Of course, that's been happening for a while. Game development, we're seeing it being used more for its cross platform capabilities. Rust is a pretty solid story for developing for macOS and windows as well. And so you see it being used for building less so GUI. So though that is changing.
01:41:59.002 - 01:42:41.830, Speaker A: But even command line applications, you want to run on multiple platforms, Rust is a pretty good candidate language for now. I think we're seeing this with adoption into Android, I think, is also something that might see a decent amount of growth. I think adoption to the Linux kernel ends up being another one of those sort of stamps of approval that makes more companies willing to consider doing it themselves. I think this acceleration is probably going to slow. So I think it's accelerating right now, but I think we're going to end up slowing that acceleration, but keeping the velocity probably, and not too long. Like, I think the. The higher the.
01:42:41.830 - 01:44:05.550, Speaker A: The rate increase is probably gonna stop in, let's say, you know, a year from now or something. I think it's a result of the times, like a result of all of the public endorsement of Rust, the language over the past twelve months. Can you talk about rust adoption at AWS? This gets into, I don't say murky waters, but it gets into, like me having to make a judgment call about what things I am, and I'm not allowed to say that Amazon is doing, so I'm not going to go too deep into that. What I will say is my job at Amazon is encouraging rust adoption not at all cost, but just advocating for where appropriate, and also making the rust experience the best that it can be internally. And that's going very well. In general, I think the rust experience at Amazon is a very good one, and the fact that there's been this investment in making the experience of using Rust a good one is indicative that the company certainly believes in the language. That's what I take from that decision to invest in the developer experience.
01:44:05.550 - 01:45:18.430, Speaker A: All right. Would you rather fly in a plane written with Rust software in it, versus, let's say, Ada software or Lisp like language like clojure? So what I'll say here is Rust is still a young language, so I don't think it has quite the safety posture of a language like Ada, which, you know, has been dedicated to this from arguably the start and for a very long time. I think Rust could get there. But I do think there are some things that we still want to see there. Things like long term stability of rust, of supporting older versions where things are known to be stable. Whereas if you're building airplane software using Rust, knightly, that seems unfortunate, but the likelihood of you having to do so is also higher than it is with Ada. You're not going to be using something that's equivalent to nightly.
01:45:18.430 - 01:46:07.520, Speaker A: Same applies to the ecosystem around it. The testing. I know that rust has gone through a lot of testing, but I don't know that it's gone through the same kind of formal testing and formal testing over time like Ada has. So I think my vote here would be, I would go with Ada for now, but I think Rust has the potential to be a good candidate here. Would you deliver packages with drones running firmware written in Rust? I mean, I think it's the same kind of argument, right? Of I would rather it be written in rust than in C. I would if it was already written in Ada. I would continue to use the ones written in Ada.
01:46:07.520 - 01:46:53.202, Speaker A: But I think for a greenfield project, you're relatively unlikely to use Ada. You might choose between Rust and C. And there I think the choice is pretty obvious. What are your favorite podcasts? Oh, let's see. Let me open my podcast app here. Let's see, let's see, let's see. I'm current.
01:46:53.202 - 01:47:22.380, Speaker A: Oh. I recently listened to a podcast called Hot Money from the Financial Times, which I thought was really interesting. It's a documentary podcast about the finance behind the porn industry. I thought it was a really interesting thing to listen to. I think there was a lot of stuff I didn't know and thought was fascinating. Freakonomics radio is fantastic. I think I've listened to every episode.
01:47:22.380 - 01:48:24.206, Speaker A: It's great. If you haven't listened to it, there's a podcast called you are not so surprised. Smart. So, to explain what freakonomics is, first, before I move on, Freakonomics is so there's a book called Freakonomics, which was about, I don't know how best to describe it, the implications and nuances of the economic system in a way that's understandable to people who aren't economists. And there's a podcast now that I think their tagline is, explores the hidden side of everything. And it's essentially, they go into really interesting questions like, how do we measure whether working from home works well or not, or whether, let's see what some of their most recent episodes are. Has globalization failed? Nuclear power isn't perfect? Is it good enough? Should public transit be free? And they explored from the side of economics.
01:48:24.206 - 01:49:38.664, Speaker A: And I think it's a really interesting lens through which to analyze these questions through. You are not so smart as a podcast about social psychology. And it's sort of taking, I really like the format where the person who runs the podcast basically interviews experts in different fields of social psychology and tries to get at not just what are these phenomena that we have observed in humans and human behaviors and human thinking, but also how do they, what implications do they have for how you live your life and for how we interact with people in our lives? Stuff you should know is a very widely known. So I'm gonna skip over talking about that too much. Let's see, what else do I have? There was a podcast called Constitutional, which I thought was really interesting. It was sort of single season podcast on the first Amendment in the US and related topics that I thought was. It's great.
01:49:38.664 - 01:50:14.400, Speaker A: It's from the Washington Post, I think. Similarly, there's also. Oh, no, sorry. It's about that one is about the, about the constitution. There's one called make no law, which is about the First Amendment and some of the implications and non implications of the First Amendment. Which is from the legal talk network, the podcast that sadly stopped now. At least they haven't published episodes in a long time called playing for Fun, which was two people talking about like they're not really video game reviews as much as they are.
01:50:14.400 - 01:50:44.622, Speaker A: Let's talk about all the things that we're excited about in video games. Let's not talk about all the things that they do poorly, but things that make us happy, make us feel engaged by video games. And I really hope they come back and make more. I think those are some of the top contenders. Not another D and D podcast is also great. I particularly like the first campaign they've done. I think they're on campaign three now, and for me, nothing beats the first campaign.
01:50:44.622 - 01:51:25.570, Speaker A: But it's a really fun podcast to listen to. It's similar to other narrative D and D podcasts where they play live like critical role and such. But I like this one a lot. I've also found intelligence squared pretty interesting. They do a lot of debates on all sorts of political, social, economic questions, and it's fascinating to hear actual debate, debate format debates as well on these topics. I'll stop there, and I'll also, of course, shout out rostation station, which is. Which is also fun.
01:51:25.570 - 01:52:19.460, Speaker A: Let's see. What is your podcast app? Oh, I use one called pocket casts, which I've been super happy with. I've used it for years. Let's see. Okay, I think that's a good place to move on to the next. Let me also put the Q and a link in chat again, in case you want to put more. I see there's more questions in chat that should go there.
01:52:19.460 - 01:52:57.570, Speaker A: Anything that's a different topic than what I'm currently talking about, I'll put in there so that I try to give everyone a fair chance to get their question answered. You mentioned you don't enjoy LA and that you'd like to move in a couple of years. What stops you from moving now? Nothing really stops me from moving now anymore. In fact, my plan is to probably move next year. I don't know exactly when. I think it's relatively likely that I'll end up moving to Norway with my partner, probably towards the summer of next year. It's not set in stone yet, but that's sort of what we're currently thinking.
01:52:57.570 - 01:53:35.410, Speaker A: I think for me, the big question is going to be whether I find Oslo in particular an interesting place to live. Like, one of the reasons why I left Norway in the first place was because it felt a little too small. Maybe. Maybe uninteresting, maybe, you know, a lack of. Not necessarily diversity, but diversification. And, you know, over the past ten years, Oslo's changed a lot. There's a lot.
01:53:35.410 - 01:54:05.580, Speaker A: There's been a lot more influx of people from all over, doing many interesting things. A lot of more businesses that have popped up. The city has grown a fair amount. And so I'm excited to see whether now it is a place where I will find that I have an interesting life. And I'm also curious to see whether my partner, who's from the US, whether she will enjoy living in Norway. You know, it's not for everyone. It is colder during the winter, there's less light during the winter.
01:54:05.580 - 01:54:54.420, Speaker A: But it's also, you know, a country that is a very pleasant place to live. And, you know, summers are very nice there, and then you have, you know, daylight throughout part of the night. Winters are cold, yes, but they're also very cozy. And so, you know, I'm hoping that we both end up enjoying it if we don't. If we stay there for a year and then decide that this is not for us, we want to try somewhere else. We would probably go to London and try that for a year and see whether that's a better candidate. We've both lived in London a little bit before and enjoyed it immensely, but since Brexit, it's become a much less attractive place to move.
01:54:54.420 - 01:55:51.818, Speaker A: So, you know, the list of good options is not as long as I would like it to be. There are other places in Europe, too, that I've considered. It's a little. It depends on our tolerance for moving somewhere where English is not the primary language or Norwegian, because I know Norwegian, but, like, the Netherlands is a place that I've looked at a bunch before. Germany, Spain, there are other candidates, but certainly, I think for us, Norway and the UK are pretty high on that list. And there's a question here of, are you going to continue working from AWS, from Norway? I think so. I have been thinking about whether when I move, is that a good time to, let's say, reevaluate my options? Because when I was initially looking for work, after I graduated, first of all, I was in a different place in life.
01:55:51.818 - 01:56:37.770, Speaker A: But also there were a lot of companies that I couldn't work for because they were based in Europe and couldn't sponsor a visa in the US. So now if I move to Europe again, suddenly there are a lot more candidates for companies that I could work for. At the same time, it's not ideal to do such a long move and also be switching your job at the same time. So I'll see what I do. But I think there's a decent chance that I'll continue working for AWS as I move, and then I'll see down the line whether there's then a better chance to make a change or even to try full time for teaching an open source. We'll see. I don't really have an answer there.
01:56:37.770 - 01:57:11.138, Speaker A: Yeah, I've had people recommend that I move to Madrid, to Barcelona. That would be pretty fun, too. What are your problems with La? Oh, I despise La. Let's see if I can summarize the top three. First of all is the desert. It's dry, it's always sunny, and it's always warm. And I'm used to cold.
01:57:11.138 - 01:57:28.722, Speaker A: I like seasons. I want there to be snow and rain. That makes me happy. I like darkness. Sometimes I want clouds. I miss not being in this climate. Everything here is dry.
01:57:28.722 - 01:58:15.200, Speaker A: There aren't really forests, there's not water, there's not really mountains. I know you can drive to those things, but that's different. Second part is related to that, which is nothing is made for walking. It's a place where you have to have a car, more or less, and everywhere is a drive, which also means everywhere is traffic, because everyone has to drive everywhere. It's not really a place where, you know, you can just go walk to the store, or you can just walk to a friend's house or to an event. And this ties into the fact that public transport is not very good here, as opposed to in Europe, where it's actually really good, certainly in Oslo. And that makes me sad.
01:58:15.200 - 01:59:12.800, Speaker A: And the third part is, LA is in the US. And there are a lot of things that I don't like about the US, and I don't necessarily want to enumerate all of them, because there are a lot. But just I don't like how Americans see their government, and I don't like how the government sees the people. And I don't love how companies see people. And it just means that it's nothing. A pleasant place like, it's not a good place to be human. And this ties into the way the healthcare system works, it ties into how lobbying works, it ties into immigration, it ties into employment rights, it ties into unionization, it ties into.
01:59:12.800 - 01:59:57.886, Speaker A: I just. It's not. What's the right word here? I don't know. I just want to be in a place where people have. Where people have more rights. It's the best way I can summarize it, and there are upsides to the US too, but there are upsides that I think I'm willing to compromise on. The upsides are things like wages are certainly in my sector, wages are much higher here.
01:59:57.886 - 02:00:32.408, Speaker A: I think the pay cut to move into Europe would probably be closer to 50%. It's pretty bizarre how much the pay cut would be. It varies by level, varies by industry, but like, it's a pretty significant cut. There's a lot of tech companies here. Like, if, you know, given that that's the sector I'm in, working here means that you get a lot of the big opportunities. Like this is where they happen. And if you're not here, you're going to be more distanced from them.
02:00:32.408 - 02:00:59.760, Speaker A: You're going to have less of an opportunity to be involved in those opportunities. But I don't think those are worth it for me. Come back to Australia. I really like Australia, actually. I think I would really like New Zealand too. The big problem for me is they're too far away. Think it's.
02:00:59.760 - 02:01:42.138, Speaker A: I think it's too costly to live that far away socially, not, not economically. See, okay, so someone put in chat. Sadly, governments suck. And I don't agree with that. Some governments suck. And I think, you know, in the US there's a lot of evidence that the government sucks at many things, but that doesn't have to be the case. But the US has gotten itself into this unfortunate spiral of people don't trust the government.
02:01:42.138 - 02:02:08.150, Speaker A: When I say that, I mean trust in multiple ways. They don't trust them to make the right choices. They don't trust them to execute on things well. They don't trust them to be responsible. But as a result, the government ends up having both a low bar and low investment and few resources, which in turn means they can't do those things well. And so people lose further trust. And that's the case in the US, but that's not the case everywhere else.
02:02:08.150 - 02:02:50.450, Speaker A: So I think it's unfortunate that the US has gotten into that situation. I think it's hard to get out of. What's your opinion on the visa restrictions on non immigrant workers? It's awful. Living on a visa is abysmal. Okay, abysmal is maybe extreme, but like, it means that there's so many things that I cannot do right, whether that is, you know, have a patreon or sponsorships inside of my work. It means that if I were to try to write a second book, for example, it's unclear that I'm allowed to do that here because it would count as work for the publisher. I'm not allowed to do any work that's not tied to my primary employer.
02:02:50.450 - 02:03:36.884, Speaker A: Your healthcare is tied to employment. It's not really visa related, but it means that you have such a strong dependence on your employer that you have to be much more willing to compromise with them because you can't. Like, first of all, they can fire you on the day, in which case you also lose your health insurance on the day, but because they are your visa sponsor, it also means that you need to get a job very quickly after or you have to leave the country. And like, picking up and leaving is not trivial. So it's not a good situation to be in. And, you know, this is going to be the case other places in the world too, like the UK, has somewhat similar limitations. Although I think there.
02:03:36.884 - 02:04:05.092, Speaker A: I think there are some exceptions that maybe I could make use of. But in general, working on a visa is not nice. One thing I do want to point out. So some people in chat is like, yeah, there are things that aren't nice about the US. To be clear, I'm very happy I came to the US. It's not as though I think it's not worth being here. It's more that this is not where I want to live long term.
02:04:05.092 - 02:04:54.844, Speaker A: I think having the experience of having been here and like, you know, going to the university I went to there aren't good. How to phrase this, the US has some really good universities, some of the best in the world, and getting to go to them is worth it. Right? So I wouldn't take that back. Same as I'm very glad I got the opportunity to work for Amazon, for example. I think it's been a really interesting, unique position that I've gotten to be in and work within. And I don't know that that would have happened if I hadn't been here. And same with the ability to have the kind of salary that I've had has also been very liberating.
02:04:54.844 - 02:05:37.970, Speaker A: Right. It's not that I necessarily have, you know, lots of expenses, but rather it allows me to save much more so that when I move, I have more of a buffer, more of a Runway to try other things myself, you know, I think that's an immense upside to coming here. It's more that it's just not. It's not, for me, a long term place to make your life be rooted. I have heard good things about Canada, too. I'm not opposed to Canada. At the same time, I really like Europe being able to so easily travel to many very different countries has a lot of appeal to me.
02:05:37.970 - 02:07:09.920, Speaker A: And you don't really get the same with Canada. Won't your partner face the same challenges in Europe if she's from the US? So she would be on a visa, although Europe in general, this is not true for all countries in Europe, but many countries in Europe have, it's called the love clause or something, where she can actually be on a partner visa because we've lived together for at least two years and she's not married to someone else and I'm not married to someone else. But basically, if you can prove that you are essentially life partners, then that is sufficient for her to be on a visa that's similar to as if we were married. And that makes it much, much easier, because then, I mean, it is true that she would then be on a visa that's dependent on me, but that's a better position than being in one that's tied to an employer and it has much fewer restrictions as well, as far as I'm aware, precisely because it's not tied to employer sponsorship. So that would be easier. Whereas in the US, there's no such clause. So it would be better if, like, if we got married, then the visa situation would be different.
02:07:09.920 - 02:07:48.426, Speaker A: But, you know, I don't really want to marry for a visa either. I want to marry for the right reasons. All right, let's see. I didn't want the question. The question has gone so far down the list, I can't mark it as answered. Where did it even go? You voted on all these other questions. All right, fine.
02:07:48.426 - 02:08:14.640, Speaker A: I'll just. I'll just ignore it. Do you read non tech related books as well? Any recommendations? I do. So I recently reread the Wheel of Time series, and I just love those books. I think the series that's come out now is fine. It seems okay, but the books just. I love them.
02:08:14.640 - 02:08:48.390, Speaker A: I read them once when I was much younger and recently reread the whole series, or I listened to much of it on audiobook and read some of it on paper. It's just. I love it. I've also been reading Harry Potter and the methods of rationality, which is a fantastic read. It's both very funny. I actually laugh out loud while reading, but it's also just a really good. I don't know how to describe it.
02:08:48.390 - 02:09:26.280, Speaker A: Exploration of rationality that actually, I think, teaches you some good ways to think. It's really good. It's really good. What else have I been reading recently? Wheel of Time has taken up so much of my time that it's been a while since I read anything else that was nonfiction. I did read shortly before I started Wheel of Time again. I read the Stormlight archives. I read mistborn.
02:09:26.280 - 02:09:59.530, Speaker A: I read what's called the King Killer Chronicles. So there's been a lot in that kind of vein for me recently. And those are, I would recommend all of them. They're all really fun reads. What else have I read that's nonfiction recently? Let's see if I have anything here. Oh, yeah, the what if books are also great. Unclear whether they're nonfiction.
02:09:59.530 - 02:10:09.576, Speaker A: Wait, hang on. Nonfiction? I've inverted the question in my head. No. Okay. The question was non tech. Great. And I turned it into nonfiction in my head.
02:10:09.576 - 02:10:45.780, Speaker A: Non tech. Yes. So what the what if books are also non tech? The what if books, if you're not aware of them, is they're written by the author of XKCD, and they're basically like explorations of the realities of theoretical questions. Like, if you managed to hit a baseball at the speed of light, what would happen? And it's really cool. It's really, really cool. I think that's. I think those are the recommendations I have.
02:10:45.780 - 02:12:05.218, Speaker A: Can you talk about different allocator options and choices in rust? I don't have a lot to say here. So the allocators are generally available to you are the system allocator, gem, alloc, and mimalloc. And there's also stuff like bumpalo, like, allocators are more like arena allocators. I remember when I worked on Noriae the, I actually found a decent amount of speedup from using the system allocator instead of jmalloc, and I'm trying to remember why. I think jmallock struggled a lot more with many small allocations. It's intended to be better for concurrent allocations, but I think my experience was that it actually worked less well when you had many, many small allocations, which Noria ended up doing a lot of. But that's ages ago, and I haven't really experimented much with it afterwards.
02:12:05.218 - 02:13:21.740, Speaker A: I think it's one of those things where, like, use benchmarks to convince me why you want to switch away from the default. Right. Like, the system allocator is generally what you should use, unless you have solid benchmarks with real world workloads that demonstrate a measurable, reliable, stable, significant impact on your benchmark outputs. And if you can't, then don't do it. It's just not worth the additional complexity, the annoyances and debugging, just use the standard arena allocators, I think are a more clear win choice for the use cases where they're convenient. So for things like game programming, for example, where you would do a lot of allocations for one frame, and then you're going to deallocate all of them at once, then having the ability to just do a huge set of allocations and then just deallocate them all at once is pretty valuable. It does assume a little bit that you, you don't have to run destructors and stuff, so there is some complexity there, but it's not something I know I can speak to in a lot of significant detail.
02:13:21.740 - 02:15:07.430, Speaker A: See soon starting my first software engineering job and feeling kind of anxious nervous about it. Any tips for the first weeks or months? This is hard to say without knowing the company, because different companies have very different, shall we say, expectations for people who start. My first bit of advice would be don't be nervous. And it sounds silly, right, but at least, at least at Amazon, my experience has been that you're not really expected to be productive for a while in the beginning because there is so much to get to grips with. That's internal stuff, like, not stuff you could have already known, but just you have to understand how the internal infrastructure works, how the internal code works, how to even write code internally and get everything set up. And so you have a fair amount of time for that soft onboarding ramp where you get to get used to what it's like internally. And so I wouldn't be too worried if your concern is, you know, how will I perform as well as they expect when I first join.
02:15:07.430 - 02:15:42.480, Speaker A: I think there's a separate nervousness around. You know, this is my first job. This is my first engineering job. I have no idea whether I can program to the standards that people expect, and that one's harder to address. Like, I still think the answer is don't be nervous. But I think, you know, the, the imposter syndrome is a very real thing. And I think if you're a new engineer, it's even more likely to, you're even more likely to feel it because you don't have the experience that tells you that you're doing well at your job.
02:15:42.480 - 02:16:50.984, Speaker A: What I would say, though, is that don't focus too much on whether other people think you're doing a good job. That does matter to some extent. Your performance evaluations and such are going to depend to some extent on what other people think of your work. But it's a terrible benchmark to use for yourself because you won't know what other people think. And instead focus on making sure you think you do a good job and also focus on what you think is the right thing for you to work on. Like if you get into a job and you feel yourself, you know, procrastinating all the time, that's an indicator that you're not working on the right thing. And that might be you're in the wrong job, but it doesn't mean that you're a bad engineer, right? It doesn't mean that you're bad at writing software.
02:16:50.984 - 02:17:54.136, Speaker A: It might just be that this isn't the right position for you. And, you know, I think there's a real concern when you're first starting out, and I think this applies equally well later on in your career that you end up under counting your own contributions or setting too high of a bar for yourself. And as a result, you overwork because you feel like you have to compensate, even though no one actually told you that you had to compensate, but you feel that way maybe because you aren't that interested in the works. You feel like you're slacking off, but then you feel like you have to catch up because you feel like you were slacking off. And it's just, it's this vicious cycle where you burn out. You feel unproductive, you feel like you're not doing well, even though there isn't actually any evidence to demonstrate that that is the case. And so I think, you know, be very mindful of the fact that you, your job is a job.
02:17:54.136 - 02:18:41.342, Speaker A: It is not you. It's not your personality, it's nothing. Your value as a human right, it is a job. But also try to find a job that you enjoy, because then much of that nervousness is going to go away because as you start working on it, you feel that you're working on things that you enjoy doing. And if that's the case, you worry much less about whether I'm engineering good. It's a little bit of a rambling answer, but, but the, I think overall, like, in general, most of the pressure you feel is probably going to come from yourself. If it's coming a lot from other people, that indicates a different problem, that that might indicate that there's a sort of management problem.
02:18:41.342 - 02:19:42.507, Speaker A: Essentially, it might indicate that there's a mismatch between how you want to work and what the, how the company wants you to work, which might indicate that this is not the right position for you, but it should be a pretty, it should take a lot of evidence for you to actually be like, concluding that you're not doing a good job as an engineer, like, focus on what measurable evidence you have for that being the case in general, that won't be the situation. There'll be something else that the problem is. Oh, funny bots. Alright. Block. Nice. Another one.
02:19:42.507 - 02:20:00.936, Speaker A: Block. I love blocking bots. Bye bye. Okay, let's see. I hope that answered the question. I mean, I know it's. It's really terrifying to start your first programming job.
02:20:00.936 - 02:20:51.604, Speaker A: Like, for me, it was similar when I started Amazon, right? Because all my background, or very much of my background, was in, in academia. And so suddenly being like, I'm gonna be at a company now is weird. But it wasn't a problem. I think partially for me, I sort of went into it with the mindset of I know what I'm doing and that helped a lot. And maybe it's. Maybe I was sort of self delusion. But I think it does help to go into the mindset of no one else is nervous about you joining the company, right? You got hired, so no one else is nervous.
02:20:51.604 - 02:21:18.510, Speaker A: So why are you nervous? Okay, let's see. I think I'm gonna keep going. I'm just. Okay, so slight aside, I was, you know, the setup for the stream was that I wanted to. That I got a new camera setup. And one of the things I wanted to do is compare the two cameras side by side. But I realized I'm missing a cable.
02:21:18.510 - 02:21:48.190, Speaker A: So the camera needs a micro HDMI cable, and I only had one, which is the one I used for the other camera. So I ordered one and it got delayed. So it's arriving today instead of yesterday. I tried to get one before I started streaming today and the place I went to was closed and all the other ones opened after the stream was supposed to start. But I think the cable is about to be delivered. So if it is delivered during the stream, I'll hook up the second camera and we can do a comparison. So I'm just keeping an eye for if it gets delivered.
02:21:48.190 - 02:22:44.816, Speaker A: What would you want to be if you weren't a software engineer? I think it's a close race between a teacher and a like, working in, working with kids, whether it be at a sort of like a kindergarten or like an activity center or something. You know, I've worked at an activity camp for kids for many, many years and I love doing that. And it's totally something I could do full time. I don't know that there are ways in which you could do it full time. But I love working with kids. It's a lot of fun. But I also really love teaching.
02:22:44.816 - 02:23:40.620, Speaker A: And, you know, there's an argument of, well, maybe you should just be a teacher because you get to work with kids. And that's true, but it's different if you're a teacher in, you know, middle school or high school or primary school, for that matter. You have a different relationship with the kids because they have to be there and your job is to teach them. And it's true that you can develop, you know, a good social connection with the people you teach. But at least I've my. I don't know, expectation is that if you are like a camp counselor, for example, it's a very different experience because you get to know the kids in a. In a context where you are, you're not really, you know, trying to lead them to water, but instead of, you're there to enable them to have fun.
02:23:40.620 - 02:24:02.448, Speaker A: And I love being in that setting, too. Maybe I would do both. Maybe I would sort of time switch between them. I don't know. But I think realistically, that's the best alternative I see for myself. Someone in chat knows the name of the camp I work at. It's great.
02:24:02.448 - 02:24:43.258, Speaker A: It's been so much fun. I think I would work there for the rest of my life if the kids wouldn't find it super weird for like a, you know, if I'm 60 years old and still, you know, working at an activity camp for eight to 15 year olds. All right, let's see. What do you think about ensemble mob pair programming versus alone programming with code reviews? I think they both have a really good place. I wouldn't want to do just one or the other. I don't really. Do, you know, more than one programming very much at work.
02:24:43.258 - 02:26:02.460, Speaker A: It happens every now and again where, you know, especially if I or a colleague have run into just some hairy bug or something, wherever, we're just like, burnt out trying to figure out why something isn't working, and we're just like, okay, let's just tag team this together. We're going to go on a video call, share screen, and just work this out. And sometimes that ends up being like a two hour session where we're really just heads down in the problem together. That can be really, really useful. But that's the extent to which I do it at work. I don't have regularly set up sessions where I do that, but I do get a lot of experience that actually, with the streams that I do, which are a little different because I'm not on a video call with anyone, but it feels like ensemble programming kind of, or mob programming when I'm working with chat, because for the implementation, not so much for crust of rust because that's more teaching, but for the implementation streams, we're really building and designing an implementation together. And I found that so much fun, but also really useful to have that ongoing interaction with other people who are looking at reading, thinking about the same problem, the same code as me.
02:26:02.460 - 02:26:44.886, Speaker A: That said, it is slower, maybe. I don't know if slower is the right word, but I can get a lot more work done if I work alone because I don't have to voice my thoughts. And I think that the trade off here is that sometimes voicing your thoughts is necessary to get to the best solution or even to a solution. But oftentimes it's not. Oftentimes I can solve the problem on my own, and then it's more efficient for me to do so. And so then I would rather work alone and then submit a code review for, you know, the things I might have missed. So I think they both have a place.
02:26:44.886 - 02:27:34.880, Speaker A: I think my default is to assume that I can do things on my own and then to engage in programming in pairs, in ensembles when there's a compelling reason to do so. Like when me working on my own either gets me stuck or where I'm actively trying to convey something to other people. Like if I had a colleague, for example, who's trying to understand a code base, say, because they're a new engineer, I'd be happy to do a sort of pair programming session with them in order for them to learn. Because if I told them we'll just submit a CR and submit a PR and I'll give you code reviews on it, they wouldn't learn as well from that. So I think for teaching purposes, pair programming works really well. For getting unstuck, it works really well. But for everyday programming, I like working alone.
02:27:34.880 - 02:28:56.900, Speaker A: Which debugger do you use for Rust, and does it have a working break on panic functionality? I very rarely use a debugger for my rust code, and I don't know why this is. It's fascinating to me, and I don't have a great answer, but it seems like a lot of developers really want debugger, and I just very rarely reach for one. It happens, right? Well, I'll basically use GDB to set breakpoints and work through some code, but it's pretty rare. Usually print debugging works really well. I set up decently good trace logging and I just enabled verbose logging and run the thing and it becomes somewhat clear what's going on fairly quickly and I can iterate on that pretty quickly. It could be that I just, you know, haven't had, I haven't experienced the, just how good it can be, how tight you can get the cycle with, with breakpoint debugging. But it's just not really been an area where I felt a lot of need.
02:28:56.900 - 02:30:14.802, Speaker A: And I think, you know, Chad observed the same thing where I think it heavily depends on the context in which you're doing programming where, you know, maybe it's the problem areas that I work in where debugging wouldn't really help me. Whereas maybe if you know, if you're, if you're developing, I don't know if you're doing algorithmic development, maybe like you're actually implementing an algorithm and you really need to trace through the individual steps and see how values change over time. Or maybe if you have a particularly complex service stack where it's like there's a bunch of code that you don't control and so you can't really instrument it with print lines and stuff very easily. But that's where the bugs are, is you need gdp be to get into there. It is totally true that in those cases you're more likely to need a real debugger experience than in the context I work, where very often I control a decent amount of the stack, but even there I will often then just patch in the dependency and just modify the source of it directly. And that works pretty well as well. I think my answer here is I don't really use a debugger and therefore I don't have a great answer.
02:30:14.802 - 02:31:44.726, Speaker A: But at the same time I've found the GDB works pretty well when I do have to reach for it. But that's not a great answer, just because it could be that the times when I have to reach for a debugger, or rather the times when I don't reach for a debugger, but other people want to use a debugger, the use cases there GDB is worse at, and that would be a blind spot for me. It could also be that it's a matter of like that how deep in the stack you work, right? Like if you're, let's say relatively speaking of an engineer that works higher up in the stack so that you have a lot of abstractions under you between you and the actual execution, then GDB, or let's say like a debugger would actually be more useful to you than if you're working lower in the stack and so you have a decent mental model of the entirety of execution, then the debugger might actually not help you that much compared to being able to actually step down through the stack if you're working at a very high level. But it's hard for me to say game engine programming makes a lot of sense. Another place where your use for a debugger might be much higher because things like print debugging just won't work. There'll be too much output. It'll be too hard to parse through.
02:31:44.726 - 02:32:45.520, Speaker A: I do remember that, you know, when working on Noria, which was a very high performance, low latency system, it was certainly true that there, I used to debugger much more than I do now because it had, you know, there were some just execution loops where I just couldn't do print debugging or where the bug would disappear if I did print debugging. And so I needed to do watchers and breakpoints and whatnot. After you finished your undergraduate degree, why did you go for the academic path? What is your thinking behind that? But I don't know that it was quite that intentional. I think what happened was I finished my bachelor's and I was like, well, I want to study more. Like, I just wanted to. I wanted to learn more things. And I think partially my undergrad was very general computer science, and I felt like there were a lot of.
02:32:45.520 - 02:33:49.140, Speaker A: I felt like there were a lot of technical things that I still wanted to learn that were more technical in nature than, like, you know, general purpose programming. And so that's why I applied to a master's program was like, well, I applied partially because I didn't get into MIT, and so I wanted to find a master's program to do so I could apply again. But that desire to ultimately go to MIT as well was driven by, I think, the desire to really specialize and learn. I don't know, I wanted to learn everything there was to learn. I think I have a real hunger for learning, and academia sort of designed for that. And so it felt like a very natural course, just keep on going in the, in the track that I was in. And I didn't really have feel a strong pull towards working in industry.
02:33:49.140 - 02:34:45.940, Speaker A: It just didn't. That didn't seem like a particularly compelling path to me. I think that changed over the course of the PhD just because I felt like, okay, I really have learned a lot of specialization now. And now I want to see the, the practical applications of that work because during your PhD you do end up with a very academic focus. And for me at least, that was frustrating because I felt like there's a lot of cool research here, but it doesn't matter if it's not practical. And therefore I felt more of that need, that drive, that desire to go into industry and work more on the practical applications of that kind of work. I think one thing the academic track gave me, a lot of which I think is, which I appreciated a lot, was the freedom to choose what you work on.
02:34:45.940 - 02:35:47.280, Speaker A: Like in industry, you're very constrained. You need to work on things that matter to the business and there can be a decent amount of freedom in that too. A lot of things might matter to business, but you know, during the PhD program especially, I had so much freedom to just work on things I thought were interesting things. I thought had the opportunity to have interesting questions in them. I got to do a lot of work in open source. That's when I got to start doing streams because I had the time, frankly, and the lack of constraints on what I could spend my work day on. And so I think a lot of my set of side projects essentially came from being in academia and therefore having that leeway that time, that flexibility to branch out.
02:35:47.280 - 02:36:50.596, Speaker A: Are PhDs funded in the US or did you need to pay for it? It varies heavily from university to university. At MIT it was paid for. So the paid for is with a bunch of asterisks, basically every semester. You can either be a research assistant for a professor or a lab, and then they basically pay you a stipendous, or you can work as a teaching assistant for a class and MIT pays you the same stipend amount. Or you can be on like a scholarship from one of the science foundations, for example, in the US, for me it worked out pretty well. I was a teaching assistant for many semesters, many more than are required, because I think it's really fun to teach. But there were also several semesters wherever I was, just a research assistant for the professor who was my advisor, and the research I was doing was my own work.
02:36:50.596 - 02:38:20.590, Speaker A: So it just worked out really well. But that's not the case for every PhD program in the US, or I think globally, where it can be pretty hard to gather the funds to get that flexibility in the first place because you're basically accumulating debt while working this up. It's a little different in many european countries, for example, where that education is free. My sense though is that the PhD programs in Europe in particular are a little bit different. Than the ones in the US, where they're more focused on a set track, whereas the PhD program in the US is very often just, you need to turn in a thesis at some point and maybe there's a mandatory classes, but there's a lot of, let's say, choose your own adventure, right? Like there's a lot of just you figure out what you should work on and how to be disciplined about your own time. And, and so even though it is free in Europe or can be free in Europe, it might also be a different experience than what I had here. How do you compare self study versus study in an academic setting? So at least during the MIT PhD, you have to do relatively little studying.
02:38:20.590 - 02:39:08.016, Speaker A: I think I had, I forget what the exact requirements is, but I think I took six classes at MIT. I might be off by one or two, but there are not a lot of mandatory units. You have to take over the course of like six years. I think I took classes for the first year and a half or two years and the rest of it I didn't take classes. I was a teaching assistant for many of those semesters, but I didn't take any classes because that wasn't required. You can, but really a lot of it was, you know, figuring out what should I be working on, what should I be learning and going to learn those things on your own. So there's a lot of self study, but that varies from university to university too.
02:39:08.016 - 02:39:47.080, Speaker A: I think at Berkeley, for example, you take a lot more classes that are required. You need to take them in order to graduate. And I like the freedom that I got, but it also requires a lot more self discipline so that you don't end up just not doing work. And so it takes forever you to graduate. Are you still working on the topics related to your PhD research? No, I'm not. In fact, the work at Amazon that I do is completely unrelated to my, to my PhD work. It's like my PhD work was on a fast database and my work now is on developer experience tooling.
02:39:47.080 - 02:40:21.090, Speaker A: It's very, very different. I did co found a company called ready, set that is basically building a commercial version of Noria of the, of my PhD thesis work. But it's a. But I'm only involved in that company and in that I was a co founder on it. I don't work for the company. Yeah. So the UK, I think, is quite similar to the US in that you have a decent amount of flexibility in terms of choosing what you work on.
02:40:21.090 - 02:41:34.520, Speaker A: It's fairly free form, although you do have a decent amount of guidance from an advisor, for example, to guide you through that work. All right. What are your thoughts on parasocial relationships? Like, if I met you somewhere, I would feel like I knew you while you would have no idea who I was. It's a great question. It's been a very bizarre experience, actually, to go to rust conferences, for example, where at this point, a decent number of people in the rust ecosystem or rust community know who I am, either through my streams or through my book or through rostation station. And it means that when I go to these conferences, suddenly, like, people recognize me, people know things about me or what I've done. And it's a pretty bizarre experience because, I mean, as the question says, like, I have no idea who they are.
02:41:34.520 - 02:41:57.890, Speaker A: I. And yet they come up to me as though they know me. And in some sense they do. And to be clear, I think that's great. I think it's a fun experience, but it is very bizarre, and I don't always know how to react to it. That said, I think I've always been. That's not true.
02:41:57.890 - 02:43:00.542, Speaker A: I have become a fairly social person. Like, I'm pretty good at just picking up with someone as if I've known them for a long time, probably almost to the point where it's a little. I almost said too much, but it depends on the culture you're in. But certainly I have very few barriers on what I will talk to people about. And so if people like, I will just not have filters on what topics are appropriate for conversation, necessarily. And in this particular case, that actually ends up being pretty useful because it means that when people approach me as though they know me, I'll just sort of respond in kind because that is generally how I interact with people. But yeah, it has been a very weird experience of that.
02:43:00.542 - 02:44:34.930, Speaker A: Kind of starting from different points in the relationship, in the conversation. What concepts do you suggest to learn or understand before someone should be looking for a rust job? So, for example, people coming from more high level languages, or even dynamic languages like Python or JavaScript, I think you. I think, I don't know that there are specific things necessarily that I would recommend that, like, you need to learn this thing in order to take a rust job. Instead, what I would advise is write something in rust, like, write a semi non trivial command line tool, for example, or like, library is a little harder, but, like, build some kind of tool in rust that does something that might be useful to you because it's going to force you to learn a lot of things and once you've learned them, you're a significant step up from having come from another language, like a dynamically programmed, dynamically interpreted language, for example, dynamically typed. And while you're building that program in rust, try to make sure that you understand all the pieces of it. It's very easy to do things like, oh, I need to do this thing. I'm going to use a crate, I'm going to copy this paste from this code from stack overflow where someone told me how to do it, and then be like, okay, I managed to build a binary that does the thing that I want.
02:44:34.930 - 02:45:20.992, Speaker A: It's tempting to do that, and it's easy to do that, but I think if your goal is to become more comfortable with rust so that you can use it in a professional setting, then you want to dig one level deeper and be like, do I actually understand all of the code that's in this program I just wrote? And if you take that extra step and you really dig into learning those pieces, I think you're in a pretty good position. You're going to be junior level in terms of your rust knowledge. But even so, that's often enough to get started. If I had to give one recommendation for a thing. You should invest in understanding in rust. I think it's trait bounce. I think a lot of people who work with rust have a sort of cursory knowledge of trait bounds.
02:45:20.992 - 02:46:42.618, Speaker A: Like, I kind of sort of know what's going on and really digging in on understanding the type system and in particular how trait bounds work out in rust is it gives some pretty hard to measure rewards. You're going to find that there's a barrier that's suddenly gone in trying to understand what a library does or a function signature or why the compiler is yelling at you when certain trait binds aren't applied. I think that's one of the worth investing time in understanding properly. So that maybe would be my recommendation, but primary recommendation is write something real rust and make sure you really understand it. What made you choose MIT? This one is funny, because I think I chose MIT when I was a child. I think when I was 1314, maybe I decided that I wanted to go to MIT. And, you know, as a, as like a kid in Norway, I had no idea what the implications of such a statement was because I didn't know that that was difficult.
02:46:42.618 - 02:47:51.776, Speaker A: I didn't know that MIT was going to be both hard to get into, but also, you know, demanding to be in. I just. I just saw that a lot of the cool things that I saw and read about and learned, came out of MIT and was like, I want to be there. And so that became my sort of long term goal, semi accidentally and without understanding that that was a long road to start down. And as I got closer to making that goal a reality, which was really when I ultimately got accepted to MIT, it was after finishing my master's degree in the UK. And at that point I got into MIT, Berkeley, Stanford, Harvard and University of Washington. And at that point, the choice became very real, I think maybe almost for the first time, where, oh, I actually have to choose between these that are all very high quality choices.
02:47:51.776 - 02:49:07.820, Speaker A: And like, when the question says, what made you choose MIT? It's more of a like, it depends where in the process you ask. Because early on it was, MIT does really cool, interesting work. I want to be in that environment. Later on it was, why do I choose MIT? Compared to other similar alternatives? And there the choice for me came down to, I think ultimately I came down to University of Washington, Berkeley or MIT. I eliminated University of Washington at the time because their computer science department was still relatively small and I wasn't confident enough in which topic I cared the most about, that I like, I wasn't confident enough that I wouldn't change my mind about which sub field I wanted to be in. And because the UW computer science department was relatively small, they had really good experts in certain things. But I was worried that even though they had experts in the things I was currently super interested in, if my interest changed, there might not be experts in the adjacent fields I eliminated.
02:49:07.820 - 02:50:09.316, Speaker A: And then it came down to Berkeley and MIT. And for me, that became a choice, apparently, or seemingly, between Berkeley being more social, perhaps, and MIT having technical ideas that resonated more with me seemed like more interesting technical topics for me. And between those two, I figured, I'm going to work on this for six years. It's more important to me that the technical problems are interesting, and then I can always make the social stuff work out than the other way around. And so therefore, I went with mitzvah. Let's see. What do you think of Elon Musk? You plan on quitting Twitter? Okay.
02:50:09.316 - 02:51:01.400, Speaker A: I think Elon Musk is an ass. I also think he's a smart ass. I'm unsure whether he's smart. I think that's my summary assessment of Elon Musk in terms of planning to quit Twitter. That's tougher, because I think Twitter does give me a lot of value, not just in terms of a lot of people are on there. So it's easier to reach many people, and it's a format that I like decently well, but also because there are many people there. Over the years, I've accumulated, I think, pretty good set of people that I follow so that I get a lot of value out of reading my Twitter timeline stream.
02:51:01.400 - 02:51:43.734, Speaker A: And it's hard to replicate that elsewhere. But at the same time, I don't think it's. I don't know how long Twitter is going to remain a good place to be. So one of the things I've thought about is to make Twitter read only for me. So move to another platform in terms of where I would post things, where I would write and then still consume things from Twitter. But that raises other questions. Like, it feels unnatural to see a tweet and want to respond to it, but respond on a different platform, because then the author of that thing won't see the thing I post.
02:51:43.734 - 02:52:35.400, Speaker A: I can post a link to it on there, but then that gets weird, too, because what if they reply to the link? Or if I see something interesting on Twitter? Do I share the link to it on this other platform and then have people like that means that I'm no longer signal boosting in quite the same way. Right? Ideally, I want to give attribution to the author and have the author get likes and retweets and follows and whatnot. But if they're on a different platform, that gets a little weird. Whereas if I retweet it, it directly gets the attribution of the author. There are a bunch of open questions there, and even things like which alternative platform is the one that I would want to switch to. I've been on Mastodon for a while, and I keep forgetting that I have one. I keep forgetting to put things there.
02:52:35.400 - 02:53:31.840, Speaker A: And multiposting is really inconvenient. And not just, you know, I could automate it, but it's also just, it means that I have to monitor multiple places where replies come back. It means that I have to cater to multiple different limitations on, you know, how long can a tweet be? What? How is it presented? It's awkward to post to many places. And so then the question becomes, should I just pick one and, like, whether that be mastodon or co host or something else. Like, if I'm just on one platform, that might help with that problem, but suddenly that means, you know, anyone who's on the other platforms is now not connected. They would have to move to that platform to get what I write, but it would solve the problem of having to split my attention too many ways. I don't have an answer.
02:53:31.840 - 02:54:08.432, Speaker A: I think quitting Twitter right now is not something I'm going to do. But I do think that I will sort of soft move to something and I'd have to figure out what that transition plan looks like. And it's also the question of, I would want to make sure that the thing I move to is more sustainable. There's an argument to like Patreon could be that thing. I could move to a platform that is also the place where people, where I would post content that is limited to people who pay, for example. But I don't love that model either. Patreon is also not a great social platform.
02:54:08.432 - 02:55:38.450, Speaker A: So I don't know where I would go instead is sort of part of the question here. Right? So I don't, I don't know what the alternative is, but I, I am looking at alternatives. Oh, was my thing delivered? Was the cable delivered? It's outside right now as I might be able to. That means I might be able to show the second camera before I end the stream because I think we're getting towards the end here. What are the biggest challenges in developer experience and tooling in rusted Amazon and in general, or in software in general? It's a very broad question. I think the challenge of the developer experience at companies, and this is not just Amazon, I suspect this is the case at other companies as well, is that for internal development you have a bunch of additional restrictions, you have a bunch of additional rules you have to follow. You have a bunch of different integration requirements for internal systems that do providence tracking or reporting or compliance or whatnot that your developer tooling needs to integrate with.
02:55:38.450 - 02:56:38.750, Speaker A: Trying to bridge that gap between it has to do these things, but also people expect it to work in this way. Bridging that gap is really hard. So one of the things that I try to do in my work is build developer tooling internally. That makes it feel as though you're having the same experience as you do externally, but it conforms to all the internal stuff and basically hiding the internal complexity as best as possible. And that is very, very difficult to do. You end up with sometimes leaky abstractions, sometimes with developer tooling that mostly feel similar, but there are sharp edges if you hold it wrong. And so you can mostly, like in the rust case in particular, it mostly feels like you're using cargo, but sometimes things don't work because it's not normal cargo.
02:56:38.750 - 02:57:51.738, Speaker A: It's a weird configuration of it. And so very much of what my work ends up being is sort of trying to find the right way to expose the external build system internally and to make the internal experience as idiomatic as possible. More broadly, I think one challenge with developer experience is actually around testing. And again, this is not an Amazon specific problem. But if you're trying to build developer tooling, one challenge you're going to have is that developers have a very diverse set of environments in which they use that tooling. You don't have a great way of testing against all those environments, right? Like as a trivial example, you know, if, if you're building tooling that you expect to work on Windows and macOS and Linux and whatnot, then okay, you might have CI that can run your test suite, you might have CI that can, you know, check that it compiles on all those platforms. But do you have CI that will, or do you have, I guess CI is the appropriate term here.
02:57:51.738 - 02:59:57.088, Speaker A: Do you have CI that checks that the tool you work, you built works even if executed within an embedded terminal inside of Intellij and sometimes that won't be the case. Or do you have tooling that allows you to test whether this also works when used in the context of the Windows subsystem for Linux? Those are testing your tooling in the way that will actually be used by the developers you're building for in such a way that you ensure that you don't have regressions, for example, is really, really difficult. And you almost need like a CI setup for every possible developer environment, which becomes impossible. Like how do you ensure that your tooling still works if executed in the context of nics? And I don't think we have a good story for testing developer tooling. And that's really hard because it means that it is very easy to introduce regressions in developer tooling that you develop because you don't have as constrained of an environment for usage. So that's, I think the best answer I can give to that question. What are some problems you find interesting in the database community? It's been a while now since I worked on databases, but one thing that I certainly spend a lot of time thinking about is indexing, which is in particular the question of how do you, why do we require humans to choose what indexes to add to their database? Doesn't the database know better? Right? Like it, it knows the, at least over time it knows the usage patterns of access to the database and it knows the, the distribution of the data in the database.
02:59:57.088 - 03:01:48.958, Speaker A: And therefore in theory it should be able to what the right indexes are, and I know there's been some research on how can we do automatic index selection and that kind of stuff, but that was the question that fascinated me a lot, where I think you could do pretty significant leaps in the experience of using databases and making them faster and better if you could just take away the necessity of defining these indexes, because I think a lot of developers get them wrong. They add indexes that have implications that they didn't expect or that weren't needed, and just add space and complexity and performance overhead, or they don't realize that they should be adding indexes and that's the reason why their application is slow, or they didn't need indexes, but now their database has grown large enough, or their access frequent enough that now they are needed. And you know, I think, I think there's some really interesting questions there. And not just how can the database infer these automatically, but also how can it surface these decisions in a way where they don't surprise developers when like suddenly your database is slower because the data, because an index got automatically added. I think there's some developer experience questions there too that are really interesting. Let's see, how do you choose between shared memory and the actor pattern for concurrency? So one challenge that actors has is that you need to have operations that make sense to do in a relatively single threaded context. And oftentimes that's true.
03:01:48.958 - 03:03:31.336, Speaker A: Often you can say it makes sense to have an actor to represent, for example, a physical device in a system or a connection to a particular machine, because it's not clear that you can have a lot of concurrency within the actor. In an actor system, you often at least end up with having your concurrency happen because you have many actors and the actors can act independently, and that's where your parallelism comes from, whereas there are some cases where that doesn't really work so well. So for example, let's take merge sort, right? So if you're trying to do a multi threaded merge sort, it's a little weird to have an actor for each sub bucket that you're sorting. It's possible, right? You can structure it that way, but it's perhaps more natural to just have threads that operate on shared memory, maybe even a worker pool where you grab the next slice that hasn't been sorted yet, rather than spinning up an actor for each sub slice that you end up doing sorting on. So I usually think of this in terms of I use an actor. I don't choose between shared memory and actors, but rather things that make sense as a, what's the right word for this? As a, like, single threaded owner of a resource, for example, I turn into actors and then use shared memory for things where they're, where we're actually doing shared ownership. And that's how you get the parallelism.
03:03:31.336 - 03:04:45.090, Speaker A: Like if you have many things that want to share ownership of something and it doesn't make sense to have it to be a single threaded owner, then you would use shared memory. Do you think there's value in doing a PhD for six plus years if your goal is to join industry? I see a lot of PhD students drop out with an MS after spending three plus years. Hence, I was curious to know, if your goal is to go into industry, you should not do a PhD. There are some sectors in industry where there are exceptions to this, but broadly speaking, I would say no, it's not worthwhile to do a PhD in order to do well in industry. And if you are in the exception cases in general, you will know this pretty quickly. You look at, basically look at the job postings for jobs that you might be interested in and see whether they require a PhD, and it's going to be very rare. So the PhD is, as I mentioned earlier, a pretty big opportunity cost, and it's not clear that you recover any of that cost later on.
03:04:45.090 - 03:05:38.698, Speaker A: I do think that there's a lot of value in the freedom that you get by doing a PhD, and you get to branch out, learn more about what things you care about, and that might change which industry you go into in the first place or what kind of job you look for. But if you have a particular goal of going into this part of industry that a PhD, I don't think, is the path to get there. And certainly if industry appeals to you. Oh, thanks. If industry appeals to you, then you might not like the PhD life either. You might not like the PhD work. It might not be like it's just going to be painful to you.
03:05:38.698 - 03:06:06.760, Speaker A: And I think that's one of the reasons why people end up leaving early, is exactly because it doesn't match the things that they enjoy doing. So, general answer, no. Oh, all right. Let me see if I can plug in this camera, have it work. I got the cable. Exciting. Hopefully it's the right cable.
03:06:06.760 - 03:07:11.210, Speaker A: Let's see here. It is the right cable. Let's see here. So one of the reasons why I switched cameras was because the old one does not have autofocus, and so I need to use a long stick to sit back and then point it at the shutter button and hold it down a little so that it will focus. It's real stupid. All right, let's see here. Let's see if this will work.
03:07:11.210 - 03:07:34.700, Speaker A: So I go over here, and then if I now do this. Aha. Oh, is one of them flipped but not the other? No, I think they're. Let's see. Yeah, they both. They're both the same. Okay, so here's old and new.
03:07:34.700 - 03:08:02.734, Speaker A: And I guess they're not quite aligned. I think this needs to go. Okay, so, yeah, you can see this. That's the old camera. That's the new camera. And it's interesting, I'm looking at it now myself too. And these are also another thing worth pointing out is they're also using different capture cards.
03:08:02.734 - 03:08:27.060, Speaker A: So one of them is using the elgato cam link. That's the one used for the old one. And the new one is using a PCIe card. That's Helink five pyre. Shouldn't make a difference for the actual signal. So now the question is which of these are better? Yeah, the loot. So the lumix is grainier.
03:08:27.060 - 03:08:58.348, Speaker A: Let me see if that's because I've set some weird settings on it or whether it actually just is. Let me try to make the contrast the same here. Ah, it froze. That's not good. This is one of the reasons why I got really frustrated with the elgato, because it kept freezing like that. Let's see. I forget what I do to reset it.
03:08:58.348 - 03:09:41.150, Speaker A: I think I do. No, no, it's still unhappy with me. Let's see. Yeah, so the other thing that's really frustrating about the old one is it's really hard to get it to reset. Bricks. There we go. Okay.
03:09:41.150 - 03:10:24.134, Speaker A: Yeah, so you see how much grainier the old one is. And also remember, no autofocus, whereas this one does. I think the old one also, the saturation duration is too high. Let me see if. Yeah, let me try one. Obs really does not like me changing these settings on the fly. See if I can convince it.
03:10:24.134 - 03:10:52.160, Speaker A: No, now the new one stopped. It's a mess. What if I do this and then that? No. Oh, I wonder. What if I do this? It's not easy. It's not easy. Easy.
03:10:52.160 - 03:11:24.454, Speaker A: Come on. Come back online. Well, so much for that. Now it's just me looking very confused in one of the frames. That's right. It's actually a 3d stream. Let's see.
03:11:24.454 - 03:11:51.340, Speaker A: There's no light in front of me. Actually, this is just natural light from windows. Let me try to unplug it. See if that does the thing. No, I think. I think it just. I think that one's just died now.
03:11:51.340 - 03:12:14.502, Speaker A: I. It's very problematic to try to do anything with these cameras while Obs is trying to capture from them. It might be a Linux thing too, where it just gets sad. Well, all right. In that case I think. I think this is then a good place to stop. Because otherwise I'm just not going to have video for the.
03:12:14.502 - 03:12:45.720, Speaker A: Not have moving video on the main webcam screen. And now you'll just see my old one. I'll see if I can post a video that just shows the comparison between these more directly. You can see now actually, now that I adjusted the saturation as well. So now they have the same contrast saturation set. If I make the similar kind of. First, they're actually pretty similar in terms of the color definition.
03:12:45.720 - 03:13:08.250, Speaker A: It's a little more color in the. In the old one, but it is also a fair amount grainier. It's interesting. Yeah. The new one has a better. The depth of field is a little different too. So the new camera is a prime lens in particular.
03:13:08.250 - 03:13:34.820, Speaker A: It is. See if I can. Yeah. So the new one is a prime 35 millimeter. And this one is a zoom 18 to 35, but with a slightly different crop factor. So I think like they're. They're not too far apart, but the lower graininess and more importantly the autofocus makes a huge difference.
03:13:34.820 - 03:14:01.710, Speaker A: All right, I think that's where I'm going to stop for today. But looks like there are a bunch more questions. So maybe I'll do another q and a in not too long next. But thank you all for coming out. I hope that was useful. And I will see you next time. So long, everyone.
03:14:01.710 - 03:14:02.150, Speaker A: Bye.
