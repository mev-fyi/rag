00:00:02.000 - 00:00:48.535, Speaker A: Hello, folks. Welcome back to another rust stream. This is going to be another one where we implement something from scratch. And in particular it's going to be one of those streams where we go through basically a sort of guided set of exercises or challenges. We've done a couple of these. So we did one following the Fly IO Distributed Systems challenge and we did one where we did the codecrafters implement your own BitTorrent one. Both of those were really popular and I've been talking to a couple of people and it seems like one of the reasons is because people can try the thing on their own at their own pace and then sort of switch over to the video and view me as a sort of reference as you go and compare their solution to mine at each step of the challenge.
00:00:48.535 - 00:01:11.599, Speaker A: And so if that is a way that people enjoy going through the learning, and I totally understand why, then I should do more of them. And so here I am. I'm going to do another one. I also think they're really fun. Um, so today we're going to build Git from scratch. Uh, we are going to follow a codecrafters thing here as well. Apologies for the saw outside my window.
00:01:11.599 - 00:01:43.015, Speaker A: Hopefully it's not too bad. Uh, so we're going to build git from scratch following the CodeCrafters Git challenge. Um, the. I've been told that the last step of this challenge, the Cloner repository, is the hardest single step in any of the codecrafter challenges. So we'll see whether we get to. It depends how, how long we actually get, but we'll see how it all pans out. So codecrafters is not free, it is a paid site.
00:01:43.015 - 00:02:12.105, Speaker A: But there is so two ways that you can sort of get access to this. The first of them is I have a referral link you can use. I'll put that in the video description. I also put it in chat here. So if you go through that link, then you get seven days free or something. They also have the Entire challenge on GitHub. I'll put that in the video description as well and in chat that has all of the sort of steps of the challenge and the text of the challenges.
00:02:12.105 - 00:02:38.049, Speaker A: It doesn't have all the nice infrastructure that is on the site for like running your test suite and stuff, but at least it's there and I think all the tests are there too. So if you don't want to pay for it, then you can do it that way instead. And as a sort of, I guess, disclaimer at the beginning here, I'm not sponsored to do the stream. Like no one has paid me to make this video. I do have the referral link, so if people like it and pay for it, then I get money from it. But. But it's not a.
00:02:38.049 - 00:03:18.949, Speaker A: It's not a paid thing. Before we get started, there are just a very short amount of housekeeping. And I know people hate housekeeping because it delays the start of the stream, but we'll do it anyway. The first one is that there is now, if you haven't seen it already, there is a discord for, I guess me specifically for Jay here. Jay has a Discord server that I happen to be on. The Discord server mainly has sort of announcements of whenever I do new videos, when I'm planning to do new videos and other things that might be relevant and sort of live notifications and such. And you can find that at Discord.
00:03:18.949 - 00:03:50.665, Speaker A: John who Eu. That'll redirect you to the invite link. And I guess I can also put the invite link right here in chat so that you have a handy way to get to it quickly. There are a bunch of other channels too that are only available to people who sponsor me. So that brings me to the second thing or the third, I guess, which is I now have a GitHub sponsors. There is no requirement to sponsor me. You don't get anything particularly fancy except access to a couple of these Discord channels.
00:03:50.665 - 00:04:27.115, Speaker A: The main thing is if you find that. That you've gotten something valuable out of the streams that I've done and the other content that I've produced over the years, then I would appreciate if you could sponsor me and sort of help me do more of this. But I'm also in a stable job, so this is not a thing that sort of sustains my living. It is more of a way to sort of go the extra mile. Okay, and then the last bit is I will be at Rust Nation at the end of March. Helsing, who I now work for, is sponsoring a hackathon at Rust Nation. So I'm going to be there running a hackathon with like remote control drones and cars.
00:04:27.115 - 00:04:50.565, Speaker A: I think it's going to be pretty cool. If you happen to be there, stop by and say hi. And that, I think is all the housekeeping I wanted to do. And so now we can get started. I have not looked at this challenge at all before starting. So this is sort of my normal style of how to do these videos, right, Is that I don't want to go in already knowing what I'm going to Build. Because if I already know what I'm going to build, it's going to be much less educational for you.
00:04:50.565 - 00:05:17.835, Speaker A: And it's also fun to watch me get stuck. So we're going to start this challenge sort of blind and hopefully this will go well. We'll see how far we get through the challenges. My guess is, based on the difficulties here, my guess is we'll get to the last one. We might not get through the last one. Sort of depends on how long I'm willing to stream today as well. I'm guessing we'll stream for four to five hours, but we'll see.
00:05:17.835 - 00:05:46.535, Speaker A: Okay, are there any questions before we start? Before I click the start building button here, the saw is very authentic. Good. Just like at home. The Discord is for anyone. Like, you don't need to be a sponsor to join the Discord. It's just that the only channels that are on the Discord if you're not a sponsor are sort of the announcement channels. Like, there's no actual chat channel.
00:05:46.535 - 00:06:35.709, Speaker A: And then depending on the tier you sponsor at, you get access to sort of a community chat channel, one where I post interesting tidbits that I come across. And then this sort of goes a little bit up from there. So there's a more frequent Q and A tier and there's also a tier where you can sort of suggest additional streams I should do and such that are further up. Will you implement rebase? Probably not. I think rebase to me would come after Clone repository here. I think it's worth pointing out that I've worked a lot with git, so it's not like I don't know what Git is. And in fact, I know a decent amount about the data model for Git too, because sometimes that's how you have to debug why Git doesn't do what you want.
00:06:35.709 - 00:07:24.107, Speaker A: I just haven't like actually looked at this challenge before. Prerequisite for this. So this is going to assume that you know Rust. Like, I'm not going to teach you Rust in this stream, but if you don't know Rust and like, hopefully you should be able to follow along. It might just be some parts of it where you're like, oh, I don't know what that piece of code does or the syntax does, but you should still generally be able to follow along. But the goal of this is someone who generally knows Rust and then wants to sort of see someone with experience building this. And hopefully over the course of that you'll get exposed to some techniques, some Libraries, some ways to use the standard library and just techniques for programming in Rust more broadly and potentially also debugging techniques.
00:07:24.107 - 00:07:57.421, Speaker A: So I'm hoping sort of teach some intermediate Rust concepts as we go through this as well. If you want an intro to Rust, one thing that I can recommend is. So a couple of years ago I ran this class or like a mini class at MIT with two other lab mates of mine called the missing semester of your CS education. It's missing CSL MIT Edu. I'll put the link in chat. Nope, that's not the link. This is the link and it has a lecture on git.
00:07:57.421 - 00:08:40.167, Speaker A: It's not given by me, it's given by Anish, who's also a great lecturer. And if you go in there, it has like both the. A bunch of written notes throughout this and it also has the entire lecture video, at least in theory, if I can get that to load. And so this one is I think a really good walkthrough of sort of the mental model of git, but also the data storage model of git. We'll get into a lot of the details of this as we go through the stream, but if you're completely new to Git, I would recommend checking that out. All right, so let's then get started. I don't think there are any other burning questions, so let's go for it.
00:08:40.167 - 00:08:59.093, Speaker A: Start building. I would like to do it in Rust, please. Language proficiency. I'm going to go with advanced. Next question. How often do you intend to practice? Um, once a month. Accountability.
00:08:59.093 - 00:09:15.405, Speaker A: I'll pass. I don't want accountability for this. All right, step one, clone the repository. That's fine, we can do that. Git clone. Okay. And then they want an empty commit.
00:09:15.405 - 00:09:41.855, Speaker A: I can do that. Right. So one of the things that sort of code crafters has set up, and I remember this from when we did the BitTorrent challenge, is that there's sort of a push hook. So whenever you do a git push it, it runs all of the sort of test suite over your things. You see here. It built the Rust app, it ran the thing and it's telling me that like basically test one failed, which is totally fine. That's sort of expected.
00:09:41.855 - 00:09:56.705, Speaker A: And I guess we can go here. Woohoo. Okay, great. They received the git push. So that means we're now set up. Okay, that's fine. Your next stage, implement the git init command.
00:09:56.705 - 00:10:26.815, Speaker A: Okay. Okay. So the idea here is that we will have, they'll run our binary basically as the git Binary and the git binary has an init command. It initializes by creating a git directory with some files and directories inside of it. Okay. Oh, yeah. What's in the git directory? Bunch of text files.
00:10:26.815 - 00:10:48.335, Speaker A: Yeah, that's fine. I'm guessing that's the same thing that's described below. All right, so we got to look at what we have in here. Let me get another couple of terminals in here. Let's see what we have. Source main. All right, I like clap.
00:10:48.335 - 00:11:31.003, Speaker A: So we're going to go ahead and add in clap here. And then I can never remember the setup for this. It is like this. Oops, great. Like so. And the arguments we want here is actually we want sub commands, right? So in clap, derive reference sub command. There's the example for sub commands.
00:11:31.003 - 00:12:13.043, Speaker A: Yeah, here. Okay, so what I actually want here is I want sub commands, right? For things like init and command. Here is one of these guys. And I don't actually have any global arguments as of yet. I do want to include here sub command, which I want to derive. And actually let's use the tutorial instead, which has sub command without all the bits. So I don't need this.
00:12:13.043 - 00:12:59.085, Speaker A: Don't need this. And get rid of this init. And initially init is going to take no arguments. We do want a derived debug for it. And then down here, instead of doing the sort of ENV args that they're using here, what we will instead do is match on args command and assuming that the only valid command initially is init and then we're going to have this. And then we don't actually need an else branch here that they have for unknown command. Because CLAP will take care of just crashing for us and giving a useful error message if the appropriate.
00:12:59.085 - 00:13:17.845, Speaker A: If a sub command was given. That's not the thing we support. And then. Okay, what do we do here? We created directory git. We create a directory git objects refs. We write to head refs head main and we print initialize git directory. All right, Just to see what that does.
00:13:17.845 - 00:13:39.285, Speaker A: That's fine. That's all fine. First exercise, get push. Let's go look at what it says here so we get an explanation as well. Okay. Yeah, so we have this directory structure. We have a head file.
00:13:39.285 - 00:14:24.535, Speaker A: The objects directory contains git objects, the references contain git references, and head contains a reference to the currently checked out branch. So in this case it says that the main branch is checked out. Okay, so let me give you a brief overview of git here rather than sort of diving into. So this is linking into the git book, which is a good read, but just in the interest of time here, rather than try to read through it, I'll give you a very rough sort of headline overview here. So in git, everything is stored as a, roughly speaking, a content addressed blob. So that means if you have a file, for example, the file is really stored as all of its bytes and then the keyed by the hash of those bytes. And so this is an object.
00:14:24.535 - 00:15:13.935, Speaker A: Similarly, a commit is also an object. So a commit is an object that has a. Well, actually there are a bunch of things in between here. So a file is sort of a blob is the lowest level thing that is an object whose key is the hash of the file of the blob's contents and whose contents are the contents of that file. A tree object is something that holds something like a directory and what it really holds is a list of name and object key for the contents of that file at that time. So you could imagine that the tree for. Well, I don't really want to use the same thing, but let's say I do here a make their foo and I touch foo or I echo hello inter food bar.
00:15:13.935 - 00:16:14.299, Speaker A: Then the way this is, this will actually be stored is there'll be a this sort of thing will be stored somewhere and that is the tree entry that we would have for for foo slash bar. So for the repository here that's rooted at foo, we would store the hash of the contents of fubar and the name foo bar in a tree object. And we would also separately in the object store, store this hash and the contents of foo bar like this. And then where would this, you know, this actual string right here, where would that be stored? Well, that would be stored in a tree object. And the tree object is keyed by the hash of this literal string. And where is that hash object? Where is that hash stored? That object key is stored in the commit object. So when you create a commit, the commit points to a tree.
00:16:14.299 - 00:17:06.675, Speaker A: In particular, it points to the object key, the hash of the root tree object as well as it includes information about the metadata like who authored it and such. And then the commit is stored as all of the bytes that make that up and keyed by the hash of that content. And that hash is what we know as a commit hash. So if I do revparse head, so this hash right here is the hash of the commit object that is that head points to. And similarly, you know, if I Do master here, for example, it's the same hash because master and head currently point to the same thing. If I did something like head hat, which means the previous commit, this is the hash of the commit object before head. And I can even do cat.
00:17:06.675 - 00:18:10.615, Speaker A: No, what is the name of that command? Maybe it is just cat file. Yeah, so cat file lets you print out what is contained within an object. So for example, here we can do cat file, commit, head and this, Sorry about the chainsaw. This is the entirety of the contents of the commit at head. And if I did a rev parse of head and then I did a cat file of this commit, it prints the same thing, right? Because ultimately the commit is keyed by its hash, just like everything in git is. So, so the core of git in a sense is this object store. And the object store just stores maps from hashes to the body of the thing that contains that hash.
00:18:10.615 - 00:19:01.971, Speaker A: So whether it's commit or a tree or a blob, whatever it is, it's all stored in the same object store that has the same rules, which is it's a content hashed storage. And so you see, when we look at the cat file here of this commit, you see the contents of it is the tree for this commit. So basically the contents of all the files recursively all the way down is this hash. The parent commit has this hash and the information about the author, the committer and the commit message. And then we can keep walking down, right? So we can do appear, we can CAT file, tree this tree. And this might not immediately look very reasonable, but this is basically a serialized representation of the tree. And in particular the things you'll see here is, you'll notice that there's the mode of the file.
00:19:01.971 - 00:20:19.909, Speaker A: So this like, is this readable, is it writable? The name of the file and then these bits in between are basically a binary representation of, you guessed it, the object key for the contents of those files in this particular tree in this particular commit. And one of the reasons why you have this structure is because, for instance, if you create a new commit where you change nothing, right? So we did a commit earlier that was like allow empty, then it can use the same tree, so you don't need to store the entire tree twice, once for each commit. You can have two commit objects that have the same tree reference embedded in them. And similarly, if you have two trees that differ only in like the contents of one file, then the tree objects are going to be different, but they're going to reuse the same Object key for the blobs of most of the files, except for the one file that's changed, right? And so that's sort of the setup here. And you'll see here, like you see here is source, and then source just points at its own tree, right? So if I. There's not really a nice way to turn this back into the hash that we need, but. But there is then a tree object for the sort of hash equivalent of this binary string.
00:20:19.909 - 00:21:16.905, Speaker A: And if we cat filed that, we would see a similar tree object that would list all of the things that are under source, which is main. Okay, so that's what we're creating here. So we're creating object which is the sort of root store for this content hashable or content addressable store. And then refs is really just a mapping between human readable names, like the name of a branch, for example, and which commit hash that reference is to. So if we in fact look inside the git that we have for this and we look inside of refs, you can see here that the refs are in heads. You can see master. And if we cat master, you'll see that that is the same get revparse the same hash as we get back on head when we parse out the commit hash.
00:21:16.905 - 00:21:51.887, Speaker A: So that's just where those are stored. If you had multiple branches, there would be different heads under here. At the moment we only have the one, but under refs we also have remotes. So remotes is where is the same kind of refs except for references that are stored remotely, such as branch pointers on GitHub, for instance, from the last time you did a git pull. So if I do a cat of origin head here, for example, you see that it doesn't have a commit hash. Instead it says head is the same as. That's what this ref here means, the same as ref's remote's origin master.
00:21:51.887 - 00:22:50.567, Speaker A: So that means head is pointing to master. And if we cat master, you see that it's the same thing as here because we did a push. If I do a git commit allow empty like this test 2. Then now if I cat, if I revparse head, you see this commit hash is now different. Similarly, if I now cat master, that's the same because that's the local one. But if I cat the master in the remote origin, I still get the old commit because that's where that points. And so now you're sort of starting to see how this comes together, that when you do a commit, you update your Local refs when you push, what you really do is you're telling the remote, hey, update your refs master to have this commit instead this commit hash, rather the other things that are in refs is tags, which, you know, obviously every tag has some name and has to point to the hash of the commit object that that tag is pointing to.
00:22:50.567 - 00:23:18.183, Speaker A: And if we look at objects, you see, this is just a. This is almost entirely just a list of files by hash. And in fact we could even find here. So head was that. So get objects 6F. You'll see here that the first two characters are used as a directory name and then the rest are flat files. The reason for that is just because Linux doesn't like it if you have a bajillion files all in the same directory.
00:23:18.183 - 00:24:08.955, Speaker A: So splitting by the first two characters of the hex just allows the file system representation of this to be a little bit more efficient. But you see here 6 FC 85. 6 FC 85. So this is the same object and indeed if we now cat this, it's, you know, a binary file, but really the contents of that is commit is the same as this. It's just a compressed version of it. Okay, if you hex dump that, we see the same hash for tree. So you want to hex dump this file.
00:24:08.955 - 00:24:33.417, Speaker A: I don't think that's going to help you too much. No, this is not just like the binary representation of that because it's ASCII would be the same. It's like I believe these are compressed. I forget. Exactly. I'm guessing we're going to get to that in one of the first exercises. Okay, so that's hopefully now you have a sense of what are in each of these two directories.
00:24:33.417 - 00:25:05.175, Speaker A: So there's objects, which is the object store refs, which we just talked about, and head, which is just a special kind of ref. It is specifically which commit is currently checked out. That's what head means. And initially that's just going to be the main branch. That's fine. So we did this first thing where we're now we just create the correct directories and then we also create the head file, right? So if you look at main here, we created git, we created git objects, git refs, and we created this githead file, the points domain. That's what we did.
00:25:05.175 - 00:25:27.765, Speaker A: Git actually creates more files and directories, right? So if you go look in git, there's a bunch of other things here like logs and branches and stuff. We're just going to Ignore those for now. These are all we need to get started. There's zlib compressed. That sounds about right. Githead has a new line at the end. That's fine.
00:25:27.765 - 00:25:47.065, Speaker A: Okay, view. Next stage, read a blob object. So this is the cat file command that we actually just used. And so I'm guessing here the goal is going to be that you can cat file some blob and it just prints what the contents of this is. So I'm guessing here we're going to get to the point of doing a decompress. Right. Which is exactly what we expect.
00:25:47.065 - 00:26:16.705, Speaker A: We'll deal with three git objects, blobs, trees and commits. Right. So we've talked about all these so far. Blobs are sort of the lowest level thing, which is just the contents of a file. Yep. Only store the contents of the file, not names or permissions. And this is so that, for example, if you have two copies of the exact same file in your directory tree, it's only stored once because the tree just stores the same hash twice under different names.
00:26:16.705 - 00:26:35.109, Speaker A: Yes. It's a SHA1 hash known as the object hash. This is an example git object storage. They're stored in git objects. We looked at that, we looked at how the path would be structured. Each git object has its own format for storage. Right.
00:26:35.109 - 00:27:04.575, Speaker A: So blobs, trees and commits have a different on disk binary representation from each other. And this is presumably because you want to optimize for, you know, both how they're used and how they compress the best. I'm guessing we'll see that in a second. So for blob storage, they are zlib compressed. Yeah. So whoever was in chat was totally on board with this format of a blob object. Looks like this blob space size, a null byte and then the contents.
00:27:04.575 - 00:28:00.325, Speaker A: Okay, so we can, we can sort of verify this if we want. Right. So the. What is the easiest way for me to do this? Actually, I just want to see if I can find, like if we look under dot get slash object objects and we look at, I don't know, F9 what what is in you? That doesn't look like a blob 60 doesn't look at the blob. Notice how it starts with the same kind of thing. So I'm guessing these are then probably either commits or trees. 9F.
00:28:00.325 - 00:28:20.665, Speaker A: So that starts with XK. So that's a different type of file 6F that we know is a commit because we looked at that one earlier. 73. Okay. Yeah. So These are all compressed. I don't think we're going to get something useful out of just looking at them.
00:28:20.665 - 00:28:38.055, Speaker A: So let's instead try to just implement this first bit. So we're going to have to. I see. Because they're. They're written like this and then zlib compressed. So we're. All we're seeing is the binary output of the zlib compression and so we need to zlib decompress and then we'll see this bit.
00:28:38.055 - 00:29:33.065, Speaker A: Okay, so let's then add here a CAT file and we should be able to here now do command CAT file. And obviously CAT file actually takes some arguments, right? In particular, it takes which thing that you actually want to print out. So it takes a. What's the dash P here for? Let's go look at CAT file. So CAT file takes a dash P and I'm guessing P being pretty printed based on its type. Okay, so let's go up here and say that CAT file is going to take a pretty print. Pretty print I can't type, which is going to be a clap short like this.
00:29:33.065 - 00:30:02.463, Speaker A: So it's going to take that. But it also is going to take a positional argument, right? Which is the. The object hash, which is going to be a. We can choose how we want to structure this, right? So we could say a string. Alternatively, we could say something like. I actually wonder whether. Yeah, it doesn't.
00:30:02.463 - 00:30:45.157, Speaker A: Yeah, I was afraid of that. I was hoping the clap might be smart enough to realize that this is something that can be passed in as a string to. To validate that it's exactly 40 characters. I think instead what we'll do is just take a string here and then if they give a hash that doesn't have the right length, then we'll just error out. There is actually the point here that I believe CAT file is a little bit smarter in that it allows you to deduplicate. So you only need to give the longest or the shortest prefix that is unique. So here, because there are no other hashes than the one for this one that starts with this, it actually lets you get away with specifying fewer.
00:30:45.157 - 00:31:13.649, Speaker A: So that's even more of a reason here to specify string. So this is also going to have the object hash. And then in CAT file we go down here. Yes, we'll have to read the blob object decompress, extract the content and print the contents to standard out. Okay. Shouldn't be too bad. CAT file must not contain a new line.
00:31:13.649 - 00:31:23.977, Speaker A: That's fine. You can use Flay 2. Okay. So here's what we're going to do. We have to open the file. In fact, we don't. So there are two ways we could do this.
00:31:23.977 - 00:32:03.343, Speaker A: We could either read the entire entire file into memory and then decompress it in memory and then do what we want the output. Or we can open an IO reader here, which is realistically the nicer thing to do. File open. And we're going to try to open. I'm going to leave a to do here. Support shortest unique object hashes. Right, because what we're going to do here for now at least, is to just open a file that is at exactly where the path should be according to the object hash.
00:32:03.343 - 00:32:59.375, Speaker A: But realistically, we basically want to use something like glob here to put a star at the end and find the number of unique files or the number of files that match that prefix. And if there are more than one, then we error saying you need to choose. If there's only one, then we give that file. But for now, let's do the whole thing. So what we want to open here is git objects slash and then the first two characters and then the rest where format. So what that is going to be is object hash2 and object hash2 like so. So that is going to open the file and then we're going to use the flate to crate.
00:32:59.375 - 00:33:36.785, Speaker A: The flate to crate basically provides different kinds of compression and decompression things. In our case, what we want is a reader and in particular I want to decompress. Do they have a copy paste example I can just use? Because that would be nice. This is for compression, don't need multimember. I guess I'll do read Zlib decoder. Aha. Amazing.
00:33:36.785 - 00:34:14.391, Speaker A: So, oh, and I don't really need env here. That one can go away. And so down here I'm then going to create a new zlib decoder. And the zlib decoder new here takes anything that implements read and files implement read. So we can just pass that in right here we get a zlib decoder back and then it implements read for zlib decoder. Right. So the idea here is that it's sort of a streaming decoder.
00:34:14.391 - 00:35:05.599, Speaker A: So it reads from the file, decompresses and produces a thing that you can then read from. In our case, the question then becomes, okay, what do we want to read out here? Well, really what we're reading out is just a string, but it is a string with a little bit of structure to it. Right? So it has this structure right here. So what we can do is we can either write a custom re implementation over read here or in fact, here's what I think I want to do. What is size here is the size of content in bytes. Yeah, but how many bits though? I see it's just an. Okay, it's variable length decimal encoded.
00:35:05.599 - 00:36:15.405, Speaker A: So this is really just a null terminated string. Okay, so in that case what we can do is use z.in fact, I think what I want here is Z is buffreader new of Z. So buffreader. All right, I guess we'll return here a anyhow results. We'll do a cargo ad anyhow so that at the end here we can do this and we can do context just to make it a little bit nicer than just unwrapping everywhere open in git objects. So this the buffreader here.
00:36:15.405 - 00:36:42.141, Speaker A: So buffreader is a type from the standard library that allows you to basically keeps both the read thing that you pass in and a buffer that it's reading into. And then it'll. Because it keeps that buffer and doesn't just take whatever comes out of read each time. It can do a little bit smarter things like this growable buffer. You can do things like read until you hit this character. And what we'll do is keep filling into the buffer until it hits something that matches that. Which is exactly what we want here.
00:36:42.141 - 00:37:46.935, Speaker A: Right? We can do Z read until we want to read until we get a zero byte. And the buffer we're going to give it is is vec new. So we're going to read until that into this buffer like this Read from get objects or read header from git objects is really what we want to do. And these don't need to be muted. Okay, so if we look at the docs for read until it says until the delimiter byte or end of file is reached, all bytes up to and including the delimiter will be appended to buf. Okay, so in theory at least, this means that after doing this reading, the stuff that's in here is technically a valid C str. So in the standard library.
00:37:46.935 - 00:38:08.275, Speaker A: Nope. C str there's a type called C str in FFI that represents a borrowed C string, right? Which is really what we have here. C string being a null terminated array of bytes. Right? That's exactly what this string is. It can constructly safely from a U8 slice, which is exactly what we want here. So we can do. Let me.
00:38:08.275 - 00:39:18.955, Speaker A: I wish this was the default view. So what I want is let header Is seester. What's the name of it? It's like from bytes with null. Yep, this one is safe, but it does scan the string ones to make sure there aren't any null bytes within the thing you gave and that there is one at the end. I think that's okay technically, you know, we could have a smarter implementation here that was like, we already know that there is no null inside, so we could use the unsafe constructor here. But in reality, you know, I don't think it actually costs us that much and it means we don't have to use unsafe, so let's just stick with it. So we can do this and say this one we can actually do expect because we can say no, there is exactly one null and it's at the end.
00:39:18.955 - 00:40:25.715, Speaker A: So this isn't an error we expect that should ever be possible at runtime. And so then we can use expect and I'll grab in CSTR here. And at this point, you know, back here we were told the structure of this is blob space and then the size. So we should now be able to do, you know, header.infact header.tostiro in fact, I'm going to do this context get objects file header is invalid UTF8 and remember here that really it's ASCII, right? But ask all ASCII is valid UTF8. And so at this point we should now be able to do let some size is header strip prefix.
00:40:25.715 - 00:41:27.937, Speaker A: We want to strip out the blob space that we know is at the beginning. And if there isn't a blob space at the beginning, then something is terribly wrong, right? And we can bail and say get objects file header did not start with blob and then we can even give the string that was actually produced, right? Which we can do here. And then we want to say let size is size parse and we want to parse this as a usize, right? It should not be a signed number. The negative wouldn't make sense here. Here too we can give the context of git objects file header has invalid size and we'll print that out as well. So now we have the size. Now we know that the now we know how long the content should be.
00:41:27.937 - 00:42:25.705, Speaker A: And so we should now be able to say buff dot reserve exact. In fact, we can truncate it to zero, which is really just a clear, right? And then we can do reserve exact and we want to reserve exact size, right? So this is saying clear all the stuff that was in the buffer that we read into previously, right, which is this header bit. And then we want to reserve space for exactly this much, which is how long git claims that the file should be. And at this point we can now do Z read to end. In fact, is there a dot read? There's a read exact. That's what I want. See.
00:42:25.705 - 00:43:12.327, Speaker A: Okay, so there are two ways to go about this. The question really is what do we want to happen if this is wrong, right? Like if the size here doesn't match how much is actually in the file. So we have two options here. We can either do read until end and what read to end will do is if I pass in the buffer here, it will read until it hits end of file and it will grow buf if necessary. So if the real file is way larger than what the size header said, then this will just keep growing buff potentially until it produce a giant file that's not. And then we could check afterwards that it matches the size. But still the other alternative is to use read exact, right? Read exact takes a slice.
00:43:12.327 - 00:43:39.985, Speaker A: So you have to take the vac and produce a slice of that size and then it will read exactly that many bytes. If it hits end of file before that, it returns an error. Which kind of is what we want here, right? Unexpected end of file. If you read something shorter. And then we would, after doing the read exact, we would check that the next read returns end of file. That's sort of the nicer way to do this, right. So I think we're going to go that way for now.
00:43:39.985 - 00:44:24.445, Speaker A: So in that case, what we actually want is we want to slice into buff of the right size. So if we go now to. I forget exactly what this method is called, right? Because what we really want here is a method that returns. Yeah. So yeah, sure, let's do this properly. So here's what we're going to do next. I'm going to do it the slow way first and then tell you why it's slow and then how we could fix it.
00:44:24.445 - 00:45:16.069, Speaker A: So let's do. So where do I want to start with this? Z read exact add mute something. So this has to be a slice. If I just give buff here, right? Like I can do this get objects file had unexpected contents did not match expectation. A little bit of weird error. The problem here is that if you this slice will be of length zero because we cleared the buffer and then we reserved this many bytes, but the length of the vector is still zero. Right? Like that we made the capacity be large or whatever the size dictates.
00:45:16.069 - 00:46:00.263, Speaker A: We did not actually set the length to anything. And the answer to that is of course. Or the reason we did that, of course, is like, if here, if the length was set to size, what would the value of buf 0 be? Or worse yet, like size minus 1, it doesn't have a defined value because we haven't set it to anything. And if there's one thing Rust dislikes, it is like memory with undefined values, right? So there are a couple of ways we can go about this. One of them is resize. So with resize, I can set size, and I can say that every value should be given the value of zero, right? So instead of reserve exact here, I do resize to size of zero. The zero here basically means every element should be given the value of zero.
00:46:00.263 - 00:46:25.617, Speaker A: So allocate to size and then set everything to zero. This works. The problem is we're writing a bunch of zeros that we're then immediately going to overwrite. So that feels kind of stupid, right? Like it's an unnecessary performance penalty. What we really want to say is I just want it to be the size, and then they're all going to be overwritten anyway. There is a way to do this, which is to use the maybe on INIT type. And what you would do is you would have a.
00:46:25.617 - 00:46:56.785, Speaker A: Instead of having a VEC of U8, you have a VEC of maybe an init of U8. And then you can resize it. You can basically set its length to be. You can hear. You would do maybe, right? So you would set the length to just have uninitialized bytes the entire way. And then you would cast it into the U8 buff that's needed here through an unsafe call. And then afterwards, you would assert that the vector now holds initialized bytes.
00:46:56.785 - 00:47:32.709, Speaker A: We're not actually going to do that here because it's a little bit of a wonky code. And I think it distracts too much from what we actually want to do here. But it's just a worthwhile thing to point out. One of the reasons I don't want to do it is because one of the methods I know I'm going to want here is a way to turn a slice of, maybe uninit U8s into a slice of U8s. There's a nightly, like an unstable function to do this, but it's not stabilized yet. And so I don't want to also need to opt into nightly here. This will turn into an optimized memset, I believe.
00:47:32.709 - 00:48:27.757, Speaker A: But even so, you're still telling the computer write all these zeros. So we're going to stick with this for now. And what readexact returns you'll see it's an IO result with unit, right? Because it doesn't need to tell you how many bytes it read because you told it read exactly this many bytes. And so now if we now do a read and I'm going to pass it a empty. I'm going to pass it a one byte long thing here. Yeah, N is this. I guess this is really read contents of read read true contents of git objects file.
00:48:27.757 - 00:49:25.681, Speaker A: And this is validate F end of file in git object file. And here we should assert that N is zero, right? So there should be no bytes after the size that the header required that we do. And here we can use, I think it's ensure, right? N equals 0 or git object file had n trailing bytes. Okay. So in theory, now we're reading out this whole thing. We write it into the buffer and at the end of all of this, the question now becomes what do we actually print out? So the thing that comes after here, the content here is like it's just a bunch of bytes. There's no guarantee that there's actually a string.
00:49:25.681 - 00:50:12.655, Speaker A: It could be an image, right? Any file that you can put into Git will have this structure. And so when it says cat file, it's worth pointing out that this, the stuff we end up with is just a binary blob. And so we don't actually want to print it using like println because println will require the thing you gave it as a string. So instead what we're going to do is take stdout, which is going to be iostandardout. So this gives us a handle to standard out. And then we can also even do, if we want to sort of maximize performance here, we could lock standard out so that no one else writes to it and so that we don't get any garbled output. There is no concurrency here, so it doesn't really matter.
00:50:12.655 - 00:50:31.835, Speaker A: But if you. So you can write directly into this. But what that means is every time you write a new chunk, it takes the lock again and again. Here we're just going to lock it and do all our writes at once. And so now we can do write to stood out. And we want to write. In fact, I don't want to do that.
00:50:31.835 - 00:51:11.325, Speaker A: I want to STD out, write all of buf. And then this will be write object contents to stood out. And then this needs to be muted. Okay, let's try to cargo run cat file. The P doesn't do anything at the moment. Let's see what that does. Right.
00:51:11.325 - 00:51:32.795, Speaker A: So it tells me well, I couldn't do that because you didn't tell me about an object hash. So let's give it an object hash cat file. This git object file header did not start with blob, it started with commit. Right. So we've only told it how to print blobs. We haven't put in handling for things like printing a commit yet. That makes sense.
00:51:32.795 - 00:52:57.867, Speaker A: So instead I guess up here where we're currently looking for the blob header, what we actually want to do is say kind and size is header dot split once on a space and we do expect that that should always be the case. Otherwise did not start with a known type and then we're going to match on the and then the size can keep going here. I'm guessing they all have the same structure for this header. But down here what we want to do is match on the kind. If it's blob then we do this. If it is anything else then we do write to standard out do. Ah, so now I know what the P flag is doing is almost certainly that if I'm going to guess that if the p flag is not given that it prints out just the raw decompress.
00:52:57.867 - 00:53:54.431, Speaker A: So if I did here, if I do get cat file this, I see you need to give the type and if you give P. Okay, never mind then. So if we get anything that's not blob then we say we do not yet know how to print a kind and this needs to be a comma and I've done something else wrong. What else have I done wrong? Ah, there we go. Buf is borrowed as mutable. Ah, so this is because we're still borrowing kind here. So let's go up here and do enum.
00:53:54.431 - 00:54:43.579, Speaker A: Kind is blob and blob is the only one we have here. And so down here we can say let kind is match kind and we'll make this a little bit nicer. So blob is going to do kind blob. Anything else we do not know how to do. So we'll do in fact we'll do anyhow bail like this. And then down here this is now going to be kind blob and we can get rid of this guy. So now if I do this, it'll say we do not yet know how to print a commit.
00:54:43.579 - 00:55:15.417, Speaker A: Fantastic. Do we have something that is a blob is the question yes we probably do. We can do. We can print out this tree like so. Oops, I meant to use the git version here. Oh tree can I like pretty print it? I probably just does the same. Aha.
00:55:15.417 - 00:55:34.485, Speaker A: Pretty print. Okay great. That's what I wanted. So let's try to do. I don't know, gitignore is probably a nice short file and so now if I run our version and do cat file of this. Aha. And look we indeed printed out what does indeed look like a git ignore file.
00:55:34.485 - 00:56:20.131, Speaker A: Amazing. Okay, so that's really nice. Amazing. So now we have a thing that actually does print out what we wanted. We can get rid of this logs from your program will happen here. Let's make that go to eprint line and I think actually up here we're going to do anyhow ensure pretty print because that's what the real git command does. Right.
00:56:20.131 - 00:57:04.155, Speaker A: When I tried git cat file of this it just gives me the help thing and says you need to give both a type and an object or you need to give dash p and so this is mode must be given without P and we don't support mode. Great. Someone asked in chat is it possible to redirect the read of the payload directly into standard out without the vec allocation? It is. So the proposal here is actually let me push this first and then show you that change. Great. Yep. Commit second exercise.
00:57:04.155 - 00:57:57.255, Speaker A: Good push. Let's see what it does. I don't know why we have Tokyo in here. Probably get rid of Tokyo here and then get significantly faster belt a whole lot of steps. Let's see what they have in cargo. Toml why do we need HTTP requests? Interesting. I don't none of oh, we're going to need it for cloning a repository at the end.
00:57:57.255 - 00:58:19.713, Speaker A: Right. Then you need to actually read things from the remote. I'm going to just comment those out right now because we don't need it for this. I'm also fine to use anyhow instead of this error. So we'll do this just to all test pass. Great. Woo.
00:58:19.713 - 00:58:55.045, Speaker A: It's happy with us. Great. So we did the right thing. So now the question is can we make this a little bit better? So instead of. Instead of doing this with sort of reading into a buffer the moment we've read the header we don't really need to do anything else. We can just stream the rest of the decoder directly to standard out and that is indeed doable. So here's what we'll do in order to Accomplish that, we'll do a match on kind because that might only be possible for blobs, for example.
00:58:55.045 - 00:59:39.291, Speaker A: Right. But if what we get is a blob, then we should be able to stream it directly out. And then what we'll actually do is IO copy, which takes a reader. In this case, the reader is going to be Z and the writer which is going to be standard out down here, mute to standard out. And then N is going to be that. And we'll do here write file into to standard out. And then at the end here, after printing it all out, we'll do this.
00:59:39.291 - 01:00:12.935, Speaker A: Assert now the downside of doing it this way. I think I can now get rid of most of this. The downside to doing this way is we might actually end up copying a lot more like imagine that the file is actually way longer than what the size dictates. Then the copy here is still going to copy until the decompressor runs out of stuff. And this is how you get to things like zip bombs where you just keep reading as long as the decompressor is giving you stuff. Even if there's a header that says how much there should be there. And so this is just going to write everything out.
01:00:12.935 - 01:00:52.785, Speaker A: There is a way to get. I forgot the one byte read. You don't need the one byte read here. The thing to check that we hit end of file because copy is going to run until it hits end of file anyway. And then it's going to tell you how many bytes it actually copied over. And so I guess this should be size has entrailing bytes. Where that's really going to be file was not the expected size.
01:00:52.785 - 01:01:23.515, Speaker A: Expected is going to be size actual is going to be nice like this. Yeah, so we don't really want to do a sort of unguarded read here. There are a couple of ways around this. So for example, it could be. We'll see whether that's the case here. This one does not have it decompression settings. Let's see here.
01:01:23.515 - 01:01:51.125, Speaker A: This one doesn't. Okay, so there are some of these libraries that actually provide you with a way to set a limiter. Given that we don't have that, what we can do is actually create a limit reader and it is going to hold a. And there are crates that provide this as well. But we can write it pretty easily ourselves. So we might as well. The reader is going to be an R.
01:01:51.125 - 01:02:44.035, Speaker A: Limit is going to be a use size. And then we're going to implement read for limit reader where R is Read and we'll grab in here, implement numbers and in fact we're also going to implement the default ones specifically because we want, we want to forward as many of these as we can. Well, all right, well, we'll not do that right now. We'll leave that to other crates to do. My thinking here was that we really want like if the underlying reader here is an optimized like vectored read, for example, we would really like to make use of that. But in the interest of time, I won't do that here. There are crates that provide exactly this type this reason.
01:02:44.035 - 01:04:35.415, Speaker A: But what we'll do is we'll have a. When you do a read, you'll do let N is self reader read into buf and then if N is more than limit, in fact we're going to shorten this even more. We're going to say if buff len is greater than self limit, then buff is equal to. So this is going to be mutable, then buff is going to be equal to mut of buff to self limit so that we never read more than what we're allowed to. We're then going to do the read into buff and then we know now that this will never be more than N, but then we'll do self limit minus equal N and then we'll do okay of N. So the idea here is there's one bit that's going to be missing here, which is we really want to error if there's more. I think what we'll actually do here is we'll do plus one and if N is greater than self limit, then we will do a return IO error new IO error kind.
01:04:35.415 - 01:05:43.115, Speaker A: I guess we'll do other too many bytes. And so now what we'll do here is we'll actually say that mute Z is in fact we can do that out here. Z is a limit reader over the original Z with the limit of size. And so now we can guarantee that we'll never read more than this size out of the reader ever, right? If we do, then we're going to get if the reader produces more bytes, then we'll hit this error right here, right? And so now this copy is going to read through the limit reader, which means it'll be limited. It might still produce a value that's lower than size, in which case we want to error. But if it produces something that's more then it'll hit this too many bytes error. And so in theory, now cat file should still work.
01:05:43.115 - 01:06:27.885, Speaker A: And it's going to complain about this bit because the limit here needs to be a U64. Almost certainly this then should also be a U64. So U64 is fine here. I guess the limit here should be use and then this should be as use size. That's fine. So it still now works. But if you were to get an object file where the size header didn't match, you would get an error regardless of whether it was too long or too short.
01:06:27.885 - 01:06:57.595, Speaker A: Could you use reader take here? Ooh, you might be right. Take an adapter which will read at most limit bytes from it. Yes, indeed. Although. So the difference here is that this will return end of file. It won't error. I guess that's okay.
01:06:57.595 - 01:07:43.215, Speaker A: It's kind of nice to get the error, but in the interest of shorter code which is easier to reason about, we can do Z is Z. Takesize has the same effect. Good call. Note this won't error if the file is if the decompressed file is too long, but will at least not spam stood out and be vulnerable to a zip bomb. And just see, this still works. It does. And then we can now get rid of the IO thing.
01:07:43.215 - 01:08:29.654, Speaker A: Let's do add cargo lock and cargo Toml first comment out big depths for now. And down here. Mitigate zip bomb Git push. I've educated chat, so they're. They've surpassed me now. Chat now is telling me about all the things I didn't know about Rust. Yeah, so see how much faster the build was here because we got rid of all those extra dependencies.
01:08:29.654 - 01:08:57.935, Speaker A: Nice. We might have to add them back, but at least we don't have to wait for them for each stage until that last one. Okay, let's go see what the next exercise is. I guess we're supposed to be doing exercises. Create a blob object. You'll implement support for creating a blob using the git hash object command used to compute the SHA hash of a git object. When used with the W dash W flag, it also writes the object of the git objects.
01:08:57.935 - 01:09:17.085, Speaker A: Oh, I see. So this produces the hash that this file would have created if it were added to git. And then with dash W will also write it into git objects. Nice. Okay, that should be pretty easy. Yeah, that's fine. We just.
01:09:17.085 - 01:09:42.085, Speaker A: It thinks we're at the next exercise. So it goes. That failed. But you see, stage two succeeded. Okay, so we have what's it called? Hash object. Right. And then this is going to be file, which is going to be a path bus.
01:09:42.085 - 01:10:30.135, Speaker A: So down here now command hash object Write and file. Let's see what we get into. So what are we going to do? Well, we need to compress it and then we need to add the sort of size field to it. No, the other way around. We need to add the size header and then we need to compress it and then we need to hash it. Right. So the inverse of what we did for print here.
01:10:30.135 - 01:11:11.653, Speaker A: So the header is going to be. Ah, see here's the awkward part. We don't know the size until we've read the bytes, which means we can't start writing, we can't start creating the hash until we've read the bytes because the hash is going to include the size and it comes before the contents. So this is why often these formats tend to have the size at the end rather than the beginning, because that way you can do it in a streaming way. But if you are at the end instead of the beginning, then when you read you can't pre allocate the storage. So like you have to choose either writing is annoying or reading is annoying. And in this case writing is annoying, which is fine.
01:11:11.653 - 01:11:39.785, Speaker A: Or rather when I say annoying, what I mean is a little bit less efficient. Right. Because you need to read all the contents into memory in order to produce the hash you're eventually going to print. You can't just stream it through, but you can stream reads. And so given that you read more often than you write, that's probably a worthwhile trade off. Yeah, we can staff the file to get the size ahead of time, but that doesn't work. For example, if file here were standard in.
01:11:39.785 - 01:12:37.545, Speaker A: So my guess for example is that hash object also allows you to pass things from standard in. Who does it not? Oh, it doesn't? Well okay then ignore me. Then what we will do is start the file. So we'll do metadata of file context stat file and we can actually here be a little bit more helpful. Right. So we can do with context format and then actually print out the path to the file and then we'll do a hasher is going to be. So I think we have the SHA1 crate here already.
01:12:37.545 - 01:13:23.237, Speaker A: I think that was already in the cargo toml. Yep. So we're going to create one of these guys and we'll add in this. And I think we already have the hex crate, although I think actually looking at the cargo toml, I think it's using hex and I seem to remember something about because there's hex and there's hex literal. Hex literal I think is maintained by the Rust crypto community which like crypto as in cryptography community, who are the same ones who maintain like things like SHA1 and so that's why they're using that here. I don't think it matters too much either way. We'll.
01:13:23.237 - 01:13:40.861, Speaker A: We'll use hex. That's fine, given that that's already in the. In our cargo toml. So we can just leave that. So we'll go down here. The hasher is going to be that. Then we're going to b.sorry
01:13:40.861 - 01:14:37.471, Speaker A: hasher.update. we're going to write blob space and then hasher.update the size, which is going to be a format of stat.alrust analyzer doesn't like me now stat.len and then we update it with the size and then we update it with a literal zero. I wonder whether. Does update allow that as ref U8? No.
01:14:37.471 - 01:15:20.565, Speaker A: So I'll do this then, like this. And then we want to stream in the actual contents of the file into. No, this is not even true because we need to compress it first. So ignore me for a second while I grab the zlib encoder. Oh, there's a stdin flag for reading from standard in. Okay, we want the zlib encoder. We'll grab the same things here and we want one of these guys.
01:15:20.565 - 01:16:03.139, Speaker A: So ah, so this is where it's going to be. Yeah. Okay, so we create a zlib encoder and we're going to write all blob space compressor is going to come at the end. Hasher is also going to come at the end. We're going to write all that. We're going to e dot write. In fact, I think E.
01:16:03.139 - 01:16:51.725, Speaker A: I think E here just implements write. So we can just do this instead. It's a little bit nicer and that way we don't need the format, we can just write estat len and that also means we can then write. And I think we can just do this like so. And this is going to be have a question mark. That's fine. So the pressed thing here is evacuate, right? So here you give it what you wanted to write the output into.
01:16:51.725 - 01:17:17.829, Speaker A: And so here really what we would do is construct the file that we're going to output imp to. But we also want to sort of keep a running hash of the thing that we're writing so that we get the hash at the end. Right. So what do we actually want here? And here I am going to claim that we need our own implementation of write. So we'll do a hash writer. I mean, unless the SHA1 crate has one, but I'd be very surprised. Yeah, it does not.
01:17:17.829 - 01:18:35.775, Speaker A: Okay, so we're going to hash writer, which takes a W, it has a writer and it has a hasher, which is going to be a SHA1. And then we're going to implement write for. Write for hash Writer W where W implements write implement asyncmembers. And again here there are a bunch of other methods you might want to pipe through. We're just going to skip them for now because the efficiency isn't that important to us. So here, what we want to do is self hasher updatebuf and then self writer dot write buff and actually this is not quite right, because we actually need to do this buff N because it could be that the writer does not write all of the bytes that it's given, and we would only want to update the hash with the bytes that were written because they're going to be given in again the next time around. So this is actually, I'm guessing someone has been tripped up by this in the past.
01:18:35.775 - 01:19:07.323, Speaker A: And so then we're going to return OK N and Flush is just going to be self writer flush. We don't need anything special for that. And so now our writer is going to be. And this is going to be annoying, isn't it? Yeah, the generics here are going to come bite us, which is a little frustrating. So we'll have a. We'll have a function for this. I'll.
01:19:07.323 - 01:19:38.701, Speaker A: I'll show you what I mean. So what I really want up here, right, Is writer is if right. Else if right, then we want. Oh, actually the thing we're going to have to do here is file create temporary. I'll talk about why we need temporary in a second. And otherwise is going to be a vec new. In fact, it's not even going to be that.
01:19:38.701 - 01:21:04.225, Speaker A: It's going to be unit, because we don't actually care about the bytes that are written, we only care about the hash. And then what I want here is given writer. The problem, as the compiler helpfully points out, is that the if and the else have different types here. And so writer doesn't have a well defined type, it has one of two, which means zlib encoder has one of two because it's generic over the writer. And you know that we could put all of this code inside each branch, but instead what we'll do is just have an fn. In fact, we can define that up in here. Write blob Going to take a W and the bits that it is given is the size and the file size here being a U64 file here being a reference to a path in fact file size and writer and it's going to return an anyhow results like so.
01:21:04.225 - 01:21:53.395, Speaker A: And then up here we're going to go up and grab this, put that in here. And so now if write then we're going to do write blob of file and stat.len stat len and this write blob object to disk. And really this is to temporary file. And again I know I've promised to explain why we have that, so I'll do that in a second. And otherwise we're going to do this like so. And then down here this is going to return okay, if nothing.
01:21:53.395 - 01:22:43.311, Speaker A: So inside of here we're going to take the writer where W is right? And we'll grab in path here. I was pretty sure unit implements right? Does it not why it should right? Really there's a sync type instead of it just being for unit. All right, fine. Stdio sync then. So this is the writer which will move data into the void. That is it does no actual system calls generally called by calling sync. Okay, fine, fine, fine, fine.
01:22:43.311 - 01:23:36.435, Speaker A: Like this. So inside here we're going to open a zlib encoder over the writer that we're given. We're going to write out blob space and and then the size and in fact that means this bit can also move in here because there's no real reason for it not to. At which point we don't need to take the size anymore and these don't need to pass it in. Oops, one too many stat len and at the end here we're going to call E Finished compressed gives us back the writer after we finish the encoding. And the hash now is compressed dot so that's the. Let writer is actually going to be one of our hash writers here.
01:23:36.435 - 01:25:02.701, Speaker A: So hash writer of writer and hasher where the Hasher is a SHA1 new like this. And so now the hash at the end is compressed.hasher. what is it finish for SHA1 finalize and then this I guess we will do contexts here because these write blobs return an error which is going to be write out write out blob object and this is really construct temporary file for blob right. And at the end here I guess we get the hash and so we could really just return the hash here instead. What is the type of hash? It is something. Ooh, not what I Meant to do so in our. In our SHA1 SHA1 here SHA1 core.
01:25:02.701 - 01:25:41.325, Speaker A: Is there an easy way I can name the output? Here is what I want to know. Fixed output core output size, user. Oof. I just want something that I can name as the output type here. That's fine. I can have it be a hex instead I suppose. So this will output then hex encode of hash as ultimately what we get out here.
01:25:41.325 - 01:26:38.335, Speaker A: And so this then is going to be let hash is this and this. Actually I'm going to have to explain this now I think so here in the, in the right case, the hash we get out like we wrote to a temporary object because we don't know the hash until we've run through the entire input file. And so we don't know where we want to write the output to until we've done reading the input. And so we have two options. Either we do it all in memory and then write out to the final file, or rewrite to a temporary file and then we move the temporary file to where it's supposed to be. And so in this case I'm going to do the writer. The latter, I mean we're going to do create all.
01:26:38.335 - 01:27:56.915, Speaker A: Oops. Yep. Get objects this where that is going to be hash. So the first two characters create subdir of git objects and then we're going to do STD FS rename of and this let's for now just say it's called temporary. Realistically here you would use a. You would use an actual like thing that generates random temporary file names. For now I'm just going to pretend that we have one of those and then we're going to move it to the final location which is going to be this and hash to onwards write out or move blob file into git objects.
01:27:56.915 - 01:28:40.555, Speaker A: And in fact I think we want to get the hash out of here. Right? So this is going to, this is going to do this, this is going to do that. And then here, regardless of which path we took, we do want to print out and it looks like hash object prints with a new line. So we'll print out the hash regardless of which path we took. Okay, so now let's just see if this does the right thing. So if we run hash object cargo lock, what does it do? Well, it printed a hash, but it's not the same hash. So that seems problematic.
01:28:40.555 - 01:29:11.655, Speaker A: As the list of implemented commands is growing, why not split the command processing of each into individual dedicated functions? We'll probably do that like, there's no real reason to have them all be directly in line here. I agree. And it's going to get unwieldy as we grow. Same thing as there are probably some things we can reuse. Like, for example, this way to construct paths. There's no real reason you want to repeat it. Quite to the contrary, you probably want to share it.
01:29:11.655 - 01:30:12.169, Speaker A: I think for now this is okay, but the moment we go to the next exercise, I'm going to split them. Okay, so we did something, but it's not quite right. Like, we end up with a different thing than Git does, which I think suggests that what we actually want to do here is a, I want to do a dash w and then I want to do a cargo run-w and then I want to diff.git objects 31e, which is what git actually produced, and git objects 2a, 70, which is what we produced. So it did actually write to the file. That's good. Okay, binary files differ.
01:30:12.169 - 01:30:37.855, Speaker A: Yeah, that's fine. So let's do xx hex dump of each of them. Hex dump of the sky. Oh, I want to decompress them, which is Z cat. I think Z cat can do this. Can't. Isn't there.
01:30:37.855 - 01:31:14.141, Speaker A: Oh, I don't remember. There's a command equivalent to Z cat but for zlib and it is called Anyone remember? I don't have xxd. Really? Neovim doesn't ship with xxd. That's really annoying. Yeah, I could write it out myself. But I also want the ditto one. There is a command for this.
01:31:14.141 - 01:31:47.095, Speaker A: I'm just blanking on the name. In fact, I actually wonder whether I can just have Vim open the file. No, I did not want to do that. No hex dump. I don't think hexdom has uncompressed Zlib data. Wow, that's awful. That's.
01:31:47.095 - 01:32:13.765, Speaker A: That's so awful. I mean, I guess that works, but that's just. That's just terrible. Wow. Wow. Okay, that's. That's so stupid.
01:32:13.765 - 01:32:52.645, Speaker A: Okay, so that's what it gives for our file. And then what was the other one? 2A. 1 2A. Wasn't it 2A too hard to scroll? 2A 70 is ours. Interesting. Well, that's certainly different. So notice that the one from Git has the actual file contents and ours just does not.
01:32:52.645 - 01:33:27.635, Speaker A: Interesting. Why do we not. Oh, that's because we don't actually write. We don't. We don't actually write the bytes at all. We write the header and then we don't write anything else. We need to STD IO copy of.
01:33:27.635 - 01:33:47.195, Speaker A: That's. That's so stupid. Okay, STD FS file open of file. We'll. We'll grab the same one here. So of course they're different because we didn't. We didn't do it.
01:33:47.195 - 01:34:38.035, Speaker A: So we're going to read from file into E context, I guess stream file into blob this needs to be a mute. Okay, let's try that one more time. How about now? Okay, so it's different. It's still wrong, but it is different. Okay, let's now see what we get this time. So no, 51A is now ours. Okay, that's better.
01:34:38.035 - 01:35:13.001, Speaker A: And what is the one that git produces? Git produces this one. Okay, so our sizes are the same, right? Blob 117 92. Blob 117 92. This file is automatically generated by cargo. Interesting. So how are these different? Let's do hex dump of this. And then do I only need like.
01:35:13.001 - 01:35:53.443, Speaker A: I think I only need like the first three. What? I'm apparently bad at files 30. And then I want the 5:51. So that's gets. And this is ours. That all looks the same to me. A, B, diff ab.
01:35:53.443 - 01:37:04.025, Speaker A: They are the same. Ah, is the SHA one of the uncompressed? Because that would certainly make a difference if it is the hash of the. Yeah, the notes at the bottom, Sean, needs to be computed of the uncompressed contents of the file, not the compressed version. Okay, that actually makes this slightly more annoying. Just because it means that what we really want is a hash reader rather than a hash writer. It's not the end of the world. Right, so we just switch this around.
01:37:04.025 - 01:37:53.575, Speaker A: We implement reader of R. Let's keep this because we're going to need almost the same thing. Why not wrap the Zlib encoder with your hash writer? No, because the whole point is that we want a. We want the hash of the input, not the hash of the output. In fact, and it doesn't include the header eater either. I don't think, in fact, that's going to be kind of weird if the hash is. In fact, we can find this out.
01:37:53.575 - 01:38:29.355, Speaker A: Right? So what is the SHA1 sum of cargo dot lock. Okay, what is the. What is the SHA1 sum of this file? Like the decompressed. Okay, so it's with the header, but it is uncompressed. Right, so. So you see this, this hash here in the file name matches this hash here. So it is a hash of everything, including the header.
01:38:29.355 - 01:39:13.115, Speaker A: And so therefore we could just have the hasher operate. We could have the hasher operate on the. Yeah, we can still do it on. Right, we just need to do it before the compress rather than after the compress. So we want here this. So this is going to be. Yeah, so you need to invert this in your head.
01:39:13.115 - 01:40:10.595, Speaker A: Right? Because when we do a copy here, the writer that's hit first. So the thing that gets to see the initial input is the last writer we sort of add to the stack here. So this is the encoding writer that zlib encodes and then we wrap that in our hash writer and our hash writer is then going to see the uncompressed bytes and then forward to the zlib encoder which is going to produce the encoded bytes. So here we do writer writer writer writer hash is then writer hasher finalize. And this is writer writer finish. And we don't actually need the writer back. And this, this needs to be mutable and this does not.
01:40:10.595 - 01:40:31.199, Speaker A: Okay, let's try that again. Haha. That's the right hash. Amazing. All right, so now we have the same hash as what git does. And just to sort of. I mean there's no, there's nothing to diff here.
01:40:31.199 - 01:41:11.771, Speaker A: Right, because the hashes are the same and we would overwrite the same file. Okay, great. So now we have hash object working. And at least in theory, if I do this, it prints it, but hopefully did not do anything to get objects 31E. So that was last modified. In fact, I can just stat that file and then I'll run our thing without W and then stat it again and the modification time has not changed. And if I do dash W and then stat it, then the modification file has changed.
01:41:11.771 - 01:41:43.373, Speaker A: Okay, so now we have a hash object that seems to be doing the right thing. Amazing. We can remove A and B. And our diff here is implement hash object kid push. See what it does. Haha. All test pass this string of your dumpty.
01:41:43.373 - 01:41:57.475, Speaker A: Yikes. Dumpty dunkey dooby dunkey. What a string. Okay, fireworks. Amazing. Next stage, read a tree object. You'll implement lstree command, which is used to inspect a tree object.
01:41:57.475 - 01:43:13.671, Speaker A: Okay, so before we do that, let's do a little bit of splitting here. So let's in fact make modules create that. And then I want cat file and I want hash object. And inside of here, inside of here I want to grab all of cat file that's going to go in here and that's going to be something like, I guess invoke and that needs to take pretty print. And here we could introduce like an object with options that we could then forward onto clap. But I don't think we're quite at the point where we need that yet. Object hash here is going to be only really needs to be a string reference.
01:43:13.671 - 01:43:57.205, Speaker A: And this returns an anyhow result of nothing. I typed too fast. And then this goes in here, this goes away, this goes away. These go away, these go away, these go away. And then kind also is in here. It's the only place it's used. So cat file here is now going to do command cat file invoke of pretty print and object hash commence.
01:43:57.205 - 01:44:44.335, Speaker A: Yep, that can borrow. And then if we also look at command hash object we'll do the same thing which will take this bit and we'll do fn invoke returns anyhow result of nothing. And it takes the arguments write and file. So write is a bool and file is a path. And this is now going to call commands hash object invoke of write and file. Right. And I guess we'll do here a pub crate.
01:44:44.335 - 01:45:30.417, Speaker A: I also can't type. Apparently today hash object is going to get these same thing with the writer that we have at the bottom. That's also going to go in here. And if we go into commands, these are both going to be pubcrate and cat file is going to be pubcrate. Oops, pubcrate and hash object is going to be pubcrate and it's yelling at me for something. I've messed up my syntax here. This should be a colon.
01:45:30.417 - 01:45:47.237, Speaker A: Here we go. Path buff goes away. This goes away, this goes away. These go away. If we now go back to main file takes a reference. Amazing. And just to check that that still hasn't broken anything.
01:45:47.237 - 01:46:31.823, Speaker A: It has, because catfile needs an OK at the bottom and main now doesn't need most of its imports, which is nice. Like so split commands into mods when not streaming for day to day coding. Do you use copilot? No, I do not. I've just never really found a use for it. Maybe it's just because I haven't integrated it with my editor. But my bottleneck is not usually actually writing the code. It is thinking about what I want to write and how to do it.
01:46:31.823 - 01:47:11.815, Speaker A: Well, okay, so now we have this split into mods. So now we want to add the next command which is lstree. Lstree. Does it take any arguments, I wonder? Ok, well, we'll look at the tree object later. No arguments, except maybe Name only. Okay, so clap Long name only is a boolean. So we're going to have here lstree name only.
01:47:11.815 - 01:47:49.389, Speaker A: That's going to be lstree. Invoke name only. We're going to go here, we'll do this, create that module and we'll go grab the start of this from here. And this is where we're probably going to start to see some reuse between cat file and lstree. Right, because LS3 also needs to read out something that is stored in the object tree or in the object store, rather. Right, so the output of lstree would be treesha. Yeah, so this is the thing we looked at earlier.
01:47:49.389 - 01:48:38.377, Speaker A: Right. So if you have a nested directory structure like this, the actual tree objects only store the listings for one level deep. So that means if you do LS3 of the tree of your repo, you would have file 1, dir 1 and dir 2 and nothing else. For the things that have subtrees, for anything that is a directory, the hash that's listed for that entry in the tree blob or the tree object is a tree hash that you can then recurse down into, whereas anything that's a file is a blob hash. So. Right, so the caller that wants to print out something like this would actually need to walk the tree objects going all the way down. The object is alphabetically sorted.
01:48:38.377 - 01:49:22.537, Speaker A: This is how git stores entries. That's fine with the name only flag. Okay, so we are going to here name only. We're going to anyhow ensure name only. Only name only is supported for now and eventually we'll return one of these. Right, so we're going to get a tree sha and we're just going to print the names and nothing else so that we don't recurse down. We recommend implementing the full LS tree output too, since that'll require you parse all data in a tree object, not file names.
01:49:22.537 - 01:49:43.895, Speaker A: Okay, so it's optional whether to also print the hashes, but we are allowed to. Great. Let's look at what a tree object looks like. Trees are used to store directory structures. Multiple entries. Yep, we know that the name the mode for directories. If I use this.
01:49:43.895 - 01:50:03.955, Speaker A: Interesting. So there. Are they actually stored in ascii. Aha. We have a. We have a command to check this now. So if I now do a git revparse head.
01:50:03.955 - 01:50:37.615, Speaker A: Nope, git cat file. No commit of this. So this has this tree. So let's now print out 60 46. Interesting. Oh, that's because that that commit didn't actually commit anything. So do revpars of head.
01:50:37.615 - 01:51:31.695, Speaker A: Let's do this guy. Cat file this commit tree here. So if I now print out the tree at 6790. Oh, that's because I'm passing it to shossam. Okay, interesting. So there is something binary in here, right? Like this is the contents they're talking about. But what I'm trying to figure out is whether that's actually what's stored in the file.
01:51:31.695 - 01:52:03.053, Speaker A: But it sounds like what's actually stored in the blob is this thing, right? So we see the object prefix, the object header here, and then this is what's actually stored. But this is binary, this is not ascii. So it's not actually ASCII that's stored in the file tree Object storage. Here we go. Tree object stored in the git objects directory. That's fine. Looks like this after zlib decompression Tree size zero.
01:52:03.053 - 01:52:19.703, Speaker A: Okay, great. Mode space name null byte and then a 20 byte SHA. I see. And the 20 byte SHA is stored as an actual like is not stored hex encoded. Great. Yeah, exactly. Not hexadecimal.
01:52:19.703 - 01:54:50.115, Speaker A: Okay, amazing. So in that case I think this shouldn't be too bad. I think what we actually want here now is if we go back to main here, we'll add a objects and then we'll go to a cat file and we'll pull out some of this. So trying to figure out what we actually want to pull out. So we want something like read object and it'll take a hash and it'll return an anyhow result of something and in fact it will return a tuple of kind and kind and an impul read I think, or buff read maybe, I think is actually what we want. So when we get down here, yeah, let's have it also return the size actually, which means we will probably want a struct here and we'll say this is an R so it returns a kind, it returns expected size which is 64 and returns a reader which has the remaining bytes of type R. And what this will actually return here is an object and I'm using impl here because I don't necessarily want to commit to exactly the order of operations in here and which wrapper types we use, for example, and so now I think we can then return here.
01:54:50.115 - 01:56:58.165, Speaker A: Okay. Of object where the reader is Z, the kind we have, the size we have expected size is this and this no longer needs to be mute. This is pubcrate. This is pubcrate and this is pubcreate and now in cat file we can use create objects we only really need read object here and I guess actually let's do a. Let's have that be an impul on object actually M. It's going to be a little bit weird as an implon object actually I guess I can do this right? Because otherwise the R on the outside doesn't actually matter here. So we'll do this and that way this can be object and we'll also take in kind and then we can do here now that object is object read of the object hash context parse out object file and we can go down here and we can match on the object kind and if it's anything I guess here we could now have cat file understand how to print trees but we'll for anything else we'll do a.
01:56:58.165 - 01:58:23.145, Speaker A: We'll do an anyhow and any are bail don't yet know how to print to print trees print these kind and then we'll do. We'll add a couple of things to this. So this can derive debug it can derive partial E can eek and we can also just do impl display for kind because why not we'll bring in STD here we'll implement this and this is just a match on self. There are crates that give you this but it's not. It's not too bad to just do yourself here like so now you can print an object kind here and we're going to go ahead and let this be pubcreate all the fields. And so now this is going to be object reader. This is going to be object expected size like so.
01:58:23.145 - 01:59:00.595, Speaker A: And that means I need the object to be mutable because I need to consume the reader. Nice. That makes this a whole lot nicer. And this says unreachable pattern because we don't have a tree yet a tree. Now tree is never constructed. That's totally fine. This is tree how to parse how to process.
01:59:00.595 - 02:00:03.005, Speaker A: We might as well add commit tier 2 actually while we're at it because we know it's going to. We know it's going to come right so commit is also going to presumably have at least the same structure for the header and the compression. So this is more of a what even is a great. So now we have a sort of generic object reader. The pretty printer in cat file just knows about blobs and the thing in lstree is a to do for now just to see that this still works. Yep. So we'll do a Commitment pull out object store reading.
02:00:03.005 - 02:00:38.529, Speaker A: Okay, do we need this to be generic or would it be simpler? Just box the reader? Yeah. So up here in objects, instead of this storing an R, we could just have a box din reader here. Didn't read. I don't really want to do that because. Well, it's fine for this to be generic and only ever be instantiated with one type. And that way you don't get the indirection via box, so it's more efficient. But you also get the code to be able to take like you get monomorphization.
02:00:38.529 - 02:01:00.855, Speaker A: Right. And it doesn't really feel like this is particularly painful. Right. Sometimes generics get really painful and boxing it just makes the pain go away. There's not really any pain here, at least the way I see it at the moment. The other nice thing here about using the monomorphization is we can we get the stuff from buff read, which is going to be pretty nice. And you also.
02:01:00.855 - 02:01:32.399, Speaker A: Well, I guess you could get the buff read stuff through dynamic dispatch as well. I think that trait is object safe. But I don't think there's really any win here from switching this to dynamic dispatch, at least at the moment. We could always switch it later. Okay, so now let's go and see if we can do lstree. So lstree, huh? What does it. What do you give it? You give it a tree sha.
02:01:32.399 - 02:02:08.653, Speaker A: Ah, so in main, this also needs to take a bum, bum, bum, a tree hash. And similarly then, you know, this needs a tree hash. This needs a tree hash. Lstree needs a tree hash. This needs a tree hash. This is now a tree. The owner.
02:02:08.653 - 02:02:34.841, Speaker A: Only thing we're going to be willing to grab in here is a kind tree. How to LS a different kind. And then you know that this bit in here, it is tbd. I'd also be tempted to call that type read object so you can have a write object later. Yeah, it's not a bad idea. It is. The.
02:02:34.841 - 02:03:14.963, Speaker A: The object that we have here is very much a. Is more like an object ref. Really? Yeah. The cool thing actually here with this being generic in this way is you could also have the reader here be a vector so you can have an object entirely in memory, which would actually also work for write. In fact, this doesn't even need to be a reader. This could be a file that you write into. It's a little weird, but it could be.
02:03:14.963 - 02:03:35.327, Speaker A: I'm going to leave it as object for now. We'll see how we adjust it over time. Okay. So let's now go back to this. This bit here. So the representation is this bit, which is the header which we already read out. The actual file doesn't contain new lines.
02:03:35.327 - 02:04:02.057, Speaker A: Okay, good to know. So these are going to be. All right. All right. And how's the mode encoded? Is the mode encoded in decimal? Okay, great. So here's what we have to do. We have to.
02:04:02.057 - 02:04:47.105, Speaker A: This sort of alternates right between Mode name and 20 by Chas. And I think the easiest way to split this is probably to read until a null. Yeah, I think this is actually just a. This is a pretty simple loop. So we do a loop where the first thing we do is mode and name. And we can have a buffer here, which is the thing we're going to need read into. So mode and name is going to be object dot reader.
02:04:47.105 - 02:05:34.985, Speaker A: And we want to read until. We want to read until we hit a zero. Really? And in fact. Yeah, give me buff Ready? So this is going to read into the buff. And in fact we're going to buff clear at the start of each of these loops. We're going to read until we get a zero, and this is going to be N. If N is equal to zero, then we break because that means we've hit the end of file.
02:05:34.985 - 02:06:15.499, Speaker A: What? Provide the argument context. Oh, mute. What is oh, Here, read next tree object entry. So here the. We know that what's now in buff is going to be the mode on the line. And so what we'll do is, in fact, we could have two different buffers here. We could have one which is going to be mode and line.
02:06:15.499 - 02:06:44.487, Speaker A: And we can have one which is SHA1 hash. So this first thing is going to be dot read until and does read until. Allow me to write into a string. There is a version of this that does. But it's not going to be nice, is it? Because it's a C string instead. All right, fine, we won't do that. Take that back.
02:06:44.487 - 02:07:41.579, Speaker A: So we're going to read until this. Then we're going to say mode and line is seaster new with what was the name of it? From bytes with null. From bytes with null of buff. And then we can do here, invalid tree entry. And here's actually an interesting question, right? So one thing that's interesting about C strings is that they're not guaranteed to be valid UTF8. So you can imagine running this command on Windows, for example, where file names are not encoded as UTF8. Or in fact on a Linux system where it's configured in the same way.
02:07:41.579 - 02:08:25.415, Speaker A: And so the byte string that we get out of here is not necessarily compatible with a string or a STR reference. It truly is a C string, whereas it's a sequence of bytes that are. That don't contain a null. And so the. The question here becomes how do we want to print these? I think what we're going to do here is just print them out RAW maybe. So we do know that mode and this should be mode and name. Mode and name is going to be mode and name dot.
02:08:25.415 - 02:09:01.065, Speaker A: Or isn't there a. I thought two bytes and then I want to. I want to split once. Why is there not a split once? I think the mode lines are actually guaranteed to all be the same length. That's an interesting question. Actually. Mode, mode, mode.
02:09:01.065 - 02:09:30.385, Speaker A: Like, I think they are always six characters. Realistically, they really should be just. We should just look by space, I suppose. So there is split first. No, I'm fairly sure there's a rust slice. That's not what I wanted it to do at all. Give me the splits.
02:09:30.385 - 02:10:11.885, Speaker A: Do I really need to do a find and then a split? Come on. Well, split does what I want. And I guess I could do a split end, but I want to split once. Yeah, split ones. Oh, it's nightly only. Fine, fine. We'll do a Split n for now 2.
02:10:11.885 - 02:11:00.625, Speaker A: And this is going to be B is equal to space, which I think technically is like is ASCII white space. But I think it's specifically we want it to be a space. Here, let me go ahead and do this and do to do replace with split once. So bits is going to be this. Let mode is bits next. Expect split always yields once. Let name is bits next dot.
02:11:00.625 - 02:11:26.255, Speaker A: Okay. Or else. Anyhow. Anyhow, this is like tree entry has no file name. Great. And this should be this one. This can be this one.
02:11:26.255 - 02:12:29.275, Speaker A: Okay, so we have the mode and the name, and the next thing now is the hash. Now the awkward part is that if we read more into the buffer, it invalidates our borrow of the buffer, which is where mode and name here live. In theory, we could sort of read into the tail end of the buffer, but we're not guaranteed that that won't reallocate and thus invalidate the references. So I think what we'll do do here. I guess we could just print out the name before we have the hash. I suppose that's okay. Well, what's the expected output format here? It's like we're supposed to print mode space.
02:12:29.275 - 02:12:55.445, Speaker A: Oh, I guess for now it's name only. So let's. Let's do the name only. So that means this will just. We'll. We'll do stood out dot, write all name, write tree entry name. And notice here we don't actually require UTF8, right? We just write the bytes directly out to standard out.
02:12:55.445 - 02:13:45.475, Speaker A: And if they happen to not contain UTF 8, that's up to the terminal to deal with. And then we'll also do a right line to standard out of nothing, write new line. A little sad, we can't combine these, but. And then we just don't do anything about the mode because we would only print that if we did the. If we didn't have name only. And then this can go away, right? We're not going to do that anymore. And then now we're going to buff clear and then we're going to.
02:13:45.475 - 02:14:13.923, Speaker A: Actually, we don't need to do that. We can do the following. We can just read them all into the buffer first. That's what we. That's what I want to do. So here we do a read until. If we hit end of file, then that's fine, we break and then we do.
02:14:13.923 - 02:15:05.617, Speaker A: N is object.reader.read. why isn't. Isn't there a read exact? Because what I really want to do here, right, is I want to take the buffer and I want to. I want to take the object reader and I want to read another exact. And I want to read sort of from N to N plus 20, right? There is a way to do this. I'm just getting the compiler to help me here for a sec. I didn't.
02:15:05.617 - 02:16:09.595, Speaker A: That's why. Okay, so read read exact. And in fact, I guess I can actually just use a different buff here. So I'll do hash buff is a 0:20 and I want to read into hash buff read tree entry hash tree entry object hash. And that is all that's stored in there, right? Yeah. Okay, great. And here too, if N is less than it is 20 bytes, right? Or is it 40? 20 by CHA is less than/buff.len
02:16:09.595 - 02:16:57.315, Speaker A: then break expected because this is unit. Ah, the read exact will error anyway because if the number of bytes available is not enough to fill hash buff so that is fine. And so now we actually do have access to this at all times, so we're good. Okay, so this writes the new line and then we loop. Are we allowed to print a trailing new line here in the output of LS tree alphabetically sorted just because that's how it's already stored anyway. Are there any notes? Yeah. Okay.
02:16:57.315 - 02:17:28.785, Speaker A: I think that's all right. We have the hash here. We just choose not to print it. In fact, we could say that the hash is hex encode of hash buff. So down here we could say, no, I do need that to be here. And then we could say if. So now we don't need to enforce name only.
02:17:28.785 - 02:18:09.175, Speaker A: So if name only, then this one's easy. We just do this else and we can have the new line printing at the end anyway. Else we encode, we decode the hash and we print out. So for the long output of this, it's supposed to be mode space, the kind which we don't know yet. And that's presumably why this one is semi optional. Right. So we're going to write all of the mode and then we're going to write all of the name.
02:18:09.175 - 02:18:51.807, Speaker A: And then I guess actually in the middle here we're going to write space. In fact, we could just write out buff here, right? Because that's already how buff is structured. So we can just do buff here instead. Tree entry to STD out. But the interesting next bit is then we want. Oh, no, we can't do that because we actually want to write the mode and then the hash and then the. And then the file name.
02:18:51.807 - 02:19:11.914, Speaker A: So we don't actually want to sprite buff, we want to keep what this was. So we're going to write the mode, then we're going to write the hash. So we're going to write space, tree or blob. We don't know yet. Right. So let kind is. Let's just say that that's tree for now.
02:19:11.914 - 02:20:03.505, Speaker A: So the kind is going to go there and then a space and then the hash and then I guess this is probably some, like, spacing to make them all be aligned. But let's do a single space for now and then it'll be the actual name. So this is right. Tree entry, hash, just it out like so. All right, let's do a cargo run of. Let's do a get LS tree of. Do we have a tree here? This is a tree, right? Yeah, this is a tree.
02:20:03.505 - 02:20:42.367, Speaker A: Okay, a moment of truth, I suppose. Cargo Run LS3. That looks right to me. Right. And if I do name only prints only the names, the hash isn't printed raw, it's stored RAW in the file we do need. Yeah. So there are two bits we need to fix here.
02:20:42.367 - 02:21:24.368, Speaker A: One of them is aligning the mode. So that should be zero padded to six characters. Luckily, that's kind of easy. So we actually know that the mode is UTF8. So here we can do let. Okay, mode is mode to str from UTF8. In fact, isn't there a mode ASCII.
02:21:24.368 - 02:21:57.907, Speaker A: That's fine. STD stir from UTF8 of mode. And we can error here too. Actually, we don't need to do that. We can say here that the mode is always valid UTF8. And now we can do this. Mode colon zero six, colon left.
02:21:57.907 - 02:22:54.225, Speaker A: No, I think it's just colon is fine. Triandry meta. Am I just being silly here? There we go. Just needed to get the characters in the right order. So now you see this entry here is right aligned with zeros padded on the left, which is indeed what we wanted. And the second one is that they're all listed as trees, which is obviously wrong. The way for us to fix that part is we will need to read out each object to figure out what type it is.
02:22:54.225 - 02:23:42.953, Speaker A: And so the way to do that is going to be very slightly painful, but it's going to be object is object read of the hash, which conveniently we have right here. And so this is read object for tree entry. And here we can be a little helpful. So we can give the object hash hash. And now this is the object kind. And notice that we don't do the rest of the reader, so we don't actually stream in the entire file contents. We just read the header and now these are all blobs and this one is a tree.
02:23:42.953 - 02:24:08.375, Speaker A: And so in fact we should be able to now sort of recurse right by calling lstree on this. And now it works further down. Amazing. It does the right thing. Okay, makes me happy. We now have LS3 implement LS3 git push. Let's see what it thinks.
02:24:08.375 - 02:24:33.065, Speaker A: Alt has passed back to the browser. Boom. View. Next stage, write a tree object. Ah, so this is the first time we're going to. Well, I guess technically we created a blob object with our write object earlier. So write tree.
02:24:33.065 - 02:25:21.255, Speaker A: We need to implement. Do we actually need to implement the staging area? Yeah, exactly. We won't implement the staging area. We'll just assume all the files in the working directory are staged. Create a file with some contents git add git right tree. The output of git right tree is the 40 character sha hash of the tree object that was written to git objects. We'll have to walk the files in the working directory, create blobs for every file for directories, recurse into them, create tree objects, record their hash and walk all the way up okay, so let's see.
02:25:21.255 - 02:25:44.325, Speaker A: It's one. Okay, so we're at the two and a half hour mark. Wow, time flies when you're having fun. That means I'm gonna go make some tea and then I'm gonna be back in a second and then we'll take tree object. Okay, I'll see you all shortly. I have returned. I have tea now.
02:25:44.325 - 02:26:21.255, Speaker A: It's the volume really low? I hope not. My audio gear says that it's good. Does Rust not have an organized imports equivalent like GO does? So Rust Analyzer does there are. You see it? It sort of when I automatically. When I use the code action to add an import, it will sort of reorder them and stuff. It doesn't automatically remove unused imports, but if I have something like a hash here, then there is a code action to remove unused imports. There's one for merging imports as well.
02:26:21.255 - 02:27:24.135, Speaker A: So it does have them. I just don't use them very well. Okay, so now we're writing tree objects, huh? So that's back to our hash object thing that we had earlier, right? So we'll want something very similar, except that we want to be able to write things that are not necessarily just a blob. The interesting thing here with trees, and this gets at the thing we originally had with files, right, with blobs, is that you don't know how long the input is until you've assembled all the input. In the file case, we could sort of cheat because we could stat the file. But even this like isn't. Is kind of technically dodgy, right? Because there's technically a race condition here, which is imagine that the file changed between when you stat it and when you actually stream it through the encoder.
02:27:24.135 - 02:27:50.603, Speaker A: If that happens, then what we'll end up doing is write the wrong size in there. So like, you know, we're. We're sort of cheating here. Let's see here. My T alarm went off. So I'll write a. Technically, there's a race here.
02:27:50.603 - 02:28:32.381, Speaker A: If the file changes between stat and write would write in the contents of the file first and then going back to append a header work it might. Although prepending to files is kind of annoying. Like appending is pretty easy. Prepending is usually expensive. The way I would probably do this instead is you. There are cheats you can do, right? So you can. Because this is encoded as an integer, you can always prefix zeros to an integer.
02:28:32.381 - 02:28:56.279, Speaker A: So you just write out a bunch of zeros and then you just replace those bytes after the fact. But that's really not very nice. Another alternative is you write the raw bytes to a file and then you read that file out, which you know is not going to be modified. But even then it's kind of dodgy. Or you write it all to memory and that way you're, you're guaranteed. But it is a little weird. So.
02:28:56.279 - 02:30:15.133, Speaker A: So it's all like, it's a little painful. Regardless, I think what we'll actually do here is I think it just has to be in memory. And the way this is probably going to work in practice is I'm going to change our object thing here and I'm going to give it a. I'm going to give it a right and I think, I know some people are going to hate this and right is going to take a. It's going to take a kind. This is going to take a size and it's going to take a writer. So object here is like kind of a.
02:30:15.133 - 02:31:00.073, Speaker A: Kind of a lie, right? Because we, we don't really have methods on object. We just have constructors to it that we're essentially name spacing. And then what I want, I'm not sure if this is what I want. I don't think it's going to give you back an object actually. I think it's going to just do this, which is kind of stupid. But. But what's interesting is that this can actually be a method on object where we basically say that this R is any IO so it can be a reader or a writer.
02:31:00.073 - 02:31:52.185, Speaker A: You get it back as a reader if you call read. But you can construct one with a writer and then you can call write. It's pretty gross though. But like here, let me show you what I mean. So it'll take a. It'll take a self and it'll return the object id. And the way it'll do that is here.
02:31:52.185 - 02:33:23.445, Speaker A: And so we'll steal the hash writer from over here, right? Put that import this. Then this is going to write now self, kind self, expected size self. And I'm going to rename the reader field. I'm not going to let reader be a writer. Going to import digest. And then this is going to be from self reader. No, the thing inside object needs to be the.
02:33:23.445 - 02:34:17.975, Speaker A: Basically trying to decide whether the thing inside of object is the object we want to write or the writer that we want to write to. Maybe it actually is a reader. Maybe write takes. Maybe. Maybe it actually is pretty reasonable here. So maybe this is a read and then write takes a W that implements write and it writes into that W. And so this does actually write into the writer.
02:34:17.975 - 02:35:03.845, Speaker A: And then this is the self reader. And then we return, okay, of the hash. And this has to be dotting too. And this has to be a mute self, right? And when I say write, I mean write as in R I G H T, not writ. Yeah, we could use, we could use simple right here. That's fine too. And so now this, let's see if we can actually rewrite this one in terms of the other one.
02:35:03.845 - 02:36:13.035, Speaker A: Now we should now be able to do object. Kind is kind blob, expected size is stat.len and reader is file. And now I should be able to dot write that into writer like this. And then the hash should be the outcome of that. Right? This goes away. This goes away.
02:36:13.035 - 02:36:50.595, Speaker A: That's not too bad. And the reason why this is kind of nice is because here the reader is a file, but because vectors implement read. We can also just write as we will for trees. For example, we could take a string and we can provide that as the reader, which will then have that be the thing that gets written in. So I think this will actually turn out pretty nicely. And then it remains true that this is a reader. And so now what is the type it wants us to implement? It wants to implement a write tree.
02:36:50.595 - 02:37:59.135, Speaker A: Okay, so let's go back to main here, right? Tree and write tree takes no arguments or at least for now write tree. And that's going to look a lot like hash object. So let's start from there. But what it will do is. Oh, actually here's another thing we could do. So let me, let me make this comment this out for now. This thing that actually goes through a file might be a handy convenience thing on object, which is we could actually have.
02:37:59.135 - 02:39:35.487, Speaker A: Oh no, we could have from blob from file, which takes a as ref path and returns this. That actually does this bit for us just because we might end up using the same thing in the tree writer. Let File is file SREF this is GroovBox dark hard is the color theme. And so this is actually going to return a buff. Read is fine, doesn't really matter. Now the weird thing here is that. Oh yeah, no.
02:39:35.487 - 02:40:10.005, Speaker A: Okay, so the reader here is always one without the header. The reader here is always a raw reader. So that's fine. This only guarantees that it implements read, which is kind of interesting actually, because we may want to do a buffered reader here to boost the runtime performance. But I think we can ignore that from now. So that means this is always going to Return a kind blob. So now this should be blob from file of file.
02:40:10.005 - 02:40:54.775, Speaker A: And these now go away. This goes away. This now becomes open blob input file. That's pretty nice because now we can have that exact same code be in our right tree. How do you set up line wraps in your new vim config? Is it on save or do you have a hotkey for that? It's on save. I run my rust analyzer is set to do rust format on save. Okay, so if we now go back to right tree.
02:40:54.775 - 02:41:51.621, Speaker A: So our task here is going to be to walk the current directory. And I guess we actually want to walk it. Yeah, I think we need to do this recursively, right? Because anytime you hit a subdirectory, you need to construct a tree object for the subdirectory, return the hash and that's the thing that goes into the parent. So here we're going to need a sort of right tree four which is going to take a path and return an anyhow result of a UA20. And so this is where we're going to write our. Our recursive thing. There are crates that help you write this.
02:41:51.621 - 02:42:37.735, Speaker A: Like there's one called walk Der Walker is really nice for this. There's also one on top of this called ignore. This is what RIP Grip uses, for example, and it knows about things like gitignore files which might actually be really handy for us here. And I believe that you can tell the walk builder to have a. Yeah, a max depth of 1. So we could use this one and that way we get things like git ignores for free. For now, let's do it the straightforward way and we'll see if it comes back to bite us.
02:42:37.735 - 02:44:18.597, Speaker A: So dir is going to be fsread dir of path context read directory and I guess we can do this so that it's. We could even do open directory this and say path dot display and then we'll do while let some entry is dir next. And I think actually this is going to be an option because it is technically possible that you have a directory for example, with no files in them and git will just not represent empty trees. They will just be completely skipped from the thing that you create. So I think we want this to be an option. So while entry is this oops, then let entry is entry dot and then when you walk over things in reader, then every individual entry might also error bad directory entry in what am I doing with context? That goes there? This goes here. Footpath display like so.
02:44:18.597 - 02:45:06.715, Speaker A: And I got to write this correctly. So what we want to do when we create a tree is we want to create that same representation that we've been talking about. Right? So we want a string. In fact, we want a vec. So the tree object is going to be a vec new. And for each entry, the thing we want to write to the tree object is the mode. The name.
02:45:06.715 - 02:45:40.685, Speaker A: A literal null character. Right. Mode space name, literal null character and then the hash. Right. That's ultimately what we want to produce. And because the hash is not a string and not hex encoded, we're actually going to have to do tree object dot push. Well, I guess dot extend hash.
02:45:40.685 - 02:46:27.795, Speaker A: So we need to compute the mode and the name. The mode is going to be match one entry metadata. Context metadata for directory entry meta is this. And I guess we'll also grab the path out because we're definitely going to need the path like so. Isn't there also entry.this file? We only really need the file name. We don't actually need the path.
02:46:27.795 - 02:47:10.841, Speaker A: File name is entry.File name. And then I think we want to match on meta dot permissions. Well, I guess mute mode is if entry dot where's the file type? That's really what I want. Oh, type is equal to this file type for directory entry. I guess technically that might be in the meta. Yeah, it is.
02:47:10.841 - 02:47:52.255, Speaker A: Okay, great. So the mode, the sort of initial state of the Mode is if meta dot is dir, then this is going to be 00. No, just 4. They write it without leading characters. Otherwise it is going to match on meta permissions or what's the. There was some set rules here somewhere. Recap.
02:47:52.255 - 02:48:08.255, Speaker A: Mode. Mode. Mode. That's not helpful. It was in the previous exercise, I think a description. Can I go back? Yeah. Tree object.
02:48:08.255 - 02:48:59.455, Speaker A: Tree objects for files. The valid values are these, these and these. Okay, so this is going to be else@meta.issymlink, then it is this string else if meta.permissions.write. that is a thing that's only available on Unix. No, why does my. Oh, have I somehow changed my search engine? That's not what I want.
02:48:59.455 - 02:49:43.935, Speaker A: I want Rust. That's why my things aren't working anymore. What is it called? Permission Permissions. Yeah, permissions X, which is UNIX only. So. Yeah, because I think there isn't actually a way to check for executable on Windows. Is it like there might not be a flag like that? It would be under FS file ext.
02:49:43.935 - 02:51:18.991, Speaker A: No, file time metadata ext file attributes. Yeah. Okay, so There might be a way to pull it out through this. I think what we'll do here is we'll go the Unix only path for right now, which is to grab this guy, which then gives us metadata permissions, dot mode. And we want to see whether that ended with and what is the bit for. How do you even determine whether it is executable? I suppose we could just take the mode, right? But it seems like git is a little bit more restrictive about which modes it actually allows in there. I think what I'll actually do here is just say so this is octal 111 not equal to 0 has at least one executable bit set.
02:51:18.991 - 02:52:39.895, Speaker A: I think that's right, because the way you go for the way you construct executable bits is you go from I think one in any given octal position is the executable bit because read and write is 644, for example, is read and write for the owner and read only for group and other. So that means the four is the read bit, two is the write bit and one is the executable. So this is if we end it with all the one bits and it's not equal to zero, that means that at least one, at least one of the executable bits are set. And so therefore I think this is what we roughly want. You could imagine that we only do this if like the owner bit is set or something. But I think this is fine, great. Else if some link we don't need the mute.
02:52:39.895 - 02:54:11.375, Speaker A: The file name here is an OS string, right? So we can't necessarily write that out like this either. So we need to do this and then we need to do tree object dot extend file name and then we do tree object dot push of a null byte. And at this point, like why even. Why even use. Right, Right? What? No, an OS string is definitely valid as just bytes, right? I give me OS string where is OS string And OS string better be valid as just a bunch of bytes, really. Oh, as encoded bytes. Okay, fine.
02:54:11.375 - 02:55:30.755, Speaker A: As encoded bytes. Right? And we don't have the hash yet. So the hash is going to be hash is if meta dot is dir then and this is where we get into the recursion, then it is right? Tree for entry dot path. If it's not, then it is the thing we made for write object, which is this from fileentry path. I guess that means I might as well just pull it out here. And this needs to write to. So this is also the question of where that goes.
02:55:30.755 - 02:56:39.355, Speaker A: And this is where this extra business is needed. Do we want to put that somewhere? No, I'll. I'm going to replicate this for now. It's annoying, but it is what it is. So that's going to do this. And that means we actually also need to hex encode the hash in order to use here in the path that we generate. And then if.
02:56:39.355 - 02:57:24.507, Speaker A: And this is actually let some hash is equal to this. And this is where we end up skipping. So this is empty directory. So don't include in parent and then that's going to be the hash. Amazing. I think that does it. Right.
02:57:24.507 - 02:57:51.605, Speaker A: So this, then the main bit we have left is. We need to decide here what. So this, this extends the tree object to include all the lines. And then I guess it's if, if tree object dot is empty, then we return okay. Of none. So that means there were no entries. Otherwise we return and this is where the hash is going to come in.
02:57:51.605 - 02:58:52.565, Speaker A: We do this object, we're going to have to do the same like temporary dance here, aren't we? Yeah, we are. That makes me think that we probably need to make that be more standardized. So this is going to be object to sort of fill in the bits here. First kind is going to be kind of tree expected size is going to be tree object len and reader is just going to be the tree object because vector implements read unsatisfied trait bounds. What doesn't I. Oh, we might need a cursor wrapper, I guess. It does not.
02:58:52.565 - 02:59:17.533, Speaker A: Let's see. Look at read maybe. Maybe it says there. It does not. Okay, so then I think it is cursor. Yep, cursor back. So we'll want here a cursor new cursor.
02:59:17.533 - 02:59:55.485, Speaker A: Now I want a cursor. Now this one. So this is then going to be okay. Of hash. Okay. Of sum of hash file for tree stream file into tree stream tree object into tree object file. Create subdir of git objects Move tree file into git objects.
02:59:55.485 - 03:00:57.729, Speaker A: So clearly this code we now have repeated a bunch of times. So that's not super nice. And that means we'll go over here and we'll probably make our right thing have to be a little bit smarter. We probably still want right as a sort of convenience method for testing, for example. But let's do a write to objects and that's going to have all of this logic here which is going to do this. And now of course again we will fix this at some point. It just doesn't matter at the moment.
03:00:57.729 - 03:01:45.825, Speaker A: So now this can all Become a lot easier because we can say write to objects. Write to objects does not need to take a writer at all. It doesn't need to take mute self. It just takes the object and then this is just right tree object. And then this becomes okay of some of that. And similarly now we can also simplify hash object which now just becomes. Now just becomes.
03:01:45.825 - 03:02:51.125, Speaker A: This one's now a little bit more annoying. But I think actually this one's okay now because we don't even need this anymore. We can just do like this method is this helper is now so small that it can go away. Uh, so this goes away and becomes this. And this becomes write to objects into get objects into blob object and this is I guess really object file. And then this all goes away. And in fact we can still keep this one.
03:02:51.125 - 03:03:31.825, Speaker A: Right? That remains the same. So this is now just where do we write the object and the hex encode we have to do regardless. So we can say here that this is going to be hex and code of hash. So that makes this a little nicer by going here and this makes sense nicer. That's pretty short and sweet, wouldn't you say? And so now we have right to objects there. It still uses this single thing called temporary. But that I think is okay.
03:03:31.825 - 03:04:40.555, Speaker A: This is now just right to objects, outputs the hash, recurses, does all of that stuff. And so in theory now we should be able to do hash is write tree four path new of dot construct root tree object and that's just going to make the hash and then we print the hash. Right? Right. I think, I think that's. Oh, I guess let some hash. And so this would be like anyhow. Anyhow.
03:04:40.555 - 03:05:47.325, Speaker A: No. Anyhow, Bail asked to ask to make tree object for empty tree. And then I suppose we may want to at least hard code that it shouldn't commit the git directory. And so what we'll do up here is if filename is equal to git then continue. Otherwise this will potentially recurse forever, which is not what we want. I guess the question becomes, uh, right. I guess I need to get add dot and then I want to see if I do a get.
03:05:47.325 - 03:06:25.985, Speaker A: What's the comparison they give you here? They say no write a tree object. Right Tree. I could run this in a different directory, but where's the fun in that? If I do write tree, what does it give me? Okay, and if I go run cargo run right Tree. I was about to say yay, it gives the same hash, but it's just the first character. That's the same. So that doesn't really work. Oops, cursor.
03:06:25.985 - 03:07:30.333, Speaker A: Well, it did something. Is there something else that we end up including that they don't? Oh, I wonder if it's the alphabetical ordering, because we walk these in. We walk these in random order, whatever order reader here gives. But I think that should be. Actually, we can find this out, right? So we can do lstree of the object we just constructed. It's a valid tree, at least Git thinks it is. And in fact all the entries.
03:07:30.333 - 03:08:05.787, Speaker A: No, something's not the same. Yeah, it's the ordering. See, in our tree we print out cargo lock, then readme, then codecrafters. They print out cargo lock cargo toml readme, then code crafters. So I think it really truly is just the ordering that's pretty promising. So that means we're actually going to have to sort all of these first. That's not the end of the world.
03:08:05.787 - 03:08:24.053, Speaker A: Although sorting is interesting because. Do they sort. I guess they have to sort by byte value. Right? Because otherwise you get a different ordering on, for example, Windows versus Linux. Or do they actually, like, understand which. Which encoding you're using the file names. I don't think you.
03:08:24.053 - 03:08:59.855, Speaker A: I don't think that's reasonable. I think they probably just do like ascii, sort of the file names. Like what does sorted mean? Right. Do they tell us down here? That's fine, that's fine. Ignore the get directory. Yeah, that's fine. But what does ordered mean? I don't think there's a sorted reader.
03:08:59.855 - 03:09:45.925, Speaker A: Yeah. So I think the way we're going to do this is entries is a. I guess we could do a B tree here, given we're sorting them anyway. It's a B tree map. And then we'll do entry and then we'll do entries.insert entry. File name.
03:09:45.925 - 03:11:27.595, Speaker A: No, I think I want this to be a vector. Yeah, I'm just gonna have this be a vector and then I'm going to do entries dot push entry and then I'm going to do entries dot sort unstable by key entry entry dot file name and then this is just going to be for entry in entries still not the same. So that's ours and that's theirs. They are now in the same order and the hashes are all. The hash for the nested directory is not the same. The hash for source for us is whatever this is and the hash for them is whatever this is. They order.
03:11:27.595 - 03:12:07.699, Speaker A: The ordering here is different. So they order shorter strings first. No We. We order shorter strings first, they order shorter strings last. Why? Okay, interesting. So they consider commands.rs. right.
03:12:07.699 - 03:12:30.265, Speaker A: Let me double check that I'm not lying here. So get Right. Tree is the one that's 401. 401 is the one that has 446. 446 is the one that has commands RS first. So they order commands.Rs before commands, whereas we order commands before commands RS.
03:12:30.265 - 03:12:55.865, Speaker A: No, they don't have directories first. This is the output from git. And the output from git does not have the tree first, it has a blob first. So they specifically order differently. Here they order with. If two things share. If one thing is strictly longer than the other, the longer thing gets ordered first.
03:12:55.865 - 03:13:29.775, Speaker A: Which is not how string comparison works in Rust. Well, that's interesting. So in that case we're going to have to do. No, it's not files versus directories. This is entirely based on the name. Again, they order the whole line entry. No, they don't order the whole line entry.
03:13:29.775 - 03:14:11.225, Speaker A: Then BD would have come before 99, or rather 99 would have come before this. It. It is just the name. But that means that our sort by up here actually needs to be A and B and I think. So there. There are two ways we could do this. Oh, it's probably because they sort including the terminating null byte.
03:14:11.225 - 03:14:32.081, Speaker A: Yeah, it's the same thing. Someone's getting out in chat. So if you sort with the terminating null byte, then null comes before other all other characters and so the null would come first, which is what they do. No, that's the thing. Like they don't sort that way. We sort that way. Right.
03:14:32.081 - 03:15:03.377, Speaker A: This first one is ours. And this one has a sort of null at the end here. Right. And that one comes before the one that doesn't have a null there, which to me seems reasonable. But in the git one it's the other way around. So I think it really is. We may actually need to.
03:15:03.377 - 03:15:43.615, Speaker A: It may even need to be the stupid. So if AFN dot. Oh, really? This is an OS string, right? To as encoded bytes as encoded bytes. In fact, that's an interesting question. So if I go to OSS string, what is their implementation of ordering? I would sort of assume that their implementation of ordering is just by the bytes. Yeah, it is. Okay, great.
03:15:43.615 - 03:16:44.095, Speaker A: Yeah, you can think of null as having a really high weight for them as opposed to a low weight. And then I think what we want to do is if AFN dot starts with bfn, then return The If AFN starts with bfn, that means AFN is longer. So then we want to return afn, right? If. If BFN starts with afn, then we want to run return bfn. Otherwise we want to return A compare B. And this needs to be ordering. So this means that.
03:16:44.095 - 03:17:25.845, Speaker A: This means A comes before. This means B comes before. I may have confused myself here. Oh, finally returns an oss. Can I have it? Just give me the thing without. Without allocating. Because that's what I want.
03:17:25.845 - 03:17:47.803, Speaker A: Really. Entry. Where's my dear? Entry. Wow. They all need to allocate. All right, that's fine. Then I guess that means this has to be this.
03:17:47.803 - 03:18:30.845, Speaker A: And then let afn is afn.as encoded bytes. Bfn is this. I guess because they're owned, we can pull this trick instead. So because they are owned, we can do the following into encoded bytes. This is at least assuming that's the method. Okay, great.
03:18:30.845 - 03:19:28.895, Speaker A: So then I can do afn.push and bfn.push and then I can return compare AFN to BFN. Get considers shorter strings to come after longer strings, which effectively means the terminating character is valued high, not low. Git add yet. Right? Tree. That's the same hash.
03:19:28.895 - 03:20:09.185, Speaker A: Yeah, nice push. Will probably need to reallocate. You think so here? Do you think the. Do you think this actually allocates like a file name OS string? It's really annoying that they don't expose this method. I guess since we're on Unix. Right. There might actually be a UNIX version of this.
03:20:09.185 - 03:21:25.105, Speaker A: So if we go here, that gives me access to the raw bytes dir entry X. No, that's not helpful. Okay, that's fine. Yeah, you might be right, because the file name here is going to get back the OSS and then I'm going to call OSString, which calls the 2 owned, which calls the 2vec. So what does 2vec in do? Unclear into vac. You're probably right that it won't overalllocate the allocation is sad here. This probably allocates which is sad.
03:21:25.105 - 03:22:08.825, Speaker A: If your directory contains a dot, get sorts normally shortest before what? Really? If your directory contains a dot. Okay, let's do a merck. Make their food.touch food dot. No, not food dot. Make their source commands dot touch that slash. Something.
03:22:08.825 - 03:22:53.535, Speaker A: Git add dot get. Right. Tree get. Lstree this thing. What? What the is this? Ordering it. What is this? What this makes. That makes no sense.
03:22:53.535 - 03:23:13.113, Speaker A: Okay, okay. Get. Go home. You're drunk. It's got to have to do with. I agree with you. I Think it has to do with extensions somehow.
03:23:13.113 - 03:25:01.385, Speaker A: Like it's everything. Maybe it's everything with extensions before anything that doesn't have an extension. But like what about if there are multiple extensions? Like, like what does that get ordered as does.combefore. does come before the letters. So that. That's not necessarily written RS. Nope.
03:25:01.385 - 03:26:19.055, Speaker A: Only applies one level deep. What? What? This. This is just ridiculous. What, what is this ordering? It's not plain files. I. I guess we can test if it's plain files, right? Like if make their SourceSource Foo Foo.bar and then I touch foo bar s and foo s and I guess I'll do a this as well.
03:26:19.055 - 03:27:36.445, Speaker A: And I do get add dot and then get right tree and then get lstree this and foo bar dot and this. I'm just. Now I'm just trying all the things get. I just want to understand foo.bar. maybe you are right. Maybe it is files first. But it's like in a weird way because like if you compare here these two.
03:27:36.445 - 03:28:12.551, Speaker A: So here the non. The one without a dot at the end comes first. But if you compare foo bar dot and foo bar that's the same pattern but they're the one with the dot at the beginning comes first. So I think you're right. I think the type does affect the ordering here. But like what's the rule? Because it's. It's not as though if you have two.
03:28:12.551 - 03:28:44.289, Speaker A: If you have a file and a tree with the same name, then the file comes first because they cannot have the same name. So I think. I think it's like ignoring what comes. I think. Okay, here's what I think it does. I think it removes the extension and then it orders them by name, then type. I think that's what's going on.
03:28:44.289 - 03:29:45.875, Speaker A: I think it removes the extension orders by name with extension removed, then orders by type and I guess then by the extension. I think that's what's going on. But. But how many extensions do they remove? Like two into to. There's a path buff from of this. I believe it compares conflicting directory file entries as equal. But these aren't conflicting.
03:29:45.875 - 03:30:10.961, Speaker A: It comes conflicting directory file entries as equal. Okay, but they're not conflicting here. They're different names. Note that while a directory name compares as equal. Just reading someone who's looked up the git source code, I guess. Let me. Let me pull this up.
03:30:10.961 - 03:31:21.705, Speaker A: So git source code GitHub get. Sure, go ahead and give me something like probably tree, tree tree tree tree tree tree tree tree diff name compare is identical to base name compare except it compares conflicting directory file entries as equal. Note that while a directory name compares as equal to a regular file, they then individually compare differently to a file name that has a dot after the base name. Right, but we don't have conflicting entries. I think I'm going insane. There's got to be something where. Where they do something about this trailing dot.
03:31:21.705 - 03:31:48.385, Speaker A: What do they do for is dur. Oops. Nope, nope. Is der. That's. But that's comparing the mode. And in fact this first thing just straight up compares the names.
03:31:48.385 - 03:32:29.703, Speaker A: So this is only if they are name one. Yeah, and the problem here is the names aren't the same. Right. So we should be taking this first branch and all of this logic shouldn't matter. Ahaha. They take the shorter of the lengths and they compare up to the shorter of the lengths. Okay, this is very cursed.
03:32:29.703 - 03:33:20.175, Speaker A: No. Okay. Oops. So here's what it does. It doesn't look at the extension, but it does look at the mode. So it takes Let common len is min of AFN len and bfn len. So that's step one into encoded bytes.
03:33:20.175 - 03:34:38.305, Speaker A: And then it. Then we do. Then we do match AFN to common len, compare BFN to common lens, and if the ordering is equal, then we continue. Otherwise we return o. Right. If AFN len is equal to bfn.len then we return ordering equal and then name at len name and then this bit.
03:34:38.305 - 03:35:26.285, Speaker A: So this is if len here is the shared length. So this is just checking whether we've hit the end of. Oh, it adds a slash at the end if the thing is a directory for the purposes of comparison. Basename compare as opposed to D if name compare. Okay, yeah, that's fine. We can use this one instead because we're not handling potential conflicts. So that might make this a little easier.
03:35:26.285 - 03:36:04.115, Speaker A: But it still does the same thing. It compares them up to the shortest. Then it looks at what the character should be. And the way it does that is it says C1. I guess that is actually a U8 C1 is AFN dot get at common length. C2 is BFN dot get at common len. That's the equivalent of what they're doing there.
03:36:04.115 - 03:37:06.209, Speaker A: And then it is unwrap or else that's what this thing is here. Except it's not an unwrapper, else it is a. We can do it as an unwrapper else. No, we'll do this as a. If let some C else. If this is like a is der then that's going to be a slash, else it's going to be none. Right? And this is really.
03:37:06.209 - 03:38:02.047, Speaker A: Then if A dot metadata, which means we actually have to extract this in the comparison, which is awful. So I think we're actually going to extract the file name and the metadata when we do this. So we're going to say File name is entry.File name. And we're also going to pull out the metadata, which we can grab down here. And then we're going to push entry and name and meta in here. And so this is then going to be a one, this is going to be B1 as encoded bytes.
03:38:02.047 - 03:38:56.545, Speaker A: As encoded bytes. And then this is going to be a dot 2. So that's the metadata dot is dir copied. Okay. And then C2, it's going to be the same but for B. And then what do they do? Then they do this. Okay, okay.
03:38:56.545 - 03:39:56.335, Speaker A: And so now they do C1 compare. I think this is just a C1 compare C2, right? If C1 is less than C2, return minus 1. If C2 is. If C1 is greater than C2 to return 1, otherwise return 0, which is what C1 compare C2 does. And then now this can be entry, file name and meta because we already extracted them. Okay, right tree cargo run. Right tree still get the same hash.
03:39:56.335 - 03:41:29.175, Speaker A: Wait, we get the same hash? So that means we succeeded, including all the weird test cases we just added. Okay, so we did it, right? Yay. Git has very specific rules for how to compare names. That's fine, as long as the thing we got was correct celebration, I guess. Source foo and also source commands RS git add git source commands with the dot implement right tree push all tests pass. Congrats. Okay, I guess we can get the fireworks.
03:41:29.175 - 03:42:05.175, Speaker A: Weird. Okay, so write a tree object. We actually got there pretty quickly. And then we spent like two or three times as long as doing the write a tree object on directory entry ordering. But hey, we still did it. Okay, git commit tree command the commit. All right, let's go to main and add a commit tree takes a message and a hash.
03:42:05.175 - 03:43:41.477, Speaker A: Okay, so commit tree takes a tree hash, which is a string, and it also takes a message, which is a string. And here, you know, you could implement things like if M isn't passed, then we spawn an editor and everything, but we'll leave that for never. Okay, commands commit tree, commit tree invoke message, entree hash commit tree. All right, so now if we go to this, let's suppose actually read the commit. A commit object contains information like the committer author name and email timestamp the tree sha and the parent commit sha, if any. Okay, Commit tree Ah dash P for parent. I see.
03:43:41.477 - 03:45:07.111, Speaker A: So the idea is that you can create a commit that doesn't have a parent, which would just be the initial commit, or you can commit one that does have a parent. So that means in our main we actually need a tree hash and there's also a parent hash which is actually optional. So that here would be parent hash and let me go ahead and generate this function and we're probably going to need most of this. The interesting thing here is I think we can actually just reuse pretty much all of this, right? So we can just make this be pub crate and then what do we have to do in commit tree? Well, oh no, the tree is already given to us, so we don't even need to reuse this. The expectation is that we're just given a tree hash. Okay. So in that case this is then pretty similar to just the the bit where we actually construct the bit at the end.
03:45:07.111 - 03:46:23.379, Speaker A: So we should be able here to do object kind commit and we don't actually know what the commit is going to look like, but it is probably going to be formattable actually. And this will be then commit dot, len and commit. Right, that hash is this. And then just like down here we'll just print the hash and be done. This is going to be an anyhow result of nothing. And the question just becomes what do we put in the commit? And I think the bit we put in the commit is pretty easy because it's just a. What's a head? It's just this kind of thing.
03:46:23.379 - 03:47:41.685, Speaker A: Right, but is that actually encoding of it? Aha, format. So we have one of the people working on codecrafters in the chat and he was like, well someone in chat pointed out, oh, the ordering cases here that we've talked about, like the name reordering can't possibly be part of the test cases, right. And the code crashes person is like it wasn't so far, but now it's going to be nice. Okay. Ha. The output is okay content. I think it actually just is ASCII encoded.
03:47:41.685 - 03:48:26.281, Speaker A: All right, well if it's just an ASCII string, then this is trivial, right? We can just do tree is the tree hash. Uh, actually I don't want to do this with format because the parent hash is optional. But we're gonna do string new and then we're going to do write because you can write into strings. It's really nice. We're gonna write tree. Write line. Actually tree tree hash.
03:48:26.281 - 03:49:14.075, Speaker A: So that's the tree for the commit. And then if let some parent hash is parent hash, then we will write parent and parent hash and then we'll write author and we'll just hard code this one. We'll set committer as well. And then we have to write. We have to write an empty line, it seems to me at least. Right. It's an empty line in between here.
03:49:14.075 - 03:49:43.935, Speaker A: And then we write line into the commit the message. It's unclear whether there's a new line at the end. 0a. It does look like there's a new line at the end. Okay. Oh, and then it wants me to use. Right.
03:49:43.935 - 03:50:17.315, Speaker A: Ordering can go away. FS can go away. These two can go away. This is just the message, right? Isn't there a. I thought there was a way to use writeline without it returning result for strings and that is by using. Using. Really? I was so sure.
03:50:17.315 - 03:50:51.833, Speaker A: Where's the macro? Yeah. Ah, fine. I thought there. I was so sure there was one where you didn't have to do the unwrap. But okay, these. I guess we can write here all the here. Right.
03:50:51.833 - 03:51:39.197, Speaker A: We'll never trigger as we're writing into a string, but we'll add them anyway so that the compiler is happy that all. Did we really make it that easy for ourselves? Oh, hang on. 40. 40 character sha. Yeah, 40 characters. So 20 bytes, that's fine. So it's the same.
03:51:39.197 - 03:52:16.695, Speaker A: Same kind of hashes, right? If I'm not mistaken, like this is the same length as this is. Yes. Okay, great. I think that's all right. We just construct the string, we make the object and we write that out into the object store. Get, write, commit. Let's do a revparse Head write commitment.
03:52:16.695 - 03:52:46.621, Speaker A: P this something. What lies. Oh, it's called commit tree. Is that what I named it? I did. I just am blind. Commit tree must give exactly one tree. Yes, I do indeed have to do that.
03:52:46.621 - 03:53:13.577, Speaker A: Which is fine because that's going to be git, right? Tree. So that's going to be at the end here. Okay. And now moment of truth yet again. Okay. We produce a different hash. Oh.
03:53:13.577 - 03:53:36.965, Speaker A: I mean we're hard coding a bunch of things in here, like the timestamp of the commit and stuff. But. But that's actually to our benefit here because it means the hashes should be the same. Oh, but. Right, but git will introduce a timestamp here. Interesting. Well, here's something fun we can try though.
03:53:36.965 - 03:54:42.775, Speaker A: Let's do a cat File p of this first. That seems right to me. What if I do a lstree of that commit? Okay, so here's one thing we can try. Remember what I just did is basically create a commitment of the current directory. So if I now do a commit implement commit tree then now. So there's now a commit at the head, right? Imagine that I now, for example, try to. What's the way I want to do this? I'm going to create a branch called foo.
03:54:42.775 - 03:55:23.685, Speaker A: I'm going to check out foo, and then I'm going to log. I'm going to reset foo to original origin master. So this now doesn't have commit tree. And then I'm going to get right tree. And then I'm going to cargo run. Commit tree. Yeah, now get right tree.
03:55:23.685 - 03:56:12.455, Speaker A: I'm now going to get no cargo run commit tree of this tree and no, I need the current commit as well. So cargo, cargo run. This. This tree that I just wrote up here and then this commit that is the head of foo here. Oh, I don't. I don't have commit tree here. Fine, fine, fine, fine, fine.
03:56:12.455 - 03:56:33.709, Speaker A: Get reset set hard. Master. I just want to create like an empty. I guess I can just do this on master. There's no. I just wanted it on foo so that if I happen to have done something completely wrong, I don't mess up my tree too much in such a way that it's annoying to get back to the place where we just fit commit tree. But we can do this just fine.
03:56:33.709 - 03:57:10.663, Speaker A: So write tree revparse head cargo run. I'm going to commit this tree with this parent and now I'm going to try to reset the foo branch to that commit and then do a git log. Aha. So master, was there foo is the commit that we just created called something. And it has the correct parent. It has the correct master. If I do a git diff master to where we are, there's no difference.
03:57:10.663 - 03:57:45.529, Speaker A: If I do a show p of head, then that is an empty commit. Okay, so now let's try to touch or echo hello to world git add hello world. Right tree. But notice that I haven't commit. I haven't committed that tree. This is going to be important. So now the parent is going to be this.
03:57:45.529 - 03:58:07.585, Speaker A: The message is going to be commit world. The tree is going to be this, which is the one with the world file added. So that gives me this. And if I now reset hard. In fact, I could. I could RM world add dot. So now there's.
03:58:07.585 - 03:58:43.145, Speaker A: There's no diff here and there's no world file. And then I can reset hard the foo branch to the commit that I created with commit tree. And if I now look at git log I have 2 commits on foo since master something and commit world. If I do a diff from master onwards and I have a world filed with hello and a show p of head gives me that commit. Okay, so we have. This is definitely a working commit tree. Amazing, that's really cool.
03:58:43.145 - 03:59:28.285, Speaker A: Okay, so now if I go back to master and I push this all test the best. Amazing. Look at us go. Okay. Oh, it's kind of tempting actually to do a. To just like implement git commit as well because we have like now we have all the bits right, you just call, you just call right tree. As I just showed, maybe we do that just like kind of for fun.
03:59:28.285 - 04:01:42.735, Speaker A: So if we go to main and we do commit, maybe we don't even do the parent hash or the triage. Okay, okay. Commit just takes a message. And, and if I go to commit tree, let's extract some of this out so that it's actually just write commit which returns you the hash of the commit and nothing else. Right? And then this now becomes hash is right commit of message tree hash and parent hash create commit and by having this one be pub create and then we do the same thing in right tree we take this guy and do this and now we go back to main and now we say, okay, tree hash is going to be commands right tree, right tree for path new dot right tree. So you can see now maybe why these commands like right tree for example, are called plumbing commands in git because they do one thing really well. And then things like commit is just straining together the plumbing commands.
04:01:42.735 - 04:02:47.593, Speaker A: And so now we get the tree hash, the parent hash is going to be git head. So here we're going to need a little bit of smarts. So we're going to do FS read to string of dot git head read head And I guess technically here we kind of want this to work even if githead doesn't exist. Like if you haven't, if you haven't created any commits yet, for example. But let's just ignore that for right now. Let's assume that there's something in there. Now it is possible for githead to contain a hash.
04:02:47.593 - 04:03:23.335, Speaker A: So if parent #len is equal to 40. No, let's not do that. Let's do if let some get ref is parent hash strip prefix ref colon right. That's what's in there then it's just in git refs and I think it's just that same path. Right. Heads master. So we're just going to cat that.
04:03:23.335 - 04:05:08.275, Speaker A: Then let then parent hash is anyhow ensure parent #LEN is equal to 40 and then we can say unknown type of head ref parent hash. So here resolved is going to be FS read to string of format dot get slash and then just what the ref is for. Right. So, so if it's, if it is for example refsheads master we should be able to just do dot git slash and then that path and cat that file, which is what I did here to get the hash. And so then this becomes here head reference target And I guess what we can do here with context because that seems like it might be relevant. I guess actually that's going to be git ref and then we should be able to just return resolved here I believe. Right.
04:05:08.275 - 04:06:00.463, Speaker A: And we can do that before we start to do the whole constructing of the tree. So now we have the tree hash and now we should be able to do the commit hash. Should now be commands, commit tree, write commit of the message which we've given the tree hash and some of the parent hash that we just computed. Create commits and write Tree4. Remember, can return can return none. So we're going to do this bail. Actually this isn't even a bail, it's just a return.
04:06:00.463 - 04:07:01.335, Speaker A: Okay, right. Which is really not committing empty tree. Ah, this is going to be a hex decode. Bad tree hash, bad tree hash. And I guess we'll give the context here as well of bad tree hash. Oh, I'm silly. It's a hex encode of the tree hash.
04:07:01.335 - 04:07:53.695, Speaker A: So that gives us the commit hash. And then if we want to be really bold here now is the next thing, right, which is which thing do we update? And that's going to be, that's actually going to be the thing that head points to. It's the thing we're going to update. Right. So, so we could print the commit hash here but then that wouldn't move us forward. What we really want to do is make head point at the newest thing, at the new commit that we made. And so.
04:07:53.695 - 04:08:44.571, Speaker A: And that you don't actually want to update head itself because head might be a reference and if head isn't a ref, then it's a little unclear with what to update because it's pointing at a specific commit. So trying to commit over that like you can't change that commit. So I think what we do here is actually. I think we're going to require that it is this. So we're actually going to do here bail refusing to commit onto detached head, which is what git calls them. So this is if you. If you check out a particular commit and not just a branch or some named head because you can't update a commit head is a symbolic ref in the original git.
04:08:44.571 - 04:09:31.725, Speaker A: It was a symlink. Oh, interesting. So that means that here we're going to do head ref. That's what we're going to call that one. And then we're actually going to do else this so that we actually get that out. And then this now can be head ref. This no longer needs to be if let.
04:09:31.725 - 04:10:24.037, Speaker A: This can be this. This can now be parent hash that. Because crucially now we can do right to string down here. And this is where it's going to be really interesting to see whether we got this right or not, because this might just completely corrupt my entire git. It's recoverable though. So we want to write the commit hash into that file. Any reason why you use with context instead of context format? Yeah.
04:10:24.037 - 04:10:58.065, Speaker A: So if you do this, then that means that even if the. Even if there's no error, you're still going to allocate a string and then immediately throw it away. If you do the with context, then this string will only be allocated if there is actually an error. That's why I do that differently. Okay, I forget whether git commit prints. Where's the last place where I ran git commit? I ran it up here somewhere right before I did the last push. Aha.
04:10:58.065 - 04:11:39.605, Speaker A: It just prints this. I'm not going to try to print that summary. That seems complicated. So let's just print line the hash, shall we? Head is now at maybe commit hash maybe. Ah, good catch. The commit hash needs to be hex encoded. So in theory this will let me commit what's here.
04:11:39.605 - 04:13:58.685, Speaker A: How do I want to do this? I'm going to commit this first implement commit and then I'm going to do something like cargo run commit m empty commit no such file or directory error read head reference target refs head master. Why? Ah, it's because there is a new line head ref is head ref trim and I guess write commit. Here can just be a str and this can be a str and this can be a str. So this can be message. This can be this. All right, let's try that again. Okay, get show empty commit Log empty commit Show-P empty commit we have a commit we made with our commit works.
04:13:58.685 - 04:17:33.335, Speaker A: What if I like touch what if I echo hello to world and then I get add world because we don't have git add and then our cargo run added world so it claims 079 git log that is 079 added world git show added world and there's now a world and if I reset hard to head then there's no more world git commit Nice. Just missing author and timestamp sure, why not commit tree so this one's annoying because you need to parse git config and such but I think email name and timestamp here's what we'll do if let some name some email is equal to env and we'll grab that from std env var what am I doing? Var OS of email I guess I'll do it this way. It's not perfect, but at least it'll do something kind of interesting. Right then name.into string context git doesn't technically require in fact, maybe the thing to do here is a map of we could map name through like into string if we really wanted to. So we would map I don't really want to write that code Then name and email and then the right line here becomes name email and I think you know, the real git allows you to do things like pass in what name and email to use for author but the committer will always be set to your to your credentials. Oh, it returns the OS string.
04:17:33.335 - 04:18:07.175, Speaker A: That's fine. Anyhow. Anyhow. Oops. Email email email. And we can just ignore this and ignore this and this needs a bracket. I guess this is really map error.
04:18:07.175 - 04:19:16.625, Speaker A: Okay. And then the time is. This is just a UNIX time I think at least that's certainly what it looks like system time. So we're going to do time is time system time now minus time system time UNIX EPIC and this is probably the epic. Yeah. So this is going to be UTC C right. So we'll do here what? Oh, isn't there there is a trick to do in this.
04:19:16.625 - 04:20:43.857, Speaker A: Oh, I can just do dot duration since nope, I need to do that here. That's what I want. So that's time. But actually that has to be time as sex I think and duration since returns a result because current system time is before UNIX epoch. I think that's going to be okay. I don't think we're going to run into that problem. And then I guess here it's a good question what does this return? Is that like will this actually give me utc? If I go here? I'm going to guess that there's.
04:20:43.857 - 04:20:59.885, Speaker A: This is basically just. Yeah, it's duration since. But it doesn't actually tell me what the current time zone is. That's fine. Realistically, we would use something fancier here that actually handled time zones. For now I'm going to have. I'm going to pretend that this should be UTC.
04:20:59.885 - 04:21:44.715, Speaker A: Ooh, is it encoded as UTC or +000 or Z? Let's find out. Oh, this might end up being just like a. It's gonna be interesting. So if I now do cargo run added World Show P 1-1-1970 okay, I'm gonna go with that didn't work. Or at least that didn't do the right thing. So let's do plus plus zero. It just does plus zero.
04:21:44.715 - 04:22:27.355, Speaker A: All right. Git add cargo run git show 1401 plus zero. That's correct because I'm at plus one. Okay, great. So now we have something that gives uses my name and email. So now if I tried to do reset head and then did env name is to tie this all together. Inspector Gadget and email is inspector@gadget.biz.
04:22:27.355 - 04:23:38.765, Speaker A: then it is committed by Inspector Gadget. Nice. And then what I really want is like I see. So this is now ended up a little bit weird. So we'll go back to. So now we're at a good place and then we can make this be Git add Git add and then we can run I still want with the Inspector Gadget added support for Setting name email actual time Set name email actual time and it makes me happy that the commit that lets us set that is written by Inspector Gadget. Amazing.
04:23:38.765 - 04:24:25.335, Speaker A: Git push. I don't. I mean this will fail at the end because we haven't implemented git clone. Okay, so clone a repository. Given that this is supposed to be the hardest exercise and way harder than the things we've done so far, I'm going to not attempt it four and a half hours into this stream. So this might be a thing that we do in a follow up or it's a good exercise for you to do as a sort of follow up to this. What I will do actually is let me see if I can't new repository.
04:24:25.335 - 04:25:10.241, Speaker A: No, I'll push this out so that it's available public. That's fine. Create repository copy Git Remote add GitHub Git push GitHub master now it'll be here. Amazing. I'll put that in chat as well. I'll put it in the video description as well so it's easy to find. Okay.
04:25:10.241 - 04:25:38.055, Speaker A: I think that's actually then where we're going to end it. I don't want to start Git Add because setting up the staging area as its own different thing because the staging area is like an in memory representation of your file system that is different from what's on the actual file system that you then need to construct your trees from. And so doing that is its own whole ordeal. Fun ordeal. Just not one that I want to do right now. Look, it got its own little indicator. That's funny.
04:25:38.055 - 04:26:10.255, Speaker A: What do I want to leave this with? So I think trying to implement Git Add would be super interesting. I don't think it's something I'm going to do right now, but it's a fun follow up exercise. Same thing with actually going through and implementing Git Clone. We might do it in another video or if I don't end up doing that then this is a good chance for you to do it yourselves. As I mentioned. So there is here I'll send the link. And again this is in the video description.
04:26:10.255 - 04:26:53.003, Speaker A: There's a referral link where if you sign up through the link you get access to all of the challenges for like seven days. And so you could in theory like clone my repo and then start just clone a repository and see if you can do it in a week or otherwise. You know you could also actually pay for this. That would certainly make me happy through the referral. But like whatever, whatever floats your boat. And then as I also mentioned there is a code crafters here and I'll put the link in chat again. And it's also in the video description which has all of the exercises here in the in like the RAW form.
04:26:53.003 - 04:27:27.395, Speaker A: So it doesn't have all the infrastructure for running the tests and getting the frame of the fireworks and stuff. But it does have at least the raw bits of the exercise so you can go through it yourself if you can't pay for it. And it goes beyond the 7 days there commits to it. Recently 1 hour ago I think. I think someone is watching the stream and is making changes as we go. I want to see what these are. Now this is the best kind of meta stream.
04:27:27.395 - 04:28:02.521, Speaker A: Aha. This is the note that we ran into of the SHA having to be over the uncompressed version and the shy is over what includes the header. Nice. That's funny. What else do we have? Ignore the git directory. Yeah, that one's important. When Creating the entries.
04:28:02.521 - 04:28:23.215, Speaker A: Nice. It's the stream talking to itself from the past. I know, right? Amazing. How can I clone the repo if I haven't implemented? Clone. It's true. It's an infinitely deep problem. I guess you might have to resort to that old git command, and then one day you can do it yourself.
04:28:23.215 - 04:28:49.441, Speaker A: Okay, I think it's time for me to go eat some food. Thank you all for watching. I hope that was interesting. If you found it super cool, then maybe we'll do more of these. If you were like, okay, I'm done with challenges now, then I'll find something else to do. I have plenty of stream ideas. As I mentioned, you can join the Discord to get announcements for new streams and stuff a bit ahead of time.
04:28:49.441 - 04:29:25.065, Speaker A: If you're not on Twitter or Mastodon or LinkedIn, which are the other places I post this. So it's Discord John who? And that gets you to the Discord Invite link. And there's an announcement channel there where new videos are announced. And if you sponsor me on Patreon or YouTube or ideally GitHub sponsors, because they take the lowest fees, you also get access to a couple other channels there, like potentially being able to suggest ideas for new streams or even just have a general sort of community chat. Okay, thank you and I'll see you later.
