00:00:01.360 - 00:00:16.361, Speaker A: Hi folks. Welcome to another J stream I'm going to. Maybe I should just call them all J streams after all. I am doing this for J, not for myself. Of course. This is a Q and A stream. It's very informal.
00:00:16.361 - 00:01:10.809, Speaker A: I've done a bunch of these before. The basic setup for these is I have this website where people can ask questions, vote on questions ahead of the stream, but also during the stream. And this will essentially just be me going through this list of questions, starting at the top and going down and what we'll see how far we get for, you know, in let's say three hours or something, or whenever I get tired of answering questions and then we'll stop and then we'll call it a day. The questions are probably mainly going to be rust oriented, but they don't have to be. I'm happy to answer things about, you know, engineering in general. You know, things like board games, cats, you know, how I live my life, equipment that I use, software, uh, whatever. It might be like anything that you have a question about that you think I might give an interesting answer or an answer that is interesting to you about where you just want to hear my opinion.
00:01:10.809 - 00:01:42.043, Speaker A: Ask them here. Chat is obviously going to be adding a bunch of questions here, but if you're watching this after the fact, you can't then ask me a question that I would respond to. Um, so you'll have to wait for the next time around and make sure to submit your question in advance. A little bit of housekeeping just before we start. Um, the main thing being I have a Discord, which I've had for a little while now, but not everyone knows that it's there. The Discord is mainly there for announcements. So if you join the Discord, which is just this, oh, Discord.
00:01:42.043 - 00:02:22.525, Speaker A: John who EU will take you to the Discord invite link. If you go to that, you'll get an invite to the Discord. It only really has these announcement channels and a little bit of information about sponsorship like GitHub sponsors and Patreon and the like that I have, and a little bit about the various kinds of content that I make. And the announcements here is just if you want to subscribe to me on a platform that's like not Twitter, for example, then this might be one that works for you. I still post all the other platforms as well, but this is a different alternative that some people like more. There's no actual chat channel here that you get access to by just joining the servers. There should be fairly low noise.
00:02:22.525 - 00:02:47.945, Speaker A: If you sponsor me on GitHub sponsors, something like it. Then you get access to more of the channels, one of them being a community chatter channel. But hopefully this discord is useful for just like hearing when I'm about to do a stream, seeing links to things like. You can submit questions here. If you happen to be watching this after the fact and are sad that you didn't get to submit a question. That's all that I really have for housekeeping. So I think we're just going to dive straight in.
00:02:47.945 - 00:03:28.285, Speaker A: And over the course of this video, you know, after the fact, you won't be able to look at the question site. But what I will do is take all of the questions that I answered throughout the video and put little timestamp links in the video description that should also show up as YouTube chapter notes. So you should be able to skip back and forth between the questions that you find interesting. All right, let's then go right ahead. I'll switch this over for face view so you get a full view of me answering these questions. You also get to see Ferris and of course Jay, the principal sponsor of these streams. Let's go down the list, starting at the top question.
00:03:28.285 - 00:04:21.715, Speaker A: Have you ever considered decrusting Rust Analyzer? So the Decrusting series was intended to be a way to give people a better understanding of the libraries that they interacted with, like things that they interact with from Rust code, so that they can write better code by utilizing those libraries. So SERDE being the original example, the reason I wrote that is because I think basically everyone ends up using SERDE somewhere. And yet SERDE is often seen as a bit of a sort of black box. People don't necessarily understand how it fits together, what the different traits are. They just sort of chuck things on there in the hope that they do the right thing. And if you have to do things like implement a custom serializer or deserializer or something, I think people tend to fall off the wagon and just be just sort of abandon all hope. So the idea behind the.
00:04:21.715 - 00:05:01.771, Speaker A: Yeah, you shouldn't be seeing the questions. You should just be seeing my face. If you're not seeing my face, that's because I pressed the wrong button. But that should be fixed now. The hope was thus that these would provide you with essentially a way to kind of level up your Rust knowledge so that you can make better use of these libraries. Um, decrusting Rust Analyzer would be a little bit weird because there, there are two interpretations of that. One is decreasing the code of Rust Analyzer, which I don't think is all that useful in the decrusting series because you very rarely interact with Rust Analyzers code.
00:05:01.771 - 00:05:38.165, Speaker A: And similarly, you know, when we did the. The decrusting of Tokyo, for example, the goal wasn't for you to be able to contribute to Tokyo, right? Like to. To really dig into the Tokyo code base and write code in there yourself. It was, how do you learn to interact with that code base and utilize Tokio in the best way that you can? This wouldn't really apply to the Rust Analyzer code because you never interact with the Rust Analyzer code base. And if you're contributing to it, that's not really what the decrusted series is for. The other interpretation here would be to say, well, decrust Rust Analyzer the tool. Like, teach me how to use the tool better.
00:05:38.165 - 00:06:30.137, Speaker A: And that I could probably do. It's a little bit different from what the decrusting series usually are, because in some sense this is more like teaching you techniques in your editor. And so that's obviously a little. A little weird, but it is something that we could do. I don't know that there's a huge value in me sort of picking up a Rust project and then walking through all of the ways in which I would use Rust Analyzer to make changes. Like, I could show you the various code actions, but like, I don't actually think that's that interesting or that deep. There is a potential here for a sort of new kind of stream, right? Which is, let's take a complicated code base and read through it and try to understand what it does and why.
00:06:30.137 - 00:06:55.695, Speaker A: Which would be more along the lines of, you know, let's say I wanted to contribute to this kind of tool or contribute to this code base, you know, let's call it, I don't know, Rust from the inside or something. Right. So this would be. You actually want to get involved with this project. Let's understand how that code base work. We can do this for US Analyzer. We could do this for Tokyo, for example, too.
00:06:55.695 - 00:07:12.635, Speaker A: Like, not how to use Tokyo, but how to contribute to it. We could do it for the compiler. The biggest challenge to doing a stream like that is for many of these code bases. I'm not a contributor. Right. I've never contributed to the Rust Analyzer code base. I've contributed to the standard library, but not to the compiler itself.
00:07:12.635 - 00:08:18.485, Speaker A: I'd be interested in doing so, but it's not clear that I would be your best guide down that path, for example, but I mean, it's something I could Try it would be more of a let's learn this code base together, which is maybe useful, but I think useful in a different way. Okay, next question. In Rust, for restations on the topic of error handling, you said that the community hadn't settled on a single unified approach. Do you think this is settled yet? And if so, how so? I think the Rust community has still not decided the right way to do errors, as in like a single true way. But I also don't know that that is the goal. I think maybe where we're we've landed is that there are a couple of different ways that you can do errors. I think, you know, the three most common among them are opaque errors.
00:08:18.485 - 00:09:01.830, Speaker A: So errors where you just get an error type and maybe it has some methods, but there's no way for you to really introspect the internals of that error. Like for example, requests error type doesn't really expose you the underlying hyper error type or the underlying, you know, STDIO error. And that's okay because usually if request fails, you don't care exactly which variant of the internals of the library truly caused that error. All that matters is it failed. And usually the way you would handle any failure, they're all the same, except for HTTP status codes, which request errors do surface. So that's the sort of opaque error approach. The other one is the very transparent error approach.
00:09:01.830 - 00:09:57.543, Speaker A: This is usually, you know, errors through enums, so you list all of the possible error variants and then each of those you can sort of further expand. This gives you exhaustive matching for errors, for instance, which can be really useful. But it also tends to tie you down a lot when it comes to things like backwards compatibility. Because now if you have a dependency that is really internal to your program, but you do allow its error to surface, then now that error, their error type is in your public API. And so if they do a breaking change, you have to do a breaking change. So this can get a little bit awkward. It also tends to have the problem that when people do exhaustive errors like enumerated errors, they tend to do it in the way where there is one error enum in the library and all of the functions return that error very that error type.
00:09:57.543 - 00:10:47.275, Speaker A: And this is problematic because not every method actually has the same set of possible errors. So if your goal is for people to be able to exhaustively match on what went wrong, then this approach is kind of wrong because let's say that you have a method that can fail because of, let's say, parsing, but it cannot Fail because of IO. Ideally it would return an error type where IO is not one of the error variants. But doing that is tricky. You do have then the sort of intermediate here, which is something like what the. And this is sort of the third variant as a hybrid mode, something like what the AWS SDKs do. So they have a single opaque error type that has a type parameter that varies by function.
00:10:47.275 - 00:11:39.459, Speaker A: And then that type parameter I think they expose is just like a kind but not deeply nested enum or something. But the idea being that you can exhaustively match on all the possible ways that each given SDK call can fail. So, like, if you do a, I don't know, S3 create bucket call, you're not going to also have to match on all the error variants from listing buckets that they each have their own listings of errors, but they're all wrapped in the same opaque error type that has this type parameter. So that gives you kind of the best of both worlds, but it's also the most annoying one to deal with because now you have a lot of possible error types. So this tends to work better if you have some kind of code generation involved. And so that's sort of the one way in which the community hasn't agreed on a single unified thing. But I also don't think they should.
00:11:39.459 - 00:12:21.363, Speaker A: Right. Which, where you land in the spectrum, I think, depends a little bit on the kind of library that you're building or the kind of application you're building, kind of code you're writing, and the kind of users you have, and the kind of expectations those users have of using your software. The other one is like, which libraries do you use to construct these types? So you can either just. You can construct all these yourself. You can use, you know, boxed in error, where error is the trait from the standard library. You could use, you know, your own enums that you implement debug and display and error and everything for. But it's pretty annoying to go either of these paths and implement all of the machinery yourself.
00:12:21.363 - 00:13:11.293, Speaker A: It has to be pretty verbose and you're going to miss things. And so this is where we have a bunch of libraries that make it, let's say, more ergonomic to construct these different kinds of errors. So you have things like, anyhow, air met, that all work really well for the sort of opaque error types. And then you have things like this error and snafu. Is that one of them? And I think there are a couple of others that make this pattern of constructing enum variants much nicer. And here, you know, the community hasn't settled either on, you know, this is the way to do these error types, and that's okay too. I think it's fine to have some variety here, as long as these are roughly interoperable.
00:13:11.293 - 00:14:07.455, Speaker A: And for the ones that implement the sort of enum error version of this kind of behavior, those are interoperable anyway, because all they do is make it nicer for you to generate enums that implement error, so those you can mix and match between crates is no problem. For the ones that do opaque errors, there is some value to your whole stack using the same thing, just so you get better structured error reports, for example. But interoperability there is still a little bit of a question mark. And there are some improvements to the standard library that might help here as well. The AWS one is implemented just by hand, or when I say by hand, what I mean is it does code generation based on. They have like this IDL called Smithy that's used to define basically every AWS service. And Smithy is like public and open source.
00:14:07.455 - 00:15:33.375, Speaker A: And the Rust code generator for Smithy will take the Smithy definitions of all the services, which includes all the different error types they can have, and generate all of these error types with the variance and everything. So the code generation code is handwritten, but the resulting all of the error variants and stuff is all code generated. Okay, next question. Oh, I get this one a lot. What don't you like about Rust? You know, I think it's a little bit of a weird question because I think what people are after when they ask a question like what don't you like about Rust? Is sort of tell us about ways in which Rust sucks, or maybe to put a positive spin on it, ways in which Rust could have been significantly better. And I think where I disagree with the premise of the question is significantly better for what? So there are some things that I think are just universally, I don't say problematic, but universally missing from Rust for every use case. And I think something like, you know, async drop and cancellation for instance, fits into this category.
00:15:33.375 - 00:16:54.075, Speaker A: There are a bunch of borrow checker bugs that make it hard to write correct code or where correct code gets rejected in a way that is hard to work around. So there are a bunch of those kinds of things that I would love to see improved or fixed things like the lack of Async iterators, the lack of generators, but those are things that I dislike that I also don't think are necessarily fundamental shortcomings or come with Trade offs or you know, are just complicated to implement and so we're not going to get them for a while. And those are things I don't like about Rust, but I don't think they're the kinds of things the question is asking for. Realistically. I think that the better question is what don't you like using Rust for? And there I think the set of things is fairly small, but the kind of things that come to mind are rapid prototyping things. And this is a very common, I don't want to say objection to Rust, but close to it, right? The place where people experience the most amount of pain in Rust is when they want to have really rapid iteration cycles, completely changing the code around. This is like write and dispose and write again kind of code.
00:16:54.075 - 00:17:58.377, Speaker A: Very interactive, the exploratory work, prototyping. I think the places where we see this the most is in like data science, like data analytics, where you're like just exploring some giant data set and you don't really know what you're after. You're just sort of playing around, plotting some things, grabbing out this data, plotting it that way, giving a table, giving a summary. I think that the recent article from Loglog Games about using Rust for game development was another good example of this. Where, you know, a lot of their use is we just want to throw a bunch of things around, try a bunch of things with low effort and we're okay sacrificing sort of strict correctness for that because we want the rapid iteration cycle is so important to us. And I think for those use cases, Rust does not work really well today and I don't know whether it ever will. There are some things that I think the language could get better at without compromising other things that would make it more amenable to those use cases.
00:17:58.377 - 00:18:53.475, Speaker A: But, but at the same time I don't think the goal should be that Rust should be sort of the perfect language for every use. I think that is how you end up with a language that is trying to straddle too many concerns at once and then ends up not excelling at any of them. So I don't want too much straddling in that direction. I think the other place where I see this is when you have to interact with very large pre existing tools and library ecosystems. And some of those we're already seeing improvements when it comes to integrating them with Rust, but for many of them there's just a lot of momentum to overcome. And I think we see this in machine learning and AI Rust is getting better there. And I think projects like Candle are really interesting, trying to take Pytorch code and being able to just transparently turn it into Rust code.
00:18:53.475 - 00:19:41.775, Speaker A: Really cool. But realistically, there's so much momentum in the Python space here and this ties into the advantage Python has with sort of rapid iteration cycles as well, that the Python is sort of the de facto standard here for doing ML and AI type stuff. And it's hard to get into that ecosystem just because of all the things that already exist that would also need to work with Rust. I think we have some other examples of this, like, you know, interacting with QT or gtk. Those are both getting a little bit better in Rust now. But it certainly used to be a pain interacting with certain embedded systems where like you just get a giant like C library that you have to integrate with and if you don't integrate with that thing, you can't run on the device. Those things are kind of painful.
00:19:41.775 - 00:20:49.925, Speaker A: We see it with things like low level networking, for instance, where like Intel DPDK and SPDK and the like, where there, there's like a giant SDK from Intel that you're supposed to use and not using that is just not an option. And so it's a pain. But, but I do think, you know, many of these are things that get better over time. And so it's not really a problem with Rust per se, it's more that, you know, it takes time to get into some of these deeply embedded spaces. Yeah, and the kernel is another example where Rust is now increasingly getting usable in the kernel. But in the beginning, certainly there were a lot of hurdles to get over to getting even, even basic things working because of that momentum cost. And I think those are sort of the main two places where I don't like to use Rust, where the cost is pretty high.
00:20:49.925 - 00:21:37.705, Speaker A: There are probably others, but those are the first two that come to mind. There is a sort of third which is in some ways related to the first, which is around writing portable scripts. If I want to write a thing that is going to run in CI, for example, I often don't really have that much of a choice. I could write a Rust binary that gets built in CI and then runs the rest of my CI. But realistically it's just going to be a Bash script, maybe a Python script, but. But it is probably just going to be like portable interpreted thing that is quick to run, quick to change, doesn't really have to be managed to like build it and then run it. And again, I think this ties into Both the first and the second.
00:21:37.705 - 00:22:18.579, Speaker A: Right. This is both. I want to iterate on those things pretty rapidly. But it's also tied into existing infrastructure. Like if we had a sort of CI Runner thing that understood Rust codes, sort of like cargo script so that I could just write Rust code and it would automatically just be run by the CI runners and I didn't have to set anything up, maybe that would change my mind. But there are a lot of those, like almost like system administration type things or like glue code things where I think Bash or Python are still the winners. Another example is WASM in the browser.
00:22:18.579 - 00:22:59.185, Speaker A: It's a paint integrate libraries there. Unless someone has done the manual work to write wrappers. So was I in the browser? Is a little bit like that. But I think the situation has gotten so much better for enough use cases that I think it's still decently compelling now to use Rust. They're certainly compared to other languages, right? If I sort of putting JavaScript to the side here, JavaScript and TypeScript are both, you know, obviously good at operating in a browser context because that's what they were made for. But if you look at all other languages, I think Rust is sort of the top one there. And I do think that's a pretty strong selling point for Rust.
00:22:59.185 - 00:24:05.155, Speaker A: A lot of ZIG use cases I heard are fields where active memory management is important. Do you think Rust lacks there as well? It's a good point. I think, you know, ZIG is trying to eat some of some of Rust's lunch. In the sort of low level active memory management, you need to do a lot of things with raw pointers that would have to be unsafe Rust anyway kind of thing. And maybe it's better in some ways there than Rust. I haven't, I don't have enough experience with it myself to really say, but I will say that I think there's a pretty big cost to requiring that people switch languages in order to do a particular task. So one of the things that is, I think problematic with something like Python is that, you know, if you're in Python and then you discover some code that really needs low level manager memory management or like some performance optimization you can only get with a statically compiled language, you have to switch language to write that code.
00:24:05.155 - 00:24:53.481, Speaker A: You have to go write it in C or C or Rust or whatever in Rust. If you're already in Rust and you need to write something that requires very low level memory management, you don't have to switch language the unsafe block. It does put some additional constraints on you and you do need to understand what those constraints are. You need to get some experience with writing unsafe code. But you are still writing Rust. A lot of your knowledge translates. And what Zig has to sell people on is if you are already using Rust for a bunch of this stuff, or if you're already using C for a bunch of this stuff and you have one part that really needs to deal with raw pointers and sort of very allocation heavy or, or memory management heavy, then switch language to Zig and write that component in that.
00:24:53.481 - 00:26:07.183, Speaker A: And I think that is a pretty high price to pay compared to Rust and then Rust in unsafe. Okay, what do you think about macro hell with constant traits or inline costs? So macros is a. Is a place where I don't think it's something that I don't like in Rust. I think, you know, when it comes to something like proc macros, the lack of types, the fact that they are relatively slow to build and run, those things are painful, yes, but they're not a thing that actively bothers me on a daily basis. I think the number of people using Rust where this is a real barrier to them doing most of their work is pretty low. I would love to see it get better. And I think there are knock on effects where if you have better systems for this, you can have better tools in the library ecosystem because they can make use of more powerful primitives and it gives you a benefit long term that way.
00:26:07.183 - 00:26:53.185, Speaker A: But it's not something I see as unsolvable and it's also not something that I actively dislike the way it currently works today. Next question. Companies want Rust devs with experience, but I cannot get experience without working with Rust. I'm doing my best working on open source and personal projects, but these do not seem to matter. What should I do? This is a difficult question because on the one hand there's a. There's a hiring problem at the moment where I think a lot of companies are looking to hire experienced developers and they're just. There aren't that many experienced developers to go around.
00:26:53.185 - 00:27:52.785, Speaker A: Certainly not experienced developers who are experienced in both Rust and let's say systems programming or ML or data structures or whatever it might be. And what companies end up doing is they end up setting a really high bar because those are the people they really want. And then anyone who's less than that bar sort of gets scrutinized or feels like they don't get a fair shot at it or feels like they don't even. They shouldn't even apply because they don't have the necessary expertise. And the reason I say this is a company problem is because companies need to be willing to hire junior people and then train them. And this is a problem now, but it will get even worse of a problem over time because if we're not hiring junior people and training them, then where are tomorrow's seniors going to come from? And that's sort of what this question is getting at. Like, how do I get experience if I can't work to gain that experience? I think what you're doing, so doing sort of open source and personal projects is making you more experienced.
00:27:52.785 - 00:29:08.225, Speaker A: It might be in a way that's hard to measure, but I do think it makes a meaningful difference. The two things that you have to focus on is first of all, how do you communicate that increased experience over time? So you know, if you've worked on open source Rust projects that have a decent number of users for like five years, that should be on your resume. But how you put it on your resume is going to matter in terms of, you know, whether people see it as actually valuable. And part of that also becomes making sure that you raise it in the right way, not just in your cv, but when you get to an interview that you can actually talk about those personal projects and talk about how the experience you gain from there has actually made you a more experienced engineer overall. The other thing that I think you need to keep in mind when doing open source and personal projects is, is choosing which things you work on. Because it is easy to end up working on a bunch of stuff in open source, a bunch of personal projects, but they're not really making you better at the kind of engineering that a company will want to hire you for. They might make you better at a bunch of stuff, but if it's not relevant to what you're ultimately going to work on, it's a lot harder to sell it as relevant experience.
00:29:08.225 - 00:30:03.333, Speaker A: And sometimes you gotta partially bite a bullet here and say, well, I'm still gonna take a full time job that is either in a different language, that still gives me experience in systems development, but just not in Rust, so that I'm leveling up on that side as well. Or to be a little bit more picky and choosy about which open source projects, which personal projects you work on, so that they. So you make sure that the experience you get out of it aligns with what you think you will ultimately need in whatever job you end up taking. Other sort of follow up questions on that before you move on. It's a tricky topic. Like how do you, how do you become a more senior engineer is tricky. And I ultimately think that the way you do it is by gaining relevant experience.
00:30:03.333 - 00:30:47.135, Speaker A: And that either means working on projects that give you related experience or taking a job that gives you relevant experience but in a different language, for instance, which might not be your preference, but it does still make you better suited for that kind of job long term. Right? Like, you know, if you, if you are an engineer who, you know, you do Rust on your spare time. So you know rust pretty well. You do it on random open source projects, personal projects, whatever. Over the course of five years, your Rust gets pretty good. And then you also work, you know, your full time job is in some C shop or a C Sharp shop or something where you're building, I don't know, some web service. Doesn't really matter.
00:30:47.135 - 00:31:59.327, Speaker A: You're building a web service and you're learning how to like scale that web service, how to think about managing database connections, how to think about caching, how to think about request handling and back off and you know, handling, load benchmarking, testing, all of that stuff. Then I think five years down the line, you're now in a pretty good place to apply for senior Rust positions that are for, you know, web service development or distributed systems development or whatever it might be because you've, you've sort of built your experience, you've built it separately in two tracks, but putting them together I think is a lot easier and so you've still gained that experience over time. There is an argument too for finding a, a company where you might be able to influence their choice of language. Right? So maybe you can sort of get Rust in there without too much of a problem. Maybe they have some enthusiasts already, maybe they've been thinking of making that switch. That is an option that you have. The more junior you are, the harder that is, or rather the longer it will take until you're in a position where you can affect that kind of change.
00:31:59.327 - 00:32:32.229, Speaker A: But, but it is a path you could take. All right, next, what are your thoughts on the recent Log Games article about the bad Rust game dev experience? So I touched on this a little bit earlier. Let me dig up the link to this. I'll put it in chat here. So this article, in fact, let me share my screen real quick on leaving Rust Game Dev after three years. It's a pretty long read. So I read the whole thing and I, I actually think it's really well written.
00:32:32.229 - 00:33:15.877, Speaker A: I think they make a lot of good points and I think they articulate them well, I think. I. I don't even want to claim that they're sort of misguided or anything. I do think there are some people who leave Rust for not very good reasons. I don't think this is an example of this. Like in general, reading through this, I sort of felt myself nodding along going, yes, I can see how these are problems that get in your way for the kind of goal that you have. I think there's some nuance to this that is captured in the article, but if you just sort of skimmed it, you might not have picked up on the first one is they have a very particular operating mode in mind.
00:33:15.877 - 00:34:10.195, Speaker A: Right. So they are a small game studio who are building sort of in order to survive, basically. They have to be able to rapidly build games. They have to be able to have the sort of quick turnaround cycles, experiment with a bunch of things, get a game out there even if it's a little, I don't want to say broken, but even if there's some things that haven't been fully figured out or, or there are some things that they literally coded up last night, they kind of still want to ship it because it's cool, it's fun. And the whole article sort of trade trades off on this, on the fun is more important. And that combination of really trying to optimize for rapid iteration and generating fun for the player combined with we don't have the resources to, you know, spend two years developing a game, I do think cuts a little bit against what Rust is trying to achieve. And, and I think that's okay.
00:34:10.195 - 00:35:11.269, Speaker A: Right? I do think their arguments here are in some sense aligned with what I was talking about earlier with Rust not being great for, you know, rapid prototyping, rapid iteration, type, type software development. I think some of these there's a chance Rust will get better at, and some of them are just kind of fundamental trade offs that Russ has chosen to make. And I don't think I would try to convince these people you're wrong. You should come back. I think this seems like a perfectly fine choice. I think that some of the nuance that I think is important to capture here is a lot of these complaints are very specific to both how they operate as game studio, but also to the specific experience of developing a game. I don't think this is a sort of general, a general objection to Rust as a language.
00:35:11.269 - 00:36:11.577, Speaker A: Right. I think it is a, it is very specific to this kind of use. I also don't think it's necessarily the case that this means you should never use Rust for games. So for example, if you are making something that is either a little more cookie cutter, which, you know, we can argue endlessly about whether people should be making cookie cutter games, but if they do, I think the fact that you have a fairly set thing in mind, Rust might actually accelerate that because if you fit the mold, things work out better for you and faster maybe. And I think the other argument here is that you could still use Rust for a bunch of underlying components. And they talk about this in the article too, that you know, there are ways in which you can write your, you can write your game in Python, right? But then when there are particular algorithms or particular data structures or particular, you know, computations you need to do that you really want to accelerate. And they're well defined.
00:36:11.577 - 00:36:58.227, Speaker A: Like they are not this sort of thing you're going to be tinkering with and just randomly changing, adding if conditions here, making things dependent on another state. They're a well defined scoped problem. You could only write that part in Rust and then have a binding to it in whatever language that does lend itself more to that kind of sort of dynamic programming. And so I don't think this is sort of damnation of Rust or condemnation of Rust entirely, but rather a, this is a place where Rust didn't work well for us. There are other places where this article doesn't really apply and that's totally fine. So in general, I'd say I thought this was a really good article. I think it's a useful bit of feedback to the language developers, to the community, and I think it's a useful reference for.
00:36:58.227 - 00:37:46.681, Speaker A: Here are some considerations that might mean the Rust is not the right choice for you. And I'm very much of a fan of getting those kinds of writings out there as well, because I think as a community it's really important that we don't sort of try to stick to our guns at all cost, right? And say Rust is the best for everything or Rust has no problems for any use case if you get good enough at it. Because I just don't think it's true. I think it alienates a lot of people who feel like they're the ones being stupid when that's not the reality. And I also think it's really important to normalize, giving sort of critical feedback, which is what this is, right? This is, this didn't work for us. Let us enumerate the ways in which that was, that was in which it didn't work. And that is hugely valuable.
00:37:46.681 - 00:38:42.829, Speaker A: As input to, to the language. So I'm all in favor of this article. Okay. Have you ever struggled with a lack of motivation, focus or drive in your academic or professional career? And do you have any suggestions for someone who does? I have on. On multiple, on multiple occasions for different reasons. So I, I think the first that comes to mind for me is during my PhD, I think maybe three or four years in, I went to Norway. So I did my PhD in the US I went to Norway for the summer.
00:38:42.829 - 00:39:20.675, Speaker A: And I work at this summer camp for kids. It's like an activity camp. Kids come for a week at a time or something and just, just are on vacation and we are the facilitators of that. I've worked there for many, many years. I was a kid there for many, many years and I went back and I worked there, I think basically the entire summer, so for almost two months. And I came back and was sort of supposed to then continue with my research. And I just felt in this sort of extreme lull of productivity where it was really hard for me to go back to the code and try to be productive there.
00:39:20.675 - 00:40:03.181, Speaker A: And I couldn't quite put my finger on why, you know, part of it might have been. Sort of a lot of the context was lost. So the lift to getting back to being productive seemed pretty high. And I think part of it was also I at that point worked on that code base for like three years. And so my, my brain was pretty saturated with it. And I think even though the two month break was really useful, a lot of that exhaustion maybe was still lingering. I think what I ended up doing there was spending a bunch of time on things that weren't directly related to the research, but that I knew long term would benefit it anyway.
00:40:03.181 - 00:40:50.179, Speaker A: Right. So this would be things like, you know, obsess about some algorithm or data structure that I really wanted to like port to rust. And I could do that because, well, a, I would learn a bunch from it and that's sort of what a PhD is all about. But also I knew that this particular data structure, this particular algorithm might actually end up being useful in my research project. And so therefore it was sort of a cheat, right, to do something useful for the ultimate thesis project without having to work on the thesis code. And so I think that helped me out of that particular one. And I had another one sort of getting closer to graduation where I think at that point I was just really exhausted with, or not even exhausted, just saturated.
00:40:50.179 - 00:41:47.541, Speaker A: Like I'd been thinking about nothing else but this research database code for almost six years and my brain just couldn't, couldn't be excited about working on the code anymore. Like I was still very much excited about the abstract notion like the solution I was solving. But I think being productive in the code became harder and harder and harder just from, just from saturation, like having looked at it too much and thought about it too much. And there luckily I was towards the end so I could spend a bunch of time writing for my thesis instead of writing code. I also got to shift gears a little and spend a bunch of time writing benchmarks and evaluations, which basically means I could do a cargo new right and write a benchmark harness for my thing. And I think that helped. I do think towards the end there, there was sort of a recognition that the, the software is not going to get better right now.
00:41:47.541 - 00:42:37.971, Speaker A: Like that is not my goal. And luckily that aligned with what was needed for my thesis, that the software is in a pretty good place. And most of what needed to happen was evaluation and thesis writing. And I think that is one of the ways you try to get out of this lack of motivation or focus is to find something that you do care about that is hopefully still helpful in the longer run. There won't always be something like that. Sometimes you just don't care about any facet of the thing you're currently working on. And you know, I think if you get to that point, you gotta ask, why am I doing this? And then, you know, how can you move to something else that you actually enjoy? And I think I ran into this a little bit at Amazon, but for completely different reasons.
00:42:37.971 - 00:43:12.507, Speaker A: So there, I think there was a set of two problems. One of them was that there was a period where I worked mostly alone. Like I was the only person who owned sort of the Rust build infrastructure. And working alone, like I'm generally pretty good at it. I don't need a lot of people around me when I work. I don't have a strong need for socialization as part of my professional career. But I do think I felt the both the weight of if anything goes wrong, it's on me, but also the I need someone to bounce ideas off of.
00:43:12.507 - 00:43:53.315, Speaker A: I need someone to like double check my thinking here. And I had some of that for some parts of it, but for the like entirety of Rust build I didn't really. And that I think was pretty demotivating. And then I think there was a combination of that and feeling overloaded because I was the only person. So everything came to me and I felt like I ended up Spending a lot of my time on sort of trying to balance support, helping teams, but also thinking about the systems, both short term and long term, fixing problems, handling security incidents. Like all of this stuff fell on me. And I think that ended up being a lot of balls I had to juggle.
00:43:53.315 - 00:44:58.325, Speaker A: At the same time, I had to spend a bunch of my time in like random meetings or writing docs and writing relatively little code during that time. And that made me unhappy. Ultimately, the solution there was partially to push for getting more people, which ultimately, you know, we did and then everyone left. And I think getting more people in was part of the solution there. But of course that's, that's hard to push for because if you don't feel like you're excited, if you don't feel like you have any excess energy to give, then where are you going to get the energy from to push for, for example, hiring? And I don't have a great answer for that. I think there's a sort of. Sometimes you have to identify, okay, what is the path out of the thing that's making me miserable or making me unhappy or making me stressed or making me unmotivated? What is the path out? Can I affect change in the direction of that path? And then try to give a sort of last push in that direction and communicate to those around you that this is a last push from me.
00:44:58.325 - 00:45:51.035, Speaker A: If this doesn't work out, I'm leaving. And then, you know, if it, if it works, then great. And if it doesn't, you got to make a change. Even if that is difficult. I think staying in that thing when you feel like you've exhausted all the options and still just sucks is just going to be super detrimental to you long term. Okay, do you have any, any follow up questions on that before I move on? No follow ups. Nice.
00:45:51.035 - 00:46:39.605, Speaker A: Rust for web development, is it ready? Ready in what sense? Right, like, I think web development, there are a bunch of facets to. One of them is if you're doing like web service development, like think, you know, if you were AWS and you're writing the AWS APIs for different services. I think Rust is totally fine for web development like that. And I think it's ready. I think there are a bunch of ways you can choose to go around about writing one. I don't know that the community settled on like this is the one way to write web services in Rust, for instance, and I'm talking about backends here. But even if there's not the one true way, I still think it's basically ready.
00:46:39.605 - 00:47:25.787, Speaker A: There are some, you know, pain points, I think, with most of the different Rust web development frameworks at the moment. I, I've had a lot of luck with, with Axum. I know some people find it a little unwieldy to understand it's sort of mental model or, or inflexible. I also think we're seeing a lot of interesting experimentation here, like things like Pavex from Luca Palmieri. So, so I, I think this is a space where there are still improvements to come, but I don't think that means you can't be successful writing web services in Rust at the moment. That is, there's still more to gain, but I still would think we're in a decent place to succeed at that. For front end development, it's hard for me to say because I haven't really been exposed that much to it.
00:47:25.787 - 00:48:06.605, Speaker A: I've heard good things about things like Leptos. I'm not. I just don't know whether it's a good idea to use Rust as a front end language. Can't really speak to it. I, I have some reservations, but, but whether to call it ready or not, I genuinely cannot answer. But for back end stuff, I would say absolutely. How are you doing, John? I get this question, I think, almost every stream and it's.
00:48:06.605 - 00:48:57.627, Speaker A: It's equally difficult to answer each time just because it's such a broad question. And I think, you know, to give a broad answer, my answer is good, but that's also not particularly instructive if I were to dig a little bit deeper. I think there are a couple of dimensions that you can answer this question along. This is sort of. There's the professional angle, like, how are you doing in terms of your professional aspirations? There's the personal side, like, how are you doing in your life? Like, do you feel like your life is on the right track? And then I think, you know, there's another one that's sort of a. How are you doing aspirationally? Like, do you feel like you're achieving the things you want in life more broadly? I think on the first one, professionally, I'm pretty happy. I.
00:48:57.627 - 00:49:41.521, Speaker A: I think the work that I'm doing at Helsing is both really interesting and really important and materially different to a lot of work that I've done before. And that combination of things means that I feel like I get a lot of value out of that work. On the, on the sort of open source slash educational side, I, and I've said this before, I wish I had more time to dedicate to it. Like for example, I would love to write a. Or not write, but. But make a Rust course that is sort of a. I think what I would call is something like Rust.
00:49:41.521 - 00:50:22.435, Speaker A: The deep end first, right. Like starting just by dropping you into a large Rust code base and then we're going to talk about everything we see with the goal that you're going to understand the whole thing. And I actually have a code base in mind for this. I think it would be a really cool Rust course. It would probably be a paid course with some kind of discount for students. I don't know yet, but I just don't have the time to build it. And I think I've come to the conclusion, I've mentioned this before too, that the only way for me to go one step further on the sort of education track is.
00:50:22.435 - 00:51:18.565, Speaker A: Is I have to drop something else. And I don't know exactly what that would be. I think realistically it would probably mean going from working five days a week at Helsinki to like four. I think the work that I do there is important and valuable and interesting enough to me and I think teaches me a lot that I want to keep. So I wouldn't want to work none at all. But I do think the only way for me to do more of the other stuff that I think is really important and ultimately I think benefits the company as well would be to reduce my workload there slightly and then spend, let's say even just one day a week developing educational resources like an online course, doing more streams, maybe do more open source contributors, contributions to the project I'm already involved with. You know, there's a bunch of open source Rust libraries I have that could use a sort of iteration cycle of me actually paying attention to them.
00:51:18.565 - 00:51:50.421, Speaker A: And also, you know, writing maybe a sort of second, second edition of the Rust for book I think could also be really interesting. There are a bunch of like errata but also things I would like to add in there that I would need to find a decent chunk of time to do. On the. On the personal side of things, I'm doing pretty well. I'm pretty happy about being in Europe. And this gets at the next question. So I won't actually.
00:51:50.421 - 00:52:09.635, Speaker A: Maybe I'll just combine this. No, I'll not talk about sort of location because that's the next question. So I'll talk about that in the next question. But on. On the other sides of the personal things, like I think I'm pretty happy with my life. I think it's. I don't have any sort of major complaints, I think.
00:52:09.635 - 00:52:46.635, Speaker A: And I think not having complaints is different from being happy. But I think I'm also happy. I think, you know, there are things I wish I got to do more of. Like I would love to travel some more. I would love to like have a regular board game night again, for example. I would love to go meet more Rust communities around the world. I would love to be part of sort of.
00:52:46.635 - 00:53:36.785, Speaker A: I think I'm a lot of what I do at the moment is very tailored to Rust, which is interesting. But I do think that I have now some experience that is useful in sort of what it's like to be an engineer and how to grow as an engineer that I would love to also find a way to share that sort of border. It's not really personal, it's more professional. But I think personally it's important to me to help other people grow. Not just in a very technical sense, but as people and try to sort of facilitate that and be a mentor. But one on one, mentoring doesn't really scale. And I think I personally get a lot out of finding ways to help people I don't know and enjoy their, their professional lives more as I would love to find a way to really do that and I'm not quite sure how to do it.
00:53:36.785 - 00:54:23.025, Speaker A: And, and on the sort of aspirational side, I guess the previous one sort of leans over into that. But I think aspirationally there are just so many other things I want to do. Like, I've already mentioned that I have at least one podcast idea I would love to start. I have, I want to build a cat, an automated cat feeder by like 3D printing a bunch of parts and like programming like an Arduino with DC motors and stuff. And I have like a design I've written up in a. In open scad and you know, I think that would be really fun. I don't know where to find the time, but there's a bunch of stuff where I kind of want to branch out.
00:54:23.025 - 00:55:26.345, Speaker A: I feel like I've done a lot of, you know, distributed systems, concurrency, Rust, programming languages, type stuff for a while and I still think that stuff is super interesting though I do feel like I have other things I also want to explore which just sort of. I don't really have an avenue to do that because it would just take more of the time that I don't have. Okay, I think that answers how are you doing? As best as I can without diving, you know, too deep into my personal life. What are your thoughts On Norway, what are the biggest upsides and what do you miss about the US Are you thinking of moving out sometime? What about Switzerland from Swiss Whiz? So I think they have a. They have a biased stake here in asking the question. So. I really like being back in Norway.
00:55:26.345 - 00:55:39.633, Speaker A: I really like being back in Europe. I also mostly like being back in Norway. There are some. There's some obvious reasons for that. Like, you know, I have a bunch of family here. I have a bunch of friends here. And it is just.
00:55:39.633 - 00:56:14.155, Speaker A: It's really lovely to be able to like, go over and like, you know, have a barbecue or just hang out with them. Like, I've gotten to spend a bunch more time with. With my brothers, for example. Now that I'm back, I've run a bunch of board games with my sister who recently also had a kid, which. So, like, I'm an uncle now, which is really exciting. And I get to actually be around the kid and not just sort of observe them over video call from the US So I really like being back in Norway for those reasons. I also think life is pretty comfortable here.
00:56:14.155 - 00:56:33.545, Speaker A: I like the fact that I can walk everywhere. There's really good public transport now that it. Now that sort of spring is arriving, I started biking around the city, which I think is good for me, but I also enjoy. And so it's just, it's a. It's a nice place to be. I just, I like life here. And I also.
00:56:33.545 - 00:57:21.555, Speaker A: I think I have a lot fewer things that frustrate me or that I'm like, this is just shit than I did in the US around things like filing taxes or, you know, worrying about food safety or dealing with health stuff, not having to deal as much with insurance. There's a bunch of that stuff that I really like here that I would not like in the US I really like sort of on the Europe side. I really like being closer to a lot of countries. Like the fact that, you know, for. I can just fly to London pretty regularly and it's not that far. I can fly to Munich and it's not that far. I can go visit Spain, which I went a lot as a kid.
00:57:21.555 - 00:57:54.955, Speaker A: I can do that without too much of a hassle. My brother lives in Copenhagen. I can go visit him pretty easily. And just being close to a bunch of places and interesting in different places, I really like. And I know that the US is large and states are relatively different from each other, but it's just a different feeling. I can't put my finger on it. I do think there are some things that I miss from the US But I don't know that they matter that much to me.
00:57:54.955 - 00:58:38.999, Speaker A: So some examples are I do really miss having Amazon deliveries. There's just no question about it. Where you have one place where you can find basically everything and it gets delivered to you the next day, that is just very hard to give up. And the reality is that here, you know, I need to figure out which store has the thing I care about and they might not ship or the shipping might be really expensive or they might not even be a Norwegian store, right? They might be from some other European country. And then I need to pay shipping and customs and sales tax. Like it is just much harder to get things here. And when I say much harder, it is much harder.
00:58:38.999 - 00:59:21.641, Speaker A: It's still not that hard, but it is much harder. And so that is one thing that I miss. The other thing that I miss is, you know, in the US especially in the larger cities, they're just lots larger, right? There are more people doing more different things. And I think, you know, I missed some of that sort of size of communities, ease of finding communities. Like, you know, there are a couple of regular board game nights in Oslo, but none of them are particularly well attended as far as I can tell. There's like one board game cafe that recently opened. There's, you know, for Rust meetup.
00:59:21.641 - 00:59:46.033, Speaker A: I've managed to start that back up, which I'm really excited about. And we get a decent, decent turnout. Whether that will last I have no idea. But. But it's more of those, like, I wish more of these things there were just lots of. And I think I missed that a little bit. But it is getting better, I think in terms of whether I'm thinking of moving out sometime, I don't know.
00:59:46.033 - 01:00:56.515, Speaker A: I think so. I did this sort of trade off exercise with my girlfriend the other day on should we Stay? And that mostly contains, okay, where would we go instead? What are all of the options for where we would go instead? And are any of them meaningfully better overall? And I think what we concluded was there are a bunch of things that we don't like about Oslo, but there isn't anywhere else that would be a universally better pick. And that's not a great feeling, right? That's a sort of this is the least bad option, but I think it's better than that. I think it's like it is a totally fine option and we just wish it were more exciting. But I do think we're probably going to stay here at least for the foreseeable future. We both enjoy traveling, though, so, you know, longer term there's totally an option for us moving somewhere else, but I think in the sort of next five years, we'll probably stay here with the goal of, like, traveling a decent amount and making use of the fact that we're now in Europe. So the hope is that I get to be in a bunch of places but still have Oslo be my base.
01:00:56.515 - 01:01:26.145, Speaker A: Don't you find the short days in winter hard? I don't. I like darkness, I think, you know, my. My girlfriend, I think, is more affected by the weather, both, both temperature and darkness than I am. But, like, I grew up here and also I just like darkness and I kind of like the cold. So for me that's just not a problem. I think for many people it would be. It just isn't for me.
01:01:26.145 - 01:02:25.245, Speaker A: There are places in Europe that have Amazon or bigger cities. What do you miss about the us? About the US exists in, let's say, Berlin. Oh, a lot of what you miss about the US exist in Berlin. That's true. And so this is what I meant by we sort of went through this exercise of let's look at all the things that matter to us and like, you know, number of food options is another thing that's like, mediocre in Oslo, I think, but is much better in a place like London, for example, or probably in Berlin as well. And again, I think what we concluded was there are a bunch of places that are better at certain things than Oslo is, but overall, I still think here is probably the place to be. And certainly a part of that is, you know, I have friends and family here and that counts for a lot.
01:02:25.245 - 01:02:59.535, Speaker A: I speak the language here with. Which counts for a lot. Like, I don't speak German. So if we moved to Germany, we would both have to learn German, which is a language neither of us knows. So, yes, there are other places where some of these benefits or some of these things that I miss from the US exist, but I don't know that they're universally better than. Than what we have here. So London is actually the place both I and my girlfriend probably would have loved to move.
01:02:59.535 - 01:03:34.491, Speaker A: But my impression has been that it's gone a lot downhill over the past. Well, since Brexit, but arguably from a little bit before that, you know, the. The NHS is struggling. I think the country as a whole is struggling. It's a lot more inconvenient because of Brexit, the like. I have a decent number of people who I either know or have worked with. Or I guess both who used to live in London have decided, either have already moved out of London or have decided that they are going to move.
01:03:34.491 - 01:04:25.457, Speaker A: And not just out of London but out of the uk. And so I get the sense that it's not, not quite a sinking ship, but that as much as I like London, I don't think it's the place to move to with the goal to live there for a longer period of time. Which makes me sa. Have you ever experienced racism considering you've lived abroad and you were considering moving out? Again, I can't say I have. I mean I'm in a privileged position here, right? Like I'm like a white dude from Norway, so that's not really been a problem. I've experienced. I'm sure there are some places in the world where I would experience that, but that hasn't factored into my decision.
01:04:25.457 - 01:05:18.005, Speaker A: No. How about Ireland instead of London? So, so I have thought of Ireland, but I just don't know that like Dublin for example would be meaningfully better again sort of along all of the dimensions that matter to me than, than Oslo would be, you know, and I think anywhere but Dublin would probably not be the. Like I probably wouldn't move to a smaller city in Ireland. But like I, I've never been to Dublin. I'm sure it's nice, but again, on the sort of trade off scale, I don't know that it makes a huge difference which is more expensive to live in NORWAY or the U.S. it's a complicated question. So Norway is more expensive in the sense that like, you know, sales tax is 25% on everything.
01:05:18.005 - 01:06:14.325, Speaker A: Like everything is more expensive here. At the same time, you know, you get a lot more benefits from living here that are free, like healthcare, but also salaries are lower and also taxes are higher. So like it's really hard to answer. I think purely based on the asking of the question, like which is more expensive. I think Norway is more expensive. Where do you end up having a better life quality overall given a certain income? Probably Norway. Might we hear some Norwegian? The funny thing is I've had people, I've had Norwegians watch my streams, meet me in person and be surprised about my.
01:06:14.325 - 01:07:03.225, Speaker A: That like surprised when they hear me speak Norwegian because they're like, oh, that's not how I thought your Norwegian would be because we have a lot of like regional accents and stuff. I don't mind is not particularly weird, like I'm from the capital, but even so it's always surprising I think, to hear people speak a different Language. Okay, I think we've. I think we've exhausted this question. Next question. How do you manage to stay focused and productive during the day? I don't think there's actually a trick to this, but I think there are two. There are two considerations that I think are important.
01:07:03.225 - 01:07:45.165, Speaker A: The first one is to make sure that the stuff you work on is interesting and is a good use of your skills and your time. But it's stuff that you really want to dig into. Because if the stuff you're working on is interesting to you, time just flies, man. Like, I was working at a sort of. I'll be kind of vague here because I kind of have to. A programming problem on, I think, Thursday last week. And I happened to have a bunch of time that day where I could do a bunch of programming.
01:07:45.165 - 01:08:30.121, Speaker A: Didn't have a lot of meetings or anything that day. And I just sort of sat down after having breakfast, started coding. And then like four hours later it was like, oh, I should probably have lunch, because it was just really interesting. Like, I was working on some interesting code that was like, hairy in a bunch of interesting ways. And as long as I have some things like that to really work on and think about, that excite me, that I find interesting and challenging, that does a lot to help me stay focused and productive. And then I think the other part of this is when you're not feeling productive or focused, but you know that this is like, generally a thing that interests you, but you're just not feeling focused and productive. Don't work.
01:08:30.121 - 01:08:59.975, Speaker A: Like, literally, there will be days when I feel that way and go, I'm not going to work for the next two, two hours because I'm just not productive right now. And then I make up for those two hours later. Like, maybe I work two hours that evening or something. But being willing to shift around the hours of your day to when you actually feel enthused and productive and focused is really meaningful. And maybe it's not that day. Maybe there's a day where, you know, this day is just not a working day. Like, it just isn't.
01:08:59.975 - 01:10:06.985, Speaker A: I'm just like threading water and it feels like absolute shit and I'm not making progress. Then it's not in your best interest to push through, and it's not in your company's best interest to push through. It is much better for you to just like, declare that day as defunct and then, you know, work a day some other time to make up for it. Or, you know, work those hours spread out somewhere else. Or you Know if you work at a company that is infinite days off, this is what that's for, is you can just not work that day because it wouldn't have benefited anyway, anyone, anyway, quite to the contrary, it might even be counterproductive because I think in general, if you force through working when you're not feeling focused, you're not feeling productive, you're not feeling attentive, then chances are you're producing code, you're producing solutions, you're producing advice. If you're mentoring, that is probably just not very good, maybe even bad advice, bad code. Things you haven't thought through carefully enough that either other people will have to catch so the cost of their time or it makes it into production and then something crashes and you know, bad business outcomes come out of it.
01:10:06.985 - 01:10:57.397, Speaker A: So, so it's just not worth it. There's a hair fine balance here though, because it's very easy if you know that you can always just choose not to do the work to be like, well, I don't need to work today because I don't really feel like it. Right, and so you need to, you need to have some amount of self discipline or self control in order to exercise it this way. But I do think that managing when you actually work is really, really important. And of course this requires you have a company that understands that this is how you do a job, like what we do as engineers. Well, if your company is like no, you gotta work nine to five, you don't have this option. And I genuinely think that then sometimes it is better to not do work for an hour.
01:10:57.397 - 01:11:53.225, Speaker A: Like just click around like go to o game or something, like play like a, like a text based browser game or something for an hour. Like it is actually better to do that again for the company as well than trying to force yourself to work for that hour. And you gotta know yourself here, right? Like I know that there are some times where I just really don't want to start a task, but I know that once I get started I will probably find it interesting and find that focus. And so I know I have to push through the sort of initial barrier. And knowing yourself well enough to know the difference between I'm not going to be productive for an hour and I'm not going to be productive and have fun for five minutes, but then I will. That's a learning exercise for yourself. But I do think this combination of these two things of make sure the stuff you're working on is generally interesting and making sure that if you're not feeling productive, you're not working.
01:11:53.225 - 01:12:54.307, Speaker A: That combination is how you stay focused and productive. Maybe not during the day, but during a week, a month. What about when too many days are like that? So if you find that like most of your workdays are, you're just not interested in what you're doing, you don't find it fun, you don't find it interesting, you don't find like that you're learning, you just don't care, then yeah, I think the problem is what you're working on. You know, it could be that you're working for a company that you don't really believe in, you don't think it matters, you don't find the tech interesting, you don't feel like you're learning from it. And that is a problem. It might not be easy to make a change, right? It is usually the case that switching jobs is not just costly. It's often costly on a sort of professional level, it can be costly on a social level.
01:12:54.307 - 01:13:58.519, Speaker A: It can be costly financially, although it can also be beneficial. But it's also just a bunch of friction and uncertainty in your life that you have to be willing to deal with at that time. Like if you just bought a house or you just had a kid or something, that might not be the time to also switch jobs. But I do think that if you genuinely find that you're just not enjoying your work and you're not feeling productive at it, you're not feeling that this is a thing that you enjoy doing, it's probably worth looking around to see what else there might be. I don't think it's worth just sort of trying to stick it out and hope it gets better. And this gets at the earlier questions that was asked where I think you need to see, you need to search around and see what is the path to this being interesting and productive to me, this, the, this job at this company, or maybe a slightly different job at this company, what is the path to me enjoying staying at this company? And if you don't see a path, you gotta leave. If you see a path but you're like, that's never gonna happen, then you have to start working for that path to happen.
01:13:58.519 - 01:14:39.249, Speaker A: And if you push and you exhaust your energy trying to push on it, it still doesn't happen. You don't have a path anymore, you gotta leave. And leaving is something that, you know, often is not a sort of same day kind of affair. But you need to start planning. This advice is the complete opposite of what I was told in the finance industry. It's crazy how different the mindsets are. I'm curious if you could say more about that, because I do think that many companies in software development, too, have this mindset of, no, just work, right? Like, you're not paid to have fun, you're paid to work.
01:14:39.249 - 01:15:19.975, Speaker A: So I don't really care if you're excited about your work. You got to do it anyway. That's what we pay you for. And like, in some sense that's true, right? Like, on a relatively fundamental level, they don't care that you're having fun. They just care that you do the work that you get assigned. But I think the moment a company thinks slightly further, right, if your experienced people end up getting bored and leave, that is extremely costly as a business, right? Because you've lost a bunch of the people who had experience, who had context, who had the history that are now just leaving to bring that somewhere else. And you now you need to retrain someone, which is hugely expensive.
01:15:19.975 - 01:15:48.645, Speaker A: But also, if people are way less productive because they're not enjoying what they're doing, then that means that, you know, you're putting in the money, but you're getting like 20% out of that person. That is a problem. And so you really should try to find ways to have people enjoy their work. Not always possible. Sometimes the company just doesn't do anything that interesting. And, yeah, that sucks. Then you got to find other ways to sort of incentivize people to stay.
01:15:48.645 - 01:16:19.975, Speaker A: But, But I do think ultimately that for you as an individual person who chooses to be an employee, you got to choose what ultimately, you know, you think is right for you and you think you can work with. And to be clear, I'm not. I'm very cynical about this kind of stuff. Like, if you find that, you know, genuinely right now, the thing that matters to me is to make a bunch of money, right? Like, I don't care that it's fun. I'm just going to do the work. And I. It might suck, I might not be focused at times.
01:16:19.975 - 01:16:57.307, Speaker A: I'm just going to do the best that I can, churn through the work. I know it's going to be a slog, but I'm going to do that for three years, four years, five years, make a bunch of money because they have to pay me well because it's not an interesting job and they know it. And then after those five years, I now have way more freedom to just kind of work on things I think is interesting. I think that's totally fine, too. The important thing is that you're making this choice consciously that it's not just a I'm just going to take the highest paying job. And then this sucks because you're making a trade off here. And I think you need to make that trade off intentionally.
01:16:57.307 - 01:17:45.937, Speaker A: It might be that in order to work on something fun, interesting, challenging, you take a pay cut, right? Like maybe you get more like much less cash compensation and more in stocks that are not worth anything because the company is a startup. So you're taking a risk, you're taking a gamble, you're taking a pay cut. But the upside is you maybe get to work more interesting things, you get to have more fun. And there is a sort of gamble that, you know, maybe it ends up being worth a bunch, but that is a trade off you're making. And I do think that we have to make that trade off consciously rather than, you know, just looking at how much are you paid in the end because then you end up funneling to jobs that I think are less interesting in general. I personally realize that I like writing code, but I hate testing. So whenever I see a change that would be hard to test, I procrastinate a lot.
01:17:45.937 - 01:18:26.735, Speaker A: So I start making tests better. Yeah, testing is one of those really interesting things where I think a bunch of engineers dislike writing tests but like writing code. And then there are some engineers that really like testing and don't really care about writing all the other code. And you know, the reality is you write better code if you test that code. I think the way to incentivize yourself to writing tests is to make good testing infrastructure, like challenge yourself to make it in some sense fun and interesting to write tests. And I think getting good at things like prop tests is one way to do this where you can probably write. You don't have to write like 100 tests.
01:18:26.735 - 01:19:10.219, Speaker A: You can write like three tests that are really well engineered to exhaustively test your thing. And now you end up with something that's both better tested but also was more interesting to write than just a bunch of copy paste tests that do slightly different things. So I think you can challenge yourself a little bit on this, on making it more interesting. Okay, the next one is what is Rust not well suited for? Which I think we've already answered in the what do you dislike about Rust? So I'm going to mark that as answered. Okay, let's do a quick pause here for me to drink some tea and for other people to make tea. Very important to always be drinking tea. You got to hydrate.
01:19:10.219 - 01:20:10.215, Speaker A: And then while we take this short break, before I answer the next question again, ask any questions you might have put them in the Q and A page, but also remember to scroll to the bottom or at least scroll down the list a bunch, and then look for other questions that you think might be interesting so that we make sure that we bubble up the newer questions that more people are interested in. The answer to the link to the question answering site should be in the video description below. I guess in the meantime, while you're all voting and asking, I'm gonna grab some cats and show you ca. Hi, Chai. You want to come out here for a second? Come on. Oh, come on, Chai. Come on.
01:20:10.215 - 01:20:20.615, Speaker A: Come on. No, Chai, come on. Come here. Chai, Come here. Come on. Come on. Yeah, come on.
01:20:20.615 - 01:20:43.373, Speaker A: Come on. Good job. Oh. Do you want to say hello? Are you so pretty? You are so pretty. You purring Here, look. Look at that. No.
01:20:43.373 - 01:21:04.911, Speaker A: Where are you going? Hi. Yeah. I love you. You're very pretty. Do you want to say hello up there? No. Okay, There we go. There you go.
01:21:04.911 - 01:21:33.285, Speaker A: Hi, Miso. You also want to say hello? What do you think? Do you want to see up here? What do you think? You want to go up there? You sniffing? Do you want to sniff that? No. Okay. Okay. I know you're a rearing lion. Okay, Come on. There you go.
01:21:33.285 - 01:21:58.713, Speaker A: Bye. Amazing. We got cats. About time. It's true. It's true. All right, I've had some tea.
01:21:58.713 - 01:22:36.575, Speaker A: I need some more tea. All right, let's continue with the questions. Nice. This is a hog Capisco chair. Yes, I've talked about it in my other streams. Yeah, one of those. I am drinking a green tea with ginger.
01:22:36.575 - 01:23:33.645, Speaker A: Not a very fancy one. Just enjoy it. All right, next question. How about best practices in setting up a Rust project? For instance, how do you start to keep things easy and fast to where all your errors are laid out? How do you set a GitHub Actions to help you. How do you maintain your cargo toml things to do in Rust that are not about programming? I think it's actually really hard to answer this question in a general sense, because ultimately it depends a lot on the project you're building. I don't think that there are that many general rules. I think in terms of starting a project just started, ultimately, you're not going to know the kinds of things you need in your code base, the kind of patterns you need, the kind of structure that you need, until you've written a bunch of it.
01:23:33.645 - 01:24:11.027, Speaker A: And that can be a. That can just be a sort of prototype, I put out a bunch of things and the shape will start to start to dictate, you know, where do you break up crates and the like. There are some techniques you can use to try to figure out where to break crate boundaries and the like, but I don't think there's really a sort of this is how you should always start. Similar for like how to choose to do errors. Like, I think the way you choose to do errors is you think about how people are going to use your library. You look at what the interface ends up being, and then you design the error types to fit how they're going to be used. It's not really a thing that you do in advance.
01:24:11.027 - 01:25:07.165, Speaker A: Like, I never write the error type first when writing a library or an application for that matter. I think for a lot of application code where the callers are never going to care about the structure of errors because there are no callers, I usually just stick with a library, like Anyhow or Air or Miette. But that's sort of the extent to which I have a rule in my head in terms of setting up GitHub Actions. I think I have a stream on this about how to set up CI that I'll try to link in the the video up here. But the general rules I have is for I want my CI to do a couple of things. I wanted to run all the tests, which is pretty obvious. I wanted to run cargo hack, which checks every combination of feature flags and make sure that they still compile.
01:25:07.165 - 01:26:13.415, Speaker A: I want to run clippy on them. I want to run cargo update minimal versions to make sure that the version specifiers that I have in my cargo TOML are actually accurate. There's some complications around this. In part, it's nightly there's like Z minimal direct versions, which helps a little bit. And then I also like to do a cargo update on beta and then do a test run with that to make sure that even if you're on a very new version of the compiler and you're using the latest version of all the dependencies, the software still works. And what else do I run in CI? I usually run loom if I have loom tests, Miri if I have any unsafe. Same with thread sanitizer and address sanitizer, if I have any concurrency and unsafe and I run code coverage, although I think I'm getting relatively little value out of code coverage, actually, to be honest.
01:26:13.415 - 01:26:45.785, Speaker A: And then I run a minimum supported rust version check. I think those are all the GitHub actions that I have that I think are sort of generally best practice. How I maintain my cargo. Toml. There's not that much to maintain really. I do try to make sure that all of my dependencies are specified with all three version segments. So major, minor and patch.
01:26:45.785 - 01:27:11.865, Speaker A: This is generally best practice anyway because you want to actually specify what the minimum version that you support is. And if you just say like, you know, Tokyo equals one, for example, then you're not actually. Then you're claiming that you work with Tokyo 1.0.0, which may not be true. You might be using some feature that was added later. So even though it can be tempting to sort of trim them down and I mean I used to do that in the past too. I don't think it's really the right way to go.
01:27:11.865 - 01:27:54.351, Speaker A: And then it's things like make sure you actually set up the minimal number of features you need from the dependencies that can pretty significantly improve your compile times. And I tend to be fairly limited with my use of features. I think the more knobs you give your users, the more they're going to set them wrong and them hurt themselves. But also it gets pretty annoying to deal with on the code side because now you need to think about all these features and how they interact. So I think these are sort of answers to the. Some of the specific questions in this question. I think the broader one of things to do in Rust that are not about programming is probably too broad of a question.
01:27:54.351 - 01:28:41.415, Speaker A: Like I just. Not in the sense that it's a bad question, just in the sense that I don't think I have a way to really answer it in a thorough, useful way. Okay, next question. If you have questions and you're currently putting them in the YouTube chat, put them on the question asking website instead because that is how I will actually see them. I'm not generally going to be answering longer questions from chat, just sort of short ones here and there. What are some unexpectedly high return on investment things you've bought or started doing? Oh, that's a very good question. Okay.
01:28:41.415 - 01:29:23.895, Speaker A: I think I have a couple getting up the same time every day. I, I think is actually has made a decent difference for me and I, I've been doing this for quite some time now. Um, but like this includes weekends. Like I just have an alarm set for the same time every day and it's, it's like the, it's like a sleep alarm. So it just vibrates on my wrist and it vibrates when I'm in light sleep and it vibrates, you know, in a Span of about half an hour. And I just find that my body gets used to getting up the same time. And so getting up is pretty easy.
01:29:23.895 - 01:29:55.725, Speaker A: I mostly just get up when the alarm goes off or usually a little bit before. And that is a little weird, right? Because weekends you might want to stay up later or whatever, but I just okay on weekends, then sometimes I stay up a little later and I still get up at the same time. Or sometimes I just go to bed earlier on weekends too. And. And I, I found that pretty nice. I don't really know why. It just has made it a lot easier to wake up and actually do stuff in the morning.
01:29:55.725 - 01:30:41.047, Speaker A: And I don't think it matters hugely what time you choose. I think you just need to be consistent about it. Other I'll pick a sort of random selection of things, like some that are smaller and some that are larger. So one of them is to have a mic arm, like this thing. I find that the combination of a mic arm and like, decent headphones makes a huge difference to like, being in meetings, because I can like, lean back and still have good audio. Um, but also you can have like the Bluetooth headphones, but the audio is still a lot worse. It means that it's more difficult for people to hear you.
01:30:41.047 - 01:31:28.655, Speaker A: Um, it also I found over time, like usually the sort of Bluetooth headphones, like the Bose or whatever that basically everyone has. Um, that's not quite true. But that style headphone, like, I just. My ears sort of hurt if I wear them for too long. Um, you have all these troubles with like, Bluetooth and stuff and just having a microphone and arm, even if it's like a dirt cheap one, it just makes like a big difference to meeting experience. I've found other things that are high roi, so I've installed smart lights in our apartment. What I mean by that is I bought like a little home, like zigbee Z wave controller.
01:31:28.655 - 01:31:52.215, Speaker A: And then I've replaced most of our light bulbs with like, smart light bulbs. And then I've installed a couple of like, little motion sensor things that are also hooked into the same system. And so now, like, our lights just sort of manage themselves. Like, I walk into the bathroom, they turn on and they turn off when I leave. Same thing with my office. Like, I have a. I have a button on my.
01:31:52.215 - 01:32:33.035, Speaker A: I have a little like, remote control for my lights, and I have a button that sets up the lights for streaming, and I have a button that sets them up for nighttime lighting. And I have one that sets them up for daytime lighting. I Have a button that switches the home whole house lighting to be, or apartment lighting to be sort of for night times. And I don't know if it's really high roi, but it is just really convenient. Like I've just found it nice like in the, like at night, for example, I can just walk into the bathroom and the lights turn on, but they turn on dim because it's nighttime. And a lot of that automation, I think I've. I've enjoyed a decent amount.
01:32:33.035 - 01:33:34.105, Speaker A: Another thing that I started doing, which I was, I've been really happy with is, you know, the Rust meetup in Oslo was kind of dormant for quite some time. And this was one of the things that bothered me about being here is I wanted a technical community and there just wasn't really one. And what I did was I just sort of decided to start running them. And in particular the way that I did this was there's a restaurant in Oslo where I know some of the owners and they were struggling a little bit with finding people who or sort of filling the restaurant on certain days of the week where there's just like not a lot of people go to eat at a restaurant on like a Tuesday. And so, you know, what do you do as a restaurant? Well, either you close on that day, you have reduced staff, but you're not really making money. So that's unfortunate. And I talked to them and I was like, well, you know, there's a meetup for a bunch of programmers that is looking for a place to be somewhat regularly.
01:33:34.105 - 01:34:15.293, Speaker A: And our restaurant is actually a pretty good place, I've come to realize, for a meetup because there's food, there's drink, there's tables and chairs. It's a cozy atmosphere rather than like a brightly lit like office meeting room. And they're often like just nice places to socialize even if you're not necessarily sitting in their own program. And so I chatted to them for a while and we ended up saying, okay, let's just try it. Let's take in an evening and just like not book out the restaurant. But I'd say like this, this corner of the restaurant is going to be for the rest meetup that day. We're not expecting to get a lot of people anyway, so like there's probably a bunch of extra tables you can use.
01:34:15.293 - 01:34:39.095, Speaker A: They didn't charge me because people are going to come in and buy food and drink. So we sort of pay for ourselves. And it worked out really well. Like we had. I think last time I ran this we had like 60 people show up and a bunch of people just ended up like ordering some drink of food and sitting and chatting about rust, chatting about other things. Some people were like sitting around a table doing some like, hacking things together. Some people brought in a better device that they were tinkering with.
01:34:39.095 - 01:35:03.225, Speaker A: It was just a very like, pleasant social atmosphere. This just worked out as a really nice sort of bring your own code, hack and learn kind of kind of ordeal. We're going to do another one pretty soon. And I think starting to basically organize something like that was a very worthwhile thing for me to do both because it was pretty low effort. Right. I'm not really preparing anything for this. There's no talks or anything.
01:35:03.225 - 01:35:34.993, Speaker A: It is. It's been really nice, both socially and professionally. And, you know, it's kickstarted this community that I care about. And that's. Yeah, I've just. I've found that really a really worthwhile thing to push for. And I think the last thing I would say here is, oh, on that.
01:35:34.993 - 01:35:59.335, Speaker A: The Copenhagen meetup spends a lot of the meetup time on talks. It sounds like you're not doing that. No. So I think it's something we're probably going to start up with again to do talks every now and again. But I think we're more likely to be in the sort of London camp of having talks relatively infrequently, like, you know, maybe every three months or something. The meetup that month is a talk and then more. More social ones, because the social ones are very low friction.
01:35:59.335 - 01:36:31.655, Speaker A: But I think there's a lot of value in them, in sort of bringing the community together, socializing and still getting, you know, professional value out of it. Like, I totally think we could have a sort of Meet Rust stations for social hour almost once a week. And maybe we only get like 10, 15 people for those, but I still think that's worthwhile. And then you, once a month you have like a hack and learn. Once every three months, maybe you have a talk. But I do think that the. I want this meetup to be a little bit more regular and less focused on it is only for talks.
01:36:31.655 - 01:37:01.245, Speaker A: Where are these Oslo meetups announced? They're on meetups. If you go to meetup.com and you just search for Rust Oslo, you'll find them. Would you post the time and location for an Oslo meetup in your discord again? If you just look at the. The Rust Oslo meetup page, it'll have them. And then let's see. Do I have any other high value ones.
01:37:01.245 - 01:37:28.137, Speaker A: Yeah, this one's kind of stupid, I guess. But I bought a backpack and I have far too many backpacks at this point. But I bought a backpack that I wanted to start using as my carry on instead of having like a roller bag or something on planes. And honestly it's great. I use this all the time now. It's a backpack that's like decently large but not so large that it's inconvenient. It's basically exactly the size of a carry on luggage on planes.
01:37:28.137 - 01:37:58.007, Speaker A: So I use this now whenever I travel. But I also use it like from bringing my laptop somewhere in town and I need to bring a couple of other things, just throw them in that backpack. It's large enough to carry whatever if I'm going like just. I just use it a lot. I found that the use for a somewhat large but decent looking backpack is actually pretty significant. It took me a while to find exactly this one. Like I had to go to London to get it because it's not sold in Norway.
01:37:58.007 - 01:38:26.765, Speaker A: But I don't think it matters hugely exactly which one you get. It's more of a. Having a large backpack and using that as your carry on on planes. I found pretty valuable. It is a Kodapaxi alpa del dia 40 liter. I think backpacks are definitely made for cats only. It's true.
01:38:26.765 - 01:39:13.103, Speaker A: I think those are the things that I can most easily think of. Yeah, if I. If I think of any others, I'll. I'll raise them. Needs more air in this room. Love low level programming. What project should I build to get a job in systems program with Rust, like OS or compilers or tools.
01:39:13.103 - 01:40:00.917, Speaker A: I'm completely beginner, high school graduate. You know, I think if you want to work with systems programming in Rust, you've chosen the right language for sure. I think a lot of the uses for Rust are for systems programming. It just depends on how you define systems programming, right? Like is systems programming. Are you going to count web services as systems programming? Because then you've got a lot to choose from. If you also include things like cryptocurrency stuff as systems programming, then most of Rust is systems programming. I think realistically, if you're talking about low level programming like in embedded stuff, I think one of the good ways to start here is to get a little like ESP32 or a raspberry Pico or something and just start fiddling around with it.
01:40:00.917 - 01:41:14.025, Speaker A: Start to work on the improvements to the open source tooling around them in Rust, for example. Because I think for the companies that care about this sort of low level embedded programming especially, I think a lot of where they look for people that might be promising is in the people who either maintain, own or contribute to those underlying crates and tools. If you're talking about low level programming more in the sense of like concurrency, data structures, algorithms, I don't have a great answer for you there. There aren't, as far as I know, a lot of companies where that is the thing that they do as a company, they might have needs for those skills, but I don't think they usually come out and say, you know, we're hiring a data structures person, that that is less common. I think it does help to build, you know, take for example, research papers that are proposing new, new algorithms, new data structures and implement them in Rust. That's both a really good learning experience for you, but it's also a good way to get in touch with the people, the academics doing that research and also to potentially provide value to the community. Because you're building now a sort of state of the art thing that you're giving the Rust community.
01:41:14.025 - 01:41:59.595, Speaker A: So that can be a good way to practice those skills. It's not necessarily a way to get a job. Like, I think there are fewer companies out there just looking for interesting and cool data structures to someone of written and gone. Like we should hire this person. There might be some, but I think they're further and farther between. So I think what you do is you build these things and then you use them as a thing on your resume, for example, and then you look for jobs where you think they're likely to have problems that overlap with interesting algorithmic solutions or interesting concurrency solutions or problems. And then you specifically try to apply for those and include that experience and highlight that experience as being relevant to what that company probably needs.
01:41:59.595 - 01:43:42.915, Speaker A: What is your rule of thumb when it comes time to decide if you use Async Rust or not for a project? I realize I start every answer with the rule of thumb I think I use is for anything that does IO, I tend to make it asynchronous. So this being things like, you know, something that has to speak some kind of Internet protocol like IMAP or has to interface with, you know, a web service of some kind or is a web service of some kind. I think Async Rust is basically the way to go there. The places where I don't go to Async Rust are where there's no internal IO and I don't expect the primary users of the library to be async so an example of this would be, for instance, the crate called Flurry, which is a port of Java's concurrent hashmap. So that crate, there's nothing IO related inside of it, there's no asynchrony inside of it, and the interface to it is all lock free anyway. And so even if you had async code using it, it wouldn't need to have an async interface, same like the standard library hashmap. There's no reason for its interface to be asynchronous.
01:43:42.915 - 01:44:42.677, Speaker A: The reason I say you have to think about what your callers are going to be doing is because if you take a library like bus, so bus is a broadcast channel, so you send on the channel and all of the recipients receive that event. Here there's actually use for building both a synchronous and an asynchronous bus, because if you have synchronous code, you can't call asynchronous functions. So you would need an asynchronous, a synchronous library. But if you're writing asynchronous code, you might want to asynchronously wait for the next thing on that channel. And so you actually need both interfaces. And then the question becomes, well, is it reasonable to have a single implementation that can both support Async and synchronous use cases? The answer to that is usually no. Usually you actually want different implementations because the way you would do it asynchronously is meaningfully different than the way you do it synchronously.
01:44:42.677 - 01:45:53.745, Speaker A: It's not as though you just need to sprinkle a bunch of async and await and now the code works fine. You would actually need different mechanisms internally. So you do have to think about what the use of server, your library, are likely to need from the library to decide whether it needs to be async or not. It's not purely a matter of what the library needs internally, although often like again, if internally you need to do a bunch of IO, and in particular if you need to do concurrent IO like waiting on concurrent events, then async is the way to go there. I don't know if it's as much of a rule of thumb as a sort of set of guidelines. There is plenty of books and other resources about design patterns in object oriented programming. Can you recommend anything about design patterns that are specific to Rust? So there are micro design patterns and macro design patterns on the micro design patterns like, you know, guidelines or best practices or IDIOMATIC recommendations.
01:45:53.745 - 01:46:56.705, Speaker A: There are a couple of tools, so Clippy obviously does some of these micro things. There's also, if you look at the Rust API guidelines, I'll see if I can dig up a link here to share in chat and I'll put it in the video description as well. So the Rust API guidelines are also a good thing I think to use here. But again they're more micro oriented, a little bit more about, you know, how do you structure an API rather than how do you structure the code. How do you implement something using a design pattern? If you want something that is more, you know, how do you solve this class of problem? In Rust there aren't a lot of great resources. So some of the, some of the Rust books give some guidance here and there, but there is something called the Rust Design Patterns book. Patterns book, let me dig that up here.
01:46:56.705 - 01:47:42.245, Speaker A: And I'm not talking about the published book, although there is one of those too. So there is this thing is the one I was thinking of. So this is on the Rust Unofficial GitHub page and it is a book on a lot of different design patterns that you might want to use in Rust. I haven't read through this very deeply myself, but I know that people do find it useful for like things that you might want to do. It also has a list of anti patterns that are sort of documented here and maintained over time. There is also this book from Manning called Rust Design Patterns. This one I haven't read myself, but I've heard decent things about.
01:47:42.245 - 01:48:25.205, Speaker A: So again, these recommendations are both with sort of a. With a pinch of salt but, but there we are starting to see some of these resources being developed for us as well. Decrosting Leptos and Bevy ecs I don't think I'm going to be decrossing either of those anytime soon because I haven't used either of them myself. And so I'm not the right person to do the decrusting of them. I'm not opposed to someone else doing it. It's just that I think in order to do a good decrusting you have to know the library inside and out yourself. You have to use it a lot.
01:48:25.205 - 01:49:15.079, Speaker A: You have to have seen a lot of the, the traps, the pitfalls, the best practices, the patterns, the common confusions. And because I haven't used either of these basically at all myself, I can't be the person to go through those because I haven't had those experiences. Maybe one day I will have and then I'll happily be decrust them, but I don't think those are ones that I will be decrusting myself anytime soon. Do you watch YouTube? What's your favorite channel? I do watch YouTube. I don't watch YouTube a lot for education purposes in the sense of like learning Rust for example. Don't do a lot of that. But what I do do.
01:49:15.079 - 01:50:02.475, Speaker A: Let me see if I can figure out here. How do I easily find this list? You know, why is there not an easy way to see the channels that I subscribe to manage. Aha. Found it. Okay, so here's a list of YouTube channels that I think are interesting for various reasons. The BBC Archive so the BBC archive is fascinating because what they post a bunch on YouTube is like really old BBC clips that they've now cut and released. And some of them are like technology oriented.
01:50:02.475 - 01:50:39.101, Speaker A: Some of them are like let us talk about the introduction of the modem or like the invention of the emoticon. Like but. But truly clips from that time that are posted now and they're just really fun to watch sometimes they're really interesting deep dives about the kind of concerns and thoughts and opportunities people saw at the time. So I think, I think that's. That one's really interesting. I follow CGP Gray CGP Gray makes these really fun deep dives on super niche things. He just sort of.
01:50:39.101 - 01:51:19.259, Speaker A: He basically searches for rabbit holes and then dives really deep, does a bunch of research and then makes really good videos about what he finds. So highly recommend that one. For sort of more fun things. I follow Daniel Thrasher makes I think pretty entertaining videos. I follow there's a YouTube channel that I think is fascinating on how to make movies, but more like cinematography type things that sadly I don't think they're making videos anymore. But they. They basically made all the videos they wanted and then stopped, which you have to respect them for.
01:51:19.259 - 01:52:00.179, Speaker A: Called Every Frame of painting. Really good YouTube series would recommend it. Similarly, there's a channel called Ian Hubert, it's @ianhubert2 that talks a lot about how to do like 3D rendering and stuff. That is just a space of problems that I've never thought about but I think are really interesting to learn about. They also haven't made a lot of things recently. For video game related things I follow Joseph Anderson who does like really in depth video game reviews and critiques. He makes really good stuff.
01:52:00.179 - 01:53:01.307, Speaker A: I think, I think the stuff he produces is really good. Similarly there is Razbuten R A Z B U T E N who also does a lot of Videos about video games and about the making of video games and playing video games and the sort of experience you're aiming for. Much more sort of meta about video games and Summoning Salt which is about people who do sort of speed runs of video games on the history of those speedruns that I think is really good. Other than that minute Physics I think is really interesting for like learning small physics things with really well made videos. XKCD now has a YouTube channel as well that has similar kinds of videos that I think are pretty interesting on the sort of what if series. Numberphile is interesting if you care about math and numbers. There's also Veritasium that does a lot of like general science.
01:53:01.307 - 01:53:40.595, Speaker A: I guess I would categorize it as of sort of learn about a thing that is science related. That's pretty cool. Another humor thing is Aussie man reviews things. Pretty entertaining. Ryan George I think is pretty entertaining. I do randomly watch like car restoration videos because I think they're interesting. I don't particularly have an interest in cars, but I got hooked on the video game car mechanic simulator for a while and that was in part because I was watching these videos on car restoration and was like this is kind of interesting.
01:53:40.595 - 01:54:26.715, Speaker A: I want to know how these things work and it's sort of really about understanding the underlying principles of things that I think is fascinating. And Tom Scott is also great for sort of science based videos and learning things. Two Minute Papers is pretty decent, although I find them a little bit annoying. Sometimes they're a little over the top, but some of the things they discuss are pretty interesting. Slow Mo Guys I think is also interesting. Not really in that they teach you science, but it's interesting to watch things happen in slow motion. Vsauce is also a channel that's like this sort of learning random little facts that I think is interesting.
01:54:26.715 - 01:55:22.705, Speaker A: And I think that's mostly my list. I have a bunch of other things here, but there are sort of random collections that aren't necessarily that interesting. Okay, have you considered doing code review style live streams? Some repositories chosen from the public as you please on the stream would be about refactoring some part saying how the person could have done some part of the code better or other ideas. I think learning from others mistakes would be valuable as well. I've gotten this request a bunch of times and I'm not opposed to doing this, but I do have some reservations. One of them is when reviewing other people's code. I think sometimes it comes across as criticism in a way that it's not intended.
01:55:22.705 - 01:56:12.381, Speaker A: Right. If the goal is for other people to learn from mistakes that are identified, then that still is a, you know, that person might feel as it as a critique of their ability to program when. When I don't think that would be the intention. And so I think you kind of need to do it with the explicit consent of the person whose code you're reviewing. And that gets particularly complicated in open source projects where there are a bunch of people who might have written that code. And I worry that if I do a review of something I'm like, oh, this pattern is really bad, or this code is really bad and talk about why, then people go and blame the code and go, oh, that came from this person, they're doing a terrible job. And it's very easy for vitriol to come out of it, which is really not my intention.
01:56:12.381 - 01:57:21.997, Speaker A: I don't think it would come from me, but it might come as a sort of knock on effect. And I worry about that and having people pile on, which very quickly happens when you start doing critical code review. Even if someone is willing for me to critique their code, I think selecting code where we're likely to get a decent number of interesting observations out of it is pretty hard. And I think for this to be to really work well, the streams would either need to be very long, which they might have to be regardless for me to truly explore the trade off space and be like, okay, this is suboptimal, but I understand why they did it. Just because of this other constraint elsewhere, it's very easy to do what I've heard termed as context free reviews where you look at the code in isolation, you go this is bad. But in reality there's a bigger reason why it's actually the right call and you miss it because you don't have all that other context. And so to really do good code review, you can't just look at the code that's in front of you.
01:57:21.997 - 01:58:25.305, Speaker A: You need to look at the whole problem space, you need to have thought about the problem space, you need to look at the other related code. And that means that either you need to pick a small crate where you can understand the totality of it, or you need to pick a large crate that you know decently well and you have the context and those there are fewer and farther between where I have a lot of the context and I haven't already reviewed that code. And so, you know, if someone just comes to me with a project, then either it's too small or it's too big and the sort of Goldilocks zone zone in between. I think it's harder to find where you also have the consent of all the people involved. And it's large enough that there are interesting trade offs, but small enough that it can be reasonably done in a stream and also has interesting things to look at. And I know that without having to look at it. Because if I go and check out the crate myself before I start the stream, then now I've looked at the code, which means that my review after the fact won't be as impromptu as it otherwise would be.
01:58:25.305 - 01:59:24.275, Speaker A: And you know, this is a thing that I do in most of my videos is I go in without preparing, right? Because I think there is a lot of value to be gained from observing me work through a problem myself for the first time, work through the reasoning, the rationale, getting stuck figuring out how I learned the relevant context. And if I have to go and read through the whole crate first to build my own context before doing a stream on it, you lose out on experiencing that aspect of it. And unfortunately me going and looking at the code is one of the primary ways in which I could evaluate whether it would be a good crate to review. And so there's this like difficult set of things that need to align perfectly for me to pick something to do a code review of. That doesn't mean that it is impossible. And I do. I have registered the fact that a lot of people want this.
01:59:24.275 - 02:00:13.797, Speaker A: It's just I'm still not quite sure how to do it. And I don't have a, I don't have a great way to select a crate is, I think a big part of the problem. It could be that the answer is take some, you know, medium sized crate that I've used but not looked at the code for, so I know it's useful. I also know maybe from the API that there are some things that feel weird. Ask the author of it, sort of look at whether this is a library that's widely used, ask the author whether they'd be willing for me to do it, and then maybe that's a good candidate. But it's mostly a matter of selection. I think there's no, there's no lack of people who say please review my code.
02:00:13.797 - 02:01:20.805, Speaker A: But I think doing a public scrutiny is quite different from hey, can you check that my code is pretty reasonable? And this is why I like doing building code from scratch is because I think you run into a lot of these considerations for what is good code, what is bad code, but you do it in a more organic way. Where this represents how you would write software yourself is you're writing a bunch of code yourself from the beginning, and it gets many of the benefits, although admittedly, not all of them. Okay, do you still program at your job or is it mainly management or quality assurance? Quality control. I still do a lot of programming. I do more at Helsing than I did at Amazon. And that. That is by choice, I think, to a large degree.
02:01:20.805 - 02:01:47.923, Speaker A: I. I really like programming. I. And I know that I would be quite sad if I spent very little of my day writing code. It is both something I enjoy and something I think I'm pretty good at. And so it would be sad and also, I think, wasteful to have me not do a bunch of coding. I do think that the kind of coding that I do and what I spend the rest of my time on has changed.
02:01:47.923 - 02:02:44.475, Speaker A: Sort of the fraction of time that's spent coding. I think I get a lot of mileage and impact out of mentoring people, educating people, doing code reviews of other people's code at. At Helsing, and sort of helping guide people in their initial system design, in scoping what problem to even solve. Which things are worth doing now, prioritization. Like, which things should we work on first? The sort of. How do we structure this Rust code? Doing a sort of deep dive with a team that's built a code base themselves and then go in and say, let's do a. Let's spend like three hours just doing a full survey of what you've built so far and look at ways in which we might be able to do systemic changes that significantly improve the overall, you know, results of or experience with working in this code base.
02:02:44.475 - 02:03:11.895, Speaker A: And so those things do tend up. Tend to take up more of my time. And I think it's a very worthwhile use of my time. And I enjoy it. I would not enjoy it if it was 100% of my time. If I were to estimate, I'd say it varies from week to week, honestly. But let's say 50, 50 on code versus other things.
02:03:11.895 - 02:03:57.611, Speaker A: I think that's at least on the ballpark. But I think even for the code that I write myself, there is a particular segment of or kind of coding that I focus on. And it's the coding where I think my particular skill set and experience are most warranted. Right. There's a bunch of code that needs to be written at Helsing, and this is true at any company. Right? There's a bunch of code that has to be Written and a lot of that code, any competent engineer could write some code requires or maybe a decent chunk of code requires some domain expertise. So like not all the engineers at the company but like some slice of them could work on it.
02:03:57.611 - 02:05:28.885, Speaker A: And then there's some code where this requires that like you know a very specific set of things or you're really good at optimizing for a particular set of conditions where you need to have a lot of context from like very not archaic knowledge but like a niche knowledge in order to solve the problem well. And so I generally end up working on those kinds of things where like trying to figure out what I can say here that is still useful. So we've been doing a lot of work on some stuff that has to do with CRDTs which are conflict free replicated data types in distributed systems. They're very useful for operating in environments where you might have like disconnected things or things happen out of order, concurrent edits and the like. And I happen to have done a lot of data systems in the past, a lot of distributed systems in the past, a lot of. Not a lot of CRDT specifically, although I implemented a bunch of CRDT stuff both in the past and currently. And there are some really thorny corner cases in CRDT code and distributed systems code where you need to have a lot of context, both about distributed system behavior and distributed system testing, but also about specifically CRDTs and our implementation of CRDTs where the set of people who can write this code and probably get it right is like two people at the company, maybe just me.
02:05:28.885 - 02:06:33.545, Speaker A: And so I try to be very conscious about where is the right place for me to spend my time. Sometimes that aligns with the highest priority things for the company overall or for sort of some subset of the company. But sometimes it's like I know that this will be a thing that in six months we need to have done and that means I have to do this work sometime in the next six months. I'm going to choose to do this one now, even though it's not needed for three because it unblocks other people doing things. But that means that it ends up being less of a. I get assigned tasks that I need to code and instead I look for the places where my coding knowledge is the best applied. And I think this is somewhat representational of as you get more senior, as you develop more sort of depth knowledge or context for a particular set of things, you start searching out the places where you are most valuable, you're most impactful, you're Most, most uniquely suited to solving this particular task.
02:06:33.545 - 02:07:31.765, Speaker A: Does that answer the question or do you have sort of follow up questions on this? On do I still write code for what's worth? I don't, I don't do too much management so I do have some people who are sort of my direct reports but they are. That doesn't take up too much of my time and I still think of that as part of engineering. Right. Because I'm sort of more of a. The amount of time I spend with those people on like specifically like people manage more like HR things is relatively small and it's more about like technical and professional mentorship which I don't think of as management even though maybe it is. And it's also something that I think is really interesting and valuable and important. CRDTs sound interesting.
02:07:31.765 - 02:08:21.921, Speaker A: This is stream worthy. CRDTs are really interesting. I don't know that I could do a stream on the things I'm doing with them for work. Maybe it's complicated, but maybe a deep dive into CRDTS separately could be really interesting. Like I could do a sort of educational stream on CRDTs maybe. I'd love to hear your perspective on the difference moving from a senior engineer role at Amazon to a principal engineer at a smaller company. Would it be the same experience at Amazon? So I think my move from Amazon to Hellsing where at Amazon I was sort of the upper end of a senior engineer and Amazon doesn't have staff engineer titles.
02:08:21.921 - 02:09:31.459, Speaker A: So the next thing up from senior is principal. And the way to think about this is roughly that the sort of the senior engineer role is sort of split into or if you were to take the staff engineer positions at like Google or Facebook or something and map them to Amazon, they would sort of map into the upper echelons of the senior engineer role and the lower echelons of the principal engineer role. So as a principal or as a near principal engineer at Amazon, I think my move to Helsing principal engineer was I do a lot of the same kinds of things. I think they actually map not super cleanly but somewhat. They're somewhat similar. The biggest differences are I do more coding at Helsing that I think I would do as a principal engineer at Amazon. And the other big difference is because Helsing is a smaller company, I feel like I have more impact because there's just like I'm closer to or even have more decision making power.
02:09:31.459 - 02:10:29.093, Speaker A: Like at Amazon. If I wanted to effect some larger change to how Amazon does engineering that's like I Don't want to say it's impossible, but it's really hard because it's such a big organization. Whereas at Helsing, my direct manager is the cto. So I'm very closely connected to the way that technical engineering of the company runs and works. And that means that if I have ideas for something that I think could meaningfully improve our engineering. And when I say engineering, I don't just mean, you know, how we write code or how we write tests, but it could also be things like infrastructure, how we, how we make our people be successful, how we grow careers, how we do leveling, how we do performance evaluation, how we document changes, whatever it might be. The path for me to put those ideas into effect, to test them out, to potentially have them be implemented, is much shorter.
02:10:29.093 - 02:11:29.201, Speaker A: So I feel like I have a more of a handle on being able to make things in my eyes better than I. Than I ever did at Amazon. Okay, do you do any workouts or exercises? I wish I could say yes to this question because I think the correct answer is yes and I. Or the, the ideal answer is yes and it's what would be good for me. It's something that I think about like every other day that I should get better at and then don't. And I don't even have a good answer for why. I think the closest I get to an answer for why is I have so many other things I would rather spend my time on, that workouts and exercises are just not where I want my time to go.
02:11:29.201 - 02:12:22.815, Speaker A: And I know all the counter arguments to that, right? Like, okay, it's going to make you healthier longer term, so you get to do more of those things longer term. They don't actually take that much time and you probably still already have downtime that you could have spent on this. And you know the claim that you get more energy out of workouts and exercise, you feel better and as a result you're going to be able to more to have more productive time you could spend on those things. I know all of those things I can quibble with whether I think they're true or the degree I think to which they're true. But like, it is something I should be better at and I'm not. I do do some like, stretching exercises somewhat regularly. So this sort of, there's like this, this yoga thing called the Sunrise Greeting or something.
02:12:22.815 - 02:12:57.469, Speaker A: I forget the exact name for it that I try to do every day because, like, I end up with like, you know, I, I sit a lot and so I need to move and, and stretch my muscles and the like. It's just like important for my well being. I'm getting older too, right. And so I try to do that basically every day. I have like a blocked out part of my cal. My work calendar that is like do the stretches and I'd say I do them 50% of the time that I should, but at least that's not zero. But realistically this is something that I just, I need to get better at.
02:12:57.469 - 02:13:39.033, Speaker A: And I think part of what I need to do here is find a way to do things while I do them right. So I actually think like you know, getting a walking pattern on my desk for example, I think could be good. I have started biking more to get places instead of taking public transport, which I think is good for me. And I think, you know, having getting back into things that I think are fun physical activities. Like you know, I really like playing squash, I really like rock climbing and I just haven't been doing those things recently. And part of that is just finding someone to do it with and making a regular schedule with them that again I just need to do and I just haven't done. And I think sun salutations is in the name of the stretch.
02:13:39.033 - 02:13:57.061, Speaker A: Thank you. Yes. And those are all excuses and I think everyone has some of these excuses. They're not good excuses, but they are nonetheless. This is the reality of, of my life. So. Yeah.
02:13:57.061 - 02:14:28.115, Speaker A: Do you do any workouts or exercises? Yes, very few. I should be doing more is the concise answer. I suppose bouldering too I think is really fun. I do do bouldering. There's actually there's a small bouldering gym like two minutes from my house and I just don't do it because again like it ends up taking a bunch of time that I would probably rather spend on other things. But maybe I just gotta at least pick a day a week and boulder. Start bouldering just like once a week after work.
02:14:28.115 - 02:14:46.925, Speaker A: I'm just gonna do it. I just, I just don't. But I, I do like bouldering a lot when I do it. Same thing with rock climbing. I, I love climbing lead for example. But again, such a long time since last time. Collaboration with Magnus mit.
02:14:46.925 - 02:15:14.487, Speaker A: Yeah, the. I mean anytime. Sure, I, I would be destroyed. What's a crate you don't have the use for, but wish you did. You know, I, I think the, the clearest answer to this is Bevy. That's partially because I would love to build a game. I think that sounds like a lot of fun.
02:15:14.487 - 02:15:44.751, Speaker A: The log. Log article actually made me go. This makes me really want to try it, to experience some of these pains myself. But also I think Bevy is a big part of it that I've seen that there's such a community around this, such a drive for it, there's so much excitement for it and it's just not relevant. Unless you're building a game, right? And I'm not building one and therefore I'm not using it. And I want to. I think there are a bunch of interesting patterns and use cases in there that I'm just not otherwise exposed to.
02:15:44.751 - 02:16:31.185, Speaker A: ECS being an example that would be really interesting to gain experience in. And yeah, I think that's the answer to the question. I think there's another sort of set of crates here are around embedded development of like building something for like an ESP32 or just in general, like controlling motors and the like directly from a Raspberry PI. I've done a little bit of that, but I would love to explore that more. And this is where this like cat feeder I'm thinking of would be a really good way to explore those. So maybe that is my path into the embedded side of things. But I think the most obvious answer that comes to mind is Bevy.
02:16:31.185 - 02:17:21.301, Speaker A: Oh, for the log log article, it's. I put it in chat earlier, but I'll put it here again. It is this one. Rust for data engineering the current state, lack of Rust jobs future career perspectives how do you think Rust adoption by companies in terms of data and AI changes in the future? Python is now the de facto standard language for data AI, but there are many powerful tools developed in Rust for data engineering, like Apache Arrow, Data Fusion, Pollers, etc. Tools like Pi03 and Maturin help to create bindings to Python, making it easier to use. I work as a data engineer and use Python and Rust. I'd love to use Rust a lot more.
02:17:21.301 - 02:18:20.114, Speaker A: Do I need to consider switching from my current data engine engineering role to a Rust developer role in some other company? You know, I think data engineering and analytics is a. Is a really interesting space for Rust because I don't think that Rust is the right language to use exclusively in that domain. I do think it's a great utility in that domain. I was actually there's a podcast called Expentia Podcast Latam Data. I just want to get the name of the podcast. Right, the Data Latam Podcast. Ah, here.
02:18:20.114 - 02:19:06.613, Speaker A: Okay. So this is the Data Latam podcast, the Latin American data podcast that I actually did an interview with just the other day. It's not out yet, I think here, I'll send it in chat. And I was on this podcast being asked specifically about the use for Rust in data engineering and data analytics. And to sort of preview my answer there, I think Rust is really good for two things. In data engineering, when you have a bunch of data and you know what you want to do with it. So you want to, like, you've already done the experimentation, you've come up with the thing you want to run and now you just want it to run fast on lots of data.
02:19:06.613 - 02:19:48.977, Speaker A: Then I think it makes perfect sense to write that logic in Rust and then just churn through it and run it sort of on a regular basis. Rust works great for that. It also works great for. And this, this gets back to the thing we were talking about for games for you have a well defined like algorithm or component like and this is where I think Apache, Arrow and Polars and data fusion are good examples. Like you have an algorithm or data structure or something where that thing is well defined and you have a. You just want to implement that thing in the most high efficiency way that you can. Rust works great for building that component, for stitching those components together, for exploring the data, for doing the sort of investigative work, for figuring out the insights you want into the data.
02:19:48.977 - 02:20:40.119, Speaker A: Rust is not great there, and I don't think it ever will be. It's not designed for that kind of sort of rapid iteration, quick feedback loops type of work. But that doesn't mean Rust doesn't have a space in data engineering. I think it, I think the way that Rust succeeds in data engineering is as a companion to another language like Python, like R, like Ruby, maybe, if that's your Jam or Perl, but like some kind of combination of having an interpreted language. With Rust powering some of the heavier workhorses that are more well defined, less churny, less iteratively less interactive. I think that is the sort of dream combination here. So if you're currently at a company that uses Python for data engineering, I don't think you're in the wrong place.
02:20:40.119 - 02:21:41.445, Speaker A: I think the goal should be to find what are areas of your current domain where Rust could replace some of the Python because that Python code is not regularly changing. It's not a place that people have to fiddle with. And so you could then buy in some of the efficiency for Rust for that part, but not necessarily have to accept the downside, the rigidity of Rust in the other parts that do change more often. And this is where Tools like, you know, pi03 and maturin comes in because they allow you to bridge that gap between the Python world and the Rust world fairly gracefully. So I don't think you need to sort of switch companies to a company that does data engineering entirely in Rust, because I don't think that should be the goal. I think the goal here should be to find that, that sort of not, not parasitic but like symbiotic relationship between Rust and Python in the space or, or Rust and R, or Ruston, whatever language you want. I mean, arguably.
02:21:41.445 - 02:22:16.525, Speaker A: Oh, Julia would be another example here. Next. Actually, let's pause here for a second and do another round of voting because I think. So we have about, let's say half an hour left. So I want to make sure that the last half an hour is spent on the questions that people are actually the most interested in. So have a read through the current list of questions I'm going to ask you. Don't propose too many new ones.
02:22:16.525 - 02:23:09.865, Speaker A: Have a read through the current list of questions. Vote for the ones that you think are interesting. Make sure to check the bottom of the list because that's where all the new questions are going to be. And let's sort of do a quick pass everyone on the questions. I'll do the same and vote for the questions you actually want the answers for in this sort of last, last half an hour of the stream. So I'll give everyone a little bit of time to do that and again, I'll do the same. And if you're watching this recording after the fact, I'll put a chapter mark in the video so you can skip to the part where I start answering questions again.
02:23:09.865 - 02:25:18.925, Speaker A: I love how there's a question about whether I could do streams on go. I'm probably not going to do streams on Go. I don't actually think there are good arguments for using Go basically anywhere at the moment. All right, I think I've almost given enough time. There are a lot of interesting questions. Man, I wish I just had infinite time. Okay, great.
02:25:18.925 - 02:26:05.495, Speaker A: You can keep, keep voting on things, but I'll start from the top now. All right, what is engineering blogs that you follow? So here I'm actually going to. I'm going to disappoint and say that I don't follow a lot of engineering blogs. I tend to instead follow people on. I mean, used to be Twitter these days, more so on. More so on LinkedIn actually of all places. And then I have some people that I follow on more the sort of Patreon side of things.
02:26:05.495 - 02:27:08.355, Speaker A: And the reason I follow those people is not necessarily because they write a lot of things themselves, but because they surface interesting stuff that I then want to read. And so a lot of the reading that I do is not really per blog, it is per person who recommends them if that makes sense. Let me see if I can dig up actually my pocketbook reading lists and see if there are any good patterns that I can recommend from there. Let's see here. Saves. Okay, a couple of examples of things I guess that's not really engineering. So one thing I really like is philosophy who is a GO developer, does a lot of work on the GO cryptography stuff, has a newsletter called Cryptographic Dispatch.
02:27:08.355 - 02:28:02.073, Speaker A: Philocratic Dispatch. Let me see if I can find you the here and it's also doing something really interesting where he's basically trying to work full time as an open source maintainer for a lot of the GO crypto code. And I think his cryptographic Dispatches are really interesting. They're usually very tailored to either open source maintenance or to cryptography work, but I find them really interesting to read. They're really deep dives about things that I don't otherwise know a lot of things about. So I find that just super interesting. Next thing that I find interesting is the the tech blog for well I guess Nicos.
02:28:02.073 - 02:28:33.675, Speaker A: I end up reading a decent amount. This is small, small cult following. Same thing with Boats blog I think is really really good. So this is just without Boats I think is the link to their their blog. They write really good articles, long form articles about about Rust specifically that I think are fascinating. There's also another engineer that I follow called Dan Liu. So Dan Liu does a lot of writing about.
02:28:33.675 - 02:29:27.685, Speaker A: Here let me send it in there. Dan Liu does a lot of writing about sort of engineering more broadly like as a discipline and I I just think they write super fascinating articles about sometimes about code but very often about like how we work as engineers and what works and what doesn't. I really liked. So David Tolnay had a sort of blog in the form of a crate for a while but I think that ended up being sort of deprecated or at least hasn't seen any updates for a while. So this is just docs RS Dtolnay but hasn't been updated for a while. Hasn't been any new things added to it. I also really like Julia Evans blog.
02:29:27.685 - 02:30:16.095, Speaker A: So this is Julia writes about here. This is an example more about like both introducing technical concepts in fun, interesting deep ways but also writes about how should we be as engineers more on a social and personal level that I think are really good. Like this article that I linked about getting your work recognized writing a brag document. I linked that in chat. I'll link it in the video description as well. The blog for nico is just smallcultfollowing.com baby steps and boats is just without dot boats I believe.
02:30:16.095 - 02:30:51.025, Speaker A: Onwards from there. I here too I have a bunch of just like blogs where there's one article that's really good and I haven't read any of the other ones. I have a large collection of just that kinds of things. So this is. There's an article called Being Glue that is real good and I identify a lot with. I haven't read anything else from this person but Being Glue is a really really good article. I'll link that in here too.
02:30:51.025 - 02:31:36.545, Speaker A: Matt Cloud's blog I think is also really good. Matt Clad writes, doesn't write super frequently but whenever they write I find it interesting. They for example have an article on Pratt Parsing that I think is is really good. It's from like 2020. What else do we have here? Oh, Ralph Young's blog. So Ralph writes a lot about unsafe rust and about the sort of formal semantics of rust and Miri. Super interesting stuff.
02:31:36.545 - 02:32:24.437, Speaker A: Always very long and in depth articles but they really give you like a much better insight into the more formal better mental models to use for rust. Also pretty much anything that that Aria wrote writes I think is great. Let me see if I can find Aria's blog. I think their blog is called Fault Lore here. I think it's also pretty good. What else do we have? Faster than Lime of course I I love Amos's articles. I think they're really good.
02:32:24.437 - 02:33:05.963, Speaker A: I don't read all of them. Some of them are very long and not necessarily only thing I care about but the ones I care about I. I enjoy it enormously. That's just faster than lied me. Let's see if I can look at my ha favorites. What else do we have here? Oh yeah, Evan Miller. Don't know if Evan still writes, but Evan Miller had a bunch of articles on sort of applied math and statistics and AB testing and the like.
02:33:05.963 - 02:33:56.345, Speaker A: And in particular they had a bunch of articles on how to do ranking and sorting that I think were really good. Here's one example. I'll. I'll put it on here. I think those are the sort of most immediate ones I can find. I'm sure there are more, but none that come to mind it immediately. Oh, there's I guess there's one more which is.
02:33:56.345 - 02:34:28.357, Speaker A: Although I haven't read this person in a long time, but I remember them being pretty interesting. This is. What's their name? Where do I find it? John Rager has some interesting articles over here. Anyway, I think I've gone through enough things now. There. There are so many more. But.
02:34:28.357 - 02:35:11.113, Speaker A: But again, I don't really follow a lot of blogs. I just. These are the ones where I've happened to have found a lot of interesting articles on through, you know, various people posting about them. Okay, what is currently the most exciting company that is using Rust? I don't know that I have a useful answer to that. There are a lot of companies using Rust these days and I'm sure many of the ones. Many companies that I think are exciting may be using Rust without me knowing about it. You know, I.
02:35:11.113 - 02:35:44.935, Speaker A: I think there are maybe some broad categories here. Right. Like, I think what Helsing is doing with us is pretty interesting. It's not so interesting in the sense of Rust specifically, but it is interesting in the sense that this is an industry where bringing in a new language is pretty challenging. And it's interesting that Helsing is trying to do that and I think succeeding at it. Other companies that come to mind here are. I think some of the stuff that Google is doing with Rust in the kernel is pretty interesting for Android.
02:35:44.935 - 02:36:24.399, Speaker A: I think some of the work that there's a company called. I don't remember what the company is called now. Why is this slipping my mind? Maybe they're just called Zed. Like the company that makes the Z editor are building like that whole editor in Rust. And it's sort of a. I think I've heard it describe as a. The goal is to build a sort of multiplayer editor, like a thing that inherently supports multiple people collaboratively editing in that system.
02:36:24.399 - 02:37:05.791, Speaker A: And I think it's a really cool use of Rust in an area where we have a bunch of notions about what an editor should be like. And this is kind of different. I also think that the work that let me find the work that. Oh my. A the work that. That Ember Studios is doing with. With Cargo Audit and is it Embers? It is Ember Studios.
02:37:05.791 - 02:37:33.745, Speaker A: Right? I'm not misremembering. Yeah. With a lot of the work that they're doing in the ecosystem to improve the ecosystem independently of what they're doing with Rust internally for game development. I think that's also really cool. But ultimately I don't think that there's any one company that Sticks out to me here as this is the one that is most interesting. I think there's just a lot of them. Them.
02:37:33.745 - 02:38:12.669, Speaker A: I think there are a lot of companies are doing interesting things with Rust now. And I think in some sense it's not important that it's Rust, we just care more about it because it's Rust, because we care about Rust. But Rust is not important in the thing they're doing. They're just doing something interesting and happening to be using Rust. Enums or traits okay, so the actual question here is enums or dynamic dispatched through trait objects. And I think the answer to this is it depends. In particular, it depends on whether the set of options is open or closed.
02:38:12.669 - 02:39:30.531, Speaker A: So enums have the advantage that you can exhaustively enumerate all of the possible all of the possible variants, and then you don't have to deal with trait objects anywhere, you don't have to deal with object safety anywhere because you just hard code all the types all the way down. And then you have to write a bunch of sort of wrappers that, you know, calling this method on the enum dispatches to that method in variant one and that method in variant two. And it can be, you know, if you have a bunch of things that are kind of different but can kind of behave the same, then enums can be a way to group them together and let you create a vector of them, even though some are of one type and some are of the other. Trait objects with traits lets you do the same thing. You can take a type and course it into a more general type that has a set of methods, and now you can have a heterogeneous set of underlying types be stored as the same set of, let's say, in a vector. So on the surface, you could sort of think of them as doing somewhat similar things. Enums require more manual effort to implement, but they are a little more flexible in the sense that they don't require things to be object safe.
02:39:30.531 - 02:40:38.845, Speaker A: However, I think they're slightly slower because I think dynamic dispatch is a little bit more optimized than the sort of function with match model. But the other reason is with enums, or the other thing that's problematic with enums is that you have a closed set. So when you define the enum, you have to enumerate, as the name implies, all of the possible variants, all of the legal types that you can have be under that sort of enum hiding type. With traits, you don't have to do that. You can define a trait and anything that implements the Trait is allowed to be a part of such a sort of trait object collection, for example, because anything that implements the trait can be turned into a boxed in of that trait and so it can be interoperable with all the other things that implement the trait. And because people can implement the trait outside of your crate, you don't ever have to fully enumerate all of the things, all of the types that implement that are allowed to be used in the setting where that trait object is used. The downside of course, is that now your trait needs to be object safe in order to treat things this way.
02:40:38.845 - 02:42:02.343, Speaker A: So ultimately it's not one or the other, it's it depends on the use case. And sometimes you actually want to constrain the set of types that are allowed to be used in a given setting, in which case you might choose enums over traits for that reason. But I think this is one of those think about the actual semantics you want and I think my rule of thumb here would be that if the trait would be object safe and it's valuable to allow the the set of types to be open, then use traits otherwise using them. Sorry, Embark Studios, not Ember Studio. Where did I have Ember Studios for Embark Studios? Will async traits be object safe from the future? Yes, I believe that's the intention. Ah, here's another. Another thing that's valuable with traits as, as Alice points out in in chat, is that you can have both arc of a structure and also an arc of a DIN trait, but they're the same underlying object.
02:42:02.343 - 02:42:37.113, Speaker A: That is the thing you could do with arcs. You can't do that with enums. Okay. Any plans for a video about intrinsics and SIMD in Rust? It's a thing that I would love to cover, but this is another one of those where I haven't written a lot of SIM decode myself yet. And so therefore I don't think I'm the best person to try to give people an intro to the subtleties of how they work. I think SIMD is something that I want to make more use of. I just haven't really had a compelling use case for it myself.
02:42:37.113 - 02:43:31.909, Speaker A: That's not to say there aren't any, it's just I haven't needed to use it and therefore I haven't built the experience that I would need in order to talk instructively about it. So yes, one day, probably not for a while because I need to gain experience with them myself first. Is there are there any frameworks for making non web services GRPC via Prost or Captain Proto look foreign after things like Actix Web, they also need an extra compile step. I'm interested in low latency RPCs. So you can like for RPC, you can use Actix Web for that too. You can use like a standard web framework and have RPC happen over there. I do think that there is a decent amount of value in choosing a relatively standard protocol for doing RPCs.
02:43:31.909 - 02:44:10.879, Speaker A: GRPC being one, Captain Proto being another. You could also go the route of something like, you know, Smithy, which lets you define your protocol and use something like CBOR for, or JSON for that matter, for the. The actual transport level encoding of data. But then they dictate what the semantics of accessing it over HTTP for example is. I think if your goal is something that's low latency, it really depends on how low of a latency you mean. Right? Because low latency could also mean you don't want to use tcp, but that's the extreme version of it. Low latency could mean you don't even want to go over the network.
02:44:10.879 - 02:44:39.085, Speaker A: You actually want to go over IPC like inter process communication. So there are a lot of loaded words in the space. But I do think in general GRPC is fairly widely used in this space. Captain Proto less so. I think where I see this going is more in the sort of IDL path. Like Smithy for instance. I do actually think Smithy is a pretty good idea where you define your.
02:44:39.085 - 02:45:15.813, Speaker A: You define your interface and your types in a particular structure just like you do with protobuf files and then you can auto generate the client and the server from it. Smithy is a little bit more versatile than GRPC is. It captures more of the semantics of your API, but then it also allows you to choose the transport protocol that should be used under the hood so that it does not have to be like in grpc. It kind of has to be protobuffs. But I don't think we have a. There's not one answer here. There.
02:45:15.813 - 02:45:48.359, Speaker A: There are trade offs that differ between grpc, Captain Proto, Smithy. All of these are. There's not a. I think an obvious right answer here. Message pack is just an encoding for data. It does not give you full RPC semantics. How do you organize your daily work? Do you use to do lists, notes, pen and paper? Any specific tools? So I use todoist for things that I have to do on a sort of day to day basis.
02:45:48.359 - 02:46:31.375, Speaker A: Right? Like I need to clean the water filter for the cat's water fountain or I need to order more cat food, like that kinds of things. Or you know, I need to publish this podcast episode or edit these photos or whatever it might be that that I tend to use todoist for. For more like longer term ideas, I use Obsidian. So I have a bunch of different docs in Obsidian for ideas and different categories like ideas for upcoming streams, for example, when it comes to. And I use Obsidian also for just like jotting down. Ha. This is an interesting idea.
02:46:31.375 - 02:47:24.403, Speaker A: If that idea is sort of time boxed or I want to spend, I want to schedule some time for thinking about it, then I put it in todoist as a thing that I need to do. But that is the extent to which I'm sort of organized in this fashion. They're relatively disorganized lists, but at least I have them in digital lists now as opposed to before where they were all just alarms on my phone, which I still think has advantages, but I think this is better. The only other thing that I have that's maybe along these lines is in my calendar. So I have a dedicated calendar called maybe. And the maybe calendar is for adding events that I hear about that maybe I would like to attend. So like basically every Rust conference in the world is in my maybe calendar.
02:47:24.403 - 02:47:49.425, Speaker A: A bunch of other like board game conventions are in there. Even board game conventions I've never gone to. If you know, someone invites me to a meetup or something, I put it like a meetup in a different country. I put it in the maybe list so that at least if I'm to schedule something, I know which things I'm choosing away because they show up in the maybe calendar. Calendar. So I have a maybe calendar. It's not public, it is just my maybe calendar.
02:47:49.425 - 02:48:22.369, Speaker A: Or like, you know, if my family proposes that maybe we go to a trip somewhere, I'll put it in there until we've actually picked a date. So that is a. I found that somewhat useful. All right, I think we're going to do. We're sort of getting up on the three hour mark here. So what I'll do is I'll do a quick fire round here at the end and just get through a bunch of questions in a row without dwelling too long on them. Which might mean that I'm giving short but unsatisfactory factory answers.
02:48:22.369 - 02:48:55.323, Speaker A: But I'll try my best. I just need to prepare with water. Okay. Why did you move your NVM config from plug to lazy? Because that seems to be what people use these days and it's Also much more LUA compatible. That's why next Rust big project on stream. I don't know yet, but I kind of want to pick back up the lock. Free to wait.
02:48:55.323 - 02:49:18.987, Speaker A: Free conversion. That is the reason why we started implementing hazard pointers in the first place. I still think it'd be cool to continue that. Why do some nightly features take so long to stabilize? It's a combination of things. Sometimes the nightly features are just not well baked. Like we still haven't figured out what the right API is, or people keep using it and they're discovering more things that aren't handled by it. That's sort of the intention of things being unstable.
02:49:18.987 - 02:49:56.497, Speaker A: And the other reason is because stabilizing requires that a bunch of people are willing to say that A they're using the feature, B it's working well for them, and a sort of experience report that gives us evidence that this should be stabilized. And I think many people don't know that those things are wanted, but also many people just don't write them. And so often things are left close to stabilization but without the final thing to push it over the line. And the third reason is because it requires someone to own the feature to drive it to finalization. And dedicated time is just not a lot. There's not a lot to go around in the Rust project. There are a lot of people who are willing to volunteer for shorter periods of time and sort of here and there.
02:49:56.497 - 02:50:34.139, Speaker A: But to actually land something requires a bit of dedication and sustained effort, and that's harder to find in a volunteer basis. How do you handle errors in a complex Rust app? I've talked about that earlier, so I'm going to skip it. How many hours a day do you spend programming? So let's say 50% of work. So let's say that's four hours. And then maybe I spend an hour or two. It really depends on the day. I think it averages out to like maybe an hour or two because sometimes I spend a lot of time more programming and sometimes I spend no time programming after work.
02:50:34.139 - 02:51:12.405, Speaker A: So let's say, you know, five to six hours total in a day. What is your process for getting to grips with or understanding a large repo? Usually I. I go from the API in. So I look at what does this library allow me to do and then I start digging into the API and I start sort of viewing source and tracing the internal call graph. That tends to help a lot. Or if it's a code base that I'm helping someone else review. Like if it's Another team at my company, for example, what I will do is I will sit down with some of the engineers there and be like okay, talk me through what you've built, starting from where you think it makes most sense to start.
02:51:12.405 - 02:52:07.285, Speaker A: And usually they have a decent sense for what order in which things should be expected, explained. And so I sort of walk through it with them asking questions along the way and then by the end I understand their rationale for why they've built things the way that they have as well. Can you recommend strategies to tackle problems that seem to require self referential types? I don't think there are any good strategies at the moment. PIN is the closest thing we have to an actual mechanism here, but realistically this is something that is currently quite hard to do right. I would look at crates like Ouroboros. This is like the name of this snake that bites his own tongue, its own tail in Norse mythology, the like world serpent. But I don't think we have really good strategies for tackling self referential things if you have things that don't actually require self referential problems.
02:52:07.285 - 02:53:01.255, Speaker A: Differentiating whether they're actually needed or just would make things more convenient I think is a longer answer than a short one. Will you cover some no stutter embedded topics? For example, the Embassy Async runtime is interesting so I think this is another one where I need more experience with it before I can talk confidently about it. And I think, you know, this cat feeder might be a good, good way to get me there. Whether I'll need something like Embassy Async I don't know. I think probably not because I think the platform I'll be running on is so low power like it's going to be a sort of ESP32 type board or an Arduino board. So I might not even get into Embassy Async but hopefully at least more nosted and embedded. And the PS to that one is please make sure your cat is willing to show up next time they were on stream both of them so I'm happy about that.
02:53:01.255 - 02:53:45.895, Speaker A: Decrusting SQLX or an ORM like Diesel haven't really used them much, can't really speak to them. This gets that someone should probably decrust them but probably not me because I just haven't needed to use them. Do you have a preference for architecture style of Rust Applications Sync or Async? We talked about that earlier. Lots of people recommending data driven design so this being sort of ECS type things maybe don't have a lot of experience With ECS here, I think it really depends on your domain. I do think that in Rust programs you often need to think about how you want your data to be shared and stored pretty early on. And that tends to drive a lot of the design of your application. It tends to make your lifetimes work out in the end.
02:53:45.895 - 02:54:21.259, Speaker A: But in terms of tips for how to get better at rest application architecture, I think it. A lot of it is just experience. Like you just need to write a bunch of Rust code and then learn from failures. There's not a sort of shortcut really here for this is how you should be doing it. But I do think thinking like as you do more Rust, the ownership model and the borrower checker starts to sort of be built into your brain. And so as you do it more, you start to be able to think about the data you're wanting to represent on an abstract level and go, okay. It kind of breaks up into this way into who should own what.
02:54:21.259 - 02:55:00.741, Speaker A: And then the design of your Rust code falls out of what the ownership edges and borrow edges are going to look like. What is your opinion on Rust compile time reflection phobia? I don't think it's a phobia. I actually think a lot of people would benefit a lot from it. I think what happened was, you know, the primary driver for that work got. I don't have the right words here, but is no longer working on those things and it's not clear that anyone else is going to pick them up. It's also unclear what the appetite from the project. And when I say the project, I mean sort of the people who'd be the deciding factors here are for this kind of work.
02:55:00.741 - 02:55:33.807, Speaker A: And genuinely it's not clear rather than it's clear that they don't want it. So I would love something in this direction. I think we've had such a big setback that it's unclear what the path there is. It's also difficult. Like in Rust compile time reflection just is difficult. And so you need some pretty sustained effort with someone who has a lot of experience in that field to really drive it home. If you had to learn software engineering again, what would be your blueprint learning path? I think you start by just learning coding.
02:55:33.807 - 02:56:43.155, Speaker A: I think you need to start learning coding by having an interesting problem to work on, like find a thing that you would like to solve, like a problem that you actually run into that turns out software engineering lets you solve more efficiently that has you to be the driver for your learning. And then once you've done that, you know, once or twice you've built a couple of things that actually solved a real problem for you. Then I think if you want to become a software engineer, you need to look at a. What are other experienced engineers doing? So both look at, you know, their, their thoughts, things like either their blogs or videos where they build things live or dive into their projects and look at how they've solved problems. And then I think you need to start contributing to code bases that are well written or where at least the people who maintain it have an interest in and the time to help and the expertise and skill to give you good reviews and meaningfully grow you as an engineer. And then you need to look at jobs that you find interesting that allow you to grow as an engineer. Okay, let's do five more.
02:56:43.155 - 02:57:19.005, Speaker A: Let's check chat quickly. Okay. Nothing relevant in chat. So five things. Let's do five. What is the interview process like at Helsing? Do you need embedded systems senior engineer? The interview process at Helsing is like I think fairly standard for these kind of companies. It's like a multi step process where one of them is like a live coding interview or a take home coding challenge.
02:57:19.005 - 02:57:50.013, Speaker A: One of them is sort of a bring something cool that you're proud of and talk about it. One of them is more of a sort of system design, system architecture type thing. And then there's like a final check off. I forget the exact structure but something like that. And we absolutely want embedded systems engineers like we're hiring basically across the board. So if, if a company like Helsing is interesting, take a look at the open positions we have and like there's a bunch of, I mean I think we work on a bunch of interesting things. So if you find something that's interesting there, then apply for it.
02:57:50.013 - 02:58:29.489, Speaker A: I think the, for many of the people watching this, the deployed AI engineer or deployed systems engineer and the back end engineer roles are probably the most relevant. Okay, four left. Have you read the Art of Computer Programming? If so, would you recommend it? I have not read it. What is your favorite video game or what are your favorite video games? That one's real tough. Some that come to mind are the Return of the Obra Dinn. I thought Papers Please was also really good from the same, same game designer. I spent a lot of my hours in Civilization games.
02:58:29.489 - 02:59:02.131, Speaker A: I spent a lot of hours on Crusader Kings, like those types of games, sort of the strategy types games. I've spent a lot of time playing Helldivers. I think that's a lot of fun. I like games with a bit of humor in them. Like Monkey island games. I think those are great. What else? It's like too many to name.
02:59:02.131 - 02:59:34.287, Speaker A: I really liked playing divinity original sin 2 with my girlfriend. That was a lot of fun. Sort of playing that together and the sort of. More We've also played a bunch of Baldur's Gate, which is also fun. I think that the sort of couch co op experience is better in divinity original sin 2. Honestly, I really like sort of. I don't want to say work games, but games that are kind of like work but in an where I feel like I'm learning something.
02:59:34.287 - 03:00:07.427, Speaker A: So I think Car Mechanic Simulator was a game like this. And also. Oh, I forget what the name of this game is. Ship Breaker Hard Space Shipbreaker, which is a video game where you break up spacecraft. Like those types of games are pretty interesting. The Anno series I thought was really interesting. I've played a bunch of Age of Empires back in the day.
03:00:07.427 - 03:00:24.475, Speaker A: I played a lot of Counter Strike. I even ran some like Counter Strike competitions. Really liked Audio Surf when that was a big thing. I don't know. I'm. I'm all across the board. Obviously played a lot of the early Pokemon games.
03:00:24.475 - 03:00:44.137, Speaker A: Also like the Pokemon Snap a lot. Great game. Have not played Factorio, although I have heard that it's a game that I really need to play and I've looked at it and. And I. I'm. I'm scared of what I see. Subliminal or is it soup? Super liminal.
03:00:44.137 - 03:01:03.989, Speaker A: I think it's really interesting. Love Portal and Portal 2. Yeah, this is too many. Too many to name. No, not audio serv. Audio Surf. It's a video game where you surf the sound waves made from video files.
03:01:03.989 - 03:01:40.185, Speaker A: No, from audio files. So you give the game. It's great. Okay, three more what tips do you have to help improving engineering culture as an individual contributor, get really good at giving constructive feedback to people. Both in sort of ongoing basis where just like if people did a good job, tell them. If you think something didn't work quite right, tell them ideally sooner rather than later. When you're asking formal feedback, do so with a mindset of is this actually useful and actionable to the recipient? The same thing goes for code reviews.
03:01:40.185 - 03:02:09.575, Speaker A: Like get really good at giving people good, meaningful, contextful code reviews. So this includes things like when they did. When they solved something in a good way, point that out. Be like, this was really good. Similarly, if they write really good docs or tests, point that out. But also try to Avoid too much of like, nitpicking. Like, if you have 10 instances of like they did a thing wrong, then just highlight one of them and say, oh, maybe you can do this differently.
03:02:09.575 - 03:02:23.545, Speaker A: There are a couple of other instances. And then trust them to do those refactoring. Trust but verify. Like, check it after. But don't leave like 10 comments that are also here, also here, also here. It's just demotivating. But try to make your reviews also be contextful.
03:02:23.545 - 03:02:58.055, Speaker A: So don't just focus on like, the code as written is wrong or right. But also try to make sure you leave comments about how does this factor into the rest of the code? Like, is this the way we actually want to do this? If you're uncertain, highlight that uncertainty in your own comments. Ask them what they think. Like, don't try to come in and sort of hammer from above like, no, you did it wrong, but try to make sure it's actually a dialogue about what is the right way to solve this problem. Is this even the right problem? Have dialogues. Be willing to change your mind. So that I think is a big one.
03:02:58.055 - 03:03:38.077, Speaker A: Just having a good continuous culture of meaningful, actionable feedback because it comes back to you as well. Right? They will do the same in return. So that's one way that you can improve the engineering culture and probably I think the most meaningful one. And given this is a short, short one, I'll do it quickly. Two more Are you familiar with any formal methods, formal method tools for Rust beside just the strong typing? The main one I know of here is Connie K A N I. So Connie is a model checker for Rust. It's really cool.
03:03:38.077 - 03:04:22.911, Speaker A: You basically you annotate a bunch of your Rust code with like or it's not. You didn't even annotate your Rust code, but you specify particular input values as being like arbitrary. So you say like Connie, colon, colon, any. And that gives you back a value that meets any type. And what happens in practice is that it doesn't actually compile and run your program the way it normally would, like just with llvm and gives you a binary. But instead Connie will run your program sort of similar to how Miri runs your program, but using a special interpreter. And it will figure out which code paths are exercised, figure out how to change that input to exercise more paths, and sort of explore your program that way.
03:04:22.911 - 03:04:53.327, Speaker A: It's a very powerful tool, but it's also one that can be kind of slow. Like it's best suited for smaller subsets of a problem rather than full program Testing very powerful tool. Not fully formal, but kind of formal. Right. So it is exhaustive model checking. So you can do things like say, is it possible to generate an input that hits this panic? And if Connie says no, there is no such input, then you know that panic is unreachable and that should make you happy. So that gives you some amount of formal guarantees.
03:04:53.327 - 03:05:43.665, Speaker A: But it could also come as a model checker that's based on sort of SMT solvers. And so it could come back and say, I don't know, that is the thing you have to deal with, but it is better than nothing. I think Loom is another in this sort of category where it tries every concurrent execution possible. Not really formal, but more formal than just strong typing. I think those are probably the two main ones because Miri, I would not quite count in this regard, even though in some sense that it is right. When you think of something like tree burrows, that is trying to implement a formalism checker on your code, even if your code currently does things that are okay, but it wouldn't classically fall under the category of formal methods. Okay, last one.
03:05:43.665 - 03:07:02.425, Speaker A: What roadmap of projects and concepts would you suggest to learn for those who already have programming experience? Okay, if you already have programming experience, some of the biggest, I think ways to level up your engineering is to learn property based testing. It is a hugely powerful testing tool that you really need to get good at. What else? I would try to get really good at git. And that might sound silly, but I've. I found it really useful to know how to like navigate branches, commit stuff to a place you're going to recover it later. Using git stash Git stash dash p, Git Apply P or Git add P using like interactive rebases, you can end up getting much better utility from git, more productivity when switching between multiple different tasks in the same code base. You end up with better commits, more reviewable PRs.
03:07:02.425 - 03:08:18.185, Speaker A: You can do things like tell people you should probably review this PR commit by commit. You can use tools like Git bisect to quickly narrow down where a particular problem is coming from. I think getting good at git is actually a really valuable skill that's undervalued. And if I were to pick a third, I think this ties into the one I talked about before, which is I think one of the best ways you can become more impactful as a programmer, even if you have a lot of programming expertise, is to be able to lift through others. Right? This is you only have so much leverage with your own time because you have a very limited amount of it. But if you can find ways to delegate to others and trust them, trust, but verify, but still trust them to do work, make them better engineers. Build a culture at the company for better reviews, for writing better software that is hugely impactful in terms of how you can do good for the company and for the company's customers.
03:08:18.185 - 03:08:52.033, Speaker A: And I think for yourself, for your own experience at the company. And I think that is something that's hugely worth growing your skill at. And not enough people do it because it's not seen as a programming skill. But I do think it is one of the things that programmers, as an experienced programmer getting better at has a. Is like a huge return on investment on getting better at that stuff. So I think probably those three. Um, okay, I'll do the.
03:08:52.033 - 03:09:10.681, Speaker A: The next one too, just because it's very brief. Will you be at Euro Rust 2024 in Zurich? Uh, yes, that is the plan. I should be in Zurich, um, at Euro Rust. I may even be giving a talk. Uh, so, yes, I will be there. Please come and say hi and I will be happy about it. Okay, we're at three hours and a little bit.
03:09:10.681 - 03:09:32.597, Speaker A: I think that went pretty well. We got through a lot of questions. Uh, what I'll do, as always, is I'll upload this video after the fact to. And then I'll mark all the chapters with all the questions. You should be able to seek back to questions that you missed. Is there anything sort of briefly here at the. At the tail end that you want me to quickly touch on? Git Ref Log too, is super useful.
03:09:32.597 - 03:09:58.351, Speaker A: Then put them in chat and I'll see if we have any time. But otherwise I think we're going to call it here. I don't see anything. So I think we're gonna call it. Thank you all for coming out and hopefully that was useful. And I'll catch you on the flip side, as they say, or I guess in another video. What's the.
03:09:58.351 - 03:10:07.735, Speaker A: What's the video equivalent of Flipside? I'll catch you on side B of the tape, side B of YouTube. I don't know. See you all later.
