00:00:05.360 - 00:00:44.821, Speaker A: Folks, welcome back. So this is going to be a crust of rust stream, which, if you haven't watched any of these before, these are. These are streams where I try to tackle sort of odd little bits of rust that are often just covered sort of while you're writing code. You run into some weird corner case or they're just a topic that many people have opinions about or are confused about, but there aren't good sort of thorough examples or walkthroughs of how they work. And in this particular stream, what I'm going to be covering is subtyping and variance. Now subtyping and variants are sort of. It's a very niche topic.
00:00:44.821 - 00:01:29.465, Speaker A: It's something that you probably don't know that you've run into, but it sometimes comes back to bite you. And if you don't know what to look out for, it might be really surprising. And it's something that's a little bit hard, I think, to get across in text. So there's the page I have open here is the Rust reference. So this is like the official Rust language reference, which is still being worked on. Like it doesn't have all the details that it sort of needs to. It has a chapter on subtyping and variance and we're going to be referring a little bit to what's in here, especially this table, but it's not great for understanding what subtyping is and what variance is and what it means for your code.
00:01:29.465 - 00:02:56.115, Speaker A: There's also the rustnomicon and the Rusty Nomicon has sort of a chapter on subtyping invariants as well. And this one is very helpful. I can highly recommend going through that if you're curious about this. But even after reading this, I wasn't quite clear on like, how does this work, what does it mean for me in practice and where is this useful? Similarly, there's a really good, I guess, code file, like educational code file going around that has sort of a very thorough example in code of how lifetime variance works out in practice that goes through just sort of a step by step buildup example where you get into why variance matters. And this is also very good. And if this is something you really want to understand, I encourage you to read through these resources. But as a part of this stream, what I wanted to do was sort of take a little bit of a more pragmatic approach of why should you care? Like, where does this come up in the code that you might write? And to get to that, what we're going to do is we're going to implement a function that comes from C and C, which is the STR function.
00:02:56.115 - 00:03:54.955, Speaker A: STR is a little weird, but its functionality is pretty straightforward. It takes a string and you give it a delimiter. Think like you take a string and a character, and what it's going to do is it's going to return to you the string up to the next delimiter, and then it's going to change the string you gave it to remove that prefix that it just returned. So you can sort of think of this as like a similar to strip prefix in the Rust standard library, except that you do a delimiter instead of a string. You can think of it as like the split function on strings that gives you like an iterator over all the things that have been split. It's sort of like that, but different in that it doesn't give you an iterator. It mutates the string in place so that you can keep calling this function.
00:03:54.955 - 00:04:48.833, Speaker A: And we're going to see what we're going to run into when we try to implement this function in sort of the straightforward way is that variance is going to make it really hard to use this function. And we're going to look at how you might go about solving that. This is going to be a little bit of a weird stream for two reasons. The first is that variance is not something that I've used a lot myself, so it could be that I get really confused over the course of the stream, in which case we're sort of going to have to do some debugging and figure out what's actually going on under the hood. And the second is that this is a very technical, formal topic and I might be using some of the word wrong words at times. I'll try to stick to what I think the right terms are, but some of it can get pretty confusing. There's a lot of terminology.
00:04:48.833 - 00:05:31.951, Speaker A: There's going to be a bunch of lifetimes flowing around. So please ask questions as we go. If you're like, I don't understand why this is important, why this matters, why we get this error, then please say so in chat and I'll try to get back to it. Because I think what tends to happen in these cases is that a lot of people have what they think are stupid or simple questions. But in practice, a lot of people have the same questions, so someone needs to ask them so that I can know to address them. So with that, let's dive into STR talk. So let's do a cargo new lib stralk we don't need.
00:05:31.951 - 00:06:06.931, Speaker A: I don't want that, thank you. So let's. We can keep the test somewhere below screen for now. So the STR talk function takes a string. So let's just do this for now. We're going to add to this over time and it takes a delimiter, which in this case we're just going to have be a character. The real STR talk takes like a list of delimiters, I think, and each delimiter I think can be a string.
00:06:06.931 - 00:06:50.045, Speaker A: It doesn't have to be a car. But for the illustration purposes here, this is going to be good enough. And we're going to return is a string that's sort of the basic signature of str. Now, in practice, we're not really taking just a string, we're actually taking a mutable reference to a string. And the reason for this is STR is going to modify. Think of it as like you give it a pointer to a string and it's going to modify the pointer so that it points later in the string. This is going to be easier to understand when I give a.
00:06:50.045 - 00:07:24.013, Speaker A: When I write a test later that demonstrates how it works. And they're going to be lifetimes here. And we're just going to make them all take a for now. And in this case, I'm just going to have it return an empty string just so that it stops yelling at me. Oh, yeah, I'm not sure if it's stralk or str Toque. It's a good question. Toke is short for token, so maybe it is stir.
00:07:24.013 - 00:07:52.385, Speaker A: Toke. I don't know. That's a good question. See, I feel like a lot of the C standard library should have pronunciation guides. Like, it's the same with car. Is it char or car or care? It's a little unclear. Okay, so the way you would use stir talk in practice is you would do something like X is hello world.
00:07:52.385 - 00:08:40.705, Speaker A: I'm going to make it mutable and then you call stir talk of mute X, let's say space. And then what's going to be left in X is going to be world. I guess this needs to use super. Oh, this font size is very large. All right, so camera over text. Oh, yeah, you can't. That's fine.
00:08:40.705 - 00:09:10.365, Speaker A: Let me go out a little bit here. Let's do that. That should be fine. So this is the way it's going to be used. Ignore the compiler errors for now. But what you do is you have some string. It doesn't have to be A static string like this, any string you pass and X here, remember, is like a ref stir, right, is an ampersand str.
00:09:10.365 - 00:10:13.903, Speaker A: And then we pass a mutable reference to the variable that holds the string and the delimiter. And then what STR is going to do is it's going to find the first occurrence of the delimiter in the string, it's going to modify the pointer it got in to point to start after the delimiter, and then it's going to return everything up to the delimiter. And so what we get back is hello, and what's left in X should be world, right? And in fact we can write the implementation for it. The implementation is not actually that complicated. What we'll do is if let some I is s find delimiter. So find gives us, I guess. Does it have to be position? No, I think it's just find find returns us the character, the position of the first occurrence of the character, we give in.
00:10:13.903 - 00:11:10.165, Speaker A: Or none, if it doesn't exist. In this case, what we want to do is we want to split S at that location. So the sort of prefix is going to be S up to I and the suffix is going to be S from just beyond the delimiter and onwards. And then we're going to say that S is going to be the suffix and we're going to return the prefix. So once we write this into code, it's like a little bit easier to understand what's going on. If there is no occurrence of the delimiter at all, then what we're going to do is we're going to set S to be the empty string, we're going to have the prefix be the entirety of S and we're going to return the prefix. And of course, in this case, because we're returning, we can just make this be this.
00:11:10.165 - 00:11:26.783, Speaker A: So the code for this is not actually that. Oh, sorry, did I. Yeah, this should be. Hello. You're right. So the code for StarTalk is not that complicated. This might be buggy, we'll test it in a second.
00:11:26.783 - 00:12:14.255, Speaker A: But the internals of StarTalk aren't going to be as important for what we're going to be talking about today. Okay, so does the basics of the function we're writing make sense? Ignoring the fact that currently the test doesn't compile, so it finds the delimiter, it returns what comes before and it sets the input argument to be what follows delimiter. So it sort of changes the input argument in place. Basically, the input argument it becomes an in out argument. If you're sort of familiar with those kind of semantics from other languages, this will work with UTF8 as well. Find returns you the character position. Ooh, this is going to be.
00:12:14.255 - 00:12:30.904, Speaker A: This is technically. Should be the length of delimiter. I don't know if There's a len UTF8. Great. Yeah, good call. The fun of UTF8. Yeah.
00:12:30.904 - 00:13:06.325, Speaker A: So this should work with UTF8 strings as well. We're finding the start of the delimiter and we're sort of slicing the string up to the delimiter, which should be fine because the delimiter is a normal character, it's not a surrogate. And then we skip past the delimiter. This is the sort of delimiter Len UTF 8. And then we return the suffix, which is everything that comes after that. All right, great. So now we have a thing that works and we want to test it.
00:13:06.325 - 00:13:43.745, Speaker A: Right? So let's go back to our test case. Here we have a mutable string X or a mutable string pointer, if you will, X. We pass that X into STR talk with the delimiter of just white space. We assign the return value to be hello. We assert that hello is equal to hello, and then we assert that X is equal to world. All right, so this now gets real weird. We're going to ignore the fact that STR sets null in C is not really important here.
00:13:43.745 - 00:14:14.035, Speaker A: It does not really important in the Rust world. So let's actually look at what this compiler method looks at in a little bit more detail. So if I run cargo check, it runs just fine. If I run cargo test, it fails. And let's look at this error message because it's kind of interesting. Let's see if I can make that error fit on screen. So it says cannot borrow X as immutable because it is also borrowed as mutable.
00:14:14.035 - 00:15:06.235, Speaker A: You see, the mutable borrows borrow occurs when we take the mutable borrow 2x, right? And that mutable borrow of X gets passed into STR talk. And the. And what that does is we've said that hello is going to have the same lifetime as the mutable reference that's given in. And therefore as long as hello lives, X continues to be mutably borrowed. Right? So at here hello still exists and therefore the compiler gets sad because we're trying to use X while it's still mutably borrowed in hello. So this is sort of the standard problem around having lifetimes. But let's see if we can't do something about this.
00:15:06.235 - 00:15:31.035, Speaker A: So let's say that we drop hello. I don't know if it's going to let us drop below to fix this. It might not. So here's what we're going to do. We're going to add a scope around here. So now hello is going to be dropped. So this mutable reference to X should be no longer in use, right? So why does this not work? Right? If I run Cargo T, it still fails.
00:15:31.035 - 00:16:06.365, Speaker A: It still says cannot borrow X as immutable because it's also borrowed as mutable. And it still points us at the same use. It says that an immutable borrow occurs here and the immutable borrows later used here. So why does it get confused? And remember, I added an extra scope here, right? So the hello borrow here, the lifetime that gets returned, that borrow has gone away. So nothing should be holding on to this mutable borrow of X anymore. X should not be mutably borrowed. And yet for some reason it is.
00:16:06.365 - 00:16:46.765, Speaker A: And in fact, I can give you an even simpler way to discover that this is a problem. So let's comment out this test case. Just we'll return to it a little bit later to understand what's going on. But let me give you a simpler example. So we're going to change, stir, talk a little bit and we're going to have it just return us static str, just to sort of get out of this lifetime world for a second. And we're going to have this just return like empty strings all around. So notice that it still fails to compile.
00:16:46.765 - 00:17:22.039, Speaker A: Ok, so this is not related to the lifetime of the return value, right? Clearly. Because the return value here is the static string. So what's going on? In fact, even if I delete, even if I delete the return value entirely like this, this still doesn't compile. Now it doesn't compile for a different reason. Let's comment out this too. It still doesn't compile. It still complains that X cannot borrow X as immutable because it's also borrowed as mutable.
00:17:22.039 - 00:18:11.871, Speaker A: What is going on? There's nothing that should be borrowing X. And the answer here, of course, as maybe you've guessed already, is variance. Specifically, let's try to work through what the compiler has to do here. So in this test case, let's just get back to this case to simplify the code. So let's see what the compiler has to do. It's trying to call a function that takes a tick, a mute tick, a stir. Okay, and what we're providing it with is a mutable reference to X, right? That's what we're passing in.
00:18:11.871 - 00:18:43.615, Speaker A: And X here, what is X? Well, X is this thing. This thing is a static stir. So it's one of these. Okay, so the compiler sees this and goes, hmm, interesting. Well, that must mean that tick A is static. Okay, but if tick A is static, then this must be static. And if that's static, then this mutable borrow has to be a static borrower.
00:18:43.615 - 00:19:18.715, Speaker A: Okay, but this mutable borrow of X is only valid for the lifetime of X, which is only until the drop here. So this means that this mutable borrow of X needs to be able to last until the end of the program. But X is a stack variable, so that won't work. And then the compiler goes, no, no, the mutable borrow of X lives forever, which means it can't be used immutably here. And in fact this won't even work even if I comment this out. So now the code is going to compile for a second. And this might strike you as weird.
00:19:18.715 - 00:20:36.995, Speaker A: This might strike you as really weird, right? Why does this now compile? Because the argument I just made still holds. The mutable borrow of X needs to be static. Well, the reason why this now compiles is not because we stopped using X, it's because the compiler now goes, this is a static string. That's true, but what if we just pretended that it wasn't static? What if we pretended that it just lived for the lifetime of it works? Then this becomes it works, this becomes it works, and this becomes it works, or X rather. I guess specifically what the compiler knows is that if you have a static reference, then you can use it in place of anything that is a shorter lifetime reference, right? So if you have a. If you have a function, if you have a function foo, that takes a take a stir, you can call foo with a static string just fine, right? This is maybe a bad example. Let's do FN main.
00:20:36.995 - 00:22:11.715, Speaker A: If I have a X, which is a static str, and then I have a Y which is some other str, and notice it's not generic over the lifetime, it's just let's say it's string new and this is a reference to S, right? So clearly Y is a string reference, but it doesn't have a static lifetime, then I can still hear, say Y equals X. Because any. If you have a string that has a static lifetime, that's valid in any context, that takes a non static lifetime because the static lifetime is always longer than any other lifetime, right? This is because of variance specifically. The reason why the compiler knows that anything that takes a ticket T you can. Anything that takes a tick at you can provide a tick static T instance is because of variance specifically. This is what's known as covariance. And here I'm going to introduce a lot of terms to you at once and we're, I promise you, we're eventually going to get back to STR talk.
00:22:11.715 - 00:23:15.309, Speaker A: But this was just motivating why this is a problem. Let me take one step back before I dive into the explanation of why all of this works. To basically get this code to not compile anymore. So here the mutable borrow of X suddenly worked again, right? And that was because the compiler knew that it could shorten the lifetime of this static stir to any shorter lifetime. But we can make it not compile again if we want. Check isstatic takes a static str, does nothing with it. Then now if I call check isstatic on X, yeah, Then now you see, it doesn't compile anymore because now again it's not allowed to shorten the lifetime of X because X has to be static.
00:23:15.309 - 00:25:15.195, Speaker A: And so now when it get back to here, it sort of comes back to this conclusion that the mutable borrow must be static, right? This static, static, static, static. So to bring all of this then back to variance, if the compiler knows that it can shorten the borrow in this case, right? It knows that it can shorten the borrow of the X, here, then why up in this case does it not also realize that it can shorten the borrow of this? And that's what we're going to be exploring in the rest of this video. All right, why does the assert that I commented out make X need to be static, this assertion. Okay, so let me bring that back before I dive into the variance bits. So if we do this, why is there a problem? Basically what happens is if we don't have this, the compiler can sort of pretend that the it can pretend that the mutable borrow that the it can make the lifetime of X be the lifetime of this scope. So basically until X is dropped, right? It shortens the lifetime of the stir reference the static stir to be the lifetime until X is dropped X is dropped down here. This mutable reference to X therefore also has to live until X is dropped because the two lifetimes are the same.
00:25:15.195 - 00:26:05.401, Speaker A: And when we then do this, this is now trying to immutably access X before X is dropped. And the lifetime is until X is dropped. And so now you have overlapping borrows of X, there's a mutable borrow that goes until the end of the scope, and there's an attempt at an immutable borrow here. So that's why this assert makes a difference. Okay, so now that we have this in place, let's talk first about why this example works so the sort of rewind to something simpler before we try to explore how we can fix this problem in the first place. So why does this example work here? The type of Y, right, is some like some lifetime tick A. But what we're assigning into it.
00:26:05.401 - 00:27:12.535, Speaker A: Oh, it's not going to like that, is it? I'll make it a comment. Right. Is some lifetime tick A, and yet we're assigning it something that is down here, we're assigning something that is a tick static into something that's a ticket. And this is because static is a subtype of any lifetime ticket. So what is a subtype? Well, a subtype is okay, and the there's formal definitions for this, but I'm going to go with something relatively informal, which is that some type T is a subtype of some type U if T is at least as useful as you. So T is a subtype of U if T is at least as useful as you. This is not the formal specification, but this is what how I remember what subtyping means.
00:27:12.535 - 00:28:24.563, Speaker A: So for example, static is a subtype of any tick A. Because static is at least as useful as tick A. Right? Anywhere where you can take a tick a a tick, static would be just as good, if not better. And in fact you can use this for things that aren't lifetimes. In Rust, currently, variants mostly just affects lifetimes, but you can imagine in a language that had inheritance like Java that let's say that you have some type, you have some class animal, and you have some class cat that is a subtype of animal or inherits from animal. Right here the property is the same. Cat is a subtype of animal because a cat is at least as useful as some generic animal you cannot use.
00:28:24.563 - 00:29:09.475, Speaker A: So there was a proposal in chat that you can use the wording tea can be used anywhere you can be used, and that's not true. These are not quite the same and we'll get into that when we get to contravariance later. So this is why I tend to prefer this phrasing and it's true that useful here is a sort of weird argument or it's a weird word, right, because it's sort of squishy. But think of it as like you can do as much with a T as with a U. So you can do as much with a tick static as you can with the ticket. You can do as much with a cat as you can with a generic animal. And this is the example I think that the rustonomicon also uses.
00:29:09.475 - 00:29:49.135, Speaker A: And Rust has this rule around variance, which is that you have three types of variance. You have covariance, you have contravariance, and you have invariance. Most things are covariant. Sure, close enough. Most things are covariant. And what that means is if you. Let's say that you have some function foo that takes a.
00:29:49.135 - 00:30:26.395, Speaker A: Let's just go with a T for now, and we're going to assume that it doesn't return anything. You can use the same argument for if you have some x of type T and you want to assign to it. These are equivalent. You can call foo with any not animal subtype of cat. No, animal is not a subtype of cat. You can't do. You can't do.
00:30:26.395 - 00:30:53.165, Speaker A: An animal is not at least as useful as a cat, because cats can do things that animals can't. So let's. Let's try to work through a specific example of covariance. So let's say that you have a. Yeah, I'll give you a counterexample soon. So here's what we're going to do. Let's say that foo takes a tick, a str.
00:30:53.165 - 00:32:05.455, Speaker A: You're allowed to provide any fun. Any. Any type that is a subtype of the arguments in this case, right? So I can call foo with some Take a str, but I can also call foo with a static str, because static is a subtype of a. So anything you can. Anything that accepts like a tick A, you can provide a static instead because it's at least as useful as the type it was expecting to get. Does that basic explanation of covariance make sense? Notice here that I'm not writing let it generic over a, because in that case it's not variance that would happen, it's just that A would be set to static. So I'm sort of imagining that you could name lifetimes, and this is some lifetime that's not a generic parameter.
00:32:05.455 - 00:32:52.469, Speaker A: This is why in the example I had with main up here, I sort of created a Y here as a reference to what's inside the string. And string is local. So that means that this str reference has some lifetime that we can't really name, but it's not static and it's not generic. Okay, so now let's. Let's think about why. Why is it that not every type is covariant? Why do we have these other types of variants? So, yeah, and it's not that foo here is covariant, it's that this. This argument type is covariant, right? So it's like the reference to string that is a covariant type.
00:32:52.469 - 00:33:28.995, Speaker A: This is why this could just as easily be written as X has the type. Take a str and you are allowed to say X equals some TK str, But you're also allowed to say that X equals some static stripe. It's this type here that is covariant. Ignore the fact that it's a function. So that then brings us to what's an example of something that isn't covariant? Because a lot of things are. You'll find this when we look at the tables later on too. That most things in Rust are covariant.
00:33:28.995 - 00:34:50.081, Speaker A: Contravariance is super interesting. So let's say that you have a function, you're writing some function foo, and what it's going to take is an argument of something that is an fn from tick a str to, let's say unit or equivalently let X of this type, right? So the question now becomes what's the variance of this? Because if I now try to provide this with a function, I'm sort of making up syntax here with this, like, anonymous function like this. Should this compile, Right? This is the same syntax as what I used previously. But here this gets weird because if you think about the implementation of foo right inside of here, the implementation of foo can take it expect to be given a specific lifetime here. What I'm. It's expecting to be able to. Let's.
00:34:50.081 - 00:35:32.209, Speaker A: If we call this bar, right, it's expecting to be able to call bar with something that has some shorter lifetime. Tick a. Right? But if I give it this. If I give it a function whose argument is a static string, then really, this is a stricter type, right? If it tried to give a function here. If it tried to call the function I passed in with something that only as a lifetime of ticket, it wouldn't compile because the function I passed in requires that the type is static. So this gets sort of. This is contravariant.
00:35:32.209 - 00:36:25.095, Speaker A: So if you have a. Let. Let me see if I can phrase this better. How to phrase this better? Foo here expects to be able to use bar with something with a particular lifetime. Here we're providing a function with a different lifetime, but it's a function that takes a lifetime that is longer. So in other words, the caller of the thing we provide has to give a more useful type than it normally would. But foo is written to provide a less useful type, a ticket.
00:36:25.095 - 00:37:17.045, Speaker A: And so this is not. You can't hand foo more useful function is a good way to phrase it, right? Like you can't hand fu a function that has stricter requirements of its arguments than what you expected. You can provide one that is weaker arguments. So imagine that I had a foo that takes a function that takes a static stir. So this means that this, the body of foo expects to be able. It can provide the argument with a static string. Then it's fine for you to pass in some function that takes an argument that is a shorter lifetime because the caller is going to provide a more useful lifetime, a static lifetime.
00:37:17.045 - 00:37:55.589, Speaker A: So you can think of this as it sort of flipped on its head to what we talked about earlier. It's contravariant. You need to provide a argument that is less useful rather than more useful. This is going to make a little bit more sense if I write it out in. Actually, let's. This is a good time to look at the reference. So if we go back to the reference, the reference has this variance table where it says that it lists out a bunch of types and it says what variances that have in the lifetime and in T.
00:37:55.589 - 00:38:54.005, Speaker A: We'll get to the distinction of those later. And you'll see here that a function that takes a T is contravariant in T and it's the only thing that's contravariant. And the argument here, right, to try to reiterate it again, it's sort of hard to phrase is that if I, if I'm a function or a variable, whatever, I expect you to give me a function that I can provide a short lifetime string to. But you give me a function that requires a long lifetime string, I can't use that function Normally, that is the case. Normally, if. If I expect to be given a short lifetime string and you give me a long lifetime string, I'm happy. But if I expect to take a function that takes a short lifetime string and you give me a function that takes a long lifetime string, that's not okay.
00:38:54.005 - 00:40:10.755, Speaker A: So in other words, the variance requirement is flipped when it comes to function arguments because a. Actually, here's maybe a way to phrase it that might be helpful. Let's write out these two functions. Let's write out a fn tick static str and an FN tick astir. Which of these is more useful? And then let's contrast that with a static stir and a tick a str. Which of these is more useful? Well, this is more useful, right? This one is easier to use, it has more features, it's more useful, it's more widely applicable because any static stir satisfied any satisfies any tick a str here. Which one is more useful when in this case, this one is more useful, as in more generally applicable, right? This one has stricter requirements of its caller than this one does.
00:40:10.755 - 00:40:53.813, Speaker A: This one can take any short lifetime string. It can also take a longer lifetime string. That's fine, but it can take a short lifetime string as well. This one you must provide a long lifetime string. And so the function that takes a short lifetime string is the more useful one, right? And so. So in the subtyping world, right, a tick static is a subtype of. I think this is the phrasing, the wording that sometimes used is a subtype of any other lifetime tick A.
00:40:53.813 - 00:42:08.885, Speaker A: And because references are covariant in their lifetimes, a static T is a subtype of a tick at. But here, even though static is still a subtype of tick a, a function tick at is a subtype of a static T. Right? So notice that the. The subtyping relationship here is flipped. And that's what contravariance is. Yeah, there's a good comment in chat that this requires its argument to be maximally useful, which means that the type itself is less useful because it has stricter requirements. All right, so that's contravariance and function argument types are the only place where we have contravariance in Rust today, where you need to provide a.
00:42:08.885 - 00:43:03.725, Speaker A: I'm not going to try to say it again, but it's the only place that we have contravariance in Rust, which then gets us to invariance. Okay, so invariance is interesting. So let's look at why we need invariance. Like, why is this not enough? Specifically, if we look back at the table here, you'll notice that a mutable reference to a T is covariant in the tick A, but is invariant in the T. This is finicky, but let's try to get at it. Okay, so let's say that I have some function foo. It takes a mutable reference to a cell of static.
00:43:03.725 - 00:44:13.075, Speaker A: She doesn't even have to take immutable reference. It can take an immutable reference even. All right, actually, let's do Is that how I want to explain this? I think I want to explain this with a tick A. Yeah, Actually, no, I know how we're going to do this. Okay, so here we have a function that takes a mutable reference to a string with some lifetime and ignore. Let's ignore what the lifetime is on the mutable reference itself. I don't want to get into cell static quite yet, but maybe later.
00:44:13.075 - 00:44:43.585, Speaker A: But, but let's imagine that you take a. You have a foo that takes a mutable reference to some string pointer. And what this is going to do is it's going to, I guess S. It's going to set S to be equal to. Let's have it also take an X. It's going to set that equal to X. That's all it's going to do.
00:44:43.585 - 00:45:42.335, Speaker A: All right, so let's imagine that mutable reference were covariant. So in that case I could have a. This is now a static stir, right? We can all agree on that. If I could do Z equals string new. All right, so I just wrote some code. Let's talk through what's happening here. So here I have X, which is a static string reference, and I give it a static string.
00:45:42.335 - 00:46:34.223, Speaker A: I create a stack local string and then I call foo with a mutable reference to my X and a reference to the stack local variable. If mutable references were covariant, then this would work just fine, right? The X is a more useful type. It's a static str. So we provide that more useful type into here and it sort of gets automatically downgraded into a tick A. This is again, if mutable references were covariant, then this would compile just fine, right? Because we would sort of downgrade this tick static into a tick A. Inside here we assign the thing behind the mutable reference. So this thing to be this thing.
00:46:34.223 - 00:46:56.745, Speaker A: They have the same lifetime. So this compiles just fine. We get back out here and we drop Z. So Z is now gone and the reference we gave in here is now gone. But the type of X out here is still static. It's still a static stir. But what we made it point to was this tick A, which was a pointer into this.
00:46:56.745 - 00:47:42.007, Speaker A: So if I now try to like print X, who knows what would happen? X is now A. Even though it's supposed to be a static string, a static string reference, it's pointing into stack local memory that has since been dropped. Clearly this is not okay. This should not compile. And the reason why this doesn't compile is because mutable references are invariant in their argument type. And what that means is if you have invariance, it means that you are. You must provide something that is exactly the same as what was specified.
00:47:42.007 - 00:48:45.089, Speaker A: You cannot provide something that's more useful, you cannot provide something that's less useful. So it's not covariant, it's not contravariant, it is invariant. And because of that this code no longer compiles. Right, and let's walk through why we have a static string, we have a Z which is a local thing, we construct a reference to Z which is a non static string. And here when the compiler gets to this line of foo, it's trying to reconcile the following types. So it's trying to recognize reconcile this signature with this signature, right? These are the provided arguments. And in order to reconcile these, it needs to be able to make static be equal to tick A or tick A equal to static.
00:48:45.089 - 00:50:19.165, Speaker A: But it's behind immutable reference. And mutable references are invariant in their, in their t in the thing that they reference. And therefore the compiler is not allowed to have these not be equal, therefore the code does not compile and therefore this problem does not arise. Okay, so does that make sense why we need invariance mutable references? It's basically the sort of informal way to think about it is that if we didn't have invariance for mutable references, you could sort of downgrade a mutable reference to something that is a reference to something less useful, stick in something less useful, but in the outer scope it's that the thing you took immutable reference to still has the more useful type. And so now you have something that thinks it's a more useful type, but it's actually a less useful type. And that's not okay because it doesn't have some of the properties that its type indicates that it should have. All right, so now let's figure out why in this table does it say that a mutable reference to T is covariant in its lifetime but invariant in the T.
00:50:19.165 - 00:52:15.665, Speaker A: Why is that? Okay, so the reason why that is is. Let's see here, how are we going to explain this? Mute Z is string new X is going to be immutable reference to Z or just a Z. I don't really have A actually, here's what I'll do. A B I see this I can do in a function foo just to just a sanity check that I'm doing the right thing. B. I'm just, I'm trying To find the right way to phrase this in such a way that it's not too confusing. So here, the lifetime of the mutable reference to B is the lifetime from B until when B gets dropped.
00:52:15.665 - 00:52:51.395, Speaker A: Okay, yeah, this will work. And this will. Why will it. Why will it work either way? That's annoying. So that's not a good example. Oh, I have a better example. Let's say that we have a foo that takes a.
00:52:51.395 - 00:53:35.835, Speaker A: No, this is a much better example. What am I doing? It takes a mutable reference to, let's say A. What's a good example of this? Let's just use a bool, because it doesn't really matter. It takes a mutable reference to a bool with some lifetime ticket. Yeah, fine, close enough. And I'm going to make a mutable reference that has a static lifetime. So I'm going to do box new true.
00:53:35.835 - 00:53:58.155, Speaker A: And then I'm going to say box leak X. So box leak is a way to introduce a memory leak in a safe way. So you can just leak. If you never drop the box, then the thing inside the box lives on the heap forever because it's never going to get dropped. So you get a mutable reference with a. With any lifetime, but specifically with a static lifetime. So X now has a.
00:53:58.155 - 00:54:20.477, Speaker A: Is a. Is a static mutable. And now I'm going to make. I don't even need foo. Now I'm going to have a Z, which is a bool. I'm gonna have a. Oops.
00:54:20.477 - 00:54:52.175, Speaker A: True. And I'm gonna have Z. Sorry, I'm writing the code while I'm thinking of it and then I promise I will explain it after. I'm gonna have a Z, which is going to be a mutable reference to Y. And I'm going to set Z equals X. Okay, so here, this compiles. That's fine, drop Z.
00:54:52.175 - 00:55:26.041, Speaker A: I just want to get rid of some of the warnings to make it easier to under Oops, no pub and stop compelling cabal error. Great. All right, so here's what we have. We have a local stack variable Y. So this, this. And then we take a. We take immutable reference to it.
00:55:26.041 - 00:56:08.045, Speaker A: So this mutable reference is effectively going to have. This is going to be sort of a tick Y, I guess, mut bool. That's the type of Z. Then I create X and X is a static mut bool. And you can ignore this line and down here, and you can also ignore this line. They're just to get rid of compiler warnings. And here what I do Is I do Z equals X, right? So on this line I'm taking a tick, why mutable? And I'm assigning it a text static mutable.
00:56:08.045 - 00:57:04.267, Speaker A: So why is this okay, right, like we said, mutable references are invariant. So why is this? Okay, well, mutable references are invariant in the type that they point to, but they're not invariant in their lifetime, they're covariant in their lifetime. And so here the compiler tries to reconcile these two and goes, yeah, static is a subtype of Y and therefore this assignment is fine. And this is the reason why mutable references are invariant in their T but covariant in their lifetime. Because this isn't a problem. And you can't use this to pull the same kind of shenanigans we were trying to pull earlier. Because even if you assigned through this, you can't accidentally assign like a less useful type into what's behind the mutable reference, because that part is still invariant.
00:57:04.267 - 00:58:26.885, Speaker A: Basically, what this is saying is it's okay to shorten the lifetime of immutable borrow, which sort of intuitively makes sense. Like, that's fine. All right, so does this roughly make sense for why? For how mutable references are invariant in their t but covariant in their lifetime. I know there's a. There's a lot of stuff we're processing here and it's fairly involved, but hopefully it makes sense. All right, so now that we've gone through all of this and subtyping and variance, let's now go back all the way up to our stir talk to try to figure out what's going on. So now that we look back at this, right, we're going to have this return our take a STR again all the way back to the top.
00:58:26.885 - 00:59:27.085, Speaker A: The lifetime is any with leak. I think it's generic over the return lifetime, but it could just as well be static because mutable references are covariant in their lifetimes. Okay, so we're back to our start talk right here and now we want to figure out how we can make this code work. And now when we look back at this error, we might actually be able to start to make sense of what's going on. We get the compiler tells us that X does not live long enough, and that's because when we look. Let me bring this back. So let's make these a again.
00:59:27.085 - 01:00:14.415, Speaker A: So the argument to strtalk is ticket. What we're providing is a tick, a static str. So the compiler goes, this must be static, right? The function is generic in ticket, so it's allowed to sort of replace this one here. This is not subtyping. This is just tick A must be static, which means this must be static. And now what the compiler has to do is it has to figure out how long is the mutable borrow going to be. Well, the mutable borrow has to live for.
01:00:14.415 - 01:01:14.265, Speaker A: Okay, so this is where the circle gets completed. We know that mutable references are covariant in their lifetime. So in theory this could just remain tick A, where tick A is like sort of tick X or something like the lifetime of the borrow of X. But we also know from the function signature that this lifetime and this lifetime must be the same. So if this was tick X, then this would have to be tick X. Right? But we're not allowed to shorten the lifetime of what's behind the mutable reference, because mutable references are invariant in their arguments. So we can't shorten this to X if we could, right? If we could shorten this, then this tick A would be X, this tick, which would make this tick ax, which would allow this to be X.
01:01:14.265 - 01:02:08.825, Speaker A: But we're not allowed, if we put this back to take A, to sort of indicate that it's generic, right? What we want to do is this, where X is the borrow of the borrow of X. But in reality we're in this position and we're not allowed to sort of weaken this lifetime reference. We're not allowed to make that shorter to be X to make the function signature match what we want, because this is behind sort of the invariance of the mutable reference. The only thing we're allowed to do, and again, because mutable references are covariant, is that we can make this static. And that's what the compiler does. But if it makes it static, it goes, well, the mutable borrow of X isn't static because X lives on the stack, and so it goes away right here. And so X does not live long enough.
01:02:08.825 - 01:03:04.845, Speaker A: So that's how we get. That's why the compiler ends up with this particular error message. Okay, does the explanation for why this doesn't compile make sense? I'll get to how we fix it in a second. The fix is, like, stupidly simple, but it's important how we get there, because it's easy to just throw lifetimes everywhere. But I want people to understand why, and that's why we're doing the stream. Okay, so the solution to this, as some have already pointed out in chat, is to introduce an additional lifetime, right? So let's go back up to the lifetime, the signature of STR talk. We can have this, have two lifetimes, which I think means that now you can't see this.
01:03:04.845 - 01:03:59.987, Speaker A: So let me add some new lines so I can bring it down here. So now we are going to have two lifetimes and we're going to do this. So what we've now done is say that strike over two lifetimes, one that is the mutable borrow and one that is the string that's being pointed to. And the return type, of course, is the string being pointed to, because that's where we're returning a reference into. And what we're doing here is making it so that the compiler is allowed to choose these two separately when calling the function, rather than having to pick one and stick with it for both. And now it doesn't matter so much that the T behind the mutable reference is invariant, because the compiler can choose these two lifetimes independently. They're generic parameters.
01:03:59.987 - 01:05:14.155, Speaker A: So we can choose this to be static and this to be non static. And in fact, with this signature, go back here, now this code compiles, and if we in fact go back to our earlier example, the one we wrote in the very, very beginning, now this compiles as well. In fact, I think we can even remove this. And I mean, just to check that it works, this now passes. So the test runs, it compiles, our implementation was correct, which is amazing. And the reason, right, to go over just that one last time is that we have a signature that says STR talk. It takes a tick a tick B tick a mu tick B str and returns a tick B str and we're trying to call STR talk with A with tick B being static.
01:05:14.155 - 01:06:04.625, Speaker A: So if tick B is static, then the compiler is just going to accept that that is the case because it's generic over B. So it replaces every occurrence of B with the lifetime we provided for B. And this tick A is going to be the borrow of X that we made. And so the compiler injects that for every case of A, it doesn't have to use subtyping at all. In fact, there is one place where subtyping comes in here, which is kind of. I might be lying here, but I think it's true, which is that here, when we borrow X, right, that borrows, sort of theoretically is like borrowing X for the remainder of the function. Like why, when I say, if I say.
01:06:04.625 - 01:07:51.315, Speaker A: In fact, here's a better example, Z is at mutex. Why does this code still Compile Z borrows X and Z gets dropped at the end of the function. So why is this okay? Why doesn't it complain that I'm trying to mutably borrow X again here? It doesn't complain because Z isn't used beyond this line and mutable references are covariant in their lifetimes. So it's allowed to shorten the borrow of X here so that that borrow stops here, right? So the essentially it goes from a sort of tick X mute to a tick until Z mute, where this is until Z. It's allowed to do this shortening because mutable references are covariant in their lifetimes. And at this point if the Z borrow stops here, then it's fine to start another borrow here. So let's see, I'm just parsing through chat for questions why isn't a tick B? So some people are asking why is this bound not needed? I need to make my video smaller or something.
01:07:51.315 - 01:08:38.497, Speaker A: But I think you know that it's a stir there. So why is this not needed? Or some. Or some variant of it, Pun not intended. This is not needed because it's always assumed that lifetimes are at least for the duration of the call. Like this is just an assumption that the REST compiler makes, that any generic lifetime argument implies at least for as long as the duration of the function. That's all we need for this mutable reference, right? Like when you execute the code in this function, it only assumes that this mutable reference exists for the duration of the function. It doesn't care what happens after if it gets dropped immediately after.
01:08:38.497 - 01:10:16.705, Speaker A: That doesn't make the function body any less correct. And tick B doesn't really depend on tick A, right? All we're doing is returning something with the same lifetime as what was passed in, and that doesn't have anything to do with how long the pointer we were modifying lives for. So there doesn't have to be an association between tick B and take a here. Would you be able to modify Z after stir talk? No? So if you here said Z equals foo, this would no longer compile because the borrow of X lasts until here and that overlaps with immutable borrow here. Would your last example still be true for the previous addition? Something seems to be tied to nonlinear lifetimes here. I think you're right. I think that in the 2015 edition, although the 2015 edition of Rust has NLL enabled now, I believe, but before we had non lexical lifetimes nll, this code would not compile because it wouldn't know to shorten this borrow after the explanation and thinking it's a general rule that tick.
01:10:16.705 - 01:11:09.645, Speaker A: Okay, so the, the question in chat is for. For this question, isn't this a requirement in order to have this in the first place? And I don't think that's true. Let's listen to work through the cases, right? So can you have a mutable reference to a value that has a shorter lifetime? Or let's do it the other way around. Can you have a mutable reference to something that lives longer than the mutable reference? Well, that's obviously true, right? In fact, our X, our mutable borrow X here is a good example. The X lives shorter than the lifetime of the things it lives for. So yes, you can have that just fine. The opposite, I think you're right.
01:11:09.645 - 01:12:18.765, Speaker A: That can't exist. So you can't have a. You can't have a tick A mute or just tick A tick B T, where tick A is longer than tick B. Because I don't think you could construct such a value in the first place. The argument for why this can't exist in the first place is because how would you like what would happen when the B lifetime ends? Well, you still have this reference around, but this lifetime has ended. So what even is this reference? I think in practice Rust would be fine with this because the lifetimes are covariant, so it would shorten the tick A, tick B to whichever lifetime is shorter. I don't think it actually sort of implicitly adds a bound that tick B must be longer than tick A or the tick B must be a subtype of tick A.
01:12:18.765 - 01:12:45.725, Speaker A: I don't think it adds that bounds implicitly. I think it's just the. If you ever try to violate it, you would get a compiler error. And so this code up here, it doesn't need the bound. But if we ever tried to do something that made that assumption, then the compiler would yell at you. But it's just really hard to write code that would make such an assumption. If it tried to use the outer reference after the inner reference became invalid, that's when the compiler would.
01:12:45.725 - 01:14:40.125, Speaker A: Would scream at you. Okay, so now we've been all the way through variance and subtyping and let's now get to one last thing I want to talk about, which does come up occasionally here, which is like you might have seen the following type, signature, marker, phantom data. So you might have seen this and you might have seen this and you might have wondered, well, what's the difference? Why do some things write this while other things write this. And why do people do this in the first place? Well, imagine. So the reason why you use phantom data in general is you might have a type that does, that is generic over T, but doesn't directly contain a T. This comes up often if you do something with FFI like you do some kind of. What's an example of this? Let's say that you are like deserializing something and you want a deserializer that is generic over the type it's going to deserialize.
01:14:40.125 - 01:15:24.357, Speaker A: So deserializer, but it doesn't actually contain a T, it's just that you want the deserializer to know which types to produce. And so in that case, there's like no T in here because we haven't deserialized one yet. But we do want it to be generic over T. The Rust compiler will complain if you do this. This is an error because it says that the parameter T is never used and that's not okay. And so it suggests you add a phantom data, right? So you add a field that's a phantom data, and a phantom data is the only type in Rust that is generic over a type parameter, but doesn't contain that type parameter. And so people write this, but then some people write this instead.
01:15:24.357 - 01:16:44.375, Speaker A: So deserializer 2, in fact, if you look inside Serde, I think you'll see this signature and the question becomes why this and not this, the end? Sometimes you'll even see, like, you'll even see this. And the reason here is because of something called the drop check, which is when a type is dropped, Rust needs to know whether the generic types might be dropped as well. Normally this is the case, right? If you have a vector of T's, then when you drop the vector, you're also going to drop some T's. The reason that is important, and this is sort of not really getting into variance specifically, but it is. I'll get to how it's relevant. So let's say I have Z, which is a vector of let X equals true. And now I drop Z and then I print X.
01:16:44.375 - 01:17:26.395, Speaker A: That's a bad example. This is a better example. So this should clearly not be okay, right? So I have an X, which is a string, I have a vector that contains a reference. Into that string, I drop X and then I drop Z. The reason this is not okay is because when I drop the vector, it might end up accessing the things. Well, when I drop X, that's not okay because there's still a reference that lives to it down here. But what if Z is never accessed again? Like this? Z is never accessed again.
01:17:26.395 - 01:19:21.845, Speaker A: And because Z is never accessed again, it's actually okay to do this, right? I drop the X, this reference still exists, but it's never used beyond this point. And how does the compiler know that this is fine? Because this wouldn't be fine if I had, let's say a touch drop. It requires that its type is format debug and we're going to impul drop for touch drop. This is beyond what we were planning to talk about, but it's, it's an interesting enough problem that I want to touch on it, mute self and it's actually going to print out the thing that it's about to drop, T. So if I do here, if I make this a touch drop of this instead, this code no longer compiles, right? So if this is just a reference it compiles, if I make it a touch drop that contains a reference, it no longer compiles. And this is what we want to happen, right? Because here, when, when Z is dropped, right down here, the sort of implicit drop of Z when Z is dropped, we're going to call this drop implementation of touch drop, which is going to access the inner type, which means it's going to access this reference. So dropping X here is not okay, because by the, when Z gets dropped, it's going to try to access the reference.
01:19:21.845 - 01:20:35.245, Speaker A: But this here, when we drop the vector, dropping the reference does not access the inner type on drop. And somehow the compiler has to know this. And it does this through something called the drop check, which is basically it needs to know whether the for vector, for example, it needs to know whether the vector drops its generic parameters or not, right? VEC is generic over the inner type, and VEC will only drop inner types if they implement drop themselves. And the way that the compiler knows this is it looks at the generic parameters and it sees whether the type contains a T. This is, I'm kind of lying. There's a, an unstable nightly feature in here, but there, basically it looks at whether the type contains a T and a phantom data T contains a T. As far as the type system is concerned, it's considered as dropping a T.
01:20:35.245 - 01:21:07.965, Speaker A: This though this signature does not, does not own a T, so it can't drop a T. If you drop one of these, you're just dropping a function definition which won't drop any T's. So that's why this is a preference compared to this. If you know that your type doesn't drop a T. Like this is the case for a deserializer. It doesn't own a T, therefore it doesn't drop a T. So we want to allow something like a touch drop, because we know that we're not going to call drop on the inner type.
01:21:07.965 - 01:21:47.865, Speaker A: If you had a deserializer of touchdrop, then it's fine to drop the deserializer. If the reference inside the touch drop is now invalid because you're not going to drop any touch drops when you drop the deserializer, it doesn't contain any. It's a little involved. So you might wonder, well, why not just use this instead? Aren't these equivalent? And no, they're not. This one is covariant, this one is contravariant. And so if you did this, you would end up with this type being really annoying to use because it wouldn't be covariant, it wouldn't be able to shorten lifetimes. So you wouldn't be able to provide a static in place of a ticket.
01:21:47.865 - 01:22:24.415, Speaker A: Whereas with this you can. So that's why you often see this function signature or this type signature in types that don't contain T's. Very roundabout, but. All right, does that roughly make sense? I know, I know that was involved, but hopefully it was somewhat interesting. It's also a little bit of a simplification technically here. There's a may dangle, I think it's called, that I haven't talked about, but I'm gonna. I'm gonna ignore it because it's.
01:22:24.415 - 01:22:50.065, Speaker A: Because we're. We've run for about an hour and a half and this is roughly what I wanted to talk about. MadeAngle is a really interesting property. I recommend you look up if you find this sort of stuff interesting. I recommend you look it up, but it's not something we're going to touch on here. What is self zero? Oh, self zero is. Touchdrop is a tuple struct with one element.
01:22:50.065 - 01:23:04.555, Speaker A: Self zero is accessing the first element of the tuple. Sorry. Yeah, you're right. The made angle is in drop here. It's like here or something. I think it's not even. Isn't in the drop implementation.
01:23:04.555 - 01:23:51.629, Speaker A: It's not really important for the distinction I wanted to make. Wouldn't the compiler know that the only T inside a deserializer is a phantom data which doesn't actually hold the table? It could, but it's actually better for it to assume that it's going to drop a T. Imagine the deserializer holds like a Like a void, like a C void pointer. Oh, which is a thing like this. And this is a pointer like into C land. And so there's no T stored in this. But imagine that this pointer is actually a pointer to a T that was allocated in, in the world of C.
01:23:51.629 - 01:24:31.705, Speaker A: And so you actually do have a drop that like calls into like C free self, C void. So you do actually drop a T when this type is dropped. So you want phantom data T to communicate that you are owning a T and might drop one. That is sort of the semantics that you want. And so that's why the phantom data T is sort of thought of as holding a T even though you're not. So, yeah, you're right. Phantom data fnt is a marker of contravariance.
01:24:31.705 - 01:25:25.115, Speaker A: You very rarely see this. One case where you do see it is imagine that you want your type to be invariant in T. There are a couple of cases where this come up where you might have some interior immutability. And so you need to have invariance so that people can't pull the same hack as we looked at for immutable references, the one thing you can do is you can do this, I guess. Let's make this four and have this continue to be here. So deserializer four is invariant in T because it contains. It has to be both covariant and contravariant in T, which no type can be both.
01:25:25.115 - 01:26:07.165, Speaker A: Variance is one of these three. So in this case, the compiler concludes that deserializer 4 must be invariant in T. And you might be like, well, can't you just do this instead? You could, but the problem is this now requires a lifetime. So you would have to add a lifetime to your type, even though it's in a phantom data, which you probably didn't want. You can also do this. That's the other way to get invariance for a T with a single field. And indeed the other way to express this thing is a star const T.
01:26:07.165 - 01:26:47.985, Speaker A: Both of these are covariant in T, and this one's shorter. But people get scared when they see raw pointers. So I think that's why people prefer this one. And in fact, if we go back to the table, right, you can use this table to figure out which type should I use. So star const T is covariant, star mut is invariant, and fnt is covariant. As we looked at, you'll see that unsafe cell is invariant. And that's because an unsafe cell lets you mutate the T and Therefore, for the same reasons why immutable reference has to be invariant, unsafe cell has to be invariant.
01:26:47.985 - 01:27:28.859, Speaker A: So I don't know whether it's preferred to use this over this. They're equivalent. But this is generally nicer because once you introduce raw pointers, there are a couple of things you don't get. Like, I think send and sync are not auto implemented for raw pointers. And therefore, if you have a type that contains a phantom data that contains a star cons t, your outer type would not be send and sync. Normally, send and sync are auto implemented for your types, assuming all the members are. But if you use this type in a phantom data, it wouldn't be.
01:27:28.859 - 01:28:25.035, Speaker A: So that's probably why people prefer this one. To get those auto implements, could you just say fnt to T for invariance? Yeah, I think you can. This signature, this signature has to be contravariant in T but also covariant in t and is therefore invariant in t. I think that's right. And yeah, like variance and subtyping is something that, like, it's rare that you have to deal with it. Usually it comes up in two contexts. One is maybe you can.
01:28:25.035 - 01:29:22.603, Speaker A: Maybe your type by default becomes invariant, but you know that it's covariant. And so you can improve the ergonomics of your type by making it covariant. In this case, you have to think really carefully about whether it really is covariant. Because if the compiler automatically concludes that your type is, say, invariant and T, it was like generic over t and the compiler concludes it's invariant over t, then if you try to sort of tweak things to make it covariant, you have to make sure that you're not vulnerable to this kind of sort of invariance attack, if you will, of sort of this accidentally weakening. And that can be hard. The other case is in unsafe code. It might be that the safety of your code relies on a generic parameter being invariant, but the compiler concludes your type is covariant.
01:29:22.603 - 01:30:28.649, Speaker A: So let's say you have some type, you have some type foo that's generic over t, and let's say that all it really contains is a const t. The compiler concludes that this type is covariant in t, but let's say that you have some code deep inside foo that for some reason, like, allows you to mutate somewhere. This can't actually happen in this case because you're not allowed to mutate through a star const, but it's a separate discussion but imagine that your unsafe code ends up mutating the t somehow. Then now you have to make sure that your type is invariant in t rather than the covariance of the compiler assumes. In general, this shouldn't happen because in order to basically invariance is only important for mutation. You can only mutate through either a mut. There are only really three types you can mutate through a mut ref t or an unsafe cell T.
01:30:28.649 - 01:31:38.965, Speaker A: And all of these are invariant. So you would have to work really hard to get something that's actually safe, like it's not undefined behavior. But also the compiler's conclusion about covariance is incorrect. But I think I've seen one case of this. Do 4 tick A changes? Does 4 take a change any variance or it doesn't have any relationship? So the question is about if you have this syntax, this comes up in like wherefore take a like t impluence, debug or something. So this is a special syntax you can use if you want to say that for any lifetime this bound holds it. I think you can only use it in bounds.
01:31:38.965 - 01:32:22.951, Speaker A: And this doesn't affect variance at all. This is just saying that this must be true for any lifetime. Tick a. So there's no variance or subtyping involved here. You can mutate through star const if you cast it without ub yeah, so this is why I said like there are cases where you can do this, which is a star const t. You can technically turn into a star mute, which you can then turn into a mut, which lets you mutate. Generally anything that gives you a star const t does so because you ultimately went from a immutable reference and not immutable reference.
01:32:22.951 - 01:32:58.587, Speaker A: And this is undefined behavior. You are never allowed to mutate through a pointer you got from a shared reference. This is never allowed. So that's why I'm saying that you really have to contort yourself. It has to be like you got a mut, you turn it into a mutable pointer to T, which you turn into a const t, which you turn into a mu T, which you like. This pattern is okay, but this pattern is not. The first one is always undefined behavior.
01:32:58.587 - 01:33:43.125, Speaker A: The second one is technically not. It's not undefined behavior. And this is one way in which you might end up with covariance because you stored this thing, but you need invariance because you're accessing this thing. I think vect and box t contain a unique T, not a const which and unique Contains a non null. And in fact we can look at the non null type rust, non null. Oh, I think I have light theme on. Sorry.
01:33:43.125 - 01:34:20.825, Speaker A: So the non null type is interesting. The non null pointer type is a star mut that is non, zero and covariant. So this is a covariant mutable pointer type. And this one you have to be really careful about. So you see how this, in the documentation it says unlike star mut, non null is covariant over T. If this is incorrect for your use case, you should include some phantom data in your type to provide invariance, such as the examples we looked at. Yeah, phantom data cell T is another way to get invariance without introducing a lifetime.
01:34:20.825 - 01:35:17.085, Speaker A: But yeah, you do have to be a little bit careful about using this type because if you're not careful, someone might then be able to pull the mutability invariance trick on you. Does non null. Yeah, non null contains a const, right? And this, like this, this is one of the few cases where you might be able to mutate through a const safely. The question becomes how did you. If you look at, I think if you look at non null, the constructor for it. Yeah, the constructor for it takes a mut, not a const. And the idea here is to prevent you from accidentally doing this by going via a non null, because this is still undefined behavior.
01:35:17.085 - 01:36:12.977, Speaker A: But this is something you might get at through. Through a non null. Okay, I think that's everything I wanted to cover today. And notice that we started out with like a super simple function like Stir talk is what, 10 lines of code. And if you think about it like if you started out with this code, right? Or maybe you. Yeah, this is like you, you started out writing no lifetimes and the compiler yells at you, right? So if we do this, this is equivalent, but it says missing lifetime specifier because it assumes that every reference has its own lifetime. So you're like, all right, fine, I have to add a lifetime and you just like stick tick A on all the things.
01:36:12.977 - 01:36:57.943, Speaker A: Then you very easily end up with this problem without realizing why you caused this problem in the first place. Like, suddenly this function is just like not possible to call. As we saw with the very beginning, we tried to write a test case in the most straightforward way for this function and it wouldn't even compile. And if you get stuck in that, you're like, why, how did this go wrong? And of course, probably what you would do if you ran into the situation might be like, oh, I'LL just do this and then you're like, oh, it works. And then you move on with your life. And it's true that that is the solution, but hopefully over the course of this video, it's clear why that's the solution and why it was a problem when you didn't have the two lifetimes who. All right.
01:36:57.943 - 01:37:28.231, Speaker A: I hope that now you understand variance and subtyping a little bit better than you did when we started. I certainly do, yeah. The other thing, this is a good point. The way I would actually probably write this is this. So we have in Rust today the ability to relied lifetimes. So you can write tick underscore. You can write this too.
01:37:28.231 - 01:37:41.821, Speaker A: But the compiler. And the compiler doesn't yell at you. But I want stop all of this code below here from compiling. I don't. I don't like it. Go away. But I'll keep my test case.
01:37:41.821 - 01:38:09.491, Speaker A: I just want to demonstrate the last thought I'll have here. So you're allowed to write this and it works just fine. But if you turn on rust 2018 idioms, which I recommend you always turn on for warnings, you should get a warning here. Oh, it's only for return types. Actually. You're right. So this is fine.
01:38:09.491 - 01:38:57.055, Speaker A: I tend to like to be explicit about things having different lifetimes, so you can write down this tick underscore. Regardless, it means the same thing. If you have a reference that doesn't have a lifetime associated with it, Rust automatically generates a distinct unique lifetime for each reference. And so this is equivalent to saying that there's some additional tick B and that gets assigned here. So realistically, I think the way I would write this is this instead, because the caller never really needs to think about this additional lifetime. All right, sweet. I think with that, that's all I wanted to cover.
01:38:57.055 - 01:39:20.189, Speaker A: Thanks for sticking with me. Thanks for all the questions. I know it is. It's a journey to get through this. And I know it's like hard to explain sometimes because all of it is very circular and trying to like speculate what the compiler is doing and the type inference is doing, but I hope ultimately we landed in a good place. Thanks for joining. I'll see you all next time.
01:39:20.189 - 01:39:38.345, Speaker A: I'm hoping that the next stream is going to be a live coding stream. I want to do some kind of larger port again. I think doing ports are really fun. I don't know what I'm going to port yet, but I'll announce once I do and that'll probably be longer, like a five, six hour porting. Stream again. We'll see. See you next time, everyone.
01:39:38.345 - 01:39:38.965, Speaker A: Bye.
