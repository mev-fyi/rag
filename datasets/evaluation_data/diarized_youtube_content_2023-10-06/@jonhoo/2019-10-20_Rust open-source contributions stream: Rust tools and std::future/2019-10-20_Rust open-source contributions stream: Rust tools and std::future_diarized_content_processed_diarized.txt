00:00:00.200 - 00:00:47.835, Speaker A: Everyone, welcome back. It's time for another stream. As always, I'm John. I do a bunch of Rust like live programming and educational content and I try to, for all of these videos, give you a say as to what you want to see. And this time we decided we're going to do another open source contribution stream. So we've done one of these in the past where we did some contributions to projects where we tried to sort of tidy up a lot of Async code. This time I wanted to focus more on Rust tooling because I think people are a little bit afraid of trying to contribute to the Rust core tools because they think they're overly complicated or fancy and scary in some sense, whereas in reality they're just open source projects like all the others.
00:00:47.835 - 00:01:18.225, Speaker A: And so in the stream we're going to make a contribution to Cargo and we're going to make a contribution to RustUp. Now, I've made a contribution to Rust up before, but I've never made actually. Is that true? I don't think I've made contributions to Cargo before. I also had a bunch of people when I mentioned this on Twitter ask me whether we could do a converting a crate from future 0.1 to standard future. And so we're going to do that as well. Which order we do these in, I don't really mind too much.
00:01:18.225 - 00:01:39.637, Speaker A: We can order them whichever your preference is. As always, I'm John. Yeah. The one thing I want to mention before we start is I want to say thank you to all the people who've bought me stuff. It's been fantastic. Like now someone complained about last time, the tapping from my keys. You could hear through the microphone.
00:01:39.637 - 00:02:05.655, Speaker A: And then someone bought me a shock mount, which now means in theory that shouldn't happen anymore. So there's an Amazon wishlist that's pinned on my Twitter where you can buy me stuff for the stream or for life. I'm not allowed to have income in the U.S. so this is my workaround for not being able to have a Patreon or something like that. All right, without further ado, let's get started. So. Oh yeah, you can if you want to.
00:02:05.655 - 00:02:33.505, Speaker A: If you want to vote on what our next stream should be about, there's this website here. I can paste it into chat as well for those who are in chat. So this page lets you basically vote on what you want the next stream to be. And we even did a stream on building this site. It uses like ranked choice voting, so it's pretty cool. You can vote on multiple Things and rank them. And this is why we're now doing an open source contribution stream.
00:02:33.505 - 00:03:19.773, Speaker A: All right, so do we want to do cargo first, rust up first, or converting old futures to new futures preferences? I'll give chat. This is maybe one of the few advantages to watching live is you can ask questions and you can suggest order of things and what to focus on. Let's see here. Cargo first. Cargo, cargo, cargo futures, futures, futures. All right, I see mostly cargo, so let's do cargo first. All right, let's see how this goes.
00:03:19.773 - 00:03:57.815, Speaker A: So usually when you want to make a contribution to a project, there are many ways you can go about it. The easiest one is usually to go to the project page, go to issues, and then look for labels. And then usually you might want to look for things like E easy, E help wanted, E mentor. There might even be things like good first issue. In my particular case, I've decided to not do that because I have an issue that I want to get fixed and so I'm just going to fix it. I filed this issue about a week ago and it's been bothering me for a while. So I figured let's just use this chance to, to fix this problem.
00:03:57.815 - 00:04:58.501, Speaker A: So this problem relies on a particular environment and variable you can set when you run cargo. And I don't know how many people know about this, but if you set the environment variable cargo target dir, then any time cargo compiles stuff, it's going to put it in that directory instead of in like a target directory in the current directory, right? So instead of ending up with target directories all over the place, you end up with a single target directory that you can choose where it is. And this is really handy because it also means that you can share compile artifacts. So let's say crate A and create B both depend on crate C. If you compile crate A and then compile crate B, crate B doesn't have to recompile crate C because it's already stored in that shared target directory. And so this is actually really handy for reducing the amount of stuff you have on your system and reducing the amount of duplicate effort and compilation you have to do. And so I have this set, and I have it set in a slightly weird way in that my target dir is a symlink.
00:04:58.501 - 00:05:53.769, Speaker A: So the reason for this is I have a script that I run on all my machines when they boot up, which looks for a symlink in my home directory called cargo target. And if that exists, then they set the cargo target dirt to be that path Otherwise it doesn't set it. And then I can use that symlink on different systems to symlink it to a directory on a different disk, for example, or on temp or something else. The problem that arises, and what this issue describes is that if you run cargo clean, which is supposed to delete your target directory, if you have cargo target dir set, or if target is a symlink, then it will only remove the symlink. It won't remove the contents inside of that directory. So this is pretty, pretty annoying. Let's see if I can give you an example of this.
00:05:53.769 - 00:06:28.775, Speaker A: So let's do something like let's make this a little larger dev temp and let's do cargo new libf. Oh man, fubar. Great. Not enough temporary names. Okay, so if I do cargo build, then you see there's no target directory here. And this is because I have cargo targeter. So I have cargo target dir set to this path.
00:06:28.775 - 00:07:21.955, Speaker A: I can unset it. And if I do, if I do this B, then you see, now there's a target directory here, and if I look inside target, there's a bunch of stuff in there that is related to the current project that I built. Where this gets. And if I run cargo, if I run cargo clean, you'll see that the target directory now goes away, which is what you want. Now where this gets weird is if I make some like my target and then I ln my target to target. So if you now look at the directory listing, target is now a symlink into my target. All right, so now I'm going to run cargo build and you'll see now that if I LS target, or rather if I LS my target, then the stuff is in there.
00:07:21.955 - 00:07:50.471, Speaker A: But if I now run cargo clean, notice how the target symlink goes away. But my target is still there. And inside of my target there's still all the stuff. So cargo clean just removed the symlink. It didn't actually clean anything. And this is annoying because it means that not only does nothing get deleted, but also my SIM link went away. And so now suddenly my cargo targeter won't get set.
00:07:50.471 - 00:08:18.665, Speaker A: And this is all sorts of annoying. So this is a relatively small issue in cargo, but it's one that's just been bothering me for a while. So instead of just complaining on it and an issue, let's just fix it. Let's see. Yeah, exactly. So the thinking here is that we want to, instead of just deleting the top level symlink, what we want to do is detect if it's a symlink, then delete everything below it. Otherwise you can just delete the top level thing.
00:08:18.665 - 00:08:59.113, Speaker A: I know that if we look at removed, is that the function for the standard library removed or. All right, so I think this is what Cargo currently uses. But notice that it does not follow symbolic links and just removes the symbolic link. Right? So this is the behavior that Cargo exhibits and this is the behavior that we don't want. How do we keep track of what we own in the simulink directory if it's shared? So Cargo doesn't actually care. If you run Cargo clean, this is going to delete the entire target directory. It doesn't check of the stuff inside of it, which like arguably is a problem in and of itself.
00:08:59.113 - 00:09:58.485, Speaker A: But it's not something that we are going to be solving in this stream. Probably because it's a larger issue. All right, so now we know what the problem that we're trying to solve is. Cargo, conveniently, I already have cargo checked out. What you'll see is that the way I have this set up is I have two git remotes, I have one called Origin which points to my fork and then I have upstream which points to the upstream cargo. And the way I do this checkout, actually I can just show you is that I do git clone and then I clone the upstream thing, right? And then I rename origin to upstream. So this way the master branch locally for me still tracks the master from upstream, not from my fork.
00:09:58.485 - 00:10:44.861, Speaker A: And then I do git remote at origin and then I add my fork because now when I push push new branches to origin they will appear in my fork, but I can still pull in master to get the upstream master. So the question now becomes, okay, we now have a checkout of cargo. Now what? Right? Where do we start? Well, let's look at what's in the cargo directory. So good places to start are usually the readme and also files like contributing architecture might be handy. We might need that later to figure out where we're going to make this change. But let's start with the readme. So the readme talks about installing cargo compiling from source.
00:10:44.861 - 00:11:10.847, Speaker A: That seems promising. Okay, so it looks like it's just like cargo build. We don't actually need release because we're not going to be running this in a performance sensitive way. The fact that they use cargo build makes me think that we could just run Cargo test if we want to run the test suite. So let's look at contributing, working on issues. Yeah, so here they talk about things like E easy and ementor. Like I mentioned before, opening new issues.
00:11:10.847 - 00:11:27.315, Speaker A: There's a cargo discord where you can discuss issues. It must compile unstable rust. Okay, that's fine. Fork and pull. That's fine. Basic steps for cargo. Create a branch code style.
00:11:27.315 - 00:11:40.763, Speaker A: That's fine. Commit as you go. Include tests. We're going to do that. Make sure cargo test passes. Okay, so this makes me think that cargo test is all we need. Cross compiles we can probably disable.
00:11:40.763 - 00:12:12.237, Speaker A: So we probably want to. I think we probably want to just ignore those. Okay, so in theory, we should be able to run something like cargo test. And so that I don't break the stream, I'm going to run it with only one thread. You could also add your own fork as origin only for push, and the upstream is origin for fetch. That's true. I think it's just easier for me to think about master.
00:12:12.237 - 00:12:35.913, Speaker A: Like I'm never going to push to master anyway, so I just want master to be tracking upstream anyway. And then I just want any branch I make to track origin. Okay, so the test suite seems to be working. So at least now we know that we can compile cargo. But I'm not actually going to run all of these. It seems relatively unimportant. The question now becomes, how does clean run? And there are many ways we could look at this.
00:12:35.913 - 00:13:03.941, Speaker A: The easiest one might just be to search for clean and see what we find. Okay, so there's a bunch of stuff in docs. Aha. Bin cargo commands. This seems pretty promising. All right, so there's a clean CLI that seems very promising. And there's a mod in here called clean.
00:13:03.941 - 00:13:42.575, Speaker A: What does clean do? Okay, so now we found where clean happens. Oh yeah, someone's asking. You can see whenever I type commands in vim, you can see them down in the bottom right corner here. And someone was asking, what does double double quote plus y do? I don't think there was a T. Oh, so T lets you select until a particular character. So if I do so the double quote plus means copy to the system clipboard. Y means copy.
00:13:42.575 - 00:14:09.241, Speaker A: Like the I set the destination to plus that's a double tick is set the destination of whatever you do. Plus is the system clipboard. Y is copy. T is until the following character and something like semicolon is going to be copy everything until semicolon to the system clipboard. Okay, so we have cargo clean. Let's see what it does. Clean options.
00:14:09.241 - 00:14:32.123, Speaker A: Huh? Ops Clean. Cargo ops. Okay, so it looks like what we want is maybe cargo ops. Cargo clean. Great. All right, so here we see these clean options. I wonder whether we want.
00:14:32.123 - 00:15:10.429, Speaker A: Actually, let me start a new branch for us. Let's call it delete through simlink. Actually, no, let's call it clean through simlink. We might want to add an option actually that lets. Actually, it's unclear. I wonder whether we want an option to say delete through symlinks or don't delete through symlinks. But when would you ever want it to only delete the symlink? There might be cases.
00:15:10.429 - 00:16:06.985, Speaker A: So that would be the argument for adding an option. I think we're going to not add an option to begin with and then take it from there. What if you want to copy anything up to a sequence of characters rather than a single character? So then instead of t, you can use slash, which is search. There's also there are plugins for adding additional nouns as they're called in vim, such as like do a search for a double character, which is usually S, but I find that I rarely need them. All right, so clean sub packages, build artifacts. Okay. So it's interesting because many of these are not a problem, right? So if you have doc set, then it's going to look at doc inside the target dir.
00:16:06.985 - 00:16:34.479, Speaker A: So if the target directory is a symlink, then doc will not be a symlink. Doc will be a directory inside the symlink. So this is fine. This too, like this looks ins. If a profile is specified, then it's going to look inside the target directory. So the target directory being a symlink is not going to be a problem. Yeah, whereas this is the real thing, Right.
00:16:34.479 - 00:17:07.813, Speaker A: If you haven't specified what to clean. So with cargo clean, you can do things like dash P and give the name of a crate. For example, you can give like doc to clean only docs. There are a bunch of options you can give, but if you haven't given any options, it just deletes the whole target directory. It looks like all of them call this RMRF function. So. Hmm, that's a very good question.
00:17:07.813 - 00:17:55.935, Speaker A: One thing we could do here is. Huh, yeah. So I think maybe the fix here is going to be just changing RMRF to check whether something is a symlink. And if it's a symlink, then we want to. Then we want to delete all the stuff inside of the symlink rather than the symlink itself. Also, one thing I want to point out, notice how quickly we got to this point, right? We had a bug in cargo and now we're editing cargo source code and like it's using Clap. It's just a normal Rust program that you can make changes to.
00:17:55.935 - 00:18:35.231, Speaker A: And it might even be that this change is going to be local enough that it's just inside of this function in cargo clean. We'll also want to write a test for this, although in theory that shouldn't be too hard. I think here. So this uses FS metadata. Why do they unwrap or false instead of issum or is? Okay, they can't because is dir. This is an option bool and so they want the bool. If the bool is there isn't the correct fix to resolve the symlink and then run removed or all in the resolved path, the symlink would be orphaned.
00:18:35.231 - 00:19:21.385, Speaker A: But I think it's closer to the behavior without symlink. What if it's a symlink to a symlink? Yeah, that's a good question. So the proposal here is maybe the thing to do is if path is a symlink, then resolve the symlink and then basically retry because that way you would remove the target of the symlink. So there are two considerations here. One is would this fix my issue? And the second is what is the correct behavior? I agree with you that resolving the symlink and then deleting the target of the symlink. So in our case of the. Let me bring that up.
00:19:21.385 - 00:19:52.861, Speaker A: In the case of our example here, right where we had my target target. So if I run now ran cargo clean, what that would do is it would delete. Delete my target. But I don't actually know what that would do. Okay, so let's. Let's try to emulate this, right? If what we did was just delete the target of the SIM link rather than its contents and leave the directory in place, that would be equivalent to running this. This is the state you would be in.
00:19:52.861 - 00:20:25.313, Speaker A: And notice that this SIM link is now dark dangling. Let's see what happens if we now do. Yeah, so notice how this now fails because it doesn't try to create the target directory. This is also somewhat important. Imagine that the. The shared target directory is on some shared drive where you aren't allowed to create directories. So someone else created it for you with the necessary permissions for you.
00:20:25.313 - 00:20:59.091, Speaker A: You don't actually want to delete that directory because you wouldn't be able. You might not be allowed to delete it because it's in a directory someone else owns. But Also, if you were able to delete it, you might not be able to create it again. So I think we actually might want to delete the contents and not the directory itself, which is a little weird. It's almost as though the behavior should always be to just delete the contents. Mmm. I don't think we need a max depth.
00:20:59.091 - 00:21:31.685, Speaker A: Well, maybe so it doesn't iterate forever. I think we should delete the target of the symlink. Yeah, exactly. So is there a reason not to just empty the directory in all cases rather than deleting it? Yeah. So that's what I'm wondering whether what it. I'm wondering whether that's what it should do. It doesn't mean that you're left with a bunch of empty target directories, but it's a little bit tempting to just delete the contents.
00:21:31.685 - 00:22:03.135, Speaker A: Hmm. The other question is if we delete just the contents. Yeah. I think that that might be what we need. We could have a special. A special case for if. If none of it was a SIM linked, then just remove the top level just so we don't regress in the current behavior.
00:22:03.135 - 00:22:28.421, Speaker A: So maybe that's the way to go. And we will also need tests for this, of course. Okay, so in order to do any of this, the first thing we're going to need is to know whether something is a symlink. So they call this FS metadata. Right. Which returns one of these. This function will traverse symbolic links.
00:22:28.421 - 00:23:13.455, Speaker A: Well, that's unhelpful. Oh, man. All right, so we need to find some way to determine whether something is a symbolic link, which is going to be this thing. Yeah, I think this is. So we're going to have to make this be symlink metadata. And I assume here that there's something like is link. What are these? Oh, no.
00:23:13.455 - 00:23:38.165, Speaker A: Extension traits for different operating systems. So there's not a single is link. It's also weird because on Windows there are only hard links. Ooh, file type though, maybe. Oh, ha. Is SIM link. Great.
00:23:38.165 - 00:24:07.095, Speaker A: All right, so we're going to have to do is to figure out whether it's a symlink is going to be M as ref. That's fine. Map. And that's going to. Does this deref. Is that why they're able to. Yeah.
00:24:07.095 - 00:25:00.855, Speaker A: Filetype issymlink. Right. Unwrap or false. And now if it's a symlink, then we want to do something. Right. You see the pattern? What's the downside of removing the top level directory? If someone created a directory for you can't you just create the top level directory inside this top level? No. So the argument is someone created a target directory for me to use in a directory that they control and I do not.
00:25:00.855 - 00:25:30.425, Speaker A: Right. And so if that directory gets deleted, I can't create it again because I don't own the parent directory if it gets deleted. Now, there's an argument that the removal would fail, but that's still a problem. That means cargo clean would always error. So I think what really what we wanted to do is only ever delete the contents and leave the directory intact. And the exception might be if target is in the current directory or something like that. Yeah, you're right.
00:25:30.425 - 00:25:47.405, Speaker A: So if we assume that the directory is owned by someone else, then we wouldn't be able to delete it. But that would mean the cargo clean would fail. Whereas it seems weird for it to fail if it just. If it could delete everything except for the top level, if it could leave an empty top level. That doesn't seem like it should be an error. Right. At least to me.
00:25:47.405 - 00:26:55.321, Speaker A: Yeah. So the question here, I think, is really one of. Actually there's an argument here that we don't even need to detect whether it's a symlink. I think really what we want to do here is to change the behavior here where if it's a directory, then remove all its contents without removing the directory itself. Unfortunately, that's not entirely straightforward. Where does paths come from? Paths join, paths normalize, path remove, dur all. They already test for whether something is a symlink, and if so, they.
00:26:55.321 - 00:27:27.295, Speaker A: It's interesting because it's implemented so that it specifically will just delete the symlink, which is not really what we want. Huh. I wonder why this code is here. Let's find out. All right, it's going to get bright here for a second. Let's. Where is this? Source cargo util paths.
00:27:27.295 - 00:28:11.983, Speaker A: Source cargo util paths. And then we're going to use blame. Great feature. Now let's look for where's our remove path here? I want older versions of this file. Apparently older versions did not have that. Okay, fine. So this is probably what added this remove business.
00:28:11.983 - 00:28:42.865, Speaker A: Yeah. So why did Alex add this specifically? Why is the SIM link clause here? This suggests that he really wants us to just delete the symlink. Hmm, that's a good question. It's interesting because this actually does walk the directory. Hmm. So this is the code path that we want. In theory.
00:28:42.865 - 00:29:46.419, Speaker A: One way to fix is just to comment this out, or perhaps even better, to Say here, if it's a. If it's not a symlink, then removed that. Right. So this way, if it's a symlink, it's going to delete all the contents. Or actually regardless of what it is, if it's a directory, it's going to delete all of its contents. And then if it wasn't a symlink, then it's also going to remove the top level. Don't you need to check whether it's assembling? Because it is.
00:29:46.419 - 00:30:02.737, Speaker A: You cannot treat it as a directory when you're recursively deleting a directory. You can. You can do things like redir on a symlink. That's. That should work fine. At least I believe that to be the case. That's a good question.
00:30:02.737 - 00:30:32.091, Speaker A: I'm fairly sure that's true. Interesting. Yeah. I feel like this is what you want, right? And now we don't even need the SIM link change. In fact, this doesn't have to change at all. This does mean that we've now changed behavior for anywhere that tries to delete files through that removed. Er.
00:30:32.091 - 00:31:13.607, Speaker A: Right. And then this now should still be this. The only question is whether Reader works on symlinks, but I believe that it does. Why not follow the default behavior of RM and Unix, follow SimLinks and delete all the folders, including the top level folder. So the reason for this is, as I said, I. I don't want it to delete my symlink. So RM and unix, if you delete a symlink, only the symlink goes away.
00:31:13.607 - 00:31:48.485, Speaker A: And that's specifically the behavior that I don't want because it means that my cargo target directory cannot be a symlink because it's going to go away each time, which sort of ruins the point of having it be a symlink in the first place. Do you need to change symlink? Yeah, exactly. So we did that, removed all recursives and now won't delete. Nested symlink makes it a directory non empty when trying to delete. That's not true. Oh, I see this one. I see what you mean.
00:31:48.485 - 00:32:22.991, Speaker A: Yeah. So the problem is being pointed out is this function is recursive. So here, if it finds something that is a directory, then this might be a symlink. And now this symlink won't be removed because we just made it not remove symlinks and therefore this removed will fail because the directory isn't empty. So the question really comes down to do we want it to preserve. Do we always want it to preserve all symlinks, including nested symlinks? Right. Like if my target directory is a symlink or in fact even just ignore that.
00:32:22.991 - 00:32:49.105, Speaker A: Imagine my target directory is not a symlink, but it contains a symlink. Like the debug directory in there is a symlink to somewhere. Like for example, I have debug and release beyond different disks or whatever. Like they're both symlinks. Then the way we've currently written this is those would both be left behind. They wouldn't be removed because they're symlinks. But when we try to remove the top level directory, which isn't a symlink, then this call would fail.
00:32:49.105 - 00:33:28.215, Speaker A: I think we want to preserve all symlinks. I just like really don't think we want to. I really don't think you ever want to delete the symlinks. But I could be wrong. I think in some sense I'm only concerned with the top level behavior at the moment. SIM linking deeper down in the target tree seems less likely. But let's look at where else uses remove all.
00:33:28.215 - 00:33:52.987, Speaker A: Okay, so this uses fs. Interesting. That's awkward. So different things use different versions of it. Like some of them use fs. Wait, there's also a crate called Removed or All. Oh man, look.
00:33:52.987 - 00:34:26.787, Speaker A: This uses Removed or all the crate. Interesting. What we could do is add like one version, that's the base case here. And once that's the recursive version and only delete the top level. But the use of Debug and release symlinks, it makes sense to keep them. Their contest would be removed, which feels like that's when intended with cargo Clean. Yeah.
00:34:26.787 - 00:35:05.924, Speaker A: So that's my thinking as well, that you never want to delete the symlinks. The only question then becomes, do we ever want to remove the directory? And I think we do. Otherwise we're just going to leave tons of empty directories around the place. Okay, here's a proposal. It's a little bit sneaky, but what if we do removedir and if it fails, we just ignore the failure? Right. RemovedIR will only succeed if there's nothing inside of it. I think that might actually be what we want to do.
00:35:05.924 - 00:35:58.105, Speaker A: We allow this call to fail because if there are symlinks left within the directory, deleting the directory would fail. But we also don't care about that failure. Keeping track of whether we did this intentionally would be pretty painful. So we just let the OS do the checking for us. How about that? You could ignore not empty errors. Oh yeah, that's. That's a good idea.
00:35:58.105 - 00:36:39.315, Speaker A: What's the kind. Am I blind? I don't think there's an empty that we can easily get at. Yeah, I think. I think that just get gets races other. So I don't think we can actually detect. We could write that here in theory. If error kind not empty was available to us then that would.
00:36:39.315 - 00:37:24.375, Speaker A: Then we could be less. Let's just say. Actually let's do. If ericai not empty was available, we could only ignore the relevant error. But sadly it is not. Yeah. So the problem is we can't actually get at that specific error.
00:37:24.375 - 00:37:41.615, Speaker A: I think it gets raised as other. But keep in mind that if someone like the permission errors will still come up when they. When Cargo tries to delete the stuff below. Right. This is. We're only ignoring the error for removing the top level directory. Right.
00:37:41.615 - 00:38:25.715, Speaker A: We're not ignoring any of the other errors. Well, what we could do is. What we could do is just look for other. Yeah. So if I don't have permission to delete the target directory, but I have permission to delete the contents, I don't think Cargo clean should error. I think that's fine. It should leave the top level directory in place so that I can keep reusing it.
00:38:25.715 - 00:39:01.525, Speaker A: Yeah, I think it would show as other. I think you're right other with the code 39. But the thing is I wanted to also not show me permission errors. Right. So this is the example of if I have a target directory in a place that I don't control, like someone made the target directory for me on like a shared drive or something. I don't want it to try to remove because it would fail. It would get a permission error and I don't want it to remove that directory and I don't want it to treat that as an error.
00:39:01.525 - 00:39:32.485, Speaker A: Note that. So let me type that. It's a good point. So let's type it up. Note that we intentionally do not propagate other errors. Permission denied. In particular, because the top level directory may be in a shared directory, the user does not have write permissions to.
00:39:32.485 - 00:40:34.641, Speaker A: In which case we want to leave the target there so we can keep using it in the future. Actually, that's poorly phrased. Not that we intentionally do not probably get other errors because the top level directory may be in a shared directory. The user does not have write permission to. In that case, the user will want to leave the target dir there so they can Keep using it in the future and will not expect a removal error for that directory. Well, keep in mind that you will still get permission errors, right? Like all the other removals or the first of the other removals will still raise a permission error. This is only ignoring it for removing the top level dir.
00:40:34.641 - 00:41:33.945, Speaker A: Right? So I think this is still the behavior that we want. Permission denied will still be raised when trying to remove the contents of the directory. So this shouldn't be hiding errors that are relevant to the user. So I think this is actually the behavior that we want. All right, so now the question is, how do we test this? Well, what do we see in the tests directory? Is there a particular test suite for clean? That would be nice. Aha. Test suite clean.
00:41:33.945 - 00:42:09.375, Speaker A: Test suite clean. Won't it be for removing any dir within the hierarchy? You're right that it's any, any empty directory in the hierarchy, but removing any files, you'll still get this error. So I feel like you will see the error. Like it. It seems like it would be a really weird case if only removing directories would have errored. And you want to know about it, right? I agree with you. It.
00:42:09.375 - 00:42:48.185, Speaker A: It feels a little weird, but I think it's the right thing. Okay, so now, um, let's just first make sure that we didn't break something. Let's do cargo. Oh man. Why is that? This is why. What? I want test suite clean and I want clean. See what that gives us.
00:42:48.185 - 00:43:26.595, Speaker A: So notice I haven't added a test for us yet. I first want to see that making this change doesn't break anything else. It probably will, actually. There's probably a test that checks for whether no target should be removed. It shouldn't break anything. Okay, all of those passed. Let's look at Build script clean Get Registry clean verbose.
00:43:26.595 - 00:44:09.293, Speaker A: Okay, I think we add this pretty early on. Cargo clean leaves symlinks. Oh, there's a test support package. What does it do? Lib Cargo has a variety of integration tests that execute the cargo binary. Okay. It creates a sandbox. That's fine.
00:44:09.293 - 00:45:10.247, Speaker A: The real question is can I use it to make a symlink? That's really all I want to know. Symlink in tests Test suite package SIM link. Interesting. Okay, so we're going to need this thing, right? This symlink supported business because it says here like we own, we can only run a test that uses symlinks if symlinks are available to us. Right? So we're going to stick this in here. What else does it do? I don't know what T is here. Macro.
00:45:10.247 - 00:45:38.737, Speaker A: Okay, so Cargo test support has a macro. Unclear what it does. Macro is T. Oh, it's just an unwrap. Okay, that seems relatively less important. The best thing would probably be that you only delete the files that are from your project out of the simlink directory, or at least as an option. But I don't know if that's possible without changing run, build, check, and so on.
00:45:38.737 - 00:46:15.861, Speaker A: I don't think we can do that because Cargo doesn't really track those files, and adding that would be a much larger effort. Yeah, so. So Holger Cargo clean will still error. Like the way we change it now, it will still error whenever it tries to remove any file. It's only for removing the empty directories that I'll ignore the error for. All right, so what does this do to actually add a symlink? It just symlinks them. Great.
00:46:15.861 - 00:46:55.015, Speaker A: So in theory, we can just do the same thing. So we'll create a project. That's fine. Why is there a foors? That's fine. We can leave foors there. And what we want to do is we want to. Now, I need to remember the order of arguments for symlink source and destination.
00:46:55.015 - 00:48:07.353, Speaker A: The destination path will be a symbolic link pointing to the source path. All right, so this is going to be the link target, and this is going to be real target, which also means we're gonna have to make a directory here somehow. Is there a way for us to test support project Paths Project get paths publish and registry. All right, so where does project comes from? Some down here. Oh, simlink builder. That seems handy. Wait, that's perfect.
00:48:07.353 - 00:48:31.805, Speaker A: Okay, so we have a SIM link builder. That's something I want. Okay, so then maybe we don't need these. And then what we want to do is SIM link builder. Let's look for someone who uses that. No one uses that. Great.
00:48:31.805 - 00:48:59.465, Speaker A: Wait, it's also not pub. That's unhelpful. Oh, great. There's a simlink dir on project wait. This is fantastic. All right, fine. Dot symlink dir and order is destination and source wait.
00:48:59.465 - 00:49:36.335, Speaker A: That's all sorts of confusing, but okay. What is the. It's symlinking, but that's the opposite of what this does. The first argument is source. Oh, man. Why? Okay, so destination here is passes the first argument, which is destination here, which is used as the source. Okay, so we need to flip these in our head.
00:49:36.335 - 00:50:17.995, Speaker A: So. No. Okay, the first argument is the first argument. It's just that they're Named differently. So we still want real target to point to. I think we want this. I also think we want real target debug to point to real debug.
00:50:17.995 - 00:50:51.525, Speaker A: And now. Oh, won't the strategy of leaving symlinks cause issues with any SIM links generated by cargo itself? Maybe it might very well be that cargo generate symlinks. But then I don't think removing them as a problem. I mean the test pass. That's a good indicator. You are right though. I don't know.
00:50:51.525 - 00:51:51.493, Speaker A: I don't know. It might be that we can detect cargo SIM links at least, but I'm not sure. All right, so what do we want to do? Well, we want to check that builder join real target. Actually, let's not even do that. We want to make sure that the build directory. What is the build directory? Is that just going to be target? Great. So we want.
00:51:51.493 - 00:52:30.895, Speaker A: We want the build directory to still exist in this case because it was a symlink. We want the target target debug dir to also still exist because that was a symlink. What else do we want? But we. What we want though is we don't want join. So this is where it's going to get fishy. Which is what inside of that. What can we look at inside of this? I guess build.
00:52:30.895 - 00:53:31.225, Speaker A: We don't want build to exist inside of there. So this is cargo Clean leaves SIM links Clean leaves leaves. Let's see how that works. That's fails. Why is that path was erroneously implicitly accepted for binary foo. What? Oh, that's fine. We don't need it to be a binary.
00:53:31.225 - 00:54:47.985, Speaker A: Now what? Can't find foo bin specify bin path. Wait, does project require us to. To actually set a library? Seems unlike. Huh? Oh, basic bin manifest. That's not what I want. I want basic lib manifest basic I want basic manifests and I want it to have name and version. Sure.
00:54:47.985 - 00:55:41.345, Speaker A: Which I guess means that there was also an. What was it called? Target debug dir. There was also something else down here which was example lib path to an example built as a library. Oh no, that doesn't really help me. Okay, that's fine. See what that does. So what are we doing? Well, so what we're doing is we are basically there's an issue in cargo that's been bothering me for a little while and we're trying to fix it, which is that if your target directory is a symlink, it removes the symlink but not the contents.
00:55:41.345 - 00:56:47.035, Speaker A: Fail to create directory. Really? Why did it fail to Create directory. Oh, I wonder whether Cargo doesn't support making debug be a SIM link 846. Okay, that's relatively unhelpful. Well, actually, no, it fails in run. But which run build or clean? Clean line 35 fails in build. Yeah, I think it might not support this, which seems like also an issue that someone should fix.
00:56:47.035 - 00:57:28.175, Speaker A: Fail to create directory, target debug file exists. What? No. Oh, we're not cleaning up after ourselves. That's probably why. Was that what this got as well? File exist. Okay, never mind. This is fine.
00:57:28.175 - 00:58:48.925, Speaker A: The problem now is when we run the test and then run the test again, the test doesn't clean up after itself because these things still exist because the clean doesn't actually clean everything. So the question is, how does this do its cleaning? No, although these don't clean, I have this sneaking suspicion that. All right, let's. Let's see if I'm right. Clean tests, clean targets. All right, what does clean targets do? I wonder whether this does actually. I wonder whether the testing script actually uses cargo clean to clean, and therefore it doesn't clean up after this project because the SIM links are still there.
00:58:48.925 - 01:00:00.297, Speaker A: Which, like, is fine. It's just P dot build, I guess. Target debugger unwrap. And this should be builder, although I'm not actually sure where those files would be. Where does it look? All right, let's just remove that cargo integration tests and then try to run it again. Ooh, that's true. Mator won't fail if directory exists, but if it's a simulink, it will.
01:00:00.297 - 01:00:30.575, Speaker A: Yeah. How'd you set up your cargo target dir variable? I set it in my. In my bash setup script. What? Linux distro. This is Arch Linux File exists. Huh. This makes me think that cargo really doesn't like if the debug directory is a symlink.
01:00:30.575 - 01:01:11.309, Speaker A: I guess one way to really find this out is to do this. Isn't there a way to have a protest function? Temporary directory gets removed, not reused when the test runs again. That would be nice. Although I want to see whether this is really the issue. Yeah, here it fails again, even though now debug isn't a symlink. So something is fishy in this pond. All right, what about now? Now there are no symlinks.
01:01:11.309 - 01:01:37.711, Speaker A: So now in theory, the test should just fail. The Arch Linux wiki is actually really good. Makes it a lot easier to install. Yeah. Oh, now, okay. Huh. So it's really the target directory being a symlink.
01:01:37.711 - 01:02:39.165, Speaker A: It doesn't like, which makes me think that it doesn't actually. It's the build that fails. Why does the build fail? Huh? It's a very good question. I feel like we've somehow, like, messed up our environment. I want to see the path here again and see if I can find out what's going on. So let's just sort of CD over to here. We are removing the target of the symlink.
01:02:39.165 - 01:03:13.275, Speaker A: This is what we didn't want to do because it breaks the symlink and that's probably what it's complaining about. It might also not like that. This is also called foo, but that shouldn't really be a problem. All right. Okay. So this is a problem in our code in particular. I think what we need to do is path.
01:03:13.275 - 01:04:10.225, Speaker A: Why is it removing the target at all? Some interesting stuff right there. I have the feeling that clean should remove everything as it does by default. If you want symlinks as an environment where everyone created when run. Sorry, I don't want Cargo to create symlinks. I wanted to not remove them if they're there. The simlink dirt actually create the repository. You're simlind your sim linking two though perhaps it only creates the symlink.
01:04:10.225 - 01:05:06.805, Speaker A: It looked an awful lot like it. Pretty sure it creates it as well. Sim link builder Builder New new dir build for file and symlinks. It calls MC and mc. Yeah, MC does mkdir P. So it should create the target and then some links. Hmm.
01:05:06.805 - 01:05:32.987, Speaker A: And you see the sim like is created correctly as well. Right. That. That is the path we expected to point to. So file exists. Actually, here's what I want to do. Mmm, hang on.
01:05:32.987 - 01:05:54.747, Speaker A: That's a good point. This is the state because the build fails, Right? We're still in line. 35 is the one that's failing, I assume. 35. Yeah. So because what fails is the build. This means that this is the directory layout that that cargo is working with.
01:05:54.747 - 01:06:14.379, Speaker A: So that does make it seem an awful lot like the target directory isn't created. Yeah, you're right. You're right. Maker P only creates the target. Parents. How weird. Like, why is that? I mean, that's fine.
01:06:14.379 - 01:07:10.615, Speaker A: I guess we can always just create. I guess we can just create the directory ourselves. But how weird that it doesn't create the target of the symlink. That seems to make nierdir kind of useless. Like, okay, who uses symlink dirt? That's not helpful. It's used only by test suite package probably. That seems wrong.
01:07:10.615 - 01:07:55.645, Speaker A: Okay, it's used in one place and there the target. It doesn't matter if the target exists. I kind of want to change this to create the directory itself as well. Oh, it's because they don't know whether the. No, I think if self source is dir then it should do this. See, I don't know if that's even a thing that I can do. No, probably.
01:07:55.645 - 01:08:53.082, Speaker A: What? That seems incredibly false. All right, well, I guess we have to create the thing ourselves. Fine, fine, we can do that. That just means that we need to go back to our test suite and here we're going to have to say before build runs, we're going to have to do. Wait, why can't it find make dir? Ah, it's called creator. Yeah, see, there's create dur all. But that's fine.
01:08:53.082 - 01:09:30.515, Speaker A: Like if this it calls mkdir P. It's. It's all fine. We'll just use this. So we'll do creator P dot router join real target, unwrap test so we can unwrap and debug. And now in theory, we don't need this. I think.
01:09:30.515 - 01:10:00.435, Speaker A: Yeah, Daniel, they call it on the parent. I see that. I'm just wondering why. But it might not matter. Let's see how this does. Oh, I probably still need to do this. It's not called router.
01:10:00.435 - 01:11:17.487, Speaker A: Am I missing something? Apparently I am. Oh, this is called root could not. This is another cargo error I've been seeing lately and I don't know why it happens or I have to do what? That's bizarre. No, no, I understand why they have to create the parents first. I'm wondering why they don't also make the directory file already exists. Where? I mean, I'm sure it does, but where? Line 35 again. Wait, now real target already exists.
01:11:17.487 - 01:12:05.255, Speaker A: What? All right, if they say so. Oh, because it's reusing the directory layout. Fine. We don't care if it errors. Actually, no, we do care if it errors. We have to do. I guess if FS isn't there a file exists.
01:12:05.255 - 01:13:09.395, Speaker A: Okay, I want a handy way to do that, but apparently not. Basically we only want to create it if it doesn't already exist. So I guess if Let air be is this if e kind is error kind. It's just file exists. Right, I forget, already exists. It's real sad that this like needs to be this verbose. I mean, needs to is a strong word.
01:13:09.395 - 01:13:53.115, Speaker A: Let's see how that works. The only reason for simlink versus simlink dir is because of Windows. Yeah, I guess my argument is More that if it's a directory which they already know, then they should also create the directory that the the symlink that's being created is pointing to. And they don't. And I'm not sure why it would be more consistent behavior. If an end you have your target set as a path, then during build, cargo should create symlink to that instead of dir. So that's not actually the problem either.
01:13:53.115 - 01:14:29.185, Speaker A: The problem is when you run cargo clean, what should it remove? And I'm arguing that should not remove my symlinks because I place them there for a reason. Failed. Ooh, okay, so now we're getting a failure at the assertion on line 51. So that seems like a better place to go. We're getting an assertion failure that the target debug. Oh, okay. So clean correctly did not remove our top level directory.
01:14:29.185 - 01:14:56.615, Speaker A: So that's good. But it did remove whatever that. It did remove the. Actually, let me just go there. Over here. Let's see what's in target. Ooh, okay, so it did remove the symlink in there.
01:14:56.615 - 01:15:47.031, Speaker A: So why did it do that? That is a good question. Does that. Even if we start from scratch, why can't we clean up after tests instead of putting if logic check for the tests? So that doesn't work because if the test fails, the code after that removes wouldn't be run. Otherwise it would be attractive to just remove it at the end of the test. It's a little weird that they have this setup where the build directory isn't cleaned each time. What did I just do? Right now I want to see what's in here. Target still points there.
01:15:47.031 - 01:16:41.585, Speaker A: But what was inside. What was inside real debug was not removed. So this suggests that real debug was treated as a. Actually, I kind of now want to just do this, actually this to see that we in fact get what we expected here. Just that the layout of these directories are what we expect. Yeah. All right, so there is a debug and it is a symlink.
01:16:41.585 - 01:17:30.105, Speaker A: So the question now is I still think I'd remove everything at the beginning of a test and not have to care for last test run artifact. But maybe I'm missing something. Or remove at the beginning of the test. Could remove at the beginning of the test. That seems fine. So you're arguing that we should do removed, er, remove. Well, it can't actually be removed, but it can be removed all.
01:17:30.105 - 01:17:56.435, Speaker A: And then we would have to ignore errors from this and ignore errors from this. In some sense I'm agreeing with you that this testing infrastructure seems weird to me. It's more that I don't want to change Cargo's testing infrastructure as a part of this pr. That seems excessive. It's only true. We can do this though. That will help clean up a little bit.
01:17:56.435 - 01:18:37.185, Speaker A: Okay, so the symlinks seem to be set up in the right way. And after build things seem to be correct. But then after clean the debug symlink goes away. So that should suggest that there really is an issue in our code somewhere. Remove dir all. Let's just give ourselves something to work with. Recurse.
01:18:37.185 - 01:19:27.035, Speaker A: I guess actually this. You have to do this, I think. Right. See what this gives us? Yeah. I mean, there are many times when I want to fix a bunch of things, but I need to constrain myself to only make the change that's sort of relevant here. Right. All right, let's see what this prints.
01:19:27.035 - 01:20:11.901, Speaker A: So. Well, that didn't print anything at all. Why? Oh, this is probably an artifact of how the tests are running. That's kind of awkward. Fubar. Because what it really does is it like compiles Cargo and then runs cargo. At least I think that's what it does.
01:20:11.901 - 01:20:40.055, Speaker A: Which makes running the test a little weird. But I don't know why I would just swallow our output. Unless this code is just like not called at all. But that seems weird too. Well then that's particularly unhelpful. Let's look at Test suite Lib Build Lib. No Test suite.
01:20:40.055 - 01:22:31.835, Speaker A: What's even in test suite? What does Cargo test actually do? And where does Cargo test come from? It's a lot of give me a this maybe test macro. All right, what does it do? It's just gonna run my thing. But it's a very good question. Why is my output not visible at all Even if I go here? Those helpful print messages. Right? Yeah, I think it's just totally suppressing our output, which makes debugging a little bit more annoying. It's also not trivial to attach GDB here because it goes through a bunch of levels of indirection, but we can try. Alright, so we're not getting prints, so we're gonna have to break out some gdb.
01:22:31.835 - 01:23:37.005, Speaker A: So let's do what does it actually give me here? Running this just recompile. Yes. It builds the cargo binary. That's my concern that it ends up running this as a binary for us, which is the reason we don't get the output. All right, so this ends up running this. So you give me that with v Want to see the exact command? Let's run this command. And now run this.
01:23:37.005 - 01:24:23.695, Speaker A: And I want to break at paths RS line 291. Yeah, exactly. So it really spawns a new process. Test support source lib. All right, fine. Test support source lib. What? Support source lib.
01:24:23.695 - 01:25:18.759, Speaker A: All right, so what does FN clean, then run. Aha. Run output. Okay, so test suite clean. Can I run output of this, please? I don't need V. Is there an interactive step by step debugger for us? GDB works fine. I life.
01:25:18.759 - 01:26:15.125, Speaker A: I. I live code on both YouTube and Twitch. It's live on both. Yeah, I have RR as well. It's really handy. The problem here is the processes are a little bit annoying. Why can't I just process builder? I'm in the mood for cheating.
01:26:15.125 - 01:27:30.533, Speaker A: Verify checks output. Verify checks output. Okay. I just want. I just want it to give me the process output. Do it, please. You should rather use exec with output.
01:27:30.533 - 01:28:04.155, Speaker A: Return the output of the command instead of matching against it. Wait, where. Oh, is this instead of run? Well, so that's on xx, but it doesn't. That doesn't really help me. From where the. It's not a function on the project. See here we cheated.
01:28:04.155 - 01:28:28.965, Speaker A: All right, so it recurses into debug. Then it removes recursive depths. Removes. Removes depths. That's fine. This is the line that's the problem. This RM dir.
01:28:28.965 - 01:29:18.583, Speaker A: Why is that RM dir even run? So remember that here, this RMDIR is only support supposed to be run if P isn't a symlink. But this path is definitely a symlink. At least that was the intention. So unless that gets removed somewhere else further up, which I don't think it does. Interesting. Oh, unless Cargo recreates that directory. That could very well be that.
01:29:18.583 - 01:30:18.565, Speaker A: This is cargo being like, I don't want my debug thing to be a P SIM link metadata. It could totally be that cargo will just like blow away debug if it's. If it's a symlink. Seems like its own kind of problem that we probably won't fix in the same run. All right, so when it chooses to RM dir this, well, that's relatively unhelpful. Huh. Seems like it's just a normal.
01:30:18.565 - 01:31:15.207, Speaker A: It thinks it's just a normal directory. Huh. How do we want to even deal with that? Like, why is this. Why does it think that debug isn't a symlink? I don't know what we want to do there. In fact, let's look Further up here. So we already checked before. Right.
01:31:15.207 - 01:32:00.835, Speaker A: We checked that debug was in fact a symlink. Pretty sure we checked that. We can. We can check it again just in case, like at this point, just to, like, be paranoid. It's not. Well, that certainly explains some things. That's because this has to happen before that.
01:32:00.835 - 01:33:08.935, Speaker A: Otherwise we overwrite the symlink, which won't work. But we can't. I think we might have to do this. Let's take a look at that. Oh, this now fails because not found where clean line 31 creator. All I think we need here. Although creating these should just not be an issue.
01:33:08.935 - 01:33:54.761, Speaker A: Oh, I see why it's an issue. It's an issue here because this creates something inside of real target, which means the real target must exist. So really the solution here is going to be. I see. This is really what we have to do. We first have to remove real target. So creating it is fine.
01:33:54.761 - 01:34:27.597, Speaker A: I guess we can remove real debug too. That doesn't really matter now. This line is going to create real target and it's going to create the parent of real debug, and then we have to create real debug here. I think that should do it. And this has to be this. Yeah, that's why I changed it to P root. Probably doesn't exist until you call build.
01:34:27.597 - 01:34:43.205, Speaker A: So that's why. That's why I do. This is just a removal. It doesn't actually need to create. It doesn't actually matter. We ignore the error. This is to remove it in case the.
01:34:43.205 - 01:35:48.565, Speaker A: In case the test previously failed midway through. All right, so now what happens if we do this? Now it's a symlink. So now if we remove this return. Fingers crossed. Well, it now runs RM on that, which is better, but not quite right. So now it's no longer hitting this case, but it is hitting this case. That's probably because this entry file type is simlink.
01:35:48.565 - 01:37:01.775, Speaker A: Ignore. Don't delete SIM links. Well, the problem here is we want to recurse into symlinks. See why it's a very good question. Please try to create context as you go. What do you mean, context as you go? Okay, so now debug is in fact a symlink, but because it's not a directory, it doesn't get recursed into. My guess is that this is because reader does a symlink metadata instead of a normal metadata.
01:37:01.775 - 01:38:02.609, Speaker A: So I think what we need Here is if path.symlink metadata, we want to. If the symlink is pointing to a directory, then we want to recurse into it. Recurse link, else ignore some link. I entered midstream and I'm unclear what you're doing, what problem you're focusing on. So I'm happy to give like a recap where we are in theory. We're almost done with the cargo bit.
01:38:02.609 - 01:38:42.273, Speaker A: I'm hesitant to keep repeating what we're doing because for the people who are watching, like, that would be a little bit jarring. I think what I'll do is because this feature is now almost done, the test just passed. I'll do a recap when we're done, which should be in like, my guess is five, ten minutes. Yeah. So the observation here is that entry that when you do read dir, all the entries you get essentially run symlink metadata and not metadata. So the file type we get for symlinks is not directory but simlink. Right.
01:38:42.273 - 01:39:19.563, Speaker A: Whereas if it's a sim link to a directory, we want to recurse into it. So that's hence this. This thing, which, if it's a symlink, then we look at the metadata of the target and see if it's a directory. So this would be. We still want to. Actually, I don't think that's even necessary. See that this works again.
01:39:19.563 - 01:39:47.481, Speaker A: Aren't you opening up cargo for getting caught in endless symlink loops this way? Yeah, the previous one would just RM symlinks so it wouldn't get caught. So that's a good point. We could do this by just keeping like a. Yeah, yeah, I know. I see what you mean. The easiest way to deal with this is a recursion modifier. So we just add like a number here that you count down for each step.
01:39:47.481 - 01:40:25.845, Speaker A: But if it reaches zero, you go like recursion limit reached. There isn't really any other way to detect symlink loops in this way. If we want the symlinks to not go away. It's a good question. Like, maybe the way to deal with this is to say recursion limit and then give, I don't know, 256 and here do. So this is going to. In fact, maybe we only decrement the recursion limit.
01:40:25.845 - 01:41:15.855, Speaker A: So this is really like a follow, follow link limit. Because that way we can say we can make this a decent amount smaller. Like you probably aren't more than 16 siblings deep. And then we do. If follow link limit is zero, too many chained symlinks, we're probably in a symlink loop. And so in this case we can return. Oh, that's a good question.
01:41:15.855 - 01:42:41.597, Speaker A: Cargo results errors I think what we might do here is something like an IO other. It's unclear actually. Maybe I always forget what the IO error new and we'll do something like caught in symlink loop and this would be standard IO error kind. Probably other. Probably other. And this probably needs an into be my guess. I agree with you.
01:42:41.597 - 01:43:48.365, Speaker A: It probably needs a separate test. Huh. Expected one parameter moved or all. What is it complaining about? Oh, I see. This needs to call these mismatch type. That's fine. This is going to be into but why does the into not do that? Oh, we might need a from instead.
01:43:48.365 - 01:44:28.245, Speaker A: Suppose somebody creates a link outside of target in target for some reason some new integration test. Previously directory was safe, now it's gone. That's true. Now there can be links outside of the target directory, whereas previously there couldn't be. I think that's almost necessary for this feature to work the way I want it to. So what I'm going to do is submit it and then mention it in the printer. It's a good observation.
01:44:28.245 - 01:45:18.215, Speaker A: All right. And then let's add to the test suite leaves symlinks cargo clean detect symlink loops and now how do we want to do this? We probably. We don't actually need any of these. Instead what we're going to do is just link. So this. Oops. We're just going to link target debug to target which obviously is not okay.
01:45:18.215 - 01:45:58.787, Speaker A: And this at least in theory, this should be cargo clean detects content loop shouldn't be the error text because just your guess as to why that would happen. Instead error should be max symbols follows. Yep, you're right. Could not remove build directory. Let's see. So that is back here. In fact.
01:45:58.787 - 01:46:55.579, Speaker A: In fact, really what this should do is we should have format error here, I think. Yeah. So this is going to be. It shouldn't really be any IO error either, which is max symlink followed. Well, so this is also kind of awkward because we don't actually have the original number here. Symlink recursion depth limit reached. Sorry.
01:46:55.579 - 01:47:24.505, Speaker A: And this failed. Where could not remove build directory because of that error. Which is what we wanted it to be. Right. We want. Is there nothing here that tries and sees whether it fails. That's odd.
01:47:24.505 - 01:48:59.775, Speaker A: We really want this to be like a run but we want to run that checks whether it fails. My guess is there's a support and we want. We want width status 101. Right. And with Standard error. Where's the My blind. Where is our actual error message? Maybe it doesn't print it with error contains and that should contain our error message from up here.
01:48:59.775 - 01:50:16.595, Speaker A: And none of these tests. Let's see what that gives us. I failed. Why? Huh. This is just like not print internal errors. That seems relatively unhelpful. Can I do this? It so it very clearly is printed.
01:50:16.595 - 01:51:16.127, Speaker A: I want to make sure that we. This and this. Huh? Oh, is it maybe printed to standard out? That seems weird. Or does contains require that to be the entire line? Maybe the given contiguous lines? Yeah. Whereas I think there's some like spacing that needs to be there. You see the actual output says could not remove build directory caused by SIM link recursion. Depth limit reached.
01:51:16.127 - 01:51:44.119, Speaker A: But see how there's like two spaces at the beginning. That seems so brittle though. But let's see if that does the trick. One of the things you'll see is that the. Yeah, okay. So the process here is going to be I'm going to submit this as a pr and then it might very well be that the cargo maintainers come back and say like, this is not okay. Like we don't want this feature at all.
01:51:44.119 - 01:52:12.569, Speaker A: Or like things like this test, they come with better proposals for how to implement it. What I wanted to do here is keep the diff as small as possible. So this is why we haven't fixed a bunch of the testing infrastructure stuff that we've seen. And so you see, the diff is actually pretty small. All right, so let's do. Arguably we should have committed as we went here. So we should have committed probably before we added the recursion limit.
01:52:12.569 - 01:53:15.975, Speaker A: But here instead we're just going to commit. Just let me check that I don't have any weird print lines or something in here. I don't think so. Great. So this is make sure that we tag the issue that was issue number 7510. So I'm going to prefix the message with clean to indicate this relates to cargo Clean do not remove symlinks, only contents. Previously, cargo clean would remove symlinks in the target directory, but not the contents of those symlinks.
01:53:15.975 - 01:54:37.749, Speaker A: This meant that large amounts of clean in some cases, like when the user sets their cargo targeter to a symlink did not clean any files. It also meant. It also causes surprising behavior where a build following a clean might fail or where a build following a clean might place build artifacts artifacts in the wrong location. Because. Because clean removed symlinks, a user expected to Be there. Yeah, my editor does cargo format. My font is.
01:54:37.749 - 01:55:33.785, Speaker A: I think you can do both artifacts and artifacts. This is the noto set sans mono font. Note that this commit does introduce some security risk. Before this change, cargo clean would never leave the current directory. We leave the target directory. Whereas now that it follows symlinks it might. It might recurse recurse into directories beyond the target directory.
01:55:33.785 - 01:56:31.315, Speaker A: An actor or. The decision that this is okay should be. We should decide whether we think this is okay. Fixes 7510 and then we push origin clean through symlink. Clean through symlink. Great. Screen is going to be bright now.
01:56:31.315 - 01:57:02.161, Speaker A: And now we're going to file this as a PR compare and pull request. Boom, we have a pull request. All right, so pull request one is out. I suggest that you watch this PR if you want to hear. I'll put the link in chat. You watch this PR if you want to see like what the follow up process is like. Right.
01:57:02.161 - 01:57:36.127, Speaker A: So what we did is just the first step and usually after you submitted a PR there are then going to be reviews of that pr follow up changes, maybe additional tests, a bunch of other things that might happen. Great. Okay, so that was PR1. Now on to the next project. All right, so I'm going to CD out of all this. So that was the first thing we wanted to do. Congratulations us.
01:57:36.127 - 01:59:44.265, Speaker A: Now the question is what do we want to do next? So I want. There's a contribution I want to make to rust up and there's a contribution I want to make to a project where we're going to move from future 0.1 to standard future. Which would you like to see first? My hope is that we'll have the time to do both. So would you rather see more rust tooling or would you rather see futures? Actually, I'll be back in a second. It I just realized one thing we forgot to put in the PR description is what the PR changed. It said what the behavior was previously, but it didn't say what the new behavior was.
01:59:44.265 - 01:59:57.195, Speaker A: Let's see, what does chat say? Futures, Futures. Rust tooling. Congrats and good luck. Future. Future. Future. Rust up.
01:59:57.195 - 02:00:10.459, Speaker A: Future. Future. Rust up. Rust up. Futures. Futures. See, I could put up a BRB screen, but it's annoying.
02:00:10.459 - 02:00:24.743, Speaker A: Like screen management in obs is annoying because you don't get it through the right hand here. If I did, that would be a lot easier, but I don't. Tooling Futures. Rust up. Rust up. Rust up. Futures.
02:00:24.743 - 02:01:18.281, Speaker A: Okay, I think we're going to do futures first, the futures change is, at least in theory, more straightforward because it's mostly a mechanical change. And then we'll do the Rust up one afterwards. For Rust up, there are actually two different issues and I don't know which one to choose yet, but that let's do the futures change. So I've done a lot of streams on like Async stuff, on Futures, on pin, all of that stuff. But one question that keeps coming back to me is if I'm on the old future stuff and I want to go to a new one, like how do I do that? Don't just tell me about how it works, but show me the actual process. And so that's what we're going to do. And so I looked around a little bit and asked for suggestions for crates that are using future 0.1
02:01:18.281 - 02:01:49.949, Speaker A: and that aren't too large, so that we could pretty easily move it to Standard Future. And so I ended up with this crate by someone who actually watches the stream pretty frequently. So this is an implementation of the BeanstalkD protocol and it was written for futures 0.1 and we're going to port it to use Standard Future. And you'll see that the process we go through is fairly applicable to any project. At least that's the hope. I don't think I have a fork of this yet.
02:01:49.949 - 02:02:38.075, Speaker A: Oh, I do. Great. How about that? Great. So we're going to do the same process of others clone this. Apparently I already had that. Let's just blow that away because I don't know how old that thing is. All right, I'm going to rename Origin to Upstream, like before you can add that.
02:02:38.075 - 02:03:28.145, Speaker A: Great. All right, so the question now becomes where do you start? Just like with always. And we're going to start by looking at Cargo toml. So generally, whenever you want to do bigger changes like this in Rust, doing it in sort of a compiler assisted fashion is really handy. So what we're going to do here is that we're going to just start changing the types to the new types and then see what breaks. So this is going to become 05 Alpha 1. We're going to use Tokyo 02 Alpha 6, future 03 Alpha 19.
02:03:28.145 - 02:03:55.363, Speaker A: I think those are the most recent versions. And then let's just run Cargo Update and see what happens. We're going to have to rust up Overrideset Beta. Am I lying? Oh yeah. There's not a Futures crate yet. This is going to be Futures Core Preview. So Futures, the Futures Crate.
02:03:55.363 - 02:04:27.913, Speaker A: There is a Futures Preview that has all the Stuff we won't actually need all of Futures Preview. So instead we're going to bring in Core and UTIL are probably the ones we're going to need. So Core has traits like stream. UTIL is. Has a little bit of things like channels selection all of the extension traits for future and for Stream. So Core is just like. Just if you want to implement the stream trait you would use that.
02:04:27.913 - 02:05:00.875, Speaker A: Whereas UTIL has all of the like map. Okay, map error. And then like all of that stuff is in util. All right, let's do a cargo check. This is probably. This is obviously going to fail in a bunch of ways because none of the types are the same but at least it'll kick off the build process. What's today's stream about? Today's stream is an open source contribution stream where we're going to take on a bunch of open source projects and try to make contributions to them.
02:05:00.875 - 02:05:20.909, Speaker A: We previously did one on. We did a contribution to Cargo. Now we're doing taking a crate that uses future 0.1 and moving it to standard future. And then next we'll try to fix an issue in rustup. Can't find crate for futures. That seems like it's obviously true actually.
02:05:20.909 - 02:06:07.659, Speaker A: Does this still use. This is not on the latest edition. So I'm going to go back a little and then I'm going to run Cargo Fix Edition. So Cargo Fix Edition is you. I just want to move the crate to the 2018 edition because it's nicer and we're going to make standard future branch and this now did some rewrites. Now we can say addition is 2018 in here and that should in theory work. Variant is never constructed.
02:06:07.659 - 02:06:48.655, Speaker A: That seems fine. What else do I want? I also want. There's a warn rust 2018 idioms. I forget what this lint is called. Rust 2018 idioms. Great. So this, this lint is used for like things that you should be doing in the 2018 edition that you couldn't in the in the 2015 edition.
02:06:48.655 - 02:07:54.085, Speaker A: So let's just fix these. So this, this the failure one is handy because it uses macro use 56. This is another change that happened in the 2018 edition where if you have types that have a lifetime parameter, it's optional to write out that lifetime parameter. But in 2018 edition you're supposed to do it to indicate that this type has a lifetime parameter. It's not static and you can do tick underscore to say I don't care what this lifetime is. And then let's see where else? Proto request 87 same thing here. The external crates we already dealt with and the variant never used cargo format.
02:07:54.085 - 02:08:52.305, Speaker A: I think I'm also going to do a restformat toml and say addition equals 2018. All right, move to 2018 edition. We install can you do the Cargo TOML thingy where you install create Future Score preview but you call it future Score in your RS files. So preview all the futures preview crates are. Their names are without the preview suffix automatically. You don't need to do anything. I don't think Fixed Edition did work because you didn't change it in the Cargo toml, did it? Cargo Fixed Edition you need to run without changing your cargo TOML first.
02:08:52.305 - 02:09:36.799, Speaker A: So your cargo TOML should not say edition 2018 and then you're supposed. In fact, it will tell you this. If you try to change Cargo TOML and then run Cargo Fix Edition, it will say nope, you've already changed your edition. Which Rust Edition version do you prefer to work with futures, you basically need the 2018 edition. There is no 2019 edition, but the 2018 edition is where you would get Async, await and these types of things. All right, so now we can go back to this and run cargo check and it's going to complain about a lot of things. And so we're just going to start at source lib and look at where it complains.
02:09:36.799 - 02:10:18.075, Speaker A: So first it complains about Tokyo Prelude, which makes sense because the Tokyo Prelude you basically don't need anymore. Maybe missing a crate Tokyo. No. Why is it saying wait? What? It's lying to me. Oh, right. Edition 2018. Great, let's try that instead.
02:10:18.075 - 02:10:35.635, Speaker A: Great. Bunch of errors. Bunch of errors. Lib. All right,139 it says Susan type item not found for future. That is right. So there are two things we could do here.
02:10:35.635 - 02:11:14.045, Speaker A: The most straightforward one is that future no longer has two associated types. So we could just say output result this. That's sort of the most straightforward change. In reality, we don't really want to do any of this like imple future business anymore because we have async functions. So we can just make this an async function that just returns the results, nothing more to it. And now we can do something like let connection is this await and then we're going to return. Ok, setup C.
02:11:14.045 - 02:11:56.945, Speaker A: Right. See how much easier that was. My guess is there are more of these. Ooh, these doc comments will not work correctly. This should say this has to be like this, this has to be like this and this has to be like this and there need to be no line, otherwise they won't actually work correctly. The additions are for rust format. It isn't necessary if you run cargo format, but if you run rust format, which rust VIM will do sometimes, then it doesn't pick up from cargo toml, which is a little unfortunate.
02:11:56.945 - 02:12:24.623, Speaker A: We can do the same thing here, right? So you see here put returns this. In fact, here there are two things we can change. First, we're going to have to change this to be output. But also notice that this is a pretty common pattern that you see in 0.1 libraries, which is they consume self and then they return self. And the reason being that they need to like, mutate self in some way. But with the old futures, this wasn't really easy to do.
02:12:24.623 - 02:12:47.195, Speaker A: Here though, we can just say make this an async function. Say that it takes mute self and that it just returns. I guess this. It's a little weird, but that's what it says. So I've never actually used this library, so I don't know what it does. This is a. This is in some sense a blind port.
02:12:47.195 - 02:13:36.275, Speaker A: What's important to note here is that when we put the async keyword before function, what that means is the return type is a future that produces this function's return type, right? And crucially, that future will be associated with the lifetime of this borrow, right? So us taking mute self here is fine. It just means that the future you get back is tied to the lifetime of that borrow of self, and we'll see how that impacts things later. Now here you see the insides of this. Of course, this is now an async block. And so we can use await if we didn't want to use await here. Notice that this uses and then you can still use and then. So let me pull up futures UTIL preview.
02:13:36.275 - 02:14:04.001, Speaker A: So let's look at the future trait. If you look at future, the new future trait, the one that's in the standard library, it just has an output, right? There's no item and error anymore. And when you poll, it just gives you that. Of course, the change is that you might still have futures that produce results, right? That basically futures like an error. And there are some convenience methods for dealing with that. And they call this try future. And they have the same for try Stream.
02:14:04.001 - 02:14:45.943, Speaker A: So try future is a trait that is implemented for anything. That's a future where the future's output is a result. And so try future is basically like if you were previously depending on a future that could error. You can Just change to use try future instead. And then you'll notice that the under future there's future X. So this is the extension trait for future, which has all the normal combinators you're used to, right? But you'll see that this doesn't have an and then. It has a then, right? Because if you have a future and it resolves and then you want to do something, you call then.
02:14:45.943 - 02:15:15.935, Speaker A: But it doesn't have an and then because it has no notion of succeeding and then doing something else. Similarly, the map function here is a map regardless of whether the underlying thing succeeded or failed. If you have a future that can succeed or fail, you would have a try future. So you would look at try future X and that has map, okay, map error. And then. Or else like all the things you're used to from the old futures that could have errors. And so we, we would be able to use this if we just imported that trait.
02:15:15.935 - 02:16:00.885, Speaker A: But look at how much nicer it is if we don't do that. And we say let con is this await. And then just that, right? We no longer have to do this callback business because we can just write it in a straight async await form. And this is of course where async await shines. We can do this for all of these, right? So this is going to take a mute self. It's going to return a don't know why result is useless. It seems weird for this to use the result type con is this await.
02:16:00.885 - 02:17:08.435, Speaker A: And then we do the same thing. Ah, same thing here. So this is what I mean by this being a relatively mechanical change is that you don't really need to think while making these changes, even though I just said while saying that and there, because generally this is just transforming code. I'm pretty sure you could write a tool that just did this. At least for most of the common cases. The result for item use was used there because there are method specific, method specific errors and protocol specific errors which I wanted to surface. Okay, so what threw me off then was I see, I see is that here, for example, this just says consumer, whereas I guess this is like consumer errors or something.
02:17:08.435 - 02:17:47.611, Speaker A: Doesn't matter too much what I want. What my goal is for basically all the PRs we do today is to make the minimal change. And this should often be what you want to do in prs. The less you can change at a time, the easier it is to review the pr. If I did a major rewrite of this crate, like beyond just the mechanical changes, it would be Much harder to review that PR instead. What's usually a good idea is make self contained changes for your PRs. So this PR will only be about moving to async await.
02:17:47.611 - 02:18:26.277, Speaker A: And then we could do a later PR which cleans up in these types should we need it. Right, but that shouldn't be something that we bundle up with the main change we're making. It's kind of easy to do these changes on code that uses implefuture often. But how about crates that have own future types? So for crates that have their own future types often, you could do the exact same transformation. The manual implementation of the future, you just turn into an async block. It's the same thing. And if they don't, that's fine too.
02:18:26.277 - 02:18:57.849, Speaker A: Right? You could imagine that this returned like instead of this. It returned like my super future. Because why not? And then in here, this used to create a my super future and return that. Well, if you're in an async block, you can still create that and you just do dot await. So and then turn this back into this. So the same transformation still applies. I don't think they want it either.
02:18:57.849 - 02:19:26.365, Speaker A: I think result result is really what was intended here. So we have one of the. We have the author of the library is in chat and is pointing out that this was written when they were pretty new to rust. And like, that's fine, we were all there. I also don't think this code is bad. It's just like it was just an odd pattern to see result result. But I think the explanation makes sense for why that's what you wanted.
02:19:26.365 - 02:19:54.349, Speaker A: Now, this library is probably more regular than what you would normally expect to see. You see, all the methods here are basically all the same. Like the transformation is the same. We'll see whether that's the case when we get to deeper parts of the library. I don't know. This should now be results. This should be con.
02:19:54.349 - 02:20:30.865, Speaker A: Is that await. Ooh, this. Ooh, I forgot a change. This should say mute self. Did I miss that anywhere else? Yeah, this should say mute self. Great. Mute self.
02:20:30.865 - 02:21:40.105, Speaker A: Arguably, I should just make a. At this point I should just do like a VIM macro for this. But in fact, I wonder. Let me try to see if I can do a VIM macro for this. So for those of you aren't familiar with VIM macros, in vim, you can record a sequence of key presses and then you can replay that recording. So let's see, QA word forward, insert async escape percent to go to the end of the block forward to the I change to the result, escape right to go to the result. Percent to go to the end of the result, right to go there, delete to the equal sign and replace the equal sign with a comma.
02:21:40.105 - 02:22:25.905, Speaker A: Oh, crap, I forgot. Mute self. You're right back. What is it? It's shift F for backward to character, end parentheses, percent append to line, mute, and then rust format will take care of that for me. Percent to get back there twice. Okay, so that transforms the header. And then we want.
02:22:25.905 - 02:23:33.325, Speaker A: If they're all as regular as this, and we want one line down zero to the start of line, let con equals percent to go to the end of the send, append to line await question mark, semicolon, escape line down, delete, insert above escape percent, line down, double delete. All right, now let's see whether it worked. That seems pretty promising. It just didn't delete this line. But apart from that, it did what I wanted, I think. Oh, but this is. This function is different.
02:23:33.325 - 02:24:07.505, Speaker A: Oh, yeah, you definitely spend more time constructing the macro. But also, of course, now we're like, almost at the end of the files. It's unclear that it's worth it. And of course, this function looks different. So con. Is this. All right, let's try this one.
02:24:07.505 - 02:24:34.567, Speaker A: Yeah, didn't have to do any work. What about this one? Not quite. For some reason, I didn't like this one. I really didn't like this one. All right, let's try recording it again, just for fun. Qb. All right.
02:24:34.567 - 02:25:31.605, Speaker A: Async end of line, mute percent percent forward to the I change to the R in the results, escape percent to the end of result, delete to the equal sign. Replace it with a comma, line down zero. Let's con equals escape percent to the end of send, append, await line down, delete, insert line above. Just because we want it to be pretty. Line down percent to end line down, delete end of Q. No, then now, of course, there are no more methods. Damn it.
02:25:31.605 - 02:25:47.401, Speaker A: Oh, well, we tried. No, Sebastian, we're. You're. We're roughly halfway through. Alex. No, I'm not using a plugin for percent. That's just what percent does.
02:25:47.401 - 02:26:18.475, Speaker A: It does. It goes to matching brackets. I kind of want to. I kind of want to undo now and, like, retry my macro. Okay, let's see how that worked. Well, no method named into future line 114, so handle response is a macro that's called in a bunch of these. And we don't need this to be into Future anymore.
02:26:18.475 - 02:27:00.585, Speaker A: Why was it even into future in the first place? Oh. Huh. Okay, so this is kind of interesting. We may have misread what handle response does, so. Oh no, it handles an okay. As long as the connection from send comes back okay, then handle response is going to act on it and con here. I see.
02:27:00.585 - 02:27:43.015, Speaker A: Okay. So this is going to turn into an async block. Actually, it doesn't even need to be an async block. What am I talking about? Why is this an into future? So that means that con is a result. I don't think it needs to be into future anymore. I think this can just do match on input and if it's okay. In fact, there might be an opportunity for us to improve this quite a lot.
02:27:43.015 - 02:28:28.825, Speaker A: So this send business previously used to consume the connection in some way, I guess. Whereas now I think this certainly doesn't need to produce any of these anymore. Right? I think it just needs to produce whatever this is. And the error no longer needs to be this. The con is no longer going to be included. So this is really just going to be that. Not sure why error turns into okay.
02:28:28.825 - 02:28:58.755, Speaker A: Oh, because it's an internal error. Okay. All right, so let's see what that does. Oh. 121. I did something silly, didn't I? This no longer needs that. This matches expression type.
02:28:58.755 - 02:29:53.445, Speaker A: Nothing that seems false. What is the type of con really? Where's my assignment to con framed connection 5. Oops. That looked like a problem. This definitely should not say what it does Ignore. I think we. I think we actually accidentally got too excited about our macros because ignore no longer sends anything.
02:29:53.445 - 02:30:39.567, Speaker A: Where is ignore? Ignore should send one of these really? I guess. Let's look up the docs for Tokyo Tokyo Codec. And we have a framed. And what do we have on framed? It implements sync and stream. Aha. Okay, so what this means is we really need back in cargo toml here. So in we need to use it as a sync.
02:30:39.567 - 02:31:04.995, Speaker A: So we want to use sync ext and sync ext I think has a just send. Yeah. Great. So this is the thing that we're calling over in over here. Right? Self connection is a framed. We call send on it and that is this business. And what does send give us back? It gives us back a future, I assume.
02:31:04.995 - 02:31:53.375, Speaker A: Yeah, just a future. Right. So why is it Nothing. I see what's going on. I see what's going on. So okay, to explain. Self connection is a framed in Tokyo world and a framed is a.
02:31:53.375 - 02:32:32.759, Speaker A: It's basically something that's both A sync and a stream that's implemented on top of async read and async write as. What we're doing here is we're using it as a sync to send a request to the server and then we're using it as a stream to read response back. And so handle response should really wait for the thing to come back. And that is no longer con. Right. We don't care about this value anymore. This con is no longer important because the return value so send gives you back to future that either errors because you couldn't send or it succeeds with no value.
02:32:32.759 - 02:33:38.565, Speaker A: So there's no like con isn't a thing anymore. And so anywhere where it says handle response con, what we really wanted to say is handle response Oops is handle response self connection. And then the macro that we have this is going to be expert next dot await please. In theory this should say con, this match expression. Yeah. So what we're saying here is we're going to send a request and then we're going to call next, which is the stream method for getting the next thing as a stream, which is going to be the response from the server. And then we're going to await that.
02:33:38.565 - 02:34:44.579, Speaker A: Now in standard future now streams return options of the output rather than like a result of option. So that's why you're seeing here that we're trying to match on the result of this as a result. But in reality this is now an option that contains a result rather than the other way around. And so this means that oops, this clause, there's no longer an okay. Alternatively you get some okay val, in which case it's this or you get some error E, in which case is this now this being an okay, I think it's because the error is if we fail to send something. Yeah. The outer error is if we fail to send something to the server, in which case is like a problem with a connection.
02:34:44.579 - 02:35:01.535, Speaker A: The error here is we got something back, but it's an error. But it still seems a little weird. But I think that's the semantics we want. Oh wait, that compiles. All right. Well, that was easy. We haven't ported the test yet.
02:35:01.535 - 02:36:16.755, Speaker A: I'm surprised there aren't other. I guess these are just like display and stuff. Alright, so let's try cargo test. Of course, I don't actually have Beanstalk D, do I? Okay, so this is gonna be port library parts, Beanstalk D, I guess I want to install it. That seems fine. Yeah. So David, it doesn't actually always return okay, because this question mark can cause it to return an error.
02:36:16.755 - 02:37:15.927, Speaker A: Handle response will always return an okay, but this question mark means that we can return an error in the sense of the outer error. I still think that these should probably be collapsed and just have the error be hierarchical, but I don't really want to make that change as a part of this PR Sy Start Beanstalk D Great. So now we need to port the tests and luckily this is probably going to be a lot easier. Ooh. All right. Well, I guess stop being sokthi if it's going to start it on its own. So here what we really want to be able to do is just use async here as well.
02:37:15.927 - 02:37:34.305, Speaker A: And it turns out that we can. When you use Tokyo, you can use Tokyo test, you can make this an async fn and then you're rolling. Now Tokyo will already create the runtime for you, so you don't actually need to worry about it. Previously we had to create these for every test that we run. No longer necessary. This is. This annotation will do that for you.
02:37:34.305 - 02:38:27.563, Speaker A: Now, because we're in an async event, we don't need to do things like block on. We can just do await unwrap. Down here we can say unwrap. This is just an await. This is also just an await that we're going to unwrap on. We don't need to keep reassigning bean because this now just takes mute self here we're going to do response is this await unwrap and then we're going to assert equal response test. So all of these blocks go away.
02:38:27.563 - 02:39:02.995, Speaker A: We don't need to check that it's not an error at the end because we're doing that as we go. We no longer deal with need to deal with the runtime. Now let's. I would anticipate an OK handle connection, but yeah, that's a bigger change. I mean, I would be okay in putting the okay around, but I think the current structure to not put okay around handle response. If handle response changes so that it might produce an error instead, it's easier to keep it the way it is. This is vim.
02:39:02.995 - 02:39:33.625, Speaker A: I don't use Atom. I don't like to have browsers running where they don't need to be okay. So this change is basically the same thing. We're just gonna await unwrap and all of this is gonna be similar kind of thing. So this is gonna be response doesn't actually use the response here. So I think this is just an await Unwrap. That's all that Inspect really does.
02:39:33.625 - 02:40:29.075, Speaker A: This does bean reserve. And here we do actually want the response and we want to assert that the response data is that apparently. And then we want to peekaboon at this thing and we want. We want to assert that response. We want to assert response. I think thinks that that's what that's saying. Oh.
02:40:29.075 - 02:41:06.125, Speaker A: Oh, no, that's just an unwrap. This is a weird way to write an unwrap this though. Oops. This one's response id. We don't need the unwrap because we already unwrapped up here. This doesn't care about the response. This doesn't care about the response.
02:41:06.125 - 02:41:53.739, Speaker A: This doesn't care about the response. Just wants to unwrap it. This seems to care about the response. Been release. So you see how this code is now basically becoming almost the way that you would write it if you were writing it just imperatively. Like, you can't really tell that there's async here apart from the awaits, because all of these, like, weird closures and inspects and then just go away. And also it's nice that now there's no longer this tuple that's returned by every method.
02:41:53.739 - 02:42:53.465, Speaker A: Instead you can just call the method directly. This goes away the response here. Oh, this is supposed to be an error, I think, right? Ah, this is supposed to be. Oh, this is where the nested. Nested OKs come into play. So really, my guess is most of these unwraps need to be double unwraps. It's a little awkward.
02:42:53.465 - 02:43:20.705, Speaker A: So this becomes that. I see. So that's why there are all these unwraps in here. That's why this is an unwrap id. So really, this is just. This is a double unwrap. This is a double unwrap.
02:43:20.705 - 02:44:21.403, Speaker A: All of these, in fact, are probably double unwraps. I don't really want to add all of them. We can add them later. Wait, unwrap. See what I mean by this is a mostly mechanical change, right? Wait, unwrap. This can go away and this can go away and then the rest of that can go away. All right.
02:44:21.403 - 02:45:00.045, Speaker A: 561. Yeah, exactly. So here we're starting to see, like, all of these are double results. 581. This is a double result. In fact, how about we just do await unwrap with dot? Await, unwrap, unwrap. The exception to that is this, which should be error, and this should check that E is equal to this.
02:45:00.045 - 02:45:57.365, Speaker A: This Also doesn't need to do that and this doesn't need to do that and they don't need to de rough and the bean needs to be mutable both here and up here. See what that does. Cinema made a tool to automate the transformation for Combinator Async Await. I haven't seen any tool. I feel like it should be possible to write, but I haven't seen anyone who does it. Sufficient enough? Is the wrong wording more powerful to the right way of saying it? Sufficient enough? Oh, about vim. Oh, I see I missed some chat.
02:45:57.365 - 02:46:37.983, Speaker A: Can you overload stack names? I don't know what you mean by overload stack names, but yes, you can declare a variable with the same name as a previous variable and shadow it. This is a published crate. How does Rust compare to Golang in terms of performance or writeability? It's a much larger discussion that doesn't really fit here. I would say they're both good for different things. Can you elaborate on browsers running where they don't need to be? I want my browser to be. I want a single browser. I want to control which one it is and I want to control all the updates to it.
02:46:37.983 - 02:47:13.881, Speaker A: I don't want a program that runs an outdated browser in the background. Like this is why I don't use Electron apps, for example. I would rather just have them be another tab in my browser and use a pinned tab or something. I am totally happy with Vim the way it is. I don't want it to have any richer features. I don't need the richer format. What's the reason you switch to COQ Vim? It was actually because I wanted better integration with Rust Analyzer, which is a little awkward to get with ncm.
02:47:13.881 - 02:48:26.233, Speaker A: It's also weird because I was using NCM and ALE for two different things and COQ just provides both of them. All right. Why did this not pass? This did not pass because connection refused address already in use. Really? Is that so? That does look an awful lot like that. What? Who ran that? Well, all right. Is it still there? No. Okay, it works.
02:48:26.233 - 02:49:36.315, Speaker A: Succeeded and then consumer commands failed. Can I have it? Just not spawn for me please. Spawn is just going to be true and then I'm just going to use that. How about now? Apparently not failed for some other reason. Unwrap on not found. Where here? Source lib line 600 huh? Not found. Did I miss something in the port? Probably that that test.
02:49:36.315 - 02:50:18.485, Speaker A: Which part of the test is this? This is after more data. Where is more data? More seems like it's expecting an okay response. Interesting. If I run just the consumer test. Yeah, that's what I was afraid of. Okay, so they work in isolation. They don't work if you run.
02:50:18.485 - 02:51:04.463, Speaker A: They do work if you run both. Okay, well, I'm just going to ignore that for a second. All right, let's not include that, but let's include all the changes there and then actually, do I want to include all those changes? Yes, for tests to standard future. Just going to leave that in there. And now you'll notice the next things that have failed were the doc tests. And the doc tests basically need to go through the same process as we've done before. We don't need any of the Extern Crate anymore.
02:51:04.463 - 02:51:30.835, Speaker A: We don't need Tokyo Prelude. We can do that. That's fine. Then this now becomes Tokyo Main. Don't need to do this anymore. And we can have this be visible just so users don't get confused. Wait, unwrap.
02:51:30.835 - 02:52:04.085, Speaker A: And then I want. This is going to have to be muted. In fact, let's see, how did this. How did it break this down? I kind of want the same breakdown in the docs. It just makes it a little bit nicer to see. Wait, unwrap. It's really sad that this double unwrap has to be there.
02:52:04.085 - 02:52:43.159, Speaker A: Use a particular tube. All right, you say so and then this. So that actually shortened the example by a decent amount. And especially given that we expanded out this part. Right. Arguably, this shouldn't even be necessary. This parse could probably be gotten rid of.
02:52:43.159 - 02:53:32.515, Speaker A: But again, in the interest of making fewer changes to the library at hand, we're going to not do anything about it. All right, so this is now the standard setup. And then this is going to be something like let spawns is being reserve. Await. Unwrap, unwrap. Do something with the response. I'm gonna take an artistic liberty here and do this.
02:53:32.515 - 02:54:13.325, Speaker A: And then bean delete response. Oh, wait, unwrap, unwrap. I guess this should also be double unwrap. And like, so let's see if it's happy about that. Great. Port Doc test to standard future. You see all of this, like, very, very straightforward mechanical changes across the board.
02:54:13.325 - 02:54:47.733, Speaker A: What is Bean? BeanTalkD is like. I want to say it's like a job server. So the idea is that you can submit jobs to it or request jobs from it. It's sort of like Sidekick or Factory. Why do you want to rewrite Async SSH with ffi? Just to show ffi or is there any problem with Thrush. So when I first wrote asyncss, Thrush was very a very immature project and so we had to hack around it a lot. Maybe it's better now.
02:54:47.733 - 02:55:36.645, Speaker A: Like maybe it's fine, it doesn't have to be with ffi. I just haven't looked at it since I also one reason to do it with FFI is to show off ffi, but it's not particularly important to me if Thrush is now good enough that we could build something reasonable on top of it. Will we have to write this many unwraps when the async await hits stable? Oh, so the unwraps are there because of choices we made in the library? The unwraps are not like async Await does not require any unwraps. The unwraps are just there because this library has a double result type and so we need to unwrap the outer result and unwrap the inner result. But it's not related to async await. I always unwrap my own wrap before I unwrap. My favorite is when I get a little bit tired I start writing unwarped instead of unwrap and it sounds way cooler.
02:55:36.645 - 02:56:27.805, Speaker A: Oh, I could go for wrap Wrap sounds tasty. All right. It's gonna get light again, people. Boom. Pull request. That's not very helpful. Port to Standard Future this PR updates the crate to Standard Future and the Alpha based ecosystem around it.
02:56:27.805 - 02:57:34.265, Speaker A: Tokyo Alpha 6 and FuturesPreview Alpha 19. Mostly mechanical changes except that all methods now take mute self instead of self and thus also do not return self anymore. Oops. Also I made a stupid which is undo that last commit for two reasons. One is this extra spacing, but I don't want to check in that change to the Boolean. Yeah I did. I said it was going to get light again.
02:57:34.265 - 02:58:23.265, Speaker A: Mostly mechanical changes, except that all methods now take mute self instead of self and this also do not return self anymore. The double result wrapping is now particularly parent and should probably be changed, but that's for another PR. This patch also updates the crate to the 2018 edition. Great. Boom. All right, good job team. We now have two PRs under our belt.
02:58:23.265 - 02:59:21.829, Speaker A: It's pretty good for a day's work, so let's make it three. Yeah, there are dark GitHub styles, but maybe one day I don't. I actually prefer the light style even for docs rs, but for the stream I don't because people get sad when they're in because it's the middle of the day here, but if you're in a place where you're in the. In a dark place in the middle of the night, then the light screen is pretty annoying. All right, time for the third and last contribution of the day. Okay, so for those of you who have joined only sort of midway through, what we're doing is an open source contribution stream. The idea is that we find Rust projects that we think we can submit a PR to and then we submit PRs to them.
02:59:21.829 - 02:59:50.675, Speaker A: We first tackled an issue in Cargo. Now we've done a port of a crate from future 0.1 to standard future. And the last thing is going to be contributing to the. To another part of the Rust tool chain, which is the Rust up tool, the thing that you usually use to install and manage your Rust installation. Here we have. Here we have two different choices of where we're going to go next.
02:59:50.675 - 03:00:24.695, Speaker A: The first one is this issue. Can you go back to the first pr? There was an error during the build. Ooh, Cargo. An error during the build, you say? Interesting. Sure, we can do that before we do the Rust up one. Really? It face all nightly. Interesting.
03:00:24.695 - 03:01:14.915, Speaker A: Why does it fail on nightly? These errors are unrelated to us. These are nightly issues, I think. Yeah, this is like cross compile stuff. I don't think this is us. I mean, could be, of course, but it doesn't seem like these errors are our faults. Failures depend. That one is us though.
03:01:14.915 - 03:02:08.455, Speaker A: On macOS. No such file or no, this one could not remove build directory. No such file or directory. Interesting. Although there seem to be other errors along this line like different dir also fails with no such file or directory. Yeah, this also fails with no such file or directory. So I'm tempted to say this is unrelated to us.
03:02:08.455 - 03:02:53.395, Speaker A: No, maybe not. This also runs clean. No such file or directory. We did push it with the. Yeah, we ignored that error. Huh. It's hard for me to reproduce given that it only happens on macOS like Windows passes and Linux Passes.
03:02:53.395 - 03:04:01.445, Speaker A: If someone with a Mac wants to try to run the test suite and like dig into it, then that would be very much appreciated. It seems to work elsewhere, so I'm not entirely sure what's going on there. I'm going to leave that for a bit. The nightly errors seem unrelated to this change cross compilation stuff. They also seem to be occurring in other unrelated tests. It's useful in PRs to at least follow up with a short like when you get errors like this, at least let them know that you've looked at the errors and what the status is in this case, if I had a Mac, it would be a lot easier to reproduce, but I may look at it later. All right, so with that aside, dealt with.
03:04:01.445 - 03:05:26.723, Speaker A: So there are two issues that we could choose to tackle for Rust Up. The first one is this one, which is Rust up recently got the ability or the support for something called Profiles. And the idea for a profile is that by what happens if you install a tool chain or rather which components get installed by default. When you install a toolchain previously you used to get a bunch of stuff which included things like all of the standard library documentation, which meant that if you downloaded Rust up and then tried to install Stable or Beta or Nightly or whatever, it would download a lot of stuff because it had to download all the documentation. And so recently in 1.20, which was released just a few days ago, they landed support for this thing called Profiles, which is if you set your profile to be minimal, for example, then Rust up will only install the parts of Rust that you need to compile things, rather than all this sort of nice to have business, which is very handy for CI scripts as an example. However, you're only able to set your profile when you install RustUp, which is nice, but you also kind of want the ability to select which profile to use when you install a particular toolchain.
03:05:26.723 - 03:05:56.445, Speaker A: Like when I install Nightly, I want to say install it with or without the bells and whistles. So it might be useful to be able to set this on a global stage, but setting it for a particular install is. Is attractive. So this is a very straightforward issue. I don't know how hard it will be to fix. It shouldn't be too bad. But this one like seems like a straightforward thing to deal with if we want to get into something that's a little bit more complicated, but also is only tangential to Rust up.
03:05:56.445 - 03:06:58.601, Speaker A: There's this issue which is basically if you interrupt Rust up in the middle of a download, then there's a. Basically when rustop has to download something from the web, it downloads it into the file with the partial suffix and it just keeps appending to that file as it downloads. And then if you interrupt the download, it's going to try to resume from that file. The problem is if that partial file either is corrupted somehow or actually completed, but it just didn't do the move of the file, then trying to continue the download is going to fail in weird ways. And basically you need to manually remove the file to make it make any progress. And there's an existing PR to try to fix this, but that PR seems to have sort of stagnated a while back. And there's also a follow up issue that's somewhat related and a little bit easier to reproduce.
03:06:58.601 - 03:08:42.631, Speaker A: And so we could try to tackle this sort of group of problems. It's a bigger task to undertake and it's also a little bit harder to test because it sort of requires to interact with HTTP servers. In fact. What is this? Oh, is the follow up comment. I think my preference is to supporting this because it seems like such an obvious hole to fix and it's a gentler introduction to Rust up. But if you particularly want to see us deal with like HTTP download issues, then we could do that too. So would you rather see improved profile support for installs or would you rather see like HTTP debugging it? 1 vote for each so far it's interesting because there's, there's a delay to both YouTube and to Twitch and so suddenly there's like a stream of messages that comes in HTTP, HTTP, HTTP Rust Up.
03:08:42.631 - 03:09:22.721, Speaker A: I mean it's going to be Rust up regardless. Both of these are Rust up, but one is how Rust up deals with HTTP weirdness and one is how it basically fixing the profile support. That's interesting. So it seems like, oh, the test suite has a web server built in. Great, that makes it easier. Seems like Twitch prefers profiles and YouTube prefers HTTP. Oh yeah, okay, great.
03:09:22.721 - 03:10:12.475, Speaker A: It doesn't have a web server. I think what we're going to do is we're going to seems to be about 50 50, so we're going to do the profile thing and here's the reason why it's a little bit shorter, which gives us more time to talk through the changes we make and to test them properly. It's also something that is more important in terms of features that Rust up needs. Like this is more needed than for people who interrupt downloads. It also means that the HTTP download issue you can go fix after we go through this, try to fix that problem. And now there'll be a bunch of people who can pick up that pr, for example, and try to run with it. So let's do that.
03:10:12.475 - 03:11:02.105, Speaker A: Okay, so I'm going to close down these and then we're going to go here and here. I cheated a little. I have a checkout already. The other thing that's a little bit nice about that I actually really like about the Rust up code base is that I can build it. In fact, I've already built it and then I can do this, this business. So if I run this funky command Then this lets me run the compiled version of Rust up on my system as if it was the real one. And this is handy.
03:11:02.105 - 03:11:45.505, Speaker A: So for example, if I do this install, I guess nightly 2019 0101. Great. So this is now running the Rust up that I have compiled on my system rather than the system wide Rust up. And you'll see that this is now downloading things like Rust docs. Ironically, I'm now going to interrupt my download and really what I want the ability to say here is profile minimal. Profile minimal. But that doesn't work.
03:11:45.505 - 03:12:21.249, Speaker A: Um, I can change. I forget where this is. Is it here somewhere? Is this where I can set like profile equals minimal? Nope, currently not. But generally it's when you install Rust up. So when you do like the whole like curl business to which has its own problems. But it's when you install Rust up that you're able to pass this profile business. And I think it creates a file somewhere.
03:12:21.249 - 03:13:12.203, Speaker A: I forget where I think this was in the. Wow. I cannot type anymore. Rust up 120 0. See if I can dig up this. Could also just read the source code, but that seems too hard. Having a piece of state somewhere.
03:13:12.203 - 03:13:26.723, Speaker A: Where is the piece of state? That's what I want to know. Profiles. Huh huh huh. Yeah. So I can do this. Great. And then this.
03:13:26.723 - 03:13:57.025, Speaker A: And notice why does it still download docs? That doesn't seem right. Have I like not pulled that? Shouldn't matter. That's interesting. Okay, so this seems like an issue. When I set the profile to minimal. Then installing something should not download docs. Maybe it's because I already tried to download this one.
03:13:57.025 - 03:14:29.675, Speaker A: I try to download a different one. What happens? Nope, it still fetches docs. Yep, that seems broken. Yeah. Okay, so it is just setting profile minimal there. Okay, so something is broken. The real question is, do we want to fix this or do we want to fix it differently? Huh.
03:14:29.675 - 03:14:57.209, Speaker A: Oh, maybe you're right. Maybe I do need to do this. Set profile minimal. Although it should just have the same effect I thought. Yep. Still download stocks. Try a more recent nightly.
03:14:57.209 - 03:15:14.285, Speaker A: Sure. Okay. Yeah. So with a more recent nightly it does not London docs. Whereas if I did this. Oh, default. Great.
03:15:14.285 - 03:15:30.579, Speaker A: Then now it will download docs. Ooh, I did not like that unavailable clippy. Great. Yeah. So now this seems to work. No, I'm on 120. It's the nightly.
03:15:30.579 - 03:15:43.219, Speaker A: I was installing the 0101 that did install docs. But on 10.04 then it will. Then the profile applies correctly. So I'm not Sure. Why that is. But that's the case.
03:15:43.219 - 03:16:21.995, Speaker A: So you see. Now let me demo this again now that it actually works. So if I have the default profile and I try to install say this nightly, you'll see that it downloads cargo, clippy, rust docs, etc. If I set the profile to minimal, Minimal profile, minimal. And then I try to install it, then it will not download clippy, it will not download docs. This apparently only works for recent nightlies, but that's fine. And now the question is, is there a way where I can do profile here? Minimal.
03:16:21.995 - 03:16:46.645, Speaker A: Right. So I'm going to set my profile back to default and now I want the ability to do this. Yeah, exactly. 0101 is before profile data was available in the channel manifest. So that's why the older ones didn't work. So I want the ability to run this. But of course, profile isn't supported on install and that's what this ticket is all about.
03:16:46.645 - 03:17:16.475, Speaker A: All right, so we want the ability to do this with Rust up. How do we do that? Well, let's start a new branch and we're going to call it Fix 2004. Great. Where do we start? Well, start with contributing the same thing that we did for Cargo. Right. And we forked the project. Done.
03:17:16.475 - 03:17:28.471, Speaker A: We created a branch. Done. We can't commit any changes because we haven't made any yet. I feel like there's a 2.5 here, which is make edits. Yeah. So we want to develop rest of itself.
03:17:28.471 - 03:17:46.425, Speaker A: So we're going to install it into temporary directory, which is what we just did. There's Cargo build. I don't actually did a. I didn't do a Rust up home. I'm just going to share my normal install and that's fine. So this is a different way of doing it. It's basically installing another copy of Rust up.
03:17:46.425 - 03:18:06.633, Speaker A: I didn't want to do that. Doesn't really matter. I know that this particular thing works. Yeah. So here, developer trips and tricks. That's where you see this environment variable that I'm using to trick Rust up into thinking that I'm running Rust up. All right.
03:18:06.633 - 03:18:49.939, Speaker A: So in theory, just Cargo build is all we should need. Which also means that in theory we should be able to run cargo tests. Actually, let's do test one. Oh, those tests are slow. Why are the tests low? Seems slower than they should be. I probably like launches some processes or something. Okay, so the test.
03:18:49.939 - 03:19:29.891, Speaker A: Now we have a test suite that runs great. Now let's see if we can actually figure out the issue so this is part of the install path, right? Like, we want rustup install some nightly to take a profile flag. So the first thing we want to do is find install. Generally the easiest way to do that is look for a file called install. Well, there's source install. What does that do? Installation and upgrade of both distribution managed and local tool chains. That seems exactly like what we want run, huh? Okay, so this seems like the stuff that gets called when you try to install something.
03:19:29.891 - 03:20:05.225, Speaker A: But the real question becomes where is this used? Like, how is this called in the first place? So this install method, see if we can find where install method comes from. Ooh, Source toolchain. That seems potentially promising. Let's look for install here. Components status install. Interesting. All right, so this all seems like sort of internal wiring, whereas really what we want to find is where are the arguments parsed? So maybe let's look for clap.
03:20:05.225 - 03:20:24.433, Speaker A: That seems promising. Rust up mode. Source cli Rust up mode. That seems very promising. And here, is there something called install? There is. Interesting. So main.
03:20:24.433 - 03:21:05.411, Speaker A: Okay, this seems great. So this is the main that gets called when you want to run rust up as a binary with the name rust up. Basically you should think of this as rust up behaves differently depending on the name of the binary you're running it as. And if you're running it as rust up, then you're in rust up mode. In fact, if we look@Source CLI, you'll see that there's like setup mode, proxy mode. Who knows what main is? Okay, so it looks like install just calls this update function. All right, so where does update come from? What is update? Well, here we have sub command install.
03:21:05.411 - 03:21:51.155, Speaker A: That seems promising. So we want sub command install to take profile. But we also know that there are other places where you can call profile, and ideally we want them to work the same way. So let's look for arg profile. All right, so setup mode also has a argument profile. Great. We want the same things in our profile, which means we need profile names and profile default name.
03:21:51.155 - 03:22:23.389, Speaker A: Where does it get profile from? Gets it from over here. So we need that over here too, which we already do. Great. So now we have the profile argument to install, so at least there's that. But now we need to parse it somewhere. All right, so this creates a giant list of commands for rust up, and at the end it probably has to parse them somewhere. So this was cli.
03:22:23.389 - 03:23:02.605, Speaker A: So something calls cli rust up main. Great. Yeah, so this is what matches on the sub command looks for install calls update. So where does update come from? Let's see if we see an update. Actually, do I have gd? I should have just who. That seems promising. Is there an FN update? Great.
03:23:02.605 - 03:23:46.535, Speaker A: All right, so it looks like both install and update. Really call this update function. So this is sort of a catch all for you want to change the set of tool chains are installed. Installed. All right. And in our case, what does this do? Values of tool chain. Does toolchain have a default value? Then values of.
03:23:46.535 - 03:24:39.897, Speaker A: Let's see. So what is toolchain even set to in install? Target toolchain, Update Install. It's not set to anything by default. That's interesting. So this is. I think. I think this will be some with an empty vector, but I'm not sure.
03:24:39.897 - 03:25:28.469, Speaker A: Regardless, it might not matter. So this calls Update all channels and this calls. Okay, so what does update all channels do? Okay, well, that's unhelpful. So where does config come from? Fine. Update all channels on config. So update all channels. Just lists all the channels which are things like stable, beta, nightly.
03:25:28.469 - 03:26:23.913, Speaker A: And it calls instead install from dist on all of them. And if we go back to our update, it calls install from dist on all toolchains. Okay, so it looks like regardless of whether you end up through this path because you haven't specified a toolchain, or you end up here because you have specified a toolchain, you always end up in this install from dist business. And so really what we want here is we want to make sure that we thread through the name of the profile, if there is one. So let's look at what install from dist does. Install from dist. So install from dist does install method dist.
03:26:23.913 - 03:27:11.185, Speaker A: That seems promising. So this is like a giant struct or tuple of various properties about the thing you want to install. I guess here we see components you want to install, targets you want to install. Who knows what all the other fields are. But this seems like a place where we need to include the profile that we want to be used. And this calls install. What does install do? It calls install method run.
03:27:11.185 - 03:28:11.855, Speaker A: All right, so that means that this means that this install method thing install must have a run method. So installment dist. What happens if you call run on it? It calls update from this. So this is like a web of calls that we're just like we're trying to. Trying to trace down to where ultimately it's trying to install all these things. So this update from dist mod, what was it? Update. Update from distribution Dist update from dist.
03:28:11.855 - 03:28:44.533, Speaker A: All right, and that calls update from dist. So down here calls try update from dist. What does try update for Distill downloads and manifest. That seems promising. Get profile components. All right, get profile components. Seems like something we care about if profile is sum.
03:28:44.533 - 03:29:47.805, Speaker A: All right, so this is the thing we need to end up overriding with. So where does profile come from? Profile comes from here, which comes from here, which comes from here, which comes from here, which comes from here, which comes from here, which comes from exists, which comes from profile. All right, so profile. So toolchain self config. Get profile. All right, so how does the config get set for install for from dist. So that would be back in rust up mode.
03:29:47.805 - 03:30:31.645, Speaker A: Toolchain. Uh huh. Okay, so it seems like what we want is to set. Is to set the profile in the. Yeah, we want to set the profile in the config that's used by the tool chain. Yeah. Does this track? I think this tracks.
03:30:31.645 - 03:31:27.625, Speaker A: So if we go back here, this toolchain has a config field and I mean we can double check that, but it should as a toolchain has a config field and inside config there is at least hopefully. How does profile get set here? Oh, interesting. Oh, this just mutably modifies the profile file. That's not ideal because we don't actually want to change the file. We want to change this temporarily. It looks like get profile will always open the settings file. Huh.
03:31:27.625 - 03:32:11.643, Speaker A: Well, that's awkward. Okay, so basically what we want to change here is we want the profile to be or the we want the profile to be stored in the config. Either that or we want to pass an override so that if the override is set, it uses that one. Otherwise it uses the one returned from get profile. That might be the cleaner way to do it if we don't want to modify the config here. Again, this is in the. In the interest of keeping PR small.
03:32:11.643 - 03:32:35.651, Speaker A: That said, like here, I think it would be okay for us to change. To change config so that it actually stored the profile and say loaded it when it starts. So there's a. Presumably like a new from env. So this probably opens the settings file, I would guess. Apparently not. But you could only imagine that this.
03:32:35.651 - 03:33:13.295, Speaker A: Ooh, set default. Yeah, so you could imagine that here in from end. Yeah, Settings file. Like right after this part it would load the profile here. That's actually probably what we want. What else is settings file used for? It's probably used to set a bunch of things. Yeah, interesting.
03:33:13.295 - 03:33:33.905, Speaker A: Okay, so we have. We have two options here. One option is for us to pass to install from dist. Like a profile override. That'll be one way to do it. We'd have to do the same for update all channels down here. So maybe it's a little awkward like we'd end up having to override a bunch of things.
03:33:33.905 - 03:34:22.051, Speaker A: Actually, we can just override it in here. I think we want to change it on config because that way we can just change the config right here. Promise. This is read only, so we don't really have a way to overwrite it. We could clone it and modify the clone. It's definitely a little ugly. So I assume the reason that it's read only is because you're not supposed to change the config on the fly because it's basically what is stored in the files.
03:34:22.051 - 03:35:18.845, Speaker A: But it feels a little bit against the spirit to be adding immutable feel to config given that it doesn't seem to have any other. It doesn't seem to have any mutable fields. So it feels a little bit like cheating to add one. But at the same time, like, all right, we could try it. Does this even implement clone? Oops, that is not what I wanted to do. Does not implement clone. It's also kind of awkward.
03:35:18.845 - 03:36:08.945, Speaker A: I think it could implement clone. Let's just check that it actually can. I want. Hmm. This is something that you run into for submitting PRs to other people's projects is that it doesn't always make sense to you, the design decisions they've made. And you want your PR to align with the design they've chosen for their application. Right.
03:36:08.945 - 03:37:08.930, Speaker A: And so you really need to think about what is the way in which this change will match the current design. Temp config. That's a good question. Rest of their joint temp. It seems to be something that's like the temporary directory used for temporary stuff. It seems like because it uses the Rust update join with temp. Let's see if we can make this be clone 37.
03:37:08.930 - 03:37:45.525, Speaker A: Should be an arc big 93. Oops config 93. This is now an arc new. Great. Okay, so that's now clone. And then I guess what we'll do is cached profile. I think it really should say just profile.
03:37:45.525 - 03:39:17.385, Speaker A: And then what we want is dist profile. So that's going to be a dist profile and then this. So get profile is really what we're going to do up here. And so we're going to say let profile is equal to that because then when we construct the config down here, we can now add in profile here. Then down here we can say that this now just returns self dot profile. This is now no longer true. This cannot fail anymore.
03:39:17.385 - 03:40:15.871, Speaker A: Interesting. So this previously returned an error if settings file could not be read or the profile is invalid. Both of those are now instead going to cause errors when you create the config, which is probably fine and it will still return ok default. All right, so this I think can now go away. And now set profile also has to change because here, let's do this. So set profile has to do self dot profile. Oh balls.
03:40:15.871 - 03:41:47.685, Speaker A: We can't do that, can we? Because set profile only takes a ref self. Problem here is if set profile is called then get. If you called get profile after, you would not get the same result. Okay, here's a proposed alternative strategy. Given that that won't work, we make this profile override, then we have this be. We have this set the profile override to nothing initially and then we have. That won't work either because this still just gets a read only config.
03:41:47.685 - 03:42:58.886, Speaker A: No, if we clone it, it's fine. So here's a proposal. Get profile is going to be if self. If let sump is self profile then return ok, P clone, right? And then we have a width profile. Basically that is pubfn with profile which takes a mute self and a profile and returns to self. And it does self profile override sets that to sum and then return self. Because now what we can do in rust up mode is say let config equals config.
03:42:58.886 - 03:43:34.085, Speaker A: Clone. With profile. Well, actually it has to do this. If let sump is m value of profile, then config is config with profile P. Great. And then of course you can do let config equals refconfig. Let's see what this says.
03:43:34.085 - 03:44:27.775, Speaker A: How are you able to search the source tree for files so quickly? So in my editor I have it set up with the fuzzy finder with fcf. So control P brings up a fuzzy finder for the file tree and so that gives me fuzzy find for files. I also have double spacebar mapped to switch to my previous file so I can swap back and forth between files quickly. And then space semicolon gives me a list of previously opened buffers and lets me fuzzy find through them. So that's my navigation flow. Okay, this probably needs something like a dist. Great.
03:44:27.775 - 03:45:37.305, Speaker A: So that's almost there. And then now we need this to parse the profile, I guess. Do you need to figure out how though? I sort of want to give the same error as Get Profile does when it fails. Get Profile which comes from tool chain. And that just seems to error normally. Okay, and what error did that give? That gives a this error like so. And this will just profile work.
03:45:37.305 - 03:45:55.685, Speaker A: Is profile even in scope here? Probably not. Oh no, it is great. Let's see how that works. Okay, so that worked. Let's see if it actually works. So my profile is now default again. And if I try this.
03:45:55.685 - 03:46:33.947, Speaker A: Oh, I need to rebuild. See what that gives us. Okay, that built. Oh, that did not download Clippy or rustock. And what if I do remove this? Then it gets clippy and rust talks. So that seems promising. That seems like exactly what we wanted, right? All right, so let's try writing a test for this now.
03:46:33.947 - 03:47:04.477, Speaker A: So install Add Profile Flag to override. Install Profile to override Profile Sound is much better than last time. Thanks. Whoever gifted you the shock mount. That's good. I'm glad. Yeah, it's because.
03:47:04.477 - 03:47:34.955, Speaker A: So the reason this happened was this microphone is better than the one I had like much earlier. And the boom arm is much more firmly attached to my desk, which means that the tapping sounds transferred to the mic a lot better and the mic picks it up better. So I think the shock mount helps. Could you use RC instead of arc? I could. The reason I used ARC is first of all, the cost doesn't really matter here. Like the atomics are insignificant in this kind of workload. Like if you're working with a command line tool.
03:47:34.955 - 03:47:58.355, Speaker A: And ARC means that the things are now send and sync, which is nice. And also because this code base uses arcs elsewhere. And so just for consistency, we might as well use ARC here as well. Install Test Install. Huh. Package contains. Let's look for profile here.
03:47:58.355 - 03:49:18.325, Speaker A: Really any profile here but setup profile in tests. That looks more promising. So there's self update climisc. What does Climisc do with profile? Alright, so this does what exactly? This seems to indicate that it runs rustup Init with profile minimal. Wait, does that not install Cargo? Really? Profile minimal doesn't give you cargo? That seems false. All right, well, I mean we could try that. Let's just copy this test to install and then just add install with profile.
03:49:18.325 - 03:49:59.245, Speaker A: Do we have a setup function over here? No. So this has a setup that does this thing. So let's copy that and see what this will do. Of course we don't actually Want to run rust up in it. So what are the other tests that do installs over here? Do they do mock installer builder? Seems awfully complicated. I don't want any of these. I think this might be the wrong file.
03:49:59.245 - 03:50:45.945, Speaker A: It's just like hang on to this and then find like test. Maybe just dist. Is there any install here? I don't know what all this business is, but from dist uninstall. Just want some easy way to write a simple test. Please. Clirused up. That seems promising.
03:50:45.945 - 03:51:09.041, Speaker A: Add target. See, this seems more promising. This does like rust up commands. That's what I want. Remove target. List target link. Do we see anything here that looks like inst.
03:51:09.041 - 03:51:48.455, Speaker A: Installing something? That seems promising. Install nightly. Show tool chain. Show tool chain. Okay, this certainly seems more like the type of. The type of test we want to write. Just want to find something that actually looks like.
03:51:48.455 - 03:52:23.745, Speaker A: Something that looks for, like components. Right. That's really what we want. This is a handy way to. I mean, this file is particularly large, but when you're submitting a PR to a project and you don't really know how to write a test, look for a test that does sort of what you want and then just copy paste it and then modify from there. Well, that's unhelpful. Let's look for like nightly.
03:52:23.745 - 03:53:31.125, Speaker A: What else do we have here? He's like test slash, cly. Looks pretty promising. Miscarriage, custom tool chains. Search path, run, install. That seems kind of promising, right? Like this has an install and then checks for installing component. That sound like kind of what I want. Yeah, like these tests seemed pretty promising.
03:53:31.125 - 03:54:06.035, Speaker A: Not gonna lie. Install profile. That's what we saw earlier. So really we've returned to the file that we started at. Okay, well, how about we just try one of these? Install profile. And I feel like I want the setup from something like this one, because this seems like a nice test setup. Let's just try that, see what happens.
03:54:06.035 - 03:54:38.895, Speaker A: And then let's just get rid of this business down here. All right. I don't know what this does yet. That's fine. Default. Default stable seems fine. And then I want to run install and I want to run install profile minimal.
03:54:38.895 - 03:55:26.585, Speaker A: See what did the install with profile. It uses setup simple V2. Okay. And that does not end up with cargo. Okay, so simple v2 install that and. Oh, I guess we need to do like nightly maybe. Actually, this seems to do stable, but I guess let's see what happens if I do like this.
03:55:26.585 - 03:55:55.915, Speaker A: All right, so we're going to do a setup I don't. Maybe we don't need this. We're going to do a simple V2, which. Who knows what that is? And we're going to set the default to be stable. I don't know if we even need that, but sure. Set default to stable. And then we're going to try to install nightly with a minimal, and we're going to see what that does.
03:55:55.915 - 03:56:57.295, Speaker A: So we're going to do cargo test and we're going to run install profile and see what happens. That's an awful lot of errors. This is all the. This is all the changes we made to temp config that apparently a bunch of things were relying on being able to. Oh, man. Use standard sync arc. There are other things that apparently distal arc.
03:56:57.295 - 03:57:32.337, Speaker A: And I guess we here too need use standard sync arc. I just want to run my test. I don't care about all these other tests. And yes, I know this. There's a flag I can add to test to make it only compile my thing, but test dist. Arc. Great.
03:57:32.337 - 03:57:59.981, Speaker A: Almost there. Now run my test, please. That seems promising. Running one test. All right, let's look at. Ooh. Okay, so it's running default stable.
03:57:59.981 - 03:58:39.765, Speaker A: That ran correctly and told us that we had stable install. Oh, I see. When we said default stable, it installed stable, and it seemed to include like, cargo Rust docs. Rusted. Great. Then we installed nightly with profile minimal, and then it downloaded Rust C. Well, okay, that's sort of good because that means that it did pick up the profile.
03:58:39.765 - 03:59:30.245, Speaker A: This was not installed. Huh. I think I know what this is. This is gonna be me cheating a little, probably. I know what this error is because I've seen it before, I think, and I'm pretty sure I need to pass this flag. And we're just gonna pretend that I spend a lot of time searching to find that and then see if it works. Okay, this is getting annoying.
03:59:30.245 - 04:00:09.451, Speaker A: Tests climb. I did mean climiscus. All right, so install profile minimal nightly. No self update that downloaded just Rust C, which is what we want. Rust up. Version that worked. Rust C.
04:00:09.451 - 04:00:45.235, Speaker A: Version that worked. Cargo version worked, which is not what we want. Oh, it's because we haven't said default. So I see that these are still run under the default tool chain because we haven't set the override. So what do these other ones do? I say we sort of need to set the default to nightly after doing this. Otherwise the following commands won't be running that way. Let's see what that does.
04:00:45.235 - 04:01:27.395, Speaker A: Well, that passed. Right. So, okay, so let's look at what this test does. I don't actually know what simple V2 does, but it's the same. I'm guessing this like sets up a manifest of some kind. And it sets up a manifest that we know from the other test we looked at. Right? So the other profile test, this one that already existed, use the same setup and when it installed with Profile minimal, then it got Rust up and rusty, but not Cargo.
04:01:27.395 - 04:02:01.443, Speaker A: And so what we're doing up here in ours is that we start with the default of Stable, which has all the stuff, and then we say install Nightly with a minimal profile. This no self update, I can tell you, is normally rustub tries to check for self updates at the end of installs because it treats them as updates. And this is just telling it not to do that. The reason is because it's not actually installed. It's running in a testing harness. And so the self update would fail. So we start with the default Stable.
04:02:01.443 - 04:02:40.339, Speaker A: We install Nightly with a minimal profile. So at that point, Nightly is installed, but it will only have Rust C. And then we switch to Nightly by setting it to the default. And now Cargo won't be there because for whatever reason, this manifest is set up such that Cargo is not installed when you install the minimal profile. Even though I feel like the minimal profile usually includes Cargo, so Rust Dock might have been a better example. In fact, I kind of want to see simple v2. What's in simple v2 in mock high tools.
04:02:40.339 - 04:03:23.545, Speaker A: Simple v2. Ooh. Okay, so when it's simple v2, you have a nightly and some stuff. Okay, so what's in these releases? What is a release Release? Mock build, mock channel. All right. Build mock channel. Build, mock channel.
04:03:23.545 - 04:04:06.545, Speaker A: All right, so where's the profile stuff? Okay, maybe it's related to this is extension business. No, it doesn't seem right. Well, there's no mention of Profile in this file. All right, well then I don't know, but it does the right thing. I wonder why. I wonder how. How it determines this profile business.
04:04:06.545 - 04:04:37.127, Speaker A: I mean, this works, right? We've tested it and it does what we expect it to do. It's more that I given that in reality Cargo is included even. Even in minimal installs. Like, it seems weird to be testing that way, but seems fine to me. It's painfully obvious to me now that I need to do a better job of structuring the install flow. Structuring the install flow in what? So this is one of the authors of Rust Up. I don't know what you mean.
04:04:37.127 - 04:04:59.465, Speaker A: By structuring the install flow. I think it's more about making it clear what the testing flow is. But the install flow. It's true if you want someone to edit the install flow. There was a pretty long chain. We had to go down like a pretty deep rabbit hole to figure out how anything ever gets called. Maybe one thing that'd be useful is some higher level docs that explained like how these pieces fit together.
04:04:59.465 - 04:05:55.181, Speaker A: Because there's a lot of just glue that really points everything to one place. Although maybe that is documented somewhere and I just like skipped the documentation. Okay, so let's first add these dist businesses because they are all. And then I guess this. Wait. Change Install Profile did not intend for that to be the case. Okay, we did a stupid.
04:05:55.181 - 04:06:39.725, Speaker A: So I'm gonna. Do you see what we did? I changed the existing test call Install Profile but I copied the test call Install Profile to Install with Profile which is the the opposite of what I wanted to do. Install Profile Install with Profile this should be down here with the other one. And this is the old one which is Install Profile and this is Install with Profile. There we go. That's more what I wanted and I want this to be the way that it was. Don't want to make any changes to the existing test if I can avoid it.
04:06:39.725 - 04:07:14.775, Speaker A: Great. And now let's see that this actually still works with Profile. I meant more the vast sequence of functions. Yeah, it was a pretty deep like rabbit hole to dive into. Great. Okay, so the test will pass this because we didn't change it, but we moved around. Add test for Install Install with Profile.
04:07:14.775 - 04:08:49.725, Speaker A: Now what I actually want to do here is I want to be a good citizen and do this. Oops, that's not what I wanted to do. Actually I want this squash these and then I want to say previously the Installation profile the profile to use for installation to use when installing a new tool chain had to be set manually had to be set through Rust up Profile. Set Set Profile. I forget Set Profile or at Rust up install time. However, often it in CI contexts and otherwise. I don't know how to phrase this.
04:08:49.725 - 04:10:17.765, Speaker A: Previously the profile to use when installing a new toolchain had to be set to Rust Upset Profile or Rust up installation had to be set globally through Rustic Profile or rest of install time. However, in CI contexts. However in some context. However, sometimes this is inconvenient because you only want to use a particular profile for a specific tool change. This patch allows users to pass profile to RustUP install to install a tool chain to Override the profile used when installing profile used for that one install. One question that this raises, actually, is if I update a tool chain that I installed with an overridden profile, does it now suddenly install the other components? It's a good question. Let's look at that test.
04:10:17.765 - 04:11:19.823, Speaker A: Sorry, what did I mean rust up init time? Sure. I just realized that what happens if I now do rust up update nightly? This should do that. I don't know that it will. I think this might break. That worked. Huh. So.
04:11:19.823 - 04:11:53.515, Speaker A: So here's my thinking. Actually, no, this. I'm almost positive that this will not work. Okay, so here's my thinking. If you install it with profile minimal, there's nothing recording that the profile you installed it with is minimal. And so if you later update it, how would it know to not install the other components? Maybe we'll check that they aren't already installed. I don't actually know.
04:11:53.515 - 04:12:40.015, Speaker A: The reason this test passes is because it recognizes that there is no newer nightly. So we want to update. Is there a way we can get a simple V2? Okay, so there's a different date that's available here. So is there like a date? Wait, I can set? Yeah. Here we go. Okay, so I'm going to set this here, and then I'm going to do this and see whether that fails. No such file or directory.
04:12:40.015 - 04:13:54.139, Speaker A: What? Wait, what? Rust backtrace equals one. Rust backtrace equals one. Why? Where? How? Change channel date apparently. Ooh. What? I'm not allowed to do whatever I did there? Apparently you can't set the date as we experienced at the start start. But other people do it, so why can't I do it? Maybe I can only set it here. Oh, so these are mocked.
04:13:54.139 - 04:14:26.615, Speaker A: These are not real manifests. They're mocked manifests. So the 2015 is you can ignore. It's not related to real dates. I'm going to make this expect error just to see what the output is now. Bollocks. Huh.
04:14:26.615 - 04:15:11.395, Speaker A: That's fascinating. All right, show me that output. Yeah, so it didn't actually do an update there. So why. Don't understand why this won't work. All right, bye. Dutch, you're here for, like, every stream.
04:15:11.395 - 04:16:14.201, Speaker A: It's amazing. No such file or directory at Mock Dist 48. That seems problematic. Why am I not allowed to do this when other things that use v2 are allowed to? Or maybe they aren't. Aha. It's because other people aren't doing that. Hmm, interesting.
04:16:14.201 - 04:17:54.381, Speaker A: So I can't actually make it update because this for Whatever reason won't work. Wonder why. What's in dis tests? Dis confused ar. Where is it getting these manifest from? Is it like generating them? Huh, that's very odd. I don't understand why. There are other tests that are able to call this current dist date, but I can't update unavailable Rust C. Like what happens if I run that update Unavailable Rust C? Yeah, that runs just fine.
04:17:54.381 - 04:18:36.235, Speaker A: So why oh why oh why does mine not? This sounds like simple v2 just like doesn't do that. That's fine. I'll just do one called I don't know. Full. Full seems great. Let's do full. I wonder why.
04:18:36.235 - 04:19:32.705, Speaker A: Seems odd, huh? Well, now that works and apparently the update I'm gonna assume that it now actually does the update. And apparently that update doesn't install any other components. Don't quite understand why that sounds like if you run Rust up update, it won't install components you didn't previously have installed. Which actually I guess maybe makes a lot of sense. I mean we can leave it in as a. As a test anyway to check for regressions in this behavior. Yeah, so it updates and then it only installed the component we had.
04:19:32.705 - 04:20:26.008, Speaker A: Okay, great. So that was the only concern I had. But at least now we have a test for it. So this is going to be installing with minimal profile. Should only install Rust C after an update. We should still only have the profile dictated components. All right, so I'm going to just fold that into the previous update and we're also going to say that this fixes 2004.
04:20:26.008 - 04:21:16.845, Speaker A: Fix 2004. 2004 was broken. All right, it's going to get light again, people. And file pull request 2004, 2004 and 2019 with tests that talk about 2015. All right, pull request excellent. So we now have another PR that you can watch this one. Oh, I forgot to push big.
04:21:16.845 - 04:21:52.877, Speaker A: This pr. This was the other PR that we filed that you may want the URL to. There we go. All right, well, we now have three PRs to three different rust projects. I think we're probably going to stop there because I don't have an idea for another contribution. And it's also getting a little bit late. So let's just recap what we did.
04:21:52.877 - 04:22:52.753, Speaker A: So first we made a contribution to Cargo where we changed its handling of what it does when the target directory has symlinks in it. Then we ported a crate from future 0.1 to stack standard Future and then we made a change to Rust up so that you can choose which profile to install a given tool chain with at install time to override the globally set profile. It was a pretty decent amount of stuff we got done in like what, four and a half hours. It's pretty good. I think we did well done us. So at this point I recommend you watch all of the PRs that we just submitted because very often there's follow up work either because the authors or the maintainers of the crate request added tests, request changes to behavior, and sometimes they might even say we don't want to fix this way.
04:22:52.753 - 04:23:44.487, Speaker A: Like for the cargo change we made. That change might be more controversial because as someone mentioned in chat as well, we will end up recursing outside of the target directory if there are symlinks outside. And so these might be worth watching if you want to continue to see the process that these PRs go through. If anything, my goal with this particular stream was to just show you that supporting a project or contributing to a project that you haven't contributed to before is okay. Remember that here we like here we just sort of dove in. We did not do any mentored issues, we just dove into the code. If you look for issues that are marked as E easy things that are marked as Hacktoberfest also work pretty well.
04:23:44.487 - 04:24:24.565, Speaker A: Things are marked as mentored. Then you can get more help getting started if you feel like you want that. But it isn't that daunting. Like just start and initially a lot of what you do is just going to be copy pasting and that's fine and then submit a PR and then people will talk to you and ask for changes and that's sort of how the whole system works. And remember that even the Rust tools are just code, right? And you can contribute to the ecosystem a lot by improving the tools that lots of people use. Like these fixes are going to matter to people like especially this one to Rust up. My guess is we will see this used and like CI scripts for lots of Rust projects and that's pretty cool.
04:24:24.565 - 04:25:05.985, Speaker A: Whenever you help improve the Rust tools, you really improve the entire ecosystem. Will you tweet about the follow up if applicable? Yeah, I'll do that as well. So if as the PRs get updates, basically when they get merged or closed, I'll make sure to tweet out as well to mention that this happened in stream and to point it out to you. So if you want to follow updates for upcoming streams, this is me, twitter.com johnwho and I tweet. So I mean I'm a normal Twitter user. I retweet things and there's stuff there that's not Rust related.
04:25:05.985 - 04:25:58.615, Speaker A: But I try to make sure that whenever I have thoughts for an upcoming stream and I want to hear feedback about it or just just if you want to talk about stuff or if just announcing upcoming streams or announcing like interesting changes in the Rust ecosystem or to the Rust language, then I'll post it there. So feel free to follow me there if you want. There's also so I also am part of a actually I should mention that here there's a Rust podcast called the Rotation Station that Ben Striegel and I have started and it's sort of a community podcast. So the idea is that if you want to make a podcast episode about Rust, even if it's just a one off, then get in touch with us and we will help you make that episode. And then we do regular episodes on what's new in each new Rust release. So we recently talked about 138. I recommend you give this a listen.
04:25:58.615 - 04:26:38.715, Speaker A: We also have guests hosts almost like almost every other week where they just talk about things they think are interesting and interview people they think are interesting. So if you want to be a part of that then, or just listen to them then, then I invite you to do so. And of course if you enjoyed what I do then please take a look at the Amazon Wishlist. It's like the only way I have to get anything back from this apart from just your you being happy about being educated, which is great. That's why I do this. But if you, if you have some extra support, I would love that. And with that I think we're gonna sign off for today.
04:26:38.715 - 04:26:49.735, Speaker A: Thanks for joining me. It's always fun to program with other people and I think this turned out pretty well. I will see you in a few weeks time. So long, farewell, auf Wiedersen, goodbye.
