00:00:01.040 - 00:00:41.684, Speaker A: Hi folks, welcome back. This one's going to be a sort of a switch of pace from the previous video in that we're not going to be talking about the sort of wait free simulation stuff that we've been doing for the past few videos. I'll link those above if you're coming here for the on demand video. And instead what we're going to do is try to implement a sort of a safe memory reclamation scheme that's designed for concurrency. And I'll talk a bunch about that over the next 5 hours. But before we dive into that, I wanted to mention, in case anyone has missed that, I am writing a book. It's called Rust for rustations.
00:00:41.684 - 00:01:22.942, Speaker A: It is, as its title implies, a book that's written for people who know Rust, who want to know more about rust. And so you can get that early access now, you'll get all the chapters ahead of time. So I wanted to mention that before we actually dive in. So the scheme we're going to be implementing today is hazard pointers. Actually, let me go to this one. So hazard pointers are this really neat structure, or algorithm rather, for safe memory reclamation and concurrent programs. And in order to understand why that's important, you probably want to watch the previous streams.
00:01:22.942 - 00:02:31.950, Speaker A: Like it should be very obvious there why we need something like this. But I'll try to give a sort of very high level overview of why this is necessary in the first place. If you come at this from like, I know some data structure stuff, but hazard pointers or concurrency looked cool, so I just jumped right into this video. So when you write concurrent data structures that allow multiple threads to read and write a given data structure at the same time, you run into this problem where let's say, let's say we have a, it's a good example of this, a linked list, a concurrent linked list. And one thread is walking the linked list. Instead of reading every element, another thread is removing an element from the list. And now imagine that the thread that, or you don't even have to imagine the thread that removes from the linked list wants to deallocate the thing that it took out of the list, right? Because otherwise you're never going to deallocate memory, and that's bad.
00:02:31.950 - 00:03:47.030, Speaker A: And now you run into this really awkward thing where the thread that removed the item doesn't know whether the thread that's reading the list, or indeed any thread is currently looking at the thing that it just removed, it knows that once it's been removed from the linked list, no thread that sort of comes along after that point is going to find that node because it's removed from the link list. Like there's no way to actually get to it anymore. But readers that were, that were around before it did the remove might still have a pointer to that thing, and you can't deallocate it until you know that no one else has pointers to it. And that's where we get into this question of concurrent memory reclamation. There are a bunch of different ways to deal with it. You can do things like reference counting, or there's a structure called RCU that's a little bit more involved maybe. And reference counting is sort of the standard one that people reach for, where anytime you grab a pointer, you like increment the reference count for it, and you only dereference it when the reference count reaches zero, because then you know that no one has references anymore.
00:03:47.030 - 00:04:30.846, Speaker A: That works really well. It does have some downsides, though. The primary one among them being that in a concurrent program, if everyone who wants to read or write any, any element in the data searcher you've constructed has to increment and decrement this one reference count number. Then as more and more threads try to access, access this data structure, you end up with contention on that counter. So, like, that counter is initially one, which is whoever allocated the thing in the first place. But it keeps going up and down, up and up and up and down as people read and write the data structure. And this can be really costly, right? Because now these threads have to sort of synchronize their access to that one counter value.
00:04:30.846 - 00:05:25.982, Speaker A: And crucially, readers have to as well. If all you're trying to do is read every element, then for each element you have to, like, increment the count, read the thing, decrement the count, increment the count, read the thing, decrement of the count. And so your read operations become fairly expensive and they don't scale very well as the number of threads go up because more threads, more contention, lower throughput. And so that brings us then to these concurrent memory reclamation schemes that are designed specifically for being efficient in the face of this kind of operation, where you want your reads to be fast and you're okay with your writes being a little bit slower because you expect them to be less frequently. Um, and hazard pointers is one of these. Um, there are a couple of others. Uh, the primary sort of other contender is, uh, epic based reclamation, which is what is implemented by crossbeam, epic, for example.
00:05:25.982 - 00:06:12.392, Speaker A: I won't go too much into epic based reclamation at least in this stream, we might do that some other time. We're just going to focus on hazard pointers here. Um, but the basic scheme that they both use is that you have sort of a mechanism guarding access to a given pointer that doesn't necessarily require that you do like a shared synchronized counter, like the way you do in reference counted schemes. It was originally proposed in this paper from 2004. And we're going to look through this paper a little bit. It talks a bunch about the way you would implement it and some of the trade offs that you're making. We're also going to be looking at Folly, which is a Facebook open source library that has all sorts of interesting, like data structures and algorithms.
00:06:12.392 - 00:07:15.162, Speaker A: And one of them is this implementation of hazard pointers that has a bunch of other optimizations and features beyond what's in the paper. And this Facebook implementation is the sort of example implementation for a proposal to add hazard pointers to the C standard library, which is this, this proposal over here. I think that's sort of stagnated a little bit, but it does have some really good explanation of what's going on and sort of the trade offs involved. And so we'll talk a little bit through that as well. It has this handy table, too, which is a comparison of deferred reclamation methods. And you see those reference counting, split reference counting, which is really, you have multiple, multiple counts, so that the increment and decrement of the different, different counters can be done in parallel rather than just having one counter. But it fundamentally has the same kind of problem, RCU, which we're not going to talk too much about, and then hazard pointers.
00:07:15.162 - 00:08:13.788, Speaker A: And so I'll leave this table up while I sort of pause here to see if there are questions before we, before we continue. Let's see. Oh, I'm glad people like the book. That makes me very happy. Sounds like the flurry hash map. So when we did flurry, which is, there's another video which is a port of the java concurrent hashmap to rust. When we did that, you run into some of the same problems, right, of how, how do you know when it's safe to deallocate? In flurry, we used crossbeam epic, which has this epic based memory reclamation, where you have like these guard objects that you hand out with any reference to a given thing.
00:08:13.788 - 00:09:13.114, Speaker A: We're probably going to end up with something somewhat similar here with hazard pointers. We'll see which, which path we end up taking. So the problem is very much similar. Like we could have used hazard pointers in flurry as well, rather than using epic based reclamation. Let's see, there's a reason we can't use crossbeam epoch for the wait free simulator. So there isn't really. One difference is that with epics you have to use these guards, which can get a little bit annoying to use, like they tend to complicate the API a little bit, whereas with hazard pointers, you might be able to get away with nothing, not having that guard more often.
00:09:13.114 - 00:09:56.136, Speaker A: So we'll see how that plays out in practice. Like you can see here as well. Actually, this isn't talk about epic based reclamation, but there is some trade off where with hazard pointers you get slightly more eager memory reclamation than you get with epic based reclamation. So there are trade offs between the two that we might go into later, too. But in some sense, the reason I'm doing this is because it's like an interesting implementation, it's an interesting problem and an interesting algorithm, and hopefully we're going to learn a bunch while going through it. And the other reason is that there just isn't really. Well, there are some hazard pointer implementations in rust, but they're all not really maintained, at least as far as I can tell.
00:09:56.136 - 00:10:41.420, Speaker A: And I feel like it would be nice to just have a solid implementation of it that we can make use of. There's a third reason, too, which is that the hazard pointer implementation that we're going to be looking at is written in C. Most of the other porting streams we've done have been porting from, from Java. I mean, there's the port of flamegraph, which was Perl, but doesn't really count. But in this case, we're porting a C code base instead of a Java code base. And I think that's valuable so that we have more different things that people can look at when they're trying to learn rust through these videos. Okay, so now that hopefully the sort of problem area at least is clear, like why we need something like this, let's go through.
00:10:41.420 - 00:11:24.158, Speaker A: Actually, let me. How do I want to do this? Do I want to do this by text or by graphics? So this paper from 2004 is actually really nice to read. It's written in a very informal style that makes it pretty straightforward to follow, and it sort of makes all of the problems you run into pretty obviously, but it's also written with like C code inlined in the paper, which makes it a little bit hard to follow. So I think what I'm going to do is actually draw this. I think that's going to be the easiest way to try to convey what's actually going on. So. Ah, so this is a good question.
00:11:24.158 - 00:12:22.320, Speaker A: Are hazard pointers weight free? No, hazard pointers are not necessarily weight free. It depends on the underlying algorithm. In our case, I think the implementation we have will be wait free. Is that true? No, it'll be lock free, but not wait free, because we're going to end up using a concurrent linked list that isn't wait free. But if you used a wait free list there, that it would be okay. So here's the basic premise that we're going to be dealing with. Let's say there's some area in memory, there's some value in memory over here, X.
00:12:22.320 - 00:13:06.908, Speaker A: All right, I'm using, that's fine. So there's some value in memory X over here that we want to guard the access to. We want to make sure that if some thread, like, there are a bunch of threads that are all trying to read X, right? So these are all readers. And then we have some thread over here that's trying to write X. It's trying to sort of set X equals Y, I guess, or change this value to Y. And the question is how it's going to do that. In practice, the memory image doesn't really look like this for concurrent access.
00:13:06.908 - 00:14:12.420, Speaker A: Right. The way that it more commonly looks is something more like this, where you have an atomic pointer here that points to x. I don't know, I've ended up with a pressure sensitive marker, which is real weird. That's why these end up with blobs. And then what happens in practice is that all of the readers have access to this atomic pointer over here, and they sort of, they load the atomic pointer and then follow it, and then dereference, whatever they get to. That's actually how this pattern ends up looking in memory. And similarly, if you're a writer, what you actually do when you try to, like if you're a writer over here and you're trying to set this to y, what you would actually do is you would do a compare and swap of, I guess, this yellow thing from Xdev to Y.
00:14:12.420 - 00:15:58.100, Speaker A: And so effectively what you're doing is you're changing this so that it instead points to your Y value, right? And so that way any reader that comes along after you've done this swap is going to see Y instead of X when they follow the pointer. So the question then becomes, as a writer, how do you, what do you do here? Right? Like when you do the swap and now any subsequent reader is going to see your, your y instead, then what do you do with the x? Because there's still like this, this reader, for example, that followed the pointer before you did the swap and is presumably still hanging, hanging on to X. Like how do you know when that, that thread goes away? And the way that hazard pointers solve this problem is that every reader, every reader is going to have a hazard pointer, okay? So this is going to be a hazard pointer, and there's going to be one for each thread like this. And what the hazard pointer is, is it is either empty or it is a pointer that the thread is currently using. So let's, let's take the progress here of like, let's call these. These are one, two, and three. So this is the hazard pointer for threads one, two, and three.
00:15:58.100 - 00:16:37.726, Speaker A: And now let's say this is thread one's hazard pointer. So initially it's empty because one doesn't hold a handle to anything. Then one reads this, this pointer, the, it reads the atomic pointer and it gets back x. Okay? So at that point what it's going to do is it's going to set its hazard pointer to be the address of X. So notice the address of X is like this. It's not the pointer that led us to x, it's the value we loaded out of the shared atomic pointer. So the address of X is what we write into here.
00:16:37.726 - 00:17:23.100, Speaker A: And then what the writer is going to do is after doing the swap, it's going to look through each of these. Let's see if I can draw an I here. Right. It's going to look at each of these and see if any of them contain the value that it's trying to deallocate. Right. So it's going to look for the address of X in all of these. In this case, because thread one is still holding on to this, it finds that there's a, there's already someone sort of, there's some hazard pointer is guarding the address of X, and that means we're not allowed to deallocate it yet.
00:17:23.100 - 00:18:17.990, Speaker A: And so what that means is the writer has to wait to deallocate, deallocate X. It can't do so yet. It can either sort of go do other things in the meantime and sort of remember X for later, or it can go in a loop. But we'll look into how you might choose one, one or the other of these. But ultimately, the fact that some hazard pointer is guarding this address means that this writer isn't allowed to deallocate x at the moment so let's say that at some later point in time, either by spinning or by going, doing something else and coming back like some time passes and thread one finishes with its, let's go back a little bit here, finishes with its read of X. So it then wipes out. It has its hazard pointer again, sets it to null because it's no longer, it no longer needs that pointer to remain valid.
00:18:17.990 - 00:19:11.924, Speaker A: Then the writer comes along again and does this, this sort of search again. This time it doesn't find any occurrence of the address of x. Like the address of X is not guarded by any of the hazard pointers. And therefore it's now okay to deallocate X because no one is claiming that they need X to stay alive. And therefore we wipe away x because we now know every reader is either every reader from the past must have, must no longer be holding x, or any reader that come in the future is going to read the atomic pointer after we did the swap, and therefore we'll be seeing y instead of x. Okay, does that, does that make sense so far? This is sort of the, the basic scheme for household pointers. There's, there's some more implementation details, but this is sort of the, the overall design that we're going for.
00:19:11.924 - 00:20:31.240, Speaker A: For, if this is lock free but not wait free, could you use the wait free algorithm to make this wait free? No, there's a, there's like a recursive dependency here where the, the thing that turns a lock free thing into a wait free thing depends on memory reclamation in order to do that. And so the memory reclamation can't depend on the wait free thing. It's a circular dependency once everything is in there. Yeah. One thing you could do here, right, is implement hazard pointers with cross beam epoch. No, implement the wait free simulation with crossbeam Epoch and then release that as one major version of the library and then release another version of the library that uses the wait free simulation on top of the epic based reclamation. But you still end up like somewhere down at the bottom there, there's an implementation that's not wait free.
00:20:31.240 - 00:21:29.938, Speaker A: This really doesn't seem that different than epics. So it's a little different than epics because there's no explicit epic annotation. Like, there's no epic counter here. Every value that gets deallocated isn't allocated to a particular epic. Rather, this is like set of sort of guarded pointers that the writers have to check. Rather than every time you deallocate, you sort of mark it with the current epic and stick it somewhere, and then at some point later on you deallocate everything in that epic after all the readers have moved along. You can sort of think of hazard pointers as being a little bit more targeted than epic based reclamation is because it's looking at which exact pointer are you using rather than in what epic did you read? This is also the reason why epic based reclamation can be a little bit more efficient than hazard pointers is because it tends to do more like batch deallocations.
00:21:29.938 - 00:22:24.860, Speaker A: But it's also the reason why epic based reclamation tends to use more memory, because you can't collect an epoch until you can't collect anything in the epoch until the entire epoch is passed. Whereas with hazard pointers you can deallocate the moment. There are no readers for that thing. So thread two and thread three can already see. Yeah, the idea here is that two and three aren't currently reading it, haven't seen x, have rescene y. If either of them were holding on to x, then the writer would be blocked on those as well. Won't this cause the wait free simulator to only be lock free? It will, but it'll still be better than something that is purely lock free, because we're still wait free for more cases.
00:22:24.860 - 00:23:45.398, Speaker A: There are now a much smaller sort of set of cases where where we actually end up being only lock free, if you will. How can one thread know if another hazard pointers is holding x? Ah, so this is where, this is sort of the first implementation detail, which is as you correctly observe, the the writer needs to know about all of the reader hazard pointers, right? Otherwise it doesn't know how to do this, like lookup check in the first place. So the way we're going to do that is that all of these hazard pointers are basically going to constitute one long linked list. So there's going to be some pointer over here. This is going to be the sort of hazard pointer list, and this is going to be a lock free linked list that just links together all the hazard pointers and it's shared. So the idea is that if you want to do a read, then you grab a hazard pointer from the list. Rather, you grab an unused hazard pointer from the list, or if there isn't one, you allocate a new one and add it to the list.
00:23:45.398 - 00:24:49.094, Speaker A: If you're a writer, you walk the entire hazard pointer list and check all of them. So that does have to be shared between the readers and the writers, basically between every thread. This has to be accessible from anyone who wants to interact with this data structure. This of course also raises another thing that's, that's kind of neat here, which is you can keep multiple hazard pointer lists. Like imagine that. What's a good example of this? Oh, just imagine that you have, let's say we expose this as a library, right? And there's like the user creates two different hash maps, like concurrent hash maps, each of which uses hazard pointers internally. Well, you don't really want a writer in one hashmap to have to check all the hazard pointers in the other, right? There's no need to do that because a reader in this map just does not affect this map at all.
00:24:49.094 - 00:25:45.166, Speaker A: And so they can have different hash hazard pointer lists. And this is sort of a nice thing that we want to expose. So it doesn't actually have to be a global pointer list, it just has to be a hazard pointer list for anyone who might read this thing or this set of guarded objects. The other thing that gets complicated here with hazard pointers. How do we ensure thread safety on the pointer list? Oh, this is, this is just going to be a standard, like atomic linked list. Like you just do a compare and swap with the head and you never have to deallocate the things in the hazard pointer list. I think the trick, we'll look at this when we look at the implementation, but the basic trick is going to be when you're done with your hazard pointer in the list, you just mark it as inactive and stick it at the head.
00:25:45.166 - 00:26:40.730, Speaker A: And that way if some other thread comes along and needs a hazard pointer, it just picks up the one that you, it reuses the one that you used. So we don't actually have to solve the reclamation problem for the hazard pointer list itself because it's basically going to be a sort of, there's going to be a reclamation, sorry, reuse thing where we avoid allocating and deallocating. Technically you can, right? Like, so you can, I think there are ways you can safely reclaim from it, but in general we won't want to. This hazard point list is going to grow probably to the number of threads. Like that's the size is going to be, and at that point it won't really grow that much more because you're not going to be allocating another one if you already have one. And so there isn't really a reason to reclaim these. These are small anyway.
00:26:40.730 - 00:28:12.060, Speaker A: Won't readers have to create linked list nodes on each read? So each read still needs to do an atomic operation. So as a reader, it is true that you have to have a hazard pointer in order to read, but you can a, you can reuse one across multiple reads. B, in general, grabbing one doesn't contend with other readers, right? So grabbing one is just going to be look for one in the list that isn't used by anyone currently and then try to grab it. Or if all of them are used, allocate a new one. And unlike something like reference counting, you're not generally going to be like compare and swapping or fetch, adding a value that lots of threads are all trying to access because you're already only going to be doing it on something that's marked as inactive. It is true that there's a little bit of contention there on grabbing a hazard pointer, but they won't have to, like necessarily allocate a new hazard pointer each time, or compare and swap it into the list. Okay, so there's one more thing that is necessary here, which is a sort of race condition that I, that I skimmed over, if you will, which is this.
00:28:12.060 - 00:29:23.940, Speaker A: Let me draw back our atomic pointer here. So it's currently pointing to x. And let's just take the case of a single hazard pointer. So there's only going to be one reader and one writer in this case, and the writer wants to swap this to instead point to y, right? In fact, it doesn't even, the one thing that's nice with hazard pointers two is that the writer can just do the swap first, and then it just needs to decide what to do with x after the fact. It doesn't have to wait to do the swap, so it just does the swap. And now once it's done the swap, like it's sort of done with the right. And now the only thing that's left is the reclamation of x, right? So what do we do with this? And here a race condition happens.
00:29:23.940 - 00:30:56.490, Speaker A: So let's say that the order of operations is as follows. Let me do this with green. Why not? So, number one, the reader reads the pointer, and it needs to read the pointer first, because otherwise it doesn't know what to write in this box, right? It needs to read the pointer in order to know what value to put in there. Number two, the writer swaps. Number three, the writer checks the hazard pointer and it finds that it doesn't contain anything because the reader hasn't had a chance to put the value at redem into the box yet into the hazard pointer, so it drops x. And then for the reader uses pointer, which is two x. So this is a problem, right? This, we can't allow this to happen, because if we do, then now at four, right, the reader is accessing a pointer that's already been deallocated in step three.
00:30:56.490 - 00:32:22.376, Speaker A: And so for this reason, hazard pointers require a second read. So the way that hazard pointers actually work is like one load to store and then three is load again, and if not equal, then go back to one. That was really ugly drawing. But the idea is that you load the atomic pointer, you store it in your hazard pointer, and the moment it's been stored in the hazard pointer, you sort of go, oh, now it's safe for me to use it, but that's not actually true because the writer might have checked it in the meantime. So you go to check that the pointer is still the same as it was, and only if it is, is your hazard pointer safe. Because then you know that if a writer came along, a writer must have come along after you did the store in order to do the swap, because you read it after you did the store. Right? So if we go back to this case, right, so one r reads the pointer.
00:32:22.376 - 00:33:17.030, Speaker A: Two w swaps three, it checks it and drops. Then at four here, r is not going to use the pointer just blindly. It's going to load again. It's going to see that the pointer is now different because of the swap over here, right? And so therefore it realizes that its current pointer is not safe to use and it's going to go back to like storing the new pointer it got and then loading a second time again in the other sort of world where, where we go first. So let's say one is r reads the pointer. Two is r reads pointer again. Right? So I guess actually this is important.
00:33:17.030 - 00:33:59.784, Speaker A: R updates the hazard. And then three r reads pointer again. And you can even imagine that, like now let's, let's go with this one for w swaps. My writing on this tablet is terrible today. Five. The writer checks all the boxes, and at this point, when it checks the box, it realizes it's not safe to drop x and therefore it backs off. So you'll see that this handles both the normal case, but also the challenging case.
00:33:59.784 - 00:35:20.440, Speaker A: And the idea is that by doing these two reads and doing the store in between, you know that if the read is the same before and after the store, that must mean that either there was no writer until the second read, or actually it must mean that there's no writer before the second read. There might be a writer coming right after, but that writer must already see your store, and so you're safe. Nice. So that's the basic algorithm that we're going to be implementing here is this sort of guarded pointer bit, and that includes the linked list of hazard pointers, the guarding that the readers have to do, the writers having to walk that whole linked list. And if we switch back now to, if we switch back now to the ha. Let's go back to the diagram from the standardization spec. This, actually, I looked at this diagram and it's really unhelpful, but I think there was another one.
00:35:20.440 - 00:35:55.052, Speaker A: Let me see if I can dig that. No, there's just a bunch of pseudocode. All right, that's fine. So if you go back to the Facebook hazard pointer implementation, actually I think I have that in my editor. It's going to be a little bit nicer to read. So it has a pretty good description of what hazard pointers are, why they're useful for. I think when not to use is not as helpful as it could be.
00:35:55.052 - 00:37:07.784, Speaker A: Like, I think there are other cases where you don't want to use it. It goes through the basic interface and here you'll see that they've made some design decisions for how this library should be structured, that maybe we want to do the same, maybe we want to do something a little bit different. We might see if we can encode a little bit more in the type system than they were able to in circum, um, we'll, we'll find out about that. Um, but they say in the haspter library raw hazard pointers are not exposed to users. Instead, each instance of the class hazard pointer holder owns and manages at most one hazard pointer. Uh, so I guess hazard pointer hold holder here is sort of like a guard that lets you read anything that supports hazard pointers, there's like some, there's the, rather than having users like write into the hazard pointers themselves, classes of objects protected by hazard pointers are derived from a class template hazard pointer object base that provides a member function retire. So what this is saying is you can only use hazard pointers to read from things that support hazard pointers.
00:37:07.784 - 00:38:23.698, Speaker A: This is a little bit of a weird restriction that they've added, which is they want to say that you can only use hazard pointers on data structures that have chosen to be guarded by hazard pointers. We'll see how this gets into the actual API design and whether we want to do the same thing. But this retire function is kind of interesting. So the idea here is that, remember in the linked list example we've had where the writer wants to swap X for ydev after it's removed X and then it's trying to figure out whether it can drop x, right? It's removed it from the data structure, but it wants to know whether it can actually call like deallocate x. The retire function is sort of the in between, which is I have now removed x. Now I'm going to retire x and at some point in the future I'm going to like drop every, every retired object that is safe to reclaim. And we'll see this terminology a bunch throughout this code as well, that you have things that are retired, which just means that they're no longer accessible, but may still be under guard, if you will.
00:38:23.698 - 00:39:00.872, Speaker A: There might still be hazard pointers pointing to them. And then we have this notion of reclaiming, which is you take things that are retired and then you check all the hazard pointers and you verify that no one is using it anymore. And at that point you can reclaim that retired object. And indeed that's what it says here too. When an object a is removed, retire is called to pass responsibility for reclaiming a to the haspter library. A will be reclaimed only after it is not protected by hazard pointers. And then we get a brief sort of overview of their API.
00:39:00.872 - 00:39:41.768, Speaker A: The essential components of the has pointer API are the holder, which is this thing that manages a hazard pointer for you. Right. There's get protected, which is a spelling error, someone to do a pr to folly, which is a member function of the has pointer holder that protects an object pointed to by an atomic source. Right? So the, the function signature here is useful, which is imagine you have a has pointer. You have a, what do they call them? The haspointer holder. Right? You have a guard or a, I guess holder is the word they're using. It has a method on it.
00:39:41.768 - 00:40:13.370, Speaker A: Get protected. That takes like a reference to self, right, to the holder itself, a reference to my hazard pointer. And it takes a reference to an atomic pointer. So note that, note that this is not a pointer to the final object. This is a pointer to the atomic pointer that we need to read. And the reason why we need to give that into the library is because the library needs to do this double read. So it needs to know which atomic pointer we're reading from.
00:40:13.370 - 00:41:03.584, Speaker A: So that's why this takes a pointer to an atomic rather than the thing that's being pointed to. And it gives you back a, a reference to the t that's, that's behind that pointer. But it will, it will. That pointer will only be valid for as long as this hazard pointer exists or the hazard pointer holder. And this is sort of important, right? The idea here is that if we wanted to write this in sort of rust terms, right, we're going to have a impulse, I guess has pointer holder. We might, we might choose better names for this, but it's gonna be something like get protected. Actually, I guess it doesn't even need to be this.
00:41:03.584 - 00:42:04.454, Speaker A: It can be this. And it's gonna take a mute self and a reference to an atomic pointer to a t, and it's going to return a immutable reference to t. And I think the lifetime annotations here are important, right? So we're going to say this, not this and this. These are the lifetimes involved, right? So the idea is you have to, the reference you get back, you're allowed to continue using for as long as you still have the mutable reference to the holder. If the atomic pointer goes away, that's not actually a problem. We don't need to borrow that for the reference because we've already read the thing that the atomic pointer pointed to. So the lifetime of it is not important.
00:42:04.454 - 00:43:07.434, Speaker A: But it is important that the, that the holder still remains because otherwise the hazard pointer itself would go out of scope and the thing would no longer be protected. It's also important that this is a mutable borrow of self. Even though we get back an immutable borrow of the t. This mutable borrow of self is necessary because otherwise you could call get protected a and then get protected b, which like is going to the get protected b is going to overwrite the hazard pointer that's stored in the hazard pointer holder to point to the the b, like it's going to guard the b, at which point the guard of a is no longer active anymore. So we really need to say that this has to be an exclusive reference. And I think that the rust type signature here really helps over the, the c one because here there's nothing that really enforces that the, that you don't use this pointer that's returned after the has pointer holder goes away. It just sort of an informal contract of get protected.
00:43:07.434 - 00:43:48.000, Speaker A: And my guess is if we look at the definition of get protected probably says get protected. Oh, maybe it's not holder. Well, that doesn't really have any. Well, so they have a usage example, right, which is you call get protected pointer is protected, and then you call h reset. And now the pointer is not protected. But in clan, there's nothing that prevents you from using the pointer here, even though it's not protected anymore. Similarly, if you called get protected a second time would be the same kind of problem.
00:43:48.000 - 00:44:20.220, Speaker A: Nice. Yeah. And here we can sort of see how this is going to be used as well. And you'll notice that one thing that's nice about this method signature is that there are no guard objects. So in the, in like the epic based reclamation scheme, you sort of have to like pass in a guard here. And then the thing you get back is tied to the lifetime of the guard, which like, I guess is sort of what the holder is. We'll see whether this actually ends up being a nicer API than epic based.
00:44:20.220 - 00:44:56.754, Speaker A: We'll see, we'll see. With c, every pointer is a hazard pointer. Yeah, that's sort of true. All right. And then this hazard pointer object base, which is this base class for protected objects. So this one I thought was kind of interesting. This is, this is the t that is pointed to has to implement sort of this trait, if you will, and sort of see nomenclature.
00:44:56.754 - 00:46:01.362, Speaker A: It's a base class. But the idea is that anything that you want to be able to get at needs to implement this. And the primary reason why you have this is so that you can expose the retire function. The way we might do this is it's unclear whether we even need retire here. I think the idea is that, okay, so in order to call retire, you need to have access to the hazard pointer linked list, right. So something has to store that pointer to the head of the linked list. And what is going to store that? And I think the answer is, I think the answer, I think this is why they have the base classes, so that they can store an additional field that sort of wraps the t that contains that linked list.
00:46:01.362 - 00:47:29.540, Speaker A: So this would be something like, well, you can't have associated state with traits, which is a little unfortunate in this case, but we would have something like has pointer, I guess target t, which is really just a real t, and a has pointer, which is like a linked list of has pointer holders. Right. Or something like it. And then we're going to sort of implement all the draft stuff for hasptarget. So that's all fine. And then we're going to implement, I guess it's a little bit of a weird, I kind of feel like we don't want to do it this way, which is, I assume is why they structured it the other way, which is have a pub function retire on, which actually consumes self. And it is going to use self has pointers and do the whole like retiring and reclamation business on there.
00:47:29.540 - 00:49:28.480, Speaker A: But if you think about it like this is a little bit of a weird API maybe, because if you're implementing a data structure, it means that now you need to make all your atomic pointers, like anything that used to be an atomic pointer t or like my type right, in your data structure now is to become an atomic pointer has pointer target my type, which is a little weird. It's sort of unfortunate that you have to make that change. And so what they, what they did in the C library with this has pointer object base is that instead of doing this business, you can sort of imagine we have a trait has pointer target that has a retire function that takes self, but it also has like a, has pointers, right? Like it sort of declares that there needs to be, there needs to be a field in whoever implements the trait that we can then use from inside retire. Because retire will be like provided method, right. This isn't something you can write in rust today, like sort of an extension trait, if you will, that also adds fields. So I think we're gonna have to go with the, the wrapper type approach, which is a little sad because it requires these, these changes to the, ooh, well, we can sort of do it, right? So one way you could do this is require that it provides one of these, right. This is sort of the equivalent.
00:49:28.480 - 00:51:27.880, Speaker A: And then we could have like a macro on a macro that people can use on their type that automatically implements this trait for them by adding the necessary fields to the type. Why not do it in drop? That's a good question. So, so we could, using this wrapper type, we couldn't do that with the extension trait, but with the wrapper type, maybe we could do like implement drop for has pointer target t wherever I, this is self dot retire. The reason why I think you might want retire to be explicit is that if someone loads an atomic pointer and then gets a hazard point target, it's not clear that they want to retire it. Like retire is a very explicit operation. I guess the moment they get an owned one, that sort of implies that they want to drop it. But, but like, okay, so remember, if you do an ATA, if you do a, let's say we have an x of this type, right? If you do x dot load, or maybe more clearly, if you do x dot swap with y old, this is maybe the right way to write it.
00:51:27.880 - 00:52:53.810, Speaker A: So like at this point, let's say you want to deallocate or you want to retire old, then old here really sort of has the type of a. Oops, it has this type, right? And so the question is, how are you going to retire it? Because if, if you need to drop it, that means that you have to like dereference that you have to do like this, which is real sketchy in Rustland, like dereferencing a raw pointer in this way. You can do it, but it's, you can do like standard pointer read, but it's like wildly unsafe. I sort of feel better about something like hazard pointer, target, retire old. That feels nicer to me. In fact, this maybe even takes a self that is actually a mute self, like a raw pointer, to indicate that you're expected to do this with the sort of output of the raw pointer, rather than having to dereference it. Do you think traits that require members on implementers is a good idea? I think it could be really helpful.
00:52:53.810 - 00:53:33.410, Speaker A: It's sort of similar to just saying you need to provide accessors like a setter and a getter, but without having to do a setter and a getter. So I do like it as a, like it fits really well in certain very specific scenarios. I don't think it's necessary. Like you can get away with using accessors instead, but, but fields feel like a nice way to do it. Yeah, we're gonna have to think a little bit through what the right abstraction here is. This is the path they chose for c. And you know, I don't hate it.
00:53:33.410 - 00:54:27.200, Speaker A: Right? Like the equivalent here would be this takes this. Right? I don't hate that this wrapper type, it does maybe let us do something around drop, but it feels nicer for this to just be a thing that you can do directly on the target and it avoids this extra intermediate type. All right, well, we'll see when we get to it. Yeah, and you'll notice retire automatically reclaims the object when safe. Right. So the idea here is that it's going to walk the hazard pointers, if none of them contain the address of the current thing, that we can just dealocate it straight away. Otherwise we need to like stick it somewhere for later consideration.
00:54:27.200 - 00:55:27.790, Speaker A: And the question is also like what is this later consideration? Like how do we decide when to collect later? And the. In fact, if I switch back to the paper, where is. Yeah, it says if a removed map is not matched by any of the hazard pointers, then it's safe for this map to be deallocated. Otherwise the writer thread keeps the node until its next scan of the hazard pointers. I see. So the idea here is that every time you deallocate or, sorry, every time someone tells you to retire something, you compare all of the things in your reclama, in your list of retired things with the set of hazard pointers. So if we go back to the drawing here for a second.
00:55:27.790 - 00:56:09.256, Speaker A: Let's see. So we do this. I really need this to be a little smaller, and I need it to not be this funky marker, maybe. How's that? Okay, that's better, maybe. So let's say that I'm a writer and I call, like, whoa, that's bad, too. Pen. Pen.
00:56:09.256 - 00:57:11.414, Speaker A: Sounds nice and simple. So I call retire of X. And then I go look at all the hazard pointers, and I find some hazard pointers that has the pointer to X. So I'm not allowed to reclaim X. So what I'm going to do is just keep, like, on the side a, like, retired list that initially is empty. But when I notice that I can't reclaim here, then what I do is I stick X onto this list and then I just move on. And then at some point later, when I call, say, retire Y for some other value that I care about, then when I go check the lists, let's say this is now ampersand Y, then I don't consider, like, here I considered X for reclamation, but here I'm actually going to consider X and Y, right? So I'm going to consider Y because it was the thing that was retired.
00:57:11.414 - 00:57:42.356, Speaker A: But I'm also going to consider X because it was the thing that is sort of left over in my retire list. And so even though this one I can't retire, so y has to go onto the list. X can be retired because this one is not equal to x. Right. Like, X is not equal to Y. And therefore, here we can reclaim X, and then we stick Y onto the list for later consideration. That's sort of the basic scheme here.
00:57:42.356 - 00:59:01.558, Speaker A: And then you can imagine that you have also a method that's like cleanup, which is okay, I really, even though I don't have a thing to remove right now, like, I don't want to retire wire or anything, just like, go through and make sure that everything that was retired, like, go block on everything that's in my retired list. Go clean that up. So that's the, that's the sort of reclamation idea for. What do you do if you can't reclaim right now? All right, let's keep walking through the Facebook documentation here. So this default domain and default deleters, I guess my guess here is that a domain is the thing that holds the hazard pointer list, right. So the idea is that you can have multiple domains if you want say two different instances of a map to have separate hazard pointer lists and then you also have a default one which is like globally shared across all data structures. It's interesting though, here they say most users do not need to specify custom domains or custom deleters and by default use the default domain and the default deleters.
00:59:01.558 - 00:59:54.634, Speaker A: We sort of suggest that generally, like even though you might have multiple different data structures and instances of them, you just use one hazard pointer linked list across all of them. It's an interesting recommendation. I'm guessing it's based on evidence, but this certainly seems like something we would want to provide too. That like there's a default sort of global static hazard pointer linked list and then you can also supply your own if you really want to. Although that does raise the concern of you need to make sure that you use a hazard pointer holder that's tied to the correct hazard pointer linked list. And when you delete you have to use the right hazard pointer linked list to check, like you have to use the same one that all your readers are using. So allowing that to be swappable does come with its own, its own concerns.
00:59:54.634 - 01:01:02.330, Speaker A: And I'm guessing we're going to see that in the like contracts for different methods too. That like the, it was like a contract probably on something like retire, that the domain of, the domain of the hazard object is the same as the domain used by all the readers. Might not be documented right here. But actually while on the topic of documentation, the official sort of standard proposal here is pretty good about this. So if we scroll back, I did, unlike what I usually do, I did actually read a bit of the documentation this time before I started. So if we look at where is retiree class template hazard pointer domain retire, right. So this is the sort of spec definition for retire.
01:01:02.330 - 01:01:42.050, Speaker A: You see it takes a deleter, this d thing, we don't know what that is yet. And a hazard pointer domain, and it says the requirements are, it mandates that t is a hazard protectable type. That's fine. This is a base class sub object of an object x of type t. X is not retired. That's fine, that's fine, that's fine. Invoking the retire function may reclaim possibly reclaimable objects retired to domain.
01:01:42.050 - 01:02:31.528, Speaker A: Yeah, so it will. Interesting. So it doesn't actually say anything about the requirements on the domain here, like the domain matching, matching what the readers use, which is a little interesting. I wonder why that is. Because if you think about it, it makes no sense to try to retire an object. And then if you give like the wrong domain, then you might just like reclaim it. Even though there are readers to still have it.
01:02:31.528 - 01:02:57.284, Speaker A: They just used a different linked list. Like that seems like a big problem. I wonder if there's a way we can enforce that using just the types. Interesting. All right, back to the code simple usage example. Okay, so you have a class config, and I'm guessing config here is the thing that you want to guard with hazard pointers. It extends the object base.
01:02:57.284 - 01:03:58.916, Speaker A: So this would be the equivalent for us of it implements the, the hazard pointer like target trait. Yeah. So one thing that's a little unfortunate with us saying that for this has pointer target, right. Saying that we need you to provide this method is that the implementer has to like add this field manually and add this method manually. If this instead was, if Rust had support for like declaring a field on the trait, right, then the, the implementer wouldn't need to do anything, they would just implement the trait with an empty like square bracket and it would just do the right thing, whereas here it can't be empty. They actually need to like fill in this. They have to add a field of this type to their struct.
01:03:58.916 - 01:04:51.060, Speaker A: This is why I'm proposing that maybe we want like a procedural macro or just a macro that can wrap the user's type and add those fields and add this implementation for them. That might be nice. Yeah. So in our case this would be like a struct config and an impl of haspointer target for config. And then this is just an implementation on config itself. I guess this is keys and values inside the. Yeah, so this is, yeah, so the implementation of get config here is, it creates a hazard pointer holder.
01:04:51.060 - 01:05:21.512, Speaker A: It calls get protected of config. So config here is an atomic pointer, right. So it passes in a reference to the atomic pointer to get protected just the way we saw earlier. And that's going to be guarded by that holder. So the holder here is the hazard pointer, and that gives you back a pointer to the actual config, the thing that's behind the atomic pointer that is safe to access because it's stored in the hazard pointer. And then this returns. I see.
01:05:21.512 - 01:06:32.040, Speaker A: So this is going to call get config on the thing that's pointed to with the appropriate, with the appropriate argument. And then the moment this returns pointer, the destructor of the holder is going to make the hazard pointer sort of blank, so that no longer protects anything, so that the writer can now swap it out. So the moment that we return from here, pointer is no longer guarded, which means that the writer can swap out the config. One interesting point here is this is not quite safe the way the C code is written because imagine that like this is instead of just vv. Let's say that this is like k key and this is v for value. But imagine that v here is actually like a pointer, like a string pointer or something to into the config. Well when you call get config with, with the key, what you're going to get back from this is a pointer into the config.
01:06:32.040 - 01:07:25.330, Speaker A: But the moment we return the holder is dropped, so the hazard pointer is zeroed out so the config can be deallocated so the return pointer is invalid. There's nothing that guards you against that in the C interface is currently specified here. If this is a copy type, like if this is like U 32 or whatever, then it's not a problem because you copy out you no longer have references to it. But in this kind of situation the C code was actually not be safe. You would need to keep holding the hazard pointer holder for as long as the user wants to use this v. Or you would have to like clone it out into an own string or something in rust. I think this would be caught by the compiler because the value returned here will be tied to the lifetime of the hazard pointer holder.
01:07:25.330 - 01:08:42.075, Speaker A: So if this was a reference into the configured, the compiler would tell you that this lifetime needs to out. No, this lifetime needs to outlive this lifetime and it doesn't because you're trying to return it when this has been dropped and therefore the code wouldn't compile. This is a nice case where like the rest type system and the borrow check will actually catch this concurrency problem as long as we get the lifetimes right for the hazard pointer holder. So this is the example of a read, and for write it takes in a new config, it does an exchange which is like a swap, right? Gets back the old pointer and then it calls retire on that. And this is similarly fuss, right? Like this is a star mute and config and calling retire on it is going to stick that. It's going to first try to eagerly reclaim anything that's in the retired list, right? And if it can, it'll reclaim them. And if it couldn't claim, if it couldn't reclaim this particular config, it'll stick it in the retire list.
01:08:42.075 - 01:09:41.192, Speaker A: So on the next retire that, that config will hopefully be reclaimed. So, so far this, this matches the sort of mental model that we drew out earlier of how this works. Optimized holders. The template haspter array provides most of the functionality of m hazard pointer holders, but with faster construction and deconstruction at the cost of restrictions. Interesting. So this is if you want to guard multiple axes. Like imagine that you want to read two pointers out of a data structure and you need to actually access both of them.
01:09:41.192 - 01:10:34.740, Speaker A: Like imagine a doubly linked list where you need to read like the head and the tail or something, right? If you only had one hazard pointer holder, then you would read the head, but you couldn't read the tail because that requires immutable access to the hazard pointer holder, which is already tied to the head. And so you would have two hazard pointer holders. Use one to load the head and one to hold the tail. And this generalizes the m, right? If there are m pointers you want to read, you would need m hazard pointer holders and so has a pointer array. Then it says is a more efficient way to have multiple hazard pointer holders for this kind of use case with certain restrictions, which I'm guessing we'll see when we actually do the implementation. I think what we'll probably do is ignore this for now. This seems like a, a good future optimization, but not something we need for the core implementation.
01:10:34.740 - 01:11:42.280, Speaker A: The template hazard point local provides greater speed even when m equals one, but is unsafe for the current thread to construct any holder type objects while the current instance exists. Oh, this is interesting. So this is like, rather than grabbing a hazard pointer holder from the linked list, we're gonna actually, I wonder how they implemented this. It's probably like a thread local hazard pointer holder, so you don't have to allocate one each time. Or maybe it's a, actually, maybe it's a hazard pointer holder that is not allocated on the heap, it's instead allocated on the stack. And you just like put its pointer on the list or something. It's like some, I don't know what they implemented.
01:11:42.280 - 01:13:05.490, Speaker A: This also seems like an optimization that we'll want to look at later, right? So they're saying like this can be more efficient than just using a standard hazard pointer holder. And my guess is because when you call get protected here, what that's going to do is like hazard pointer holder is sort of an empty hazard pointer holder, right? It's not associated with an actual hazard pointer yet, because for that it needs to go talk to the linked list and fetch out a hazard pointer or allocate one if there are no free ones. So like, it's the, the structure here is actually a little bit weird. Let me, let me try to draw this out. This might be helpful where we have. Yeah, so there is, what color should we use? Let's go with like bright orange. So there is a holder, I guess there's a hazard pointer holder over here, and then there's a hazard pointer over here.
01:13:05.490 - 01:15:06.540, Speaker A: And then there's sort of a, I guess, a hazardous object over here. And I guess technically there's also like an atomic in the middle here, right? So we really have all of these different components and it's important to understand that they're different. So the atomic points to a hazard object. A hazard pointers points either to either to nothing or it points to a hazard object. A hazard holder points either to nothing when you first create it, or it points to a hazard pointer. I think that's the structure here. And a, I guess to switch colors here, a writer is going to look at all of these and it's going to also access this, right? So it's going to swap this and it's going to check these, and a reader is going to allocate one of these, which is gonna have, like, initially when you create a hazard pointer holder in a reader, it doesn't point to any actual hazard pointers.
01:15:06.540 - 01:15:44.220, Speaker A: You might, it might then point to a hazard pointer the moment you try to access something. So it's also gonna, I guess, access all the transitive arrows here. Right. But it might actually hold, hold, I guess, one plus hazard pointers. So imagine that you're a reader, you create a hazard pointer holder, then you do a read. Hmm. Like over the course of a given hazard pointer holder, you could do multiple different reads.
01:15:44.220 - 01:16:14.066, Speaker A: I guess you probably wouldn't give away your hazard pointer. You might stick with the same hazard pointer over time, but the idea is that you don't. When you create a hazard pointer holder, it doesn't immediately give you a hazard pointer. Although maybe it could, maybe it eagerly should. Not quite sure. We'll have to look at whether this distinction is actually necessary or whether the reader can just grab a hazard pointer straight away. Interesting.
01:16:14.066 - 01:16:56.560, Speaker A: We'll have to think about this. But the idea is that the reader can actually reuse a hazard pointer holder and a hazard pointer pointer too, over time, over the course of multiple reads. But the writer will only ever check the list of hazard pointers. It doesn't actually know anything about the holders. Great. So let's go back here. Memory usage, the size of the metadata for the house pointed library is linear in the number of threads using hazard pointers, assuming a constant number of hazard pointers per thread, which is typical.
01:16:56.560 - 01:18:07.620, Speaker A: Right? So this is saying we might not deallocate objects straight away, but we're not going to allocate more than, or I see. So this is actually for the hazard pointers themselves. So for the metadata of the library, we're going to have this like linked list of hazard pointers, right? And we're never going to deallocate from that list. It's just going to grow until at some point you can always reuse one that's in there no longer being used. And the observation here is that the number of things in that linked list of hazard pointers is going to be like proportional to the number of threads. Assuming that every thread uses only a constant number of hazard pointers over time, which seems fairly reasonable. Like I sort of buy that this is typical, but if you did have a use case where a thread would just like use, what's an example of this? Like, imagine that it has to create, it has to walk like a super deep tree and it has to create a, it has to keep one hazard pointer for every level.
01:18:07.620 - 01:18:54.990, Speaker A: Then like now, every thread needs to have like log n of the size of the data hazard pointers. So now the, the size of the metadata is going to grow as number of threads times log n, where n is the size of your data, which might be much larger. But that is probably not typical. Like in general, a given thread can probably get away with just using like a constant number of hazard pointers for any given algorithm goal operation. This isn't quite test num threads because we don't need to know the number of threads in advance. In some sense this is a nicer design. Right? Where we're going to have this linked list where if there are no things that are free, then I'll get a new one.
01:18:54.990 - 01:20:12.882, Speaker A: If there is a free one, then reuse it. And what that means is over time, what you would expect to happen is that the linked list will grow to the sort of number of hazard pointers that exist concurrently in the program at any given point in time, which is probably linear in the number of threads. So we don't need to know how many threads there are, but the linked list is probably going to be end up being that length or something fairly close to it. But not having to know it in advance is a big benefit. The typical number of reclaimable, so retired but not yet reclaimed objects of should not be there, but not yet reclaimed objects is linear in the number of hazard pointers, which typically is linear in the number of threads using hazard pointers, right? So the observation here is that when you retire something, it might not be reclaimed immediately. But imagine that, okay, so let's say there are n hazard pointers. They can guard at most n different pointers, but by definition, each hazard pointer can only guard one address, and n objects will have n different addresses.
01:20:12.882 - 01:21:27.636, Speaker A: So n hazard pointers are needed. So this means that if you have more retired objects than there are hazard pointers, some of them must be reclaimable, right? So the number of reclaimable, so retired but not yet reclaimed objects is linear in the number of hazard pointers, which again is typically linear as per the point above. Typically linear the number of threads. So the idea is that the amount of stuff that hasn't been deallocated yet is going to be linear in the number of threads, which is often better than what you get with something like epic based reclamation, where the amount of stuff that hasn't been reclaimed yet might be much larger because it's any, any thread that doesn't move on to the next epoch prevents reclamation of everything in the past epoch. Protecting linked structures and automatic retirement hazard pointers provide link counting API to protect linked structures. It is capable of automatic retirement of objects even when the removal of objects is uncertain. It also supports optimizations when links are known to be immutable.
01:21:27.636 - 01:22:15.050, Speaker A: All the link counting features incur no extra overhead for readers, so this seems like an extra feature they've added for supporting something like a linked list. Or I guess the idea here is like imagine that you have a linked list implementation and you like remove ten objects at once. Then you want them all to be allocated at the same time. So maybe you can like have some magic in the hazard point implementation that knows how to chase the pointers and deallocate to them or retire them. But this also seems like an extra feature that we'll look at subsequently. This is nice. So they provide an alternative safe reclamation methods, like things you might want to use instead of hazard pointers.
01:22:15.050 - 01:23:10.830, Speaker A: Locking is the obvious one, right? Like if you don't have concurrent access because you use a lock which provides exclusive access, then this is all just trivial, right? Like if you want to delete something from the hash map, you take the lock, you remove it from the map, and you drop it immediately because you have exclusive access, and then you release the lock. So great. But of course the problem is you now lose out of the concurrency because it's exclusive reference counting, as we mentioned. It's like nice. It's, it provides automatic reclamation. You don't need to do very much special, but the downside is high reader and writer overhead and contention, because everything is operating on this, like shared, this shared counter and RCU, which. So RCU is a little weird because so RCU is read copy update.
01:23:10.830 - 01:24:26.440, Speaker A: The idea is that if you want to update a thing, you, you like, prevent other threads from running, then you read the value, copy it, update it, and map it back in place. I forget the exact implementation of user space RCU, actually, but I think the problem is that you have to, there's like a section of execution where it's not okay for the thread to be interrupted. So you need to like put some safeguards in place. And that means that you can't, like, if you, what's the best example of this in RCU? I don't think you can read a value, like read out a pointer and then like issue a blocking system call and then continue to use that pointer. Like, that doesn't work in RCU because you end up with deadlocks. I'm sort of, I'm watching the explanation of RCU, but it's because use based RCU is actually kind of complicated. Simple seems incorrect to me here, but regardless, like, read copy update has its uses, but I don't think it's a particularly important comparison right here.
01:24:26.440 - 01:24:48.022, Speaker A: Right. This is a comparison that's similar to epic based reclamation. That RCU, or epic based reclamation also protects everything rather than a specific object. That's fine. I'm just going to skip over this. Oh, this is kind of interesting differences from the standard proposal. Right.
01:24:48.022 - 01:25:31.500, Speaker A: So this link here is a link to the c standardization proposal that I've been looking at as well. And I see the substances of the proposal was frozen around October 2017, but there were subsequent API changes based on committee feedback. Oh, interesting. So I'm guessing the implementation here is more up to date than the spec. I think in general it's useful to have both, because the spec is probably a little simpler to follow and a little better sort of enumerated exactly what the conditions are in the implementations are, because as a spec it has to, but the implementation is clearly one that's being used. So. So that gives us some confidence.
01:25:31.500 - 01:26:06.620, Speaker A: Main differences are extra atomic template parameter for testing and debugging. Okay, that seems like something we can ignore. This library does not support a custom polymorphic allocator. That seems fine. We can just ignore that. I mean, this is relevant in rust two right, with maybe you want the user to be able to provide their own allocator for use with the hazard pointer holders, but I think we can ignore that for at least for the initial implementation. Constructions of m, the construction of empty and non empty hazard pointer holders are reversed.
01:26:06.620 - 01:26:50.362, Speaker A: Interesting. I don't know what they mean here. I mean, so empty and non empty hazard pointer holders. This is if you construct a hazard pointer holder initially, it doesn't point to an actual hazard pointer. And I'm guessing maybe in the standard, like the expectation is that you always construct a hazard pointer holder for a particular hazard pointer when you make it, because it's rare that you want a hazard pointer holder but not a hazard pointer. We'll look at this when we are at the actual implementation. Hazard pointer holder member functions get protected and reset are called protect and reset protected in the latest proposal.
01:26:50.362 - 01:27:07.076, Speaker A: That's fine. We can choose our own names here. Array and local are not part of the standardized proposal. Right. So this sort of supports the idea that these seems to be extensions that we can do later on. Link counting, support and protection of linked structures is not part of the standard proposal. Great.
01:27:07.076 - 01:27:51.046, Speaker A: So this is also an additional feature. The standard proposal does not include cohorts and associated synchronous reclamation capabilities. This. So I skimmed a little bit of the Facebook code, and I think the idea here is that you can say like, these objects are related and should be allocated and deallocated or retired and reclaimed together as a unit, which can sort of help with, if you have a large batch of things you want to reclaim, it sort of amortizes the overhead of retiring and reclaiming them. I don't think we're going to implement the cohort part, at least initially, but it seems like something that's also a cool extension, we could, we could eventually do. Nice. Okay.
01:27:51.046 - 01:28:47.536, Speaker A: I think we're now at a point where we can start doing the actual rust implementation, and now we, I think we now have a decent idea of the structure we're going to build. I think what we'll do is actually one question is whether we want to follow the Facebook code here, or whether we just want to write our own, at least high level structure and then just look at their implementation. I think maybe that's the way I want to go. I want to write the rust interface first, and then the implementation is probably going to be very similar to what the Facebook one is, because clearly it's actually correct. Yeah. All right. Now that we're all the way through the documentation about to sort of actually start the rust code.
01:28:47.536 - 01:30:16.940, Speaker A: Let's do sort of questions on this structure, the hazard pointer library, the sort of data structure and algorithms involved before we dive deep into the code. And also while people are thinking of names like what should we call this library? So I want to know what are synonyms of hazard obstacle? Is that too lame? What does it do? This library? It ensures that, it assures that concurrent accesses are safe. It guards the accesses. Char hazard. It could just be Zard. I mean, okay, so one option here is to go with something really stupid. Peril is pretty good.
01:30:16.940 - 01:30:44.550, Speaker A: Peril is pretty good. Although for some reason I feel like there is a project called perilous. Yep. And in fact this is a hazard pointer implementation. I'm just saying. Yep. Fast and safe has reported implication for rust.
01:30:44.550 - 01:31:30.290, Speaker A: Interesting. This seems like a different, a slightly different approach. Nice. Yeah, this would be a good thing to benchmark against, actually. Danger, rust warning. Warning is also kind of funny. The other thing I was thinking was we could go really silly and go like, or really not silly, very straightforward, and be like safe atomic pointer.
01:31:30.290 - 01:32:07.660, Speaker A: Because in some sense that's what we're providing here. The goal should be that using this we can provide something that looks like atomic pointer, but it operates like on references instead. Haphazard is also very funny. I mean, it's not really haphazard. Okay. Haphazard is too funny to skip. Haphazard.
01:32:07.660 - 01:32:43.946, Speaker A: Nice. I can't, I can't not go with haphazard. That's, that's, that's too great. Danger rs also pretty good. Can't drop this. That's funny. Okay, so I think the, the API that we have in mind, right, is let's use the, the names from the spec first and then translate them once we have the structure in place.
01:32:43.946 - 01:34:00.392, Speaker A: So we have, has pointer holder. We have a hazard pointer, we have a, I guess, I guess we have like standard sync, atomic, atomic pointer is going to be relevant here, but I think we might want to provide a wrapper type around it. And we have a hazard pointer like object. And we're going to have a private hazard pointer, I guess they call it domain, right. Which holds the link list of hazard pointers. And it's going to have to implement default. Yeah.
01:34:00.392 - 01:35:39.950, Speaker A: And then this will probably be something like, actually, I think what we'll want is actually a, like a pub struct. This is also going to be pub, a pub struct shared hazard pointer domain, where anything that uses this as the hazard pointer domain is going to like share it across the entire execution of the program. And what else do we need? So we're going to need a sort of linked list for things that have been retired but not reclaimed. I, so it's like a reclaim list or I guess it's just retired really. Right. And in fact, here's what I think these should be called. So actually let me, let me try to write like what, what I would want this code to actually feel like when writing, which is something like, feels good.
01:35:39.950 - 01:37:28.030, Speaker A: So let's say that we have an atomic pointer, new box, new box into raw, I don't know, 42, it doesn't really matter. Okay. So I think what I would expect to be able to do is as a reader, okay, so the C code does this, right? So you create a hazard pointer holder default. Then you do let x, or my x is h dot, I guess, load of x, where this is now a reference to the I 32. And then if I drop h, then my x here should be invalid to invalid like this should not be okay. Right, because the, the holder has gone away. I think that's sort of the, that's roughly the, the C API.
01:37:28.030 - 01:38:27.140, Speaker A: I wonder if we can make this nicer somehow. Right? Like one option would be to have our own atomic pointer type that. Actually let's, let's write out the writer as well. As a writer, I want to be able to write old is x dot swap over 9000 and I guess sync atomic ordering, whatever. It's not terribly important. And here I want to be able to call old retire somehow. And all of this, I guess, is with the default domain.
01:38:27.140 - 01:39:29.530, Speaker A: So I think what we'll do is sort of not worry too much about exposing like genericism over domains in the first instance of the implementation. And then we can add that as sort of the, the second part. So let's then say that this is going to be private and there isn't going to be a shared and hazard pointer holder is going to use the sort of standard shared domain old dot retire. So this will only work. I see. So this is where we have the trait, right? So this is going to be a trait instead that's going to hold retiree where self is a star, mute of self. I guess it doesn't need a t, actually.
01:39:29.530 - 01:41:45.130, Speaker A: Fine. I thought this had already stabilized, but I guess not. And we're gonna also need a, I guess in our case actually, because we, if we're just using a shared domain, then this should be able to use like shared domain dot whatever, right? So we're gonna have a static shared domain. This is probably gonna end up being like a, maybe this has to be a lazy static, but let's just say for now it's gonna be one of these. That's fine. And then the expectation is that we sort of want to implement hazard pointer object for any type. Like is there really a restriction on what you can point to with this? Like why would we not just have impl haspt object for any t, right? And then this is going to be, I guess has pointerobject retire and haspter holder is going to implement default, that's fine.
01:41:45.130 - 01:43:07.094, Speaker A: And has pointer domain is going to have a list of hazard pointers, right? Which is, I guess let's just say for now that it's going to be a has pointer. Like in reality there's going to be a linked list of those. Actually let's just make a struct has pointers. So this is going to be one of those and this is going to be one of those. And then the h load on Hazard pointer holder has pointer holder. This is going to have a pub fn load of, which takes a mute self and a reference to a atomic pointer of t. And it's going to return a reference to Tachyde.
01:43:07.094 - 01:44:41.850, Speaker A: There's something here about this probably needs to be an option reference to t in case it's null or it needs to be unsafe, right? Like there's a, what's awkward about this, right, is that we don't actually know that what we get back from atomic pointer is a valid pointer. Like it, one thing is it could be null, but it could be like an unaligned pointer or something like that. Um, so in some sense I see. Unless we define our own atomic pointer type, like because this is just the atomic pointer type from the standard library. Nothing prevents a caller from like creating one and storing like the pointer one in there, which is just like not a valid pointer, but it's also not the null pointer. And then calling load from our poor library, which then goes ah, and tries to dereference whatever it loads, which is not a valid reference and you get undefined behavior, which sort of means that this has to be unsafe, which is unfortunate. If on the other hand we made this, if we provided our own atomic pointer type, we could just disallow setting raw pointers, although that would mean that we would only allow passing in like a box, like something that's owned in order to store.
01:44:41.850 - 01:45:29.380, Speaker A: Maybe that's worthwhile. I'm not entirely sure it would mean that you couldn't store like stack pointers and stuff. I think this actually does need to be unsafe, but it's like unsafe in a different way than just a normal lotus unsafe. And we'll have to document why that is. And this is just going to do, I guess. So has pointer holder is going to hold an option, in fact option star mu task pointer. So this is going to be if self dot zero is none.
01:45:29.380 - 01:46:55.090, Speaker A: Actually we can write this a little bit nicer, but I'll do that in a second. Then we need to use the shared domain dot acquire, I guess, right. So if we don't already have a hazard pointer for this holder that we need to get one from the domain. Otherwise we can just use the one we have. So this can be rewritten a little bit nicer as self dot zero dot, as mute dot. Actually, let's just say if let sum then house pointer. Otherwise has pointer is this and give back has pointer.
01:46:55.090 - 01:47:41.490, Speaker A: So we're going to get out the has pointer. Then we're going to do the first read, right. Remember we, we have to do multiple reads, right. So we're going to do, we're going to read the real pointer. Which memory ordering we use here is probably going to be dictated by whatever the, whatever the Facebook library does because presumably they've already thought hard about this. In this case, I'm just going to go, it's sequentially consistent for now because we're just sort of writing out the code anyway. So we're going to load the pointer one, then we're going to, I guess, sethe the pointer.
01:47:41.490 - 01:48:29.410, Speaker A: Or I guess we could, we could call this like protect, I guess, pointer one. Then we're going to load pointer two. Like we're going to load the pointer again. And if pointer one is not equal to pointer two, then we have to try again, which really means we probably want to do something like a loop here. So we're going to load it once, we're going to try to protect that. We're going to load it again. And if the two are equal then all good protected.
01:48:29.410 - 01:49:31.890, Speaker A: Otherwise what we're going to end up doing is set pointer one equals pointer two and then go around the loop. This just saves us an extra load. And this is going to break with pointer one dot. Ooh. Pointer nonnull from new of pointer one map. So I use non new here because it's a way to check that the pointer is not null and get an option. It doesn't, doesn't have to be this way.
01:49:31.890 - 01:51:12.210, Speaker A: And now we can say this is going to be, this is now it's fine. To dereference this pointer and this bit here. Right. Safety this is safe because one target of pointer one will not be deallocated while since our hazard pointer is active, deallocated for the lifetime for the returned lifetime. Since our hazard pointer is active and pointing at pointer one and two pointer address is valid by the safety contract of load. Right. So there's going to be, here we're going to have to say something like safety caller must guarantee, guarantee that the address in atomic pointer is valid, aligned is valid.
01:51:12.210 - 01:53:00.530, Speaker A: Yeah. Column is guaranteed that the address in atomy pointer is a vat is valid as a reference or null. Caller must also guarantee that atomic pointer that the value behind the atomic pointer will only be deallocated through calls to and I guess this is, what did we call it? Hazard pointer object retire. Hazard pointer object retire. So as long as this, as long as the caller fulfills this contract, then it's fine for us to dereference the pointer down here. Oh, dot as ref. Then it's fine to dereference the, the raw pointer as a reference down there because we know it's valid as a reference or null and the null is taken care of by the non null new which returns an option and it's fine for us to turn it into a reference with the lifetime wind up returning here, which is the lifetime of the mutable borrow itself because we know that hazard pointer object retiree will sort of respect all of the hazard pointers of which we are one.
01:53:00.530 - 01:53:48.542, Speaker A: Great. So now we need acquire and acquire on hazard pointer domain. It's going to take itself and return a hazard pointer, a star mute hazard pointer. In fact a not, I'm not going to make it a static, because it's not necessarily a static reference. Even though the hazard pointers never get deallocated. Remember, once we add them to the list, it might be that we give out immutable, that we give out a pointer to a hazard pointer to other threads in the future once it's returned to us. So giving it a static lifetime isn't quite right.
01:53:48.542 - 01:55:15.400, Speaker A: There is someone's safety there that needs to be upheld and this one we haven't implemented yet and has pointer protect. So here we're going to have hazard pointer. We're going to have a FN protect which takes I guess a star mute to hazard pointer. Now I think this is going to take a mute self and a pointer address. What should that even be? This is sort of like a, it doesn't really matter what it is like. A hazard pointer can guard any pointer, right. So this is really just gonna, a hazard pointer here is really just a pointer, like the thing that's being guarded, which might be, it might be null or it is a, well, there's going to be something like active here to, so that we can reuse them.
01:55:15.400 - 01:56:10.200, Speaker A: But I think for now we're just have that be pointer and all that has to do is self dot pointer equals pointer. That's all protect needs to do. Right? And this one, right. So in order to call protect, we need to, we need to get immutable reference to the hazard pointer, which in some sense is what we get back from shared domain acquire. Like whenever we get a hazard pointer out, it's ours until we give it back. But we don't have the appropriate lifetime to stick here because the lifetime is sort of, it's sort of an owned hazard pointer. That's really what it is, right? Like we own it until we return it.
01:56:10.200 - 01:57:09.670, Speaker A: But it can't be one of these because it's also owned by the, by the domain, by the, by the linked list because writers need to be able to look at it. So I guess, actually I lied a little bit here. Protect is going to take a shared reference to self, and this has to be an atomic pointer itself, actually, because it has to be storable by the thread that owns the hazard pointer and has to be readable by any writer. So this actually does need to be, has to be an atomic pointer. It does need to be a shared reference, though. We need to make sure that it's still valid. And this is why it's a little weird.
01:57:09.670 - 01:58:06.250, Speaker A: Like in some sense it's like tick static, but it's nothing. Well, tick static is not a shared tick static is not quite wrong, because it is true that we never deallocate them and every axis is a shared access. So maybe that is what we do. I think that is what we do. I think this returns a tick static has pointer, at which point this is fine. And this is just saying you're trying to protect the pointer of type t and this takes a pointer of type nothing. So we do this.
01:58:06.250 - 01:59:26.168, Speaker A: Nice. Yeah, I just saw the comment in chat that like, the API feels like it was designed to accommodate the algorithm rather than being ergonomic. And I agree with that. That's part of the reason why I wanted to write this code first, to sort of see what it feels like and see whether we can do something better. But I wanted to at least write it out the way it is designed to, then see if we can adapt it how many hazard pointers would you expect to use in the list? Is a vic unsuitable? A Vec is unsuitable because it needs concurrent access, right? Like multiple threads going to be concurrently accessing this hazard pointers list, including adding to it and so it can't be effect. Do I recall retire after reading? No, after you read you don't actually have to do anything except like at some point you have to say I don't care about this reference anymore. Which you can do just by dropping the holder or you can call like h resethez.
01:59:26.168 - 02:00:10.970, Speaker A: So at this point this should be invalid. And so I guess to sort of expand this a little bit, right? Like here it should be valid to dereference this. Here it should be invalid because you've reset the hazard pointer. Here I load it. So here it should be valid to read this again. Then I drop the holder and now it's invalid. So as you can imagine that like either of either of these patterns are ways that you would write as a reader and this is unsafe which is little unfortunate.
02:00:10.970 - 02:01:44.830, Speaker A: But the safety here is atomic pointer points to a box so as valid safety, one atomic pointer points to a box so is always valid. And two writers to atomic pointer use hazardous pointer object retire which are the two safety requirements expected. I 32 find option integer that's weird. I wonder why he complains about that load of t gives you a reference tache. And the type of this is atomic pointer I 32. So that's what it gets in there. So t is I 32 so this should give an I 32.
02:01:44.830 - 02:02:41.364, Speaker A: I guess I can do this. Oh, it's because of an option. That's why I lied a little. This is an option. So we're gonna here I guess expect not nullified and same thing here, expect. So retire is only called as a writer is it possible that swap can return retirable object? So the challenge with that, I mean it could but then we need our own atomic pointer type which it could very well be that that's what we want to provide because that way we could sort of have the wrapper return things from swap. But really like if this just worked that would be nice.
02:02:41.364 - 02:03:27.482, Speaker A: And that will work. Actually if we do, if we do rust up override set nightly and then we do feature arbitrary self types and then we do retire. So this is going to be self now we can just be old retire. So then we, then we don't actually need to wrap atomic pointer ourselves because we can just say there's a blanket implementation of retiree for any type. Now whether this is actually reasonable. I'm not quite sure. Like maybe we do want people to opt into this.
02:03:27.482 - 02:03:56.730, Speaker A: I'm not, I don't actually know. I, I think the reason why the C library doesn't do this is because it can't. Like I don't think it has a meaningful way to, to give this kind of blanket implementation. Actually, no, it's because it needs to add the field. We don't have the domain here. Once you need the domain you need to have a field, which means you haven't, need to have an impul. But I think with a blanket implementation you should be able to do this.
02:03:56.730 - 02:04:51.560, Speaker A: But, right, like imagine this had a link, has pointers or whatever, right. That takes itself and gives a, like this or I guess domain, right. Then here you need to write that implementation. And the question is like what do you write here? You don't have anything you can write here. If we had fields and traits, this wouldn't be a problem because, well, assuming that the way fields and traits worked was that you could basically inject the field in the type, then this would be fine. And practice is probably not what it's going to do. And so people will need to add this implementation themselves because they need to add the domain.
02:04:51.560 - 02:05:59.300, Speaker A: Like if you think about this, right, like how would you write this implementation? You can't really, and this is why you can't actually call retire on something that's just an I 32 because you don't have a reference to the domain which you need in order to call retire. So it does actually kind of make sense that this won't really work. So maybe we do need a wrapper type. It's a little awkward. This is why I was thinking like a procedural macro around your own custom type because we could have like a pub struct. Actually we could, we could do both. We could say has pointer object wrapper t, right, which is a real of a t or I guess inner and a domain which is a has pointer domain.
02:05:59.300 - 02:06:56.520, Speaker A: And then we can implement has pointer object for has pointer object wrapper for any t which returns self dot domain. Right. And then this would also like implement I guess draf. So use standard ops drf and drift mute for haspt wrapper. So this is self dot inner and then draft mute. Oh, this does not take a tache mute. Mute.
02:06:56.520 - 02:08:14.470, Speaker A: And so now callers can either choose to use our wrapper or, or they can use their own, their own thing. In fact we just make both of these fields be pub if we wanted to, but so then we would have like impl, I guess t from t four has pointer object wrapper from t self. This is a very standard, oh, actually that wouldn't work. It would be this new t and it would take a domain. But in our case we'd say with default domain because we don't provide anything else yet where inner is going to be a is going to be t we're given and this will eventually hold domain, but for now that's just going to be the standard domain. So this is just going to be shared domain for now. And then retire is going to do, is just going to be using self dot domain and call retire on that.
02:08:14.470 - 02:09:39.280, Speaker A: And retire probably has to be unsafe because you have to. The safety requirement on retire is that the caller must guarantee that self is no longer accessible to readers. It is okay for existing readers to it's okay for exist. Caller must guarantee that pointer is a valid reference. Obviously, columns guarantee the self is no longer accessible to readers. It's okay for existing readers to still refer to self. And at that point we can do this and retire.
02:09:39.280 - 02:11:22.280, Speaker A: So given these guarantees, then it's okay for us to take a, to turn this reference into a shared reference to ourselves, get the domain out of that using the accessor, and then retire and pass in the, the pointer that we're trying to retire. And so now for the hazard pointer domain, we're gonna have retire, which is going to be, I guess here a pointer, which can really be a pointer to anything. I guess this is probably going to be something like a didn't drop, because otherwise how would we retire anything? And who knows what that's going to do yet. Oh yeah, this can't be, this cannot be used as a trait object. The method might not be found because of this self type. This seems wrong. I'm pretty sure that trait that should not be required because everything implements drop, but I guess, I guess maybe not.
02:11:22.280 - 02:11:58.298, Speaker A: Why does this need to, that's really awkward. It has to implement drop. Why? All right, fine. We'll just make this, this for now. That's fine. I, no, it needs so, okay, the challenge here is in order to reclaim an object in rust, we need to call this destructor, which is in drop. But not every type implements drop.
02:11:58.298 - 02:12:59.582, Speaker A: So this sort of a, well, what do we like? It sort of should be didn't drop, but then the type needs to implement drop, which like, maybe that's fine, maybe we just required that there's an implementation of like impul t drop for pointer object wrapper t. This seems like a really stupid requirement because it doesn't, the drop doesn't do anything to do get rid of this requirement. But like we need to have a drop because otherwise you can't construct a v table for it. Why does this may not live long enough. That's fine. There are all sorts of bounds we're gonna have to add here. I don't really want to have to add all of them right now because we're still at a fairly high level of the code and that's probably not gonna work.
02:12:59.582 - 02:13:49.380, Speaker A: That's fine. Right. So now what you're going to do down here is this is actually going to be a, I guess has pointer object wrapper with default domain of 42. That's what we're going to store in there. So this is not going to be an I 32 really. This is going to be a reference to a has pointer object wrapper, but that's fine. So this is going to read out the I 32, but we have to double dereference now because it's a, it's a wrapper.
02:13:49.380 - 02:14:32.026, Speaker A: Although this might work, this is no longer necessary. We're going to say that this is in I 32 though. Same thing here. And this is going to swap in a has pointerobject wrapper with default domain of this. And this is now unsafe. And safety here is old value is no longer accessible. One, the pointer came from box so is valid.
02:14:32.026 - 02:15:40.880, Speaker A: And two, the old values don't look accessible. All right, I've been ignoring chat for a little bit, so I'm gonna, I'm gonna go to chat and see all the questions that you have about this stuff. It's gonna be couldn't you make an aligned atomic pointer t wrapper so we could have a wrapper around atomic pointer? The challenge is that we would end up re implementing basically all of the atomic pointer things anyway, including things like storing raw pointers. Because it's really annoying to work with atomic pointer if you can't use raw pointers there because you don't always have a box. Right? Like we could make, I guess like store unsafe. That would be one way to make this wrapper that when you store you have to assert that you're storing a valid pointer. But I feel like it's probably nicer to just require it on consume rather than on produce.
02:15:40.880 - 02:17:12.249, Speaker A: What happens if the writer always swaps between two reads? I mean, the reader would not make progress, but the question is why is the writer doing that? The writer swapping means the writer is making progress. Someone is still making progress, don't we need ordering protection around hazard protect on the pointer D ref. Yeah, so this is, I've made all the ordering sequentially consistent for now. What we'll do is we'll walk through and make all of them match what's in the Facebook library in a second. Why is an explicit retire needed? Couldn't it just do the retirement when dropped? When would one retire but not drop? So there are some examples of that where you might want to, like what's an example of this? Like imagine you're shuffling a linked list, right? You might want to remove a value like swap it out, but then you're going to stick it back in and you don't want it to. When you drop the thing you got back from swap for that to be deallocated because you're going to put it somewhere else after like hmm. We could have, we could sort of require that all of this is like passed around owned.
02:17:12.249 - 02:17:51.546, Speaker A: That feels, feels like it would be fairly restricting when you actually implement a data structure on top of this, right? Okay, let's think this through. So if swap returned a like owned reference, right. First of all, it's not clear that it's owned. Actually this is a great example. Think of a doubly linked list. So you have the next pointer of the previous node and the previous pointer of the next node both point to the node that you're about to remove. You do a swap from one and a swap from the other.
02:17:51.546 - 02:18:27.719, Speaker A: Both of them get back one of these owned references. Dropping one is fine, but dropping the dropping or using the other is now undefined behavior. So just because you did a swap does not mean that the thing is no longer accessible. And this is why I think it's probably better to just say that retire is unsafe because it's up to the implementing data structure whether it's sufficiently unaccessible. Right. Like the safety requirement we said for retire, said caller must guarantee that self is no longer accessible to readers. And that doesn't necessarily mean just one swap.
02:18:27.719 - 02:19:19.096, Speaker A: Yeah, it's a good point. It came up from chat. It's because the drop thing, copy types don't implement drop because they're copied. There's no way for you to drop one. So like maybe didn't drop is the right thing to do here. Just feels wonky, but it might be the way we have to go. Yeah.
02:19:19.096 - 02:19:56.939, Speaker A: So the other option, right, is to have a wrapper that we return from swap that you can choose whether or not to retire, but it defaults to not retiring it. But at that point calling retire seems like the easier thing to do. Yeah. Okay, so we need the double dereference. That's sad, but all right, we don't have a reset on hazard pointer holder. That's fine. So reset is actually kind of neat.
02:19:56.939 - 02:21:35.452, Speaker A: It's really just going to say, I guess we'll probably have to factor out like FN haspointer, which takes a mu self and gives you back a tick, static haspointer and just stick that in here. And this is going to be then self dot has pointer. So we're going to do the same thing in reset. Actually, we can, we can do better in reset because reset is a no op if we don't have a hazard pointer in the first place. So it's like if let some has pointer is self dot zero, then has pointer dot pointer dot store standard pointer null and ordering sec. Right? So reset is just saying make my hazard pointer point to nothing again because I'm willing to give up my reference. And crucially here that the borrow checker is going to take care of making sure that you don't use any pointer you got back from load after calling reset because reset requires an exclusive reference to self.
02:21:35.452 - 02:22:17.606, Speaker A: And load also takes an exclusive reference to self and ties that to the lifetime of the t. Maybe let this make this like explicit here of this is tied to this. So in order to give an exclusive reference to self to reset, you need to not be holding this anymore. Anyway. All right, final just, just to make this. Stop yelling at me. I'll just, I'll just do this and do this.
02:22:17.606 - 02:23:17.766, Speaker A: Oops, I great sat stopped yelling at me. That's good. Bounce on drop are useless, but it's not useless. I need it. This is a bad lint from the compiler. Oh, why? Oh, so this is, this is something that's arguably an erroneous lint, which is so when you have an unsafe function, the body of the function is also a giant unsafe block, which means that you don't need unsafe blocks for individual things. But it feels a lot nicer to explicitly say when things are unsafe or not.
02:23:17.766 - 02:24:28.820, Speaker A: Down here there is a unsafe block, this one, unsafe blocks and unsafe fns. So there's actually been an RFC on this that we should just not, we should require unsafe blocks even inside of unsafe functions because otherwise you can't really tell which part of the function is using the unsafe guarantees. And so I want to enable this one. Unsafe op and unsafe fn. Unsafe op and unsafe fn. I want to block deny. And now you see this is no longer linting me, because now if I, if I remove this now this is going to yell at me saying you're trying to do something unsafe inside of an unsafe fn, you need an unsafe block.
02:24:28.820 - 02:24:55.180, Speaker A: This is arguably a lint that like hopefully will someday be turned on by default. But of course it breaks any existing unsafe code because people rely on not having to respecify unsafe. But I definitely like the explicitness here better. Hazard pointer domain in public interface. That's fine, we'll just make that pub for now. That's okay. Field is never read.
02:24:55.180 - 02:25:37.508, Speaker A: That's fine. Where are our compiler errors? They're down here. This needs to be declared as mute h reset. Ah, okay, so, so here if I do cargo t, you see it's sort of want to get rid of this warnings, but that's fine. It says cannot borrow h as mutable more than once at a time. This is the line that we said should be invalid, right? Which is if I call reset, I then can't use the thing that I got back from load. And indeed that's exactly what this error is telling me.
02:25:37.508 - 02:26:32.160, Speaker A: The borrow checker saying this is not okay. Same thing down here. If I drop the, the holder, then trying to use the pointer after that is not acceptable. And so indeed if we comment out this one comment out the invalid uses then now that code compiles. So the borrow checker here enforced that contract for us rather than us having to sort of document it and rely on people using it correctly. Great. So now we have the sort of high level interface down to match what the C code does.
02:26:32.160 - 02:27:33.160, Speaker A: And now the question is like do we want to, before we start implementing all of this, do we want to change it or do we want to implement it and then see if we can tidy up the interface? Because the underlying mechanisms, like the sort of the actual checking of the hazard pointer stuff that we're going to have to implement regardless. Like we don't really have a choice in that. That's just how the algorithm works. And so we can always implement the inner things and then go through and tidy up the interface and try to make it more ergonomic on top later. So I think that's what I want to do is like basically implement the to dos we have. Because if you look about it like there aren't really other to dos here at the moment, right? Like the implementation isn't that complicated. The complicated bits are going to come here with the actual hazard pointer domain which has to manage this, this list of objects which is really just, it has to implement a linked list.
02:27:33.160 - 02:29:16.190, Speaker A: Alright, so I think these two to Dos are going to be next on our list here. What's that? There's a third warning, right? I mean one option here is to like it's dumb, right? Because really it should be okay to cast any type to this. If I make this like me. Is this a, is this a bug with arbitrary self types? Nope. This feels like it's at the very least a bug in the linthe. And there's certainly here, there's like a. If what's the standard mem needs drop of self.
02:29:16.190 - 02:30:11.884, Speaker A: If it doesn't need, if it doesn't need a drop, then retire is a no op, right? Like it's been removed from the data structure. There's nothing more to do. So that's fine. And there's sort of an argument that like if it doesn't need drop then it doesn't need to have domain either because we're not going to use it. It's all like a little silly for types that don't need dropping. This is like in practice never really going to happen. But this cast like this would have been fine if it didn't apply to like copy types.
02:30:11.884 - 02:31:21.350, Speaker A: But if you have a wrapper type that contains the type that implements drop, then I, this still wouldn't let me do this. So I think, I think this is just going to have to require drop, which means I guess I need to allow, what's it called? Drop bounce. But this very much feels like just a bug in the compiler. Like it should not give me that warning because it's not useless. It's usually useless, it just isn't useless. Great. And I think this domain here probably needs to be static or something like this probably needs to be like a star mute star const.
02:31:21.350 - 02:33:14.870, Speaker A: And then like this has to be, I guess unsafe because. Yeah, there's like something, there's something here that's going to need to be an unsafe pointer dereference because the, the thing that gets pointed to has to have a pointer to the domain, but it can't be a reference because the domain might be tied to the data structure. So it's like some kind of weird reference not cycle here necessarily, but like the, the data structure holds the domain, but also holds pointers to things that hold pointers to the domain. So I guess it is a cycle. So this probably needs to be a pointer, but that means that dereferencing it is unsafe because you need to guarantee that the domain still lives when you try to retire an object, which I think is going to tie back to probably domain being unsafe or something. Yeah, I think the way this is going to work in practice is like, if you make a new, like new is going to be unsafe because you need to promise that the domain matches, that the domain lives for as long as any of the objects that use it. So I think for now we're just going to not worry about that.
02:33:14.870 - 02:33:57.152, Speaker A: Yeah. Yeah. So let's go implement, acquire and retire because they are sort of the, the keystones that are gonna make this actually work. Why do you need the cast at all? I need the cast so that this cast, this cast is needed because hazard pointers can guard objects of many different types. It doesn't care. All it cares about is what the pointer addresses or the pointer, what the pointer is, the address of the pointer is. And so you might be retiring a bunch of different types of objects.
02:33:57.152 - 02:35:08.420, Speaker A: Like you might be retiring like some boxes over here, some vectors over here, whatever. And all of them are using the same hazard pointer domain. The hazard pointer domain is not generic over t, so it just keeps a collection of things to reclaim. And that's why this has to be this one thing we're going to have to be careful about is when we compare the pointer down in retire. No, I guess let's use when comparing, comparing pointer only compare data not vtable. So the, when we're looking through the hazard pointers, where are the as pointers? The hazard pointers all store like star mute this, right, for the pointer that they're protecting. I guess this could be a u eight or something instead, if we wanted to.
02:35:08.420 - 02:36:03.258, Speaker A: Doesn't really matter what we use here, but this just stores a star mute u eight. But the pointers we get into retire are you. Star mute didn't drop so that we can drop them. And a starmute u eight and a star mute didn't drop like the starmute didn't drop is a fat pointer, and the star mute u eight is a thin pointer. And comparing them might do weird things, but we want to make sure that we only compare the data portion of the fat pointer. Otherwise we might get these two are not the same, when in fact they're pointing to the same data. And the other one just has the additional metadata of the where the drop method is.
02:36:03.258 - 02:37:40.132, Speaker A: So you have to be careful about that. What about types that need drop but aren't dropped themselves? Yeah, so an example of this is the has pointerobject wrapper type we did, right. Its drop is empty because it doesn't need to do anything on drop. But we want, we needed to implement drop because of this requirement, which is like kind of stupid, but what are you gonna do? Can't you use mutant any and call mem? I I don't think if this took a mute in any, I don't think. I think you can drop star of that. Er, like, what's the drop in place? It's actually a little weird because I'm just like thinking this through a little bit more. And it's not necessarily just the target type that should be dropped, because imagine that someone, imagine that this pointer originally came from box into raw.
02:37:40.132 - 02:39:01.864, Speaker A: The way to drop it is to call box from raw on the pointer itself. We don't just want to drop the target of the pointer because again, in the case of box, if we called like drop and place on the target of the pointer, we would call the destructor of the target, but we would never actually free the memory because we never call the deallocator of box itself, which is kind of awkward. You know, maybe we just need to enforce that all this is box. That's a little unfortunate. I'm guessing this is why they have this like deleter trait. Right? So there's a, they have like a generic d, where there's a pub trait, deleter, which takes, I guess delete takes a immutable reference to self. Or maybe, maybe it's just a.
02:39:01.864 - 02:39:46.674, Speaker A: Ooh, that's not what I meant to do. I think it was. No, that's too large there. It takes like a star mute, I guess, din drop. And then the idea would be that your deleter would be the thing that knows whether this is really a box and you need to call something else. Right. And we could even have a default implementation of deleter, which is just calling drop in place but not dropping the actual holder or something.
02:39:46.674 - 02:40:52.950, Speaker A: Right. Or we could specialize all of this to box. That's the other alternative. Right? So now if we say that this doesn't even get this, it just needs to be a deleter. So where D is deleter? Or maybe this is even just a generic argument here. So retire. There's like something sort of wonky here of maybe the domain has actually, let's go look at what the Facebook library did here, because I feel like that might be just instructive.
02:40:52.950 - 02:42:35.396, Speaker A: So for a hazard pointer, make hazard pointers, specialized algorithms, hazard pointer object base. This is the equivalent to our hazard pointer object trait. Retire is generic over dheendev. Yeah. Right. So this is exactly the observation that the deleter is the thing that's responsible for taking a pointer of that type and calling the appropriate destructor on it, as is appropriate for that deleter. I think one question here is retire needs to pass the deleter into the domain.
02:42:35.396 - 02:43:52.602, Speaker A: So where does the domain factor into this? So the domain doesn't have a deleter. I see. So really what this is saying is that retire takes a d, that's a deleter. It passes that to this on the domain retire. And then this deleter needs to also be a part of what gets put. In fact, this probably then needs to take like an instance of that deleter or something. So, so what we need to stick in retired is actually something like the pointer and like a D default or something like this is probably a, it can't be a zero size type, it's a function pointer.
02:43:52.602 - 02:44:29.810, Speaker A: Basically saying in order to delete this pointer, use this function. Yeah, so this is going to be a function pointer type. Maybe deleter doesn't even need to be a trait. Maybe it really just is a function pointer. That is certainly one option. Like to say that this is going to take a fn of star mutant drop, which is a function pointer type, but it doesn't need to be. Right? Like this could totally be just a d, which is going to be a star mute deleter.
02:44:29.810 - 02:45:24.400, Speaker A: Or maybe we require the deleter is copy or something, but we're still going to need. What gets awkward, right, is that the list of things to retire does not have. It's not generic over t or over d. So we need to stick in things here that are like all of the same size. So, so maybe actually this is going to be a star mute din deleter and we stick the deleter in there with the pointer. Oh, I think I know what we do here, actually. Maybe what we do is actually just take a closure and then we stick the closure in the pointer to compare and the closure to call to dispose of it in there.
02:45:24.400 - 02:48:26.622, Speaker A: We're going to have to think a little bit about this interface, but it is going to be necessary to take this deleter and somehow, somehow stick it into the linked list so that we know what to call later. All right, I'm going to be back in a second and then let's implement these linked lists. Oh, and I can put up JDev. I have returned, I think. Seems like this interface would be simpler if domain was generic over t and d. It would be, but you don't really want it to be because that would require that you have a, you couldn't have one domain that's shared across like all users of haspointers, it would also mean well because the domain would then be specialized to a particular object type and a particular deleter. And that's unfortunate.
02:48:26.622 - 02:49:31.180, Speaker A: Like if we can avoid that that'd be better because we really want to amortize the cost of managing the domain. Having multiple domains is unfortunate actually. I wonder what the Facebook library does for house pointer domain retiree. The retired list is a head only list. That's fine. The holds object and atom. Wonder what atom is here.
02:49:31.180 - 02:51:57.400, Speaker A: Has pointerobject seems to be what it does. So retire allocates a new node to stick on the list. Where to reclaim is the DNA. It creates a private type structure. Retire node. Yeah, I think what it's doing here is, is it's just, it's, it's creating a, for each t and D you have a different node type, but they all implement haspterobject and, and the linked list is of these haspter objects. The question is how does it end up invoking the particular implementation? Ah, it basically ends up using sort of dynamic dispatch.
02:51:57.400 - 02:52:41.184, Speaker A: Right. So there's a, I think reclaim is a method on haspterobject. So if you get like a din of this, then you just call the reclaim method which is implemented for this particular implementation as the deallocator of this particular instance of that type which calls the appropriate reclaim. Yeah, so it's really just dynamic dispatch. And we could do something similar here too. In fact we could probably do it in almost the same way. Basically the idea is you stick a bunch of trait objects on.
02:52:41.184 - 02:53:51.350, Speaker A: In fact we could probably use din drop here and just stick a bunch of, of trait objects that do dynamic dispatch to the actual deleter onto this linked list. Ok. Yeah, it matches what we sort of wanted to do. All right. So actually if we go back here for a second and look at the Facebook code, this is a definition of domain, right? So domain has a bunch of things in it. It has, has pointers and retired, which we've already looked at. These other things are you, I think these are all related to the extra features so we can probably ignore them for now.
02:53:51.350 - 02:55:03.520, Speaker A: And these I think are just the heads of lists. Right. So retired and has pointers. Retired list, yeah, this is just a head and has pointer rec. We're going to figure out what that is. I guess that is an actual has pointer as a type that we've just called has pointer and they're both just linked lists and push retired just compare exchanges. The head of the retired list with the new node adds to the count if check.
02:55:03.520 - 02:56:13.810, Speaker A: Right. So when you're trying to retire something, you stick it at the head of the retired list, add to the count, and then if check, then we call check, cleanup and reclaim. And I'm guessing this is. Yeah, so this is the thing that, that decides to actually try to reclaim objects that have been retired, like missing, try time cleaning up is if it's been a while since the last time we did cleanup, then do some clean, then try to reclaim things. But also if we have enough objects on the retired list, then try to reclaim a bunch of them. And why does this do bulk reclaim? Just steals the whole list. It exchanges the retired list with nothing.
02:56:13.810 - 02:57:37.170, Speaker A: Then it loads the head of the list of hazard pointers. Then it records all the pointers that are guarded by hazard pointers. So it gets a set of pointer values, it loops through all of the hazard pointers, reads all of their hazard pointer values, and then here, for each retired object, like for each thing in the, in the retired list, if it's not in any of the hazard pointers, if it's not in the set that we collected, then reclaim it. Why is this a while? True bulk lookup and reclaim is. Yeah, so this walks through all of the objects and if it's in the set, if it's not in the set, then reclaim it. Otherwise just keep it because we're gonna have to put it back. And it puts it back.
02:57:37.170 - 02:58:41.320, Speaker A: Okay, so this, I think we can write ourselves like this is not a fairly, this is not a particularly complex linked list. Great. Although something has to make sure that multiple writers don't try to reclaim at the same time. M, which like should be in here somewhere. But, oh, the thing that guarantees that is because we exchanged the head of the list. So two writers come along, one tries to reclaim it, steals the head, the other tries to reclaim it, tries to take the head and the head is then none. So it doesn't try to reclaim anything.
02:58:41.320 - 03:00:13.250, Speaker A: Great. Okay, that seems simple enough. There's like all these optimizations for timed cleaning and stuff that we're probably going to want to implement, but the basic implementations seems pretty straightforward. Now here, this is a pretty standard linked list, really. Question is, is there one that we can just reuse? I think we just implemented ourselves here. I guess let's do, listen, actually you can probably do something even easier than that, which is haspters is just a head pointer, which is an atomic pointer to a has pointer and a has pointer, has a atomic pointer to the next has pointer, and it's also going to have to have an active so that we can know whether to reuse them. Great.
03:00:13.250 - 03:01:42.910, Speaker A: So I guess I'm, let's do acquire first. Oh, and we're also going to have to write drop for holder which is going to be the thing that returns the hazard pointer return the has return self dot zero to domain if some. So this is going to be a to do. And actually this one we can write pretty easily first because this one is just self dot. I guess if let some haspter equals self zero then haspointer active store false and head is. And I guess this is going to be sort of while loop or a loop. It's going to be head is.
03:01:42.910 - 03:03:10.000, Speaker A: Oh, the haspinder holder needs to know which domain it came from, which I guess can be stored just in the haspointer. But really it kind of feels like it should be in the whole. So this should hold a domain which in our case is just going to be shared domain dot head or I guess dot has pointers dot head dot load. So we're going to load the head and then we're going to actually keep that one around because we're going to want to reference it again and we're going to do something like led head is head pointer load. Then we're going to do has pointer dot next dot store head. And then we're going to do head pointer.com parent swap.
03:03:10.000 - 03:04:11.650, Speaker A: And we're going to compare and swap the what we read as the head with ourselves const has pointer. And again, all of these currently like this. So we're going to do a match on this. So this is just, we're just swat taking the, actually we may not even need to swap it back. I don't think we need to swap it back because it's already in the list. So all we need to do here is just, yeah, we never remove it from the list in the first place. The hazard pointer linked list is never unlinked so we don't even need to do that.
03:04:11.650 - 03:05:42.300, Speaker A: What we do need to do though is make sure that if it's currently guarding something, it stops guarding that thing. So we're going to do self dot reset if necessary. Right. And then we're going to set it to be not active so that other threads can now pick up and reuse this thing. So that's dirty z and then acquire I guess is really just going to be, while this, this static is only true because the domain itself is static, we're gonna have to deal with that at some point. So here, I guess what we're gonna do is the head is going to be self haspters head. And then I guess what we'll do is let mute node is headpointer dot load, while node dot not node, is null and, and the nodes active.
03:05:42.300 - 03:06:54.040, Speaker A: Then node is node. Sorry, let me write this out and then I'll explain what it means. No, is null. Okay, so what we're doing here is in order to acquire a hazard pointer, to give out, what we're going to do is just walk the list of hazard pointers, the linked list of hazard pointers. And if we get to a null pointer, then there are no hazard pointers we can reuse, and we need to allocate one. And if we're going to look at, like, we're going to look at the list in order. And if the next one has the active flag set, then we can't use it because it's already being used by someone, it's already active.
03:06:54.040 - 03:07:53.770, Speaker A: So we need to also keep looping. And the loop is just going to load the next pointer. Like we're just going to walk the linked list in sequence. And then at the end, if the node is null, then we need to allocate. Otherwise we now just sort of own this node, but only kind of, I guess maybe we want this to be, I think what we want is this here. What we need to do is try to acquire this node, right, which is node because it might be the two threads both try to like take the same hazard pointer at the same time. We need to guard against that.
03:07:53.770 - 03:08:32.130, Speaker A: So we need to do a compare exchange week of it currently was active. And we're going to make it active because we're going to take it. So if is okay, it's ours. Oh, it's complaining about something. That's fine. This is going to break, then it's ours. And we can actually just break with that node.
03:08:32.130 - 03:09:10.930, Speaker A: In this case, we haven't written yet. And in this case, it's sort of like someone else grabbed this node right before us. Keep walking. Right. So in this case, we just keep looping through and we continue from the node that we were just looking at. Like there's no reason for us to restart at the top of the list. We can just keep walking towards the end.
03:09:10.930 - 03:10:22.750, Speaker A: And there's maybe an optimization here where like you, like maybe this means you end up allocating slightly too many nodes if there's too much churn. But I think this is okay, at least for now. So for allocating, allocating here is super easy, right? Which is we just do has pointer is has pointer box new has pointer of implement default. I forget it kind of should. But even if it doesn't, we can just do this box into raw of that pointer here is going to start out being null. Next is going to be we're going to stick this. Might as well stick it at the head, right? Just atomic bool.
03:10:22.750 - 03:10:58.320, Speaker A: This one is active and the next pointer here is going to be the head pointer. Actually it's gonna be. We're gonna fill this in in a second. Actually is what it's gonna be. This is gonna be an atomic pointer new of that. And this is gonna be the same for now. I'll show you one a second.
03:10:58.320 - 03:11:45.850, Speaker A: So what do we have to do here? Right, we allocate a new has pointer. No free has pointers. Need to allocate a new one and stick it at the head of the linked list. So to stick it out the head we do. This is going to be a loop again. We're going to read the head which is going to, I guess let mute head is going to be head pointer load. And what we're going to do is we're going to keep looping and doing has pointer.
03:11:45.850 - 03:12:57.680, Speaker A: This is going to have to be unsafe. We're going to set the next pointer. I think there's a get mute. So we're going to set that to behead and then we're going to compare and swap the head pointer from what we read the head to be to our new haspter node. If that doesn't quite make sense, let me explain it in a second. Then we can, if the comparison succeeded then we can just return that haspter. And if it failed, head now, then the head is going to be head now and we go around and try again.
03:12:57.680 - 03:13:38.004, Speaker A: Okay, let me try to explain what's going on here. So we're trying to stick it at the head of the linked list. This is a standard linked list operation really. It's just concurrent, right? So we take the head pointer, read where it points. We can take our node and we set its next pointer to be the current head. And then we compare and swap in our has pointer that we just allocated with its next pointer to the old head. Try to stick it in there.
03:13:38.004 - 03:14:22.856, Speaker A: But it has to be a compare and swap because someone else could have slotted in a new head and we then need to use that new head as our next pointer. And so hence the loop. When eventually we succeed, when eventually we do set the next, then, then we can just break. And it's safe for us to use the hazard pointer we just allocated because we allocated it with active. True. So we can sort of here add in a safety. Active is true, so no one else is actually, this doesn't even have to do with active.
03:14:22.856 - 03:15:17.740, Speaker A: Safety is will never be deallocated. And safety here is has pointer was never shared, so mute is okay. Does that loop make sense? Doesn't the head pointer load need to be in the loop? No, it doesn't actually. So the idea here is that we first load whatever the head pointer is and then we try to the compare exchange. And when compare exchange fails it tells you what the value was when it failed. So we update head here. Let me add a comment that's probably helpful.
03:15:17.740 - 03:16:10.814, Speaker A: Head has changed. Try again with that as our next pointer. Is that clearer now? So this basically ends up the compare exchange doubles as our extra load rather than having to do an additional load at the top of the loop as well. And. Great. And here, I guess the up here safety here also will never be deallocated. I guess the safety has pointers are never deallocated.
03:16:10.814 - 03:17:02.390, Speaker A: Is maybe a better phrasing. Now, this will no longer be true once we move to hazard pointer domain because then they can no longer really be static. They actually have to be raw pointers because the moment the domain goes away, all of the hazard pointers associated with it should no longer be used either. Yeah, so once we move to a domain that's not static, right? Like maybe one way to phrase this is currently hasptered domain. There is only one, and that is the static one we declared at the top. Right. Once we go beyond that, this will no longer be true.
03:17:02.390 - 03:17:46.180, Speaker A: Although even now we're never called, we're never deallocating any of these nodes. Like even if you drop the domain, we're not currently deallocating those. So this still remains true for other domains as well. At the moment it's just once we add the ability for a domain to deallocate its nodes, then we need to deal with that here. But for now this is okay, that's acquire, not too bad. And then it's retire, which is going to be a little bit more annoying. So retire is also going to be a linked list.
03:17:46.180 - 03:18:50.522, Speaker A: Where is my? And we can obviously split this up more, right? Like there's nothing that requires that all of this implementation is in this one file. In reality, what we'll probably do is move the linked list implementation into its own file and we might even be able to reuse the same linked list implementation for both, for both haspters and retired. In practice, I think there's an argument for keeping them separate, which is you can optimize much better. You can optimize the implementation of the linked list much better if you know that it'll only be used in one particular way. And I think in the Facebook library. Let's see if I can dig this up. They have, they have house pointer detail linked list.
03:18:50.522 - 03:19:37.170, Speaker A: They have house pointer detail shared head only list. I'm pretty sure they have another one too. So there's like different implementations for different use cases because you can optimize them appropriately. And so I think it's fine for us to just inline the implementation now and then, and then split it out later. So retire. One thing we need to figure out is what should they even hold? I think like there's going to have to be a retired retired list. I guess this is going to be a retired list and this is going to be, oops, no, this one is going to be a retired.
03:19:37.170 - 03:21:21.434, Speaker A: But what does retired actually hold? I think what retired is going to hold is a pointer which is going to be the, the actual like pointer to the data, the thing that we're going to compare with all the hazard pointers. So maybe data, no, let's go pointer. And then we're going to have reclaim, which it's a little unclear what reclaim should be. Mmm. It is kind of tempting to say that reclaim should be a tick static din deleter, although then this has to be mute, drop, mute and drop. Or if you think about it like an FN from Gindrop. What did I do? It's complaining somewhere.
03:21:21.434 - 03:22:32.930, Speaker A: Oh, I'm gonna have, it's, it's up here that is complaining. This is going to have to be head, it's going to be atomic pointer new default. Nice. It can't be default because default is not const null. And hopefully maybe this too. Is there really not a const null constructor for atomic Pointer? No, there's default, but default is not const. There's from, but from is not const.
03:22:32.930 - 03:23:20.402, Speaker A: But I think the new, the newest const. So we're gonna have to do new, oops, new pointer null mute then same thing here. Great. Okay. I wanted to stop complaining about my dead code because I'm not done writing the code yet. And those warnings get in the way and highlight things when I don't want them to be highlighted. Yeah.
03:23:20.402 - 03:25:30.500, Speaker A: So the question is what should retire do? Well, my thinking here was that each of the things in the list of things that are retired should certainly have the pointer it needs to have the v table entry for the drop implementation of the target type. Um, and then reclaim should really just be a function pointer which I guess it doesn't even need to be this, it could just be fn which is a function pointer. It doesn't get to be a closure even. And then I guess what retire is going to do is let's, let's first stick pointer onto the list of retired objects, right? So this is going to be retired is going to be box into raw box new of retired of pointer. And I guess reclaim is going to be dedeleete. And then, and then it's the same procedure as we did up here where we want to stick it at the head of the list. And this code being the same is like a little bit silly but we do actually need retired then to have a next pointer which has to be the atomic pointer to a retired.
03:25:30.500 - 03:26:45.420, Speaker A: Right. So this is how they're going to chain and head pointer is here, self dot retired dot head. And next, initially here should be null pointer. Retired was never shared retired retired. And if it succeeds then we're done. We don't actually want to return anything and otherwise we have to try again. So this is the standard like push onto the head of a concurrent, concurrent linked list.
03:26:45.420 - 03:28:14.590, Speaker A: Now check if we need to retire. I guess this is where it's going to be handy to have a count of I guess atomic use size for like how many elements which are here. We're going to do self dot retired dot count, fetch, add one. Notice that we, we have to do this before we put the thing at the head of the list because otherwise someone else might decrement the count including our own before we add, which makes it go negative, which is a wraparound, which would be bad. Increment the count before we give anyone a chance to reclaim it. And now check if we need to retire. So if self dot retired dot count like this is where there's like some heuristic in the Facebook code base where maybe we could be smarter about exactly when should be load, when we should, when we should reclaim and when we shouldn't.
03:28:14.590 - 03:29:33.420, Speaker A: But here what we can do is just like if it's not equal to zero, then we're going to go do some work, we're going to try to reclaim some objects. We might fail, but we're going to try to here to do better heuristics. And just to make this a little bit nicer, we're going to do bulk bulk reclaimed bulk reclaim, great. And so in bulk reclaim. What we do is we sort of steal the entire retired list. Do just a compare exchange week. Or actually we just do a swap standard pointer null mute.
03:29:33.420 - 03:30:58.940, Speaker A: If steal is null then return nothing to reclaim. And then what we need to do is get all of the hazard pointers, right. So node is self dot hazard pointers collect find all guarded addresses, dot head dot load ordering. And then we're just going to do while node, while not node is null, no dot here. This is again, the safety is still the same, which is has pointers are never deallocated. So node is going to be end next load. And I guess here what we're going to really going to do is like pointers is going to be a hash set.
03:30:58.940 - 03:32:17.680, Speaker A: So use collections hash set. And we're just gonna go ahead and pointers dot insert n dot pointer dot load, right? So we're just walking all the hazard pointers and collecting all of their pointer addresses into this hash set. Oh yeah, it's if once in a while. That's right, once in a while. So we're just going to collect all of the guarded pointers. Let's do guarded pointers. We're going to insert all the ones we find and then now we're going to reclaim any retired reclaim any retired objects that aren't guarded.
03:32:17.680 - 03:34:18.380, Speaker A: So here too we're going to have basically the same thing except this is going to be the steel. And here I guess the safety is we own these objects. So in fact this can be box from raw of node, which is totally fine because we made them inaccessible and we know that no one else can be walking them because the only reason you walk them, the only reason you ever walk the retired objects is because you are swapping the head is because you have swapped the head. We own these objects so really the safety is all accessors only access the head. And the head is now is no longer pointing here. And then what we want to do is if the guarded pointers contains NpTer and I think we can just use get here now because we own the n. Oh, I'm being stupid.
03:34:18.380 - 03:35:28.690, Speaker A: This should be, what did we call this? Just n pointer. This not safe to reclaim, still guarded. In which case we sort of need to, we need to put it back. So to do put it back otherwise it is safe to reclaim. And in this case what we really need to do is just call end dot reclaim on n pointer no longer guarded reclaim using deleter. Right. So this is where we need to be careful.
03:35:28.690 - 03:36:24.770, Speaker A: We need to do this as constu eight. And then we need to do a ref, a reference to this. And this putting back is sort of important because really what we're doing is like we're walking this linked list and some of the elements in the linked list we're going to reclaim and others were not. So I think really what we're going to do is like let mute remaining is going to be standard point null mute. And then we're going to do, if we have to put it back, then we're going to set remaining. Right. We're actually, we're just going to reconstruct a linked list.
03:36:24.770 - 03:37:19.954, Speaker A: We're going to say end dot next is remaining. We're going to set. How are we gonna do? Well, so what I was thinking was we said end next to be remaining. We said remaining to be box into raw of n. No, yeah, into raw n. I'm going to go ahead and load that here. And this can just be get get mute because we already own it so there's no need for an atomic read n.
03:37:19.954 - 03:38:25.670, Speaker A: Dot next is, I guess this can be dot get mute. I mean, whenever we have like mutable access to a thing, I don't want to use the load and store methods because we should take advantage of the fact that we know that they're not needed to not specify an ordering, for example. So here really what I'm doing is just like anything that I don't find, I just like put back onto this linked list. And then what we actually need to do here is at the end here to do put remaining back. This is so, so we need to swap this back into the head of the linked list. But if you think about it, it's a little bit awkward because we need to set the head to remaining. But we also need to set the next pointer of the last thing in remaining to be the head of the current list, which makes it all a little bit awkward.
03:38:25.670 - 03:40:03.092, Speaker A: We can, I mean, we can sort of do this by, um, I mean we could put them back one by one, but that seems unfortunate. How can we atomically do this? It's a good question. I'm wondering if there's some efficient way for us to put all of them back without having to put them one by one. There's certainly like, okay, if remaining is null, then there's nothing to put back. So we can return. If there's only one element, then it's trivial because this is a standard like compare and swap loop like we did above. But I.
03:40:03.092 - 03:41:05.798, Speaker A: What should we do if we have more than one. I'm wondering if we can like reverse the linked list. That doesn't help either. I mean one option here is steal the new linked list added to remaining and then just keep going until the head is null. But that seems problematic too. So if we walk the current list and then set, so if we, if we set the last thing to put to head and then do a cas, oh, you're right. No, you're totally right.
03:41:05.798 - 03:41:44.830, Speaker A: You're totally right. Yeah, you're totally right. Ignore me. So we're gonna say we're gonna have the same loop again. This is a loop we're familiar with. Now where's our loop here? Should really just make this a macro or something. So we're first going to say the tail of remaining is going to be new.
03:41:44.830 - 03:42:34.160, Speaker A: Tail is none. If tail is none then tail is equal to remaining. Just so we don't actually need to walk this list. Tail is if let and we're just trying to avoid the unwrap here. If some tail is tail then tail else return. And here we can also assert remaining is empty, remaining is null. I mean, and if we want to, we can also assert it's not null here.
03:42:34.160 - 03:43:50.718, Speaker A: And then what we do here is say we're going to read the head pointer, we're going to set the tail. The tails next is going to be head. And the head pointer is going to be remaining. Yeah, that should be right. Okay, so, so this is a little silly. Oh, and this is, we still have exclusive access to remaining which includes tail. Okay, so the, the plan here is we're gonna, we're gonna construct this like segment of a linked list, right, which is everything that didn't, the, everything that we couldn't reclaim the head of.
03:43:50.718 - 03:44:53.230, Speaker A: That is the thing called remaining the tail. The tail value here is the pointer to the last element in that linked list. And what we're going to do is we're going to load the head of the retired list pointer, set the next of the tail to be that head and then compare and swap the head to the remaining, right. So the start of this linked list and that compare and swap is sufficient because if the head has changed then the compare and swap will fail and we'll update the next pointer of the tail again and do it all over. And if the head pointer hasn't changed then the next pointer of the tail is still correct and the whole linked list remains intact. Great stuff. So now we have put remaining back.
03:44:53.230 - 03:45:42.690, Speaker A: Alright, what's this complaining about count? That's fine. That starts out as new zero. And I guess what we also need to do in retire is. Oh, right, this needs to be mute. Is we need to ret reclaimed. Is zero reclaimed plus equals one self dot retired. Dot count fetch sub count reclaimed.
03:45:42.690 - 03:46:56.190, Speaker A: Like, so this complains because we cannot borrow n next as mutable. Only one error left. Old retire. Right, so here the problem is we don't know how to retire this. Um, because really, this has to be like, maybe this can just be fox from raw. Right, so the deleter here is a little awkward. Like, how do you specify the deleter? It arguably doesn't even need to be a trait.
03:46:56.190 - 03:48:44.590, Speaker A: The advantage of it being a trait is that it doesn't have to be a. It doesn't have to be just like a function pointer. We could associate state with the deleter two, which is valuable if someone wants to bring their own allocator, for example. And so the delete can't really just be a freestanding function. Right? So if we said it's going to be this, then this is now going to be a star mute deleter din deleter, and then retire is going to take a deleter of type d or reference to one, just a d. Maybe we're going to require that the deleter is move, or that it's like static or something. Right? Like, okay, the deleter we get in here, I guess reclaim is going to be deleter as star mute din deleter, which is why this has to be.
03:48:44.590 - 03:49:37.606, Speaker A: Yeah. So the question is, what. What do we want retire to actually take? Like, do we want someone to have to pass in an instance of a deleter? Or should we just say, you just have to be generic over it, and then it just has to be a sort of stateless closure. We could also have, we could make this interface a little simpler, right? By saying we also have a retire. Retire with drop in place. That just takes a pointer, and all it's going to do is call drop in place on the thing. But it is tempting to sort of allow the user to pass in a deleter.
03:49:37.606 - 03:50:20.980, Speaker A: But the interface is a little bit weird here. Hmm. Because the. The deleter they give us has to be, it, like, has to be behind a pointer, because otherwise we can't stick it in the list with other things that might use other deleters. Right. So this is why we can't just stick the leader here, because then we'd have a d. And retired is not generic over D.
03:50:20.980 - 03:51:17.370, Speaker A: It could be a pointer, but then this has to be a pointer. And if this is a pointer, then what is it even a pointer? Two? Like, maybe it's a static, but if it's static, then why not just have it be a static method instead? Like, why not just have it be a function pointer if it can't hold state anyway, there's like a, it could be a star mute din deleter that gets passed in here. And it's up to the caller to make sure that this is like valid for long enough, but long enough is really poorly defined here. Right. It's like the lifetime of the domain, because you don't know when it's going to be reclaimed. That might be, it might not be until the domain actually gets destroyed, which might be a super long time from here. So it's hard to assign a lifetime to this.
03:51:17.370 - 03:53:08.590, Speaker A: You know, I think we're just gonna go with what we had here for now. I think this is just gonna be a function pointer. We're not gonna have a deleter trait, and this is gonna take a d, which is gonna be an FN. Actually, no, I do want a deleter trait just because it documents the interface better, but I don't want it to do this. And then the question now becomes, what do I pass to retire? So one thing we certainly could do is have a, there are too many things in this file now, but we could have a pub struct drop in place. So maybe this is a pub mod deleters and impul deleter for drop in place, delete, mute and drop, which does standard mem, standard pointer drop in place of pointer. And similarly, we'll have a Dropbox which does a just box from raw of pointer.
03:53:08.590 - 03:55:18.320, Speaker A: This is unsafe, and this is unsafe, and these are safe by the contract on retire, which is has pointerobject retire. And then we're going to have to go back to retire and add here. Column is guaranteed that pointer is a valid reference. Column is guaranteed that self is no longer accessible to reader, and caller must guarantee that D is a valid deleter for self. Right? So if you're using the box deleter or drop as box or whatever we ended up calling it, then the part of the unsafe promise you need to make in order to call retire is, is that the star mute you pass in used to be a box. And I guess we could, we could document this on here, right, which is sort of safety can only be used on values that were originally derived from box. And similarly for drop in place can only be used.
03:55:18.320 - 03:57:15.722, Speaker A: I guess drop in place is just like always safe. So this one is actually always safe to use given requirements on retiree on has pointer object retire, but may lead to memory leaks if the pointer type itself needs drop. Can you indirect the leader behind a local generic function? You behind a local generic function? I mean, yes, it can be any, it can be any function pointer. So I think what you're suggesting, if I understand you correctly, is that here we do fn Dropbox, which takes a pointer, which is a start mute din drop, and it does unsafe box from raw pointer this. And then we pass old retire oops, drop box. This Dropbox is a function item, not a type function item types cannot be named directly. Yeah, so this is what you run into.
03:57:15.722 - 03:58:35.540, Speaker A: I mean, it is true that we could have, we can maybe do this and then say that retire is generic over deleter and takes an inst. Or maybe it's not generic over deleter. Maybe it just take, well, I guess it would have to be, it takes a deleter and I guess this, and then deleter is the d and then this is the deleter. Right? Like D delete, like the, the argument is unused, which is a little weird, but maybe it makes it nicer to work with the interface. It is true that now trade deleter is not implemented. Right. So this is where maybe we don't actually want the deleter trait.
03:58:35.540 - 03:59:29.360, Speaker A: Is that nicer? Like, I'm not, I'm not quite sure. Right. So if we comment this out like this, and then say the d is going to be an fn star mu didn't, and then we do the same here. And then we say this is just d. And then I guess, I guess actually this then is d. This has to be in, this is this. It's not generic anymore.
03:59:29.360 - 04:00:17.110, Speaker A: And then this same thing is not generic anymore. It just takes a function pointer that the deleter like that. Is that nicer. And then let's actually call this deleter to have it sort of match up. So this is going to be deleter and this is going to be deleter. Maybe that is nicer. Maybe you're right.
04:00:17.110 - 04:01:45.238, Speaker A: It doesn't mean that like people need to write these closures themselves, but maybe that's the nicer way to do things anyway. And then here, safety safe by safe because by the safe, the guarantees of retire and because retired object and because it's only used when retiring box objects, something like that. Why not pointer read instead of box from raw in drop? Because pointer read would just give us back the t like the didn't drop. It wouldn't. But we want box from raw because we want to run the destructor of box, so that we free the memory as well, instead of just running the drop for the, for the backing type. Right. So imagine this is a box file, right? Like imagine this is really a box file.
04:01:45.238 - 04:02:53.550, Speaker A: Then if we just call standard, well, if we just called standard pointer read for this, we would get back a file. We would drop the file, but we wouldn't drop the box. So the file would be closed, but the memory used by the box would never be freed. That's why we need to turn it back into a box first. Could you drop in place a string? You could, but actually, what would drop and place string even do? I mean, if, you mean if you have a star mute string, can you drop and place it? You absolutely can drop in place a star mute string and it would drop the string correctly, but it wouldn't drop whatever this pointer type was. Like, if this originally was a box string, then you would end up dropping the string, but not the box, as you would call the destructor for string, which deallocates the heap memory used by the string. But you wouldn't call the, the drop method for box, which frees the memory associated with the box itself.
04:02:53.550 - 04:03:43.060, Speaker A: So that would be a memory leak. Oh, yeah. So one thing we could do actually, in order to keep the deleter as a trait is impl deleter for fn starmutin drop delete pointer. Star mutant drop. No, that won't work. We would need a self. And we don't get a self.
04:03:43.060 - 04:04:49.568, Speaker A: Maybe we do get a self. Yeah, the problem is we don't get to store anything except a single function pointer. It's like awkward, because it's really just because of the lifetimes that this gets awkward. Like, you need to make sure that the deleter is valid for, is valid for the entire duration of the domain. So I guess we could just require that it's static, right? Like, okay, here's, here's one way to get at this, which is delete of. See, maybe it just takes a self. Yeah, so we do this.
04:04:49.568 - 04:05:38.836, Speaker A: We do this. We do. So this is just going to be this of pointer. And then I guess this is like a little bit weird, but let's go with it for now. And then what we do is on retire, we take a deleter and that's going to be a tick static din din deleter, actually. So it doesn't even need to be generic over dheenden. And same thing here.
04:05:38.836 - 04:06:57.798, Speaker A: This is going to take a tick. Static leader. This is still, this is more general than what we had before. Not by much because of the static bound, but is maybe a little nicer. And then what we do is we go here and we say this is going to be a tick static din deleter. And now I think, actually I wonder, I think closures that don't capture from their environments are considered function pointers. Like if I do this, yeah, I was afraid of that.
04:06:57.798 - 04:07:30.170, Speaker A: That's fine. I mean, it can just be this instead. I think expected one argument found zero. That sounds like a lie. I mean, I feel like I did something silly. Like the syntax is like not valid. That's fine.
04:07:30.170 - 04:08:36.390, Speaker A: Dropbox. The traitbound fn starmute didn't drop. Plus static Dropbox implements deleter is not satisfied. Let me, I want to, I don't believe that. I want to see the output. Oh, something else failed. Deleter delete.
04:08:36.390 - 04:09:43.080, Speaker A: That's fine. Now there are two vtables, but that's sort of what we would need this to be anyway, to allow the deleter to be somewhat stateful. Like in the future this might not need to be tick static, right. It's just going to be ticked of the domain, which might be something we can find a way to express. At least this way we're not building our way into a corner where we won't be able to add it in the future. Yeah, the c library uses this like it basically constructs, constructs a function that calls the deleter, which is basically equivalent to what we're doing here, except that you would have to, in that case you would have to allocate. Hmm.
04:09:43.080 - 04:11:37.160, Speaker A: Could the reclaim API be like reclaim t? No, because you no longer know the t once it's in the retire list. The retire list contains all sorts of different types. We can maybe do something here with like type ids, but it gets real wonky and I don't know that it gives as much of a benefit here. I wonder, why did I mess up my trait implementation here that put it once. Could a delete closure be saved along with the pointer in the linked list? That's basically what we're doing with the vtable, right? Restoring a closure is really just a function pointer. A function pointer with some associated state. Oh, ate too many dry nuts.
04:11:37.160 - 04:13:03.676, Speaker A: So storing the vtable is sort of equivalent because the vtable is the function pointer for a closure. So the reason I didn't write, the reason I did not write this for f where f is fn. The reason I didn't write that is because it's a blanket implementation, which means that no one will be able to implement this trait themselves for their own type. So that's why I didn't write that. I'm a little confused why this isn't allowed. Um, because like this function signature looks an awful lot like this. The question is, what does this mean? I'm guessing that's the name used for it to just help me figure out which one.
04:13:03.676 - 04:14:44.020, Speaker A: But are you planning on making a fuzzing harness for this? That'd be really cool. One thing that's challenging about fuzzing stuff like this is that because it's so concurrent, you sort of need to fuzz the concurrency. That's not always trivial. Well, one way that it might be doable is to like, you generate a, you basically fuzz a command sequence and a schedule and then you execute that. That could, that could be really neat, right? So you generate like here's a sequence of 100 commands, and you generate a schedule among like three threads, a schedule of those, among those commands, and then you run them. But, but it's just really hard to fuss concurrency like this because you don't really have control over the relative ordering of events across the different threads. Maybe we could do it with something like loom here.
04:14:44.020 - 04:15:38.160, Speaker A: Might work really well. Like, testing those with loom seems like a really cool idea. I think we still have a little bit to go before we get to that, but I think that's probably something we want to do. Yeah, Loom would give you assurance that you're actually handling every schedule, which is basically exactly designed for something like this. But why oh why oh why does this not implement deleter? Like if I do let x is static din, deleter is equal to Dropbox. Like does that complain? That complains. If I here do underscore, does that complain? Okay, so it is static.
04:15:38.160 - 04:16:53.150, Speaker A: If I do fn star mu didn drop. Oh, what? Like am I just being dense here? Like why these are the same, hey, compiler. Right? Like if I just do this, these are the same. And we've already confirmed that it's static because I can do this and it doesn't complain. So it must be tick static. So this part is not a problem. I think it's because it's an inner function for some reason.
04:16:53.150 - 04:18:01.150, Speaker A: Like if I declare it out here and then do out Dropbox, huh? No, not that either. So it's not because it's an inner function either. That's weird. This feels like a bug. Um, all din pointers have drop in their v table. Yeah, I I know that, but, but I can't. But look, if I don't take drop as a bound here, then I'm not allowed to cast to a din drop, right? So I mean, I guess I can just do like what else would it be then? Din drop.
04:18:01.150 - 04:19:25.480, Speaker A: Right? Like min dinheinhe. There's no other trait here. And I can't drop this because if I drop this, I'm not allowed to cast into a din drop in the first place. But see, this is trying to cast it to the function type and I'm not allowed to do that. Okay, what if I do this? Like can I do this? Okay. And now can I do, why is this bizarre? Why is tick static of that? Can that be? And x? What? So if I give y here, x here and get rid of this. Okay, this is a more helpful error message.
04:19:25.480 - 04:20:25.244, Speaker A: So this is just saying you can't take the, you can't take the address of x because x is on the stack. That's fine. But the address of Dropbox, I guess maybe it's just like, it's just Dropbox itself is the function pointer. I feel like this is really what it should be. Oh, what did I do? Right? I should not have deleted that. And now the problem, right? Okay. I think what's going on here is this is not a meaningful type because this is saying like Dropbox is the address of the Dropbox function already.
04:20:25.244 - 04:21:16.050, Speaker A: So what even is the address of the address of Dropbox? Like, that's not a meaningful sentiment. And I think that's what it's trying to tell me. It's telling it very poorly, but I think that's what it's trying to say. But if I try to actually just pass in the address, then it doesn't know that this is already a, it doesn't know that this is already a pointer type that can just be turned into a din. Like I'm saying that I need to take a reference and this isn't a reference. Ah, so maybe this really just needs to take a, and we need to cast it to a vtable pointer. It's just really not nice.
04:21:16.050 - 04:22:01.870, Speaker A: Basically this isn't a fat pointer. I think that's what the compiler is trying to get at here, that this isn't a fat pointer. And you don't have a way to give me a static fat pointer to it. But maybe if I do like, okay, static foo is an fn of starmuderop is equal to Dropbox. Can I now give and foo. So dumb. It's so dumb.
04:22:01.870 - 04:23:34.600, Speaker A: Yeah, because this is a pointer to a pointer. It wants a pointer to a thing that implements the trait and that means in our case, a pointer to a function pointer. But this is clearly not an ergonomic interface. But we can't have that be the interface. I mean, another option here is like retired just takes. But the reason we have to do this, I think, is because we need to construct a fat pointer to pass the retire. And the raw function pointer doesn't have any data associated with it, so there isn't really a translation.
04:23:34.600 - 04:25:04.750, Speaker A: But by constructing a reference here, it sort of, I guess, understands with which impulse to use. I really feel like this is a bug, that the compiler should be able to handle this for you. Okay, so maybe what we do here is like so silly. It's so silly. But maybe what we do is for, at least for the time being, we say that this is a pub static and then we do the same thing for drop in place. Right? And then we do, then we document the pub static. Can I, can I say that a static is unsafe? I don't think so.
04:25:04.750 - 04:26:21.920, Speaker A: Right. And then now in the test I can have this be, I guess, the leaders Dropbox. In fact, I can go even further than that and say, oh, this is, this is even worse. What I'm actually going to do here is do pub fn drop in the place takes nothing and returns a tick static din deleter. And it does this. How do you like them apples? As the saying goes. And then Dropbox is going to be static din deleter.
04:26:21.920 - 04:27:02.564, Speaker A: And it does this and it returns Dropbox. And this one is unsafe. Nice. Now we actually do get to document all of our oddities. And then down here, this is now going to be deleters Dropbox. It's real stupid, but it's the best way I know for us to work through this, this weirdity. It does not work with a cast.
04:27:02.564 - 04:28:24.150, Speaker A: I already tried it with a caste. Wait, what, what cast are you proposing to use? Oh, you're saying, all right, let me, so your proposal is down here that we can use instead of this drop in play, drop in place. But whatever, as fn star mu didn drop reference. I think you're lying. Oh, like this. But why? Why? This should not be necessary. Like this cast should not be necessary.
04:28:24.150 - 04:29:33.320, Speaker A: I don't know if this is better, actually. The reason, I don't know whether I think it's better. Like, okay, first of all, why on earth does this work? Or rather why is the explicit coercion necessary here? Because that's already the signature. Like this shouldn't be necessary. But at the same time, I kind of like this because it lets me document these separately. Like, I could provide drop in place and Dropbox as just function pointers in deleters, but there wouldn't be a way to annotate the one was unsafe and the other was not. Although I guess retire is unsafe anyway, so maybe.
04:29:33.320 - 04:30:56.940, Speaker A: Okay, so maybe. Maybe you're right. Maybe what we can do is where is my deleters? Like, I don't want that cast to have to be there in user code. Can I make it a static, oops, drop in place? Like, if I do this, I guess that is another way to do it. And then specifically say, allow uppercase static. What's it called? Non uppercase globals. Non uppercase globals.
04:30:56.940 - 04:31:31.600, Speaker A: And then can I do the same thing here? Probably Dropbox. Dropbox two hub, static Dropbox. And then this. I don't need this anymore. That's fine. And now this can be this. Okay, now I'm happy.
04:31:31.600 - 04:32:26.112, Speaker A: Great. Yeah, it's just like the ergonomics would be too bad if the caller had to actually give this, this cast. The pointer came from box, so is valid. Two, the deleter is valid for box type, and three, the old value is no longer accessible. And I guess let's number these so that it's easier for people to document their safety. Nice. Do we even have any more to dos? Get rid of this requirement.
04:32:26.112 - 04:33:19.699, Speaker A: Better heuristics. Okay, so I guess maybe it's time for us to run the test. Okay, feel good passes. So if I do assert equals this 42, and I guess down here assert equals x 42 still. And I guess I'm going to do the swap down here. Oh, so here's what I'll do. If I create an h.
04:33:19.699 - 04:34:40.849, Speaker A: Ooh, it's confused. And then I load this h here, I assert that I can still read 42 there. I can still read 42 here. And what else can I do? And then if I now do, I guess old retire all, we're going to need some, like, eager reclaim, so that's fine. And at this point, after calling whatever that is, I should still be able to read that. And then if I then drop h at that and then run oldeagerclaim. Like to do check actually reclaimed.
04:34:40.849 - 04:35:50.575, Speaker A: So I loaded before the swap. So I should still see 42. I should still see 42 all the way up there. And I guess after the swap, if I do an h two and load that, then x two should be 9001. And here, if I drop hdd, not drop h two. Actually, I guess there's also an argument here for I create a thing that loaded and then I guess this is htemp. Like I'm going to have one that loads the old value but then goes away.
04:35:50.575 - 04:36:28.950, Speaker A: And I want to make sure that doesn't hold up the reclamation either. So at this point, eagerly reclaiming shouldn't work because I still have this holder. Same here. Here I should be able to eagerly reclaim. And then here I should check that it actually was reclaimed. Here we can do something around like magical drop implementations or something, right? And eager reclaim is something we can add on, actually. What do we even, it's not entirely clear what we call eager reclaim on because we've already given a, well, retire.
04:36:28.950 - 04:37:21.621, Speaker A: So this I guess should be shared domain. I think this has to be on the domain. So there's a pub fn eager reclaim on self, which just does a bulk reclaimed and I mess something up. It's borrowed. That's fine. Does that all pass? Okay, that all passes. That doesn't tell us very much.
04:37:21.621 - 04:38:28.824, Speaker A: We don't actually assert that things aren't dropped because it could be that like this retire actually drops the 42. But I, the memory isn't reused for anything so it doesn't end up being a problem. So what we're going to do is add a little sneaky type that's going to be like count drops. So we're going to have a struct count drops, which is going to hold an arc of atomic new size. We're gonna implement drops, impul drop for count drops. And that's gonna be self zero, dot fetch add. We could probably use like a mocking library here to make this a little nicer.
04:38:28.824 - 04:39:35.579, Speaker A: But I just want something that's simple in this case. So 42 and count drops. Drops is an arc new of atomic use size new zero. This is going to take drops assert equals myx dot zero. Is this just gonna nice. This is gonna be count drops, I guess count drops of drops over here, let drops 9001. And this is going to be, I guess, drops 42 just so we can keep them distinct.
04:39:35.579 - 04:40:22.440, Speaker A: That's all fine. And then here we're going to cert equal count no drops 42 load is still equal to zero here. It should still be zero here. It should probably still be zero here though. It should be one. And the 9001 drop should still be zero. Nice.
04:40:22.440 - 04:40:53.790, Speaker A: And this can be zero and borrow of moved value. That's right. Because this has to be arc clone of this. And this has to be our clone of this. Oh, I can't type anymore. All right, let's see if that does the right thing. That does the right thing.
04:40:53.790 - 04:41:35.662, Speaker A: Wow. Did we just write error free code the first time around? I don't quite believe it. You could detect that with zero wise being implemented on the type. Yeah, there are a bunch of libraries that aim with to help with this kind of stuff, but it's like, it's so simple to just set up this type for ourselves here that I'm not too concerned. I guess we could, like, impul count drops fn new, which returns itself, which is a self arc new. But I don't really want to do that. It seems more worth that.
04:41:35.662 - 04:42:17.450, Speaker A: It's. Yeah, I don't believe this yet. There is. So we're also going to want some compile tests here, some compile failure tests for things like this being invalid and for this. Oops, where's the other? This one being invalid? That's neat. I mean, that seems like it works. That's a little bit scary.
04:42:17.450 - 04:43:32.360, Speaker A: I mean, remember, we haven't done anything about the, like, we only have this shared domain business, which is something that we would want to fix up, I guess, actually, like, if I now do say, drop h two and then this, then this should still be zero. So silly test. But there are almost certainly things missing. Like, for example, there are memory barriers that are not documented in the paper, but the implementation has. There's also all of these memory orderings that need to be corrected because currently they're all sequentially consistent, and in reality, that's not what we want them to be. Um, what does eager reclaim do? Oh, eager reclaim is, like, if you. If you specifically want to make sure that you free memory before you do something else.
04:43:32.360 - 04:43:59.590, Speaker A: Eager reclaim is what you would call. Right. So it's. I don't have a thing to. I don't have a thing to retire right now, but I still want you to reclaim things that have been retired in the past, because, remember, a call to retire might not succeed. Like, it might not be able to reclaim the item yet. So eager reclaim is a way for you to say, I now want to reclaim things that I retired in the past, even if you have to block in order to do so.
04:43:59.590 - 04:44:56.200, Speaker A: So, arguably, actually, eager reclaimed should say, this should be true. This should be false, and this should be like, block is a bool. And then, like, there should be some kind of. Here, like a. Where's the best place to do this? I'm going to go with down here, actually. It's really sort of around here. Here somewhere.
04:44:56.200 - 04:46:12.780, Speaker A: But I'm going to, for now, just say if block, then return self, dot, bulk, reclaim. If b pa pa. If tail dot is sum and block, we caller wants to reclaim everything, but somewhere left. So try again. And here we can do, like, thread yield now, right? We can be a little bit nice about retrying. Oh, fine. I guess if remain, if remaining is not null, then do it again.
04:46:12.780 - 04:47:20.380, Speaker A: And I guess this could actually be a parameter here, right? Like, do you want to actually block or do you want to just try? And so here, we could say in all these cases, we don't actually want to block because we sort of know that blocking shouldn't be necessary. And maybe, maybe eager reclaim returns. How many things were reclaimed? Maybe. That's nice. So this is going to be return zero, and this is going to be return reclaimed. And this is gonna be reclaimed. So now our test can actually be, like, assert, eek and zero.
04:47:20.380 - 04:47:54.670, Speaker A: And we can do the same thing. Here it should be one, and here it should be zero. Great. And then the one thing. Okay, so we are getting pretty close to time. One thing I do want to run those cargo miritest. I want to see if Miri spots something silly here.
04:47:54.670 - 04:48:24.990, Speaker A: Like, Miri is particularly good at spotting incorrect things in this kind of unsafe code and might spot something silly. We did. Like, ultimately, I want loom tests here, too. The following memory was leaked. That's fine. I. So we are expecting this to leak memory at the moment.
04:48:24.990 - 04:49:07.126, Speaker A: There's certainly, like, a impl drop for hasptomain to do, but that's fine. I'm not too concerned about that because it's sort of a. It's a known memory leak, and that doesn't bother me. Arguably. Yeah, that's fine. Like, we are gonna have to implement drop for hazard point domain. I think.
04:49:07.126 - 04:49:28.940, Speaker A: Can I even do this? Like, if I do this, will it panic? No. Great. Yeah, because destructors for domain. Destructors for statics are never run. Great. The recursion of bulk reclaim should be added to reclaim results. You are completely right.
04:49:28.940 - 04:50:36.210, Speaker A: Which actually means that it can't be tail recursive, which is real sad. We could make it be tail recursive, actually. Did I even use reclaimed for anything? I don't think I. So this way, it can be tailored recursive, because this is still just a recursive call. If this was instead reclaimed, plus, then it couldn't be tail recursive, because you need to run something after the function returns. It won't necessarily be turned tail recursive anyway. Allow tail recursion by passing in, by passing down reclaimed.
04:50:36.210 - 04:51:44.200, Speaker A: Yeah. Rust doesn't guarantee tail recursion but it is nice to write things that can be tail recursive once we get something like become, which is a keyword that's reserved. But even so, like if, if we didn't do this, it couldn't be tail recursive even if the compiler sometimes made it. Yeah, there are a bunch of sanitizer we might want to run here, like thread sanitizer and stuff. Miri will work perfectly fine just here. The challenge with Miri and with sanitizers in general is that they will only check the code that you wrote, like the code that actually ran, whereas very often the concurrency bugs are in particular interleavings that you haven't run right. And that's where a library like loom comes into play, where loom will ensure that every possible interleaving gets executed or approximately, which means you're much more likely to find these kinds of problems.
04:51:44.200 - 04:52:26.866, Speaker A: And then you can run Miri on top of loom, but then things run really slow. I could make it a loop, but making this whole thing is loop is actually really painful because the whole thing ends up being very long. That's why I didn't want to do that, so I intentionally wanted to do it this way instead. Great. I think now that we actually have a test that passes and code with no to DOS except features, I think that's a good place for us to end today. Um, I guess I will push this code to GitHub. It's not super interesting yet.
04:52:26.866 - 04:53:13.460, Speaker A: Like it's a pretty simple implementation of hazard pointers and there, there are obviously things that we want to add. Actually I just realized one thing that we missed, I think. Yeah, spotted a thing that we missed. Oh no, nevermind, never mind. There are a bunch of things we want to add. Like I'm guessing for the next stream what we'll probably do is implement domains so that they actually work so that there's not just the one static domain. Maybe we'll take a look at like the other features.
04:53:13.460 - 04:53:56.560, Speaker A: We'll certainly fix up all the memory orderings and the atomic barriers and stuff that are necessary and then probably write a little bit of a test suite with loom because I'm just like not convinced that this actually is correct and that should give us some more confidence in the correctness of the implementation. Let's see. Yeah, it's a haphazard implementation of hazard pointers. That's right. That's very funny. And of course this is like better heuristics for this once in a while. Like it seems like the Facebook library has a much smarter implementation here that we'll want to investigate now that we have the basic structure up and running.
04:53:56.560 - 04:54:43.020, Speaker A: But I think that's all something, all things we're going to save for next time. So I guess, are there any sort of tail end questions from chat on everything that we did today and sort of the path we're going to go next? And then after that, I think we're going to call it quits for the day. Ibrahim, I know you were very much screaming at the screen earlier to get me to realize the, the cast for the function pointer. I'm glad I caught it eventually. I do think we ended up at a good compromise, though, of having the. There's too much code on screen now. I really need to split this up of having.
04:54:43.020 - 04:55:06.510, Speaker A: Where even is it having it so that you, the caller, doesn't need to do the cast. It's a little bit of like an ugly trick here, but I think it's the right thing to do. All right. If there are no further questions, I think we'll end it there. Thanks, everyone, for watching, and I'll see you in two to three weeks when we do another one. So long. Farewell.
04:55:06.510 - 04:55:08.370, Speaker A: Bye.
