00:00:00.280 - 00:00:45.015, Speaker A: It's time for another crust of rust stream, and this time we're going to be looking at iterators, because iterators are something you're going to run into a lot in rust. You may or may not know where iterators actually appear. You may have used them without even realizing they have some relatively interesting trait bounds once you get to more advanced uses of iterators. And so that's what we're going to try to dig into now to basically use iterators to teach us about trade bounds first, though, as sort of a starting point, like we do for all these streams. I'm John. I do a bunch of these sort of live coding videos and educational videos, especially around the rust language. You can find announcements of upcoming streams on my Twitter account.
00:00:45.015 - 00:01:25.103, Speaker A: You can Also subscribe on YouTube or on Twitch. And you'll get notifications whenever I post a recording of a video or whenever I go live. I also have a wishlist there if you have some way to support the show. But apart from that, how about we get started on iterators? Same as with past streams, like past crossover streams, I will be sort of monitoring chat as we go along. So if you have questions, please ask them. The people who are currently in chat, keep in mind that if you have a question, chances are some other person who's watching the recording afterwards will have the same question, but they don't have the opportunity to ask. So, like, ask your questions.
00:01:25.103 - 00:01:46.977, Speaker A: I'll try to pick the ones that seem pretty common and seem like things that need to be explained in order to go on. I won't go on too many tangents beyond that. All right. Sweet. The text on this particular page is not important. When the text is important, I'll zoom in. Great.
00:01:46.977 - 00:02:12.045, Speaker A: Okay. So we're going to talk about iterators, and in order to talk about iterators, we first need to understand what an iterator is. An iterator in rust is a trait. It's a trait that has actually let me here, I can zoom in. So iterator is a trait. It has two primary things that you need to be concerned with. It has an associated type called item, and it has a method called next.
00:02:12.045 - 00:03:17.223, Speaker A: And perhaps intuitively, the associated type item is the items that will be yielded by the iterator. And next is going to be called by the thing that drives the iterator and is going to yield some of the item type until the iterator has been exhausted, at which point it yields none and the iterator terminates. So let's look at some. Just sort of start a new thing here, iterators and look at some code because it might be instructive when you Write something like 4x in Vec A, B, C, right? Imagine you write some code like this. What actually happens under the hood is a little interesting. There aren't really for loops in Rust. Once you get below a certain sort of level of sugar, or syntax, if you will, really, this turns into.
00:03:17.223 - 00:03:52.115, Speaker A: Well, first it turns into iter. Into iter we'll talk about what intuitor means. And then while let sum E is iter.next, right? So notice that this is basically the same thing. This is a de sugaring of what we wrote before. So the thing that was passed as an argument to for we call into iteron. This gives us an iterator over whatever that thing is, assuming that it is something that can be iterated over.
00:03:52.115 - 00:04:29.415, Speaker A: And then the for loop can go away and be replaced with a while let loop that just keeps calling next while it's returning sum. Which means that there's more stuff in the iterator for us to look at. And the moment it returns none, it stops iterating over that thing. The syntax sugar isn't exactly like this in reality. I think it actually just evolves into a loop with a break. But this gives you enough of a flavor for what's going on behind the scenes. So before we start looking at the particular Iterator implementation we're going to be looking at today, let's take a look at this into iter just briefly.
00:04:29.415 - 00:05:17.333, Speaker A: So into ITER is a separate trait. So if we go to the ITER module down here somewhere, you will see that there's a trait called into iterator. And into iterator is sort of a wrapper trait around Iterator. It is really just anything that can be turned into an iterator. Anything that is an iterator can obviously be turned into an iterator, but. But other things can be turned into iterators. So for example, if we look at some of the implementations, you'll see that there are implementations here for things like hash maps, hash sets, their implementations for slices, references to slices, mutable references to slices, mutable references to hash maps.
00:05:17.333 - 00:05:58.027, Speaker A: All of these things. If you have one of them, you can get an iterator over some relevant part of them. So, for example, if you have a mutable reference to a hash map, right? Then into iterator is implemented for this type for that mutable reference and the item that you get back the things you're going to get back from the iterator is a tuple of an immutable reference to a key. So the shared reference to the key and an exclusive or mutable reference to the value. This makes sense, right? If you have a hashmap, it has keys and values. You can't change the keys as you iterate over them, but you can't change the values. You can't change the keys because things would then move around under you in the map, which is not.
00:05:58.027 - 00:06:24.757, Speaker A: Okay. Intuitor also has this associated type of into iter, which is the type of the iterator that it's going to return. And so in this case, itermute is a type that's implemented internally in the hashmap sub module. We don't get to look at it here because it's not really that important. And we're not going to look too much at Intuiterator here. It's just a useful thing to look at. Okay, so back to Iterator.
00:06:24.757 - 00:06:37.797, Speaker A: One thing you might wonder is why is this an associated type? Why do we have an associated type item as opposed to having item or I or t be a type attribute on the trait itself?
00:06:37.941 - 00:06:38.221, Speaker B: Right?
00:06:38.253 - 00:07:04.455, Speaker A: So what I'm talking about here is why do we have Iterator item type item and mute self returns an option of self item. Why is this the trait and not this?
00:07:04.755 - 00:07:05.115, Speaker B: Right?
00:07:05.155 - 00:07:52.775, Speaker A: Like why the former, not the latter? And the reason why we use the former and not the latter is because if we use the. So there's no hard and fast rule for this. There's no right way or wrong way. Both of these would work. In general, you use an associated type if you expect that there will only be one implementation of the trait for a given type. So if you have a type like hashmap, there is only one Iterator type for it, which is keys and values. If you have a vector, there's only one iterator type, which is something that yields the values of the vector, right? And in general, this is going to be true for iterators that they only have one item type that is meaningful.
00:07:52.775 - 00:08:36.605, Speaker A: On the other hand, you want things to be generic type parameters to the trait. If there if multiple implementations might make sense for any given type. So let's look at some hypothetical service trait that has a request type. And like, who knows what this does, right? This do and it takes a request mute self and our requests and it returns nothing, right? This trait here. We could also have requests be an associated type. But it might make sense that you could have some service that supports accepting multiple different types of requests. If we had request be an associated type here, then that would no longer work.
00:08:36.605 - 00:09:56.385, Speaker A: You would only be able to implement this trait once and give what the associated type is. This might make you wonder, isn't the generic type parameter just more general? Why don't we use that always so we never constrain the implementer? The answer to that is a little complicated, but the general idea is that if you have it be an associated type, the type checker has a much easier job of things because now it knows that there is only one implementation to choose, and so there are fewer times where you need to write implementation blocks, for example, or function signatures that have additional generic parameters. The associated type is sort of dictated by which underlying type it is, right? So if I give you a something iterable and you say that you want to use this as an iterator, I immediately know which iterator implementation you mean, because there is only one. If on the other hand, I give you a something service and you want to use it as a service, you have to tell the compiler which request type service do you want it to be. So in general, associated type reduce the amount of extra generic type parameters you need to be using. Okay, so that was a sort of long aside on traits and associated types. Let's look through some questions before we move on to actually implementing an iterator ourselves.
00:09:56.385 - 00:10:38.809, Speaker A: Why do some types of ITER and others use into iter? I don't think there's a good reason to have an ITER method. Like if you have a slice. You may have seen that if I have like an A, B. Well, it's a bad example, but I can call.iter and it gives me an iterator over the elements of the slice. So you might wonder, well, why doesn't slice just implement into iterator? And the answer is it does. Usually these methods are unnecessary, but they might.
00:10:38.809 - 00:11:41.301, Speaker A: They're shorter to type if they happen to come up very often. And they also let you. They mean that you don't have to conform exactly to the to the method signature that the trait, the intuitor trait requires, which in some cases make lifetime reasoning easier. Couldn't hashmap also have separate iterators for just keys or just values? It could and it does, right? Like it has a hashmap, for example, has inherent methods. So those are methods implemented directly on the type rather than through a trait for the one called dot keys and one called dot values. But hashmap itself does not implement iterator, it implements into iterator. And if you have a hash map and you say give me an iterator over it, there's only really one answer because it doesn't take any other arguments, right? If we're using a for loop, we don't need to explicitly call.iter
00:11:41.301 - 00:12:33.745, Speaker A: that is correct. Although keep in mind that if I have these as a VEC of 1, 2, 3, there's a big difference between this and this, right? This one consumes VS and gives you owned, like owned access to V. This one borrows VS and gives you references to the V's. Now if you don't want to write the iter, what you can also do is this. This is equivalent to VS iter. These are the same. And this is because into iter is implemented for reference to slice vector.
00:12:33.745 - 00:13:03.845, Speaker A: Why does range inclusive? That seems separate. Great. Increase font size. Yes, I can. There we go. That's real big. Yeah.
00:13:03.845 - 00:13:28.411, Speaker A: So someone pointed out that it's strange that the consuming iterator is the implicit default. I don't think that's strange. You said iterate over this thing and that's what it's doing. It's iterating over the vector. If you want to iterate over a borrow of the vector, you have to explicitly say that you want to iterate over the borrow of a vector. This is sort of the. Sort of a general idea and rust of like being explicit is good.
00:13:28.411 - 00:14:26.735, Speaker A: And here's an example of that. Like it's not going to auto borrow unless you tell it to. Great. All right, so now let's get to what I was planning to do today, which is you may have noticed that there are a bunch of other methods on Iterator and these, you can tell from the little bit at the end here, have default implementations. That is the standard library or the thing that defines this trait, which in this case is the standard library, has default implementations on these that just use this type and this method. So for example, the default implementation of count just calls next until it returns none and keeps a track of how many times it got a sum and that is the value. Of course, for some iterators you can imagine a much more efficient implementation of count, right? So the implementation of iterator count for a vector can just like the vector knows its length, so we can just return that rather than iterate over all the things.
00:14:26.735 - 00:15:03.655, Speaker A: And this is why these have default implementations, because there are sane defaults for them, but you want them to be able to be overridden for particular implementations of iterator. And there are a lot of really cool things here, but the one I particularly want to look at today is flatten. So what flatten does, which we can see from the method signature 2, is it takes an iterator, right? So this is a method on the iterator traits. So by default, self must be something that is an iterator. And it's only defined where self item implements into iterator.
00:15:04.635 - 00:15:05.375, Speaker B: Right?
00:15:05.715 - 00:16:20.277, Speaker A: And then what flatten actually does is it walks the elements of the outer iterator. And for each item, each item is expected to itself be able to be turned into an iterator and then it walks all the inner things before returning to the next outer thing. A diagram might be useful here. So let's actually draw a little. Let's do something like this color. So conceptually imagine our iterator as some like endless thing of items, right? So this is going to be our outer, and then we're going to have an inner, which is when the outer iterator is about to yield its first item, instead of yielding this item, what it's going to do is it's going to call into iter on that item, which again gives us another iterator. We don't necessarily know how long it is, it's just some other iterator.
00:16:20.277 - 00:17:02.545, Speaker A: And then the first call to next is going to return this item. The second call to next is going to return this item all the way until this iterator ends. So these are all going to be returned. And then when the inner iterator has been exhausted, what we're going to do is at that point we're going to move, oops, go back there. We're going to then only then move on to the next outer item. Then we're going to call into iterator on that, and then we're going to iterate through the things inside here and then so on. So it flattens a nested iterator type, right? So imagine for example, that you have a vector of vectors.
00:17:02.545 - 00:17:39.853, Speaker A: Flatten would iterate over all of the items of the inner vectors in order. Does that roughly make sense? Just let's make sure that we're on the same page. Okay, so that seems to roughly make sense. Great. So flatten is a fairly straightforward in terms of how you use it. But let's try to actually implement flatten. So let's have a library.
00:17:39.853 - 00:17:54.685, Speaker A: It has a PUBFN flatten and it takes an iterator. Does it flatten infinitely? Well, it keeps taking as long as there are iterator items left.
00:17:54.805 - 00:17:55.061, Speaker B: Right.
00:17:55.093 - 00:18:35.613, Speaker A: The moment it has consumed the entire outer iterator, then there's no more items to yield. But it keeps taking until the none none of the iterators and the type you're iterating over yield. Any more items. Do these nested iterators need to have the same item type? Yes. So I mean this is already a requirement of iterator that all of think of it this way. If all of the blue things have the same type, then calling into iter on each of them must also by necessity give the same type. And so we don't actually have to explicitly say this.
00:18:35.613 - 00:18:51.789, Speaker A: This is just implied. It does not. It only recurses one level. So this is not recursive all the way down. It's not turtles all the way down.
00:18:51.837 - 00:18:52.213, Speaker B: Right.
00:18:52.309 - 00:19:28.425, Speaker A: It only recurses one level, so it's not recursive. Okay, great. So let's look at what the interface to this look like. We're going to start with having this just be a freestanding function and then we might see if we can do better than that after a while. So we take an iterator and it's going to be of some generic type I. I haven't decided what I is going to be yet. And it's going to return some type flatten that obviously need to include that I.
00:19:28.425 - 00:19:43.349, Speaker A: And this is probably just going to be like flatten new iter. Great. So we don't have a flatten. That's fine. We're going to define a flatten. It takes an I. And let's start with something that just holds the outer iterator.
00:19:43.349 - 00:19:44.705, Speaker A: Let's call it outer.
00:19:45.245 - 00:19:45.965, Speaker B: Right.
00:19:46.125 - 00:19:58.633, Speaker A: And we're going to do flatten I FNU iter I. This is standard like setup stuff.
00:19:58.689 - 00:19:59.285, Speaker B: Right.
00:20:01.785 - 00:20:14.005, Speaker A: Great. And this has to be generic over the iterator type. Ok, seems fine enough. We now have a type and now we want to implement iterator for flattening.
00:20:14.335 - 00:20:15.075, Speaker B: Right.
00:20:17.855 - 00:21:02.445, Speaker A: And we need to define then the item and we need to implement next. Those are sort of the two primary requirements for us to do in order to implement iterator. So what do we set item to here? Well, we don't actually know what the item is here. Right. We could do I item but that's not really the type we're going to be yielding because we're going to be yielding the type of the inner iterator where I here is the outer iterator. So let's go ahead and actually do that straight away. We're going to make this O to indicate that it's the outer Iterator just for our own sanity.
00:21:02.445 - 00:21:35.461, Speaker A: And then this makes a lot more sense, right? Like it's not the outer item we're going to yield. So clearly something more is needed here. Well, we know that we're going to need to have at least some bound that says where the outer thing implements iterator. Right? If the outer thing isn't iterable, then we're not going to get anywhere. I guess let's make this none. Okay, so that compiles. But again, as we said, this is not right.
00:21:35.461 - 00:22:22.719, Speaker A: What we really want to say here is like this, right? Like we want the item of the item. But rust is like, I don't know what you mean here. Like, what is this associated type? Well, we can do a little bit better. So what we want to do is we want to define additional trait bounds here. We want to say that O item also needs to implement into iterator, right? And then we want to say that the return type here is going to be the O item as into iterator item. Does this syntax make sense?
00:22:22.817 - 00:22:23.027, Speaker B: Right.
00:22:23.051 - 00:23:17.655, Speaker A: So here we're saying the outer thing is an iterator and the items of that iterator. So this could also have been written as O as iterator. But rust is helpful enough that it lets us omit this when. When O is only when there's only one trait bound of O that gives an associated time with this name, then we don't need to give this name explicitly. So we want the outer thing to be an iterator and we want the items of that outer type to implement into Iterator so that we can then later iter over them. All right. We have of course not written next yet, but does this part make sense? Why is O item as inter iterator? Yeah.
00:23:17.655 - 00:24:02.553, Speaker A: So this is sort of the same question, right? If we could admit O as iterator here, why can't we do the same here? It's a good question. Let's see what cargo check says. Let's do. Let's do beta here. Why not? I don't know why it thinks that's ambiguous. I think this is a parsing ambiguity. It doesn't know whether this is well, unclear.
00:24:02.553 - 00:24:38.389, Speaker A: It could be a parsing ambiguity. I think in general, like this could be a path, for example, might get confused about that. I'm not sure it's certain. The as long as it's parsed as usual sort of nested associated types, then it's not ambiguous. So I don't think this is technically needed, but it seems fine. Could you add another generic type with bounds? Yeah. So you could flatten this a third level if you wanted to.
00:24:38.389 - 00:25:13.395, Speaker A: Right. You could say, and then I want O item as into iterator item to implement into iterator if you wanted like a three level deep flatten. But notice that this would only work for things that are in fact three levels deep. This would not work for things that are two levels deep because this last bound would no longer be true. Let's stick to just two levels for now. Oh yeah, we might be able to do this to see. No, apparently it doesn't like that.
00:25:13.395 - 00:25:32.527, Speaker A: That's fine. Great. So now let's try to actually write next. Okay, so we could do self.outer. next.
00:25:32.711 - 00:25:33.055, Speaker B: Right.
00:25:33.095 - 00:25:36.711, Speaker A: That seems like the obvious thing, but then it tells us this is wrong.
00:25:36.823 - 00:25:37.095, Speaker B: Right?
00:25:37.135 - 00:25:47.783, Speaker A: Because the type of this is O item, the item of O. Whereas what we promised was that we would give the item of the iterator of the item of O.
00:25:47.959 - 00:25:48.675, Speaker B: Right.
00:25:48.975 - 00:25:51.515, Speaker A: And maybe this is going to be clearer in a terminal.
00:25:51.815 - 00:25:52.555, Speaker B: Right.
00:25:54.215 - 00:26:31.175, Speaker A: It expected to get like this sort of nested type, and instead it just found O item O as iterator item because we haven't nested at all. So what do we do? Well, we could do like map and like inner. Inner. I guess this would have to be an and then inner next. Well, that doesn't work because it's an into iterator, not an iterator. So it doesn't have a next. So intuitor.
00:26:31.175 - 00:27:11.517, Speaker A: Great. Okay, so this compiles and obviously there's nothing wrong with this code. You could write a macro that generates an implementation for an arbitrary level, probably as a proc. Macro. Oh yeah, you can flatten recursively yourself, as in like you can invoke flatten multiple times. Flatmap is a good way to do this, actually. Okay, so let's.
00:27:11.517 - 00:27:53.605, Speaker A: Now that we're. Now that we're totally done, let's do tests, use super. And then we're going to have a test. Well, let's do first empty. So what's this going to do? Well, this is going to do a flatten of iter empty. And we want to assert that that count is zero. And I guess we're going to have to say what type we're iterating over because it can't infer it because we haven't given it any values.
00:27:53.605 - 00:28:28.381, Speaker A: And the. So this is actually kind of interesting. So empty returns you an iterator that Yields no items. But because there are no items, the compiler needs us to tell it what the iterator item type is. I tried to use this unit here, like the empty tuple, but then it says, oh, that won't work because flatten be easier here. Oh, test. The method count exists, but the following trait bounds were not satisfied.
00:28:28.381 - 00:28:58.671, Speaker A: Unit does not implement into iterator, which is required by flatten in order for it to implement Iterator. Right, so it's actually telling us pretty nicely here exactly what's going on. You can't use flatten as an iterator unless the item type, which here is unit implements into iterator. Since this is empty though, we can just tell it that it's some other type that is totally iterable. Like this. Okay, see if that works. Great.
00:28:58.671 - 00:29:22.685, Speaker A: An empty iterator works correctly. All right, now let's see if it works if we have just one item. So this is going to be. It yields only one item. And that one item is going to be, let's say, a vector of zero.
00:29:28.185 - 00:29:28.925, Speaker B: Right?
00:29:31.425 - 00:29:43.937, Speaker A: So that failed. And it failed because it got a 1 when it expected a 0. Because there is one item here, right? If you go all the way down, you will get this zero. Let's make it not zero. Let's make it A.
00:29:44.081 - 00:29:44.625, Speaker B: Right.
00:29:44.745 - 00:30:01.165, Speaker A: A should be counted. So the count here should be one. Let's see if that is in fact the case. That is in fact the case. All right, so now let's. Let's go even weirder. Let's try to make this.
00:30:01.165 - 00:30:28.741, Speaker A: Try to iterate over more items. Let's do B as well and see if the count is two. What? The count is only one. Okay, so this clearly implies that our iterator sort of works, but it only works for the first item, which is clearly pretty useless. So let's maybe. Maybe we sort of got it right. Like, let's see what happens if we try something else.
00:30:28.741 - 00:31:07.819, Speaker A: Let's see if we try a vector of vectors where they're in different vectors. And I guess here actually we're going to have to do. We're going to do into iter here for relatively uninteresting reasons. Let's see what this does. Ooh, did I miss the parentheses? Yes. And terminate these with semicolons. And so this is sort of a.
00:31:07.819 - 00:31:30.265, Speaker A: Too wide. So here there is. The outer iterator has one element, and the inner iterator, the first inner iterator has two elements here. The outer iterator has two elements, and both of the inner iterators have one element each. Let's see. Okay, so that worked.
00:31:31.805 - 00:31:32.545, Speaker B: Right.
00:31:32.885 - 00:31:41.665, Speaker A: So clearly it is walking over the outer iterator, but it's only returning the first thing from each inner iterator.
00:31:42.605 - 00:31:43.397, Speaker B: Right.
00:31:43.581 - 00:32:01.195, Speaker A: And we can test this with something that's wide as well. Right. So another way for us to get empty is to have this be just a ton of empty things.
00:32:03.975 - 00:32:04.695, Speaker B: Right.
00:32:04.855 - 00:32:28.153, Speaker A: If you flatten this iterator, I guess, fine, we need to actually tell it what type it is. Like so, like so, so this, when you flatten this type, that still has no elements in it.
00:32:28.249 - 00:32:28.745, Speaker B: Right.
00:32:28.865 - 00:32:46.323, Speaker A: The outer iterator has three items, but each of those items iterators have zero items. So if you count them, there are zero items. Let's see that. That in fact works out too. It does. Okay, so the only problem here seems to be if any of the iterators have more than one item.
00:32:46.459 - 00:32:46.731, Speaker B: Right.
00:32:46.763 - 00:33:33.685, Speaker A: It works fine if they're empty, it works fine if they have one item. It does not work fine if one outer iterator element has multiple inner items. So let's look at our implementation why that might be. Actually, let's see if there are questions first. Yeah, so we could also do standard iterator empty. Whose type is an empty iterator? But we want the test to be easy to read where we can. Okay, so let's try to see what's actually going on here.
00:33:33.685 - 00:34:05.825, Speaker A: Maybe this is going to be clearer if we use question mark. So question mark also works for all options. So we can do this. Actually, let's, I guess inner. This is equivalent to the code we wrote before. Enter it. Well, I guess inner item, inner it, and then we want inner it next.
00:34:05.825 - 00:34:36.523, Speaker A: This should be item. And I guess if we're going to be really explicit about it, we do this. Now that the code is written out this way, it might become a little bit more obvious what the problem is. So we call next on the outer iterator, and that is the first thing we do anytime someone calls next. This means that every time next is called, we're going to be moving the outer iterator along. And when we get the inner iterator.
00:34:36.659 - 00:34:37.027, Speaker B: Right.
00:34:37.091 - 00:35:23.705, Speaker A: So here we take the item that was yielded by the outer iterator, this sort of green long iterator, and we call next on it, but then we just drop it and we never get to touch that again. But in reality, this inner iterator might have more items to yield beyond just the very first one. So what do we do with this? Like, where do we stick this inner iterator because we're going to have to stick it somewhere so that we can continue to call it. Well, we have a struct. So how about we do inner and what type do we give this? Well, O item. But that means we here need to say where O is iterator. And that means we here need to say where O is iterator.
00:35:23.705 - 00:36:09.335, Speaker A: And that means we here need to say where I is iterator. Now this particular problem of like the bounds propagating all the way up is something that will get fixed a little bit by something called implied bounds, where if you have a bound that's on the struct, you don't need to name it again for any implementation that is not currently the case, but that will help. And so when someone creates a new iterator, what do we do? Like what do we set inner to? Here we don't have an inner iterator. So what we actually do here is this probably just needs to be an option because we may not have one yet.
00:36:10.195 - 00:36:10.935, Speaker B: Right.
00:36:13.795 - 00:37:07.849, Speaker A: And so now let's look at what we do need to do for next. What we want to do is if there is an inner iterator that we're still working on, then we want to give items from that. It's only if the inner iterator has been exhausted that we want to move out to the next outer element. So if let sum enter, let's do iter to make it really clear. So if there's an inner iterator and if the inner iterator when we call next on it gives us an item, then we want to return that item. If it doesn't, Right. That means that we've exhausted the inner iterator and self.inner
00:37:07.849 - 00:37:51.807, Speaker A: can be set to none. Why is it complaining here? Method next, Right? All right, so why is this a problem? Well, the item type as we see does not actually implement iterator. It implements into iterator. So we can't call next on it because we can only call next on it when it has become an iterator. The example here would be the vector type, right? So what we're the way this is currently written, inner would be an option vector. But you can't call next on a vector.
00:37:51.951 - 00:37:52.399, Speaker B: Right?
00:37:52.487 - 00:38:49.335, Speaker A: The iterator implementation for a vector has some additional information like where in the vector am I currently? If we just here stored option vector then we wouldn't have that information and we wouldn't be able to call next. So really what this needs to be is O item as into iterator into iter, which is the iterator type of that item. And now we get through the same thing again, where we actually need to now require that the inner thing is also an iterator. You can see this gets a little bit unreadable because we need to navigate our way down to exactly the type that we need to store. And then, of course, the trait bounds propagate up in the same way. And now. Now we can say, I want to call next on it.
00:38:49.335 - 00:39:46.073, Speaker A: Okay, we haven't finished fixing next, but let's see if there are questions there. This is. This is fairly involved, what we went through just now. Yeah, the syntax here gets pretty gnarly, but it's because we're. We're trying to name a type that's pretty deep, right? There's not that much extraneous syntax here, right? It's saying item as an interior. If we look at the bound up here, right. The contents of this is not actually that complicated, and the syntax isn't that complicated either.
00:39:46.073 - 00:40:13.039, Speaker A: It's more that the bound needs to be there because it really is a restriction of our implementation. And so it needs to be written somewhere in some form. And I don't think this form is particularly bad. This form is a little bad. But again, there's not that much sort of extraneous information here. All right, so let's finish fixing our next. So if there's an inner iterator, then we're just done.
00:40:13.039 - 00:40:42.141, Speaker A: Like, there's nothing more for us to do. Well, we call next on it, and if it gives us a thing, then we're done. However, if there's not an inner iterator, or if we exhausted the iterator just now, then what do we do? Well, then we just want to get the next outer iterator item, right? So we can do this.
00:40:42.333 - 00:40:42.925, Speaker B: Right?
00:40:43.045 - 00:41:08.885, Speaker A: So this is. Give me the next item from the outer thing. Question mark. Means if there are no more items yielded by the outer iterator, then just return. Otherwise, give me the item that was returned and then turn that into an iterator and this is going to be the next inner iterator. So now we need to store that somewhere, right? So we can do self.iner equals sum of next iterator.
00:41:08.885 - 00:41:51.259, Speaker A: Great. But we then still need to actually get that item. So we could do self inner as mute, unwrap next. Right, but that doesn't quite work either, because this might exhaust the iterator itself. Like, the inner iterator might be empty. So really, the thing we're going to do here is basically sort of do a loop where we're going to end up recursing. And to see why this works, once we set the inner iterator here, we're going to loop back around, it's going to be set to sum and we're going to do the right thing.
00:41:51.259 - 00:42:47.005, Speaker A: And then ultimately, either we're going to return sum from some inner iterator, or we're going to return early with a none here when the outer iterator has been exhausted. All right, does this make sense for now? Do you normally include bounds on the struct definition as well or just the input block? I usually include them just on the input block when I can get away with it. Here's an example where we can't, because a struct actually needs to talk about the nested associated types. All right, so let's see if this actually compiles and runs. It does. Okay, so now the tests actually work great. We successfully implemented Flatten and like, there's a little bit of syntax pain here, but it's not that bad.
00:42:47.005 - 00:43:38.275, Speaker A: So let's look at some ways in which we can prove this. One obvious first fix is that we had to call into iterator whenever we called flatten on something that isn't already an iterator. And that's kind of unnecessary. Like, we'd like to be able to get rid of these into iterator calls. And we can do that already with the into iterator trait. If we just do this, then now you can give flatten anything that can be turned into an iterator and it will call intuitor for you. And then flatten only has to think about iterator types would while let suminner equal self inner here.
00:43:38.275 - 00:44:28.989, Speaker A: So the proposal list we do while let sum enter is self inner instead. That doesn't quite work because think of the first time next is called we need to make sure that we execute this code. And so that wouldn't work. Okay, so we fixed that. So we fixed that sort of annoying just usability problem. But now let's look at some weirder parts of iterators. So if we go to the flatten from the standard library, you'll notice that it implements a bunch of other things here we can implement clone and debug, but those aren't that interesting for these purposes.
00:44:28.989 - 00:45:17.755, Speaker A: But it also implements some other weird things. Most notably, it implements this double ended iterator trait. So what is double ended iterator? Well, as the name implies, it's an Iterator that you can iterate from either end. So if we look at the declaration of it, it requires that the underlying type is iterator and then in addition to the methods from iterator, so namely the associated type item and the method next, there's also a next back, where next back gives you the last element from the iterator, so you can sort of walk the iterator from either side. This means that you can really efficiently walk it backwards, for example. Great. So let's see if we can implement double ended iterator for flatten.
00:45:17.755 - 00:46:06.187, Speaker A: In theory it should be doable, right? Like if we think about this drawing again for a second, if the outer iterator lets us get to this item, then and that gives us some inner iterator, right? So if this is yielded, then that gives us some other iterator and if that iterator also gives us the ability to look at its back, then it should be possible for us to implement next back to just the same way as how we implemented next. By taking the first item of the first the first inner item of the first outer item, we can take the last inner item of the last outer item in order to implement next back should be totally fine.
00:46:06.291 - 00:46:06.935, Speaker B: Right?
00:46:09.475 - 00:47:16.675, Speaker A: So let's see what that might look like. So here, what do we want to do? Well, we want to implement o double ended iterator for flatten O and we're going to need to have the same trait bounds that iterator has, right? Because these are just like fundamental to flatten. And then we're going to implement next back. And notice here that we can refer to self item here because let me get rid of that. Because double ended iterator sort of extends the iterator trait that is a type can only implement double ended iterator if it implements iterator. And since iterator has an associated type item, anything that so self which implements double ended iterator must also have that same associated type here too. We could say self as iterator item, but we don't need to.
00:47:16.675 - 00:48:16.145, Speaker A: Basically the compiler lets us omit that particular declaration if it's only one level deep. Great. So now how do we implement next back? Well, we already talked about this, right? Isn't it sort of just the same? Right, where it's the same thing it was it for iterator, except instead of calling next we're going to call next back. Great. Well this doesn't quite work because next back there's nothing that says that the inner iterators can be walked backwards. So we need to add those bounds too. So this needs to also implement double ended iterator and o item as into iterator.
00:48:16.145 - 00:48:28.475, Speaker A: Its into iter needs to implement double ended iterator.
00:48:32.695 - 00:48:33.175, Speaker B: Right.
00:48:33.255 - 00:49:24.173, Speaker A: So what we're saying here is the outer iterator needs to implement double ended iterator. Iterator is becoming a hard word to say. And in addition the inner item, the inner iterator or the inner item when turned into an iterator, that iterator type, which is this associated type, needs to also implement double ended iterator so that we can walk the inner things backwards as well. Notice that the into iterator is sort of complicating things here. Right? Because it's not as though the things that the outer thing produces are iterators themselves. We have to go through this extra step of turning them into iterators in order for us to be able to talk about them. And so this associated type into iteration is the name of the or the it is the type, the iterator type for that item.
00:49:24.173 - 00:50:03.975, Speaker A: So if the outer thing is an iterator whose items are vectors, then the into iter of vector is a vector iterator which is its own type. And it's that type that we need to be double ended iterator. I know that this is like there's a lot of levels that are hard to follow. I recommend that after we finish, like go back and look at the stream and try to actually write this out for yourself and see that this sequence of logic works out. We can luckily simplify this a little. So we can for example get rid of iterator there. Because double ended iterator implies iterator.
00:50:03.975 - 00:50:21.093, Speaker A: But that's mostly what we can do. Yeah, so you can imagine that if we went three levels deep, this would get even more complicated.
00:50:21.149 - 00:50:21.317, Speaker B: Right.
00:50:21.341 - 00:50:44.245, Speaker A: Because you need the bounds need to apply at every level. What's the difference between plus and comma in trade bounds? Comma is just. Here's a new rule. So this is one bound, this is one bound. Plus is saying both bounds must hold for the thing before the colon. So this is saying O is iterator and double ended iterator.
00:50:44.625 - 00:50:44.961, Speaker B: Right.
00:50:44.993 - 00:51:31.555, Speaker A: Whereas the comma here is saying this must be true and this must be true. All right, so let's see if this works. Right, so what can we do here? Well, let's try to reverse. Reverse that. And we're going to try to reverse to reverse wide. So ab if we collect, that should give a vector of ba. If we reverse that as well.
00:51:31.555 - 00:52:17.565, Speaker A: And similarly here if we reverse this and rev is in fact we can look at this if you want. You'll see that on iterator. Where's my iterator? There's a reverse. That is the reverse method which only exists if the iterator itself implements double ended iterator. And since flatten now does, we can call ref. So here we're reversing and then collecting into a vector so that it's easy for us to compare it with things. And here too, this should give B followed by A.
00:52:17.565 - 00:53:19.655, Speaker A: All right, see what that gives us? Great compiles. The tests run, we must be done right. Let me give you a more complicated tests and some of you may already have figured out what's wrong here. It's more. It's useful to actually walk through it step by step, both ends. So here what we're going to do is we're going to try to flatten this thing. All right, so what do we expect here? Well, we expect that if we take the first item then that should give us A right because if we just flatten this thing in our minds, then the very first thing, so the leftmost thing is an A.
00:53:19.655 - 00:53:41.965, Speaker A: We expected the thing from the back, so now it's the remainder is like B, C, D. If we now get from the back, what we expect to see is D. If we now get from the front, we expect the next thing would be B and so on. And then once we've exhausted the iterator we expect all of these to be none.
00:53:42.345 - 00:53:43.457, Speaker B: Right there.
00:53:43.561 - 00:54:15.935, Speaker A: After we've consumed A and D and B and C, then now there's nothing left. And so trying to take from the iterator from either either side should yield none. All right, so let's try that. Okay. That does not pass. Why did it not pass? So on line 126. So for this, for this next back it expected, we expected to get a D and instead we got a B.
00:54:15.935 - 00:55:02.435, Speaker A: Hmm. So instead of getting a D here we got a B. Why might that be? Let's see if we can shed some light on this by making this a little longer. She let's do this. Like is going to be A1, A2, A3 is going to be B1, B2 and B3. So now we expect this to give A1, this to give B3, this to give A2, this to give B2, this to give A3, this to give B1 and then none. And my prediction here is this is going to give us a 3.
00:55:02.435 - 00:55:32.825, Speaker A: Let's see if that's true. Yeah. So this gave us a 3 instead of B3. So why is that? Well, what's happening here is the next is going to give us this item and then for some reason next back gives us this item, not this item. Hmm, how weird. Well, if you think about it, it's actually not that weird. Currently we only have one field that stores the inner iterator.
00:55:32.825 - 00:55:45.073, Speaker A: So we can only keep track of one inner iterator at a time. But in this example, when we call next back, what is the inner iterator? There's not just one.
00:55:45.129 - 00:55:45.345, Speaker B: Right.
00:55:45.385 - 00:56:18.715, Speaker A: Because we're iterating over this thing because we called next. So we're sort of. We have a cursor that's like pointing here to a 2, but when we call next back, what we want is a second cursor, right. That's going to point to B2 after consuming B3. So what this is telling us is that we actually need to have two cursors here or two iterators that we may currently be in the process of going through. So this is sort of going to be like a prefix iter.
00:56:20.935 - 00:56:21.399, Speaker B: Or if.
00:56:21.407 - 00:56:33.399, Speaker A: We will, a next iter and then a back iter. And we're actually lucky here that this works out. We don't need to add double ended iterator to flatten.
00:56:33.567 - 00:56:34.087, Speaker B: Right.
00:56:34.191 - 00:56:58.755, Speaker A: Which would be inconvenient. It would be sad if you could only flatten things that were double ended iterators. And the reason for that is because the inner iterator types are the same. Regardless of whether you go from the front to the back, the type is the same. Okay, so now next iter is going to start out none. Back iter is going to start out none. And our logic here needs to be a little more clever.
00:56:58.755 - 00:57:42.955, Speaker A: What we want is if the next iter is sum, then we want to take the next thing from it is none. Okay, what about this case? So here we have exhausted the. I guess this is maybe flipped from you. Now we've exhausted the iterator that we were at and now we need to move to the next item. Well, if there's a next outer item then great, we just give that next item. But what if. And we might need a drawing for this actually.
00:57:42.955 - 00:58:19.049, Speaker A: So here's a weird case. What? Ooh, why can't I do that? That's kind of sad. Doesn't my thing to move work anymore? My button won't let me move. Well, maybe I can just do this. So here's what's going on. I'M going to draw this iterator in a slightly different way. And I realize I have flipped the colors.
00:58:19.049 - 00:59:01.075, Speaker A: I'm sorry about that. Right, so this is really what's going on. We have the outer iterator which points to, I guess let's make some lines here too. The outer iterator is, let's say currently pointing here, right? And the outer iterator, because it implements double ended iterator, actually points both there and here.
00:59:01.935 - 00:59:02.675, Speaker B: Right.
00:59:04.255 - 00:59:46.115, Speaker A: And when we call next back, we can then set our previous iterator to be this type and we can set our next iterator to be this type. That's all well and good, but now imagine what happens if our back iterator is still pointing at this item, right? This item has not been yielded yet. And then we just keep calling next. So the next iterator finishes looking at this item, right? And then the outer iterator is called again. So that yields this item. And then we start looking at this one and then we finish that. And then we call next again and we get this one.
00:59:46.115 - 01:00:19.635, Speaker A: Now what happens if we call next again? Ideally we should end up yielding this item, right? Because it hasn't been yielded yet. But if we call outernext, outer next will give us nothing because outer next has already yielded like the outer iterator has already yielded all three items. It yielded this one, it yielded this one, and it yielded this one. We initially called next back, so it's going to return none. And the inner, the next inner iterator is also none. We've. There's nothing more for us to look at in here.
01:00:19.635 - 01:01:43.019, Speaker A: And so somehow this means that when calling next, when the outer iterator has been exhausted, you need to start walking the back iterator from the front. So that's what we're going to do here, which is, I guess this is going to be next inner. So if the outer thing does give us a next item, then we just set. Then we do the same thing we did before, right? We just set the sort of front iterator. Maybe we should call these front and back rather than next. Let's do front iter and back iteration. So if the outer iter.
01:01:43.019 - 01:02:09.455, Speaker A: If we're walking forward and the outer iterator gives us another element, then we just set that to be the front iterator. And then we keep going, we just loop. But if the outer iterator stops iterating, it does not give us any more items. Then what we want to do is start looking at the back iterator. And if the back iterator is also none, then we can return none. So question mark is fine here. And then we're going to call next on that.
01:02:09.455 - 01:03:23.735, Speaker A: So this way we're going to, if we get to sort of the end, right, where we've exhausted the outer iterator and there's only one iterator left and that one inner iterator left, and that happens to be at the back, then we're now just going to be calling next on that. And then the same case is going to be true for the back iterator. So here, let me just reuse the implementation we just used. Except here, this is going to be looking at the back iterator and so the front iterator and it's going to call next back rather than next right. It's going to be next back inner because it's going to look at the back of the outer iterator. And if we're walking backwards, backwards, and the outer iterator yields no more elements, then we need to walk the front iterator from the back. And so that's what this is going to be doing.
01:03:23.735 - 01:04:01.965, Speaker A: And if the front iterator is empty, then of course we can just return and what did I mess up here? This needs to be as mute because we don't want to, we don't want to move out of it, we just want to use it as a reference. All right, that was a lot. So let's do questions. Yeah, exactly. So someone observed correctly that the inner references were being reset in each direction. So it gets lost what the end should be. And so that's what we did.
01:04:01.965 - 01:05:06.605, Speaker A: Is there a way to implement it in such a way that you don't need to have to pay the cost of two cursors when the iterator is only used in one way? It's a good question. There is, but I'm not going to talk about it. I think basically the way. Well, I'm not sure. I think you would need specialization for this trick to work, but the idea would be to add a second generic parameter to flatten that is either like that is a some type that implements like walk back and you could give a zero size type to it that does not implement walkback in order if you wanted to use it without supporting double iteration. But you would need, I think, specialization to be able to implement iterator for it. Because when you have, as we observed here, right, like when you have a back iterator, it changes the forward iterator as well.
01:05:06.605 - 01:05:27.681, Speaker A: And so you would need to have a different implementation of Iterator depending on whether or not you had two cursors. Yeah. So this gets back to the question that was raised. Why store back iterator for. Even for types that aren't double ended iterator? And the answer is we don't have a way around it.
01:05:27.793 - 01:05:28.185, Speaker B: Right?
01:05:28.265 - 01:05:57.825, Speaker A: The flattened struct. We don't have a way to say here like not if, like config, not if O implement. O does not implement double entity. Like that's not a construct that we have. Because it's not. It's not just the matter of like defining two different flattened structs because then they would be different types. You don't really have a good way to say this.
01:05:57.825 - 01:06:35.649, Speaker A: Keep in mind though that these will be allocated on the stack. So I mean they don't necessarily have to be, but these are likely to be cheap. Also they're likely to be used as iterators and then dropped as opposed to being kept around for a long time. Great. Let's see. This whole process gives you major future vibes. Yeah, I mean it is a little bit like futures in that, like streams or iterators.
01:06:35.649 - 01:07:20.605, Speaker A: And when you work with these nested iterators, it is very much like working with nested futures or nested streams. I don't think the compiler will optimize away the field. I don't think it can. Yeah, it probably can't. Okay, so now that my brain no longer hurts, I can say that the two cursor problem is a lot easier to solve in Rust than Python. Okay, that's good to hear. I don't know why can you call next and next back concurrently? No, so the reason for this is because they both require exclusive access to self.
01:07:20.685 - 01:07:20.853, Speaker B: Right.
01:07:20.869 - 01:07:42.037, Speaker A: So immutable reference, otherwise known as an exclusive reference. You couldn't call next back and next concurrently. You could call one then the other in either order. But you can't have like two threads that both call it because neither of them would have an exclusive reference. And next, notably here does not require double ended Iterator.
01:07:42.101 - 01:07:42.451, Speaker B: Right.
01:07:42.533 - 01:08:15.797, Speaker A: There's nothing in this body that calls next back. It does have to access the back iterator, but that back iterator will always be empty. If you never called next back, why do you need to use ref mute? I probably don't. Yeah. Okay, so the reason for this is that self.front iter its type is option of a thing.
01:08:15.901 - 01:08:16.381, Speaker B: Right.
01:08:16.493 - 01:08:49.823, Speaker A: So if I do if let some T is self front iter then T here is like if I used T. Right. The type of T here is T, which is an owned T. Right. It's not a reference to. And so this would mean that I have to move out of self front iter, but I only have a mutable reference to self, so I'm not allowed to consume this field and take ownership of T. And so I have two ways to get around this.
01:08:49.823 - 01:09:27.112, Speaker A: I can even write as mute. So as mute goes from an option T to an option mute mute. And now I could get rid of this and it would be fine as mute as this. Because now the. The thing that I'm moving as a mutable reference as opposed to the T itself. I personally find it easier to write this. So this is saying when you take the T, take it as a mutable reference, it's sort of the opposite of this.
01:09:27.112 - 01:10:18.797, Speaker A: We talked about this at length in the previous crust of rust, so I recommend you take give that a look. What if instead of live walking you flatten the entire data into a flattened structure and then iterate over it from both ends. If you did that, you would have to allocate, right? So one thing you could do is in flatten we just walk the entire iterator and collect everything into a vector. But that means you have to allocate all of that stuff. This flatten will work even if this iterator is infinite because it only consumes element while you're calling next, right? So imagine. In fact I can give you an example of this inf. So here's what I'm going to do.
01:10:18.797 - 01:11:03.639, Speaker A: Going to give you an iterator that is infinite. So 0, dot dot will continue yielding iterators forever. And not only that, but the items of that iterator are also themselves going to be infinite. And this will still work. In fact this would be a super unhelpful iterator. Like there's no reason to flatten this because this is infinite. So let's make this like 1 to I.
01:11:03.639 - 01:11:37.745, Speaker A: So the inner one is not infinite, that's fine. But the. If you couldn't flatten this into a vector because this is an infinite list, so what is this going to yield? Well, this is going to yield. So the first outer item is going to be a map of is going to be this. The second outer item which is empty, I think let's make this zero. So the first inner item is going to be the range zero to zero, which is empty. The second inner list is going to be zero to one, which only holds one.
01:11:37.745 - 01:12:04.101, Speaker A: So the first thing we expect to get Is one the next. So that exhausts that inner item. So now we go to the next outer item, which is going to be. So the outers here. So the next outer is going to be two, which gives us an inner iterator of zero to two, which gives us zero and one. So next should give zero. Next should give one.
01:12:04.101 - 01:12:14.745, Speaker A: Just see that. Sanity check. My solution there. Probably wrong. 49. Right. 001.
01:12:14.745 - 01:12:49.755, Speaker A: Great. And you could keep calling next on this for as long as you want and flatten will still work. And notice we did not have to allocate an infinite amount of memory, which it would require if you actually flattened it eagerly. So it's not. Someone pointed out that stream and chat are five minutes out of date. They're not actually. It's just that I'm still catching up with old chat.
01:12:49.755 - 01:13:14.915, Speaker A: Ref mute is inferred by the compiler in many patterns. Now, not all this is an example where it's not. Yeah. So in fact here's a different way the compiler can actually infer this in many cases. So one way you can do this is when you have a pattern. What the compiler is smart enough to do is it will. It will.
01:13:14.915 - 01:13:55.525, Speaker A: Instead of moving, it will mutably borrow if the thing you're matching on is itself immutable borrow. So this will also work. I still prefer refmut myself, but this is equivalent. Next back makes no sense. Yeah. So you couldn't call next back for this infinite iterator. If you tried, the compiler would tell you that next back is not found because this infinite iterator is not double ended.
01:13:55.525 - 01:14:48.045, Speaker A: Does this code work for arbitrarily nested iterators? No. If you wanted for a third level, then you would need. You would need a front front iter, a front back iter, a back front iter and a back back iter because you'd need to keep track of. You're essentially keeping track of a tree of cursors that you're walking. So this is why it gets pretty complicated to make this sort of generic over the number of levels. I don't know of a way to do that. You could probably have a macro that generates it for you.
01:14:48.045 - 01:15:36.015, Speaker A: The way you would probably do this in practice is if you want to flatten further levels. You like basically do some kind of collection. But you can flatten a flattened iterator right? Like there's nothing stopping you from writing. Like let's do like deep. So this is going to be a, I guess a vector vector, A vector of zero and I want the count. I Want the count of that to be one. Well, I want the count of this to be two.
01:15:36.355 - 01:15:36.715, Speaker B: Right.
01:15:36.755 - 01:16:08.707, Speaker A: So I don't want to count these, I want to count these. That's what a three level deep would look like. And in practice, the way this would work out is you would flatten the flatten. I think this should work. Right, so this iterator, this is going to be an iterator that yields these and then you flatten that. And that's going to be an iterator that yields these. Yep.
01:16:08.707 - 01:16:32.991, Speaker A: So you can flatten a flat. Could you detect. Could you nest calls of flatten if it detects more than two levels? No. So keep in mind there's nothing of. None of this happens at runtime. This is a flatten as a compile time construct where you need to give it a type at compile time. It's not like it will just like it can.
01:16:32.991 - 01:17:02.175, Speaker A: There's no way for it to check at runtime how deep the iterator is. This is only written for a two level deep iterator. You could write a. You couldn't even write a macro to do this. I think because you need to know the type. You might be able to do this with some like really fancy type level magic, but you wouldn't generally want to do that. Yeah.
01:17:02.175 - 01:18:01.571, Speaker A: And then the other thing I wanted to mention briefly is the standard library also has a method called flatmap. And flatmap is basically map over flatten. It's not terribly interesting, but it maps over the outer iterator, not the inner iterator. So rather than look like this, it takes an F. Whose? Let me see if I can. Yeah, so it's gonna require like actually, so it takes an F where F is a function from O item to I, where I is the inner iterator and where the inner thing implements into iterator. So this is what flatmap looks like.
01:18:01.571 - 01:18:35.339, Speaker A: So it maps over the outer iterator and the closure that gets given the outer iterator needs to produce iterators itself, which is a. It's an interesting case study. If you want to try to like see that you actually understood this. Try to implement flatmap. And then the last thing we have like 10 more minutes or so is it's sort of annoying for flatten to be a freestanding function. Ideally what we want is if you have an iterator you can just call dot flatten. And of course you can already do this because flatten is a method on iterator.
01:18:35.339 - 01:19:39.085, Speaker A: But imagine that iterator did not have a flatten method and we wanted people to easily be able to use that. What we can do is we can actually use something called an extension trait. So extension traits are not special, they're more of like an idiomatic pattern. So what we're going to do is we're going to declare some new trait iterator X for extension and it is only going to be implemented on iterators and it's only going to have one method and that's going to be flatten. It's going to take self and it's going to return flatten self. There's a lot of flatten in this. That in turn is going to call the top level flatten function with self and it's going to require that self item implements into iterator.
01:19:39.085 - 01:20:43.385, Speaker A: Oh, in fact, this is a fun error message to look at. I'm going to get to that in a second. What this lets you do is if someone uses this trait then and they have an iterator, actually let's do impulse. We do a blanket implementation of this for all t iterator X for T where t implements iterator flatten itself. I'm just writing it out and then I'll explain. So what we're saying here is any type that implements iterator has this iterator extension trait implemented for it. And the way you do it is by flattening the iterator itself.
01:20:43.385 - 01:21:54.807, Speaker A: And the idea here is that instead of having to call flatten you can do, let's give it a different name so we don't end up conflicting with the outer one. So our flatten is that you can now do, instead of this sort of flatten flatten business, you can just do our flatten. Now, this isn't actually compile and the reason is here we require that self is sized. This is a little complicated to explain why we require that. It says the size for values of type self cannot be noted compilation time. But basically when you have a flatten, it takes a value of type o, a type of typo. A typo, it takes a typo and it stores that o in the struct.
01:21:54.807 - 01:22:37.555, Speaker A: The only way you can do that is if it knows how large o is. If o here was like what's a good example? If O here was the name of a trait. A trait itself does not have a size and so it couldn't store that here in this variable, it wouldn't know what size it has. And so O clearly has to be sized. Size is the trait that Rust uses to express that a type has some known size. And because you can only construct a flatten if O is sized, this complains here that the size for values of type self cannot be known to compile time. Basically, self is not sized, because we've said here that we implement this for any iterator, including maybe if that type is not.
01:22:37.555 - 01:23:03.935, Speaker A: Including if that type is not sized, any type. So we can just say where self is sized. And that takes care of that. And I won't go too much into the details of why this is necessary. Let's see if that works. Self is sized. Ooh.
01:23:03.935 - 01:23:50.695, Speaker A: Right. And this is implemented for anything that implements iterator, not anything that implements into iterator. And so for in order to use the extension trait, you need to already have an intuitor into already have an iterator. Nice. Yeah. So ignoring the size bit for a second, hopefully this should make sense that we're defining a trait that only has the method we want to add. We say that that trait extends the sort of base trait that we want to provide an implementation for any implementer of, and then we provide that general implementation, that blanket implementation for any T that meets our bounds.
01:23:50.695 - 01:24:22.725, Speaker A: All right, I think that's all I wanted to cover for flatten. Let's do questions before we end, though. FN or fn mute. FN mute. Yeah. You could then implement flatten as outer flatmap. Inner.
01:24:22.725 - 01:25:17.337, Speaker A: Yes, that's correct. Why not implement the monad laws that. That seems outside the scope of this particular stream. The SEIS bounds is required because you. Well, both because you take self here and because you return, you name the self type. Why do I sometimes see a question mark sized? So, by default, any generic type must be sized because you might store it. But imagine that you store something like a box O.
01:25:17.337 - 01:25:44.015, Speaker A: It turns out here the compiler can store things that it doesn't even know the size of. And you can say that for this, you can sort of opt out of the implicit size requirement by saying question mark sized. So that's what that means. Could you put the bounce on the trait iterator X instead? You could. You could do this. Oops. Sized.
01:25:44.015 - 01:26:12.585, Speaker A: That also works. These are mostly equivalent, but not entirely equivalent, plus sized. T is implicitly sized here. So that works. All right, great. I think that means we're all done. I'm going to go turn on the air conditioning again.
01:26:12.585 - 01:26:25.845, Speaker A: Thank you all for watching. Hopefully that was useful. And just follow me on Twitter and you'll get to learn about upcoming episodes. Thanks, everyone. Thanks for watching. Hope you learned something. And I'll see you next time.
