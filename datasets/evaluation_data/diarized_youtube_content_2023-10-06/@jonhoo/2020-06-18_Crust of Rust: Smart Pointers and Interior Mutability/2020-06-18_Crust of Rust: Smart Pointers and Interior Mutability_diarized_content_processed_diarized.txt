00:00:01.080 - 00:00:26.222, Speaker A: Huh. Alright, nice. Hi everyone. Welcome back to another crust of Rust. This time we're going to be talking about smart pointers and interior immutability. So this is something, it's a little bit of a vague topic, but I want to talk about some of the types. You come across a lot in the rust world that maybe you have some passing knowledge of, but they're just, they're so pervasive and you need to have knowledge of them.
00:00:26.222 - 00:00:58.364, Speaker A: And these are things like Arc RC, Refcell, mutex Cell, the deref and Azref traits, the borrow trait, maybe even things like cow and sized if we get to it. I don't quite know. And I figured the best way for us to try to understand these is try to implement some of them ourselves. And so that's what we're going to do. As before, I do a lot of these streams. I post all the recordings on YouTube afterwards. So if you have to leave during the course of the stream or something, just jump on there.
00:00:58.364 - 00:01:43.490, Speaker A: There are also a lot of older videos online you can go look at. Follow me on Twitter if you want to provide input on these episodes or new episodes, or if you just want announcements of upcoming streams. And to that end, I actually recently added a sub channel to the restation station Discord server. So rostation station is a podcast that is sort of intended to be a Rust community podcast, and I figured it would work pretty well for it to have sort of audio visual content as well. And so the discord right here both has integration with all of the live chat that goes on during the stream. So in theory, people can see here. I'll post the link to the discord in that chat for those of you who may want to move.
00:01:43.490 - 00:02:30.360, Speaker A: And it has announcements for upcoming streams. So here you can see this announcement of my stream. Ryan Levick, who's also a rust streamer, has a stream announced here, and hopefully we'll get more of the rust streamers onto this one server so that there'll be one place where you can get announcements, these streams, rather than having to like go all the way around. And hopefully we can have some useful discussion here as well about, about the streams, the content of them, and where to move forward. And of course go to my YouTube channel if you want to see some of the past videos. I also do these sort of for those who haven't watched them before, I do these longer programming videos as well that you can also find here, such as porting Java's concurrent hash map to rust, as if you want some more in depth, longer videos. Go check those out.
00:02:30.360 - 00:03:21.388, Speaker A: All right, so today we're going to be implementing, well, if we get to it, RC ref, cell and cell, and also discuss Arc and Mutex and maybe also look at things like Sref, Dref, borrow, and cow. We'll see where we get to there. I think we're actually going to start out with Cell because it's the one that is, has the least amount of quirkiness to it. So you'll see the, and as before, like for these crust of rust, they're intended to be a way for you to understand the sort of somewhat more intermediate concepts in rust. And so I'm not assuming you're an expert here. If you have questions, please ask them. Other people will have the same questions as well.
00:03:21.388 - 00:04:03.582, Speaker A: And so just like post in chat and I'll make sure to check it every now and again. And that will, hopefully this will mean that whatever questions you have get sort of persisted in the stream that in the recording of the stream that other people might watch later. So if there's any questions you have, other people will have them, too. Feel free to ask them. And I'll try to try to keep up with the chat as we go. All right, great. So you'll see that the rust standard library has, let's move this over there, has a module called cell, and this module, as the top level common says, is shareable mutable containers.
00:04:03.582 - 00:04:52.770, Speaker A: Now, this might sound a little bit like a weird concept in rust, because in rust you have the notion of a shared reference. This is just like the ampersand, and you have a mutable reference, or an exclusive reference, as it's more aptly described as, which is only one thing has that pointer. And so therefore you're allowed to mutate the thing that you have an exclusive reference to. And so a shareable mutable container sounds a little weird, right? This is something where you have an, you have a shared reference to something, so someone else also has a reference, but yet you're still allowed to mutate it. It should immediately set off alarm bells in your head. But this module is various container types that allow you to do this in a controlled fashion under the constraints where. Where it is permitted.
00:04:52.770 - 00:05:28.600, Speaker A: This is often referred to as interior immutability. So it's a type that externally it looks like it's immutable, but it has methods that allow you to mutate it. The primary two ones, well, the primary three ones you have are cell, Refcell and mutex. Mutex is not in cell. It's in sync, because it uses synchronization primitives that are provided by the operating system or by the cpu to make those operations safe. So it doesn't really belong in cell, but it kind of belongs in cell. And you can really think of a mutex as a type of cell, a type of interior immutability.
00:05:28.600 - 00:06:21.630, Speaker A: We're going to look at cell first because cell is. It provides interior immutability in a kind of interesting and very rusty way. And it's a good segue into some of the more advanced things we're going to look at first. Any questions about interior immutability or, like, exclusive or shared references just before. Before we dive into cell? Hopefully it should strike you as odd that we can mutate things through shared references in rust that seems antithetical to what shared references imply, even though in reality there are ways to do this. All right, I don't see any questions, so let's move forward with cell. Okay, so a cell.
00:06:21.630 - 00:07:08.120, Speaker A: Can cell be used for recursive type storage? Depends what you mean by recursive type storage. You can store any type in a cell, if that answers your question. If we could outline why using one versus the other would be great. Shared mutation sounds fine, but there seemed to be a number of specialized tools to a similar problem. Yeah, so one thing you'll see as we go through this is what are the restrictions of the different cell types, the different interior immutability types. So cell refcel and mutex have different restrictions on what things you can stick inside of them and how you can use them. And generally, like, the farther you go towards mutex, the freer you are to put whatever you want inside.
00:07:08.120 - 00:07:48.116, Speaker A: But the cost, the overhead of doing the required logistics to make the type work out also increases. So I'll discuss that a little bit as we go through. The types box does not provide interior immutability. If you have a shared reference to a box, then you cannot mutate the thing inside the box. Is there a way to tell that a supposedly immutable struct has some stuff inside it that is mutable, like a cell? No. You do not know externally from a type whether it has interior immutability. All right, so let's dive into cell.
00:07:48.116 - 00:08:39.858, Speaker A: So cell is kind of interesting. If we look down at what cell provides, you'll see that, perhaps unsurprisingly, you can create a new cell and you give it a value of some type t. You can also change the value by calling set, and you'll notice the set has an immutable reference, but it still allows you to modify the value that's contained within the cell. It also has a swap method, which lets you take references to two cells and swap the values are inside of them. There's a replace, there's an into inner that consumes self. So assuming you have ownership of the cell, which of course means that there are no shared references, and then we get down here and you'll see that cell where the type is copy, has a get method, and you'll notice the get does not give you a reference to the thing inside the cell. Instead, it copies the thing that's inside the cell and gives you a new copy of that value.
00:08:39.858 - 00:09:20.278, Speaker A: But you do not get a reference inside the cell. And in fact, if you were to look through all the different methods on cell, you would see that there is no way with cell for you to get a reference to what's inside the cell. You can replace it, you can change it, and you can get a copy of it, but you can never get a pointer into the cell itself. And this turns out to be important. Think of it this way. If, if there's no way for you to get a reference to a cell, to the thing inside a cell, then it's always safe to mutate it, right? Because if no one else has a pointer to it, then changing it is fine. Does that make sense? Think about that for a second.
00:09:20.278 - 00:10:06.048, Speaker A: If no one, if we know no one else is a pointer to the value we're storing, then changing that value is fine, right? And that is what cell tries to provide. Just by virtue of the, of the method signatures that it provides. It never gives one out, and therefore it knows that no one has it. The other restriction that cell has in order to make this safe is that cell, you will see, does not implement sync. And what this means is, if you have a reference to a cell, you cannot give away that reference to a different thread. And the reasoning for this is pretty straightforward. If I had two threads that both have an immutable reference to the cell, a shared reference to the cell, then both threads could try to change the value at the same time.
00:10:06.048 - 00:11:08.498, Speaker A: And that is obviously also not okay. But if you have both of those restrictions, if you know that there's only one thread that has a pointer to the cell, then you also know that if, if I have a shared reference to that cell, then no one, no one has a shared reference to the value inside the cell. So it's safe to change it, as long as I don't give out a reference to what's inside the cell. There's a lot of words, so let's check in on whether that made sense before we continue. All these guarantees are at compile time for cell, by the way. All right, let me just open a window. Question, why can't we borrow as mute more than once for RC if it's on, there's no rc here and there's no borrowing.
00:11:08.498 - 00:12:20.450, Speaker A: So with a cell, there's no, there's, you never use an exclusive reference. In general, with a cell, if you have an exclusive reference to the cell, you can get an exclusive reference to the value inside, but at that point you can't get or change the value, right. In the example you mentioned, you say if there's a single thread and there's no need to worry about multiple references to a cell. In that case, what benefit does using cell provide? So the benefit that cell provides is that you can have multiple shared references to a thing. For example, you can store, usually cell is used with something like rc where you want, you want the cell to be stored in multiple places or pointers to it be stored in multiple places, like in some data structure, like imagine a graph where some of the things might share a value, right? Then you might have multiple references to a thing, but because it's single threaded, you know that you will only be using one of the reference at a time. And so what cell lets you do is in safe code, lets you mutate that value. Cell should usually just be used for small copy types.
00:12:20.450 - 00:13:16.990, Speaker A: Yes. You notice that you can only get the value out of a cell either if you have a mutable reference to it, in which case where you probably don't need the cell at all, or if, or if the value is copy. And so you generally want to use cell with types that are copy and that are relatively cheap to copy to copy out, because that's the only way you can get their values. Is there a sync version of cell? No, I don't think you can do this just with the type system if you don't rely on sync. Okay, so let's try to implement cell ourselves. That's usually a good way to like understand any of these things. So a new lib, and we're going to call this pointers, why not? Okay, source lib.
00:13:16.990 - 00:13:56.540, Speaker A: We're going to get rid of that. We're going to do a mod cell and we're going to do cell rs. All right, so we're obviously going to need a pub struct, I guess pub mod cell. So we're gonna have a cell type. It's gonna hold a t. We're gonna have to figure out what's inside here. Let's for now, just assume that it's gonna be a t and we're gonna implement for cell, it's gonna be a new, which takes a value of type t and returns the self.
00:13:56.540 - 00:14:30.610, Speaker A: And that gives us a cell that contains the value that was given. We're going to have, I guess this is going to be pub. We're going to pub fn set, which is going to take an immutable reference to self and a value t. And it is going to do self dot value equals value. This of course, currently will not work. Right. We're trying to, we're trying to assign to self dot value, which is behind a shared reference, and so we can't modify it.
00:14:30.610 - 00:15:07.132, Speaker A: And we want to do a get self, which is going to return a t, and this is going to be self dot value. This is like the basic API we're going for. Right. But remember that part of the, part of the, well, okay, let's, let's try to figure out how we might actually do this. So at the core of almost all of these types to provide interior immutability is a special cell type called unsafe cell. So if you go back to the, to the browser. Let me zoom in a little bit here.
00:15:07.132 - 00:15:47.200, Speaker A: That might help. If we go back to cell, you'll notice that there is one called unsafe cell, which lists itself as the core primitive for interior immutability in rust. And core cell is unsafe cell is, is totally unsafe to use. It really just holds some type and you can random, you can get a raw, exclusive pointer to it whenever you want. And it's up to you to cast that into an exclusive rust reference when you know that it's safe to do. So it's sort of a building block, right? So here we're going to use cell unsafe cell. And so the value here is going to have to be an unsafe cell.
00:15:47.200 - 00:16:55.444, Speaker A: That's the only way that we can actually, from a shared reference, that we can mutate something through that shared reference is by using unsafe cell. Is there a classic example of when someone would want to use cell? It's usually used for smaller values, like, usually things like numbers or flags that need to be mutated from multiple different places. So for example, it's often used with thread locals, right? So with a thread local, you know that there's only one thread accessing it. And you might want to keep some thread local, state, like a flag or a counter or something. But the thread local only gives you shared, a shared reference to that thing, because one thread might try to get the thread local multiple times and then sell is a good way to provide mutability to it. Why does cell have an as pointer method that gives you a pointer, a raw pointer to the thing inside the cell, right. But trying to bring that back to a shared reference would be unsafe.
00:16:55.444 - 00:18:02.818, Speaker A: And so it's fine for cell to expose the raw pointer because you can't do anything with that raw pointer unless you write an unsafe block. Alright, so the value here is going to be just unsafe cell new value. So that's fine, that's not too bad. And here what we're going to do is so unsafe cell has a get method, and the get method takes a shared reference to self and gives you a raw exclusive pointer to t, right? And so what we're trying to do is this, and similarly here, going to do dot get star. The code I'm writing now is currently incorrect and we're going to see why it's incorrect. So here we're trying to dereference a raw pointer and the compiler is telling us that that is unsafe and rightly so, right, where we have a shared reference to this unsafe, this t and there's, the compiler doesn't know that it's okay for us to change that value. It doesn't know that no one else is currently mutating that value under us.
00:18:02.818 - 00:18:52.370, Speaker A: For example, it doesn't know that there's not some other thread somewhere that's changing this t that we're trying to dereference at the same time. And so if we write unsafe here, what we're doing is we're telling the compiler, I have checked that no one else is currently mutating this value. And if we just did this like this is just wrong. But what we're currently doing is simply wrong. Uh, well how do I want to do this? That's fine, because even though we have said unsafe here, so the compiler accepts it, the code is just wrong. There's nothing preventing some, there's nothing preventing currently the following from happening. That's sometimes useful to do this in a test driven way.
00:18:52.370 - 00:19:37.420, Speaker A: Right? So let's do a simple test here. Bad. So this is gonna use super cell, it's gonna do cell new of 42. And then we're gonna do like a thread spawn. Threadspawn won't actually let us do this, which is a little awkward. Let's do like an arc new of a cell new. We haven't talked about Arc yet, but it basically lets us share a reference to something across thread boundaries.
00:19:37.420 - 00:21:06.360, Speaker A: X dot set 43. And in this thread we're going to do x set 44 sync arc. There's a little bit of setup here, but clone x, right? So currently nothing stops a developer from writing this code, right? To start two threads, well, it actually will be prevented, but that's annoying. So here, we haven't written anything here to prevent this from happening. Right? To have two references to the same cell and then two different threads, both called set at the same time, and this unsafe is us just telling the compiler that's fine, but it's not fine, right? If two threads try to write to a value at the same time, what value does that thing now have? It doesn't have a well defined value, and so this is not okay. Instead what we need to say is we need to basically implement not sync for cell t, right? We need to tell the compiler that you can never share a cell across threads. This is what we talked about for sell when we initially looked at the API for it.
00:21:06.360 - 00:21:57.590, Speaker A: The compiler has support for the syntax, but it's nightly only. The way you get around for this for now is you basically stick a value in there that is not thread safe. And guess what is not thread safe? Unsafe cell itself. So it is not sync. And so we actually already get this implementation because unsafe cell is not sync and therefore cell is not sync. So this is implied by unsafe cell, which means that this unsafe is actually now okay, and this code will be rejected. And if we try to run that code, let me get the compiler error a little larger.
00:21:57.590 - 00:22:59.490, Speaker A: Fine, let's do this. Is, this is just to get it to compile. Er, fine. I was hoping to do that later, but if I now, if I now try to compile the test, you'll see that it says unsafe cell cannot be shared between threads safely and specifically tells us within our cell type, sink is not implemented for unsay cell, which means that cell is not sync. And so even though we tried to pass it to multiple threads that did not work as intended, this is a little bit of a roundabout explanation. So let's pause here before we move on. All right, this was a lot, so let me try to walk through it one more time from the top.
00:22:59.490 - 00:24:00.370, Speaker A: The cell type allows you to modify a value because through a shared reference, because no other threads have a reference to it, and so you can't have multiple concurrent modifications and because you've never given out a reference into the value you store and therefore you can replace it just fine. Right? So because get here returns a copy of the value that's stored inside. We didn't, we never gave out a reference. And so even if we change the value, we don't have to invalidate any references because there are no references outside. And this is why this code doesn't compile, because here we're trying to mutate the cell from two places at the same time. And to give another example of what, what wouldn't work and what cell defends you against bad two. So here I'm just gonna have a single thread and show you why a single thread can also go wrong.
00:24:00.370 - 00:25:11.460, Speaker A: So here we're gonna do something like a vec 42. So here, imagine that I do first is x. Imagine that cell allowed you to get a reference out, right? Then I could do this to get a reference to the first thing inside the vector, and then I could do set vec blank or whatever, right? And now, even though this is single threaded, if I now tried to say printhead first, even if I now try to, even though this is single threaded, this is clearly not okay, right? Because here first is a pointer to this 42. Once I call this set, that vector is gone as a first should be invalidated. So we can't allow this code either. And the way that we don't allow this code with, with cell is by get not returning a reference. Get only returns a copy and we never give out a reference, which means the set is always safe.
00:25:11.460 - 00:26:13.088, Speaker A: All right, let's see if what we've done so far makes sense. Can you unsafely implement sync to show your test failing? Yes, I can impl for cell taiden. So we can, we can say that, in fact we could if we want to. Here's what I'm going to do here. I've removed all the safety restrictions, so now these tests are both going to pass, or, sorry, are both going to compile. Right? So if I now try to run the tests and run bad two. Oh, right.
00:26:13.088 - 00:26:48.990, Speaker A: I need to actually mark them as tests. That's a good idea. So let me try to run bad two here. That's interesting. That should definitely not work. Oh, I wonder. It's because it doesn't actually get deallocated.
00:26:48.990 - 00:27:37.980, Speaker A: Let's do box new instead. Or string. String is good. Hello. So we're going to replace it with an empty string and then try to print out the original string. Why does this work? I think what's happening here is that, is that the, even though the memory has been deallocated, the pointer is still valid. So if I try to do this, that might no capture.
00:27:37.980 - 00:28:20.450, Speaker A: Why is it not printing this out? Yeah, so see here for example, so in this test, we create the string hello. We make our cell point to it, we get a reference to that string. So this should now point to hello. Then we change that value. And now suddenly the pointer that we initially took out is now pointing to world instead, even though that's a completely different allocation. And so this should print a low but doesn't. All right.
00:28:20.450 - 00:28:59.500, Speaker A: Yeah. It's basically the allocator didn't release the memory, so the pointer is still valid. But you should, hopefully you see why this shouldn't be okay, right? Because this is a pointer to this memory. And once we change this, once we allocate some new string here, then this memory should be deallocated, it goes away and this pointer is invalid. It happens to still be valid because of the memory system. And that's why this isn't crash. But if this was a larger, more busy application, that would not be okay.
00:28:59.500 - 00:30:14.490, Speaker A: All right, so we want to disallow this and the way we disallow that is by never giving out a reference, right? So we want get to only work when the type is copy and then we give out a copy of that value. And now this won't compile because you can't get that reference in the first place. And this case, the case where you have multiple threads, this one is probably not going to fail easily. Like it's going to be hard to write this as a test that fails. But maybe the way to see this is what's a good way to demonstrate that this is broken. There isn't really a good way to demonstrate that this is broken, even though it is, because so the two threads are both going to modify the value in place. And the problem is you don't know what value it's going to be set to.
00:30:14.490 - 00:31:18.170, Speaker A: Maybe the way to do this actually is to have this be a array. It's going to be zero, 1024 zeros. And this is going to set it to be 1024 ones. And this is going to set it to be 1024 twos. And we're going to do so we can have one thread that tries to set the whole value, the whole array to be one and one that's going to set the whole array to be two. Let's make this larger, take a little bit longer, and then we're going to wait for both threads to finish and then we're going to print out the value that ends up being stored in there. So that's going to be X dot get Br.
00:31:18.170 - 00:32:26.690, Speaker A: That's awkward, I guess, for I in X dot get reprint, the x dot get. See what happens if we run this. That doesn't seem right. X get is not an iterator. Fine. Like this then. So we scroll up here, we'll see that.
00:32:26.690 - 00:33:11.860, Speaker A: Let's see if we find any that are broken. Are all of these set to one? Because if so, that undermines my point. Yeah, they might all be, which is awkward, actually. Here's what we're gonna do. We're going to do sort unique c. Sorry. This is great.
00:33:11.860 - 00:33:49.678, Speaker A: Okay. This printed all of them as twos. Sometimes, though, this really ought to not do that. Make it a little larger. Stack overflow, you say? I'm just trying to make it large enough that the threads start interleaving. Apparently it won't let me do that. Okay, I guess in that case I'm going to have to argue why this is problematic.
00:33:49.678 - 00:34:26.579, Speaker A: So the problem here, right, is this thread is going to be writing out this long array of ones. This thread is going to be writing out this long array of twos. Both of them are going to take a while, and we're allowing both of them to be modifying the same bit of memory, right? The same memory that's stored inside the cell at the same time. So we have no guarantees that these threads aren't going to be stepping on each other. Right? Imagine like this thread runs for a while, then goes to sleep. Then this thread runs for a while, and then it goes to sleep, and we'll see an interleaving of ones and twos. In this particular case, that the test, when we run it in practice, doesn't fail.
00:34:26.579 - 00:34:58.222, Speaker A: And the reason it doesn't fail is because of the underlying memory system being fast enough that these interleaving store don't actually show up. But this is something that can happen. And then if it happens, you basically can think of this as we're going to end up with a corrupted array. We're going to end up with an array that contains some ones and some twos, even though nowhere did we set that to be the value. Right. We expect at the end of this test for the entire array to be ones or the entire array to be twos. We do not expect it to be interleaved.
00:34:58.222 - 00:35:53.860, Speaker A: But the way we've set this up, that could happen if the threads start yielding inappropriately. Yeah, the, so there's a, there's another way for us to demonstrate this. Which is? Which would be this. Imagine that this thread does X equals x one, get X one dot set, x plus one. This is like the silly way to do this, right? X two, I'm going to do this, this is just going to be zero, and we're going to do this 100,000 times. Maybe this is a better way to demonstrate it. You're probably right.
00:35:53.860 - 00:36:33.544, Speaker A: And we're going to assert that when we get out the value, it's going to be 200,000, right? Because each thread is incrementing by 100,000 times. So hopefully by the end it should be 200,000 and we're gonna stick in here. Thread yields might not even be, it's too tight of a loop, the computer is too fast. I doubt this will actually pick up, but we'll see. Let's try to run this. Great, it failed. Fantastic.
00:36:33.544 - 00:37:31.370, Speaker A: It expected the value to oh, I need to add a zero to this, but it will still fail. Great, it failed. It expected the value to be 2 million, and instead it was this lower number. And the reason here is because the threads are, the threads get to race. They are both modifying this value, and so some of the modifications end up being lost, because one thread writes its value and the other thread writes its value, and they both read before, they both write before they read again. All right, hopefully I've sufficiently convinced and confused you that this implementation is necessary. So specifically because cell, if we declare cell as not being sync, then now this code won't compile because it'll recognize that we're trying to share the cell across threads, and that's not okay.
00:37:31.370 - 00:38:53.610, Speaker A: And so really, if we, if we want to do this sort of the proper way, we're going to document why this is safe. We know no other, no one else is concurrently mutating self dot value because not sync. And we know we're not invalidating any references because we never give any out. Similarly here, safety, we know no one else is modifying this value since this, since only this thread can mutate because not sync and it is executing this function instead. Right. A given thread can only do one thing at a time, and because we know it's not shared between threads, and we know that it's calling get because we're in get, that means set is not being called, and so therefore this value is not being modified. Okay, so hopefully this should explain why cell is safe.
00:38:53.610 - 00:40:00.410, Speaker A: Actually, I guess I can leave those tests in, in theory, but okay, does cell make sense? We went back and forth on a bunch. I apologize for that, but sometimes happens. What is the point of allowing t to be non copy if we only have the get method for copy types. Or you're saying up here, why not do this and require it? Or why not do this and require it for the whole thing? We could totally do that. Generally, the only thing that requires it is the get method. And so far the idiomatic rust way is to only put the bounds where they're needed. This is usually, you usually don't want it on the type, because then any type that contains the cell would also need the copy trait, and it ends up just putting a bunch of extraneous bounds all over the place.
00:40:00.410 - 00:41:12.090, Speaker A: Putting it only in the most constrained space means that callers only have to put it where they are actually using the cell themselves. Would you be able to give a quick explanation of what's under the hood in unsafe cell? And can you explain why we need unsafe cell and cannot just unsafely cast the shared reference to an exclusive reference? Yes, this is an important point. The only way in rust to correctly go from a shared reference to an exclusive reference is with unsafe cell. You are not allowed to cast a shared reference into an exclusive reference, it's just not allowed. The only way is through unsafe cell. The reason why that's true is a little complicated and comes down to the way that the rust compiler optimizes your code and how it interacts with LLVm, for example. But you are never allowed to cast a shared reference to an exclusive reference, just ever, except by going through unsafe cell.
00:41:12.090 - 00:41:54.420, Speaker A: If you do, the compiler might optimize your code in such a way that it breaks. All right, so that was cell. Now let's move on to refcella. So Refcell is a little different. Unsafe cell is really just, it's just a t. But with the compiler has special knowledge of unsafe cell, cell does not have any special compiler instructions. No, unsafe cell is a special type, but cell is not.
00:41:54.420 - 00:43:03.102, Speaker A: All right, so ref cell, let's go back to our documentation here. So refcel is a little different. If you look at the documentation, you'll see it says immutable memory location with dynamically checked borrow rules. So normally in rust, all of your borrow checking is done at compile time, right? Either you have a shared reference, in which case you cannot mutate, or you have an exclusive reference in which you can mutate, but those are all determined at compile time. What Refcell lets you do is basically it lets you check at runtime whether anyone else is mutating. This is really handy if you have a value that appears like you're traversing a tree or something, or you're traversing a graph where there might be cycles and you are like, it might be that earlier in your recursion you already got immutable reference to this thing, but later down you're trying to take immutable reference to the same thing and refcel will catch these cases. But imagine that you have a graph that you know has no cycles.
00:43:03.102 - 00:43:42.814, Speaker A: So you know that you have like checked your graph that it has no cycles. But this is a runtime check. And so you know that you can always get immutable reference to any given node, but the compiler doesn't know that because the graph is not known at compile time. So Refcel is a way for you to get safe dynamic borrowing. Dynamically checked borrowing, yes, exactly. So Refcell is a good use case for things like graphs and trees. And in fact, Refcell is fairly straightforward.
00:43:42.814 - 00:44:58.380, Speaker A: So Refcel is type that is basically also just a use unsafe cell. It is basically also just an unsafe cell of t, but it also has this special value that keeps track of how the thing is currently borrowed. We're going to call this, I guess, flag references. Let's make it an eye size. And what we're going to do for Refcell is that Refcel is going to have a new shake a value t and gives you a self like standard setup stuff, right? And the reference is basically going to be a reference count. It's going to be how many references have we given out to this thing and of what type? And think of it as a positive number is going to be how many shared references are there? And of course that number can be any value. Like there can be zero to a million references or to however many.
00:44:58.380 - 00:46:10.652, Speaker A: It's basically infinite, right? And there can only be ever be one exclusive reference because this is what the rust ownership system requires that we guarantee. And so we're going to have a method called borrow, which is going to take a shared reference to self and it's going to give you an option. Let's for now go with an option reference to t, and then we're going to have a borrow mute, which is going to do this. And additionally, let's just make these be none. So this is the basic API we're going for, where if you try to mutably or exclusively borrow a ref cell that has already been borrowed, whether exclusively or not, then you'll get a none back because the compiler is not, or we're not willing to give you another exclusive reference because that would violate the reference rules in Rust. If you try to borrow then you will get a sum unless an exclusive borrow has already been given out, because we want to guarantee this contract. Rust has of if you have a shared reference, then there are no exclusive references.
00:46:10.652 - 00:47:39.360, Speaker A: And if you have an, if you get an exclusive reference, there are no shared references. And so that's why this has to be an option. Does this API roughly make sense? We're going to make it be eye size, because it needs to also handle the case when there are exclusive references. It can be an enum instead, if you'd rather have it be an enum, like, in fact, if we want to be a little bit more explicit about this, we can say ref state, which is going to be either it's going to be either unshared or shared with some count or exclusive, and this is going to be a ref state. Maybe that's easier. Why can't we use the borrow and borrow mute trait here? The borrow and borrow mute traits are for something very different also. You'll see why in a moment.
00:47:39.360 - 00:48:50.850, Speaker A: Okay, so it looks like the rough API makes sense, so let's try to actually write one of these. Right? So what is borrow going to do? Well, it's gonna depend on the state of self. Basically, if the if self dot state is ref state unshared, then we're going to give out, and then we're going to give out this, and otherwise we're going to give out nothing, right? So if it's currently hasn't been shared, then we're willing to give out the value. Otherwise we're not. And borrow is going to be a little bit similar in that it's going to be if it is currently oops state. If it's currently unshared, then we're fine to give it out. Right? Because no one else has a reference.
00:48:50.850 - 00:49:38.330, Speaker A: If it's currently shared with some number, then it's also fine to give out. And if it's currently exclusively borrowed out, then it's not fine to give out. So if we've given out an exclusive reference, if we've given out an exclusive reference, then it's not okay to give out a shared reference. Similarly, if we have given out any reference, then it's not okay to give out an exclusive reference. Right? So this is really just us typing up the rust rules for references. I don't think this is deviating from the refsal API. I've simplified it because I want to explain why we can't simplify it this way, as you'll see shortly.
00:49:38.330 - 00:50:20.456, Speaker A: So there's one thing that's yeah. So there's one thing that's obviously missing here, and that that is that we're not doing any rough counting, right? Like we're never changing self dot state. And so this is clearly not okay right here. If we give out an exclusive reference, that we need to set self dot state to be exclusive. Right? And similarly, if, if it was unshared but we give out a shared reference to it, then we need to set that it is now shared. And if it was shared and we give out another shared reference, then we need to update the reference count. Right.
00:50:20.456 - 00:50:50.862, Speaker A: So that's certainly one thing that was missing. So. But of course this won't actually work because we have a shared reference to self and we're trying to mutate something that's inside of that shared reference. And so this won't work. Well, one thing you'll notice here is that we're modifying ref state here in a way that's not thread safe. Right. If you had multiple, this is basically another instance of the problem we saw before.
00:50:50.862 - 00:51:46.674, Speaker A: If multiple threads were allowed to borrow at the same time, they might both read the old n. Both set the new n to be n plus one, but you would end up losing one of the increments. Right? So this can't, this type just cannot be thread safe. So where this also, just like cell is not sync. But if this type is not sync, and we need some way to mutate state in a place where it's not thread safe anyway, well, we can just use cell. So in fact, what we can do here is we can make this a cell. Because if you think about what we talked about for cell, cell doesn't like the restrictions for cell is that it's not thread safe, which is fine, because ref cell is also not thread safe.
00:51:46.674 - 00:52:10.180, Speaker A: It doesn't allow us to get references to the thing that's inside. And that's fine. Ref state can easily be copy, right. Nothing really preventing us from that. Great. So why don't we just use cell? Right? Because cell gives us the ability to mutate something through a shared reference. So it gives us exactly the thing that we need.
00:52:10.180 - 00:52:51.220, Speaker A: So someone's asking, could you use an atomic ice to make it thread safe? We'll talk about that when we get to mutex. Mutex is basically a well rw lock. And mutex are basically thread safe versions of refcel. So we'll get to that later. Okay, so let's use create cell. Use the cell type we just made. Because why not use the thing we made ourselves? Right? So cell, new this is going to be a dot get and this is going to be a dot set.
00:52:51.220 - 00:54:00.004, Speaker A: Great cellception. Yeah, that's right. Okay, so now we can write the safety argument here, right? So no exclusive references have been given out since state would be exclusive. And similarly here, this is also safe for the same reason. And no exclusive references. Actually, that's not even necessary. And down here for this, no other references have been given out since then.
00:54:00.004 - 00:55:08.590, Speaker A: State would be shared or exclusive when using something like Rayon would refcel cell. Make no sense. Yeah, with rayon you need something that's thread safe and this is not thread safe, so you need mutex or rw lock or some other sync primitive, right? So as chat just observed, the problem here is that we're increasing these, but we're never decreasing them. So if you wrote this code, the moment you exclusively borrow something, you can never borrow it again, which seems kind of useless, right? Like the moment I stop having this exclusive reference, I want to be able to get shared references again. Otherwise this whole data structure is kind of useless. And so this is why we can't really have these be just shared references and exclusive references because we have no way to track when they go away. And so really we need some other type here as we're going to do is we're going to use a ref type and a ref mu type.
00:55:08.590 - 00:55:51.480, Speaker A: And let me define those down here. So a ref is going to have a lifetime that points to the ref cell, right? Because when the ref cell goes away, we certainly need to make sure that all of the references have gone away. Otherwise those references would have dangling pointers. So that's not okay. And we're going to have to figure out what actually goes in here. And the same for ref mutezhen. And what really are these? Well, these are really, really, they just contain a reference to the ref cell.
00:55:51.480 - 00:57:16.470, Speaker A: That's all they really need to hold, right? And now what we can do is we can implement a cell implement t drop for ref, right? So we want to implement drop for it. And when you drop a ref, then we want to decrement the reference count. So what we're going to do is let, we're going to do a match on self ref cell get. And if it is actually dot state, dot get. And if it's a ref state exclusive, then that should be impossible, right? The ref is a shared reference and so the state must be shared because otherwise how do we get here in the first place? So that shouldn't be possible if it's a ref state. Unshared that should also be impossible because we have a shared reference. So clearly it's not unshared.
00:57:16.470 - 00:58:39.130, Speaker A: Right? So these two aren't possible. But what about shared? Well, if it was marked as being shared with one reference, well then now it is unshared. When this thing goes away, refstate, unshared. And if it's shared with some higher account, and I guess, well, let's leave that for now, then we're going to share it with refcount. One lower is that tracking makes sense, right? So anytime we give out, every time someone borrows a shared version of our inner value, then we increment the count and we return one of these refs. And when that ref is eventually dropped, then we decrement the count and set it either to n minus one or two, unshared if there are now no shared references. All right, questions about this, right? So this ref type, let's just make this not be.
00:58:39.130 - 00:59:45.550, Speaker A: So we're going to return some of ref where the ref cell is self. And same thing here. But now if the user gets a ref, how do they actually get to the t? Right? Like previously we gave out a shared reference to the t, but now they're just given this weird ref type. And really if they borrow, what they want to do is get to the t. And the way that we solve this problem is that we implement the D ref trait. So I'm going to stick that out for a second. So we're going to implement standard ops draft for ref of t.
00:59:45.550 - 01:00:41.230, Speaker A: And the so d ref is basically the trait that gets invoked whenever you use the dot operator. So if you have something of type t and you do like that value dot and then some method, then if t doesn't have that method but d refs to something that does, then the D ref trait gets called. It's basically a way to get sort of automatically follow deeper into a type. And this will make a little bit more sense once you see the signature, right? So for the deref trait, what you're saying, what the deref trait requires you to give is the following signature. Given a reference to self. Give me a reference to this target type. In this case, the target type is t.
01:00:41.230 - 01:01:54.810, Speaker A: What this allows you to do is if you have a ref of t, then you can call any method that requires a ref of t on it. It basically, it dereferences into that inner type t. So basically in this point, ref is a smart pointer, right? It's a pointer that dereferences. That is really just a transparent pointer to some inner type, but it has additional semantics when you drop it, which is basically what a smart pointer is, and then the question becomes, how do we actually get the value? Well, doing that is pretty straightforward. We just get the value inside the ref cell. We have to update the safety argument a little, though, to say that the ref is only created if no exclusive references have been given out. It's good to get into the habit of like writing these out, since we once it is given out, state is set to shift shared, so no exclusive references are given out.
01:01:54.810 - 01:03:06.384, Speaker A: So dereferencing the dereferencing into a shared reference is fine. Is the argument here d ref automatically does the arrow operator from circumental? Yeah, you can think of it that way. And we basically want to pull the same trick for ref mute, right? So let me go ahead and copy all of what we just did for ref. We're going to make this ref mute, and ref mute works much the same way. It will also implement d ref implement draft, but it also has to implement draft mute. So d ref mute is a similar trait to d ref, except that it says that you can go from immutable reference to the smart pointer type and get a mutable reference to the inner, the pointed to type. And this is true for ref mute, but it's not true for ref.
01:03:06.384 - 01:03:59.810, Speaker A: Right? So the reason it's not true for ref is because there can be multiple refs to the same value. And so us giving out a mutable reference to the thing inside would not be okay, because that way, if I have a ref to a thing and you have a ref to a thing, and we both tried to do draft mute, we would now both have a, an exclusive reference to the inner value, which of course is not correct. That should never be legal in rust. Whereas with ref mute here we can, we can write the argument better, right? Which is a ref mute is only created if no other references have been given out. Once it is given out, state is set to exclusive, so no future references are given out. So we have an exclusive lease on the inner value. So dereferencing is fine.
01:03:59.810 - 01:04:54.018, Speaker A: Mutably or exclusively. So mutably dereferencing is fine. And the safety here is c safety for DRfmute is it common practice to write safety comments for every unsafe use? Yes, I highly recommend you do this. People vary a little bit in how they do this. You can look at the stream that I did a while back, porting Java's concurrent hashmap to rust. We did a lot of this, but in general you should make sure to document all your safety requirements, both where you write unsafe and for the module as a whole. Okay.
01:04:54.018 - 01:05:45.464, Speaker A: And then we need to implement drop for ref mutever. And this one is also pretty straightforward here, shared or unshared should not be possible, right? It should not be possible for us to get, for the ref cell to be in a shared state because we have an exclusive reference. And it shouldn't be possible for it to be unshared because we have an exclusive reference. So it must be in the exclusive state. And now we're going to be, when we drop our exclusive reference, we now know that it's unshared. And of course here we now need to do ref mute of refcell. And notice here that there's nothing stopping people from writing code here that will crash.
01:05:45.464 - 01:06:37.960, Speaker A: Right. They can unwrap this option all they want, but there's no way for them to get two exclusive references to some inner value at the same time. Okay, does ref cell roughly make sense? Hopefully this was a little bit more cogent than the explanation of cell. Should borrow mute return a ref mute? Yes, does it not? It does. Great, they both make sense. All right, perfect. So now we're going to get to RC, and RC is a little bit trickier.
01:06:37.960 - 01:07:26.760, Speaker A: So let's do pub mod RC. Okay, so what is RC? Well, let's go back to our documentation here. So RC is a single threaded reference counted pointer, and the type RCT provides shared ownership of a value of type T allocated in the heap. Invoking clone on RC produces a new pointer to the same allocation in the heap. And when the last RC pointer to a given allocation is destroyed, the value stored in that allocation, often referred to as the inner value, is also dropped. Shared references and rust disallow mutation by default, and RC is no exception. You cannot generally obtain immutable reference to something inside an RC.
01:07:26.760 - 01:08:37.893, Speaker A: If you need mutability, put a cell or ref cell inside the RC, which is what we've already talked about before. So an RC is in some sense similar to a ref cell in that it keeps count of references, but it's dissimilar in the sense that it never provides mutability. All it does is allow you to have multiple shared references to a thing and only deallocate it when the last one goes away. This is also useful if you have things like usually this is useful in data structures where you might have one element be present in multiple places. So imagine a best example of this. Imagine that you have some string in your program, and that's some large binary blob or a configuration or something. You don't want to keep multiple copies of that blob around in your program, you just want to keep like pointers to it.
01:08:37.893 - 01:09:09.710, Speaker A: But the problem becomes, how do you know when to deallocate that big blob? Well, the answer is when all the pointers go away. But how do you know when all the pointers go away? And this is what RC gives you. But crucially, RC is also not sync, it's also not send. We'll get back to what that means in a second. But basically RC is not thread safe. So it will only do reference counting on a single thread. But even on a single thread this is useful often, again in the context of data structures or things like graphs.
01:09:09.710 - 01:10:14.690, Speaker A: How does RC handle cyclic references? It doesn't. If you have a cycle then the cycle just prevents it from being dallocated. Generally, though, especially if you look at the standard library implementation of RC, you have weak pointers and strong pointers. We're not going to implement them because they're not that interesting. But basically the difference is a weak pointer will not prevent the thing from being deleted, whereas a strong pointer will. So if you have, if the strong pointer count goes to zero, then the thing is de allocated and weak smart pointers will, you basically need to upgrade them to a real pointer before you use them and that upgrade will fail. All right, so what is RC? Well, RC is basically a pointer to some type t, right? That's stored on the heap.
01:10:14.690 - 01:11:30.210, Speaker A: It needs to be stored on the heap because if I have multiple functions in my code are all referencing this, this type that's stored somewhere, it can't be on the stack of any given type, of any given function because when that stack frame goes away, when that function returns, the value would disappear for all the other places where I have it as well. So you can sort of think of this as it has to be a box t. Of course it can't actually be a box t because if we clone the Rc, we're going to clone the box and cloning the box clones the t, right? So really this is just going to be something like a value again, and it's really going to be a pointer to a t. And then what we're going to do is we're going to implement clone for t. And notice that we don't actually require here the t is clone. And the answer should be the reason for that should be apparent, right? Because when, when we're cloning the RC, what we're really doing is we're increasing the reference count. We're increasing the reference count, but we're not actually copying the inner value, there's only one of the inner value.
01:11:30.210 - 01:13:34.230, Speaker A: And so the question then becomes where do we keep the reference count? We can't keep it here, right? If we keep it here, then each clone of the RC would have its own reference count. So how would we ever know when the count goes to zero? Instead, the reference count has to be in the value that is shared amongst all the copies of the RC. So what we're going to do is we're going to define like an RC inner, and the RC inner is the thing that's going to actually hold the value and in addition it's going to hold the refcount. And when you clone, what we're actually going to do is do a, we're going to get a reference to the inner thing, we're going to increment the refcount and then we're going to return an RC of just another RC, right? And then we're also going to implement d ref the same way that we did before for RCT. And it's going to deref into the inner type tachyde. And this is going to be unsafe, right, because there's a, this is a raw pointer. So you'll see.
01:13:34.230 - 01:14:51.562, Speaker A: We'll explain why we need these unsafe blocks in a bit. So the problem we run into here, right, is that if you have an RC, the compiler doesn't know whether this pointer is still valid, right? So think of this as if we define new. This might become a little bit clearer. So new is really just going to do inner is going to be box new rc inner where the value is v and the ref count is one, which is the current thing we have. And then it's going to return an inner which is going to be boxed into raw of inner, right? So we're going to do a heap allocation. We're going to stick this like shared state, we call this shared instead of RC inner if we wanted to. And then we're going to box into raw, sort of consumes the box and gives us a pointer to it.
01:14:51.562 - 01:15:37.350, Speaker A: And the reason we want to use box into raw rather than just dereferencing it is because otherwise if I here just did this right, then when this scope ends, then the box gets dropped and so the memory gets freed. And so that wouldn't be okay. We needed to not drop the box even though we don't have a box anymore. So we do that by doing this. But of course, inside of the D ref. Let's move the clone down here for a second. Inside of the D ref here, we're just saying take this random pointer that's inside of this RC and dereference it, it's fine, and then give back a pointer.
01:15:37.350 - 01:16:41.470, Speaker A: But the compiler doesn't know that this is still valid. It doesn't know that the box that we initially allocated hasn't been freed since. For example, if we had written this the way I wrote it earlier, right? If I had written this as this, this same code would have compiled, but it would have been wrong, because when this function returns, the box is freed, and so this pointer that we stored inside the RC is invalid, and so this dereference would be invalid. And so this needs to be an unsafe, unsafe block. And what we're asserting here, safety, is self dot inner is a box that is only deallocated when the last RC goes away. We have an RC, therefore it has, therefore the box has not been deallocated. So draft is fine.
01:16:41.470 - 01:17:29.894, Speaker A: Let's see. Rcs are quite useful when building GTk apps, since passing a reference to a closure is somewhat icky. Wrap your value in an RC clone and send to your closure. Yeah, in anything that's single threaded, which is often GUI loops, for example, RC is great for this kind of stuff. If you could explain the difference between reference types such as ref mu t, star mu t, and star const. So star mute and star const are not references, they are raw pointers. So in rust there are a bunch of semantics you have to follow when you're using references.
01:17:29.894 - 01:18:09.182, Speaker A: Like if you use the ampersand symbol, an ampersand alone means a shared reference, and you have the guaranteed that there are no exclusive references to that thing. And similarly, if you have an ampersandmute, an exclusive reference, you know that there are no shared references. The star versions of these, like Star Const and Star Mute, do not have these guarantees. If you have a star mute, there may be other star mutes to the same thing. There might be star cons to the same thing. You have no guarantees, but you also can't do much with a star. If you have a raw pointer, the only thing you can really do to it is use an unsafe block to dereference it and turn it into a reference.
01:18:09.182 - 01:19:35.898, Speaker A: But that is unsafe, and you need to document why it is safe. The difference between star const and star mute is a little fuzzy, but the basic semantics there are a star mute. A star mute is something that you is usually something that you might be able to mutate something you might have an exclusive exclusive reference to, whereas a star const is intended to signify that you will, it will never be okay for you to mutate this. And so, for example, in general, you're not able to go from a const pointer to an exclusive reference, but you can go from a mutable pointer to an exclusive reference. What does box provide for us? The box here provides us with heap allocation, right? That's what lets us go from this RC inner, which would otherwise be on the stack, to a pointer that is on the heap, which is what we store here. Okay? So for the clone here we're going to increase the reference count, but here we have the same problem as we did for ref cell, right? Which is we have a shared reference to self, but we need to mutate something inside of it. And so here, lo and behold, the problem is, the answer is the same thing that we've done before.
01:19:35.898 - 01:20:41.700, Speaker A: It is our friend cell, right? If this is a cell you size, then now what we can do is refcount c is inner dot ref count dot get, and then we do inner dot ref count dot set c plus one. Isn't unsafe a pretty weird keyword name. It just means something the compiler cannot guarantee is safe, not that it's actually unsafe. Yeah, the unsafe keyword is a little weird because really what it means is I have checked that the stuff inside the brackets is safe. It's like I, as the programmer certify that this is safe, so it's not really unsafe. It's like in some sense saying that. I acknowledge that this code seems unsafe, but it's actually safe.
01:20:41.700 - 01:21:16.090, Speaker A: So I agree with you, it's a little bit of a weird keyword name. So we have the same problem for RC as we did for refcell, which is when an RC goes away. This is the smart pointer part, right? We need to make sure that when the last RC goes away, then we actually deallocate. Otherwise there's going to be a memory leak, right? Otherwise you keep cloning your rcs, eventually all of them go away. But nothing here actually drops this box. And so the value is just going to live on forever on the heap, which is obviously not. Okay.
01:21:16.090 - 01:23:19.244, Speaker A: So we need to implement drop for IC. And so the question here becomes, should we, when you drop an RC, should we or should we not drop the inner value? And so what we're going to do here, right, is we are going to check what the count is. If the count is one, we are the only reference, we are the only RC left, and we are being dropped for after us, there will be no rcs and no references to t. Otherwise there are other references, there are other rcs, so don't drop the box, right, because other things are going to need it. But up here we are the last RC, and so at this point we need to actually drop the inner value. And how are we going to do that? Well, there's box from raw, which takes, lo and behold, a let's do a drop inner here, which takes a raw pointer and gives you back the box, and we're gonna drop it immediately. What is the relationship between box into raw and box leak? Box into raw gives you a raw pointer that you then can do whatever you want with, including mutating through it.
01:23:19.244 - 01:24:12.380, Speaker A: Box leak gives you a static ref, a static shared reference to the, to the heap memory. Because when you leak a value, right, it's going to live on the heap till the end of the program. And so giving a shared static reference to it is fine, because that shared reference will indeed always be valid, as in what static implies. But you can't then mutate through it, for example, because it's just completely shareable. Um, you'll see that this code doesn't actually compile, and the reason here is in the difference between mutable or star mute and star Const, box from raw requires that we give it a pointer that has that, that is not star const, that is star mute. Instead. The contract here, as I mentioned, is a little like fuzzy.
01:24:12.380 - 01:25:07.210, Speaker A: But basically what they're trying to encourage here is that you don't take that, you don't take some raw pointer that might be shared and, and try to turn that into a box. Now there is some fairly subtle thing at things that work here, and this ties into something called coherence in Rust. Well, sorry, not coherence, but variance in rust. Coherence is another beast, but this ties into something called variance in rust is one of the primary differences between star Mute and star Const. It's not something you will usually run into, so I'm not going to dive too much into it here, but basically we need to give it a star mute. And currently we're giving it a star const. We could just make this a star mute, but instead what we're going to do is the standard library has this really neat thing called non null.
01:25:07.210 - 01:25:53.280, Speaker A: So a non null is, so you'll notice here it mentions variance. The primary reason to use non null, though, is for optimization purposes, which is basically, if the compiler knows that a pointer can't be null, right? As a star mute can be point to, it can be a value of zero. It can point to nothing but a non null. The compiler knows that the pointer is not a null pointer, which means that it can use the null pointer as an extra value. So for the example they give here is if you have an option non null, then the compiler can use the null pointer to represent none. So there's no overhead to an option none null. And the other thing that's nice about non null is that it's sort of like a star mute.
01:25:53.280 - 01:27:12.380, Speaker A: So we give it a star mute, which is where we get from box from raw, and we can use it to get back this, the star muti, which is what we need for into raw. So let's go ahead and use that instead. Use standard pointer non null. So this is going to be, oops, no, this is going to be a non null of these. And then here we're going to do, this is going to be a non null new new unchecked. And here, of course the safety argument is box does not give us a null pointer, because the box actually does give us a heap allocation. And now what we're going to do here is we can use the unsafe asref method on nonnull instead of having this star ampersand star thing.
01:27:12.380 - 01:28:07.370, Speaker A: So as ref and same thing here. And now down at the end here, we can now do self inner as pointer. And this obviously is unsafe. Right. The compiler, this is another case where the compiler doesn't know, the compiler doesn't know that we have the last pointer, and therefore that it's safe to turn this back into a box and drop it. But we know, because we know that we're keeping the reference count correctly. Can't we leak immutable reference to the value in ref cell by calling dref on ref mute, storing the return value somewhere, and then dropping the ref mute.
01:28:07.370 - 01:28:48.238, Speaker A: No. So this is a good question. Let's go back to this briefly. This ties into the way the draft and draft mute works. So the observation was, why don't I just get a ref mute, call draft mute, take the pointer that I get the reference, that I get back the mutable reference and save it somewhere, and then drop the ref mute, and then use the mutable reference. This won't work. And the reason is because of how rust deals with lifetimes, there's an implicit lifetime here of this, which is the mutable reference that we return live only as long as the mutable reference to self.
01:28:48.238 - 01:29:46.108, Speaker A: So the mutable reference to the ref mute. So if you tried to stick the mutable reference, you got back from draft mute somewhere and then drop the ref mute, and then try to use this mutable reference again, the compiler would say, no, that's not allowed. You're trying to use this mutable reference after the lifetime it's tied to has already expired because the ref muta has gone away, and so the compiler would not let you do that. If we have a mutable pointer, why do we need a cell? We don't have a mutable pointer in RC. The so we have a mutable pointer, but it's not safe for us to mutate through it. Is the difference immutable? So this is why this is the difference between immutable pointer and immutable reference. Immutable reference guarantees that no one else is currently modifying it, and it is an exclusive reference.
01:29:46.108 - 01:30:31.470, Speaker A: Immutable pointer has no such guarantee. Immutable pointer is just this is a pointer with certain semantics, and we call it star mute. It does not, it does not carry the additional implication that it's exclusive, which is what allows you to mutate through things. It says memory is size aligned in rust. Can the compiler fit other non null variants in zero, one, two, and three? This is something that's being discussed in the unsafe, in the unsafe working group for rust. I don't think they've reached a verdict on it yet, though. Ooh, restream seems to be duplicating a bunch of my things.
01:30:31.470 - 01:31:30.622, Speaker A: Someone asked, why do I drop the inner before I do this? So this is me being paranoid at this line. We're dropping the box, and so any pointer into that box is invalid. The moment we do this, inner is a pointer into that box, and it doesn't get dropped until here or here. And so technically this reference is no longer valid from this point forward. And so if I didn't put this here, someone could later accidentally come along and write inner dot ref count minus equals one or dot set zero. And the compiler wouldn't warn them that this isn't okay, here they're accessing something through the pointer that we just deallocated, but they won't know that this is the case if I do this. So that's why this, this code compiles.
01:31:30.622 - 01:32:08.260, Speaker A: But if I drop this, this code no longer compiles, or at least shouldn't, because the inner has gone away. So that's the only reason. All right, so now we have cell, refcell and RC. Great. Now let's talk about. Actually, no, there's one more thing we need to do, and this is going to make your head hurt. So I apologize for that in advance.
01:32:08.260 - 01:33:07.868, Speaker A: Let me just type this out first, and then I will explain why it's there. Okay. So I think we need to test for me to demonstrate why this is a problem. So this is something in rust called the drop check. And I don't want to get into it too much because it's fairly complicated, but I'm going to try to cover it a little bit. If you look at the Namicon, the unsafe nomicon, it goes into a lot more detail here. So here's what we're going to do.
01:33:07.868 - 01:35:03.030, Speaker A: We're going to. How am I going to explain this? This is a good question. This is some really gnarly stuff that usually you will not even need to know about. But I'm going to cover it because we're implementing RC and we should do it properly. Imagine that I write the following code, Y and x, and then I say, x is. And why is RC new? This, I'm gonna try to explain what goes wrong if we don't add the stuff I added, and then I'm gonna explain why that is the case. Well, there are actually multiple things, right? If I remove this for a second, I might make it easier to explain, and then I do cardo tests.
01:35:03.030 - 01:36:00.850, Speaker A: I don't know how to explain this. Yeah, this is, um. Let me try to explain it without explaining it. It's gonna seem weird, but I think it's too detailed to be useful when we write this rust, if we don't have this marker here. Rust does not know that this type owns a t. All it knows is that this type has a pointer to a t. But when this RC goes away, it doesn't know that there might be a t that gets dropped.
01:36:00.850 - 01:36:51.750, Speaker A: This matters if T might contain lifetimes. So rust has this thing called the drop check, which I'm going to explain in very basic terms because it's fairly complicated, but the intuition is there. Imagine that I have. I have some type that contains a reference, and when it gets dropped, it's going to modify that reference. So I have some code that looks a little bit like this. I mean, struct foo t, and it has a, it has a v that's a mutable reference to t. And I implement drop for foo.
01:36:51.750 - 01:38:06.138, Speaker A: And let's imagine that this does like, I don't know, what does this do? This does like a v dot fr omify some mutable function on v. And now imagine that someone writes a main function and they create a new foo. They create a t string from hello and they create a foo and then they drop, and then they drop the tache and then they drop the foo. This code is problematic, right. So here we create a string, we create a food that has a pointer to that string, immutable pointer to that string. Then we drop the string. At this point we cannot, we cannot touch that string again.
01:38:06.138 - 01:38:40.964, Speaker A: Right. Because when t is dropped, the string goes away. But then we drop foo. And dropping foo calls a method on the string through its drop implementation. But drop is implicit. Right. So if I write let foo and t here, what's going to happen is the t is going to be dropped first and then the foo, because rust dropped things in reverse order.
01:38:40.964 - 01:39:42.620, Speaker A: But I haven't written drop anywhere. And so the compiler, when functions, when any type gets dropped, it has to assume that every use of that type, sorry, every drop of that type is a use of the type and any fields that it contains. So even though I haven't written drop foo here, there's an implicit drop foo at the end of the scope of maintained. And Rust is going to treat that as accessing every single one of its fields. And so this means that this code is going to be rejected. I guess this is going to be this and it's going to be mem replacement v with t default. I'm just putting something here so that it'll compile.
01:39:42.620 - 01:40:28.490, Speaker A: So Rust is going to treat this as dropping the, when you drop the foo, it's considered a test of use of all the fields of foo, which includes the string. And so if these were dropped in the wrong order, Rust would, would actually catch this as a problem. Right. It would say that the, when foo is dropped, it tries to access t, but the t has already been dropped. This is what's known as the drop check. But it can only do that because it knows that Foo holds a t in here. It can only do this because it knows that a foo is dropped at the end of the scope.
01:40:28.490 - 01:41:38.454, Speaker A: Imagine that we did this with RC instead. If I wrote RC new of foo, and now that RC is dropped, when that RC is dropped, rust looks inside of RC and looks, does RC contain any foos? In the old case where we just had this, RC doesn't contain any foo. And so the, the compiler is going to assume that when we drop a foo, when we drop the RC, no foo is dropped, and therefore we don't have to check Foo's implementation of drop. And that's not okay. That means that this code would actually be allowed to compile when it shouldn't, even though t has gone away, because the dropping of this RC will not count as a use of this string because the compiler thinks that RC doesn't contain a foo by adding this marker. So phantom data is a way to say there's one of this type, but I'm storing none of them. It basically tells the compiler, treat this type as though we have one of these in here, even though we only have a pointer to it.
01:41:38.454 - 01:42:21.550, Speaker A: This makes the compiler that lets the compiler know that we own something of that type. And so when you drop an RC, you need to treat it as dropping one of these. Okay, that is a complicated, simplified explanation of a very complicated topic in rust. I highly recommend that you go look at the Namicon drop check. Oh, that's very bright. Sorry about that. So the nomicon on the drop check has way more details about what this check is, but an escape hatch that technically we need an RC, but I'm not going to go through it.
01:42:21.550 - 01:43:25.202, Speaker A: Hopefully that made a little bit of sense. But I'm going to take some questions because I agree that this is complicated, what I just explained, but I felt like I couldn't, I couldn't not put this in there because without it, RC is broken and I couldn't put it in there without explaining a little bit about it. All right. Yeah. So the phantom data tells rust that when you drop an RC, an RC inner t might be dropped, and you need to check that. If we didn't have the marker, rust would not assume this to be the case because it's only a pointer to one. Would it be sufficient to have phantom data t instead of phantom data inner rct? Yes, although it's a good question.
01:43:25.202 - 01:44:07.110, Speaker A: I think this actually was a pull request to the standard library to change it from being just a t to an, to like the wrapper that internally in the standard library we have. I forget why that was changed. I think it's to guard against someone accidentally writing an impul drop for rcinner. For example, if someone wrote that implementation, then this, if we just had rct here, the drop for rcinner would not be checked. It's just off the top of my head. That would be the guess why this only needed. This is only needed when t is not static.
01:44:07.110 - 01:45:14.930, Speaker A: Yes, but we want to allow any t here, right? There's no reason why RC shouldn't work for other types. All right, so there's one other thing I want to mention for RC in particular, which is if you look at the real definition of RC over here. You'll see that the RC type allows the t to be unsized. So question mark sized here means it's opting out of the. So rust normally requires that every generic argument is sized. We talked about this in a previous video, and question mark size is the way to say I'm opting out of that requirement and sized. We're not actually going to go through how this works internally in the stream because it's a little complicated and because you need some unstable features to actually support this fully.
01:45:14.930 - 01:46:34.280, Speaker A: But if you are curious about the kind of stuff that question mark size will let you do, we'll probably do a future stream on trait objects that we'll go into it in a little bit of detail. And you want to look up the coerce unsized trait, which is a, which deals with some of the restrictions of why it's hard for you to implement RC fully yourself if you want to support dynamically sized types. The real question for me is that should this problem exist in the first place, I'm feeling that if I write the same thing in C, it'll be clearer and I won't be wasting time in all of these. So I want to stress here, you will very rarely be writing the kind of convoluted stuff that I wrote right now in your own code. What we're writing is a very low level primitive in rust, right? The RC type is a very low level smart pointer type, and usually these concerns won't come up for you. And it's important that you can write these restrictions in rust. In C, if you wrote this code, the C compiler would never check, right? And see, the way this would manifest is you run your code and it randomly crashes at runtime.
01:46:34.280 - 01:47:23.472, Speaker A: In rust, you have to think a bit, little bit more about the code to make the types correct. But if you do, these problems are caught at compile time rather than runtime. And so it's true in C you don't have to do this reasoning. But in C you also don't get the benefit that this gets checked at compile time. So I don't think this is wasting time. What is the difference between exclamation mark sized and question mark sized? Exclamation mark sized means not sized, and question mark sized means it does not have to be sized. This is because the default is that everything has a sized bound.
01:47:23.472 - 01:48:19.406, Speaker A: There's a way to opt out of that bound. All right, so the next thing we're going to cover in the last bit of time is the synchronous versions of these. So if you have multiple threads, then the strategies we've written so far don't quite work right. In the, in the cell case, if you have multiple threads that can mutate at the same time, there just is no equivalent of cell, because even though you're not giving out references to things, having two threads modify the same type or the same value at the same time is just not okay. So actually is no thread safe version of cell. Ref cell is a little interesting. So in the ref cell we wrote, you have borrow and borrow mute, and they return options.
01:48:19.406 - 01:49:20.564, Speaker A: You could totally implement a thread safe version of Refcell, one that uses an atomic counter instead of cell for these numbers. So it turns out that the cpu has built in instructions that can, in a thread safe way, increment and decrement counters. So you could do that. In practice, this is usually not what people want, because if you borrow and get a none, but you need the sum just because some other thread has it, you would just have to like spin in a loop to get the sum that you wanted, which isn't great. And so the multi threaded or the synchronized version of Refcell is usually RW lock. So if we look in sync, you'll see that it has a bunch of different types and RW lock is one of them. And what a reader writer lock is, is basically a ref cell where the counters are kept using atomics.
01:49:20.564 - 01:50:44.122, Speaker A: So they're thread safe, but also borrow and borrow mute, which in the reader writer lock are called read and write, they don't return an option. Instead they always return the ref or the ref mute. But what they do is they block the current thread if the borrow can't succeed yet, so they block the current thread until the conditions are met. So for example, if you call borrow or the equivalent in ref in reader writer locks called read, then if there's an if a thread has exclusive reference to it, it will block the current thread until that exclusive reference is given up, and at that point that thread will resume and you'll have the shared reference. Similarly, if you try to take the right side of the lock, the exclusive part of the lock, then it will block if there are any shared references that are giving out and will only stop blocking once there are no more shared references. Mutex is sort of a simplified version of refcel, if you will, where there's only borrow mute, as you don't need to keep all these like extra counts for how many readers or how many shared references there are, it's just either some other thread has a reference to it or some other threads is not. And it similarly has the blocking behavior where when you call lock on a mutex, it will block until there are no other references to the inner value.
01:50:44.122 - 01:51:31.592, Speaker A: And at that point you're given that reference. And it similarly has a guard the same way ref cell does, where you get back a ref mute, and that ref mute when you drop it is going to decrement the count and let someone else go. Okay, does the translation. Oh, and RC, the synchronous. The thread safe version of RC is arc or atomic reference count. So if we go back here to sync, you'll see there's an arc and this is a thread safe reference counting pointer. And arc is pretty much exactly the same as RC, except that it uses these thread safe operations, these atomic CPU atomics, for managing the reference count rather than a cell the way that we did.
01:51:31.592 - 01:53:05.366, Speaker A: And this is why an arc is indeed send and sync. Actually, that's a good point. Our rc needs to not be sentence I don't know whether this is already not send, but this needs to be not send, which I'm gonna mark as a what types are not send? Pointers are not send. Actually, I don't know if non null is senditive, which means we may be fine. So with a, with an RC, it's not safe to send it to different threads because the count is not, is not thread safe, right? So if I sent an RC to some other thread, and that other thread dropped the RC, and I dropped an RC at the same time, both of us would try to use the cell to decrement the count. But that's obviously not okay because cell is not threat safe and so the RC cannot be sent and non null is indeed not sent by default. Can you guarantee thread safety across FFI boundaries, or is that just the C code calls into? You need to uphold some guarantees.
01:53:05.366 - 01:54:01.660, Speaker A: So across FFI boundaries there are no guarantees. That's why everything across an FFI binder boundary is inherently unsafe. And any guarantees you want to give you have to establish by wrapping it in an unsafe block. Why would you ever prefer rc over arc? RC is much cheaper, so there's a cost to using these atomics. They're much more expensive in terms of number of cpu cycles and coordination overhead between cores. So in general, you want to prefer the non thread safe versions if you can, because they are cheaper to use, they have lower overhead. Is there an async RW lock? Yeah, I think both async std and Tokyo and the futures crate and the futures intrusive crate have asynchronous mutexes.
01:54:01.660 - 01:54:42.038, Speaker A: All right, so now we've covered the, oh, sorry. So RC is indeed not send because non null is not sent. So we're fine there. We have a couple of minutes left. So in the last couple of minutes, let's look at the borrow module. So the borrow module is a little weird because it's not, it's sort of a smart pointer. We're going to look specifically at the cow type.
01:54:42.038 - 01:55:22.532, Speaker A: So the cow type is an enum that is either owned or borrowed. So if you have a cow of till then, the cow either contains a reference to a t or it contains a t itself, roughly. So think of this as either it contains a reference to a string or it contains the string itself. The name comes from copy on. Right. And the idea here is that, is that when you have, let me pull up the here. So cow implements d ref so you can get a shared reference into the cow.
01:55:22.532 - 01:56:07.950, Speaker A: And if the cow is itself just, if it just holds a reference to something else, it just passes access through there. But if it owns the thing it contains, that gives you a reference to that. But crucially, if you want to modify the value inside of, inside of a copy on write, then if it's a reference, you can't modify it because it's a shared reference. So what cow will do, the magic of cow in some sense is to, if you require write access, you call like get mute and it's currently borrowed, then it will clone the value and turn it into the owned version. So if you had a reference to a string, it will clone the string and store a copy of the string instead. Hence the copy on write. And then it will give you a mutable reference into this thing.
01:56:07.950 - 01:57:03.416, Speaker A: The reason you often want cow and the place it usually shows up is if you have some operation where most of the time you don't need a copy because you're only going to read, but sometimes you need to modify it. Right. This comes up pretty often in string operations. So imagine that you have a, what's the best example of this? Imagine that you have an escaping function. So you have something, let's go back to live. Imagine you have something like an escape that takes a string and it returns a string. Now sometimes when you're given a string, there are, so this is going to be like, it's going to turn every like single quote into a backslash, single quote.
01:57:03.416 - 01:57:43.270, Speaker A: It's going to turn every double quote into a backslash double quote, etcetera. But imagine that you're given the string foo, right? The string foo just turns into the string foo. There's no escaping. You don't need to modify the string at all. And so it would be kind of sad if we returned a string here, because then when you're given a foo, you would still need to clone it, even though you didn't need to modify it at all, because the signature says you're returning a string. And this is where cow comes in really handy. You can here return a cow, and of course the lifetime here is the same as the input.
01:57:43.270 - 01:58:32.240, Speaker A: And now what we can do is if we don't have to modify it, if sort of already escaped, if you will, then we can return a cow borrowed of s. And we don't need to do any allocation. And only in the other case do we do like let string is s, like to string, this is mutable. And we like do something to string, like add backslashes. And then we return a cow owned of stringental. So the benefit here is, if we don't have to write, if we don't have to change anything, we just pass it through. And only if we do have to change something, do we do the cloning and do the mutation.
01:58:32.240 - 01:59:37.712, Speaker A: And if we do have to do the copy, we also pass that ownership to the caller. Right. They're going to get a cow owned that they can then operate on, including, they then have ownership of it. So why does from UTF eight lossy return cal, but the other UTF variants don't? Yeah, so that's a good example. So in the string type, the string type in the standard library has a function called from UTF eight lossy. And what this does is it takes a, it takes like a bunch of bytes and it turns you a cow stirrer. And the reason it does this is that if the given byte string is completely valid UTf eight, then you can just pass it straight through.
01:59:37.712 - 02:00:34.610, Speaker A: You can just cast it to a string reference and just pass it on through. Right. ISIS should be borrowed of like bites as str. It's not quite what it does, but like if valid UTF eight bites and this. And if it's not valid, then what they do is they like walk, they do like a. It's gonna be vec from bytes. This is a slice, right? So let's create a vector of bytes, and then they're gonna walk through bits and replace with this like un invalid character UTf eight symbol, if not valid UTf eight.
02:00:34.610 - 02:01:25.630, Speaker A: And then they're going to return cow owned sort of bits as string. This is a little simplified little pseudocode, right? But the idea here is basically the same as what we saw for the escaping, where if you don't need to modify, then don't allocate, and the cal type lets you do that. The other from UTF a types usually allocate regardless, and if they allocate regardless, then, then there's no reason for the cow type. Some of them are like checked from UTF eight, so they return a result and then you never need the mutation, so you can always return a reference. I think we've now covered most of the smart pointer types in rust. Right. So we talked about.
02:01:25.630 - 02:02:08.676, Speaker A: Let me go back here. We talked about cell first, which is for non thread safe, non reference interior immutability. Then we talked about ref cell, which is dynamic interior immutability. Then we talked about RC, which is for dynamically shared references. So this is something where you don't know how many references are going to be, you don't know when the inner value is going to be dropped, and that you only know that at runtime. Then we looked at the thread safe versions, the synchronized versions of those types, and then we looked at Cal, which is not really a smart pointer, but kind of a smart pointer. Right.
02:02:08.676 - 02:02:54.210, Speaker A: It's like a copy on write pointer that upgrades when you need it. All right, I think that's all I wanted to cover. There's a lot to digest here, so consider going back and watching the stream again when the recording goes up and see if you can tease apart some of the explanations, which are a little convoluted at times. And apart from that, thanks for watching. And hopefully I think next thing will probably be a bit of a potpourri, like a mix of different things, maybe trait objects, maybe things like the borrow trait. Oh, I forgot to talk about trait delegation. I'll probably make it into a subsequent stream.
02:02:54.210 - 02:03:02.710, Speaker A: Great. All right, thanks for watching. I'll see you next time. Bye. If I can make this work. Nice.
