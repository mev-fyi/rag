00:00:00.960 - 00:00:41.829, Speaker A: I'm trying something kind of different today. I ended up with some unexpected free time today and figured, you know, let's not. Why not just try to do a stream and see what happens. And for this stream I haven't really prepared anything. It's more that I've noticed over the past few streams that there keep being a bunch of just like questions that come up in chat, often not necessarily related to the topic we're covering. And I figured why not just do a Q and A session? And I'm aiming for this to be very informal. I don't even know whether the like video recording afterwards is going to be that useful because you can't ask questions.
00:00:41.829 - 00:01:20.865, Speaker A: But hopefully me splitting out the questions might make it easier for you to find like in the bottom of the video somewhere on YouTube. But for chat, like treat this as sort of a informal chat Q and A. Like an ask me anything. It doesn't even have to be about Rust, just like things you're curious about that you think maybe I might know the answer to or have some input on. I'll try my best to give useful answers and yeah, I mean let's just see where this goes. I have no idea. You can also treat this a little bit like sort of office hours.
00:01:20.865 - 00:01:56.645, Speaker A: Like if you have particular oddities in Rust or in programming that you would like to meet, just like talk a little bit around then I'm happy to try to help out with like specific problems or design problems people are having. I'll try to do things that aren't too long winded. Like if someone goes, can you explain Async Await? Which there's like a. I have like a three or four hour video already on. I'm probably not going to tackle those kind of things here unless. Unless in like very broad strokes. Oh yeah, I should switch to this so you can see J.
00:01:56.645 - 00:02:45.913, Speaker A: There's J. I really want to get like a plushie of J and it's on my list. I don't know that there's much more to present about J. One thing I've wanted with J is to make like multiple different intro videos. The feature J. There's already the crust of Rust intro that some of you may have seen and it would be really fun to make like variants for different types of streams that I do. I'm still playing around with the idea where in your config repo can I find your shell prompt? It's under config Fish.
00:02:45.913 - 00:03:29.925, Speaker A: Fish config YAML. Yeah, I think that's where er, config fish? I guess not YAML opinions on Swift vs Rust I have not used Swift. Can't really speak to it. I like Rust Swift. I don't know what the selling point of Swift is over Rust. The impression I have is that Swift tries to do some similar things to Rust in the sense of trying to be sort of a higher level language that provides low level things like a modern C or C or something like that. But I like things like the Rust lifetime system, which my understanding is Swift doesn't really have.
00:03:29.925 - 00:04:27.245, Speaker A: How do you get your head around difficult concepts? I think about them for a while, realistically. Usually what I do is I just read a bunch about it and then see whether like over time your brain in the background is just like processing the data right and you might not get it initially, it might even take a while. And I think just accepting that you won't immediately understand helps a lot. Do you think Rust is in danger of becoming too complex like Scala? I don't feel like Rust is becoming more complex. I feel like if anything it's becoming less complex because there are fewer weird corner cases like with when non lexical lifetimes landed. This is ages ago, but the borrow checker went from often making mistakes to less often making mistakes. And so even though the underlying system was more complex, it now fit better how programmers think about the code.
00:04:27.245 - 00:05:14.565, Speaker A: So I don't think it's really becoming more complex. It's like Async Await for example. There's some language features that are being introduced, but I think the complexity in them is not so much about the language, but about the fact that they introduce new concepts to the language that people like. Imagine that if they add generics to Go as the traditional example, go becomes a more complex language, but in some sense it's because it now has the feature of generics as opposed to the. I mean the language is also getting more complex, but I don't feel like it's becoming unnecessarily complex. What do you think about Dvorak and Kolomak? Not worth it because I work too often on other people's computers. I also have seen some studies that apparently the speed up isn't that great.
00:05:14.565 - 00:05:43.365, Speaker A: So I just. It hasn't. I've had like the sort of technical curiosity, but I've never actually used it. Seriously, your opinion on GPT3? GPT3? There's a really cool article. Might as well just kill that. There was a really cool article written a little while back. Let me see if I can find that.
00:05:43.365 - 00:06:50.265, Speaker A: Thinking about oh, hmm. Let me see if I can find that article actually, because that was really good. If you're curious about GPT3. Yeah, it was called. Let me dig that up here. Ah, I just scrolled very far without meaning to do do do do do. I just remember I sent it to a friend a little while back so I'm scrolling back through my chat with them From Minimaxier Maxier GPT3 this article I thought was a really good take on GPT3.
00:06:50.265 - 00:07:24.091, Speaker A: I'll send it to chat which is basically like it's cool but it's unclear. It's quite as revolutionary as like it's a big step forward but it's not clear that it's like everything is now possible that wasn't possible before. There's a lot of questions. I'm just like walking through them. I'm scrolling, I'm lagging a little bit behind you all. Can you talk about higher ranked trait bounds someday in a crust of rust? I could, but higher ranked trait bounds because so much of it is not really supported in the language. Like so much of the design isn't settled yet.
00:07:24.091 - 00:08:17.067, Speaker A: It's not clear that it's worth really diving deep into it because I don't know what to teach about it yet. Crust of Rust is sort of intended for like you read the Rust book, you've programmed some simple things and now you want to try something more advanced with the language. It's not really like let's explore this like long term potential future for rust. So like for example, I probably wouldn't cover generators either in a crust of rust until they're actually released. If you're going to build a protocol parser, what crates would be your go to Tokyo Codex, NOM or something else? Well, Tokyo Codex is more of a way to wrap a protocol, like a framed protocol into the stream and sync API. It's basically a mapping between stream and sync and Async read and Async write. So that's a nice sort of wrapper but it doesn't actually provide you with the protocol parsing.
00:08:17.067 - 00:09:02.125, Speaker A: I've been pretty happy with num, although I've also seen some other cool like top down parsers so I don't have a strong opinion there. Like I feel like there was a comparison of these a while back if I do recent downloads. So we're going to find NOM somewhere relatively high up here. Pest is the other thing that I've heard really good things about, but I haven't used it myself. I want to hear Your take on ethics and the tech industry and Rust. Ooh, can you. I'm happy to talk about that, but I would like to have a more specific question, because otherwise it's a very broad topic.
00:09:02.125 - 00:09:43.401, Speaker A: IOS app development. I've done zero of that, so can't really speak to it. I've always wondered, how does one program specifically for the GPU with Rust, and what kind of computation would be great to run on the gpu? So the GPU is great for massively parallel computations. It's basically divide on conquer on steroids. If your problem works well with divide and Conquer, the GPU is going to be great for you. The idea is basically that the gpu, rather than having few very powerful cores, is that it has a lot of simpler cores, but they can all execute in parallel. And so if you have a task that you can break down into smaller components, run them all in parallel, then you can get very high speed ups.
00:09:43.401 - 00:10:22.485, Speaker A: The biggest challenge with GPUs is memory access in particular, because you need to ship data to the GPU and back to the CPU to work on it. And so there's a lot of work that goes into just designing that pipeline and designing your computation in such a way that it fits the pipeline of the gpu. I don't know that there's that much available for GPU program in Rust at the moment, but I haven't really been keeping up with it. I would look at things like Vulkan and then obviously like Nvidia's. Forget what it's called. Totally blanking on the name now. But Nvidia's like CPU GPU programming framework.
00:10:22.485 - 00:10:57.051, Speaker A: I'm sure someone will tell you in chat. I don't know that there are. There are better or worse here, but I think one big advantage of Vulkan is that it is cross hardware and even cross CPU and gpu. But the Nvidia one is generally faster because it's been around for longer and has direct support from Nvidia, and they've worked a lot on that toolkit. So it really depends on what you're favoring. Have you tried Haskell? I have, a long time ago. I thought Haskell was fine, but I think part of what happened was I didn't have any practical use cases for it, and so it sort of fell by the wayside.
00:10:57.051 - 00:11:27.131, Speaker A: It felt more like an academic exercise than running a language, learning a language for the purposes of using it in production somewhere. I'm a C developer. Do you suggest to continue with Rust to switch to C or C I really love Rust, but I did not find any use case in real production apps. I don't know why you would start a new project in C today. I think you have many good alternatives. Rust is one of them. Swift and Go are other good alternatives.
00:11:27.131 - 00:12:19.279, Speaker A: Even things like TypeScript script, it really just depends on your use case. C and C for me at the moment are primarily useful if you need integration with some existing ecosystem. So for example, if you need to work with vendor libraries from some vendor that you don't have control over and it's this massive C beast, you may be better off using C. Or if you need to run within a framework that is already C based or, or that only support C in the early days like Linux Kernel modules was a good example of this. Not so much anymore. But only really if you have constraints that mean that C and C are the best language, would I go for those. Other than that, I feel like the wins you get from some of these higher level languages are pretty high gats, generic associated types.
00:12:19.279 - 00:13:21.977, Speaker A: They fall in the same category as higher ranked trait bounds. I assume you wrote some kind of master's thesis. If so, what was it about? My master's thesis was about interference in wireless networks. So the idea was that we set up like two wireless access points and we set up a TCP stream so we're going across both of them and we would see what was the effect of having the two endpoints be transmitting at the same time on the same channel, nearby channels and far apart channels to look at that interference. Will you code something tonight, by the way? Probably not, unless something particular comes up. Oh, let me bring back J. It'd be great if you could comment about Tokyo versus Async, STD versus versus crossbeam compatibility and interoperability issues.
00:13:21.977 - 00:13:55.465, Speaker A: Is there a light at the end of the tunnel? Ooh. So this is a. This is a big one and there's a lot going on in that sort of sphere of projects. The high level take is Rust's futures story is not done yet. The sort of some of the core pieces are in the language. There's like the future trait, the waker and context bits and pin of course, which was a major achievement. And so much of that is in the standard library.
00:13:55.465 - 00:14:40.673, Speaker A: And that's great. And that means that many things will work across libraries. The things that are left are things where we haven't figured out what the right core abstractions are. These are things like Async Read and Async Write, which we have versions of, but they have some Drawbacks. For example, it's not clear that they'll work well with things like iouring, which is coming out and will potentially be a pretty big win in the Async ecosystem. And so those haven't stabilized yet, which means that different libraries are using different versions of them. Tokyo, for example, does not use the same one that's in the futures crate, which is what Async STD uses, because they, as I understand it, basically wanted to experiment and try something different to see whether wins could be gotten there.
00:14:40.673 - 00:15:51.477, Speaker A: And so the ecosystem there is still developing, and to some extent, for good reason, there are other things we don't have common abstractions for, things like timers or spawning futures. So some of these things, the core abstractions, aren't done yet, and that's why we're seeing this fracturing of the ecosystem. There are some more political reasons for it as well, but those it's not clear it's productive to talk about those, just because I think the underlying technical issues are the real reason why we're seeing this fracturing, and I think that split is happening for relatively good reason, which is we're still experimenting with the primitives. Do you use a debugger much? I use GDB a decent amount, especially in highly concurrent programs, or if I see crashes in things like Noria. Apart from that, Printf debugging is great and people can say what they want. I have not tried the Visual Studio debugger with Rust. How do you learn data structures and algorithms in Rust? Can you suggest some resources? I mean, just take any data structures and algorithms book and start trying to code it in Rust.
00:15:51.477 - 00:16:26.727, Speaker A: It's my best recommendation. I think Exercism IO has some cool exercises. There's also learning Rust with entirely too many linked lists. A really great post. What are your thoughts on working for a while and then going back to school? I mean, do what makes you happy. I don't think there's a reason to stay in school if you feel sick of it because you won't be productive and you won't learn. How is Rust capable of object oriented programming since the memory management scope works really strictly compared to C.
00:16:26.727 - 00:17:19.655, Speaker A: If you're trying to write object oriented code in Rust, try to see if there are other more idiomatic ways to do it. Object oriented programming is not the only way to write complex software, and Rust has some other approaches to it, and I would recommend that you try to do it in those other ways rather than try to force your current way of structuring programs into Rust. You'll find things are less painful that way. What are your thoughts on doing crate review streams except viewer submissions and review small crates that people have written? I've done a little bit of that in the past. The open source contribution streams have a little bit of that flavor. Doing a plain review stream, maybe it really depends on the crates that are submitted. Like reviewing a crate is a lot of work, even if it's anything more than a very simple one.
00:17:19.655 - 00:18:09.205, Speaker A: And the very simple ones might not be that interesting, but maybe, maybe it's not a bad idea. How did you find out about your area in computer science? I just started my graduation and I'm very confused about my future on it. You know, the way it happened for me was really I was just working up through school and sort of observed along the way that I found things like concurrency and distributed systems and networking interesting topics and high performance stuff. And so I just sort of gravitated towards the things I found interesting. And then I took on projects that were that kind and then I found professors that worked on that kind of stuff. I read papers that were about that kind of stuff in the classes I took, the ones that had that were the ones I liked the most. And so it sort of worked itself out that way.
00:18:09.205 - 00:18:44.835, Speaker A: I think in general focus on the things you enjoy doing and that's the best way to find what you're going to be what you should be working on. Have you done anything with webassembly in the browser or not? I haven't. Webassembly is something I really want to learn. It looks like a really cool thing that I think is going to have a pretty substantial effect in the ecosystem and already is, but I haven't worked with it myself. Your facecam has a moire pattern on it. Maybe switch scaling method by cubic or something. I'll try to do that for next stream.
00:18:44.835 - 00:19:17.741, Speaker A: What are your plans after finishing your PhD? I'm going to go into industry. I don't quite know what I'll be doing yet. I'm looking at a couple of different job postings. My hope is to have decided by the end of August because I'm moving to LA in September. But because of the way Visa things work out, I'll be starting work November 1st is the hope, but I don't know yet. Looking at a couple of different things. Some are in the very open source space, some are more like bigger companies and we'll see.
00:19:17.741 - 00:20:11.573, Speaker A: There's a lot of just cool stuff out there to do. Do you think having macros means there's less need for generics? No, I think generics serve a very different they serve a very different need than macros do. I know that in C template programming sort of gives you both, and I think there's an advantage to splitting them up. For example, with generics and rust you can have things like trait bounds, and with macros you couldn't really do that. And I think there are huge advantages to being able to express the contract over the types you're given explicitly using trait bounds, you can include bounds, for example, that aren't represented in the code, such as things like send, whereas macros will just not let you do that. An experience or thoughts on competitive programming? I've done a little bit of that. I've been in some programming competitions and seemed fine.
00:20:11.573 - 00:20:55.685, Speaker A: I think you should do it because you think it's fun. I don't think it's useful, I don't think it's important for you, but if you think it's fun, then do it. It is a great way to just learn lots of random things and get a lot of experience with programming, but it doesn't really resemble real programming, much like interview programming. Mostly a stupid idea, but it just doesn't represent how you really work when you do programming. Do you prefer to read papers physically printed out or on a screen? It's a little bit of a mix if I am going to read on paper. If I am going to read electronically, I rarely want to watch it on a computer screen. I have a remarkable that I'm super happy with.
00:20:55.685 - 00:21:32.565, Speaker A: It's a large E Ink tablet that's great for PDFs. It's black and white or grayscale, which is a little sad, but it's great for just annotations. Screen is really comfortable to read on. I've tried using an iPad a little bit and it's great for annotations and for richer content. But I don't know, I feel like I haven't found the right thing yet. I specifically I want the screen to be the size of a page which like an iPad for example, does not do. Otherwise the text gets too small or you need to zoom and both of them are problematic.
00:21:32.565 - 00:22:24.585, Speaker A: Do you know of the Rust GUI Library Iced I do not. What do you think is the coolest or most interesting feature that's coming up for Rust? Ooh, there are a lot of contenders here. Const Generics is really cool. Like I've written some libraries that use it already and it's just really handy to be able to have like constant Generic parameters like be generic over a number. I think the changes around generators are pretty cool. When we end up getting those generic associated types is going to be a huge win for especially a lot of like async libraries. If you look at something like Tower, it'll completely change how we write the traits and stuff there.
00:22:24.585 - 00:23:15.961, Speaker A: Inline assembly, I think is also going to be pretty big, mostly because it lets us disconnect Rust from what LVM does, which is pretty important if you want to try using different backends for rust. So things like if you want to use Crane Lift or something as the compilation backend for Rust. There's also some of the work on like Chalk and Polonius, which I think is going to make it much nicer to work with the borrow checker in particular, but also some of the trait system. For example. One thing I really want is the ability to have partial borrows. So this is something like you can call a method that takes self, but imagine you borrow like self foo and then you want to call a method that takes self. Currently the compiler won't let you do that if they're both mutable borrows.
00:23:15.961 - 00:24:01.055, Speaker A: Even if the method you call doesn't use self foo, which you've already borrowed and split borrows or partial borrows are, in a way you could express that this method only borrows these fields. There are a lot of open questions there. It's not something that's going to land anytime soon, but it would be pretty neat. Cuda is the name of the Nvidia GPU thing. Thanks. How about the ethics regarding the sort of problems that ML should tackle, given the inherent difficulty of debugging these systems? I think it's a real problem. I think we're in this space where there are really cool technical developments happening, especially in the machine learning space, but in machine learning, in computer science in general too.
00:24:01.055 - 00:24:39.969, Speaker A: Computer science is a very young field and I think we're going to see a lot of progress in the coming years. And that's great. But I do think we need to, as software engineers, be very aware of what are the implications of the stuff we're doing. And very often the answers are not black and white. It's not clear that things are just good or good or just bad. Even just like companies are not necessarily just good or just bad. The real world is complicated and for something like machine learning approaches, it's worthwhile to think carefully about whether something is something you should work on an important problem and the extent to which it can be abused.
00:24:39.969 - 00:25:46.851, Speaker A: And I think Part of what we need is just like good standards, ethical standards, but also sort of codified law of what should we be okay with machine learning systems being used for. Do you see Rust as a general purpose language or do you think it's more suited for a particular domain? I see Rust as general purpose. The reason I hesitate is because there are definitely some domains where Rust is not right front end code, for example, even though there is like webassembly for example, you probably want to write in TypeScript if you're writing. If you're writing. If you're writing something that interacts with vendor libraries like I mentioned before, you might actually want to use C or C just because that's what the existing vendor library is implemented in. And trying to cross those boundaries is hard. If you're working with people who.
00:25:46.851 - 00:26:34.965, Speaker A: If you're trying to offer a language to people who aren't programmers, then something like Python for example, or R have a lot of value because they aren't going to. They don't need the low level control and the low level control makes it hard for them to write code that runs. And so in those settings you might make different trade offs. But certainly for me, I haven't found the need for any other language except sort of JavaScript for browser based stuff in quite a while. The state of Rust networking, quite good. I don't have that much to say about it. It is certainly true that there's a lot of sort of churn in the, in the Rust Async ecosystem, but I think the networking story is pretty good.
00:26:34.965 - 00:27:14.475, Speaker A: And certainly in terms of performance numbers, Rust does pretty well. I would much rather use C than Go. That's tougher. One of Go's biggest advantages and one of its biggest disadvantages is how simple it is. It's a major advantage once you have very large code bases with many people working on them. But the downside is that your code often ends up being pretty verbose because you just don't have all these features or there are a bunch of things you just can't do, like write your own custom map implementation. Have you ever done 3D modeling with Blender? No.
00:27:14.475 - 00:28:16.079, Speaker A: Any language language recommendations after Rust? Say your second favorite language? Second favorite language? That's tough. You know, I like Bash, which is weird, but it's the language I use the most after Rust. I think there's sort of syntactic languages like I like Markdown a lot, but it's not really a programming language. I do use Python a fair amount. I've used Ruby a Fair amount. I don't know that I have a good second language really. Any books you particularly like? What kind of books? Fictional or factional? Fictional or like what is the opposite of fictional? Like books on particular factual topics unrelated to programming.
00:28:16.079 - 00:29:03.087, Speaker A: Do you play any musical instruments? I don't. I really want to. I started learning the guitar ages ago when I lived in London and I just like, for various reasons ended up not bringing my guitar here and so I have now stopped learning it and have therefore presumably lost all knowledge. I really want to learn to play the piano, but I don't have a piano and I feel like I would need lessons to actually learn it well. But I do really want to. So one day you'll hear the I'll make a little jingle for Jay Russ uses linear type systems what do you think about quantitative type Systems like in Idris 2? So formal methods Languages I have mixed feelings about. I think they're really cool in what they enable us to start doing.
00:29:03.087 - 00:29:57.815, Speaker A: Being able to have machine check proofs about the behavior program is amazing. I worry that currently they're too hard to use for real things and bridging that gap is hard and I don't have good answers for how we do it. And I think that's much of what the research is going on is this sort of how do you do this sort of push button verification where many things are automated. You work in a language where you have many of the niceties that we're used to without that adding too much proof burden and it's difficult. I don't think we have the right balance there. I do think that one advantage Rust gives us is that it adds some of those things to a very pragmatic language, which I think is easier to see widespread adoption than trying to have a very strict formal language where you then try to ease it into being approachable. That's not to say that they can't get there, but I think the path is longer.
00:29:57.815 - 00:30:37.219, Speaker A: Do you have plans to cover a distributed systems project in a future stream? In what sense? Like building one? Probably not. I mean it could be fun to implement like Paxos or Raft or something. So maybe, but that's a much larger endeavor. Your favorite flavor of bagel? I really like Asiago cheese on bagels. I'm also just like a fan of just the classic everything bagel. Love the new intro. I love the new intro too.
00:30:37.219 - 00:31:09.785, Speaker A: Nom nom, nom, nom nom. Sorry, I know I'm far behind chat, but I'm trying to catch up. Any advice on writing efficient servers which handle millions of connections, tips for efficiency in terms of throughput and tail latency. It's hard. You probably need to use asynchrony. In theory, something like Tokyo should work pretty well, like under the hood. That sort of simplifies to edge triggered E pole stuff.
00:31:09.785 - 00:32:03.405, Speaker A: Hopefully one day we get something that works even better with IO uring. In theory you could write your own stuff that uses Intel DPDK or something, but it's pretty hard to get that stuff right. I think one challenge you run into with most of the traditional implementations, including things like Tokio or Async STD or small for that matter, is that they ultimately are using the same mechanism for interacting with the operating system. And so you end up just hitting the operating system a lot. And this is one thing through system calls, which adds a lot of overhead. And this is one thing where iouring tries to make things better, where you can do this pole based thing in user space instead, where you don't have to cross the kernel boundary which has the potential to improve both your throughput and reduce your latency quite a lot. Or you could look at more research systems like I forget the names of them now, but things where.
00:32:03.405 - 00:32:33.535, Speaker A: If you look at Dune, for example, there are a bunch of papers based on Dune that basically tried to do full kernel bypass. So the application runs almost directly on the hardware without having to interact through the kernel. And this lets you optimize performance way farther. Farther. Higher education versus certifications I think certifications are useless. I think higher education is. Higher education is not necessary, but it is valuable.
00:32:33.535 - 00:33:09.143, Speaker A: And what I mean by that is you don't need to go through the classical education pipeline to learn the things that are important. That's just like not true. But it is a useful way to learn things. And there's a lot of stuff that you learn there that is really useful in certain types of jobs. Examples of this are things like the things that always come up, right? Like is design of data structures and algorithms. There are a lot of programming jobs where that is not relevant and then you shouldn't need to learn it. But there are a lot of places where like things like big O notation and complexity analysis are useful tools to know.
00:33:09.143 - 00:34:01.717, Speaker A: And that's not to say you have to learn it through higher education, but they are things that are worth knowing and you happen to learn them there. I think ultimately it comes down to do you enjoy learning in that setting? Do you feel like you can learn in that setting? If you can, then go for higher education. If you don't then learn on your own, that's fine too. I often find myself missing self referential structs, especially when I try to wrap some functionality behind a single type to provide an ergonomic API. Do you find yourself in similar situations? If so, what are your go to solutions? I used to, but not so much anymore. The only places where this really comes up for me are in parsing situations where I want to be able to give out zero copy types of parsing. You can use crates like rental, although I think maybe rental is deprecated now, but there are a couple of crates that are in that space to try to provide self referential structure with someone.
00:34:01.717 - 00:34:42.463, Speaker A: Safety and PIN actually helps a little bit there. Pin makes it so that you can more easily write safe self referential things. Whether this will land in Rust proper I don't know, but maybe use SIMD and Norio just rely on auto vectorization. Norio does not use simd. It probably could. Noria's implementation is not so much focused on like single core performance. There's a lot of work I could have done on SIMD optimizations or currently it stores every row of every view as just a vector in a hash map, which in theory you could do column based storage which saves you a lot of allocations and make all things faster.
00:34:42.463 - 00:36:00.035, Speaker A: But that's not where Noria tries to innovate. Have you ever used tracing? If so, what are your thoughts on it? I think the tracing crate is really cool and I have a lot of belief in that approach and in fact in Noria I've started implementing tracing and I implemented this crate called Tracing Timing which consumes the events generated by tracing and instead of printing them like a logger which is what tracing is often used for, it times the inter event times and gives you histograms so you can look at like in my HTTP request handlers what are the latency distribution between say the receive and respond events across all executions of my program and it's really cool that you can just sort of instrument it that way without having to change the application. You just switch out the the consumer of the events. Have you ever done game dev Rust or not? During my bachelor I did a little bit of game programming just sort of 2D games that were really stupid. I wrote them in Java. I think it's a really cool space. I think it would have been really fun to try my hand there because they're also working on a lot of projects and problems that I find interesting like high concurrency, low Latency type stuff.
00:36:00.035 - 00:36:50.545, Speaker A: Unfortunately, there aren't that many game companies doing Rust currently, and the biggest one, Embark Studios, are not based in the us, which means that I couldn't work from them, from LA because I'm not a US citizen. But maybe one day. What was the side project that got delayed? If you can talk about it, I cannot yet. But maybe one day. Would you be interested in contributing to a Rust game? Man, if I had the time, I would. I don't currently have the time, but maybe one day. What are some of the ideas that inspired you or that you found beautiful? Amazing, neat and simple, but profound? Ooh, you know, none that really come to mind.
00:36:50.545 - 00:37:33.445, Speaker A: There are a lot of things that are neat, but none that stand out to me as like, this just blew my mind when I saw it. There are some things that are fascinating or possible and for me some of those are like Paxos, for example. It's just like crazy that it works out in every case and. But. But that's the best I can think of. I'm just constantly amazed that anything works at all. I feel like the more I dig into any kind of software, the more I feel like it's amazing to me that program like computers mostly boot up and don't crash.
00:37:33.445 - 00:37:58.735, Speaker A: That's more in my opinion. Now I do think that in general, maybe part of the reason I'm not. I don't have those sort of, wow, that's amazing. Is because if I find something that is that way, my first instant is to dig in and figure out how does it work. And then some of the magic goes away. But I learn more. When do you graduate and get your PhD? When I finish my thesis and hold my defense, which hopefully will be by the end of October.
00:37:58.735 - 00:38:47.815, Speaker A: Can you give an example of the other ways to program other than object oriented programming that Rust provides? Rust is not object oriented. It uses the trait based system, which is not object oriented. Really? How do you pronounce your name? So my full Norwegian name is Jun Fnan. In practice, Americans can't pronounce that and neither can many people around the world. So I usually go by John Jengset, which is really just ignore the G's in the surname. That works pretty well. Any resources to understand memory orderings better? I never seem to fully internalize them.
00:38:47.815 - 00:39:32.095, Speaker A: Memory orderings are really hard and they're not well documented. They're basically whatever the CPU feels like, although not quite. It's whatever LLVM implements. And it's really complicated because you also get into things like happen before relationships between different parts of your code. I haven't found any good resources on it really, except LLVM has a page on memory orderings. Read it many times is the best suggestion I can have. And if one of you reads it a lot and understands it, write a blog post about it and explain how it all works and then get people to vet it because probably it's wrong the first time around.
00:39:32.095 - 00:40:10.355, Speaker A: When do you first notice or start programming in Rust? I first started programming in Rust just before I started Noria, which. So I started grad school in 2014 and in 2015 is when I started Noria and that was in Rust. So five years ago for online teaching. What do you use to draw with? So I have like a Huion drawing tablet. I don't know if you can see it. It's orange. It's like the HS610 I think it's called.
00:40:10.355 - 00:40:25.015, Speaker A: And then I have. I just use my Paint, which is a Linux based drawing software that gives you like infinite canvas and stuff. It's pretty nice. You have a schedule for the next crust of Rust. I do not have a schedule. My. My schedule is too unpredictable to have a schedule.
00:40:25.015 - 00:41:13.937, Speaker A: But my hope is that once I move and things settle down a little bit more into a rhythm, I'll be able to actually set a schedule and that'd be pretty fun. Thoughts on the Rust Evangelist Evangelism strike force and rewrite and Rust memes. I mean it is true that there's some amount of evangelism around Rust and in some sense I think that's deserved. Like I really like Rust and I agree that it's a language that deserves some, some evangelism. At the same time I, I also understand that the pushback of like we're sick of hearing about it. Stop talking about it. Programmers gonna program like I don't, I don't think there's a solution to this.
00:41:13.937 - 00:41:56.111, Speaker A: I think talk about things that you think are cool. I think touting Rust as the solution to everything and rewrite everything it's Rust in Rust is not the right approach. Both because it's not really true. Like there are real considerations why you might not want to do things in Rust and that there are some use cases where Rust is harder to apply. It's also learning it is a pretty big barrier and getting contributors to learn it is even more for an open source project and it's also just unproductive. Chances are if all you're saying is rewrite it in Rust, people are going to have this instinctive Response that is, I hear that everywhere. I'm going to ignore the argument as opposed to actually sitting down and consider it seriously.
00:41:56.111 - 00:42:33.097, Speaker A: And so you want to try to be rational and reasonable about this whenever you can and try to stay somewhat objective, like call out things that are also bad. Not everything is perfect about Rust, and I'd be wildly surprised if that was the case for any programming language. The goal is that over time you improve. I want to develop a database engine like Noria. Where should I start? Which books would you recommend? You're embarking on a very big journey. Figure out what problem you want to solve first. Saying I want to write a database is a massive undertaking.
00:42:33.097 - 00:43:10.569, Speaker A: Start with developing a core that matters to you and then build out from there. I do recommend that the SQLite documentation and code was a great help in developing at least the SQL parts of Noria. They have some really good documentation, they have good tests and good code. So that would be a good place to read. I already answered that. Is big tech becoming too large and stifling innovation in some fields because the companies are becoming too big and are basically monopolies that devour the competition? Yes and no. Some of these companies are certainly large enough that they can sort of swallow projects as they come up.
00:43:10.569 - 00:44:06.955, Speaker A: At the same time, I think the answer here is just don't allow them to buy you. Like if you, if you start something that you believe should be its own thing and they approach you with a lot of money, say no. Now you can't always do that because investors have a say in that kind of stuff. But I feel like it's not so much the problem is the big companies because a small company can move a lot faster often and can come up with like crazy ideas that someone just had and build them. The problem becomes when it becomes easy to swallow them, which like is part of at least in the us the sort of the startup culture, there's a lot of this sort of aqua hire just like buy companies aiming to do an exit, that kind of stuff. And I think that is part of the reason why we're seeing these companies being swallowed up. And so I don't think it's just on the big tech side.
00:44:06.955 - 00:44:56.805, Speaker A: Do you have a guess on how long it will take before we have Async fn in traits? Are there major technical blockers or is it more a matter of people resources to work on it? I don't know. I know that many people know it's important. I'm sure that Rust is lacking people and so certainly having More people would help. The biggest thing Rust needs is for companies to pay people to work on Rust itself. That is slowly happening, but that is certainly just like manpower is something. And paid manpower, like people who can actually devote their resources, like hiring people to work full time, I think is the way to make these things move faster. I don't know of specific technical blockers, but I'm sure there are some, otherwise it would have landed.
00:44:56.805 - 00:45:28.765, Speaker A: Have you worked with the hyper library? Can you show how to write middleware for the server? That's probably too technical for this, but I'm sure there are examples in the hyper repo. I don't have any recommendations or experience with writing native GUI programming in Rust. Non fiction. See, non fiction is just stupid. It should be fiction and faction clearly. Or it should be faction and non faction or something. I don't know.
00:45:28.765 - 00:46:25.423, Speaker A: What are your thoughts on functional programming? I don't think that everything should be functional and I don't think everything should be imperative. Use the tool that fits for the job. How do you feel about the blockchain? I think the blockchain is overhyped. I think very often when people use a blockchain they could just as well have not used a blockchain and instead use a database. There are legitimate use cases for things like a blockchain and especially for some of the newer developments of blockchains that you think like proof of stake instead of proof of work. But my impression certainly is that it's become a buzzword where many things are built on the blockchain that simply do not need to be your favorite. Rust crates in general.
00:46:25.423 - 00:46:51.545, Speaker A: Too hard. There are too many of them, but Serdi is certainly one I bring up a lot. Rayon is another that they're probably the most common things I bring up to people for ways in which rust is cool because they're just. It's amazing that they can be libraries and do what they do. My questions was about computing books, but of course, if there are any fiction books you like, let us know. Computing books. Let me look at my shelf.
00:46:51.545 - 00:47:39.533, Speaker A: There's a book called the Pragmatic Programmer which I think is really good. There was recently a new release of it. I haven't read it yet, but that book I liked a lot. If you like low level fiddling and stuff, Hacker's Delight is really fun to read. It's weird and obscure, but it's cool. There was also the Purely Functional Data Structures book was kind of cool. It's a little niche, but there's some interesting stuff there.
00:47:39.533 - 00:48:27.035, Speaker A: This One I haven't opened yet, but I've heard very good things about. It's the Visual Display of Quantitative Information by Edward Tuft. And this is a book that explains how you should plot data and present data in ways that are understandable to people. Yeah, those are the ones that come to mind. There was another book a while back called. It was called Seven Languages in Seven Weeks, which is a book that just presents you with seven very different languages that you can in sort of decent amount of detail just so you learn what they are. And that was an interesting journey.
00:48:27.035 - 00:48:57.685, Speaker A: The FreeBSD book is really interesting if you just want to learn like operating system stuff. I think those are the ones that immediately come to mind. Let's see. Are you interested in quantum computer programming? Qubit is coming soon. What is your opinion? Seems cool. I know nothing about it. I know roughly what the computational model is, but that's about it.
00:48:57.685 - 00:49:25.717, Speaker A: Seems like it could be really important based on what I hear, but I don't have enough experience with it. Do you play video games? Which ones? Yes, I play video games. I play a lot of different ones. I actually played a lot of Counter Strike when I was younger. I even hosted Counter Strike competitions at a this huge LAN party back in Norway called the Gathering. I also played. I've played all sorts of games up through the years.
00:49:25.717 - 00:49:42.265, Speaker A: Like I played the Last of Us. I liked a lot. Played a lot of Battlefield in high school. But I also like the sort of more adventure puzzle games like Portal. It's fantastic. Braid if you've ever played it. Great, great game.
00:49:42.265 - 00:50:13.501, Speaker A: There's a game called not not, which was really cool. I think it's like on all sorts of platforms now. Played a lot of the Zelda games. What else? I'm currently playing a game called Townscaper, which is just a really fun little twiddly game where like you. It's a city builder, but you're only really placing blocks. And it uses like progressive. I forget what it's called.
00:50:13.501 - 00:50:31.255, Speaker A: Like progressive rendering. Like it just like procedurally generates what the town looks like. And there's no content in the game, there are no people. There's nothing else than just building blocks. But it looks really cool. I've played a lot of like Civilization, Age of Empires, those strategy games I like a lot. So all sorts of things really.
00:50:31.255 - 00:51:02.995, Speaker A: Was it hard to get into mit? Yes, it took me four tries. I applied straight out of high school, did not get in. I applied after a year of my bachelor's in Norway and did not get in. I applied after I finished my bachelor's in Australia and did not get in. And then I applied after finishing my master's in London and that's when I finally got in. So it took a long time. I think getting good references from people that the professors that evaluate your application know is the hardest part.
00:51:02.995 - 00:51:53.229, Speaker A: There have been a couple of comments in here of like just people thanking me for the videos and it means a lot. I'm not reading them out as questions, but I just want to address this more generally that the reason I've kept doing this and the reason I enjoy it so much is partially because it really feels like I'm teaching people things. Like it feels like I'm helping and that just gives me a lot. Like when people say I've been programming for more than 20 years and you've really helped me understand Rust, that's like that. It's a huge compliment and I don't know how to answer or respond to it really, but I'm very happy that is the case. I'm thinking of doing a few streams teaching graph algorithms in Rust. Does it sound like a good idea? Do you think there'll be enough interest in space? Absolutely.
00:51:53.229 - 00:52:14.515, Speaker A: Try it. I'm not any kind of authority on what people will find interesting. The way I do these streams is I stream stuff that I find interesting and if I find it interesting, that means at least one person does. So maybe there are others. There's a. You should join the Rustation Station Discord server. There are a bunch of Rust streamers there that we can chat about ideas you have for streams and stuff.
00:52:14.515 - 00:52:53.241, Speaker A: What YouTubers do you watch? Not that many, but I do really like summoning salt, which they do. Like video game speedrun world record progressions over the years. Joseph Anderson does really cool video game reviews. Like super in depth. What else? The Slow mo guys I like a lot. What else do I fall? It's a good question. Let's see.
00:52:53.241 - 00:53:06.399, Speaker A: How dangerous is that? It's fine. Let's see what YouTube tells me. What else do I subscribe to? Oh, Julie Null is real funny. Big fan. Sly flourish for D and D, of course. Last week. Tonight.
00:53:06.399 - 00:53:20.079, Speaker A: Yep. What else? I don't even know what else I subscribe to. I hope there's nothing like worrying here. Man shorts are fun. Like D and D. Like mock things. Dr.
00:53:20.079 - 00:53:50.035, Speaker A: Mike has been. I don't watch a lot but he has some like fun reviews of like medical video games that have been funny. Aussie man reviews. Pretty funny. Blood on the Clock Tower is a board game I've been really involved with and they have some really fun videos going through games. Numberphile, really cool minute physics, really cool. CGP Grey, if you haven't watched is fantastic.
00:53:50.035 - 00:54:47.145, Speaker A: He does these videos where he just like dives down a rabbit hole of something completely random and discovers really cool things. Yeah, those are the things that oh Tier Zoo is pretty cool. It's looking at. It's treating real life and the world and the animal kingdom in particular as a video game and evaluating the different classes relative to one another. Any advice on writing a networking crate which provides both sync and async versions of everything without duplicating logic too much? Well, I mean that's easy if performance isn't super important or I should rephrase, if you write it as async and then you provide sync wrappers, you will duplicate very little and your performance will be fine. It'll be great for the async version and fine for the sync version if you specifically want a custom implementation for each. I don't think there's a way to do it.
00:54:47.145 - 00:55:44.617, Speaker A: Maybe one day. But what are some of the big next things for Noria that other people will be working on? There are a lot of things actually. So sharding is a big one. GDPR compliance, authorization and access so things like can you encode your security and privacy policies in a way that autumn? Any query you add automatically gets integrated with the policy and it produces an optimal query graph for computing the results with the policy in mind. What other things? Higher consistency guarantees sort of transactions and stuff. More fine grained fault tolerance like the ability to have a data flow graph and a node in the middle goes down and you want the top and bottom to continue computing and keeping the current state. How do you recover them in the middle? Those are the most obvious candidates for me.
00:55:44.617 - 00:56:39.301, Speaker A: There's also a lot of work on just like additional SQL things like correlated subqueries that could be made better. Yeah, that's like the stuff that most easily comes to mind. Would you recommend any specific crates useful for implementing a browser board or card game in wasm? I don't know enough about that space to really say. Why are you moving to la? I moved to LA because my girlfriend is getting into voice acting and it turns out that if you're in the like art artist or not artist, but the sort of acting industry, you basically need to be in LA in the western world if you want to like establish the necessary connections. I think neither of us really want to be in LA long term, but it's sort of a. That's just the place you have to be. And so that's where we're gonna go.
00:56:39.301 - 00:57:19.765, Speaker A: And then we'll see after like two, three years, something like that, to sort of reevaluate and see, well, where do we actually want to go? Now that has sort of gotten started. So that's why I'm going to la. Any advice from someone just beginning to learn Rust? I'm learning from the book and I watch your videos regularly. Anything else? Watch some of the other Rust streamers and just try to build stuff. That's the best way to learn. Is the remarkable tablet worth it? I've been very happy with it. I haven't tried the new one that just came out, so I can't really speak to that, but I've been pretty happy with it.
00:57:19.765 - 00:58:05.477, Speaker A: Do you think being good in mathematics is good for programming? How good are you in maths? I don't think it matters, but it depends on what programming you do. Like, if you're doing like game programming or graphics programming or some amount of like algorithms work, then mathematics is going to help. But if you're doing things that aren't, that maths probably won't make too much of a difference. I think the big advantage of knowing maths is it teaches you a little bit about formal reasoning and just like how to think about abstract problems. But I don't think mathematics themselves are that important. Are you hired yet? I have some job openings. I don't.
00:58:05.477 - 00:58:42.497, Speaker A: I have not accepted any offers yet. When I do, I'll make sure to let people know. Do you have imposter syndrome? And if so, how do you go about it? So I've always had very high self confidence and I don't really know why. So not really. I think maybe to rephrase that a little, there are things that I know I'm not good at and I'm okay with that. I think you're not constantly going around and evaluating yourself compared to other people. It's just like never going to lead to anything good.
00:58:42.497 - 00:59:23.017, Speaker A: And it's also not realistic, right? Like, it's not as though you have to be as good or better at everything as everyone else. What you need to do is find the things that you enjoy and you feel you're good at and then work with those and ignore the fact that you're bad at some other things or laugh about it. Like it doesn't. It doesn't matter if you were bad at some things because you will be. So like, for example, I know that I'M a pretty good educator and so that's something that I do a lot because I enjoy it and I think I'm good at it. I don't think I'm very good at formal reasoning, for example, sort of in a computer science sense. And so I don't do that much about it.
00:59:23.017 - 01:00:05.555, Speaker A: I sometimes try to learn, but that's like not my primary thing. Where did John who come from? I don't know man. It's from the good old days of Yahoo Being big and I was like, huh, John who? That's the entire extent of the story. And then it just sort of stuck because it happens to be unique enough that I can use it in most places. Is it so that you need to have n number of pages published in order to get a PhD? It really depends on the university at MIT. No, you don't need to have any papers published to get a PhD. There are some universities that have publication requirements, but that's a bad idea and MIT does not require it.
01:00:05.555 - 01:00:56.071, Speaker A: Are there any good resources about low level stuff like open source software, compiler, CPU concepts, internals, that sort of stuff? So I really recommend looking at what's his name? I only remember his username which is Phil Op. I think it's Philip Opperman, but I could be wrong. So he has this blog where he writes about implementing an operating system from scratch in Rust and it's really cool. Steve Klabnik also has this inter mesos that is a similar kind of thing. I think Tim has a book, the Rust in Action book. I don't think it's fully out yet, but that also goes through a lot of the sort of systems aspects of programming in Rust. Those are good ways to learn.
01:00:56.071 - 01:01:27.235, Speaker A: Otherwise there's a lot of just stuff about writing operating systems that's not tied to Rust and is still relevant. The FreeBSD book is a good example. Or just like MIT has this class 6 which is about building operating systems. It's available online, including all the labs. Try that. What about making a crust of Rust recording? Talking about memory orderings? Probably too hard and not really about Rust. Like I don't know it well enough that I'd be comfortable doing that.
01:01:27.235 - 01:02:33.435, Speaker A: What makes you choose Rust over another language like Go? I like the additional features Rust gives you, and the simplicity of Go is not an advantage to me in my use cases. How do you typically go on about debugging distributed code? I've been doing the 6824 raft labs and read your post in it as well. Even with Go it can Be a pain in the ass to do it myself. Debugging distributed code is really hard. I feel like usually the way to go about it is have really good logging and then make sure that your logs include sufficient information that you can reconstruct what happened afterwards. Once you get to really high load, you probably want to actually parse these log files, but use something like tracing and then assign every request unique identifier. Make sure that you can timestamp your logs, collect all of them when you run, and then afterwards if something weird happens, what you do is you correlate the logs to try to sort of construct this timeline of what happened and when.
01:02:33.435 - 01:03:55.161, Speaker A: Actually what I've done a couple of times is basically instrument my code for when different things happen and then I write like a Perl script that just walks all the different text files and figures out what the current state of the system is and then checks a bunch of invariants over the execution log and then highlights things that seem weird. That works pretty well, but it generates a lot of output for and that's specifically for distributed code where you can't just like spin up GDB easily. That's the best I've got. There are some cool research systems out there, although I'm blanking on their names. I want to say pivot tracing was a big one and there was some follow up papers by Jonathan and some other people that is worth reading if you're interested in the academic side of things, but nothing I think you can really use in production at the moment. What are your thoughts on covariance, contravariance, high rank trait bound concepts in Rust? How important are these? From a day to day programming perspective, they are not important at all if you're writing Rust, they are very important for implementers of very specific libraries. Without it, it would be extremely painful to use some of these libraries like in syn, for example.
01:03:55.161 - 01:04:59.145, Speaker A: I think there's a lot of covariance contravariance tweaking going on to make sure that the API is actually useful or usable, but I don't think I've really had to think about it much except if I'm reading those implementations. Garbage collector may be a reason not to use Go. It could also be a reason to use Go depending on your use case. For highly concurrent things, for example, garbage collection is often the problem, or collecting garbage is the problem, and a garbage collector solves many of those problems for you. There's a bunch more about this if you're interested in the stream where we ported Java's concurrent hash map to Rust in one of the recent context free videos, the init order of impulse drops instead of inverse is pointed out. I didn't investigate further. I think I would need more detail to answer that.
01:04:59.145 - 01:05:29.335, Speaker A: The web development on Rust seems immature. It makes sense to try it. Do you think it will grow? I don't think it's that immature. Like Rocket is a pretty mature project at this point, unless you're talking about writing client side code in Rust. But the server side I think is it's true that it's somewhat young, but like Rocket is pretty serious. Dwini Other mainstream languages have lifetimes? Not that I know of. I think there are other languages that have linear typing.
01:05:29.335 - 01:06:04.865, Speaker A: I forget. I feel like D does, but I may be wrong. But yeah, I'm not sure you would have to look it up. Any experience in making your own language? No, I haven't really been doing that, although it seems pretty cool. Is GPT3 going to make developers obsolete? No, I talked about this earlier actually. I think GP3 is cool, but it's not as revolutionary as it seems. More incremental, even though it is pretty impressive.
01:06:04.865 - 01:06:39.431, Speaker A: Oh, someone mentioned that async and traits are blocked on generic associated types. That makes a lot of sense. Anything in particular about Rustling? You don't like bad design decisions or places that need more work? There are certainly places that need more work. This is some of the features we've talked about so far. In terms of bad design decisions. I'm sure there are some. There aren't any that immediately come to mind.
01:06:39.431 - 01:07:26.065, Speaker A: There are decisions that after the fact it becomes clear that they should have been different. One example of this is drop should have taken a pin self pin mute self. There are a couple of others like? Like. It's unclear we really needed both into and from, but that's only with the features the compiler has today. But apart from that I think I've been pretty happy. I'm sure I'm missing something, but yeah, I don't. I can't immediately think of other sort of major mistakes that I think Russ has made.
01:07:26.065 - 01:08:40.545, Speaker A: What kind of libraries do you think are the most lacking in the Rust ecosystem? Well, this is going to sound kind of silly, but enterprise libraries is what's lacking. I think Rust has seen a lot of benefit from having people working on open source sort of take it to heart and start developing it and developing libraries for it. But for real companies to start adopting Rust they really need things like integration with Microsoft SQL Server or with Oracle DB or IBM DB2. And these are things that open source developers don't care about, therefore they don't build libraries for them. Therefore when enterprise businesses look at Rust and see those things missing, they go, well, it doesn't have the things that we obviously need. And the solution to this is for more companies to invest in Rust. I think realistically the open source community is hard pressed for building those implementations themselves, so it needs some kind of Rust sponsorship.
01:08:40.545 - 01:09:27.113, Speaker A: So those are the most obvious ones that come to mind for me. Yeah, there's also a bunch of audio and video processing stuff that would be cool to have that we don't really have, but it is sort of coming. I think we'll see some of this. With the fact that the GNOME project is starting to look a little bit at Both Gnomon and GStreamer, I think are starting to look a little bit at Rust. I also really want a good plotting library in Rust. That's something I've been missing. How do you think I should start learning Async Await in Tokyo? Watch my video on Async Await.
01:09:27.113 - 01:09:45.505, Speaker A: That's how I think you should start. Will you continue working on Noria? Probably not. It's a little unclear, but probably not. I need a. I need a break, I think. Have you played Factorio? For a very short amount of time. I feel like it's the kind of game I could get engaged with, but I feel like I would get bored with it.
01:09:45.505 - 01:10:21.675, Speaker A: Like it becomes too monotonous at some point, I think. What's your background like from before college? Were you always tech focused? You plan on CS from the beginning? I've always been very, really fascinated by computers, probably since I was like 13 and so that was always the way I was leaning. But in high school, for example, I didn't. I never did any. I never took any classes in computer science. That wasn't a thing my school offered. So it was all sort of on my own time on the side.
01:10:21.675 - 01:10:46.667, Speaker A: It wasn't until I started my bachelor's that I really sort of chose computer science. But before then I did do a lot of it on the side and that that's sort of how I got started. Favorite board game? Oh, that's hard. I really like Blood on the Clock Tower. I've played it a lot, I've run it a lot and it is fantastic. Oh man, I'm so far behind on the questions. I'm like 20 minutes behind your questions.
01:10:46.667 - 01:11:09.065, Speaker A: Sorry about that. But that's what happens when there are this many questions. The witness is cool, it's true. Let's see The Braid author is working on a new language. Oh, that's cool. And is streaming on Twitch. Neat.
01:11:09.065 - 01:11:56.835, Speaker A: Do you think standardized testing should be stopped for grad school? I'm about to finish undergrad and want to apply for grad school. I'm just being reminded of how much I hate standardized testing. I think there's been some studies showing that the SAT and GRE bear very little correlation to people who are actually good students or good researchers. I think MIT does not require the GRE precisely for this reason. Part of the challenge is there's a scalability problem of the best way to do this is to interview every candidate. But realistically, many of these big schools just can't do that. You need to have a filtering process and the standardized test provides some of that.
01:11:56.835 - 01:12:36.387, Speaker A: In some sense, I think they serve more as a filter for people who are clearly not good candidates. But even for that kind of filter, it just does not work. This is the same as many of the sort of coding interviews that the companies do that just like, bear very little relationship with reality. I don't have a good solution, but I agree the standardized test is probably not it. What are some good complementary resources to rustlings to learn? Rust. I really like rust by example. I think that's a good way for many people to learn.
01:12:36.387 - 01:13:35.369, Speaker A: And then I think many of these rust streams that have come up is a good way to just get exposed to the language and sort of learn by osmosis. Just by observing people who know the language, use the language and see them get stuck and pick up things that way and otherwise, like build stuff yourself. It's the best way to learn. Do you have to work while studying abroad? So MIT actually pays grad students. So I receive a stipend from mit and under the visa regulations here, I'm not even allowed to work during my studies, so that wouldn't have been an option in the uk. I benefited from the fact that the Norwegian government has this international student stipend that they pay to Norwegian students abroad. So that helped a lot.
01:13:35.369 - 01:13:53.993, Speaker A: But at MIT, no. During my PhD, MIT pays me sort of enough to live on. You are brave for showing your YouTube recommendations. Yeah, I know, I know. It was risky. Is Noria ready for production? No, don't do it. Absolutely.
01:13:53.993 - 01:14:37.763, Speaker A: Try it. But it's not ready for production. I was wondering if you could do a stream where you would show us how to bridge the gap from intermediate level to publishing your first crate with the best practices. I think that if you publishing your first crate is something you can do As a beginner, that's not even intermediate level. Just write cargo, publish Clippy will take care of making it fit best practices to a large extent. How's your experience working with Malta? I will hopefully be joining Brown. Yeah, Malta has been a big part of the NORIA work and if you'll be working with him, I'm sure he will tell tell you about it at length.
01:14:37.763 - 01:15:37.939, Speaker A: He's, he's been great to work with. This is i3 or DWM? Neither. It's BSPWM. It's the binary space partitioning window manager. Highest level of mathematics you'd say is enough for the reasoning you just described Discrete maths. I mean it really depends that in some sense the more you go into the depths of computer science you want to do things like category theory, but like for everyday programming none of that is necessary. How's your teaching evolved over time and what tips would you have for others that want to teach computer science stuff? So I actually watched an interesting talk a friend of mine gave her PhD thesis defense actually on how to do education of basically how to teach people machine learning.
01:15:37.939 - 01:16:47.291, Speaker A: And I think there's some really interesting just educational frameworks. A lot of it is to make sure that people are able to feel like they're introducing value. So if you give people a bunch of tasks they're not going to be able to complete, or you just give them a bunch of stuff to read, they don't feel like they're accomplishing anything and that makes it hard to feel like you're learning and it makes it hard to motivate your learning. And so this is one of the reasons why I enjoy doing these live coding streams is because other people get to work with me, learn with me, but they make progress because at least I know what I'm doing and they can then be learning but also seeing the results of what they're learning. And so that I think having that aspect of we're accomplishing something useful and interesting and seeing the impact of it I think is a big part of doing, doing teaching well, especially in computer science. Huge fan of the llamas. Are they your favorite animal? I don't know that they're my favorite animal, but I really like Jay favorite animal.
01:16:47.291 - 01:17:13.701, Speaker A: I like, really like turtles. I don't have a turtle, but I like turtles. Yeah, I'm so far behind chat. I'm sorry but I am catching up. Actually we really need to ask fewer questions. It's fine. What made you interested in the lab you chose to apply to at mit? Basically the same path as I talked about before that I've just been working.
01:17:13.701 - 01:17:56.745, Speaker A: I've always been interested in concurrency and distributed stuff and like high performance, low level type stuff. And when I found a group that was parallel and distributed operating systems, it seems pretty ideal. Realistically, much of it was talking to the professors, but also just reading papers and being like. A lot of the papers that come out of this group seem to be really interesting to what I enjoyed working on and that's a good way to choose is look at the work that they actually did. In general, asking about current projects, for example, is hard. Reading the website doesn't really get you that far. What really helps is like look at the past few years of conferences, for example, look for papers that you find interesting and then look at the authors of those papers and where they are.
01:17:56.745 - 01:18:29.723, Speaker A: Do you write a lot about documentation? And if so, do you have any tips on how to get better at that? The best way to write better documentation is to read good documentation. And it's just like it's sort of the same as being a good programmer. You need to just have experience with code. With code it's unclear that reading helps that much there. It's more about writing, but with documentation too. Read a lot of good documentation and when you do it, try to read actively rather than passively. Don't just consume it, but read it.
01:18:29.723 - 01:19:00.035, Speaker A: And try to understand why did they include this here? Why is this placed here in the documentation? Try to understand the larger structure of it and then try to replicate that in your own projects. And then just like write lots of documentation. When you start out a project like started with deny missing documentation and really just focus on writing good documentation. If you have a docstring, that's one line, it's probably not good enough. I'm not quite a fan of the like. Everything should have an example, for example. That doesn't really work that well.
01:19:00.035 - 01:19:47.255, Speaker A: But I do think that there's a lot of value in if you document something, it should have longer documentation. If the documentation is basically like the name of the function with some extra words that doesn't add very much and it should arguably not be documented, the name is sufficient. What do covariant, contravariant and invariant actually mean? Topic for a different stream. It's a complicated topic that's. Well, it's just like intricate. It's not that complicated. I recommend you read the Rust Nomicon page on covariance and contravariance.
01:19:47.255 - 01:20:49.945, Speaker A: What will you get for dinner? I don't know what I'M making for dinner today. I think I'm having tuna salad, homemade. Very good. Can recommend Any thoughts on Risk five? I think Risk five is really interesting. It's not gonna be a big thing for probably many years, but it seems like it's a pretty serious effort now and it has some cool benefits that I think academia in particular is going to start picking up. What is the difference performance and efficiency between crossbeam like epic based GC and normal gc? Normal GC is usually better. Not necessarily, but it often is because it has the ability to stop executions of things, which makes things easier.
01:20:49.945 - 01:21:42.575, Speaker A: It has the ability to but if you have a runtime like in Java and go, you can instrument code that's not your own, whereas crossbeam can't do that. And so epic space GC like it just sort of forces you into using slightly less efficient patterns, but it means you don't need a runtime. So there's a balance there. I also think that the crossbeam implementation I've had some experience with it through Flurry concurrent hashmap port to Rust and there seems to be something there that could probably be optimized further. But it is really cool that it can be provided as a library. Do you have any opinions on Actix and Actix Web? Haven't used it, haven't seen the reason, and I'm certainly one of the people who is pretty skeptical about it. Given the history I've seen of the project.
01:21:42.575 - 01:22:14.045, Speaker A: It could be that things have gotten much better now. I don't know. What advice do you have for someone from machine learning who wants to get into high performance computing and systems programming? Where can I start? Ooh, that's a good question. I think you start the same place you would if you started from scratch. You can just probably skip ahead faster than other people can. Start looking at algorithms, data structures. Start just implementing something interesting yourself.
01:22:14.045 - 01:22:52.855, Speaker A: Even just try implementing an efficient concurrent hash map is a good place to start. It certainly has taught me a lot through the years. But even just implement a concurrent linked list or something. Concurrency is certainly something that comes up a lot in high performance computing. Or just try to build sort of multicore applications and try to build something that, I don't know, sorts a bunch of files really quickly using many cores. I've not really looked at the Crystal language. No, SQL X is actually working on supporting the databases.
01:22:52.855 - 01:23:27.025, Speaker A: You just mentioned about the lacking libraries in the Rust ecosystem. That's great. I think what we need is more people from industry working on Rust. That's the only way that the enterprise sides of the ecosystem is going to start to take off and we are seeing some of that. Ooh, a braid remaster is coming out soon. That's cool. What is the red flag in C libraries API that show it would be way hard to safely connect it to Rust? I haven't really seen any of those, but at the same time I've also done relatively little FFI work with Rust.
01:23:27.025 - 01:24:13.553, Speaker A: I think function pointers are the biggest complexity there, but that's all I can really think of. I don't think it's really that hard. It's usually comes more down to size than anything else. What is the best approach to implement an RFC and protocol like HTTP or WebSocket? Start implementing it like usually the RFC has some guide for general protocol design, but otherwise you just start parsing the grammar it gives you. Do you feel like you fully understand Rust? No, I don't think anyone does. There are some people who get pretty close. Like Nico Matsakis is a good person that comes to mind.
01:24:13.553 - 01:24:49.075, Speaker A: But no, I think it's. I think it's a large enough language that there are enough pieces and it also depends on what you mean by understand Rust. Like understand how the compiler works, understand how the tool chain works, understand all the features of the language. Does that include things are still in development? I don't think it's a well defined question. Is there a system on the computer that greatly affects bandwidth stability? Because this problem makes me sad. I don't know what the question is. Can you make a skillshare course on Rust? I like the book but I myself am more of a visual learner.
01:24:49.075 - 01:25:21.475, Speaker A: It would be really fun to develop a course for Rust. It's a lot of work that I don't have the time to do now but maybe one day I'm going to put Nori in production now. No one can stop me now. Dude, go for it if you can make it work. It makes me happy. Do you know of any window managers for Windows? I don't, but I know there's a security researcher called Troy Hunt who's great. I would go follow him immediately if you're not already.
01:25:21.475 - 01:26:03.855, Speaker A: And I think he uses Windows and I think he had a recent blog post on his new working from Home Setup and part of that he talks about his Windows window manager which is sort of tiling based and stuff. Very keyboard oriented. That might be something to try. Who is your friend to give the talk in machine learning? Can we see the talk or paper? Her name is Natalie Lau. I Think she's considering actually like recording her thesis defense and putting it online, but I don't know of it yet. Do you think Latex is a good way to write good documentation or is there a better tool? Do not write your documentation Latex. It's a terrible idea.
01:26:03.855 - 01:26:39.949, Speaker A: Don't do it. Depends on what you're writing documentation for. But in general, no PDFs are a terrible way to be consuming code documentation. You want things like interlink, automatic links to source code, things that build on other people's computers like use rustoc. If you're using Rust. Where do I find good papers? Any recommendations? Look for computer science conferences, some of the big top tier conferences in fields that you care about. And look at the papers who were published over the past few years or just look at like the.
01:26:39.949 - 01:27:26.213, Speaker A: They usually give out sort of test of time awards that are papers that were published many, many years ago and that are still considered important. Those are a good place to start. Or just look for university classes that are research oriented about the topic. So MIT is a class on distributed systems, for example, like 6, 8 to 4, which I've TA'ed before as well. And there the website and the curriculum for that class has a lot of sort of traditional, well established papers on the reading list. Go read those. How do you deal with loss of motivation on a project that has a huge roadblock? This is something I've hit a decent amount actually just with noria.
01:27:26.213 - 01:28:00.485, Speaker A: It's a project that has gone on for so long, so I've certainly had periods where I felt a bit of burnout and it's hard. I don't have a good solution. I think the two primary recommendations I would give is if you're starting to feel burnt out, especially in a PhD then stop working on it for a bit. Like it's okay. You have a lot of time in your PhD. You have a lot of say over how you spend your own time. If it's not worth forcing yourself to work on something when you won't be productive because you'll be less productive for longer.
01:28:00.485 - 01:28:58.027, Speaker A: If you instead just like don't work for a week, work on something else, then that's going to. If you get out of that rut, you'll be far more productive coming soon and that's probably going to be better than if you were lower productivity for longer and separately from that, like find side projects. I think for me, one of the, one of the things that helped a lot with me getting burned out with Noria was having things like these streams that let me do something else where I feel like I'm productive in accomplishing something. Because that means that even though if you're like roadblock on this project, if you only had that, you might feel like you're not making progress, that you're like stagnant. And that's where things like imposter syndrome start to come in. But if you have something else you're doing well on, that helps keeps your spirits up, so I'd recommend that as well. And otherwise, if there's something that you need to make progress on, like you're writing your thesis or something like that, try to make like at least make a little progress each day.
01:28:58.027 - 01:29:28.945, Speaker A: And it's fine if it's tiny as long as you're making forward progress. Things are getting better. Let's see, I'm on my third year of CS and I'm going to be learning MPI and programming in C. Do you think it's a bit outdated or is C perfectly fine? C is perfectly fine. C is not going anywhere anytime soon. I don't think you're going to be building new things in C, but it's a worthwhile language to learn. I still think that's very much the case.
01:29:28.945 - 01:30:19.105, Speaker A: MPI is not really the way to do sort of parallel programming nowadays. Like I would rather use Rust for that. But MPI is very well established, very well used, and it is good at what it does. So in that sense it's worth learning. But it's not sort of the state of the art of what you would do today usually. How much math should someone know when learning Rust relative to other languages? I don't think Rust requires more math knowledge than other languages at all. Things like the borrow checker is just not really about math.
01:30:19.105 - 01:30:59.255, Speaker A: If you're better at math or logic or formal methods, it's not going to make you better at things like lifetimes. I think that's focusing on the wrong part of lifetimes. Try to figure out what's happening to the memory in your computer to understand why the code doesn't compile, as opposed to try to formally model it in some way. What do you think about if let chains? I like them, they're fine. If that's a. If that's the right fit, then use that. I guess the question is sort of indirectly is are they better than match? I don't think it really matters.
01:30:59.255 - 01:31:36.099, Speaker A: At the same time, the compiler can probably optimize match statements better than chained if lets. But whatever floats your boat for the red flag in C question Variadics and global variables are probably the most annoying to work with. That makes a lot of sense. Like if you have global state, if you have things you can't really express in rustic variadics, those are a pain to try to expose. They're not impossible, but they are pretty painful. I want to learn Cuda. I was wondering this is like GPU programming for Nvidia GPUs.
01:31:36.099 - 01:32:27.653, Speaker A: I was wondering if it's worth learning it in Rust or is it better to use C and C has better tutorials. If you want to do Cuda, probably learn it through C like Cuda. The language that Cuda presents you with is basically C anyway, or some mix of C and C, so you'll probably want to learn that regardless. And then even if you start using the Rust bindings later, chances are what your the kernels are written in something that's more C like Laptop Recommendations the Lenovo ThinkPad X1 Carbon is the laptop I've been using for the past 8 years. Like different generations of it, and I've been super happy. Do you speak any language other than Norwegian and English? Technically? Some Spanish. I would not.
01:32:27.653 - 01:33:23.935, Speaker A: I would not call myself a native Spanish speaker by any stretch of the imagination. What are your PC specs? I have a an AMD threadripper 2600x like a 12 core CPU. I have 16 gigs of ram, 32 gigs of ram somewhere around there. I recently switched from a GeForce GTX 1060 to an AMD. What AMD card do I have? The RX5700 because Nvidia on Linux is a pain. Any time management tips how do you balance your thesis? Side projects, open source contributions, relationships, et cetera. It's hard, especially when writing your thesis.
01:33:23.935 - 01:34:02.027, Speaker A: It's just like you're spending so much time working on it. And when you're a PhD student, there aren't good boundaries for whether you're spending too much time, too little time. Like if you, if you work, you have like you're supposed to work 40 hours a week or something. As a PhD student, you're sort of supposed to work 40 days a week. Realistically, you work all the time, you're not working and you have this weird incentive structure where you need to work because you need to finish, and anytime you take a break you're delaying your eventual finish, which is a bad mind state to have. I think it comes down to work on things when you're productive with them. Trust your brain a little bit.
01:34:02.027 - 01:34:49.541, Speaker A: If you are not feeling productive with your thesis writing, then go do something instead that you want to, because you're way more productive when you're working on things that you enjoy doing. And then at some point, hopefully, at least if, hopefully, your thesis work is interesting, otherwise you have other problems, right? But if you're feeling a little bit fed up, you're feeling a little bit stuck, go work on something else that your brain is like pulling you towards. Oh, I want to think about these things instead. And then after a while your thesis is going to creep back into your thoughts and that's when you go back and work on that. So sort of have it be driven by what you enjoy doing. Is it worth teaching Rust rather than C in colleges, or do you think students still need C basics to understand Rust? I think you can learn Rust first. I think there's still value in learning C, but I think they're independent.
01:34:49.541 - 01:35:18.479, Speaker A: I don't think you need to learn one before the other in either direction. I think teaching Rust in universities can work. It can be a little bit of a higher barrier in some cases. It depends the way, like what you're trying to teach them. I don't think C is easier than Rust. And the reason being in C, you're more likely to shoot yourself in the foot and have things crash at runtime. And it's better if the compiler can tell you this thing is wrong and give you helpful examples rather than you ran your code and it crashes.
01:35:18.479 - 01:36:08.285, Speaker A: Like for. For. For a beginner who's learning programming, it's a lot better to have the compiler give you helpful error message messages than being told like core dumped. What are the big CS conferences you mentioned? It really depends on the field. I don't know about many other fields in system specifically there's like nsdi, osdi, sosp, ures, hot os. Sure, there are other others I'm missing, but those are the first that come to mind. Rockets author Sergio Benitez is not teaching Rust at his university, I don't think, but he is finishing up his PhD at Stanford, I think.
01:36:08.285 - 01:37:11.305, Speaker A: Oh, I'm catching up to chat. What do you think about using Rust to develop AI and machine learning? What are the benefits as opposed to Python? I think the benefits with using Rust over Python for machine learning is that it's easier for you to hook into the internals without losing performance in Python. Python is efficient because you have building blocks that are built in other languages that you can hook together and then they are still performant because behind the scenes, not Python that's running, but the code that hooks Things together is allowed to be slow because it's sort of the control plane and not the data plane, which is what needs to be fast. With Rust, you can in theory at least write code that is in the data plane, in your control plane and have it still be fast. So that's a benefit. But it also means that there's more of an onus if you allow that to be done. It's more of an onus on the developer to make sure that they don't slow things too much down by using those features.
01:37:11.305 - 01:37:42.425, Speaker A: But it is true that Rust has a much more. Sorry, Python has a much more well developed machine learning sort of space currently. Like Python is just a better language for doing this with solely because it has better support, better. Better libraries, better tutorials, more people working on it, more attention. So. So in that sense Python is better currently. I don't think that Python is fundamentally better for machine learning stuff.
01:37:42.425 - 01:38:04.975, Speaker A: 40 days a week. I meant 40 hours a week. Good catch. Will you end the stream when you catch up with questions? That's a good question. Maybe that's what I should do. Thoughts on async drop and cancelable async processing seems like a prereq for structured concurrency. Async drop is really complicated.
01:38:04.975 - 01:38:41.875, Speaker A: I don't have the answers there. I know there have been some proposals that have shortcomings. Structured concurrency is really cool, but it has some challenges with getting things to work with existing code if you want things like being able to spawn futures, for example. Part of the challenge is that we already have an ecosystem that relies heavily on the drop trait, on having destructors. And structured concurrency fits really poorly with having destructors that can happen at any time. And you sort of need async drop. But we don't have async drop and we have a lot of code that uses drop.
01:38:41.875 - 01:39:25.625, Speaker A: It's just. It's a mess. I don't know what the solution here is. I think we're going to need some sort of brilliant insight, sort of like what we had with pin, before we figure out what's going to happen there. I do think async drop is important because the number of times I've written implementations of libraries that there needs to be a shutdown method because you want to hang up with the other side cleanly. Imagine you're interacting with, I don't know, MySQL you could just drop the TCP connection, but realistically you probably want to send some messages to close things up. And you can't do that in drop because drop isn't async.
01:39:25.625 - 01:39:54.315, Speaker A: You can't. So what you end up doing is have a function that consumes self. That's async. That's called shutdown or close or something. And the user just has to remember to call it. And if they don't, you do the best you can and it works okay, but it's not great. I don't know how we figure this out, but we sort of need to Anything that should be added to Missing Semester Love the metaprogramming lecture.
01:39:54.315 - 01:40:58.665, Speaker A: I don't know of anything that's obviously missing, but I'm sure there are things we certainly have gotten a lot of feedback on the class, but in general it's been positive. It's funny that you mentioned the metaprogramming lecture, because that one has maybe the most controversial name of all. I don't think think metaprogramming is the wrong name for that lecture, but many people who have experience with the other the existing meaning of metaprogramming disagree, but I'm glad you liked it. Have you seen any documentation tools better than what Rust has? Not off the top of my head, but I also Rust is by far the language I have the most experience with, so I might not be the right person to ask. Are your dot files on GitHub up to date? Your desktop looks like it's i3, but I only see configs for X monad. They are up to date. I'm not using i3.
01:40:58.665 - 01:42:13.117, Speaker A: I'm not using Xmonad either anymore. I'm using BSPWM and Polybar also. When will you try Wayland? The moment OBS has good support for Wayland, I'm happy to switch, but OBS currently does not have good support for Wayland. So what year of 6824 class are you in? ITA 6824 in 2015? 2015 or 2016? Did you know what to pursue while studying in universities? Are you confident that whatever you're focusing on right now is what you want to learn the most? I don't think that's the way to think about it. Think about what things do you want to learn and then learn those things. You're not committing to doing something for the rest of your life just because you study it, right? In fact, for example, for my PhD, it seems unlikely that I'll be working on like dataflow databases for the rest of my life, and I don't want to. And I think the thing to remember is that you learn a lot over the course of your PhD, and very little of it actually is related to the concrete thing you write your thesis on.
01:42:13.117 - 01:42:52.845, Speaker A: You may be like a sort of big expert on that specific thing, but that doesn't mean you have to work on that. You learn a lot about how to learn. You learn a lot about just various of the dependencies you have in your thesis. You learn significant amounts of. And you can sort of pick and choose and you can always learn more things later. Don't think about it as like your choice is the be all and end all pie or tao. I like pieces, but I've also seen some convincing arguments that tau is better.
01:42:52.845 - 01:43:03.405, Speaker A: I don't. It's. I have. It's not a hill I'm willing to die on. So I'm gonna. I'm gonna. I'm gonna claim that either is fine.
01:43:03.405 - 01:43:35.055, Speaker A: Is there a specific problem you've solved or program you've written that you're very proud? I really like evmap. This is the data structure that I talked about in the rusted speed talk from 2018. This is the sort of. You keep two maps and you have atomics and counters to swap between them correctly. I think it's just a really cool data structure. I use it a lot in Noria. It's done really well there.
01:43:35.055 - 01:44:22.395, Speaker A: I think it's really neat. That's the first one that comes to mind. What are your thoughts on ecosystem splitting in terms of async runtimes? I covered this earlier in the Steam, so I'm not gonna go over it again. Can you explain pin? I have like a four hour video where I explain pin and so I recommend you go watch that video. It's very hard to cover it like in five minutes here. What's your favorite local or not coffee shop or restaurant? I don't know that I have a good answer to that. There's a restaurant here in Boston called Mei Mei that makes really good food.
01:44:22.395 - 01:45:16.145, Speaker A: They make these like, like almost like scallion pancake sandwiches. It's really good. Can recommend what was the brilliant insight with pin? So the insight with PIN was really that all of the problems around self referential structs could be solved with pin, which could be a library. And getting to what that minimal set of things it had to do and what its guaranteed guarantees had to be getting. There was a lot of work, but it just worked really well and didn't require the language to change in like fundamental ways. Will you do more streams like this one? Probably. I mean, do you feel like the stream was useful if you if people found this stream useful, then I'm happy to do more of them.
01:45:16.145 - 01:46:31.015, Speaker A: How good is Rust for microcontroller programming? I haven't tried, but my my impression is that Rust actually works really well for embedded devices these days, but I don't know Book and resources recommendations for parallel and distributed computing I would go check the 6824 website so 6824 is the MIT class on distributed systems. It's taught by my advisor amongst other people and there's a lot. But the whole class is available online, all the labs are available online, all the tests are available online, and all of the reading lists and papers that they list to are online. It's a great way to just get a sort of survey of the field. I think they even have videos of the classes from a few years ago. I highly recommend looking at that. If you're curious, does your code style align with what Rust wants to do, or do you find you've fought with Clippy or even the compiler over non issues like having the open squiggly bracket on its own line versus on the same line as the if? So I'm of the opinion with code styles that consistency across developers and code bases is way more important than what I like.
01:46:31.015 - 01:46:57.737, Speaker A: So I do whatever Rust format does and that works well. I think people who have curly braces on a separate line are maniacs. So luckily Rust format does not do that. It doesn't sometimes, but. But no, don't do that. It's bad. As for Clippy, Clippy has some lints that should not be on by default.
01:46:57.737 - 01:47:41.355, Speaker A: There was a cool I wonder where that Ooh, that's the wrong place. Let's see here. This is going to be bright because I'm going to switch to GitHub here. Ah, I also can't type cargo, so this issue was pretty cool. So this is basically David Tolnay went through and looked for Clippy lints that are most often ignored and argued basically that these should not be on by default because everyone ignores them. And if some of these went away I'd be pretty happy. Like cognitive complexity, although I think that one has already gone away.
01:47:41.355 - 01:48:30.959, Speaker A: Too many arguments and type complexity are basically often ignored and those are some things that have cost me annoyance in the past. I'll paste this to the chat as well, but apart from that I've been very happy with Clippy. What are your thoughts on the opportunity cost of going to grad school instead of going to industry? Practical experience, finances, etc. Going to grad school is not worth it for the money. You should not go there if what you care about is like financial benefit. The opportunity cost there is not worth it in terms of whether you should do it, ignoring the money or taking the money into account, but not having that be the only factor. It depends on whether you want to, like, don't do a PhD because you feel like you have to.
01:48:30.959 - 01:49:11.441, Speaker A: It is not worth it. You can get the same experience learning on your own, going into industry, that sort of stuff. What doing a PhD gives you is the freedom to work on a very like, diverse set of problems. You get to work very much on your own time, on your own speed, and you get to work on things that aren't necessarily like things that people will pay for. If you work in industry, you sort of need to work on something that other people are willing to pay for, whereas in academia you don't need to do that. You have a lot more flexibility in just working on things that you think are interesting or fascinating or important. And you also learn a lot more about learning.
01:49:11.441 - 01:49:44.655, Speaker A: You're in a learning environment, you're working with people who love to learn. And that's a lot of what it teaches you. But, but the PhD is long. It's like, well, I mean, it depends on your field and your area of expertise, but like mine is about six years. It requires a lot of self discipline. No one tells you like you have to come in this and this time or tell me when you go on vacation like that you, you're in charge of your own time and what you do. But that also puts a lot of responsibility on yourself to make sure that you do things that are important, that you make progress, that you eventually graduate.
01:49:44.655 - 01:50:29.885, Speaker A: So is it worth it? If you think it's interesting and fun, then it's worth it. If you are doing it because you want to have that paper, it is not worth it. I open a PR to the Rust compiler with the bulk of the work done, and I've been having difficulty getting a few questions answered for finishing touches. I don't want to pester anyone, but I'm kind of stumped on my own. Any advice? It's tough. Like this is one of the reasons why I say that the Rust project needs more people that are sponsored by industry that are full time because the Rust project is very large. But it's, it like survives because of a small number of people who are devoting a lot of time to it.
01:50:29.885 - 01:51:08.085, Speaker A: And we just need to see more people getting pulled like paid to work full time that will solve some of those problems. In terms of what to do. Right now, the easiest thing I can imagine is interacting on the Zulip, like on the actual chat. That might be the best way to ask these questions rather than leaving in a PR where a bunch of people might not see it, like join the compiler Zulip, for example, and ask your question there. Because there you might get a sort of quick answer from someone who's not directly looking at your pr. Do you develop any activity not related to coding, like practicing sports or any hobby? Probably. It's challenging to do while having to do a Ph.D.
01:51:08.085 - 01:51:50.165, Speaker A: well, so I have a couple of things like this stream, for example, like this sort of education part I do a lot. Apart from that, a big thing for me is I run a lot of D and D campaigns and play in D and D. And that I think is really fun. Board games in general, in fact, is a big thing that has certainly taken up a bunch of my time. I used to run the a weekly board game night at MIT in the computer science department. Of course, these days that's not really happening anymore, but that was certainly one of my big things. And Blood on the Clock Tower, which is this big social deduction game that's like still in pre release but is probably going to come out like start of next year.
01:51:50.165 - 01:52:22.795, Speaker A: Like I've spent a lot of time with that. I've run it at conventions and stuff and that's been a lot of fun. So those are the things that like most immediately come to mind. I also do like I enjoy rock climbing, although I haven't done it in a very long time. The PhD has certainly gone a little bit in the way of that. Where do you see rust in the next 10 years? I think rust is going to keep increasing in adoption. Certainly all I've been seeing in industry.
01:52:22.795 - 01:53:03.495, Speaker A: After I announced I was like looking for work. I've talked to a lot of companies and it really seems like Rust is gaining adoption. It's a gaining speed inside many larger companies and that's exciting and hopefully that turns out well for Rust. I think my biggest concern is whether or not Rust will, whether like one company will take over Rust, like become the dominant driver. I don't think that's the case. It doesn't look like that's currently happening, but that's certainly a concern I have in the back of my head. And I think as I mentioned, finding a way to sustain the project beyond just like a few people paid by Mozilla is hard.
01:53:03.495 - 01:53:37.605, Speaker A: I think we need more people like David Tolnay is a good example of someone who is now paid to work full time on Rust. I mean from within Facebook, working with Facebook and for Facebook, but with a lot of the focus is on working on Rust and the Rust ecosystem and I think we need more people in positions like that. I know Wayland support in OBS is coming. I've seen patches. That was a month ago. Yeah, there are many patches for OBS and Wayland and they seem to have stagnated a little bit. I think part of what they're missing is testing.
01:53:37.605 - 01:54:33.195, Speaker A: I guess now that I'm on like a nightly build of OBS anyway, maybe I should try it, but I just haven't gotten around with it. Also, right now is not the best time for me to experiment with things because in theory I'm like moving in less than a month and in the middle I'm like organizing, moving and writing Thesis and it's just like a lot at the same time. And trying to fix my computer at the same time would not be great. Do you think NPM's node modules can be compared with Rust's package system? I love rust, but downloading 200 to 300 packages for relatively simple program seems successive to me, which happens frequently. That actually happens fairly rarely to me these days. I think one thing that's helped a lot is I have the environment variable cargo target dir set up so that all my projects build in the same target directory. This means the dependencies that are built are shared between my projects as well.
01:54:33.195 - 01:55:19.625, Speaker A: So this basically means that instead of having like one node modules directory, I have a shared one that helps a lot. Tell Anish to stream I actually have already told Anish to stream and I hope people do it. Do you have a special setup to write your thesis? Not really. I just sort of write in the tech. I've set up the template the way I want. It's working out pretty well. What window manager are you using when you switch to Wayland? I don't know.
01:55:19.625 - 01:56:16.315, Speaker A: I haven't looked enough at it seriously to say I've heard good things about Sway, but I don't know. There are cool dark mode styles and stylus for GitHub. Yeah, someone mentioned this in my YouTube comments as well. I just like don't really like dark mode for websites. I I have it on for for the Rust documentation for these streams because I have it open enough and I know that it bothers people enough and it's easy enough that it's worth doing. But for GitHub I actively want it to be light mode. And so I don't want to like install and set up stylus and like find a style that I like for GitHub and then turn it off most of the time and remember to turn it on for every stream.
01:56:16.315 - 01:56:54.045, Speaker A: Like it's just not worth it. Why does having brackets on a new line after an if make you a maniac? It takes up a line and it doesn't need to. The indentation already tells you where the block starts and ends. What advice would you give an 18 year old who has a decent grasp on Rust? Uni or something else? It depends on what you find interesting. Like if you want to learn more about like the academics side of things, then go to university. I do think that bachelor degrees are worth it. Like they're a good way to get this like broad survey of what's out there.
01:56:54.045 - 01:57:18.575, Speaker A: Like a PhD is very niche and very advanced. I think a bachelor is generally worth it because it gives you. It exposes you to all these things you don't even know are out there. And like a bunch of it you won't care about, but at least you're sort of forced to see them. And I think there's value in that. I'm trying to introduce Rust in our company. We mostly use go for web services.
01:57:18.575 - 01:57:56.813, Speaker A: People always point out that Rust is too hard and there aren't enough Rust developers to hire. How would you counter that? Rust is not too hard, it just takes longer to learn than other languages. But it's not too hard. People are productive in it. And the reason it is hard to learn is because it gives you benefits that other languages don't give you. And the other thing to remember about Rust is that you're paying more upfront cost for compilation, which is what makes it seem harder. But if you give up on that stage, you don't get to observe that it saves you time in runtime debugging and it probably even saves you more time than you would otherwise have spent there.
01:57:56.813 - 01:58:39.025, Speaker A: Like remember that it's. It's like saying that C is easy because it's easy to compile a C program, which is like not the right comparison. As for there not being enough Rust developers to hire, that's just not true. I think there are a lot of good Rust developers out there. And in general I think you'll find that the people who have chosen to learn Rust are often fairly skilled developers because they chose to be willing to tolerate that initial learning curve. And certainly from what I've seen, there are a lot of Rust developers out there who are maybe currently in other positions, but would totally pick up a good rust job if one came along. Do you think that a PhD and working industry is feasible at the same time? No, don't do it.
01:58:39.025 - 01:59:10.175, Speaker A: Not worth it. Zulip is sort of like Discord, but it's a little bit more technically focused. It has like threading and stuff. And it's what some of the Rust compiler teams are using. Things you wish you knew before starting grad school. Whether it be advice for getting in or getting through it for getting in. References are some of the most important things for your application.
01:59:10.175 - 01:59:33.887, Speaker A: Your grades are sort of an exclusionary factor. Like if they're too bad, you won't get in, but having good grades won't get you in. Whereas having like solid references and solid things to point to in your application matters a lot more for getting through it. Remember, you're not in a rush. Take your time. Work on things that you think are interesting. That way you will be far more productive.
01:59:33.887 - 02:00:06.469, Speaker A: And keep in mind that there is some degree of self discipline to this. You do need to like find a plan and figure out how you yourself work and how you want to work. Let's see. Stream your dnd. That could be fun. Maybe one day if you're into bouldering, then when you move to LA you should make a trick to bishop. It's mind blowing.
02:00:06.469 - 02:00:39.463, Speaker A: Nice. Do that. Any smaller Rust crates you particularly like? Probably. I like Slab. Slab is cool. Like skipping some just so I can catch up with chat again. Any tips on how to get started with open source projects in Rust? Take a look at some of my videos on open source contributions.
02:00:39.463 - 02:01:05.815, Speaker A: I go through some of that a lot in those videos and give you some. Some like concrete advice for how to do it. And also we actually make some open source contributions right in those streams. Use a specific tool or method for taking notes for your research? Not really. I tried getting on board with like the note system where you have like a column on the left, notes and then a note field at the bottom for summarization. I use that a lot for notes in classes. I don't know that it made much of a difference.
02:01:05.815 - 02:01:26.407, Speaker A: I'm pretty bad at taking notes. Like I don't. Or rather I usually don't. I usually find that I don't look at the notes afterwards so it doesn't matter. And so I'm. I think over the course of the years I've been stopping taking notes unless I specifically know I will need them later. Because it.
02:01:26.407 - 02:01:55.239, Speaker A: I've found that if you are taking notes, you're not paying attention in the moment and if you're not going to look at the notes later, that's just not worth it. As a trade off, it's better to pay attention to the thing that's happening right now. You'll remember it better and understand it better. Do you think the Windows subsystem For Linux version 2 will change development patterns? Or is it more of a toy? I've heard really good things. I've heard people are pretty excited. I just like don't use Windows. I don't.
02:01:55.239 - 02:02:30.085, Speaker A: I haven't used Windows in many, many years. I don't want to use Windows. I'm sure it'll be great for people who are on Windows to not feel sort of excluded by a lot of the software that's built by especially open source people who frequently use Linux. But I haven't really. It's not something I know enough about to really say for sure. I'm sure it makes a huge difference to many people, but I'm not one of those people. Do you think Rust could be a replacement for C as an introduction to programming language? I don't think you should ever use C as an introduction programming languages.
02:02:30.085 - 02:02:55.105, Speaker A: I think you should use something like Python, maybe JavaScript. A little unclear. I think introducing people to types makes a lot of sense. Like TypeScript might be better, but Rust potentially is a good one too. But it is harder to get started with. But it's harder in the sense that the compiler will sort of give you errors more often. But those errors are also pretty helpful, which is good for beginners.
02:02:55.105 - 02:03:43.137, Speaker A: So hard to say. There's an experimental opt in dark mode for and from GitHub. I might try that again. Like I just like don't want it so I would have to remember to toggle it on and off, which is annoying. Do you think it's more valuable to spend time in college learning core topics like data structures or more random electives that are more niche but you want to explore? So during my bachelor's you're supposed to pick a major. At least in Australia you were supposed to pick a major and I just didn't. So I have a double major in general computer science because I took a lot of different classes and none of them gave me a major when combined just because I took the things that I was interested in.
02:03:43.137 - 02:04:47.345, Speaker A: And like I think that's a good approach. It also it doesn't. Data structures you can sort of learn on your own, but they are like I at least think they're really interesting and worth learning and maybe even through a class it can be really valuable to sort of have someone walk you through them. But like take classes on the things you think are interesting. Do you have any recommendation on breaking into a Rust job from another development background? I think Rust is pretty forgiving there. I think there's still enough like thirst for Rust developers that even if you're coming from a different background and you're relatively less experienced, you might actually find that it that getting a job might be easier than with some other languages where there's a bigger pool of candidates. If you could magically add or change one thing in Rust right now, what would it be? Oh, that's tough.
02:04:47.345 - 02:05:34.841, Speaker A: I actually can't immediately think of anything big I would want to change. Like, I've been pretty happy with how the languages turned out. I think if there was a magic way to fix Async Async drop that would be amazing. But I don't know of a way to change it to make it better. Any assembly experience? I've written a little bit of assembly, but not enough to really give good resources for recommendation. How do you balance school and work? What do you prioritize and focus on to get more output per input ratio? I don't know what you mean by balancing school and work. Like I'm not.
02:05:34.841 - 02:06:07.087, Speaker A: My work is my university studies. So I don't know what you mean there. What got you interested in Rust? I got interested in Rust because it seemed like a language that first of all, I just think languages are interesting. I like learning languages and seeing what they have to offer. But also the things that Rust had to offer, at least sort of on the COVID were things that just appealed a lot to me. And I like, because I do low level, high performance concurrency stuff, Rust was very much in that realm. Oh, lecture notes in latex.
02:06:07.087 - 02:06:45.481, Speaker A: No, please, no. What version of Linux do you like the most and what advantages does it have over alternatives? Arch Linux, because it's really easy to write. Your own crates, your own libraries, packages and everything is very up to date and that has not been a problem for me up through the years. Which industries do you think will benefit most from using Rust? I think many of them. I think one of the places we're seeing a lot of adoption in Rust is in low levels of OS programming. This is stuff like Amazon's Firecracker, like the virtualization stuff. I think another is webassembly and the interaction with the web.
02:06:45.481 - 02:07:22.645, Speaker A: And I think a third is in the space of high frequency trading and finance. That seems to be a place that has been sticking pretty hard to very old software. And Rust seems like a candidate that might they might actually be willing to rewrite things in. I haven't tried Typescript, but I've heard good things about it. Shouldn't intro to programming be done in a functional language? I don't know why people keep claiming that you should do introductory programming in a functional language. I'm like, I don't. Why I don't think you should.
02:07:22.645 - 02:08:03.205, Speaker A: You helped me start contributing to open source. Nice. Do you feel that by using DuckDuckGo it takes a little longer to you to find what you're looking for than if you were using Google? Not really. That's only for relatively niche searches. Like there's some searches where it very quickly becomes apparent that DuckDuckGo doesn't give me good results. But usually like I find what I need are Python or gnuplot. For plots I use all three.
02:08:03.205 - 02:08:45.113, Speaker A: Not for any good reason. I use new plot when I just have a data set and I just want to see what the line is because you can pretty easily just like write out a command line. The plots I use matplotlib for when I'm producing papers because it's usually easier to build into a pipeline. People know Python better so it's easier to maintain longer term. And when you really want to customize your plots, matplotlib is great for that and for producing like PDF output and stuff. And I use R for when I'm doing more exploratory plotting. Like if I have some data set and I just want to plot it all sorts of different ways and use different plotting strategies and like I want to do like facet wraps and facet grids.
02:08:45.113 - 02:09:22.043, Speaker A: R is great for that, for just like data exploration. So all three crates has replaced the word libraries for you. Yeah, it's true. Favorite dessert? Oh, I forget what these are called in English. There's like a. It's a lava cake I think it's called. It's like a chocolate brownie, but that has like chocolate has like, like runny chocolate dough in the middle.
02:09:22.043 - 02:09:57.995, Speaker A: It's great with a bit of ice cream. M what nightly features of Rust are you most excited coming to Stable? That's a good question. I mean we can, we can take a look at what, what Noria is using at the moment. Nori oh, type L is impiltrate. Like existential. Existential types. Great feature, very required.
02:09:57.995 - 02:10:32.929, Speaker A: Apart from that I don't know what other features I'm really using a bunch of the con stuff. I'm using a little bit specialization I'm really excited for. Yeah, specialization is going to be great. Apart from that, I'm not really using that many interestingly enough. Yeah, type alias, infiltrate. It's gonna be fantastic. What's your programming beverage minus tea.
02:10:32.929 - 02:10:50.575, Speaker A: I don't drink coffee. I never liked the taste. But tea, like a Twinnings Earl Grey. It's my go to always. And I drink a lot of tea. Like I drink tea. I drink probably four or five cups of tea a day.
02:10:50.575 - 02:11:06.495, Speaker A: I really like. Speaking of, I have tea right here, actually, that I haven't drinking. I made it. I'm at the end. It's true. I got to the bottom of the questions. Nice.
02:11:06.495 - 02:11:29.075, Speaker A: Oh, all right. I think that's about right. So that's like two hours of questions. It's funny because I was not expecting this to be this long. I sort of figured I'd just like spin it up, answer some questions that I'd be done. But clearly there were a lot of questions, which is fun. It seems like maybe this was useful as well.
02:11:29.075 - 02:11:48.401, Speaker A: If people find this useful, then let me know. Tweet at me or something if you found the stream useful and I might do some more in the future. In Nice. Thanks for showing up. Thanks for asking questions. This obviously would not work without all of you and hopefully we'll do it some other time. Bye everyone.
02:11:48.401 - 02:11:50.105, Speaker A: Have a great rest of your weekend.
